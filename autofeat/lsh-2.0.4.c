/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 108 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow.h"
struct yarrow_key_event_ctx {
   unsigned int index ;
   unsigned int chars[16] ;
   unsigned int previous ;
};
#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes.h"
struct aes_ctx {
   uint32_t keys[60] ;
   unsigned int nrounds ;
};
#line 81 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha.h"
struct sha256_ctx {
   uint32_t state[8] ;
   uint32_t count_low ;
   uint32_t count_high ;
   uint8_t block[64] ;
   unsigned int index ;
};
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow.h"
enum yarrow_pool_id {
    YARROW_FAST = 0,
    YARROW_SLOW = 1
} ;
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow.h"
struct yarrow_source {
   uint32_t estimate[2] ;
   enum yarrow_pool_id next ;
};
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow.h"
struct yarrow256_ctx {
   struct sha256_ctx pools[2] ;
   uint8_t seed_file[32] ;
   int seeded ;
   struct aes_ctx key ;
   uint8_t counter[16] ;
   unsigned int nsources ;
   struct yarrow_source *sources ;
};
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.h"
struct twofish_ctx {
   uint32_t keys[40] ;
   uint32_t s_box[4][256] ;
};
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_cipher {
   char const   *name ;
   unsigned int context_size ;
   unsigned int block_size ;
   unsigned int key_size ;
   void (*set_encrypt_key)(void *ctx , unsigned int length , uint8_t const   *key ) ;
   void (*set_decrypt_key)(void *ctx , unsigned int length , uint8_t const   *key ) ;
   void (*encrypt)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ) ;
   void (*decrypt)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ) ;
};
#line 126 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_hash {
   char const   *name ;
   unsigned int context_size ;
   unsigned int digest_size ;
   unsigned int block_size ;
   void (*init)(void *ctx ) ;
   void (*update)(void *ctx , unsigned int length , uint8_t const   *src ) ;
   void (*digest)(void *ctx , unsigned int length , uint8_t *dst ) ;
};
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha.h"
struct sha1_ctx {
   uint32_t digest[5] ;
   uint32_t count_low ;
   uint32_t count_high ;
   uint8_t block[64] ;
   unsigned int index ;
};
#line 194 "/usr/include/gmp-i386.h"
typedef unsigned long mp_limb_t;
#line 202 "/usr/include/gmp-i386.h"
struct __anonstruct___mpz_struct_1 {
   int _mp_alloc ;
   int _mp_size ;
   mp_limb_t *_mp_d ;
};
#line 202 "/usr/include/gmp-i386.h"
typedef struct __anonstruct___mpz_struct_1 __mpz_struct;
#line 216 "/usr/include/gmp-i386.h"
typedef __mpz_struct mpz_t[1];
#line 218 "/usr/include/gmp-i386.h"
typedef mp_limb_t *mp_ptr;
#line 219 "/usr/include/gmp-i386.h"
typedef mp_limb_t const   *mp_srcptr;
#line 227 "/usr/include/gmp-i386.h"
typedef long mp_size_t;
#line 231 "/usr/include/gmp-i386.h"
struct __anonstruct___mpq_struct_2 {
   __mpz_struct _mp_num ;
   __mpz_struct _mp_den ;
};
#line 231 "/usr/include/gmp-i386.h"
typedef struct __anonstruct___mpq_struct_2 __mpq_struct;
#line 276 "/usr/include/gmp-i386.h"
typedef __mpz_struct const   *mpz_srcptr;
#line 277 "/usr/include/gmp-i386.h"
typedef __mpz_struct *mpz_ptr;
#line 280 "/usr/include/gmp-i386.h"
typedef __mpq_struct const   *mpq_srcptr;
#line 281 "/usr/include/gmp-i386.h"
typedef __mpq_struct *mpq_ptr;
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
struct rsa_public_key {
   unsigned int size ;
   mpz_t n ;
   mpz_t e ;
};
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
struct rsa_private_key {
   unsigned int size ;
   mpz_t d ;
   mpz_t p ;
   mpz_t q ;
   mpz_t a ;
   mpz_t b ;
   mpz_t c ;
};
#line 270
struct sexp_iterator;
#line 270
struct sexp_iterator;
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.h"
enum sexp_type {
    SEXP_ATOM = 0,
    SEXP_LIST = 1,
    SEXP_END = 2
} ;
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.h"
struct sexp_iterator {
   unsigned int length ;
   uint8_t const   *buffer ;
   unsigned int start ;
   unsigned int pos ;
   unsigned int level ;
   enum sexp_type type ;
   unsigned int display_length ;
   uint8_t const   *display ;
   unsigned int atom_length ;
   uint8_t const   *atom ;
};
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.h"
struct dsa_public_key {
   mpz_t p ;
   mpz_t q ;
   mpz_t g ;
   mpz_t y ;
};
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.h"
struct dsa_private_key {
   mpz_t x ;
};
#line 80 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.h"
struct dsa_signature {
   mpz_t r ;
   mpz_t s ;
};
#line 107 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64.h"
struct base64_decode_ctx {
   unsigned int word ;
   unsigned int bits ;
   unsigned int padding ;
};
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 149 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.h"
struct nettle_buffer;
#line 149
struct nettle_buffer;
#line 30 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/realloc.h"
typedef void *nettle_realloc_func(void *ctx , void *p , unsigned int length );
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.h"
struct nettle_buffer {
   uint8_t *contents ;
   unsigned int alloc ;
   void *realloc_ctx ;
   nettle_realloc_func *realloc ;
   unsigned int size ;
};
#line 215 "/usr/include/gmp-i386.h"
typedef __mpz_struct MP_INT;
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent.h"
struct serpent_ctx {
   uint32_t keys[33][4] ;
};
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5.h"
struct md5_ctx {
   uint32_t digest[4] ;
   uint32_t count_l ;
   uint32_t count_h ;
   uint8_t block[64] ;
   unsigned int index ;
};
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-compat.h"
struct __anonstruct_R_RSA_PUBLIC_KEY_8 {
   unsigned int bits ;
   uint8_t modulus[256] ;
   uint8_t exponent[256] ;
};
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-compat.h"
typedef struct __anonstruct_R_RSA_PUBLIC_KEY_8 R_RSA_PUBLIC_KEY;
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-compat.h"
struct __anonstruct_R_RSA_PRIVATE_KEY_9 {
   unsigned int bits ;
   uint8_t modulus[256] ;
   uint8_t publicExponent[256] ;
   uint8_t exponent[256] ;
   uint8_t prime[2][256] ;
   uint8_t primeExponent[2][256] ;
   uint8_t coefficient[256] ;
};
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-compat.h"
typedef struct __anonstruct_R_RSA_PRIVATE_KEY_9 R_RSA_PRIVATE_KEY;
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-compat.h"
struct __anonstruct_R_SIGNATURE_CTX_10 {
   struct md5_ctx hash ;
};
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-compat.h"
typedef struct __anonstruct_R_SIGNATURE_CTX_10 R_SIGNATURE_CTX;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 45
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64.h"
struct base64_encode_ctx {
   unsigned int word ;
   unsigned int bits ;
};
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.h"
enum des_error {
    DES_OK = 0,
    DES_BAD_PARITY = 1,
    DES_WEAK_KEY = 2
} ;
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.h"
struct des_ctx {
   uint32_t key[32] ;
   enum des_error status ;
};
#line 84 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.h"
struct des3_ctx {
   struct des_ctx des[3] ;
   enum des_error status ;
};
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/blowfish.h"
enum blowfish_error {
    BLOWFISH_OK = 0,
    BLOWFISH_WEAK_KEY = 1
} ;
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/blowfish.h"
struct blowfish_ctx {
   uint32_t s[4][256] ;
   uint32_t p[18] ;
   enum blowfish_error status ;
};
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5-compat.h"
typedef struct md5_ctx MD5_CTX;
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md4.h"
struct md4_ctx {
   uint32_t digest[4] ;
   uint32_t count_l ;
   uint32_t count_h ;
   uint8_t block[64] ;
   unsigned int index ;
};
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md2.h"
struct md2_ctx {
   uint8_t C[16] ;
   uint8_t X[48] ;
   uint8_t block[16] ;
   unsigned int index ;
};
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/knuth-lfib.h"
struct knuth_lfib_ctx {
   uint32_t x[100] ;
   unsigned int index ;
};
#line 111 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac.h"
struct hmac_sha256_ctx {
   struct sha256_ctx outer ;
   struct sha256_ctx inner ;
   struct sha256_ctx state ;
};
#line 96 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac.h"
struct hmac_sha1_ctx {
   struct sha1_ctx outer ;
   struct sha1_ctx inner ;
   struct sha1_ctx state ;
};
#line 80 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac.h"
struct hmac_md5_ctx {
   struct md5_ctx outer ;
   struct md5_ctx inner ;
   struct md5_ctx state ;
};
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.h"
typedef uint8_t des_cblock[8];
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.c"
struct des_compat_des3 {
   struct des_ctx  const  *keys[3] ;
};
#line 290 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
struct asn1_der_iterator;
#line 290
struct asn1_der_iterator;
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/asn1.h"
enum asn1_type {
    ASN1_BOOLEAN = 1,
    ASN1_INTEGER = 2,
    ASN1_BITSTRING = 3,
    ASN1_OCTETSTRING = 4,
    ASN1_NULL = 5,
    ASN1_IDENTIFIER = 6,
    ASN1_REAL = 9,
    ASN1_ENUMERATED = 10,
    ASN1_UTF8STRING = 12,
    ASN1_SEQUENCE = 4112,
    ASN1_SET = 4113,
    ASN1_PRINTABLESTRING = 19,
    ASN1_TELETEXSTRING = 20,
    ASN1_IA5STRING = 22,
    ASN1_UTC = 23,
    ASN1_UNIVERSALSTRING = 28,
    ASN1_BMPSTRING = 30
} ;
#line 81
enum asn1_iterator_result {
    ASN1_ITERATOR_ERROR = 0,
    ASN1_ITERATOR_PRIMITIVE = 1,
    ASN1_ITERATOR_CONSTRUCTED = 2,
    ASN1_ITERATOR_END = 3
} ;
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/asn1.h"
struct asn1_der_iterator {
   unsigned int buffer_length ;
   uint8_t const   *buffer ;
   unsigned int pos ;
   enum asn1_type type ;
   unsigned int length ;
   uint8_t const   *data ;
};
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128.h"
struct cast128_ctx {
   uint32_t keys[32] ;
   unsigned int rounds ;
};
#line 181 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_armor {
   char const   *name ;
   unsigned int encode_context_size ;
   unsigned int decode_context_size ;
   unsigned int encode_final_length ;
   void (*encode_init)(void *ctx ) ;
   unsigned int (*encode_length)(unsigned int length ) ;
   unsigned int (*encode_update)(void *ctx , uint8_t *dst , unsigned int src_length ,
                                 uint8_t const   *src ) ;
   unsigned int (*encode_final)(void *ctx , uint8_t *dst ) ;
   void (*decode_init)(void *ctx ) ;
   unsigned int (*decode_length)(unsigned int length ) ;
   int (*decode_update)(void *ctx , unsigned int *dst_length , uint8_t *dst , unsigned int src_length ,
                        uint8_t const   *src ) ;
   int (*decode_final)(void *ctx ) ;
};
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16.h"
struct base16_decode_ctx {
   unsigned int word ;
   unsigned int bits ;
};
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.h"
struct arctwo_ctx {
   uint16_t S[64] ;
};
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arcfour.h"
struct arcfour_ctx {
   uint8_t S[256] ;
   uint8_t i ;
   uint8_t j ;
};
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-internal.h"
struct aes_table {
   uint8_t sbox[256] ;
   uint32_t table[4][256] ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/spki-types.h"
enum spki_type {
    SPKI_TYPE_SYNTAX_ERROR = 0,
    SPKI_TYPE_ACL = 1,
    SPKI_TYPE_CERT = 2,
    SPKI_TYPE_COMMENT = 3,
    SPKI_TYPE_DISPLAY = 4,
    SPKI_TYPE_DO = 5,
    SPKI_TYPE_DSA_SHA1 = 6,
    SPKI_TYPE_ENTRY = 7,
    SPKI_TYPE_HASH = 8,
    SPKI_TYPE_ISSUER = 9,
    SPKI_TYPE_ISSUER_INFO = 10,
    SPKI_TYPE_MD5 = 11,
    SPKI_TYPE_NAME = 12,
    SPKI_TYPE_NOT_AFTER = 13,
    SPKI_TYPE_NOT_BEFORE = 14,
    SPKI_TYPE_PROPAGATE = 15,
    SPKI_TYPE_PRIVATE_KEY = 16,
    SPKI_TYPE_PUBLIC_KEY = 17,
    SPKI_TYPE_RSA_PKCS1_MD5 = 18,
    SPKI_TYPE_RSA_PKCS1_SHA1 = 19,
    SPKI_TYPE_SEQUENCE = 20,
    SPKI_TYPE_SHA1 = 21,
    SPKI_TYPE_SIGNATURE = 22,
    SPKI_TYPE_SUBJECT = 23,
    SPKI_TYPE_SUBJECT_INFO = 24,
    SPKI_TYPE_TAG = 25,
    SPKI_TYPE_VALID = 26,
    SPKI_TYPE_VERSION = 27,
    SPKI_TYPE_END_OF_EXPR = 28
} ;
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
struct spki_iterator;
#line 50
struct spki_iterator;
#line 51
struct spki_hash_value;
#line 51
struct spki_hash_value;
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
struct spki_hashes {
   uint8_t md5[16] ;
   uint8_t sha1[20] ;
};
#line 66
enum spki_principal_flags {
    SPKI_PRINCIPAL_MD5 = 1,
    SPKI_PRINCIPAL_SHA1 = 2
} ;
#line 72 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
struct spki_principal {
   struct spki_principal *next ;
   unsigned int key_length ;
   uint8_t *key ;
   enum spki_principal_flags flags ;
   struct spki_hashes hashes ;
   struct spki_principal *alias ;
   void *verifier ;
};
#line 30 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.h"
struct spki_iterator {
   struct sexp_iterator sexp ;
   enum spki_type type ;
   unsigned int start ;
};
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.h"
struct spki_hash_value {
   enum spki_type type ;
   unsigned int length ;
   uint8_t const   *digest ;
};
#line 33 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.h"
struct spki_tag;
#line 33
struct spki_tag;
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
struct spki_string {
   unsigned int refs ;
   unsigned int length ;
   uint8_t const   *data ;
};
#line 132 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
struct spki_cons {
   struct spki_tag *car ;
   struct spki_cons *cdr ;
};
#line 192
enum spki_tag_type {
    SPKI_TAG_ERROR = 0,
    SPKI_TAG_ANY = 1,
    SPKI_TAG_SET = 2,
    SPKI_TAG_LIST = 3,
    SPKI_TAG_PREFIX = 4,
    SPKI_TAG_RANGE = 5,
    SPKI_TAG_ATOM = 6
} ;
#line 205 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
struct spki_tag {
   enum spki_tag_type type ;
   unsigned int refs ;
};
#line 215 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
struct spki_tag_list {
   struct spki_tag super ;
   struct spki_cons *children ;
};
#line 231 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
struct spki_tag_atom {
   struct spki_tag super ;
   struct spki_string *display ;
   struct spki_string *atom ;
};
#line 247
enum spki_range_type {
    SPKI_RANGE_TYPE_ALPHA = 0,
    SPKI_RANGE_TYPE_NUMERIC = 1,
    SPKI_RANGE_TYPE_TIME = 2,
    SPKI_RANGE_TYPE_BINARY = 3,
    SPKI_RANGE_TYPE_DATE = 4,
    SPKI_RANGE_GTE = 16,
    SPKI_RANGE_LTE = 32
} ;
#line 260 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
struct spki_tag_range {
   struct spki_tag super ;
   enum spki_range_type flags ;
   struct spki_string *display ;
   struct spki_string *lower ;
   struct spki_string *upper ;
};
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
struct spki_acl_db;
#line 57
struct spki_acl_db;
#line 99
enum spki_5_tuple_flags {
    SPKI_PROPAGATE = 1,
    SPKI_NOT_BEFORE = 2,
    SPKI_NOT_AFTER = 4
} ;
#line 113 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
struct spki_date {
   uint8_t date[19] ;
};
#line 131 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
struct spki_5_tuple {
   unsigned int refs ;
   struct spki_principal *issuer ;
   struct spki_principal *subject ;
   enum spki_5_tuple_flags flags ;
   struct spki_date not_before ;
   struct spki_date not_after ;
   struct spki_tag *tag ;
};
#line 157 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
struct spki_5_tuple_list {
   struct spki_5_tuple *car ;
   struct spki_5_tuple_list *cdr ;
};
#line 179 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
typedef int spki_5_tuple_filter_func(struct spki_acl_db *db , void *ctx , struct spki_5_tuple *tuple );
#line 198 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
struct spki_acl_db {
   void *realloc_ctx ;
   nettle_realloc_func *realloc ;
   struct spki_principal *first_principal ;
   struct spki_5_tuple_list *acls ;
};
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
struct spki_assoc;
#line 39
struct spki_assoc;
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/spki-gperf.h"
struct spki_assoc {
   char const   *name ;
   enum spki_type id ;
};
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
struct spki_type_name {
   unsigned int length ;
   uint8_t const   *name ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 273 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
typedef int spki_verify_func(void *ctx , struct spki_hash_value  const  *hash , struct spki_principal *principal ,
                             struct spki_iterator *signature );
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.h"
struct lsh_class;
#line 48
struct lsh_class;
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.h"
struct lsh_object {
   struct lsh_object *next ;
   struct lsh_class *isa ;
   char alloc_method ;
   char marked ;
   char dead ;
};
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.h"
struct lsh_class {
   struct lsh_object super ;
   struct lsh_class *super_class ;
   char *name ;
   size_t size ;
   void (*mark_instance)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ) ;
   void (*free_instance)(struct lsh_object *instance ) ;
};
#line 90
struct lsh_string;
#line 90
struct lsh_string;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/compress.h.x"
struct compress_instance {
   struct lsh_object super ;
   struct lsh_string *(*codec)(struct compress_instance *self , struct lsh_string *data ,
                               int free ) ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/compress.h.x"
struct compress_algorithm {
   struct lsh_object super ;
   struct compress_instance *(*make_compress)(struct compress_algorithm *self , int mode ) ;
};
#line 328 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 330 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 331 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 337 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 346 "/usr/include/zconf.h"
typedef void *voidpf;
#line 83 "/usr/include/zlib.h"
struct internal_state;
#line 83
struct internal_state;
#line 85 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 85 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 106 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1395 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/string_buffer.h"
struct string_node;
#line 35
struct string_node;
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/string_buffer.h"
struct string_buffer {
   struct lsh_string *partial ;
   uint32_t left ;
   uint32_t pos ;
   struct string_node *tail ;
   uint32_t total ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c.x"
struct zlib_instance {
   struct compress_instance super ;
   uint32_t max ;
   uint32_t rate ;
   int (*f)(z_stream * , int  ) ;
   z_stream z ;
};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c.x"
struct zlib_algorithm {
   struct compress_algorithm super ;
   int level ;
};
#line 72 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
struct zlib_type {
   int (*free_func)(z_stream *z ) ;
   char const   *operation ;
};
#line 34 "/usr/include/X11/Xauth.h"
struct xauth {
   unsigned short family ;
   unsigned short address_length ;
   char *address ;
   unsigned short number_length ;
   char *number ;
   unsigned short name_length ;
   char *name ;
   unsigned short data_length ;
   char *data ;
};
#line 34 "/usr/include/X11/Xauth.h"
typedef struct xauth Xauth;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 174 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 92 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 92
struct sockaddr_in;
#line 92
struct sockaddr_in6;
#line 92
struct sockaddr_in6;
#line 97 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 141 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 142 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 198 "/usr/include/netinet/in.h"
union __anonunion___in6_u_31 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 198 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_31 __in6_u ;
};
#line 225 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 239 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 98 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.h"
struct abstract_write;
#line 98
struct abstract_write;
#line 104
struct command_continuation;
#line 104
struct command_continuation;
#line 112
struct ssh_connection;
#line 112
struct ssh_connection;
#line 118
struct address_info;
#line 118
struct address_info;
#line 120
struct lsh_fd;
#line 120
struct lsh_fd;
#line 127
struct randomness;
#line 127
struct randomness;
#line 134
struct resource;
#line 134
struct resource;
#line 137
struct lsh_user;
#line 137
struct lsh_user;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h.x"
struct exception {
   struct lsh_object super ;
   uint32_t type ;
   char const   *msg ;
};
#line 30 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h.x"
struct exception_handler {
   struct lsh_object super ;
   void (*raise)(struct exception_handler *self , struct exception  const  * ) ;
   struct exception_handler *parent ;
   char const   *context ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_io.h.x"
struct abstract_write {
   struct lsh_object super ;
   void (*write)(struct abstract_write *self , struct lsh_string *packet ) ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_io.h.x"
struct abstract_write_pipe {
   struct abstract_write super ;
   struct abstract_write *next ;
};
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h"
struct lsh_queue_node {
   struct lsh_queue_node *np_links[2] ;
};
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h"
struct lsh_queue {
   struct lsh_queue_node *ht_links[3] ;
   unsigned int length ;
};
#line 27 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h.x"
struct string_queue {
   struct lsh_queue q ;
};
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.h"
struct resource_node;
#line 34
struct resource_node;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.h.x"
struct resource {
   struct lsh_object super ;
   int alive ;
   void (*kill)(struct resource *self ) ;
};
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.h.x"
struct resource_list {
   struct resource super ;
   struct resource_node *q ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct crypto_instance {
   struct lsh_object super ;
   uint32_t block_size ;
   void (*crypt)(struct crypto_instance *self , uint32_t length , struct lsh_string *dst ,
                 uint32_t di , struct lsh_string  const  *src , uint32_t si ) ;
};
#line 106 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct mac_instance {
   struct lsh_object super ;
   uint32_t mac_size ;
   void (*update)(struct mac_instance *self , uint32_t length , uint8_t const   *data ) ;
   struct lsh_string *(*digest)(struct mac_instance *self , struct lsh_string *res ,
                                uint32_t pos ) ;
};
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/randomness.h"
enum random_source_type {
    RANDOM_SOURCE_TRIVIA = 0,
    RANDOM_SOURCE_REMOTE = 1,
    RANDOM_SOURCE_DEVICE = 2,
    RANDOM_SOURCE_SECRET = 3,
    RANDOM_SOURCE_NEW_SEED = 4,
    RANDOM_NSOURCES = 5
} ;
#line 49
enum randomness_quality {
    RANDOM_GOOD = 0,
    RANDOM_PAD_ONLY = 1
} ;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/randomness.h.x"
struct randomness {
   struct lsh_object super ;
   enum randomness_quality quality ;
   void (*random)(struct randomness *self , uint32_t length , uint8_t *dst ) ;
   void (*add)(struct randomness *self , enum random_source_type  , uint32_t length ,
               uint8_t const   *data ) ;
};
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h"
enum connection_flag {
    CONNECTION_MODE = 1,
    CONNECTION_CLIENT = 0,
    CONNECTION_SERVER = 1,
    CONNECTION_SRP = 2
} ;
#line 53
enum peer_flag {
    PEER_NONE = 0
} ;
#line 59
enum kex_state {
    KEX_STATE_INIT = 0,
    KEX_STATE_IGNORE = 1,
    KEX_STATE_IN_PROGRESS = 2,
    KEX_STATE_NEWKEYS = 3
} ;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h.x"
struct packet_handler {
   struct lsh_object super ;
   void (*handler)(struct packet_handler *self , struct ssh_connection *connection ,
                   struct lsh_string *packet ) ;
};
#line 29
struct make_kexinit;
#line 29
struct make_kexinit;
#line 29
struct kexinit;
#line 29
struct kexinit;
#line 29
struct channel_table;
#line 29
struct channel_table;
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h.x"
struct ssh_connection {
   struct abstract_write super ;
   struct exception_handler *e ;
   enum connection_flag flags ;
   struct lsh_string *versions[2] ;
   struct lsh_string *session_id ;
   char const   *debug_comment ;
   enum peer_flag peer_flags ;
   struct resource *timer ;
   struct lsh_user *user ;
   struct ssh_connection *chain ;
   struct resource_list *resources ;
   struct address_info *peer ;
   struct address_info *local ;
   struct make_kexinit *kexinit ;
   uint32_t rec_max_packet ;
   struct mac_instance *rec_mac ;
   struct crypto_instance *rec_crypto ;
   struct compress_instance *rec_compress ;
   struct lsh_fd *socket ;
   uint32_t soft_limit ;
   uint32_t hard_limit ;
   struct abstract_write *write_packet ;
   struct mac_instance *send_mac ;
   struct crypto_instance *send_crypto ;
   struct compress_instance *send_compress ;
   int paused ;
   struct string_queue pending ;
   enum kex_state read_kex_state ;
   int send_kex_only ;
   struct string_queue send_queue ;
   struct resource *key_expire ;
   uint32_t sent_data ;
   struct command_continuation *keyexchange_done ;
   struct command_continuation *wakeup ;
   struct kexinit *kexinits[2] ;
   struct lsh_string *literal_kexinits[2] ;
   struct packet_handler *dispatch[256] ;
   struct channel_table *table ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_packet.c.x"
struct write_packet {
   struct abstract_write_pipe super ;
   struct ssh_connection *connection ;
   struct randomness *random ;
   uint32_t sequence_number ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.h.x"
struct flow_controlled {
   struct lsh_object super ;
   void (*report)(struct flow_controlled *self , uint32_t  ) ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.h.x"
struct write_buffer {
   struct abstract_write super ;
   struct lsh_fd *fd ;
   uint32_t block_size ;
   struct lsh_string *buffer ;
   int empty ;
   uint32_t length ;
   struct flow_controlled *report ;
   int closed ;
   struct string_queue q ;
   uint32_t pos ;
   struct lsh_string *partial ;
   uint32_t start ;
   uint32_t end ;
};
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
enum io_type {
    IO_NORMAL = 0,
    IO_PTY = 1,
    IO_STDIO = 2,
    IO_STDERR = 3
} ;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_callback {
   struct lsh_object super ;
   void (*f)(struct lsh_callback *self ) ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct io_callback {
   struct lsh_object super ;
   void (*f)(struct io_callback *self , struct lsh_fd *fd ) ;
};
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_fd {
   struct resource super ;
   int fd ;
   enum io_type type ;
   char const   *label ;
   struct exception_handler *e ;
   struct lsh_callback *close_callback ;
   int want_read ;
   struct io_callback *read ;
   int want_write ;
   struct io_callback *write ;
   struct write_buffer *write_buffer ;
};
#line 69 "/usr/include/errno.h"
typedef int error_t;
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/argp/argp.h"
struct argp_option {
   char const   *name ;
   int key ;
   char const   *arg ;
   int flags ;
   char const   *doc ;
   int group ;
};
#line 138
struct argp;
#line 138
struct argp;
#line 139
struct argp_state;
#line 139
struct argp_state;
#line 140
struct argp_child;
#line 140
struct argp_child;
#line 212 "/home/ysko/Works/test-src/lsh-2.0.4/src/argp/argp.h"
struct argp {
   struct argp_option  const  *options ;
   error_t (*parser)(int key , char *arg , struct argp_state *state ) ;
   char const   *args_doc ;
   char const   *doc ;
   struct argp_child  const  *children ;
   char *(*help_filter)(int __key , char const   *__text , void *__input ) ;
   char const   *argp_domain ;
};
#line 278 "/home/ysko/Works/test-src/lsh-2.0.4/src/argp/argp.h"
struct argp_child {
   struct argp  const  *argp ;
   int flags ;
   char const   *header ;
   int group ;
};
#line 303 "/home/ysko/Works/test-src/lsh-2.0.4/src/argp/argp.h"
struct argp_state {
   struct argp  const  *root_argp ;
   int argc ;
   char **argv ;
   int next ;
   unsigned int flags ;
   unsigned int arg_num ;
   int quoted ;
   void *input ;
   void **child_inputs ;
   void *hook ;
   char *name ;
   FILE *err_stream ;
   FILE *out_stream ;
   void *pstate ;
};
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.h"
enum utf8_flag {
    utf8_replace = 1,
    utf8_paranoid = 2,
    utf8_tolerant = 4
} ;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 238 "/usr/include/unistd.h"
typedef __uid_t uid_t;
#line 130 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.h"
struct exit_callback;
#line 130
struct exit_callback;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h"
struct env_value;
#line 34
struct env_value;
#line 35
struct spawn_info;
#line 35
struct spawn_info;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h.x"
struct userauth_special_exception {
   struct exception super ;
   struct lsh_string *reply ;
};
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h.x"
struct lsh_process {
   struct resource super ;
   int (*signal)(struct lsh_process *self , int  ) ;
};
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h.x"
struct lsh_user {
   struct lsh_object super ;
   struct lsh_string *name ;
   uid_t uid ;
   void (*verify_password)(struct lsh_user *self , struct lsh_string *pw , struct command_continuation *c ,
                           struct exception_handler *e ) ;
   int (*file_exists)(struct lsh_user *self , struct lsh_string *name , int free ) ;
   struct exception  const  *(*read_file)(struct lsh_user *self , char const   *name ,
                                          int secret , uint32_t limit , struct abstract_write *c ) ;
   struct lsh_process *(*spawn)(struct lsh_user *self , struct spawn_info *info ,
                                struct exit_callback *c ) ;
};
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h"
struct env_value {
   char const   *name ;
   struct lsh_string *value ;
};
#line 70
struct pty_info;
#line 70
struct pty_info;
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h"
struct spawn_info {
   struct address_info *peer ;
   struct pty_info *pty ;
   int login ;
   int in[2] ;
   int out[2] ;
   int err[2] ;
   unsigned int argc ;
   char const   **argv ;
   unsigned int env_length ;
   struct env_value  const  *env ;
};
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 174 "/usr/include/time.h"
typedef __pid_t pid_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 131 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.h"
struct reaper;
#line 131
struct reaper;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.h"
struct alist;
#line 34
struct alist;
#line 13 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.h.x"
struct alist {
   struct lsh_object super ;
   unsigned int size ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct command_continuation {
   struct lsh_object super ;
   void (*c)(struct command_continuation *self , struct lsh_object *result ) ;
};
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_io.h.x"
struct read_handler {
   struct lsh_object super ;
   uint32_t (*handler)(struct read_handler **self , uint32_t available , uint8_t const   *data ) ;
};
#line 161 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct address_info {
   struct lsh_object super ;
   struct lsh_string *ip ;
   uint32_t port ;
};
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.h"
struct simple_buffer {
   uint32_t capacity ;
   uint32_t pos ;
   uint8_t const   *data ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.h.x"
struct user_db {
   struct lsh_object super ;
   struct lsh_user *(*lookup)(struct user_db *self , struct lsh_string *name , int free ) ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.h.x"
struct userauth {
   struct lsh_object super ;
   void (*authenticate)(struct userauth *self , struct ssh_connection *connection ,
                        struct lsh_string *username , uint32_t service , struct simple_buffer *args ,
                        struct command_continuation *c , struct exception_handler *e ) ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.h.x"
struct exit_callback {
   struct lsh_object super ;
   void (*exit)(struct exit_callback *self , int signaled , int core , int value ) ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.h.x"
struct reaper {
   struct lsh_object super ;
   void (*reap)(struct reaper *self , pid_t pid , struct exit_callback *callback ) ;
   struct alist *children ;
};
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.h"
struct terminal_dimensions {
   uint32_t char_width ;
   uint32_t char_height ;
   uint32_t pixel_width ;
   uint32_t pixel_height ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_pty.h.x"
struct pty_info {
   struct resource super ;
   int master ;
   struct lsh_string *tty_name ;
   struct terminal_dimensions dims ;
   struct lsh_string *mode ;
};
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
struct unix_user_db;
#line 86
struct unix_user_db;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
struct unix_user {
   struct lsh_user super ;
   gid_t gid ;
   struct unix_user_db *ctx ;
   struct lsh_string *passwd ;
   struct lsh_string *home ;
   struct lsh_string *shell ;
};
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
struct pwhelper_callback {
   struct exit_callback super ;
   struct unix_user *user ;
   struct command_continuation *c ;
   struct exception_handler *e ;
};
#line 83 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
struct exc_read_user_file_handler {
   struct exception_handler super ;
   struct abstract_write *c ;
};
#line 114 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
struct unix_user_db {
   struct user_db super ;
   struct reaper *reaper ;
   char const   *pw_helper ;
   char const   *login_shell ;
   int allow_root ;
};
#line 148 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
struct unix_user_self {
   struct lsh_user super ;
   struct reaper *reaper ;
   char const   *shell ;
   char const   *home ;
};
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 154 "/usr/include/bits/resource.h"
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1,
    RUSAGE_THREAD = 1
} ;
#line 178 "/usr/include/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
#line 40 "/usr/include/sys/resource.h"
typedef enum __rusage_who __rusage_who_t;
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.h"
struct lsh_file_lock_info;
#line 29
struct lsh_file_lock_info;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.h.x"
struct lsh_file_lock_info {
   struct lsh_object super ;
   struct lsh_string *lockname ;
   struct resource *(*lock)(struct lsh_file_lock_info *self , unsigned int retries ) ;
   int (*lock_p)(struct lsh_file_lock_info *self ) ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c.x"
struct unix_random {
   struct randomness super ;
   int seed_file_fd ;
   struct lsh_file_lock_info *lock ;
   struct yarrow256_ctx yarrow ;
   struct yarrow_source sources[5] ;
   long previous_time ;
   unsigned int time_count ;
   int device_fd ;
   time_t device_last_read ;
};
#line 203 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c"
struct __anonstruct_event_68 {
   struct timeval now ;
   struct rusage rusage ;
   unsigned int count ;
   pid_t pid ;
};
#line 41 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 43 "/usr/include/bits/utmpx.h"
struct __exit_status {
   short e_termination ;
   short e_exit ;
};
#line 56 "/usr/include/bits/utmpx.h"
struct utmpx {
   short ut_type ;
   __pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct __exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   __int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c.x"
struct unix_process {
   struct lsh_process super ;
   pid_t pid ;
   int signal ;
};
#line 30 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c.x"
struct logout_notice {
   struct exit_callback super ;
   struct resource *process ;
   struct exit_callback *c ;
};
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c.x"
struct utmp_cleanup {
   struct exit_callback super ;
   struct lsh_string *id ;
   struct lsh_string *line ;
   struct exit_callback *c ;
};
#line 115 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.h"
struct interact;
#line 115
struct interact;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.h.x"
struct terminal_attributes {
   struct lsh_object super ;
   struct terminal_attributes *(*make_raw)(struct terminal_attributes *self ) ;
   struct lsh_string *(*encode)(struct terminal_attributes *self ) ;
};
#line 30 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.h.x"
struct window_change_callback {
   struct lsh_object super ;
   void (*f)(struct window_change_callback *self , struct interact *i ) ;
};
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.h.x"
struct interact_dialog {
   struct lsh_object super ;
   struct lsh_string *instruction ;
   unsigned int nprompt ;
   struct lsh_string **prompt ;
   struct lsh_string **response ;
   int *echo ;
};
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.h.x"
struct interact {
   struct lsh_object super ;
   int (*is_tty)(struct interact *self ) ;
   struct lsh_string *(*read_password)(struct interact *self , uint32_t max_length ,
                                       struct lsh_string  const  *prompt ) ;
   void (*set_askpass)(struct interact *self , char const   *askpass ) ;
   int (*yes_or_no)(struct interact *self , struct lsh_string  const  *prompt , int def ,
                    int free ) ;
   int (*dialog)(struct interact *self , struct interact_dialog  const  *dialog ) ;
   struct terminal_attributes *(*get_attributes)(struct interact *self ) ;
   int (*set_attributes)(struct interact *self , struct terminal_attributes *attr ) ;
   int (*window_size)(struct interact *self , struct terminal_dimensions * ) ;
   struct resource *(*window_change_subscribe)(struct interact *self , struct window_change_callback *callback ) ;
};
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c.x"
struct unix_interact;
#line 5
struct unix_interact;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c.x"
struct window_subscriber {
   struct resource super ;
   struct unix_interact *interact ;
   struct window_subscriber *next ;
   struct window_change_callback *callback ;
};
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c.x"
struct unix_interact {
   struct interact super ;
   int tty_fd ;
   char const   *askpass ;
   struct resource *winch_handler ;
   unsigned int nsubscribers ;
   struct window_subscriber *subscribers ;
};
#line 76 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c.x"
struct unix_termios {
   struct terminal_attributes super ;
   struct termios ios ;
};
#line 100 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c.x"
struct winch_handler {
   struct lsh_callback super ;
   struct unix_interact *interact ;
};
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/translate_signal.c"
struct signal_assoc {
   int network ;
   int local ;
};
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.h"
struct client_x11_display;
#line 101
struct client_x11_display;
#line 105
struct command;
#line 105
struct command;
#line 106
struct command_2;
#line 106
struct command_2;
#line 107
struct command_3;
#line 107
struct command_3;
#line 108
struct command_4;
#line 108
struct command_4;
#line 109
struct catch_report_collect;
#line 109
struct catch_report_collect;
#line 119
struct listen_value;
#line 119
struct listen_value;
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h.x"
struct report_exception_info {
   struct lsh_object super ;
   uint32_t mask ;
   uint32_t value ;
   char const   *prefix ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct command {
   struct lsh_object super ;
   void (*call)(struct command *self , struct lsh_object *arg , struct command_continuation *c ,
                struct exception_handler *e ) ;
};
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct command_2 {
   struct command super ;
   void (*invoke)(struct command_2 *self , struct lsh_object *a1 , struct lsh_object *a2 ,
                  struct command_continuation *c , struct exception_handler *e ) ;
};
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct command_3 {
   struct command super ;
   void (*invoke)(struct lsh_object *a1 , struct lsh_object *a2 , struct lsh_object *a3 ,
                  struct command_continuation *c , struct exception_handler *e ) ;
};
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct command_4 {
   struct command super ;
   void (*invoke)(struct lsh_object *a1 , struct lsh_object *a2 , struct lsh_object *a3 ,
                  struct lsh_object *a4 , struct command_continuation *c , struct exception_handler *e ) ;
};
#line 125 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct command_frame {
   struct command_continuation super ;
   struct command_continuation *up ;
   struct exception_handler *e ;
};
#line 191 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct catch_report_collect {
   struct command super ;
   struct report_exception_info  const  *info ;
};
#line 2 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h.x"
struct object_queue {
   struct lsh_queue q ;
};
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h"
struct channel_open_info {
   uint32_t type_length ;
   uint8_t const   *type_data ;
   int type ;
   uint32_t remote_channel_number ;
   uint32_t send_window_size ;
   uint32_t send_max_packet ;
};
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h"
struct channel_request_info {
   uint32_t type_length ;
   uint8_t const   *type_data ;
   int type ;
   int want_reply ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct channel_request;
#line 5
struct channel_request;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct ssh_channel {
   struct flow_controlled super ;
   uint32_t channel_number ;
   struct exception_handler *e ;
   struct resource_list *resources ;
   uint32_t rec_window_size ;
   uint32_t rec_max_packet ;
   uint32_t send_window_size ;
   uint32_t send_max_packet ;
   struct ssh_connection *connection ;
   struct alist *request_types ;
   struct channel_request *request_fallback ;
   int flags ;
   int sources ;
   void (*receive)(struct ssh_channel *self , int type , struct lsh_string *data ) ;
   void (*send_adjust)(struct ssh_channel *self , uint32_t increment ) ;
   void (*close)(struct ssh_channel *self ) ;
   void (*eof)(struct ssh_channel *self ) ;
   struct command_continuation *open_continuation ;
   struct object_queue pending_requests ;
   struct object_queue active_requests ;
};
#line 70
struct channel_open;
#line 70
struct channel_open;
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct channel_table {
   struct lsh_object super ;
   struct ssh_channel **channels ;
   struct alist *global_requests ;
   struct alist *channel_types ;
   struct channel_open *open_fallback ;
   uint8_t *in_use ;
   uint32_t allocated_channels ;
   uint32_t used_channels ;
   uint32_t next_channel ;
   uint32_t channel_count ;
   uint32_t max_channels ;
   struct object_queue local_ports ;
   struct object_queue remote_ports ;
   struct client_x11_display *x11_display ;
   struct object_queue active_global_requests ;
   struct object_queue pending_global_requests ;
   int pending_close ;
};
#line 143 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct global_request {
   struct lsh_object super ;
   void (*handler)(struct global_request *self , struct ssh_connection *connection ,
                   uint32_t type , int want_reply , struct simple_buffer *args , struct command_continuation *c ,
                   struct exception_handler *e ) ;
};
#line 191 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct channel_open {
   struct lsh_object super ;
   void (*handler)(struct channel_open *self , struct ssh_connection *connection ,
                   struct channel_open_info *info , struct simple_buffer *data , struct command_continuation *c ,
                   struct exception_handler *e ) ;
};
#line 215 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct channel_request {
   struct lsh_object super ;
   void (*handler)(struct channel_request *self , struct ssh_channel *channel , struct channel_request_info *info ,
                   struct simple_buffer *args , struct command_continuation *c , struct exception_handler *e ) ;
};
#line 224 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct listen_value {
   struct lsh_object super ;
   struct lsh_fd *fd ;
   struct address_info *peer ;
   struct address_info *local ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.h.x"
struct forwarded_port {
   struct lsh_object super ;
   struct address_info *listen ;
};
#line 67 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.h.x"
struct remote_port {
   struct forwarded_port super ;
   struct command *callback ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h.x"
struct channel_open_command {
   struct command super ;
   struct ssh_channel *(*new_channel)(struct channel_open_command *self , struct ssh_connection *connection ,
                                      uint32_t local_channel_number , struct lsh_string **request ) ;
};
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h.x"
struct global_request_command {
   struct command super ;
   struct lsh_string *(*format_request)(struct global_request_command *self , struct ssh_connection *connection ,
                                        struct command_continuation **c ) ;
};
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h.x"
struct install_info {
   struct command_2 super ;
   int name ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.h.x"
struct channel_forward {
   struct ssh_channel super ;
   struct lsh_fd *socket ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
struct open_tcpip_command {
   struct channel_open_command super ;
   int type ;
   struct address_info *port ;
   struct listen_value *peer ;
};
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
struct remote_port_install_continuation {
   struct command_frame super ;
   struct remote_port *port ;
   struct command *callback ;
};
#line 72 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
struct request_tcpip_forward_command {
   struct global_request_command super ;
   struct command *callback ;
   struct address_info *port ;
};
#line 80 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h"
struct object_queue_node {
   struct lsh_queue_node header ;
   struct lsh_object *o ;
};
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.h.x"
struct local_port {
   struct forwarded_port super ;
   struct lsh_fd *socket ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
struct open_forwarded_tcpip_continuation {
   struct command_continuation super ;
   struct command_continuation *up ;
   struct ssh_connection *connection ;
};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
struct channel_open_direct_tcpip {
   struct channel_open super ;
   struct command *callback ;
};
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
struct tcpip_forward_request_continuation {
   struct command_continuation super ;
   struct local_port *forward ;
   struct ssh_connection *connection ;
   struct command_continuation *c ;
};
#line 104 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
struct tcpip_forward_request_handler {
   struct exception_handler super ;
   struct ssh_connection *connection ;
   struct local_port *forward ;
};
#line 137 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
struct tcpip_forward_request {
   struct global_request super ;
   struct command *callback ;
};
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_1 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_1 __sigset_t;
#line 50 "/usr/include/signal.h"
typedef __sigset_t sigset_t;
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_4 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_5 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_6 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_7 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_8 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_9 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_3 {
   int _pad[128UL / sizeof(int ) - 3UL] ;
   struct __anonstruct__kill_4 _kill ;
   struct __anonstruct__timer_5 _timer ;
   struct __anonstruct__rt_6 _rt ;
   struct __anonstruct__sigchld_7 _sigchld ;
   struct __anonstruct__sigfault_8 _sigfault ;
   struct __anonstruct__sigpoll_9 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_3 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_21 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_21 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/suspend.h"
struct escape_callback;
#line 37
struct escape_callback;
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h.x"
struct escape_callback {
   struct lsh_callback super ;
   char const   *help ;
};
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/string_buffer.c"
struct string_node {
   struct string_node *prev ;
   struct lsh_string *s ;
};
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct hash_instance {
   struct lsh_object super ;
   struct nettle_hash  const  *type ;
   char ctx[1] ;
};
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct hash_algorithm {
   struct lsh_object super ;
   struct nettle_hash  const  *type ;
};
#line 132 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct mac_algorithm {
   struct lsh_object super ;
   uint32_t mac_size ;
   uint32_t key_size ;
   struct mac_instance *(*make_mac)(struct mac_algorithm *self , uint32_t length ,
                                    uint8_t const   *key ) ;
};
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
struct zn_group {
   struct lsh_object super ;
   mpz_t modulo ;
   mpz_t generator ;
   mpz_t order ;
};
#line 78 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
struct dh_method {
   struct lsh_object super ;
   struct zn_group  const  *G ;
   struct hash_algorithm  const  *H ;
   struct randomness *random ;
};
#line 110 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
struct dh_instance {
   struct dh_method  const  *method ;
   mpz_t e ;
   mpz_t f ;
   mpz_t secret ;
   struct lsh_string *K ;
   struct hash_instance *hash ;
   struct lsh_string *exchange_hash ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp.h.x"
struct srp_entry {
   struct lsh_object super ;
   struct lsh_string *name ;
   struct lsh_string *salt ;
   mpz_t verifier ;
};
#line 2 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.h.x"
struct alist_meta {
   struct lsh_class super ;
   struct lsh_object *(*get)(struct alist *self , int atom ) ;
   void (*set)(struct alist *self , int atom , struct lsh_object *value ) ;
};
#line 30 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct crypto_algorithm {
   struct lsh_object super ;
   uint32_t block_size ;
   uint32_t key_size ;
   uint32_t iv_size ;
   struct crypto_instance *(*make_crypt)(struct crypto_algorithm *self , int mode ,
                                         uint8_t const   *key , uint8_t const   *iv ) ;
};
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct verifier {
   struct lsh_object super ;
   int (*verify)(struct verifier *self , int algorithm , uint32_t length , uint8_t const   *data ,
                 uint32_t signature_length , uint8_t const   *signature_data ) ;
   struct lsh_string *(*public_key)(struct verifier *self ) ;
   struct lsh_string *(*public_spki_key)(struct verifier *self , int transport ) ;
};
#line 184 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct signer {
   struct lsh_object super ;
   struct lsh_string *(*sign)(struct signer *self , int algorithm , uint32_t length ,
                              uint8_t const   *data ) ;
   struct verifier *(*get_verifier)(struct signer *self ) ;
};
#line 209 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct signature_algorithm {
   struct lsh_object super ;
   struct signer *(*make_signer)(struct signature_algorithm *self , struct sexp_iterator *i ) ;
   struct verifier *(*make_verifier)(struct signature_algorithm *self , struct sexp_iterator *i ) ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.h.x"
struct spki_context {
   struct lsh_object super ;
   struct alist *algorithms ;
   struct spki_acl_db db ;
};
#line 167 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct channel_open_exception {
   struct exception super ;
   uint32_t error_code ;
};
#line 259 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct io_exception {
   struct exception super ;
   struct lsh_fd *fd ;
   int error ;
};
#line 92 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
enum socks_state {
    SOCKS_VERSION_HEADER = 0,
    SOCKS_VERSION_METHODS = 1,
    SOCKS_COMMAND_HEADER = 2,
    SOCKS_COMMAND_ADDR = 3,
    SOCKS4_COMMAND = 4,
    SOCKS_COMMAND_WAIT = 5
} ;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
struct socks_connection {
   struct lsh_object super ;
   uint8_t version ;
   struct ssh_connection *connection ;
   struct listen_value *peer ;
};
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
struct socks_continuation {
   struct command_continuation super ;
   struct socks_connection *socks ;
};
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
struct socks_exception_handler {
   struct exception_handler super ;
   struct socks_connection *socks ;
};
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
struct read_socks {
   struct read_handler super ;
   struct socks_connection *socks ;
   struct lsh_string *buffer ;
   uint32_t pos ;
   enum socks_state state ;
   uint32_t length ;
};
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 275 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 92 "/usr/include/sys/socket.h"
struct sockaddr_un;
#line 92
struct sockaddr_un;
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.h.x"
struct server_x11_info {
   struct lsh_object super ;
   struct lsh_string *display ;
   struct lsh_string *xauthority ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c.x"
struct channel_open_command_x11 {
   struct channel_open_command super ;
   struct listen_value *peer ;
};
#line 99 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c.x"
struct server_x11_socket {
   struct resource super ;
   int dir ;
   struct lsh_string *name ;
   int display_number ;
   uid_t uid ;
   struct lsh_fd *fd ;
};
#line 140 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c.x"
struct xauth_exit_callback {
   struct exit_callback super ;
   struct command_continuation *c ;
   struct exception_handler *e ;
};
#line 123 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.h"
struct int_list;
#line 123
struct int_list;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.h.x"
struct list_header {
   struct lsh_object super ;
   unsigned int length ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.h.x"
struct int_list {
   struct list_header super ;
   int elements[1] ;
};
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.h.x"
struct userauth_service {
   struct command super ;
   struct int_list *advertised_methods ;
   struct alist *methods ;
   struct alist *services ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c.x"
struct userauth_handler {
   struct packet_handler super ;
   struct command_continuation *c ;
   struct exception_handler *service_e ;
   struct exception_handler *auth_e ;
   struct alist *methods ;
   struct alist *services ;
};
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c.x"
struct userauth_continuation {
   struct command_continuation super ;
   struct command_continuation *up ;
   struct ssh_connection *connection ;
};
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c.x"
struct exc_userauth_handler {
   struct exception_handler super ;
   struct ssh_connection *connection ;
   struct int_list *advertised_methods ;
   unsigned int attempts ;
};
#line 111 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c.x"
struct userauth_none_permit {
   struct userauth super ;
   struct lsh_user *user ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c.x"
struct server_session {
   struct ssh_channel super ;
   uint32_t initial_window ;
   struct lsh_process *process ;
   struct pty_info *pty ;
   struct server_x11_info *x11 ;
   struct lsh_string *term ;
   struct lsh_string *client ;
   struct lsh_fd *in ;
   struct lsh_fd *out ;
   struct lsh_fd *err ;
};
#line 56 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c.x"
struct open_session {
   struct channel_open super ;
   struct alist *session_requests ;
};
#line 87 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c.x"
struct exit_shell {
   struct exit_callback super ;
   struct server_session *session ;
};
#line 118 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c.x"
struct subsystem_request {
   struct channel_request super ;
   char const   **subsystems ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/lookup_verifier.h.x"
struct lookup_verifier {
   struct lsh_object super ;
   struct verifier *(*lookup)(struct lookup_verifier *self , int method , struct lsh_user *user ,
                              struct lsh_string *key ) ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_publickey.c.x"
struct userauth_publickey {
   struct userauth super ;
   struct user_db *db ;
   struct alist *verifiers ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_password.c.x"
struct userauth_password {
   struct userauth super ;
   struct user_db *db ;
};
#line 124 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.h"
struct object_list;
#line 124
struct object_list;
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.h.x"
struct object_list {
   struct list_header super ;
   struct lsh_object *elements[1] ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.h.x"
struct keyexchange_algorithm {
   struct lsh_object super ;
   void (*init)(struct keyexchange_algorithm *self , struct ssh_connection *connection ,
                int hostkey_algorithm_atom , struct lsh_object *extra , struct object_list *algorithms ) ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.h.x"
struct kexinit {
   struct lsh_object super ;
   uint8_t cookie[16] ;
   struct int_list *kex_algorithms ;
   struct int_list *server_hostkey_algorithms ;
   struct int_list *parameters[6] ;
   struct int_list *languages_client_to_server ;
   struct int_list *languages_server_to_client ;
   int first_kex_packet_follows ;
   struct lsh_string *first_kex_packet ;
};
#line 81 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.h.x"
struct make_kexinit {
   struct lsh_object super ;
   struct kexinit *(*make)(struct make_kexinit *self ) ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
struct keypair {
   struct lsh_object super ;
   int type ;
   struct lsh_string *public ;
   struct signer *private ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
struct dh_server_exchange {
   struct keyexchange_algorithm super ;
   struct dh_method *dh ;
};
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
struct dh_server {
   struct packet_handler super ;
   struct dh_instance dh ;
   int hostkey_algorithm ;
   struct lsh_string *server_key ;
   struct signer *signer ;
   struct object_list *algorithms ;
};
#line 81 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
struct srp_server_instance {
   struct lsh_object super ;
   struct dh_instance dh ;
   struct object_list *algorithms ;
   struct user_db *db ;
   struct lsh_user *user ;
   struct srp_entry *entry ;
};
#line 127 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
struct srp_server_handler {
   struct packet_handler super ;
   struct srp_server_instance *srp ;
};
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
struct server_srp_read_verifier {
   struct abstract_write super ;
   struct srp_server_instance *srp ;
   struct ssh_connection *connection ;
};
#line 191 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
struct srp_server_exchange {
   struct keyexchange_algorithm super ;
   struct dh_method  const  *dh ;
   struct user_db *db ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_authorization.c.x"
struct authorization_db {
   struct lookup_verifier super ;
   struct lsh_string *index_name ;
   struct hash_algorithm  const  *hashalgo ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c.x"
struct service_handler {
   struct packet_handler super ;
   struct alist *services ;
   struct command_continuation *c ;
   struct exception_handler *e ;
};
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c.x"
struct offer_service {
   struct command super ;
   struct alist *services ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c.x"
struct rsa_verifier {
   struct verifier super ;
   struct rsa_public_key key ;
};
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c.x"
struct rsa_signer {
   struct signer super ;
   struct rsa_verifier *verifier ;
   struct rsa_private_key key ;
};
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.c"
struct resource_node {
   struct resource_node *next ;
   struct resource *resource ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c.x"
struct reaper_callback {
   struct lsh_callback super ;
   struct reaper *reaper ;
};
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 98 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c"
union __anonunion_62 {
   int __in ;
   int __i ;
};
#line 102 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c"
union __anonunion_63 {
   int __in ;
   int __i ;
};
#line 92 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c"
union __anonunion_64 {
   int __in ;
   int __i ;
};
#line 84 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c"
union __anonunion_65 {
   int __in ;
   int __i ;
};
#line 119 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c"
union __anonunion_66 {
   int __in ;
   int __i ;
};
#line 89 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h.x"
struct protocol_exception {
   struct exception super ;
   uint32_t reason ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c.x"
struct read_packet {
   struct read_handler super ;
   int state ;
   uint32_t sequence_number ;
   uint32_t pos ;
   struct lsh_string *block_buffer ;
   struct lsh_string *mac_buffer ;
   struct lsh_string *mac_computed ;
   struct lsh_string *packet_buffer ;
   uint32_t payload_length ;
   uint32_t crypt_pos ;
   struct abstract_write *handler ;
   struct ssh_connection *connection ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_line.h.x"
struct line_handler {
   struct lsh_object super ;
   void (*handler)(struct line_handler **self , struct read_handler **r , uint32_t length ,
                   uint8_t const   *line , struct exception_handler *e ) ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_line.c.x"
struct read_line {
   struct read_handler super ;
   struct line_handler *handler ;
   struct exception_handler *e ;
   uint32_t pos ;
   struct lsh_string *buffer ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_file.c.x"
struct read_file {
   struct read_handler super ;
   struct abstract_write *c ;
   struct lsh_string *buffer ;
   uint32_t pos ;
};
#line 129 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct io_consuming_read {
   struct io_callback super ;
   uint32_t (*query)(struct io_consuming_read *self ) ;
   struct abstract_write *consumer ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_data.c.x"
struct read_data {
   struct io_consuming_read super ;
   struct ssh_channel *channel ;
};
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h.x"
struct addr_queue {
   struct lsh_queue q ;
};
#line 130 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h"
struct string_queue_node {
   struct lsh_queue_node header ;
   struct lsh_string *s ;
};
#line 156 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h"
struct addr_queue_node {
   struct lsh_queue_node header ;
   socklen_t size ;
   struct sockaddr addr ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.h"
enum config_type {
    CONFIG_ADDRESS = 0,
    CONFIG_USER = 1
} ;
#line 32
struct config_setting;
#line 32
struct config_setting;
#line 33
struct config_group;
#line 33
struct config_group;
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.h"
struct config_match {
   struct config_setting  const  *group ;
   struct config_setting  const  *host ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c.x"
struct config_setting {
   struct lsh_object super ;
   struct config_setting *next ;
   enum config_type type ;
   struct lsh_string *value ;
};
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c.x"
struct config_host {
   struct lsh_object super ;
   struct config_host *next ;
   struct lsh_string *name ;
   struct config_setting *settings ;
};
#line 84 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c.x"
struct config_group {
   struct lsh_object super ;
   struct config_group *next ;
   struct lsh_string *name ;
   struct config_setting *settings ;
   struct config_host *hosts ;
};
#line 84 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
enum token_type {
    TOK_EOF = 0,
    TOK_BEGIN_GROUP = 1,
    TOK_END_GROUP = 2,
    TOK_STRING = 3,
    TOK_ERROR = 4
} ;
#line 87 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
struct tokenizer {
   struct simple_buffer buffer ;
   unsigned int lineno ;
   enum token_type type ;
   unsigned int token_length ;
   char const   *token ;
};
#line 108 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
struct lsh_string {
   uint32_t sequence_number ;
   uint32_t length ;
   uint8_t data[1] ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.c.x"
struct lsh_file_lock {
   struct resource super ;
   struct lsh_file_lock_info *info ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c.x"
struct kexinit_handler {
   struct packet_handler super ;
   struct lsh_object *extra ;
   struct alist *algorithms ;
};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c.x"
struct reexchange_timeout {
   struct lsh_callback super ;
   struct ssh_connection *connection ;
};
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c.x"
struct newkeys_handler {
   struct packet_handler super ;
   struct crypto_instance *crypto ;
   struct mac_instance *mac ;
   struct compress_instance *compression ;
};
#line 104 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c.x"
struct simple_kexinit {
   struct make_kexinit super ;
   struct randomness *r ;
   struct int_list *kex_algorithms ;
   struct int_list *hostkey_algorithms ;
   struct int_list *crypto_algorithms ;
   struct int_list *mac_algorithms ;
   struct int_list *compression_algorithms ;
   struct int_list *languages ;
};
#line 192 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct local_info {
   struct lsh_object super ;
   struct lsh_string *directory ;
   struct lsh_string *name ;
};
#line 291 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct connect_list_state {
   struct resource super ;
   struct addr_queue q ;
   unsigned int nfds ;
   struct lsh_fd *fds[3] ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c.x"
struct connect_continuation {
   struct command_continuation super ;
   struct address_info *target ;
   struct command_continuation *up ;
};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c.x"
struct connect_port {
   struct command super ;
   struct address_info *target ;
};
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c.x"
struct tcp_wrapper {
   struct command super ;
   struct lsh_string *name ;
   struct lsh_string *msg ;
};
#line 37 "/usr/include/sys/poll.h"
typedef unsigned long nfds_t;
#line 40 "/usr/include/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 187 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 16 "/usr/local/include/oop.h"
struct oop_source;
#line 16
struct oop_source;
#line 16 "/usr/local/include/oop.h"
typedef struct oop_source oop_source;
#line 19
enum __anonenum_oop_event_53 {
    OOP_READ = 0,
    OOP_WRITE = 1,
    OOP_EXCEPTION = 2,
    OOP_NUM_EVENTS = 3
} ;
#line 19 "/usr/local/include/oop.h"
typedef enum __anonenum_oop_event_53 oop_event;
#line 40 "/usr/local/include/oop.h"
typedef void *oop_call_fd(oop_source * , int fd , oop_event  , void * );
#line 41 "/usr/local/include/oop.h"
typedef void *oop_call_time(oop_source * , struct timeval  , void * );
#line 42 "/usr/local/include/oop.h"
typedef void *oop_call_signal(oop_source * , int sig , void * );
#line 44 "/usr/local/include/oop.h"
struct oop_source {
   void (*on_fd)(oop_source * , int fd , oop_event  , oop_call_fd * , void * ) ;
   void (*cancel_fd)(oop_source * , int fd , oop_event  ) ;
   void (*on_time)(oop_source * , struct timeval  , oop_call_time * , void * ) ;
   void (*cancel_time)(oop_source * , struct timeval  , oop_call_time * , void * ) ;
   void (*on_signal)(oop_source * , int sig , oop_call_signal * , void * ) ;
   void (*cancel_signal)(oop_source * , int sig , oop_call_signal * , void * ) ;
};
#line 66
struct oop_source_sys;
#line 66
struct oop_source_sys;
#line 66 "/usr/local/include/oop.h"
typedef struct oop_source_sys oop_source_sys;
#line 111
struct oop_adapter_signal;
#line 111
struct oop_adapter_signal;
#line 111 "/usr/local/include/oop.h"
typedef struct oop_adapter_signal oop_adapter_signal;
#line 256 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 543 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 97 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct io_buffered_read {
   struct io_callback super ;
   uint32_t buffer_size ;
   struct read_handler *handler ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct lsh_signal_handler {
   struct resource super ;
   int signum ;
   struct lsh_callback *action ;
};
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct lsh_callout {
   struct resource super ;
   struct timeval when ;
   struct lsh_callback *action ;
};
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct io_listen_callback {
   struct io_callback super ;
   struct command *c ;
   struct exception_handler *e ;
};
#line 102 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct io_connect_callback {
   struct io_callback super ;
   struct command_continuation *c ;
};
#line 133 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct connect_list_callback {
   struct io_callback super ;
   struct connect_list_state *state ;
   unsigned int index ;
   struct command_continuation *c ;
   struct exception_handler *e ;
};
#line 169 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct write_only_file {
   struct abstract_write super ;
   int fd ;
   struct exception_handler *e ;
};
#line 201 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct exc_finish_read_handler {
   struct exception_handler super ;
   struct lsh_fd *fd ;
};
#line 2491 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
union __anonunion_70 {
   int __in ;
   int __i ;
};
#line 2495 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
union __anonunion_71 {
   int __in ;
   int __i ;
};
#line 2499 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
union __anonunion_72 {
   int __in ;
   int __i ;
};
#line 2499 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
union __anonunion_73 {
   int __in ;
   int __i ;
};
#line 2489 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
union __anonunion_74 {
   int __in ;
   int __i ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.h.x"
struct handshake_info {
   struct lsh_object super ;
   enum connection_flag flags ;
   uint32_t block_size ;
   char const   *id_comment ;
   char const   *debug_comment ;
   struct randomness *random ;
   struct alist *algorithms ;
   struct make_kexinit *kexinit ;
   struct lsh_string *banner_text ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.c.x"
struct connection_line_handler {
   struct line_handler super ;
   struct ssh_connection *connection ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c.x"
struct read_gateway_packet {
   struct read_handler super ;
   uint32_t pos ;
   struct lsh_string *header ;
   struct lsh_string *payload ;
   struct abstract_write *handler ;
   struct ssh_connection *connection ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.h.x"
struct gateway_channel {
   struct ssh_channel super ;
   struct gateway_channel *chain ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h.x"
struct channel_request_command {
   struct command super ;
   struct lsh_string *(*format_request)(struct channel_request_command *self , struct ssh_channel *channel ,
                                        struct command_continuation **c ) ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
struct gateway_channel_open_command {
   struct channel_open_command super ;
   struct lsh_string *type ;
   uint32_t rec_window_size ;
   uint32_t rec_max_packet ;
   struct alist *requests ;
   struct lsh_string *args ;
};
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
struct general_channel_request_command {
   struct channel_request_command super ;
   struct lsh_string *request ;
};
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
struct general_global_request_command {
   struct global_request_command super ;
   struct lsh_string *request ;
};
#line 107 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
struct gateway_channel_open_continuation {
   struct command_continuation super ;
   struct command_continuation *up ;
   struct channel_request *fallback ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c.x"
struct report_exception_handler {
   struct exception_handler super ;
   struct report_exception_info  const  *info ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c.x"
struct dsa_algorithm {
   struct signature_algorithm super ;
   struct randomness *random ;
};
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c.x"
struct dsa_verifier {
   struct verifier super ;
   struct dsa_public_key key ;
};
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c.x"
struct dsa_signer {
   struct signer super ;
   struct dsa_verifier *verifier ;
   struct randomness *random ;
   struct dsa_private_key key ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/debug.c.x"
struct packet_debug {
   struct abstract_write_pipe super ;
   struct lsh_string *prefix ;
};
#line 146 "/usr/include/bits/types.h"
typedef unsigned long __rlim_t;
#line 33 "/usr/include/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_NLIMITS = 15,
    __RLIM_NLIMITS = 15
} ;
#line 127 "/usr/include/bits/resource.h"
typedef __rlim_t rlim_t;
#line 135 "/usr/include/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 39 "/usr/include/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/daemon.h"
enum daemon_mode {
    DAEMON_NORMAL = 1,
    DAEMON_INIT = 2,
    DAEMON_INETD = 3
} ;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct arcfour_instance {
   struct crypto_instance super ;
   struct arcfour_ctx ctx ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct __anonstruct_ctx_38 {
   struct aes_ctx ctx ;
   uint8_t iv[16] ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct aes_cbc_instance {
   struct crypto_instance super ;
   struct __anonstruct_ctx_38 ctx ;
};
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct __anonstruct_ctx_39 {
   struct aes_ctx ctx ;
   uint8_t ctr[16] ;
};
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct aes_ctr_instance {
   struct crypto_instance super ;
   struct __anonstruct_ctx_39 ctx ;
};
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct __anonstruct_ctx_40 {
   struct des3_ctx ctx ;
   uint8_t iv[8] ;
};
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct des3_instance {
   struct crypto_instance super ;
   struct __anonstruct_ctx_40 ctx ;
};
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct __anonstruct_ctx_41 {
   struct cast128_ctx ctx ;
   uint8_t iv[8] ;
};
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct cast128_instance {
   struct crypto_instance super ;
   struct __anonstruct_ctx_41 ctx ;
};
#line 125 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct __anonstruct_ctx_42 {
   struct twofish_ctx ctx ;
   uint8_t iv[16] ;
};
#line 125 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct twofish_instance {
   struct crypto_instance super ;
   struct __anonstruct_ctx_42 ctx ;
};
#line 149 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct __anonstruct_ctx_43 {
   struct blowfish_ctx ctx ;
   uint8_t iv[8] ;
};
#line 149 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct blowfish_instance {
   struct crypto_instance super ;
   struct __anonstruct_ctx_43 ctx ;
};
#line 173 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct __anonstruct_ctx_44 {
   struct serpent_ctx ctx ;
   uint8_t iv[16] ;
};
#line 173 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct serpent_instance {
   struct crypto_instance super ;
   struct __anonstruct_ctx_44 ctx ;
};
#line 197 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct hmac_instance {
   struct mac_instance super ;
   struct nettle_hash  const  *type ;
   char ctx[1] ;
};
#line 222 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct hmac_algorithm {
   struct mac_algorithm super ;
   struct nettle_hash  const  *type ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection_commands.h.x"
struct connection_command {
   struct command super ;
   struct ssh_connection *connection ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
struct io_backend;
#line 5
struct io_backend;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
struct exc_connection_handler {
   struct exception_handler super ;
   struct io_backend *backend ;
   struct ssh_connection *connection ;
};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
struct connection_flow_controlled {
   struct flow_controlled super ;
   struct ssh_connection *connection ;
};
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
struct connection_close_handler {
   struct lsh_callback super ;
   struct ssh_connection *connection ;
};
#line 100 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
struct connection_timeout {
   struct lsh_callback super ;
   struct ssh_connection *connection ;
   struct exception  const  *e ;
};
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct command_context {
   struct lsh_object super ;
   struct command_continuation *c ;
   struct exception_handler *e ;
};
#line 253 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h"
struct catch_handler_info;
#line 253
struct catch_handler_info;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct command_apply {
   struct command_frame super ;
   struct command *f ;
};
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct gaba_continuation {
   struct command_continuation super ;
   struct lsh_object *value ;
};
#line 67 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct command_2_invoke {
   struct command super ;
   struct command_2 *f ;
   struct lsh_object *a1 ;
};
#line 100 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct command_3_invoke_2 {
   struct command super ;
   struct command_3 *f ;
   struct lsh_object *a1 ;
   struct lsh_object *a2 ;
};
#line 135 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct command_3_invoke {
   struct command super ;
   struct command_3 *f ;
   struct lsh_object *a1 ;
};
#line 168 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct command_4_invoke_3 {
   struct command super ;
   struct command_4 *f ;
   struct lsh_object *a1 ;
   struct lsh_object *a2 ;
   struct lsh_object *a3 ;
};
#line 205 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct command_4_invoke_2 {
   struct command super ;
   struct command_4 *f ;
   struct lsh_object *a1 ;
   struct lsh_object *a2 ;
};
#line 240 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct command_4_invoke {
   struct command super ;
   struct command_4 *f ;
   struct lsh_object *a1 ;
};
#line 273 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct trace_continuation {
   struct command_continuation super ;
   char const   *name ;
   struct command_continuation *real ;
};
#line 305 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct trace_command {
   struct command super ;
   char const   *name ;
   struct command *real ;
};
#line 337 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct parallell_progn {
   struct command super ;
   struct object_list *body ;
};
#line 368 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct catch_handler_info {
   struct lsh_object super ;
   uint32_t mask ;
   uint32_t value ;
   int ignore_value ;
   struct command *handler ;
};
#line 402 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct catch_handler {
   struct exception_handler super ;
   struct command_continuation *c ;
   struct catch_handler_info *info ;
};
#line 435 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct catch_apply {
   struct command super ;
   struct catch_handler_info *info ;
   struct command *body ;
};
#line 468 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct catch_report_apply {
   struct command super ;
   struct report_exception_info  const  *info ;
   struct command *body ;
};
#line 501 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct protect_handler {
   struct exception_handler super ;
   struct resource *resource ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c.x"
struct command_S_continuation {
   struct command_frame super ;
   struct command *g ;
   struct lsh_object *x ;
};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c.x"
struct command_C_continuation {
   struct command_frame super ;
   struct lsh_object *y ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct client_x11_display {
   struct lsh_object super ;
   socklen_t address_length ;
   struct sockaddr *address ;
   uint16_t screen ;
   struct lsh_string *fake ;
   struct lsh_string *auth_name ;
   struct lsh_string *auth_data ;
};
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct channel_open_x11 {
   struct channel_open super ;
   struct io_backend *backend ;
};
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct client_x11_channel {
   struct channel_forward super ;
   struct client_x11_display *display ;
   int state ;
   int little_endian ;
   unsigned int name_length ;
   unsigned int auth_length ;
   uint32_t i ;
   struct lsh_string *buffer ;
};
#line 117 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct channel_open_x11_continuation {
   struct command_continuation super ;
   struct client_x11_display *display ;
   struct command_continuation *up ;
};
#line 150 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct client_x11_display_resource {
   struct resource super ;
   struct ssh_connection *connection ;
   struct client_x11_display *display ;
};
#line 183 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct request_x11_continuation {
   struct command_continuation super ;
   struct ssh_connection *connection ;
   struct client_x11_display *display ;
   struct command_continuation *up ;
};
#line 218 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct request_x11_forward_command {
   struct channel_request_command super ;
   struct ssh_connection *connection ;
   struct client_x11_display *display ;
};
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.h"
struct client_userauth_method;
#line 47
struct client_userauth_method;
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
struct client_userauth;
#line 43
struct client_userauth;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct client_userauth_failure {
   struct lsh_object super ;
   void (*failure)(struct client_userauth_failure *self , int again ) ;
};
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct client_userauth_method {
   struct lsh_object super ;
   int type ;
   struct client_userauth_failure *(*login)(struct client_userauth_method *self ,
                                            struct client_userauth *u , struct ssh_connection *c ,
                                            struct exception_handler *e ) ;
};
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct client_userauth {
   struct command super ;
   struct lsh_string *username ;
   int service_name ;
   struct object_list *methods ;
};
#line 93 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct client_userauth_state {
   struct lsh_object super ;
   struct client_userauth *userauth ;
   struct ssh_connection *connection ;
   struct client_userauth_failure *failure ;
   unsigned int current ;
   unsigned int next ;
};
#line 130 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct userauth_packet_handler {
   struct packet_handler super ;
   struct client_userauth_state *state ;
};
#line 161 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct userauth_success_handler {
   struct packet_handler super ;
   struct command_continuation *c ;
};
#line 192 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct failure_handler {
   struct userauth_packet_handler super ;
   struct exception_handler *e ;
};
#line 223 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct exc_client_userauth {
   struct exception_handler super ;
   struct client_userauth_state *state ;
};
#line 254 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct exc_userauth_disconnect {
   struct exception_handler super ;
   struct ssh_connection *connection ;
};
#line 285 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct client_none_state {
   struct client_userauth_failure super ;
   struct exception_handler *e ;
};
#line 316 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct client_password_state {
   struct client_userauth_failure super ;
   struct client_userauth *userauth ;
   struct interact *tty ;
   int tried_empty_passwd ;
   struct ssh_connection *connection ;
   struct exception_handler *e ;
};
#line 354 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct client_userauth_interactive_method {
   struct client_userauth_method super ;
   struct interact *tty ;
};
#line 385 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct client_publickey_method {
   struct client_userauth_method super ;
   struct object_list *keys ;
};
#line 416 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct client_publickey_state {
   struct client_userauth_failure super ;
   struct client_userauth *userauth ;
   struct ssh_connection *connection ;
   struct object_list *keys ;
   uint32_t done ;
   uint32_t pending ;
   struct exception_handler *e ;
};
#line 455 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct userauth_pk_ok_handler {
   struct packet_handler super ;
   struct client_publickey_state *state ;
};
#line 486 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct client_kbdinteract_state {
   struct client_userauth_failure super ;
   struct interact *tty ;
   struct ssh_connection *connection ;
   struct exception_handler *e ;
};
#line 521 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct userauth_info_request_handler {
   struct packet_handler super ;
   struct client_kbdinteract_state *state ;
};
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h.x"
struct escape_info {
   struct lsh_object super ;
   uint8_t escape ;
   struct escape_callback *dispatch[256] ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c.x"
struct client_session_channel {
   struct ssh_channel super ;
   struct lsh_fd *in ;
   struct lsh_fd *out ;
   struct lsh_fd *err ;
   struct escape_info *escape ;
   int *exit_status ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
struct pty_request {
   struct channel_request_command super ;
   struct interact *tty ;
   struct lsh_string *term ;
   struct terminal_attributes *attr ;
   struct terminal_dimensions dims ;
};
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
struct client_tty_resource {
   struct resource super ;
   struct interact *tty ;
   struct terminal_attributes *attr ;
};
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
struct client_winch_handler {
   struct window_change_callback super ;
   struct ssh_channel *channel ;
};
#line 110 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
struct pty_request_continuation {
   struct command_frame super ;
   struct pty_request *req ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
struct dh_client_exchange {
   struct keyexchange_algorithm super ;
   struct dh_method  const  *dh ;
};
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
struct dh_client {
   struct packet_handler super ;
   struct dh_instance dh ;
   int hostkey_algorithm ;
   struct lookup_verifier *verifier ;
   struct object_list *algorithms ;
};
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
struct srp_client_instance {
   struct lsh_object super ;
   struct dh_instance dh ;
   struct interact *tty ;
   struct lsh_string *name ;
   struct lsh_string *m2 ;
   struct object_list *algorithms ;
};
#line 125 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
struct srp_client_handler {
   struct packet_handler super ;
   struct srp_client_instance *srp ;
};
#line 156 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
struct srp_client_exchange {
   struct keyexchange_algorithm super ;
   struct dh_method  const  *dh ;
   struct interact *tty ;
   struct lsh_string *name ;
};
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c"
enum escape_state {
    GOT_NONE = 0,
    GOT_NEWLINE = 1,
    GOT_ESCAPE = 2
} ;
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c.x"
struct escape_help {
   struct escape_callback super ;
   struct escape_info *info ;
};
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c.x"
struct escape_handler {
   struct abstract_write_pipe super ;
   struct escape_info *info ;
   enum escape_state state ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h.x"
struct request_service {
   struct command super ;
   int service ;
};
#line 89 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h.x"
struct client_options {
   struct lsh_object super ;
   struct randomness *random ;
   struct interact *tty ;
   int escape ;
   struct exception_handler *handler ;
   int *exit_code ;
   int not ;
   char const   *port ;
   char const   *target ;
   char *local_user ;
   char *user ;
   int with_remote_peers ;
   int with_pty ;
   int with_x11 ;
   char const   *stdin_file ;
   char const   *stdout_file ;
   char const   *stderr_file ;
   int used_stdin ;
   int used_pty ;
   int used_x11 ;
   int write_pid ;
   int detach_end ;
   int inhibit_actions ;
   int start_shell ;
   int remote_forward ;
   struct object_queue actions ;
   struct resource_list *resources ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct accept_service_handler {
   struct packet_handler super ;
   int service ;
   struct command_continuation *c ;
};
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct detach_callback {
   struct lsh_callback super ;
   int channel_flag ;
   int fd_flag ;
   int *exit_status ;
};
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct detach_resource {
   struct resource super ;
   struct detach_callback *c ;
};
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct exit_handler {
   struct channel_request super ;
   int *exit_status ;
};
#line 118 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct session_open_command {
   struct channel_open_command super ;
   struct ssh_channel *session ;
};
#line 149 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct exec_request {
   struct channel_request_command super ;
   struct lsh_string *command ;
};
#line 179 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct subsystem_request___0 {
   struct channel_request_command super ;
   struct lsh_string *subsystem ;
};
#line 333 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct background_process_command {
   struct command super ;
   int write_pid ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c.x"
struct install_global_request_handler {
   struct command super ;
   int name ;
   struct global_request *handler ;
};
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c.x"
struct install_channel_open_handler {
   struct command super ;
   int name ;
   struct channel_open *handler ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct exc_finish_channel_handler {
   struct exception_handler super ;
   struct ssh_connection *connection ;
   int dead ;
   uint32_t channel_number ;
};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct request_status {
   struct lsh_object super ;
   int status ;
};
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct global_request_continuation {
   struct command_continuation super ;
   struct ssh_connection *connection ;
   struct request_status *active ;
};
#line 95 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct global_request_exception_handler {
   struct exception_handler super ;
   struct ssh_connection *connection ;
   struct request_status *active ;
};
#line 128 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct channel_request_continuation {
   struct command_continuation super ;
   struct ssh_channel *channel ;
   struct request_status *active ;
};
#line 161 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct channel_request_exception_handler {
   struct exception_handler super ;
   struct ssh_channel *channel ;
   struct request_status *active ;
};
#line 194 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct channel_open_continuation {
   struct command_continuation super ;
   struct ssh_connection *connection ;
   uint32_t local_channel_number ;
   uint32_t remote_channel_number ;
   uint32_t send_window_size ;
   uint32_t send_max_packet ;
};
#line 229 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct exc_channel_open_handler {
   struct exception_handler super ;
   struct ssh_connection *connection ;
   uint32_t local_channel_number ;
   uint32_t remote_channel_number ;
};
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct channel_write {
   struct abstract_write super ;
   struct ssh_channel *channel ;
};
#line 293 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct channel_write_extended {
   struct channel_write super ;
   uint32_t type ;
};
#line 317 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct channel_close_callback {
   struct lsh_callback super ;
   struct ssh_channel *channel ;
};
#line 348 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct channel_io_exception_handler {
   struct exception_handler super ;
   struct ssh_channel *channel ;
   char const   *prefix ;
   int silent ;
};
#line 33 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms.c"
struct atom_rassoc {
   uint8_t const   *name ;
   uint32_t length ;
};
#line 39
struct atom_assoc;
#line 39
struct atom_assoc;
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms_gperf.c"
struct atom_assoc {
   char const   *name ;
   int id ;
};
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c"
struct alist_node {
   struct alist_node *next ;
   int atom ;
   struct lsh_object *value ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c.x"
struct alist_linear {
   struct alist super ;
   struct lsh_object *table[108] ;
};
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c.x"
struct alist_linked {
   struct alist super ;
   struct alist_node *head ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.h.x"
struct algorithms_options {
   struct lsh_object super ;
   struct alist *algorithms ;
   struct int_list *crypto_algorithms ;
   struct int_list *mac_algorithms ;
   struct int_list *compression_algorithms ;
   struct int_list *hostkey_algorithms ;
};
#line 5 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c.x"
struct lsh_options {
   struct client_options super ;
   struct algorithms_options *algorithms ;
   struct alist *signature_algorithms ;
   char const   *home ;
   char *identity ;
   int with_publickey ;
   int with_srp_keyexchange ;
   int with_dh_keyexchange ;
   struct int_list *kex_algorithms ;
   int sloppy ;
   char const   *capture ;
   struct abstract_write *capture_file ;
   char const   *known_hosts ;
   int start_gateway ;
};
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c.x"
struct lsh_host_db {
   struct lookup_verifier super ;
   struct spki_context *db ;
   struct interact *tty ;
   struct lsh_string *access ;
   char const   *host ;
   int sloppy ;
   struct abstract_write *file ;
   struct hash_algorithm  const  *hash ;
};
#line 171 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c.x"
struct lsh_default_handler {
   struct exception_handler super ;
   int *status ;
};
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 116 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow.h"
void nettle_yarrow_key_event_init(struct yarrow_key_event_ctx *ctx ) ;
#line 119
unsigned int nettle_yarrow_key_event_estimate(struct yarrow_key_event_ctx *ctx , unsigned int key ,
                                              unsigned int time___0 ) ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow_key_event.c"
void nettle_yarrow_key_event_init(struct yarrow_key_event_ctx *ctx ) 
{ 
  unsigned int i ;

  {
#line 36
  ctx->index = 0U;
#line 37
  ctx->previous = 0U;
#line 39
  i = 0U;
  {
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 39
    if (! (i < 16U)) {
#line 39
      goto while_break;
    }
#line 40
    ctx->chars[i] = 0U;
#line 39
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 41
  return;
}
}
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow_key_event.c"
unsigned int nettle_yarrow_key_event_estimate(struct yarrow_key_event_ctx *ctx , unsigned int key ,
                                              unsigned int time___0 ) 
{ 
  unsigned int entropy ;
  unsigned int i ;

  {
#line 47
  entropy = 0U;
#line 51
  if (ctx->previous) {
#line 51
    if (time___0 > ctx->previous) {
#line 53
      if (time___0 - ctx->previous >= 256U) {
#line 54
        entropy ++;
      }
    }
  }
#line 56
  ctx->previous = time___0;
#line 58
  if (! key) {
#line 59
    return (entropy);
  }
#line 61
  i = 0U;
  {
  {
#line 61
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 61
    if (! (i < 16U)) {
#line 61
      goto while_break;
    }
#line 62
    if (key == ctx->chars[i]) {
#line 64
      return (entropy);
    }
#line 61
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 68
  if (ctx->chars[ctx->index]) {
#line 69
    entropy ++;
  }
#line 73
  ctx->chars[ctx->index] = key;
#line 74
  ctx->index = (ctx->index + 1U) % 16U;
#line 76
  return (entropy);
}
}
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 513 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes.h"
void nettle_aes_set_encrypt_key(struct aes_ctx *ctx , unsigned int keysize , uint8_t const   *key ) ;
#line 59
void nettle_aes_encrypt(struct aes_ctx *ctx , unsigned int length , uint8_t *dst ,
                        uint8_t const   *src ) ;
#line 89 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha.h"
void nettle_sha256_init(struct sha256_ctx *ctx ) ;
#line 92
void nettle_sha256_update(struct sha256_ctx *ctx , unsigned int length , uint8_t const   *buffer ) ;
#line 97
void nettle_sha256_digest(struct sha256_ctx *ctx , unsigned int length , uint8_t *digest ) ;
#line 76 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow.h"
void nettle_yarrow256_init(struct yarrow256_ctx *ctx , unsigned int n , struct yarrow_source *s ) ;
#line 81
void nettle_yarrow256_seed(struct yarrow256_ctx *ctx , unsigned int length , uint8_t const   *seed_file ) ;
#line 87
int nettle_yarrow256_update(struct yarrow256_ctx *ctx , unsigned int source_index ,
                            unsigned int entropy , unsigned int length , uint8_t const   *data ) ;
#line 92
void nettle_yarrow256_random(struct yarrow256_ctx *ctx , unsigned int length , uint8_t *dst ) ;
#line 95
int nettle_yarrow256_is_seeded(struct yarrow256_ctx *ctx ) ;
#line 98
unsigned int nettle_yarrow256_needed_sources(struct yarrow256_ctx *ctx ) ;
#line 101
void nettle_yarrow256_force_reseed(struct yarrow256_ctx *ctx ) ;
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c"
static void yarrow_fast_reseed(struct yarrow256_ctx *ctx ) ;
#line 76
static void yarrow_gate(struct yarrow256_ctx *ctx ) ;
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c"
void nettle_yarrow256_init(struct yarrow256_ctx *ctx , unsigned int n , struct yarrow_source *s ) 
{ 
  unsigned int i ;

  {
  {
  {
#line 86
  nettle_sha256_init(& ctx->pools[0]);
  }
  {
#line 87
  nettle_sha256_init(& ctx->pools[1]);
  }
#line 89
  ctx->seeded = 0;
  {
#line 93
  memset((void *)(ctx->seed_file), 0, (size_t )32);
  }
  {
#line 94
  memset((void *)(ctx->counter), 0, (size_t )sizeof(ctx->counter));
  }
#line 96
  ctx->nsources = n;
#line 97
  ctx->sources = s;
#line 99
  i = 0U;
  }
  {
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 99
    if (! (i < n)) {
#line 99
      goto while_break;
    }
#line 101
    (ctx->sources + i)->estimate[0] = (uint32_t )0;
#line 102
    (ctx->sources + i)->estimate[1] = (uint32_t )0;
#line 103
    (ctx->sources + i)->next = (enum yarrow_pool_id )0;
#line 99
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 105
  return;
}
}
#line 107 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c"
void nettle_yarrow256_seed(struct yarrow256_ctx *ctx , unsigned int length , uint8_t const   *seed_file ) 
{ 


  {
#line 113
  if (! length) {
#line 114
    return;
  }
  {
  {
#line 116
  nettle_sha256_update(& ctx->pools[0], length, seed_file);
  }
  {
#line 117
  yarrow_fast_reseed(ctx);
  }
#line 119
  ctx->seeded = 1;
  }
#line 120
  return;
}
}
#line 124 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c"
static void yarrow_generate_block(struct yarrow256_ctx *ctx , uint8_t *block ) 
{ 
  unsigned int i ;
  unsigned int tmp ;

  {
  {
  {
#line 130
  nettle_aes_encrypt(& ctx->key, (unsigned int )sizeof(ctx->counter), block, (uint8_t const   *)(ctx->counter));
  }
#line 139
  i = (unsigned int )sizeof(ctx->counter);
  }
  {
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 139
    tmp = i;
#line 139
    i --;
#line 139
    if (! tmp) {
#line 139
      goto while_break;
    }
#line 141
    ctx->counter[i] = (uint8_t )((int )ctx->counter[i] + 1);
#line 141
    if (ctx->counter[i]) {
#line 142
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 144
  return;
}
}
#line 146 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c"
static void yarrow_iterate(uint8_t *digest ) 
{ 
  uint8_t v0[32] ;
  unsigned int i ;
  uint8_t count[4] ;
  struct sha256_ctx hash___2 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
  {
#line 152
  memcpy((void */* __restrict  */)((void *)(v0)), (void const   */* __restrict  */)((void const   *)digest),
         (size_t )32);
  }
#line 156
  i = 0U;
  }
  {
  {
#line 156
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 156
    i ++;
#line 156
    if (! (i < 1500U)) {
#line 156
      goto while_break;
    }
    {
    {
#line 161
    nettle_sha256_init(& hash___2);
    }
    }
    {
    {
#line 164
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 164
      count[0] = (uint8_t )((i >> 24) & 255U);
#line 164
      count[1] = (uint8_t )((i >> 16) & 255U);
#line 164
      count[2] = (uint8_t )((i >> 8) & 255U);
#line 164
      count[3] = (uint8_t )(i & 255U);
#line 164
      goto while_break___0;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
    {
#line 165
    nettle_sha256_update(& hash___2, 32U, (uint8_t const   *)digest);
    }
    {
#line 166
    nettle_sha256_update(& hash___2, (unsigned int )sizeof(v0), (uint8_t const   *)(v0));
    }
    {
#line 167
    nettle_sha256_update(& hash___2, (unsigned int )sizeof(count), (uint8_t const   *)(count));
    }
    {
#line 169
    nettle_sha256_digest(& hash___2, 32U, digest);
    }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 171
  return;
}
}
#line 176 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c"
static void yarrow_fast_reseed(struct yarrow256_ctx *ctx ) 
{ 
  uint8_t digest[32] ;
  unsigned int i ;
  uint8_t blocks[32] ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
#line 188
  if (ctx->seeded) {
    {
    {
#line 192
    yarrow_generate_block(ctx, blocks);
    }
    {
#line 193
    yarrow_generate_block(ctx, blocks + 16);
    }
    {
#line 194
    nettle_sha256_update(& ctx->pools[0], (unsigned int )sizeof(blocks), (uint8_t const   *)(blocks));
    }
    }
  }
  {
  {
#line 197
  nettle_sha256_digest(& ctx->pools[0], (unsigned int )sizeof(digest), digest);
  }
  {
#line 200
  yarrow_iterate(digest);
  }
  {
#line 202
  nettle_aes_set_encrypt_key(& ctx->key, (unsigned int )sizeof(digest), (uint8_t const   *)(digest));
  }
  {
#line 205
  memset((void *)(ctx->counter), 0, (size_t )sizeof(ctx->counter));
  }
  {
#line 206
  nettle_aes_encrypt(& ctx->key, (unsigned int )sizeof(ctx->counter), ctx->counter,
                     (uint8_t const   *)(ctx->counter));
  }
#line 209
  i = 0U;
  }
  {
  {
#line 209
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 209
    if (! (i < ctx->nsources)) {
#line 209
      goto while_break;
    }
#line 210
    (ctx->sources + i)->estimate[0] = (uint32_t )0;
#line 209
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 214
  i = 0U;
  {
  {
#line 214
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 214
    if (! ((unsigned long )i < sizeof(ctx->seed_file))) {
#line 214
      goto while_break___0;
    }
    {
    {
#line 215
    yarrow_generate_block(ctx, ctx->seed_file + i);
    }
#line 214
    i += 16U;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
  {
#line 217
  yarrow_gate(ctx);
  }
  }
#line 218
  return;
}
}
#line 220 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c"
static void yarrow_slow_reseed(struct yarrow256_ctx *ctx ) 
{ 
  uint8_t digest[32] ;
  unsigned int i ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
  {
#line 232
  nettle_sha256_digest(& ctx->pools[1], (unsigned int )sizeof(digest), digest);
  }
  {
#line 235
  nettle_sha256_update(& ctx->pools[0], (unsigned int )sizeof(digest), (uint8_t const   *)(digest));
  }
  {
#line 237
  yarrow_fast_reseed(ctx);
  }
#line 240
  i = 0U;
  }
  {
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 240
    if (! (i < ctx->nsources)) {
#line 240
      goto while_break;
    }
#line 241
    (ctx->sources + i)->estimate[1] = (uint32_t )0;
#line 240
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 242
  return;
}
}
#line 244 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c"
int nettle_yarrow256_update(struct yarrow256_ctx *ctx , unsigned int source_index ,
                            unsigned int entropy , unsigned int length , uint8_t const   *data ) 
{ 
  enum yarrow_pool_id current ;
  struct yarrow_source *source___0 ;
  unsigned int tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 252
  if (! (source_index < ctx->nsources)) {
    {
    {
#line 252
    __assert_fail("source_index < ctx->nsources", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c",
                  252U, "nettle_yarrow256_update");
    }
    }
  }
#line 254
  if (! length) {
#line 256
    return (0);
  }
#line 258
  source___0 = ctx->sources + source_index;
#line 260
  if (! ctx->seeded) {
#line 262
    current = (enum yarrow_pool_id )1;
  } else {
#line 265
    current = source___0->next;
#line 266
    source___0->next = (enum yarrow_pool_id )(! source___0->next);
  }
  {
  {
#line 269
  nettle_sha256_update(& ctx->pools[current], length, data);
  }
  }
#line 272
  if (source___0->estimate[current] < 1048576U) {
#line 274
    if (entropy > 1048576U) {
#line 275
      entropy = 1048576U;
    }
#line 277
    if (length < 262144U) {
#line 277
      if (entropy > 4U * length) {
#line 279
        entropy = 4U * length;
      }
    }
#line 284
    entropy += source___0->estimate[current];
#line 285
    if (entropy > 1048576U) {
#line 286
      entropy = 1048576U;
    }
#line 288
    source___0->estimate[current] = entropy;
  }
#line 294
  if ((unsigned int )current == 0U) {
#line 294
    goto case_0;
  }
#line 309
  if ((unsigned int )current == 1U) {
#line 309
    goto case_1;
  }
#line 325
  goto switch_default;
  case_0: 
#line 301
  if (source___0->estimate[0] >= 100U) {
    {
    {
#line 303
    yarrow_fast_reseed(ctx);
    }
    }
#line 304
    return (1);
  } else {
#line 307
    return (0);
  }
  case_1: 
  {
  {
#line 315
  tmp = nettle_yarrow256_needed_sources(ctx);
  }
  }
#line 315
  if (tmp) {
#line 323
    return (0);
  } else {
    {
    {
#line 317
    yarrow_slow_reseed(ctx);
    }
#line 318
    ctx->seeded = 1;
    }
#line 320
    return (1);
  }
  switch_default: 
  {
  {
#line 326
  abort();
  }
  }

#line 331
  return (0);
}
}
#line 330 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c"
static void yarrow_gate(struct yarrow256_ctx *ctx ) 
{ 
  uint8_t key[32] ;
  unsigned int i ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
#line 336
  i = 0U;
  {
  {
#line 336
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 336
    if (! ((unsigned long )i < sizeof(key))) {
#line 336
      goto while_break;
    }
    {
    {
#line 337
    yarrow_generate_block(ctx, key + i);
    }
#line 336
    i += 16U;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 339
  nettle_aes_set_encrypt_key(& ctx->key, (unsigned int )sizeof(key), (uint8_t const   *)(key));
  }
  }
#line 340
  return;
}
}
#line 342 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c"
void nettle_yarrow256_random(struct yarrow256_ctx *ctx , unsigned int length , uint8_t *dst ) 
{ 
  uint8_t buffer[16] ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 345
  if (! ctx->seeded) {
    {
    {
#line 345
    __assert_fail("ctx->seeded", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c",
                  345U, "nettle_yarrow256_random");
    }
    }
  }
  {
  {
#line 347
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 347
    if (! (length >= 16U)) {
#line 347
      goto while_break;
    }
    {
    {
#line 349
    yarrow_generate_block(ctx, dst);
    }
#line 350
    dst += 16;
#line 351
    length -= 16U;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 353
  if (length) {
#line 357
    if (! (length < 16U)) {
      {
      {
#line 357
      __assert_fail("length < 16", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c",
                    357U, "nettle_yarrow256_random");
      }
      }
    }
    {
    {
#line 358
    yarrow_generate_block(ctx, buffer);
    }
    {
#line 359
    memcpy((void */* __restrict  */)((void *)dst), (void const   */* __restrict  */)((void const   *)(buffer)),
           length);
    }
    }
  }
  {
  {
#line 361
  yarrow_gate(ctx);
  }
  }
#line 362
  return;
}
}
#line 364 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c"
int nettle_yarrow256_is_seeded(struct yarrow256_ctx *ctx ) 
{ 


  {
#line 367
  return (ctx->seeded);
}
}
#line 370 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c"
unsigned int nettle_yarrow256_needed_sources(struct yarrow256_ctx *ctx ) 
{ 
  unsigned int k ;
  unsigned int i ;
  unsigned int tmp ;

  {
#line 378
  k = 0U;
#line 378
  i = k;
  {
  {
#line 378
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 378
    if (! (i < ctx->nsources)) {
#line 378
      goto while_break;
    }
#line 379
    if ((ctx->sources + i)->estimate[1] >= 160U) {
#line 380
      k ++;
    }
#line 378
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 390
  if (k < 2U) {
#line 390
    tmp = 2U - k;
  } else {
#line 390
    tmp = 0U;
  }
#line 390
  return (tmp);
}
}
#line 393 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/yarrow256.c"
void nettle_yarrow256_force_reseed(struct yarrow256_ctx *ctx ) 
{ 


  {
  {
  {
#line 396
  yarrow_slow_reseed(ctx);
  }
  }
#line 397
  return;
}
}
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.h"
void nettle_twofish_set_key(struct twofish_ctx *context , unsigned int keysize , uint8_t const   *key ) ;
#line 61
void nettle_twofish_encrypt(struct twofish_ctx *context , unsigned int length , uint8_t *ciphertext ,
                            uint8_t const   *plaintext ) ;
#line 65
void nettle_twofish_decrypt(struct twofish_ctx *context , unsigned int length , uint8_t *plaintext ,
                            uint8_t const   *ciphertext ) ;
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c"
static uint8_t const   q0[256]  = 
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c"
  {      (uint8_t const   )169,      (uint8_t const   )103,      (uint8_t const   )179,      (uint8_t const   )232, 
        (uint8_t const   )4,      (uint8_t const   )253,      (uint8_t const   )163,      (uint8_t const   )118, 
        (uint8_t const   )154,      (uint8_t const   )146,      (uint8_t const   )128,      (uint8_t const   )120, 
        (uint8_t const   )228,      (uint8_t const   )221,      (uint8_t const   )209,      (uint8_t const   )56, 
        (uint8_t const   )13,      (uint8_t const   )198,      (uint8_t const   )53,      (uint8_t const   )152, 
        (uint8_t const   )24,      (uint8_t const   )247,      (uint8_t const   )236,      (uint8_t const   )108, 
        (uint8_t const   )67,      (uint8_t const   )117,      (uint8_t const   )55,      (uint8_t const   )38, 
        (uint8_t const   )250,      (uint8_t const   )19,      (uint8_t const   )148,      (uint8_t const   )72, 
        (uint8_t const   )242,      (uint8_t const   )208,      (uint8_t const   )139,      (uint8_t const   )48, 
        (uint8_t const   )132,      (uint8_t const   )84,      (uint8_t const   )223,      (uint8_t const   )35, 
        (uint8_t const   )25,      (uint8_t const   )91,      (uint8_t const   )61,      (uint8_t const   )89, 
        (uint8_t const   )243,      (uint8_t const   )174,      (uint8_t const   )162,      (uint8_t const   )130, 
        (uint8_t const   )99,      (uint8_t const   )1,      (uint8_t const   )131,      (uint8_t const   )46, 
        (uint8_t const   )217,      (uint8_t const   )81,      (uint8_t const   )155,      (uint8_t const   )124, 
        (uint8_t const   )166,      (uint8_t const   )235,      (uint8_t const   )165,      (uint8_t const   )190, 
        (uint8_t const   )22,      (uint8_t const   )12,      (uint8_t const   )227,      (uint8_t const   )97, 
        (uint8_t const   )192,      (uint8_t const   )140,      (uint8_t const   )58,      (uint8_t const   )245, 
        (uint8_t const   )115,      (uint8_t const   )44,      (uint8_t const   )37,      (uint8_t const   )11, 
        (uint8_t const   )187,      (uint8_t const   )78,      (uint8_t const   )137,      (uint8_t const   )107, 
        (uint8_t const   )83,      (uint8_t const   )106,      (uint8_t const   )180,      (uint8_t const   )241, 
        (uint8_t const   )225,      (uint8_t const   )230,      (uint8_t const   )189,      (uint8_t const   )69, 
        (uint8_t const   )226,      (uint8_t const   )244,      (uint8_t const   )182,      (uint8_t const   )102, 
        (uint8_t const   )204,      (uint8_t const   )149,      (uint8_t const   )3,      (uint8_t const   )86, 
        (uint8_t const   )212,      (uint8_t const   )28,      (uint8_t const   )30,      (uint8_t const   )215, 
        (uint8_t const   )251,      (uint8_t const   )195,      (uint8_t const   )142,      (uint8_t const   )181, 
        (uint8_t const   )233,      (uint8_t const   )207,      (uint8_t const   )191,      (uint8_t const   )186, 
        (uint8_t const   )234,      (uint8_t const   )119,      (uint8_t const   )57,      (uint8_t const   )175, 
        (uint8_t const   )51,      (uint8_t const   )201,      (uint8_t const   )98,      (uint8_t const   )113, 
        (uint8_t const   )129,      (uint8_t const   )121,      (uint8_t const   )9,      (uint8_t const   )173, 
        (uint8_t const   )36,      (uint8_t const   )205,      (uint8_t const   )249,      (uint8_t const   )216, 
        (uint8_t const   )229,      (uint8_t const   )197,      (uint8_t const   )185,      (uint8_t const   )77, 
        (uint8_t const   )68,      (uint8_t const   )8,      (uint8_t const   )134,      (uint8_t const   )231, 
        (uint8_t const   )161,      (uint8_t const   )29,      (uint8_t const   )170,      (uint8_t const   )237, 
        (uint8_t const   )6,      (uint8_t const   )112,      (uint8_t const   )178,      (uint8_t const   )210, 
        (uint8_t const   )65,      (uint8_t const   )123,      (uint8_t const   )160,      (uint8_t const   )17, 
        (uint8_t const   )49,      (uint8_t const   )194,      (uint8_t const   )39,      (uint8_t const   )144, 
        (uint8_t const   )32,      (uint8_t const   )246,      (uint8_t const   )96,      (uint8_t const   )255, 
        (uint8_t const   )150,      (uint8_t const   )92,      (uint8_t const   )177,      (uint8_t const   )171, 
        (uint8_t const   )158,      (uint8_t const   )156,      (uint8_t const   )82,      (uint8_t const   )27, 
        (uint8_t const   )95,      (uint8_t const   )147,      (uint8_t const   )10,      (uint8_t const   )239, 
        (uint8_t const   )145,      (uint8_t const   )133,      (uint8_t const   )73,      (uint8_t const   )238, 
        (uint8_t const   )45,      (uint8_t const   )79,      (uint8_t const   )143,      (uint8_t const   )59, 
        (uint8_t const   )71,      (uint8_t const   )135,      (uint8_t const   )109,      (uint8_t const   )70, 
        (uint8_t const   )214,      (uint8_t const   )62,      (uint8_t const   )105,      (uint8_t const   )100, 
        (uint8_t const   )42,      (uint8_t const   )206,      (uint8_t const   )203,      (uint8_t const   )47, 
        (uint8_t const   )252,      (uint8_t const   )151,      (uint8_t const   )5,      (uint8_t const   )122, 
        (uint8_t const   )172,      (uint8_t const   )127,      (uint8_t const   )213,      (uint8_t const   )26, 
        (uint8_t const   )75,      (uint8_t const   )14,      (uint8_t const   )167,      (uint8_t const   )90, 
        (uint8_t const   )40,      (uint8_t const   )20,      (uint8_t const   )63,      (uint8_t const   )41, 
        (uint8_t const   )136,      (uint8_t const   )60,      (uint8_t const   )76,      (uint8_t const   )2, 
        (uint8_t const   )184,      (uint8_t const   )218,      (uint8_t const   )176,      (uint8_t const   )23, 
        (uint8_t const   )85,      (uint8_t const   )31,      (uint8_t const   )138,      (uint8_t const   )125, 
        (uint8_t const   )87,      (uint8_t const   )199,      (uint8_t const   )141,      (uint8_t const   )116, 
        (uint8_t const   )183,      (uint8_t const   )196,      (uint8_t const   )159,      (uint8_t const   )114, 
        (uint8_t const   )126,      (uint8_t const   )21,      (uint8_t const   )34,      (uint8_t const   )18, 
        (uint8_t const   )88,      (uint8_t const   )7,      (uint8_t const   )153,      (uint8_t const   )52, 
        (uint8_t const   )110,      (uint8_t const   )80,      (uint8_t const   )222,      (uint8_t const   )104, 
        (uint8_t const   )101,      (uint8_t const   )188,      (uint8_t const   )219,      (uint8_t const   )248, 
        (uint8_t const   )200,      (uint8_t const   )168,      (uint8_t const   )43,      (uint8_t const   )64, 
        (uint8_t const   )220,      (uint8_t const   )254,      (uint8_t const   )50,      (uint8_t const   )164, 
        (uint8_t const   )202,      (uint8_t const   )16,      (uint8_t const   )33,      (uint8_t const   )240, 
        (uint8_t const   )211,      (uint8_t const   )93,      (uint8_t const   )15,      (uint8_t const   )0, 
        (uint8_t const   )111,      (uint8_t const   )157,      (uint8_t const   )54,      (uint8_t const   )66, 
        (uint8_t const   )74,      (uint8_t const   )94,      (uint8_t const   )193,      (uint8_t const   )224};
#line 95 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c"
static uint8_t const   q1[256]  = 
#line 95
  {      (uint8_t const   )117,      (uint8_t const   )243,      (uint8_t const   )198,      (uint8_t const   )244, 
        (uint8_t const   )219,      (uint8_t const   )123,      (uint8_t const   )251,      (uint8_t const   )200, 
        (uint8_t const   )74,      (uint8_t const   )211,      (uint8_t const   )230,      (uint8_t const   )107, 
        (uint8_t const   )69,      (uint8_t const   )125,      (uint8_t const   )232,      (uint8_t const   )75, 
        (uint8_t const   )214,      (uint8_t const   )50,      (uint8_t const   )216,      (uint8_t const   )253, 
        (uint8_t const   )55,      (uint8_t const   )113,      (uint8_t const   )241,      (uint8_t const   )225, 
        (uint8_t const   )48,      (uint8_t const   )15,      (uint8_t const   )248,      (uint8_t const   )27, 
        (uint8_t const   )135,      (uint8_t const   )250,      (uint8_t const   )6,      (uint8_t const   )63, 
        (uint8_t const   )94,      (uint8_t const   )186,      (uint8_t const   )174,      (uint8_t const   )91, 
        (uint8_t const   )138,      (uint8_t const   )0,      (uint8_t const   )188,      (uint8_t const   )157, 
        (uint8_t const   )109,      (uint8_t const   )193,      (uint8_t const   )177,      (uint8_t const   )14, 
        (uint8_t const   )128,      (uint8_t const   )93,      (uint8_t const   )210,      (uint8_t const   )213, 
        (uint8_t const   )160,      (uint8_t const   )132,      (uint8_t const   )7,      (uint8_t const   )20, 
        (uint8_t const   )181,      (uint8_t const   )144,      (uint8_t const   )44,      (uint8_t const   )163, 
        (uint8_t const   )178,      (uint8_t const   )115,      (uint8_t const   )76,      (uint8_t const   )84, 
        (uint8_t const   )146,      (uint8_t const   )116,      (uint8_t const   )54,      (uint8_t const   )81, 
        (uint8_t const   )56,      (uint8_t const   )176,      (uint8_t const   )189,      (uint8_t const   )90, 
        (uint8_t const   )252,      (uint8_t const   )96,      (uint8_t const   )98,      (uint8_t const   )150, 
        (uint8_t const   )108,      (uint8_t const   )66,      (uint8_t const   )247,      (uint8_t const   )16, 
        (uint8_t const   )124,      (uint8_t const   )40,      (uint8_t const   )39,      (uint8_t const   )140, 
        (uint8_t const   )19,      (uint8_t const   )149,      (uint8_t const   )156,      (uint8_t const   )199, 
        (uint8_t const   )36,      (uint8_t const   )70,      (uint8_t const   )59,      (uint8_t const   )112, 
        (uint8_t const   )202,      (uint8_t const   )227,      (uint8_t const   )133,      (uint8_t const   )203, 
        (uint8_t const   )17,      (uint8_t const   )208,      (uint8_t const   )147,      (uint8_t const   )184, 
        (uint8_t const   )166,      (uint8_t const   )131,      (uint8_t const   )32,      (uint8_t const   )255, 
        (uint8_t const   )159,      (uint8_t const   )119,      (uint8_t const   )195,      (uint8_t const   )204, 
        (uint8_t const   )3,      (uint8_t const   )111,      (uint8_t const   )8,      (uint8_t const   )191, 
        (uint8_t const   )64,      (uint8_t const   )231,      (uint8_t const   )43,      (uint8_t const   )226, 
        (uint8_t const   )121,      (uint8_t const   )12,      (uint8_t const   )170,      (uint8_t const   )130, 
        (uint8_t const   )65,      (uint8_t const   )58,      (uint8_t const   )234,      (uint8_t const   )185, 
        (uint8_t const   )228,      (uint8_t const   )154,      (uint8_t const   )164,      (uint8_t const   )151, 
        (uint8_t const   )126,      (uint8_t const   )218,      (uint8_t const   )122,      (uint8_t const   )23, 
        (uint8_t const   )102,      (uint8_t const   )148,      (uint8_t const   )161,      (uint8_t const   )29, 
        (uint8_t const   )61,      (uint8_t const   )240,      (uint8_t const   )222,      (uint8_t const   )179, 
        (uint8_t const   )11,      (uint8_t const   )114,      (uint8_t const   )167,      (uint8_t const   )28, 
        (uint8_t const   )239,      (uint8_t const   )209,      (uint8_t const   )83,      (uint8_t const   )62, 
        (uint8_t const   )143,      (uint8_t const   )51,      (uint8_t const   )38,      (uint8_t const   )95, 
        (uint8_t const   )236,      (uint8_t const   )118,      (uint8_t const   )42,      (uint8_t const   )73, 
        (uint8_t const   )129,      (uint8_t const   )136,      (uint8_t const   )238,      (uint8_t const   )33, 
        (uint8_t const   )196,      (uint8_t const   )26,      (uint8_t const   )235,      (uint8_t const   )217, 
        (uint8_t const   )197,      (uint8_t const   )57,      (uint8_t const   )153,      (uint8_t const   )205, 
        (uint8_t const   )173,      (uint8_t const   )49,      (uint8_t const   )139,      (uint8_t const   )1, 
        (uint8_t const   )24,      (uint8_t const   )35,      (uint8_t const   )221,      (uint8_t const   )31, 
        (uint8_t const   )78,      (uint8_t const   )45,      (uint8_t const   )249,      (uint8_t const   )72, 
        (uint8_t const   )79,      (uint8_t const   )242,      (uint8_t const   )101,      (uint8_t const   )142, 
        (uint8_t const   )120,      (uint8_t const   )92,      (uint8_t const   )88,      (uint8_t const   )25, 
        (uint8_t const   )141,      (uint8_t const   )229,      (uint8_t const   )152,      (uint8_t const   )87, 
        (uint8_t const   )103,      (uint8_t const   )127,      (uint8_t const   )5,      (uint8_t const   )100, 
        (uint8_t const   )175,      (uint8_t const   )99,      (uint8_t const   )182,      (uint8_t const   )254, 
        (uint8_t const   )245,      (uint8_t const   )183,      (uint8_t const   )60,      (uint8_t const   )165, 
        (uint8_t const   )206,      (uint8_t const   )233,      (uint8_t const   )104,      (uint8_t const   )68, 
        (uint8_t const   )224,      (uint8_t const   )77,      (uint8_t const   )67,      (uint8_t const   )105, 
        (uint8_t const   )41,      (uint8_t const   )46,      (uint8_t const   )172,      (uint8_t const   )21, 
        (uint8_t const   )89,      (uint8_t const   )168,      (uint8_t const   )10,      (uint8_t const   )158, 
        (uint8_t const   )110,      (uint8_t const   )71,      (uint8_t const   )223,      (uint8_t const   )52, 
        (uint8_t const   )53,      (uint8_t const   )106,      (uint8_t const   )207,      (uint8_t const   )220, 
        (uint8_t const   )34,      (uint8_t const   )201,      (uint8_t const   )192,      (uint8_t const   )155, 
        (uint8_t const   )137,      (uint8_t const   )212,      (uint8_t const   )237,      (uint8_t const   )171, 
        (uint8_t const   )18,      (uint8_t const   )162,      (uint8_t const   )13,      (uint8_t const   )82, 
        (uint8_t const   )187,      (uint8_t const   )2,      (uint8_t const   )47,      (uint8_t const   )169, 
        (uint8_t const   )215,      (uint8_t const   )97,      (uint8_t const   )30,      (uint8_t const   )180, 
        (uint8_t const   )80,      (uint8_t const   )4,      (uint8_t const   )246,      (uint8_t const   )194, 
        (uint8_t const   )22,      (uint8_t const   )37,      (uint8_t const   )134,      (uint8_t const   )86, 
        (uint8_t const   )85,      (uint8_t const   )9,      (uint8_t const   )190,      (uint8_t const   )145};
#line 144 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c"
static uint8_t gf_multiply(uint8_t p , uint8_t a , uint8_t b ) 
{ 
  uint32_t shift ;
  uint8_t result ;

  {
#line 147
  shift = (uint32_t )b;
#line 148
  result = (uint8_t )0;
  {
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 149
    if (! a) {
#line 149
      goto while_break;
    }
#line 151
    if ((int )a & 1) {
#line 151
      result = (uint8_t )((unsigned int )result ^ shift);
    }
#line 152
    a = (uint8_t )((int )a >> 1);
#line 153
    shift <<= 1;
#line 154
    if (shift & 256U) {
#line 154
      shift ^= (unsigned int )p;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 156
  return (result);
}
}
#line 163 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c"
static uint8_t const   rs_matrix[4][8]  = { {        (uint8_t const   )1,        (uint8_t const   )164,        (uint8_t const   )85,        (uint8_t const   )135, 
            (uint8_t const   )90,        (uint8_t const   )88,        (uint8_t const   )219,        (uint8_t const   )158}, 
   {        (uint8_t const   )164,        (uint8_t const   )86,        (uint8_t const   )130,        (uint8_t const   )243, 
            (uint8_t const   )30,        (uint8_t const   )198,        (uint8_t const   )104,        (uint8_t const   )229}, 
   {        (uint8_t const   )2,        (uint8_t const   )161,        (uint8_t const   )252,        (uint8_t const   )193, 
            (uint8_t const   )71,        (uint8_t const   )174,        (uint8_t const   )61,        (uint8_t const   )25}, 
   {        (uint8_t const   )164,        (uint8_t const   )85,        (uint8_t const   )135,        (uint8_t const   )90, 
            (uint8_t const   )88,        (uint8_t const   )219,        (uint8_t const   )158,        (uint8_t const   )3}};
#line 179 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c"
static uint32_t compute_s(uint32_t m1 , uint32_t m2 ) 
{ 
  uint32_t s ;
  int i ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  uint8_t tmp___3 ;
  uint8_t tmp___4 ;
  uint8_t tmp___5 ;
  uint8_t tmp___6 ;

  {
#line 182
  s = (uint32_t )0;
#line 184
  i = 0;
  {
  {
#line 184
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 184
    if (! (i < 4)) {
#line 184
      goto while_break;
    }
    {
    {
#line 185
    tmp = gf_multiply((uint8_t )77, (uint8_t )m1, (uint8_t )rs_matrix[i][0]);
    }
    {
#line 185
    tmp___0 = gf_multiply((uint8_t )77, (uint8_t )(m1 >> 8), (uint8_t )rs_matrix[i][1]);
    }
    {
#line 185
    tmp___1 = gf_multiply((uint8_t )77, (uint8_t )(m1 >> 16), (uint8_t )rs_matrix[i][2]);
    }
    {
#line 185
    tmp___2 = gf_multiply((uint8_t )77, (uint8_t )(m1 >> 24), (uint8_t )rs_matrix[i][3]);
    }
    {
#line 185
    tmp___3 = gf_multiply((uint8_t )77, (uint8_t )m2, (uint8_t )rs_matrix[i][4]);
    }
    {
#line 185
    tmp___4 = gf_multiply((uint8_t )77, (uint8_t )(m2 >> 8), (uint8_t )rs_matrix[i][5]);
    }
    {
#line 185
    tmp___5 = gf_multiply((uint8_t )77, (uint8_t )(m2 >> 16), (uint8_t )rs_matrix[i][6]);
    }
    {
#line 185
    tmp___6 = gf_multiply((uint8_t )77, (uint8_t )(m2 >> 24), (uint8_t )rs_matrix[i][7]);
    }
#line 185
    s |= (unsigned int )(((((((((int )tmp ^ (int )tmp___0) ^ (int )tmp___1) ^ (int )tmp___2) ^ (int )tmp___3) ^ (int )tmp___4) ^ (int )tmp___5) ^ (int )tmp___6) << i * 8);
#line 184
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 193
  return (s);
}
}
#line 202 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c"
static uint8_t const   * const  q_table[4][5]  = { {        (uint8_t const   */* const  */)(q1),        (uint8_t const   */* const  */)(q1),        (uint8_t const   */* const  */)(q0),        (uint8_t const   */* const  */)(q0), 
            (uint8_t const   */* const  */)(q1)}, 
   {        (uint8_t const   */* const  */)(q0),        (uint8_t const   */* const  */)(q1),        (uint8_t const   */* const  */)(q1),        (uint8_t const   */* const  */)(q0), 
            (uint8_t const   */* const  */)(q0)}, 
   {        (uint8_t const   */* const  */)(q0),        (uint8_t const   */* const  */)(q0),        (uint8_t const   */* const  */)(q0),        (uint8_t const   */* const  */)(q1), 
            (uint8_t const   */* const  */)(q1)}, 
   {        (uint8_t const   */* const  */)(q1),        (uint8_t const   */* const  */)(q0),        (uint8_t const   */* const  */)(q1),        (uint8_t const   */* const  */)(q1), 
            (uint8_t const   */* const  */)(q0)}};
#line 210 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c"
static uint8_t const   mds_matrix[4][4]  = { {        (uint8_t const   )1,        (uint8_t const   )239,        (uint8_t const   )91,        (uint8_t const   )91}, 
   {        (uint8_t const   )91,        (uint8_t const   )239,        (uint8_t const   )239,        (uint8_t const   )1}, 
   {        (uint8_t const   )239,        (uint8_t const   )91,        (uint8_t const   )1,        (uint8_t const   )239}, 
   {        (uint8_t const   )239,        (uint8_t const   )1,        (uint8_t const   )239,        (uint8_t const   )91}};
#line 228 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c"
static uint32_t h_byte(int k , int i , uint8_t x , uint8_t l0 , uint8_t l1 , uint8_t l2 ,
                       uint8_t l3 ) 
{ 
  uint8_t y ;
  int tmp ;
  int tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  uint8_t tmp___3 ;
  uint8_t tmp___4 ;

  {
#line 231
  if (k == 2) {
#line 231
    tmp___0 = (int )x;
  } else {
#line 231
    if (k == 3) {
#line 231
      tmp = (int )x;
    } else {
#line 231
      tmp = (int )l3 ^ (int )*(q_table[i][0] + (int )x);
    }
#line 231
    tmp___0 = (int )l2 ^ (int )*(q_table[i][1] + tmp);
  }
  {
#line 231
  y = (uint8_t )*(q_table[i][4] + ((int )l0 ^ (int )*(q_table[i][3] + ((int )l1 ^ (int )*(q_table[i][2] + tmp___0)))));
  {
#line 236
  tmp___1 = gf_multiply((uint8_t )105, (uint8_t )mds_matrix[0][i], y);
  }
  {
#line 236
  tmp___2 = gf_multiply((uint8_t )105, (uint8_t )mds_matrix[1][i], y);
  }
  {
#line 236
  tmp___3 = gf_multiply((uint8_t )105, (uint8_t )mds_matrix[2][i], y);
  }
  {
#line 236
  tmp___4 = gf_multiply((uint8_t )105, (uint8_t )mds_matrix[3][i], y);
  }
  }
#line 236
  return ((((uint32_t )tmp___1 | ((uint32_t )tmp___2 << 8)) | ((uint32_t )tmp___3 << 16)) | ((uint32_t )tmp___4 << 24));
}
}
#line 247 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c"
static uint32_t h(int k , uint8_t x , uint32_t l0 , uint32_t l1 , uint32_t l2 , uint32_t l3 ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
  {
#line 250
  tmp = h_byte(k, 0, x, (uint8_t )l0, (uint8_t )l1, (uint8_t )l2, (uint8_t )l3);
  }
  {
#line 250
  tmp___0 = h_byte(k, 1, x, (uint8_t )(l0 >> 8), (uint8_t )(l1 >> 8), (uint8_t )(l2 >> 8),
                   (uint8_t )(l3 >> 8));
  }
  {
#line 250
  tmp___1 = h_byte(k, 2, x, (uint8_t )(l0 >> 16), (uint8_t )(l1 >> 16), (uint8_t )(l2 >> 16),
                   (uint8_t )(l3 >> 16));
  }
  {
#line 250
  tmp___2 = h_byte(k, 3, x, (uint8_t )(l0 >> 24), (uint8_t )(l1 >> 24), (uint8_t )(l2 >> 24),
                   (uint8_t )(l3 >> 24));
  }
  }
#line 250
  return (((tmp ^ tmp___0) ^ tmp___1) ^ tmp___2);
}
}
#line 272 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c"
void nettle_twofish_set_key(struct twofish_ctx *context , unsigned int keysize , uint8_t const   *key ) 
{ 
  uint8_t key_copy[32] ;
  uint32_t m[8] ;
  uint32_t s[4] ;
  uint32_t t ;
  int i ;
  int j ;
  int k ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 282
  if (! (keysize <= 32U)) {
    {
    {
#line 282
    __assert_fail("keysize <= 32", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c",
                  282U, "nettle_twofish_set_key");
    }
    }
  }
  {
  {
#line 286
  memset((void *)(key_copy), 0, (size_t )32);
  }
  {
#line 287
  memcpy((void */* __restrict  */)((void *)(key_copy)), (void const   */* __restrict  */)((void const   *)key),
         keysize);
  }
#line 289
  i = 0;
  }
  {
  {
#line 289
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 289
    if (! (i < 8)) {
#line 289
      goto while_break;
    }
#line 290
    m[i] = ((((uint32_t )*((key_copy + i * 4) + 3) << 24) | ((uint32_t )*((key_copy + i * 4) + 2) << 16)) | ((uint32_t )*((key_copy + i * 4) + 1) << 8)) | (uint32_t )*((key_copy + i * 4) + 0);
#line 289
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 292
  if (keysize <= 16U) {
#line 293
    k = 2;
  } else
#line 294
  if (keysize <= 24U) {
#line 295
    k = 3;
  } else {
#line 297
    k = 4;
  }
#line 301
  i = 0;
  {
  {
#line 301
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 301
    if (! (i < 20)) {
#line 301
      goto while_break___0;
    }
    {
    {
#line 303
    t = h(k, (uint8_t )(2 * i + 1), m[1], m[3], m[5], m[7]);
    }
#line 304
    t = (t << 8) | ((t & 4278190080U) >> 24);
    {
#line 305
    tmp___0 = h(k, (uint8_t )(2 * i), m[0], m[2], m[4], m[6]);
    }
#line 305
    tmp = t + tmp___0;
#line 305
    context->keys[2 * i] = tmp;
#line 305
    t += tmp;
#line 307
    t = (t << 9) | ((t & 4286578688U) >> 23);
#line 308
    context->keys[2 * i + 1] = t;
#line 301
    i ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
#line 313
  i = 0;
  {
  {
#line 313
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;

#line 313
    if (! (i < k)) {
#line 313
      goto while_break___1;
    }
    {
    {
#line 314
    s[(k - 1) - i] = compute_s(m[2 * i], m[2 * i + 1]);
    }
#line 313
    i ++;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
#line 316
  i = 0;
  {
  {
#line 316
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;

#line 316
    if (! (i < 4)) {
#line 316
      goto while_break___2;
    }
#line 317
    j = 0;
    {
    {
#line 317
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;

#line 317
      if (! (j < 256)) {
#line 317
        goto while_break___3;
      }
      {
      {
#line 318
      context->s_box[i][j] = h_byte(k, i, (uint8_t )j, (uint8_t )(s[0] >> i * 8),
                                    (uint8_t )(s[1] >> i * 8), (uint8_t )(s[2] >> i * 8),
                                    (uint8_t )(s[3] >> i * 8));
      }
#line 317
      j ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: 
#line 316
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: ;
#line 323
  return;
}
}
#line 335 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c"
void nettle_twofish_encrypt(struct twofish_ctx *context , unsigned int length , uint8_t *ciphertext ,
                            uint8_t const   *plaintext ) 
{ 
  uint32_t *keys ;
  uint32_t (*s_box)[256] ;
  uint32_t words[4] ;
  uint32_t r0 ;
  uint32_t r1 ;
  uint32_t r2 ;
  uint32_t r3 ;
  uint32_t t0 ;
  uint32_t t1 ;
  int i ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 341
  keys = context->keys;
#line 342
  s_box = context->s_box;
#line 344
  if (! (! (length % 16U))) {
    {
    {
#line 344
    __assert_fail("!(length % 16)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c",
                  344U, "nettle_twofish_encrypt");
    }
    }
  }
  {
  {
#line 345
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 345
    if (! length) {
#line 345
      goto while_break;
    }
#line 351
    i = 0;
    {
    {
#line 351
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 351
      if (! (i < 4)) {
#line 351
        goto while_break___0;
      }
#line 352
      words[i] = ((((uint32_t )*(plaintext + 3) << 24) | ((uint32_t )*(plaintext + 2) << 16)) | ((uint32_t )*(plaintext + 1) << 8)) | (uint32_t )*(plaintext + 0);
#line 351
      i ++;
#line 351
      plaintext += 4;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 354
    r0 = words[0] ^ *(keys + 0);
#line 355
    r1 = words[1] ^ *(keys + 1);
#line 356
    r2 = words[2] ^ *(keys + 2);
#line 357
    r3 = words[3] ^ *(keys + 3);
#line 359
    i = 0;
    {
    {
#line 359
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;

#line 359
      if (! (i < 8)) {
#line 359
        goto while_break___1;
      }
#line 360
      t1 = (((*(s_box + 1))[r1 & 255U] ^ (*(s_box + 2))[(r1 >> 8) & 255U]) ^ (*(s_box + 3))[(r1 >> 16) & 255U]) ^ (*(s_box + 0))[(r1 >> 24) & 255U];
#line 364
      t0 = ((((*(s_box + 0))[r0 & 255U] ^ (*(s_box + 1))[(r0 >> 8) & 255U]) ^ (*(s_box + 2))[(r0 >> 16) & 255U]) ^ (*(s_box + 3))[(r0 >> 24) & 255U]) + t1;
#line 368
      r3 = ((t1 + t0) + *(keys + (4 * i + 9))) ^ ((r3 << 1) | ((r3 & 2147483648U) >> 31));
#line 369
      r2 = (t0 + *(keys + (4 * i + 8))) ^ r2;
#line 370
      r2 = (r2 >> 1) | ((r2 & 1U) << 31);
#line 372
      t1 = (((*(s_box + 1))[r3 & 255U] ^ (*(s_box + 2))[(r3 >> 8) & 255U]) ^ (*(s_box + 3))[(r3 >> 16) & 255U]) ^ (*(s_box + 0))[(r3 >> 24) & 255U];
#line 376
      t0 = ((((*(s_box + 0))[r2 & 255U] ^ (*(s_box + 1))[(r2 >> 8) & 255U]) ^ (*(s_box + 2))[(r2 >> 16) & 255U]) ^ (*(s_box + 3))[(r2 >> 24) & 255U]) + t1;
#line 380
      r1 = ((t1 + t0) + *(keys + (4 * i + 11))) ^ ((r1 << 1) | ((r1 & 2147483648U) >> 31));
#line 381
      r0 = (t0 + *(keys + (4 * i + 10))) ^ r0;
#line 382
      r0 = (r0 >> 1) | ((r0 & 1U) << 31);
#line 359
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
#line 385
    words[0] = r2 ^ *(keys + 4);
#line 386
    words[1] = r3 ^ *(keys + 5);
#line 387
    words[2] = r0 ^ *(keys + 6);
#line 388
    words[3] = r1 ^ *(keys + 7);
#line 390
    i = 0;
    {
    {
#line 390
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;

#line 390
      if (! (i < 4)) {
#line 390
        goto while_break___2;
      }
      {
      {
#line 391
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 391
        *(ciphertext + 3) = (uint8_t )((words[i] >> 24) & 255U);
#line 391
        *(ciphertext + 2) = (uint8_t )((words[i] >> 16) & 255U);
#line 391
        *(ciphertext + 1) = (uint8_t )((words[i] >> 8) & 255U);
#line 391
        *(ciphertext + 0) = (uint8_t )(words[i] & 255U);
#line 391
        goto while_break___3;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 390
      i ++;
#line 390
      ciphertext += 4;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 345
    length -= 16U;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 393
  return;
}
}
#line 405 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c"
void nettle_twofish_decrypt(struct twofish_ctx *context , unsigned int length , uint8_t *plaintext ,
                            uint8_t const   *ciphertext ) 
{ 
  uint32_t *keys ;
  uint32_t (*s_box)[256] ;
  uint32_t words[4] ;
  uint32_t r0 ;
  uint32_t r1 ;
  uint32_t r2 ;
  uint32_t r3 ;
  uint32_t t0 ;
  uint32_t t1 ;
  int i ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 412
  keys = context->keys;
#line 413
  s_box = context->s_box;
#line 415
  if (! (! (length % 16U))) {
    {
    {
#line 415
    __assert_fail("!(length % 16)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish.c",
                  415U, "nettle_twofish_decrypt");
    }
    }
  }
  {
  {
#line 416
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 416
    if (! length) {
#line 416
      goto while_break;
    }
#line 422
    i = 0;
    {
    {
#line 422
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 422
      if (! (i < 4)) {
#line 422
        goto while_break___0;
      }
#line 423
      words[i] = ((((uint32_t )*(ciphertext + 3) << 24) | ((uint32_t )*(ciphertext + 2) << 16)) | ((uint32_t )*(ciphertext + 1) << 8)) | (uint32_t )*(ciphertext + 0);
#line 422
      i ++;
#line 422
      ciphertext += 4;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 425
    r0 = words[2] ^ *(keys + 6);
#line 426
    r1 = words[3] ^ *(keys + 7);
#line 427
    r2 = words[0] ^ *(keys + 4);
#line 428
    r3 = words[1] ^ *(keys + 5);
#line 430
    i = 0;
    {
    {
#line 430
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;

#line 430
      if (! (i < 8)) {
#line 430
        goto while_break___1;
      }
#line 431
      t1 = (((*(s_box + 1))[r3 & 255U] ^ (*(s_box + 2))[(r3 >> 8) & 255U]) ^ (*(s_box + 3))[(r3 >> 16) & 255U]) ^ (*(s_box + 0))[(r3 >> 24) & 255U];
#line 435
      t0 = ((((*(s_box + 0))[r2 & 255U] ^ (*(s_box + 1))[(r2 >> 8) & 255U]) ^ (*(s_box + 2))[(r2 >> 16) & 255U]) ^ (*(s_box + 3))[(r2 >> 24) & 255U]) + t1;
#line 439
      r1 = ((t1 + t0) + *(keys + (39 - 4 * i))) ^ r1;
#line 440
      r1 = (r1 >> 1) | ((r1 & 1U) << 31);
#line 441
      r0 = (t0 + *(keys + (38 - 4 * i))) ^ ((r0 << 1) | ((r0 & 2147483648U) >> 31));
#line 443
      t1 = (((*(s_box + 1))[r1 & 255U] ^ (*(s_box + 2))[(r1 >> 8) & 255U]) ^ (*(s_box + 3))[(r1 >> 16) & 255U]) ^ (*(s_box + 0))[(r1 >> 24) & 255U];
#line 447
      t0 = ((((*(s_box + 0))[r0 & 255U] ^ (*(s_box + 1))[(r0 >> 8) & 255U]) ^ (*(s_box + 2))[(r0 >> 16) & 255U]) ^ (*(s_box + 3))[(r0 >> 24) & 255U]) + t1;
#line 451
      r3 = ((t1 + t0) + *(keys + (37 - 4 * i))) ^ r3;
#line 452
      r3 = (r3 >> 1) | ((r3 & 1U) << 31);
#line 453
      r2 = (t0 + *(keys + (36 - 4 * i))) ^ ((r2 << 1) | ((r2 & 2147483648U) >> 31));
#line 430
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
#line 456
    words[0] = r0 ^ *(keys + 0);
#line 457
    words[1] = r1 ^ *(keys + 1);
#line 458
    words[2] = r2 ^ *(keys + 2);
#line 459
    words[3] = r3 ^ *(keys + 3);
#line 461
    i = 0;
    {
    {
#line 461
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;

#line 461
      if (! (i < 4)) {
#line 461
        goto while_break___2;
      }
      {
      {
#line 462
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 462
        *(plaintext + 3) = (uint8_t )((words[i] >> 24) & 255U);
#line 462
        *(plaintext + 2) = (uint8_t )((words[i] >> 16) & 255U);
#line 462
        *(plaintext + 1) = (uint8_t )((words[i] >> 8) & 255U);
#line 462
        *(plaintext + 0) = (uint8_t )(words[i] & 255U);
#line 462
        goto while_break___3;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 461
      i ++;
#line 461
      plaintext += 4;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 416
    length -= 16U;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 464
  return;
}
}
#line 108 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_cipher  const  nettle_twofish128 ;
#line 109
struct nettle_cipher  const  nettle_twofish192 ;
#line 110
struct nettle_cipher  const  nettle_twofish256 ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish-meta.c"
struct nettle_cipher  const  nettle_twofish128  = 
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish-meta.c"
     {"twofish128", (unsigned int )sizeof(struct twofish_ctx ), 16U, 16U, (void (*)(void *ctx ,
                                                                                  unsigned int length ,
                                                                                  uint8_t const   *key ))(& nettle_twofish_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_twofish_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_twofish_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_twofish_decrypt)};
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish-meta.c"
struct nettle_cipher  const  nettle_twofish192  = 
#line 34
     {"twofish192", (unsigned int )sizeof(struct twofish_ctx ), 16U, 24U, (void (*)(void *ctx ,
                                                                                  unsigned int length ,
                                                                                  uint8_t const   *key ))(& nettle_twofish_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_twofish_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_twofish_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_twofish_decrypt)};
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/twofish-meta.c"
struct nettle_cipher  const  nettle_twofish256  = 
#line 37
     {"twofish256", (unsigned int )sizeof(struct twofish_ctx ), 16U, 32U, (void (*)(void *ctx ,
                                                                                  unsigned int length ,
                                                                                  uint8_t const   *key ))(& nettle_twofish_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_twofish_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_twofish_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_twofish_decrypt)};
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha256.c"
static uint32_t const   K[64]  = 
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha256.c"
  {      (uint32_t const   )1116352408UL,      (uint32_t const   )1899447441UL,      (uint32_t const   )3049323471UL,      (uint32_t const   )3921009573UL, 
        (uint32_t const   )961987163UL,      (uint32_t const   )1508970993UL,      (uint32_t const   )2453635748UL,      (uint32_t const   )2870763221UL, 
        (uint32_t const   )3624381080UL,      (uint32_t const   )310598401UL,      (uint32_t const   )607225278UL,      (uint32_t const   )1426881987UL, 
        (uint32_t const   )1925078388UL,      (uint32_t const   )2162078206UL,      (uint32_t const   )2614888103UL,      (uint32_t const   )3248222580UL, 
        (uint32_t const   )3835390401UL,      (uint32_t const   )4022224774UL,      (uint32_t const   )264347078UL,      (uint32_t const   )604807628UL, 
        (uint32_t const   )770255983UL,      (uint32_t const   )1249150122UL,      (uint32_t const   )1555081692UL,      (uint32_t const   )1996064986UL, 
        (uint32_t const   )2554220882UL,      (uint32_t const   )2821834349UL,      (uint32_t const   )2952996808UL,      (uint32_t const   )3210313671UL, 
        (uint32_t const   )3336571891UL,      (uint32_t const   )3584528711UL,      (uint32_t const   )113926993UL,      (uint32_t const   )338241895UL, 
        (uint32_t const   )666307205UL,      (uint32_t const   )773529912UL,      (uint32_t const   )1294757372UL,      (uint32_t const   )1396182291UL, 
        (uint32_t const   )1695183700UL,      (uint32_t const   )1986661051UL,      (uint32_t const   )2177026350UL,      (uint32_t const   )2456956037UL, 
        (uint32_t const   )2730485921UL,      (uint32_t const   )2820302411UL,      (uint32_t const   )3259730800UL,      (uint32_t const   )3345764771UL, 
        (uint32_t const   )3516065817UL,      (uint32_t const   )3600352804UL,      (uint32_t const   )4094571909UL,      (uint32_t const   )275423344UL, 
        (uint32_t const   )430227734UL,      (uint32_t const   )506948616UL,      (uint32_t const   )659060556UL,      (uint32_t const   )883997877UL, 
        (uint32_t const   )958139571UL,      (uint32_t const   )1322822218UL,      (uint32_t const   )1537002063UL,      (uint32_t const   )1747873779UL, 
        (uint32_t const   )1955562222UL,      (uint32_t const   )2024104815UL,      (uint32_t const   )2227730452UL,      (uint32_t const   )2361852424UL, 
        (uint32_t const   )2428436474UL,      (uint32_t const   )2756734187UL,      (uint32_t const   )3204031479UL,      (uint32_t const   )3329325298UL};
#line 136 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha256.c"
static uint32_t const   H0[8]  = 
#line 136
  {      (uint32_t const   )1779033703UL,      (uint32_t const   )3144134277UL,      (uint32_t const   )1013904242UL,      (uint32_t const   )2773480762UL, 
        (uint32_t const   )1359893119UL,      (uint32_t const   )2600822924UL,      (uint32_t const   )528734635UL,      (uint32_t const   )1541459225UL};
#line 132 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha256.c"
void nettle_sha256_init(struct sha256_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 142
  memcpy((void */* __restrict  */)((void *)(ctx->state)), (void const   */* __restrict  */)((void const   *)(H0)),
         (size_t )sizeof(H0));
  }
#line 145
  tmp = (uint32_t )0;
#line 145
  ctx->count_high = tmp;
#line 145
  ctx->count_low = tmp;
#line 148
  ctx->index = 0U;
  }
#line 149
  return;
}
}
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha256.c"
static void sha256_transform(uint32_t *state , uint32_t *data ) 
{ 
  uint32_t A ;
  uint32_t B ;
  uint32_t C ;
  uint32_t D ;
  uint32_t E ;
  uint32_t F ;
  uint32_t G ;
  uint32_t H ;
  unsigned int i ;
  uint32_t const   *k ;
  uint32_t *d ;
  uint32_t T1 ;
  uint32_t T2 ;
  uint32_t T1___0 ;
  uint32_t T2___0 ;
  uint32_t T1___1 ;
  uint32_t T2___1 ;
  uint32_t T1___2 ;
  uint32_t T2___2 ;
  uint32_t T1___3 ;
  uint32_t T2___3 ;
  uint32_t T1___4 ;
  uint32_t T2___4 ;
  uint32_t T1___5 ;
  uint32_t T2___5 ;
  uint32_t T1___6 ;
  uint32_t T2___6 ;
  uint32_t T1___7 ;
  uint32_t tmp ;
  uint32_t T2___7 ;
  uint32_t T1___8 ;
  uint32_t tmp___0 ;
  uint32_t T2___8 ;
  uint32_t T1___9 ;
  uint32_t tmp___1 ;
  uint32_t T2___9 ;
  uint32_t T1___10 ;
  uint32_t tmp___2 ;
  uint32_t T2___10 ;
  uint32_t T1___11 ;
  uint32_t tmp___3 ;
  uint32_t T2___11 ;
  uint32_t T1___12 ;
  uint32_t tmp___4 ;
  uint32_t T2___12 ;
  uint32_t T1___13 ;
  uint32_t tmp___5 ;
  uint32_t T2___13 ;
  uint32_t T1___14 ;
  uint32_t tmp___6 ;
  uint32_t T2___14 ;
  uint32_t T1___15 ;
  uint32_t tmp___7 ;
  uint32_t T2___15 ;
  uint32_t T1___16 ;
  uint32_t tmp___8 ;
  uint32_t T2___16 ;
  uint32_t T1___17 ;
  uint32_t tmp___9 ;
  uint32_t T2___17 ;
  uint32_t T1___18 ;
  uint32_t tmp___10 ;
  uint32_t T2___18 ;
  uint32_t T1___19 ;
  uint32_t tmp___11 ;
  uint32_t T2___19 ;
  uint32_t T1___20 ;
  uint32_t tmp___12 ;
  uint32_t T2___20 ;
  uint32_t T1___21 ;
  uint32_t tmp___13 ;
  uint32_t T2___21 ;
  uint32_t T1___22 ;
  uint32_t tmp___14 ;
  uint32_t T2___22 ;

  {
#line 167
  A = *(state + 0);
#line 168
  B = *(state + 1);
#line 169
  C = *(state + 2);
#line 170
  D = *(state + 3);
#line 171
  E = *(state + 4);
#line 172
  F = *(state + 5);
#line 173
  G = *(state + 6);
#line 174
  H = *(state + 7);
#line 179
  i = 0U;
#line 179
  k = K;
#line 179
  d = data;
  {
  {
#line 179
  while (1) {
    while_continue___25: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 179
    if (! (i < 16U)) {
#line 179
      goto while_break;
    }
    {
    {
#line 181
    while (1) {
      while_continue___26: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 181
      T1 = (((H + ((((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21))) ^ ((E >> 25) | (E << 7)))) + (G ^ (E & (F ^ G)))) + (uint32_t )*(k + 0)) + *(d + 0);
#line 181
      T2 = ((((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19))) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (C & (A ^ B)));
#line 181
      D += T1;
#line 181
      H = T1 + T2;
#line 181
      goto while_break___0;
    }
    while_break___52: /* CIL Label */ ;
    }
    while_break___26: /* CIL Label */ ;
    }
    while_break___0: ;
    {
    {
#line 182
    while (1) {
      while_continue___27: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 182
      T1___0 = (((G + ((((D >> 6) | (D << 26)) ^ ((D >> 11) | (D << 21))) ^ ((D >> 25) | (D << 7)))) + (F ^ (D & (E ^ F)))) + (uint32_t )*(k + 1)) + *(d + 1);
#line 182
      T2___0 = ((((H >> 2) | (H << 30)) ^ ((H >> 13) | (H << 19))) ^ ((H >> 22) | (H << 10))) + ((H & A) ^ (B & (H ^ A)));
#line 182
      C += T1___0;
#line 182
      G = T1___0 + T2___0;
#line 182
      goto while_break___1;
    }
    while_break___53: /* CIL Label */ ;
    }
    while_break___27: /* CIL Label */ ;
    }
    while_break___1: ;
    {
    {
#line 183
    while (1) {
      while_continue___28: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 183
      T1___1 = (((F + ((((C >> 6) | (C << 26)) ^ ((C >> 11) | (C << 21))) ^ ((C >> 25) | (C << 7)))) + (E ^ (C & (D ^ E)))) + (uint32_t )*(k + 2)) + *(d + 2);
#line 183
      T2___1 = ((((G >> 2) | (G << 30)) ^ ((G >> 13) | (G << 19))) ^ ((G >> 22) | (G << 10))) + ((G & H) ^ (A & (G ^ H)));
#line 183
      B += T1___1;
#line 183
      F = T1___1 + T2___1;
#line 183
      goto while_break___2;
    }
    while_break___54: /* CIL Label */ ;
    }
    while_break___28: /* CIL Label */ ;
    }
    while_break___2: ;
    {
    {
#line 184
    while (1) {
      while_continue___29: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 184
      T1___2 = (((E + ((((B >> 6) | (B << 26)) ^ ((B >> 11) | (B << 21))) ^ ((B >> 25) | (B << 7)))) + (D ^ (B & (C ^ D)))) + (uint32_t )*(k + 3)) + *(d + 3);
#line 184
      T2___2 = ((((F >> 2) | (F << 30)) ^ ((F >> 13) | (F << 19))) ^ ((F >> 22) | (F << 10))) + ((F & G) ^ (H & (F ^ G)));
#line 184
      A += T1___2;
#line 184
      E = T1___2 + T2___2;
#line 184
      goto while_break___3;
    }
    while_break___55: /* CIL Label */ ;
    }
    while_break___29: /* CIL Label */ ;
    }
    while_break___3: ;
    {
    {
#line 185
    while (1) {
      while_continue___30: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 185
      T1___3 = (((D + ((((A >> 6) | (A << 26)) ^ ((A >> 11) | (A << 21))) ^ ((A >> 25) | (A << 7)))) + (C ^ (A & (B ^ C)))) + (uint32_t )*(k + 4)) + *(d + 4);
#line 185
      T2___3 = ((((E >> 2) | (E << 30)) ^ ((E >> 13) | (E << 19))) ^ ((E >> 22) | (E << 10))) + ((E & F) ^ (G & (E ^ F)));
#line 185
      H += T1___3;
#line 185
      D = T1___3 + T2___3;
#line 185
      goto while_break___4;
    }
    while_break___56: /* CIL Label */ ;
    }
    while_break___30: /* CIL Label */ ;
    }
    while_break___4: ;
    {
    {
#line 186
    while (1) {
      while_continue___31: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 186
      T1___4 = (((C + ((((H >> 6) | (H << 26)) ^ ((H >> 11) | (H << 21))) ^ ((H >> 25) | (H << 7)))) + (B ^ (H & (A ^ B)))) + (uint32_t )*(k + 5)) + *(d + 5);
#line 186
      T2___4 = ((((D >> 2) | (D << 30)) ^ ((D >> 13) | (D << 19))) ^ ((D >> 22) | (D << 10))) + ((D & E) ^ (F & (D ^ E)));
#line 186
      G += T1___4;
#line 186
      C = T1___4 + T2___4;
#line 186
      goto while_break___5;
    }
    while_break___57: /* CIL Label */ ;
    }
    while_break___31: /* CIL Label */ ;
    }
    while_break___5: ;
    {
    {
#line 187
    while (1) {
      while_continue___32: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 187
      T1___5 = (((B + ((((G >> 6) | (G << 26)) ^ ((G >> 11) | (G << 21))) ^ ((G >> 25) | (G << 7)))) + (A ^ (G & (H ^ A)))) + (uint32_t )*(k + 6)) + *(d + 6);
#line 187
      T2___5 = ((((C >> 2) | (C << 30)) ^ ((C >> 13) | (C << 19))) ^ ((C >> 22) | (C << 10))) + ((C & D) ^ (E & (C ^ D)));
#line 187
      F += T1___5;
#line 187
      B = T1___5 + T2___5;
#line 187
      goto while_break___6;
    }
    while_break___58: /* CIL Label */ ;
    }
    while_break___32: /* CIL Label */ ;
    }
    while_break___6: ;
    {
    {
#line 188
    while (1) {
      while_continue___33: /* CIL Label */ ;
      while_continue___7: /* CIL Label */ ;
#line 188
      T1___6 = (((A + ((((F >> 6) | (F << 26)) ^ ((F >> 11) | (F << 21))) ^ ((F >> 25) | (F << 7)))) + (H ^ (F & (G ^ H)))) + (uint32_t )*(k + 7)) + *(d + 7);
#line 188
      T2___6 = ((((B >> 2) | (B << 30)) ^ ((B >> 13) | (B << 19))) ^ ((B >> 22) | (B << 10))) + ((B & C) ^ (D & (B ^ C)));
#line 188
      E += T1___6;
#line 188
      A = T1___6 + T2___6;
#line 188
      goto while_break___7;
    }
    while_break___59: /* CIL Label */ ;
    }
    while_break___33: /* CIL Label */ ;
    }
    while_break___7: 
#line 179
    i += 8U;
#line 179
    k += 8;
#line 179
    d += 8;
  }
  while_break___51: /* CIL Label */ ;
  }
  while_break___25: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 191
  while (1) {
    while_continue___34: /* CIL Label */ ;
    while_continue___8: /* CIL Label */ ;

#line 191
    if (! (i < 64U)) {
#line 191
      goto while_break___8;
    }
    {
    {
#line 193
    while (1) {
      while_continue___35: /* CIL Label */ ;
      while_continue___9: /* CIL Label */ ;
#line 193
      tmp = *(data + 0) + ((((((*(data + 14) >> 17) | (*(data + 14) << 15)) ^ ((*(data + 14) >> 19) | (*(data + 14) << 13))) ^ (*(data + 14) >> 10)) + *(data + 9)) + ((((*(data + 1) >> 7) | (*(data + 1) << 25)) ^ ((*(data + 1) >> 18) | (*(data + 1) << 14))) ^ (*(data + 1) >> 3)));
#line 193
      *(data + 0) = tmp;
#line 193
      T1___7 = (((H + ((((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21))) ^ ((E >> 25) | (E << 7)))) + (G ^ (E & (F ^ G)))) + (uint32_t )*(k + 0)) + tmp;
#line 193
      T2___7 = ((((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19))) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (C & (A ^ B)));
#line 193
      D += T1___7;
#line 193
      H = T1___7 + T2___7;
#line 193
      goto while_break___9;
    }
    while_break___61: /* CIL Label */ ;
    }
    while_break___35: /* CIL Label */ ;
    }
    while_break___9: ;
    {
    {
#line 194
    while (1) {
      while_continue___36: /* CIL Label */ ;
      while_continue___10: /* CIL Label */ ;
#line 194
      tmp___0 = *(data + 1) + ((((((*(data + 15) >> 17) | (*(data + 15) << 15)) ^ ((*(data + 15) >> 19) | (*(data + 15) << 13))) ^ (*(data + 15) >> 10)) + *(data + 10)) + ((((*(data + 2) >> 7) | (*(data + 2) << 25)) ^ ((*(data + 2) >> 18) | (*(data + 2) << 14))) ^ (*(data + 2) >> 3)));
#line 194
      *(data + 1) = tmp___0;
#line 194
      T1___8 = (((G + ((((D >> 6) | (D << 26)) ^ ((D >> 11) | (D << 21))) ^ ((D >> 25) | (D << 7)))) + (F ^ (D & (E ^ F)))) + (uint32_t )*(k + 1)) + tmp___0;
#line 194
      T2___8 = ((((H >> 2) | (H << 30)) ^ ((H >> 13) | (H << 19))) ^ ((H >> 22) | (H << 10))) + ((H & A) ^ (B & (H ^ A)));
#line 194
      C += T1___8;
#line 194
      G = T1___8 + T2___8;
#line 194
      goto while_break___10;
    }
    while_break___62: /* CIL Label */ ;
    }
    while_break___36: /* CIL Label */ ;
    }
    while_break___10: ;
    {
    {
#line 195
    while (1) {
      while_continue___37: /* CIL Label */ ;
      while_continue___11: /* CIL Label */ ;
#line 195
      tmp___1 = *(data + 2) + ((((((*(data + 0) >> 17) | (*(data + 0) << 15)) ^ ((*(data + 0) >> 19) | (*(data + 0) << 13))) ^ (*(data + 0) >> 10)) + *(data + 11)) + ((((*(data + 3) >> 7) | (*(data + 3) << 25)) ^ ((*(data + 3) >> 18) | (*(data + 3) << 14))) ^ (*(data + 3) >> 3)));
#line 195
      *(data + 2) = tmp___1;
#line 195
      T1___9 = (((F + ((((C >> 6) | (C << 26)) ^ ((C >> 11) | (C << 21))) ^ ((C >> 25) | (C << 7)))) + (E ^ (C & (D ^ E)))) + (uint32_t )*(k + 2)) + tmp___1;
#line 195
      T2___9 = ((((G >> 2) | (G << 30)) ^ ((G >> 13) | (G << 19))) ^ ((G >> 22) | (G << 10))) + ((G & H) ^ (A & (G ^ H)));
#line 195
      B += T1___9;
#line 195
      F = T1___9 + T2___9;
#line 195
      goto while_break___11;
    }
    while_break___63: /* CIL Label */ ;
    }
    while_break___37: /* CIL Label */ ;
    }
    while_break___11: ;
    {
    {
#line 196
    while (1) {
      while_continue___38: /* CIL Label */ ;
      while_continue___12: /* CIL Label */ ;
#line 196
      tmp___2 = *(data + 3) + ((((((*(data + 1) >> 17) | (*(data + 1) << 15)) ^ ((*(data + 1) >> 19) | (*(data + 1) << 13))) ^ (*(data + 1) >> 10)) + *(data + 12)) + ((((*(data + 4) >> 7) | (*(data + 4) << 25)) ^ ((*(data + 4) >> 18) | (*(data + 4) << 14))) ^ (*(data + 4) >> 3)));
#line 196
      *(data + 3) = tmp___2;
#line 196
      T1___10 = (((E + ((((B >> 6) | (B << 26)) ^ ((B >> 11) | (B << 21))) ^ ((B >> 25) | (B << 7)))) + (D ^ (B & (C ^ D)))) + (uint32_t )*(k + 3)) + tmp___2;
#line 196
      T2___10 = ((((F >> 2) | (F << 30)) ^ ((F >> 13) | (F << 19))) ^ ((F >> 22) | (F << 10))) + ((F & G) ^ (H & (F ^ G)));
#line 196
      A += T1___10;
#line 196
      E = T1___10 + T2___10;
#line 196
      goto while_break___12;
    }
    while_break___64: /* CIL Label */ ;
    }
    while_break___38: /* CIL Label */ ;
    }
    while_break___12: ;
    {
    {
#line 197
    while (1) {
      while_continue___39: /* CIL Label */ ;
      while_continue___13: /* CIL Label */ ;
#line 197
      tmp___3 = *(data + 4) + ((((((*(data + 2) >> 17) | (*(data + 2) << 15)) ^ ((*(data + 2) >> 19) | (*(data + 2) << 13))) ^ (*(data + 2) >> 10)) + *(data + 13)) + ((((*(data + 5) >> 7) | (*(data + 5) << 25)) ^ ((*(data + 5) >> 18) | (*(data + 5) << 14))) ^ (*(data + 5) >> 3)));
#line 197
      *(data + 4) = tmp___3;
#line 197
      T1___11 = (((D + ((((A >> 6) | (A << 26)) ^ ((A >> 11) | (A << 21))) ^ ((A >> 25) | (A << 7)))) + (C ^ (A & (B ^ C)))) + (uint32_t )*(k + 4)) + tmp___3;
#line 197
      T2___11 = ((((E >> 2) | (E << 30)) ^ ((E >> 13) | (E << 19))) ^ ((E >> 22) | (E << 10))) + ((E & F) ^ (G & (E ^ F)));
#line 197
      H += T1___11;
#line 197
      D = T1___11 + T2___11;
#line 197
      goto while_break___13;
    }
    while_break___65: /* CIL Label */ ;
    }
    while_break___39: /* CIL Label */ ;
    }
    while_break___13: ;
    {
    {
#line 198
    while (1) {
      while_continue___40: /* CIL Label */ ;
      while_continue___14: /* CIL Label */ ;
#line 198
      tmp___4 = *(data + 5) + ((((((*(data + 3) >> 17) | (*(data + 3) << 15)) ^ ((*(data + 3) >> 19) | (*(data + 3) << 13))) ^ (*(data + 3) >> 10)) + *(data + 14)) + ((((*(data + 6) >> 7) | (*(data + 6) << 25)) ^ ((*(data + 6) >> 18) | (*(data + 6) << 14))) ^ (*(data + 6) >> 3)));
#line 198
      *(data + 5) = tmp___4;
#line 198
      T1___12 = (((C + ((((H >> 6) | (H << 26)) ^ ((H >> 11) | (H << 21))) ^ ((H >> 25) | (H << 7)))) + (B ^ (H & (A ^ B)))) + (uint32_t )*(k + 5)) + tmp___4;
#line 198
      T2___12 = ((((D >> 2) | (D << 30)) ^ ((D >> 13) | (D << 19))) ^ ((D >> 22) | (D << 10))) + ((D & E) ^ (F & (D ^ E)));
#line 198
      G += T1___12;
#line 198
      C = T1___12 + T2___12;
#line 198
      goto while_break___14;
    }
    while_break___66: /* CIL Label */ ;
    }
    while_break___40: /* CIL Label */ ;
    }
    while_break___14: ;
    {
    {
#line 199
    while (1) {
      while_continue___41: /* CIL Label */ ;
      while_continue___15: /* CIL Label */ ;
#line 199
      tmp___5 = *(data + 6) + ((((((*(data + 4) >> 17) | (*(data + 4) << 15)) ^ ((*(data + 4) >> 19) | (*(data + 4) << 13))) ^ (*(data + 4) >> 10)) + *(data + 15)) + ((((*(data + 7) >> 7) | (*(data + 7) << 25)) ^ ((*(data + 7) >> 18) | (*(data + 7) << 14))) ^ (*(data + 7) >> 3)));
#line 199
      *(data + 6) = tmp___5;
#line 199
      T1___13 = (((B + ((((G >> 6) | (G << 26)) ^ ((G >> 11) | (G << 21))) ^ ((G >> 25) | (G << 7)))) + (A ^ (G & (H ^ A)))) + (uint32_t )*(k + 6)) + tmp___5;
#line 199
      T2___13 = ((((C >> 2) | (C << 30)) ^ ((C >> 13) | (C << 19))) ^ ((C >> 22) | (C << 10))) + ((C & D) ^ (E & (C ^ D)));
#line 199
      F += T1___13;
#line 199
      B = T1___13 + T2___13;
#line 199
      goto while_break___15;
    }
    while_break___67: /* CIL Label */ ;
    }
    while_break___41: /* CIL Label */ ;
    }
    while_break___15: ;
    {
    {
#line 200
    while (1) {
      while_continue___42: /* CIL Label */ ;
      while_continue___16: /* CIL Label */ ;
#line 200
      tmp___6 = *(data + 7) + ((((((*(data + 5) >> 17) | (*(data + 5) << 15)) ^ ((*(data + 5) >> 19) | (*(data + 5) << 13))) ^ (*(data + 5) >> 10)) + *(data + 0)) + ((((*(data + 8) >> 7) | (*(data + 8) << 25)) ^ ((*(data + 8) >> 18) | (*(data + 8) << 14))) ^ (*(data + 8) >> 3)));
#line 200
      *(data + 7) = tmp___6;
#line 200
      T1___14 = (((A + ((((F >> 6) | (F << 26)) ^ ((F >> 11) | (F << 21))) ^ ((F >> 25) | (F << 7)))) + (H ^ (F & (G ^ H)))) + (uint32_t )*(k + 7)) + tmp___6;
#line 200
      T2___14 = ((((B >> 2) | (B << 30)) ^ ((B >> 13) | (B << 19))) ^ ((B >> 22) | (B << 10))) + ((B & C) ^ (D & (B ^ C)));
#line 200
      E += T1___14;
#line 200
      A = T1___14 + T2___14;
#line 200
      goto while_break___16;
    }
    while_break___68: /* CIL Label */ ;
    }
    while_break___42: /* CIL Label */ ;
    }
    while_break___16: ;
    {
    {
#line 201
    while (1) {
      while_continue___43: /* CIL Label */ ;
      while_continue___17: /* CIL Label */ ;
#line 201
      tmp___7 = *(data + 8) + ((((((*(data + 6) >> 17) | (*(data + 6) << 15)) ^ ((*(data + 6) >> 19) | (*(data + 6) << 13))) ^ (*(data + 6) >> 10)) + *(data + 1)) + ((((*(data + 9) >> 7) | (*(data + 9) << 25)) ^ ((*(data + 9) >> 18) | (*(data + 9) << 14))) ^ (*(data + 9) >> 3)));
#line 201
      *(data + 8) = tmp___7;
#line 201
      T1___15 = (((H + ((((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21))) ^ ((E >> 25) | (E << 7)))) + (G ^ (E & (F ^ G)))) + (uint32_t )*(k + 8)) + tmp___7;
#line 201
      T2___15 = ((((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19))) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (C & (A ^ B)));
#line 201
      D += T1___15;
#line 201
      H = T1___15 + T2___15;
#line 201
      goto while_break___17;
    }
    while_break___69: /* CIL Label */ ;
    }
    while_break___43: /* CIL Label */ ;
    }
    while_break___17: ;
    {
    {
#line 202
    while (1) {
      while_continue___44: /* CIL Label */ ;
      while_continue___18: /* CIL Label */ ;
#line 202
      tmp___8 = *(data + 9) + ((((((*(data + 7) >> 17) | (*(data + 7) << 15)) ^ ((*(data + 7) >> 19) | (*(data + 7) << 13))) ^ (*(data + 7) >> 10)) + *(data + 2)) + ((((*(data + 10) >> 7) | (*(data + 10) << 25)) ^ ((*(data + 10) >> 18) | (*(data + 10) << 14))) ^ (*(data + 10) >> 3)));
#line 202
      *(data + 9) = tmp___8;
#line 202
      T1___16 = (((G + ((((D >> 6) | (D << 26)) ^ ((D >> 11) | (D << 21))) ^ ((D >> 25) | (D << 7)))) + (F ^ (D & (E ^ F)))) + (uint32_t )*(k + 9)) + tmp___8;
#line 202
      T2___16 = ((((H >> 2) | (H << 30)) ^ ((H >> 13) | (H << 19))) ^ ((H >> 22) | (H << 10))) + ((H & A) ^ (B & (H ^ A)));
#line 202
      C += T1___16;
#line 202
      G = T1___16 + T2___16;
#line 202
      goto while_break___18;
    }
    while_break___70: /* CIL Label */ ;
    }
    while_break___44: /* CIL Label */ ;
    }
    while_break___18: ;
    {
    {
#line 203
    while (1) {
      while_continue___45: /* CIL Label */ ;
      while_continue___19: /* CIL Label */ ;
#line 203
      tmp___9 = *(data + 10) + ((((((*(data + 8) >> 17) | (*(data + 8) << 15)) ^ ((*(data + 8) >> 19) | (*(data + 8) << 13))) ^ (*(data + 8) >> 10)) + *(data + 3)) + ((((*(data + 11) >> 7) | (*(data + 11) << 25)) ^ ((*(data + 11) >> 18) | (*(data + 11) << 14))) ^ (*(data + 11) >> 3)));
#line 203
      *(data + 10) = tmp___9;
#line 203
      T1___17 = (((F + ((((C >> 6) | (C << 26)) ^ ((C >> 11) | (C << 21))) ^ ((C >> 25) | (C << 7)))) + (E ^ (C & (D ^ E)))) + (uint32_t )*(k + 10)) + tmp___9;
#line 203
      T2___17 = ((((G >> 2) | (G << 30)) ^ ((G >> 13) | (G << 19))) ^ ((G >> 22) | (G << 10))) + ((G & H) ^ (A & (G ^ H)));
#line 203
      B += T1___17;
#line 203
      F = T1___17 + T2___17;
#line 203
      goto while_break___19;
    }
    while_break___71: /* CIL Label */ ;
    }
    while_break___45: /* CIL Label */ ;
    }
    while_break___19: ;
    {
    {
#line 204
    while (1) {
      while_continue___46: /* CIL Label */ ;
      while_continue___20: /* CIL Label */ ;
#line 204
      tmp___10 = *(data + 11) + ((((((*(data + 9) >> 17) | (*(data + 9) << 15)) ^ ((*(data + 9) >> 19) | (*(data + 9) << 13))) ^ (*(data + 9) >> 10)) + *(data + 4)) + ((((*(data + 12) >> 7) | (*(data + 12) << 25)) ^ ((*(data + 12) >> 18) | (*(data + 12) << 14))) ^ (*(data + 12) >> 3)));
#line 204
      *(data + 11) = tmp___10;
#line 204
      T1___18 = (((E + ((((B >> 6) | (B << 26)) ^ ((B >> 11) | (B << 21))) ^ ((B >> 25) | (B << 7)))) + (D ^ (B & (C ^ D)))) + (uint32_t )*(k + 11)) + tmp___10;
#line 204
      T2___18 = ((((F >> 2) | (F << 30)) ^ ((F >> 13) | (F << 19))) ^ ((F >> 22) | (F << 10))) + ((F & G) ^ (H & (F ^ G)));
#line 204
      A += T1___18;
#line 204
      E = T1___18 + T2___18;
#line 204
      goto while_break___20;
    }
    while_break___72: /* CIL Label */ ;
    }
    while_break___46: /* CIL Label */ ;
    }
    while_break___20: ;
    {
    {
#line 205
    while (1) {
      while_continue___47: /* CIL Label */ ;
      while_continue___21: /* CIL Label */ ;
#line 205
      tmp___11 = *(data + 12) + ((((((*(data + 10) >> 17) | (*(data + 10) << 15)) ^ ((*(data + 10) >> 19) | (*(data + 10) << 13))) ^ (*(data + 10) >> 10)) + *(data + 5)) + ((((*(data + 13) >> 7) | (*(data + 13) << 25)) ^ ((*(data + 13) >> 18) | (*(data + 13) << 14))) ^ (*(data + 13) >> 3)));
#line 205
      *(data + 12) = tmp___11;
#line 205
      T1___19 = (((D + ((((A >> 6) | (A << 26)) ^ ((A >> 11) | (A << 21))) ^ ((A >> 25) | (A << 7)))) + (C ^ (A & (B ^ C)))) + (uint32_t )*(k + 12)) + tmp___11;
#line 205
      T2___19 = ((((E >> 2) | (E << 30)) ^ ((E >> 13) | (E << 19))) ^ ((E >> 22) | (E << 10))) + ((E & F) ^ (G & (E ^ F)));
#line 205
      H += T1___19;
#line 205
      D = T1___19 + T2___19;
#line 205
      goto while_break___21;
    }
    while_break___73: /* CIL Label */ ;
    }
    while_break___47: /* CIL Label */ ;
    }
    while_break___21: ;
    {
    {
#line 206
    while (1) {
      while_continue___48: /* CIL Label */ ;
      while_continue___22: /* CIL Label */ ;
#line 206
      tmp___12 = *(data + 13) + ((((((*(data + 11) >> 17) | (*(data + 11) << 15)) ^ ((*(data + 11) >> 19) | (*(data + 11) << 13))) ^ (*(data + 11) >> 10)) + *(data + 6)) + ((((*(data + 14) >> 7) | (*(data + 14) << 25)) ^ ((*(data + 14) >> 18) | (*(data + 14) << 14))) ^ (*(data + 14) >> 3)));
#line 206
      *(data + 13) = tmp___12;
#line 206
      T1___20 = (((C + ((((H >> 6) | (H << 26)) ^ ((H >> 11) | (H << 21))) ^ ((H >> 25) | (H << 7)))) + (B ^ (H & (A ^ B)))) + (uint32_t )*(k + 13)) + tmp___12;
#line 206
      T2___20 = ((((D >> 2) | (D << 30)) ^ ((D >> 13) | (D << 19))) ^ ((D >> 22) | (D << 10))) + ((D & E) ^ (F & (D ^ E)));
#line 206
      G += T1___20;
#line 206
      C = T1___20 + T2___20;
#line 206
      goto while_break___22;
    }
    while_break___74: /* CIL Label */ ;
    }
    while_break___48: /* CIL Label */ ;
    }
    while_break___22: ;
    {
    {
#line 207
    while (1) {
      while_continue___49: /* CIL Label */ ;
      while_continue___23: /* CIL Label */ ;
#line 207
      tmp___13 = *(data + 14) + ((((((*(data + 12) >> 17) | (*(data + 12) << 15)) ^ ((*(data + 12) >> 19) | (*(data + 12) << 13))) ^ (*(data + 12) >> 10)) + *(data + 7)) + ((((*(data + 15) >> 7) | (*(data + 15) << 25)) ^ ((*(data + 15) >> 18) | (*(data + 15) << 14))) ^ (*(data + 15) >> 3)));
#line 207
      *(data + 14) = tmp___13;
#line 207
      T1___21 = (((B + ((((G >> 6) | (G << 26)) ^ ((G >> 11) | (G << 21))) ^ ((G >> 25) | (G << 7)))) + (A ^ (G & (H ^ A)))) + (uint32_t )*(k + 14)) + tmp___13;
#line 207
      T2___21 = ((((C >> 2) | (C << 30)) ^ ((C >> 13) | (C << 19))) ^ ((C >> 22) | (C << 10))) + ((C & D) ^ (E & (C ^ D)));
#line 207
      F += T1___21;
#line 207
      B = T1___21 + T2___21;
#line 207
      goto while_break___23;
    }
    while_break___75: /* CIL Label */ ;
    }
    while_break___49: /* CIL Label */ ;
    }
    while_break___23: ;
    {
    {
#line 208
    while (1) {
      while_continue___50: /* CIL Label */ ;
      while_continue___24: /* CIL Label */ ;
#line 208
      tmp___14 = *(data + 15) + ((((((*(data + 13) >> 17) | (*(data + 13) << 15)) ^ ((*(data + 13) >> 19) | (*(data + 13) << 13))) ^ (*(data + 13) >> 10)) + *(data + 8)) + ((((*(data + 0) >> 7) | (*(data + 0) << 25)) ^ ((*(data + 0) >> 18) | (*(data + 0) << 14))) ^ (*(data + 0) >> 3)));
#line 208
      *(data + 15) = tmp___14;
#line 208
      T1___22 = (((A + ((((F >> 6) | (F << 26)) ^ ((F >> 11) | (F << 21))) ^ ((F >> 25) | (F << 7)))) + (H ^ (F & (G ^ H)))) + (uint32_t )*(k + 15)) + tmp___14;
#line 208
      T2___22 = ((((B >> 2) | (B << 30)) ^ ((B >> 13) | (B << 19))) ^ ((B >> 22) | (B << 10))) + ((B & C) ^ (D & (B ^ C)));
#line 208
      E += T1___22;
#line 208
      A = T1___22 + T2___22;
#line 208
      goto while_break___24;
    }
    while_break___76: /* CIL Label */ ;
    }
    while_break___50: /* CIL Label */ ;
    }
    while_break___24: 
#line 191
    i += 16U;
#line 191
    k += 16;
  }
  while_break___60: /* CIL Label */ ;
  }
  while_break___34: /* CIL Label */ ;
  }
  while_break___8: 
#line 212
  *(state + 0) += A;
#line 213
  *(state + 1) += B;
#line 214
  *(state + 2) += C;
#line 215
  *(state + 3) += D;
#line 216
  *(state + 4) += E;
#line 217
  *(state + 5) += F;
#line 218
  *(state + 6) += G;
#line 219
  *(state + 7) += H;
#line 220
  return;
}
}
#line 222 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha256.c"
static void sha256_block(struct sha256_ctx *ctx , uint8_t const   *block ) 
{ 
  uint32_t data[16] ;
  int i ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 229
  (ctx->count_low) ++;
#line 229
  if (! ctx->count_low) {
#line 230
    (ctx->count_high) ++;
  }
#line 233
  i = 0;
  {
  {
#line 233
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 233
    if (! (i < 16)) {
#line 233
      goto while_break;
    }
#line 234
    data[i] = ((((uint32_t )*(block + 0) << 24) | ((uint32_t )*(block + 1) << 16)) | ((uint32_t )*(block + 2) << 8)) | (uint32_t )*(block + 3);
#line 233
    i ++;
#line 233
    block += 4;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 236
  sha256_transform(ctx->state, data);
  }
  }
#line 237
  return;
}
}
#line 239 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha256.c"
void nettle_sha256_update(struct sha256_ctx *ctx , unsigned int length , uint8_t const   *buffer ) 
{ 
  unsigned int left ;

  {
#line 243
  if (ctx->index) {
#line 245
    left = 64U - ctx->index;
#line 246
    if (length < left) {
      {
      {
#line 248
      memcpy((void */* __restrict  */)((void *)(ctx->block + ctx->index)), (void const   */* __restrict  */)((void const   *)buffer),
             length);
      }
#line 249
      ctx->index += length;
      }
#line 250
      return;
    } else {
      {
      {
#line 254
      memcpy((void */* __restrict  */)((void *)(ctx->block + ctx->index)), (void const   */* __restrict  */)((void const   *)buffer),
             left);
      }
      {
#line 255
      sha256_block(ctx, (uint8_t const   *)(ctx->block));
      }
#line 256
      buffer += left;
#line 257
      length -= left;
      }
    }
  }
  {
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 260
    if (! (length >= 64U)) {
#line 260
      goto while_break;
    }
    {
    {
#line 262
    sha256_block(ctx, buffer);
    }
#line 263
    buffer += 64;
#line 264
    length -= 64U;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 270
  memcpy((void */* __restrict  */)((void *)(ctx->block)), (void const   */* __restrict  */)((void const   *)buffer),
         length);
  }
#line 271
  ctx->index = length;
  }
#line 272
  return;
}
}
#line 277 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha256.c"
static void sha256_final(struct sha256_ctx *ctx ) 
{ 
  uint32_t data[16] ;
  int i ;
  int words ;
  int tmp ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 284
  i = (int )ctx->index;
#line 289
  if (! (i < 64)) {
    {
    {
#line 289
    __assert_fail("i < 64", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha256.c",
                  289U, "sha256_final");
    }
    }
  }
#line 290
  tmp = i;
#line 290
  i ++;
#line 290
  ctx->block[tmp] = (uint8_t )128;
  {
  {
#line 293
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 293
    if (! (i & 3)) {
#line 293
      goto while_break;
    }
#line 294
    ctx->block[i] = (uint8_t )0;
#line 293
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 297
  words = i >> 2;
#line 298
  i = 0;
  {
  {
#line 298
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 298
    if (! (i < words)) {
#line 298
      goto while_break___0;
    }
#line 299
    data[i] = ((((uint32_t )*((ctx->block + 4 * i) + 0) << 24) | ((uint32_t )*((ctx->block + 4 * i) + 1) << 16)) | ((uint32_t )*((ctx->block + 4 * i) + 2) << 8)) | (uint32_t )*((ctx->block + 4 * i) + 3);
#line 298
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: ;
#line 301
  if (words > 14) {
#line 304
    i = words;
    {
    {
#line 304
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;

#line 304
      if (! (i < 16)) {
#line 304
        goto while_break___1;
      }
#line 305
      data[i] = (uint32_t )0;
#line 304
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
    {
    {
#line 306
    sha256_transform(ctx->state, data);
    }
#line 307
    i = 0;
    }
    {
    {
#line 307
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;

#line 307
      if (! (i < 14)) {
#line 307
        goto while_break___2;
      }
#line 308
      data[i] = (uint32_t )0;
#line 307
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
  } else {
#line 311
    i = words;
    {
    {
#line 311
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;

#line 311
      if (! (i < 14)) {
#line 311
        goto while_break___3;
      }
#line 312
      data[i] = (uint32_t )0;
#line 311
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: ;
  }
  {
#line 315
  data[14] = (ctx->count_high << 9) | (ctx->count_low >> 23);
#line 316
  data[15] = (ctx->count_low << 9) | (ctx->index << 3);
  {
#line 317
  sha256_transform(ctx->state, data);
  }
  }
#line 318
  return;
}
}
#line 320 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha256.c"
void nettle_sha256_digest(struct sha256_ctx *ctx , unsigned int length , uint8_t *digest ) 
{ 
  unsigned int i ;
  unsigned int words ;
  unsigned int leftover ;
  uint32_t word ;
  unsigned int j ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 329
  if (! (length <= 32U)) {
    {
    {
#line 329
    __assert_fail("length <= 32", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha256.c",
                  329U, "nettle_sha256_digest");
    }
    }
  }
  {
  {
#line 331
  sha256_final(ctx);
  }
#line 333
  words = length / 4U;
#line 334
  leftover = length % 4U;
#line 336
  i = 0U;
  }
  {
  {
#line 336
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 336
    if (! (i < words)) {
#line 336
      goto while_break;
    }
    {
    {
#line 337
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 337
      *(digest + 0) = (uint8_t )((ctx->state[i] >> 24) & 255U);
#line 337
      *(digest + 1) = (uint8_t )((ctx->state[i] >> 16) & 255U);
#line 337
      *(digest + 2) = (uint8_t )((ctx->state[i] >> 8) & 255U);
#line 337
      *(digest + 3) = (uint8_t )(ctx->state[i] & 255U);
#line 337
      goto while_break___0;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 336
    i ++;
#line 336
    digest += 4;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 339
  if (leftover) {
#line 342
    j = leftover;
#line 344
    if (! (i < 8U)) {
      {
      {
#line 344
      __assert_fail("i < 8", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha256.c",
                    344U, "nettle_sha256_digest");
      }
      }
    }
#line 346
    word = ctx->state[i];
#line 352
    if (leftover == 3U) {
#line 352
      goto case_3;
    }
#line 355
    if (leftover == 2U) {
#line 355
      goto case_2;
    }
#line 358
    if (leftover == 1U) {
#line 358
      goto case_1;
    }
#line 350
    goto switch_default;
    switch_default: 
    {
    {
#line 351
    abort();
    }
    }
    case_3: 
#line 353
    j --;
#line 353
    *(digest + j) = (uint8_t )((word >> 8) & 255U);
    case_2: 
#line 356
    j --;
#line 356
    *(digest + j) = (uint8_t )((word >> 16) & 255U);
    case_1: 
#line 359
    j --;
#line 359
    *(digest + j) = (uint8_t )((word >> 24) & 255U);

  }
  {
  {
#line 362
  nettle_sha256_init(ctx);
  }
  }
#line 363
  return;
}
}
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_hash  const  nettle_sha256 ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha256-meta.c"
struct nettle_hash  const  nettle_sha256  =    {"sha256", (unsigned int )sizeof(struct sha256_ctx ), 32U, 64U, (void (*)(void *ctx ))(& nettle_sha256_init),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *src ))(& nettle_sha256_update),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst ))(& nettle_sha256_digest)};
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha.h"
void nettle_sha1_init(struct sha1_ctx *ctx ) ;
#line 58
void nettle_sha1_update(struct sha1_ctx *ctx , unsigned int length , uint8_t const   *buffer ) ;
#line 63
void nettle_sha1_digest(struct sha1_ctx *ctx , unsigned int length , uint8_t *digest ) ;
#line 70
extern void _nettle_sha1_compress(uint32_t *state , uint8_t const   *data ) ;
#line 64 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha1.c"
void nettle_sha1_init(struct sha1_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 68
  ctx->digest[0] = (uint32_t )1732584193L;
#line 69
  ctx->digest[1] = (uint32_t )4023233417L;
#line 70
  ctx->digest[2] = (uint32_t )2562383102L;
#line 71
  ctx->digest[3] = (uint32_t )271733878L;
#line 72
  ctx->digest[4] = (uint32_t )3285377520L;
#line 75
  tmp = (uint32_t )0;
#line 75
  ctx->count_high = tmp;
#line 75
  ctx->count_low = tmp;
#line 78
  ctx->index = 0U;
#line 79
  return;
}
}
#line 83 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha1.c"
void nettle_sha1_update(struct sha1_ctx *ctx , unsigned int length , uint8_t const   *buffer ) 
{ 
  unsigned int left ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 87
  if (ctx->index) {
#line 89
    left = 64U - ctx->index;
#line 90
    if (length < left) {
      {
      {
#line 92
      memcpy((void */* __restrict  */)((void *)(ctx->block + ctx->index)), (void const   */* __restrict  */)((void const   *)buffer),
             length);
      }
#line 93
      ctx->index += length;
      }
#line 94
      return;
    } else {
      {
      {
#line 98
      memcpy((void */* __restrict  */)((void *)(ctx->block + ctx->index)), (void const   */* __restrict  */)((void const   *)buffer),
             left);
      }
      {
#line 100
      _nettle_sha1_compress(ctx->digest, (uint8_t const   *)(ctx->block));
      }
#line 101
      (ctx->count_low) ++;
      }
#line 101
      if (ctx->count_low) {
#line 101
        tmp = 0;
      } else {
#line 101
        tmp = 1;
      }
#line 101
      ctx->count_high += (uint32_t )tmp;
#line 103
      buffer += left;
#line 104
      length -= left;
    }
  }
  {
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 107
    if (! (length >= 64U)) {
#line 107
      goto while_break;
    }
    {
    {
#line 109
    _nettle_sha1_compress(ctx->digest, buffer);
    }
#line 110
    (ctx->count_low) ++;
    }
#line 110
    if (ctx->count_low) {
#line 110
      tmp___0 = 0;
    } else {
#line 110
      tmp___0 = 1;
    }
#line 110
    ctx->count_high += (uint32_t )tmp___0;
#line 112
    buffer += 64;
#line 113
    length -= 64U;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 115
  tmp___1 = length;
#line 115
  ctx->index = tmp___1;
#line 115
  if (tmp___1) {
    {
    {
#line 117
    memcpy((void */* __restrict  */)((void *)(ctx->block)), (void const   */* __restrict  */)((void const   *)buffer),
           length);
    }
    }
  }
#line 118
  return;
}
}
#line 123 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha1.c"
static void sha1_final(struct sha1_ctx *ctx ) 
{ 
  uint32_t bitcount_high ;
  uint32_t bitcount_low ;
  unsigned int i ;
  unsigned int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 130
  i = ctx->index;
#line 135
  if (! (i < 64U)) {
    {
    {
#line 135
    __assert_fail("i < 64", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha1.c",
                  135U, "sha1_final");
    }
    }
  }
#line 136
  tmp = i;
#line 136
  i ++;
#line 136
  ctx->block[tmp] = (uint8_t )128;
#line 138
  if (i > 56U) {
    {
    {
#line 141
    memset((void *)(ctx->block + i), 0, 64U - i);
    }
    {
#line 143
    _nettle_sha1_compress(ctx->digest, (uint8_t const   *)(ctx->block));
    }
#line 144
    i = 0U;
    }
  }
#line 146
  if (i < 56U) {
    {
    {
#line 147
    memset((void *)(ctx->block + i), 0, 56U - i);
    }
    }
  }
#line 150
  bitcount_high = (ctx->count_high << 9) | (ctx->count_low >> 23);
#line 151
  bitcount_low = (ctx->count_low << 9) | (ctx->index << 3);
  {
  {
#line 156
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 156
    *((ctx->block + 56) + 0) = (uint8_t )((bitcount_high >> 24) & 255U);
#line 156
    *((ctx->block + 56) + 1) = (uint8_t )((bitcount_high >> 16) & 255U);
#line 156
    *((ctx->block + 56) + 2) = (uint8_t )((bitcount_high >> 8) & 255U);
#line 156
    *((ctx->block + 56) + 3) = (uint8_t )(bitcount_high & 255U);
#line 156
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 157
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 157
    *((ctx->block + 60) + 0) = (uint8_t )((bitcount_low >> 24) & 255U);
#line 157
    *((ctx->block + 60) + 1) = (uint8_t )((bitcount_low >> 16) & 255U);
#line 157
    *((ctx->block + 60) + 2) = (uint8_t )((bitcount_low >> 8) & 255U);
#line 157
    *((ctx->block + 60) + 3) = (uint8_t )(bitcount_low & 255U);
#line 157
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
  {
#line 159
  _nettle_sha1_compress(ctx->digest, (uint8_t const   *)(ctx->block));
  }
  }
#line 160
  return;
}
}
#line 162 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha1.c"
void nettle_sha1_digest(struct sha1_ctx *ctx , unsigned int length , uint8_t *digest ) 
{ 
  unsigned int i ;
  unsigned int words ;
  unsigned int leftover ;
  uint32_t word ;
  unsigned int j ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 171
  if (! (length <= 20U)) {
    {
    {
#line 171
    __assert_fail("length <= 20", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha1.c",
                  171U, "nettle_sha1_digest");
    }
    }
  }
  {
  {
#line 173
  sha1_final(ctx);
  }
#line 175
  words = length / 4U;
#line 176
  leftover = length % 4U;
#line 178
  i = 0U;
  }
  {
  {
#line 178
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 178
    if (! (i < words)) {
#line 178
      goto while_break;
    }
    {
    {
#line 179
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 179
      *(digest + 0) = (uint8_t )((ctx->digest[i] >> 24) & 255U);
#line 179
      *(digest + 1) = (uint8_t )((ctx->digest[i] >> 16) & 255U);
#line 179
      *(digest + 2) = (uint8_t )((ctx->digest[i] >> 8) & 255U);
#line 179
      *(digest + 3) = (uint8_t )(ctx->digest[i] & 255U);
#line 179
      goto while_break___0;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 178
    i ++;
#line 178
    digest += 4;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 181
  if (leftover) {
#line 184
    j = leftover;
#line 186
    if (! (i < 5U)) {
      {
      {
#line 186
      __assert_fail("i < 5", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha1.c",
                    186U, "nettle_sha1_digest");
      }
      }
    }
#line 188
    word = ctx->digest[i];
#line 194
    if (leftover == 3U) {
#line 194
      goto case_3;
    }
#line 197
    if (leftover == 2U) {
#line 197
      goto case_2;
    }
#line 200
    if (leftover == 1U) {
#line 200
      goto case_1;
    }
#line 192
    goto switch_default;
    switch_default: 
    {
    {
#line 193
    abort();
    }
    }
    case_3: 
#line 195
    j --;
#line 195
    *(digest + j) = (uint8_t )((word >> 8) & 255U);
    case_2: 
#line 198
    j --;
#line 198
    *(digest + j) = (uint8_t )((word >> 16) & 255U);
    case_1: 
#line 201
    j --;
#line 201
    *(digest + j) = (uint8_t )((word >> 24) & 255U);

  }
  {
  {
#line 204
  nettle_sha1_init(ctx);
  }
  }
#line 205
  return;
}
}
#line 157 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_hash  const  nettle_sha1 ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sha1-meta.c"
struct nettle_hash  const  nettle_sha1  =    {"sha1", (unsigned int )sizeof(struct sha1_ctx ), 20U, 64U, (void (*)(void *ctx ))(& nettle_sha1_init),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *src ))(& nettle_sha1_update),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst ))(& nettle_sha1_digest)};
#line 692 "/usr/include/gmp-i386.h"
__inline extern void __gmpz_abs(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) ;
#line 856
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 861
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 866
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 892
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 897
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n )  __attribute__((__pure__)) ;
#line 996
__inline extern void __gmpz_neg(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) ;
#line 1017
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a )  __attribute__((__pure__)) ;
#line 1022
__inline extern unsigned long __gmpz_popcount(mpz_srcptr __gmp_u )  __attribute__((__pure__)) ;
#line 1065
extern void __gmpz_set(mpz_ptr  , mpz_srcptr  ) ;
#line 1075
__inline extern void __gmpz_set_q(mpz_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1092
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1126
extern void __gmpz_tdiv_q(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 1170
__inline extern void __gmpq_abs(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1231
__inline extern void __gmpq_neg(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1240
extern void __gmpq_set(mpq_ptr  , mpq_srcptr  ) ;
#line 1480
__inline extern mp_limb_t __gmpn_add(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) ;
#line 1485
__inline extern mp_limb_t __gmpn_add_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) ;
#line 1489
extern mp_limb_t __gmpn_add_n(mp_ptr  , mp_srcptr  , mp_srcptr  , mp_size_t  ) ;
#line 1499
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size )  __attribute__((__pure__)) ;
#line 1558
__inline extern mp_limb_t __gmpn_neg_n(mp_ptr __gmp_rp , mp_srcptr __gmp_up , mp_size_t __gmp_n ) ;
#line 1562
extern int __gmpn_perfect_square_p(mp_srcptr  , mp_size_t  )  __attribute__((__pure__)) ;
#line 1565
extern unsigned long __gmpn_popcount(mp_srcptr  , mp_size_t  )  __attribute__((__pure__)) ;
#line 1597
__inline extern mp_limb_t __gmpn_sub(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) ;
#line 1602
__inline extern mp_limb_t __gmpn_sub_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) ;
#line 1606
extern mp_limb_t __gmpn_sub_n(mp_ptr  , mp_srcptr  , mp_srcptr  , mp_size_t  ) ;
#line 1632 "/usr/include/gmp-i386.h"
__inline extern void __gmpz_abs(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) 
{ 


  {
#line 1635
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
    {
#line 1636
    __gmpz_set(__gmp_w, __gmp_u);
    }
    }
  }
#line 1637
  if (__gmp_w->_mp_size >= 0) {
#line 1637
    __gmp_w->_mp_size = __gmp_w->_mp_size;
  } else {
#line 1637
    __gmp_w->_mp_size = - __gmp_w->_mp_size;
  }
#line 1638
  return;
}
}
#line 1656
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1656 "/usr/include/gmp-i386.h"
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
#line 1661
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1661
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1661
  if (__gmp_n == 0L) {
#line 1661
    tmp = 1;
  } else
#line 1661
  if (__gmp_n == 1L) {
#line 1661
    if (*(__gmp_p + 0) <= 4294967295UL) {
#line 1661
      tmp = 1;
    } else {
#line 1661
      tmp = 0;
    }
  } else {
#line 1661
    tmp = 0;
  }
#line 1661
  return (tmp);
}
}
#line 1667
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1667 "/usr/include/gmp-i386.h"
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
#line 1672
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1672
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1672
  if (__gmp_n == 0L) {
#line 1672
    tmp = 1;
  } else
#line 1672
  if (__gmp_n == 1L) {
#line 1672
    if (*(__gmp_p + 0) <= 0xffffffffffffffffUL) {
#line 1672
      tmp = 1;
    } else {
#line 1672
      tmp = 0;
    }
  } else {
#line 1672
    tmp = 0;
  }
#line 1672
  return (tmp);
}
}
#line 1678
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1678 "/usr/include/gmp-i386.h"
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
#line 1683
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1683
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1683
  if (__gmp_n == 0L) {
#line 1683
    tmp = 1;
  } else
#line 1683
  if (__gmp_n == 1L) {
#line 1683
    if (*(__gmp_p + 0) <= 65535UL) {
#line 1683
      tmp = 1;
    } else {
#line 1683
      tmp = 0;
    }
  } else {
#line 1683
    tmp = 0;
  }
#line 1683
  return (tmp);
}
}
#line 1689
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1689 "/usr/include/gmp-i386.h"
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z ) 
{ 
  mp_ptr __gmp_p ;
  mp_size_t __gmp_n ;
  mp_limb_t __gmp_l ;
  mp_limb_t tmp ;

  {
#line 1694
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1695
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1696
  __gmp_l = *(__gmp_p + 0);
#line 1703
  if (__gmp_n != 0L) {
#line 1703
    tmp = __gmp_l;
  } else {
#line 1703
    tmp = (mp_limb_t )0;
  }
#line 1703
  return (tmp);
}
}
#line 1717
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n )  __attribute__((__pure__)) ;
#line 1717 "/usr/include/gmp-i386.h"
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n ) 
{ 
  mp_limb_t __gmp_result ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 1722
  __gmp_result = (mp_limb_t )0;
#line 1723
  if (__gmp_n >= 0L) {
#line 1723
    if (__gmp_z->_mp_size >= 0) {
#line 1723
      tmp = (int )__gmp_z->_mp_size;
    } else {
#line 1723
      tmp = (int )(- __gmp_z->_mp_size);
    }
#line 1723
    if (__gmp_n < (mp_size_t )tmp) {
#line 1723
      tmp___0 = 1;
    } else {
#line 1723
      tmp___0 = 0;
    }
  } else {
#line 1723
    tmp___0 = 0;
  }
  {
  {
#line 1723
  tmp___1 = __builtin_expect((long )(tmp___0 != 0), 1L);
  }
  }
#line 1723
  if (tmp___1) {
#line 1724
    __gmp_result = *(__gmp_z->_mp_d + __gmp_n);
  }
#line 1725
  return (__gmp_result);
}
}
#line 1730 "/usr/include/gmp-i386.h"
__inline extern void __gmpz_neg(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) 
{ 


  {
#line 1733
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
    {
#line 1734
    __gmpz_set(__gmp_w, __gmp_u);
    }
    }
  }
#line 1735
  __gmp_w->_mp_size = - __gmp_w->_mp_size;
#line 1736
  return;
}
}
#line 1741
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a )  __attribute__((__pure__)) ;
#line 1741 "/usr/include/gmp-i386.h"
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a ) 
{ 
  mp_size_t __gmp_asize ;
  int __gmp_result ;
  long tmp ;

  {
  {
#line 1749
  __gmp_asize = (mp_size_t )__gmp_a->_mp_size;
#line 1750
  __gmp_result = __gmp_asize >= 0L;
  {
#line 1751
  tmp = __builtin_expect((long )((__gmp_asize > 0L) != 0), 1L);
  }
  }
#line 1751
  if (tmp) {
    {
    {
#line 1752
    __gmp_result = __gmpn_perfect_square_p((mp_srcptr )__gmp_a->_mp_d, __gmp_asize);
    }
    }
  }
#line 1753
  return (__gmp_result);
}
}
#line 1759
__inline extern unsigned long __gmpz_popcount(mpz_srcptr __gmp_u )  __attribute__((__pure__)) ;
#line 1759 "/usr/include/gmp-i386.h"
__inline extern unsigned long __gmpz_popcount(mpz_srcptr __gmp_u ) 
{ 
  mp_size_t __gmp_usize ;
  unsigned long __gmp_result ;
  long tmp ;

  {
#line 1767
  __gmp_usize = (mp_size_t )__gmp_u->_mp_size;
#line 1768
  if (__gmp_usize < 0L) {
#line 1768
    __gmp_result = ~ 0UL;
  } else {
#line 1768
    __gmp_result = 0UL;
  }
  {
  {
#line 1769
  tmp = __builtin_expect((long )((__gmp_usize > 0L) != 0), 1L);
  }
  }
#line 1769
  if (tmp) {
    {
    {
#line 1770
    __gmp_result = __gmpn_popcount((mp_srcptr )__gmp_u->_mp_d, __gmp_usize);
    }
    }
  }
#line 1771
  return (__gmp_result);
}
}
#line 1777 "/usr/include/gmp-i386.h"
__inline extern void __gmpz_set_q(mpz_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
  {
  {
#line 1782
  __gmpz_tdiv_q(__gmp_w, & __gmp_u->_mp_num, & __gmp_u->_mp_den);
  }
  }
#line 1783
  return;
}
}
#line 1788
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1788 "/usr/include/gmp-i386.h"
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z ) 
{ 
  int tmp ;

  {
#line 1793
  if (__gmp_z->_mp_size >= 0) {
#line 1793
    tmp = (int )__gmp_z->_mp_size;
  } else {
#line 1793
    tmp = (int )(- __gmp_z->_mp_size);
  }
#line 1793
  return ((size_t )tmp);
}
}
#line 1801 "/usr/include/gmp-i386.h"
__inline extern void __gmpq_abs(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
#line 1804
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
    {
#line 1805
    __gmpq_set(__gmp_w, __gmp_u);
    }
    }
  }
#line 1806
  if (__gmp_w->_mp_num._mp_size >= 0) {
#line 1806
    __gmp_w->_mp_num._mp_size = __gmp_w->_mp_num._mp_size;
  } else {
#line 1806
    __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
  }
#line 1807
  return;
}
}
#line 1811 "/usr/include/gmp-i386.h"
__inline extern void __gmpq_neg(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
#line 1814
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
    {
#line 1815
    __gmpq_set(__gmp_w, __gmp_u);
    }
    }
  }
#line 1816
  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
#line 1817
  return;
}
}
#line 2054 "/usr/include/gmp-i386.h"
__inline extern mp_limb_t __gmpn_add(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_size_t tmp ;
  mp_limb_t tmp___0 ;
  mp_limb_t tmp___1 ;
  mp_size_t __gmp_j ;

  {
  {
  {
#line 2060
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2060
    __gmp_i = __gmp_ysize;
#line 2060
    if (__gmp_i != 0L) {
      {
      {
#line 2060
      tmp___1 = __gmpn_add_n(__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i);
      }
      }
#line 2060
      if (tmp___1) {
        {
        {
#line 2060
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;

#line 2060
          if (__gmp_i >= __gmp_xsize) {
#line 2060
            __gmp_c = (mp_limb_t )1;
#line 2060
            goto __gmp_done;
          }
#line 2060
          __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2060
          tmp = __gmp_i;
#line 2060
          __gmp_i ++;
#line 2060
          tmp___0 = (__gmp_x + 1UL) & 0xffffffffffffffffUL;
#line 2060
          *(__gmp_wp + tmp) = tmp___0;
#line 2060
          if (! (tmp___0 == 0UL)) {
#line 2060
            goto while_break___0;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___0: ;
      }
    }
#line 2060
    if ((unsigned long )__gmp_wp != (unsigned long )__gmp_xp) {
      {
      {
#line 2060
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 2060
        __gmp_j = __gmp_i;
        {
        {
#line 2060
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;

#line 2060
          if (! (__gmp_j < __gmp_xsize)) {
#line 2060
            goto while_break___2;
          }
#line 2060
          *(__gmp_wp + __gmp_j) = (mp_limb_t )*(__gmp_xp + __gmp_j);
#line 2060
          __gmp_j ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: ;
#line 2060
        goto while_break___1;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 2060
    __gmp_c = (mp_limb_t )0;
    __gmp_done: ;
#line 2060
    goto while_break;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 2061
  return (__gmp_c);
}
}
#line 2067 "/usr/include/gmp-i386.h"
__inline extern mp_limb_t __gmpn_add_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_r ;
  mp_size_t __gmp_j ;
  mp_size_t __gmp_j___0 ;

  {
  {
  {
#line 2073
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2073
    __gmp_x = (mp_limb_t )*(__gmp_src + 0);
#line 2073
    __gmp_r = __gmp_x + __gmp_n;
#line 2073
    *(__gmp_dst + 0) = __gmp_r;
#line 2073
    if (__gmp_r < __gmp_n) {
#line 2073
      __gmp_c = (mp_limb_t )1;
#line 2073
      __gmp_i = (mp_size_t )1;
      {
      {
#line 2073
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;

#line 2073
        if (! (__gmp_i < __gmp_size)) {
#line 2073
          goto while_break___0;
        }
#line 2073
        __gmp_x = (mp_limb_t )*(__gmp_src + __gmp_i);
#line 2073
        __gmp_r = __gmp_x + 1UL;
#line 2073
        *(__gmp_dst + __gmp_i) = __gmp_r;
#line 2073
        __gmp_i ++;
#line 2073
        if (! (__gmp_r < 1UL)) {
#line 2073
          if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
            {
            {
#line 2073
            while (1) {
              while_continue___7: /* CIL Label */ ;
              while_continue___1: /* CIL Label */ ;
#line 2073
              __gmp_j = __gmp_i;
              {
              {
#line 2073
              while (1) {
                while_continue___8: /* CIL Label */ ;
                while_continue___2: /* CIL Label */ ;

#line 2073
                if (! (__gmp_j < __gmp_size)) {
#line 2073
                  goto while_break___2;
                }
#line 2073
                *(__gmp_dst + __gmp_j) = (mp_limb_t )*(__gmp_src + __gmp_j);
#line 2073
                __gmp_j ++;
              }
              while_break___14: /* CIL Label */ ;
              }
              while_break___8: /* CIL Label */ ;
              }
              while_break___2: ;
#line 2073
              goto while_break___1;
            }
            while_break___13: /* CIL Label */ ;
            }
            while_break___7: /* CIL Label */ ;
            }
            while_break___1: ;
          }
#line 2073
          __gmp_c = (mp_limb_t )0;
#line 2073
          goto while_break___0;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 2073
      if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
        {
        {
#line 2073
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 2073
          __gmp_j___0 = (mp_size_t )1;
          {
          {
#line 2073
          while (1) {
            while_continue___10: /* CIL Label */ ;
            while_continue___4: /* CIL Label */ ;

#line 2073
            if (! (__gmp_j___0 < __gmp_size)) {
#line 2073
              goto while_break___4;
            }
#line 2073
            *(__gmp_dst + __gmp_j___0) = (mp_limb_t )*(__gmp_src + __gmp_j___0);
#line 2073
            __gmp_j___0 ++;
          }
          while_break___16: /* CIL Label */ ;
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___4: ;
#line 2073
          goto while_break___3;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: ;
      }
#line 2073
      __gmp_c = (mp_limb_t )0;
    }
#line 2073
    goto while_break;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 2074
  return (__gmp_c);
}
}
#line 2080
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size )  __attribute__((__pure__)) ;
#line 2080 "/usr/include/gmp-i386.h"
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size ) 
{ 
  int __gmp_result ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_y ;

  {
  {
  {
#line 2086
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2086
    __gmp_result = 0;
#line 2086
    __gmp_i = __gmp_size;
    {
    {
#line 2086
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 2086
      __gmp_i --;
#line 2086
      if (! (__gmp_i >= 0L)) {
#line 2086
        goto while_break___0;
      }
#line 2086
      __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2086
      __gmp_y = (mp_limb_t )*(__gmp_yp + __gmp_i);
#line 2086
      if (__gmp_x != __gmp_y) {
#line 2086
        if (__gmp_x > __gmp_y) {
#line 2086
          __gmp_result = 1;
        } else {
#line 2086
          __gmp_result = -1;
        }
#line 2086
        goto while_break___0;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 2086
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 2087
  return (__gmp_result);
}
}
#line 2093 "/usr/include/gmp-i386.h"
__inline extern mp_limb_t __gmpn_sub(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_size_t tmp ;
  mp_limb_t tmp___0 ;
  mp_size_t __gmp_j ;

  {
  {
  {
#line 2099
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2099
    __gmp_i = __gmp_ysize;
#line 2099
    if (__gmp_i != 0L) {
      {
      {
#line 2099
      tmp___0 = __gmpn_sub_n(__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i);
      }
      }
#line 2099
      if (tmp___0) {
        {
        {
#line 2099
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;

#line 2099
          if (__gmp_i >= __gmp_xsize) {
#line 2099
            __gmp_c = (mp_limb_t )1;
#line 2099
            goto __gmp_done;
          }
#line 2099
          __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2099
          tmp = __gmp_i;
#line 2099
          __gmp_i ++;
#line 2099
          *(__gmp_wp + tmp) = (__gmp_x - 1UL) & 0xffffffffffffffffUL;
#line 2099
          if (! (__gmp_x == 0UL)) {
#line 2099
            goto while_break___0;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___0: ;
      }
    }
#line 2099
    if ((unsigned long )__gmp_wp != (unsigned long )__gmp_xp) {
      {
      {
#line 2099
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 2099
        __gmp_j = __gmp_i;
        {
        {
#line 2099
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;

#line 2099
          if (! (__gmp_j < __gmp_xsize)) {
#line 2099
            goto while_break___2;
          }
#line 2099
          *(__gmp_wp + __gmp_j) = (mp_limb_t )*(__gmp_xp + __gmp_j);
#line 2099
          __gmp_j ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: ;
#line 2099
        goto while_break___1;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 2099
    __gmp_c = (mp_limb_t )0;
    __gmp_done: ;
#line 2099
    goto while_break;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 2100
  return (__gmp_c);
}
}
#line 2106 "/usr/include/gmp-i386.h"
__inline extern mp_limb_t __gmpn_sub_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_r ;
  mp_size_t __gmp_j ;
  mp_size_t __gmp_j___0 ;

  {
  {
  {
#line 2112
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2112
    __gmp_x = (mp_limb_t )*(__gmp_src + 0);
#line 2112
    __gmp_r = __gmp_x - __gmp_n;
#line 2112
    *(__gmp_dst + 0) = __gmp_r;
#line 2112
    if (__gmp_x < __gmp_n) {
#line 2112
      __gmp_c = (mp_limb_t )1;
#line 2112
      __gmp_i = (mp_size_t )1;
      {
      {
#line 2112
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;

#line 2112
        if (! (__gmp_i < __gmp_size)) {
#line 2112
          goto while_break___0;
        }
#line 2112
        __gmp_x = (mp_limb_t )*(__gmp_src + __gmp_i);
#line 2112
        __gmp_r = __gmp_x - 1UL;
#line 2112
        *(__gmp_dst + __gmp_i) = __gmp_r;
#line 2112
        __gmp_i ++;
#line 2112
        if (! (__gmp_x < 1UL)) {
#line 2112
          if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
            {
            {
#line 2112
            while (1) {
              while_continue___7: /* CIL Label */ ;
              while_continue___1: /* CIL Label */ ;
#line 2112
              __gmp_j = __gmp_i;
              {
              {
#line 2112
              while (1) {
                while_continue___8: /* CIL Label */ ;
                while_continue___2: /* CIL Label */ ;

#line 2112
                if (! (__gmp_j < __gmp_size)) {
#line 2112
                  goto while_break___2;
                }
#line 2112
                *(__gmp_dst + __gmp_j) = (mp_limb_t )*(__gmp_src + __gmp_j);
#line 2112
                __gmp_j ++;
              }
              while_break___14: /* CIL Label */ ;
              }
              while_break___8: /* CIL Label */ ;
              }
              while_break___2: ;
#line 2112
              goto while_break___1;
            }
            while_break___13: /* CIL Label */ ;
            }
            while_break___7: /* CIL Label */ ;
            }
            while_break___1: ;
          }
#line 2112
          __gmp_c = (mp_limb_t )0;
#line 2112
          goto while_break___0;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 2112
      if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
        {
        {
#line 2112
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 2112
          __gmp_j___0 = (mp_size_t )1;
          {
          {
#line 2112
          while (1) {
            while_continue___10: /* CIL Label */ ;
            while_continue___4: /* CIL Label */ ;

#line 2112
            if (! (__gmp_j___0 < __gmp_size)) {
#line 2112
              goto while_break___4;
            }
#line 2112
            *(__gmp_dst + __gmp_j___0) = (mp_limb_t )*(__gmp_src + __gmp_j___0);
#line 2112
            __gmp_j___0 ++;
          }
          while_break___16: /* CIL Label */ ;
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___4: ;
#line 2112
          goto while_break___3;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: ;
      }
#line 2112
      __gmp_c = (mp_limb_t )0;
    }
#line 2112
    goto while_break;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 2113
  return (__gmp_c);
}
}
#line 2119 "/usr/include/gmp-i386.h"
__inline extern mp_limb_t __gmpn_neg_n(mp_ptr __gmp_rp , mp_srcptr __gmp_up , mp_size_t __gmp_n ) 
{ 
  mp_limb_t __gmp_ul ;
  mp_limb_t __gmp_cy ;
  mp_srcptr tmp ;
  mp_ptr tmp___0 ;

  {
#line 2125
  __gmp_cy = (mp_limb_t )0;
  {
  {
#line 2126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2127
    tmp = __gmp_up;
#line 2127
    __gmp_up ++;
#line 2127
    __gmp_ul = (mp_limb_t )*tmp;
#line 2128
    tmp___0 = __gmp_rp;
#line 2128
    __gmp_rp ++;
#line 2128
    *tmp___0 = - __gmp_ul - __gmp_cy;
#line 2129
    __gmp_cy |= (unsigned long )(__gmp_ul != 0UL);
#line 2126
    __gmp_n --;
#line 2126
    if (! (__gmp_n != 0L)) {
#line 2126
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2131
  return (__gmp_cy);
}
}
#line 142 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
int nettle_rsa_public_key_prepare(struct rsa_public_key *key ) ;
#line 153
int nettle_rsa_private_key_prepare(struct rsa_private_key *key ) ;
#line 272
int nettle_rsa_keypair_from_sexp_alist(struct rsa_public_key *pub , struct rsa_private_key *priv ,
                                       unsigned int limit , struct sexp_iterator *i ) ;
#line 282
int nettle_rsa_keypair_from_sexp(struct rsa_public_key *pub , struct rsa_private_key *priv ,
                                 unsigned int limit , unsigned int length , uint8_t const   *expr ) ;
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.h"
int nettle_mpz_set_sexp(__mpz_struct *x , unsigned int limit , struct sexp_iterator *i ) ;
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.h"
int nettle_sexp_iterator_first(struct sexp_iterator *iterator , unsigned int length ,
                               uint8_t const   *input ) ;
#line 120
int nettle_sexp_iterator_check_type(struct sexp_iterator *iterator , uint8_t const   *type ) ;
#line 124
uint8_t const   *nettle_sexp_iterator_check_types(struct sexp_iterator *iterator ,
                                                  unsigned int ntypes , uint8_t const   * const  *types ) ;
#line 138
int nettle_sexp_iterator_assoc(struct sexp_iterator *iterator , unsigned int nkeys ,
                               uint8_t const   * const  *keys , struct sexp_iterator *values ) ;
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp2rsa.c"
static uint8_t const   * const  names[8]  = 
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp2rsa.c"
  {      (uint8_t const   */* const  */)((uint8_t const   *)"n"),      (uint8_t const   */* const  */)((uint8_t const   *)"e"),      (uint8_t const   */* const  */)((uint8_t const   *)"d"),      (uint8_t const   */* const  */)((uint8_t const   *)"p"), 
        (uint8_t const   */* const  */)((uint8_t const   *)"q"),      (uint8_t const   */* const  */)((uint8_t const   *)"a"),      (uint8_t const   */* const  */)((uint8_t const   *)"b"),      (uint8_t const   */* const  */)((uint8_t const   *)"c")};
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp2rsa.c"
int nettle_rsa_keypair_from_sexp_alist(struct rsa_public_key *pub , struct rsa_private_key *priv ,
                                       unsigned int limit , struct sexp_iterator *i ) 
{ 
  struct sexp_iterator values[8] ;
  unsigned int nvalues ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  void *__cil_tmp30 ;
  int __cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  int __cil_tmp34 ;
  void *__cil_tmp35 ;

  {
#line 60
  if (priv) {
#line 60
    tmp = 8;
  } else {
#line 60
    tmp = 2;
  }
  {
#line 60
  nvalues = (unsigned int )tmp;
  {
#line 62
  tmp___0 = nettle_sexp_iterator_assoc(i, nvalues, names, values);
  }
  }
#line 62
  if (! tmp___0) {
#line 63
    return (0);
  }
#line 65
  if (priv) {
    {
    {
#line 67
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 67
      tmp___1 = nettle_mpz_set_sexp(priv->d, limit, & values[2]);
      }
      }
#line 67
      if (tmp___1) {
#line 67
        if (priv->d[0]._mp_size < 0) {
#line 67
          tmp___2 = -1;
        } else {
#line 67
          tmp___2 = priv->d[0]._mp_size > 0;
        }
#line 67
        if (tmp___2 <= 0) {
#line 67
          return (0);
        }
      } else {
#line 67
        return (0);
      }
#line 67
      goto while_break;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break: ;
    {
    {
#line 68
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 68
      tmp___3 = nettle_mpz_set_sexp(priv->p, limit, & values[3]);
      }
      }
#line 68
      if (tmp___3) {
#line 68
        if (priv->p[0]._mp_size < 0) {
#line 68
          tmp___4 = -1;
        } else {
#line 68
          tmp___4 = priv->p[0]._mp_size > 0;
        }
#line 68
        if (tmp___4 <= 0) {
#line 68
          return (0);
        }
      } else {
#line 68
        return (0);
      }
#line 68
      goto while_break___0;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: ;
    {
    {
#line 69
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 69
      tmp___5 = nettle_mpz_set_sexp(priv->q, limit, & values[4]);
      }
      }
#line 69
      if (tmp___5) {
#line 69
        if (priv->q[0]._mp_size < 0) {
#line 69
          tmp___6 = -1;
        } else {
#line 69
          tmp___6 = priv->q[0]._mp_size > 0;
        }
#line 69
        if (tmp___6 <= 0) {
#line 69
          return (0);
        }
      } else {
#line 69
        return (0);
      }
#line 69
      goto while_break___1;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___1: ;
    {
    {
#line 70
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
      {
      {
#line 70
      tmp___7 = nettle_mpz_set_sexp(priv->a, limit, & values[5]);
      }
      }
#line 70
      if (tmp___7) {
#line 70
        if (priv->a[0]._mp_size < 0) {
#line 70
          tmp___8 = -1;
        } else {
#line 70
          tmp___8 = priv->a[0]._mp_size > 0;
        }
#line 70
        if (tmp___8 <= 0) {
#line 70
          return (0);
        }
      } else {
#line 70
        return (0);
      }
#line 70
      goto while_break___2;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: ;
    {
    {
#line 71
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
      {
      {
#line 71
      tmp___9 = nettle_mpz_set_sexp(priv->b, limit, & values[6]);
      }
      }
#line 71
      if (tmp___9) {
#line 71
        if (priv->b[0]._mp_size < 0) {
#line 71
          tmp___10 = -1;
        } else {
#line 71
          tmp___10 = priv->b[0]._mp_size > 0;
        }
#line 71
        if (tmp___10 <= 0) {
#line 71
          return (0);
        }
      } else {
#line 71
        return (0);
      }
#line 71
      goto while_break___3;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: ;
    {
    {
#line 72
    while (1) {
      while_continue___12: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
      {
      {
#line 72
      tmp___11 = nettle_mpz_set_sexp(priv->c, limit, & values[7]);
      }
      }
#line 72
      if (tmp___11) {
#line 72
        if (priv->c[0]._mp_size < 0) {
#line 72
          tmp___12 = -1;
        } else {
#line 72
          tmp___12 = priv->c[0]._mp_size > 0;
        }
#line 72
        if (tmp___12 <= 0) {
#line 72
          return (0);
        }
      } else {
#line 72
        return (0);
      }
#line 72
      goto while_break___4;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___4: 
    {
    {
#line 74
    tmp___13 = nettle_rsa_private_key_prepare(priv);
    }
    }
#line 74
    if (! tmp___13) {
#line 75
      return (0);
    }
  }
#line 78
  if (pub) {
    {
    {
#line 80
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
      {
      {
#line 80
      tmp___14 = nettle_mpz_set_sexp(pub->n, limit, & values[0]);
      }
      }
#line 80
      if (tmp___14) {
#line 80
        if (pub->n[0]._mp_size < 0) {
#line 80
          tmp___15 = -1;
        } else {
#line 80
          tmp___15 = pub->n[0]._mp_size > 0;
        }
#line 80
        if (tmp___15 <= 0) {
#line 80
          return (0);
        }
      } else {
#line 80
        return (0);
      }
#line 80
      goto while_break___5;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___5: ;
    {
    {
#line 81
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
      {
      {
#line 81
      tmp___16 = nettle_mpz_set_sexp(pub->e, limit, & values[1]);
      }
      }
#line 81
      if (tmp___16) {
#line 81
        if (pub->e[0]._mp_size < 0) {
#line 81
          tmp___17 = -1;
        } else {
#line 81
          tmp___17 = pub->e[0]._mp_size > 0;
        }
#line 81
        if (tmp___17 <= 0) {
#line 81
          return (0);
        }
      } else {
#line 81
        return (0);
      }
#line 81
      goto while_break___6;
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___6: 
    {
    {
#line 83
    tmp___18 = nettle_rsa_public_key_prepare(pub);
    }
    }
#line 83
    if (! tmp___18) {
#line 84
      return (0);
    }
  }
#line 87
  return (1);
}
}
#line 97 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp2rsa.c"
static uint8_t const   * const  names___0[3]  = {      (uint8_t const   */* const  */)((uint8_t const   *)"rsa"),      (uint8_t const   */* const  */)((uint8_t const   *)"rsa-pkcs1"),      (uint8_t const   */* const  */)((uint8_t const   *)"rsa-pkcs1-sha1")};
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp2rsa.c"
int nettle_rsa_keypair_from_sexp(struct rsa_public_key *pub , struct rsa_private_key *priv ,
                                 unsigned int limit , unsigned int length , uint8_t const   *expr ) 
{ 
  struct sexp_iterator i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  uint8_t const   *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
  {
#line 100
  tmp = nettle_sexp_iterator_first(& i, length, expr);
  }
  }
#line 100
  if (! tmp) {
#line 101
    return (0);
  }
#line 103
  if (priv) {
#line 103
    tmp___0 = "private-key";
  } else {
#line 103
    tmp___0 = "public-key";
  }
  {
  {
#line 103
  tmp___1 = nettle_sexp_iterator_check_type(& i, (uint8_t const   *)tmp___0);
  }
  }
#line 103
  if (! tmp___1) {
#line 104
    return (0);
  }
  {
  {
#line 106
  tmp___2 = nettle_sexp_iterator_check_types(& i, 3U, names___0);
  }
  }
#line 106
  if (! tmp___2) {
#line 107
    return (0);
  }
  {
  {
#line 109
  tmp___3 = nettle_rsa_keypair_from_sexp_alist(pub, priv, limit, & i);
  }
  }
#line 109
  return (tmp___3);
}
}
#line 173 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.h"
int nettle_dsa_signature_from_sexp(struct dsa_signature *rs , struct sexp_iterator *i ) ;
#line 177
int nettle_dsa_keypair_from_sexp_alist(struct dsa_public_key *pub , struct dsa_private_key *priv ,
                                       unsigned int limit , struct sexp_iterator *i ) ;
#line 187
int nettle_dsa_keypair_from_sexp(struct dsa_public_key *pub , struct dsa_private_key *priv ,
                                 unsigned int limit , unsigned int length , uint8_t const   *expr ) ;
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp2dsa.c"
static uint8_t const   * const  names___1[5]  = {      (uint8_t const   */* const  */)((uint8_t const   *)"p"),      (uint8_t const   */* const  */)((uint8_t const   *)"q"),      (uint8_t const   */* const  */)((uint8_t const   *)"g"),      (uint8_t const   */* const  */)((uint8_t const   *)"y"), 
        (uint8_t const   */* const  */)((uint8_t const   *)"x")};
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp2dsa.c"
int nettle_dsa_keypair_from_sexp_alist(struct dsa_public_key *pub , struct dsa_private_key *priv ,
                                       unsigned int limit , struct sexp_iterator *i ) 
{ 
  struct sexp_iterator values[5] ;
  unsigned int nvalues ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp22 ;
  int __cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  int __cil_tmp26 ;
  void *__cil_tmp27 ;

  {
#line 60
  if (priv) {
#line 60
    tmp = 5;
  } else {
#line 60
    tmp = 4;
  }
  {
#line 60
  nvalues = (unsigned int )tmp;
  {
#line 62
  tmp___0 = nettle_sexp_iterator_assoc(i, nvalues, names___1, values);
  }
  }
#line 62
  if (! tmp___0) {
#line 63
    return (0);
  }
#line 65
  if (priv) {
    {
    {
#line 66
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 66
      tmp___1 = nettle_mpz_set_sexp(priv->x, limit, & values[4]);
      }
      }
#line 66
      if (tmp___1) {
#line 66
        if (priv->x[0]._mp_size < 0) {
#line 66
          tmp___2 = -1;
        } else {
#line 66
          tmp___2 = priv->x[0]._mp_size > 0;
        }
#line 66
        if (tmp___2 <= 0) {
#line 66
          return (0);
        }
      } else {
#line 66
        return (0);
      }
#line 66
      goto while_break;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
  {
#line 68
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 68
    tmp___3 = nettle_mpz_set_sexp(pub->p, limit, & values[0]);
    }
    }
#line 68
    if (tmp___3) {
#line 68
      if (pub->p[0]._mp_size < 0) {
#line 68
        tmp___4 = -1;
      } else {
#line 68
        tmp___4 = pub->p[0]._mp_size > 0;
      }
#line 68
      if (tmp___4 <= 0) {
#line 68
        return (0);
      }
    } else {
#line 68
      return (0);
    }
#line 68
    goto while_break___0;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: ;
  {
  {
#line 69
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
    {
#line 69
    tmp___5 = nettle_mpz_set_sexp(pub->q, 160U, & values[1]);
    }
    }
#line 69
    if (tmp___5) {
#line 69
      if (pub->q[0]._mp_size < 0) {
#line 69
        tmp___6 = -1;
      } else {
#line 69
        tmp___6 = pub->q[0]._mp_size > 0;
      }
#line 69
      if (tmp___6 <= 0) {
#line 69
        return (0);
      }
    } else {
#line 69
      return (0);
    }
#line 69
    goto while_break___1;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: ;
  {
  {
#line 70
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
    {
    {
#line 70
    tmp___7 = nettle_mpz_set_sexp(pub->g, limit, & values[2]);
    }
    }
#line 70
    if (tmp___7) {
#line 70
      if (pub->g[0]._mp_size < 0) {
#line 70
        tmp___8 = -1;
      } else {
#line 70
        tmp___8 = pub->g[0]._mp_size > 0;
      }
#line 70
      if (tmp___8 <= 0) {
#line 70
        return (0);
      }
    } else {
#line 70
      return (0);
    }
#line 70
    goto while_break___2;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: ;
  {
  {
#line 71
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
    {
    {
#line 71
    tmp___9 = nettle_mpz_set_sexp(pub->y, limit, & values[3]);
    }
    }
#line 71
    if (tmp___9) {
#line 71
      if (pub->y[0]._mp_size < 0) {
#line 71
        tmp___10 = -1;
      } else {
#line 71
        tmp___10 = pub->y[0]._mp_size > 0;
      }
#line 71
      if (tmp___10 <= 0) {
#line 71
        return (0);
      }
    } else {
#line 71
      return (0);
    }
#line 71
    goto while_break___3;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: ;
#line 73
  return (1);
}
}
#line 76 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp2dsa.c"
int nettle_dsa_keypair_from_sexp(struct dsa_public_key *pub , struct dsa_private_key *priv ,
                                 unsigned int limit , unsigned int length , uint8_t const   *expr ) 
{ 
  struct sexp_iterator i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
  {
#line 84
  tmp = nettle_sexp_iterator_first(& i, length, expr);
  }
  }
#line 84
  if (tmp) {
#line 84
    if (priv) {
#line 84
      tmp___0 = "private-key";
    } else {
#line 84
      tmp___0 = "public-key";
    }
    {
    {
#line 84
    tmp___1 = nettle_sexp_iterator_check_type(& i, (uint8_t const   *)tmp___0);
    }
    }
#line 84
    if (tmp___1) {
      {
      {
#line 84
      tmp___2 = nettle_sexp_iterator_check_type(& i, (uint8_t const   *)"dsa");
      }
      }
#line 84
      if (tmp___2) {
        {
        {
#line 84
        tmp___3 = nettle_dsa_keypair_from_sexp_alist(pub, priv, limit, & i);
        }
        }
#line 84
        if (tmp___3) {
#line 84
          tmp___4 = 1;
        } else {
#line 84
          tmp___4 = 0;
        }
      } else {
#line 84
        tmp___4 = 0;
      }
    } else {
#line 84
      tmp___4 = 0;
    }
  } else {
#line 84
    tmp___4 = 0;
  }
#line 84
  return (tmp___4);
}
}
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp2dsa.c"
static uint8_t const   * const  names___2[2]  = {      (uint8_t const   */* const  */)((uint8_t const   *)"r"),      (uint8_t const   */* const  */)((uint8_t const   *)"s")};
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp2dsa.c"
int nettle_dsa_signature_from_sexp(struct dsa_signature *rs , struct sexp_iterator *i ) 
{ 
  struct sexp_iterator values[2] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;

  {
  {
  {
#line 97
  tmp = nettle_sexp_iterator_assoc(i, 2U, names___2, values);
  }
  }
#line 97
  if (! tmp) {
#line 98
    return (0);
  }
  {
  {
#line 100
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 100
    tmp___0 = nettle_mpz_set_sexp(rs->r, 160U, & values[0]);
    }
    }
#line 100
    if (tmp___0) {
#line 100
      if (rs->r[0]._mp_size < 0) {
#line 100
        tmp___1 = -1;
      } else {
#line 100
        tmp___1 = rs->r[0]._mp_size > 0;
      }
#line 100
      if (tmp___1 <= 0) {
#line 100
        return (0);
      }
    } else {
#line 100
      return (0);
    }
#line 100
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 101
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 101
    tmp___2 = nettle_mpz_set_sexp(rs->s, 160U, & values[1]);
    }
    }
#line 101
    if (tmp___2) {
#line 101
      if (rs->s[0]._mp_size < 0) {
#line 101
        tmp___3 = -1;
      } else {
#line 101
        tmp___3 = rs->s[0]._mp_size > 0;
      }
#line 101
      if (tmp___3 <= 0) {
#line 101
        return (0);
      }
    } else {
#line 101
      return (0);
    }
#line 101
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 103
  return (1);
}
}
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.h"
int nettle_sexp_iterator_next(struct sexp_iterator *iterator ) ;
#line 1096 "/usr/include/gmp-i386.h"
extern size_t __gmpz_sizeinbase(mpz_srcptr  , int  )  __attribute__((__pure__)) ;
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.h"
void nettle_mpz_set_str_256_s(__mpz_struct *x , unsigned int length , uint8_t const   *s ) ;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp2bignum.c"
int nettle_mpz_set_sexp(__mpz_struct *x , unsigned int limit , struct sexp_iterator *i ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
#line 37
  if ((unsigned int )i->type == 0U) {
#line 37
    if (i->atom_length) {
#line 37
      if (! i->display) {
#line 42
        if (limit) {
#line 42
          if (8U * i->atom_length > 16U + limit) {
#line 43
            return (0);
          }
        }
        {
        {
#line 45
        nettle_mpz_set_str_256_s(x, i->atom_length, i->atom);
        }
        }
#line 48
        if (limit) {
          {
          {
#line 48
          tmp = __gmpz_sizeinbase((mpz_srcptr )x, 2);
          }
          }
#line 48
          if (tmp > limit) {
#line 49
            return (0);
          }
        }
        {
        {
#line 51
        tmp___0 = nettle_sexp_iterator_next(i);
        }
        }
#line 51
        return (tmp___0);
      } else {
#line 54
        return (0);
      }
    } else {
#line 54
      return (0);
    }
  } else {
#line 54
    return (0);
  }
}
}
#line 67 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.h"
int nettle_sexp_iterator_enter_list(struct sexp_iterator *iterator ) ;
#line 94
int nettle_sexp_iterator_exit_list(struct sexp_iterator *iterator ) ;
#line 107
uint8_t const   *nettle_sexp_iterator_subexpr(struct sexp_iterator *iterator , unsigned int *length ) ;
#line 111
int nettle_sexp_iterator_get_uint32(struct sexp_iterator *iterator , uint32_t *x ) ;
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.c"
static void sexp_iterator_init(struct sexp_iterator *iterator , unsigned int length ,
                               uint8_t const   *input ) 
{ 


  {
#line 44
  iterator->length = length;
#line 45
  iterator->buffer = input;
#line 46
  iterator->pos = 0U;
#line 47
  iterator->level = 0U;
#line 48
  iterator->type = (enum sexp_type )2;
#line 49
  iterator->display_length = 0U;
#line 50
  iterator->display = (uint8_t const   *)((void *)0);
#line 51
  iterator->atom_length = 0U;
#line 52
  iterator->atom = (uint8_t const   *)((void *)0);
#line 56
  return;
}
}
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.c"
static int sexp_iterator_simple(struct sexp_iterator *iterator , unsigned int *size ,
                                uint8_t const   **string ) 
{ 
  unsigned int length ;
  uint8_t c ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 66
  length = 0U;
#line 69
  if (iterator->pos == iterator->length) {
#line 69
    return (0);
  }
#line 70
  tmp = iterator->pos;
#line 70
  (iterator->pos) ++;
#line 70
  c = (uint8_t )*(iterator->buffer + tmp);
#line 71
  if (iterator->pos == iterator->length) {
#line 71
    return (0);
  }
#line 73
  if ((int )c >= 49) {
#line 73
    if ((int )c <= 57) {
      {
      {
#line 74
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 76
        length = length * 10U + (unsigned int )((int )c - 48);
#line 77
        if (length > iterator->length - iterator->pos) {
#line 78
          return (0);
        }
#line 80
        if (iterator->pos == iterator->length) {
#line 80
          return (0);
        }
#line 81
        tmp___0 = iterator->pos;
#line 81
        (iterator->pos) ++;
#line 81
        c = (uint8_t )*(iterator->buffer + tmp___0);
#line 74
        if ((int )c >= 48) {
#line 74
          if (! ((int )c <= 57)) {
#line 74
            goto while_break;
          }
        } else {
#line 74
          goto while_break;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    } else {
#line 73
      goto _L;
    }
  } else
  _L: 
#line 85
  if ((int )c == 48) {
#line 87
    tmp___1 = iterator->pos;
#line 87
    (iterator->pos) ++;
#line 87
    c = (uint8_t )*(iterator->buffer + tmp___1);
  } else {
#line 89
    return (0);
  }
#line 91
  if ((int )c != 58) {
#line 92
    return (0);
  }
#line 94
  *size = length;
#line 95
  *string = iterator->buffer + iterator->pos;
#line 96
  iterator->pos += length;
#line 98
  return (1);
}
}
#line 106 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.c"
static int sexp_iterator_parse(struct sexp_iterator *iterator ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 109
  iterator->start = iterator->pos;
#line 111
  if (iterator->pos == iterator->length) {
#line 113
    if (iterator->level) {
#line 114
      return (0);
    }
#line 116
    iterator->type = (enum sexp_type )2;
#line 117
    return (1);
  }
#line 121
  if ((int const   )*(iterator->buffer + iterator->pos) == 40) {
#line 121
    goto case_40;
  }
#line 125
  if ((int const   )*(iterator->buffer + iterator->pos) == 41) {
#line 125
    goto case_41;
  }
#line 133
  if ((int const   )*(iterator->buffer + iterator->pos) == 91) {
#line 133
    goto case_91;
  }
#line 144
  goto switch_default;
  case_40: 
#line 122
  iterator->type = (enum sexp_type )1;
#line 123
  return (1);
  case_41: 
#line 126
  if (! iterator->level) {
#line 127
    return (0);
  }
#line 129
  (iterator->pos) ++;
#line 130
  iterator->type = (enum sexp_type )2;
#line 131
  return (1);
  case_91: 
  {
#line 134
  (iterator->pos) ++;
  {
#line 135
  tmp = sexp_iterator_simple(iterator, & iterator->display_length, & iterator->display);
  }
  }
#line 135
  if (! tmp) {
#line 138
    return (0);
  }
#line 139
  if (iterator->pos == iterator->length) {
#line 140
    return (0);
  } else {
#line 139
    tmp___0 = iterator->pos;
#line 139
    (iterator->pos) ++;
#line 139
    if ((int const   )*(iterator->buffer + tmp___0) != 93) {
#line 140
      return (0);
    }
  }
#line 142
  goto switch_break;
  switch_default: 
#line 147
  iterator->display_length = 0U;
#line 148
  iterator->display = (uint8_t const   *)((void *)0);
#line 150
  goto switch_break;
  switch_break: 
  {
#line 153
  iterator->type = (enum sexp_type )0;
  {
#line 155
  tmp___1 = sexp_iterator_simple(iterator, & iterator->atom_length, & iterator->atom);
  }
  }
#line 155
  return (tmp___1);
}
}
#line 160 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.c"
int nettle_sexp_iterator_first(struct sexp_iterator *iterator , unsigned int length ,
                               uint8_t const   *input ) 
{ 
  int tmp ;

  {
  {
  {
#line 164
  sexp_iterator_init(iterator, length, input);
  }
  {
#line 165
  tmp = sexp_iterator_parse(iterator);
  }
  }
#line 165
  return (tmp);
}
}
#line 168 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.c"
int nettle_sexp_iterator_next(struct sexp_iterator *iterator ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 173
  if ((unsigned int )iterator->type == 2U) {
#line 173
    goto case_2;
  }
#line 175
  if ((unsigned int )iterator->type == 1U) {
#line 175
    goto case_1;
  }
#line 179
  if ((unsigned int )iterator->type == 0U) {
#line 179
    goto case_0;
  }
#line 171
  goto switch_break;
  case_2: 
#line 174
  return (1);
  case_1: 
  {
  {
#line 177
  tmp = nettle_sexp_iterator_enter_list(iterator);
  }
  }
#line 177
  if (tmp) {
    {
    {
#line 177
    tmp___0 = nettle_sexp_iterator_exit_list(iterator);
    }
    }
#line 177
    if (tmp___0) {
#line 177
      tmp___1 = 1;
    } else {
#line 177
      tmp___1 = 0;
    }
  } else {
#line 177
    tmp___1 = 0;
  }
#line 177
  return (tmp___1);
  case_0: 
  {
  {
#line 182
  tmp___2 = sexp_iterator_parse(iterator);
  }
  }
#line 182
  return (tmp___2);
  switch_break: 
  {
  {
#line 185
  abort();
  }
  }
}
}
#line 189 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.c"
int nettle_sexp_iterator_enter_list(struct sexp_iterator *iterator ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 192
  if ((unsigned int )iterator->type != 1U) {
#line 193
    return (0);
  }
#line 195
  if (iterator->pos == iterator->length) {
    {
    {
#line 197
    abort();
    }
    }
  } else {
#line 195
    tmp = iterator->pos;
#line 195
    (iterator->pos) ++;
#line 195
    if ((int const   )*(iterator->buffer + tmp) != 40) {
      {
      {
#line 197
      abort();
      }
      }
    }
  }
  {
#line 199
  (iterator->level) ++;
  {
#line 201
  tmp___0 = sexp_iterator_parse(iterator);
  }
  }
#line 201
  return (tmp___0);
}
}
#line 205 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.c"
int nettle_sexp_iterator_exit_list(struct sexp_iterator *iterator ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 208
  if (! iterator->level) {
#line 209
    return (0);
  }
  {
  {
#line 211
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 211
    if (! ((unsigned int )iterator->type != 2U)) {
#line 211
      goto while_break;
    }
    {
    {
#line 212
    tmp = nettle_sexp_iterator_next(iterator);
    }
    }
#line 212
    if (! tmp) {
#line 213
      return (0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 215
  (iterator->level) --;
  {
#line 217
  tmp___0 = sexp_iterator_parse(iterator);
  }
  }
#line 217
  return (tmp___0);
}
}
#line 236 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.c"
uint8_t const   *nettle_sexp_iterator_subexpr(struct sexp_iterator *iterator , unsigned int *length ) 
{ 
  unsigned int start ;
  int tmp ;

  {
  {
#line 240
  start = iterator->start;
  {
#line 241
  tmp = nettle_sexp_iterator_next(iterator);
  }
  }
#line 241
  if (! tmp) {
#line 242
    return ((uint8_t const   *)0);
  }
#line 244
  *length = iterator->start - start;
#line 245
  return (iterator->buffer + start);
}
}
#line 248 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.c"
int nettle_sexp_iterator_get_uint32(struct sexp_iterator *iterator , uint32_t *x ) 
{ 
  unsigned int length ;
  uint8_t const   *p ;
  int tmp ;

  {
#line 252
  if ((unsigned int )iterator->type == 0U) {
#line 252
    if (! iterator->display) {
#line 252
      if (iterator->atom_length) {
#line 252
        if ((int const   )*(iterator->atom + 0) < 128) {
#line 257
          length = iterator->atom_length;
#line 258
          p = iterator->atom;
          {
          {
#line 261
          while (1) {
            while_continue___0: /* CIL Label */ ;
            while_continue: /* CIL Label */ ;

#line 261
            if (length) {
#line 261
              if (! (! *p)) {
#line 261
                goto while_break;
              }
            } else {
#line 261
              goto while_break;
            }
#line 263
            length --;
#line 263
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: ;
#line 268
          if (length == 0U) {
#line 268
            goto case_0;
          }
#line 271
          if (length == 1U) {
#line 271
            goto case_1;
          }
#line 274
          if (length == 2U) {
#line 274
            goto case_2;
          }
#line 277
          if (length == 3U) {
#line 277
            goto case_3;
          }
#line 280
          if (length == 4U) {
#line 280
            goto case_4;
          }
#line 283
          goto switch_default;
          case_0: 
#line 269
          *x = (uint32_t )0;
#line 270
          goto switch_break;
          case_1: 
#line 272
          *x = (uint32_t )*(p + 0);
#line 273
          goto switch_break;
          case_2: 
#line 275
          *x = ((uint32_t )*(p + 0) << 8) | (uint32_t )*(p + 1);
#line 276
          goto switch_break;
          case_3: 
#line 278
          *x = (((uint32_t )*(p + 0) << 16) | ((uint32_t )*(p + 1) << 8)) | (uint32_t )*(p + 2);
#line 279
          goto switch_break;
          case_4: 
#line 281
          *x = ((((uint32_t )*(p + 0) << 24) | ((uint32_t )*(p + 1) << 16)) | ((uint32_t )*(p + 2) << 8)) | (uint32_t )*(p + 3);
#line 282
          goto switch_break;
          switch_default: 
#line 284
          return (0);
          switch_break: 
          {
          {
#line 286
          tmp = nettle_sexp_iterator_next(iterator);
          }
          }
#line 286
          return (tmp);
        }
      }
    }
  }
#line 288
  return (0);
}
}
#line 291 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.c"
int nettle_sexp_iterator_check_type(struct sexp_iterator *iterator , uint8_t const   *type ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  {
#line 295
  tmp = nettle_sexp_iterator_enter_list(iterator);
  }
  }
#line 295
  if (tmp) {
#line 295
    if ((unsigned int )iterator->type == 0U) {
#line 295
      if (! iterator->display) {
        {
        {
#line 295
        tmp___0 = strlen((char const   *)type);
        }
        }
#line 295
        if (tmp___0 == iterator->atom_length) {
          {
          {
#line 295
          tmp___1 = memcmp((void const   *)type, (void const   *)iterator->atom, iterator->atom_length);
          }
          }
#line 295
          if (tmp___1) {
#line 295
            tmp___3 = 0;
          } else {
            {
            {
#line 295
            tmp___2 = nettle_sexp_iterator_next(iterator);
            }
            }
#line 295
            if (tmp___2) {
#line 295
              tmp___3 = 1;
            } else {
#line 295
              tmp___3 = 0;
            }
          }
        } else {
#line 295
          tmp___3 = 0;
        }
      } else {
#line 295
        tmp___3 = 0;
      }
    } else {
#line 295
      tmp___3 = 0;
    }
  } else {
#line 295
    tmp___3 = 0;
  }
#line 295
  return (tmp___3);
}
}
#line 303 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.c"
uint8_t const   *nettle_sexp_iterator_check_types(struct sexp_iterator *iterator ,
                                                  unsigned int ntypes , uint8_t const   * const  *types ) 
{ 
  unsigned int i ;
  uint8_t const   *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 308
  tmp___4 = nettle_sexp_iterator_enter_list(iterator);
  }
  }
#line 308
  if (tmp___4) {
#line 308
    if ((unsigned int )iterator->type == 0U) {
#line 308
      if (! iterator->display) {
#line 313
        i = 0U;
        {
        {
#line 313
        while (1) {
          while_continue___0: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;

#line 313
          if (! (i < ntypes)) {
#line 313
            goto while_break;
          }
          {
          {
#line 314
          tmp___2 = strlen((char const   *)*(types + i));
          }
          }
#line 314
          if (tmp___2 == iterator->atom_length) {
            {
            {
#line 314
            tmp___3 = memcmp((void const   *)*(types + i), (void const   *)iterator->atom,
                             iterator->atom_length);
            }
            }
#line 314
            if (! tmp___3) {
              {
              {
#line 317
              tmp___1 = nettle_sexp_iterator_next(iterator);
              }
              }
#line 317
              if (tmp___1) {
#line 317
                tmp___0 = (uint8_t const   *)*(types + i);
              } else {
#line 317
                tmp___0 = (uint8_t const   *)((void *)0);
              }
#line 317
              return (tmp___0);
            }
          }
#line 313
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        while_break: ;
      }
    }
  }
#line 319
  return ((uint8_t const   *)((void *)0));
}
}
#line 322 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.c"
int nettle_sexp_iterator_assoc(struct sexp_iterator *iterator , unsigned int nkeys ,
                               uint8_t const   * const  *keys , struct sexp_iterator *values ) 
{ 
  int *found ;
  unsigned int nfound ;
  unsigned int i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
  {
#line 332
  tmp = __builtin_alloca(sizeof(*found) * (unsigned long )nkeys);
  }
#line 332
  found = (int *)tmp;
#line 333
  i = 0U;
  }
  {
  {
#line 333
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 333
    if (! (i < nkeys)) {
#line 333
      goto while_break;
    }
#line 334
    *(found + i) = 0;
#line 333
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 336
  nfound = 0U;
  {
  {
#line 338
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 342
    if ((unsigned int )iterator->type == 1U) {
#line 342
      goto case_1;
    }
#line 383
    if ((unsigned int )iterator->type == 0U) {
#line 383
      goto case_0;
    }
#line 389
    if ((unsigned int )iterator->type == 2U) {
#line 389
      goto case_2;
    }
#line 393
    goto switch_default;
    case_1: 
    {
    {
#line 347
    tmp___0 = nettle_sexp_iterator_enter_list(iterator);
    }
    }
#line 347
    if (! tmp___0) {
#line 348
      return (0);
    }
#line 350
    if ((unsigned int )iterator->type == 0U) {
#line 350
      if (! iterator->display) {
#line 354
        i = 0U;
        {
        {
#line 354
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;

#line 354
          if (! (i < nkeys)) {
#line 354
            goto while_break___1;
          }
          {
          {
#line 358
          tmp___2 = strlen((char const   *)*(keys + i));
          }
          }
#line 358
          if (tmp___2 == iterator->atom_length) {
            {
            {
#line 358
            tmp___3 = memcmp((void const   *)*(keys + i), (void const   *)iterator->atom,
                             iterator->atom_length);
            }
            }
#line 358
            if (! tmp___3) {
#line 362
              if (*(found + i)) {
#line 364
                return (0);
              }
              {
              {
#line 367
              tmp___1 = nettle_sexp_iterator_next(iterator);
              }
              }
#line 367
              if (! tmp___1) {
#line 368
                return (0);
              }
#line 370
              *(found + i) = 1;
#line 371
              nfound ++;
#line 374
              *(values + i) = *iterator;
#line 376
              goto while_break___1;
            }
          }
#line 354
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: ;
      }
    }
    {
    {
#line 380
    tmp___4 = nettle_sexp_iterator_exit_list(iterator);
    }
    }
#line 380
    if (! tmp___4) {
#line 381
      return (0);
    }
#line 382
    goto switch_break;
    case_0: 
    {
    {
#line 385
    tmp___5 = nettle_sexp_iterator_next(iterator);
    }
    }
#line 385
    if (! tmp___5) {
#line 386
      return (0);
    }
#line 387
    goto switch_break;
    case_2: 
    {
    {
#line 390
    tmp___6 = nettle_sexp_iterator_exit_list(iterator);
    }
    }
#line 390
    if (tmp___6) {
#line 390
      if (nfound == nkeys) {
#line 390
        tmp___7 = 1;
      } else {
#line 390
        tmp___7 = 0;
      }
    } else {
#line 390
      tmp___7 = 0;
    }
#line 390
    return (tmp___7);
    switch_default: 
    {
    {
#line 394
    abort();
    }
    }
    switch_break: ;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }

#line 402
  return (0);
}
}
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.h"
int nettle_sexp_transport_iterator_first(struct sexp_iterator *iterator , unsigned int length ,
                                         uint8_t *input ) ;
#line 116 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64.h"
void nettle_base64_decode_init(struct base64_decode_ctx *ctx ) ;
#line 134
int nettle_base64_decode_update(struct base64_decode_ctx *ctx , unsigned int *dst_length ,
                                uint8_t *dst , unsigned int src_length , uint8_t const   *src ) ;
#line 142
int nettle_base64_decode_final(struct base64_decode_ctx *ctx ) ;
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp-transport.c"
int nettle_sexp_transport_iterator_first(struct sexp_iterator *iterator , unsigned int length ,
                                         uint8_t *input ) 
{ 
  unsigned int in ;
  unsigned int out ;
  struct base64_decode_ctx ctx ;
  unsigned int coded_length ;
  unsigned int end ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 45
  in = 0U;
#line 46
  out = 0U;
  {
  {
#line 48
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 48
    if (! (in < length)) {
#line 48
      goto while_break;
    }
#line 54
    if ((int )*(input + in) == 13) {
#line 54
      goto case_13;
    }
#line 54
    if ((int )*(input + in) == 10) {
#line 54
      goto case_13;
    }
#line 54
    if ((int )*(input + in) == 9) {
#line 54
      goto case_13;
    }
#line 54
    if ((int )*(input + in) == 32) {
#line 54
      goto case_13;
    }
#line 58
    if ((int )*(input + in) == 59) {
#line 58
      goto case_59;
    }
#line 63
    if ((int )*(input + in) == 123) {
#line 63
      goto case_123;
    }
#line 91
    goto switch_default;
    case_13: 
#line 55
    in ++;
#line 56
    goto switch_break;
    case_59: 
    {
    {
#line 59
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 59
      in ++;
#line 59
      if (in < length) {
#line 59
        if (! ((int )*(input + in) != 10)) {
#line 59
          goto while_break___0;
        }
      } else {
#line 59
        goto while_break___0;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
#line 61
    goto switch_break;
    case_123: 
#line 70
    in ++;
#line 70
    end = in;
    {
    {
#line 70
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;

#line 70
      if (end < length) {
#line 70
        if (! ((int )*(input + end) != 125)) {
#line 70
          goto while_break___1;
        }
      } else {
#line 70
        goto while_break___1;
      }
#line 70
      end ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
#line 73
    if (end == length) {
#line 74
      return (0);
    }
    {
    {
#line 76
    nettle_base64_decode_init(& ctx);
    }
#line 77
    coded_length = end - in;
    {
#line 79
    tmp = nettle_base64_decode_update(& ctx, & coded_length, input + out, coded_length,
                                      (uint8_t const   *)(input + in));
    }
    }
#line 79
    if (tmp) {
      {
      {
#line 79
      tmp___0 = nettle_base64_decode_final(& ctx);
      }
      }
#line 79
      if (tmp___0) {
#line 83
        out += coded_length;
#line 84
        in = end + 1U;
      } else {
#line 87
        return (0);
      }
    } else {
#line 87
      return (0);
    }
#line 89
    goto switch_break;
    switch_default: 
#line 94
    goto transport_done;
    switch_break: ;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
  transport_done: 
#line 109
  if (! out) {
#line 111
    input += in;
#line 112
    length -= in;
  } else
#line 114
  if (in == length) {
#line 115
    length = out;
  } else
#line 116
  if (! (out == in)) {
#line 122
    if (! (out < in)) {
      {
      {
#line 122
      __assert_fail("out < in", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp-transport.c",
                    122U, "nettle_sexp_transport_iterator_first");
      }
      }
    }
    {
    {
#line 123
    memmove((void *)(input + out), (void const   *)(input + in), length - in);
    }
#line 124
    length -= in - out;
    }
  }
  {
  {
#line 127
  tmp___1 = nettle_sexp_iterator_first(iterator, length, (uint8_t const   *)input);
  }
  }
#line 127
  return (tmp___1);
}
}
#line 186 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.h"
unsigned int nettle_sexp_vformat(struct nettle_buffer *buffer , char const   *format ,
                                 va_list args ) ;
#line 193
unsigned int nettle_sexp_transport_format(struct nettle_buffer *buffer , char const   *format 
                                          , ...) ;
#line 197
unsigned int nettle_sexp_transport_vformat(struct nettle_buffer *buffer , char const   *format ,
                                           va_list args ) ;
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64.h"
void nettle_base64_encode_raw(uint8_t *dst , unsigned int length , uint8_t const   *src ) ;
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.h"
int nettle_buffer_grow(struct nettle_buffer *buffer , unsigned int length ) ;
#line 81
uint8_t *nettle_buffer_space(struct nettle_buffer *buffer , unsigned int length ) ;
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp-transport-format.c"
unsigned int nettle_sexp_transport_vformat(struct nettle_buffer *buffer , char const   *format ,
                                           va_list args ) 
{ 
  unsigned int start ;
  unsigned int length ;
  unsigned int base64_length ;
  int tmp ;
  unsigned int tmp___0 ;
  uint8_t *tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 39
  start = 0U;
#line 43
  if (buffer) {
#line 45
    if (buffer->size < buffer->alloc) {
#line 45
      tmp___0 = buffer->size;
#line 45
      (buffer->size) ++;
#line 45
      *(buffer->contents + tmp___0) = (uint8_t )'{';
    } else {
      {
      {
#line 45
      tmp = nettle_buffer_grow(buffer, 1U);
      }
      }
#line 45
      if (tmp) {
#line 45
        tmp___0 = buffer->size;
#line 45
        (buffer->size) ++;
#line 45
        *(buffer->contents + tmp___0) = (uint8_t )'{';
      } else {
#line 46
        return (0U);
      }
    }
#line 48
    start = buffer->size;
  }
  {
  {
#line 51
  length = nettle_sexp_vformat(buffer, format, args);
  }
  }
#line 53
  if (! length) {
#line 54
    return (0U);
  }
#line 56
  base64_length = ((length + 2U) / 3U) * 4U;
#line 58
  if (buffer) {
    {
    {
#line 63
    tmp___1 = nettle_buffer_space(buffer, base64_length - length);
    }
    }
#line 63
    if (! tmp___1) {
#line 64
      return (0U);
    }
    {
    {
#line 66
    nettle_base64_encode_raw(buffer->contents + start, length, (uint8_t const   *)(buffer->contents + start));
    }
    }
#line 69
    if (buffer->size < buffer->alloc) {
#line 69
      tmp___3 = buffer->size;
#line 69
      (buffer->size) ++;
#line 69
      *(buffer->contents + tmp___3) = (uint8_t )'}';
    } else {
      {
      {
#line 69
      tmp___2 = nettle_buffer_grow(buffer, 1U);
      }
      }
#line 69
      if (tmp___2) {
#line 69
        tmp___3 = buffer->size;
#line 69
        (buffer->size) ++;
#line 69
        *(buffer->contents + tmp___3) = (uint8_t )'}';
      } else {
#line 70
        return (0U);
      }
    }
  }
#line 73
  return (base64_length + 2U);
}
}
#line 76 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp-transport-format.c"
unsigned int nettle_sexp_transport_format(struct nettle_buffer *buffer , char const   *format 
                                          , ...) 
{ 
  unsigned int done ;
  va_list args ;

  {
  {
  {
#line 83
  __builtin_va_start(args, format);
  }
  {
#line 84
  done = nettle_sexp_transport_vformat(buffer, format, args);
  }
  {
#line 85
  __builtin_va_end(args);
  }
  }
#line 87
  return (done);
}
}
#line 282 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 182 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp.h"
unsigned int nettle_sexp_format(struct nettle_buffer *buffer , char const   *format 
                                , ...) ;
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.h"
int nettle_buffer_write(struct nettle_buffer *buffer , unsigned int length , uint8_t const   *data ) ;
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.h"
unsigned int nettle_mpz_sizeinbase_256_s(__mpz_struct * const  x ) ;
#line 46
void nettle_mpz_get_str_256(unsigned int length , uint8_t *s , __mpz_struct * const  x ) ;
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp-format.c"
static unsigned int format_prefix(struct nettle_buffer *buffer , unsigned int length ) 
{ 
  unsigned int digit ;
  unsigned int prefix_length ;
  unsigned int next ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 48
  digit = 1U;
#line 49
  prefix_length = 1U;
  {
  {
#line 51
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 53
    next = digit * 10U;
#line 54
    if (next > length) {
#line 55
      goto while_break;
    }
#line 57
    prefix_length ++;
#line 58
    digit = next;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 61
  if (buffer) {
    {
    {
#line 63
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 63
      if (! digit) {
#line 63
        goto while_break___0;
      }
#line 64
      if (buffer->size < buffer->alloc) {
#line 64
        tmp___0 = buffer->size;
#line 64
        (buffer->size) ++;
#line 64
        *(buffer->contents + tmp___0) = (uint8_t )(48U + length / digit);
      } else {
        {
        {
#line 64
        tmp = nettle_buffer_grow(buffer, 1U);
        }
        }
#line 64
        if (tmp) {
#line 64
          tmp___0 = buffer->size;
#line 64
          (buffer->size) ++;
#line 64
          *(buffer->contents + tmp___0) = (uint8_t )(48U + length / digit);
        } else {
#line 65
          return (0U);
        }
      }
#line 63
      length %= digit;
#line 63
      digit /= 10U;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 67
    if (buffer->size < buffer->alloc) {
#line 67
      tmp___2 = buffer->size;
#line 67
      (buffer->size) ++;
#line 67
      *(buffer->contents + tmp___2) = (uint8_t )':';
    } else {
      {
      {
#line 67
      tmp___1 = nettle_buffer_grow(buffer, 1U);
      }
      }
#line 67
      if (tmp___1) {
#line 67
        tmp___2 = buffer->size;
#line 67
        (buffer->size) ++;
#line 67
        *(buffer->contents + tmp___2) = (uint8_t )':';
      } else {
#line 68
        return (0U);
      }
    }
  }
#line 71
  return (prefix_length + 1U);
}
}
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp-format.c"
static unsigned int format_string(struct nettle_buffer *buffer , unsigned int length ,
                                  uint8_t const   *s ) 
{ 
  unsigned int prefix_length ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 78
  tmp = format_prefix(buffer, length);
  }
#line 78
  prefix_length = tmp;
  }
#line 79
  if (! prefix_length) {
#line 80
    return (0U);
  }
#line 82
  if (buffer) {
    {
    {
#line 82
    tmp___0 = nettle_buffer_write(buffer, length, s);
    }
    }
#line 82
    if (! tmp___0) {
#line 83
      return (0U);
    }
  }
#line 85
  return (prefix_length + length);
}
}
#line 88 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp-format.c"
unsigned int nettle_sexp_vformat(struct nettle_buffer *buffer , char const   *format ,
                                 va_list args ) 
{ 
  unsigned int nesting ;
  unsigned int done ;
  char const   *tmp ;
  char const   *start ;
  unsigned int length ;
  size_t tmp___0 ;
  unsigned int output_length ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int nul_flag ;
  char const   *tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  char const   *s ;
  unsigned int length___0 ;
  unsigned int output_length___0 ;
  char const   *tmp___9 ;
  unsigned int tmp___10 ;
  char const   *tmp___11 ;
  char const   *s___0 ;
  unsigned int length___1 ;
  unsigned int output_length___1 ;
  char const   *tmp___12 ;
  unsigned int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  unsigned int tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___18 ;
  char const   *s___1 ;
  unsigned int length___2 ;
  char const   *tmp___19 ;
  unsigned int tmp___20 ;
  char const   *tmp___21 ;
  int tmp___22 ;
  uint32_t x ;
  uint32_t tmp___24 ;
  unsigned int length___3 ;
  int tmp___25 ;
  unsigned int tmp___26 ;
  int tmp___27 ;
  unsigned int tmp___28 ;
  int tmp___29 ;
  unsigned int tmp___30 ;
  int tmp___31 ;
  unsigned int tmp___32 ;
  int tmp___33 ;
  unsigned int tmp___34 ;
  int tmp___35 ;
  unsigned int tmp___36 ;
  int tmp___37 ;
  unsigned int tmp___38 ;
  MP_INT const   *n ;
  MP_INT const   *tmp___40 ;
  unsigned int length___4 ;
  unsigned int prefix_length ;
  uint8_t *space ;
  uint8_t *tmp___41 ;
  char const   *tmp___42 ;
  unsigned int tmp___43 ;
  char const   *tmp___44 ;
  char const   *tmp___45 ;
  unsigned int tmp___46 ;
  char const   *tmp___47 ;
  char const   *tmp___48 ;
  unsigned int tmp___49 ;
  char const   *tmp___50 ;
  uint32_t tmp___51 ;
  MP_INT const   *tmp___52 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;

  {
#line 91
  nesting = 0U;
#line 92
  done = 0U;
  {
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 95
    tmp = format;
#line 95
    format ++;
#line 110
    if ((int const   )*tmp == 9) {
#line 110
      goto case_9;
    }
#line 110
    if ((int const   )*tmp == 32) {
#line 110
      goto case_9;
    }
#line 113
    if ((int const   )*tmp == 0) {
#line 113
      goto case_0;
    }
#line 118
    if ((int const   )*tmp == 40) {
#line 118
      goto case_40;
    }
#line 126
    if ((int const   )*tmp == 41) {
#line 126
      goto case_41;
    }
#line 135
    if ((int const   )*tmp == 37) {
#line 135
      goto case_37;
    }
#line 97
    goto switch_default;
    switch_default: 
    {
#line 99
    start = format - 1;
    {
#line 100
    tmp___0 = strcspn(format, "()% \t");
    }
#line 100
    length = 1U + tmp___0;
    {
#line 101
    tmp___1 = format_string(buffer, length, (uint8_t const   *)start);
    }
#line 101
    output_length = tmp___1;
    }
#line 102
    if (! output_length) {
#line 103
      return (0U);
    }
#line 105
    done += output_length;
#line 106
    format = start + length;
#line 108
    goto switch_break;
    case_9: 
#line 111
    goto switch_break;
    case_0: 
#line 114
    if (! (! nesting)) {
      {
      {
#line 114
      __assert_fail("!nesting", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp-format.c",
                    114U, "nettle_sexp_vformat");
      }
      }
    }
#line 116
    return (done);
    case_40: 
#line 119
    if (buffer) {
#line 119
      if (buffer->size < buffer->alloc) {
#line 119
        tmp___3 = buffer->size;
#line 119
        (buffer->size) ++;
#line 119
        *(buffer->contents + tmp___3) = (uint8_t )'(';
      } else {
        {
        {
#line 119
        tmp___2 = nettle_buffer_grow(buffer, 1U);
        }
        }
#line 119
        if (tmp___2) {
#line 119
          tmp___3 = buffer->size;
#line 119
          (buffer->size) ++;
#line 119
          *(buffer->contents + tmp___3) = (uint8_t )'(';
        } else {
#line 120
          return (0U);
        }
      }
    }
#line 122
    done ++;
#line 123
    nesting ++;
#line 124
    goto switch_break;
    case_41: 
#line 127
    if (! nesting) {
      {
      {
#line 127
      __assert_fail("nesting", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp-format.c",
                    127U, "nettle_sexp_vformat");
      }
      }
    }
#line 128
    if (buffer) {
#line 128
      if (buffer->size < buffer->alloc) {
#line 128
        tmp___5 = buffer->size;
#line 128
        (buffer->size) ++;
#line 128
        *(buffer->contents + tmp___5) = (uint8_t )')';
      } else {
        {
        {
#line 128
        tmp___4 = nettle_buffer_grow(buffer, 1U);
        }
        }
#line 128
        if (tmp___4) {
#line 128
          tmp___5 = buffer->size;
#line 128
          (buffer->size) ++;
#line 128
          *(buffer->contents + tmp___5) = (uint8_t )')';
        } else {
#line 129
          return (0U);
        }
      }
    }
#line 131
    done ++;
#line 132
    nesting --;
#line 133
    goto switch_break;
    case_37: 
#line 137
    nul_flag = 0;
#line 139
    if ((int const   )*format == 48) {
#line 141
      format ++;
#line 142
      nul_flag = 1;
    }
#line 144
    tmp___6 = format;
#line 144
    format ++;
#line 150
    if ((int const   )*tmp___6 == 41) {
#line 150
      goto case_41___0;
    }
#line 150
    if ((int const   )*tmp___6 == 40) {
#line 150
      goto case_41___0;
    }
#line 157
    if ((int const   )*tmp___6 == 115) {
#line 157
      goto case_115;
    }
#line 181
    if ((int const   )*tmp___6 == 116) {
#line 181
      goto case_116;
    }
#line 221
    if ((int const   )*tmp___6 == 108) {
#line 221
      goto case_108;
    }
#line 243
    if ((int const   )*tmp___6 == 105) {
#line 243
      goto case_105;
    }
#line 294
    if ((int const   )*tmp___6 == 98) {
#line 294
      goto case_98;
    }
#line 146
    goto switch_default___0;
    switch_default___0: 
    {
    {
#line 147
    abort();
    }
    }
    case_41___0: 
#line 152
    if (buffer) {
#line 152
      if (buffer->size < buffer->alloc) {
#line 152
        tmp___8 = buffer->size;
#line 152
        (buffer->size) ++;
#line 152
        *(buffer->contents + tmp___8) = (uint8_t )*(format + -1);
      } else {
        {
        {
#line 152
        tmp___7 = nettle_buffer_grow(buffer, 1U);
        }
        }
#line 152
        if (tmp___7) {
#line 152
          tmp___8 = buffer->size;
#line 152
          (buffer->size) ++;
#line 152
          *(buffer->contents + tmp___8) = (uint8_t )*(format + -1);
        } else {
#line 153
          return (0U);
        }
      }
    }
#line 154
    done ++;
#line 155
    goto switch_break___0;
    case_115: 
#line 163
    if (nul_flag) {
      {
      {
#line 165
      tmp___42 = __builtin_va_arg(args, char const   *);
      }
#line 165
      tmp___9 = tmp___42;
#line 165
      s = tmp___9;
      {
#line 166
      length___0 = strlen(s);
      }
      }
    } else {
      {
      {
#line 170
      tmp___43 = __builtin_va_arg(args, unsigned int );
      }
#line 170
      tmp___10 = tmp___43;
#line 170
      length___0 = tmp___10;
      {
#line 171
      tmp___44 = __builtin_va_arg(args, char const   *);
      }
#line 171
      tmp___11 = tmp___44;
#line 171
      s = tmp___11;
      }
    }
    {
    {
#line 174
    output_length___0 = format_string(buffer, length___0, (uint8_t const   *)s);
    }
    }
#line 175
    if (! output_length___0) {
#line 176
      return (0U);
    }
#line 178
    done += output_length___0;
#line 179
    goto switch_break___0;
    case_116: 
#line 187
    if (nul_flag) {
      {
      {
#line 189
      tmp___45 = __builtin_va_arg(args, char const   *);
      }
#line 189
      tmp___12 = tmp___45;
#line 189
      s___0 = tmp___12;
      }
#line 190
      if (! s___0) {
#line 191
        goto switch_break___0;
      }
      {
      {
#line 193
      length___1 = strlen(s___0);
      }
      }
    } else {
      {
      {
#line 197
      tmp___46 = __builtin_va_arg(args, unsigned int );
      }
#line 197
      tmp___13 = tmp___46;
#line 197
      length___1 = tmp___13;
      {
#line 198
      tmp___47 = __builtin_va_arg(args, char const   *);
      }
#line 198
      tmp___14 = tmp___47;
#line 198
      s___0 = tmp___14;
      }
#line 199
      if (! s___0) {
#line 200
        goto switch_break___0;
      }
    }
#line 203
    if (buffer) {
#line 203
      if (buffer->size < buffer->alloc) {
#line 203
        tmp___16 = buffer->size;
#line 203
        (buffer->size) ++;
#line 203
        *(buffer->contents + tmp___16) = (uint8_t )'[';
      } else {
        {
        {
#line 203
        tmp___15 = nettle_buffer_grow(buffer, 1U);
        }
        }
#line 203
        if (tmp___15) {
#line 203
          tmp___16 = buffer->size;
#line 203
          (buffer->size) ++;
#line 203
          *(buffer->contents + tmp___16) = (uint8_t )'[';
        } else {
#line 204
          return (0U);
        }
      }
    }
    {
#line 205
    done ++;
    {
#line 207
    output_length___1 = format_string(buffer, length___1, (uint8_t const   *)s___0);
    }
    }
#line 209
    if (! output_length___1) {
#line 210
      return (0U);
    }
#line 212
    done += output_length___1;
#line 214
    if (buffer) {
#line 214
      if (buffer->size < buffer->alloc) {
#line 214
        tmp___18 = buffer->size;
#line 214
        (buffer->size) ++;
#line 214
        *(buffer->contents + tmp___18) = (uint8_t )']';
      } else {
        {
        {
#line 214
        tmp___17 = nettle_buffer_grow(buffer, 1U);
        }
        }
#line 214
        if (tmp___17) {
#line 214
          tmp___18 = buffer->size;
#line 214
          (buffer->size) ++;
#line 214
          *(buffer->contents + tmp___18) = (uint8_t )']';
        } else {
#line 215
          return (0U);
        }
      }
    }
#line 216
    done ++;
#line 218
    goto switch_break___0;
    case_108: 
#line 226
    if (nul_flag) {
      {
      {
#line 228
      tmp___48 = __builtin_va_arg(args, char const   *);
      }
#line 228
      tmp___19 = tmp___48;
#line 228
      s___1 = tmp___19;
      {
#line 229
      length___2 = strlen(s___1);
      }
      }
    } else {
      {
      {
#line 233
      tmp___49 = __builtin_va_arg(args, unsigned int );
      }
#line 233
      tmp___20 = tmp___49;
#line 233
      length___2 = tmp___20;
      {
#line 234
      tmp___50 = __builtin_va_arg(args, char const   *);
      }
#line 234
      tmp___21 = tmp___50;
#line 234
      s___1 = tmp___21;
      }
    }
#line 237
    if (buffer) {
      {
      {
#line 237
      tmp___22 = nettle_buffer_write(buffer, length___2, (uint8_t const   *)s___1);
      }
      }
#line 237
      if (! tmp___22) {
#line 238
        return (0U);
      }
    }
#line 240
    done += length___2;
#line 241
    goto switch_break___0;
    case_105: 
    {
    {
#line 245
    tmp___51 = __builtin_va_arg(args, uint32_t );
    }
#line 245
    tmp___24 = tmp___51;
#line 245
    x = tmp___24;
    }
#line 248
    if (x < 128U) {
#line 249
      length___3 = 1U;
    } else
#line 250
    if ((long )x < 32768L) {
#line 251
      length___3 = 2U;
    } else
#line 252
    if ((long )x < 8388608L) {
#line 253
      length___3 = 3U;
    } else
#line 254
    if ((long )x < 2147483648L) {
#line 255
      length___3 = 4U;
    } else {
#line 257
      length___3 = 5U;
    }
#line 259
    if (buffer) {
#line 259
      if (buffer->size < buffer->alloc) {
#line 259
        goto _L;
      } else {
        {
        {
#line 259
        tmp___25 = nettle_buffer_grow(buffer, 1U);
        }
        }
#line 259
        if (tmp___25) {
          _L: 
#line 259
          tmp___26 = buffer->size;
#line 259
          (buffer->size) ++;
#line 259
          *(buffer->contents + tmp___26) = (uint8_t )(48U + length___3);
#line 259
          if (buffer->size < buffer->alloc) {
#line 259
            tmp___28 = buffer->size;
#line 259
            (buffer->size) ++;
#line 259
            *(buffer->contents + tmp___28) = (uint8_t )':';
          } else {
            {
            {
#line 259
            tmp___27 = nettle_buffer_grow(buffer, 1U);
            }
            }
#line 259
            if (tmp___27) {
#line 259
              tmp___28 = buffer->size;
#line 259
              (buffer->size) ++;
#line 259
              *(buffer->contents + tmp___28) = (uint8_t )':';
            } else {
#line 261
              return (0U);
            }
          }
        } else {
#line 261
          return (0U);
        }
      }
    }
#line 263
    done += 2U + length___3;
#line 265
    if (buffer) {
#line 268
      if (length___3 == 5U) {
#line 268
        goto case_5;
      }
#line 273
      if (length___3 == 4U) {
#line 273
        goto case_4;
      }
#line 277
      if (length___3 == 3U) {
#line 277
        goto case_3;
      }
#line 281
      if (length___3 == 2U) {
#line 281
        goto case_2;
      }
#line 285
      if (length___3 == 1U) {
#line 285
        goto case_1;
      }
#line 289
      goto switch_default___1;
      case_5: 
#line 270
      if (buffer->size < buffer->alloc) {
#line 270
        tmp___30 = buffer->size;
#line 270
        (buffer->size) ++;
#line 270
        *(buffer->contents + tmp___30) = (uint8_t )0;
      } else {
        {
        {
#line 270
        tmp___29 = nettle_buffer_grow(buffer, 1U);
        }
        }
#line 270
        if (tmp___29) {
#line 270
          tmp___30 = buffer->size;
#line 270
          (buffer->size) ++;
#line 270
          *(buffer->contents + tmp___30) = (uint8_t )0;
        } else {
#line 271
          return (0U);
        }
      }
      case_4: 
#line 274
      if (buffer->size < buffer->alloc) {
#line 274
        tmp___32 = buffer->size;
#line 274
        (buffer->size) ++;
#line 274
        *(buffer->contents + tmp___32) = (uint8_t )(x >> 24);
      } else {
        {
        {
#line 274
        tmp___31 = nettle_buffer_grow(buffer, 1U);
        }
        }
#line 274
        if (tmp___31) {
#line 274
          tmp___32 = buffer->size;
#line 274
          (buffer->size) ++;
#line 274
          *(buffer->contents + tmp___32) = (uint8_t )(x >> 24);
        } else {
#line 275
          return (0U);
        }
      }
      case_3: 
#line 278
      if (buffer->size < buffer->alloc) {
#line 278
        tmp___34 = buffer->size;
#line 278
        (buffer->size) ++;
#line 278
        *(buffer->contents + tmp___34) = (uint8_t )((x >> 16) & 255U);
      } else {
        {
        {
#line 278
        tmp___33 = nettle_buffer_grow(buffer, 1U);
        }
        }
#line 278
        if (tmp___33) {
#line 278
          tmp___34 = buffer->size;
#line 278
          (buffer->size) ++;
#line 278
          *(buffer->contents + tmp___34) = (uint8_t )((x >> 16) & 255U);
        } else {
#line 279
          return (0U);
        }
      }
      case_2: 
#line 282
      if (buffer->size < buffer->alloc) {
#line 282
        tmp___36 = buffer->size;
#line 282
        (buffer->size) ++;
#line 282
        *(buffer->contents + tmp___36) = (uint8_t )((x >> 8) & 255U);
      } else {
        {
        {
#line 282
        tmp___35 = nettle_buffer_grow(buffer, 1U);
        }
        }
#line 282
        if (tmp___35) {
#line 282
          tmp___36 = buffer->size;
#line 282
          (buffer->size) ++;
#line 282
          *(buffer->contents + tmp___36) = (uint8_t )((x >> 8) & 255U);
        } else {
#line 283
          return (0U);
        }
      }
      case_1: 
#line 286
      if (buffer->size < buffer->alloc) {
#line 286
        tmp___38 = buffer->size;
#line 286
        (buffer->size) ++;
#line 286
        *(buffer->contents + tmp___38) = (uint8_t )(x & 255U);
      } else {
        {
        {
#line 286
        tmp___37 = nettle_buffer_grow(buffer, 1U);
        }
        }
#line 286
        if (tmp___37) {
#line 286
          tmp___38 = buffer->size;
#line 286
          (buffer->size) ++;
#line 286
          *(buffer->contents + tmp___38) = (uint8_t )(x & 255U);
        } else {
#line 287
          return (0U);
        }
      }
#line 288
      goto switch_break___1;
      switch_default___1: 
      {
      {
#line 290
      abort();
      }
      }
      switch_break___1: ;
    }
#line 292
    goto switch_break___0;
    case_98: 
    {
    {
#line 297
    tmp___52 = __builtin_va_arg(args, MP_INT const   *);
    }
#line 297
    tmp___40 = tmp___52;
#line 297
    n = tmp___40;
    {
#line 301
    length___4 = nettle_mpz_sizeinbase_256_s((__mpz_struct */* const  */)((__mpz_struct *)n));
    }
    {
#line 302
    prefix_length = format_prefix(buffer, length___4);
    }
    }
#line 303
    if (! prefix_length) {
#line 304
      return (0U);
    }
#line 306
    done += prefix_length;
#line 308
    if (buffer) {
      {
      {
#line 310
      tmp___41 = nettle_buffer_space(buffer, length___4);
      }
#line 310
      space = tmp___41;
      }
#line 311
      if (! space) {
#line 312
        return (0U);
      }
      {
      {
#line 314
      nettle_mpz_get_str_256(length___4, space, (__mpz_struct */* const  */)((__mpz_struct *)n));
      }
      }
    }
#line 317
    done += length___4;
#line 322
    goto switch_break___0;
    switch_break___0: ;
    switch_break: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 331
  return (0U);
}
}
#line 329 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/sexp-format.c"
unsigned int nettle_sexp_format(struct nettle_buffer *buffer , char const   *format 
                                , ...) 
{ 
  va_list args ;
  unsigned int done ;

  {
  {
  {
#line 335
  __builtin_va_start(args, format);
  }
  {
#line 336
  done = nettle_sexp_vformat(buffer, format, args);
  }
  {
#line 337
  __builtin_va_end(args);
  }
  }
#line 339
  return (done);
}
}
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent.h"
void nettle_serpent_set_key(struct serpent_ctx *ctx , unsigned int key_size , uint8_t const   *key ) ;
#line 64
void nettle_serpent_encrypt(struct serpent_ctx *ctx , unsigned int length , uint8_t *dst ,
                            uint8_t const   *plain ) ;
#line 68
void nettle_serpent_decrypt(struct serpent_ctx *ctx , unsigned int length , uint8_t *dst ,
                            uint8_t const   *cipher ) ;
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent.c"
void nettle_serpent_set_key(struct serpent_ctx *ctx , unsigned int key_size , uint8_t const   *key ) 
{ 
  unsigned int i ;
  unsigned int j ;
  uint32_t w[132] ;
  uint32_t k[132] ;
  uint32_t partial ;
  uint8_t const   *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  register uint32_t t02 ;
  register uint32_t t03 ;
  register uint32_t t04 ;
  register uint32_t t05 ;
  register uint32_t t06 ;
  register uint32_t t07 ;
  register uint32_t t08 ;
  register uint32_t t09 ;
  register uint32_t t10 ;
  register uint32_t t11 ;
  register uint32_t t13 ;
  register uint32_t t14 ;
  register uint32_t t15 ;
  register uint32_t t01 ;
  register uint32_t t02___0 ;
  register uint32_t t03___0 ;
  register uint32_t t05___0 ;
  register uint32_t t06___0 ;
  register uint32_t t07___0 ;
  register uint32_t t08___0 ;
  register uint32_t t09___0 ;
  register uint32_t t10___0 ;
  register uint32_t t12 ;
  register uint32_t t13___0 ;
  register uint32_t t14___0 ;
  register uint32_t t01___0 ;
  register uint32_t t02___1 ;
  register uint32_t t03___1 ;
  register uint32_t t04___0 ;
  register uint32_t t05___1 ;
  register uint32_t t06___1 ;
  register uint32_t t07___1 ;
  register uint32_t t08___1 ;
  register uint32_t t10___1 ;
  register uint32_t t11___0 ;
  register uint32_t t12___0 ;
  register uint32_t t13___1 ;
  register uint32_t t16 ;
  register uint32_t t17 ;
  register uint32_t t01___1 ;
  register uint32_t t02___2 ;
  register uint32_t t03___2 ;
  register uint32_t t05___2 ;
  register uint32_t t06___2 ;
  register uint32_t t07___2 ;
  register uint32_t t08___2 ;
  register uint32_t t09___1 ;
  register uint32_t t11___1 ;
  register uint32_t t12___1 ;
  register uint32_t t13___2 ;
  register uint32_t t14___1 ;
  register uint32_t t15___0 ;
  register uint32_t t17___0 ;
  register uint32_t t01___2 ;
  register uint32_t t02___3 ;
  register uint32_t t03___3 ;
  register uint32_t t04___1 ;
  register uint32_t t05___3 ;
  register uint32_t t06___3 ;
  register uint32_t t08___3 ;
  register uint32_t t09___2 ;
  register uint32_t t10___2 ;
  register uint32_t t11___2 ;
  register uint32_t t13___3 ;
  register uint32_t t14___2 ;
  register uint32_t t15___1 ;
  register uint32_t t16___0 ;
  register uint32_t t17___1 ;
  register uint32_t t01___3 ;
  register uint32_t t02___4 ;
  register uint32_t t03___4 ;
  register uint32_t t04___2 ;
  register uint32_t t05___4 ;
  register uint32_t t07___3 ;
  register uint32_t t08___4 ;
  register uint32_t t09___3 ;
  register uint32_t t10___3 ;
  register uint32_t t11___3 ;
  register uint32_t t12___2 ;
  register uint32_t t13___4 ;
  register uint32_t t15___2 ;
  register uint32_t t17___2 ;
  register uint32_t t18 ;
  register uint32_t t01___4 ;
  register uint32_t t02___5 ;
  register uint32_t t03___5 ;
  register uint32_t t04___3 ;
  register uint32_t t05___5 ;
  register uint32_t t07___4 ;
  register uint32_t t08___5 ;
  register uint32_t t09___4 ;
  register uint32_t t10___4 ;
  register uint32_t t11___4 ;
  register uint32_t t12___3 ;
  register uint32_t t13___5 ;
  register uint32_t t14___3 ;
  register uint32_t t01___5 ;
  register uint32_t t02___6 ;
  register uint32_t t03___6 ;
  register uint32_t t04___4 ;
  register uint32_t t05___6 ;
  register uint32_t t06___4 ;
  register uint32_t t08___6 ;
  register uint32_t t09___5 ;
  register uint32_t t10___5 ;
  register uint32_t t11___5 ;
  register uint32_t t12___4 ;
  register uint32_t t13___6 ;
  register uint32_t t14___4 ;
  register uint32_t t15___3 ;
  register uint32_t t16___1 ;
  register uint32_t t01___6 ;
  register uint32_t t02___7 ;
  register uint32_t t03___7 ;
  register uint32_t t04___5 ;
  register uint32_t t05___7 ;
  register uint32_t t06___5 ;
  register uint32_t t07___5 ;
  register uint32_t t08___7 ;
  register uint32_t t09___6 ;
  register uint32_t t10___6 ;
  register uint32_t t11___6 ;
  register uint32_t t13___7 ;
  register uint32_t t14___5 ;
  register uint32_t t15___4 ;
  register uint32_t t01___7 ;
  register uint32_t t02___8 ;
  register uint32_t t03___8 ;
  register uint32_t t05___8 ;
  register uint32_t t06___6 ;
  register uint32_t t07___6 ;
  register uint32_t t08___8 ;
  register uint32_t t09___7 ;
  register uint32_t t10___7 ;
  register uint32_t t12___5 ;
  register uint32_t t13___8 ;
  register uint32_t t14___6 ;
  register uint32_t t01___8 ;
  register uint32_t t02___9 ;
  register uint32_t t03___9 ;
  register uint32_t t04___6 ;
  register uint32_t t05___9 ;
  register uint32_t t06___7 ;
  register uint32_t t07___7 ;
  register uint32_t t08___9 ;
  register uint32_t t10___8 ;
  register uint32_t t11___7 ;
  register uint32_t t12___6 ;
  register uint32_t t13___9 ;
  register uint32_t t16___2 ;
  register uint32_t t17___3 ;
  register uint32_t t01___9 ;
  register uint32_t t02___10 ;
  register uint32_t t03___10 ;
  register uint32_t t05___10 ;
  register uint32_t t06___8 ;
  register uint32_t t07___8 ;
  register uint32_t t08___10 ;
  register uint32_t t09___8 ;
  register uint32_t t11___8 ;
  register uint32_t t12___7 ;
  register uint32_t t13___10 ;
  register uint32_t t14___7 ;
  register uint32_t t15___5 ;
  register uint32_t t17___4 ;
  register uint32_t t01___10 ;
  register uint32_t t02___11 ;
  register uint32_t t03___11 ;
  register uint32_t t04___7 ;
  register uint32_t t05___11 ;
  register uint32_t t06___9 ;
  register uint32_t t08___11 ;
  register uint32_t t09___9 ;
  register uint32_t t10___9 ;
  register uint32_t t11___9 ;
  register uint32_t t13___11 ;
  register uint32_t t14___8 ;
  register uint32_t t15___6 ;
  register uint32_t t16___3 ;
  register uint32_t t17___5 ;
  register uint32_t t01___11 ;
  register uint32_t t02___12 ;
  register uint32_t t03___12 ;
  register uint32_t t04___8 ;
  register uint32_t t05___12 ;
  register uint32_t t07___9 ;
  register uint32_t t08___12 ;
  register uint32_t t09___10 ;
  register uint32_t t10___10 ;
  register uint32_t t11___10 ;
  register uint32_t t12___8 ;
  register uint32_t t13___12 ;
  register uint32_t t15___7 ;
  register uint32_t t17___6 ;
  register uint32_t t18___0 ;
  register uint32_t t01___12 ;
  register uint32_t t02___13 ;
  register uint32_t t03___13 ;
  register uint32_t t04___9 ;
  register uint32_t t05___13 ;
  register uint32_t t07___10 ;
  register uint32_t t08___13 ;
  register uint32_t t09___11 ;
  register uint32_t t10___11 ;
  register uint32_t t11___11 ;
  register uint32_t t12___9 ;
  register uint32_t t13___13 ;
  register uint32_t t14___9 ;
  register uint32_t t01___13 ;
  register uint32_t t02___14 ;
  register uint32_t t03___14 ;
  register uint32_t t04___10 ;
  register uint32_t t05___14 ;
  register uint32_t t06___10 ;
  register uint32_t t08___14 ;
  register uint32_t t09___12 ;
  register uint32_t t10___12 ;
  register uint32_t t11___12 ;
  register uint32_t t12___10 ;
  register uint32_t t13___14 ;
  register uint32_t t14___10 ;
  register uint32_t t15___8 ;
  register uint32_t t16___4 ;
  register uint32_t t01___14 ;
  register uint32_t t02___15 ;
  register uint32_t t03___15 ;
  register uint32_t t04___11 ;
  register uint32_t t05___15 ;
  register uint32_t t06___11 ;
  register uint32_t t07___11 ;
  register uint32_t t08___15 ;
  register uint32_t t09___13 ;
  register uint32_t t10___13 ;
  register uint32_t t11___13 ;
  register uint32_t t13___15 ;
  register uint32_t t14___11 ;
  register uint32_t t15___9 ;
  register uint32_t t01___15 ;
  register uint32_t t02___16 ;
  register uint32_t t03___16 ;
  register uint32_t t05___16 ;
  register uint32_t t06___12 ;
  register uint32_t t07___12 ;
  register uint32_t t08___16 ;
  register uint32_t t09___14 ;
  register uint32_t t10___14 ;
  register uint32_t t12___11 ;
  register uint32_t t13___16 ;
  register uint32_t t14___12 ;
  register uint32_t t01___16 ;
  register uint32_t t02___17 ;
  register uint32_t t03___17 ;
  register uint32_t t04___12 ;
  register uint32_t t05___17 ;
  register uint32_t t06___13 ;
  register uint32_t t07___13 ;
  register uint32_t t08___17 ;
  register uint32_t t10___15 ;
  register uint32_t t11___14 ;
  register uint32_t t12___12 ;
  register uint32_t t13___17 ;
  register uint32_t t16___5 ;
  register uint32_t t17___7 ;
  register uint32_t t01___17 ;
  register uint32_t t02___18 ;
  register uint32_t t03___18 ;
  register uint32_t t05___18 ;
  register uint32_t t06___14 ;
  register uint32_t t07___14 ;
  register uint32_t t08___18 ;
  register uint32_t t09___15 ;
  register uint32_t t11___15 ;
  register uint32_t t12___13 ;
  register uint32_t t13___18 ;
  register uint32_t t14___13 ;
  register uint32_t t15___10 ;
  register uint32_t t17___8 ;
  register uint32_t t01___18 ;
  register uint32_t t02___19 ;
  register uint32_t t03___19 ;
  register uint32_t t04___13 ;
  register uint32_t t05___19 ;
  register uint32_t t06___15 ;
  register uint32_t t08___19 ;
  register uint32_t t09___16 ;
  register uint32_t t10___16 ;
  register uint32_t t11___16 ;
  register uint32_t t13___19 ;
  register uint32_t t14___14 ;
  register uint32_t t15___11 ;
  register uint32_t t16___6 ;
  register uint32_t t17___9 ;
  register uint32_t t01___19 ;
  register uint32_t t02___20 ;
  register uint32_t t03___20 ;
  register uint32_t t04___14 ;
  register uint32_t t05___20 ;
  register uint32_t t07___15 ;
  register uint32_t t08___20 ;
  register uint32_t t09___17 ;
  register uint32_t t10___17 ;
  register uint32_t t11___17 ;
  register uint32_t t12___14 ;
  register uint32_t t13___20 ;
  register uint32_t t15___12 ;
  register uint32_t t17___10 ;
  register uint32_t t18___1 ;
  register uint32_t t01___20 ;
  register uint32_t t02___21 ;
  register uint32_t t03___21 ;
  register uint32_t t04___15 ;
  register uint32_t t05___21 ;
  register uint32_t t07___16 ;
  register uint32_t t08___21 ;
  register uint32_t t09___18 ;
  register uint32_t t10___18 ;
  register uint32_t t11___18 ;
  register uint32_t t12___15 ;
  register uint32_t t13___21 ;
  register uint32_t t14___15 ;
  register uint32_t t01___21 ;
  register uint32_t t02___22 ;
  register uint32_t t03___22 ;
  register uint32_t t04___16 ;
  register uint32_t t05___22 ;
  register uint32_t t06___16 ;
  register uint32_t t08___22 ;
  register uint32_t t09___19 ;
  register uint32_t t10___19 ;
  register uint32_t t11___19 ;
  register uint32_t t12___16 ;
  register uint32_t t13___22 ;
  register uint32_t t14___16 ;
  register uint32_t t15___13 ;
  register uint32_t t16___7 ;
  register uint32_t t01___22 ;
  register uint32_t t02___23 ;
  register uint32_t t03___23 ;
  register uint32_t t04___17 ;
  register uint32_t t05___23 ;
  register uint32_t t06___17 ;
  register uint32_t t07___17 ;
  register uint32_t t08___23 ;
  register uint32_t t09___20 ;
  register uint32_t t10___20 ;
  register uint32_t t11___20 ;
  register uint32_t t13___23 ;
  register uint32_t t14___17 ;
  register uint32_t t15___14 ;
  register uint32_t t01___23 ;
  register uint32_t t02___24 ;
  register uint32_t t03___24 ;
  register uint32_t t05___24 ;
  register uint32_t t06___18 ;
  register uint32_t t07___18 ;
  register uint32_t t08___24 ;
  register uint32_t t09___21 ;
  register uint32_t t10___21 ;
  register uint32_t t12___17 ;
  register uint32_t t13___24 ;
  register uint32_t t14___18 ;
  register uint32_t t01___24 ;
  register uint32_t t02___25 ;
  register uint32_t t03___25 ;
  register uint32_t t04___18 ;
  register uint32_t t05___25 ;
  register uint32_t t06___19 ;
  register uint32_t t07___19 ;
  register uint32_t t08___25 ;
  register uint32_t t10___22 ;
  register uint32_t t11___21 ;
  register uint32_t t12___18 ;
  register uint32_t t13___25 ;
  register uint32_t t16___8 ;
  register uint32_t t17___11 ;
  register uint32_t t01___25 ;
  register uint32_t t02___26 ;
  register uint32_t t03___26 ;
  register uint32_t t05___26 ;
  register uint32_t t06___20 ;
  register uint32_t t07___20 ;
  register uint32_t t08___26 ;
  register uint32_t t09___22 ;
  register uint32_t t11___22 ;
  register uint32_t t12___19 ;
  register uint32_t t13___26 ;
  register uint32_t t14___19 ;
  register uint32_t t15___15 ;
  register uint32_t t17___12 ;
  register uint32_t t01___26 ;
  register uint32_t t02___27 ;
  register uint32_t t03___27 ;
  register uint32_t t04___19 ;
  register uint32_t t05___27 ;
  register uint32_t t06___21 ;
  register uint32_t t08___27 ;
  register uint32_t t09___23 ;
  register uint32_t t10___23 ;
  register uint32_t t11___23 ;
  register uint32_t t13___27 ;
  register uint32_t t14___20 ;
  register uint32_t t15___16 ;
  register uint32_t t16___9 ;
  register uint32_t t17___13 ;
  register uint32_t t01___27 ;
  register uint32_t t02___28 ;
  register uint32_t t03___28 ;
  register uint32_t t04___20 ;
  register uint32_t t05___28 ;
  register uint32_t t07___21 ;
  register uint32_t t08___28 ;
  register uint32_t t09___24 ;
  register uint32_t t10___24 ;
  register uint32_t t11___24 ;
  register uint32_t t12___20 ;
  register uint32_t t13___28 ;
  register uint32_t t15___17 ;
  register uint32_t t17___14 ;
  register uint32_t t18___2 ;
  register uint32_t t01___28 ;
  register uint32_t t02___29 ;
  register uint32_t t03___29 ;
  register uint32_t t04___21 ;
  register uint32_t t05___29 ;
  register uint32_t t07___22 ;
  register uint32_t t08___29 ;
  register uint32_t t09___25 ;
  register uint32_t t10___25 ;
  register uint32_t t11___25 ;
  register uint32_t t12___21 ;
  register uint32_t t13___29 ;
  register uint32_t t14___21 ;
  register uint32_t t01___29 ;
  register uint32_t t02___30 ;
  register uint32_t t03___30 ;
  register uint32_t t04___22 ;
  register uint32_t t05___30 ;
  register uint32_t t06___22 ;
  register uint32_t t08___30 ;
  register uint32_t t09___26 ;
  register uint32_t t10___26 ;
  register uint32_t t11___26 ;
  register uint32_t t12___22 ;
  register uint32_t t13___30 ;
  register uint32_t t14___22 ;
  register uint32_t t15___18 ;
  register uint32_t t16___10 ;
  register uint32_t t01___30 ;
  register uint32_t t02___31 ;
  register uint32_t t03___31 ;
  register uint32_t t04___23 ;
  register uint32_t t05___31 ;
  register uint32_t t06___23 ;
  register uint32_t t07___23 ;
  register uint32_t t08___31 ;
  register uint32_t t09___27 ;
  register uint32_t t10___27 ;
  register uint32_t t11___27 ;
  register uint32_t t13___31 ;
  register uint32_t t14___23 ;
  register uint32_t t15___19 ;
  register uint32_t t01___31 ;
  void *__cil_tmp485 ;
  void *__cil_tmp486 ;
  char *__cil_tmp487 ;
  char *__cil_tmp488 ;
  char *__cil_tmp489 ;
  char *__cil_tmp490 ;
  char *__cil_tmp491 ;
  char *__cil_tmp492 ;
  char *__cil_tmp493 ;
  char *__cil_tmp494 ;
  char *__cil_tmp495 ;
  void *__cil_tmp496 ;
  void *__cil_tmp497 ;
  char *__cil_tmp498 ;
  char *__cil_tmp499 ;
  char *__cil_tmp500 ;
  char *__cil_tmp501 ;
  char *__cil_tmp502 ;
  char *__cil_tmp503 ;
  char *__cil_tmp504 ;
  char *__cil_tmp505 ;
  char *__cil_tmp506 ;

  {
#line 56
  if (! (key_size >= 16U)) {
    {
    {
#line 56
    __assert_fail("key_size >= 16", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent.c",
                  56U, "nettle_serpent_set_key");
    }
    }
  }
#line 57
  if (! (key_size <= 32U)) {
    {
    {
#line 57
    __assert_fail("key_size <= 32", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent.c",
                  57U, "nettle_serpent_set_key");
    }
    }
  }
#line 59
  i = key_size;
#line 59
  j = 0U;
  {
  {
#line 59
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 59
    if (! (i >= 4U)) {
#line 59
      goto while_break;
    }
#line 63
    if (! (j < 8U)) {
      {
      {
#line 63
      __assert_fail("j<8", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent.c",
                    63U, "nettle_serpent_set_key");
      }
      }
    }
#line 65
    w[j] = ((((uint32_t )*(((key + i) - 4) + 0) << 24) | ((uint32_t )*(((key + i) - 4) + 1) << 16)) | ((uint32_t )*(((key + i) - 4) + 2) << 8)) | (uint32_t )*(((key + i) - 4) + 3);
#line 59
    i -= 4U;
#line 59
    j ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 68
  if (j < 8U) {
#line 71
    partial = (uint32_t )1;
    {
    {
#line 72
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 72
      if (! i) {
#line 72
        goto while_break___0;
      }
#line 73
      tmp = key;
#line 73
      key ++;
#line 73
      partial = (partial << 8) | (unsigned int )*tmp;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 74
    tmp___0 = j;
#line 74
    j ++;
#line 74
    w[tmp___0] = partial;
    {
    {
#line 76
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;

#line 76
      if (! (j < 8U)) {
#line 76
        goto while_break___1;
      }
#line 77
      tmp___1 = j;
#line 77
      j ++;
#line 77
      w[tmp___1] = (uint32_t )0;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 80
  i = 8U;
  {
  {
#line 80
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;

#line 80
    if (! (i < 16U)) {
#line 80
      goto while_break___2;
    }
#line 81
    w[i] = ((uint32_t )(((long )(((w[i - 8U] ^ w[i - 5U]) ^ w[i - 3U]) ^ w[i - 1U]) ^ 2654435769L) ^ (long )(i - 8U)) << 11) | ((uint32_t )(((long )(((w[i - 8U] ^ w[i - 5U]) ^ w[i - 3U]) ^ w[i - 1U]) ^ 2654435769L) ^ (long )(i - 8U)) >> 21);
#line 80
    i ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___2: 
#line 82
  i = 0U;
  {
  {
#line 82
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;

#line 82
    if (! (i < 8U)) {
#line 82
      goto while_break___3;
    }
#line 83
    w[i] = w[i + 8U];
#line 82
    i ++;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___3: 
#line 84
  i = 8U;
  {
  {
#line 84
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;

#line 84
    if (! (i < 132U)) {
#line 84
      goto while_break___4;
    }
#line 85
    w[i] = ((uint32_t )(((long )(((w[i - 8U] ^ w[i - 5U]) ^ w[i - 3U]) ^ w[i - 1U]) ^ 2654435769L) ^ (long )i) << 11) | ((uint32_t )(((long )(((w[i - 8U] ^ w[i - 5U]) ^ w[i - 3U]) ^ w[i - 1U]) ^ 2654435769L) ^ (long )i) >> 21);
#line 84
    i ++;
  }
  while_break___20: /* CIL Label */ ;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___4: 
#line 87
  t01 = w[0] ^ w[2];
#line 87
  t02 = w[0] | w[3];
#line 87
  t03 = w[0] & w[3];
#line 87
  t04 = t01 & t02;
#line 87
  t05 = w[1] | t03;
#line 87
  t06 = w[0] & w[1];
#line 87
  t07 = w[3] ^ t04;
#line 87
  t08 = w[2] | t06;
#line 87
  t09 = w[1] ^ t07;
#line 87
  t10 = w[3] & t05;
#line 87
  t11 = t02 ^ t10;
#line 87
  k[3] = t08 ^ t09;
#line 87
  t13 = w[3] | k[3];
#line 87
  t14 = w[0] | t07;
#line 87
  t15 = w[1] & t13;
#line 87
  k[2] = t08 ^ t11;
#line 87
  k[0] = t14 ^ t15;
#line 87
  k[1] = t05 ^ t04;
#line 88
  t01___0 = w[4] | w[6];
#line 88
  t02___0 = w[4] ^ w[5];
#line 88
  t03___0 = w[7] ^ t01___0;
#line 88
  k[4] = t02___0 ^ t03___0;
#line 88
  t05___0 = w[6] ^ k[4];
#line 88
  t06___0 = w[5] ^ t05___0;
#line 88
  t07___0 = w[5] | t05___0;
#line 88
  t08___0 = t01___0 & t06___0;
#line 88
  t09___0 = t03___0 ^ t07___0;
#line 88
  t10___0 = t02___0 | t09___0;
#line 88
  k[5] = t10___0 ^ t08___0;
#line 88
  t12 = w[4] | w[7];
#line 88
  t13___0 = t09___0 ^ k[5];
#line 88
  t14___0 = w[5] ^ t13___0;
#line 88
  k[7] = ~ t09___0;
#line 88
  k[6] = t12 ^ t14___0;
#line 89
  t01___1 = w[8] | w[11];
#line 89
  t02___1 = w[10] ^ w[11];
#line 89
  t03___1 = ~ w[9];
#line 89
  t04___0 = w[8] ^ w[10];
#line 89
  t05___1 = w[8] | t03___1;
#line 89
  t06___1 = w[11] & t04___0;
#line 89
  t07___1 = t01___1 & t02___1;
#line 89
  t08___1 = w[9] | t06___1;
#line 89
  k[10] = t02___1 ^ t05___1;
#line 89
  t10___1 = t07___1 ^ t08___1;
#line 89
  t11___0 = t01___1 ^ t10___1;
#line 89
  t12___0 = k[10] ^ t11___0;
#line 89
  t13___1 = w[9] & w[11];
#line 89
  k[11] = ~ t10___1;
#line 89
  k[9] = t13___1 ^ t12___0;
#line 89
  t16 = t10___1 | k[9];
#line 89
  t17 = t05___1 & t16;
#line 89
  k[8] = w[10] ^ t17;
#line 90
  t01___2 = w[13] ^ w[14];
#line 90
  t02___2 = w[12] | w[15];
#line 90
  t03___2 = w[12] ^ w[13];
#line 90
  k[15] = t02___2 ^ t01___2;
#line 90
  t05___2 = w[14] | k[15];
#line 90
  t06___2 = w[12] ^ w[15];
#line 90
  t07___2 = w[13] | w[14];
#line 90
  t08___2 = w[15] & t05___2;
#line 90
  t09___1 = t03___2 & t07___2;
#line 90
  k[14] = t09___1 ^ t08___2;
#line 90
  t11___1 = t09___1 & k[14];
#line 90
  t12___1 = w[14] ^ w[15];
#line 90
  t13___2 = t07___2 ^ t11___1;
#line 90
  t14___1 = w[13] & t06___2;
#line 90
  t15___0 = t06___2 ^ t13___2;
#line 90
  k[12] = ~ t15___0;
#line 90
  t17___0 = k[12] ^ t14___1;
#line 90
  k[13] = t12___1 ^ t17___0;
#line 91
  t01___3 = w[16] & w[18];
#line 91
  t02___3 = ~ w[19];
#line 91
  t03___3 = w[16] & t02___3;
#line 91
  t04___1 = w[17] | t01___3;
#line 91
  t05___3 = w[16] & w[17];
#line 91
  t06___3 = w[18] ^ t04___1;
#line 91
  k[19] = t03___3 ^ t06___3;
#line 91
  t08___3 = w[18] | k[19];
#line 91
  t09___2 = w[19] | t05___3;
#line 91
  t10___2 = w[16] ^ t08___3;
#line 91
  t11___2 = t04___1 & k[19];
#line 91
  k[17] = t09___2 ^ t10___2;
#line 91
  t13___3 = w[17] ^ k[17];
#line 91
  t14___2 = t01___3 ^ k[17];
#line 91
  t15___1 = w[18] ^ t05___3;
#line 91
  t16___0 = t11___2 | t13___3;
#line 91
  t17___1 = t02___3 | t14___2;
#line 91
  k[16] = t15___1 ^ t17___1;
#line 91
  k[18] = w[16] ^ t16___0;
#line 92
  t01___4 = w[20] & w[23];
#line 92
  t02___4 = w[21] ^ w[22];
#line 92
  t03___4 = w[20] ^ w[23];
#line 92
  t04___2 = t01___4 ^ t02___4;
#line 92
  t05___4 = w[21] | w[22];
#line 92
  k[21] = ~ t04___2;
#line 92
  t07___3 = t03___4 & t05___4;
#line 92
  t08___4 = w[21] & k[21];
#line 92
  t09___3 = w[20] | w[22];
#line 92
  t10___3 = t07___3 ^ t08___4;
#line 92
  t11___3 = w[21] | w[23];
#line 92
  t12___2 = w[22] ^ t11___3;
#line 92
  t13___4 = t09___3 ^ t10___3;
#line 92
  k[22] = ~ t13___4;
#line 92
  t15___2 = k[21] & t03___4;
#line 92
  k[23] = t12___2 ^ t07___3;
#line 92
  t17___2 = w[20] ^ w[21];
#line 92
  t18 = k[22] ^ t15___2;
#line 92
  k[20] = t17___2 ^ t18;
#line 93
  t01___5 = w[25] ^ w[27];
#line 93
  t02___5 = w[25] | w[27];
#line 93
  t03___5 = w[24] & t01___5;
#line 93
  t04___3 = w[26] ^ t02___5;
#line 93
  t05___5 = t03___5 ^ t04___3;
#line 93
  k[24] = ~ t05___5;
#line 93
  t07___4 = w[24] ^ t01___5;
#line 93
  t08___5 = w[27] | k[24];
#line 93
  t09___4 = w[25] | t05___5;
#line 93
  t10___4 = w[27] ^ t08___5;
#line 93
  t11___4 = w[25] | t07___4;
#line 93
  t12___3 = t03___5 | k[24];
#line 93
  t13___5 = t07___4 | t10___4;
#line 93
  t14___3 = t01___5 ^ t11___4;
#line 93
  k[26] = t09___4 ^ t13___5;
#line 93
  k[25] = t07___4 ^ t08___5;
#line 93
  k[27] = t12___3 ^ t14___3;
#line 94
  t01___6 = w[28] | w[29];
#line 94
  t02___6 = w[29] | w[30];
#line 94
  t03___6 = w[28] ^ t02___6;
#line 94
  t04___4 = w[29] ^ w[31];
#line 94
  t05___6 = w[31] | t03___6;
#line 94
  t06___4 = w[31] & t01___6;
#line 94
  k[31] = t03___6 ^ t06___4;
#line 94
  t08___6 = k[31] & t04___4;
#line 94
  t09___5 = t04___4 & t05___6;
#line 94
  t10___5 = w[30] ^ t06___4;
#line 94
  t11___5 = w[29] & w[30];
#line 94
  t12___4 = t04___4 ^ t08___6;
#line 94
  t13___6 = t11___5 | t03___6;
#line 94
  t14___4 = t10___5 ^ t09___5;
#line 94
  t15___3 = w[28] & t05___6;
#line 94
  t16___1 = t11___5 | t12___4;
#line 94
  k[30] = t13___6 ^ t08___6;
#line 94
  k[29] = t15___3 ^ t16___1;
#line 94
  k[28] = ~ t14___4;
#line 95
  t01___7 = w[32] ^ w[34];
#line 95
  t02___7 = w[32] | w[35];
#line 95
  t03___7 = w[32] & w[35];
#line 95
  t04___5 = t01___7 & t02___7;
#line 95
  t05___7 = w[33] | t03___7;
#line 95
  t06___5 = w[32] & w[33];
#line 95
  t07___5 = w[35] ^ t04___5;
#line 95
  t08___7 = w[34] | t06___5;
#line 95
  t09___6 = w[33] ^ t07___5;
#line 95
  t10___6 = w[35] & t05___7;
#line 95
  t11___6 = t02___7 ^ t10___6;
#line 95
  k[35] = t08___7 ^ t09___6;
#line 95
  t13___7 = w[35] | k[35];
#line 95
  t14___5 = w[32] | t07___5;
#line 95
  t15___4 = w[33] & t13___7;
#line 95
  k[34] = t08___7 ^ t11___6;
#line 95
  k[32] = t14___5 ^ t15___4;
#line 95
  k[33] = t05___7 ^ t04___5;
#line 96
  t01___8 = w[36] | w[38];
#line 96
  t02___8 = w[36] ^ w[37];
#line 96
  t03___8 = w[39] ^ t01___8;
#line 96
  k[36] = t02___8 ^ t03___8;
#line 96
  t05___8 = w[38] ^ k[36];
#line 96
  t06___6 = w[37] ^ t05___8;
#line 96
  t07___6 = w[37] | t05___8;
#line 96
  t08___8 = t01___8 & t06___6;
#line 96
  t09___7 = t03___8 ^ t07___6;
#line 96
  t10___7 = t02___8 | t09___7;
#line 96
  k[37] = t10___7 ^ t08___8;
#line 96
  t12___5 = w[36] | w[39];
#line 96
  t13___8 = t09___7 ^ k[37];
#line 96
  t14___6 = w[37] ^ t13___8;
#line 96
  k[39] = ~ t09___7;
#line 96
  k[38] = t12___5 ^ t14___6;
#line 97
  t01___9 = w[40] | w[43];
#line 97
  t02___9 = w[42] ^ w[43];
#line 97
  t03___9 = ~ w[41];
#line 97
  t04___6 = w[40] ^ w[42];
#line 97
  t05___9 = w[40] | t03___9;
#line 97
  t06___7 = w[43] & t04___6;
#line 97
  t07___7 = t01___9 & t02___9;
#line 97
  t08___9 = w[41] | t06___7;
#line 97
  k[42] = t02___9 ^ t05___9;
#line 97
  t10___8 = t07___7 ^ t08___9;
#line 97
  t11___7 = t01___9 ^ t10___8;
#line 97
  t12___6 = k[42] ^ t11___7;
#line 97
  t13___9 = w[41] & w[43];
#line 97
  k[43] = ~ t10___8;
#line 97
  k[41] = t13___9 ^ t12___6;
#line 97
  t16___2 = t10___8 | k[41];
#line 97
  t17___3 = t05___9 & t16___2;
#line 97
  k[40] = w[42] ^ t17___3;
#line 98
  t01___10 = w[45] ^ w[46];
#line 98
  t02___10 = w[44] | w[47];
#line 98
  t03___10 = w[44] ^ w[45];
#line 98
  k[47] = t02___10 ^ t01___10;
#line 98
  t05___10 = w[46] | k[47];
#line 98
  t06___8 = w[44] ^ w[47];
#line 98
  t07___8 = w[45] | w[46];
#line 98
  t08___10 = w[47] & t05___10;
#line 98
  t09___8 = t03___10 & t07___8;
#line 98
  k[46] = t09___8 ^ t08___10;
#line 98
  t11___8 = t09___8 & k[46];
#line 98
  t12___7 = w[46] ^ w[47];
#line 98
  t13___10 = t07___8 ^ t11___8;
#line 98
  t14___7 = w[45] & t06___8;
#line 98
  t15___5 = t06___8 ^ t13___10;
#line 98
  k[44] = ~ t15___5;
#line 98
  t17___4 = k[44] ^ t14___7;
#line 98
  k[45] = t12___7 ^ t17___4;
#line 99
  t01___11 = w[48] & w[50];
#line 99
  t02___11 = ~ w[51];
#line 99
  t03___11 = w[48] & t02___11;
#line 99
  t04___7 = w[49] | t01___11;
#line 99
  t05___11 = w[48] & w[49];
#line 99
  t06___9 = w[50] ^ t04___7;
#line 99
  k[51] = t03___11 ^ t06___9;
#line 99
  t08___11 = w[50] | k[51];
#line 99
  t09___9 = w[51] | t05___11;
#line 99
  t10___9 = w[48] ^ t08___11;
#line 99
  t11___9 = t04___7 & k[51];
#line 99
  k[49] = t09___9 ^ t10___9;
#line 99
  t13___11 = w[49] ^ k[49];
#line 99
  t14___8 = t01___11 ^ k[49];
#line 99
  t15___6 = w[50] ^ t05___11;
#line 99
  t16___3 = t11___9 | t13___11;
#line 99
  t17___5 = t02___11 | t14___8;
#line 99
  k[48] = t15___6 ^ t17___5;
#line 99
  k[50] = w[48] ^ t16___3;
#line 100
  t01___12 = w[52] & w[55];
#line 100
  t02___12 = w[53] ^ w[54];
#line 100
  t03___12 = w[52] ^ w[55];
#line 100
  t04___8 = t01___12 ^ t02___12;
#line 100
  t05___12 = w[53] | w[54];
#line 100
  k[53] = ~ t04___8;
#line 100
  t07___9 = t03___12 & t05___12;
#line 100
  t08___12 = w[53] & k[53];
#line 100
  t09___10 = w[52] | w[54];
#line 100
  t10___10 = t07___9 ^ t08___12;
#line 100
  t11___10 = w[53] | w[55];
#line 100
  t12___8 = w[54] ^ t11___10;
#line 100
  t13___12 = t09___10 ^ t10___10;
#line 100
  k[54] = ~ t13___12;
#line 100
  t15___7 = k[53] & t03___12;
#line 100
  k[55] = t12___8 ^ t07___9;
#line 100
  t17___6 = w[52] ^ w[53];
#line 100
  t18___0 = k[54] ^ t15___7;
#line 100
  k[52] = t17___6 ^ t18___0;
#line 101
  t01___13 = w[57] ^ w[59];
#line 101
  t02___13 = w[57] | w[59];
#line 101
  t03___13 = w[56] & t01___13;
#line 101
  t04___9 = w[58] ^ t02___13;
#line 101
  t05___13 = t03___13 ^ t04___9;
#line 101
  k[56] = ~ t05___13;
#line 101
  t07___10 = w[56] ^ t01___13;
#line 101
  t08___13 = w[59] | k[56];
#line 101
  t09___11 = w[57] | t05___13;
#line 101
  t10___11 = w[59] ^ t08___13;
#line 101
  t11___11 = w[57] | t07___10;
#line 101
  t12___9 = t03___13 | k[56];
#line 101
  t13___13 = t07___10 | t10___11;
#line 101
  t14___9 = t01___13 ^ t11___11;
#line 101
  k[58] = t09___11 ^ t13___13;
#line 101
  k[57] = t07___10 ^ t08___13;
#line 101
  k[59] = t12___9 ^ t14___9;
#line 102
  t01___14 = w[60] | w[61];
#line 102
  t02___14 = w[61] | w[62];
#line 102
  t03___14 = w[60] ^ t02___14;
#line 102
  t04___10 = w[61] ^ w[63];
#line 102
  t05___14 = w[63] | t03___14;
#line 102
  t06___10 = w[63] & t01___14;
#line 102
  k[63] = t03___14 ^ t06___10;
#line 102
  t08___14 = k[63] & t04___10;
#line 102
  t09___12 = t04___10 & t05___14;
#line 102
  t10___12 = w[62] ^ t06___10;
#line 102
  t11___12 = w[61] & w[62];
#line 102
  t12___10 = t04___10 ^ t08___14;
#line 102
  t13___14 = t11___12 | t03___14;
#line 102
  t14___10 = t10___12 ^ t09___12;
#line 102
  t15___8 = w[60] & t05___14;
#line 102
  t16___4 = t11___12 | t12___10;
#line 102
  k[62] = t13___14 ^ t08___14;
#line 102
  k[61] = t15___8 ^ t16___4;
#line 102
  k[60] = ~ t14___10;
#line 103
  t01___15 = w[64] ^ w[66];
#line 103
  t02___15 = w[64] | w[67];
#line 103
  t03___15 = w[64] & w[67];
#line 103
  t04___11 = t01___15 & t02___15;
#line 103
  t05___15 = w[65] | t03___15;
#line 103
  t06___11 = w[64] & w[65];
#line 103
  t07___11 = w[67] ^ t04___11;
#line 103
  t08___15 = w[66] | t06___11;
#line 103
  t09___13 = w[65] ^ t07___11;
#line 103
  t10___13 = w[67] & t05___15;
#line 103
  t11___13 = t02___15 ^ t10___13;
#line 103
  k[67] = t08___15 ^ t09___13;
#line 103
  t13___15 = w[67] | k[67];
#line 103
  t14___11 = w[64] | t07___11;
#line 103
  t15___9 = w[65] & t13___15;
#line 103
  k[66] = t08___15 ^ t11___13;
#line 103
  k[64] = t14___11 ^ t15___9;
#line 103
  k[65] = t05___15 ^ t04___11;
#line 104
  t01___16 = w[68] | w[70];
#line 104
  t02___16 = w[68] ^ w[69];
#line 104
  t03___16 = w[71] ^ t01___16;
#line 104
  k[68] = t02___16 ^ t03___16;
#line 104
  t05___16 = w[70] ^ k[68];
#line 104
  t06___12 = w[69] ^ t05___16;
#line 104
  t07___12 = w[69] | t05___16;
#line 104
  t08___16 = t01___16 & t06___12;
#line 104
  t09___14 = t03___16 ^ t07___12;
#line 104
  t10___14 = t02___16 | t09___14;
#line 104
  k[69] = t10___14 ^ t08___16;
#line 104
  t12___11 = w[68] | w[71];
#line 104
  t13___16 = t09___14 ^ k[69];
#line 104
  t14___12 = w[69] ^ t13___16;
#line 104
  k[71] = ~ t09___14;
#line 104
  k[70] = t12___11 ^ t14___12;
#line 105
  t01___17 = w[72] | w[75];
#line 105
  t02___17 = w[74] ^ w[75];
#line 105
  t03___17 = ~ w[73];
#line 105
  t04___12 = w[72] ^ w[74];
#line 105
  t05___17 = w[72] | t03___17;
#line 105
  t06___13 = w[75] & t04___12;
#line 105
  t07___13 = t01___17 & t02___17;
#line 105
  t08___17 = w[73] | t06___13;
#line 105
  k[74] = t02___17 ^ t05___17;
#line 105
  t10___15 = t07___13 ^ t08___17;
#line 105
  t11___14 = t01___17 ^ t10___15;
#line 105
  t12___12 = k[74] ^ t11___14;
#line 105
  t13___17 = w[73] & w[75];
#line 105
  k[75] = ~ t10___15;
#line 105
  k[73] = t13___17 ^ t12___12;
#line 105
  t16___5 = t10___15 | k[73];
#line 105
  t17___7 = t05___17 & t16___5;
#line 105
  k[72] = w[74] ^ t17___7;
#line 106
  t01___18 = w[77] ^ w[78];
#line 106
  t02___18 = w[76] | w[79];
#line 106
  t03___18 = w[76] ^ w[77];
#line 106
  k[79] = t02___18 ^ t01___18;
#line 106
  t05___18 = w[78] | k[79];
#line 106
  t06___14 = w[76] ^ w[79];
#line 106
  t07___14 = w[77] | w[78];
#line 106
  t08___18 = w[79] & t05___18;
#line 106
  t09___15 = t03___18 & t07___14;
#line 106
  k[78] = t09___15 ^ t08___18;
#line 106
  t11___15 = t09___15 & k[78];
#line 106
  t12___13 = w[78] ^ w[79];
#line 106
  t13___18 = t07___14 ^ t11___15;
#line 106
  t14___13 = w[77] & t06___14;
#line 106
  t15___10 = t06___14 ^ t13___18;
#line 106
  k[76] = ~ t15___10;
#line 106
  t17___8 = k[76] ^ t14___13;
#line 106
  k[77] = t12___13 ^ t17___8;
#line 107
  t01___19 = w[80] & w[82];
#line 107
  t02___19 = ~ w[83];
#line 107
  t03___19 = w[80] & t02___19;
#line 107
  t04___13 = w[81] | t01___19;
#line 107
  t05___19 = w[80] & w[81];
#line 107
  t06___15 = w[82] ^ t04___13;
#line 107
  k[83] = t03___19 ^ t06___15;
#line 107
  t08___19 = w[82] | k[83];
#line 107
  t09___16 = w[83] | t05___19;
#line 107
  t10___16 = w[80] ^ t08___19;
#line 107
  t11___16 = t04___13 & k[83];
#line 107
  k[81] = t09___16 ^ t10___16;
#line 107
  t13___19 = w[81] ^ k[81];
#line 107
  t14___14 = t01___19 ^ k[81];
#line 107
  t15___11 = w[82] ^ t05___19;
#line 107
  t16___6 = t11___16 | t13___19;
#line 107
  t17___9 = t02___19 | t14___14;
#line 107
  k[80] = t15___11 ^ t17___9;
#line 107
  k[82] = w[80] ^ t16___6;
#line 108
  t01___20 = w[84] & w[87];
#line 108
  t02___20 = w[85] ^ w[86];
#line 108
  t03___20 = w[84] ^ w[87];
#line 108
  t04___14 = t01___20 ^ t02___20;
#line 108
  t05___20 = w[85] | w[86];
#line 108
  k[85] = ~ t04___14;
#line 108
  t07___15 = t03___20 & t05___20;
#line 108
  t08___20 = w[85] & k[85];
#line 108
  t09___17 = w[84] | w[86];
#line 108
  t10___17 = t07___15 ^ t08___20;
#line 108
  t11___17 = w[85] | w[87];
#line 108
  t12___14 = w[86] ^ t11___17;
#line 108
  t13___20 = t09___17 ^ t10___17;
#line 108
  k[86] = ~ t13___20;
#line 108
  t15___12 = k[85] & t03___20;
#line 108
  k[87] = t12___14 ^ t07___15;
#line 108
  t17___10 = w[84] ^ w[85];
#line 108
  t18___1 = k[86] ^ t15___12;
#line 108
  k[84] = t17___10 ^ t18___1;
#line 109
  t01___21 = w[89] ^ w[91];
#line 109
  t02___21 = w[89] | w[91];
#line 109
  t03___21 = w[88] & t01___21;
#line 109
  t04___15 = w[90] ^ t02___21;
#line 109
  t05___21 = t03___21 ^ t04___15;
#line 109
  k[88] = ~ t05___21;
#line 109
  t07___16 = w[88] ^ t01___21;
#line 109
  t08___21 = w[91] | k[88];
#line 109
  t09___18 = w[89] | t05___21;
#line 109
  t10___18 = w[91] ^ t08___21;
#line 109
  t11___18 = w[89] | t07___16;
#line 109
  t12___15 = t03___21 | k[88];
#line 109
  t13___21 = t07___16 | t10___18;
#line 109
  t14___15 = t01___21 ^ t11___18;
#line 109
  k[90] = t09___18 ^ t13___21;
#line 109
  k[89] = t07___16 ^ t08___21;
#line 109
  k[91] = t12___15 ^ t14___15;
#line 110
  t01___22 = w[92] | w[93];
#line 110
  t02___22 = w[93] | w[94];
#line 110
  t03___22 = w[92] ^ t02___22;
#line 110
  t04___16 = w[93] ^ w[95];
#line 110
  t05___22 = w[95] | t03___22;
#line 110
  t06___16 = w[95] & t01___22;
#line 110
  k[95] = t03___22 ^ t06___16;
#line 110
  t08___22 = k[95] & t04___16;
#line 110
  t09___19 = t04___16 & t05___22;
#line 110
  t10___19 = w[94] ^ t06___16;
#line 110
  t11___19 = w[93] & w[94];
#line 110
  t12___16 = t04___16 ^ t08___22;
#line 110
  t13___22 = t11___19 | t03___22;
#line 110
  t14___16 = t10___19 ^ t09___19;
#line 110
  t15___13 = w[92] & t05___22;
#line 110
  t16___7 = t11___19 | t12___16;
#line 110
  k[94] = t13___22 ^ t08___22;
#line 110
  k[93] = t15___13 ^ t16___7;
#line 110
  k[92] = ~ t14___16;
#line 111
  t01___23 = w[96] ^ w[98];
#line 111
  t02___23 = w[96] | w[99];
#line 111
  t03___23 = w[96] & w[99];
#line 111
  t04___17 = t01___23 & t02___23;
#line 111
  t05___23 = w[97] | t03___23;
#line 111
  t06___17 = w[96] & w[97];
#line 111
  t07___17 = w[99] ^ t04___17;
#line 111
  t08___23 = w[98] | t06___17;
#line 111
  t09___20 = w[97] ^ t07___17;
#line 111
  t10___20 = w[99] & t05___23;
#line 111
  t11___20 = t02___23 ^ t10___20;
#line 111
  k[99] = t08___23 ^ t09___20;
#line 111
  t13___23 = w[99] | k[99];
#line 111
  t14___17 = w[96] | t07___17;
#line 111
  t15___14 = w[97] & t13___23;
#line 111
  k[98] = t08___23 ^ t11___20;
#line 111
  k[96] = t14___17 ^ t15___14;
#line 111
  k[97] = t05___23 ^ t04___17;
#line 112
  t01___24 = w[100] | w[102];
#line 112
  t02___24 = w[100] ^ w[101];
#line 112
  t03___24 = w[103] ^ t01___24;
#line 112
  k[100] = t02___24 ^ t03___24;
#line 112
  t05___24 = w[102] ^ k[100];
#line 112
  t06___18 = w[101] ^ t05___24;
#line 112
  t07___18 = w[101] | t05___24;
#line 112
  t08___24 = t01___24 & t06___18;
#line 112
  t09___21 = t03___24 ^ t07___18;
#line 112
  t10___21 = t02___24 | t09___21;
#line 112
  k[101] = t10___21 ^ t08___24;
#line 112
  t12___17 = w[100] | w[103];
#line 112
  t13___24 = t09___21 ^ k[101];
#line 112
  t14___18 = w[101] ^ t13___24;
#line 112
  k[103] = ~ t09___21;
#line 112
  k[102] = t12___17 ^ t14___18;
#line 113
  t01___25 = w[104] | w[107];
#line 113
  t02___25 = w[106] ^ w[107];
#line 113
  t03___25 = ~ w[105];
#line 113
  t04___18 = w[104] ^ w[106];
#line 113
  t05___25 = w[104] | t03___25;
#line 113
  t06___19 = w[107] & t04___18;
#line 113
  t07___19 = t01___25 & t02___25;
#line 113
  t08___25 = w[105] | t06___19;
#line 113
  k[106] = t02___25 ^ t05___25;
#line 113
  t10___22 = t07___19 ^ t08___25;
#line 113
  t11___21 = t01___25 ^ t10___22;
#line 113
  t12___18 = k[106] ^ t11___21;
#line 113
  t13___25 = w[105] & w[107];
#line 113
  k[107] = ~ t10___22;
#line 113
  k[105] = t13___25 ^ t12___18;
#line 113
  t16___8 = t10___22 | k[105];
#line 113
  t17___11 = t05___25 & t16___8;
#line 113
  k[104] = w[106] ^ t17___11;
#line 114
  t01___26 = w[109] ^ w[110];
#line 114
  t02___26 = w[108] | w[111];
#line 114
  t03___26 = w[108] ^ w[109];
#line 114
  k[111] = t02___26 ^ t01___26;
#line 114
  t05___26 = w[110] | k[111];
#line 114
  t06___20 = w[108] ^ w[111];
#line 114
  t07___20 = w[109] | w[110];
#line 114
  t08___26 = w[111] & t05___26;
#line 114
  t09___22 = t03___26 & t07___20;
#line 114
  k[110] = t09___22 ^ t08___26;
#line 114
  t11___22 = t09___22 & k[110];
#line 114
  t12___19 = w[110] ^ w[111];
#line 114
  t13___26 = t07___20 ^ t11___22;
#line 114
  t14___19 = w[109] & t06___20;
#line 114
  t15___15 = t06___20 ^ t13___26;
#line 114
  k[108] = ~ t15___15;
#line 114
  t17___12 = k[108] ^ t14___19;
#line 114
  k[109] = t12___19 ^ t17___12;
#line 115
  t01___27 = w[112] & w[114];
#line 115
  t02___27 = ~ w[115];
#line 115
  t03___27 = w[112] & t02___27;
#line 115
  t04___19 = w[113] | t01___27;
#line 115
  t05___27 = w[112] & w[113];
#line 115
  t06___21 = w[114] ^ t04___19;
#line 115
  k[115] = t03___27 ^ t06___21;
#line 115
  t08___27 = w[114] | k[115];
#line 115
  t09___23 = w[115] | t05___27;
#line 115
  t10___23 = w[112] ^ t08___27;
#line 115
  t11___23 = t04___19 & k[115];
#line 115
  k[113] = t09___23 ^ t10___23;
#line 115
  t13___27 = w[113] ^ k[113];
#line 115
  t14___20 = t01___27 ^ k[113];
#line 115
  t15___16 = w[114] ^ t05___27;
#line 115
  t16___9 = t11___23 | t13___27;
#line 115
  t17___13 = t02___27 | t14___20;
#line 115
  k[112] = t15___16 ^ t17___13;
#line 115
  k[114] = w[112] ^ t16___9;
#line 116
  t01___28 = w[116] & w[119];
#line 116
  t02___28 = w[117] ^ w[118];
#line 116
  t03___28 = w[116] ^ w[119];
#line 116
  t04___20 = t01___28 ^ t02___28;
#line 116
  t05___28 = w[117] | w[118];
#line 116
  k[117] = ~ t04___20;
#line 116
  t07___21 = t03___28 & t05___28;
#line 116
  t08___28 = w[117] & k[117];
#line 116
  t09___24 = w[116] | w[118];
#line 116
  t10___24 = t07___21 ^ t08___28;
#line 116
  t11___24 = w[117] | w[119];
#line 116
  t12___20 = w[118] ^ t11___24;
#line 116
  t13___28 = t09___24 ^ t10___24;
#line 116
  k[118] = ~ t13___28;
#line 116
  t15___17 = k[117] & t03___28;
#line 116
  k[119] = t12___20 ^ t07___21;
#line 116
  t17___14 = w[116] ^ w[117];
#line 116
  t18___2 = k[118] ^ t15___17;
#line 116
  k[116] = t17___14 ^ t18___2;
#line 117
  t01___29 = w[121] ^ w[123];
#line 117
  t02___29 = w[121] | w[123];
#line 117
  t03___29 = w[120] & t01___29;
#line 117
  t04___21 = w[122] ^ t02___29;
#line 117
  t05___29 = t03___29 ^ t04___21;
#line 117
  k[120] = ~ t05___29;
#line 117
  t07___22 = w[120] ^ t01___29;
#line 117
  t08___29 = w[123] | k[120];
#line 117
  t09___25 = w[121] | t05___29;
#line 117
  t10___25 = w[123] ^ t08___29;
#line 117
  t11___25 = w[121] | t07___22;
#line 117
  t12___21 = t03___29 | k[120];
#line 117
  t13___29 = t07___22 | t10___25;
#line 117
  t14___21 = t01___29 ^ t11___25;
#line 117
  k[122] = t09___25 ^ t13___29;
#line 117
  k[121] = t07___22 ^ t08___29;
#line 117
  k[123] = t12___21 ^ t14___21;
#line 118
  t01___30 = w[124] | w[125];
#line 118
  t02___30 = w[125] | w[126];
#line 118
  t03___30 = w[124] ^ t02___30;
#line 118
  t04___22 = w[125] ^ w[127];
#line 118
  t05___30 = w[127] | t03___30;
#line 118
  t06___22 = w[127] & t01___30;
#line 118
  k[127] = t03___30 ^ t06___22;
#line 118
  t08___30 = k[127] & t04___22;
#line 118
  t09___26 = t04___22 & t05___30;
#line 118
  t10___26 = w[126] ^ t06___22;
#line 118
  t11___26 = w[125] & w[126];
#line 118
  t12___22 = t04___22 ^ t08___30;
#line 118
  t13___30 = t11___26 | t03___30;
#line 118
  t14___22 = t10___26 ^ t09___26;
#line 118
  t15___18 = w[124] & t05___30;
#line 118
  t16___10 = t11___26 | t12___22;
#line 118
  k[126] = t13___30 ^ t08___30;
#line 118
  k[125] = t15___18 ^ t16___10;
#line 118
  k[124] = ~ t14___22;
#line 119
  t01___31 = w[128] ^ w[130];
#line 119
  t02___31 = w[128] | w[131];
#line 119
  t03___31 = w[128] & w[131];
#line 119
  t04___23 = t01___31 & t02___31;
#line 119
  t05___31 = w[129] | t03___31;
#line 119
  t06___23 = w[128] & w[129];
#line 119
  t07___23 = w[131] ^ t04___23;
#line 119
  t08___31 = w[130] | t06___23;
#line 119
  t09___27 = w[129] ^ t07___23;
#line 119
  t10___27 = w[131] & t05___31;
#line 119
  t11___27 = t02___31 ^ t10___27;
#line 119
  k[131] = t08___31 ^ t09___27;
#line 119
  t13___31 = w[131] | k[131];
#line 119
  t14___23 = w[128] | t07___23;
#line 119
  t15___19 = w[129] & t13___31;
#line 119
  k[130] = t08___31 ^ t11___27;
#line 119
  k[128] = t14___23 ^ t15___19;
#line 119
  k[129] = t05___31 ^ t04___23;
#line 121
  i = 0U;
  {
  {
#line 121
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;

#line 121
    if (! (i <= 32U)) {
#line 121
      goto while_break___5;
    }
#line 122
    j = 0U;
    {
    {
#line 122
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;

#line 122
      if (! (j < 4U)) {
#line 122
        goto while_break___6;
      }
#line 123
      ctx->keys[i][j] = k[4U * i + j];
#line 122
      j ++;
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___6: 
#line 121
    i ++;
  }
  while_break___21: /* CIL Label */ ;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___5: ;
#line 124
  return;
}
}
#line 126 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent.c"
void nettle_serpent_encrypt(struct serpent_ctx *ctx , unsigned int length , uint8_t *dst ,
                            uint8_t const   *plain ) 
{ 
  register uint32_t x0 ;
  register uint32_t x1 ;
  register uint32_t x2 ;
  register uint32_t x3 ;
  register uint32_t y0 ;
  register uint32_t y1 ;
  register uint32_t y2 ;
  register uint32_t y3 ;
  register uint32_t t02 ;
  register uint32_t t03 ;
  register uint32_t t05 ;
  register uint32_t t06 ;
  register uint32_t t07 ;
  register uint32_t t08 ;
  register uint32_t t09 ;
  register uint32_t t11 ;
  register uint32_t t12 ;
  register uint32_t t13 ;
  register uint32_t t14 ;
  register uint32_t t15 ;
  register uint32_t t17 ;
  register uint32_t t01 ;
  register uint32_t t02___0 ;
  register uint32_t t03___0 ;
  register uint32_t t04 ;
  register uint32_t t05___0 ;
  register uint32_t t06___0 ;
  register uint32_t t07___0 ;
  register uint32_t t08___0 ;
  register uint32_t t10 ;
  register uint32_t t11___0 ;
  register uint32_t t12___0 ;
  register uint32_t t13___0 ;
  register uint32_t t16 ;
  register uint32_t t17___0 ;
  register uint32_t t01___0 ;
  register uint32_t t02___1 ;
  register uint32_t t03___1 ;
  register uint32_t t05___1 ;
  register uint32_t t06___1 ;
  register uint32_t t07___1 ;
  register uint32_t t08___1 ;
  register uint32_t t09___0 ;
  register uint32_t t10___0 ;
  register uint32_t t12___1 ;
  register uint32_t t13___1 ;
  register uint32_t t14___0 ;
  register uint32_t t01___1 ;
  register uint32_t t02___2 ;
  register uint32_t t03___2 ;
  register uint32_t t04___0 ;
  register uint32_t t05___2 ;
  register uint32_t t06___2 ;
  register uint32_t t07___2 ;
  register uint32_t t08___2 ;
  register uint32_t t09___1 ;
  register uint32_t t10___1 ;
  register uint32_t t11___1 ;
  register uint32_t t13___2 ;
  register uint32_t t14___1 ;
  register uint32_t t15___0 ;
  register uint32_t t01___2 ;
  register uint32_t t02___3 ;
  register uint32_t t03___3 ;
  register uint32_t t04___1 ;
  register uint32_t t05___3 ;
  register uint32_t t06___3 ;
  register uint32_t t08___3 ;
  register uint32_t t09___2 ;
  register uint32_t t10___2 ;
  register uint32_t t11___2 ;
  register uint32_t t12___2 ;
  register uint32_t t13___3 ;
  register uint32_t t14___2 ;
  register uint32_t t15___1 ;
  register uint32_t t16___0 ;
  register uint32_t t01___3 ;
  register uint32_t t02___4 ;
  register uint32_t t03___4 ;
  register uint32_t t04___2 ;
  register uint32_t t05___4 ;
  register uint32_t t07___3 ;
  register uint32_t t08___4 ;
  register uint32_t t09___3 ;
  register uint32_t t10___3 ;
  register uint32_t t11___3 ;
  register uint32_t t12___3 ;
  register uint32_t t13___4 ;
  register uint32_t t14___3 ;
  register uint32_t t01___4 ;
  register uint32_t t02___5 ;
  register uint32_t t03___5 ;
  register uint32_t t04___3 ;
  register uint32_t t05___5 ;
  register uint32_t t07___4 ;
  register uint32_t t08___5 ;
  register uint32_t t09___4 ;
  register uint32_t t10___4 ;
  register uint32_t t11___4 ;
  register uint32_t t12___4 ;
  register uint32_t t13___5 ;
  register uint32_t t15___2 ;
  register uint32_t t17___1 ;
  register uint32_t t18 ;
  register uint32_t t01___5 ;
  register uint32_t t02___6 ;
  register uint32_t t03___6 ;
  register uint32_t t04___4 ;
  register uint32_t t05___6 ;
  register uint32_t t06___4 ;
  register uint32_t t08___6 ;
  register uint32_t t09___5 ;
  register uint32_t t10___5 ;
  register uint32_t t11___5 ;
  register uint32_t t13___6 ;
  register uint32_t t14___4 ;
  register uint32_t t15___3 ;
  register uint32_t t16___1 ;
  register uint32_t t17___2 ;
  register uint32_t t01___6 ;
  register uint32_t t02___7 ;
  register uint32_t t03___7 ;
  register uint32_t t05___7 ;
  register uint32_t t06___5 ;
  register uint32_t t07___5 ;
  register uint32_t t08___7 ;
  register uint32_t t09___6 ;
  register uint32_t t11___6 ;
  register uint32_t t12___5 ;
  register uint32_t t13___7 ;
  register uint32_t t14___5 ;
  register uint32_t t15___4 ;
  register uint32_t t17___3 ;
  register uint32_t t01___7 ;
  register uint32_t t02___8 ;
  register uint32_t t03___8 ;
  register uint32_t t04___5 ;
  register uint32_t t05___8 ;
  register uint32_t t06___6 ;
  register uint32_t t07___6 ;
  register uint32_t t08___8 ;
  register uint32_t t10___6 ;
  register uint32_t t11___7 ;
  register uint32_t t12___6 ;
  register uint32_t t13___8 ;
  register uint32_t t16___2 ;
  register uint32_t t17___4 ;
  register uint32_t t01___8 ;
  register uint32_t t02___9 ;
  register uint32_t t03___9 ;
  register uint32_t t05___9 ;
  register uint32_t t06___7 ;
  register uint32_t t07___7 ;
  register uint32_t t08___9 ;
  register uint32_t t09___7 ;
  register uint32_t t10___7 ;
  register uint32_t t12___7 ;
  register uint32_t t13___9 ;
  register uint32_t t14___6 ;
  register uint32_t t01___9 ;
  register uint32_t t02___10 ;
  register uint32_t t03___10 ;
  register uint32_t t04___6 ;
  register uint32_t t05___10 ;
  register uint32_t t06___8 ;
  register uint32_t t07___8 ;
  register uint32_t t08___10 ;
  register uint32_t t09___8 ;
  register uint32_t t10___8 ;
  register uint32_t t11___8 ;
  register uint32_t t13___10 ;
  register uint32_t t14___7 ;
  register uint32_t t15___5 ;
  register uint32_t t01___10 ;
  register uint32_t t02___11 ;
  register uint32_t t03___11 ;
  register uint32_t t04___7 ;
  register uint32_t t05___11 ;
  register uint32_t t06___9 ;
  register uint32_t t08___11 ;
  register uint32_t t09___9 ;
  register uint32_t t10___9 ;
  register uint32_t t11___9 ;
  register uint32_t t12___8 ;
  register uint32_t t13___11 ;
  register uint32_t t14___8 ;
  register uint32_t t15___6 ;
  register uint32_t t16___3 ;
  register uint32_t t01___11 ;
  register uint32_t t02___12 ;
  register uint32_t t03___12 ;
  register uint32_t t04___8 ;
  register uint32_t t05___12 ;
  register uint32_t t07___9 ;
  register uint32_t t08___12 ;
  register uint32_t t09___10 ;
  register uint32_t t10___10 ;
  register uint32_t t11___10 ;
  register uint32_t t12___9 ;
  register uint32_t t13___12 ;
  register uint32_t t14___9 ;
  register uint32_t t01___12 ;
  register uint32_t t02___13 ;
  register uint32_t t03___13 ;
  register uint32_t t04___9 ;
  register uint32_t t05___13 ;
  register uint32_t t07___10 ;
  register uint32_t t08___13 ;
  register uint32_t t09___11 ;
  register uint32_t t10___11 ;
  register uint32_t t11___11 ;
  register uint32_t t12___10 ;
  register uint32_t t13___13 ;
  register uint32_t t15___7 ;
  register uint32_t t17___5 ;
  register uint32_t t18___0 ;
  register uint32_t t01___13 ;
  register uint32_t t02___14 ;
  register uint32_t t03___14 ;
  register uint32_t t04___10 ;
  register uint32_t t05___14 ;
  register uint32_t t06___10 ;
  register uint32_t t08___14 ;
  register uint32_t t09___12 ;
  register uint32_t t10___12 ;
  register uint32_t t11___12 ;
  register uint32_t t13___14 ;
  register uint32_t t14___10 ;
  register uint32_t t15___8 ;
  register uint32_t t16___4 ;
  register uint32_t t17___6 ;
  register uint32_t t01___14 ;
  register uint32_t t02___15 ;
  register uint32_t t03___15 ;
  register uint32_t t05___15 ;
  register uint32_t t06___11 ;
  register uint32_t t07___11 ;
  register uint32_t t08___15 ;
  register uint32_t t09___13 ;
  register uint32_t t11___13 ;
  register uint32_t t12___11 ;
  register uint32_t t13___15 ;
  register uint32_t t14___11 ;
  register uint32_t t15___9 ;
  register uint32_t t17___7 ;
  register uint32_t t01___15 ;
  register uint32_t t02___16 ;
  register uint32_t t03___16 ;
  register uint32_t t04___11 ;
  register uint32_t t05___16 ;
  register uint32_t t06___12 ;
  register uint32_t t07___12 ;
  register uint32_t t08___16 ;
  register uint32_t t10___13 ;
  register uint32_t t11___14 ;
  register uint32_t t12___12 ;
  register uint32_t t13___16 ;
  register uint32_t t16___5 ;
  register uint32_t t17___8 ;
  register uint32_t t01___16 ;
  register uint32_t t02___17 ;
  register uint32_t t03___17 ;
  register uint32_t t05___17 ;
  register uint32_t t06___13 ;
  register uint32_t t07___13 ;
  register uint32_t t08___17 ;
  register uint32_t t09___14 ;
  register uint32_t t10___14 ;
  register uint32_t t12___13 ;
  register uint32_t t13___17 ;
  register uint32_t t14___12 ;
  register uint32_t t01___17 ;
  register uint32_t t02___18 ;
  register uint32_t t03___18 ;
  register uint32_t t04___12 ;
  register uint32_t t05___18 ;
  register uint32_t t06___14 ;
  register uint32_t t07___14 ;
  register uint32_t t08___18 ;
  register uint32_t t09___15 ;
  register uint32_t t10___15 ;
  register uint32_t t11___15 ;
  register uint32_t t13___18 ;
  register uint32_t t14___13 ;
  register uint32_t t15___10 ;
  register uint32_t t01___18 ;
  register uint32_t t02___19 ;
  register uint32_t t03___19 ;
  register uint32_t t04___13 ;
  register uint32_t t05___19 ;
  register uint32_t t06___15 ;
  register uint32_t t08___19 ;
  register uint32_t t09___16 ;
  register uint32_t t10___16 ;
  register uint32_t t11___16 ;
  register uint32_t t12___14 ;
  register uint32_t t13___19 ;
  register uint32_t t14___14 ;
  register uint32_t t15___11 ;
  register uint32_t t16___6 ;
  register uint32_t t01___19 ;
  register uint32_t t02___20 ;
  register uint32_t t03___20 ;
  register uint32_t t04___14 ;
  register uint32_t t05___20 ;
  register uint32_t t07___15 ;
  register uint32_t t08___20 ;
  register uint32_t t09___17 ;
  register uint32_t t10___17 ;
  register uint32_t t11___17 ;
  register uint32_t t12___15 ;
  register uint32_t t13___20 ;
  register uint32_t t14___15 ;
  register uint32_t t01___20 ;
  register uint32_t t02___21 ;
  register uint32_t t03___21 ;
  register uint32_t t04___15 ;
  register uint32_t t05___21 ;
  register uint32_t t07___16 ;
  register uint32_t t08___21 ;
  register uint32_t t09___18 ;
  register uint32_t t10___18 ;
  register uint32_t t11___18 ;
  register uint32_t t12___16 ;
  register uint32_t t13___21 ;
  register uint32_t t15___12 ;
  register uint32_t t17___9 ;
  register uint32_t t18___1 ;
  register uint32_t t01___21 ;
  register uint32_t t02___22 ;
  register uint32_t t03___22 ;
  register uint32_t t04___16 ;
  register uint32_t t05___22 ;
  register uint32_t t06___16 ;
  register uint32_t t08___22 ;
  register uint32_t t09___19 ;
  register uint32_t t10___19 ;
  register uint32_t t11___19 ;
  register uint32_t t13___22 ;
  register uint32_t t14___16 ;
  register uint32_t t15___13 ;
  register uint32_t t16___7 ;
  register uint32_t t17___10 ;
  register uint32_t t01___22 ;
  register uint32_t t02___23 ;
  register uint32_t t03___23 ;
  register uint32_t t05___23 ;
  register uint32_t t06___17 ;
  register uint32_t t07___17 ;
  register uint32_t t08___23 ;
  register uint32_t t09___20 ;
  register uint32_t t11___20 ;
  register uint32_t t12___17 ;
  register uint32_t t13___23 ;
  register uint32_t t14___17 ;
  register uint32_t t15___14 ;
  register uint32_t t17___11 ;
  register uint32_t t01___23 ;
  register uint32_t t02___24 ;
  register uint32_t t03___24 ;
  register uint32_t t04___17 ;
  register uint32_t t05___24 ;
  register uint32_t t06___18 ;
  register uint32_t t07___18 ;
  register uint32_t t08___24 ;
  register uint32_t t10___20 ;
  register uint32_t t11___21 ;
  register uint32_t t12___18 ;
  register uint32_t t13___24 ;
  register uint32_t t16___8 ;
  register uint32_t t17___12 ;
  register uint32_t t01___24 ;
  register uint32_t t02___25 ;
  register uint32_t t03___25 ;
  register uint32_t t05___25 ;
  register uint32_t t06___19 ;
  register uint32_t t07___19 ;
  register uint32_t t08___25 ;
  register uint32_t t09___21 ;
  register uint32_t t10___21 ;
  register uint32_t t12___19 ;
  register uint32_t t13___25 ;
  register uint32_t t14___18 ;
  register uint32_t t01___25 ;
  register uint32_t t02___26 ;
  register uint32_t t03___26 ;
  register uint32_t t04___18 ;
  register uint32_t t05___26 ;
  register uint32_t t06___20 ;
  register uint32_t t07___20 ;
  register uint32_t t08___26 ;
  register uint32_t t09___22 ;
  register uint32_t t10___22 ;
  register uint32_t t11___22 ;
  register uint32_t t13___26 ;
  register uint32_t t14___19 ;
  register uint32_t t15___15 ;
  register uint32_t t01___26 ;
  register uint32_t t02___27 ;
  register uint32_t t03___27 ;
  register uint32_t t04___19 ;
  register uint32_t t05___27 ;
  register uint32_t t06___21 ;
  register uint32_t t08___27 ;
  register uint32_t t09___23 ;
  register uint32_t t10___23 ;
  register uint32_t t11___23 ;
  register uint32_t t12___20 ;
  register uint32_t t13___27 ;
  register uint32_t t14___20 ;
  register uint32_t t15___16 ;
  register uint32_t t16___9 ;
  register uint32_t t01___27 ;
  register uint32_t t02___28 ;
  register uint32_t t03___28 ;
  register uint32_t t04___20 ;
  register uint32_t t05___28 ;
  register uint32_t t07___21 ;
  register uint32_t t08___28 ;
  register uint32_t t09___24 ;
  register uint32_t t10___24 ;
  register uint32_t t11___24 ;
  register uint32_t t12___21 ;
  register uint32_t t13___28 ;
  register uint32_t t14___21 ;
  register uint32_t t01___28 ;
  register uint32_t t02___29 ;
  register uint32_t t03___29 ;
  register uint32_t t04___21 ;
  register uint32_t t05___29 ;
  register uint32_t t07___22 ;
  register uint32_t t08___29 ;
  register uint32_t t09___25 ;
  register uint32_t t10___25 ;
  register uint32_t t11___25 ;
  register uint32_t t12___22 ;
  register uint32_t t13___29 ;
  register uint32_t t15___17 ;
  register uint32_t t17___13 ;
  register uint32_t t18___2 ;
  register uint32_t t01___29 ;
  register uint32_t t02___30 ;
  register uint32_t t03___30 ;
  register uint32_t t04___22 ;
  register uint32_t t05___30 ;
  register uint32_t t06___22 ;
  register uint32_t t08___30 ;
  register uint32_t t09___26 ;
  register uint32_t t10___26 ;
  register uint32_t t11___26 ;
  register uint32_t t13___30 ;
  register uint32_t t14___22 ;
  register uint32_t t15___18 ;
  register uint32_t t16___10 ;
  register uint32_t t17___14 ;
  register uint32_t t01___30 ;
  char *__cil_tmp464 ;
  char *__cil_tmp465 ;
  char *__cil_tmp466 ;
  char *__cil_tmp467 ;
  char *__cil_tmp468 ;
  char *__cil_tmp469 ;

  {
#line 134
  if (! (! (length % 16U))) {
    {
    {
#line 134
    __assert_fail("!((length) % (16))", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent.c",
                  134U, "nettle_serpent_encrypt");
    }
    }
  }
  {
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 134
    if (! length) {
#line 134
      goto while_break;
    }
#line 137
    x0 = ((((uint32_t )*((plain + 12) + 0) << 24) | ((uint32_t )*((plain + 12) + 1) << 16)) | ((uint32_t )*((plain + 12) + 2) << 8)) | (uint32_t )*((plain + 12) + 3);
#line 138
    x1 = ((((uint32_t )*((plain + 8) + 0) << 24) | ((uint32_t )*((plain + 8) + 1) << 16)) | ((uint32_t )*((plain + 8) + 2) << 8)) | (uint32_t )*((plain + 8) + 3);
#line 139
    x2 = ((((uint32_t )*((plain + 4) + 0) << 24) | ((uint32_t )*((plain + 4) + 1) << 16)) | ((uint32_t )*((plain + 4) + 2) << 8)) | (uint32_t )*((plain + 4) + 3);
#line 140
    x3 = ((((uint32_t )*(plain + 0) << 24) | ((uint32_t )*(plain + 1) << 16)) | ((uint32_t )*(plain + 2) << 8)) | (uint32_t )*(plain + 3);
#line 143
    x0 ^= ctx->keys[0][0];
#line 143
    x1 ^= ctx->keys[0][1];
#line 143
    x2 ^= ctx->keys[0][2];
#line 143
    x3 ^= ctx->keys[0][3];
#line 144
    t01 = x1 ^ x2;
#line 144
    t02 = x0 | x3;
#line 144
    t03 = x0 ^ x1;
#line 144
    y3 = t02 ^ t01;
#line 144
    t05 = x2 | y3;
#line 144
    t06 = x0 ^ x3;
#line 144
    t07 = x1 | x2;
#line 144
    t08 = x3 & t05;
#line 144
    t09 = t03 & t07;
#line 144
    y2 = t09 ^ t08;
#line 144
    t11 = t09 & y2;
#line 144
    t12 = x2 ^ x3;
#line 144
    t13 = t07 ^ t11;
#line 144
    t14 = x1 & t06;
#line 144
    t15 = t06 ^ t13;
#line 144
    y0 = ~ t15;
#line 144
    t17 = y0 ^ t14;
#line 144
    y1 = t12 ^ t17;
#line 145
    x0 = (y0 << 13) | (y0 >> 19);
#line 145
    x2 = (y2 << 3) | (y2 >> 29);
#line 145
    x1 = (y1 ^ x0) ^ x2;
#line 145
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 145
    x1 = (x1 << 1) | (x1 >> 31);
#line 145
    x3 = (x3 << 7) | (x3 >> 25);
#line 145
    x0 = (x0 ^ x1) ^ x3;
#line 145
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 145
    x0 = (x0 << 5) | (x0 >> 27);
#line 145
    x2 = (x2 << 22) | (x2 >> 10);
#line 146
    x0 ^= ctx->keys[1][0];
#line 146
    x1 ^= ctx->keys[1][1];
#line 146
    x2 ^= ctx->keys[1][2];
#line 146
    x3 ^= ctx->keys[1][3];
#line 147
    t01___0 = x0 | x3;
#line 147
    t02___0 = x2 ^ x3;
#line 147
    t03___0 = ~ x1;
#line 147
    t04 = x0 ^ x2;
#line 147
    t05___0 = x0 | t03___0;
#line 147
    t06___0 = x3 & t04;
#line 147
    t07___0 = t01___0 & t02___0;
#line 147
    t08___0 = x1 | t06___0;
#line 147
    y2 = t02___0 ^ t05___0;
#line 147
    t10 = t07___0 ^ t08___0;
#line 147
    t11___0 = t01___0 ^ t10;
#line 147
    t12___0 = y2 ^ t11___0;
#line 147
    t13___0 = x1 & x3;
#line 147
    y3 = ~ t10;
#line 147
    y1 = t13___0 ^ t12___0;
#line 147
    t16 = t10 | y1;
#line 147
    t17___0 = t05___0 & t16;
#line 147
    y0 = x2 ^ t17___0;
#line 148
    x0 = (y0 << 13) | (y0 >> 19);
#line 148
    x2 = (y2 << 3) | (y2 >> 29);
#line 148
    x1 = (y1 ^ x0) ^ x2;
#line 148
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 148
    x1 = (x1 << 1) | (x1 >> 31);
#line 148
    x3 = (x3 << 7) | (x3 >> 25);
#line 148
    x0 = (x0 ^ x1) ^ x3;
#line 148
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 148
    x0 = (x0 << 5) | (x0 >> 27);
#line 148
    x2 = (x2 << 22) | (x2 >> 10);
#line 149
    x0 ^= ctx->keys[2][0];
#line 149
    x1 ^= ctx->keys[2][1];
#line 149
    x2 ^= ctx->keys[2][2];
#line 149
    x3 ^= ctx->keys[2][3];
#line 150
    t01___1 = x0 | x2;
#line 150
    t02___1 = x0 ^ x1;
#line 150
    t03___1 = x3 ^ t01___1;
#line 150
    y0 = t02___1 ^ t03___1;
#line 150
    t05___1 = x2 ^ y0;
#line 150
    t06___1 = x1 ^ t05___1;
#line 150
    t07___1 = x1 | t05___1;
#line 150
    t08___1 = t01___1 & t06___1;
#line 150
    t09___0 = t03___1 ^ t07___1;
#line 150
    t10___0 = t02___1 | t09___0;
#line 150
    y1 = t10___0 ^ t08___1;
#line 150
    t12___1 = x0 | x3;
#line 150
    t13___1 = t09___0 ^ y1;
#line 150
    t14___0 = x1 ^ t13___1;
#line 150
    y3 = ~ t09___0;
#line 150
    y2 = t12___1 ^ t14___0;
#line 151
    x0 = (y0 << 13) | (y0 >> 19);
#line 151
    x2 = (y2 << 3) | (y2 >> 29);
#line 151
    x1 = (y1 ^ x0) ^ x2;
#line 151
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 151
    x1 = (x1 << 1) | (x1 >> 31);
#line 151
    x3 = (x3 << 7) | (x3 >> 25);
#line 151
    x0 = (x0 ^ x1) ^ x3;
#line 151
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 151
    x0 = (x0 << 5) | (x0 >> 27);
#line 151
    x2 = (x2 << 22) | (x2 >> 10);
#line 152
    x0 ^= ctx->keys[3][0];
#line 152
    x1 ^= ctx->keys[3][1];
#line 152
    x2 ^= ctx->keys[3][2];
#line 152
    x3 ^= ctx->keys[3][3];
#line 153
    t01___2 = x0 ^ x2;
#line 153
    t02___2 = x0 | x3;
#line 153
    t03___2 = x0 & x3;
#line 153
    t04___0 = t01___2 & t02___2;
#line 153
    t05___2 = x1 | t03___2;
#line 153
    t06___2 = x0 & x1;
#line 153
    t07___2 = x3 ^ t04___0;
#line 153
    t08___2 = x2 | t06___2;
#line 153
    t09___1 = x1 ^ t07___2;
#line 153
    t10___1 = x3 & t05___2;
#line 153
    t11___1 = t02___2 ^ t10___1;
#line 153
    y3 = t08___2 ^ t09___1;
#line 153
    t13___2 = x3 | y3;
#line 153
    t14___1 = x0 | t07___2;
#line 153
    t15___0 = x1 & t13___2;
#line 153
    y2 = t08___2 ^ t11___1;
#line 153
    y0 = t14___1 ^ t15___0;
#line 153
    y1 = t05___2 ^ t04___0;
#line 154
    x0 = (y0 << 13) | (y0 >> 19);
#line 154
    x2 = (y2 << 3) | (y2 >> 29);
#line 154
    x1 = (y1 ^ x0) ^ x2;
#line 154
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 154
    x1 = (x1 << 1) | (x1 >> 31);
#line 154
    x3 = (x3 << 7) | (x3 >> 25);
#line 154
    x0 = (x0 ^ x1) ^ x3;
#line 154
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 154
    x0 = (x0 << 5) | (x0 >> 27);
#line 154
    x2 = (x2 << 22) | (x2 >> 10);
#line 155
    x0 ^= ctx->keys[4][0];
#line 155
    x1 ^= ctx->keys[4][1];
#line 155
    x2 ^= ctx->keys[4][2];
#line 155
    x3 ^= ctx->keys[4][3];
#line 156
    t01___3 = x0 | x1;
#line 156
    t02___3 = x1 | x2;
#line 156
    t03___3 = x0 ^ t02___3;
#line 156
    t04___1 = x1 ^ x3;
#line 156
    t05___3 = x3 | t03___3;
#line 156
    t06___3 = x3 & t01___3;
#line 156
    y3 = t03___3 ^ t06___3;
#line 156
    t08___3 = y3 & t04___1;
#line 156
    t09___2 = t04___1 & t05___3;
#line 156
    t10___2 = x2 ^ t06___3;
#line 156
    t11___2 = x1 & x2;
#line 156
    t12___2 = t04___1 ^ t08___3;
#line 156
    t13___3 = t11___2 | t03___3;
#line 156
    t14___2 = t10___2 ^ t09___2;
#line 156
    t15___1 = x0 & t05___3;
#line 156
    t16___0 = t11___2 | t12___2;
#line 156
    y2 = t13___3 ^ t08___3;
#line 156
    y1 = t15___1 ^ t16___0;
#line 156
    y0 = ~ t14___2;
#line 157
    x0 = (y0 << 13) | (y0 >> 19);
#line 157
    x2 = (y2 << 3) | (y2 >> 29);
#line 157
    x1 = (y1 ^ x0) ^ x2;
#line 157
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 157
    x1 = (x1 << 1) | (x1 >> 31);
#line 157
    x3 = (x3 << 7) | (x3 >> 25);
#line 157
    x0 = (x0 ^ x1) ^ x3;
#line 157
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 157
    x0 = (x0 << 5) | (x0 >> 27);
#line 157
    x2 = (x2 << 22) | (x2 >> 10);
#line 158
    x0 ^= ctx->keys[5][0];
#line 158
    x1 ^= ctx->keys[5][1];
#line 158
    x2 ^= ctx->keys[5][2];
#line 158
    x3 ^= ctx->keys[5][3];
#line 159
    t01___4 = x1 ^ x3;
#line 159
    t02___4 = x1 | x3;
#line 159
    t03___4 = x0 & t01___4;
#line 159
    t04___2 = x2 ^ t02___4;
#line 159
    t05___4 = t03___4 ^ t04___2;
#line 159
    y0 = ~ t05___4;
#line 159
    t07___3 = x0 ^ t01___4;
#line 159
    t08___4 = x3 | y0;
#line 159
    t09___3 = x1 | t05___4;
#line 159
    t10___3 = x3 ^ t08___4;
#line 159
    t11___3 = x1 | t07___3;
#line 159
    t12___3 = t03___4 | y0;
#line 159
    t13___4 = t07___3 | t10___3;
#line 159
    t14___3 = t01___4 ^ t11___3;
#line 159
    y2 = t09___3 ^ t13___4;
#line 159
    y1 = t07___3 ^ t08___4;
#line 159
    y3 = t12___3 ^ t14___3;
#line 160
    x0 = (y0 << 13) | (y0 >> 19);
#line 160
    x2 = (y2 << 3) | (y2 >> 29);
#line 160
    x1 = (y1 ^ x0) ^ x2;
#line 160
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 160
    x1 = (x1 << 1) | (x1 >> 31);
#line 160
    x3 = (x3 << 7) | (x3 >> 25);
#line 160
    x0 = (x0 ^ x1) ^ x3;
#line 160
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 160
    x0 = (x0 << 5) | (x0 >> 27);
#line 160
    x2 = (x2 << 22) | (x2 >> 10);
#line 161
    x0 ^= ctx->keys[6][0];
#line 161
    x1 ^= ctx->keys[6][1];
#line 161
    x2 ^= ctx->keys[6][2];
#line 161
    x3 ^= ctx->keys[6][3];
#line 162
    t01___5 = x0 & x3;
#line 162
    t02___5 = x1 ^ x2;
#line 162
    t03___5 = x0 ^ x3;
#line 162
    t04___3 = t01___5 ^ t02___5;
#line 162
    t05___5 = x1 | x2;
#line 162
    y1 = ~ t04___3;
#line 162
    t07___4 = t03___5 & t05___5;
#line 162
    t08___5 = x1 & y1;
#line 162
    t09___4 = x0 | x2;
#line 162
    t10___4 = t07___4 ^ t08___5;
#line 162
    t11___4 = x1 | x3;
#line 162
    t12___4 = x2 ^ t11___4;
#line 162
    t13___5 = t09___4 ^ t10___4;
#line 162
    y2 = ~ t13___5;
#line 162
    t15___2 = y1 & t03___5;
#line 162
    y3 = t12___4 ^ t07___4;
#line 162
    t17___1 = x0 ^ x1;
#line 162
    t18 = y2 ^ t15___2;
#line 162
    y0 = t17___1 ^ t18;
#line 163
    x0 = (y0 << 13) | (y0 >> 19);
#line 163
    x2 = (y2 << 3) | (y2 >> 29);
#line 163
    x1 = (y1 ^ x0) ^ x2;
#line 163
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 163
    x1 = (x1 << 1) | (x1 >> 31);
#line 163
    x3 = (x3 << 7) | (x3 >> 25);
#line 163
    x0 = (x0 ^ x1) ^ x3;
#line 163
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 163
    x0 = (x0 << 5) | (x0 >> 27);
#line 163
    x2 = (x2 << 22) | (x2 >> 10);
#line 164
    x0 ^= ctx->keys[7][0];
#line 164
    x1 ^= ctx->keys[7][1];
#line 164
    x2 ^= ctx->keys[7][2];
#line 164
    x3 ^= ctx->keys[7][3];
#line 165
    t01___6 = x0 & x2;
#line 165
    t02___6 = ~ x3;
#line 165
    t03___6 = x0 & t02___6;
#line 165
    t04___4 = x1 | t01___6;
#line 165
    t05___6 = x0 & x1;
#line 165
    t06___4 = x2 ^ t04___4;
#line 165
    y3 = t03___6 ^ t06___4;
#line 165
    t08___6 = x2 | y3;
#line 165
    t09___5 = x3 | t05___6;
#line 165
    t10___5 = x0 ^ t08___6;
#line 165
    t11___5 = t04___4 & y3;
#line 165
    y1 = t09___5 ^ t10___5;
#line 165
    t13___6 = x1 ^ y1;
#line 165
    t14___4 = t01___6 ^ y1;
#line 165
    t15___3 = x2 ^ t05___6;
#line 165
    t16___1 = t11___5 | t13___6;
#line 165
    t17___2 = t02___6 | t14___4;
#line 165
    y0 = t15___3 ^ t17___2;
#line 165
    y2 = x0 ^ t16___1;
#line 166
    x0 = (y0 << 13) | (y0 >> 19);
#line 166
    x2 = (y2 << 3) | (y2 >> 29);
#line 166
    x1 = (y1 ^ x0) ^ x2;
#line 166
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 166
    x1 = (x1 << 1) | (x1 >> 31);
#line 166
    x3 = (x3 << 7) | (x3 >> 25);
#line 166
    x0 = (x0 ^ x1) ^ x3;
#line 166
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 166
    x0 = (x0 << 5) | (x0 >> 27);
#line 166
    x2 = (x2 << 22) | (x2 >> 10);
#line 167
    x0 ^= ctx->keys[8][0];
#line 167
    x1 ^= ctx->keys[8][1];
#line 167
    x2 ^= ctx->keys[8][2];
#line 167
    x3 ^= ctx->keys[8][3];
#line 168
    t01___7 = x1 ^ x2;
#line 168
    t02___7 = x0 | x3;
#line 168
    t03___7 = x0 ^ x1;
#line 168
    y3 = t02___7 ^ t01___7;
#line 168
    t05___7 = x2 | y3;
#line 168
    t06___5 = x0 ^ x3;
#line 168
    t07___5 = x1 | x2;
#line 168
    t08___7 = x3 & t05___7;
#line 168
    t09___6 = t03___7 & t07___5;
#line 168
    y2 = t09___6 ^ t08___7;
#line 168
    t11___6 = t09___6 & y2;
#line 168
    t12___5 = x2 ^ x3;
#line 168
    t13___7 = t07___5 ^ t11___6;
#line 168
    t14___5 = x1 & t06___5;
#line 168
    t15___4 = t06___5 ^ t13___7;
#line 168
    y0 = ~ t15___4;
#line 168
    t17___3 = y0 ^ t14___5;
#line 168
    y1 = t12___5 ^ t17___3;
#line 169
    x0 = (y0 << 13) | (y0 >> 19);
#line 169
    x2 = (y2 << 3) | (y2 >> 29);
#line 169
    x1 = (y1 ^ x0) ^ x2;
#line 169
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 169
    x1 = (x1 << 1) | (x1 >> 31);
#line 169
    x3 = (x3 << 7) | (x3 >> 25);
#line 169
    x0 = (x0 ^ x1) ^ x3;
#line 169
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 169
    x0 = (x0 << 5) | (x0 >> 27);
#line 169
    x2 = (x2 << 22) | (x2 >> 10);
#line 170
    x0 ^= ctx->keys[9][0];
#line 170
    x1 ^= ctx->keys[9][1];
#line 170
    x2 ^= ctx->keys[9][2];
#line 170
    x3 ^= ctx->keys[9][3];
#line 171
    t01___8 = x0 | x3;
#line 171
    t02___8 = x2 ^ x3;
#line 171
    t03___8 = ~ x1;
#line 171
    t04___5 = x0 ^ x2;
#line 171
    t05___8 = x0 | t03___8;
#line 171
    t06___6 = x3 & t04___5;
#line 171
    t07___6 = t01___8 & t02___8;
#line 171
    t08___8 = x1 | t06___6;
#line 171
    y2 = t02___8 ^ t05___8;
#line 171
    t10___6 = t07___6 ^ t08___8;
#line 171
    t11___7 = t01___8 ^ t10___6;
#line 171
    t12___6 = y2 ^ t11___7;
#line 171
    t13___8 = x1 & x3;
#line 171
    y3 = ~ t10___6;
#line 171
    y1 = t13___8 ^ t12___6;
#line 171
    t16___2 = t10___6 | y1;
#line 171
    t17___4 = t05___8 & t16___2;
#line 171
    y0 = x2 ^ t17___4;
#line 172
    x0 = (y0 << 13) | (y0 >> 19);
#line 172
    x2 = (y2 << 3) | (y2 >> 29);
#line 172
    x1 = (y1 ^ x0) ^ x2;
#line 172
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 172
    x1 = (x1 << 1) | (x1 >> 31);
#line 172
    x3 = (x3 << 7) | (x3 >> 25);
#line 172
    x0 = (x0 ^ x1) ^ x3;
#line 172
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 172
    x0 = (x0 << 5) | (x0 >> 27);
#line 172
    x2 = (x2 << 22) | (x2 >> 10);
#line 173
    x0 ^= ctx->keys[10][0];
#line 173
    x1 ^= ctx->keys[10][1];
#line 173
    x2 ^= ctx->keys[10][2];
#line 173
    x3 ^= ctx->keys[10][3];
#line 174
    t01___9 = x0 | x2;
#line 174
    t02___9 = x0 ^ x1;
#line 174
    t03___9 = x3 ^ t01___9;
#line 174
    y0 = t02___9 ^ t03___9;
#line 174
    t05___9 = x2 ^ y0;
#line 174
    t06___7 = x1 ^ t05___9;
#line 174
    t07___7 = x1 | t05___9;
#line 174
    t08___9 = t01___9 & t06___7;
#line 174
    t09___7 = t03___9 ^ t07___7;
#line 174
    t10___7 = t02___9 | t09___7;
#line 174
    y1 = t10___7 ^ t08___9;
#line 174
    t12___7 = x0 | x3;
#line 174
    t13___9 = t09___7 ^ y1;
#line 174
    t14___6 = x1 ^ t13___9;
#line 174
    y3 = ~ t09___7;
#line 174
    y2 = t12___7 ^ t14___6;
#line 175
    x0 = (y0 << 13) | (y0 >> 19);
#line 175
    x2 = (y2 << 3) | (y2 >> 29);
#line 175
    x1 = (y1 ^ x0) ^ x2;
#line 175
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 175
    x1 = (x1 << 1) | (x1 >> 31);
#line 175
    x3 = (x3 << 7) | (x3 >> 25);
#line 175
    x0 = (x0 ^ x1) ^ x3;
#line 175
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 175
    x0 = (x0 << 5) | (x0 >> 27);
#line 175
    x2 = (x2 << 22) | (x2 >> 10);
#line 176
    x0 ^= ctx->keys[11][0];
#line 176
    x1 ^= ctx->keys[11][1];
#line 176
    x2 ^= ctx->keys[11][2];
#line 176
    x3 ^= ctx->keys[11][3];
#line 177
    t01___10 = x0 ^ x2;
#line 177
    t02___10 = x0 | x3;
#line 177
    t03___10 = x0 & x3;
#line 177
    t04___6 = t01___10 & t02___10;
#line 177
    t05___10 = x1 | t03___10;
#line 177
    t06___8 = x0 & x1;
#line 177
    t07___8 = x3 ^ t04___6;
#line 177
    t08___10 = x2 | t06___8;
#line 177
    t09___8 = x1 ^ t07___8;
#line 177
    t10___8 = x3 & t05___10;
#line 177
    t11___8 = t02___10 ^ t10___8;
#line 177
    y3 = t08___10 ^ t09___8;
#line 177
    t13___10 = x3 | y3;
#line 177
    t14___7 = x0 | t07___8;
#line 177
    t15___5 = x1 & t13___10;
#line 177
    y2 = t08___10 ^ t11___8;
#line 177
    y0 = t14___7 ^ t15___5;
#line 177
    y1 = t05___10 ^ t04___6;
#line 178
    x0 = (y0 << 13) | (y0 >> 19);
#line 178
    x2 = (y2 << 3) | (y2 >> 29);
#line 178
    x1 = (y1 ^ x0) ^ x2;
#line 178
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 178
    x1 = (x1 << 1) | (x1 >> 31);
#line 178
    x3 = (x3 << 7) | (x3 >> 25);
#line 178
    x0 = (x0 ^ x1) ^ x3;
#line 178
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 178
    x0 = (x0 << 5) | (x0 >> 27);
#line 178
    x2 = (x2 << 22) | (x2 >> 10);
#line 179
    x0 ^= ctx->keys[12][0];
#line 179
    x1 ^= ctx->keys[12][1];
#line 179
    x2 ^= ctx->keys[12][2];
#line 179
    x3 ^= ctx->keys[12][3];
#line 180
    t01___11 = x0 | x1;
#line 180
    t02___11 = x1 | x2;
#line 180
    t03___11 = x0 ^ t02___11;
#line 180
    t04___7 = x1 ^ x3;
#line 180
    t05___11 = x3 | t03___11;
#line 180
    t06___9 = x3 & t01___11;
#line 180
    y3 = t03___11 ^ t06___9;
#line 180
    t08___11 = y3 & t04___7;
#line 180
    t09___9 = t04___7 & t05___11;
#line 180
    t10___9 = x2 ^ t06___9;
#line 180
    t11___9 = x1 & x2;
#line 180
    t12___8 = t04___7 ^ t08___11;
#line 180
    t13___11 = t11___9 | t03___11;
#line 180
    t14___8 = t10___9 ^ t09___9;
#line 180
    t15___6 = x0 & t05___11;
#line 180
    t16___3 = t11___9 | t12___8;
#line 180
    y2 = t13___11 ^ t08___11;
#line 180
    y1 = t15___6 ^ t16___3;
#line 180
    y0 = ~ t14___8;
#line 181
    x0 = (y0 << 13) | (y0 >> 19);
#line 181
    x2 = (y2 << 3) | (y2 >> 29);
#line 181
    x1 = (y1 ^ x0) ^ x2;
#line 181
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 181
    x1 = (x1 << 1) | (x1 >> 31);
#line 181
    x3 = (x3 << 7) | (x3 >> 25);
#line 181
    x0 = (x0 ^ x1) ^ x3;
#line 181
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 181
    x0 = (x0 << 5) | (x0 >> 27);
#line 181
    x2 = (x2 << 22) | (x2 >> 10);
#line 182
    x0 ^= ctx->keys[13][0];
#line 182
    x1 ^= ctx->keys[13][1];
#line 182
    x2 ^= ctx->keys[13][2];
#line 182
    x3 ^= ctx->keys[13][3];
#line 183
    t01___12 = x1 ^ x3;
#line 183
    t02___12 = x1 | x3;
#line 183
    t03___12 = x0 & t01___12;
#line 183
    t04___8 = x2 ^ t02___12;
#line 183
    t05___12 = t03___12 ^ t04___8;
#line 183
    y0 = ~ t05___12;
#line 183
    t07___9 = x0 ^ t01___12;
#line 183
    t08___12 = x3 | y0;
#line 183
    t09___10 = x1 | t05___12;
#line 183
    t10___10 = x3 ^ t08___12;
#line 183
    t11___10 = x1 | t07___9;
#line 183
    t12___9 = t03___12 | y0;
#line 183
    t13___12 = t07___9 | t10___10;
#line 183
    t14___9 = t01___12 ^ t11___10;
#line 183
    y2 = t09___10 ^ t13___12;
#line 183
    y1 = t07___9 ^ t08___12;
#line 183
    y3 = t12___9 ^ t14___9;
#line 184
    x0 = (y0 << 13) | (y0 >> 19);
#line 184
    x2 = (y2 << 3) | (y2 >> 29);
#line 184
    x1 = (y1 ^ x0) ^ x2;
#line 184
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 184
    x1 = (x1 << 1) | (x1 >> 31);
#line 184
    x3 = (x3 << 7) | (x3 >> 25);
#line 184
    x0 = (x0 ^ x1) ^ x3;
#line 184
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 184
    x0 = (x0 << 5) | (x0 >> 27);
#line 184
    x2 = (x2 << 22) | (x2 >> 10);
#line 185
    x0 ^= ctx->keys[14][0];
#line 185
    x1 ^= ctx->keys[14][1];
#line 185
    x2 ^= ctx->keys[14][2];
#line 185
    x3 ^= ctx->keys[14][3];
#line 186
    t01___13 = x0 & x3;
#line 186
    t02___13 = x1 ^ x2;
#line 186
    t03___13 = x0 ^ x3;
#line 186
    t04___9 = t01___13 ^ t02___13;
#line 186
    t05___13 = x1 | x2;
#line 186
    y1 = ~ t04___9;
#line 186
    t07___10 = t03___13 & t05___13;
#line 186
    t08___13 = x1 & y1;
#line 186
    t09___11 = x0 | x2;
#line 186
    t10___11 = t07___10 ^ t08___13;
#line 186
    t11___11 = x1 | x3;
#line 186
    t12___10 = x2 ^ t11___11;
#line 186
    t13___13 = t09___11 ^ t10___11;
#line 186
    y2 = ~ t13___13;
#line 186
    t15___7 = y1 & t03___13;
#line 186
    y3 = t12___10 ^ t07___10;
#line 186
    t17___5 = x0 ^ x1;
#line 186
    t18___0 = y2 ^ t15___7;
#line 186
    y0 = t17___5 ^ t18___0;
#line 187
    x0 = (y0 << 13) | (y0 >> 19);
#line 187
    x2 = (y2 << 3) | (y2 >> 29);
#line 187
    x1 = (y1 ^ x0) ^ x2;
#line 187
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 187
    x1 = (x1 << 1) | (x1 >> 31);
#line 187
    x3 = (x3 << 7) | (x3 >> 25);
#line 187
    x0 = (x0 ^ x1) ^ x3;
#line 187
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 187
    x0 = (x0 << 5) | (x0 >> 27);
#line 187
    x2 = (x2 << 22) | (x2 >> 10);
#line 188
    x0 ^= ctx->keys[15][0];
#line 188
    x1 ^= ctx->keys[15][1];
#line 188
    x2 ^= ctx->keys[15][2];
#line 188
    x3 ^= ctx->keys[15][3];
#line 189
    t01___14 = x0 & x2;
#line 189
    t02___14 = ~ x3;
#line 189
    t03___14 = x0 & t02___14;
#line 189
    t04___10 = x1 | t01___14;
#line 189
    t05___14 = x0 & x1;
#line 189
    t06___10 = x2 ^ t04___10;
#line 189
    y3 = t03___14 ^ t06___10;
#line 189
    t08___14 = x2 | y3;
#line 189
    t09___12 = x3 | t05___14;
#line 189
    t10___12 = x0 ^ t08___14;
#line 189
    t11___12 = t04___10 & y3;
#line 189
    y1 = t09___12 ^ t10___12;
#line 189
    t13___14 = x1 ^ y1;
#line 189
    t14___10 = t01___14 ^ y1;
#line 189
    t15___8 = x2 ^ t05___14;
#line 189
    t16___4 = t11___12 | t13___14;
#line 189
    t17___6 = t02___14 | t14___10;
#line 189
    y0 = t15___8 ^ t17___6;
#line 189
    y2 = x0 ^ t16___4;
#line 190
    x0 = (y0 << 13) | (y0 >> 19);
#line 190
    x2 = (y2 << 3) | (y2 >> 29);
#line 190
    x1 = (y1 ^ x0) ^ x2;
#line 190
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 190
    x1 = (x1 << 1) | (x1 >> 31);
#line 190
    x3 = (x3 << 7) | (x3 >> 25);
#line 190
    x0 = (x0 ^ x1) ^ x3;
#line 190
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 190
    x0 = (x0 << 5) | (x0 >> 27);
#line 190
    x2 = (x2 << 22) | (x2 >> 10);
#line 191
    x0 ^= ctx->keys[16][0];
#line 191
    x1 ^= ctx->keys[16][1];
#line 191
    x2 ^= ctx->keys[16][2];
#line 191
    x3 ^= ctx->keys[16][3];
#line 192
    t01___15 = x1 ^ x2;
#line 192
    t02___15 = x0 | x3;
#line 192
    t03___15 = x0 ^ x1;
#line 192
    y3 = t02___15 ^ t01___15;
#line 192
    t05___15 = x2 | y3;
#line 192
    t06___11 = x0 ^ x3;
#line 192
    t07___11 = x1 | x2;
#line 192
    t08___15 = x3 & t05___15;
#line 192
    t09___13 = t03___15 & t07___11;
#line 192
    y2 = t09___13 ^ t08___15;
#line 192
    t11___13 = t09___13 & y2;
#line 192
    t12___11 = x2 ^ x3;
#line 192
    t13___15 = t07___11 ^ t11___13;
#line 192
    t14___11 = x1 & t06___11;
#line 192
    t15___9 = t06___11 ^ t13___15;
#line 192
    y0 = ~ t15___9;
#line 192
    t17___7 = y0 ^ t14___11;
#line 192
    y1 = t12___11 ^ t17___7;
#line 193
    x0 = (y0 << 13) | (y0 >> 19);
#line 193
    x2 = (y2 << 3) | (y2 >> 29);
#line 193
    x1 = (y1 ^ x0) ^ x2;
#line 193
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 193
    x1 = (x1 << 1) | (x1 >> 31);
#line 193
    x3 = (x3 << 7) | (x3 >> 25);
#line 193
    x0 = (x0 ^ x1) ^ x3;
#line 193
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 193
    x0 = (x0 << 5) | (x0 >> 27);
#line 193
    x2 = (x2 << 22) | (x2 >> 10);
#line 194
    x0 ^= ctx->keys[17][0];
#line 194
    x1 ^= ctx->keys[17][1];
#line 194
    x2 ^= ctx->keys[17][2];
#line 194
    x3 ^= ctx->keys[17][3];
#line 195
    t01___16 = x0 | x3;
#line 195
    t02___16 = x2 ^ x3;
#line 195
    t03___16 = ~ x1;
#line 195
    t04___11 = x0 ^ x2;
#line 195
    t05___16 = x0 | t03___16;
#line 195
    t06___12 = x3 & t04___11;
#line 195
    t07___12 = t01___16 & t02___16;
#line 195
    t08___16 = x1 | t06___12;
#line 195
    y2 = t02___16 ^ t05___16;
#line 195
    t10___13 = t07___12 ^ t08___16;
#line 195
    t11___14 = t01___16 ^ t10___13;
#line 195
    t12___12 = y2 ^ t11___14;
#line 195
    t13___16 = x1 & x3;
#line 195
    y3 = ~ t10___13;
#line 195
    y1 = t13___16 ^ t12___12;
#line 195
    t16___5 = t10___13 | y1;
#line 195
    t17___8 = t05___16 & t16___5;
#line 195
    y0 = x2 ^ t17___8;
#line 196
    x0 = (y0 << 13) | (y0 >> 19);
#line 196
    x2 = (y2 << 3) | (y2 >> 29);
#line 196
    x1 = (y1 ^ x0) ^ x2;
#line 196
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 196
    x1 = (x1 << 1) | (x1 >> 31);
#line 196
    x3 = (x3 << 7) | (x3 >> 25);
#line 196
    x0 = (x0 ^ x1) ^ x3;
#line 196
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 196
    x0 = (x0 << 5) | (x0 >> 27);
#line 196
    x2 = (x2 << 22) | (x2 >> 10);
#line 197
    x0 ^= ctx->keys[18][0];
#line 197
    x1 ^= ctx->keys[18][1];
#line 197
    x2 ^= ctx->keys[18][2];
#line 197
    x3 ^= ctx->keys[18][3];
#line 198
    t01___17 = x0 | x2;
#line 198
    t02___17 = x0 ^ x1;
#line 198
    t03___17 = x3 ^ t01___17;
#line 198
    y0 = t02___17 ^ t03___17;
#line 198
    t05___17 = x2 ^ y0;
#line 198
    t06___13 = x1 ^ t05___17;
#line 198
    t07___13 = x1 | t05___17;
#line 198
    t08___17 = t01___17 & t06___13;
#line 198
    t09___14 = t03___17 ^ t07___13;
#line 198
    t10___14 = t02___17 | t09___14;
#line 198
    y1 = t10___14 ^ t08___17;
#line 198
    t12___13 = x0 | x3;
#line 198
    t13___17 = t09___14 ^ y1;
#line 198
    t14___12 = x1 ^ t13___17;
#line 198
    y3 = ~ t09___14;
#line 198
    y2 = t12___13 ^ t14___12;
#line 199
    x0 = (y0 << 13) | (y0 >> 19);
#line 199
    x2 = (y2 << 3) | (y2 >> 29);
#line 199
    x1 = (y1 ^ x0) ^ x2;
#line 199
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 199
    x1 = (x1 << 1) | (x1 >> 31);
#line 199
    x3 = (x3 << 7) | (x3 >> 25);
#line 199
    x0 = (x0 ^ x1) ^ x3;
#line 199
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 199
    x0 = (x0 << 5) | (x0 >> 27);
#line 199
    x2 = (x2 << 22) | (x2 >> 10);
#line 200
    x0 ^= ctx->keys[19][0];
#line 200
    x1 ^= ctx->keys[19][1];
#line 200
    x2 ^= ctx->keys[19][2];
#line 200
    x3 ^= ctx->keys[19][3];
#line 201
    t01___18 = x0 ^ x2;
#line 201
    t02___18 = x0 | x3;
#line 201
    t03___18 = x0 & x3;
#line 201
    t04___12 = t01___18 & t02___18;
#line 201
    t05___18 = x1 | t03___18;
#line 201
    t06___14 = x0 & x1;
#line 201
    t07___14 = x3 ^ t04___12;
#line 201
    t08___18 = x2 | t06___14;
#line 201
    t09___15 = x1 ^ t07___14;
#line 201
    t10___15 = x3 & t05___18;
#line 201
    t11___15 = t02___18 ^ t10___15;
#line 201
    y3 = t08___18 ^ t09___15;
#line 201
    t13___18 = x3 | y3;
#line 201
    t14___13 = x0 | t07___14;
#line 201
    t15___10 = x1 & t13___18;
#line 201
    y2 = t08___18 ^ t11___15;
#line 201
    y0 = t14___13 ^ t15___10;
#line 201
    y1 = t05___18 ^ t04___12;
#line 202
    x0 = (y0 << 13) | (y0 >> 19);
#line 202
    x2 = (y2 << 3) | (y2 >> 29);
#line 202
    x1 = (y1 ^ x0) ^ x2;
#line 202
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 202
    x1 = (x1 << 1) | (x1 >> 31);
#line 202
    x3 = (x3 << 7) | (x3 >> 25);
#line 202
    x0 = (x0 ^ x1) ^ x3;
#line 202
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 202
    x0 = (x0 << 5) | (x0 >> 27);
#line 202
    x2 = (x2 << 22) | (x2 >> 10);
#line 203
    x0 ^= ctx->keys[20][0];
#line 203
    x1 ^= ctx->keys[20][1];
#line 203
    x2 ^= ctx->keys[20][2];
#line 203
    x3 ^= ctx->keys[20][3];
#line 204
    t01___19 = x0 | x1;
#line 204
    t02___19 = x1 | x2;
#line 204
    t03___19 = x0 ^ t02___19;
#line 204
    t04___13 = x1 ^ x3;
#line 204
    t05___19 = x3 | t03___19;
#line 204
    t06___15 = x3 & t01___19;
#line 204
    y3 = t03___19 ^ t06___15;
#line 204
    t08___19 = y3 & t04___13;
#line 204
    t09___16 = t04___13 & t05___19;
#line 204
    t10___16 = x2 ^ t06___15;
#line 204
    t11___16 = x1 & x2;
#line 204
    t12___14 = t04___13 ^ t08___19;
#line 204
    t13___19 = t11___16 | t03___19;
#line 204
    t14___14 = t10___16 ^ t09___16;
#line 204
    t15___11 = x0 & t05___19;
#line 204
    t16___6 = t11___16 | t12___14;
#line 204
    y2 = t13___19 ^ t08___19;
#line 204
    y1 = t15___11 ^ t16___6;
#line 204
    y0 = ~ t14___14;
#line 205
    x0 = (y0 << 13) | (y0 >> 19);
#line 205
    x2 = (y2 << 3) | (y2 >> 29);
#line 205
    x1 = (y1 ^ x0) ^ x2;
#line 205
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 205
    x1 = (x1 << 1) | (x1 >> 31);
#line 205
    x3 = (x3 << 7) | (x3 >> 25);
#line 205
    x0 = (x0 ^ x1) ^ x3;
#line 205
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 205
    x0 = (x0 << 5) | (x0 >> 27);
#line 205
    x2 = (x2 << 22) | (x2 >> 10);
#line 206
    x0 ^= ctx->keys[21][0];
#line 206
    x1 ^= ctx->keys[21][1];
#line 206
    x2 ^= ctx->keys[21][2];
#line 206
    x3 ^= ctx->keys[21][3];
#line 207
    t01___20 = x1 ^ x3;
#line 207
    t02___20 = x1 | x3;
#line 207
    t03___20 = x0 & t01___20;
#line 207
    t04___14 = x2 ^ t02___20;
#line 207
    t05___20 = t03___20 ^ t04___14;
#line 207
    y0 = ~ t05___20;
#line 207
    t07___15 = x0 ^ t01___20;
#line 207
    t08___20 = x3 | y0;
#line 207
    t09___17 = x1 | t05___20;
#line 207
    t10___17 = x3 ^ t08___20;
#line 207
    t11___17 = x1 | t07___15;
#line 207
    t12___15 = t03___20 | y0;
#line 207
    t13___20 = t07___15 | t10___17;
#line 207
    t14___15 = t01___20 ^ t11___17;
#line 207
    y2 = t09___17 ^ t13___20;
#line 207
    y1 = t07___15 ^ t08___20;
#line 207
    y3 = t12___15 ^ t14___15;
#line 208
    x0 = (y0 << 13) | (y0 >> 19);
#line 208
    x2 = (y2 << 3) | (y2 >> 29);
#line 208
    x1 = (y1 ^ x0) ^ x2;
#line 208
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 208
    x1 = (x1 << 1) | (x1 >> 31);
#line 208
    x3 = (x3 << 7) | (x3 >> 25);
#line 208
    x0 = (x0 ^ x1) ^ x3;
#line 208
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 208
    x0 = (x0 << 5) | (x0 >> 27);
#line 208
    x2 = (x2 << 22) | (x2 >> 10);
#line 209
    x0 ^= ctx->keys[22][0];
#line 209
    x1 ^= ctx->keys[22][1];
#line 209
    x2 ^= ctx->keys[22][2];
#line 209
    x3 ^= ctx->keys[22][3];
#line 210
    t01___21 = x0 & x3;
#line 210
    t02___21 = x1 ^ x2;
#line 210
    t03___21 = x0 ^ x3;
#line 210
    t04___15 = t01___21 ^ t02___21;
#line 210
    t05___21 = x1 | x2;
#line 210
    y1 = ~ t04___15;
#line 210
    t07___16 = t03___21 & t05___21;
#line 210
    t08___21 = x1 & y1;
#line 210
    t09___18 = x0 | x2;
#line 210
    t10___18 = t07___16 ^ t08___21;
#line 210
    t11___18 = x1 | x3;
#line 210
    t12___16 = x2 ^ t11___18;
#line 210
    t13___21 = t09___18 ^ t10___18;
#line 210
    y2 = ~ t13___21;
#line 210
    t15___12 = y1 & t03___21;
#line 210
    y3 = t12___16 ^ t07___16;
#line 210
    t17___9 = x0 ^ x1;
#line 210
    t18___1 = y2 ^ t15___12;
#line 210
    y0 = t17___9 ^ t18___1;
#line 211
    x0 = (y0 << 13) | (y0 >> 19);
#line 211
    x2 = (y2 << 3) | (y2 >> 29);
#line 211
    x1 = (y1 ^ x0) ^ x2;
#line 211
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 211
    x1 = (x1 << 1) | (x1 >> 31);
#line 211
    x3 = (x3 << 7) | (x3 >> 25);
#line 211
    x0 = (x0 ^ x1) ^ x3;
#line 211
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 211
    x0 = (x0 << 5) | (x0 >> 27);
#line 211
    x2 = (x2 << 22) | (x2 >> 10);
#line 212
    x0 ^= ctx->keys[23][0];
#line 212
    x1 ^= ctx->keys[23][1];
#line 212
    x2 ^= ctx->keys[23][2];
#line 212
    x3 ^= ctx->keys[23][3];
#line 213
    t01___22 = x0 & x2;
#line 213
    t02___22 = ~ x3;
#line 213
    t03___22 = x0 & t02___22;
#line 213
    t04___16 = x1 | t01___22;
#line 213
    t05___22 = x0 & x1;
#line 213
    t06___16 = x2 ^ t04___16;
#line 213
    y3 = t03___22 ^ t06___16;
#line 213
    t08___22 = x2 | y3;
#line 213
    t09___19 = x3 | t05___22;
#line 213
    t10___19 = x0 ^ t08___22;
#line 213
    t11___19 = t04___16 & y3;
#line 213
    y1 = t09___19 ^ t10___19;
#line 213
    t13___22 = x1 ^ y1;
#line 213
    t14___16 = t01___22 ^ y1;
#line 213
    t15___13 = x2 ^ t05___22;
#line 213
    t16___7 = t11___19 | t13___22;
#line 213
    t17___10 = t02___22 | t14___16;
#line 213
    y0 = t15___13 ^ t17___10;
#line 213
    y2 = x0 ^ t16___7;
#line 214
    x0 = (y0 << 13) | (y0 >> 19);
#line 214
    x2 = (y2 << 3) | (y2 >> 29);
#line 214
    x1 = (y1 ^ x0) ^ x2;
#line 214
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 214
    x1 = (x1 << 1) | (x1 >> 31);
#line 214
    x3 = (x3 << 7) | (x3 >> 25);
#line 214
    x0 = (x0 ^ x1) ^ x3;
#line 214
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 214
    x0 = (x0 << 5) | (x0 >> 27);
#line 214
    x2 = (x2 << 22) | (x2 >> 10);
#line 215
    x0 ^= ctx->keys[24][0];
#line 215
    x1 ^= ctx->keys[24][1];
#line 215
    x2 ^= ctx->keys[24][2];
#line 215
    x3 ^= ctx->keys[24][3];
#line 216
    t01___23 = x1 ^ x2;
#line 216
    t02___23 = x0 | x3;
#line 216
    t03___23 = x0 ^ x1;
#line 216
    y3 = t02___23 ^ t01___23;
#line 216
    t05___23 = x2 | y3;
#line 216
    t06___17 = x0 ^ x3;
#line 216
    t07___17 = x1 | x2;
#line 216
    t08___23 = x3 & t05___23;
#line 216
    t09___20 = t03___23 & t07___17;
#line 216
    y2 = t09___20 ^ t08___23;
#line 216
    t11___20 = t09___20 & y2;
#line 216
    t12___17 = x2 ^ x3;
#line 216
    t13___23 = t07___17 ^ t11___20;
#line 216
    t14___17 = x1 & t06___17;
#line 216
    t15___14 = t06___17 ^ t13___23;
#line 216
    y0 = ~ t15___14;
#line 216
    t17___11 = y0 ^ t14___17;
#line 216
    y1 = t12___17 ^ t17___11;
#line 217
    x0 = (y0 << 13) | (y0 >> 19);
#line 217
    x2 = (y2 << 3) | (y2 >> 29);
#line 217
    x1 = (y1 ^ x0) ^ x2;
#line 217
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 217
    x1 = (x1 << 1) | (x1 >> 31);
#line 217
    x3 = (x3 << 7) | (x3 >> 25);
#line 217
    x0 = (x0 ^ x1) ^ x3;
#line 217
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 217
    x0 = (x0 << 5) | (x0 >> 27);
#line 217
    x2 = (x2 << 22) | (x2 >> 10);
#line 218
    x0 ^= ctx->keys[25][0];
#line 218
    x1 ^= ctx->keys[25][1];
#line 218
    x2 ^= ctx->keys[25][2];
#line 218
    x3 ^= ctx->keys[25][3];
#line 219
    t01___24 = x0 | x3;
#line 219
    t02___24 = x2 ^ x3;
#line 219
    t03___24 = ~ x1;
#line 219
    t04___17 = x0 ^ x2;
#line 219
    t05___24 = x0 | t03___24;
#line 219
    t06___18 = x3 & t04___17;
#line 219
    t07___18 = t01___24 & t02___24;
#line 219
    t08___24 = x1 | t06___18;
#line 219
    y2 = t02___24 ^ t05___24;
#line 219
    t10___20 = t07___18 ^ t08___24;
#line 219
    t11___21 = t01___24 ^ t10___20;
#line 219
    t12___18 = y2 ^ t11___21;
#line 219
    t13___24 = x1 & x3;
#line 219
    y3 = ~ t10___20;
#line 219
    y1 = t13___24 ^ t12___18;
#line 219
    t16___8 = t10___20 | y1;
#line 219
    t17___12 = t05___24 & t16___8;
#line 219
    y0 = x2 ^ t17___12;
#line 220
    x0 = (y0 << 13) | (y0 >> 19);
#line 220
    x2 = (y2 << 3) | (y2 >> 29);
#line 220
    x1 = (y1 ^ x0) ^ x2;
#line 220
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 220
    x1 = (x1 << 1) | (x1 >> 31);
#line 220
    x3 = (x3 << 7) | (x3 >> 25);
#line 220
    x0 = (x0 ^ x1) ^ x3;
#line 220
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 220
    x0 = (x0 << 5) | (x0 >> 27);
#line 220
    x2 = (x2 << 22) | (x2 >> 10);
#line 221
    x0 ^= ctx->keys[26][0];
#line 221
    x1 ^= ctx->keys[26][1];
#line 221
    x2 ^= ctx->keys[26][2];
#line 221
    x3 ^= ctx->keys[26][3];
#line 222
    t01___25 = x0 | x2;
#line 222
    t02___25 = x0 ^ x1;
#line 222
    t03___25 = x3 ^ t01___25;
#line 222
    y0 = t02___25 ^ t03___25;
#line 222
    t05___25 = x2 ^ y0;
#line 222
    t06___19 = x1 ^ t05___25;
#line 222
    t07___19 = x1 | t05___25;
#line 222
    t08___25 = t01___25 & t06___19;
#line 222
    t09___21 = t03___25 ^ t07___19;
#line 222
    t10___21 = t02___25 | t09___21;
#line 222
    y1 = t10___21 ^ t08___25;
#line 222
    t12___19 = x0 | x3;
#line 222
    t13___25 = t09___21 ^ y1;
#line 222
    t14___18 = x1 ^ t13___25;
#line 222
    y3 = ~ t09___21;
#line 222
    y2 = t12___19 ^ t14___18;
#line 223
    x0 = (y0 << 13) | (y0 >> 19);
#line 223
    x2 = (y2 << 3) | (y2 >> 29);
#line 223
    x1 = (y1 ^ x0) ^ x2;
#line 223
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 223
    x1 = (x1 << 1) | (x1 >> 31);
#line 223
    x3 = (x3 << 7) | (x3 >> 25);
#line 223
    x0 = (x0 ^ x1) ^ x3;
#line 223
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 223
    x0 = (x0 << 5) | (x0 >> 27);
#line 223
    x2 = (x2 << 22) | (x2 >> 10);
#line 224
    x0 ^= ctx->keys[27][0];
#line 224
    x1 ^= ctx->keys[27][1];
#line 224
    x2 ^= ctx->keys[27][2];
#line 224
    x3 ^= ctx->keys[27][3];
#line 225
    t01___26 = x0 ^ x2;
#line 225
    t02___26 = x0 | x3;
#line 225
    t03___26 = x0 & x3;
#line 225
    t04___18 = t01___26 & t02___26;
#line 225
    t05___26 = x1 | t03___26;
#line 225
    t06___20 = x0 & x1;
#line 225
    t07___20 = x3 ^ t04___18;
#line 225
    t08___26 = x2 | t06___20;
#line 225
    t09___22 = x1 ^ t07___20;
#line 225
    t10___22 = x3 & t05___26;
#line 225
    t11___22 = t02___26 ^ t10___22;
#line 225
    y3 = t08___26 ^ t09___22;
#line 225
    t13___26 = x3 | y3;
#line 225
    t14___19 = x0 | t07___20;
#line 225
    t15___15 = x1 & t13___26;
#line 225
    y2 = t08___26 ^ t11___22;
#line 225
    y0 = t14___19 ^ t15___15;
#line 225
    y1 = t05___26 ^ t04___18;
#line 226
    x0 = (y0 << 13) | (y0 >> 19);
#line 226
    x2 = (y2 << 3) | (y2 >> 29);
#line 226
    x1 = (y1 ^ x0) ^ x2;
#line 226
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 226
    x1 = (x1 << 1) | (x1 >> 31);
#line 226
    x3 = (x3 << 7) | (x3 >> 25);
#line 226
    x0 = (x0 ^ x1) ^ x3;
#line 226
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 226
    x0 = (x0 << 5) | (x0 >> 27);
#line 226
    x2 = (x2 << 22) | (x2 >> 10);
#line 227
    x0 ^= ctx->keys[28][0];
#line 227
    x1 ^= ctx->keys[28][1];
#line 227
    x2 ^= ctx->keys[28][2];
#line 227
    x3 ^= ctx->keys[28][3];
#line 228
    t01___27 = x0 | x1;
#line 228
    t02___27 = x1 | x2;
#line 228
    t03___27 = x0 ^ t02___27;
#line 228
    t04___19 = x1 ^ x3;
#line 228
    t05___27 = x3 | t03___27;
#line 228
    t06___21 = x3 & t01___27;
#line 228
    y3 = t03___27 ^ t06___21;
#line 228
    t08___27 = y3 & t04___19;
#line 228
    t09___23 = t04___19 & t05___27;
#line 228
    t10___23 = x2 ^ t06___21;
#line 228
    t11___23 = x1 & x2;
#line 228
    t12___20 = t04___19 ^ t08___27;
#line 228
    t13___27 = t11___23 | t03___27;
#line 228
    t14___20 = t10___23 ^ t09___23;
#line 228
    t15___16 = x0 & t05___27;
#line 228
    t16___9 = t11___23 | t12___20;
#line 228
    y2 = t13___27 ^ t08___27;
#line 228
    y1 = t15___16 ^ t16___9;
#line 228
    y0 = ~ t14___20;
#line 229
    x0 = (y0 << 13) | (y0 >> 19);
#line 229
    x2 = (y2 << 3) | (y2 >> 29);
#line 229
    x1 = (y1 ^ x0) ^ x2;
#line 229
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 229
    x1 = (x1 << 1) | (x1 >> 31);
#line 229
    x3 = (x3 << 7) | (x3 >> 25);
#line 229
    x0 = (x0 ^ x1) ^ x3;
#line 229
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 229
    x0 = (x0 << 5) | (x0 >> 27);
#line 229
    x2 = (x2 << 22) | (x2 >> 10);
#line 230
    x0 ^= ctx->keys[29][0];
#line 230
    x1 ^= ctx->keys[29][1];
#line 230
    x2 ^= ctx->keys[29][2];
#line 230
    x3 ^= ctx->keys[29][3];
#line 231
    t01___28 = x1 ^ x3;
#line 231
    t02___28 = x1 | x3;
#line 231
    t03___28 = x0 & t01___28;
#line 231
    t04___20 = x2 ^ t02___28;
#line 231
    t05___28 = t03___28 ^ t04___20;
#line 231
    y0 = ~ t05___28;
#line 231
    t07___21 = x0 ^ t01___28;
#line 231
    t08___28 = x3 | y0;
#line 231
    t09___24 = x1 | t05___28;
#line 231
    t10___24 = x3 ^ t08___28;
#line 231
    t11___24 = x1 | t07___21;
#line 231
    t12___21 = t03___28 | y0;
#line 231
    t13___28 = t07___21 | t10___24;
#line 231
    t14___21 = t01___28 ^ t11___24;
#line 231
    y2 = t09___24 ^ t13___28;
#line 231
    y1 = t07___21 ^ t08___28;
#line 231
    y3 = t12___21 ^ t14___21;
#line 232
    x0 = (y0 << 13) | (y0 >> 19);
#line 232
    x2 = (y2 << 3) | (y2 >> 29);
#line 232
    x1 = (y1 ^ x0) ^ x2;
#line 232
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 232
    x1 = (x1 << 1) | (x1 >> 31);
#line 232
    x3 = (x3 << 7) | (x3 >> 25);
#line 232
    x0 = (x0 ^ x1) ^ x3;
#line 232
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 232
    x0 = (x0 << 5) | (x0 >> 27);
#line 232
    x2 = (x2 << 22) | (x2 >> 10);
#line 233
    x0 ^= ctx->keys[30][0];
#line 233
    x1 ^= ctx->keys[30][1];
#line 233
    x2 ^= ctx->keys[30][2];
#line 233
    x3 ^= ctx->keys[30][3];
#line 234
    t01___29 = x0 & x3;
#line 234
    t02___29 = x1 ^ x2;
#line 234
    t03___29 = x0 ^ x3;
#line 234
    t04___21 = t01___29 ^ t02___29;
#line 234
    t05___29 = x1 | x2;
#line 234
    y1 = ~ t04___21;
#line 234
    t07___22 = t03___29 & t05___29;
#line 234
    t08___29 = x1 & y1;
#line 234
    t09___25 = x0 | x2;
#line 234
    t10___25 = t07___22 ^ t08___29;
#line 234
    t11___25 = x1 | x3;
#line 234
    t12___22 = x2 ^ t11___25;
#line 234
    t13___29 = t09___25 ^ t10___25;
#line 234
    y2 = ~ t13___29;
#line 234
    t15___17 = y1 & t03___29;
#line 234
    y3 = t12___22 ^ t07___22;
#line 234
    t17___13 = x0 ^ x1;
#line 234
    t18___2 = y2 ^ t15___17;
#line 234
    y0 = t17___13 ^ t18___2;
#line 235
    x0 = (y0 << 13) | (y0 >> 19);
#line 235
    x2 = (y2 << 3) | (y2 >> 29);
#line 235
    x1 = (y1 ^ x0) ^ x2;
#line 235
    x3 = (y3 ^ x2) ^ (x0 << 3);
#line 235
    x1 = (x1 << 1) | (x1 >> 31);
#line 235
    x3 = (x3 << 7) | (x3 >> 25);
#line 235
    x0 = (x0 ^ x1) ^ x3;
#line 235
    x2 = (x2 ^ x3) ^ (x1 << 7);
#line 235
    x0 = (x0 << 5) | (x0 >> 27);
#line 235
    x2 = (x2 << 22) | (x2 >> 10);
#line 236
    x0 ^= ctx->keys[31][0];
#line 236
    x1 ^= ctx->keys[31][1];
#line 236
    x2 ^= ctx->keys[31][2];
#line 236
    x3 ^= ctx->keys[31][3];
#line 237
    t01___30 = x0 & x2;
#line 237
    t02___30 = ~ x3;
#line 237
    t03___30 = x0 & t02___30;
#line 237
    t04___22 = x1 | t01___30;
#line 237
    t05___30 = x0 & x1;
#line 237
    t06___22 = x2 ^ t04___22;
#line 237
    y3 = t03___30 ^ t06___22;
#line 237
    t08___30 = x2 | y3;
#line 237
    t09___26 = x3 | t05___30;
#line 237
    t10___26 = x0 ^ t08___30;
#line 237
    t11___26 = t04___22 & y3;
#line 237
    y1 = t09___26 ^ t10___26;
#line 237
    t13___30 = x1 ^ y1;
#line 237
    t14___22 = t01___30 ^ y1;
#line 237
    t15___18 = x2 ^ t05___30;
#line 237
    t16___10 = t11___26 | t13___30;
#line 237
    t17___14 = t02___30 | t14___22;
#line 237
    y0 = t15___18 ^ t17___14;
#line 237
    y2 = x0 ^ t16___10;
#line 238
    x0 = y0;
#line 238
    x1 = y1;
#line 238
    x2 = y2;
#line 238
    x3 = y3;
#line 239
    x0 ^= ctx->keys[32][0];
#line 239
    x1 ^= ctx->keys[32][1];
#line 239
    x2 ^= ctx->keys[32][2];
#line 239
    x3 ^= ctx->keys[32][3];
    {
    {
#line 244
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 244
      *(dst + 0) = (uint8_t )((x3 >> 24) & 255U);
#line 244
      *(dst + 1) = (uint8_t )((x3 >> 16) & 255U);
#line 244
      *(dst + 2) = (uint8_t )((x3 >> 8) & 255U);
#line 244
      *(dst + 3) = (uint8_t )(x3 & 255U);
#line 244
      goto while_break___0;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: ;
    {
    {
#line 245
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 245
      *((dst + 4) + 0) = (uint8_t )((x2 >> 24) & 255U);
#line 245
      *((dst + 4) + 1) = (uint8_t )((x2 >> 16) & 255U);
#line 245
      *((dst + 4) + 2) = (uint8_t )((x2 >> 8) & 255U);
#line 245
      *((dst + 4) + 3) = (uint8_t )(x2 & 255U);
#line 245
      goto while_break___1;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: ;
    {
    {
#line 246
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 246
      *((dst + 8) + 0) = (uint8_t )((x1 >> 24) & 255U);
#line 246
      *((dst + 8) + 1) = (uint8_t )((x1 >> 16) & 255U);
#line 246
      *((dst + 8) + 2) = (uint8_t )((x1 >> 8) & 255U);
#line 246
      *((dst + 8) + 3) = (uint8_t )(x1 & 255U);
#line 246
      goto while_break___2;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
    {
    {
#line 247
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 247
      *((dst + 12) + 0) = (uint8_t )((x0 >> 24) & 255U);
#line 247
      *((dst + 12) + 1) = (uint8_t )((x0 >> 16) & 255U);
#line 247
      *((dst + 12) + 2) = (uint8_t )((x0 >> 8) & 255U);
#line 247
      *((dst + 12) + 3) = (uint8_t )(x0 & 255U);
#line 247
      goto while_break___3;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: 
#line 134
    length -= 16U;
#line 134
    dst += 16;
#line 134
    plain += 16;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 249
  return;
}
}
#line 251 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent.c"
void nettle_serpent_decrypt(struct serpent_ctx *ctx , unsigned int length , uint8_t *dst ,
                            uint8_t const   *cipher ) 
{ 
  register uint32_t x0 ;
  register uint32_t x1 ;
  register uint32_t x2 ;
  register uint32_t x3 ;
  register uint32_t y0 ;
  register uint32_t y1 ;
  register uint32_t y2 ;
  register uint32_t y3 ;
  register uint32_t t02 ;
  register uint32_t t03 ;
  register uint32_t t04 ;
  register uint32_t t06 ;
  register uint32_t t07 ;
  register uint32_t t08 ;
  register uint32_t t09 ;
  register uint32_t t10 ;
  register uint32_t t11 ;
  register uint32_t t13 ;
  register uint32_t t14 ;
  register uint32_t t15 ;
  register uint32_t t16 ;
  register uint32_t t01 ;
  register uint32_t t02___0 ;
  register uint32_t t03___0 ;
  register uint32_t t04___0 ;
  register uint32_t t05 ;
  register uint32_t t06___0 ;
  register uint32_t t07___0 ;
  register uint32_t t08___0 ;
  register uint32_t t09___0 ;
  register uint32_t t12 ;
  register uint32_t t13___0 ;
  register uint32_t t14___0 ;
  register uint32_t t15___0 ;
  register uint32_t t16___0 ;
  register uint32_t t17 ;
  register uint32_t t01___0 ;
  register uint32_t t02___1 ;
  register uint32_t t03___1 ;
  register uint32_t t04___1 ;
  register uint32_t t05___0 ;
  register uint32_t t07___1 ;
  register uint32_t t08___1 ;
  register uint32_t t09___1 ;
  register uint32_t t10___0 ;
  register uint32_t t12___0 ;
  register uint32_t t13___1 ;
  register uint32_t t15___1 ;
  register uint32_t t16___1 ;
  register uint32_t t01___1 ;
  register uint32_t t02___2 ;
  register uint32_t t03___2 ;
  register uint32_t t04___2 ;
  register uint32_t t05___1 ;
  register uint32_t t06___1 ;
  register uint32_t t07___2 ;
  register uint32_t t09___2 ;
  register uint32_t t10___1 ;
  register uint32_t t11___0 ;
  register uint32_t t12___1 ;
  register uint32_t t13___2 ;
  register uint32_t t15___2 ;
  register uint32_t t01___2 ;
  register uint32_t t02___3 ;
  register uint32_t t03___3 ;
  register uint32_t t04___3 ;
  register uint32_t t05___2 ;
  register uint32_t t06___2 ;
  register uint32_t t07___3 ;
  register uint32_t t09___3 ;
  register uint32_t t11___1 ;
  register uint32_t t12___2 ;
  register uint32_t t13___3 ;
  register uint32_t t14___1 ;
  register uint32_t t16___2 ;
  register uint32_t t01___3 ;
  register uint32_t t02___4 ;
  register uint32_t t03___4 ;
  register uint32_t t04___4 ;
  register uint32_t t06___3 ;
  register uint32_t t07___4 ;
  register uint32_t t08___2 ;
  register uint32_t t09___4 ;
  register uint32_t t10___2 ;
  register uint32_t t11___2 ;
  register uint32_t t12___3 ;
  register uint32_t t15___3 ;
  register uint32_t t16___3 ;
  register uint32_t t17___0 ;
  register uint32_t t01___4 ;
  register uint32_t t02___5 ;
  register uint32_t t03___5 ;
  register uint32_t t04___5 ;
  register uint32_t t05___3 ;
  register uint32_t t06___4 ;
  register uint32_t t07___5 ;
  register uint32_t t08___3 ;
  register uint32_t t09___5 ;
  register uint32_t t10___3 ;
  register uint32_t t11___3 ;
  register uint32_t t14___2 ;
  register uint32_t t15___4 ;
  register uint32_t t17___1 ;
  register uint32_t t01___5 ;
  register uint32_t t02___6 ;
  register uint32_t t03___6 ;
  register uint32_t t04___6 ;
  register uint32_t t05___4 ;
  register uint32_t t06___5 ;
  register uint32_t t08___4 ;
  register uint32_t t09___6 ;
  register uint32_t t10___4 ;
  register uint32_t t12___4 ;
  register uint32_t t13___4 ;
  register uint32_t t14___3 ;
  register uint32_t t15___5 ;
  register uint32_t t17___2 ;
  register uint32_t t18 ;
  register uint32_t t01___6 ;
  register uint32_t t02___7 ;
  register uint32_t t03___7 ;
  register uint32_t t04___7 ;
  register uint32_t t06___6 ;
  register uint32_t t07___6 ;
  register uint32_t t08___5 ;
  register uint32_t t09___7 ;
  register uint32_t t10___5 ;
  register uint32_t t11___4 ;
  register uint32_t t13___5 ;
  register uint32_t t14___4 ;
  register uint32_t t15___6 ;
  register uint32_t t16___4 ;
  register uint32_t t01___7 ;
  register uint32_t t02___8 ;
  register uint32_t t03___8 ;
  register uint32_t t04___8 ;
  register uint32_t t05___5 ;
  register uint32_t t06___7 ;
  register uint32_t t07___7 ;
  register uint32_t t08___6 ;
  register uint32_t t09___8 ;
  register uint32_t t12___5 ;
  register uint32_t t13___6 ;
  register uint32_t t14___5 ;
  register uint32_t t15___7 ;
  register uint32_t t16___5 ;
  register uint32_t t17___3 ;
  register uint32_t t01___8 ;
  register uint32_t t02___9 ;
  register uint32_t t03___9 ;
  register uint32_t t04___9 ;
  register uint32_t t05___6 ;
  register uint32_t t07___8 ;
  register uint32_t t08___7 ;
  register uint32_t t09___9 ;
  register uint32_t t10___6 ;
  register uint32_t t12___6 ;
  register uint32_t t13___7 ;
  register uint32_t t15___8 ;
  register uint32_t t16___6 ;
  register uint32_t t01___9 ;
  register uint32_t t02___10 ;
  register uint32_t t03___10 ;
  register uint32_t t04___10 ;
  register uint32_t t05___7 ;
  register uint32_t t06___8 ;
  register uint32_t t07___9 ;
  register uint32_t t09___10 ;
  register uint32_t t10___7 ;
  register uint32_t t11___5 ;
  register uint32_t t12___7 ;
  register uint32_t t13___8 ;
  register uint32_t t15___9 ;
  register uint32_t t01___10 ;
  register uint32_t t02___11 ;
  register uint32_t t03___11 ;
  register uint32_t t04___11 ;
  register uint32_t t05___8 ;
  register uint32_t t06___9 ;
  register uint32_t t07___10 ;
  register uint32_t t09___11 ;
  register uint32_t t11___6 ;
  register uint32_t t12___8 ;
  register uint32_t t13___9 ;
  register uint32_t t14___6 ;
  register uint32_t t16___7 ;
  register uint32_t t01___11 ;
  register uint32_t t02___12 ;
  register uint32_t t03___12 ;
  register uint32_t t04___12 ;
  register uint32_t t06___10 ;
  register uint32_t t07___11 ;
  register uint32_t t08___8 ;
  register uint32_t t09___12 ;
  register uint32_t t10___8 ;
  register uint32_t t11___7 ;
  register uint32_t t12___9 ;
  register uint32_t t15___10 ;
  register uint32_t t16___8 ;
  register uint32_t t17___4 ;
  register uint32_t t01___12 ;
  register uint32_t t02___13 ;
  register uint32_t t03___13 ;
  register uint32_t t04___13 ;
  register uint32_t t05___9 ;
  register uint32_t t06___11 ;
  register uint32_t t07___12 ;
  register uint32_t t08___9 ;
  register uint32_t t09___13 ;
  register uint32_t t10___9 ;
  register uint32_t t11___8 ;
  register uint32_t t14___7 ;
  register uint32_t t15___11 ;
  register uint32_t t17___5 ;
  register uint32_t t01___13 ;
  register uint32_t t02___14 ;
  register uint32_t t03___14 ;
  register uint32_t t04___14 ;
  register uint32_t t05___10 ;
  register uint32_t t06___12 ;
  register uint32_t t08___10 ;
  register uint32_t t09___14 ;
  register uint32_t t10___10 ;
  register uint32_t t12___10 ;
  register uint32_t t13___10 ;
  register uint32_t t14___8 ;
  register uint32_t t15___12 ;
  register uint32_t t17___6 ;
  register uint32_t t18___0 ;
  register uint32_t t01___14 ;
  register uint32_t t02___15 ;
  register uint32_t t03___15 ;
  register uint32_t t04___15 ;
  register uint32_t t06___13 ;
  register uint32_t t07___13 ;
  register uint32_t t08___11 ;
  register uint32_t t09___15 ;
  register uint32_t t10___11 ;
  register uint32_t t11___9 ;
  register uint32_t t13___11 ;
  register uint32_t t14___9 ;
  register uint32_t t15___13 ;
  register uint32_t t16___9 ;
  register uint32_t t01___15 ;
  register uint32_t t02___16 ;
  register uint32_t t03___16 ;
  register uint32_t t04___16 ;
  register uint32_t t05___11 ;
  register uint32_t t06___14 ;
  register uint32_t t07___14 ;
  register uint32_t t08___12 ;
  register uint32_t t09___16 ;
  register uint32_t t12___11 ;
  register uint32_t t13___12 ;
  register uint32_t t14___10 ;
  register uint32_t t15___14 ;
  register uint32_t t16___10 ;
  register uint32_t t17___7 ;
  register uint32_t t01___16 ;
  register uint32_t t02___17 ;
  register uint32_t t03___17 ;
  register uint32_t t04___17 ;
  register uint32_t t05___12 ;
  register uint32_t t07___15 ;
  register uint32_t t08___13 ;
  register uint32_t t09___17 ;
  register uint32_t t10___12 ;
  register uint32_t t12___12 ;
  register uint32_t t13___13 ;
  register uint32_t t15___15 ;
  register uint32_t t16___11 ;
  register uint32_t t01___17 ;
  register uint32_t t02___18 ;
  register uint32_t t03___18 ;
  register uint32_t t04___18 ;
  register uint32_t t05___13 ;
  register uint32_t t06___15 ;
  register uint32_t t07___16 ;
  register uint32_t t09___18 ;
  register uint32_t t10___13 ;
  register uint32_t t11___10 ;
  register uint32_t t12___13 ;
  register uint32_t t13___14 ;
  register uint32_t t15___16 ;
  register uint32_t t01___18 ;
  register uint32_t t02___19 ;
  register uint32_t t03___19 ;
  register uint32_t t04___19 ;
  register uint32_t t05___14 ;
  register uint32_t t06___16 ;
  register uint32_t t07___17 ;
  register uint32_t t09___19 ;
  register uint32_t t11___11 ;
  register uint32_t t12___14 ;
  register uint32_t t13___15 ;
  register uint32_t t14___11 ;
  register uint32_t t16___12 ;
  register uint32_t t01___19 ;
  register uint32_t t02___20 ;
  register uint32_t t03___20 ;
  register uint32_t t04___20 ;
  register uint32_t t06___17 ;
  register uint32_t t07___18 ;
  register uint32_t t08___14 ;
  register uint32_t t09___20 ;
  register uint32_t t10___14 ;
  register uint32_t t11___12 ;
  register uint32_t t12___15 ;
  register uint32_t t15___17 ;
  register uint32_t t16___13 ;
  register uint32_t t17___8 ;
  register uint32_t t01___20 ;
  register uint32_t t02___21 ;
  register uint32_t t03___21 ;
  register uint32_t t04___21 ;
  register uint32_t t05___15 ;
  register uint32_t t06___18 ;
  register uint32_t t07___19 ;
  register uint32_t t08___15 ;
  register uint32_t t09___21 ;
  register uint32_t t10___15 ;
  register uint32_t t11___13 ;
  register uint32_t t14___12 ;
  register uint32_t t15___18 ;
  register uint32_t t17___9 ;
  register uint32_t t01___21 ;
  register uint32_t t02___22 ;
  register uint32_t t03___22 ;
  register uint32_t t04___22 ;
  register uint32_t t05___16 ;
  register uint32_t t06___19 ;
  register uint32_t t08___16 ;
  register uint32_t t09___22 ;
  register uint32_t t10___16 ;
  register uint32_t t12___16 ;
  register uint32_t t13___16 ;
  register uint32_t t14___13 ;
  register uint32_t t15___19 ;
  register uint32_t t17___10 ;
  register uint32_t t18___1 ;
  register uint32_t t01___22 ;
  register uint32_t t02___23 ;
  register uint32_t t03___23 ;
  register uint32_t t04___23 ;
  register uint32_t t06___20 ;
  register uint32_t t07___20 ;
  register uint32_t t08___17 ;
  register uint32_t t09___23 ;
  register uint32_t t10___17 ;
  register uint32_t t11___14 ;
  register uint32_t t13___17 ;
  register uint32_t t14___14 ;
  register uint32_t t15___20 ;
  register uint32_t t16___14 ;
  register uint32_t t01___23 ;
  register uint32_t t02___24 ;
  register uint32_t t03___24 ;
  register uint32_t t04___24 ;
  register uint32_t t05___17 ;
  register uint32_t t06___21 ;
  register uint32_t t07___21 ;
  register uint32_t t08___18 ;
  register uint32_t t09___24 ;
  register uint32_t t12___17 ;
  register uint32_t t13___18 ;
  register uint32_t t14___15 ;
  register uint32_t t15___21 ;
  register uint32_t t16___15 ;
  register uint32_t t17___11 ;
  register uint32_t t01___24 ;
  register uint32_t t02___25 ;
  register uint32_t t03___25 ;
  register uint32_t t04___25 ;
  register uint32_t t05___18 ;
  register uint32_t t07___22 ;
  register uint32_t t08___19 ;
  register uint32_t t09___25 ;
  register uint32_t t10___18 ;
  register uint32_t t12___18 ;
  register uint32_t t13___19 ;
  register uint32_t t15___22 ;
  register uint32_t t16___16 ;
  register uint32_t t01___25 ;
  register uint32_t t02___26 ;
  register uint32_t t03___26 ;
  register uint32_t t04___26 ;
  register uint32_t t05___19 ;
  register uint32_t t06___22 ;
  register uint32_t t07___23 ;
  register uint32_t t09___26 ;
  register uint32_t t10___19 ;
  register uint32_t t11___15 ;
  register uint32_t t12___19 ;
  register uint32_t t13___20 ;
  register uint32_t t15___23 ;
  register uint32_t t01___26 ;
  register uint32_t t02___27 ;
  register uint32_t t03___27 ;
  register uint32_t t04___27 ;
  register uint32_t t05___20 ;
  register uint32_t t06___23 ;
  register uint32_t t07___24 ;
  register uint32_t t09___27 ;
  register uint32_t t11___16 ;
  register uint32_t t12___20 ;
  register uint32_t t13___21 ;
  register uint32_t t14___16 ;
  register uint32_t t16___17 ;
  register uint32_t t01___27 ;
  register uint32_t t02___28 ;
  register uint32_t t03___28 ;
  register uint32_t t04___28 ;
  register uint32_t t06___24 ;
  register uint32_t t07___25 ;
  register uint32_t t08___20 ;
  register uint32_t t09___28 ;
  register uint32_t t10___20 ;
  register uint32_t t11___17 ;
  register uint32_t t12___21 ;
  register uint32_t t15___24 ;
  register uint32_t t16___18 ;
  register uint32_t t17___12 ;
  register uint32_t t01___28 ;
  register uint32_t t02___29 ;
  register uint32_t t03___29 ;
  register uint32_t t04___29 ;
  register uint32_t t05___21 ;
  register uint32_t t06___25 ;
  register uint32_t t07___26 ;
  register uint32_t t08___21 ;
  register uint32_t t09___29 ;
  register uint32_t t10___21 ;
  register uint32_t t11___18 ;
  register uint32_t t14___17 ;
  register uint32_t t15___25 ;
  register uint32_t t17___13 ;
  register uint32_t t01___29 ;
  register uint32_t t02___30 ;
  register uint32_t t03___30 ;
  register uint32_t t04___30 ;
  register uint32_t t05___22 ;
  register uint32_t t06___26 ;
  register uint32_t t08___22 ;
  register uint32_t t09___30 ;
  register uint32_t t10___22 ;
  register uint32_t t12___22 ;
  register uint32_t t13___22 ;
  register uint32_t t14___18 ;
  register uint32_t t15___26 ;
  register uint32_t t17___14 ;
  register uint32_t t18___2 ;
  register uint32_t t01___30 ;
  char *__cil_tmp460 ;
  char *__cil_tmp461 ;
  char *__cil_tmp462 ;
  char *__cil_tmp463 ;
  char *__cil_tmp464 ;
  char *__cil_tmp465 ;

  {
#line 259
  if (! (! (length % 16U))) {
    {
    {
#line 259
    __assert_fail("!((length) % (16))", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent.c",
                  259U, "nettle_serpent_decrypt");
    }
    }
  }
  {
  {
#line 259
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 259
    if (! length) {
#line 259
      goto while_break;
    }
#line 262
    x0 = ((((uint32_t )*((cipher + 12) + 0) << 24) | ((uint32_t )*((cipher + 12) + 1) << 16)) | ((uint32_t )*((cipher + 12) + 2) << 8)) | (uint32_t )*((cipher + 12) + 3);
#line 263
    x1 = ((((uint32_t )*((cipher + 8) + 0) << 24) | ((uint32_t )*((cipher + 8) + 1) << 16)) | ((uint32_t )*((cipher + 8) + 2) << 8)) | (uint32_t )*((cipher + 8) + 3);
#line 264
    x2 = ((((uint32_t )*((cipher + 4) + 0) << 24) | ((uint32_t )*((cipher + 4) + 1) << 16)) | ((uint32_t )*((cipher + 4) + 2) << 8)) | (uint32_t )*((cipher + 4) + 3);
#line 265
    x3 = ((((uint32_t )*(cipher + 0) << 24) | ((uint32_t )*(cipher + 1) << 16)) | ((uint32_t )*(cipher + 2) << 8)) | (uint32_t )*(cipher + 3);
#line 268
    x0 ^= ctx->keys[32][0];
#line 268
    x1 ^= ctx->keys[32][1];
#line 268
    x2 ^= ctx->keys[32][2];
#line 268
    x3 ^= ctx->keys[32][3];
#line 269
    t01 = x0 & x1;
#line 269
    t02 = x0 | x1;
#line 269
    t03 = x2 | t01;
#line 269
    t04 = x3 & t02;
#line 269
    y3 = t03 ^ t04;
#line 269
    t06 = x1 ^ t04;
#line 269
    t07 = x3 ^ y3;
#line 269
    t08 = ~ t07;
#line 269
    t09 = t06 | t08;
#line 269
    t10 = x1 ^ x3;
#line 269
    t11 = x0 | x3;
#line 269
    y1 = x0 ^ t09;
#line 269
    t13 = x2 ^ t06;
#line 269
    t14 = x2 & t11;
#line 269
    t15 = x3 | y1;
#line 269
    t16 = t01 | t10;
#line 269
    y0 = t13 ^ t15;
#line 269
    y2 = t14 ^ t16;
#line 270
    y0 ^= ctx->keys[31][0];
#line 270
    y1 ^= ctx->keys[31][1];
#line 270
    y2 ^= ctx->keys[31][2];
#line 270
    y3 ^= ctx->keys[31][3];
#line 271
    x2 = (y2 << 10) | (y2 >> 22);
#line 271
    x0 = (y0 << 27) | (y0 >> 5);
#line 271
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 271
    x0 = (x0 ^ y1) ^ y3;
#line 271
    x3 = (y3 << 25) | (y3 >> 7);
#line 271
    x1 = (y1 << 31) | (y1 >> 1);
#line 271
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 271
    x1 = (x1 ^ x0) ^ x2;
#line 271
    x2 = (x2 << 29) | (x2 >> 3);
#line 271
    x0 = (x0 << 19) | (x0 >> 13);
#line 272
    t01___0 = x0 ^ x2;
#line 272
    t02___0 = ~ x2;
#line 272
    t03___0 = x1 & t01___0;
#line 272
    t04___0 = x1 | t02___0;
#line 272
    t05 = x3 | t03___0;
#line 272
    t06___0 = x1 ^ x3;
#line 272
    t07___0 = x0 & t04___0;
#line 272
    t08___0 = x0 | t02___0;
#line 272
    t09___0 = t07___0 ^ t05;
#line 272
    y1 = t06___0 ^ t08___0;
#line 272
    y0 = ~ t09___0;
#line 272
    t12 = x1 & y0;
#line 272
    t13___0 = t01___0 & t05;
#line 272
    t14___0 = t01___0 ^ t12;
#line 272
    t15___0 = t07___0 ^ t13___0;
#line 272
    t16___0 = x3 | t02___0;
#line 272
    t17 = x0 ^ y1;
#line 272
    y3 = t17 ^ t15___0;
#line 272
    y2 = t16___0 ^ t14___0;
#line 273
    y0 ^= ctx->keys[30][0];
#line 273
    y1 ^= ctx->keys[30][1];
#line 273
    y2 ^= ctx->keys[30][2];
#line 273
    y3 ^= ctx->keys[30][3];
#line 274
    x2 = (y2 << 10) | (y2 >> 22);
#line 274
    x0 = (y0 << 27) | (y0 >> 5);
#line 274
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 274
    x0 = (x0 ^ y1) ^ y3;
#line 274
    x3 = (y3 << 25) | (y3 >> 7);
#line 274
    x1 = (y1 << 31) | (y1 >> 1);
#line 274
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 274
    x1 = (x1 ^ x0) ^ x2;
#line 274
    x2 = (x2 << 29) | (x2 >> 3);
#line 274
    x0 = (x0 << 19) | (x0 >> 13);
#line 275
    t01___1 = x0 & x3;
#line 275
    t02___1 = x2 ^ t01___1;
#line 275
    t03___1 = x0 ^ x3;
#line 275
    t04___1 = x1 & t02___1;
#line 275
    t05___0 = x0 & x2;
#line 275
    y0 = t03___1 ^ t04___1;
#line 275
    t07___1 = x0 & y0;
#line 275
    t08___1 = t01___1 ^ y0;
#line 275
    t09___1 = x1 | t05___0;
#line 275
    t10___0 = ~ x1;
#line 275
    y1 = t08___1 ^ t09___1;
#line 275
    t12___0 = t10___0 | t07___1;
#line 275
    t13___1 = y0 | y1;
#line 275
    y3 = t02___1 ^ t12___0;
#line 275
    t15___1 = t02___1 ^ t13___1;
#line 275
    t16___1 = x1 ^ x3;
#line 275
    y2 = t16___1 ^ t15___1;
#line 276
    y0 ^= ctx->keys[29][0];
#line 276
    y1 ^= ctx->keys[29][1];
#line 276
    y2 ^= ctx->keys[29][2];
#line 276
    y3 ^= ctx->keys[29][3];
#line 277
    x2 = (y2 << 10) | (y2 >> 22);
#line 277
    x0 = (y0 << 27) | (y0 >> 5);
#line 277
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 277
    x0 = (x0 ^ y1) ^ y3;
#line 277
    x3 = (y3 << 25) | (y3 >> 7);
#line 277
    x1 = (y1 << 31) | (y1 >> 1);
#line 277
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 277
    x1 = (x1 ^ x0) ^ x2;
#line 277
    x2 = (x2 << 29) | (x2 >> 3);
#line 277
    x0 = (x0 << 19) | (x0 >> 13);
#line 278
    t01___2 = x1 | x3;
#line 278
    t02___2 = x2 | x3;
#line 278
    t03___2 = x0 & t01___2;
#line 278
    t04___2 = x1 ^ t02___2;
#line 278
    t05___1 = x2 ^ x3;
#line 278
    t06___1 = ~ t03___2;
#line 278
    t07___2 = x0 & t04___2;
#line 278
    y1 = t05___1 ^ t07___2;
#line 278
    t09___2 = y1 | t06___1;
#line 278
    t10___1 = x0 ^ t07___2;
#line 278
    t11___0 = t01___2 ^ t09___2;
#line 278
    t12___1 = x3 ^ t04___2;
#line 278
    t13___2 = x2 | t10___1;
#line 278
    y3 = t03___2 ^ t12___1;
#line 278
    t15___2 = x0 ^ t04___2;
#line 278
    y2 = t11___0 ^ t13___2;
#line 278
    y0 = t15___2 ^ t09___2;
#line 279
    y0 ^= ctx->keys[28][0];
#line 279
    y1 ^= ctx->keys[28][1];
#line 279
    y2 ^= ctx->keys[28][2];
#line 279
    y3 ^= ctx->keys[28][3];
#line 280
    x2 = (y2 << 10) | (y2 >> 22);
#line 280
    x0 = (y0 << 27) | (y0 >> 5);
#line 280
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 280
    x0 = (x0 ^ y1) ^ y3;
#line 280
    x3 = (y3 << 25) | (y3 >> 7);
#line 280
    x1 = (y1 << 31) | (y1 >> 1);
#line 280
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 280
    x1 = (x1 ^ x0) ^ x2;
#line 280
    x2 = (x2 << 29) | (x2 >> 3);
#line 280
    x0 = (x0 << 19) | (x0 >> 13);
#line 281
    t01___3 = x2 | x3;
#line 281
    t02___3 = x0 | x3;
#line 281
    t03___3 = x2 ^ t02___3;
#line 281
    t04___3 = x1 ^ t02___3;
#line 281
    t05___2 = x0 ^ x3;
#line 281
    t06___2 = t04___3 & t03___3;
#line 281
    t07___3 = x1 & t01___3;
#line 281
    y2 = t05___2 ^ t06___2;
#line 281
    t09___3 = x0 ^ t03___3;
#line 281
    y0 = t07___3 ^ t03___3;
#line 281
    t11___1 = y0 | t05___2;
#line 281
    t12___2 = t09___3 & t11___1;
#line 281
    t13___3 = x0 & y2;
#line 281
    t14___1 = t01___3 ^ t05___2;
#line 281
    y1 = x1 ^ t12___2;
#line 281
    t16___2 = x1 | t13___3;
#line 281
    y3 = t14___1 ^ t16___2;
#line 282
    y0 ^= ctx->keys[27][0];
#line 282
    y1 ^= ctx->keys[27][1];
#line 282
    y2 ^= ctx->keys[27][2];
#line 282
    y3 ^= ctx->keys[27][3];
#line 283
    x2 = (y2 << 10) | (y2 >> 22);
#line 283
    x0 = (y0 << 27) | (y0 >> 5);
#line 283
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 283
    x0 = (x0 ^ y1) ^ y3;
#line 283
    x3 = (y3 << 25) | (y3 >> 7);
#line 283
    x1 = (y1 << 31) | (y1 >> 1);
#line 283
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 283
    x1 = (x1 ^ x0) ^ x2;
#line 283
    x2 = (x2 << 29) | (x2 >> 3);
#line 283
    x0 = (x0 << 19) | (x0 >> 13);
#line 284
    t01___4 = x0 ^ x3;
#line 284
    t02___4 = x2 ^ x3;
#line 284
    t03___4 = x0 & x2;
#line 284
    t04___4 = x1 | t02___4;
#line 284
    y0 = t01___4 ^ t04___4;
#line 284
    t06___3 = x0 | x2;
#line 284
    t07___4 = x3 | y0;
#line 284
    t08___2 = ~ x3;
#line 284
    t09___4 = x1 & t06___3;
#line 284
    t10___2 = t08___2 | t03___4;
#line 284
    t11___2 = x1 & t07___4;
#line 284
    t12___3 = t06___3 & t02___4;
#line 284
    y3 = t09___4 ^ t10___2;
#line 284
    y1 = t12___3 ^ t11___2;
#line 284
    t15___3 = x2 & y3;
#line 284
    t16___3 = y0 ^ y1;
#line 284
    t17___0 = t10___2 ^ t15___3;
#line 284
    y2 = t16___3 ^ t17___0;
#line 285
    y0 ^= ctx->keys[26][0];
#line 285
    y1 ^= ctx->keys[26][1];
#line 285
    y2 ^= ctx->keys[26][2];
#line 285
    y3 ^= ctx->keys[26][3];
#line 286
    x2 = (y2 << 10) | (y2 >> 22);
#line 286
    x0 = (y0 << 27) | (y0 >> 5);
#line 286
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 286
    x0 = (x0 ^ y1) ^ y3;
#line 286
    x3 = (y3 << 25) | (y3 >> 7);
#line 286
    x1 = (y1 << 31) | (y1 >> 1);
#line 286
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 286
    x1 = (x1 ^ x0) ^ x2;
#line 286
    x2 = (x2 << 29) | (x2 >> 3);
#line 286
    x0 = (x0 << 19) | (x0 >> 13);
#line 287
    t01___5 = x0 ^ x1;
#line 287
    t02___5 = x1 | x3;
#line 287
    t03___5 = x0 & x2;
#line 287
    t04___5 = x2 ^ t02___5;
#line 287
    t05___3 = x0 | t04___5;
#line 287
    t06___4 = t01___5 & t05___3;
#line 287
    t07___5 = x3 | t03___5;
#line 287
    t08___3 = x1 ^ t06___4;
#line 287
    t09___5 = t07___5 ^ t06___4;
#line 287
    t10___3 = t04___5 | t03___5;
#line 287
    t11___3 = x3 & t08___3;
#line 287
    y2 = ~ t09___5;
#line 287
    y1 = t10___3 ^ t11___3;
#line 287
    t14___2 = x0 | y2;
#line 287
    t15___4 = t06___4 ^ y1;
#line 287
    y3 = t01___5 ^ t04___5;
#line 287
    t17___1 = x2 ^ t15___4;
#line 287
    y0 = t14___2 ^ t17___1;
#line 288
    y0 ^= ctx->keys[25][0];
#line 288
    y1 ^= ctx->keys[25][1];
#line 288
    y2 ^= ctx->keys[25][2];
#line 288
    y3 ^= ctx->keys[25][3];
#line 289
    x2 = (y2 << 10) | (y2 >> 22);
#line 289
    x0 = (y0 << 27) | (y0 >> 5);
#line 289
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 289
    x0 = (x0 ^ y1) ^ y3;
#line 289
    x3 = (y3 << 25) | (y3 >> 7);
#line 289
    x1 = (y1 << 31) | (y1 >> 1);
#line 289
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 289
    x1 = (x1 ^ x0) ^ x2;
#line 289
    x2 = (x2 << 29) | (x2 >> 3);
#line 289
    x0 = (x0 << 19) | (x0 >> 13);
#line 290
    t01___6 = x2 ^ x3;
#line 290
    t02___6 = x0 | x1;
#line 290
    t03___6 = x1 | x2;
#line 290
    t04___6 = x2 & t01___6;
#line 290
    t05___4 = t02___6 ^ t01___6;
#line 290
    t06___5 = x0 | t04___6;
#line 290
    y2 = ~ t05___4;
#line 290
    t08___4 = x1 ^ x3;
#line 290
    t09___6 = t03___6 & t08___4;
#line 290
    t10___4 = x3 | y2;
#line 290
    y1 = t09___6 ^ t06___5;
#line 290
    t12___4 = x0 | t05___4;
#line 290
    t13___4 = y1 ^ t12___4;
#line 290
    t14___3 = t03___6 ^ t10___4;
#line 290
    t15___5 = x0 ^ x2;
#line 290
    y3 = t14___3 ^ t13___4;
#line 290
    t17___2 = t05___4 & t13___4;
#line 290
    t18 = t14___3 | t17___2;
#line 290
    y0 = t15___5 ^ t18;
#line 291
    y0 ^= ctx->keys[24][0];
#line 291
    y1 ^= ctx->keys[24][1];
#line 291
    y2 ^= ctx->keys[24][2];
#line 291
    y3 ^= ctx->keys[24][3];
#line 292
    x2 = (y2 << 10) | (y2 >> 22);
#line 292
    x0 = (y0 << 27) | (y0 >> 5);
#line 292
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 292
    x0 = (x0 ^ y1) ^ y3;
#line 292
    x3 = (y3 << 25) | (y3 >> 7);
#line 292
    x1 = (y1 << 31) | (y1 >> 1);
#line 292
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 292
    x1 = (x1 ^ x0) ^ x2;
#line 292
    x2 = (x2 << 29) | (x2 >> 3);
#line 292
    x0 = (x0 << 19) | (x0 >> 13);
#line 293
    t01___7 = x0 & x1;
#line 293
    t02___7 = x0 | x1;
#line 293
    t03___7 = x2 | t01___7;
#line 293
    t04___7 = x3 & t02___7;
#line 293
    y3 = t03___7 ^ t04___7;
#line 293
    t06___6 = x1 ^ t04___7;
#line 293
    t07___6 = x3 ^ y3;
#line 293
    t08___5 = ~ t07___6;
#line 293
    t09___7 = t06___6 | t08___5;
#line 293
    t10___5 = x1 ^ x3;
#line 293
    t11___4 = x0 | x3;
#line 293
    y1 = x0 ^ t09___7;
#line 293
    t13___5 = x2 ^ t06___6;
#line 293
    t14___4 = x2 & t11___4;
#line 293
    t15___6 = x3 | y1;
#line 293
    t16___4 = t01___7 | t10___5;
#line 293
    y0 = t13___5 ^ t15___6;
#line 293
    y2 = t14___4 ^ t16___4;
#line 294
    y0 ^= ctx->keys[23][0];
#line 294
    y1 ^= ctx->keys[23][1];
#line 294
    y2 ^= ctx->keys[23][2];
#line 294
    y3 ^= ctx->keys[23][3];
#line 295
    x2 = (y2 << 10) | (y2 >> 22);
#line 295
    x0 = (y0 << 27) | (y0 >> 5);
#line 295
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 295
    x0 = (x0 ^ y1) ^ y3;
#line 295
    x3 = (y3 << 25) | (y3 >> 7);
#line 295
    x1 = (y1 << 31) | (y1 >> 1);
#line 295
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 295
    x1 = (x1 ^ x0) ^ x2;
#line 295
    x2 = (x2 << 29) | (x2 >> 3);
#line 295
    x0 = (x0 << 19) | (x0 >> 13);
#line 296
    t01___8 = x0 ^ x2;
#line 296
    t02___8 = ~ x2;
#line 296
    t03___8 = x1 & t01___8;
#line 296
    t04___8 = x1 | t02___8;
#line 296
    t05___5 = x3 | t03___8;
#line 296
    t06___7 = x1 ^ x3;
#line 296
    t07___7 = x0 & t04___8;
#line 296
    t08___6 = x0 | t02___8;
#line 296
    t09___8 = t07___7 ^ t05___5;
#line 296
    y1 = t06___7 ^ t08___6;
#line 296
    y0 = ~ t09___8;
#line 296
    t12___5 = x1 & y0;
#line 296
    t13___6 = t01___8 & t05___5;
#line 296
    t14___5 = t01___8 ^ t12___5;
#line 296
    t15___7 = t07___7 ^ t13___6;
#line 296
    t16___5 = x3 | t02___8;
#line 296
    t17___3 = x0 ^ y1;
#line 296
    y3 = t17___3 ^ t15___7;
#line 296
    y2 = t16___5 ^ t14___5;
#line 297
    y0 ^= ctx->keys[22][0];
#line 297
    y1 ^= ctx->keys[22][1];
#line 297
    y2 ^= ctx->keys[22][2];
#line 297
    y3 ^= ctx->keys[22][3];
#line 298
    x2 = (y2 << 10) | (y2 >> 22);
#line 298
    x0 = (y0 << 27) | (y0 >> 5);
#line 298
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 298
    x0 = (x0 ^ y1) ^ y3;
#line 298
    x3 = (y3 << 25) | (y3 >> 7);
#line 298
    x1 = (y1 << 31) | (y1 >> 1);
#line 298
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 298
    x1 = (x1 ^ x0) ^ x2;
#line 298
    x2 = (x2 << 29) | (x2 >> 3);
#line 298
    x0 = (x0 << 19) | (x0 >> 13);
#line 299
    t01___9 = x0 & x3;
#line 299
    t02___9 = x2 ^ t01___9;
#line 299
    t03___9 = x0 ^ x3;
#line 299
    t04___9 = x1 & t02___9;
#line 299
    t05___6 = x0 & x2;
#line 299
    y0 = t03___9 ^ t04___9;
#line 299
    t07___8 = x0 & y0;
#line 299
    t08___7 = t01___9 ^ y0;
#line 299
    t09___9 = x1 | t05___6;
#line 299
    t10___6 = ~ x1;
#line 299
    y1 = t08___7 ^ t09___9;
#line 299
    t12___6 = t10___6 | t07___8;
#line 299
    t13___7 = y0 | y1;
#line 299
    y3 = t02___9 ^ t12___6;
#line 299
    t15___8 = t02___9 ^ t13___7;
#line 299
    t16___6 = x1 ^ x3;
#line 299
    y2 = t16___6 ^ t15___8;
#line 300
    y0 ^= ctx->keys[21][0];
#line 300
    y1 ^= ctx->keys[21][1];
#line 300
    y2 ^= ctx->keys[21][2];
#line 300
    y3 ^= ctx->keys[21][3];
#line 301
    x2 = (y2 << 10) | (y2 >> 22);
#line 301
    x0 = (y0 << 27) | (y0 >> 5);
#line 301
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 301
    x0 = (x0 ^ y1) ^ y3;
#line 301
    x3 = (y3 << 25) | (y3 >> 7);
#line 301
    x1 = (y1 << 31) | (y1 >> 1);
#line 301
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 301
    x1 = (x1 ^ x0) ^ x2;
#line 301
    x2 = (x2 << 29) | (x2 >> 3);
#line 301
    x0 = (x0 << 19) | (x0 >> 13);
#line 302
    t01___10 = x1 | x3;
#line 302
    t02___10 = x2 | x3;
#line 302
    t03___10 = x0 & t01___10;
#line 302
    t04___10 = x1 ^ t02___10;
#line 302
    t05___7 = x2 ^ x3;
#line 302
    t06___8 = ~ t03___10;
#line 302
    t07___9 = x0 & t04___10;
#line 302
    y1 = t05___7 ^ t07___9;
#line 302
    t09___10 = y1 | t06___8;
#line 302
    t10___7 = x0 ^ t07___9;
#line 302
    t11___5 = t01___10 ^ t09___10;
#line 302
    t12___7 = x3 ^ t04___10;
#line 302
    t13___8 = x2 | t10___7;
#line 302
    y3 = t03___10 ^ t12___7;
#line 302
    t15___9 = x0 ^ t04___10;
#line 302
    y2 = t11___5 ^ t13___8;
#line 302
    y0 = t15___9 ^ t09___10;
#line 303
    y0 ^= ctx->keys[20][0];
#line 303
    y1 ^= ctx->keys[20][1];
#line 303
    y2 ^= ctx->keys[20][2];
#line 303
    y3 ^= ctx->keys[20][3];
#line 304
    x2 = (y2 << 10) | (y2 >> 22);
#line 304
    x0 = (y0 << 27) | (y0 >> 5);
#line 304
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 304
    x0 = (x0 ^ y1) ^ y3;
#line 304
    x3 = (y3 << 25) | (y3 >> 7);
#line 304
    x1 = (y1 << 31) | (y1 >> 1);
#line 304
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 304
    x1 = (x1 ^ x0) ^ x2;
#line 304
    x2 = (x2 << 29) | (x2 >> 3);
#line 304
    x0 = (x0 << 19) | (x0 >> 13);
#line 305
    t01___11 = x2 | x3;
#line 305
    t02___11 = x0 | x3;
#line 305
    t03___11 = x2 ^ t02___11;
#line 305
    t04___11 = x1 ^ t02___11;
#line 305
    t05___8 = x0 ^ x3;
#line 305
    t06___9 = t04___11 & t03___11;
#line 305
    t07___10 = x1 & t01___11;
#line 305
    y2 = t05___8 ^ t06___9;
#line 305
    t09___11 = x0 ^ t03___11;
#line 305
    y0 = t07___10 ^ t03___11;
#line 305
    t11___6 = y0 | t05___8;
#line 305
    t12___8 = t09___11 & t11___6;
#line 305
    t13___9 = x0 & y2;
#line 305
    t14___6 = t01___11 ^ t05___8;
#line 305
    y1 = x1 ^ t12___8;
#line 305
    t16___7 = x1 | t13___9;
#line 305
    y3 = t14___6 ^ t16___7;
#line 306
    y0 ^= ctx->keys[19][0];
#line 306
    y1 ^= ctx->keys[19][1];
#line 306
    y2 ^= ctx->keys[19][2];
#line 306
    y3 ^= ctx->keys[19][3];
#line 307
    x2 = (y2 << 10) | (y2 >> 22);
#line 307
    x0 = (y0 << 27) | (y0 >> 5);
#line 307
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 307
    x0 = (x0 ^ y1) ^ y3;
#line 307
    x3 = (y3 << 25) | (y3 >> 7);
#line 307
    x1 = (y1 << 31) | (y1 >> 1);
#line 307
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 307
    x1 = (x1 ^ x0) ^ x2;
#line 307
    x2 = (x2 << 29) | (x2 >> 3);
#line 307
    x0 = (x0 << 19) | (x0 >> 13);
#line 308
    t01___12 = x0 ^ x3;
#line 308
    t02___12 = x2 ^ x3;
#line 308
    t03___12 = x0 & x2;
#line 308
    t04___12 = x1 | t02___12;
#line 308
    y0 = t01___12 ^ t04___12;
#line 308
    t06___10 = x0 | x2;
#line 308
    t07___11 = x3 | y0;
#line 308
    t08___8 = ~ x3;
#line 308
    t09___12 = x1 & t06___10;
#line 308
    t10___8 = t08___8 | t03___12;
#line 308
    t11___7 = x1 & t07___11;
#line 308
    t12___9 = t06___10 & t02___12;
#line 308
    y3 = t09___12 ^ t10___8;
#line 308
    y1 = t12___9 ^ t11___7;
#line 308
    t15___10 = x2 & y3;
#line 308
    t16___8 = y0 ^ y1;
#line 308
    t17___4 = t10___8 ^ t15___10;
#line 308
    y2 = t16___8 ^ t17___4;
#line 309
    y0 ^= ctx->keys[18][0];
#line 309
    y1 ^= ctx->keys[18][1];
#line 309
    y2 ^= ctx->keys[18][2];
#line 309
    y3 ^= ctx->keys[18][3];
#line 310
    x2 = (y2 << 10) | (y2 >> 22);
#line 310
    x0 = (y0 << 27) | (y0 >> 5);
#line 310
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 310
    x0 = (x0 ^ y1) ^ y3;
#line 310
    x3 = (y3 << 25) | (y3 >> 7);
#line 310
    x1 = (y1 << 31) | (y1 >> 1);
#line 310
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 310
    x1 = (x1 ^ x0) ^ x2;
#line 310
    x2 = (x2 << 29) | (x2 >> 3);
#line 310
    x0 = (x0 << 19) | (x0 >> 13);
#line 311
    t01___13 = x0 ^ x1;
#line 311
    t02___13 = x1 | x3;
#line 311
    t03___13 = x0 & x2;
#line 311
    t04___13 = x2 ^ t02___13;
#line 311
    t05___9 = x0 | t04___13;
#line 311
    t06___11 = t01___13 & t05___9;
#line 311
    t07___12 = x3 | t03___13;
#line 311
    t08___9 = x1 ^ t06___11;
#line 311
    t09___13 = t07___12 ^ t06___11;
#line 311
    t10___9 = t04___13 | t03___13;
#line 311
    t11___8 = x3 & t08___9;
#line 311
    y2 = ~ t09___13;
#line 311
    y1 = t10___9 ^ t11___8;
#line 311
    t14___7 = x0 | y2;
#line 311
    t15___11 = t06___11 ^ y1;
#line 311
    y3 = t01___13 ^ t04___13;
#line 311
    t17___5 = x2 ^ t15___11;
#line 311
    y0 = t14___7 ^ t17___5;
#line 312
    y0 ^= ctx->keys[17][0];
#line 312
    y1 ^= ctx->keys[17][1];
#line 312
    y2 ^= ctx->keys[17][2];
#line 312
    y3 ^= ctx->keys[17][3];
#line 313
    x2 = (y2 << 10) | (y2 >> 22);
#line 313
    x0 = (y0 << 27) | (y0 >> 5);
#line 313
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 313
    x0 = (x0 ^ y1) ^ y3;
#line 313
    x3 = (y3 << 25) | (y3 >> 7);
#line 313
    x1 = (y1 << 31) | (y1 >> 1);
#line 313
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 313
    x1 = (x1 ^ x0) ^ x2;
#line 313
    x2 = (x2 << 29) | (x2 >> 3);
#line 313
    x0 = (x0 << 19) | (x0 >> 13);
#line 314
    t01___14 = x2 ^ x3;
#line 314
    t02___14 = x0 | x1;
#line 314
    t03___14 = x1 | x2;
#line 314
    t04___14 = x2 & t01___14;
#line 314
    t05___10 = t02___14 ^ t01___14;
#line 314
    t06___12 = x0 | t04___14;
#line 314
    y2 = ~ t05___10;
#line 314
    t08___10 = x1 ^ x3;
#line 314
    t09___14 = t03___14 & t08___10;
#line 314
    t10___10 = x3 | y2;
#line 314
    y1 = t09___14 ^ t06___12;
#line 314
    t12___10 = x0 | t05___10;
#line 314
    t13___10 = y1 ^ t12___10;
#line 314
    t14___8 = t03___14 ^ t10___10;
#line 314
    t15___12 = x0 ^ x2;
#line 314
    y3 = t14___8 ^ t13___10;
#line 314
    t17___6 = t05___10 & t13___10;
#line 314
    t18___0 = t14___8 | t17___6;
#line 314
    y0 = t15___12 ^ t18___0;
#line 315
    y0 ^= ctx->keys[16][0];
#line 315
    y1 ^= ctx->keys[16][1];
#line 315
    y2 ^= ctx->keys[16][2];
#line 315
    y3 ^= ctx->keys[16][3];
#line 316
    x2 = (y2 << 10) | (y2 >> 22);
#line 316
    x0 = (y0 << 27) | (y0 >> 5);
#line 316
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 316
    x0 = (x0 ^ y1) ^ y3;
#line 316
    x3 = (y3 << 25) | (y3 >> 7);
#line 316
    x1 = (y1 << 31) | (y1 >> 1);
#line 316
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 316
    x1 = (x1 ^ x0) ^ x2;
#line 316
    x2 = (x2 << 29) | (x2 >> 3);
#line 316
    x0 = (x0 << 19) | (x0 >> 13);
#line 317
    t01___15 = x0 & x1;
#line 317
    t02___15 = x0 | x1;
#line 317
    t03___15 = x2 | t01___15;
#line 317
    t04___15 = x3 & t02___15;
#line 317
    y3 = t03___15 ^ t04___15;
#line 317
    t06___13 = x1 ^ t04___15;
#line 317
    t07___13 = x3 ^ y3;
#line 317
    t08___11 = ~ t07___13;
#line 317
    t09___15 = t06___13 | t08___11;
#line 317
    t10___11 = x1 ^ x3;
#line 317
    t11___9 = x0 | x3;
#line 317
    y1 = x0 ^ t09___15;
#line 317
    t13___11 = x2 ^ t06___13;
#line 317
    t14___9 = x2 & t11___9;
#line 317
    t15___13 = x3 | y1;
#line 317
    t16___9 = t01___15 | t10___11;
#line 317
    y0 = t13___11 ^ t15___13;
#line 317
    y2 = t14___9 ^ t16___9;
#line 318
    y0 ^= ctx->keys[15][0];
#line 318
    y1 ^= ctx->keys[15][1];
#line 318
    y2 ^= ctx->keys[15][2];
#line 318
    y3 ^= ctx->keys[15][3];
#line 319
    x2 = (y2 << 10) | (y2 >> 22);
#line 319
    x0 = (y0 << 27) | (y0 >> 5);
#line 319
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 319
    x0 = (x0 ^ y1) ^ y3;
#line 319
    x3 = (y3 << 25) | (y3 >> 7);
#line 319
    x1 = (y1 << 31) | (y1 >> 1);
#line 319
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 319
    x1 = (x1 ^ x0) ^ x2;
#line 319
    x2 = (x2 << 29) | (x2 >> 3);
#line 319
    x0 = (x0 << 19) | (x0 >> 13);
#line 320
    t01___16 = x0 ^ x2;
#line 320
    t02___16 = ~ x2;
#line 320
    t03___16 = x1 & t01___16;
#line 320
    t04___16 = x1 | t02___16;
#line 320
    t05___11 = x3 | t03___16;
#line 320
    t06___14 = x1 ^ x3;
#line 320
    t07___14 = x0 & t04___16;
#line 320
    t08___12 = x0 | t02___16;
#line 320
    t09___16 = t07___14 ^ t05___11;
#line 320
    y1 = t06___14 ^ t08___12;
#line 320
    y0 = ~ t09___16;
#line 320
    t12___11 = x1 & y0;
#line 320
    t13___12 = t01___16 & t05___11;
#line 320
    t14___10 = t01___16 ^ t12___11;
#line 320
    t15___14 = t07___14 ^ t13___12;
#line 320
    t16___10 = x3 | t02___16;
#line 320
    t17___7 = x0 ^ y1;
#line 320
    y3 = t17___7 ^ t15___14;
#line 320
    y2 = t16___10 ^ t14___10;
#line 321
    y0 ^= ctx->keys[14][0];
#line 321
    y1 ^= ctx->keys[14][1];
#line 321
    y2 ^= ctx->keys[14][2];
#line 321
    y3 ^= ctx->keys[14][3];
#line 322
    x2 = (y2 << 10) | (y2 >> 22);
#line 322
    x0 = (y0 << 27) | (y0 >> 5);
#line 322
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 322
    x0 = (x0 ^ y1) ^ y3;
#line 322
    x3 = (y3 << 25) | (y3 >> 7);
#line 322
    x1 = (y1 << 31) | (y1 >> 1);
#line 322
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 322
    x1 = (x1 ^ x0) ^ x2;
#line 322
    x2 = (x2 << 29) | (x2 >> 3);
#line 322
    x0 = (x0 << 19) | (x0 >> 13);
#line 323
    t01___17 = x0 & x3;
#line 323
    t02___17 = x2 ^ t01___17;
#line 323
    t03___17 = x0 ^ x3;
#line 323
    t04___17 = x1 & t02___17;
#line 323
    t05___12 = x0 & x2;
#line 323
    y0 = t03___17 ^ t04___17;
#line 323
    t07___15 = x0 & y0;
#line 323
    t08___13 = t01___17 ^ y0;
#line 323
    t09___17 = x1 | t05___12;
#line 323
    t10___12 = ~ x1;
#line 323
    y1 = t08___13 ^ t09___17;
#line 323
    t12___12 = t10___12 | t07___15;
#line 323
    t13___13 = y0 | y1;
#line 323
    y3 = t02___17 ^ t12___12;
#line 323
    t15___15 = t02___17 ^ t13___13;
#line 323
    t16___11 = x1 ^ x3;
#line 323
    y2 = t16___11 ^ t15___15;
#line 324
    y0 ^= ctx->keys[13][0];
#line 324
    y1 ^= ctx->keys[13][1];
#line 324
    y2 ^= ctx->keys[13][2];
#line 324
    y3 ^= ctx->keys[13][3];
#line 325
    x2 = (y2 << 10) | (y2 >> 22);
#line 325
    x0 = (y0 << 27) | (y0 >> 5);
#line 325
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 325
    x0 = (x0 ^ y1) ^ y3;
#line 325
    x3 = (y3 << 25) | (y3 >> 7);
#line 325
    x1 = (y1 << 31) | (y1 >> 1);
#line 325
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 325
    x1 = (x1 ^ x0) ^ x2;
#line 325
    x2 = (x2 << 29) | (x2 >> 3);
#line 325
    x0 = (x0 << 19) | (x0 >> 13);
#line 326
    t01___18 = x1 | x3;
#line 326
    t02___18 = x2 | x3;
#line 326
    t03___18 = x0 & t01___18;
#line 326
    t04___18 = x1 ^ t02___18;
#line 326
    t05___13 = x2 ^ x3;
#line 326
    t06___15 = ~ t03___18;
#line 326
    t07___16 = x0 & t04___18;
#line 326
    y1 = t05___13 ^ t07___16;
#line 326
    t09___18 = y1 | t06___15;
#line 326
    t10___13 = x0 ^ t07___16;
#line 326
    t11___10 = t01___18 ^ t09___18;
#line 326
    t12___13 = x3 ^ t04___18;
#line 326
    t13___14 = x2 | t10___13;
#line 326
    y3 = t03___18 ^ t12___13;
#line 326
    t15___16 = x0 ^ t04___18;
#line 326
    y2 = t11___10 ^ t13___14;
#line 326
    y0 = t15___16 ^ t09___18;
#line 327
    y0 ^= ctx->keys[12][0];
#line 327
    y1 ^= ctx->keys[12][1];
#line 327
    y2 ^= ctx->keys[12][2];
#line 327
    y3 ^= ctx->keys[12][3];
#line 328
    x2 = (y2 << 10) | (y2 >> 22);
#line 328
    x0 = (y0 << 27) | (y0 >> 5);
#line 328
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 328
    x0 = (x0 ^ y1) ^ y3;
#line 328
    x3 = (y3 << 25) | (y3 >> 7);
#line 328
    x1 = (y1 << 31) | (y1 >> 1);
#line 328
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 328
    x1 = (x1 ^ x0) ^ x2;
#line 328
    x2 = (x2 << 29) | (x2 >> 3);
#line 328
    x0 = (x0 << 19) | (x0 >> 13);
#line 329
    t01___19 = x2 | x3;
#line 329
    t02___19 = x0 | x3;
#line 329
    t03___19 = x2 ^ t02___19;
#line 329
    t04___19 = x1 ^ t02___19;
#line 329
    t05___14 = x0 ^ x3;
#line 329
    t06___16 = t04___19 & t03___19;
#line 329
    t07___17 = x1 & t01___19;
#line 329
    y2 = t05___14 ^ t06___16;
#line 329
    t09___19 = x0 ^ t03___19;
#line 329
    y0 = t07___17 ^ t03___19;
#line 329
    t11___11 = y0 | t05___14;
#line 329
    t12___14 = t09___19 & t11___11;
#line 329
    t13___15 = x0 & y2;
#line 329
    t14___11 = t01___19 ^ t05___14;
#line 329
    y1 = x1 ^ t12___14;
#line 329
    t16___12 = x1 | t13___15;
#line 329
    y3 = t14___11 ^ t16___12;
#line 330
    y0 ^= ctx->keys[11][0];
#line 330
    y1 ^= ctx->keys[11][1];
#line 330
    y2 ^= ctx->keys[11][2];
#line 330
    y3 ^= ctx->keys[11][3];
#line 331
    x2 = (y2 << 10) | (y2 >> 22);
#line 331
    x0 = (y0 << 27) | (y0 >> 5);
#line 331
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 331
    x0 = (x0 ^ y1) ^ y3;
#line 331
    x3 = (y3 << 25) | (y3 >> 7);
#line 331
    x1 = (y1 << 31) | (y1 >> 1);
#line 331
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 331
    x1 = (x1 ^ x0) ^ x2;
#line 331
    x2 = (x2 << 29) | (x2 >> 3);
#line 331
    x0 = (x0 << 19) | (x0 >> 13);
#line 332
    t01___20 = x0 ^ x3;
#line 332
    t02___20 = x2 ^ x3;
#line 332
    t03___20 = x0 & x2;
#line 332
    t04___20 = x1 | t02___20;
#line 332
    y0 = t01___20 ^ t04___20;
#line 332
    t06___17 = x0 | x2;
#line 332
    t07___18 = x3 | y0;
#line 332
    t08___14 = ~ x3;
#line 332
    t09___20 = x1 & t06___17;
#line 332
    t10___14 = t08___14 | t03___20;
#line 332
    t11___12 = x1 & t07___18;
#line 332
    t12___15 = t06___17 & t02___20;
#line 332
    y3 = t09___20 ^ t10___14;
#line 332
    y1 = t12___15 ^ t11___12;
#line 332
    t15___17 = x2 & y3;
#line 332
    t16___13 = y0 ^ y1;
#line 332
    t17___8 = t10___14 ^ t15___17;
#line 332
    y2 = t16___13 ^ t17___8;
#line 333
    y0 ^= ctx->keys[10][0];
#line 333
    y1 ^= ctx->keys[10][1];
#line 333
    y2 ^= ctx->keys[10][2];
#line 333
    y3 ^= ctx->keys[10][3];
#line 334
    x2 = (y2 << 10) | (y2 >> 22);
#line 334
    x0 = (y0 << 27) | (y0 >> 5);
#line 334
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 334
    x0 = (x0 ^ y1) ^ y3;
#line 334
    x3 = (y3 << 25) | (y3 >> 7);
#line 334
    x1 = (y1 << 31) | (y1 >> 1);
#line 334
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 334
    x1 = (x1 ^ x0) ^ x2;
#line 334
    x2 = (x2 << 29) | (x2 >> 3);
#line 334
    x0 = (x0 << 19) | (x0 >> 13);
#line 335
    t01___21 = x0 ^ x1;
#line 335
    t02___21 = x1 | x3;
#line 335
    t03___21 = x0 & x2;
#line 335
    t04___21 = x2 ^ t02___21;
#line 335
    t05___15 = x0 | t04___21;
#line 335
    t06___18 = t01___21 & t05___15;
#line 335
    t07___19 = x3 | t03___21;
#line 335
    t08___15 = x1 ^ t06___18;
#line 335
    t09___21 = t07___19 ^ t06___18;
#line 335
    t10___15 = t04___21 | t03___21;
#line 335
    t11___13 = x3 & t08___15;
#line 335
    y2 = ~ t09___21;
#line 335
    y1 = t10___15 ^ t11___13;
#line 335
    t14___12 = x0 | y2;
#line 335
    t15___18 = t06___18 ^ y1;
#line 335
    y3 = t01___21 ^ t04___21;
#line 335
    t17___9 = x2 ^ t15___18;
#line 335
    y0 = t14___12 ^ t17___9;
#line 336
    y0 ^= ctx->keys[9][0];
#line 336
    y1 ^= ctx->keys[9][1];
#line 336
    y2 ^= ctx->keys[9][2];
#line 336
    y3 ^= ctx->keys[9][3];
#line 337
    x2 = (y2 << 10) | (y2 >> 22);
#line 337
    x0 = (y0 << 27) | (y0 >> 5);
#line 337
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 337
    x0 = (x0 ^ y1) ^ y3;
#line 337
    x3 = (y3 << 25) | (y3 >> 7);
#line 337
    x1 = (y1 << 31) | (y1 >> 1);
#line 337
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 337
    x1 = (x1 ^ x0) ^ x2;
#line 337
    x2 = (x2 << 29) | (x2 >> 3);
#line 337
    x0 = (x0 << 19) | (x0 >> 13);
#line 338
    t01___22 = x2 ^ x3;
#line 338
    t02___22 = x0 | x1;
#line 338
    t03___22 = x1 | x2;
#line 338
    t04___22 = x2 & t01___22;
#line 338
    t05___16 = t02___22 ^ t01___22;
#line 338
    t06___19 = x0 | t04___22;
#line 338
    y2 = ~ t05___16;
#line 338
    t08___16 = x1 ^ x3;
#line 338
    t09___22 = t03___22 & t08___16;
#line 338
    t10___16 = x3 | y2;
#line 338
    y1 = t09___22 ^ t06___19;
#line 338
    t12___16 = x0 | t05___16;
#line 338
    t13___16 = y1 ^ t12___16;
#line 338
    t14___13 = t03___22 ^ t10___16;
#line 338
    t15___19 = x0 ^ x2;
#line 338
    y3 = t14___13 ^ t13___16;
#line 338
    t17___10 = t05___16 & t13___16;
#line 338
    t18___1 = t14___13 | t17___10;
#line 338
    y0 = t15___19 ^ t18___1;
#line 339
    y0 ^= ctx->keys[8][0];
#line 339
    y1 ^= ctx->keys[8][1];
#line 339
    y2 ^= ctx->keys[8][2];
#line 339
    y3 ^= ctx->keys[8][3];
#line 340
    x2 = (y2 << 10) | (y2 >> 22);
#line 340
    x0 = (y0 << 27) | (y0 >> 5);
#line 340
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 340
    x0 = (x0 ^ y1) ^ y3;
#line 340
    x3 = (y3 << 25) | (y3 >> 7);
#line 340
    x1 = (y1 << 31) | (y1 >> 1);
#line 340
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 340
    x1 = (x1 ^ x0) ^ x2;
#line 340
    x2 = (x2 << 29) | (x2 >> 3);
#line 340
    x0 = (x0 << 19) | (x0 >> 13);
#line 341
    t01___23 = x0 & x1;
#line 341
    t02___23 = x0 | x1;
#line 341
    t03___23 = x2 | t01___23;
#line 341
    t04___23 = x3 & t02___23;
#line 341
    y3 = t03___23 ^ t04___23;
#line 341
    t06___20 = x1 ^ t04___23;
#line 341
    t07___20 = x3 ^ y3;
#line 341
    t08___17 = ~ t07___20;
#line 341
    t09___23 = t06___20 | t08___17;
#line 341
    t10___17 = x1 ^ x3;
#line 341
    t11___14 = x0 | x3;
#line 341
    y1 = x0 ^ t09___23;
#line 341
    t13___17 = x2 ^ t06___20;
#line 341
    t14___14 = x2 & t11___14;
#line 341
    t15___20 = x3 | y1;
#line 341
    t16___14 = t01___23 | t10___17;
#line 341
    y0 = t13___17 ^ t15___20;
#line 341
    y2 = t14___14 ^ t16___14;
#line 342
    y0 ^= ctx->keys[7][0];
#line 342
    y1 ^= ctx->keys[7][1];
#line 342
    y2 ^= ctx->keys[7][2];
#line 342
    y3 ^= ctx->keys[7][3];
#line 343
    x2 = (y2 << 10) | (y2 >> 22);
#line 343
    x0 = (y0 << 27) | (y0 >> 5);
#line 343
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 343
    x0 = (x0 ^ y1) ^ y3;
#line 343
    x3 = (y3 << 25) | (y3 >> 7);
#line 343
    x1 = (y1 << 31) | (y1 >> 1);
#line 343
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 343
    x1 = (x1 ^ x0) ^ x2;
#line 343
    x2 = (x2 << 29) | (x2 >> 3);
#line 343
    x0 = (x0 << 19) | (x0 >> 13);
#line 344
    t01___24 = x0 ^ x2;
#line 344
    t02___24 = ~ x2;
#line 344
    t03___24 = x1 & t01___24;
#line 344
    t04___24 = x1 | t02___24;
#line 344
    t05___17 = x3 | t03___24;
#line 344
    t06___21 = x1 ^ x3;
#line 344
    t07___21 = x0 & t04___24;
#line 344
    t08___18 = x0 | t02___24;
#line 344
    t09___24 = t07___21 ^ t05___17;
#line 344
    y1 = t06___21 ^ t08___18;
#line 344
    y0 = ~ t09___24;
#line 344
    t12___17 = x1 & y0;
#line 344
    t13___18 = t01___24 & t05___17;
#line 344
    t14___15 = t01___24 ^ t12___17;
#line 344
    t15___21 = t07___21 ^ t13___18;
#line 344
    t16___15 = x3 | t02___24;
#line 344
    t17___11 = x0 ^ y1;
#line 344
    y3 = t17___11 ^ t15___21;
#line 344
    y2 = t16___15 ^ t14___15;
#line 345
    y0 ^= ctx->keys[6][0];
#line 345
    y1 ^= ctx->keys[6][1];
#line 345
    y2 ^= ctx->keys[6][2];
#line 345
    y3 ^= ctx->keys[6][3];
#line 346
    x2 = (y2 << 10) | (y2 >> 22);
#line 346
    x0 = (y0 << 27) | (y0 >> 5);
#line 346
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 346
    x0 = (x0 ^ y1) ^ y3;
#line 346
    x3 = (y3 << 25) | (y3 >> 7);
#line 346
    x1 = (y1 << 31) | (y1 >> 1);
#line 346
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 346
    x1 = (x1 ^ x0) ^ x2;
#line 346
    x2 = (x2 << 29) | (x2 >> 3);
#line 346
    x0 = (x0 << 19) | (x0 >> 13);
#line 347
    t01___25 = x0 & x3;
#line 347
    t02___25 = x2 ^ t01___25;
#line 347
    t03___25 = x0 ^ x3;
#line 347
    t04___25 = x1 & t02___25;
#line 347
    t05___18 = x0 & x2;
#line 347
    y0 = t03___25 ^ t04___25;
#line 347
    t07___22 = x0 & y0;
#line 347
    t08___19 = t01___25 ^ y0;
#line 347
    t09___25 = x1 | t05___18;
#line 347
    t10___18 = ~ x1;
#line 347
    y1 = t08___19 ^ t09___25;
#line 347
    t12___18 = t10___18 | t07___22;
#line 347
    t13___19 = y0 | y1;
#line 347
    y3 = t02___25 ^ t12___18;
#line 347
    t15___22 = t02___25 ^ t13___19;
#line 347
    t16___16 = x1 ^ x3;
#line 347
    y2 = t16___16 ^ t15___22;
#line 348
    y0 ^= ctx->keys[5][0];
#line 348
    y1 ^= ctx->keys[5][1];
#line 348
    y2 ^= ctx->keys[5][2];
#line 348
    y3 ^= ctx->keys[5][3];
#line 349
    x2 = (y2 << 10) | (y2 >> 22);
#line 349
    x0 = (y0 << 27) | (y0 >> 5);
#line 349
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 349
    x0 = (x0 ^ y1) ^ y3;
#line 349
    x3 = (y3 << 25) | (y3 >> 7);
#line 349
    x1 = (y1 << 31) | (y1 >> 1);
#line 349
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 349
    x1 = (x1 ^ x0) ^ x2;
#line 349
    x2 = (x2 << 29) | (x2 >> 3);
#line 349
    x0 = (x0 << 19) | (x0 >> 13);
#line 350
    t01___26 = x1 | x3;
#line 350
    t02___26 = x2 | x3;
#line 350
    t03___26 = x0 & t01___26;
#line 350
    t04___26 = x1 ^ t02___26;
#line 350
    t05___19 = x2 ^ x3;
#line 350
    t06___22 = ~ t03___26;
#line 350
    t07___23 = x0 & t04___26;
#line 350
    y1 = t05___19 ^ t07___23;
#line 350
    t09___26 = y1 | t06___22;
#line 350
    t10___19 = x0 ^ t07___23;
#line 350
    t11___15 = t01___26 ^ t09___26;
#line 350
    t12___19 = x3 ^ t04___26;
#line 350
    t13___20 = x2 | t10___19;
#line 350
    y3 = t03___26 ^ t12___19;
#line 350
    t15___23 = x0 ^ t04___26;
#line 350
    y2 = t11___15 ^ t13___20;
#line 350
    y0 = t15___23 ^ t09___26;
#line 351
    y0 ^= ctx->keys[4][0];
#line 351
    y1 ^= ctx->keys[4][1];
#line 351
    y2 ^= ctx->keys[4][2];
#line 351
    y3 ^= ctx->keys[4][3];
#line 352
    x2 = (y2 << 10) | (y2 >> 22);
#line 352
    x0 = (y0 << 27) | (y0 >> 5);
#line 352
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 352
    x0 = (x0 ^ y1) ^ y3;
#line 352
    x3 = (y3 << 25) | (y3 >> 7);
#line 352
    x1 = (y1 << 31) | (y1 >> 1);
#line 352
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 352
    x1 = (x1 ^ x0) ^ x2;
#line 352
    x2 = (x2 << 29) | (x2 >> 3);
#line 352
    x0 = (x0 << 19) | (x0 >> 13);
#line 353
    t01___27 = x2 | x3;
#line 353
    t02___27 = x0 | x3;
#line 353
    t03___27 = x2 ^ t02___27;
#line 353
    t04___27 = x1 ^ t02___27;
#line 353
    t05___20 = x0 ^ x3;
#line 353
    t06___23 = t04___27 & t03___27;
#line 353
    t07___24 = x1 & t01___27;
#line 353
    y2 = t05___20 ^ t06___23;
#line 353
    t09___27 = x0 ^ t03___27;
#line 353
    y0 = t07___24 ^ t03___27;
#line 353
    t11___16 = y0 | t05___20;
#line 353
    t12___20 = t09___27 & t11___16;
#line 353
    t13___21 = x0 & y2;
#line 353
    t14___16 = t01___27 ^ t05___20;
#line 353
    y1 = x1 ^ t12___20;
#line 353
    t16___17 = x1 | t13___21;
#line 353
    y3 = t14___16 ^ t16___17;
#line 354
    y0 ^= ctx->keys[3][0];
#line 354
    y1 ^= ctx->keys[3][1];
#line 354
    y2 ^= ctx->keys[3][2];
#line 354
    y3 ^= ctx->keys[3][3];
#line 355
    x2 = (y2 << 10) | (y2 >> 22);
#line 355
    x0 = (y0 << 27) | (y0 >> 5);
#line 355
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 355
    x0 = (x0 ^ y1) ^ y3;
#line 355
    x3 = (y3 << 25) | (y3 >> 7);
#line 355
    x1 = (y1 << 31) | (y1 >> 1);
#line 355
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 355
    x1 = (x1 ^ x0) ^ x2;
#line 355
    x2 = (x2 << 29) | (x2 >> 3);
#line 355
    x0 = (x0 << 19) | (x0 >> 13);
#line 356
    t01___28 = x0 ^ x3;
#line 356
    t02___28 = x2 ^ x3;
#line 356
    t03___28 = x0 & x2;
#line 356
    t04___28 = x1 | t02___28;
#line 356
    y0 = t01___28 ^ t04___28;
#line 356
    t06___24 = x0 | x2;
#line 356
    t07___25 = x3 | y0;
#line 356
    t08___20 = ~ x3;
#line 356
    t09___28 = x1 & t06___24;
#line 356
    t10___20 = t08___20 | t03___28;
#line 356
    t11___17 = x1 & t07___25;
#line 356
    t12___21 = t06___24 & t02___28;
#line 356
    y3 = t09___28 ^ t10___20;
#line 356
    y1 = t12___21 ^ t11___17;
#line 356
    t15___24 = x2 & y3;
#line 356
    t16___18 = y0 ^ y1;
#line 356
    t17___12 = t10___20 ^ t15___24;
#line 356
    y2 = t16___18 ^ t17___12;
#line 357
    y0 ^= ctx->keys[2][0];
#line 357
    y1 ^= ctx->keys[2][1];
#line 357
    y2 ^= ctx->keys[2][2];
#line 357
    y3 ^= ctx->keys[2][3];
#line 358
    x2 = (y2 << 10) | (y2 >> 22);
#line 358
    x0 = (y0 << 27) | (y0 >> 5);
#line 358
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 358
    x0 = (x0 ^ y1) ^ y3;
#line 358
    x3 = (y3 << 25) | (y3 >> 7);
#line 358
    x1 = (y1 << 31) | (y1 >> 1);
#line 358
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 358
    x1 = (x1 ^ x0) ^ x2;
#line 358
    x2 = (x2 << 29) | (x2 >> 3);
#line 358
    x0 = (x0 << 19) | (x0 >> 13);
#line 359
    t01___29 = x0 ^ x1;
#line 359
    t02___29 = x1 | x3;
#line 359
    t03___29 = x0 & x2;
#line 359
    t04___29 = x2 ^ t02___29;
#line 359
    t05___21 = x0 | t04___29;
#line 359
    t06___25 = t01___29 & t05___21;
#line 359
    t07___26 = x3 | t03___29;
#line 359
    t08___21 = x1 ^ t06___25;
#line 359
    t09___29 = t07___26 ^ t06___25;
#line 359
    t10___21 = t04___29 | t03___29;
#line 359
    t11___18 = x3 & t08___21;
#line 359
    y2 = ~ t09___29;
#line 359
    y1 = t10___21 ^ t11___18;
#line 359
    t14___17 = x0 | y2;
#line 359
    t15___25 = t06___25 ^ y1;
#line 359
    y3 = t01___29 ^ t04___29;
#line 359
    t17___13 = x2 ^ t15___25;
#line 359
    y0 = t14___17 ^ t17___13;
#line 360
    y0 ^= ctx->keys[1][0];
#line 360
    y1 ^= ctx->keys[1][1];
#line 360
    y2 ^= ctx->keys[1][2];
#line 360
    y3 ^= ctx->keys[1][3];
#line 361
    x2 = (y2 << 10) | (y2 >> 22);
#line 361
    x0 = (y0 << 27) | (y0 >> 5);
#line 361
    x2 = (x2 ^ y3) ^ (y1 << 7);
#line 361
    x0 = (x0 ^ y1) ^ y3;
#line 361
    x3 = (y3 << 25) | (y3 >> 7);
#line 361
    x1 = (y1 << 31) | (y1 >> 1);
#line 361
    x3 = (x3 ^ x2) ^ (x0 << 3);
#line 361
    x1 = (x1 ^ x0) ^ x2;
#line 361
    x2 = (x2 << 29) | (x2 >> 3);
#line 361
    x0 = (x0 << 19) | (x0 >> 13);
#line 362
    t01___30 = x2 ^ x3;
#line 362
    t02___30 = x0 | x1;
#line 362
    t03___30 = x1 | x2;
#line 362
    t04___30 = x2 & t01___30;
#line 362
    t05___22 = t02___30 ^ t01___30;
#line 362
    t06___26 = x0 | t04___30;
#line 362
    y2 = ~ t05___22;
#line 362
    t08___22 = x1 ^ x3;
#line 362
    t09___30 = t03___30 & t08___22;
#line 362
    t10___22 = x3 | y2;
#line 362
    y1 = t09___30 ^ t06___26;
#line 362
    t12___22 = x0 | t05___22;
#line 362
    t13___22 = y1 ^ t12___22;
#line 362
    t14___18 = t03___30 ^ t10___22;
#line 362
    t15___26 = x0 ^ x2;
#line 362
    y3 = t14___18 ^ t13___22;
#line 362
    t17___14 = t05___22 & t13___22;
#line 362
    t18___2 = t14___18 | t17___14;
#line 362
    y0 = t15___26 ^ t18___2;
#line 363
    x0 = y0;
#line 363
    x1 = y1;
#line 363
    x2 = y2;
#line 363
    x3 = y3;
#line 364
    x0 ^= ctx->keys[0][0];
#line 364
    x1 ^= ctx->keys[0][1];
#line 364
    x2 ^= ctx->keys[0][2];
#line 364
    x3 ^= ctx->keys[0][3];
    {
    {
#line 369
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 369
      *(dst + 0) = (uint8_t )((x3 >> 24) & 255U);
#line 369
      *(dst + 1) = (uint8_t )((x3 >> 16) & 255U);
#line 369
      *(dst + 2) = (uint8_t )((x3 >> 8) & 255U);
#line 369
      *(dst + 3) = (uint8_t )(x3 & 255U);
#line 369
      goto while_break___0;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: ;
    {
    {
#line 370
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 370
      *((dst + 4) + 0) = (uint8_t )((x2 >> 24) & 255U);
#line 370
      *((dst + 4) + 1) = (uint8_t )((x2 >> 16) & 255U);
#line 370
      *((dst + 4) + 2) = (uint8_t )((x2 >> 8) & 255U);
#line 370
      *((dst + 4) + 3) = (uint8_t )(x2 & 255U);
#line 370
      goto while_break___1;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: ;
    {
    {
#line 371
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 371
      *((dst + 8) + 0) = (uint8_t )((x1 >> 24) & 255U);
#line 371
      *((dst + 8) + 1) = (uint8_t )((x1 >> 16) & 255U);
#line 371
      *((dst + 8) + 2) = (uint8_t )((x1 >> 8) & 255U);
#line 371
      *((dst + 8) + 3) = (uint8_t )(x1 & 255U);
#line 371
      goto while_break___2;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
    {
    {
#line 372
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 372
      *((dst + 12) + 0) = (uint8_t )((x0 >> 24) & 255U);
#line 372
      *((dst + 12) + 1) = (uint8_t )((x0 >> 16) & 255U);
#line 372
      *((dst + 12) + 2) = (uint8_t )((x0 >> 8) & 255U);
#line 372
      *((dst + 12) + 3) = (uint8_t )(x0 & 255U);
#line 372
      goto while_break___3;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: 
#line 259
    length -= 16U;
#line 259
    dst += 16;
#line 259
    cipher += 16;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 374
  return;
}
}
#line 104 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_cipher  const  nettle_serpent128 ;
#line 105
struct nettle_cipher  const  nettle_serpent192 ;
#line 106
struct nettle_cipher  const  nettle_serpent256 ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent-meta.c"
struct nettle_cipher  const  nettle_serpent128  = 
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent-meta.c"
     {"serpent128", (unsigned int )sizeof(struct serpent_ctx ), 16U, 16U, (void (*)(void *ctx ,
                                                                                  unsigned int length ,
                                                                                  uint8_t const   *key ))(& nettle_serpent_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_serpent_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_serpent_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_serpent_decrypt)};
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent-meta.c"
struct nettle_cipher  const  nettle_serpent192  = 
#line 34
     {"serpent192", (unsigned int )sizeof(struct serpent_ctx ), 16U, 24U, (void (*)(void *ctx ,
                                                                                  unsigned int length ,
                                                                                  uint8_t const   *key ))(& nettle_serpent_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_serpent_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_serpent_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_serpent_decrypt)};
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/serpent-meta.c"
struct nettle_cipher  const  nettle_serpent256  = 
#line 37
     {"serpent256", (unsigned int )sizeof(struct serpent_ctx ), 16U, 32U, (void (*)(void *ctx ,
                                                                                  unsigned int length ,
                                                                                  uint8_t const   *key ))(& nettle_serpent_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_serpent_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_serpent_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_serpent_decrypt)};
#line 264 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
int nettle_rsa_keypair_to_sexp(struct nettle_buffer *buffer , char const   *algorithm_name ,
                               struct rsa_public_key  const  *pub , struct rsa_private_key  const  *priv ) ;
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa2sexp.c"
int nettle_rsa_keypair_to_sexp(struct nettle_buffer *buffer , char const   *algorithm_name ,
                               struct rsa_public_key  const  *pub , struct rsa_private_key  const  *priv ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 41
  if (! algorithm_name) {
#line 42
    algorithm_name = "rsa";
  }
#line 44
  if (priv) {
    {
    {
#line 45
    tmp = nettle_sexp_format(buffer, "(private-key(%0s(n%b)(e%b)(d%b)(p%b)(q%b)(a%b)(b%b)(c%b)))",
                             algorithm_name, pub->n, pub->e, priv->d, priv->p, priv->q,
                             priv->a, priv->b, priv->c);
    }
    }
#line 45
    return ((int )tmp);
  } else {
    {
    {
#line 52
    tmp___0 = nettle_sexp_format(buffer, "(public-key(%0s(n%b)(e%b)))", algorithm_name,
                                 pub->n, pub->e);
    }
    }
#line 52
    return ((int )tmp___0);
  }
}
}
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 311 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
int nettle_rsa_keypair_to_openpgp(struct nettle_buffer *buffer , struct rsa_public_key  const  *pub ,
                                  struct rsa_private_key  const  *priv , char const   *userid ) ;
#line 99 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp.h"
int nettle_pgp_put_public_rsa_key(struct nettle_buffer *buffer , struct rsa_public_key  const  *pub ,
                                  time_t timestamp ) ;
#line 104
int nettle_pgp_put_rsa_sha1_signature(struct nettle_buffer *buffer , struct rsa_private_key  const  *key ,
                                      uint8_t const   *keyid , unsigned int type ,
                                      struct sha1_ctx *hash___2 ) ;
#line 111
int nettle_pgp_put_userid(struct nettle_buffer *buffer , unsigned int length , uint8_t const   *name ) ;
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa2openpgp.c"
int nettle_rsa_keypair_to_openpgp(struct nettle_buffer *buffer , struct rsa_public_key  const  *pub ,
                                  struct rsa_private_key  const  *priv , char const   *userid ) 
{ 
  time_t now ;
  time_t tmp ;
  unsigned int key_start ;
  unsigned int userid_start ;
  struct sha1_ctx key_hash ;
  struct sha1_ctx signature_hash ;
  uint8_t fingerprint[20] ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;

  {
  {
  {
#line 66
  tmp = time((time_t *)((void *)0));
  }
#line 66
  now = tmp;
#line 76
  key_start = buffer->size;
  {
#line 78
  tmp___0 = nettle_pgp_put_public_rsa_key(buffer, pub, now);
  }
  }
#line 78
  if (! tmp___0) {
#line 79
    return (0);
  }
  {
#line 82
  userid_start = buffer->size;
  {
#line 83
  tmp___1 = strlen(userid);
  }
  {
#line 83
  tmp___2 = nettle_pgp_put_userid(buffer, tmp___1, (uint8_t const   *)userid);
  }
  }
#line 83
  if (! tmp___2) {
#line 84
    return (0);
  }
  {
  {
#line 87
  nettle_sha1_init(& key_hash);
  }
  {
#line 88
  nettle_sha1_update(& key_hash, userid_start - key_start, (uint8_t const   *)(buffer->contents + key_start));
  }
#line 92
  signature_hash = key_hash;
  {
#line 93
  nettle_sha1_digest(& key_hash, (unsigned int )sizeof(fingerprint), fingerprint);
  }
  {
#line 95
  nettle_sha1_update(& signature_hash, buffer->size - userid_start, (uint8_t const   *)(buffer->contents + userid_start));
  }
  {
#line 99
  tmp___3 = nettle_pgp_put_rsa_sha1_signature(buffer, priv, (uint8_t const   *)((fingerprint + 20) - 8),
                                              16U, & signature_hash);
  }
  }
#line 99
  return (tmp___3);
}
}
#line 747 "/usr/include/gmp-i386.h"
extern void __gmpz_clear(mpz_ptr  ) ;
#line 907
extern void __gmpz_init(mpz_ptr  ) ;
#line 135 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
void nettle_rsa_public_key_init(struct rsa_public_key *key ) ;
#line 139
void nettle_rsa_public_key_clear(struct rsa_public_key *key ) ;
#line 324
unsigned int _nettle_rsa_check_size(__mpz_struct *n ) ;
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.c"
void nettle_rsa_public_key_init(struct rsa_public_key *key ) 
{ 


  {
  {
  {
#line 39
  __gmpz_init(key->n);
  }
  {
#line 40
  __gmpz_init(key->e);
  }
#line 44
  key->size = 0U;
  }
#line 45
  return;
}
}
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.c"
void nettle_rsa_public_key_clear(struct rsa_public_key *key ) 
{ 


  {
  {
  {
#line 50
  __gmpz_clear(key->n);
  }
  {
#line 51
  __gmpz_clear(key->e);
  }
  }
#line 52
  return;
}
}
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.c"
unsigned int _nettle_rsa_check_size(__mpz_struct *n ) 
{ 
  unsigned int size ;
  size_t tmp ;

  {
  {
  {
#line 61
  tmp = __gmpz_sizeinbase((mpz_srcptr )n, 2);
  }
#line 61
  size = (tmp + 7U) / 8U;
  }
#line 63
  if (size < 46U) {
#line 64
    return (0U);
  }
#line 66
  return (size);
}
}
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.c"
int nettle_rsa_public_key_prepare(struct rsa_public_key *key ) 
{ 


  {
  {
  {
#line 79
  key->size = _nettle_rsa_check_size(key->n);
  }
  }
#line 81
  return (key->size > 0U);
}
}
#line 753 "/usr/include/gmp-i386.h"
extern int __gmpz_cmp(mpz_srcptr  , mpz_srcptr  )  __attribute__((__pure__)) ;
#line 1029
extern void __gmpz_powm(mpz_ptr  , mpz_srcptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 319 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
int _nettle_rsa_verify(struct rsa_public_key  const  *key , __mpz_struct * const  m ,
                       __mpz_struct * const  s ) ;
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-verify.c"
int _nettle_rsa_verify(struct rsa_public_key  const  *key , __mpz_struct * const  m ,
                       __mpz_struct * const  s ) 
{ 
  int res ;
  mpz_t m1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
#line 45
  if (s->_mp_size < 0) {
#line 45
    tmp = -1;
  } else {
#line 45
    tmp = s->_mp_size > 0;
  }
#line 45
  if (tmp <= 0) {
#line 47
    return (0);
  } else {
    {
    {
#line 45
    tmp___0 = __gmpz_cmp((mpz_srcptr )s, (mpz_srcptr )(key->n));
    }
    }
#line 45
    if (tmp___0 >= 0) {
#line 47
      return (0);
    }
  }
  {
  {
#line 49
  __gmpz_init(m1);
  }
  {
#line 51
  __gmpz_powm(m1, (mpz_srcptr )s, (mpz_srcptr )(key->e), (mpz_srcptr )(key->n));
  }
  {
#line 54
  tmp___1 = __gmpz_cmp((mpz_srcptr )m, (mpz_srcptr )(m1));
  }
  }
#line 54
  if (tmp___1) {
#line 54
    tmp___2 = 0;
  } else {
#line 54
    tmp___2 = 1;
  }
  {
#line 54
  res = tmp___2;
  {
#line 56
  __gmpz_clear(m1);
  }
  }
#line 58
  return (res);
}
}
#line 696 "/usr/include/gmp-i386.h"
extern void __gmpz_add(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 828
extern void __gmpz_fdiv_r(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 983
extern void __gmpz_mul(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 1105
extern void __gmpz_sub(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 146 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
void nettle_rsa_private_key_init(struct rsa_private_key *key ) ;
#line 150
void nettle_rsa_private_key_clear(struct rsa_private_key *key ) ;
#line 225
void nettle_rsa_compute_root(struct rsa_private_key  const  *key , __mpz_struct *x ,
                             __mpz_struct * const  m ) ;
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-sign.c"
void nettle_rsa_private_key_init(struct rsa_private_key *key ) 
{ 


  {
  {
  {
#line 39
  __gmpz_init(key->d);
  }
  {
#line 40
  __gmpz_init(key->p);
  }
  {
#line 41
  __gmpz_init(key->q);
  }
  {
#line 42
  __gmpz_init(key->a);
  }
  {
#line 43
  __gmpz_init(key->b);
  }
  {
#line 44
  __gmpz_init(key->c);
  }
#line 48
  key->size = 0U;
  }
#line 49
  return;
}
}
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-sign.c"
void nettle_rsa_private_key_clear(struct rsa_private_key *key ) 
{ 


  {
  {
  {
#line 54
  __gmpz_clear(key->d);
  }
  {
#line 55
  __gmpz_clear(key->p);
  }
  {
#line 56
  __gmpz_clear(key->q);
  }
  {
#line 57
  __gmpz_clear(key->a);
  }
  {
#line 58
  __gmpz_clear(key->b);
  }
  {
#line 59
  __gmpz_clear(key->c);
  }
  }
#line 60
  return;
}
}
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-sign.c"
int nettle_rsa_private_key_prepare(struct rsa_private_key *key ) 
{ 
  mpz_t n ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
  {
#line 73
  __gmpz_init(n);
  }
  {
#line 74
  __gmpz_mul(n, (mpz_srcptr )(key->p), (mpz_srcptr )(key->q));
  }
  {
#line 76
  key->size = _nettle_rsa_check_size(n);
  }
  {
#line 78
  __gmpz_clear(n);
  }
  }
#line 80
  return (key->size > 0U);
}
}
#line 84 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-sign.c"
void nettle_rsa_compute_root(struct rsa_private_key  const  *key , __mpz_struct *x ,
                             __mpz_struct * const  m ) 
{ 
  mpz_t xp ;
  mpz_t xq ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  {
  {
#line 91
  __gmpz_init(xp);
  }
  {
#line 91
  __gmpz_init(xq);
  }
  {
#line 94
  __gmpz_fdiv_r(xq, (mpz_srcptr )m, (mpz_srcptr )(key->q));
  }
  {
#line 95
  __gmpz_powm(xq, (mpz_srcptr )(xq), (mpz_srcptr )(key->b), (mpz_srcptr )(key->q));
  }
  {
#line 98
  __gmpz_fdiv_r(xp, (mpz_srcptr )m, (mpz_srcptr )(key->p));
  }
  {
#line 99
  __gmpz_powm(xp, (mpz_srcptr )(xp), (mpz_srcptr )(key->a), (mpz_srcptr )(key->p));
  }
  {
#line 102
  __gmpz_sub(xp, (mpz_srcptr )(xp), (mpz_srcptr )(xq));
  }
  {
#line 103
  __gmpz_mul(xp, (mpz_srcptr )(xp), (mpz_srcptr )(key->c));
  }
  {
#line 104
  __gmpz_fdiv_r(xp, (mpz_srcptr )(xp), (mpz_srcptr )(key->p));
  }
  {
#line 136
  __gmpz_mul(x, (mpz_srcptr )(key->q), (mpz_srcptr )(xp));
  }
  {
#line 137
  __gmpz_add(x, (mpz_srcptr )x, (mpz_srcptr )(xq));
  }
  {
#line 139
  __gmpz_clear(xp);
  }
  {
#line 139
  __gmpz_clear(xq);
  }
  }
#line 140
  return;
}
}
#line 174 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
int nettle_rsa_sha1_verify(struct rsa_public_key  const  *key , struct sha1_ctx *hash___2 ,
                           __mpz_struct * const  s ) ;
#line 195
int nettle_rsa_sha1_verify_digest(struct rsa_public_key  const  *key , uint8_t const   *digest ,
                                  __mpz_struct * const  s ) ;
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1.h"
void nettle_pkcs1_rsa_sha1_encode(__mpz_struct *m , unsigned int length , struct sha1_ctx *hash___2 ) ;
#line 57
void nettle_pkcs1_rsa_sha1_encode_digest(__mpz_struct *m , unsigned int length , uint8_t const   *digest ) ;
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-sha1-verify.c"
int nettle_rsa_sha1_verify(struct rsa_public_key  const  *key , struct sha1_ctx *hash___2 ,
                           __mpz_struct * const  s ) 
{ 
  int res ;
  mpz_t m ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 47
  if (! (key->size >= 46U)) {
    {
    {
#line 47
    __assert_fail("key->size >= 46", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-sha1-verify.c",
                  47U, "nettle_rsa_sha1_verify");
    }
    }
  }
  {
  {
#line 48
  __gmpz_init(m);
  }
  {
#line 50
  nettle_pkcs1_rsa_sha1_encode(m, (unsigned int )(key->size - 1U), hash___2);
  }
  {
#line 51
  res = _nettle_rsa_verify(key, (__mpz_struct */* const  */)(m), s);
  }
  {
#line 53
  __gmpz_clear(m);
  }
  }
#line 55
  return (res);
}
}
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-sha1-verify.c"
int nettle_rsa_sha1_verify_digest(struct rsa_public_key  const  *key , uint8_t const   *digest ,
                                  __mpz_struct * const  s ) 
{ 
  int res ;
  mpz_t m ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 66
  if (! (key->size >= 46U)) {
    {
    {
#line 66
    __assert_fail("key->size >= 46", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-sha1-verify.c",
                  66U, "nettle_rsa_sha1_verify_digest");
    }
    }
  }
  {
  {
#line 67
  __gmpz_init(m);
  }
  {
#line 69
  nettle_pkcs1_rsa_sha1_encode_digest(m, (unsigned int )(key->size - 1U), digest);
  }
  {
#line 70
  res = _nettle_rsa_verify(key, (__mpz_struct */* const  */)(m), s);
  }
  {
#line 72
  __gmpz_clear(m);
  }
  }
#line 74
  return (res);
}
}
#line 169 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
void nettle_rsa_sha1_sign(struct rsa_private_key  const  *key , struct sha1_ctx *hash___2 ,
                          __mpz_struct *s ) ;
#line 190
void nettle_rsa_sha1_sign_digest(struct rsa_private_key  const  *key , uint8_t const   *digest ,
                                 __mpz_struct *s ) ;
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-sha1-sign.c"
void nettle_rsa_sha1_sign(struct rsa_private_key  const  *key , struct sha1_ctx *hash___2 ,
                          __mpz_struct *s ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 44
  if (! (key->size >= 46U)) {
    {
    {
#line 44
    __assert_fail("key->size >= 46", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-sha1-sign.c",
                  44U, "nettle_rsa_sha1_sign");
    }
    }
  }
  {
  {
#line 46
  nettle_pkcs1_rsa_sha1_encode(s, (unsigned int )(key->size - 1U), hash___2);
  }
  {
#line 48
  nettle_rsa_compute_root(key, s, (__mpz_struct */* const  */)s);
  }
  }
#line 49
  return;
}
}
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-sha1-sign.c"
void nettle_rsa_sha1_sign_digest(struct rsa_private_key  const  *key , uint8_t const   *digest ,
                                 __mpz_struct *s ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 56
  if (! (key->size >= 46U)) {
    {
    {
#line 56
    __assert_fail("key->size >= 46", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-sha1-sign.c",
                  56U, "nettle_rsa_sha1_sign_digest");
    }
    }
  }
  {
  {
#line 58
  nettle_pkcs1_rsa_sha1_encode_digest(s, (unsigned int )(key->size - 1U), digest);
  }
  {
#line 60
  nettle_rsa_compute_root(key, s, (__mpz_struct */* const  */)s);
  }
  }
#line 61
  return;
}
}
#line 164 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
int nettle_rsa_md5_verify(struct rsa_public_key  const  *key , struct md5_ctx *hash___2 ,
                          __mpz_struct * const  s ) ;
#line 185
int nettle_rsa_md5_verify_digest(struct rsa_public_key  const  *key , uint8_t const   *digest ,
                                 __mpz_struct * const  s ) ;
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1.h"
void nettle_pkcs1_rsa_md5_encode(__mpz_struct *m , unsigned int length , struct md5_ctx *hash___2 ) ;
#line 51
void nettle_pkcs1_rsa_md5_encode_digest(__mpz_struct *m , unsigned int length , uint8_t const   *digest ) ;
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-md5-verify.c"
int nettle_rsa_md5_verify(struct rsa_public_key  const  *key , struct md5_ctx *hash___2 ,
                          __mpz_struct * const  s ) 
{ 
  int res ;
  mpz_t m ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 47
  if (! (key->size >= 46U)) {
    {
    {
#line 47
    __assert_fail("key->size >= 46", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-md5-verify.c",
                  47U, "nettle_rsa_md5_verify");
    }
    }
  }
  {
  {
#line 48
  __gmpz_init(m);
  }
  {
#line 50
  nettle_pkcs1_rsa_md5_encode(m, (unsigned int )(key->size - 1U), hash___2);
  }
  {
#line 51
  res = _nettle_rsa_verify(key, (__mpz_struct */* const  */)(m), s);
  }
  {
#line 53
  __gmpz_clear(m);
  }
  }
#line 55
  return (res);
}
}
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-md5-verify.c"
int nettle_rsa_md5_verify_digest(struct rsa_public_key  const  *key , uint8_t const   *digest ,
                                 __mpz_struct * const  s ) 
{ 
  int res ;
  mpz_t m ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 66
  if (! (key->size >= 46U)) {
    {
    {
#line 66
    __assert_fail("key->size >= 46", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-md5-verify.c",
                  66U, "nettle_rsa_md5_verify_digest");
    }
    }
  }
  {
  {
#line 68
  __gmpz_init(m);
  }
  {
#line 70
  nettle_pkcs1_rsa_md5_encode_digest(m, (unsigned int )(key->size - 1U), digest);
  }
  {
#line 71
  res = _nettle_rsa_verify(key, (__mpz_struct */* const  */)(m), s);
  }
  {
#line 73
  __gmpz_clear(m);
  }
  }
#line 75
  return (res);
}
}
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
void nettle_rsa_md5_sign(struct rsa_private_key  const  *key , struct md5_ctx *hash___2 ,
                         __mpz_struct *s ) ;
#line 180
void nettle_rsa_md5_sign_digest(struct rsa_private_key  const  *key , uint8_t const   *digest ,
                                __mpz_struct *s ) ;
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-md5-sign.c"
void nettle_rsa_md5_sign(struct rsa_private_key  const  *key , struct md5_ctx *hash___2 ,
                         __mpz_struct *s ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 44
  if (! (key->size >= 46U)) {
    {
    {
#line 44
    __assert_fail("key->size >= 46", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-md5-sign.c",
                  44U, "nettle_rsa_md5_sign");
    }
    }
  }
  {
  {
#line 46
  nettle_pkcs1_rsa_md5_encode(s, (unsigned int )(key->size - 1U), hash___2);
  }
  {
#line 48
  nettle_rsa_compute_root(key, s, (__mpz_struct */* const  */)s);
  }
  }
#line 49
  return;
}
}
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-md5-sign.c"
void nettle_rsa_md5_sign_digest(struct rsa_private_key  const  *key , uint8_t const   *digest ,
                                __mpz_struct *s ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 56
  if (! (key->size >= 46U)) {
    {
    {
#line 56
    __assert_fail("key->size >= 46", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-md5-sign.c",
                  56U, "nettle_rsa_md5_sign_digest");
    }
    }
  }
  {
  {
#line 58
  nettle_pkcs1_rsa_md5_encode_digest(s, (unsigned int )(key->size - 1U), digest);
  }
  {
#line 60
  nettle_rsa_compute_root(key, s, (__mpz_struct */* const  */)s);
  }
  }
#line 61
  return;
}
}
#line 699 "/usr/include/gmp-i386.h"
extern void __gmpz_add_ui(mpz_ptr  , mpz_srcptr  , unsigned long  ) ;
#line 762
extern int __gmpz_cmp_ui(mpz_srcptr  , unsigned long  )  __attribute__((__pure__)) ;
#line 837
extern unsigned long __gmpz_fdiv_ui(mpz_srcptr  , unsigned long  )  __attribute__((__pure__)) ;
#line 870
extern void __gmpz_gcd(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 938
extern int __gmpz_invert(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 1035
extern int __gmpz_probab_prime_p(mpz_srcptr  , int  )  __attribute__((__pure__)) ;
#line 1085
extern void __gmpz_set_ui(mpz_ptr  , unsigned long  ) ;
#line 1088
extern void __gmpz_setbit(mpz_ptr  , unsigned long  ) ;
#line 1108
extern void __gmpz_sub_ui(mpz_ptr  , mpz_srcptr  , unsigned long  ) ;
#line 1150
extern int __gmpz_tstbit(mpz_srcptr  , unsigned long  )  __attribute__((__pure__)) ;
#line 233 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
int nettle_rsa_generate_keypair(struct rsa_public_key *pub , struct rsa_private_key *key ,
                                void *random_ctx , void (*random___0)(void *ctx ,
                                                                      unsigned int length ,
                                                                      uint8_t *dst ) ,
                                void *progress_ctx , void (*progress)(void *ctx ,
                                                                      int c ) , unsigned int n_size ,
                                unsigned int e_size ) ;
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.h"
void nettle_mpz_random_size(__mpz_struct *x , void *ctx , void (*random___0)(void *ctx ,
                                                                             unsigned int length ,
                                                                             uint8_t *dst ) ,
                            unsigned int bits ) ;
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-keygen.c"
static unsigned long const   primes[167]  = 
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-keygen.c"
  {      (unsigned long const   )3,      (unsigned long const   )5,      (unsigned long const   )7,      (unsigned long const   )11, 
        (unsigned long const   )13,      (unsigned long const   )17,      (unsigned long const   )19,      (unsigned long const   )23, 
        (unsigned long const   )29,      (unsigned long const   )31,      (unsigned long const   )37,      (unsigned long const   )41, 
        (unsigned long const   )43,      (unsigned long const   )47,      (unsigned long const   )53,      (unsigned long const   )59, 
        (unsigned long const   )61,      (unsigned long const   )67,      (unsigned long const   )71,      (unsigned long const   )73, 
        (unsigned long const   )79,      (unsigned long const   )83,      (unsigned long const   )89,      (unsigned long const   )97, 
        (unsigned long const   )101,      (unsigned long const   )103,      (unsigned long const   )107,      (unsigned long const   )109, 
        (unsigned long const   )113,      (unsigned long const   )127,      (unsigned long const   )131,      (unsigned long const   )137, 
        (unsigned long const   )139,      (unsigned long const   )149,      (unsigned long const   )151,      (unsigned long const   )157, 
        (unsigned long const   )163,      (unsigned long const   )167,      (unsigned long const   )173,      (unsigned long const   )179, 
        (unsigned long const   )181,      (unsigned long const   )191,      (unsigned long const   )193,      (unsigned long const   )197, 
        (unsigned long const   )199,      (unsigned long const   )211,      (unsigned long const   )223,      (unsigned long const   )227, 
        (unsigned long const   )229,      (unsigned long const   )233,      (unsigned long const   )239,      (unsigned long const   )241, 
        (unsigned long const   )251,      (unsigned long const   )257,      (unsigned long const   )263,      (unsigned long const   )269, 
        (unsigned long const   )271,      (unsigned long const   )277,      (unsigned long const   )281,      (unsigned long const   )283, 
        (unsigned long const   )293,      (unsigned long const   )307,      (unsigned long const   )311,      (unsigned long const   )313, 
        (unsigned long const   )317,      (unsigned long const   )331,      (unsigned long const   )337,      (unsigned long const   )347, 
        (unsigned long const   )349,      (unsigned long const   )353,      (unsigned long const   )359,      (unsigned long const   )367, 
        (unsigned long const   )373,      (unsigned long const   )379,      (unsigned long const   )383,      (unsigned long const   )389, 
        (unsigned long const   )397,      (unsigned long const   )401,      (unsigned long const   )409,      (unsigned long const   )419, 
        (unsigned long const   )421,      (unsigned long const   )431,      (unsigned long const   )433,      (unsigned long const   )439, 
        (unsigned long const   )443,      (unsigned long const   )449,      (unsigned long const   )457,      (unsigned long const   )461, 
        (unsigned long const   )463,      (unsigned long const   )467,      (unsigned long const   )479,      (unsigned long const   )487, 
        (unsigned long const   )491,      (unsigned long const   )499,      (unsigned long const   )503,      (unsigned long const   )509, 
        (unsigned long const   )521,      (unsigned long const   )523,      (unsigned long const   )541,      (unsigned long const   )547, 
        (unsigned long const   )557,      (unsigned long const   )563,      (unsigned long const   )569,      (unsigned long const   )571, 
        (unsigned long const   )577,      (unsigned long const   )587,      (unsigned long const   )593,      (unsigned long const   )599, 
        (unsigned long const   )601,      (unsigned long const   )607,      (unsigned long const   )613,      (unsigned long const   )617, 
        (unsigned long const   )619,      (unsigned long const   )631,      (unsigned long const   )641,      (unsigned long const   )643, 
        (unsigned long const   )647,      (unsigned long const   )653,      (unsigned long const   )659,      (unsigned long const   )661, 
        (unsigned long const   )673,      (unsigned long const   )677,      (unsigned long const   )683,      (unsigned long const   )691, 
        (unsigned long const   )701,      (unsigned long const   )709,      (unsigned long const   )719,      (unsigned long const   )727, 
        (unsigned long const   )733,      (unsigned long const   )739,      (unsigned long const   )743,      (unsigned long const   )751, 
        (unsigned long const   )757,      (unsigned long const   )761,      (unsigned long const   )769,      (unsigned long const   )773, 
        (unsigned long const   )787,      (unsigned long const   )797,      (unsigned long const   )809,      (unsigned long const   )811, 
        (unsigned long const   )821,      (unsigned long const   )823,      (unsigned long const   )827,      (unsigned long const   )829, 
        (unsigned long const   )839,      (unsigned long const   )853,      (unsigned long const   )857,      (unsigned long const   )859, 
        (unsigned long const   )863,      (unsigned long const   )877,      (unsigned long const   )881,      (unsigned long const   )883, 
        (unsigned long const   )887,      (unsigned long const   )907,      (unsigned long const   )911,      (unsigned long const   )919, 
        (unsigned long const   )929,      (unsigned long const   )937,      (unsigned long const   )941,      (unsigned long const   )947, 
        (unsigned long const   )953,      (unsigned long const   )967,      (unsigned long const   )971,      (unsigned long const   )977, 
        (unsigned long const   )983,      (unsigned long const   )991,      (unsigned long const   )997};
#line 68 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-keygen.c"
static void bignum_next_prime(__mpz_struct *p , __mpz_struct *n , int count , void *progress_ctx ,
                              void (*progress)(void *ctx , int c ) ) 
{ 
  mpz_t tmp ;
  unsigned long *moduli ;
  unsigned long difference ;
  unsigned int prime_limit ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___5 ;
  void *tmp___6 ;
  unsigned int i ;
  int composite ;
  unsigned int i___0 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
  {
#line 76
  prime_limit = 167U;
  {
#line 79
  tmp___1 = __gmpz_cmp_ui((mpz_srcptr )n, 2UL);
  }
  }
#line 79
  if (tmp___1 <= 0) {
    {
    {
#line 81
    __gmpz_set_ui(p, 2UL);
    }
    }
#line 82
    return;
  }
  {
  {
#line 84
  __gmpz_set(p, (mpz_srcptr )n);
  }
  {
#line 85
  __gmpz_setbit(p, 0UL);
  }
  {
#line 87
  tmp___3 = __gmpz_cmp_ui((mpz_srcptr )p, 8UL);
  }
  }
#line 87
  if (tmp___3 < 0) {
#line 88
    return;
  }
  {
  {
#line 90
  __gmpz_init(tmp);
  }
  {
#line 92
  tmp___5 = __gmpz_cmp_ui((mpz_srcptr )p, (unsigned long )primes[prime_limit - 1U]);
  }
  }
#line 92
  if (tmp___5 <= 0) {
#line 94
    prime_limit = 3U;
  }
  {
  {
#line 97
  tmp___6 = __builtin_alloca(sizeof(*moduli) * (unsigned long )prime_limit);
  }
#line 97
  moduli = (unsigned long *)tmp___6;
#line 100
  i = 0U;
  }
  {
  {
#line 100
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 100
    if (! (i < prime_limit)) {
#line 100
      goto while_break;
    }
    {
    {
#line 101
    *(moduli + i) = __gmpz_fdiv_ui((mpz_srcptr )p, (unsigned long )primes[i]);
    }
#line 100
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 104
  difference = 0UL;
  {
  {
#line 104
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 106
    composite = 0;
#line 109
    if (difference >= 4294967285UL) {
      {
      {
#line 111
      __gmpz_add_ui(p, (mpz_srcptr )p, difference);
      }
#line 112
      difference = 0UL;
      }
    }
#line 116
    i___0 = 0U;
    {
    {
#line 116
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;

#line 116
      if (! (i___0 < prime_limit)) {
#line 116
        goto while_break___1;
      }
#line 118
      if (*(moduli + i___0) == 0UL) {
#line 119
        composite = 1;
      }
#line 120
      *(moduli + i___0) = (*(moduli + i___0) + 2UL) % (unsigned long )primes[i___0];
#line 116
      i___0 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
#line 122
    if (composite) {
#line 123
      goto __Cont;
    }
    {
    {
#line 125
    __gmpz_add_ui(p, (mpz_srcptr )p, difference);
    }
#line 126
    difference = 0UL;
    }
#line 128
    if (progress) {
      {
      {
#line 129
      (*progress)(progress_ctx, '.');
      }
      }
    }
    {
    {
#line 132
    __gmpz_set_ui(tmp, 2UL);
    }
    {
#line 133
    __gmpz_powm(tmp, (mpz_srcptr )(tmp), (mpz_srcptr )p, (mpz_srcptr )p);
    }
    {
#line 134
    tmp___8 = __gmpz_cmp_ui((mpz_srcptr )(tmp), 2UL);
    }
    }
#line 134
    if (tmp___8 != 0) {
#line 135
      goto __Cont;
    }
#line 137
    if (progress) {
      {
      {
#line 138
      (*progress)(progress_ctx, '+');
      }
      }
    }
    {
    {
#line 141
    tmp___9 = __gmpz_probab_prime_p((mpz_srcptr )p, count);
    }
    }
#line 141
    if (tmp___9) {
#line 142
      goto while_break___0;
    }
    __Cont: 
#line 104
    difference += 2UL;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
  {
#line 144
  __gmpz_clear(tmp);
  }
  }
#line 145
  return;
}
}
#line 148 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-keygen.c"
static void bignum_random_prime(__mpz_struct *x , unsigned int bits , void *random_ctx ,
                                void (*random___0)(void *ctx , unsigned int length ,
                                                   uint8_t *dst ) , void *progress_ctx ,
                                void (*progress)(void *ctx , int c ) ) 
{ 
  size_t tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 153
  if (! bits) {
    {
    {
#line 153
    __assert_fail("bits", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-keygen.c",
                  153U, "bignum_random_prime");
    }
    }
  }
  {
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 157
    nettle_mpz_random_size(x, random_ctx, random___0, bits);
    }
    {
#line 158
    __gmpz_setbit(x, (unsigned long )(bits - 1U));
    }
    {
#line 161
    bignum_next_prime(x, x, 25, progress_ctx, progress);
    }
    {
#line 163
    tmp = __gmpz_sizeinbase((mpz_srcptr )x, 2);
    }
    }
#line 163
    if (tmp == bits) {
#line 164
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 166
  return;
}
}
#line 168 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-keygen.c"
int nettle_rsa_generate_keypair(struct rsa_public_key *pub , struct rsa_private_key *key ,
                                void *random_ctx , void (*random___0)(void *ctx ,
                                                                      unsigned int length ,
                                                                      uint8_t *dst ) ,
                                void *progress_ctx , void (*progress)(void *ctx ,
                                                                      int c ) , unsigned int n_size ,
                                unsigned int e_size ) 
{ 
  mpz_t p1 ;
  mpz_t q1___0 ;
  mpz_t phi ;
  mpz_t tmp ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int retried ;
  int tmp___9 ;
  int res ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  size_t tmp___12 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
#line 181
  if (e_size) {
#line 184
    if (e_size < 16U) {
#line 185
      return (0);
    } else
#line 184
    if (e_size > n_size) {
#line 185
      return (0);
    }
  } else {
    {
    {
#line 192
    tmp___0 = __gmpz_tstbit((mpz_srcptr )(pub->e), 0UL);
    }
    }
#line 192
    if (! tmp___0) {
#line 193
      return (0);
    }
    {
    {
#line 196
    tmp___2 = __gmpz_cmp_ui((mpz_srcptr )(pub->e), 3UL);
    }
    }
#line 196
    if (tmp___2 < 0) {
#line 197
      return (0);
    }
  }
#line 200
  if (n_size < 361U) {
#line 201
    return (0);
  }
  {
  {
#line 203
  __gmpz_init(p1);
  }
  {
#line 203
  __gmpz_init(q1___0);
  }
  {
#line 203
  __gmpz_init(phi);
  }
  {
#line 203
  __gmpz_init(tmp);
  }
  }
  {
  {
#line 206
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

    {
    {
#line 209
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 211
      bignum_random_prime(key->p, (n_size + 1U) / 2U, random_ctx, random___0, progress_ctx,
                          progress);
      }
      {
#line 214
      __gmpz_sub_ui(p1, (mpz_srcptr )(key->p), 1UL);
      }
      }
#line 218
      if (e_size) {
#line 219
        goto while_break___0;
      }
      {
      {
#line 221
      __gmpz_gcd(tmp, (mpz_srcptr )(pub->e), (mpz_srcptr )(p1));
      }
      {
#line 223
      tmp___4 = __gmpz_cmp_ui((mpz_srcptr )(tmp), 1UL);
      }
      }
#line 223
      if (tmp___4 == 0) {
#line 224
        goto while_break___0;
      } else
#line 225
      if (progress) {
        {
        {
#line 225
        (*progress)(progress_ctx, 'c');
        }
        }
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: ;
#line 228
    if (progress) {
      {
      {
#line 229
      (*progress)(progress_ctx, '\n');
      }
      }
    }
    {
    {
#line 232
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 234
      bignum_random_prime(key->q, n_size / 2U, random_ctx, random___0, progress_ctx,
                          progress);
      }
      {
#line 237
      __gmpz_sub_ui(q1___0, (mpz_srcptr )(key->q), 1UL);
      }
      }
#line 241
      if (e_size) {
#line 242
        goto while_break___1;
      }
      {
      {
#line 244
      __gmpz_gcd(tmp, (mpz_srcptr )(pub->e), (mpz_srcptr )(q1___0));
      }
      {
#line 246
      tmp___6 = __gmpz_cmp_ui((mpz_srcptr )(tmp), 1UL);
      }
      }
#line 246
      if (tmp___6 == 0) {
#line 247
        goto while_break___1;
      } else
#line 248
      if (progress) {
        {
        {
#line 248
        (*progress)(progress_ctx, 'c');
        }
        }
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
    {
    {
#line 252
    __gmpz_mul(pub->n, (mpz_srcptr )(key->p), (mpz_srcptr )(key->q));
    }
    {
#line 254
    tmp___7 = __gmpz_sizeinbase((mpz_srcptr )(pub->n), 2);
    }
    }
#line 254
    if (tmp___7 != n_size) {
#line 265
      if (progress) {
        {
        {
#line 267
        (*progress)(progress_ctx, 'b');
        }
        {
#line 268
        (*progress)(progress_ctx, '\n');
        }
        }
      }
#line 270
      goto __Cont;
    }
#line 273
    if (progress) {
      {
      {
#line 274
      (*progress)(progress_ctx, '\n');
      }
      }
    }
    {
    {
#line 277
    tmp___8 = __gmpz_invert(key->c, (mpz_srcptr )(key->q), (mpz_srcptr )(key->p));
    }
    }
#line 277
    if (tmp___8) {
#line 280
      goto while_break;
    } else
#line 281
    if (progress) {
      {
      {
#line 281
      (*progress)(progress_ctx, '?');
      }
      }
    }
    __Cont: ;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 284
  __gmpz_mul(phi, (mpz_srcptr )(p1), (mpz_srcptr )(q1___0));
  }
  }
#line 287
  if (e_size) {
#line 289
    retried = 0;
    {
    {
#line 290
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
      {
      {
#line 292
      nettle_mpz_random_size(pub->e, random_ctx, random___0, e_size);
      }
      {
#line 298
      __gmpz_setbit(pub->e, 0UL);
      }
      {
#line 299
      __gmpz_setbit(pub->e, (unsigned long )(e_size - 1U));
      }
      {
#line 302
      tmp___9 = __gmpz_invert(key->d, (mpz_srcptr )(pub->e), (mpz_srcptr )(phi));
      }
      }
#line 302
      if (tmp___9) {
#line 303
        goto while_break___2;
      }
#line 305
      if (progress) {
        {
        {
#line 305
        (*progress)(progress_ctx, 'e');
        }
        }
      }
#line 306
      retried = 1;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
#line 308
    if (retried) {
#line 308
      if (progress) {
        {
        {
#line 309
        (*progress)(progress_ctx, '\n');
        }
        }
      }
    }
  } else {
    {
    {
#line 315
    tmp___10 = __gmpz_invert(key->d, (mpz_srcptr )(pub->e), (mpz_srcptr )(phi));
    }
#line 315
    res = tmp___10;
    }
#line 316
    if (! res) {
      {
      {
#line 316
      __assert_fail("res", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-keygen.c",
                    316U, "nettle_rsa_generate_keypair");
      }
      }
    }
  }
  {
  {
#line 321
  __gmpz_fdiv_r(key->a, (mpz_srcptr )(key->d), (mpz_srcptr )(p1));
  }
  {
#line 324
  __gmpz_fdiv_r(key->b, (mpz_srcptr )(key->d), (mpz_srcptr )(q1___0));
  }
  {
#line 328
  tmp___12 = __gmpz_sizeinbase((mpz_srcptr )(pub->n), 2);
  }
#line 328
  tmp___11 = (tmp___12 + 7U) / 8U;
#line 328
  key->size = tmp___11;
#line 328
  pub->size = tmp___11;
  }
#line 329
  if (! (pub->size >= 46U)) {
    {
    {
#line 329
    __assert_fail("pub->size >= 46", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-keygen.c",
                  329U, "nettle_rsa_generate_keypair");
    }
    }
  }
  {
  {
#line 331
  __gmpz_clear(p1);
  }
  {
#line 331
  __gmpz_clear(q1___0);
  }
  {
#line 331
  __gmpz_clear(phi);
  }
  {
#line 331
  __gmpz_clear(tmp);
  }
  }
#line 333
  return (1);
}
}
#line 207 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
int nettle_rsa_encrypt(struct rsa_public_key  const  *key , void *random_ctx , void (*random___0)(void *ctx ,
                                                                                                  unsigned int length ,
                                                                                                  uint8_t *dst ) ,
                       unsigned int length , uint8_t const   *message , __mpz_struct *gibbberish ) ;
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.h"
void nettle_mpz_set_str_256_u(__mpz_struct *x , unsigned int length , uint8_t const   *s ) ;
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-encrypt.c"
int nettle_rsa_encrypt(struct rsa_public_key  const  *key , void *random_ctx , void (*random___0)(void *ctx ,
                                                                                                  unsigned int length ,
                                                                                                  uint8_t *dst ) ,
                       unsigned int length , uint8_t const   *message , __mpz_struct *gibbberish ) 
{ 
  uint8_t *em ;
  unsigned int padding ;
  unsigned int i ;
  void *tmp ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 60
  if (length + 11U > (unsigned int )key->size) {
#line 62
    return (0);
  }
#line 65
  padding = (unsigned int )((key->size - (unsigned int const   )length) - 3U);
#line 66
  if (! (padding >= 8U)) {
    {
    {
#line 66
    __assert_fail("padding >= 8", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-encrypt.c",
                  66U, "nettle_rsa_encrypt");
    }
    }
  }
  {
  {
#line 68
  tmp = __builtin_alloca(sizeof(*em) * (unsigned long )key->size - 1UL);
  }
#line 68
  em = (uint8_t *)tmp;
#line 69
  *(em + 0) = (uint8_t )2;
  {
#line 71
  (*random___0)(random_ctx, padding, em + 1);
  }
#line 74
  i = 0U;
  }
  {
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 74
    if (! (i < padding)) {
#line 74
      goto while_break;
    }
#line 75
    if (! *(em + (i + 1U))) {
#line 76
      *(em + (i + 1U)) = (uint8_t )1;
    }
#line 74
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 78
  *(em + (padding + 1U)) = (uint8_t )0;
  {
#line 79
  memcpy((void */* __restrict  */)((void *)((em + padding) + 2)), (void const   */* __restrict  */)((void const   *)message),
         length);
  }
  {
#line 81
  nettle_mpz_set_str_256_u(gibbberish, (unsigned int )(key->size - 1U), (uint8_t const   *)em);
  }
  {
#line 82
  __gmpz_powm(gibbberish, (mpz_srcptr )gibbberish, (mpz_srcptr )(key->e), (mpz_srcptr )(key->n));
  }
  }
#line 84
  return (1);
}
}
#line 94 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 219 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
int nettle_rsa_decrypt(struct rsa_private_key  const  *key , unsigned int *length ,
                       uint8_t *message , __mpz_struct * const  gibberish ) ;
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-decrypt.c"
int nettle_rsa_decrypt(struct rsa_private_key  const  *key , unsigned int *length ,
                       uint8_t *message , __mpz_struct * const  gibberish ) 
{ 
  uint8_t *em ;
  uint8_t *terminator ;
  unsigned int padding ;
  unsigned int message_length ;
  mpz_t m ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;

  {
  {
  {
#line 53
  __gmpz_init(m);
  }
  {
#line 54
  nettle_rsa_compute_root(key, m, gibberish);
  }
  {
#line 56
  tmp = __builtin_alloca(sizeof(*em) * (unsigned long )key->size);
  }
#line 56
  em = (uint8_t *)tmp;
  {
#line 57
  nettle_mpz_get_str_256((unsigned int )key->size, em, (__mpz_struct */* const  */)(m));
  }
  {
#line 58
  __gmpz_clear(m);
  }
  }
#line 61
  if (*(em + 0)) {
#line 62
    return (0);
  } else
#line 61
  if ((int )*(em + 1) != 2) {
#line 62
    return (0);
  }
  {
  {
#line 64
  tmp___0 = memchr((void const   *)(em + 2), 0, (size_t )(key->size - 2U));
  }
#line 64
  terminator = (uint8_t *)tmp___0;
  }
#line 66
  if (! terminator) {
#line 67
    return (0);
  }
#line 69
  padding = (unsigned int )(terminator - (em + 2));
#line 70
  if (padding < 8U) {
#line 71
    return (0);
  }
#line 73
  message_length = (unsigned int )((key->size - 3U) - (unsigned int const   )padding);
#line 75
  if (*length < message_length) {
#line 76
    return (0);
  }
  {
  {
#line 78
  memcpy((void */* __restrict  */)((void *)message), (void const   */* __restrict  */)((void const   *)(terminator + 1)),
         message_length);
  }
#line 79
  *length = message_length;
  }
#line 81
  return (1);
}
}
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5.h"
void nettle_md5_init(struct md5_ctx *ctx ) ;
#line 53
void nettle_md5_update(struct md5_ctx *ctx , unsigned int length , uint8_t const   *data ) ;
#line 89 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-compat.h"
int nettle_R_SignInit(R_SIGNATURE_CTX *ctx , int digestAlgorithm ) ;
#line 93
int nettle_R_SignUpdate(R_SIGNATURE_CTX *ctx , uint8_t const   *data , unsigned int length ) ;
#line 100
int nettle_R_SignFinal(R_SIGNATURE_CTX *ctx , uint8_t *signature , unsigned int *length ,
                       R_RSA_PRIVATE_KEY *key ) ;
#line 106
int nettle_R_VerifyInit(R_SIGNATURE_CTX *ctx , int digestAlgorithm ) ;
#line 110
int nettle_R_VerifyUpdate(R_SIGNATURE_CTX *ctx , uint8_t const   *data , unsigned int length ) ;
#line 117
int nettle_R_VerifyFinal(R_SIGNATURE_CTX *ctx , uint8_t *signature , unsigned int length ,
                         R_RSA_PUBLIC_KEY *key ) ;
#line 64 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.h"
void nettle_mpz_init_set_str_256_u(__mpz_struct *x , unsigned int length , uint8_t const   *s ) ;
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-compat.c"
int nettle_R_SignInit(R_SIGNATURE_CTX *ctx , int digestAlgorithm ) 
{ 


  {
#line 41
  if (digestAlgorithm != 1) {
#line 42
    return (3);
  }
  {
  {
#line 44
  nettle_md5_init(& ctx->hash);
  }
  }
#line 46
  return (0);
}
}
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-compat.c"
int nettle_R_SignUpdate(R_SIGNATURE_CTX *ctx , uint8_t const   *data , unsigned int length ) 
{ 


  {
  {
  {
#line 56
  nettle_md5_update(& ctx->hash, length, data);
  }
  }
#line 58
  return (0);
}
}
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-compat.c"
int nettle_R_SignFinal(R_SIGNATURE_CTX *ctx , uint8_t *signature , unsigned int *length ,
                       R_RSA_PRIVATE_KEY *key ) 
{ 
  struct rsa_private_key k ;
  int res ;
  mpz_t s ;
  int tmp ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;

  {
  {
  {
#line 70
  nettle_mpz_init_set_str_256_u(k.p, 256U, (uint8_t const   *)(key->prime[0]));
  }
  {
#line 72
  nettle_mpz_init_set_str_256_u(k.q, 256U, (uint8_t const   *)(key->prime[1]));
  }
  {
#line 74
  nettle_mpz_init_set_str_256_u(k.a, 256U, (uint8_t const   *)(key->primeExponent[0]));
  }
  {
#line 76
  nettle_mpz_init_set_str_256_u(k.b, 256U, (uint8_t const   *)(key->primeExponent[1]));
  }
  {
#line 78
  nettle_mpz_init_set_str_256_u(k.c, 256U, (uint8_t const   *)(key->coefficient));
  }
  {
#line 81
  tmp = nettle_rsa_private_key_prepare(& k);
  }
  }
#line 81
  if (tmp) {
#line 81
    if (k.size <= 256U) {
      {
      {
#line 84
      __gmpz_init(s);
      }
      {
#line 86
      nettle_rsa_md5_sign((struct rsa_private_key  const  *)(& k), & ctx->hash, s);
      }
      {
#line 87
      nettle_mpz_get_str_256(k.size, signature, (__mpz_struct */* const  */)(s));
      }
      {
#line 89
      __gmpz_clear(s);
      }
#line 91
      *length = k.size;
#line 93
      res = 0;
      }
    } else {
#line 96
      res = 11;
    }
  } else {
#line 96
    res = 11;
  }
  {
  {
#line 98
  __gmpz_clear(k.p);
  }
  {
#line 99
  __gmpz_clear(k.q);
  }
  {
#line 100
  __gmpz_clear(k.a);
  }
  {
#line 101
  __gmpz_clear(k.b);
  }
  {
#line 102
  __gmpz_clear(k.c);
  }
  }
#line 104
  return (res);
}
}
#line 107 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-compat.c"
int nettle_R_VerifyInit(R_SIGNATURE_CTX *ctx , int digestAlgorithm ) 
{ 
  int tmp ;

  {
  {
  {
#line 111
  tmp = nettle_R_SignInit(ctx, digestAlgorithm);
  }
  }
#line 111
  return (tmp);
}
}
#line 114 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-compat.c"
int nettle_R_VerifyUpdate(R_SIGNATURE_CTX *ctx , uint8_t const   *data , unsigned int length ) 
{ 
  int tmp ;

  {
  {
  {
#line 121
  tmp = nettle_R_SignUpdate(ctx, data, length);
  }
  }
#line 121
  return (tmp);
}
}
#line 124 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa-compat.c"
int nettle_R_VerifyFinal(R_SIGNATURE_CTX *ctx , uint8_t *signature , unsigned int length ,
                         R_RSA_PUBLIC_KEY *key ) 
{ 
  struct rsa_public_key k ;
  int res ;
  mpz_t s ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
  {
  {
#line 133
  nettle_mpz_init_set_str_256_u(k.n, 256U, (uint8_t const   *)(key->modulus));
  }
  {
#line 135
  nettle_mpz_init_set_str_256_u(k.e, 256U, (uint8_t const   *)(key->exponent));
  }
  {
#line 138
  tmp___1 = nettle_rsa_public_key_prepare(& k);
  }
  }
#line 138
  if (tmp___1) {
#line 138
    if (k.size == length) {
      {
      {
#line 142
      nettle_mpz_init_set_str_256_u(s, k.size, (uint8_t const   *)signature);
      }
      {
#line 144
      tmp___0 = nettle_rsa_md5_verify((struct rsa_public_key  const  *)(& k), & ctx->hash,
                                      (__mpz_struct */* const  */)(s));
      }
      }
#line 144
      if (tmp___0) {
#line 144
        res = 0;
      } else {
#line 144
        res = 13;
      }
      {
      {
#line 147
      __gmpz_clear(s);
      }
      }
    } else {
#line 150
      res = 12;
    }
  } else {
#line 150
    res = 12;
  }
  {
  {
#line 152
  __gmpz_clear(k.n);
  }
  {
#line 153
  __gmpz_clear(k.e);
  }
  }
#line 155
  return (res);
}
}
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/realloc.h"
void *nettle_realloc(void *ctx  __attribute__((__unused__)) , void *p , unsigned int length ) ;
#line 33
void *nettle_xrealloc(void *ctx  __attribute__((__unused__)) , void *p , unsigned int length ) ;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/realloc.c"
void *nettle_realloc(void *ctx  __attribute__((__unused__)) , void *p , unsigned int length ) 
{ 
  void *tmp ;

  {
  {
  {
#line 37
  tmp = realloc(p, length);
  }
  }
#line 37
  return (tmp);
}
}
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/realloc.c"
void *nettle_xrealloc(void *ctx  __attribute__((__unused__)) , void *p , unsigned int length ) 
{ 
  void *n ;
  void *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 43
  tmp = realloc(p, length);
  }
#line 43
  n = tmp;
  }
#line 44
  if (length) {
#line 44
    if (! n) {
      {
      {
#line 46
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Virtual memory exhausted.\n");
      }
      {
#line 47
      abort();
      }
      }
    }
  }
#line 49
  return (n);
}
}
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1.h"
void nettle_pkcs1_signature_prefix(unsigned int length , uint8_t *buffer , unsigned int id_length ,
                                   uint8_t const   *id ) ;
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1.c"
void nettle_pkcs1_signature_prefix(unsigned int length , uint8_t *buffer , unsigned int id_length ,
                                   uint8_t const   *id ) 
{ 
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 43
  if (! (length >= id_length)) {
    {
    {
#line 43
    __assert_fail("length >= id_length", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1.c",
                  43U, "nettle_pkcs1_signature_prefix");
    }
    }
  }
  {
#line 44
  length -= id_length;
  {
#line 45
  memcpy((void */* __restrict  */)((void *)(buffer + length)), (void const   */* __restrict  */)((void const   *)id),
         id_length);
  }
  }
#line 47
  if (! length) {
    {
    {
#line 47
    __assert_fail("length", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1.c",
                  47U, "nettle_pkcs1_signature_prefix");
    }
    }
  }
#line 48
  length --;
#line 48
  *(buffer + length) = (uint8_t )0;
#line 50
  if (! (length >= 9U)) {
    {
    {
#line 50
    __assert_fail("length >= 9", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1.c",
                  50U, "nettle_pkcs1_signature_prefix");
    }
    }
  }
  {
  {
#line 51
  memset((void *)(buffer + 1), 255, length - 1U);
  }
#line 52
  *(buffer + 0) = (uint8_t )1;
  }
#line 53
  return;
}
}
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1-rsa-sha1.c"
static uint8_t const   sha1_prefix[15]  = 
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1-rsa-sha1.c"
  {      (uint8_t const   )48,      (uint8_t const   )33,      (uint8_t const   )48,      (uint8_t const   )9, 
        (uint8_t const   )6,      (uint8_t const   )5,      (uint8_t const   )43,      (uint8_t const   )14, 
        (uint8_t const   )3,      (uint8_t const   )2,      (uint8_t const   )26,      (uint8_t const   )5, 
        (uint8_t const   )0,      (uint8_t const   )4,      (uint8_t const   )20};
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1-rsa-sha1.c"
void nettle_pkcs1_rsa_sha1_encode(__mpz_struct *m , unsigned int length , struct sha1_ctx *hash___2 ) 
{ 
  uint8_t *em ;
  void *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 70
  tmp = __builtin_alloca(sizeof(*em) * (unsigned long )length);
  }
#line 70
  em = (uint8_t *)tmp;
  }
#line 72
  if (! (length >= 20U)) {
    {
    {
#line 72
    __assert_fail("length >= 20", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1-rsa-sha1.c",
                  72U, "nettle_pkcs1_rsa_sha1_encode");
    }
    }
  }
  {
  {
#line 73
  nettle_pkcs1_signature_prefix(length - 20U, em, (unsigned int )sizeof(sha1_prefix),
                                sha1_prefix);
  }
  {
#line 77
  nettle_sha1_digest(hash___2, 20U, (em + length) - 20);
  }
  {
#line 78
  nettle_mpz_set_str_256_u(m, length, (uint8_t const   *)em);
  }
  }
#line 79
  return;
}
}
#line 81 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1-rsa-sha1.c"
void nettle_pkcs1_rsa_sha1_encode_digest(__mpz_struct *m , unsigned int length , uint8_t const   *digest ) 
{ 
  uint8_t *em ;
  void *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 85
  tmp = __builtin_alloca(sizeof(*em) * (unsigned long )length);
  }
#line 85
  em = (uint8_t *)tmp;
  }
#line 87
  if (! (length >= 20U)) {
    {
    {
#line 87
    __assert_fail("length >= 20", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1-rsa-sha1.c",
                  87U, "nettle_pkcs1_rsa_sha1_encode_digest");
    }
    }
  }
  {
  {
#line 88
  nettle_pkcs1_signature_prefix(length - 20U, em, (unsigned int )sizeof(sha1_prefix),
                                sha1_prefix);
  }
  {
#line 92
  memcpy((void */* __restrict  */)((void *)((em + length) - 20)), (void const   */* __restrict  */)((void const   *)digest),
         (size_t )20);
  }
  {
#line 93
  nettle_mpz_set_str_256_u(m, length, (uint8_t const   *)em);
  }
  }
#line 94
  return;
}
}
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5.h"
void nettle_md5_digest(struct md5_ctx *ctx , unsigned int length , uint8_t *digest ) ;
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1-rsa-md5.c"
static uint8_t const   md5_prefix[18]  = 
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1-rsa-md5.c"
  {      (uint8_t const   )48,      (uint8_t const   )32,      (uint8_t const   )48,      (uint8_t const   )12, 
        (uint8_t const   )6,      (uint8_t const   )8,      (uint8_t const   )42,      (uint8_t const   )134, 
        (uint8_t const   )72,      (uint8_t const   )134,      (uint8_t const   )247,      (uint8_t const   )13, 
        (uint8_t const   )2,      (uint8_t const   )5,      (uint8_t const   )5,      (uint8_t const   )0, 
        (uint8_t const   )4,      (uint8_t const   )16};
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1-rsa-md5.c"
void nettle_pkcs1_rsa_md5_encode(__mpz_struct *m , unsigned int length , struct md5_ctx *hash___2 ) 
{ 
  uint8_t *em ;
  void *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 70
  tmp = __builtin_alloca(sizeof(*em) * (unsigned long )length);
  }
#line 70
  em = (uint8_t *)tmp;
  }
#line 72
  if (! (length >= 16U)) {
    {
    {
#line 72
    __assert_fail("length >= 16", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1-rsa-md5.c",
                  72U, "nettle_pkcs1_rsa_md5_encode");
    }
    }
  }
  {
  {
#line 73
  nettle_pkcs1_signature_prefix(length - 16U, em, (unsigned int )sizeof(md5_prefix),
                                md5_prefix);
  }
  {
#line 77
  nettle_md5_digest(hash___2, 16U, (em + length) - 16);
  }
  {
#line 78
  nettle_mpz_set_str_256_u(m, length, (uint8_t const   *)em);
  }
  }
#line 79
  return;
}
}
#line 81 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1-rsa-md5.c"
void nettle_pkcs1_rsa_md5_encode_digest(__mpz_struct *m , unsigned int length , uint8_t const   *digest ) 
{ 
  uint8_t *em ;
  void *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 85
  tmp = __builtin_alloca(sizeof(*em) * (unsigned long )length);
  }
#line 85
  em = (uint8_t *)tmp;
  }
#line 87
  if (! (length >= 16U)) {
    {
    {
#line 87
    __assert_fail("length >= 16", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pkcs1-rsa-md5.c",
                  87U, "nettle_pkcs1_rsa_md5_encode_digest");
    }
    }
  }
  {
  {
#line 88
  nettle_pkcs1_signature_prefix(length - 16U, em, (unsigned int )sizeof(md5_prefix),
                                md5_prefix);
  }
  {
#line 92
  memcpy((void */* __restrict  */)((void *)((em + length) - 16)), (void const   */* __restrict  */)((void const   *)digest),
         (size_t )16);
  }
  {
#line 93
  nettle_mpz_set_str_256_u(m, length, (uint8_t const   *)em);
  }
  }
#line 94
  return;
}
}
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.h"
unsigned int nettle_mpz_sizeinbase_256_u(__mpz_struct * const  x ) ;
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp.h"
int nettle_pgp_put_uint32(struct nettle_buffer *buffer , uint32_t i ) ;
#line 62
int nettle_pgp_put_uint16(struct nettle_buffer *buffer , unsigned int i ) ;
#line 65
int nettle_pgp_put_mpi(struct nettle_buffer *buffer , __mpz_struct * const  x ) ;
#line 68
int nettle_pgp_put_string(struct nettle_buffer *buffer , unsigned int length , uint8_t const   *s ) ;
#line 73
int nettle_pgp_put_length(struct nettle_buffer *buffer , unsigned int length ) ;
#line 77
int nettle_pgp_put_header(struct nettle_buffer *buffer , unsigned int tag , unsigned int length ) ;
#line 81
void nettle_pgp_put_header_length(struct nettle_buffer *buffer , unsigned int start ,
                                  unsigned int field_size ) ;
#line 87
unsigned int nettle_pgp_sub_packet_start(struct nettle_buffer *buffer ) ;
#line 90
int nettle_pgp_put_sub_packet(struct nettle_buffer *buffer , unsigned int type , unsigned int length ,
                              uint8_t const   *data ) ;
#line 96
void nettle_pgp_sub_packet_end(struct nettle_buffer *buffer , unsigned int start ) ;
#line 116
uint32_t nettle_pgp_crc24(unsigned int length , uint8_t const   *data ) ;
#line 119
int nettle_pgp_armor(struct nettle_buffer *buffer , char const   *tag , unsigned int length ,
                     uint8_t const   *data ) ;
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64.h"
void nettle_base64_encode_init(struct base64_encode_ctx *ctx ) ;
#line 77
unsigned int nettle_base64_encode_update(struct base64_encode_ctx *ctx , uint8_t *dst ,
                                         unsigned int length , uint8_t const   *src ) ;
#line 85
unsigned int nettle_base64_encode_final(struct base64_encode_ctx *ctx , uint8_t *dst ) ;
#line 97
void nettle_base64_encode_group(uint8_t *dst , uint32_t group ) ;
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
int nettle_pgp_put_uint32(struct nettle_buffer *buffer , uint32_t i ) 
{ 
  uint8_t *p ;
  uint8_t *tmp ;

  {
  {
  {
#line 55
  tmp = nettle_buffer_space(buffer, 4U);
  }
#line 55
  p = tmp;
  }
#line 56
  if (! p) {
#line 57
    return (0);
  }
  {
  {
#line 59
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 59
    *(p + 0) = (uint8_t )((i >> 24) & 255U);
#line 59
    *(p + 1) = (uint8_t )((i >> 16) & 255U);
#line 59
    *(p + 2) = (uint8_t )((i >> 8) & 255U);
#line 59
    *(p + 3) = (uint8_t )(i & 255U);
#line 59
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 60
  return (1);
}
}
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
int nettle_pgp_put_uint16(struct nettle_buffer *buffer , unsigned int i ) 
{ 
  uint8_t *p ;
  uint8_t *tmp ;

  {
  {
  {
#line 66
  tmp = nettle_buffer_space(buffer, 2U);
  }
#line 66
  p = tmp;
  }
#line 67
  if (! p) {
#line 68
    return (0);
  }
  {
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 70
    *(p + 0) = (uint8_t )((i >> 8) & 255U);
#line 70
    *(p + 1) = (uint8_t )(i & 255U);
#line 70
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 71
  return (1);
}
}
#line 75 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
int nettle_pgp_put_mpi(struct nettle_buffer *buffer , __mpz_struct * const  x ) 
{ 
  unsigned int bits ;
  size_t tmp ;
  unsigned int octets ;
  uint8_t *p ;
  int tmp___0 ;

  {
  {
  {
#line 78
  tmp = __gmpz_sizeinbase((mpz_srcptr )x, 2);
  }
#line 78
  bits = tmp;
#line 79
  octets = (bits + 7U) / 8U;
  {
#line 84
  tmp___0 = nettle_pgp_put_uint16(buffer, bits);
  }
  }
#line 84
  if (! tmp___0) {
#line 85
    return (0);
  }
  {
  {
#line 87
  p = nettle_buffer_space(buffer, octets);
  }
  }
#line 89
  if (! p) {
#line 90
    return (0);
  }
  {
  {
#line 92
  nettle_mpz_get_str_256(octets, p, x);
  }
  }
#line 94
  return (1);
}
}
#line 98 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
int nettle_pgp_put_string(struct nettle_buffer *buffer , unsigned int length , uint8_t const   *s ) 
{ 
  int tmp ;

  {
  {
  {
#line 103
  tmp = nettle_buffer_write(buffer, length, s);
  }
  }
#line 103
  return (tmp);
}
}
#line 124 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
int nettle_pgp_put_length(struct nettle_buffer *buffer , unsigned int length ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 128
  if (length < 192U) {
#line 129
    if (buffer->size < buffer->alloc) {
#line 129
      tmp___0 = buffer->size;
#line 129
      (buffer->size) ++;
#line 129
      *(buffer->contents + tmp___0) = (uint8_t )length;
#line 129
      tmp___1 = 1;
    } else {
      {
      {
#line 129
      tmp = nettle_buffer_grow(buffer, 1U);
      }
      }
#line 129
      if (tmp) {
#line 129
        tmp___0 = buffer->size;
#line 129
        (buffer->size) ++;
#line 129
        *(buffer->contents + tmp___0) = (uint8_t )length;
#line 129
        tmp___1 = 1;
      } else {
#line 129
        tmp___1 = 0;
      }
    }
#line 129
    return (tmp___1);
  } else
#line 131
  if (length < 8384U) {
    {
    {
#line 132
    tmp___2 = nettle_pgp_put_uint16(buffer, length + 48960U);
    }
    }
#line 132
    return (tmp___2);
  } else {
#line 134
    if (buffer->size < buffer->alloc) {
#line 134
      goto _L;
    } else {
      {
      {
#line 134
      tmp___3 = nettle_buffer_grow(buffer, 1U);
      }
      }
#line 134
      if (tmp___3) {
        _L: 
        {
#line 134
        tmp___4 = buffer->size;
#line 134
        (buffer->size) ++;
#line 134
        *(buffer->contents + tmp___4) = (uint8_t )255;
        {
#line 134
        tmp___5 = nettle_pgp_put_uint32(buffer, length);
        }
        }
#line 134
        if (tmp___5) {
#line 134
          tmp___6 = 1;
        } else {
#line 134
          tmp___6 = 0;
        }
      } else {
#line 134
        tmp___6 = 0;
      }
    }
#line 134
    return (tmp___6);
  }
}
}
#line 138 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
int nettle_pgp_put_header(struct nettle_buffer *buffer , unsigned int tag , unsigned int length ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 142
  if (! (tag < 64U)) {
    {
    {
#line 142
    __assert_fail("tag < 0x40", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c",
                  142U, "nettle_pgp_put_header");
    }
    }
  }
#line 144
  if (buffer->size < buffer->alloc) {
#line 144
    goto _L;
  } else {
    {
    {
#line 144
    tmp = nettle_buffer_grow(buffer, 1U);
    }
    }
#line 144
    if (tmp) {
      _L: 
      {
#line 144
      tmp___0 = buffer->size;
#line 144
      (buffer->size) ++;
#line 144
      *(buffer->contents + tmp___0) = (uint8_t )(192U | tag);
      {
#line 144
      tmp___1 = nettle_pgp_put_length(buffer, length);
      }
      }
#line 144
      if (tmp___1) {
#line 144
        tmp___2 = 1;
      } else {
#line 144
        tmp___2 = 0;
      }
    } else {
#line 144
      tmp___2 = 0;
    }
  }
#line 144
  return (tmp___2);
}
}
#line 150 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
void nettle_pgp_put_header_length(struct nettle_buffer *buffer , unsigned int start ,
                                  unsigned int field_size ) 
{ 
  unsigned int length ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 159
  if (field_size == 1U) {
#line 159
    goto case_1;
  }
#line 164
  if (field_size == 2U) {
#line 164
    goto case_2;
  }
#line 170
  if (field_size == 4U) {
#line 170
    goto case_4;
  }
#line 174
  goto switch_default;
  case_1: 
#line 160
  length = buffer->size - (start + 2U);
#line 161
  if (! (length < 192U)) {
    {
    {
#line 161
    __assert_fail("length < PGP_LENGTH_TWO_OCTETS", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c",
                  161U, "nettle_pgp_put_header_length");
    }
    }
  }
#line 162
  *(buffer->contents + (start + 1U)) = (uint8_t )length;
#line 163
  goto switch_break;
  case_2: 
#line 165
  length = buffer->size - (start + 3U);
#line 166
  if (length < 8384U) {
#line 166
    if (! (length >= 192U)) {
      {
      {
#line 166
      __assert_fail("length < PGP_LENGTH_FOUR_OCTETS && length >= PGP_LENGTH_TWO_OCTETS",
                    "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c",
                    167U, "nettle_pgp_put_header_length");
      }
      }
    }
  } else {
    {
    {
#line 166
    __assert_fail("length < PGP_LENGTH_FOUR_OCTETS && length >= PGP_LENGTH_TWO_OCTETS",
                  "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c", 167U,
                  "nettle_pgp_put_header_length");
    }
    }
  }
  {
  {
#line 168
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 168
    *(((buffer->contents + start) + 1) + 0) = (uint8_t )(((length + 48960U) >> 8) & 255U);
#line 168
    *(((buffer->contents + start) + 1) + 1) = (uint8_t )((length + 48960U) & 255U);
#line 168
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 169
  goto switch_break;
  case_4: 
#line 171
  length = buffer->size - (start + 5U);
  {
  {
#line 172
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 172
    *(((buffer->contents + start) + 2) + 0) = (uint8_t )((length >> 24) & 255U);
#line 172
    *(((buffer->contents + start) + 2) + 1) = (uint8_t )((length >> 16) & 255U);
#line 172
    *(((buffer->contents + start) + 2) + 2) = (uint8_t )((length >> 8) & 255U);
#line 172
    *(((buffer->contents + start) + 2) + 3) = (uint8_t )(length & 255U);
#line 172
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 173
  goto switch_break;
  switch_default: 
  {
  {
#line 175
  abort();
  }
  }
  switch_break: ;
#line 177
  return;
}
}
#line 179 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
int nettle_pgp_put_userid(struct nettle_buffer *buffer , unsigned int length , uint8_t const   *name ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 184
  tmp = nettle_pgp_put_header(buffer, 13U, length);
  }
  }
#line 184
  if (tmp) {
    {
    {
#line 184
    tmp___0 = nettle_pgp_put_string(buffer, length, name);
    }
    }
#line 184
    if (tmp___0) {
#line 184
      tmp___1 = 1;
    } else {
#line 184
      tmp___1 = 0;
    }
  } else {
#line 184
    tmp___1 = 0;
  }
#line 184
  return (tmp___1);
}
}
#line 188 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
unsigned int nettle_pgp_sub_packet_start(struct nettle_buffer *buffer ) 
{ 
  unsigned int tmp___0 ;
  uint8_t *tmp___1 ;

  {
  {
  {
#line 191
  tmp___1 = nettle_buffer_space(buffer, 2U);
  }
  }
#line 191
  if (tmp___1) {
#line 191
    tmp___0 = buffer->size;
  } else {
#line 191
    tmp___0 = 0U;
  }
#line 191
  return (tmp___0);
}
}
#line 194 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
int nettle_pgp_put_sub_packet(struct nettle_buffer *buffer , unsigned int type , unsigned int length ,
                              uint8_t const   *data ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  {
#line 200
  tmp = nettle_pgp_put_length(buffer, length + 1U);
  }
  }
#line 200
  if (tmp) {
#line 200
    if (buffer->size < buffer->alloc) {
#line 200
      goto _L;
    } else {
      {
      {
#line 200
      tmp___0 = nettle_buffer_grow(buffer, 1U);
      }
      }
#line 200
      if (tmp___0) {
        _L: 
        {
#line 200
        tmp___1 = buffer->size;
#line 200
        (buffer->size) ++;
#line 200
        *(buffer->contents + tmp___1) = (uint8_t )type;
        {
#line 200
        tmp___2 = nettle_pgp_put_string(buffer, length, data);
        }
        }
#line 200
        if (tmp___2) {
#line 200
          tmp___3 = 1;
        } else {
#line 200
          tmp___3 = 0;
        }
      } else {
#line 200
        tmp___3 = 0;
      }
    }
  } else {
#line 200
    tmp___3 = 0;
  }
#line 200
  return (tmp___3);
}
}
#line 205 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
void nettle_pgp_sub_packet_end(struct nettle_buffer *buffer , unsigned int start ) 
{ 
  unsigned int length ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 210
  if (! (start >= 2U)) {
    {
    {
#line 210
    __assert_fail("start >= 2", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c",
                  210U, "nettle_pgp_sub_packet_end");
    }
    }
  }
#line 211
  if (! (start <= buffer->size)) {
    {
    {
#line 211
    __assert_fail("start <= buffer->size", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c",
                  211U, "nettle_pgp_sub_packet_end");
    }
    }
  }
#line 213
  length = buffer->size - start;
  {
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 214
    *(((buffer->contents + start) - 2) + 0) = (uint8_t )((length >> 24) & 255U);
#line 214
    *(((buffer->contents + start) - 2) + 1) = (uint8_t )((length >> 16) & 255U);
#line 214
    *(((buffer->contents + start) - 2) + 2) = (uint8_t )((length >> 8) & 255U);
#line 214
    *(((buffer->contents + start) - 2) + 3) = (uint8_t )(length & 255U);
#line 214
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 215
  return;
}
}
#line 218 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
int nettle_pgp_put_public_rsa_key(struct nettle_buffer *buffer , struct rsa_public_key  const  *pub ,
                                  time_t timestamp ) 
{ 
  unsigned int start ;
  unsigned int length ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
  {
#line 228
  tmp = nettle_mpz_sizeinbase_256_u((__mpz_struct */* const  */)((__mpz_struct *)(pub->n)));
  }
  {
#line 228
  tmp___0 = nettle_mpz_sizeinbase_256_u((__mpz_struct */* const  */)((__mpz_struct *)(pub->e)));
  }
#line 228
  length = (16U + tmp) + tmp___0;
  {
#line 232
  tmp___1 = nettle_pgp_put_header(buffer, 6U, length);
  }
  }
#line 232
  if (! tmp___1) {
#line 233
    return (0);
  }
  {
#line 235
  start = buffer->size;
  {
#line 237
  tmp___2 = nettle_pgp_put_header(buffer, 6U, 192U);
  }
  }
#line 237
  if (tmp___2) {
    {
    {
#line 237
    tmp___3 = nettle_pgp_put_uint32(buffer, (uint32_t )4);
    }
    }
#line 237
    if (tmp___3) {
      {
      {
#line 237
      tmp___4 = nettle_pgp_put_uint32(buffer, (uint32_t )timestamp);
      }
      }
#line 237
      if (tmp___4) {
        {
        {
#line 237
        tmp___5 = nettle_pgp_put_uint32(buffer, (uint32_t )1);
        }
        }
#line 237
        if (tmp___5) {
          {
          {
#line 237
          tmp___6 = nettle_pgp_put_mpi(buffer, (__mpz_struct */* const  */)((__mpz_struct *)(pub->n)));
          }
          }
#line 237
          if (tmp___6) {
            {
            {
#line 237
            tmp___7 = nettle_pgp_put_mpi(buffer, (__mpz_struct */* const  */)((__mpz_struct *)(pub->e)));
            }
            }
#line 237
            if (! tmp___7) {
#line 245
              return (0);
            }
          } else {
#line 245
            return (0);
          }
        } else {
#line 245
          return (0);
        }
      } else {
#line 245
        return (0);
      }
    } else {
#line 245
      return (0);
    }
  } else {
#line 245
    return (0);
  }
#line 247
  if (! (buffer->size == start + length)) {
    {
    {
#line 247
    __assert_fail("buffer->size == start + length", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c",
                  247U, "nettle_pgp_put_public_rsa_key");
    }
    }
  }
#line 249
  return (1);
}
}
#line 252 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
int nettle_pgp_put_rsa_sha1_signature(struct nettle_buffer *buffer , struct rsa_private_key  const  *key ,
                                      uint8_t const   *keyid , unsigned int type ,
                                      struct sha1_ctx *hash___2 ) 
{ 
  unsigned int signature_start ;
  unsigned int hash_end ;
  unsigned int sub_packet_start ;
  uint8_t trailer[6] ;
  mpz_t s ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  struct sha1_ctx hcopy ;
  uint8_t *p ;
  uint8_t *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;

  {
  {
#line 259
  signature_start = buffer->size;
  {
#line 270
  tmp = nettle_pgp_put_header(buffer, 2U, 8384U);
  }
  }
#line 270
  if (tmp) {
#line 270
    if (buffer->size < buffer->alloc) {
#line 270
      goto _L___2;
    } else {
      {
      {
#line 270
      tmp___0 = nettle_buffer_grow(buffer, 1U);
      }
      }
#line 270
      if (tmp___0) {
        _L___2: 
#line 270
        tmp___1 = buffer->size;
#line 270
        (buffer->size) ++;
#line 270
        *(buffer->contents + tmp___1) = (uint8_t )4;
#line 270
        if (buffer->size < buffer->alloc) {
#line 270
          goto _L___1;
        } else {
          {
          {
#line 270
          tmp___2 = nettle_buffer_grow(buffer, 1U);
          }
          }
#line 270
          if (tmp___2) {
            _L___1: 
#line 270
            tmp___3 = buffer->size;
#line 270
            (buffer->size) ++;
#line 270
            *(buffer->contents + tmp___3) = (uint8_t )type;
#line 270
            if (buffer->size < buffer->alloc) {
#line 270
              goto _L___0;
            } else {
              {
              {
#line 270
              tmp___4 = nettle_buffer_grow(buffer, 1U);
              }
              }
#line 270
              if (tmp___4) {
                _L___0: 
#line 270
                tmp___5 = buffer->size;
#line 270
                (buffer->size) ++;
#line 270
                *(buffer->contents + tmp___5) = (uint8_t )1;
#line 270
                if (buffer->size < buffer->alloc) {
#line 270
                  goto _L;
                } else {
                  {
                  {
#line 270
                  tmp___6 = nettle_buffer_grow(buffer, 1U);
                  }
                  }
#line 270
                  if (tmp___6) {
                    _L: 
                    {
#line 270
                    tmp___7 = buffer->size;
#line 270
                    (buffer->size) ++;
#line 270
                    *(buffer->contents + tmp___7) = (uint8_t )2;
                    {
#line 270
                    tmp___8 = nettle_pgp_put_uint16(buffer, 0U);
                    }
                    }
#line 270
                    if (! tmp___8) {
#line 277
                      return (0);
                    }
                  } else {
#line 277
                    return (0);
                  }
                }
              } else {
#line 277
                return (0);
              }
            }
          } else {
#line 277
            return (0);
          }
        }
      } else {
#line 277
        return (0);
      }
    }
  } else {
#line 277
    return (0);
  }
  {
#line 279
  hash_end = buffer->size;
  {
#line 281
  nettle_sha1_update(hash___2, hash_end - signature_start, (uint8_t const   *)(buffer->contents + signature_start));
  }
#line 285
  trailer[0] = (uint8_t )4;
#line 285
  trailer[1] = (uint8_t )255;
  }
  {
  {
#line 286
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 286
    *((trailer + 2) + 0) = (uint8_t )(((buffer->size - signature_start) >> 24) & 255U);
#line 286
    *((trailer + 2) + 1) = (uint8_t )(((buffer->size - signature_start) >> 16) & 255U);
#line 286
    *((trailer + 2) + 2) = (uint8_t )(((buffer->size - signature_start) >> 8) & 255U);
#line 286
    *((trailer + 2) + 3) = (uint8_t )((buffer->size - signature_start) & 255U);
#line 286
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 288
  nettle_sha1_update(hash___2, (unsigned int )sizeof(trailer), (uint8_t const   *)(trailer));
  }
#line 291
  hcopy = *hash___2;
  {
#line 292
  tmp___9 = nettle_buffer_space(buffer, 2U);
  }
#line 292
  p = tmp___9;
  }
#line 293
  if (! p) {
#line 294
    return (0);
  }
  {
  {
#line 296
  nettle_sha1_digest(& hcopy, 2U, p);
  }
  {
#line 300
  sub_packet_start = nettle_pgp_sub_packet_start(buffer);
  }
  }
#line 301
  if (! sub_packet_start) {
#line 302
    return (0);
  }
  {
  {
#line 304
  tmp___10 = nettle_pgp_put_sub_packet(buffer, 16U, 8U, keyid);
  }
  }
#line 304
  if (tmp___10) {
    {
    {
#line 306
    nettle_pgp_sub_packet_end(buffer, sub_packet_start);
    }
    }
#line 307
    return (0);
  }
  {
  {
#line 310
  __gmpz_init(s);
  }
  {
#line 311
  nettle_rsa_sha1_sign(key, hash___2, s);
  }
  {
#line 313
  tmp___11 = nettle_pgp_put_mpi(buffer, (__mpz_struct */* const  */)(s));
  }
  }
#line 313
  if (! tmp___11) {
    {
    {
#line 315
    __gmpz_clear(s);
    }
    }
#line 316
    return (0);
  }
  {
  {
#line 319
  __gmpz_clear(s);
  }
  {
#line 320
  nettle_pgp_put_header_length(buffer, signature_start, 4U);
  }
  }
#line 322
  return (1);
}
}
#line 329 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
uint32_t nettle_pgp_crc24(unsigned int length , uint8_t const   *data ) 
{ 
  uint32_t crc ;
  unsigned int i ;
  unsigned int j ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 332
  crc = (uint32_t )11994318L;
#line 335
  i = 0U;
  {
  {
#line 335
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 335
    if (! (i < length)) {
#line 335
      goto while_break;
    }
#line 338
    crc ^= (unsigned int )*(data + i) << 16;
#line 339
    j = 0U;
    {
    {
#line 339
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 339
      if (! (j < 8U)) {
#line 339
        goto while_break___0;
      }
#line 341
      crc <<= 1;
#line 342
      if (crc & 16777216U) {
#line 343
        crc = (uint32_t )((long )crc ^ 25578747L);
      }
#line 339
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 335
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 346
  if (! (crc < 16777216U)) {
    {
    {
#line 346
    __assert_fail("crc < 0x1000000", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c",
                  346U, "nettle_pgp_crc24");
    }
    }
  }
#line 347
  return (crc);
}
}
#line 357 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c"
int nettle_pgp_armor(struct nettle_buffer *buffer , char const   *tag , unsigned int length ,
                     uint8_t const   *data ) 
{ 
  struct base64_encode_ctx ctx ;
  unsigned int crc ;
  uint32_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned int done ;
  uint8_t *p ;
  uint8_t *tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int text_size ;
  unsigned int done___0 ;
  uint8_t *p___0 ;
  uint8_t *tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  int tmp___13 ;
  unsigned int tmp___14 ;
  uint8_t *p___1 ;
  uint8_t *tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  unsigned int tmp___21 ;
  int tmp___22 ;
  void *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  void *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
  {
  {
#line 365
  tmp = nettle_pgp_crc24(length, data);
  }
#line 365
  crc = tmp;
  {
#line 367
  nettle_base64_encode_init(& ctx);
  }
  {
#line 369
  tmp___0 = strlen("BEGIN PGP ");
  }
  {
#line 369
  tmp___1 = nettle_buffer_write(buffer, tmp___0, (uint8_t const   *)"BEGIN PGP ");
  }
  }
#line 369
  if (tmp___1) {
    {
    {
#line 369
    tmp___2 = strlen(tag);
    }
    {
#line 369
    tmp___3 = nettle_buffer_write(buffer, tmp___2, (uint8_t const   *)tag);
    }
    }
#line 369
    if (tmp___3) {
      {
      {
#line 369
      tmp___4 = strlen("\nComment: Nettle\n\n");
      }
      {
#line 369
      tmp___5 = nettle_buffer_write(buffer, tmp___4, (uint8_t const   *)"\nComment: Nettle\n\n");
      }
      }
#line 369
      if (! tmp___5) {
#line 372
        return (0);
      }
    } else {
#line 372
      return (0);
    }
  } else {
#line 372
    return (0);
  }
  {
  {
#line 374
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 374
    if (! (length >= 45U)) {
#line 374
      goto while_break;
    }
    {
    {
#line 379
    tmp___6 = nettle_buffer_space(buffer, 60U);
    }
#line 379
    p = tmp___6;
    }
#line 382
    if (! p) {
#line 383
      return (0);
    }
    {
    {
#line 385
    done = nettle_base64_encode_update(& ctx, p, 45U, data);
    }
    }
#line 386
    if (! (done <= 60U)) {
      {
      {
#line 386
      __assert_fail("done <= (((45) * 8 + 4)/6)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/pgp-encode.c",
                    386U, "nettle_pgp_armor");
      }
      }
    }
#line 389
    buffer->size -= 60U - done;
#line 391
    if (buffer->size < buffer->alloc) {
#line 391
      tmp___8 = buffer->size;
#line 391
      (buffer->size) ++;
#line 391
      *(buffer->contents + tmp___8) = (uint8_t )'\n';
    } else {
      {
      {
#line 391
      tmp___7 = nettle_buffer_grow(buffer, 1U);
      }
      }
#line 391
      if (tmp___7) {
#line 391
        tmp___8 = buffer->size;
#line 391
        (buffer->size) ++;
#line 391
        *(buffer->contents + tmp___8) = (uint8_t )'\n';
      } else {
#line 392
        return (0);
      }
    }
#line 374
    length -= 45U;
#line 374
    data += 45;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 395
  if (length) {
    {
#line 397
    text_size = (length * 8U + 4U) / 6U + 3U;
    {
#line 401
    tmp___9 = nettle_buffer_space(buffer, text_size);
    }
#line 401
    p___0 = tmp___9;
    }
#line 403
    if (! p___0) {
#line 404
      return (0);
    }
    {
    {
#line 406
    done___0 = nettle_base64_encode_update(& ctx, p___0, length, data);
    }
    {
#line 407
    tmp___10 = nettle_base64_encode_final(& ctx, p___0 + done___0);
    }
#line 407
    done___0 += tmp___10;
#line 410
    buffer->size -= text_size - done___0;
    }
#line 412
    if (buffer->size < buffer->alloc) {
#line 412
      tmp___12 = buffer->size;
#line 412
      (buffer->size) ++;
#line 412
      *(buffer->contents + tmp___12) = (uint8_t )'\n';
    } else {
      {
      {
#line 412
      tmp___11 = nettle_buffer_grow(buffer, 1U);
      }
      }
#line 412
      if (tmp___11) {
#line 412
        tmp___12 = buffer->size;
#line 412
        (buffer->size) ++;
#line 412
        *(buffer->contents + tmp___12) = (uint8_t )'\n';
      } else {
#line 413
        return (0);
      }
    }
  }
#line 416
  if (buffer->size < buffer->alloc) {
#line 416
    tmp___14 = buffer->size;
#line 416
    (buffer->size) ++;
#line 416
    *(buffer->contents + tmp___14) = (uint8_t )'=';
  } else {
    {
    {
#line 416
    tmp___13 = nettle_buffer_grow(buffer, 1U);
    }
    }
#line 416
    if (tmp___13) {
#line 416
      tmp___14 = buffer->size;
#line 416
      (buffer->size) ++;
#line 416
      *(buffer->contents + tmp___14) = (uint8_t )'=';
    } else {
#line 417
      return (0);
    }
  }
  {
  {
#line 420
  tmp___15 = nettle_buffer_space(buffer, 4U);
  }
#line 420
  p___1 = tmp___15;
  }
#line 421
  if (! p___1) {
#line 422
    return (0);
  }
  {
  {
#line 423
  nettle_base64_encode_group(p___1, crc);
  }
  {
#line 426
  tmp___16 = strlen("\nBEGIN PGP ");
  }
  {
#line 426
  tmp___17 = nettle_buffer_write(buffer, tmp___16, (uint8_t const   *)"\nBEGIN PGP ");
  }
  }
#line 426
  if (tmp___17) {
    {
    {
#line 426
    tmp___18 = strlen(tag);
    }
    {
#line 426
    tmp___19 = nettle_buffer_write(buffer, tmp___18, (uint8_t const   *)tag);
    }
    }
#line 426
    if (tmp___19) {
#line 426
      if (buffer->size < buffer->alloc) {
#line 426
        tmp___21 = buffer->size;
#line 426
        (buffer->size) ++;
#line 426
        *(buffer->contents + tmp___21) = (uint8_t )'\n';
#line 426
        tmp___22 = 1;
      } else {
        {
        {
#line 426
        tmp___20 = nettle_buffer_grow(buffer, 1U);
        }
        }
#line 426
        if (tmp___20) {
#line 426
          tmp___21 = buffer->size;
#line 426
          (buffer->size) ++;
#line 426
          *(buffer->contents + tmp___21) = (uint8_t )'\n';
#line 426
          tmp___22 = 1;
        } else {
#line 426
          tmp___22 = 0;
        }
      }
    } else {
#line 426
      tmp___22 = 0;
    }
  } else {
#line 426
    tmp___22 = 0;
  }
#line 426
  return (tmp___22);
}
}
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-internal.h"
struct nettle_cipher  const  nettle_des ;
#line 58
struct nettle_cipher  const  nettle_des3 ;
#line 60
struct nettle_cipher  const  nettle_blowfish128 ;
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.h"
int nettle_des_set_key(struct des_ctx *ctx , uint8_t const   *key ) ;
#line 68
void nettle_des_encrypt(struct des_ctx  const  *ctx , unsigned int length , uint8_t *dst ,
                        uint8_t const   *src ) ;
#line 72
void nettle_des_decrypt(struct des_ctx  const  *ctx , unsigned int length , uint8_t *dst ,
                        uint8_t const   *src ) ;
#line 77
void nettle_des_fix_parity(unsigned int length , uint8_t *dst , uint8_t const   *src ) ;
#line 93
int nettle_des3_set_key(struct des3_ctx *ctx , uint8_t const   *key ) ;
#line 96
void nettle_des3_encrypt(struct des3_ctx  const  *ctx , unsigned int length , uint8_t *dst ,
                         uint8_t const   *src ) ;
#line 100
void nettle_des3_decrypt(struct des3_ctx  const  *ctx , unsigned int length , uint8_t *dst ,
                         uint8_t const   *src ) ;
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/blowfish.h"
int nettle_blowfish_set_key(struct blowfish_ctx *ctx , unsigned int keylen , uint8_t const   *key ) ;
#line 62
void nettle_blowfish_encrypt(struct blowfish_ctx *bc , unsigned int length , uint8_t *outbuf ,
                             uint8_t const   *inbuf ) ;
#line 66
void nettle_blowfish_decrypt(struct blowfish_ctx *bc , unsigned int length , uint8_t *outbuf ,
                             uint8_t const   *inbuf ) ;
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-internal.c"
static void des_set_key_hack(void *c , unsigned int length , uint8_t const   *key ) 
{ 
  struct des_ctx *ctx ;
  uint8_t pkey[8] ;
  int tmp ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 43
  ctx = (struct des_ctx *)c;
#line 46
  if (! (length == 8U)) {
    {
    {
#line 46
    __assert_fail("length == 8", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-internal.c",
                  46U, "des_set_key_hack");
    }
    }
  }
  {
  {
#line 47
  nettle_des_fix_parity(8U, pkey, key);
  }
  {
#line 48
  tmp = nettle_des_set_key(ctx, (uint8_t const   *)(pkey));
  }
  }
#line 48
  if (! tmp) {
    {
    {
#line 49
    abort();
    }
    }
  }
#line 50
  return;
}
}
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-internal.c"
static void des3_set_key_hack(void *c , unsigned int length , uint8_t const   *key ) 
{ 
  struct des3_ctx *ctx ;
  uint8_t pkey[24] ;
  int tmp ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 55
  ctx = (struct des3_ctx *)c;
#line 58
  if (! (length == 24U)) {
    {
    {
#line 58
    __assert_fail("length == 24", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-internal.c",
                  58U, "des3_set_key_hack");
    }
    }
  }
  {
  {
#line 59
  nettle_des_fix_parity(24U, pkey, key);
  }
  {
#line 60
  tmp = nettle_des3_set_key(ctx, (uint8_t const   *)(pkey));
  }
  }
#line 60
  if (! tmp) {
    {
    {
#line 61
    abort();
    }
    }
  }
#line 62
  return;
}
}
#line 64 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-internal.c"
struct nettle_cipher  const  nettle_des  = 
#line 64
     {"des", (unsigned int )sizeof(struct des_ctx ), 8U, 8U, & des_set_key_hack, & des_set_key_hack,
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_des_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_des_decrypt)};
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-internal.c"
struct nettle_cipher  const  nettle_des3  = 
#line 73
     {"des3", (unsigned int )sizeof(struct des3_ctx ), 8U, 24U, & des3_set_key_hack,
    & des3_set_key_hack, (void (*)(void *ctx , unsigned int length , uint8_t *dst ,
                                   uint8_t const   *src ))(& nettle_des3_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_des3_decrypt)};
#line 84 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-internal.c"
struct nettle_cipher  const  nettle_blowfish128  = 
#line 84
     {"blowfish128", (unsigned int )sizeof(struct blowfish_ctx ), 8U, 16U, (void (*)(void *ctx ,
                                                                                   unsigned int length ,
                                                                                   uint8_t const   *key ))(& nettle_blowfish_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_blowfish_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_blowfish_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_blowfish_decrypt)};
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/memxor.h"
uint8_t *memxor(uint8_t *dst , uint8_t const   *src , size_t n ) ;
#line 12
uint8_t *memxor3(uint8_t *dst , uint8_t const   *a , uint8_t const   *b , size_t n ) ;
#line 16 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/memxor.c"
uint8_t *memxor(uint8_t *dst , uint8_t const   *src , size_t n ) 
{ 
  size_t i ;

  {
#line 20
  i = (size_t )0;
  {
  {
#line 20
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 20
    if (! (i < n)) {
#line 20
      goto while_break;
    }
#line 21
    *(dst + i) = (uint8_t )((int )*(dst + i) ^ (int )*(src + i));
#line 20
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 23
  return (dst);
}
}
#line 26 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/memxor.c"
uint8_t *memxor3(uint8_t *dst , uint8_t const   *a , uint8_t const   *b , size_t n ) 
{ 
  size_t i ;

  {
#line 30
  i = (size_t )0;
  {
  {
#line 30
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 30
    if (! (i < n)) {
#line 30
      goto while_break;
    }
#line 31
    *(dst + i) = (uint8_t )((int const   )*(a + i) ^ (int const   )*(b + i));
#line 30
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 33
  return (dst);
}
}
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5.h"
extern void _nettle_md5_compress(uint32_t *state , uint8_t const   *data ) ;
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5.c"
static void md5_final(struct md5_ctx *ctx ) ;
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5.c"
void nettle_md5_init(struct md5_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 46
  ctx->digest[0] = (uint32_t )1732584193;
#line 47
  ctx->digest[1] = 4023233417U;
#line 48
  ctx->digest[2] = 2562383102U;
#line 49
  ctx->digest[3] = (uint32_t )271733878;
#line 51
  tmp = (uint32_t )0;
#line 51
  ctx->count_h = tmp;
#line 51
  ctx->count_l = tmp;
#line 52
  ctx->index = 0U;
#line 53
  return;
}
}
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5.c"
void nettle_md5_update(struct md5_ctx *ctx , unsigned int length , uint8_t const   *data ) 
{ 
  unsigned int left ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 62
  if (ctx->index) {
#line 65
    left = 64U - ctx->index;
#line 66
    if (length < left) {
      {
      {
#line 68
      memcpy((void */* __restrict  */)((void *)(ctx->block + ctx->index)), (void const   */* __restrict  */)((void const   *)data),
             length);
      }
#line 69
      ctx->index += length;
      }
#line 70
      return;
    } else {
      {
      {
#line 74
      memcpy((void */* __restrict  */)((void *)(ctx->block + ctx->index)), (void const   */* __restrict  */)((void const   *)data),
             left);
      }
      {
#line 76
      _nettle_md5_compress(ctx->digest, (uint8_t const   *)(ctx->block));
      }
#line 77
      (ctx->count_l) ++;
      }
#line 77
      if (ctx->count_l) {
#line 77
        tmp = 0;
      } else {
#line 77
        tmp = 1;
      }
#line 77
      ctx->count_h += (uint32_t )tmp;
#line 79
      data += left;
#line 80
      length -= left;
    }
  }
  {
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 83
    if (! (length >= 64U)) {
#line 83
      goto while_break;
    }
    {
    {
#line 85
    _nettle_md5_compress(ctx->digest, data);
    }
#line 86
    (ctx->count_l) ++;
    }
#line 86
    if (ctx->count_l) {
#line 86
      tmp___0 = 0;
    } else {
#line 86
      tmp___0 = 1;
    }
#line 86
    ctx->count_h += (uint32_t )tmp___0;
#line 88
    data += 64;
#line 89
    length -= 64U;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 91
  tmp___1 = length;
#line 91
  ctx->index = tmp___1;
#line 91
  if (tmp___1) {
    {
    {
#line 93
    memcpy((void */* __restrict  */)((void *)(ctx->block)), (void const   */* __restrict  */)((void const   *)data),
           length);
    }
    }
  }
#line 94
  return;
}
}
#line 96 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5.c"
void nettle_md5_digest(struct md5_ctx *ctx , unsigned int length , uint8_t *digest ) 
{ 
  unsigned int i ;
  unsigned int words ;
  unsigned int leftover ;
  uint32_t word ;
  unsigned int j ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 105
  if (! (length <= 16U)) {
    {
    {
#line 105
    __assert_fail("length <= 16", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5.c",
                  105U, "nettle_md5_digest");
    }
    }
  }
  {
  {
#line 107
  md5_final(ctx);
  }
#line 109
  words = length / 4U;
#line 110
  leftover = length % 4U;
#line 113
  i = 0U;
  }
  {
  {
#line 113
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 113
    if (! (i < words)) {
#line 113
      goto while_break;
    }
    {
    {
#line 114
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 114
      *(digest + 3) = (uint8_t )((ctx->digest[i] >> 24) & 255U);
#line 114
      *(digest + 2) = (uint8_t )((ctx->digest[i] >> 16) & 255U);
#line 114
      *(digest + 1) = (uint8_t )((ctx->digest[i] >> 8) & 255U);
#line 114
      *(digest + 0) = (uint8_t )(ctx->digest[i] & 255U);
#line 114
      goto while_break___0;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 113
    i ++;
#line 113
    digest += 4;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 116
  if (leftover) {
#line 121
    if (! (i < 4U)) {
      {
      {
#line 121
      __assert_fail("i < 4", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5.c",
                    121U, "nettle_md5_digest");
      }
      }
    }
#line 124
    word = ctx->digest[i];
#line 124
    j = 0U;
    {
    {
#line 124
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;

#line 124
      if (! (j < leftover)) {
#line 124
        goto while_break___1;
      }
#line 126
      *(digest + j) = (uint8_t )(word & 255U);
#line 124
      j ++;
#line 124
      word >>= 8;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
  {
  {
#line 128
  nettle_md5_init(ctx);
  }
  }
#line 129
  return;
}
}
#line 134 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5.c"
static void md5_final(struct md5_ctx *ctx ) 
{ 
  uint32_t bitcount_high ;
  uint32_t bitcount_low ;
  unsigned int i ;
  unsigned int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 141
  i = ctx->index;
#line 145
  if (! (i < 64U)) {
    {
    {
#line 145
    __assert_fail("i < 64", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5.c",
                  145U, "md5_final");
    }
    }
  }
#line 146
  tmp = i;
#line 146
  i ++;
#line 146
  ctx->block[tmp] = (uint8_t )128;
#line 148
  if (i > 56U) {
    {
    {
#line 152
    memset((void *)(ctx->block + i), 0, 64U - i);
    }
    {
#line 154
    _nettle_md5_compress(ctx->digest, (uint8_t const   *)(ctx->block));
    }
#line 155
    i = 0U;
    }
  }
#line 157
  if (i < 56U) {
    {
    {
#line 158
    memset((void *)(ctx->block + i), 0, 56U - i);
    }
    }
  }
#line 163
  bitcount_low = (ctx->count_l << 9) | (ctx->index << 3);
#line 164
  bitcount_high = (ctx->count_h << 9) | (ctx->count_l >> 23);
  {
  {
#line 165
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 165
    *((ctx->block + 56) + 3) = (uint8_t )((bitcount_low >> 24) & 255U);
#line 165
    *((ctx->block + 56) + 2) = (uint8_t )((bitcount_low >> 16) & 255U);
#line 165
    *((ctx->block + 56) + 1) = (uint8_t )((bitcount_low >> 8) & 255U);
#line 165
    *((ctx->block + 56) + 0) = (uint8_t )(bitcount_low & 255U);
#line 165
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 166
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 166
    *((ctx->block + 60) + 3) = (uint8_t )((bitcount_high >> 24) & 255U);
#line 166
    *((ctx->block + 60) + 2) = (uint8_t )((bitcount_high >> 16) & 255U);
#line 166
    *((ctx->block + 60) + 1) = (uint8_t )((bitcount_high >> 8) & 255U);
#line 166
    *((ctx->block + 60) + 0) = (uint8_t )(bitcount_high & 255U);
#line 166
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
  {
#line 168
  _nettle_md5_compress(ctx->digest, (uint8_t const   *)(ctx->block));
  }
  }
#line 169
  return;
}
}
#line 156 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_hash  const  nettle_md5 ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5-meta.c"
struct nettle_hash  const  nettle_md5  =    {"md5", (unsigned int )sizeof(struct md5_ctx ), 16U, 64U, (void (*)(void *ctx ))(& nettle_md5_init),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *src ))(& nettle_md5_update),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst ))(& nettle_md5_digest)};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5-compat.h"
void nettle_MD5Init(MD5_CTX *ctx ) ;
#line 39
void nettle_MD5Update(MD5_CTX *ctx , unsigned char const   *data , unsigned int length ) ;
#line 40
void nettle_MD5Final(unsigned char *out , MD5_CTX *ctx ) ;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5-compat.c"
void nettle_MD5Init(MD5_CTX *ctx ) 
{ 


  {
  {
  {
#line 35
  nettle_md5_init(ctx);
  }
  }
#line 36
  return;
}
}
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5-compat.c"
void nettle_MD5Update(MD5_CTX *ctx , unsigned char const   *data , unsigned int length ) 
{ 


  {
  {
  {
#line 41
  nettle_md5_update(ctx, length, data);
  }
  }
#line 42
  return;
}
}
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md5-compat.c"
void nettle_MD5Final(unsigned char *out , MD5_CTX *ctx ) 
{ 


  {
  {
  {
#line 47
  nettle_md5_digest(ctx, 16U, out);
  }
  }
#line 48
  return;
}
}
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md4.h"
void nettle_md4_init(struct md4_ctx *ctx ) ;
#line 53
void nettle_md4_update(struct md4_ctx *ctx , unsigned int length , uint8_t const   *data ) ;
#line 58
void nettle_md4_digest(struct md4_ctx *ctx , unsigned int length , uint8_t *digest ) ;
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md4.c"
static void md4_transform(uint32_t *digest , uint32_t const   *data ) ;
#line 46
static void md4_block(struct md4_ctx *ctx , uint8_t const   *block ) ;
#line 49
static void md4_final(struct md4_ctx *ctx ) ;
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md4.c"
void nettle_md4_init(struct md4_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 56
  ctx->digest[0] = (uint32_t )1732584193;
#line 57
  ctx->digest[1] = 4023233417U;
#line 58
  ctx->digest[2] = 2562383102U;
#line 59
  ctx->digest[3] = (uint32_t )271733878;
#line 61
  tmp = (uint32_t )0;
#line 61
  ctx->count_h = tmp;
#line 61
  ctx->count_l = tmp;
#line 62
  ctx->index = 0U;
#line 63
  return;
}
}
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md4.c"
void nettle_md4_update(struct md4_ctx *ctx , unsigned int length , uint8_t const   *data ) 
{ 
  unsigned int left ;
  unsigned int tmp ;

  {
#line 70
  if (ctx->index) {
#line 73
    left = 64U - ctx->index;
#line 74
    if (length < left) {
      {
      {
#line 76
      memcpy((void */* __restrict  */)((void *)(ctx->block + ctx->index)), (void const   */* __restrict  */)((void const   *)data),
             length);
      }
#line 77
      ctx->index += length;
      }
#line 78
      return;
    } else {
      {
      {
#line 82
      memcpy((void */* __restrict  */)((void *)(ctx->block + ctx->index)), (void const   */* __restrict  */)((void const   *)data),
             left);
      }
      {
#line 83
      md4_block(ctx, (uint8_t const   *)(ctx->block));
      }
#line 84
      data += left;
#line 85
      length -= left;
      }
    }
  }
  {
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 88
    if (! (length >= 64U)) {
#line 88
      goto while_break;
    }
    {
    {
#line 90
    md4_block(ctx, data);
    }
#line 91
    data += 64;
#line 92
    length -= 64U;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 94
  tmp = length;
#line 94
  ctx->index = tmp;
#line 94
  if (tmp) {
    {
    {
#line 96
    memcpy((void */* __restrict  */)((void *)(ctx->block)), (void const   */* __restrict  */)((void const   *)data),
           length);
    }
    }
  }
#line 97
  return;
}
}
#line 99 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md4.c"
void nettle_md4_digest(struct md4_ctx *ctx , unsigned int length , uint8_t *digest ) 
{ 
  unsigned int i ;
  unsigned int words ;
  unsigned int leftover ;
  uint32_t word ;
  unsigned int j ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 108
  if (! (length <= 16U)) {
    {
    {
#line 108
    __assert_fail("length <= 16", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md4.c",
                  108U, "nettle_md4_digest");
    }
    }
  }
  {
  {
#line 110
  md4_final(ctx);
  }
#line 112
  words = length / 4U;
#line 113
  leftover = length % 4U;
#line 116
  i = 0U;
  }
  {
  {
#line 116
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 116
    if (! (i < words)) {
#line 116
      goto while_break;
    }
    {
    {
#line 117
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 117
      *(digest + 3) = (uint8_t )((ctx->digest[i] >> 24) & 255U);
#line 117
      *(digest + 2) = (uint8_t )((ctx->digest[i] >> 16) & 255U);
#line 117
      *(digest + 1) = (uint8_t )((ctx->digest[i] >> 8) & 255U);
#line 117
      *(digest + 0) = (uint8_t )(ctx->digest[i] & 255U);
#line 117
      goto while_break___0;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 116
    i ++;
#line 116
    digest += 4;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 119
  if (leftover) {
#line 124
    if (! (i < 4U)) {
      {
      {
#line 124
      __assert_fail("i < 4", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md4.c",
                    124U, "nettle_md4_digest");
      }
      }
    }
#line 127
    word = ctx->digest[i];
#line 127
    j = 0U;
    {
    {
#line 127
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;

#line 127
      if (! (j < leftover)) {
#line 127
        goto while_break___1;
      }
#line 129
      *(digest + j) = (uint8_t )(word & 255U);
#line 127
      j ++;
#line 127
      word >>= 8;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
  {
  {
#line 131
  nettle_md4_init(ctx);
  }
  }
#line 132
  return;
}
}
#line 144 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md4.c"
static void md4_transform(uint32_t *digest , uint32_t const   *data ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;

  {
#line 148
  a = *(digest + 0);
#line 149
  b = *(digest + 1);
#line 150
  c = *(digest + 2);
#line 151
  d = *(digest + 3);
#line 153
  a += ((c & b) | (d & ~ b)) + (unsigned int )*(data + 0);
#line 153
  a = (a << 3) | (a >> 29);
#line 154
  d += ((b & a) | (c & ~ a)) + (unsigned int )*(data + 1);
#line 154
  d = (d << 7) | (d >> 25);
#line 155
  c += ((a & d) | (b & ~ d)) + (unsigned int )*(data + 2);
#line 155
  c = (c << 11) | (c >> 21);
#line 156
  b += ((d & c) | (a & ~ c)) + (unsigned int )*(data + 3);
#line 156
  b = (b << 19) | (b >> 13);
#line 157
  a += ((c & b) | (d & ~ b)) + (unsigned int )*(data + 4);
#line 157
  a = (a << 3) | (a >> 29);
#line 158
  d += ((b & a) | (c & ~ a)) + (unsigned int )*(data + 5);
#line 158
  d = (d << 7) | (d >> 25);
#line 159
  c += ((a & d) | (b & ~ d)) + (unsigned int )*(data + 6);
#line 159
  c = (c << 11) | (c >> 21);
#line 160
  b += ((d & c) | (a & ~ c)) + (unsigned int )*(data + 7);
#line 160
  b = (b << 19) | (b >> 13);
#line 161
  a += ((c & b) | (d & ~ b)) + (unsigned int )*(data + 8);
#line 161
  a = (a << 3) | (a >> 29);
#line 162
  d += ((b & a) | (c & ~ a)) + (unsigned int )*(data + 9);
#line 162
  d = (d << 7) | (d >> 25);
#line 163
  c += ((a & d) | (b & ~ d)) + (unsigned int )*(data + 10);
#line 163
  c = (c << 11) | (c >> 21);
#line 164
  b += ((d & c) | (a & ~ c)) + (unsigned int )*(data + 11);
#line 164
  b = (b << 19) | (b >> 13);
#line 165
  a += ((c & b) | (d & ~ b)) + (unsigned int )*(data + 12);
#line 165
  a = (a << 3) | (a >> 29);
#line 166
  d += ((b & a) | (c & ~ a)) + (unsigned int )*(data + 13);
#line 166
  d = (d << 7) | (d >> 25);
#line 167
  c += ((a & d) | (b & ~ d)) + (unsigned int )*(data + 14);
#line 167
  c = (c << 11) | (c >> 21);
#line 168
  b += ((d & c) | (a & ~ c)) + (unsigned int )*(data + 15);
#line 168
  b = (b << 19) | (b >> 13);
#line 170
  a += ((((c & b) | (d & b)) | (c & d)) + (unsigned int )*(data + 0)) + 1518500249U;
#line 170
  a = (a << 3) | (a >> 29);
#line 171
  d += ((((b & a) | (c & a)) | (b & c)) + (unsigned int )*(data + 4)) + 1518500249U;
#line 171
  d = (d << 5) | (d >> 27);
#line 172
  c += ((((a & d) | (b & d)) | (a & b)) + (unsigned int )*(data + 8)) + 1518500249U;
#line 172
  c = (c << 9) | (c >> 23);
#line 173
  b += ((((d & c) | (a & c)) | (d & a)) + (unsigned int )*(data + 12)) + 1518500249U;
#line 173
  b = (b << 13) | (b >> 19);
#line 174
  a += ((((c & b) | (d & b)) | (c & d)) + (unsigned int )*(data + 1)) + 1518500249U;
#line 174
  a = (a << 3) | (a >> 29);
#line 175
  d += ((((b & a) | (c & a)) | (b & c)) + (unsigned int )*(data + 5)) + 1518500249U;
#line 175
  d = (d << 5) | (d >> 27);
#line 176
  c += ((((a & d) | (b & d)) | (a & b)) + (unsigned int )*(data + 9)) + 1518500249U;
#line 176
  c = (c << 9) | (c >> 23);
#line 177
  b += ((((d & c) | (a & c)) | (d & a)) + (unsigned int )*(data + 13)) + 1518500249U;
#line 177
  b = (b << 13) | (b >> 19);
#line 178
  a += ((((c & b) | (d & b)) | (c & d)) + (unsigned int )*(data + 2)) + 1518500249U;
#line 178
  a = (a << 3) | (a >> 29);
#line 179
  d += ((((b & a) | (c & a)) | (b & c)) + (unsigned int )*(data + 6)) + 1518500249U;
#line 179
  d = (d << 5) | (d >> 27);
#line 180
  c += ((((a & d) | (b & d)) | (a & b)) + (unsigned int )*(data + 10)) + 1518500249U;
#line 180
  c = (c << 9) | (c >> 23);
#line 181
  b += ((((d & c) | (a & c)) | (d & a)) + (unsigned int )*(data + 14)) + 1518500249U;
#line 181
  b = (b << 13) | (b >> 19);
#line 182
  a += ((((c & b) | (d & b)) | (c & d)) + (unsigned int )*(data + 3)) + 1518500249U;
#line 182
  a = (a << 3) | (a >> 29);
#line 183
  d += ((((b & a) | (c & a)) | (b & c)) + (unsigned int )*(data + 7)) + 1518500249U;
#line 183
  d = (d << 5) | (d >> 27);
#line 184
  c += ((((a & d) | (b & d)) | (a & b)) + (unsigned int )*(data + 11)) + 1518500249U;
#line 184
  c = (c << 9) | (c >> 23);
#line 185
  b += ((((d & c) | (a & c)) | (d & a)) + (unsigned int )*(data + 15)) + 1518500249U;
#line 185
  b = (b << 13) | (b >> 19);
#line 187
  a += (((b ^ c) ^ d) + (unsigned int )*(data + 0)) + 1859775393U;
#line 187
  a = (a << 3) | (a >> 29);
#line 188
  d += (((a ^ b) ^ c) + (unsigned int )*(data + 8)) + 1859775393U;
#line 188
  d = (d << 9) | (d >> 23);
#line 189
  c += (((d ^ a) ^ b) + (unsigned int )*(data + 4)) + 1859775393U;
#line 189
  c = (c << 11) | (c >> 21);
#line 190
  b += (((c ^ d) ^ a) + (unsigned int )*(data + 12)) + 1859775393U;
#line 190
  b = (b << 15) | (b >> 17);
#line 191
  a += (((b ^ c) ^ d) + (unsigned int )*(data + 2)) + 1859775393U;
#line 191
  a = (a << 3) | (a >> 29);
#line 192
  d += (((a ^ b) ^ c) + (unsigned int )*(data + 10)) + 1859775393U;
#line 192
  d = (d << 9) | (d >> 23);
#line 193
  c += (((d ^ a) ^ b) + (unsigned int )*(data + 6)) + 1859775393U;
#line 193
  c = (c << 11) | (c >> 21);
#line 194
  b += (((c ^ d) ^ a) + (unsigned int )*(data + 14)) + 1859775393U;
#line 194
  b = (b << 15) | (b >> 17);
#line 195
  a += (((b ^ c) ^ d) + (unsigned int )*(data + 1)) + 1859775393U;
#line 195
  a = (a << 3) | (a >> 29);
#line 196
  d += (((a ^ b) ^ c) + (unsigned int )*(data + 9)) + 1859775393U;
#line 196
  d = (d << 9) | (d >> 23);
#line 197
  c += (((d ^ a) ^ b) + (unsigned int )*(data + 5)) + 1859775393U;
#line 197
  c = (c << 11) | (c >> 21);
#line 198
  b += (((c ^ d) ^ a) + (unsigned int )*(data + 13)) + 1859775393U;
#line 198
  b = (b << 15) | (b >> 17);
#line 199
  a += (((b ^ c) ^ d) + (unsigned int )*(data + 3)) + 1859775393U;
#line 199
  a = (a << 3) | (a >> 29);
#line 200
  d += (((a ^ b) ^ c) + (unsigned int )*(data + 11)) + 1859775393U;
#line 200
  d = (d << 9) | (d >> 23);
#line 201
  c += (((d ^ a) ^ b) + (unsigned int )*(data + 7)) + 1859775393U;
#line 201
  c = (c << 11) | (c >> 21);
#line 202
  b += (((c ^ d) ^ a) + (unsigned int )*(data + 15)) + 1859775393U;
#line 202
  b = (b << 15) | (b >> 17);
#line 204
  *(digest + 0) += a;
#line 205
  *(digest + 1) += b;
#line 206
  *(digest + 2) += c;
#line 207
  *(digest + 3) += d;
#line 208
  return;
}
}
#line 210 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md4.c"
static void md4_block(struct md4_ctx *ctx , uint8_t const   *block ) 
{ 
  uint32_t data[16] ;
  unsigned int i ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 217
  (ctx->count_l) ++;
#line 217
  if (! ctx->count_l) {
#line 218
    (ctx->count_h) ++;
  }
#line 221
  i = 0U;
  {
  {
#line 221
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 221
    if (! (i < 16U)) {
#line 221
      goto while_break;
    }
#line 222
    data[i] = ((((uint32_t )*(block + 3) << 24) | ((uint32_t )*(block + 2) << 16)) | ((uint32_t )*(block + 1) << 8)) | (uint32_t )*(block + 0);
#line 221
    i ++;
#line 221
    block += 4;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 224
  md4_transform(ctx->digest, (uint32_t const   *)(data));
  }
  }
#line 225
  return;
}
}
#line 230 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md4.c"
static void md4_final(struct md4_ctx *ctx ) 
{ 
  uint32_t data[16] ;
  unsigned int i ;
  unsigned int words ;
  unsigned int tmp ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 237
  i = ctx->index;
#line 241
  if (! (i < 64U)) {
    {
    {
#line 241
    __assert_fail("i < 64", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md4.c",
                  241U, "md4_final");
    }
    }
  }
#line 242
  tmp = i;
#line 242
  i ++;
#line 242
  ctx->block[tmp] = (uint8_t )128;
  {
  {
#line 245
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 245
    if (! (i & 3U)) {
#line 245
      goto while_break;
    }
#line 246
    ctx->block[i] = (uint8_t )0;
#line 245
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 249
  words = i >> 2;
#line 250
  i = 0U;
  {
  {
#line 250
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 250
    if (! (i < words)) {
#line 250
      goto while_break___0;
    }
#line 251
    data[i] = ((((uint32_t )*((ctx->block + 4U * i) + 3) << 24) | ((uint32_t )*((ctx->block + 4U * i) + 2) << 16)) | ((uint32_t )*((ctx->block + 4U * i) + 1) << 8)) | (uint32_t )*((ctx->block + 4U * i) + 0);
#line 250
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: ;
#line 253
  if (words > 14U) {
#line 256
    i = words;
    {
    {
#line 256
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;

#line 256
      if (! (i < 16U)) {
#line 256
        goto while_break___1;
      }
#line 257
      data[i] = (uint32_t )0;
#line 256
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
    {
    {
#line 258
    md4_transform(ctx->digest, (uint32_t const   *)(data));
    }
#line 259
    i = 0U;
    }
    {
    {
#line 259
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;

#line 259
      if (! (i < 14U)) {
#line 259
        goto while_break___2;
      }
#line 260
      data[i] = (uint32_t )0;
#line 259
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
  } else {
#line 263
    i = words;
    {
    {
#line 263
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;

#line 263
      if (! (i < 14U)) {
#line 263
        goto while_break___3;
      }
#line 264
      data[i] = (uint32_t )0;
#line 263
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: ;
  }
  {
#line 269
  data[15] = (ctx->count_h << 9) | (ctx->count_l >> 23);
#line 270
  data[14] = (ctx->count_l << 9) | (ctx->index << 3);
  {
#line 271
  md4_transform(ctx->digest, (uint32_t const   *)(data));
  }
  }
#line 272
  return;
}
}
#line 155 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_hash  const  nettle_md4 ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md4-meta.c"
struct nettle_hash  const  nettle_md4  =    {"md4", (unsigned int )sizeof(struct md4_ctx ), 16U, 64U, (void (*)(void *ctx ))(& nettle_md4_init),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *src ))(& nettle_md4_update),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst ))(& nettle_md4_digest)};
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md2.h"
void nettle_md2_init(struct md2_ctx *ctx ) ;
#line 50
void nettle_md2_update(struct md2_ctx *ctx , unsigned int length , uint8_t const   *data ) ;
#line 55
void nettle_md2_digest(struct md2_ctx *ctx , unsigned int length , uint8_t *digest ) ;
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md2.c"
static uint8_t const   S[256]  = 
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md2.c"
  {      (uint8_t const   )41,      (uint8_t const   )46,      (uint8_t const   )67,      (uint8_t const   )201, 
        (uint8_t const   )162,      (uint8_t const   )216,      (uint8_t const   )124,      (uint8_t const   )1, 
        (uint8_t const   )61,      (uint8_t const   )54,      (uint8_t const   )84,      (uint8_t const   )161, 
        (uint8_t const   )236,      (uint8_t const   )240,      (uint8_t const   )6,      (uint8_t const   )19, 
        (uint8_t const   )98,      (uint8_t const   )167,      (uint8_t const   )5,      (uint8_t const   )243, 
        (uint8_t const   )192,      (uint8_t const   )199,      (uint8_t const   )115,      (uint8_t const   )140, 
        (uint8_t const   )152,      (uint8_t const   )147,      (uint8_t const   )43,      (uint8_t const   )217, 
        (uint8_t const   )188,      (uint8_t const   )76,      (uint8_t const   )130,      (uint8_t const   )202, 
        (uint8_t const   )30,      (uint8_t const   )155,      (uint8_t const   )87,      (uint8_t const   )60, 
        (uint8_t const   )253,      (uint8_t const   )212,      (uint8_t const   )224,      (uint8_t const   )22, 
        (uint8_t const   )103,      (uint8_t const   )66,      (uint8_t const   )111,      (uint8_t const   )24, 
        (uint8_t const   )138,      (uint8_t const   )23,      (uint8_t const   )229,      (uint8_t const   )18, 
        (uint8_t const   )190,      (uint8_t const   )78,      (uint8_t const   )196,      (uint8_t const   )214, 
        (uint8_t const   )218,      (uint8_t const   )158,      (uint8_t const   )222,      (uint8_t const   )73, 
        (uint8_t const   )160,      (uint8_t const   )251,      (uint8_t const   )245,      (uint8_t const   )142, 
        (uint8_t const   )187,      (uint8_t const   )47,      (uint8_t const   )238,      (uint8_t const   )122, 
        (uint8_t const   )169,      (uint8_t const   )104,      (uint8_t const   )121,      (uint8_t const   )145, 
        (uint8_t const   )21,      (uint8_t const   )178,      (uint8_t const   )7,      (uint8_t const   )63, 
        (uint8_t const   )148,      (uint8_t const   )194,      (uint8_t const   )16,      (uint8_t const   )137, 
        (uint8_t const   )11,      (uint8_t const   )34,      (uint8_t const   )95,      (uint8_t const   )33, 
        (uint8_t const   )128,      (uint8_t const   )127,      (uint8_t const   )93,      (uint8_t const   )154, 
        (uint8_t const   )90,      (uint8_t const   )144,      (uint8_t const   )50,      (uint8_t const   )39, 
        (uint8_t const   )53,      (uint8_t const   )62,      (uint8_t const   )204,      (uint8_t const   )231, 
        (uint8_t const   )191,      (uint8_t const   )247,      (uint8_t const   )151,      (uint8_t const   )3, 
        (uint8_t const   )255,      (uint8_t const   )25,      (uint8_t const   )48,      (uint8_t const   )179, 
        (uint8_t const   )72,      (uint8_t const   )165,      (uint8_t const   )181,      (uint8_t const   )209, 
        (uint8_t const   )215,      (uint8_t const   )94,      (uint8_t const   )146,      (uint8_t const   )42, 
        (uint8_t const   )172,      (uint8_t const   )86,      (uint8_t const   )170,      (uint8_t const   )198, 
        (uint8_t const   )79,      (uint8_t const   )184,      (uint8_t const   )56,      (uint8_t const   )210, 
        (uint8_t const   )150,      (uint8_t const   )164,      (uint8_t const   )125,      (uint8_t const   )182, 
        (uint8_t const   )118,      (uint8_t const   )252,      (uint8_t const   )107,      (uint8_t const   )226, 
        (uint8_t const   )156,      (uint8_t const   )116,      (uint8_t const   )4,      (uint8_t const   )241, 
        (uint8_t const   )69,      (uint8_t const   )157,      (uint8_t const   )112,      (uint8_t const   )89, 
        (uint8_t const   )100,      (uint8_t const   )113,      (uint8_t const   )135,      (uint8_t const   )32, 
        (uint8_t const   )134,      (uint8_t const   )91,      (uint8_t const   )207,      (uint8_t const   )101, 
        (uint8_t const   )230,      (uint8_t const   )45,      (uint8_t const   )168,      (uint8_t const   )2, 
        (uint8_t const   )27,      (uint8_t const   )96,      (uint8_t const   )37,      (uint8_t const   )173, 
        (uint8_t const   )174,      (uint8_t const   )176,      (uint8_t const   )185,      (uint8_t const   )246, 
        (uint8_t const   )28,      (uint8_t const   )70,      (uint8_t const   )97,      (uint8_t const   )105, 
        (uint8_t const   )52,      (uint8_t const   )64,      (uint8_t const   )126,      (uint8_t const   )15, 
        (uint8_t const   )85,      (uint8_t const   )71,      (uint8_t const   )163,      (uint8_t const   )35, 
        (uint8_t const   )221,      (uint8_t const   )81,      (uint8_t const   )175,      (uint8_t const   )58, 
        (uint8_t const   )195,      (uint8_t const   )92,      (uint8_t const   )249,      (uint8_t const   )206, 
        (uint8_t const   )186,      (uint8_t const   )197,      (uint8_t const   )234,      (uint8_t const   )38, 
        (uint8_t const   )44,      (uint8_t const   )83,      (uint8_t const   )13,      (uint8_t const   )110, 
        (uint8_t const   )133,      (uint8_t const   )40,      (uint8_t const   )132,      (uint8_t const   )9, 
        (uint8_t const   )211,      (uint8_t const   )223,      (uint8_t const   )205,      (uint8_t const   )244, 
        (uint8_t const   )65,      (uint8_t const   )129,      (uint8_t const   )77,      (uint8_t const   )82, 
        (uint8_t const   )106,      (uint8_t const   )220,      (uint8_t const   )55,      (uint8_t const   )200, 
        (uint8_t const   )108,      (uint8_t const   )193,      (uint8_t const   )171,      (uint8_t const   )250, 
        (uint8_t const   )36,      (uint8_t const   )225,      (uint8_t const   )123,      (uint8_t const   )8, 
        (uint8_t const   )12,      (uint8_t const   )189,      (uint8_t const   )177,      (uint8_t const   )74, 
        (uint8_t const   )120,      (uint8_t const   )136,      (uint8_t const   )149,      (uint8_t const   )139, 
        (uint8_t const   )227,      (uint8_t const   )99,      (uint8_t const   )232,      (uint8_t const   )109, 
        (uint8_t const   )233,      (uint8_t const   )203,      (uint8_t const   )213,      (uint8_t const   )254, 
        (uint8_t const   )59,      (uint8_t const   )0,      (uint8_t const   )29,      (uint8_t const   )57, 
        (uint8_t const   )242,      (uint8_t const   )239,      (uint8_t const   )183,      (uint8_t const   )14, 
        (uint8_t const   )102,      (uint8_t const   )88,      (uint8_t const   )208,      (uint8_t const   )228, 
        (uint8_t const   )166,      (uint8_t const   )119,      (uint8_t const   )114,      (uint8_t const   )248, 
        (uint8_t const   )235,      (uint8_t const   )117,      (uint8_t const   )75,      (uint8_t const   )10, 
        (uint8_t const   )49,      (uint8_t const   )68,      (uint8_t const   )80,      (uint8_t const   )180, 
        (uint8_t const   )143,      (uint8_t const   )237,      (uint8_t const   )31,      (uint8_t const   )26, 
        (uint8_t const   )219,      (uint8_t const   )153,      (uint8_t const   )141,      (uint8_t const   )51, 
        (uint8_t const   )159,      (uint8_t const   )17,      (uint8_t const   )131,      (uint8_t const   )20};
#line 76 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md2.c"
static void md2_transform(struct md2_ctx *ctx , uint8_t const   *data ) 
{ 
  unsigned int i ;
  uint8_t t ;
  uint8_t tmp ;
  unsigned int j ;
  uint8_t tmp___0 ;

  {
  {
  {
#line 82
  memcpy((void */* __restrict  */)((void *)(ctx->X + 16)), (void const   */* __restrict  */)((void const   *)data),
         (size_t )16);
  }
#line 84
  i = 0U;
#line 84
  t = ctx->C[15];
  }
  {
  {
#line 84
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 84
    if (! (i < 16U)) {
#line 84
      goto while_break;
    }
#line 87
    ctx->X[32U + i] = (uint8_t )((int )ctx->X[i] ^ (int )ctx->X[16U + i]);
#line 89
    tmp = (uint8_t )((int )ctx->C[i] ^ (int )S[(int const   )*(data + i) ^ (int const   )t]);
#line 89
    ctx->C[i] = tmp;
#line 89
    t = tmp;
#line 84
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 91
  t = (uint8_t )0;
#line 91
  i = (unsigned int )t;
  {
  {
#line 91
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 91
    if (! (i < 18U)) {
#line 91
      goto while_break___0;
    }
#line 96
    j = 0U;
    {
    {
#line 96
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;

#line 96
      if (! (j < 48U)) {
#line 96
        goto while_break___1;
      }
#line 97
      tmp___0 = (uint8_t )((int )ctx->X[j] ^ (int )S[t]);
#line 97
      ctx->X[j] = tmp___0;
#line 97
      t = tmp___0;
#line 96
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 91
    t = (uint8_t )(((unsigned int )t + i) & 255U);
#line 91
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 99
  return;
}
}
#line 111 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md2.c"
void nettle_md2_init(struct md2_ctx *ctx ) 
{ 


  {
  {
  {
#line 114
  memset((void *)ctx, 0, (size_t )sizeof(*ctx));
  }
  }
#line 115
  return;
}
}
#line 117 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md2.c"
void nettle_md2_update(struct md2_ctx *ctx , unsigned int length , uint8_t const   *data ) 
{ 
  unsigned int left ;
  unsigned int tmp ;

  {
#line 122
  if (ctx->index) {
#line 125
    left = 16U - ctx->index;
#line 126
    if (length < left) {
      {
      {
#line 128
      memcpy((void */* __restrict  */)((void *)(ctx->block + ctx->index)), (void const   */* __restrict  */)((void const   *)data),
             length);
      }
#line 129
      ctx->index += length;
      }
#line 130
      return;
    } else {
      {
      {
#line 134
      memcpy((void */* __restrict  */)((void *)(ctx->block + ctx->index)), (void const   */* __restrict  */)((void const   *)data),
             left);
      }
      {
#line 135
      md2_transform(ctx, (uint8_t const   *)(ctx->block));
      }
#line 136
      data += left;
#line 137
      length -= left;
      }
    }
  }
  {
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 140
    if (! (length >= 16U)) {
#line 140
      goto while_break;
    }
    {
    {
#line 142
    md2_transform(ctx, data);
    }
#line 143
    data += 16;
#line 144
    length -= 16U;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 146
  tmp = length;
#line 146
  ctx->index = tmp;
#line 146
  if (tmp) {
    {
    {
#line 148
    memcpy((void */* __restrict  */)((void *)(ctx->block)), (void const   */* __restrict  */)((void const   *)data),
           length);
    }
    }
  }
#line 149
  return;
}
}
#line 151 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md2.c"
void nettle_md2_digest(struct md2_ctx *ctx , unsigned int length , uint8_t *digest ) 
{ 
  unsigned int left ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 158
  if (! (length <= 16U)) {
    {
    {
#line 158
    __assert_fail("length <= 16", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md2.c",
                  158U, "nettle_md2_digest");
    }
    }
  }
  {
#line 160
  left = 16U - ctx->index;
  {
#line 161
  memset((void *)(ctx->block + ctx->index), (int )left, left);
  }
  {
#line 162
  md2_transform(ctx, (uint8_t const   *)(ctx->block));
  }
  {
#line 164
  md2_transform(ctx, (uint8_t const   *)(ctx->C));
  }
  {
#line 165
  memcpy((void */* __restrict  */)((void *)digest), (void const   */* __restrict  */)((void const   *)(ctx->X)),
         length);
  }
  {
#line 166
  nettle_md2_init(ctx);
  }
  }
#line 167
  return;
}
}
#line 154 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_hash  const  nettle_md2 ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/md2-meta.c"
struct nettle_hash  const  nettle_md2  =    {"md2", (unsigned int )sizeof(struct md2_ctx ), 16U, 16U, (void (*)(void *ctx ))(& nettle_md2_init),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *src ))(& nettle_md2_update),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst ))(& nettle_md2_digest)};
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/knuth-lfib.h"
void nettle_knuth_lfib_init(struct knuth_lfib_ctx *ctx , uint32_t seed ) ;
#line 54
uint32_t nettle_knuth_lfib_get(struct knuth_lfib_ctx *ctx ) ;
#line 58
void nettle_knuth_lfib_get_array(struct knuth_lfib_ctx *ctx , unsigned int n , uint32_t *a ) ;
#line 63
void nettle_knuth_lfib_random(struct knuth_lfib_ctx *ctx , unsigned int n , uint8_t *dst ) ;
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/knuth-lfib.c"
void nettle_knuth_lfib_init(struct knuth_lfib_ctx *ctx , uint32_t seed ) 
{ 
  uint32_t t ;
  uint32_t j ;
  uint32_t x[199] ;
  uint32_t ss ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 55
  ss = (uint32_t )((unsigned long )(seed + 2U) & ((1UL << 30) - 2UL));
#line 57
  j = (uint32_t )0;
  {
  {
#line 57
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 57
    if (! (j < 100U)) {
#line 57
      goto while_break;
    }
#line 59
    x[j] = ss;
#line 60
    ss <<= 1;
#line 60
    if ((unsigned long )ss >= 1UL << 30) {
#line 60
      ss = (uint32_t )((unsigned long )ss - ((1UL << 30) - 2UL));
    }
#line 57
    j ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 62
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 62
    if (! (j < 199U)) {
#line 62
      goto while_break___0;
    }
#line 63
    x[j] = (uint32_t )0;
#line 62
    j ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___0: 
#line 65
  (x[1]) ++;
#line 67
  ss = (uint32_t )((unsigned long )seed & ((1UL << 30) - 1UL));
#line 68
  t = (uint32_t )69;
  {
  {
#line 68
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;

#line 68
    if (! t) {
#line 68
      goto while_break___1;
    }
#line 70
    j = (uint32_t )99;
    {
    {
#line 70
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;

#line 70
      if (! (j > 0U)) {
#line 70
        goto while_break___2;
      }
#line 71
      x[j + j] = x[j];
#line 70
      j --;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___2: 
#line 72
    j = (uint32_t )198;
    {
    {
#line 72
    while (1) {
      while_continue___12: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;

#line 72
      if (! (j > 63U)) {
#line 72
        goto while_break___3;
      }
#line 73
      x[199U - j] = x[j] & 4294967294U;
#line 72
      j -= 2U;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___3: 
#line 74
    j = (uint32_t )198;
    {
    {
#line 74
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;

#line 74
      if (! (j >= 100U)) {
#line 74
        goto while_break___4;
      }
#line 75
      if (x[j] & 1U) {
#line 77
        x[j - 63U] = (uint32_t )((unsigned long )(x[j - 63U] - x[j]) & ((1UL << 30) - 1UL));
#line 78
        x[j - 100U] = (uint32_t )((unsigned long )(x[j - 100U] - x[j]) & ((1UL << 30) - 1UL));
      }
#line 74
      j --;
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: ;
#line 80
    if (ss & 1U) {
#line 82
      j = (uint32_t )100;
      {
      {
#line 82
      while (1) {
        while_continue___14: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;

#line 82
        if (! (j > 0U)) {
#line 82
          goto while_break___5;
        }
#line 83
        x[j] = x[j - 1U];
#line 82
        j --;
      }
      while_break___23: /* CIL Label */ ;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___5: 
#line 84
      x[0] = x[100];
#line 85
      if (x[100] & 1U) {
#line 86
        x[37] = (uint32_t )((unsigned long )(x[37] - x[100]) & ((1UL << 30) - 1UL));
      }
    }
#line 88
    if (ss) {
#line 89
      ss >>= 1;
    } else {
#line 91
      t --;
    }
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___1: 
#line 93
  j = (uint32_t )0;
  {
  {
#line 93
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;

#line 93
    if (! (j < 37U)) {
#line 93
      goto while_break___6;
    }
#line 94
    ctx->x[(j + 100U) - 37U] = x[j];
#line 93
    j ++;
  }
  while_break___24: /* CIL Label */ ;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___6: ;
  {
  {
#line 95
  while (1) {
    while_continue___16: /* CIL Label */ ;
    while_continue___7: /* CIL Label */ ;

#line 95
    if (! (j < 100U)) {
#line 95
      goto while_break___7;
    }
#line 96
    ctx->x[j - 37U] = x[j];
#line 95
    j ++;
  }
  while_break___25: /* CIL Label */ ;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___7: 
#line 98
  ctx->index = 0U;
#line 99
  return;
}
}
#line 102 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/knuth-lfib.c"
uint32_t nettle_knuth_lfib_get(struct knuth_lfib_ctx *ctx ) 
{ 
  uint32_t value ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 106
  if (! (ctx->index < 100U)) {
    {
    {
#line 106
    __assert_fail("ctx->index < 100", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/knuth-lfib.c",
                  106U, "nettle_knuth_lfib_get");
    }
    }
  }
#line 108
  value = ctx->x[ctx->index];
#line 109
  ctx->x[ctx->index] -= ctx->x[((ctx->index + 100U) - 37U) % 100U];
#line 110
  ctx->x[ctx->index] = (uint32_t )((unsigned long )ctx->x[ctx->index] & ((1UL << 30) - 1UL));
#line 112
  ctx->index = (ctx->index + 1U) % 100U;
#line 114
  return (value);
}
}
#line 118 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/knuth-lfib.c"
void nettle_knuth_lfib_get_array(struct knuth_lfib_ctx *ctx , unsigned int n , uint32_t *a ) 
{ 
  unsigned int i ;

  {
#line 124
  i = 0U;
  {
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 124
    if (! (i < n)) {
#line 124
      goto while_break;
    }
    {
    {
#line 125
    *(a + i) = nettle_knuth_lfib_get(ctx);
    }
#line 124
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 126
  return;
}
}
#line 129 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/knuth-lfib.c"
void nettle_knuth_lfib_random(struct knuth_lfib_ctx *ctx , unsigned int n , uint8_t *dst ) 
{ 
  uint32_t value ;
  uint32_t tmp ;
  uint32_t value___0 ;
  uint32_t tmp___0 ;
  uint8_t *tmp___1 ;

  {
  {
  {
#line 136
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 136
    if (! (n >= 3U)) {
#line 136
      goto while_break;
    }
    {
    {
#line 138
    tmp = nettle_knuth_lfib_get(ctx);
    }
#line 138
    value = tmp;
#line 142
    value ^= value >> 24;
    }
    {
    {
#line 144
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 144
      *(dst + 0) = (uint8_t )((value >> 16) & 255U);
#line 144
      *(dst + 1) = (uint8_t )((value >> 8) & 255U);
#line 144
      *(dst + 2) = (uint8_t )(value & 255U);
#line 144
      goto while_break___0;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 136
    n -= 3U;
#line 136
    dst += 3;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 146
  if (n) {
    {
    {
#line 149
    tmp___0 = nettle_knuth_lfib_get(ctx);
    }
#line 149
    value___0 = tmp___0;
    }
#line 152
    if (n == 1U) {
#line 152
      goto case_1;
    }
#line 155
    if (n == 2U) {
#line 155
      goto case_2;
    }
#line 158
    goto switch_default;
    case_1: 
#line 153
    tmp___1 = dst;
#line 153
    dst ++;
#line 153
    *tmp___1 = (uint8_t )(value___0 & 255U);
#line 154
    goto switch_break;
    case_2: 
    {
    {
#line 156
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 156
      *(dst + 0) = (uint8_t )((value___0 >> 8) & 255U);
#line 156
      *(dst + 1) = (uint8_t )(value___0 & 255U);
#line 156
      goto while_break___1;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
#line 157
    goto switch_break;
    switch_default: 
    {
    {
#line 159
    abort();
    }
    }
    switch_break: ;
  }
#line 162
  return;
}
}
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac.h"
void nettle_hmac_set_key(void *outer , void *inner , void *state , struct nettle_hash  const  *hash___2 ,
                         unsigned int key_length , uint8_t const   *key ) ;
#line 55
void nettle_hmac_update(void *state , struct nettle_hash  const  *hash___2 , unsigned int length ,
                        uint8_t const   *data ) ;
#line 60
void nettle_hmac_digest(void const   *outer , void const   *inner , void *state ,
                        struct nettle_hash  const  *hash___2 , unsigned int length ,
                        uint8_t *dst ) ;
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac.c"
void nettle_hmac_set_key(void *outer , void *inner , void *state , struct nettle_hash  const  *hash___2 ,
                         unsigned int key_length , uint8_t const   *key ) 
{ 
  uint8_t *pad___0 ;
  void *tmp ;
  uint8_t *digest ;
  void *tmp___0 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 47
  tmp = __builtin_alloca(sizeof(*pad___0) * (unsigned long )hash___2->block_size);
  }
#line 47
  pad___0 = (uint8_t *)tmp;
  {
#line 49
  (*(hash___2->init))(outer);
  }
  {
#line 50
  (*(hash___2->init))(inner);
  }
  }
#line 52
  if (key_length > (unsigned int )hash___2->block_size) {
    {
    {
#line 58
    tmp___0 = __builtin_alloca(sizeof(*digest) * (unsigned long )hash___2->digest_size);
    }
#line 58
    digest = (uint8_t *)tmp___0;
    {
#line 60
    (*(hash___2->init))(state);
    }
    {
#line 61
    (*(hash___2->update))(state, key_length, key);
    }
    {
#line 62
    (*(hash___2->digest))(state, (unsigned int )hash___2->digest_size, digest);
    }
#line 64
    key = (uint8_t const   *)digest;
#line 65
    key_length = (unsigned int )hash___2->digest_size;
    }
  }
#line 68
  if (! (key_length <= (unsigned int )hash___2->block_size)) {
    {
    {
#line 68
    __assert_fail("key_length <= hash->block_size", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac.c",
                  68U, "nettle_hmac_set_key");
    }
    }
  }
  {
  {
#line 70
  memset((void *)pad___0, 92, (size_t )hash___2->block_size);
  }
  {
#line 71
  memxor(pad___0, key, key_length);
  }
  {
#line 73
  (*(hash___2->update))(outer, (unsigned int )hash___2->block_size, (uint8_t const   *)pad___0);
  }
  {
#line 75
  memset((void *)pad___0, 54, (size_t )hash___2->block_size);
  }
  {
#line 76
  memxor(pad___0, key, key_length);
  }
  {
#line 78
  (*(hash___2->update))(inner, (unsigned int )hash___2->block_size, (uint8_t const   *)pad___0);
  }
  {
#line 80
  memcpy((void */* __restrict  */)state, (void const   */* __restrict  */)((void const   *)inner),
         (size_t )hash___2->context_size);
  }
  }
#line 81
  return;
}
}
#line 83 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac.c"
void nettle_hmac_update(void *state , struct nettle_hash  const  *hash___2 , unsigned int length ,
                        uint8_t const   *data ) 
{ 


  {
  {
  {
#line 88
  (*(hash___2->update))(state, length, data);
  }
  }
#line 89
  return;
}
}
#line 91 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac.c"
void nettle_hmac_digest(void const   *outer , void const   *inner , void *state ,
                        struct nettle_hash  const  *hash___2 , unsigned int length ,
                        uint8_t *dst ) 
{ 
  uint8_t *digest ;
  void *tmp ;

  {
  {
  {
#line 97
  tmp = __builtin_alloca(sizeof(*digest) * (unsigned long )hash___2->digest_size);
  }
#line 97
  digest = (uint8_t *)tmp;
  {
#line 99
  (*(hash___2->digest))(state, (unsigned int )hash___2->digest_size, digest);
  }
  {
#line 101
  memcpy((void */* __restrict  */)state, (void const   */* __restrict  */)outer, (size_t )hash___2->context_size);
  }
  {
#line 103
  (*(hash___2->update))(state, (unsigned int )hash___2->digest_size, (uint8_t const   *)digest);
  }
  {
#line 104
  (*(hash___2->digest))(state, length, dst);
  }
  {
#line 106
  memcpy((void */* __restrict  */)state, (void const   */* __restrict  */)inner, (size_t )hash___2->context_size);
  }
  }
#line 107
  return;
}
}
#line 113 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac.h"
void nettle_hmac_sha256_set_key(struct hmac_sha256_ctx *ctx , unsigned int key_length ,
                                uint8_t const   *key ) ;
#line 117
void nettle_hmac_sha256_update(struct hmac_sha256_ctx *ctx , unsigned int length ,
                               uint8_t const   *data ) ;
#line 121
void nettle_hmac_sha256_digest(struct hmac_sha256_ctx *ctx , unsigned int length ,
                               uint8_t *digest ) ;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac-sha256.c"
void nettle_hmac_sha256_set_key(struct hmac_sha256_ctx *ctx , unsigned int key_length ,
                                uint8_t const   *key ) 
{ 


  {
  {
  {
#line 36
  nettle_hmac_set_key((void *)(& ctx->outer), (void *)(& ctx->inner), (void *)(& ctx->state),
                      & nettle_sha256, key_length, key);
  }
  }
#line 37
  return;
}
}
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac-sha256.c"
void nettle_hmac_sha256_update(struct hmac_sha256_ctx *ctx , unsigned int length ,
                               uint8_t const   *data ) 
{ 


  {
  {
  {
#line 43
  nettle_sha256_update(& ctx->state, length, data);
  }
  }
#line 44
  return;
}
}
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac-sha256.c"
void nettle_hmac_sha256_digest(struct hmac_sha256_ctx *ctx , unsigned int length ,
                               uint8_t *digest ) 
{ 


  {
  {
  {
#line 50
  nettle_hmac_digest((void const   *)(& ctx->outer), (void const   *)(& ctx->inner),
                     (void *)(& ctx->state), & nettle_sha256, length, digest);
  }
  }
#line 51
  return;
}
}
#line 98 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac.h"
void nettle_hmac_sha1_set_key(struct hmac_sha1_ctx *ctx , unsigned int key_length ,
                              uint8_t const   *key ) ;
#line 102
void nettle_hmac_sha1_update(struct hmac_sha1_ctx *ctx , unsigned int length , uint8_t const   *data ) ;
#line 106
void nettle_hmac_sha1_digest(struct hmac_sha1_ctx *ctx , unsigned int length , uint8_t *digest ) ;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac-sha1.c"
void nettle_hmac_sha1_set_key(struct hmac_sha1_ctx *ctx , unsigned int key_length ,
                              uint8_t const   *key ) 
{ 


  {
  {
  {
#line 36
  nettle_hmac_set_key((void *)(& ctx->outer), (void *)(& ctx->inner), (void *)(& ctx->state),
                      & nettle_sha1, key_length, key);
  }
  }
#line 37
  return;
}
}
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac-sha1.c"
void nettle_hmac_sha1_update(struct hmac_sha1_ctx *ctx , unsigned int length , uint8_t const   *data ) 
{ 


  {
  {
  {
#line 43
  nettle_sha1_update(& ctx->state, length, data);
  }
  }
#line 44
  return;
}
}
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac-sha1.c"
void nettle_hmac_sha1_digest(struct hmac_sha1_ctx *ctx , unsigned int length , uint8_t *digest ) 
{ 


  {
  {
  {
#line 50
  nettle_hmac_digest((void const   *)(& ctx->outer), (void const   *)(& ctx->inner),
                     (void *)(& ctx->state), & nettle_sha1, length, digest);
  }
  }
#line 51
  return;
}
}
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac.h"
void nettle_hmac_md5_set_key(struct hmac_md5_ctx *ctx , unsigned int key_length ,
                             uint8_t const   *key ) ;
#line 86
void nettle_hmac_md5_update(struct hmac_md5_ctx *ctx , unsigned int length , uint8_t const   *data ) ;
#line 90
void nettle_hmac_md5_digest(struct hmac_md5_ctx *ctx , unsigned int length , uint8_t *digest ) ;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac-md5.c"
void nettle_hmac_md5_set_key(struct hmac_md5_ctx *ctx , unsigned int key_length ,
                             uint8_t const   *key ) 
{ 


  {
  {
  {
#line 36
  nettle_hmac_set_key((void *)(& ctx->outer), (void *)(& ctx->inner), (void *)(& ctx->state),
                      & nettle_md5, key_length, key);
  }
  }
#line 37
  return;
}
}
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac-md5.c"
void nettle_hmac_md5_update(struct hmac_md5_ctx *ctx , unsigned int length , uint8_t const   *data ) 
{ 


  {
  {
  {
#line 43
  nettle_md5_update(& ctx->state, length, data);
  }
  }
#line 44
  return;
}
}
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/hmac-md5.c"
void nettle_hmac_md5_digest(struct hmac_md5_ctx *ctx , unsigned int length , uint8_t *digest ) 
{ 


  {
  {
  {
#line 50
  nettle_hmac_digest((void const   *)(& ctx->outer), (void const   *)(& ctx->inner),
                     (void *)(& ctx->state), & nettle_md5, length, digest);
  }
  }
#line 51
  return;
}
}
#line 107 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.h"
void nettle_dsa_public_key_init(struct dsa_public_key *key ) ;
#line 111
void nettle_dsa_public_key_clear(struct dsa_public_key *key ) ;
#line 116
void nettle_dsa_private_key_init(struct dsa_private_key *key ) ;
#line 120
void nettle_dsa_private_key_clear(struct dsa_private_key *key ) ;
#line 124
void nettle_dsa_signature_init(struct dsa_signature *signature ) ;
#line 128
void nettle_dsa_signature_clear(struct dsa_signature *signature ) ;
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.c"
void nettle_dsa_public_key_init(struct dsa_public_key *key ) 
{ 


  {
  {
  {
#line 39
  __gmpz_init(key->p);
  }
  {
#line 40
  __gmpz_init(key->q);
  }
  {
#line 41
  __gmpz_init(key->g);
  }
  {
#line 42
  __gmpz_init(key->y);
  }
  }
#line 43
  return;
}
}
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.c"
void nettle_dsa_public_key_clear(struct dsa_public_key *key ) 
{ 


  {
  {
  {
#line 48
  __gmpz_clear(key->p);
  }
  {
#line 49
  __gmpz_clear(key->q);
  }
  {
#line 50
  __gmpz_clear(key->g);
  }
  {
#line 51
  __gmpz_clear(key->y);
  }
  }
#line 52
  return;
}
}
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.c"
void nettle_dsa_private_key_init(struct dsa_private_key *key ) 
{ 


  {
  {
  {
#line 58
  __gmpz_init(key->x);
  }
  }
#line 59
  return;
}
}
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.c"
void nettle_dsa_private_key_clear(struct dsa_private_key *key ) 
{ 


  {
  {
  {
#line 64
  __gmpz_clear(key->x);
  }
  }
#line 65
  return;
}
}
#line 68 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.c"
void nettle_dsa_signature_init(struct dsa_signature *signature ) 
{ 


  {
  {
  {
#line 71
  __gmpz_init(signature->r);
  }
  {
#line 72
  __gmpz_init(signature->s);
  }
  }
#line 73
  return;
}
}
#line 75 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.c"
void nettle_dsa_signature_clear(struct dsa_signature *signature ) 
{ 


  {
  {
  {
#line 78
  __gmpz_clear(signature->r);
  }
  {
#line 79
  __gmpz_clear(signature->s);
  }
  }
#line 80
  return;
}
}
#line 140 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.h"
int nettle_dsa_verify(struct dsa_public_key  const  *key , struct sha1_ctx *hash___2 ,
                      struct dsa_signature  const  *signature ) ;
#line 152
int nettle_dsa_verify_digest(struct dsa_public_key  const  *key , uint8_t const   *digest ,
                             struct dsa_signature  const  *signature ) ;
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa-verify.c"
int nettle_dsa_verify_digest(struct dsa_public_key  const  *key , uint8_t const   *digest ,
                             struct dsa_signature  const  *signature ) 
{ 
  mpz_t w ;
  mpz_t tmp ;
  mpz_t v ;
  int res ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;

  {
#line 50
  if (signature->r[0]._mp_size < 0) {
#line 50
    tmp___0 = -1;
  } else {
#line 50
    tmp___0 = signature->r[0]._mp_size > 0;
  }
#line 50
  if (tmp___0 <= 0) {
#line 51
    return (0);
  } else {
    {
    {
#line 50
    tmp___1 = __gmpz_cmp((mpz_srcptr )(signature->r), (mpz_srcptr )(key->q));
    }
    }
#line 50
    if (tmp___1 >= 0) {
#line 51
      return (0);
    }
  }
#line 53
  if (signature->s[0]._mp_size < 0) {
#line 53
    tmp___2 = -1;
  } else {
#line 53
    tmp___2 = signature->s[0]._mp_size > 0;
  }
#line 53
  if (tmp___2 <= 0) {
#line 54
    return (0);
  } else {
    {
    {
#line 53
    tmp___3 = __gmpz_cmp((mpz_srcptr )(signature->s), (mpz_srcptr )(key->q));
    }
    }
#line 53
    if (tmp___3 >= 0) {
#line 54
      return (0);
    }
  }
  {
  {
#line 56
  __gmpz_init(w);
  }
  {
#line 62
  tmp___4 = __gmpz_invert(w, (mpz_srcptr )(signature->s), (mpz_srcptr )(key->q));
  }
  }
#line 62
  if (! tmp___4) {
    {
    {
#line 64
    __gmpz_clear(w);
    }
    }
#line 65
    return (0);
  }
  {
  {
#line 68
  __gmpz_init(tmp);
  }
  {
#line 69
  __gmpz_init(v);
  }
  {
#line 72
  nettle_mpz_set_str_256_u(tmp, 20U, digest);
  }
  {
#line 75
  __gmpz_mul(tmp, (mpz_srcptr )(tmp), (mpz_srcptr )(w));
  }
  {
#line 76
  __gmpz_fdiv_r(tmp, (mpz_srcptr )(tmp), (mpz_srcptr )(key->q));
  }
  {
#line 78
  __gmpz_powm(v, (mpz_srcptr )(key->g), (mpz_srcptr )(tmp), (mpz_srcptr )(key->p));
  }
  {
#line 81
  __gmpz_mul(tmp, (mpz_srcptr )(signature->r), (mpz_srcptr )(w));
  }
  {
#line 82
  __gmpz_fdiv_r(tmp, (mpz_srcptr )(tmp), (mpz_srcptr )(key->q));
  }
  {
#line 84
  __gmpz_powm(tmp, (mpz_srcptr )(key->y), (mpz_srcptr )(tmp), (mpz_srcptr )(key->p));
  }
  {
#line 87
  __gmpz_mul(v, (mpz_srcptr )(v), (mpz_srcptr )(tmp));
  }
  {
#line 88
  __gmpz_fdiv_r(v, (mpz_srcptr )(v), (mpz_srcptr )(key->p));
  }
  {
#line 90
  __gmpz_fdiv_r(v, (mpz_srcptr )(v), (mpz_srcptr )(key->q));
  }
  {
#line 92
  tmp___5 = __gmpz_cmp((mpz_srcptr )(v), (mpz_srcptr )(signature->r));
  }
  }
#line 92
  if (tmp___5) {
#line 92
    tmp___6 = 0;
  } else {
#line 92
    tmp___6 = 1;
  }
  {
#line 92
  res = tmp___6;
  {
#line 94
  __gmpz_clear(w);
  }
  {
#line 95
  __gmpz_clear(tmp);
  }
  {
#line 96
  __gmpz_clear(v);
  }
  }
#line 98
  return (res);
}
}
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa-verify.c"
int nettle_dsa_verify(struct dsa_public_key  const  *key , struct sha1_ctx *hash___2 ,
                      struct dsa_signature  const  *signature ) 
{ 
  uint8_t digest[20] ;
  int tmp ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
  {
#line 107
  nettle_sha1_digest(hash___2, (unsigned int )sizeof(digest), digest);
  }
  {
#line 109
  tmp = nettle_dsa_verify_digest(key, (uint8_t const   *)(digest), signature);
  }
  }
#line 109
  return (tmp);
}
}
#line 913 "/usr/include/gmp-i386.h"
extern void __gmpz_init_set(mpz_ptr  , mpz_srcptr  ) ;
#line 132 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.h"
void nettle_dsa_sign(struct dsa_public_key  const  *pub , struct dsa_private_key  const  *key ,
                     void *random_ctx , void (*random___0)(void *ctx , unsigned int length ,
                                                           uint8_t *dst ) , struct sha1_ctx *hash___2 ,
                     struct dsa_signature *signature ) ;
#line 145
void nettle_dsa_sign_digest(struct dsa_public_key  const  *pub , struct dsa_private_key  const  *key ,
                            void *random_ctx , void (*random___0)(void *ctx , unsigned int length ,
                                                                  uint8_t *dst ) ,
                            uint8_t const   *digest , struct dsa_signature *signature ) ;
#line 76 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.h"
void nettle_mpz_random(__mpz_struct *x , void *ctx , void (*random___0)(void *ctx ,
                                                                        unsigned int length ,
                                                                        uint8_t *dst ) ,
                       __mpz_struct * const  n ) ;
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa-sign.c"
void nettle_dsa_sign_digest(struct dsa_public_key  const  *pub , struct dsa_private_key  const  *key ,
                            void *random_ctx , void (*random___0)(void *ctx , unsigned int length ,
                                                                  uint8_t *dst ) ,
                            uint8_t const   *digest , struct dsa_signature *signature ) 
{ 
  mpz_t k ;
  mpz_t h___0 ;
  mpz_t tmp ;
  int tmp___0 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
  {
#line 51
  __gmpz_init_set(tmp, (mpz_srcptr )(pub->q));
  }
  {
#line 52
  __gmpz_sub_ui(tmp, (mpz_srcptr )(tmp), 1UL);
  }
  {
#line 54
  __gmpz_init(k);
  }
  {
#line 55
  nettle_mpz_random(k, random_ctx, random___0, (__mpz_struct */* const  */)(tmp));
  }
  {
#line 56
  __gmpz_add_ui(k, (mpz_srcptr )(k), 1UL);
  }
  {
#line 59
  __gmpz_powm(tmp, (mpz_srcptr )(pub->g), (mpz_srcptr )(k), (mpz_srcptr )(pub->p));
  }
  {
#line 60
  __gmpz_fdiv_r(signature->r, (mpz_srcptr )(tmp), (mpz_srcptr )(pub->q));
  }
  {
#line 63
  __gmpz_init(h___0);
  }
  {
#line 64
  nettle_mpz_set_str_256_u(h___0, 20U, digest);
  }
  {
#line 67
  tmp___0 = __gmpz_invert(k, (mpz_srcptr )(k), (mpz_srcptr )(pub->q));
  }
  }
#line 67
  if (! tmp___0) {
    {
    {
#line 69
    abort();
    }
    }
  }
  {
  {
#line 72
  __gmpz_mul(tmp, (mpz_srcptr )(signature->r), (mpz_srcptr )(key->x));
  }
  {
#line 73
  __gmpz_fdiv_r(tmp, (mpz_srcptr )(tmp), (mpz_srcptr )(pub->q));
  }
  {
#line 74
  __gmpz_add(tmp, (mpz_srcptr )(tmp), (mpz_srcptr )(h___0));
  }
  {
#line 75
  __gmpz_mul(tmp, (mpz_srcptr )(tmp), (mpz_srcptr )(k));
  }
  {
#line 76
  __gmpz_fdiv_r(signature->s, (mpz_srcptr )(tmp), (mpz_srcptr )(pub->q));
  }
  {
#line 78
  __gmpz_clear(k);
  }
  {
#line 79
  __gmpz_clear(h___0);
  }
  {
#line 80
  __gmpz_clear(tmp);
  }
  }
#line 81
  return;
}
}
#line 83 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa-sign.c"
void nettle_dsa_sign(struct dsa_public_key  const  *pub , struct dsa_private_key  const  *key ,
                     void *random_ctx , void (*random___0)(void *ctx , unsigned int length ,
                                                           uint8_t *dst ) , struct sha1_ctx *hash___2 ,
                     struct dsa_signature *signature ) 
{ 
  uint8_t digest[20] ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
  {
#line 91
  nettle_sha1_digest(hash___2, (unsigned int )sizeof(digest), digest);
  }
  {
#line 93
  nettle_dsa_sign_digest(pub, key, random_ctx, random___0, (uint8_t const   *)(digest),
                         signature);
  }
  }
#line 95
  return;
}
}
#line 789 "/usr/include/gmp-i386.h"
extern void __gmpz_divexact(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 831
extern void __gmpz_fdiv_r_2exp(mpz_ptr  , mpz_srcptr  , unsigned long  ) ;
#line 986
extern void __gmpz_mul_2exp(mpz_ptr  , mpz_srcptr  , unsigned long  ) ;
#line 159 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa.h"
int nettle_dsa_generate_keypair(struct dsa_public_key *pub , struct dsa_private_key *key ,
                                void *random_ctx , void (*random___0)(void *ctx ,
                                                                      unsigned int length ,
                                                                      uint8_t *dst ) ,
                                void *progress_ctx , void (*progress)(void *ctx ,
                                                                      int c ) , unsigned int bits ) ;
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa-keygen.c"
static void hash(__mpz_struct *x , uint8_t *digest ) 
{ 
  mpz_t t ;
  uint8_t data[20] ;
  struct sha1_ctx ctx ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
  {
#line 53
  __gmpz_init_set(t, (mpz_srcptr )x);
  }
  {
#line 54
  __gmpz_fdiv_r_2exp(t, (mpz_srcptr )(t), 160UL);
  }
  {
#line 56
  nettle_mpz_get_str_256(20U, data, (__mpz_struct */* const  */)(t));
  }
  {
#line 57
  __gmpz_clear(t);
  }
  {
#line 59
  nettle_sha1_init(& ctx);
  }
  {
#line 60
  nettle_sha1_update(& ctx, 20U, (uint8_t const   *)(data));
  }
  {
#line 61
  nettle_sha1_digest(& ctx, 20U, digest);
  }
  }
#line 62
  return;
}
}
#line 64 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa-keygen.c"
static void dsa_nist_gen(__mpz_struct *p , __mpz_struct *q , void *random_ctx , void (*random___0)(void *ctx ,
                                                                                                   unsigned int length ,
                                                                                                   uint8_t *dst ) ,
                         void *progress_ctx , void (*progress)(void *ctx , int c ) ,
                         unsigned int L ) 
{ 
  unsigned int n ;
  unsigned int b ;
  mpz_t s ;
  mpz_t t ;
  mpz_t c ;
  uint8_t h1[20] ;
  uint8_t h2[20] ;
  int tmp ;
  uint8_t *buffer ;
  unsigned int size ;
  unsigned int i ;
  unsigned int j ;
  void *tmp___0 ;
  unsigned int k ;
  int tmp___1 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;

  {
  {
#line 77
  n = (L - 1U) / 160U;
#line 77
  b = (L - 1U) % 160U;
  {
#line 79
  __gmpz_init(s);
  }
  {
#line 80
  __gmpz_init(t);
  }
  {
#line 81
  __gmpz_init(c);
  }
  }
  {
  {
#line 83
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 89
    if (progress) {
      {
      {
#line 90
      (*progress)(progress_ctx, '.');
      }
      }
    }
    {
    {
#line 92
    nettle_mpz_random_size(s, random_ctx, random___0, 160U);
    }
    {
#line 94
    hash(s, h1);
    }
    {
#line 96
    __gmpz_set(t, (mpz_srcptr )(s));
    }
    {
#line 97
    __gmpz_add_ui(t, (mpz_srcptr )(t), 1UL);
    }
    {
#line 99
    hash(t, h2);
    }
    {
#line 101
    memxor(h1, (uint8_t const   *)(h2), (size_t )20);
    }
#line 103
    h1[0] = (uint8_t )((int )h1[0] | 128);
#line 104
    h1[19] = (uint8_t )((int )h1[19] | 1);
    {
#line 106
    nettle_mpz_set_str_256_u(q, 20U, (uint8_t const   *)(h1));
    }
    {
#line 112
    tmp = __gmpz_probab_prime_p((mpz_srcptr )q, 18);
    }
    }
#line 112
    if (! tmp) {
#line 114
      goto __Cont;
    }
#line 118
    if (progress) {
      {
      {
#line 119
      (*progress)(progress_ctx, '\n');
      }
      }
    }
    {
#line 124
    size = (n + 1U) * 20U;
    {
#line 127
    tmp___0 = __builtin_alloca(sizeof(*buffer) * (unsigned long )size);
    }
#line 127
    buffer = (uint8_t *)tmp___0;
#line 129
    i = 0U;
#line 129
    j = 2U;
    }
    {
    {
#line 129
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 129
      if (! (i < 4096U)) {
#line 129
        goto while_break___0;
      }
#line 133
      if (progress) {
        {
        {
#line 134
        (*progress)(progress_ctx, ',');
        }
        }
      }
#line 135
      k = 0U;
      {
      {
#line 135
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;

#line 135
        if (! (k <= n)) {
#line 135
          goto while_break___1;
        }
        {
        {
#line 137
        __gmpz_set(t, (mpz_srcptr )(s));
        }
        {
#line 138
        __gmpz_add_ui(t, (mpz_srcptr )(t), (unsigned long )(j + k));
        }
        {
#line 139
        hash(t, buffer + (n - k) * 20U);
        }
#line 135
        k ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___1: 
      {
      {
#line 141
      nettle_mpz_set_str_256_u(p, size, (uint8_t const   *)buffer);
      }
      {
#line 143
      __gmpz_fdiv_r_2exp(p, (mpz_srcptr )p, (unsigned long )L);
      }
      {
#line 144
      __gmpz_setbit(p, (unsigned long )(L - 1U));
      }
      {
#line 146
      __gmpz_set(t, (mpz_srcptr )q);
      }
      {
#line 147
      __gmpz_mul_2exp(t, (mpz_srcptr )(t), 1UL);
      }
      {
#line 149
      __gmpz_fdiv_r(c, (mpz_srcptr )p, (mpz_srcptr )(t));
      }
      {
#line 151
      __gmpz_sub_ui(c, (mpz_srcptr )(c), 1UL);
      }
      {
#line 153
      __gmpz_sub(p, (mpz_srcptr )p, (mpz_srcptr )(c));
      }
      {
#line 155
      tmp___1 = __gmpz_probab_prime_p((mpz_srcptr )p, 5);
      }
      }
#line 155
      if (tmp___1) {
#line 158
        if (progress) {
          {
          {
#line 159
          (*progress)(progress_ctx, '\n');
          }
          }
        }
        {
        {
#line 161
        __gmpz_clear(s);
        }
        {
#line 162
        __gmpz_clear(t);
        }
        {
#line 163
        __gmpz_clear(c);
        }
        }
#line 165
        return;
      }
#line 129
      i ++;
#line 129
      j += n + 1U;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 168
    if (progress) {
      {
      {
#line 169
      (*progress)(progress_ctx, '+');
      }
      }
    }
    __Cont: ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 177
  return;
}
}
#line 174 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa-keygen.c"
static void dsa_find_generator(__mpz_struct *g , void *random_ctx , void (*random___0)(void *ctx ,
                                                                                       unsigned int length ,
                                                                                       uint8_t *dst ) ,
                               void *progress_ctx , void (*progress)(void *ctx , int c ) ,
                               __mpz_struct * const  p , __mpz_struct * const  q ) 
{ 
  mpz_t e ;
  mpz_t n ;
  int tmp___0 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
  {
  {
#line 184
  __gmpz_init_set(e, (mpz_srcptr )p);
  }
  {
#line 185
  __gmpz_sub_ui(e, (mpz_srcptr )(e), 1UL);
  }
  {
#line 186
  __gmpz_divexact(e, (mpz_srcptr )(e), (mpz_srcptr )q);
  }
  {
#line 189
  __gmpz_init_set(n, (mpz_srcptr )p);
  }
  {
#line 190
  __gmpz_sub_ui(n, (mpz_srcptr )(n), 2UL);
  }
  }
  {
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 194
    nettle_mpz_random(g, random_ctx, random___0, (__mpz_struct */* const  */)(n));
    }
    {
#line 195
    __gmpz_add_ui(g, (mpz_srcptr )g, 2UL);
    }
    }
#line 197
    if (progress) {
      {
      {
#line 198
      (*progress)(progress_ctx, 'g');
      }
      }
    }
    {
    {
#line 199
    __gmpz_powm(g, (mpz_srcptr )g, (mpz_srcptr )(e), (mpz_srcptr )p);
    }
    {
#line 201
    tmp___0 = __gmpz_cmp_ui((mpz_srcptr )g, 1UL);
    }
    }
#line 201
    if (tmp___0) {
#line 204
      if (progress) {
        {
        {
#line 205
        (*progress)(progress_ctx, '\n');
        }
        }
      }
      {
      {
#line 207
      __gmpz_clear(e);
      }
      {
#line 208
      __gmpz_clear(n);
      }
      }
#line 210
      return;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 216
  return;
}
}
#line 215 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/dsa-keygen.c"
int nettle_dsa_generate_keypair(struct dsa_public_key *pub , struct dsa_private_key *key ,
                                void *random_ctx , void (*random___0)(void *ctx ,
                                                                      unsigned int length ,
                                                                      uint8_t *dst ) ,
                                void *progress_ctx , void (*progress)(void *ctx ,
                                                                      int c ) , unsigned int bits ) 
{ 
  mpz_t t ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
#line 227
  if (bits < 512U) {
#line 228
    return (0);
  }
  {
  {
#line 230
  dsa_nist_gen(pub->p, pub->q, random_ctx, random___0, progress_ctx, progress, bits);
  }
  {
#line 235
  dsa_find_generator(pub->g, random_ctx, random___0, progress_ctx, progress, (__mpz_struct */* const  */)(pub->p),
                     (__mpz_struct */* const  */)(pub->q));
  }
  {
#line 240
  __gmpz_init_set(t, (mpz_srcptr )(pub->q));
  }
  {
#line 241
  __gmpz_sub_ui(t, (mpz_srcptr )(t), 2UL);
  }
  {
#line 242
  nettle_mpz_random(key->x, random_ctx, random___0, (__mpz_struct */* const  */)(t));
  }
  {
#line 244
  __gmpz_add_ui(key->x, (mpz_srcptr )(key->x), 1UL);
  }
  {
#line 246
  __gmpz_powm(pub->y, (mpz_srcptr )(pub->g), (mpz_srcptr )(key->x), (mpz_srcptr )(pub->p));
  }
  {
#line 248
  __gmpz_clear(t);
  }
  }
#line 250
  return (1);
}
}
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des3.c"
int nettle_des3_set_key(struct des3_ctx *ctx , uint8_t const   *key ) 
{ 
  unsigned int i ;
  int tmp ;

  {
#line 42
  i = 0U;
  {
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 42
    if (! (i < 3U)) {
#line 42
      goto while_break;
    }
    {
    {
#line 43
    tmp = nettle_des_set_key(& ctx->des[i], key);
    }
    }
#line 43
    if (! tmp) {
#line 45
      ctx->status = ctx->des[i].status;
#line 46
      return (0);
    }
#line 42
    i ++;
#line 42
    key += 8;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 48
  ctx->status = (enum des_error )0;
#line 49
  return (1);
}
}
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des3.c"
void nettle_des3_encrypt(struct des3_ctx  const  *ctx , unsigned int length , uint8_t *dst ,
                         uint8_t const   *src ) 
{ 


  {
  {
  {
#line 57
  nettle_des_encrypt((struct des_ctx  const  *)(& ctx->des[0]), length, dst, src);
  }
  {
#line 59
  nettle_des_decrypt((struct des_ctx  const  *)(& ctx->des[1]), length, dst, (uint8_t const   *)dst);
  }
  {
#line 61
  nettle_des_encrypt((struct des_ctx  const  *)(& ctx->des[2]), length, dst, (uint8_t const   *)dst);
  }
  }
#line 63
  return;
}
}
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des3.c"
void nettle_des3_decrypt(struct des3_ctx  const  *ctx , unsigned int length , uint8_t *dst ,
                         uint8_t const   *src ) 
{ 


  {
  {
  {
#line 70
  nettle_des_decrypt((struct des_ctx  const  *)(& ctx->des[2]), length, dst, src);
  }
  {
#line 72
  nettle_des_encrypt((struct des_ctx  const  *)(& ctx->des[1]), length, dst, (uint8_t const   *)dst);
  }
  {
#line 74
  nettle_des_decrypt((struct des_ctx  const  *)(& ctx->des[0]), length, dst, (uint8_t const   *)dst);
  }
  }
#line 76
  return;
}
}
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c"
static uint32_t const   des_keymap[512]  = 
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c"
  {      (uint32_t const   )34078728,      (uint32_t const   )34086912,      (uint32_t const   )8200,      (uint32_t const   )0, 
        (uint32_t const   )33562624,      (uint32_t const   )524296,      (uint32_t const   )34078720,      (uint32_t const   )34086920, 
        (uint32_t const   )8,      (uint32_t const   )33554432,      (uint32_t const   )532480,      (uint32_t const   )8200, 
        (uint32_t const   )532488,      (uint32_t const   )33562632,      (uint32_t const   )33554440,      (uint32_t const   )34078720, 
        (uint32_t const   )8192,      (uint32_t const   )532488,      (uint32_t const   )524296,      (uint32_t const   )33562624, 
        (uint32_t const   )34086920,      (uint32_t const   )33554440,      (uint32_t const   )0,      (uint32_t const   )532480, 
        (uint32_t const   )33554432,      (uint32_t const   )524288,      (uint32_t const   )33562632,      (uint32_t const   )34078728, 
        (uint32_t const   )524288,      (uint32_t const   )8192,      (uint32_t const   )34086912,      (uint32_t const   )8, 
        (uint32_t const   )524288,      (uint32_t const   )8192,      (uint32_t const   )33554440,      (uint32_t const   )34086920, 
        (uint32_t const   )8200,      (uint32_t const   )33554432,      (uint32_t const   )0,      (uint32_t const   )532480, 
        (uint32_t const   )34078728,      (uint32_t const   )33562632,      (uint32_t const   )33562624,      (uint32_t const   )524296, 
        (uint32_t const   )34086912,      (uint32_t const   )8,      (uint32_t const   )524296,      (uint32_t const   )33562624, 
        (uint32_t const   )34086920,      (uint32_t const   )524288,      (uint32_t const   )34078720,      (uint32_t const   )33554440, 
        (uint32_t const   )532480,      (uint32_t const   )8200,      (uint32_t const   )33562632,      (uint32_t const   )34078720, 
        (uint32_t const   )8,      (uint32_t const   )34086912,      (uint32_t const   )532488,      (uint32_t const   )0, 
        (uint32_t const   )33554432,      (uint32_t const   )34078728,      (uint32_t const   )8192,      (uint32_t const   )532488, 
        (uint32_t const   )134217732,      (uint32_t const   )131076,      (uint32_t const   )0,      (uint32_t const   )134349312, 
        (uint32_t const   )131076,      (uint32_t const   )512,      (uint32_t const   )134218244,      (uint32_t const   )131072, 
        (uint32_t const   )516,      (uint32_t const   )134349316,      (uint32_t const   )131584,      (uint32_t const   )134217728, 
        (uint32_t const   )134218240,      (uint32_t const   )134217732,      (uint32_t const   )134348800,      (uint32_t const   )131588, 
        (uint32_t const   )131072,      (uint32_t const   )134218244,      (uint32_t const   )134348804,      (uint32_t const   )0, 
        (uint32_t const   )512,      (uint32_t const   )4,      (uint32_t const   )134349312,      (uint32_t const   )134348804, 
        (uint32_t const   )134349316,      (uint32_t const   )134348800,      (uint32_t const   )134217728,      (uint32_t const   )516, 
        (uint32_t const   )4,      (uint32_t const   )131584,      (uint32_t const   )131588,      (uint32_t const   )134218240, 
        (uint32_t const   )516,      (uint32_t const   )134217728,      (uint32_t const   )134218240,      (uint32_t const   )131588, 
        (uint32_t const   )134349312,      (uint32_t const   )131076,      (uint32_t const   )0,      (uint32_t const   )134218240, 
        (uint32_t const   )134217728,      (uint32_t const   )512,      (uint32_t const   )134348804,      (uint32_t const   )131072, 
        (uint32_t const   )131076,      (uint32_t const   )134349316,      (uint32_t const   )131584,      (uint32_t const   )4, 
        (uint32_t const   )134349316,      (uint32_t const   )131584,      (uint32_t const   )131072,      (uint32_t const   )134218244, 
        (uint32_t const   )134217732,      (uint32_t const   )134348800,      (uint32_t const   )131588,      (uint32_t const   )0, 
        (uint32_t const   )512,      (uint32_t const   )134217732,      (uint32_t const   )134218244,      (uint32_t const   )134349312, 
        (uint32_t const   )134348800,      (uint32_t const   )516,      (uint32_t const   )4,      (uint32_t const   )134348804, 
        (uint32_t const   )2147746048U,      (uint32_t const   )16777472,      (uint32_t const   )2147483648U,      (uint32_t const   )2164523264U, 
        (uint32_t const   )0,      (uint32_t const   )17039360,      (uint32_t const   )2164261120U,      (uint32_t const   )2147745792U, 
        (uint32_t const   )17039616,      (uint32_t const   )2164260864U,      (uint32_t const   )16777216,      (uint32_t const   )2147483904U, 
        (uint32_t const   )2164260864U,      (uint32_t const   )2147746048U,      (uint32_t const   )262144,      (uint32_t const   )16777216, 
        (uint32_t const   )2164523008U,      (uint32_t const   )262400,      (uint32_t const   )256,      (uint32_t const   )2147483648U, 
        (uint32_t const   )262400,      (uint32_t const   )2164261120U,      (uint32_t const   )17039360,      (uint32_t const   )256, 
        (uint32_t const   )2147483904U,      (uint32_t const   )0,      (uint32_t const   )2147745792U,      (uint32_t const   )17039616, 
        (uint32_t const   )16777472,      (uint32_t const   )2164523008U,      (uint32_t const   )2164523264U,      (uint32_t const   )262144, 
        (uint32_t const   )2164523008U,      (uint32_t const   )2147483904U,      (uint32_t const   )262144,      (uint32_t const   )2164260864U, 
        (uint32_t const   )262400,      (uint32_t const   )16777472,      (uint32_t const   )2147483648U,      (uint32_t const   )17039360, 
        (uint32_t const   )2164261120U,      (uint32_t const   )0,      (uint32_t const   )256,      (uint32_t const   )2147745792U, 
        (uint32_t const   )0,      (uint32_t const   )2164523008U,      (uint32_t const   )17039616,      (uint32_t const   )256, 
        (uint32_t const   )16777216,      (uint32_t const   )2164523264U,      (uint32_t const   )2147746048U,      (uint32_t const   )262144, 
        (uint32_t const   )2164523264U,      (uint32_t const   )2147483648U,      (uint32_t const   )16777472,      (uint32_t const   )2147746048U, 
        (uint32_t const   )2147745792U,      (uint32_t const   )262400,      (uint32_t const   )17039360,      (uint32_t const   )2164261120U, 
        (uint32_t const   )2147483904U,      (uint32_t const   )16777216,      (uint32_t const   )2164260864U,      (uint32_t const   )17039616, 
        (uint32_t const   )67176449,      (uint32_t const   )0,      (uint32_t const   )67584,      (uint32_t const   )67174400, 
        (uint32_t const   )67108865,      (uint32_t const   )2049,      (uint32_t const   )67110912,      (uint32_t const   )67584, 
        (uint32_t const   )2048,      (uint32_t const   )67174401,      (uint32_t const   )1,      (uint32_t const   )67110912, 
        (uint32_t const   )65537,      (uint32_t const   )67176448,      (uint32_t const   )67174400,      (uint32_t const   )1, 
        (uint32_t const   )65536,      (uint32_t const   )67110913,      (uint32_t const   )67174401,      (uint32_t const   )2048, 
        (uint32_t const   )67585,      (uint32_t const   )67108864,      (uint32_t const   )0,      (uint32_t const   )65537, 
        (uint32_t const   )67110913,      (uint32_t const   )67585,      (uint32_t const   )67176448,      (uint32_t const   )67108865, 
        (uint32_t const   )67108864,      (uint32_t const   )65536,      (uint32_t const   )2049,      (uint32_t const   )67176449, 
        (uint32_t const   )65537,      (uint32_t const   )67176448,      (uint32_t const   )67110912,      (uint32_t const   )67585, 
        (uint32_t const   )67176449,      (uint32_t const   )65537,      (uint32_t const   )67108865,      (uint32_t const   )0, 
        (uint32_t const   )67108864,      (uint32_t const   )2049,      (uint32_t const   )65536,      (uint32_t const   )67174401, 
        (uint32_t const   )2048,      (uint32_t const   )67108864,      (uint32_t const   )67585,      (uint32_t const   )67110913, 
        (uint32_t const   )67176448,      (uint32_t const   )2048,      (uint32_t const   )0,      (uint32_t const   )67108865, 
        (uint32_t const   )1,      (uint32_t const   )67176449,      (uint32_t const   )67584,      (uint32_t const   )67174400, 
        (uint32_t const   )67174401,      (uint32_t const   )65536,      (uint32_t const   )2049,      (uint32_t const   )67110912, 
        (uint32_t const   )67110913,      (uint32_t const   )1,      (uint32_t const   )67174400,      (uint32_t const   )67584, 
        (uint32_t const   )1024,      (uint32_t const   )32,      (uint32_t const   )1048608,      (uint32_t const   )1074790400, 
        (uint32_t const   )1074791456,      (uint32_t const   )1073742848,      (uint32_t const   )1056,      (uint32_t const   )0, 
        (uint32_t const   )1048576,      (uint32_t const   )1074790432,      (uint32_t const   )1073741856,      (uint32_t const   )1049600, 
        (uint32_t const   )1073741824,      (uint32_t const   )1049632,      (uint32_t const   )1049600,      (uint32_t const   )1073741856, 
        (uint32_t const   )1074790432,      (uint32_t const   )1024,      (uint32_t const   )1073742848,      (uint32_t const   )1074791456, 
        (uint32_t const   )0,      (uint32_t const   )1048608,      (uint32_t const   )1074790400,      (uint32_t const   )1056, 
        (uint32_t const   )1074791424,      (uint32_t const   )1073742880,      (uint32_t const   )1049632,      (uint32_t const   )1073741824, 
        (uint32_t const   )1073742880,      (uint32_t const   )1074791424,      (uint32_t const   )32,      (uint32_t const   )1048576, 
        (uint32_t const   )1073742880,      (uint32_t const   )1049600,      (uint32_t const   )1074791424,      (uint32_t const   )1073741856, 
        (uint32_t const   )1024,      (uint32_t const   )32,      (uint32_t const   )1048576,      (uint32_t const   )1074791424, 
        (uint32_t const   )1074790432,      (uint32_t const   )1073742880,      (uint32_t const   )1056,      (uint32_t const   )0, 
        (uint32_t const   )32,      (uint32_t const   )1074790400,      (uint32_t const   )1073741824,      (uint32_t const   )1048608, 
        (uint32_t const   )0,      (uint32_t const   )1074790432,      (uint32_t const   )1048608,      (uint32_t const   )1056, 
        (uint32_t const   )1073741856,      (uint32_t const   )1024,      (uint32_t const   )1074791456,      (uint32_t const   )1048576, 
        (uint32_t const   )1049632,      (uint32_t const   )1073741824,      (uint32_t const   )1073742848,      (uint32_t const   )1074791456, 
        (uint32_t const   )1074790400,      (uint32_t const   )1049632,      (uint32_t const   )1049600,      (uint32_t const   )1073742848, 
        (uint32_t const   )8388608,      (uint32_t const   )4096,      (uint32_t const   )64,      (uint32_t const   )8392770, 
        (uint32_t const   )8392706,      (uint32_t const   )8388672,      (uint32_t const   )4162,      (uint32_t const   )8392704, 
        (uint32_t const   )4096,      (uint32_t const   )2,      (uint32_t const   )8388610,      (uint32_t const   )4160, 
        (uint32_t const   )8388674,      (uint32_t const   )8392706,      (uint32_t const   )8392768,      (uint32_t const   )0, 
        (uint32_t const   )4160,      (uint32_t const   )8388608,      (uint32_t const   )4098,      (uint32_t const   )66, 
        (uint32_t const   )8388672,      (uint32_t const   )4162,      (uint32_t const   )0,      (uint32_t const   )8388610, 
        (uint32_t const   )2,      (uint32_t const   )8388674,      (uint32_t const   )8392770,      (uint32_t const   )4098, 
        (uint32_t const   )8392704,      (uint32_t const   )64,      (uint32_t const   )66,      (uint32_t const   )8392768, 
        (uint32_t const   )8392768,      (uint32_t const   )8388674,      (uint32_t const   )4098,      (uint32_t const   )8392704, 
        (uint32_t const   )4096,      (uint32_t const   )2,      (uint32_t const   )8388610,      (uint32_t const   )8388672, 
        (uint32_t const   )8388608,      (uint32_t const   )4160,      (uint32_t const   )8392770,      (uint32_t const   )0, 
        (uint32_t const   )4162,      (uint32_t const   )8388608,      (uint32_t const   )64,      (uint32_t const   )4098, 
        (uint32_t const   )8388674,      (uint32_t const   )64,      (uint32_t const   )0,      (uint32_t const   )8392770, 
        (uint32_t const   )8392706,      (uint32_t const   )8392768,      (uint32_t const   )66,      (uint32_t const   )4096, 
        (uint32_t const   )4160,      (uint32_t const   )8392706,      (uint32_t const   )8388672,      (uint32_t const   )66, 
        (uint32_t const   )2,      (uint32_t const   )4162,      (uint32_t const   )8392704,      (uint32_t const   )8388610, 
        (uint32_t const   )272629760,      (uint32_t const   )4210704,      (uint32_t const   )16,      (uint32_t const   )272629776, 
        (uint32_t const   )268451840,      (uint32_t const   )4194304,      (uint32_t const   )272629776,      (uint32_t const   )16400, 
        (uint32_t const   )4194320,      (uint32_t const   )16384,      (uint32_t const   )4210688,      (uint32_t const   )268435456, 
        (uint32_t const   )272646160,      (uint32_t const   )268435472,      (uint32_t const   )268435456,      (uint32_t const   )272646144, 
        (uint32_t const   )0,      (uint32_t const   )268451840,      (uint32_t const   )4210704,      (uint32_t const   )16, 
        (uint32_t const   )268435472,      (uint32_t const   )272646160,      (uint32_t const   )16384,      (uint32_t const   )272629760, 
        (uint32_t const   )272646144,      (uint32_t const   )4194320,      (uint32_t const   )268451856,      (uint32_t const   )4210688, 
        (uint32_t const   )16400,      (uint32_t const   )0,      (uint32_t const   )4194304,      (uint32_t const   )268451856, 
        (uint32_t const   )4210704,      (uint32_t const   )16,      (uint32_t const   )268435456,      (uint32_t const   )16384, 
        (uint32_t const   )268435472,      (uint32_t const   )268451840,      (uint32_t const   )4210688,      (uint32_t const   )272629776, 
        (uint32_t const   )0,      (uint32_t const   )4210704,      (uint32_t const   )16400,      (uint32_t const   )272646144, 
        (uint32_t const   )268451840,      (uint32_t const   )4194304,      (uint32_t const   )272646160,      (uint32_t const   )268435456, 
        (uint32_t const   )268451856,      (uint32_t const   )272629760,      (uint32_t const   )4194304,      (uint32_t const   )272646160, 
        (uint32_t const   )16384,      (uint32_t const   )4194320,      (uint32_t const   )272629776,      (uint32_t const   )16400, 
        (uint32_t const   )4194320,      (uint32_t const   )0,      (uint32_t const   )272646144,      (uint32_t const   )268435472, 
        (uint32_t const   )272629760,      (uint32_t const   )268451856,      (uint32_t const   )16,      (uint32_t const   )4210688, 
        (uint32_t const   )2130048,      (uint32_t const   )32768,      (uint32_t const   )538968064,      (uint32_t const   )539000960, 
        (uint32_t const   )2097152,      (uint32_t const   )536903808,      (uint32_t const   )536903680,      (uint32_t const   )538968064, 
        (uint32_t const   )536903808,      (uint32_t const   )2130048,      (uint32_t const   )2129920,      (uint32_t const   )536871040, 
        (uint32_t const   )538968192,      (uint32_t const   )2097152,      (uint32_t const   )0,      (uint32_t const   )536903680, 
        (uint32_t const   )32768,      (uint32_t const   )536870912,      (uint32_t const   )2097280,      (uint32_t const   )32896, 
        (uint32_t const   )539000960,      (uint32_t const   )2129920,      (uint32_t const   )536871040,      (uint32_t const   )2097280, 
        (uint32_t const   )536870912,      (uint32_t const   )128,      (uint32_t const   )32896,      (uint32_t const   )539000832, 
        (uint32_t const   )128,      (uint32_t const   )538968192,      (uint32_t const   )539000832,      (uint32_t const   )0, 
        (uint32_t const   )0,      (uint32_t const   )539000960,      (uint32_t const   )2097280,      (uint32_t const   )536903680, 
        (uint32_t const   )2130048,      (uint32_t const   )32768,      (uint32_t const   )536871040,      (uint32_t const   )2097280, 
        (uint32_t const   )539000832,      (uint32_t const   )128,      (uint32_t const   )32896,      (uint32_t const   )538968064, 
        (uint32_t const   )536903808,      (uint32_t const   )536870912,      (uint32_t const   )538968064,      (uint32_t const   )2129920, 
        (uint32_t const   )539000960,      (uint32_t const   )32896,      (uint32_t const   )2129920,      (uint32_t const   )538968192, 
        (uint32_t const   )2097152,      (uint32_t const   )536871040,      (uint32_t const   )536903680,      (uint32_t const   )0, 
        (uint32_t const   )32768,      (uint32_t const   )2097152,      (uint32_t const   )538968192,      (uint32_t const   )2130048, 
        (uint32_t const   )536870912,      (uint32_t const   )539000832,      (uint32_t const   )128,      (uint32_t const   )536903808};
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c"
static uint8_t const   rotors[768]  = 
#line 49
  {      (uint8_t const   )34,      (uint8_t const   )13,      (uint8_t const   )5,      (uint8_t const   )46, 
        (uint8_t const   )47,      (uint8_t const   )18,      (uint8_t const   )32,      (uint8_t const   )41, 
        (uint8_t const   )11,      (uint8_t const   )53,      (uint8_t const   )33,      (uint8_t const   )20, 
        (uint8_t const   )14,      (uint8_t const   )36,      (uint8_t const   )30,      (uint8_t const   )24, 
        (uint8_t const   )49,      (uint8_t const   )2,      (uint8_t const   )15,      (uint8_t const   )37, 
        (uint8_t const   )42,      (uint8_t const   )50,      (uint8_t const   )0,      (uint8_t const   )21, 
        (uint8_t const   )38,      (uint8_t const   )48,      (uint8_t const   )6,      (uint8_t const   )26, 
        (uint8_t const   )39,      (uint8_t const   )4,      (uint8_t const   )52,      (uint8_t const   )25, 
        (uint8_t const   )12,      (uint8_t const   )27,      (uint8_t const   )31,      (uint8_t const   )40, 
        (uint8_t const   )1,      (uint8_t const   )17,      (uint8_t const   )28,      (uint8_t const   )29, 
        (uint8_t const   )23,      (uint8_t const   )51,      (uint8_t const   )35,      (uint8_t const   )7, 
        (uint8_t const   )3,      (uint8_t const   )22,      (uint8_t const   )9,      (uint8_t const   )43, 
        (uint8_t const   )41,      (uint8_t const   )20,      (uint8_t const   )12,      (uint8_t const   )53, 
        (uint8_t const   )54,      (uint8_t const   )25,      (uint8_t const   )39,      (uint8_t const   )48, 
        (uint8_t const   )18,      (uint8_t const   )31,      (uint8_t const   )40,      (uint8_t const   )27, 
        (uint8_t const   )21,      (uint8_t const   )43,      (uint8_t const   )37,      (uint8_t const   )0, 
        (uint8_t const   )1,      (uint8_t const   )9,      (uint8_t const   )22,      (uint8_t const   )44, 
        (uint8_t const   )49,      (uint8_t const   )2,      (uint8_t const   )7,      (uint8_t const   )28, 
        (uint8_t const   )45,      (uint8_t const   )55,      (uint8_t const   )13,      (uint8_t const   )33, 
        (uint8_t const   )46,      (uint8_t const   )11,      (uint8_t const   )6,      (uint8_t const   )32, 
        (uint8_t const   )19,      (uint8_t const   )34,      (uint8_t const   )38,      (uint8_t const   )47, 
        (uint8_t const   )8,      (uint8_t const   )24,      (uint8_t const   )35,      (uint8_t const   )36, 
        (uint8_t const   )30,      (uint8_t const   )3,      (uint8_t const   )42,      (uint8_t const   )14, 
        (uint8_t const   )10,      (uint8_t const   )29,      (uint8_t const   )16,      (uint8_t const   )50, 
        (uint8_t const   )55,      (uint8_t const   )34,      (uint8_t const   )26,      (uint8_t const   )38, 
        (uint8_t const   )11,      (uint8_t const   )39,      (uint8_t const   )53,      (uint8_t const   )5, 
        (uint8_t const   )32,      (uint8_t const   )45,      (uint8_t const   )54,      (uint8_t const   )41, 
        (uint8_t const   )35,      (uint8_t const   )2,      (uint8_t const   )51,      (uint8_t const   )14, 
        (uint8_t const   )15,      (uint8_t const   )23,      (uint8_t const   )36,      (uint8_t const   )3, 
        (uint8_t const   )8,      (uint8_t const   )16,      (uint8_t const   )21,      (uint8_t const   )42, 
        (uint8_t const   )6,      (uint8_t const   )12,      (uint8_t const   )27,      (uint8_t const   )47, 
        (uint8_t const   )31,      (uint8_t const   )25,      (uint8_t const   )20,      (uint8_t const   )46, 
        (uint8_t const   )33,      (uint8_t const   )48,      (uint8_t const   )52,      (uint8_t const   )4, 
        (uint8_t const   )22,      (uint8_t const   )7,      (uint8_t const   )49,      (uint8_t const   )50, 
        (uint8_t const   )44,      (uint8_t const   )17,      (uint8_t const   )1,      (uint8_t const   )28, 
        (uint8_t const   )24,      (uint8_t const   )43,      (uint8_t const   )30,      (uint8_t const   )9, 
        (uint8_t const   )12,      (uint8_t const   )48,      (uint8_t const   )40,      (uint8_t const   )52, 
        (uint8_t const   )25,      (uint8_t const   )53,      (uint8_t const   )38,      (uint8_t const   )19, 
        (uint8_t const   )46,      (uint8_t const   )6,      (uint8_t const   )11,      (uint8_t const   )55, 
        (uint8_t const   )49,      (uint8_t const   )16,      (uint8_t const   )10,      (uint8_t const   )28, 
        (uint8_t const   )29,      (uint8_t const   )37,      (uint8_t const   )50,      (uint8_t const   )17, 
        (uint8_t const   )22,      (uint8_t const   )30,      (uint8_t const   )35,      (uint8_t const   )1, 
        (uint8_t const   )20,      (uint8_t const   )26,      (uint8_t const   )41,      (uint8_t const   )4, 
        (uint8_t const   )45,      (uint8_t const   )39,      (uint8_t const   )34,      (uint8_t const   )31, 
        (uint8_t const   )47,      (uint8_t const   )5,      (uint8_t const   )13,      (uint8_t const   )18, 
        (uint8_t const   )36,      (uint8_t const   )21,      (uint8_t const   )8,      (uint8_t const   )9, 
        (uint8_t const   )3,      (uint8_t const   )0,      (uint8_t const   )15,      (uint8_t const   )42, 
        (uint8_t const   )7,      (uint8_t const   )2,      (uint8_t const   )44,      (uint8_t const   )23, 
        (uint8_t const   )26,      (uint8_t const   )5,      (uint8_t const   )54,      (uint8_t const   )13, 
        (uint8_t const   )39,      (uint8_t const   )38,      (uint8_t const   )52,      (uint8_t const   )33, 
        (uint8_t const   )31,      (uint8_t const   )20,      (uint8_t const   )25,      (uint8_t const   )12, 
        (uint8_t const   )8,      (uint8_t const   )30,      (uint8_t const   )24,      (uint8_t const   )42, 
        (uint8_t const   )43,      (uint8_t const   )51,      (uint8_t const   )9,      (uint8_t const   )0, 
        (uint8_t const   )36,      (uint8_t const   )44,      (uint8_t const   )49,      (uint8_t const   )15, 
        (uint8_t const   )34,      (uint8_t const   )40,      (uint8_t const   )55,      (uint8_t const   )18, 
        (uint8_t const   )6,      (uint8_t const   )53,      (uint8_t const   )48,      (uint8_t const   )45, 
        (uint8_t const   )4,      (uint8_t const   )19,      (uint8_t const   )27,      (uint8_t const   )32, 
        (uint8_t const   )50,      (uint8_t const   )35,      (uint8_t const   )22,      (uint8_t const   )23, 
        (uint8_t const   )17,      (uint8_t const   )14,      (uint8_t const   )29,      (uint8_t const   )1, 
        (uint8_t const   )21,      (uint8_t const   )16,      (uint8_t const   )3,      (uint8_t const   )37, 
        (uint8_t const   )40,      (uint8_t const   )19,      (uint8_t const   )11,      (uint8_t const   )27, 
        (uint8_t const   )53,      (uint8_t const   )52,      (uint8_t const   )13,      (uint8_t const   )47, 
        (uint8_t const   )45,      (uint8_t const   )34,      (uint8_t const   )39,      (uint8_t const   )26, 
        (uint8_t const   )22,      (uint8_t const   )44,      (uint8_t const   )7,      (uint8_t const   )1, 
        (uint8_t const   )2,      (uint8_t const   )10,      (uint8_t const   )23,      (uint8_t const   )14, 
        (uint8_t const   )50,      (uint8_t const   )3,      (uint8_t const   )8,      (uint8_t const   )29, 
        (uint8_t const   )48,      (uint8_t const   )54,      (uint8_t const   )12,      (uint8_t const   )32, 
        (uint8_t const   )20,      (uint8_t const   )38,      (uint8_t const   )5,      (uint8_t const   )6, 
        (uint8_t const   )18,      (uint8_t const   )33,      (uint8_t const   )41,      (uint8_t const   )46, 
        (uint8_t const   )9,      (uint8_t const   )49,      (uint8_t const   )36,      (uint8_t const   )37, 
        (uint8_t const   )0,      (uint8_t const   )28,      (uint8_t const   )43,      (uint8_t const   )15, 
        (uint8_t const   )35,      (uint8_t const   )30,      (uint8_t const   )17,      (uint8_t const   )51, 
        (uint8_t const   )54,      (uint8_t const   )33,      (uint8_t const   )25,      (uint8_t const   )41, 
        (uint8_t const   )38,      (uint8_t const   )13,      (uint8_t const   )27,      (uint8_t const   )4, 
        (uint8_t const   )6,      (uint8_t const   )48,      (uint8_t const   )53,      (uint8_t const   )40, 
        (uint8_t const   )36,      (uint8_t const   )3,      (uint8_t const   )21,      (uint8_t const   )15, 
        (uint8_t const   )16,      (uint8_t const   )24,      (uint8_t const   )37,      (uint8_t const   )28, 
        (uint8_t const   )9,      (uint8_t const   )17,      (uint8_t const   )22,      (uint8_t const   )43, 
        (uint8_t const   )5,      (uint8_t const   )11,      (uint8_t const   )26,      (uint8_t const   )46, 
        (uint8_t const   )34,      (uint8_t const   )52,      (uint8_t const   )19,      (uint8_t const   )20, 
        (uint8_t const   )32,      (uint8_t const   )47,      (uint8_t const   )55,      (uint8_t const   )31, 
        (uint8_t const   )23,      (uint8_t const   )8,      (uint8_t const   )50,      (uint8_t const   )51, 
        (uint8_t const   )14,      (uint8_t const   )42,      (uint8_t const   )2,      (uint8_t const   )29, 
        (uint8_t const   )49,      (uint8_t const   )44,      (uint8_t const   )0,      (uint8_t const   )10, 
        (uint8_t const   )11,      (uint8_t const   )47,      (uint8_t const   )39,      (uint8_t const   )55, 
        (uint8_t const   )52,      (uint8_t const   )27,      (uint8_t const   )41,      (uint8_t const   )18, 
        (uint8_t const   )20,      (uint8_t const   )5,      (uint8_t const   )38,      (uint8_t const   )54, 
        (uint8_t const   )50,      (uint8_t const   )17,      (uint8_t const   )35,      (uint8_t const   )29, 
        (uint8_t const   )30,      (uint8_t const   )7,      (uint8_t const   )51,      (uint8_t const   )42, 
        (uint8_t const   )23,      (uint8_t const   )0,      (uint8_t const   )36,      (uint8_t const   )2, 
        (uint8_t const   )19,      (uint8_t const   )25,      (uint8_t const   )40,      (uint8_t const   )31, 
        (uint8_t const   )48,      (uint8_t const   )13,      (uint8_t const   )33,      (uint8_t const   )34, 
        (uint8_t const   )46,      (uint8_t const   )4,      (uint8_t const   )12,      (uint8_t const   )45, 
        (uint8_t const   )37,      (uint8_t const   )22,      (uint8_t const   )9,      (uint8_t const   )10, 
        (uint8_t const   )28,      (uint8_t const   )1,      (uint8_t const   )16,      (uint8_t const   )43, 
        (uint8_t const   )8,      (uint8_t const   )3,      (uint8_t const   )14,      (uint8_t const   )24, 
        (uint8_t const   )18,      (uint8_t const   )54,      (uint8_t const   )46,      (uint8_t const   )5, 
        (uint8_t const   )6,      (uint8_t const   )34,      (uint8_t const   )48,      (uint8_t const   )25, 
        (uint8_t const   )27,      (uint8_t const   )12,      (uint8_t const   )45,      (uint8_t const   )4, 
        (uint8_t const   )2,      (uint8_t const   )24,      (uint8_t const   )42,      (uint8_t const   )36, 
        (uint8_t const   )37,      (uint8_t const   )14,      (uint8_t const   )3,      (uint8_t const   )49, 
        (uint8_t const   )30,      (uint8_t const   )7,      (uint8_t const   )43,      (uint8_t const   )9, 
        (uint8_t const   )26,      (uint8_t const   )32,      (uint8_t const   )47,      (uint8_t const   )38, 
        (uint8_t const   )55,      (uint8_t const   )20,      (uint8_t const   )40,      (uint8_t const   )41, 
        (uint8_t const   )53,      (uint8_t const   )11,      (uint8_t const   )19,      (uint8_t const   )52, 
        (uint8_t const   )44,      (uint8_t const   )29,      (uint8_t const   )16,      (uint8_t const   )17, 
        (uint8_t const   )35,      (uint8_t const   )8,      (uint8_t const   )23,      (uint8_t const   )50, 
        (uint8_t const   )15,      (uint8_t const   )10,      (uint8_t const   )21,      (uint8_t const   )0, 
        (uint8_t const   )32,      (uint8_t const   )11,      (uint8_t const   )31,      (uint8_t const   )19, 
        (uint8_t const   )20,      (uint8_t const   )48,      (uint8_t const   )5,      (uint8_t const   )39, 
        (uint8_t const   )41,      (uint8_t const   )26,      (uint8_t const   )6,      (uint8_t const   )18, 
        (uint8_t const   )16,      (uint8_t const   )7,      (uint8_t const   )1,      (uint8_t const   )50, 
        (uint8_t const   )51,      (uint8_t const   )28,      (uint8_t const   )17,      (uint8_t const   )8, 
        (uint8_t const   )44,      (uint8_t const   )21,      (uint8_t const   )2,      (uint8_t const   )23, 
        (uint8_t const   )40,      (uint8_t const   )46,      (uint8_t const   )4,      (uint8_t const   )52, 
        (uint8_t const   )12,      (uint8_t const   )34,      (uint8_t const   )54,      (uint8_t const   )55, 
        (uint8_t const   )38,      (uint8_t const   )25,      (uint8_t const   )33,      (uint8_t const   )13, 
        (uint8_t const   )3,      (uint8_t const   )43,      (uint8_t const   )30,      (uint8_t const   )0, 
        (uint8_t const   )49,      (uint8_t const   )22,      (uint8_t const   )37,      (uint8_t const   )9, 
        (uint8_t const   )29,      (uint8_t const   )24,      (uint8_t const   )35,      (uint8_t const   )14, 
        (uint8_t const   )46,      (uint8_t const   )25,      (uint8_t const   )45,      (uint8_t const   )33, 
        (uint8_t const   )34,      (uint8_t const   )5,      (uint8_t const   )19,      (uint8_t const   )53, 
        (uint8_t const   )55,      (uint8_t const   )40,      (uint8_t const   )20,      (uint8_t const   )32, 
        (uint8_t const   )30,      (uint8_t const   )21,      (uint8_t const   )15,      (uint8_t const   )9, 
        (uint8_t const   )10,      (uint8_t const   )42,      (uint8_t const   )0,      (uint8_t const   )22, 
        (uint8_t const   )3,      (uint8_t const   )35,      (uint8_t const   )16,      (uint8_t const   )37, 
        (uint8_t const   )54,      (uint8_t const   )31,      (uint8_t const   )18,      (uint8_t const   )13, 
        (uint8_t const   )26,      (uint8_t const   )48,      (uint8_t const   )11,      (uint8_t const   )12, 
        (uint8_t const   )52,      (uint8_t const   )39,      (uint8_t const   )47,      (uint8_t const   )27, 
        (uint8_t const   )17,      (uint8_t const   )2,      (uint8_t const   )44,      (uint8_t const   )14, 
        (uint8_t const   )8,      (uint8_t const   )36,      (uint8_t const   )51,      (uint8_t const   )23, 
        (uint8_t const   )43,      (uint8_t const   )7,      (uint8_t const   )49,      (uint8_t const   )28, 
        (uint8_t const   )31,      (uint8_t const   )39,      (uint8_t const   )6,      (uint8_t const   )47, 
        (uint8_t const   )48,      (uint8_t const   )19,      (uint8_t const   )33,      (uint8_t const   )38, 
        (uint8_t const   )12,      (uint8_t const   )54,      (uint8_t const   )34,      (uint8_t const   )46, 
        (uint8_t const   )44,      (uint8_t const   )35,      (uint8_t const   )29,      (uint8_t const   )23, 
        (uint8_t const   )24,      (uint8_t const   )1,      (uint8_t const   )14,      (uint8_t const   )36, 
        (uint8_t const   )17,      (uint8_t const   )49,      (uint8_t const   )30,      (uint8_t const   )51, 
        (uint8_t const   )11,      (uint8_t const   )45,      (uint8_t const   )32,      (uint8_t const   )27, 
        (uint8_t const   )40,      (uint8_t const   )5,      (uint8_t const   )25,      (uint8_t const   )26, 
        (uint8_t const   )13,      (uint8_t const   )53,      (uint8_t const   )4,      (uint8_t const   )41, 
        (uint8_t const   )0,      (uint8_t const   )16,      (uint8_t const   )3,      (uint8_t const   )28, 
        (uint8_t const   )22,      (uint8_t const   )50,      (uint8_t const   )10,      (uint8_t const   )37, 
        (uint8_t const   )2,      (uint8_t const   )21,      (uint8_t const   )8,      (uint8_t const   )42, 
        (uint8_t const   )45,      (uint8_t const   )53,      (uint8_t const   )20,      (uint8_t const   )4, 
        (uint8_t const   )5,      (uint8_t const   )33,      (uint8_t const   )47,      (uint8_t const   )52, 
        (uint8_t const   )26,      (uint8_t const   )11,      (uint8_t const   )48,      (uint8_t const   )31, 
        (uint8_t const   )3,      (uint8_t const   )49,      (uint8_t const   )43,      (uint8_t const   )37, 
        (uint8_t const   )7,      (uint8_t const   )15,      (uint8_t const   )28,      (uint8_t const   )50, 
        (uint8_t const   )0,      (uint8_t const   )8,      (uint8_t const   )44,      (uint8_t const   )10, 
        (uint8_t const   )25,      (uint8_t const   )6,      (uint8_t const   )46,      (uint8_t const   )41, 
        (uint8_t const   )54,      (uint8_t const   )19,      (uint8_t const   )39,      (uint8_t const   )40, 
        (uint8_t const   )27,      (uint8_t const   )38,      (uint8_t const   )18,      (uint8_t const   )55, 
        (uint8_t const   )14,      (uint8_t const   )30,      (uint8_t const   )17,      (uint8_t const   )42, 
        (uint8_t const   )36,      (uint8_t const   )9,      (uint8_t const   )24,      (uint8_t const   )51, 
        (uint8_t const   )16,      (uint8_t const   )35,      (uint8_t const   )22,      (uint8_t const   )1, 
        (uint8_t const   )6,      (uint8_t const   )38,      (uint8_t const   )34,      (uint8_t const   )18, 
        (uint8_t const   )19,      (uint8_t const   )47,      (uint8_t const   )4,      (uint8_t const   )13, 
        (uint8_t const   )40,      (uint8_t const   )25,      (uint8_t const   )5,      (uint8_t const   )45, 
        (uint8_t const   )17,      (uint8_t const   )8,      (uint8_t const   )2,      (uint8_t const   )51, 
        (uint8_t const   )21,      (uint8_t const   )29,      (uint8_t const   )42,      (uint8_t const   )9, 
        (uint8_t const   )14,      (uint8_t const   )22,      (uint8_t const   )3,      (uint8_t const   )24, 
        (uint8_t const   )39,      (uint8_t const   )20,      (uint8_t const   )31,      (uint8_t const   )55, 
        (uint8_t const   )11,      (uint8_t const   )33,      (uint8_t const   )53,      (uint8_t const   )54, 
        (uint8_t const   )41,      (uint8_t const   )52,      (uint8_t const   )32,      (uint8_t const   )12, 
        (uint8_t const   )28,      (uint8_t const   )44,      (uint8_t const   )0,      (uint8_t const   )1, 
        (uint8_t const   )50,      (uint8_t const   )23,      (uint8_t const   )7,      (uint8_t const   )10, 
        (uint8_t const   )30,      (uint8_t const   )49,      (uint8_t const   )36,      (uint8_t const   )15, 
        (uint8_t const   )20,      (uint8_t const   )52,      (uint8_t const   )48,      (uint8_t const   )32, 
        (uint8_t const   )33,      (uint8_t const   )4,      (uint8_t const   )18,      (uint8_t const   )27, 
        (uint8_t const   )54,      (uint8_t const   )39,      (uint8_t const   )19,      (uint8_t const   )6, 
        (uint8_t const   )0,      (uint8_t const   )22,      (uint8_t const   )16,      (uint8_t const   )10, 
        (uint8_t const   )35,      (uint8_t const   )43,      (uint8_t const   )1,      (uint8_t const   )23, 
        (uint8_t const   )28,      (uint8_t const   )36,      (uint8_t const   )17,      (uint8_t const   )7, 
        (uint8_t const   )53,      (uint8_t const   )34,      (uint8_t const   )45,      (uint8_t const   )12, 
        (uint8_t const   )25,      (uint8_t const   )47,      (uint8_t const   )38,      (uint8_t const   )11, 
        (uint8_t const   )55,      (uint8_t const   )13,      (uint8_t const   )46,      (uint8_t const   )26, 
        (uint8_t const   )42,      (uint8_t const   )3,      (uint8_t const   )14,      (uint8_t const   )15, 
        (uint8_t const   )9,      (uint8_t const   )37,      (uint8_t const   )21,      (uint8_t const   )24, 
        (uint8_t const   )44,      (uint8_t const   )8,      (uint8_t const   )50,      (uint8_t const   )29, 
        (uint8_t const   )27,      (uint8_t const   )6,      (uint8_t const   )55,      (uint8_t const   )39, 
        (uint8_t const   )40,      (uint8_t const   )11,      (uint8_t const   )25,      (uint8_t const   )34, 
        (uint8_t const   )4,      (uint8_t const   )46,      (uint8_t const   )26,      (uint8_t const   )13, 
        (uint8_t const   )7,      (uint8_t const   )29,      (uint8_t const   )23,      (uint8_t const   )17, 
        (uint8_t const   )42,      (uint8_t const   )50,      (uint8_t const   )8,      (uint8_t const   )30, 
        (uint8_t const   )35,      (uint8_t const   )43,      (uint8_t const   )24,      (uint8_t const   )14, 
        (uint8_t const   )31,      (uint8_t const   )41,      (uint8_t const   )52,      (uint8_t const   )19, 
        (uint8_t const   )32,      (uint8_t const   )54,      (uint8_t const   )45,      (uint8_t const   )18, 
        (uint8_t const   )5,      (uint8_t const   )20,      (uint8_t const   )53,      (uint8_t const   )33, 
        (uint8_t const   )49,      (uint8_t const   )10,      (uint8_t const   )21,      (uint8_t const   )22, 
        (uint8_t const   )16,      (uint8_t const   )44,      (uint8_t const   )28,      (uint8_t const   )0, 
        (uint8_t const   )51,      (uint8_t const   )15,      (uint8_t const   )2,      (uint8_t const   )36};
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c"
static char const   parity[256]  = 
#line 54
  {      (char const   )8,      (char const   )1,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )2,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )3, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )4,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )8,      (char const   )0,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )5,      (char const   )0,      (char const   )8, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )0,      (char const   )8,      (char const   )8,      (char const   )0, 
        (char const   )8,      (char const   )0,      (char const   )6,      (char const   )8};
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c"
static void DesSmallFipsEncrypt(uint8_t *d , uint32_t const   *r , uint8_t const   *s ) 
{ 
  register uint32_t x ;
  register uint32_t y ;
  register uint32_t z ;

  {
#line 59
  x = (uint32_t )*(s + 7);
#line 59
  x <<= 8;
#line 59
  x |= (unsigned int )*(s + 6);
#line 59
  x <<= 8;
#line 59
  x |= (unsigned int )*(s + 5);
#line 59
  x <<= 8;
#line 59
  x |= (unsigned int )*(s + 4);
#line 59
  y = (uint32_t )*(s + 3);
#line 59
  y <<= 8;
#line 59
  y |= (unsigned int )*(s + 2);
#line 59
  y <<= 8;
#line 59
  y |= (unsigned int )*(s + 1);
#line 59
  y <<= 8;
#line 59
  y |= (unsigned int )*(s + 0);
#line 59
  z = (uint32_t )((long )((x >> 4) ^ y) & 252645135L);
#line 59
  x ^= z << 4;
#line 59
  y ^= z;
#line 59
  z = (uint32_t )((long )((y >> 16) ^ x) & 65535L);
#line 59
  y ^= z << 16;
#line 59
  x ^= z;
#line 59
  z = (uint32_t )((long )((x >> 2) ^ y) & 858993459L);
#line 59
  x ^= z << 2;
#line 59
  y ^= z;
#line 59
  z = (uint32_t )((long )((y >> 8) ^ x) & 16711935L);
#line 59
  y ^= z << 8;
#line 59
  x ^= z;
#line 59
  x = (x >> 1) | (x << 31);
#line 59
  z = (uint32_t )((long )(x ^ y) & 1431655765L);
#line 59
  y ^= z;
#line 59
  x ^= z;
#line 59
  y = (y >> 1) | (y << 31);
#line 59
  z = (uint32_t )*(r + 0);
#line 59
  z ^= y;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 1);
#line 59
  z ^= y;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 2);
#line 59
  z ^= x;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 3);
#line 59
  z ^= x;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 4);
#line 59
  z ^= y;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 5);
#line 59
  z ^= y;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 6);
#line 59
  z ^= x;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 7);
#line 59
  z ^= x;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 8);
#line 59
  z ^= y;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 9);
#line 59
  z ^= y;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 10);
#line 59
  z ^= x;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 11);
#line 59
  z ^= x;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 12);
#line 59
  z ^= y;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 13);
#line 59
  z ^= y;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 14);
#line 59
  z ^= x;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 15);
#line 59
  z ^= x;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 16);
#line 59
  z ^= y;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 17);
#line 59
  z ^= y;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 18);
#line 59
  z ^= x;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 19);
#line 59
  z ^= x;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 20);
#line 59
  z ^= y;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 21);
#line 59
  z ^= y;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 22);
#line 59
  z ^= x;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 23);
#line 59
  z ^= x;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 24);
#line 59
  z ^= y;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 25);
#line 59
  z ^= y;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 26);
#line 59
  z ^= x;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 27);
#line 59
  z ^= x;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 28);
#line 59
  z ^= y;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 29);
#line 59
  z ^= y;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 30);
#line 59
  z ^= x;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 59
  z = (uint32_t )*(r + 31);
#line 59
  z ^= x;
#line 59
  z = (z << 4) | (z >> 28);
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 59
  z >>= 8;
#line 59
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 59
  x = (x << 1) | (x >> 31);
#line 59
  z = (uint32_t )((long )(x ^ y) & 1431655765L);
#line 59
  y ^= z;
#line 59
  x ^= z;
#line 59
  y = (y << 1) | (y >> 31);
#line 59
  z = (uint32_t )((long )((x >> 8) ^ y) & 16711935L);
#line 59
  x ^= z << 8;
#line 59
  y ^= z;
#line 59
  z = (uint32_t )((long )((y >> 2) ^ x) & 858993459L);
#line 59
  y ^= z << 2;
#line 59
  x ^= z;
#line 59
  z = (uint32_t )((long )((x >> 16) ^ y) & 65535L);
#line 59
  x ^= z << 16;
#line 59
  y ^= z;
#line 59
  z = (uint32_t )((long )((y >> 4) ^ x) & 252645135L);
#line 59
  y ^= z << 4;
#line 59
  x ^= z;
#line 59
  *(d + 0) = (uint8_t )x;
#line 59
  x >>= 8;
#line 59
  *(d + 1) = (uint8_t )x;
#line 59
  x >>= 8;
#line 59
  *(d + 2) = (uint8_t )x;
#line 59
  x >>= 8;
#line 59
  *(d + 3) = (uint8_t )x;
#line 59
  *(d + 4) = (uint8_t )y;
#line 59
  y >>= 8;
#line 59
  *(d + 5) = (uint8_t )y;
#line 59
  y >>= 8;
#line 59
  *(d + 6) = (uint8_t )y;
#line 59
  y >>= 8;
#line 59
  *(d + 7) = (uint8_t )y;
#line 59
  return;
}
}
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c"
static void DesSmallFipsDecrypt(uint8_t *d , uint32_t const   *r , uint8_t const   *s ) 
{ 
  register uint32_t x ;
  register uint32_t y ;
  register uint32_t z ;

  {
#line 60
  x = (uint32_t )*(s + 7);
#line 60
  x <<= 8;
#line 60
  x |= (unsigned int )*(s + 6);
#line 60
  x <<= 8;
#line 60
  x |= (unsigned int )*(s + 5);
#line 60
  x <<= 8;
#line 60
  x |= (unsigned int )*(s + 4);
#line 60
  y = (uint32_t )*(s + 3);
#line 60
  y <<= 8;
#line 60
  y |= (unsigned int )*(s + 2);
#line 60
  y <<= 8;
#line 60
  y |= (unsigned int )*(s + 1);
#line 60
  y <<= 8;
#line 60
  y |= (unsigned int )*(s + 0);
#line 60
  z = (uint32_t )((long )((x >> 4) ^ y) & 252645135L);
#line 60
  x ^= z << 4;
#line 60
  y ^= z;
#line 60
  z = (uint32_t )((long )((y >> 16) ^ x) & 65535L);
#line 60
  y ^= z << 16;
#line 60
  x ^= z;
#line 60
  z = (uint32_t )((long )((x >> 2) ^ y) & 858993459L);
#line 60
  x ^= z << 2;
#line 60
  y ^= z;
#line 60
  z = (uint32_t )((long )((y >> 8) ^ x) & 16711935L);
#line 60
  y ^= z << 8;
#line 60
  x ^= z;
#line 60
  x = (x >> 1) | (x << 31);
#line 60
  z = (uint32_t )((long )(x ^ y) & 1431655765L);
#line 60
  y ^= z;
#line 60
  x ^= z;
#line 60
  y = (y >> 1) | (y << 31);
#line 60
  z = (uint32_t )*(r + 31);
#line 60
  z ^= y;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 30);
#line 60
  z ^= y;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 29);
#line 60
  z ^= x;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 28);
#line 60
  z ^= x;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 27);
#line 60
  z ^= y;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 26);
#line 60
  z ^= y;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 25);
#line 60
  z ^= x;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 24);
#line 60
  z ^= x;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 23);
#line 60
  z ^= y;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 22);
#line 60
  z ^= y;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 21);
#line 60
  z ^= x;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 20);
#line 60
  z ^= x;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 19);
#line 60
  z ^= y;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 18);
#line 60
  z ^= y;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 17);
#line 60
  z ^= x;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 16);
#line 60
  z ^= x;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 15);
#line 60
  z ^= y;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 14);
#line 60
  z ^= y;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 13);
#line 60
  z ^= x;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 12);
#line 60
  z ^= x;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 11);
#line 60
  z ^= y;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 10);
#line 60
  z ^= y;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 9);
#line 60
  z ^= x;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 8);
#line 60
  z ^= x;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 7);
#line 60
  z ^= y;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 6);
#line 60
  z ^= y;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 5);
#line 60
  z ^= x;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 4);
#line 60
  z ^= x;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 3);
#line 60
  z ^= y;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 2);
#line 60
  z ^= y;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  x ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 1);
#line 60
  z ^= x;
#line 60
  z = (z << 4) | (z >> 28);
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 448) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 384) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 320) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 256) + (252U & z)));
#line 60
  z = (uint32_t )*(r + 0);
#line 60
  z ^= x;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 192) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 128) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap + 64) + (252U & z)));
#line 60
  z >>= 8;
#line 60
  y ^= *((uint32_t *)((uint8_t *)(des_keymap) + (252U & z)));
#line 60
  x = (x << 1) | (x >> 31);
#line 60
  z = (uint32_t )((long )(x ^ y) & 1431655765L);
#line 60
  y ^= z;
#line 60
  x ^= z;
#line 60
  y = (y << 1) | (y >> 31);
#line 60
  z = (uint32_t )((long )((x >> 8) ^ y) & 16711935L);
#line 60
  x ^= z << 8;
#line 60
  y ^= z;
#line 60
  z = (uint32_t )((long )((y >> 2) ^ x) & 858993459L);
#line 60
  y ^= z << 2;
#line 60
  x ^= z;
#line 60
  z = (uint32_t )((long )((x >> 16) ^ y) & 65535L);
#line 60
  x ^= z << 16;
#line 60
  y ^= z;
#line 60
  z = (uint32_t )((long )((y >> 4) ^ x) & 252645135L);
#line 60
  y ^= z << 4;
#line 60
  x ^= z;
#line 60
  *(d + 0) = (uint8_t )x;
#line 60
  x >>= 8;
#line 60
  *(d + 1) = (uint8_t )x;
#line 60
  x >>= 8;
#line 60
  *(d + 2) = (uint8_t )x;
#line 60
  x >>= 8;
#line 60
  *(d + 3) = (uint8_t )x;
#line 60
  *(d + 4) = (uint8_t )y;
#line 60
  y >>= 8;
#line 60
  *(d + 5) = (uint8_t )y;
#line 60
  y >>= 8;
#line 60
  *(d + 6) = (uint8_t )y;
#line 60
  y >>= 8;
#line 60
  *(d + 7) = (uint8_t )y;
#line 60
  return;
}
}
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c"
void nettle_des_fix_parity(unsigned int length , uint8_t *dst , uint8_t const   *src ) 
{ 
  unsigned int i ;

  {
#line 67
  i = 0U;
  {
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 67
    if (! (i < length)) {
#line 67
      goto while_break;
    }
#line 68
    *(dst + i) = (uint8_t )((int const   )*(src + i) ^ (int const   )((int const   )parity[*(src + i)] == 8));
#line 67
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 69
  return;
}
}
#line 71 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c"
int nettle_des_set_key(struct des_ctx *ctx , uint8_t const   *key ) 
{ 
  register uint32_t n ;
  register uint32_t w ;
  register char *b0 ;
  register char *b1 ;
  char bits0[56] ;
  char bits1[56] ;
  uint32_t *method ;
  uint8_t const   *k ;
  register char const   *b ;
  uint8_t const   *tmp ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;

  {
#line 83
  b = parity;
#line 84
  n = (uint32_t )*(b + (int const   )*(key + 0));
#line 84
  n <<= 4;
#line 85
  n |= (unsigned int )*(b + (int const   )*(key + 1));
#line 85
  n <<= 4;
#line 86
  n |= (unsigned int )*(b + (int const   )*(key + 2));
#line 86
  n <<= 4;
#line 87
  n |= (unsigned int )*(b + (int const   )*(key + 3));
#line 87
  n <<= 4;
#line 88
  n |= (unsigned int )*(b + (int const   )*(key + 4));
#line 88
  n <<= 4;
#line 89
  n |= (unsigned int )*(b + (int const   )*(key + 5));
#line 89
  n <<= 4;
#line 90
  n |= (unsigned int )*(b + (int const   )*(key + 6));
#line 90
  n <<= 4;
#line 91
  n |= (unsigned int )*(b + (int const   )*(key + 7));
#line 92
  w = (uint32_t )2290649224L;
#line 96
  if (n & w) {
#line 98
    ctx->status = (enum des_error )1;
#line 99
    return (0);
  }
#line 101
  ctx->status = (enum des_error )0;
#line 104
  if (! ((n - (w >> 3)) & w)) {
#line 105
    if (n < 1094799697U) {
#line 106
      if (n < 825303329U) {
#line 107
        if (n < 336860437U) {
#line 109
          if (n == 286331153U) {
#line 109
            goto weak;
          }
#line 111
          if (n == 320016914U) {
#line 111
            goto weak;
          }
        } else {
#line 114
          if (n == 336860437U) {
#line 114
            goto weak;
          }
#line 116
          if (n == 370546198U) {
#line 116
            goto weak;
          }
        }
      } else
#line 119
      if (n < 875832613U) {
#line 121
        if (n == 825303329U) {
#line 121
          goto weak;
        }
#line 123
        if (n == 858989090U) {
#line 123
          goto weak;
        }
      } else {
#line 126
        if (n == 875832613U) {
#line 126
          goto weak;
        }
#line 128
        if (n == 909518374U) {
#line 128
          goto weak;
        }
      }
    } else
#line 132
    if (n < 1633771873U) {
#line 133
      if (n < 1145328981U) {
#line 135
        if (n == 1094799697U) {
#line 135
          goto weak;
        }
#line 137
        if (n == 1128485458U) {
#line 137
          goto weak;
        }
      } else {
#line 140
        if (n == 1145328981U) {
#line 140
          goto weak;
        }
#line 142
        if (n == 1179014742U) {
#line 142
          goto weak;
        }
      }
    } else
#line 145
    if (n < 1684301157U) {
#line 147
      if (n == 1633771873U) {
#line 147
        goto weak;
      }
#line 149
      if (n == 1667457634U) {
#line 149
        goto weak;
      }
    } else {
#line 152
      if (n == 1684301157U) {
#line 152
        goto weak;
      }
#line 154
      if (n == 1717986918U) {
        weak: 
#line 157
        ctx->status = (enum des_error )2;
      }
    }
  }
#line 166
  n = (uint32_t )56;
#line 167
  b0 = bits0;
#line 168
  b1 = bits1;
  {
  {
#line 169
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 170
    tmp = key;
#line 170
    key ++;
#line 170
    w = (uint32_t )((256 | (int )*tmp) << 2);
    {
    {
#line 171
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 172
      n --;
#line 173
      *(b1 + n) = (char )(8U & w);
#line 174
      w >>= 1;
#line 175
      *(b0 + n) = (char )(4U & w);
#line 171
      if (! (w >= 16U)) {
#line 171
        goto while_break___0;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
#line 169
    if (! n) {
#line 169
      goto while_break;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 180
  n = (uint32_t )16;
#line 181
  k = rotors;
#line 182
  method = ctx->key;
  {
  {
#line 184
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 185
    w = (uint32_t )(((int )*(b1 + (int const   )*(k + 0)) | (int )*(b0 + (int const   )*(k + 1))) << 4);
#line 186
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 2)) | (int )*(b0 + (int const   )*(k + 3))) << 2);
#line 187
    w |= (unsigned int )((int )*(b1 + (int const   )*(k + 4)) | (int )*(b0 + (int const   )*(k + 5)));
#line 188
    w <<= 8;
#line 189
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 6)) | (int )*(b0 + (int const   )*(k + 7))) << 4);
#line 190
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 8)) | (int )*(b0 + (int const   )*(k + 9))) << 2);
#line 191
    w |= (unsigned int )((int )*(b1 + (int const   )*(k + 10)) | (int )*(b0 + (int const   )*(k + 11)));
#line 192
    w <<= 8;
#line 193
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 12)) | (int )*(b0 + (int const   )*(k + 13))) << 4);
#line 194
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 14)) | (int )*(b0 + (int const   )*(k + 15))) << 2);
#line 195
    w |= (unsigned int )((int )*(b1 + (int const   )*(k + 16)) | (int )*(b0 + (int const   )*(k + 17)));
#line 196
    w <<= 8;
#line 197
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 18)) | (int )*(b0 + (int const   )*(k + 19))) << 4);
#line 198
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 20)) | (int )*(b0 + (int const   )*(k + 21))) << 2);
#line 199
    w |= (unsigned int )((int )*(b1 + (int const   )*(k + 22)) | (int )*(b0 + (int const   )*(k + 23)));
#line 201
    *(method + 0) = w;
#line 203
    w = (uint32_t )(((int )*(b1 + (int const   )*(k + 24)) | (int )*(b0 + (int const   )*(k + 25))) << 4);
#line 204
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 26)) | (int )*(b0 + (int const   )*(k + 27))) << 2);
#line 205
    w |= (unsigned int )((int )*(b1 + (int const   )*(k + 28)) | (int )*(b0 + (int const   )*(k + 29)));
#line 206
    w <<= 8;
#line 207
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 30)) | (int )*(b0 + (int const   )*(k + 31))) << 4);
#line 208
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 32)) | (int )*(b0 + (int const   )*(k + 33))) << 2);
#line 209
    w |= (unsigned int )((int )*(b1 + (int const   )*(k + 34)) | (int )*(b0 + (int const   )*(k + 35)));
#line 210
    w <<= 8;
#line 211
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 36)) | (int )*(b0 + (int const   )*(k + 37))) << 4);
#line 212
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 38)) | (int )*(b0 + (int const   )*(k + 39))) << 2);
#line 213
    w |= (unsigned int )((int )*(b1 + (int const   )*(k + 40)) | (int )*(b0 + (int const   )*(k + 41)));
#line 214
    w <<= 8;
#line 215
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 42)) | (int )*(b0 + (int const   )*(k + 43))) << 4);
#line 216
    w |= (unsigned int )(((int )*(b1 + (int const   )*(k + 44)) | (int )*(b0 + (int const   )*(k + 45))) << 2);
#line 217
    w |= (unsigned int )((int )*(b1 + (int const   )*(k + 46)) | (int )*(b0 + (int const   )*(k + 47)));
#line 219
    w = (w >> 4) | (w << 28);
#line 220
    *(method + 1) = w;
#line 222
    k += 48;
#line 223
    method += 2;
#line 184
    n --;
#line 184
    if (! n) {
#line 184
      goto while_break___1;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 226
  return ((unsigned int )ctx->status == 0U);
}
}
#line 229 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c"
void nettle_des_encrypt(struct des_ctx  const  *ctx , unsigned int length , uint8_t *dst ,
                        uint8_t const   *src ) 
{ 
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 234
  if (! (! (length % 8U))) {
    {
    {
#line 234
    __assert_fail("!(length % 8)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c",
                  234U, "nettle_des_encrypt");
    }
    }
  }
#line 235
  if (! ((unsigned int const   )ctx->status == 0U)) {
    {
    {
#line 235
    __assert_fail("ctx->status == DES_OK", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c",
                  235U, "nettle_des_encrypt");
    }
    }
  }
  {
  {
#line 237
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 237
    if (! length) {
#line 237
      goto while_break;
    }
    {
    {
#line 239
    DesSmallFipsEncrypt(dst, (uint32_t const   *)(ctx->key), src);
    }
#line 240
    length -= 8U;
#line 241
    src += 8;
#line 242
    dst += 8;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 244
  return;
}
}
#line 246 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c"
void nettle_des_decrypt(struct des_ctx  const  *ctx , unsigned int length , uint8_t *dst ,
                        uint8_t const   *src ) 
{ 
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 251
  if (! (! (length % 8U))) {
    {
    {
#line 251
    __assert_fail("!(length % 8)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c",
                  251U, "nettle_des_decrypt");
    }
    }
  }
#line 252
  if (! ((unsigned int const   )ctx->status == 0U)) {
    {
    {
#line 252
    __assert_fail("ctx->status == DES_OK", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des.c",
                  252U, "nettle_des_decrypt");
    }
    }
  }
  {
  {
#line 254
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 254
    if (! length) {
#line 254
      goto while_break;
    }
    {
    {
#line 256
    DesSmallFipsDecrypt(dst, (uint32_t const   *)(ctx->key), src);
    }
#line 257
    length -= 8U;
#line 258
    src += 8;
#line 259
    dst += 8;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 261
  return;
}
}
#line 88 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.h"
int nettle_openssl_des_check_key ;
#line 100
void nettle_openssl_des_ecb3_encrypt(des_cblock *src , des_cblock *dst , struct des_ctx *k1 ,
                                     struct des_ctx *k2 , struct des_ctx *k3 , int enc ) ;
#line 108
uint32_t nettle_openssl_des_cbc_cksum(uint8_t const   *src , des_cblock *dst , long length ,
                                      struct des_ctx *ctx , des_cblock *iv ) ;
#line 114
void nettle_openssl_des_cbc_encrypt(des_cblock *src , des_cblock *dst , long length ,
                                    struct des_ctx *ctx , des_cblock *civ , int enc ) ;
#line 120
void nettle_openssl_des_ncbc_encrypt(des_cblock *src , des_cblock *dst , long length ,
                                     struct des_ctx *ctx , des_cblock *iv , int enc ) ;
#line 125
void nettle_openssl_des_ecb_encrypt(des_cblock *src , des_cblock *dst , struct des_ctx *ctx ,
                                    int enc ) ;
#line 129
void nettle_openssl_des_ede3_cbc_encrypt(des_cblock *src , des_cblock *dst , long length ,
                                         struct des_ctx *k1 , struct des_ctx *k2 ,
                                         struct des_ctx *k3 , des_cblock *iv , int enc ) ;
#line 137
int nettle_openssl_des_set_odd_parity(des_cblock *key ) ;
#line 140
int nettle_openssl_des_key_sched(des_cblock *key , struct des_ctx *ctx ) ;
#line 143
int nettle_openssl_des_is_weak_key(des_cblock *key ) ;
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cbc.h"
void nettle_cbc_encrypt(void *ctx , void (*f)(void *ctx , unsigned int length , uint8_t *dst ,
                                              uint8_t const   *src ) , unsigned int block_size ,
                        uint8_t *iv , unsigned int length , uint8_t *dst , uint8_t const   *src ) ;
#line 41
void nettle_cbc_decrypt(void *ctx , void (*f)(void *ctx , unsigned int length , uint8_t *dst ,
                                              uint8_t const   *src ) , unsigned int block_size ,
                        uint8_t *iv , unsigned int length , uint8_t *dst , uint8_t const   *src ) ;
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.c"
static void des_compat_des3_encrypt(struct des_compat_des3 *ctx , uint32_t length ,
                                    uint8_t *dst , uint8_t const   *src ) 
{ 


  {
  {
  {
#line 45
  nettle_des_encrypt(ctx->keys[0], length, dst, src);
  }
  {
#line 46
  nettle_des_decrypt(ctx->keys[1], length, dst, (uint8_t const   *)dst);
  }
  {
#line 47
  nettle_des_encrypt(ctx->keys[2], length, dst, (uint8_t const   *)dst);
  }
  }
#line 48
  return;
}
}
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.c"
static void des_compat_des3_decrypt(struct des_compat_des3 *ctx , uint32_t length ,
                                    uint8_t *dst , uint8_t const   *src ) 
{ 


  {
  {
  {
#line 54
  nettle_des_decrypt(ctx->keys[2], length, dst, src);
  }
  {
#line 55
  nettle_des_encrypt(ctx->keys[1], length, dst, (uint8_t const   *)dst);
  }
  {
#line 56
  nettle_des_decrypt(ctx->keys[0], length, dst, (uint8_t const   *)dst);
  }
  }
#line 57
  return;
}
}
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.c"
void nettle_openssl_des_ecb3_encrypt(des_cblock *src , des_cblock *dst , struct des_ctx *k1 ,
                                     struct des_ctx *k2 , struct des_ctx *k3 , int enc ) 
{ 
  struct des_compat_des3 keys ;
  void (*tmp)(struct des_compat_des3 *ctx , uint32_t length , uint8_t *dst , uint8_t const   *src ) ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;

  {
#line 66
  keys.keys[0] = (struct des_ctx  const  *)k1;
#line 67
  keys.keys[1] = (struct des_ctx  const  *)k2;
#line 68
  keys.keys[2] = (struct des_ctx  const  *)k3;
#line 70
  if (enc == 1) {
#line 70
    tmp = & des_compat_des3_encrypt;
  } else {
#line 70
    tmp = & des_compat_des3_decrypt;
  }
  {
  {
#line 70
  (*tmp)(& keys, (uint32_t )8, *dst, (uint8_t const   *)(*src));
  }
  }
#line 72
  return;
}
}
#line 78 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.c"
uint32_t nettle_openssl_des_cbc_cksum(uint8_t const   *src , des_cblock *dst , long length ,
                                      struct des_ctx *ctx , des_cblock *iv ) 
{ 
  uint8_t block[8] ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
  {
#line 88
  memcpy((void */* __restrict  */)((void *)(block)), (void const   */* __restrict  */)((void const   *)(*iv)),
         (size_t )8);
  }
  }
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 90
    if (! (length >= 8L)) {
#line 90
      goto while_break;
    }
    {
    {
#line 92
    memxor(block, src, (size_t )8);
    }
    {
#line 93
    nettle_des_encrypt((struct des_ctx  const  *)ctx, 8U, block, (uint8_t const   *)(block));
    }
#line 95
    src += 8;
#line 96
    length -= 8L;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 98
  if (length > 0L) {
    {
    {
#line 100
    memxor(block, src, (size_t )length);
    }
    {
#line 101
    nettle_des_encrypt((struct des_ctx  const  *)ctx, 8U, block, (uint8_t const   *)(block));
    }
    }
  }
  {
  {
#line 103
  memcpy((void */* __restrict  */)((void *)(*dst)), (void const   */* __restrict  */)((void const   *)(block)),
         (size_t )8);
  }
  }
#line 105
  return (((((uint32_t )*((block + 4) + 3) << 24) | ((uint32_t )*((block + 4) + 2) << 16)) | ((uint32_t )*((block + 4) + 1) << 8)) | (uint32_t )*((block + 4) + 0));
}
}
#line 108 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.c"
void nettle_openssl_des_ncbc_encrypt(des_cblock *src , des_cblock *dst , long length ,
                                     struct des_ctx *ctx , des_cblock *iv , int enc ) 
{ 


  {
#line 115
  if (enc == 1) {
#line 115
    goto case_1;
  }
#line 120
  if (enc == 0) {
#line 120
    goto case_0;
  }
#line 126
  goto switch_default;
  case_1: 
  {
  {
#line 116
  nettle_cbc_encrypt((void *)ctx, (void (*)(void *ctx , unsigned int length , uint8_t *dst ,
                                            uint8_t const   *src ))(& nettle_des_encrypt),
                     8U, *iv, (unsigned int )length, *dst, (uint8_t const   *)(*src));
  }
  }
#line 119
  goto switch_break;
  case_0: 
  {
  {
#line 121
  nettle_cbc_decrypt((void *)ctx, (void (*)(void *ctx , unsigned int length , uint8_t *dst ,
                                            uint8_t const   *src ))(& nettle_des_decrypt),
                     8U, *iv, (unsigned int )length, *dst, (uint8_t const   *)(*src));
  }
  }
#line 125
  goto switch_break;
  switch_default: 
  {
  {
#line 127
  abort();
  }
  }
  switch_break: ;
#line 129
  return;
}
}
#line 131 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.c"
void nettle_openssl_des_cbc_encrypt(des_cblock *src , des_cblock *dst , long length ,
                                    struct des_ctx *ctx , des_cblock *civ , int enc ) 
{ 
  des_cblock iv ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
  {
#line 138
  memcpy((void */* __restrict  */)((void *)(iv)), (void const   */* __restrict  */)((void const   *)civ),
         (size_t )8);
  }
  {
#line 140
  nettle_openssl_des_ncbc_encrypt(src, dst, length, ctx, & iv, enc);
  }
  }
#line 141
  return;
}
}
#line 144 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.c"
void nettle_openssl_des_ecb_encrypt(des_cblock *src , des_cblock *dst , struct des_ctx *ctx ,
                                    int enc ) 
{ 
  void (*tmp)(struct des_ctx  const  *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ) ;

  {
#line 149
  if (enc == 1) {
#line 149
    tmp = & nettle_des_encrypt;
  } else {
#line 149
    tmp = & nettle_des_decrypt;
  }
  {
  {
#line 149
  (*tmp)((struct des_ctx  const  *)ctx, 8U, *dst, (uint8_t const   *)(*src));
  }
  }
#line 151
  return;
}
}
#line 153 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.c"
void nettle_openssl_des_ede3_cbc_encrypt(des_cblock *src , des_cblock *dst , long length ,
                                         struct des_ctx *k1 , struct des_ctx *k2 ,
                                         struct des_ctx *k3 , des_cblock *iv , int enc ) 
{ 
  struct des_compat_des3 keys ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
#line 162
  keys.keys[0] = (struct des_ctx  const  *)k1;
#line 163
  keys.keys[1] = (struct des_ctx  const  *)k2;
#line 164
  keys.keys[2] = (struct des_ctx  const  *)k3;
#line 168
  if (enc == 1) {
#line 168
    goto case_1;
  }
#line 173
  if (enc == 0) {
#line 173
    goto case_0;
  }
#line 178
  goto switch_default;
  case_1: 
  {
  {
#line 169
  nettle_cbc_encrypt((void *)(& keys), (void (*)(void *ctx , unsigned int length ,
                                                 uint8_t *dst , uint8_t const   *src ))(& des_compat_des3_encrypt),
                     8U, *iv, (unsigned int )length, *dst, (uint8_t const   *)(*src));
  }
  }
#line 172
  goto switch_break;
  case_0: 
  {
  {
#line 174
  nettle_cbc_decrypt((void *)(& keys), (void (*)(void *ctx , unsigned int length ,
                                                 uint8_t *dst , uint8_t const   *src ))(& des_compat_des3_decrypt),
                     8U, *iv, (unsigned int )length, *dst, (uint8_t const   *)(*src));
  }
  }
#line 177
  goto switch_break;
  switch_default: 
  {
  {
#line 179
  abort();
  }
  }
  switch_break: ;
#line 181
  return;
}
}
#line 183 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.c"
int nettle_openssl_des_set_odd_parity(des_cblock *key ) 
{ 


  {
  {
  {
#line 186
  nettle_des_fix_parity(8U, *key, (uint8_t const   *)(*key));
  }
  }
#line 189
  return (0);
}
}
#line 200 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.c"
int nettle_openssl_des_check_key  =    0;
#line 202 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.c"
int nettle_openssl_des_key_sched(des_cblock *key , struct des_ctx *ctx ) 
{ 
  des_cblock nkey ;
  uint8_t const   *pkey ;
  int tmp ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
#line 208
  if (nettle_openssl_des_check_key) {
#line 209
    pkey = (uint8_t const   *)(*key);
  } else {
    {
    {
#line 213
    nettle_des_fix_parity(8U, nkey, (uint8_t const   *)(*key));
    }
#line 214
    pkey = (uint8_t const   *)(nkey);
    }
  }
  {
  {
#line 217
  tmp = nettle_des_set_key(ctx, pkey);
  }
  }
#line 217
  if (tmp) {
#line 218
    return (0);
  } else {
#line 221
    if ((unsigned int )ctx->status == 1U) {
#line 221
      goto case_1;
    }
#line 227
    if ((unsigned int )ctx->status == 2U) {
#line 227
      goto case_2;
    }
#line 235
    goto switch_default;
    case_1: 
#line 222
    if (nettle_openssl_des_check_key) {
#line 223
      return (-1);
    } else {
      {
      {
#line 226
      abort();
      }
      }
    }
    case_2: 
#line 228
    if (nettle_openssl_des_check_key) {
#line 229
      return (-2);
    }
#line 232
    ctx->status = (enum des_error )0;
#line 233
    return (0);
    switch_default: 
    {
    {
#line 236
    abort();
    }
    }

  }
#line 242
  return (0);
}
}
#line 240 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/des-compat.c"
int nettle_openssl_des_is_weak_key(des_cblock *key ) 
{ 
  struct des_ctx ctx ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
  {
#line 245
  tmp = nettle_des_set_key(& ctx, (uint8_t const   *)(*key));
  }
  }
#line 245
  if (tmp) {
#line 245
    tmp___0 = 0;
  } else {
#line 245
    tmp___0 = 1;
  }
#line 245
  return (tmp___0);
}
}
#line 292 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/rsa.h"
int nettle_rsa_public_key_from_der_iterator(struct rsa_public_key *pub , unsigned int limit ,
                                            struct asn1_der_iterator *i ) ;
#line 297
int nettle_rsa_private_key_from_der_iterator(struct rsa_public_key *pub , struct rsa_private_key *priv ,
                                             unsigned int limit , struct asn1_der_iterator *i ) ;
#line 304
int nettle_rsa_keypair_from_der(struct rsa_public_key *pub , struct rsa_private_key *priv ,
                                unsigned int limit , unsigned int length , uint8_t const   *data ) ;
#line 93 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.h"
int nettle_asn1_der_get_bignum(struct asn1_der_iterator *i , __mpz_struct *x , unsigned int limit ) ;
#line 106 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/asn1.h"
enum asn1_iterator_result nettle_asn1_der_iterator_first(struct asn1_der_iterator *i ,
                                                         unsigned int length , uint8_t const   *input ) ;
#line 110
enum asn1_iterator_result nettle_asn1_der_iterator_next(struct asn1_der_iterator *i ) ;
#line 121
enum asn1_iterator_result nettle_asn1_der_decode_constructed_last(struct asn1_der_iterator *i ) ;
#line 132
int nettle_asn1_der_get_uint32(struct asn1_der_iterator *i , uint32_t *x ) ;
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der2rsa.c"
int nettle_rsa_public_key_from_der_iterator(struct rsa_public_key *pub , unsigned int limit ,
                                            struct asn1_der_iterator *i ) 
{ 
  enum asn1_iterator_result tmp ;
  int tmp___0 ;
  int tmp___1 ;
  enum asn1_iterator_result tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  enum asn1_iterator_result tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 54
  if ((unsigned int )i->type == 4112U) {
    {
    {
#line 54
    tmp = nettle_asn1_der_decode_constructed_last(i);
    }
    }
#line 54
    if ((unsigned int )tmp == 1U) {
      {
      {
#line 54
      tmp___0 = nettle_asn1_der_get_bignum(i, pub->n, limit);
      }
      }
#line 54
      if (tmp___0) {
#line 54
        if (pub->n[0]._mp_size < 0) {
#line 54
          tmp___1 = -1;
        } else {
#line 54
          tmp___1 = pub->n[0]._mp_size > 0;
        }
#line 54
        if (tmp___1 > 0) {
          {
          {
#line 54
          tmp___2 = nettle_asn1_der_iterator_next(i);
          }
          }
#line 54
          if ((unsigned int )tmp___2 == 1U) {
#line 54
            if ((unsigned int )i->type == 2U) {
              {
              {
#line 54
              tmp___3 = nettle_asn1_der_get_bignum(i, pub->e, limit);
              }
              }
#line 54
              if (tmp___3) {
#line 54
                if (pub->e[0]._mp_size < 0) {
#line 54
                  tmp___4 = -1;
                } else {
#line 54
                  tmp___4 = pub->e[0]._mp_size > 0;
                }
#line 54
                if (tmp___4 > 0) {
                  {
                  {
#line 54
                  tmp___5 = nettle_asn1_der_iterator_next(i);
                  }
                  }
#line 54
                  if ((unsigned int )tmp___5 == 3U) {
                    {
                    {
#line 54
                    tmp___6 = nettle_rsa_public_key_prepare(pub);
                    }
                    }
#line 54
                    if (tmp___6) {
#line 54
                      tmp___7 = 1;
                    } else {
#line 54
                      tmp___7 = 0;
                    }
                  } else {
#line 54
                    tmp___7 = 0;
                  }
                } else {
#line 54
                  tmp___7 = 0;
                }
              } else {
#line 54
                tmp___7 = 0;
              }
            } else {
#line 54
              tmp___7 = 0;
            }
          } else {
#line 54
            tmp___7 = 0;
          }
        } else {
#line 54
          tmp___7 = 0;
        }
      } else {
#line 54
        tmp___7 = 0;
      }
    } else {
#line 54
      tmp___7 = 0;
    }
  } else {
#line 54
    tmp___7 = 0;
  }
#line 54
  return (tmp___7);
}
}
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der2rsa.c"
int nettle_rsa_private_key_from_der_iterator(struct rsa_public_key *pub , struct rsa_private_key *priv ,
                                             unsigned int limit , struct asn1_der_iterator *i ) 
{ 
  uint32_t version ;
  enum asn1_iterator_result tmp ;
  enum asn1_iterator_result tmp___0 ;
  enum asn1_iterator_result tmp___1 ;
  int tmp___2 ;
  enum asn1_iterator_result tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  enum asn1_iterator_result tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  enum asn1_iterator_result tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  enum asn1_iterator_result tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  enum asn1_iterator_result tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  enum asn1_iterator_result tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  enum asn1_iterator_result tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  enum asn1_iterator_result tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;

  {
#line 85
  if ((unsigned int )i->type != 4112U) {
#line 86
    return (0);
  }
  {
  {
#line 88
  tmp___1 = nettle_asn1_der_decode_constructed_last(i);
  }
  }
#line 88
  if ((unsigned int )tmp___1 == 1U) {
#line 88
    if ((unsigned int )i->type == 2U) {
      {
      {
#line 88
      tmp___2 = nettle_asn1_der_get_uint32(i, & version);
      }
      }
#line 88
      if (tmp___2) {
#line 88
        if (version <= 1U) {
          {
          {
#line 88
          tmp___3 = nettle_asn1_der_iterator_next(i);
          }
          }
#line 88
          if ((unsigned int )tmp___3 == 1U) {
#line 88
            if ((unsigned int )i->type == 2U) {
              {
              {
#line 88
              tmp___4 = nettle_asn1_der_get_bignum(i, pub->n, limit);
              }
              }
#line 88
              if (tmp___4) {
#line 88
                if (pub->n[0]._mp_size < 0) {
#line 88
                  tmp___5 = -1;
                } else {
#line 88
                  tmp___5 = pub->n[0]._mp_size > 0;
                }
#line 88
                if (tmp___5 > 0) {
                  {
                  {
#line 88
                  tmp___6 = nettle_asn1_der_iterator_next(i);
                  }
                  }
#line 88
                  if ((unsigned int )tmp___6 == 1U) {
#line 88
                    if ((unsigned int )i->type == 2U) {
                      {
                      {
#line 88
                      tmp___7 = nettle_asn1_der_get_bignum(i, pub->e, limit);
                      }
                      }
#line 88
                      if (tmp___7) {
#line 88
                        if (pub->e[0]._mp_size < 0) {
#line 88
                          tmp___8 = -1;
                        } else {
#line 88
                          tmp___8 = pub->e[0]._mp_size > 0;
                        }
#line 88
                        if (tmp___8 > 0) {
                          {
                          {
#line 88
                          tmp___9 = nettle_rsa_public_key_prepare(pub);
                          }
                          }
#line 88
                          if (tmp___9) {
                            {
                            {
#line 88
                            tmp___10 = nettle_asn1_der_iterator_next(i);
                            }
                            }
#line 88
                            if ((unsigned int )tmp___10 == 1U) {
#line 88
                              if ((unsigned int )i->type == 2U) {
                                {
                                {
#line 88
                                tmp___11 = nettle_asn1_der_get_bignum(i, priv->d,
                                                                      limit);
                                }
                                }
#line 88
                                if (tmp___11) {
#line 88
                                  if (priv->d[0]._mp_size < 0) {
#line 88
                                    tmp___12 = -1;
                                  } else {
#line 88
                                    tmp___12 = priv->d[0]._mp_size > 0;
                                  }
#line 88
                                  if (tmp___12 > 0) {
                                    {
                                    {
#line 88
                                    tmp___13 = nettle_asn1_der_iterator_next(i);
                                    }
                                    }
#line 88
                                    if ((unsigned int )tmp___13 == 1U) {
#line 88
                                      if ((unsigned int )i->type == 2U) {
                                        {
                                        {
#line 88
                                        tmp___14 = nettle_asn1_der_get_bignum(i, priv->p,
                                                                              limit);
                                        }
                                        }
#line 88
                                        if (tmp___14) {
#line 88
                                          if (priv->p[0]._mp_size < 0) {
#line 88
                                            tmp___15 = -1;
                                          } else {
#line 88
                                            tmp___15 = priv->p[0]._mp_size > 0;
                                          }
#line 88
                                          if (tmp___15 > 0) {
                                            {
                                            {
#line 88
                                            tmp___16 = nettle_asn1_der_iterator_next(i);
                                            }
                                            }
#line 88
                                            if ((unsigned int )tmp___16 == 1U) {
#line 88
                                              if ((unsigned int )i->type == 2U) {
                                                {
                                                {
#line 88
                                                tmp___17 = nettle_asn1_der_get_bignum(i,
                                                                                      priv->q,
                                                                                      limit);
                                                }
                                                }
#line 88
                                                if (tmp___17) {
#line 88
                                                  if (priv->q[0]._mp_size < 0) {
#line 88
                                                    tmp___18 = -1;
                                                  } else {
#line 88
                                                    tmp___18 = priv->q[0]._mp_size > 0;
                                                  }
#line 88
                                                  if (tmp___18 > 0) {
                                                    {
                                                    {
#line 88
                                                    tmp___19 = nettle_asn1_der_iterator_next(i);
                                                    }
                                                    }
#line 88
                                                    if ((unsigned int )tmp___19 == 1U) {
#line 88
                                                      if ((unsigned int )i->type == 2U) {
                                                        {
                                                        {
#line 88
                                                        tmp___20 = nettle_asn1_der_get_bignum(i,
                                                                                              priv->a,
                                                                                              limit);
                                                        }
                                                        }
#line 88
                                                        if (tmp___20) {
#line 88
                                                          if (priv->a[0]._mp_size < 0) {
#line 88
                                                            tmp___21 = -1;
                                                          } else {
#line 88
                                                            tmp___21 = priv->a[0]._mp_size > 0;
                                                          }
#line 88
                                                          if (tmp___21 > 0) {
                                                            {
                                                            {
#line 88
                                                            tmp___22 = nettle_asn1_der_iterator_next(i);
                                                            }
                                                            }
#line 88
                                                            if ((unsigned int )tmp___22 == 1U) {
#line 88
                                                              if ((unsigned int )i->type == 2U) {
                                                                {
                                                                {
#line 88
                                                                tmp___23 = nettle_asn1_der_get_bignum(i,
                                                                                                      priv->b,
                                                                                                      limit);
                                                                }
                                                                }
#line 88
                                                                if (tmp___23) {
#line 88
                                                                  if (priv->b[0]._mp_size < 0) {
#line 88
                                                                    tmp___24 = -1;
                                                                  } else {
#line 88
                                                                    tmp___24 = priv->b[0]._mp_size > 0;
                                                                  }
#line 88
                                                                  if (tmp___24 > 0) {
                                                                    {
                                                                    {
#line 88
                                                                    tmp___25 = nettle_asn1_der_iterator_next(i);
                                                                    }
                                                                    }
#line 88
                                                                    if ((unsigned int )tmp___25 == 1U) {
#line 88
                                                                      if ((unsigned int )i->type == 2U) {
                                                                        {
                                                                        {
#line 88
                                                                        tmp___26 = nettle_asn1_der_get_bignum(i,
                                                                                                              priv->c,
                                                                                                              limit);
                                                                        }
                                                                        }
#line 88
                                                                        if (tmp___26) {
#line 88
                                                                          if (priv->c[0]._mp_size < 0) {
#line 88
                                                                            tmp___27 = -1;
                                                                          } else {
#line 88
                                                                            tmp___27 = priv->c[0]._mp_size > 0;
                                                                          }
#line 88
                                                                          if (tmp___27 > 0) {
                                                                            {
                                                                            {
#line 88
                                                                            tmp___28 = nettle_rsa_private_key_prepare(priv);
                                                                            }
                                                                            }
#line 88
                                                                            if (tmp___28) {
#line 103
                                                                              if (version == 1U) {
                                                                                {
                                                                                {
#line 106
                                                                                tmp = nettle_asn1_der_iterator_next(i);
                                                                                }
                                                                                }
#line 106
                                                                                if ((unsigned int )tmp == 2U) {
#line 106
                                                                                  if (! ((unsigned int )i->type == 4112U)) {
#line 108
                                                                                    return (0);
                                                                                  }
                                                                                } else {
#line 108
                                                                                  return (0);
                                                                                }
                                                                              }
                                                                              {
                                                                              {
#line 111
                                                                              tmp___0 = nettle_asn1_der_iterator_next(i);
                                                                              }
                                                                              }
#line 111
                                                                              return ((unsigned int )tmp___0 == 3U);
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 114
  return (0);
}
}
#line 117 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der2rsa.c"
int nettle_rsa_keypair_from_der(struct rsa_public_key *pub , struct rsa_private_key *priv ,
                                unsigned int limit , unsigned int length , uint8_t const   *data ) 
{ 
  struct asn1_der_iterator i ;
  enum asn1_iterator_result res ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
  {
  {
#line 126
  res = nettle_asn1_der_iterator_first(& i, length, data);
  }
  }
#line 128
  if ((unsigned int )res != 2U) {
#line 129
    return (0);
  }
#line 131
  if (priv) {
    {
    {
#line 132
    tmp = nettle_rsa_private_key_from_der_iterator(pub, priv, limit, & i);
    }
    }
#line 132
    return (tmp);
  } else {
    {
    {
#line 134
    tmp___0 = nettle_rsa_public_key_from_der_iterator(pub, limit, & i);
    }
    }
#line 134
    return (tmp___0);
  }
}
}
#line 114 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/asn1.h"
enum asn1_iterator_result nettle_asn1_der_decode_constructed(struct asn1_der_iterator *i ,
                                                             struct asn1_der_iterator *contents ) ;
#line 124
enum asn1_iterator_result nettle_asn1_der_decode_bitstring(struct asn1_der_iterator *i ,
                                                           struct asn1_der_iterator *contents ) ;
#line 128
enum asn1_iterator_result nettle_asn1_der_decode_bitstring_last(struct asn1_der_iterator *i ) ;
#line 88 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der-iterator.c"
static void asn1_der_iterator_init(struct asn1_der_iterator *iterator , unsigned int length ,
                                   uint8_t const   *input ) 
{ 


  {
#line 92
  iterator->buffer_length = length;
#line 93
  iterator->buffer = input;
#line 94
  iterator->pos = 0U;
#line 95
  iterator->type = (enum asn1_type )0;
#line 96
  iterator->length = 0U;
#line 97
  iterator->data = (uint8_t const   *)((void *)0);
#line 98
  return;
}
}
#line 104 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der-iterator.c"
enum asn1_iterator_result nettle_asn1_der_iterator_next(struct asn1_der_iterator *i ) 
{ 
  uint8_t tag ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int k ;
  unsigned int j ;
  uint8_t const   *data ;

  {
#line 109
  if (! (i->buffer_length - i->pos)) {
#line 110
    return ((enum asn1_iterator_result )3);
  }
#line 112
  tmp = i->pos;
#line 112
  (i->pos) ++;
#line 112
  tag = (uint8_t )*(i->buffer + tmp);
#line 113
  if (! (i->buffer_length - i->pos)) {
#line 114
    return ((enum asn1_iterator_result )0);
  }
#line 116
  if (((int )tag & 31) == 31) {
#line 119
    return ((enum asn1_iterator_result )0);
  }
#line 122
  tmp___0 = i->pos;
#line 122
  (i->pos) ++;
#line 122
  i->length = (unsigned int )*(i->buffer + tmp___0);
#line 123
  if (i->length & 128U) {
#line 125
    k = i->length & 127U;
#line 127
    data = i->buffer + i->pos;
#line 129
    if (k == 0U) {
#line 131
      return ((enum asn1_iterator_result )0);
    }
#line 133
    if (i->buffer_length - i->pos < k) {
#line 134
      return ((enum asn1_iterator_result )0);
    }
#line 136
    if ((unsigned long )k > sizeof(unsigned int )) {
#line 137
      return ((enum asn1_iterator_result )0);
    }
#line 139
    i->pos += k;
#line 140
    i->length = (unsigned int )*(data + 0);
#line 141
    if (i->length == 0U) {
#line 143
      return ((enum asn1_iterator_result )0);
    } else
#line 141
    if (k == 1U) {
#line 141
      if (i->length < 128U) {
#line 143
        return ((enum asn1_iterator_result )0);
      }
    }
#line 145
    j = 1U;
    {
    {
#line 145
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 145
      if (! (j < k)) {
#line 145
        goto while_break;
      }
#line 146
      i->length = (i->length << 8) | (unsigned int )*(data + j);
#line 145
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 148
  if (i->buffer_length - i->pos < i->length) {
#line 149
    return ((enum asn1_iterator_result )0);
  }
#line 151
  i->data = i->buffer + i->pos;
#line 152
  i->pos += i->length;
#line 154
  i->type = (enum asn1_type )((int )tag & 31);
#line 155
  i->type = (enum asn1_type )((unsigned int )i->type | (unsigned int )(((int )tag & 192) << 7));
#line 156
  if ((int )tag & 32) {
#line 158
    i->type = (enum asn1_type )((unsigned int )i->type | 4096U);
#line 159
    return ((enum asn1_iterator_result )2);
  } else {
#line 162
    return ((enum asn1_iterator_result )1);
  }
}
}
#line 165 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der-iterator.c"
enum asn1_iterator_result nettle_asn1_der_iterator_first(struct asn1_der_iterator *i ,
                                                         unsigned int length , uint8_t const   *input ) 
{ 
  enum asn1_iterator_result tmp ;

  {
  {
  {
#line 169
  asn1_der_iterator_init(i, length, input);
  }
  {
#line 170
  tmp = nettle_asn1_der_iterator_next(i);
  }
  }
#line 170
  return (tmp);
}
}
#line 173 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der-iterator.c"
enum asn1_iterator_result nettle_asn1_der_decode_constructed(struct asn1_der_iterator *i ,
                                                             struct asn1_der_iterator *contents ) 
{ 
  enum asn1_iterator_result tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 177
  if (! ((unsigned int )i->type & 4096U)) {
    {
    {
#line 177
    __assert_fail("i->type & ASN1_TYPE_CONSTRUCTED", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der-iterator.c",
                  177U, "nettle_asn1_der_decode_constructed");
    }
    }
  }
  {
  {
#line 178
  tmp = nettle_asn1_der_iterator_first(contents, i->length, i->data);
  }
  }
#line 178
  return (tmp);
}
}
#line 181 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der-iterator.c"
enum asn1_iterator_result nettle_asn1_der_decode_constructed_last(struct asn1_der_iterator *i ) 
{ 
  enum asn1_iterator_result tmp ;

  {
#line 184
  if (i->buffer_length - i->pos > 0U) {
#line 185
    return ((enum asn1_iterator_result )0);
  }
  {
  {
#line 187
  tmp = nettle_asn1_der_decode_constructed(i, i);
  }
  }
#line 187
  return (tmp);
}
}
#line 191 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der-iterator.c"
enum asn1_iterator_result nettle_asn1_der_decode_bitstring(struct asn1_der_iterator *i ,
                                                           struct asn1_der_iterator *contents ) 
{ 
  enum asn1_iterator_result tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 195
  if (! ((unsigned int )i->type == 3U)) {
    {
    {
#line 195
    __assert_fail("i->type == ASN1_BITSTRING", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der-iterator.c",
                  195U, "nettle_asn1_der_decode_bitstring");
    }
    }
  }
#line 197
  if (i->length == 0U) {
#line 198
    return ((enum asn1_iterator_result )0);
  } else
#line 197
  if ((int const   )*(i->data + 0) != 0) {
#line 198
    return ((enum asn1_iterator_result )0);
  }
  {
  {
#line 200
  tmp = nettle_asn1_der_iterator_first(contents, i->length - 1U, i->data + 1);
  }
  }
#line 200
  return (tmp);
}
}
#line 203 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der-iterator.c"
enum asn1_iterator_result nettle_asn1_der_decode_bitstring_last(struct asn1_der_iterator *i ) 
{ 
  enum asn1_iterator_result tmp ;

  {
#line 206
  if (i->buffer_length - i->pos > 0U) {
#line 207
    return ((enum asn1_iterator_result )0);
  }
  {
  {
#line 209
  tmp = nettle_asn1_der_decode_bitstring(i, i);
  }
  }
#line 209
  return (tmp);
}
}
#line 212 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der-iterator.c"
int nettle_asn1_der_get_uint32(struct asn1_der_iterator *i , uint32_t *x ) 
{ 
  uint32_t value ;
  unsigned int length ;
  unsigned int k ;

  {
#line 218
  value = (uint32_t )0;
#line 219
  length = i->length;
#line 222
  if (! length) {
#line 223
    return (0);
  } else
#line 222
  if (length > 5U) {
#line 223
    return (0);
  }
#line 225
  if ((int const   )*(i->data + (length - 1U)) >= 128) {
#line 227
    return (0);
  }
#line 229
  if (length > 1U) {
#line 229
    if ((int const   )*(i->data + (length - 1U)) == 0) {
#line 229
      if ((int const   )*(i->data + (length - 2U)) < 128) {
#line 233
        return (0);
      }
    }
  }
#line 235
  if (length == 5U) {
#line 237
    if (*(i->data + 4)) {
#line 238
      return (0);
    }
#line 239
    length --;
  }
#line 242
  k = 0U;
#line 242
  value = k;
  {
  {
#line 242
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 242
    if (! (k < length)) {
#line 242
      goto while_break;
    }
#line 243
    value = (value << 8) | (unsigned int )*(i->data + k);
#line 242
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 245
  *x = value;
#line 246
  return (1);
}
}
#line 250 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/der-iterator.c"
int nettle_asn1_der_get_bignum(struct asn1_der_iterator *i , __mpz_struct *x , unsigned int limit ) 
{ 
  size_t tmp ;

  {
#line 254
  if (i->length > 1U) {
#line 254
    if ((int const   )*(i->data + 0) == 0) {
#line 254
      if ((int const   )*(i->data + 1) < 128) {
#line 258
        return (0);
      } else {
#line 254
        goto _L;
      }
    } else
    _L: 
#line 254
    if ((int const   )*(i->data + 0) == 255) {
#line 254
      if ((int const   )*(i->data + 1) >= 128) {
#line 258
        return (0);
      }
    }
  }
#line 261
  if (limit) {
#line 261
    if (8U * i->length > 16U + limit) {
#line 262
      return (0);
    }
  }
  {
  {
#line 264
  nettle_mpz_set_str_256_s(x, i->length, i->data);
  }
  }
#line 267
  if (limit) {
    {
    {
#line 267
    tmp = __gmpz_sizeinbase((mpz_srcptr )x, 2);
    }
    }
#line 267
    if (tmp > limit) {
#line 268
      return (0);
    }
  }
#line 270
  return (1);
}
}
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/ctr.h"
void nettle_ctr_crypt(void *ctx , void (*f)(void *ctx , unsigned int length , uint8_t *dst ,
                                            uint8_t const   *src ) , unsigned int block_size ,
                      uint8_t *ctr , unsigned int length , uint8_t *dst , uint8_t const   *src ) ;
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/ctr.c"
void nettle_ctr_crypt(void *ctx , void (*f)(void *ctx , unsigned int length , uint8_t *dst ,
                                            uint8_t const   *src ) , unsigned int block_size ,
                      uint8_t *ctr , unsigned int length , uint8_t *dst , uint8_t const   *src ) 
{ 
  uint8_t *buffer ;
  void *tmp ;
  unsigned int i ;
  unsigned int i___0 ;
  unsigned int i___1 ;

  {
  {
  {
#line 56
  tmp = __builtin_alloca(sizeof(*buffer) * (unsigned long )block_size);
  }
#line 56
  buffer = (uint8_t *)tmp;
  }
#line 58
  if ((unsigned long )src != (unsigned long )dst) {
    {
    {
#line 60
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 60
      if (! (length >= block_size)) {
#line 60
        goto while_break;
      }
      {
      {
#line 62
      (*f)(ctx, block_size, dst, (uint8_t const   *)ctr);
      }
      {
#line 63
      memxor(dst, src, block_size);
      }
      }
      {
      {
#line 64
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 64
        *(ctr + (block_size - 1U)) = (uint8_t )((int )*(ctr + (block_size - 1U)) + 1);
#line 64
        if ((int )*(ctr + (block_size - 1U)) == 0) {
#line 64
          i = block_size - 1U;
          {
          {
#line 64
          while (1) {
            while_continue___9: /* CIL Label */ ;
            while_continue___1: /* CIL Label */ ;

#line 64
            if (i > 0U) {
#line 64
              i --;
#line 64
              *(ctr + i) = (uint8_t )((int )*(ctr + i) + 1);
#line 64
              if (! ((int )*(ctr + i) == 0)) {
#line 64
                goto while_break___1;
              }
            } else {
#line 64
              goto while_break___1;
            }
          }
          while_break___17: /* CIL Label */ ;
          }
          while_break___9: /* CIL Label */ ;
          }
          while_break___1: ;
        }
#line 64
        goto while_break___0;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___0: 
#line 60
      length -= block_size;
#line 60
      src += block_size;
#line 60
      dst += block_size;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
    {
#line 69
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;

#line 69
      if (! (length >= block_size)) {
#line 69
        goto while_break___2;
      }
      {
      {
#line 71
      (*f)(ctx, block_size, buffer, (uint8_t const   *)ctr);
      }
      {
#line 72
      memxor3(dst, src, (uint8_t const   *)buffer, block_size);
      }
      }
      {
      {
#line 73
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 73
        *(ctr + (block_size - 1U)) = (uint8_t )((int )*(ctr + (block_size - 1U)) + 1);
#line 73
        if ((int )*(ctr + (block_size - 1U)) == 0) {
#line 73
          i___0 = block_size - 1U;
          {
          {
#line 73
          while (1) {
            while_continue___12: /* CIL Label */ ;
            while_continue___4: /* CIL Label */ ;

#line 73
            if (i___0 > 0U) {
#line 73
              i___0 --;
#line 73
              *(ctr + i___0) = (uint8_t )((int )*(ctr + i___0) + 1);
#line 73
              if (! ((int )*(ctr + i___0) == 0)) {
#line 73
                goto while_break___4;
              }
            } else {
#line 73
              goto while_break___4;
            }
          }
          while_break___20: /* CIL Label */ ;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___4: ;
        }
#line 73
        goto while_break___3;
      }
      while_break___19: /* CIL Label */ ;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___3: 
#line 69
      length -= block_size;
#line 69
      src += block_size;
#line 69
      dst += block_size;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 76
  if (length > 0U) {
    {
    {
#line 80
    (*f)(ctx, block_size, buffer, (uint8_t const   *)ctr);
    }
    {
#line 81
    memxor3(dst, src, (uint8_t const   *)buffer, length);
    }
    }
    {
    {
#line 82
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 82
      *(ctr + (block_size - 1U)) = (uint8_t )((int )*(ctr + (block_size - 1U)) + 1);
#line 82
      if ((int )*(ctr + (block_size - 1U)) == 0) {
#line 82
        i___1 = block_size - 1U;
        {
        {
#line 82
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___6: /* CIL Label */ ;

#line 82
          if (i___1 > 0U) {
#line 82
            i___1 --;
#line 82
            *(ctr + i___1) = (uint8_t )((int )*(ctr + i___1) + 1);
#line 82
            if (! ((int )*(ctr + i___1) == 0)) {
#line 82
              goto while_break___6;
            }
          } else {
#line 82
            goto while_break___6;
          }
        }
        while_break___22: /* CIL Label */ ;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: ;
      }
#line 82
      goto while_break___5;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___5: ;
  }
#line 84
  return;
}
}
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cbc.c"
void nettle_cbc_encrypt(void *ctx , void (*f)(void *ctx , unsigned int length , uint8_t *dst ,
                                              uint8_t const   *src ) , unsigned int block_size ,
                        uint8_t *iv , unsigned int length , uint8_t *dst , uint8_t const   *src ) 
{ 
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 45
  if (! (! (length % block_size))) {
    {
    {
#line 45
    __assert_fail("!(length % block_size)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cbc.c",
                  45U, "nettle_cbc_encrypt");
    }
    }
  }
  {
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 47
    if (! length) {
#line 47
      goto while_break;
    }
    {
    {
#line 49
    memxor(iv, src, block_size);
    }
    {
#line 50
    (*f)(ctx, block_size, dst, (uint8_t const   *)iv);
    }
    {
#line 51
    memcpy((void */* __restrict  */)((void *)iv), (void const   */* __restrict  */)((void const   *)dst),
           block_size);
    }
#line 47
    length -= block_size;
#line 47
    src += block_size;
#line 47
    dst += block_size;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 53
  return;
}
}
#line 56 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cbc.c"
static void cbc_decrypt_internal(void *ctx , void (*f)(void *ctx , unsigned int length ,
                                                       uint8_t *dst , uint8_t const   *src ) ,
                                 unsigned int block_size , uint8_t *iv , unsigned int length ,
                                 uint8_t *dst , uint8_t const   *src ) 
{ 
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 62
  if (! length) {
    {
    {
#line 62
    __assert_fail("length", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cbc.c",
                  62U, "cbc_decrypt_internal");
    }
    }
  }
#line 63
  if (! (! (length % block_size))) {
    {
    {
#line 63
    __assert_fail("!(length % block_size)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cbc.c",
                  63U, "cbc_decrypt_internal");
    }
    }
  }
#line 64
  if (! ((unsigned long )src != (unsigned long )dst)) {
    {
    {
#line 64
    __assert_fail("src != dst", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cbc.c",
                  64U, "cbc_decrypt_internal");
    }
    }
  }
  {
  {
#line 67
  (*f)(ctx, length, dst, src);
  }
  {
#line 70
  memxor(dst, (uint8_t const   *)iv, block_size);
  }
  {
#line 71
  memxor(dst + block_size, src, length - block_size);
  }
  {
#line 72
  memcpy((void */* __restrict  */)((void *)iv), (void const   */* __restrict  */)((void const   *)((src + length) - block_size)),
         block_size);
  }
  }
#line 73
  return;
}
}
#line 78 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cbc.c"
void nettle_cbc_decrypt(void *ctx , void (*f)(void *ctx , unsigned int length , uint8_t *dst ,
                                              uint8_t const   *src ) , unsigned int block_size ,
                        uint8_t *iv , unsigned int length , uint8_t *dst , uint8_t const   *src ) 
{ 
  unsigned int buffer_size ;
  uint8_t *buffer ;
  void *tmp ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 84
  if (! (! (length % block_size))) {
    {
    {
#line 84
    __assert_fail("!(length % block_size)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cbc.c",
                  84U, "nettle_cbc_decrypt");
    }
    }
  }
#line 86
  if (! length) {
#line 87
    return;
  }
#line 89
  if ((unsigned long )src != (unsigned long )dst) {
    {
    {
#line 90
    cbc_decrypt_internal(ctx, f, block_size, iv, length, dst, src);
    }
    }
  } else {
#line 106
    if (length <= 4096U) {
#line 107
      buffer_size = length;
    } else {
#line 109
      buffer_size = 4096U - 4096U % block_size;
    }
    {
    {
#line 114
    tmp = __builtin_alloca(sizeof(*buffer) * (unsigned long )buffer_size);
    }
#line 114
    buffer = (uint8_t *)tmp;
    }
    {
    {
#line 116
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 116
      if (! (length > buffer_size)) {
#line 116
        goto while_break;
      }
      {
      {
#line 119
      memcpy((void */* __restrict  */)((void *)buffer), (void const   */* __restrict  */)((void const   *)src),
             buffer_size);
      }
      {
#line 120
      cbc_decrypt_internal(ctx, f, block_size, iv, buffer_size, dst, (uint8_t const   *)buffer);
      }
#line 116
      length -= buffer_size;
#line 116
      dst += buffer_size;
#line 116
      src += buffer_size;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
    {
#line 124
    memcpy((void */* __restrict  */)((void *)buffer), (void const   */* __restrict  */)((void const   *)src),
           length);
    }
    {
#line 126
    cbc_decrypt_internal(ctx, f, block_size, iv, length, dst, (uint8_t const   *)buffer);
    }
    }
  }
#line 130
  return;
}
}
#line 56 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128.h"
void nettle_cast128_set_key(struct cast128_ctx *ctx , unsigned int keybytes , uint8_t const   *rawkey ) ;
#line 60
void nettle_cast128_encrypt(struct cast128_ctx *ctx , unsigned int length , uint8_t *dst ,
                            uint8_t const   *src ) ;
#line 64
void nettle_cast128_decrypt(struct cast128_ctx *ctx , unsigned int length , uint8_t *dst ,
                            uint8_t const   *src ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128_sboxes.h"
static uint32_t const   cast_sbox1[256]  = 
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128_sboxes.h"
  {      (uint32_t const   )821772500,      (uint32_t const   )2678128395U,      (uint32_t const   )1810681135,      (uint32_t const   )1059425402, 
        (uint32_t const   )505495343,      (uint32_t const   )2617265619U,      (uint32_t const   )1610868032,      (uint32_t const   )3483355465U, 
        (uint32_t const   )3218386727U,      (uint32_t const   )2294005173U,      (uint32_t const   )3791863952U,      (uint32_t const   )2563806837U, 
        (uint32_t const   )1852023008,      (uint32_t const   )365126098,      (uint32_t const   )3269944861U,      (uint32_t const   )584384398, 
        (uint32_t const   )677919599,      (uint32_t const   )3229601881U,      (uint32_t const   )4280515016U,      (uint32_t const   )2002735330, 
        (uint32_t const   )1136869587,      (uint32_t const   )3744433750U,      (uint32_t const   )2289869850U,      (uint32_t const   )2731719981U, 
        (uint32_t const   )2714362070U,      (uint32_t const   )879511577,      (uint32_t const   )1639411079,      (uint32_t const   )575934255, 
        (uint32_t const   )717107937,      (uint32_t const   )2857637483U,      (uint32_t const   )576097850,      (uint32_t const   )2731753936U, 
        (uint32_t const   )1725645000,      (uint32_t const   )2810460463U,      (uint32_t const   )5111599,      (uint32_t const   )767152862, 
        (uint32_t const   )2543075244U,      (uint32_t const   )1251459544,      (uint32_t const   )1383482551,      (uint32_t const   )3052681127U, 
        (uint32_t const   )3089939183U,      (uint32_t const   )3612463449U,      (uint32_t const   )1878520045,      (uint32_t const   )1510570527, 
        (uint32_t const   )2189125840U,      (uint32_t const   )2431448366U,      (uint32_t const   )582008916,      (uint32_t const   )3163445557U, 
        (uint32_t const   )1265446783,      (uint32_t const   )1354458274,      (uint32_t const   )3529918736U,      (uint32_t const   )3202711853U, 
        (uint32_t const   )3073581712U,      (uint32_t const   )3912963487U,      (uint32_t const   )3029263377U,      (uint32_t const   )1275016285, 
        (uint32_t const   )4249207360U,      (uint32_t const   )2905708351U,      (uint32_t const   )3304509486U,      (uint32_t const   )1442611557, 
        (uint32_t const   )3585198765U,      (uint32_t const   )2712415662U,      (uint32_t const   )2731849581U,      (uint32_t const   )3248163920U, 
        (uint32_t const   )2283946226U,      (uint32_t const   )208555832,      (uint32_t const   )2766454743U,      (uint32_t const   )1331405426, 
        (uint32_t const   )1447828783,      (uint32_t const   )3315356441U,      (uint32_t const   )3108627284U,      (uint32_t const   )2957404670U, 
        (uint32_t const   )2981538698U,      (uint32_t const   )3339933917U,      (uint32_t const   )1669711173,      (uint32_t const   )286233437, 
        (uint32_t const   )1465092821,      (uint32_t const   )1782121619,      (uint32_t const   )3862771680U,      (uint32_t const   )710211251, 
        (uint32_t const   )980974943,      (uint32_t const   )1651941557,      (uint32_t const   )430374111,      (uint32_t const   )2051154026, 
        (uint32_t const   )704238805,      (uint32_t const   )4128970897U,      (uint32_t const   )3144820574U,      (uint32_t const   )2857402727U, 
        (uint32_t const   )948965521,      (uint32_t const   )3333752299U,      (uint32_t const   )2227686284U,      (uint32_t const   )718756367, 
        (uint32_t const   )2269778983U,      (uint32_t const   )2731643755U,      (uint32_t const   )718440111,      (uint32_t const   )2857816721U, 
        (uint32_t const   )3616097120U,      (uint32_t const   )1113355533,      (uint32_t const   )2478022182U,      (uint32_t const   )410092745, 
        (uint32_t const   )1811985197,      (uint32_t const   )1944238868,      (uint32_t const   )2696854588U,      (uint32_t const   )1415722873, 
        (uint32_t const   )1682284203,      (uint32_t const   )1060277122,      (uint32_t const   )1998114690,      (uint32_t const   )1503841958, 
        (uint32_t const   )82706478,      (uint32_t const   )2315155686U,      (uint32_t const   )1068173648,      (uint32_t const   )845149890, 
        (uint32_t const   )2167947013U,      (uint32_t const   )1768146376,      (uint32_t const   )1993038550,      (uint32_t const   )3566826697U, 
        (uint32_t const   )3390574031U,      (uint32_t const   )940016341,      (uint32_t const   )3355073782U,      (uint32_t const   )2328040721U, 
        (uint32_t const   )904371731,      (uint32_t const   )1205506512,      (uint32_t const   )4094660742U,      (uint32_t const   )2816623006U, 
        (uint32_t const   )825647681,      (uint32_t const   )85914773,      (uint32_t const   )2857843460U,      (uint32_t const   )1249926541, 
        (uint32_t const   )1417871568,      (uint32_t const   )3287612,      (uint32_t const   )3211054559U,      (uint32_t const   )3126306446U, 
        (uint32_t const   )1975924523,      (uint32_t const   )1353700161,      (uint32_t const   )2814456437U,      (uint32_t const   )2438597621U, 
        (uint32_t const   )1800716203,      (uint32_t const   )722146342,      (uint32_t const   )2873936343U,      (uint32_t const   )1151126914, 
        (uint32_t const   )4160483941U,      (uint32_t const   )2877670899U,      (uint32_t const   )458611604,      (uint32_t const   )2866078500U, 
        (uint32_t const   )3483680063U,      (uint32_t const   )770352098,      (uint32_t const   )2652916994U,      (uint32_t const   )3367839148U, 
        (uint32_t const   )3940505011U,      (uint32_t const   )3585973912U,      (uint32_t const   )3809620402U,      (uint32_t const   )718646636, 
        (uint32_t const   )2504206814U,      (uint32_t const   )2914927912U,      (uint32_t const   )3631288169U,      (uint32_t const   )2857486607U, 
        (uint32_t const   )2860018678U,      (uint32_t const   )575749918,      (uint32_t const   )2857478043U,      (uint32_t const   )718488780, 
        (uint32_t const   )2069512688,      (uint32_t const   )3548183469U,      (uint32_t const   )453416197,      (uint32_t const   )1106044049, 
        (uint32_t const   )3032691430U,      (uint32_t const   )52586708,      (uint32_t const   )3378514636U,      (uint32_t const   )3459808877U, 
        (uint32_t const   )3211506028U,      (uint32_t const   )1785789304,      (uint32_t const   )218356169,      (uint32_t const   )3571399134U, 
        (uint32_t const   )3759170522U,      (uint32_t const   )1194783844,      (uint32_t const   )1523787992,      (uint32_t const   )3007827094U, 
        (uint32_t const   )1975193539,      (uint32_t const   )2555452411U,      (uint32_t const   )1341901877,      (uint32_t const   )3045838698U, 
        (uint32_t const   )3776907964U,      (uint32_t const   )3217423946U,      (uint32_t const   )2802510864U,      (uint32_t const   )2889438986U, 
        (uint32_t const   )1057244207,      (uint32_t const   )1636348243,      (uint32_t const   )3761863214U,      (uint32_t const   )1462225785, 
        (uint32_t const   )2632663439U,      (uint32_t const   )481089165,      (uint32_t const   )718503062,      (uint32_t const   )24497053, 
        (uint32_t const   )3332243209U,      (uint32_t const   )3344655856U,      (uint32_t const   )3655024856U,      (uint32_t const   )3960371065U, 
        (uint32_t const   )1195698900,      (uint32_t const   )2971415156U,      (uint32_t const   )3710176158U,      (uint32_t const   )2115785917, 
        (uint32_t const   )4027663609U,      (uint32_t const   )3525578417U,      (uint32_t const   )2524296189U,      (uint32_t const   )2745972565U, 
        (uint32_t const   )3564906415U,      (uint32_t const   )1372086093,      (uint32_t const   )1452307862,      (uint32_t const   )2780501478U, 
        (uint32_t const   )1476592880,      (uint32_t const   )3389271281U,      (uint32_t const   )18495466,      (uint32_t const   )2378148571U, 
        (uint32_t const   )901398090,      (uint32_t const   )891748256,      (uint32_t const   )3279637769U,      (uint32_t const   )3157290713U, 
        (uint32_t const   )2560960102U,      (uint32_t const   )1447622437,      (uint32_t const   )4284372637U,      (uint32_t const   )216884176, 
        (uint32_t const   )2086908623,      (uint32_t const   )1879786977,      (uint32_t const   )3588903153U,      (uint32_t const   )2242455666U, 
        (uint32_t const   )2938092967U,      (uint32_t const   )3559082096U,      (uint32_t const   )2810645491U,      (uint32_t const   )758861177, 
        (uint32_t const   )1121993112,      (uint32_t const   )215018983,      (uint32_t const   )642190776,      (uint32_t const   )4169236812U, 
        (uint32_t const   )1196255959,      (uint32_t const   )2081185372,      (uint32_t const   )3508738393U,      (uint32_t const   )941322904, 
        (uint32_t const   )4124243163U,      (uint32_t const   )2877523539U,      (uint32_t const   )1848581667,      (uint32_t const   )2205260958U, 
        (uint32_t const   )3180453958U,      (uint32_t const   )2589345134U,      (uint32_t const   )3694731276U,      (uint32_t const   )550028657, 
        (uint32_t const   )2519456284U,      (uint32_t const   )3789985535U,      (uint32_t const   )2973870856U,      (uint32_t const   )2093648313, 
        (uint32_t const   )443148163,      (uint32_t const   )46942275,      (uint32_t const   )2734146937U,      (uint32_t const   )1117713533, 
        (uint32_t const   )1115362972,      (uint32_t const   )1523183689,      (uint32_t const   )3717140224U,      (uint32_t const   )1551984063};
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128_sboxes.h"
static uint32_t const   cast_sbox2[256]  = 
#line 77
  {      (uint32_t const   )522195092,      (uint32_t const   )4010518363U,      (uint32_t const   )1776537470,      (uint32_t const   )960447360, 
        (uint32_t const   )4267822970U,      (uint32_t const   )4005896314U,      (uint32_t const   )1435016340,      (uint32_t const   )1929119313, 
        (uint32_t const   )2913464185U,      (uint32_t const   )1310552629,      (uint32_t const   )3579470798U,      (uint32_t const   )3724818106U, 
        (uint32_t const   )2579771631U,      (uint32_t const   )1594623892,      (uint32_t const   )417127293,      (uint32_t const   )2715217907U, 
        (uint32_t const   )2696228731U,      (uint32_t const   )1508390405,      (uint32_t const   )3994398868U,      (uint32_t const   )3925858569U, 
        (uint32_t const   )3695444102U,      (uint32_t const   )4019471449U,      (uint32_t const   )3129199795U,      (uint32_t const   )3770928635U, 
        (uint32_t const   )3520741761U,      (uint32_t const   )990456497,      (uint32_t const   )4187484609U,      (uint32_t const   )2783367035U, 
        (uint32_t const   )21106139,      (uint32_t const   )3840405339U,      (uint32_t const   )631373633,      (uint32_t const   )3783325702U, 
        (uint32_t const   )532942976,      (uint32_t const   )396095098,      (uint32_t const   )3548038825U,      (uint32_t const   )4267192484U, 
        (uint32_t const   )2564721535U,      (uint32_t const   )2011709262,      (uint32_t const   )2039648873,      (uint32_t const   )620404603, 
        (uint32_t const   )3776170075U,      (uint32_t const   )2898526339U,      (uint32_t const   )3612357925U,      (uint32_t const   )4159332703U, 
        (uint32_t const   )1645490516,      (uint32_t const   )223693667,      (uint32_t const   )1567101217,      (uint32_t const   )3362177881U, 
        (uint32_t const   )1029951347,      (uint32_t const   )3470931136U,      (uint32_t const   )3570957959U,      (uint32_t const   )1550265121, 
        (uint32_t const   )119497089,      (uint32_t const   )972513919,      (uint32_t const   )907948164,      (uint32_t const   )3840628539U, 
        (uint32_t const   )1613718692,      (uint32_t const   )3594177948U,      (uint32_t const   )465323573,      (uint32_t const   )2659255085U, 
        (uint32_t const   )654439692,      (uint32_t const   )2575596212U,      (uint32_t const   )2699288441U,      (uint32_t const   )3127702412U, 
        (uint32_t const   )277098644,      (uint32_t const   )624404830,      (uint32_t const   )4100943870U,      (uint32_t const   )2717858591U, 
        (uint32_t const   )546110314,      (uint32_t const   )2403699828U,      (uint32_t const   )3655377447U,      (uint32_t const   )1321679412, 
        (uint32_t const   )4236791657U,      (uint32_t const   )1045293279,      (uint32_t const   )4010672264U,      (uint32_t const   )895050893, 
        (uint32_t const   )2319792268U,      (uint32_t const   )494945126,      (uint32_t const   )1914543101,      (uint32_t const   )2777056443U, 
        (uint32_t const   )3894764339U,      (uint32_t const   )2219737618U,      (uint32_t const   )311263384,      (uint32_t const   )4275257268U, 
        (uint32_t const   )3458730721U,      (uint32_t const   )669096869,      (uint32_t const   )3584475730U,      (uint32_t const   )3835122877U, 
        (uint32_t const   )3319158237U,      (uint32_t const   )3949359204U,      (uint32_t const   )2005142349,      (uint32_t const   )2713102337U, 
        (uint32_t const   )2228954793U,      (uint32_t const   )3769984788U,      (uint32_t const   )569394103,      (uint32_t const   )3855636576U, 
        (uint32_t const   )1425027204,      (uint32_t const   )108000370,      (uint32_t const   )2736431443U,      (uint32_t const   )3671869269U, 
        (uint32_t const   )3043122623U,      (uint32_t const   )1750473702,      (uint32_t const   )2211081108U,      (uint32_t const   )762237499, 
        (uint32_t const   )3972989403U,      (uint32_t const   )2798899386U,      (uint32_t const   )3061857628U,      (uint32_t const   )2943854345U, 
        (uint32_t const   )867476300,      (uint32_t const   )964413654,      (uint32_t const   )1591880597,      (uint32_t const   )1594774276, 
        (uint32_t const   )2179821409U,      (uint32_t const   )552026980,      (uint32_t const   )3026064248U,      (uint32_t const   )3726140315U, 
        (uint32_t const   )2283577634U,      (uint32_t const   )3110545105U,      (uint32_t const   )2152310760U,      (uint32_t const   )582474363, 
        (uint32_t const   )1582640421,      (uint32_t const   )1383256631,      (uint32_t const   )2043843868,      (uint32_t const   )3322775884U, 
        (uint32_t const   )1217180674,      (uint32_t const   )463797851,      (uint32_t const   )2763038571U,      (uint32_t const   )480777679, 
        (uint32_t const   )2718707717U,      (uint32_t const   )2289164131U,      (uint32_t const   )3118346187U,      (uint32_t const   )214354409, 
        (uint32_t const   )200212307,      (uint32_t const   )3810608407U,      (uint32_t const   )3025414197U,      (uint32_t const   )2674075964U, 
        (uint32_t const   )3997296425U,      (uint32_t const   )1847405948,      (uint32_t const   )1342460550,      (uint32_t const   )510035443, 
        (uint32_t const   )4080271814U,      (uint32_t const   )815934613,      (uint32_t const   )833030224,      (uint32_t const   )1620250387, 
        (uint32_t const   )1945732119,      (uint32_t const   )2703661145U,      (uint32_t const   )3966000196U,      (uint32_t const   )1388869545, 
        (uint32_t const   )3456054182U,      (uint32_t const   )2687178561U,      (uint32_t const   )2092620194,      (uint32_t const   )562037615, 
        (uint32_t const   )1356438536,      (uint32_t const   )3409922145U,      (uint32_t const   )3261847397U,      (uint32_t const   )1688467115, 
        (uint32_t const   )2150901366U,      (uint32_t const   )631725691,      (uint32_t const   )3840332284U,      (uint32_t const   )549916902, 
        (uint32_t const   )3455104640U,      (uint32_t const   )394546491,      (uint32_t const   )837744717,      (uint32_t const   )2114462948, 
        (uint32_t const   )751520235,      (uint32_t const   )2221554606U,      (uint32_t const   )2415360136U,      (uint32_t const   )3999097078U, 
        (uint32_t const   )2063029875,      (uint32_t const   )803036379,      (uint32_t const   )2702586305U,      (uint32_t const   )821456707, 
        (uint32_t const   )3019566164U,      (uint32_t const   )360699898,      (uint32_t const   )4018502092U,      (uint32_t const   )3511869016U, 
        (uint32_t const   )3677355358U,      (uint32_t const   )2402471449U,      (uint32_t const   )812317050,      (uint32_t const   )49299192, 
        (uint32_t const   )2570164949U,      (uint32_t const   )3259169295U,      (uint32_t const   )2816732080U,      (uint32_t const   )3331213574U, 
        (uint32_t const   )3101303564U,      (uint32_t const   )2156015656U,      (uint32_t const   )3705598920U,      (uint32_t const   )3546263921U, 
        (uint32_t const   )143268808,      (uint32_t const   )3200304480U,      (uint32_t const   )1638124008,      (uint32_t const   )3165189453U, 
        (uint32_t const   )3341807610U,      (uint32_t const   )578956953,      (uint32_t const   )2193977524U,      (uint32_t const   )3638120073U, 
        (uint32_t const   )2333881532U,      (uint32_t const   )807278310,      (uint32_t const   )658237817,      (uint32_t const   )2969561766U, 
        (uint32_t const   )1641658566,      (uint32_t const   )11683945,      (uint32_t const   )3086995007U,      (uint32_t const   )148645947, 
        (uint32_t const   )1138423386,      (uint32_t const   )4158756760U,      (uint32_t const   )1981396783,      (uint32_t const   )2401016740U, 
        (uint32_t const   )3699783584U,      (uint32_t const   )380097457,      (uint32_t const   )2680394679U,      (uint32_t const   )2803068651U, 
        (uint32_t const   )3334260286U,      (uint32_t const   )441530178,      (uint32_t const   )4016580796U,      (uint32_t const   )1375954390, 
        (uint32_t const   )761952171,      (uint32_t const   )891809099,      (uint32_t const   )2183123478U,      (uint32_t const   )157052462, 
        (uint32_t const   )3683840763U,      (uint32_t const   )1592404427,      (uint32_t const   )341349109,      (uint32_t const   )2438483839U, 
        (uint32_t const   )1417898363,      (uint32_t const   )644327628,      (uint32_t const   )2233032776U,      (uint32_t const   )2353769706U, 
        (uint32_t const   )2201510100U,      (uint32_t const   )220455161,      (uint32_t const   )1815641738,      (uint32_t const   )182899273, 
        (uint32_t const   )2995019788U,      (uint32_t const   )3627381533U,      (uint32_t const   )3702638151U,      (uint32_t const   )2890684138U, 
        (uint32_t const   )1052606899,      (uint32_t const   )588164016,      (uint32_t const   )1681439879,      (uint32_t const   )4038439418U, 
        (uint32_t const   )2405343923U,      (uint32_t const   )4229449282U,      (uint32_t const   )167996282,      (uint32_t const   )1336969661, 
        (uint32_t const   )1688053129,      (uint32_t const   )2739224926U,      (uint32_t const   )1543734051,      (uint32_t const   )1046297529, 
        (uint32_t const   )1138201970,      (uint32_t const   )2121126012,      (uint32_t const   )115334942,      (uint32_t const   )1819067631, 
        (uint32_t const   )1902159161,      (uint32_t const   )1941945968,      (uint32_t const   )2206692869U,      (uint32_t const   )1159982321};
#line 144 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128_sboxes.h"
static uint32_t const   cast_sbox3[256]  = 
#line 144
  {      (uint32_t const   )2381300288U,      (uint32_t const   )637164959,      (uint32_t const   )3952098751U,      (uint32_t const   )3893414151U, 
        (uint32_t const   )1197506559,      (uint32_t const   )916448331,      (uint32_t const   )2350892612U,      (uint32_t const   )2932787856U, 
        (uint32_t const   )3199334847U,      (uint32_t const   )4009478890U,      (uint32_t const   )3905886544U,      (uint32_t const   )1373570990, 
        (uint32_t const   )2450425862U,      (uint32_t const   )4037870920U,      (uint32_t const   )3778841987U,      (uint32_t const   )2456817877U, 
        (uint32_t const   )286293407,      (uint32_t const   )124026297,      (uint32_t const   )3001279700U,      (uint32_t const   )1028597854, 
        (uint32_t const   )3115296800U,      (uint32_t const   )4208886496U,      (uint32_t const   )2691114635U,      (uint32_t const   )2188540206U, 
        (uint32_t const   )1430237888,      (uint32_t const   )1218109995,      (uint32_t const   )3572471700U,      (uint32_t const   )308166588, 
        (uint32_t const   )570424558,      (uint32_t const   )2187009021U,      (uint32_t const   )2455094765U,      (uint32_t const   )307733056, 
        (uint32_t const   )1310360322,      (uint32_t const   )3135275007U,      (uint32_t const   )1384269543,      (uint32_t const   )2388071438U, 
        (uint32_t const   )863238079,      (uint32_t const   )2359263624U,      (uint32_t const   )2801553128U,      (uint32_t const   )3380786597U, 
        (uint32_t const   )2831162807U,      (uint32_t const   )1470087780,      (uint32_t const   )1728663345,      (uint32_t const   )4072488799U, 
        (uint32_t const   )1090516929,      (uint32_t const   )532123132,      (uint32_t const   )2389430977U,      (uint32_t const   )1132193179, 
        (uint32_t const   )2578464191U,      (uint32_t const   )3051079243U,      (uint32_t const   )1670234342,      (uint32_t const   )1434557849, 
        (uint32_t const   )2711078940U,      (uint32_t const   )1241591150,      (uint32_t const   )3314043432U,      (uint32_t const   )3435360113U, 
        (uint32_t const   )3091448339U,      (uint32_t const   )1812415473,      (uint32_t const   )2198440252U,      (uint32_t const   )267246943, 
        (uint32_t const   )796911696,      (uint32_t const   )3619716990U,      (uint32_t const   )38830015,      (uint32_t const   )1526438404, 
        (uint32_t const   )2806502096U,      (uint32_t const   )374413614,      (uint32_t const   )2943401790U,      (uint32_t const   )1489179520, 
        (uint32_t const   )1603809326,      (uint32_t const   )1920779204,      (uint32_t const   )168801282,      (uint32_t const   )260042626, 
        (uint32_t const   )2358705581U,      (uint32_t const   )1563175598,      (uint32_t const   )2397674057U,      (uint32_t const   )1356499128, 
        (uint32_t const   )2217211040U,      (uint32_t const   )514611088,      (uint32_t const   )2037363785,      (uint32_t const   )2186468373U, 
        (uint32_t const   )4022173083U,      (uint32_t const   )2792511869U,      (uint32_t const   )2913485016U,      (uint32_t const   )1173701892, 
        (uint32_t const   )4200428547U,      (uint32_t const   )3896427269U,      (uint32_t const   )1334932762,      (uint32_t const   )2455136706U, 
        (uint32_t const   )602925377,      (uint32_t const   )2835607854U,      (uint32_t const   )1613172210,      (uint32_t const   )41346230, 
        (uint32_t const   )2499634548U,      (uint32_t const   )2457437618U,      (uint32_t const   )2188827595U,      (uint32_t const   )41386358, 
        (uint32_t const   )4172255629U,      (uint32_t const   )1313404830,      (uint32_t const   )2405527007U,      (uint32_t const   )3801973774U, 
        (uint32_t const   )2217704835U,      (uint32_t const   )873260488,      (uint32_t const   )2528884354U,      (uint32_t const   )2478092616U, 
        (uint32_t const   )4012915883U,      (uint32_t const   )2555359016U,      (uint32_t const   )2006953883,      (uint32_t const   )2463913485U, 
        (uint32_t const   )575479328,      (uint32_t const   )2218240648U,      (uint32_t const   )2099895446,      (uint32_t const   )660001756, 
        (uint32_t const   )2341502190U,      (uint32_t const   )3038761536U,      (uint32_t const   )3888151779U,      (uint32_t const   )3848713377U, 
        (uint32_t const   )3286851934U,      (uint32_t const   )1022894237,      (uint32_t const   )1620365795,      (uint32_t const   )3449594689U, 
        (uint32_t const   )1551255054,      (uint32_t const   )15374395,      (uint32_t const   )3570825345U,      (uint32_t const   )4249311020U, 
        (uint32_t const   )4151111129U,      (uint32_t const   )3181912732U,      (uint32_t const   )310226346,      (uint32_t const   )1133119310, 
        (uint32_t const   )530038928,      (uint32_t const   )136043402,      (uint32_t const   )2476768958U,      (uint32_t const   )3107506709U, 
        (uint32_t const   )2544909567U,      (uint32_t const   )1036173560,      (uint32_t const   )2367337196U,      (uint32_t const   )1681395281, 
        (uint32_t const   )1758231547,      (uint32_t const   )3641649032U,      (uint32_t const   )306774401,      (uint32_t const   )1575354324, 
        (uint32_t const   )3716085866U,      (uint32_t const   )1990386196,      (uint32_t const   )3114533736U,      (uint32_t const   )2455606671U, 
        (uint32_t const   )1262092282,      (uint32_t const   )3124342505U,      (uint32_t const   )2768229131U,      (uint32_t const   )4210529083U, 
        (uint32_t const   )1833535011,      (uint32_t const   )423410938,      (uint32_t const   )660763973,      (uint32_t const   )2187129978U, 
        (uint32_t const   )1639812000,      (uint32_t const   )3508421329U,      (uint32_t const   )3467445492U,      (uint32_t const   )310289298, 
        (uint32_t const   )272797111,      (uint32_t const   )2188552562U,      (uint32_t const   )2456863912U,      (uint32_t const   )310240523, 
        (uint32_t const   )677093832,      (uint32_t const   )1013118031,      (uint32_t const   )901835429,      (uint32_t const   )3892695601U, 
        (uint32_t const   )1116285435,      (uint32_t const   )3036471170U,      (uint32_t const   )1337354835,      (uint32_t const   )243122523, 
        (uint32_t const   )520626091,      (uint32_t const   )277223598,      (uint32_t const   )4244441197U,      (uint32_t const   )4194248841U, 
        (uint32_t const   )1766575121,      (uint32_t const   )594173102,      (uint32_t const   )316590669,      (uint32_t const   )742362309, 
        (uint32_t const   )3536858622U,      (uint32_t const   )4176435350U,      (uint32_t const   )3838792410U,      (uint32_t const   )2501204839U, 
        (uint32_t const   )1229605004,      (uint32_t const   )3115755532U,      (uint32_t const   )1552908988,      (uint32_t const   )2312334149U, 
        (uint32_t const   )979407927,      (uint32_t const   )3959474601U,      (uint32_t const   )1148277331,      (uint32_t const   )176638793, 
        (uint32_t const   )3614686272U,      (uint32_t const   )2083809052,      (uint32_t const   )40992502,      (uint32_t const   )1340822838, 
        (uint32_t const   )2731552767U,      (uint32_t const   )3535757508U,      (uint32_t const   )3560899520U,      (uint32_t const   )1354035053, 
        (uint32_t const   )122129617,      (uint32_t const   )7215240,      (uint32_t const   )2732932949U,      (uint32_t const   )3118912700U, 
        (uint32_t const   )2718203926U,      (uint32_t const   )2539075635U,      (uint32_t const   )3609230695U,      (uint32_t const   )3725561661U, 
        (uint32_t const   )1928887091,      (uint32_t const   )2882293555U,      (uint32_t const   )1988674909,      (uint32_t const   )2063640240, 
        (uint32_t const   )2491088897U,      (uint32_t const   )1459647954,      (uint32_t const   )4189817080U,      (uint32_t const   )2302804382U, 
        (uint32_t const   )1113892351,      (uint32_t const   )2237858528U,      (uint32_t const   )1927010603,      (uint32_t const   )4002880361U, 
        (uint32_t const   )1856122846,      (uint32_t const   )1594404395,      (uint32_t const   )2944033133U,      (uint32_t const   )3855189863U, 
        (uint32_t const   )3474975698U,      (uint32_t const   )1643104450,      (uint32_t const   )4054590833U,      (uint32_t const   )3431086530U, 
        (uint32_t const   )1730235576,      (uint32_t const   )2984608721U,      (uint32_t const   )3084664418U,      (uint32_t const   )2131803598, 
        (uint32_t const   )4178205752U,      (uint32_t const   )267404349,      (uint32_t const   )1617849798,      (uint32_t const   )1616132681, 
        (uint32_t const   )1462223176,      (uint32_t const   )736725533,      (uint32_t const   )2327058232U,      (uint32_t const   )551665188, 
        (uint32_t const   )2945899023U,      (uint32_t const   )1749386277,      (uint32_t const   )2575514597U,      (uint32_t const   )1611482493, 
        (uint32_t const   )674206544,      (uint32_t const   )2201269090U,      (uint32_t const   )3642560800U,      (uint32_t const   )728599968, 
        (uint32_t const   )1680547377,      (uint32_t const   )2620414464U,      (uint32_t const   )1388111496,      (uint32_t const   )453204106, 
        (uint32_t const   )4156223445U,      (uint32_t const   )1094905244,      (uint32_t const   )2754698257U,      (uint32_t const   )2201108165U, 
        (uint32_t const   )3757000246U,      (uint32_t const   )2704524545U,      (uint32_t const   )3922940700U,      (uint32_t const   )3996465027U};
#line 211 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128_sboxes.h"
static uint32_t const   cast_sbox4[256]  = 
#line 211
  {      (uint32_t const   )2645754912U,      (uint32_t const   )532081118,      (uint32_t const   )2814278639U,      (uint32_t const   )3530793624U, 
        (uint32_t const   )1246723035,      (uint32_t const   )1689095255,      (uint32_t const   )2236679235U,      (uint32_t const   )4194438865U, 
        (uint32_t const   )2116582143,      (uint32_t const   )3859789411U,      (uint32_t const   )157234593,      (uint32_t const   )2045505824, 
        (uint32_t const   )4245003587U,      (uint32_t const   )1687664561,      (uint32_t const   )4083425123U,      (uint32_t const   )605965023, 
        (uint32_t const   )672431967,      (uint32_t const   )1336064205,      (uint32_t const   )3376611392U,      (uint32_t const   )214114848, 
        (uint32_t const   )4258466608U,      (uint32_t const   )3232053071U,      (uint32_t const   )489488601,      (uint32_t const   )605322005, 
        (uint32_t const   )3998028058U,      (uint32_t const   )264917351,      (uint32_t const   )1912574028,      (uint32_t const   )756637694, 
        (uint32_t const   )436560991,      (uint32_t const   )202637054,      (uint32_t const   )135989450,      (uint32_t const   )85393697, 
        (uint32_t const   )2152923392U,      (uint32_t const   )3896401662U,      (uint32_t const   )2895836408U,      (uint32_t const   )2145855233, 
        (uint32_t const   )3535335007U,      (uint32_t const   )115294817,      (uint32_t const   )3147733898U,      (uint32_t const   )1922296357, 
        (uint32_t const   )3464822751U,      (uint32_t const   )4117858305U,      (uint32_t const   )1037454084,      (uint32_t const   )2725193275U, 
        (uint32_t const   )2127856640,      (uint32_t const   )1417604070,      (uint32_t const   )1148013728,      (uint32_t const   )1827919605, 
        (uint32_t const   )642362335,      (uint32_t const   )2929772533U,      (uint32_t const   )909348033,      (uint32_t const   )1346338451, 
        (uint32_t const   )3547799649U,      (uint32_t const   )297154785,      (uint32_t const   )1917849091,      (uint32_t const   )4161712827U, 
        (uint32_t const   )2883604526U,      (uint32_t const   )3968694238U,      (uint32_t const   )1469521537,      (uint32_t const   )3780077382U, 
        (uint32_t const   )3375584256U,      (uint32_t const   )1763717519,      (uint32_t const   )136166297,      (uint32_t const   )4290970789U, 
        (uint32_t const   )1295325189,      (uint32_t const   )2134727907,      (uint32_t const   )2798151366U,      (uint32_t const   )1566297257, 
        (uint32_t const   )3672928234U,      (uint32_t const   )2677174161U,      (uint32_t const   )2672173615U,      (uint32_t const   )965822077, 
        (uint32_t const   )2780786062U,      (uint32_t const   )289653839,      (uint32_t const   )1133871874,      (uint32_t const   )3491843819U, 
        (uint32_t const   )35685304,      (uint32_t const   )1068898316,      (uint32_t const   )418943774,      (uint32_t const   )672553190, 
        (uint32_t const   )642281022,      (uint32_t const   )2346158704U,      (uint32_t const   )1954014401,      (uint32_t const   )3037126780U, 
        (uint32_t const   )4079815205U,      (uint32_t const   )2030668546,      (uint32_t const   )3840588673U,      (uint32_t const   )672283427, 
        (uint32_t const   )1776201016,      (uint32_t const   )359975446,      (uint32_t const   )3750173538U,      (uint32_t const   )555499703, 
        (uint32_t const   )2769985273U,      (uint32_t const   )1324923,      (uint32_t const   )69110472,      (uint32_t const   )152125443, 
        (uint32_t const   )3176785106U,      (uint32_t const   )3822147285U,      (uint32_t const   )1340634837,      (uint32_t const   )798073664, 
        (uint32_t const   )1434183902,      (uint32_t const   )15393959,      (uint32_t const   )216384236,      (uint32_t const   )1303690150, 
        (uint32_t const   )3881221631U,      (uint32_t const   )3711134124U,      (uint32_t const   )3960975413U,      (uint32_t const   )106373927, 
        (uint32_t const   )2578434224U,      (uint32_t const   )1455997841,      (uint32_t const   )1801814300,      (uint32_t const   )1578393881, 
        (uint32_t const   )1854262133,      (uint32_t const   )3188178946U,      (uint32_t const   )3258078583U,      (uint32_t const   )2302670060U, 
        (uint32_t const   )1539295533,      (uint32_t const   )3505142565U,      (uint32_t const   )3078625975U,      (uint32_t const   )2372746020U, 
        (uint32_t const   )549938159,      (uint32_t const   )3278284284U,      (uint32_t const   )2620926080U,      (uint32_t const   )181285381, 
        (uint32_t const   )2865321098U,      (uint32_t const   )3970029511U,      (uint32_t const   )68876850,      (uint32_t const   )488006234, 
        (uint32_t const   )1728155692,      (uint32_t const   )2608167508U,      (uint32_t const   )836007927,      (uint32_t const   )2435231793U, 
        (uint32_t const   )919367643,      (uint32_t const   )3339422534U,      (uint32_t const   )3655756360U,      (uint32_t const   )1457871481, 
        (uint32_t const   )40520939,      (uint32_t const   )1380155135,      (uint32_t const   )797931188,      (uint32_t const   )234455205, 
        (uint32_t const   )2255801827U,      (uint32_t const   )3990488299U,      (uint32_t const   )397000196,      (uint32_t const   )739833055, 
        (uint32_t const   )3077865373U,      (uint32_t const   )2871719860U,      (uint32_t const   )4022553888U,      (uint32_t const   )772369276, 
        (uint32_t const   )390177364,      (uint32_t const   )3853951029U,      (uint32_t const   )557662966,      (uint32_t const   )740064294, 
        (uint32_t const   )1640166671,      (uint32_t const   )1699928825,      (uint32_t const   )3535942136U,      (uint32_t const   )622006121, 
        (uint32_t const   )3625353122U,      (uint32_t const   )68743880,      (uint32_t const   )1742502,      (uint32_t const   )219489963, 
        (uint32_t const   )1664179233,      (uint32_t const   )1577743084,      (uint32_t const   )1236991741,      (uint32_t const   )410585305, 
        (uint32_t const   )2366487942U,      (uint32_t const   )823226535,      (uint32_t const   )1050371084,      (uint32_t const   )3426619607U, 
        (uint32_t const   )3586839478U,      (uint32_t const   )212779912,      (uint32_t const   )4147118561U,      (uint32_t const   )1819446015, 
        (uint32_t const   )1911218849,      (uint32_t const   )530248558,      (uint32_t const   )3486241071U,      (uint32_t const   )3252585495U, 
        (uint32_t const   )2886188651U,      (uint32_t const   )3410272728U,      (uint32_t const   )2342195030U,      (uint32_t const   )20547779, 
        (uint32_t const   )2982490058U,      (uint32_t const   )3032363469U,      (uint32_t const   )3631753222U,      (uint32_t const   )312714466, 
        (uint32_t const   )1870521650,      (uint32_t const   )1493008054,      (uint32_t const   )3491686656U,      (uint32_t const   )615382978, 
        (uint32_t const   )4103671749U,      (uint32_t const   )2534517445U,      (uint32_t const   )1932181,      (uint32_t const   )2196105170U, 
        (uint32_t const   )278426614,      (uint32_t const   )6369430,      (uint32_t const   )3274544417U,      (uint32_t const   )2913018367U, 
        (uint32_t const   )697336853,      (uint32_t const   )2143000447,      (uint32_t const   )2946413531U,      (uint32_t const   )701099306, 
        (uint32_t const   )1558357093,      (uint32_t const   )2805003052U,      (uint32_t const   )3500818408U,      (uint32_t const   )2321334417U, 
        (uint32_t const   )3567135975U,      (uint32_t const   )216290473,      (uint32_t const   )3591032198U,      (uint32_t const   )23009561, 
        (uint32_t const   )1996984579,      (uint32_t const   )3735042806U,      (uint32_t const   )2024298078,      (uint32_t const   )3739440863U, 
        (uint32_t const   )569400510,      (uint32_t const   )2339758983U,      (uint32_t const   )3016033873U,      (uint32_t const   )3097871343U, 
        (uint32_t const   )3639523026U,      (uint32_t const   )3844324983U,      (uint32_t const   )3256173865U,      (uint32_t const   )795471839, 
        (uint32_t const   )2951117563U,      (uint32_t const   )4101031090U,      (uint32_t const   )4091603803U,      (uint32_t const   )3603732598U, 
        (uint32_t const   )971261452,      (uint32_t const   )534414648,      (uint32_t const   )428311343,      (uint32_t const   )3389027175U, 
        (uint32_t const   )2844869880U,      (uint32_t const   )694888862,      (uint32_t const   )1227866773,      (uint32_t const   )2456207019U, 
        (uint32_t const   )3043454569U,      (uint32_t const   )2614353370U,      (uint32_t const   )3749578031U,      (uint32_t const   )3676663836U, 
        (uint32_t const   )459166190,      (uint32_t const   )4132644070U,      (uint32_t const   )1794958188,      (uint32_t const   )51825668, 
        (uint32_t const   )2252611902U,      (uint32_t const   )3084671440U,      (uint32_t const   )2036672799,      (uint32_t const   )3436641603U, 
        (uint32_t const   )1099053433,      (uint32_t const   )2469121526U,      (uint32_t const   )3059204941U,      (uint32_t const   )1323291266, 
        (uint32_t const   )2061838604,      (uint32_t const   )1018778475,      (uint32_t const   )2233344254U,      (uint32_t const   )2553501054U, 
        (uint32_t const   )334295216,      (uint32_t const   )3556750194U,      (uint32_t const   )1065731521,      (uint32_t const   )183467730};
#line 278 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128_sboxes.h"
static uint32_t const   cast_sbox5[256]  = 
#line 278
  {      (uint32_t const   )2127105028,      (uint32_t const   )745436345,      (uint32_t const   )2601412319U,      (uint32_t const   )2788391185U, 
        (uint32_t const   )3093987327U,      (uint32_t const   )500390133,      (uint32_t const   )1155374404,      (uint32_t const   )389092991, 
        (uint32_t const   )150729210,      (uint32_t const   )3891597772U,      (uint32_t const   )3523549952U,      (uint32_t const   )1935325696, 
        (uint32_t const   )716645080,      (uint32_t const   )946045387,      (uint32_t const   )2901812282U,      (uint32_t const   )1774124410, 
        (uint32_t const   )3869435775U,      (uint32_t const   )4039581901U,      (uint32_t const   )3293136918U,      (uint32_t const   )3438657920U, 
        (uint32_t const   )948246080,      (uint32_t const   )363898952,      (uint32_t const   )3867875531U,      (uint32_t const   )1286266623, 
        (uint32_t const   )1598556673,      (uint32_t const   )68334250,      (uint32_t const   )630723836,      (uint32_t const   )1104211938, 
        (uint32_t const   )1312863373,      (uint32_t const   )613332731,      (uint32_t const   )2377784574U,      (uint32_t const   )1101634306, 
        (uint32_t const   )441780740,      (uint32_t const   )3129959883U,      (uint32_t const   )1917973735,      (uint32_t const   )2510624549U, 
        (uint32_t const   )3238456535U,      (uint32_t const   )2544211978U,      (uint32_t const   )3308894634U,      (uint32_t const   )1299840618, 
        (uint32_t const   )4076074851U,      (uint32_t const   )1756332096,      (uint32_t const   )3977027158U,      (uint32_t const   )297047435, 
        (uint32_t const   )3790297736U,      (uint32_t const   )2265573040U,      (uint32_t const   )3621810518U,      (uint32_t const   )1311375015, 
        (uint32_t const   )1667687725,      (uint32_t const   )47300608,      (uint32_t const   )3299642885U,      (uint32_t const   )2474112369U, 
        (uint32_t const   )201668394,      (uint32_t const   )1468347890,      (uint32_t const   )576830978,      (uint32_t const   )3594690761U, 
        (uint32_t const   )3742605952U,      (uint32_t const   )1958042578,      (uint32_t const   )1747032512,      (uint32_t const   )3558991340U, 
        (uint32_t const   )1408974056,      (uint32_t const   )3366841779U,      (uint32_t const   )682131401,      (uint32_t const   )1033214337, 
        (uint32_t const   )1545599232,      (uint32_t const   )4265137049U,      (uint32_t const   )206503691,      (uint32_t const   )103024618, 
        (uint32_t const   )2855227313U,      (uint32_t const   )1337551222,      (uint32_t const   )2428998917U,      (uint32_t const   )2963842932U, 
        (uint32_t const   )4015366655U,      (uint32_t const   )3852247746U,      (uint32_t const   )2796956967U,      (uint32_t const   )3865723491U, 
        (uint32_t const   )3747938335U,      (uint32_t const   )247794022,      (uint32_t const   )3755824572U,      (uint32_t const   )702416469, 
        (uint32_t const   )2434691994U,      (uint32_t const   )397379957,      (uint32_t const   )851939612,      (uint32_t const   )2314769512U, 
        (uint32_t const   )218229120,      (uint32_t const   )1380406772,      (uint32_t const   )62274761,      (uint32_t const   )214451378, 
        (uint32_t const   )3170103466U,      (uint32_t const   )2276210409U,      (uint32_t const   )3845813286U,      (uint32_t const   )28563499, 
        (uint32_t const   )446592073,      (uint32_t const   )1693330814,      (uint32_t const   )3453727194U,      (uint32_t const   )29968656, 
        (uint32_t const   )3093872512U,      (uint32_t const   )220656637,      (uint32_t const   )2470637031U,      (uint32_t const   )77972100, 
        (uint32_t const   )1667708854,      (uint32_t const   )1358280214,      (uint32_t const   )4064765667U,      (uint32_t const   )2395616961U, 
        (uint32_t const   )325977563,      (uint32_t const   )4277240721U,      (uint32_t const   )4220025399U,      (uint32_t const   )3605526484U, 
        (uint32_t const   )3355147721U,      (uint32_t const   )811859167,      (uint32_t const   )3069544926U,      (uint32_t const   )3962126810U, 
        (uint32_t const   )652502677,      (uint32_t const   )3075892249U,      (uint32_t const   )4132761541U,      (uint32_t const   )3498924215U, 
        (uint32_t const   )1217549313,      (uint32_t const   )3250244479U,      (uint32_t const   )3858715919U,      (uint32_t const   )3053989961U, 
        (uint32_t const   )1538642152,      (uint32_t const   )2279026266U,      (uint32_t const   )2875879137U,      (uint32_t const   )574252750, 
        (uint32_t const   )3324769229U,      (uint32_t const   )2651358713U,      (uint32_t const   )1758150215,      (uint32_t const   )141295887, 
        (uint32_t const   )2719868960U,      (uint32_t const   )3515574750U,      (uint32_t const   )4093007735U,      (uint32_t const   )4194485238U, 
        (uint32_t const   )1082055363,      (uint32_t const   )3417560400U,      (uint32_t const   )395511885,      (uint32_t const   )2966884026U, 
        (uint32_t const   )179534037,      (uint32_t const   )3646028556U,      (uint32_t const   )3738688086U,      (uint32_t const   )1092926436, 
        (uint32_t const   )2496269142U,      (uint32_t const   )257381841,      (uint32_t const   )3772900718U,      (uint32_t const   )1636087230, 
        (uint32_t const   )1477059743,      (uint32_t const   )2499234752U,      (uint32_t const   )3811018894U,      (uint32_t const   )2675660129U, 
        (uint32_t const   )3285975680U,      (uint32_t const   )90732309,      (uint32_t const   )1684827095,      (uint32_t const   )1150307763, 
        (uint32_t const   )1723134115,      (uint32_t const   )3237045386U,      (uint32_t const   )1769919919,      (uint32_t const   )1240018934, 
        (uint32_t const   )815675215,      (uint32_t const   )750138730,      (uint32_t const   )2239792499U,      (uint32_t const   )1234303040, 
        (uint32_t const   )1995484674,      (uint32_t const   )138143821,      (uint32_t const   )675421338,      (uint32_t const   )1145607174, 
        (uint32_t const   )1936608440,      (uint32_t const   )3238603024U,      (uint32_t const   )2345230278U,      (uint32_t const   )2105974004, 
        (uint32_t const   )323969391,      (uint32_t const   )779555213,      (uint32_t const   )3004902369U,      (uint32_t const   )2861610098U, 
        (uint32_t const   )1017501463,      (uint32_t const   )2098600890,      (uint32_t const   )2628620304U,      (uint32_t const   )2940611490U, 
        (uint32_t const   )2682542546U,      (uint32_t const   )1171473753,      (uint32_t const   )3656571411U,      (uint32_t const   )3687208071U, 
        (uint32_t const   )4091869518U,      (uint32_t const   )393037935,      (uint32_t const   )159126506,      (uint32_t const   )1662887367, 
        (uint32_t const   )1147106178,      (uint32_t const   )391545844,      (uint32_t const   )3452332695U,      (uint32_t const   )1891500680, 
        (uint32_t const   )3016609650U,      (uint32_t const   )1851642611,      (uint32_t const   )546529401,      (uint32_t const   )1167818917, 
        (uint32_t const   )3194020571U,      (uint32_t const   )2848076033U,      (uint32_t const   )3953471836U,      (uint32_t const   )575554290, 
        (uint32_t const   )475796850,      (uint32_t const   )4134673196U,      (uint32_t const   )450035699,      (uint32_t const   )2351251534U, 
        (uint32_t const   )844027695,      (uint32_t const   )1080539133,      (uint32_t const   )86184846,      (uint32_t const   )1554234488, 
        (uint32_t const   )3692025454U,      (uint32_t const   )1972511363,      (uint32_t const   )2018339607,      (uint32_t const   )1491841390, 
        (uint32_t const   )1141460869,      (uint32_t const   )1061690759,      (uint32_t const   )4244549243U,      (uint32_t const   )2008416118, 
        (uint32_t const   )2351104703U,      (uint32_t const   )2868147542U,      (uint32_t const   )1598468138,      (uint32_t const   )722020353, 
        (uint32_t const   )1027143159,      (uint32_t const   )212344630,      (uint32_t const   )1387219594,      (uint32_t const   )1725294528, 
        (uint32_t const   )3745187956U,      (uint32_t const   )2500153616U,      (uint32_t const   )458938280,      (uint32_t const   )4129215917U, 
        (uint32_t const   )1828119673,      (uint32_t const   )544571780,      (uint32_t const   )3503225445U,      (uint32_t const   )2297937496U, 
        (uint32_t const   )1241802790,      (uint32_t const   )267843827,      (uint32_t const   )2694610800U,      (uint32_t const   )1397140384, 
        (uint32_t const   )1558801448,      (uint32_t const   )3782667683U,      (uint32_t const   )1806446719,      (uint32_t const   )929573330, 
        (uint32_t const   )2234912681U,      (uint32_t const   )400817706,      (uint32_t const   )616011623,      (uint32_t const   )4121520928U, 
        (uint32_t const   )3603768725U,      (uint32_t const   )1761550015,      (uint32_t const   )1968522284,      (uint32_t const   )4053731006U, 
        (uint32_t const   )4192232858U,      (uint32_t const   )4005120285U,      (uint32_t const   )872482584,      (uint32_t const   )3140537016U, 
        (uint32_t const   )3894607381U,      (uint32_t const   )2287405443U,      (uint32_t const   )1963876937,      (uint32_t const   )3663887957U, 
        (uint32_t const   )1584857000,      (uint32_t const   )2975024454U,      (uint32_t const   )1833426440,      (uint32_t const   )4025083860U};
#line 345 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128_sboxes.h"
static uint32_t const   cast_sbox6[256]  = 
#line 345
  {      (uint32_t const   )4143615901U,      (uint32_t const   )749497569,      (uint32_t const   )1285769319,      (uint32_t const   )3795025788U, 
        (uint32_t const   )2514159847U,      (uint32_t const   )23610292,      (uint32_t const   )3974978748U,      (uint32_t const   )844452780, 
        (uint32_t const   )3214870880U,      (uint32_t const   )3751928557U,      (uint32_t const   )2213566365U,      (uint32_t const   )1676510905, 
        (uint32_t const   )448177848,      (uint32_t const   )3730751033U,      (uint32_t const   )4086298418U,      (uint32_t const   )2307502392U, 
        (uint32_t const   )871450977,      (uint32_t const   )3222878141U,      (uint32_t const   )4110862042U,      (uint32_t const   )3831651966U, 
        (uint32_t const   )2735270553U,      (uint32_t const   )1310974780,      (uint32_t const   )2043402188,      (uint32_t const   )1218528103, 
        (uint32_t const   )2736035353U,      (uint32_t const   )4274605013U,      (uint32_t const   )2702448458U,      (uint32_t const   )3936360550U, 
        (uint32_t const   )2693061421U,      (uint32_t const   )162023535,      (uint32_t const   )2827510090U,      (uint32_t const   )687910808, 
        (uint32_t const   )23484817,      (uint32_t const   )3784910947U,      (uint32_t const   )3371371616U,      (uint32_t const   )779677500, 
        (uint32_t const   )3503626546U,      (uint32_t const   )3473927188U,      (uint32_t const   )4157212626U,      (uint32_t const   )3500679282U, 
        (uint32_t const   )4248902014U,      (uint32_t const   )2466621104U,      (uint32_t const   )3899384794U,      (uint32_t const   )1958663117, 
        (uint32_t const   )925738300,      (uint32_t const   )1283408968,      (uint32_t const   )3669349440U,      (uint32_t const   )1840910019, 
        (uint32_t const   )137959847,      (uint32_t const   )2679828185U,      (uint32_t const   )1239142320,      (uint32_t const   )1315376211, 
        (uint32_t const   )1547541505,      (uint32_t const   )1690155329,      (uint32_t const   )739140458,      (uint32_t const   )3128809933U, 
        (uint32_t const   )3933172616U,      (uint32_t const   )3876308834U,      (uint32_t const   )905091803,      (uint32_t const   )1548541325, 
        (uint32_t const   )4040461708U,      (uint32_t const   )3095483362U,      (uint32_t const   )144808038,      (uint32_t const   )451078856, 
        (uint32_t const   )676114313,      (uint32_t const   )2861728291U,      (uint32_t const   )2469707347U,      (uint32_t const   )993665471, 
        (uint32_t const   )373509091,      (uint32_t const   )2599041286U,      (uint32_t const   )4025009006U,      (uint32_t const   )4170239449U, 
        (uint32_t const   )2149739950U,      (uint32_t const   )3275793571U,      (uint32_t const   )3749616649U,      (uint32_t const   )2794760199U, 
        (uint32_t const   )1534877388,      (uint32_t const   )572371878,      (uint32_t const   )2590613551U,      (uint32_t const   )1753320020, 
        (uint32_t const   )3467782511U,      (uint32_t const   )1405125690,      (uint32_t const   )4270405205U,      (uint32_t const   )633333386, 
        (uint32_t const   )3026356924U,      (uint32_t const   )3475123903U,      (uint32_t const   )632057672,      (uint32_t const   )2846462855U, 
        (uint32_t const   )1404951397,      (uint32_t const   )3882875879U,      (uint32_t const   )3915906424U,      (uint32_t const   )195638627, 
        (uint32_t const   )2385783745U,      (uint32_t const   )3902872553U,      (uint32_t const   )1233155085,      (uint32_t const   )3355999740U, 
        (uint32_t const   )2380578713U,      (uint32_t const   )2702246304U,      (uint32_t const   )2144565621,      (uint32_t const   )3663341248U, 
        (uint32_t const   )3894384975U,      (uint32_t const   )2502479241U,      (uint32_t const   )4248018925U,      (uint32_t const   )3094885567U, 
        (uint32_t const   )1594115437,      (uint32_t const   )572884632,      (uint32_t const   )3385116731U,      (uint32_t const   )767645374, 
        (uint32_t const   )1331858858,      (uint32_t const   )1475698373,      (uint32_t const   )3793881790U,      (uint32_t const   )3532746431U, 
        (uint32_t const   )1321687957,      (uint32_t const   )619889600,      (uint32_t const   )1121017241,      (uint32_t const   )3440213920U, 
        (uint32_t const   )2070816767,      (uint32_t const   )2833025776U,      (uint32_t const   )1933951238,      (uint32_t const   )4095615791U, 
        (uint32_t const   )890643334,      (uint32_t const   )3874130214U,      (uint32_t const   )859025556,      (uint32_t const   )360630002, 
        (uint32_t const   )925594799,      (uint32_t const   )1764062180,      (uint32_t const   )3920222280U,      (uint32_t const   )4078305929U, 
        (uint32_t const   )979562269,      (uint32_t const   )2810700344U,      (uint32_t const   )4087740022U,      (uint32_t const   )1949714515, 
        (uint32_t const   )546639971,      (uint32_t const   )1165388173,      (uint32_t const   )3069891591U,      (uint32_t const   )1495988560, 
        (uint32_t const   )922170659,      (uint32_t const   )1291546247,      (uint32_t const   )2107952832,      (uint32_t const   )1813327274, 
        (uint32_t const   )3406010024U,      (uint32_t const   )3306028637U,      (uint32_t const   )4241950635U,      (uint32_t const   )153207855, 
        (uint32_t const   )2313154747U,      (uint32_t const   )1608695416,      (uint32_t const   )1150242611,      (uint32_t const   )1967526857, 
        (uint32_t const   )721801357,      (uint32_t const   )1220138373,      (uint32_t const   )3691287617U,      (uint32_t const   )3356069787U, 
        (uint32_t const   )2112743302,      (uint32_t const   )3281662835U,      (uint32_t const   )1111556101,      (uint32_t const   )1778980689, 
        (uint32_t const   )250857638,      (uint32_t const   )2298507990U,      (uint32_t const   )673216130,      (uint32_t const   )2846488510U, 
        (uint32_t const   )3207751581U,      (uint32_t const   )3562756981U,      (uint32_t const   )3008625920U,      (uint32_t const   )3417367384U, 
        (uint32_t const   )2198807050U,      (uint32_t const   )529510932,      (uint32_t const   )3547516680U,      (uint32_t const   )3426503187U, 
        (uint32_t const   )2364944742U,      (uint32_t const   )102533054,      (uint32_t const   )2294910856U,      (uint32_t const   )1617093527, 
        (uint32_t const   )1204784762,      (uint32_t const   )3066581635U,      (uint32_t const   )1019391227,      (uint32_t const   )1069574518, 
        (uint32_t const   )1317995090,      (uint32_t const   )1691889997,      (uint32_t const   )3661132003U,      (uint32_t const   )510022745, 
        (uint32_t const   )3238594800U,      (uint32_t const   )1362108837,      (uint32_t const   )1817929911,      (uint32_t const   )2184153760U, 
        (uint32_t const   )805817662,      (uint32_t const   )1953603311,      (uint32_t const   )3699844737U,      (uint32_t const   )120799444, 
        (uint32_t const   )2118332377,      (uint32_t const   )207536705,      (uint32_t const   )2282301548U,      (uint32_t const   )4120041617U, 
        (uint32_t const   )145305846,      (uint32_t const   )2508124933U,      (uint32_t const   )3086745533U,      (uint32_t const   )3261524335U, 
        (uint32_t const   )1877257368,      (uint32_t const   )2977164480U,      (uint32_t const   )3160454186U,      (uint32_t const   )2503252186U, 
        (uint32_t const   )4221677074U,      (uint32_t const   )759945014,      (uint32_t const   )254147243,      (uint32_t const   )2767453419U, 
        (uint32_t const   )3801518371U,      (uint32_t const   )629083197,      (uint32_t const   )2471014217U,      (uint32_t const   )907280572, 
        (uint32_t const   )3900796746U,      (uint32_t const   )940896768,      (uint32_t const   )2751021123U,      (uint32_t const   )2625262786U, 
        (uint32_t const   )3161476951U,      (uint32_t const   )3661752313U,      (uint32_t const   )3260732218U,      (uint32_t const   )1425318020, 
        (uint32_t const   )2977912069U,      (uint32_t const   )1496677566,      (uint32_t const   )3988592072U,      (uint32_t const   )2140652971, 
        (uint32_t const   )3126511541U,      (uint32_t const   )3069632175U,      (uint32_t const   )977771578,      (uint32_t const   )1392695845, 
        (uint32_t const   )1698528874,      (uint32_t const   )1411812681,      (uint32_t const   )1369733098,      (uint32_t const   )1343739227, 
        (uint32_t const   )3620887944U,      (uint32_t const   )1142123638,      (uint32_t const   )67414216,      (uint32_t const   )3102056737U, 
        (uint32_t const   )3088749194U,      (uint32_t const   )1626167401,      (uint32_t const   )2546293654U,      (uint32_t const   )3941374235U, 
        (uint32_t const   )697522451,      (uint32_t const   )33404913,      (uint32_t const   )143560186,      (uint32_t const   )2595682037U, 
        (uint32_t const   )994885535,      (uint32_t const   )1247667115,      (uint32_t const   )3859094837U,      (uint32_t const   )2699155541U, 
        (uint32_t const   )3547024625U,      (uint32_t const   )4114935275U,      (uint32_t const   )2968073508U,      (uint32_t const   )3199963069U, 
        (uint32_t const   )2732024527U,      (uint32_t const   )1237921620,      (uint32_t const   )951448369,      (uint32_t const   )1898488916, 
        (uint32_t const   )1211705605,      (uint32_t const   )2790989240U,      (uint32_t const   )2233243581U,      (uint32_t const   )3598044975U};
#line 412 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128_sboxes.h"
static uint32_t const   cast_sbox7[256]  = 
#line 412
  {      (uint32_t const   )2246066201U,      (uint32_t const   )858518887,      (uint32_t const   )1714274303,      (uint32_t const   )3485882003U, 
        (uint32_t const   )713916271,      (uint32_t const   )2879113490U,      (uint32_t const   )3730835617U,      (uint32_t const   )539548191, 
        (uint32_t const   )36158695,      (uint32_t const   )1298409750,      (uint32_t const   )419087104,      (uint32_t const   )1358007170, 
        (uint32_t const   )749914897,      (uint32_t const   )2989680476U,      (uint32_t const   )1261868530,      (uint32_t const   )2995193822U, 
        (uint32_t const   )2690628854U,      (uint32_t const   )3443622377U,      (uint32_t const   )3780124940U,      (uint32_t const   )3796824509U, 
        (uint32_t const   )2976433025U,      (uint32_t const   )4259637129U,      (uint32_t const   )1551479000,      (uint32_t const   )512490819, 
        (uint32_t const   )1296650241,      (uint32_t const   )951993153,      (uint32_t const   )2436689437U,      (uint32_t const   )2460458047U, 
        (uint32_t const   )144139966,      (uint32_t const   )3136204276U,      (uint32_t const   )310820559,      (uint32_t const   )3068840729U, 
        (uint32_t const   )643875328,      (uint32_t const   )1969602020,      (uint32_t const   )1680088954,      (uint32_t const   )2185813161U, 
        (uint32_t const   )3283332454U,      (uint32_t const   )672358534,      (uint32_t const   )198762408,      (uint32_t const   )896343282, 
        (uint32_t const   )276269502,      (uint32_t const   )3014846926U,      (uint32_t const   )84060815,      (uint32_t const   )197145886, 
        (uint32_t const   )376173866,      (uint32_t const   )3943890818U,      (uint32_t const   )3813173521U,      (uint32_t const   )3545068822U, 
        (uint32_t const   )1316698879,      (uint32_t const   )1598252827,      (uint32_t const   )2633424951U,      (uint32_t const   )1233235075, 
        (uint32_t const   )859989710,      (uint32_t const   )2358460855U,      (uint32_t const   )3503838400U,      (uint32_t const   )3409603720U, 
        (uint32_t const   )1203513385,      (uint32_t const   )1193654839,      (uint32_t const   )2792018475U,      (uint32_t const   )2060853022, 
        (uint32_t const   )207403770,      (uint32_t const   )1144516871,      (uint32_t const   )3068631394U,      (uint32_t const   )1121114134, 
        (uint32_t const   )177607304,      (uint32_t const   )3785736302U,      (uint32_t const   )326409831,      (uint32_t const   )1929119770, 
        (uint32_t const   )2983279095U,      (uint32_t const   )4183308101U,      (uint32_t const   )3474579288U,      (uint32_t const   )3200513878U, 
        (uint32_t const   )3228482096U,      (uint32_t const   )119610148,      (uint32_t const   )1170376745,      (uint32_t const   )3378393471U, 
        (uint32_t const   )3163473169U,      (uint32_t const   )951863017,      (uint32_t const   )3337026068U,      (uint32_t const   )3135789130U, 
        (uint32_t const   )2907618374U,      (uint32_t const   )1183797387,      (uint32_t const   )2015970143,      (uint32_t const   )4045674555U, 
        (uint32_t const   )2182986399U,      (uint32_t const   )2952138740U,      (uint32_t const   )3928772205U,      (uint32_t const   )384012900, 
        (uint32_t const   )2454997643U,      (uint32_t const   )10178499,      (uint32_t const   )2879818989U,      (uint32_t const   )2596892536U, 
        (uint32_t const   )111523738,      (uint32_t const   )2995089006U,      (uint32_t const   )451689641,      (uint32_t const   )3196290696U, 
        (uint32_t const   )235406569,      (uint32_t const   )1441906262,      (uint32_t const   )3890558523U,      (uint32_t const   )3013735005U, 
        (uint32_t const   )4158569349U,      (uint32_t const   )1644036924,      (uint32_t const   )376726067,      (uint32_t const   )1006849064, 
        (uint32_t const   )3664579700U,      (uint32_t const   )2041234796,      (uint32_t const   )1021632941,      (uint32_t const   )1374734338, 
        (uint32_t const   )2566452058U,      (uint32_t const   )371631263,      (uint32_t const   )4007144233U,      (uint32_t const   )490221539, 
        (uint32_t const   )206551450,      (uint32_t const   )3140638584U,      (uint32_t const   )1053219195,      (uint32_t const   )1853335209, 
        (uint32_t const   )3412429660U,      (uint32_t const   )3562156231U,      (uint32_t const   )735133835,      (uint32_t const   )1623211703, 
        (uint32_t const   )3104214392U,      (uint32_t const   )2738312436U,      (uint32_t const   )4096837757U,      (uint32_t const   )3366392578U, 
        (uint32_t const   )3110964274U,      (uint32_t const   )3956598718U,      (uint32_t const   )3196820781U,      (uint32_t const   )2038037254, 
        (uint32_t const   )3877786376U,      (uint32_t const   )2339753847U,      (uint32_t const   )300912036,      (uint32_t const   )3766732888U, 
        (uint32_t const   )2372630639U,      (uint32_t const   )1516443558,      (uint32_t const   )4200396704U,      (uint32_t const   )1574567987, 
        (uint32_t const   )4069441456U,      (uint32_t const   )4122592016U,      (uint32_t const   )2699739776U,      (uint32_t const   )146372218, 
        (uint32_t const   )2748961456U,      (uint32_t const   )2043888151,      (uint32_t const   )35287437,      (uint32_t const   )2596680554U, 
        (uint32_t const   )655490400,      (uint32_t const   )1132482787,      (uint32_t const   )110692520,      (uint32_t const   )1031794116, 
        (uint32_t const   )2188192751U,      (uint32_t const   )1324057718,      (uint32_t const   )1217253157,      (uint32_t const   )919197030, 
        (uint32_t const   )686247489,      (uint32_t const   )3261139658U,      (uint32_t const   )1028237775,      (uint32_t const   )3135486431U, 
        (uint32_t const   )3059715558U,      (uint32_t const   )2460921700U,      (uint32_t const   )986174950,      (uint32_t const   )2661811465U, 
        (uint32_t const   )4062904701U,      (uint32_t const   )2752986992U,      (uint32_t const   )3709736643U,      (uint32_t const   )367056889, 
        (uint32_t const   )1353824391,      (uint32_t const   )731860949,      (uint32_t const   )1650113154,      (uint32_t const   )1778481506, 
        (uint32_t const   )784341916,      (uint32_t const   )357075625,      (uint32_t const   )3608602432U,      (uint32_t const   )1074092588, 
        (uint32_t const   )2480052770U,      (uint32_t const   )3811426202U,      (uint32_t const   )92751289,      (uint32_t const   )877911070, 
        (uint32_t const   )3600361838U,      (uint32_t const   )1231880047,      (uint32_t const   )480201094,      (uint32_t const   )3756190983U, 
        (uint32_t const   )3094495953U,      (uint32_t const   )434011822,      (uint32_t const   )87971354,      (uint32_t const   )363687820, 
        (uint32_t const   )1717726236,      (uint32_t const   )1901380172,      (uint32_t const   )3926403882U,      (uint32_t const   )2481662265U, 
        (uint32_t const   )400339184,      (uint32_t const   )1490350766,      (uint32_t const   )2661455099U,      (uint32_t const   )1389319756, 
        (uint32_t const   )2558787174U,      (uint32_t const   )784598401,      (uint32_t const   )1983468483,      (uint32_t const   )30828846, 
        (uint32_t const   )3550527752U,      (uint32_t const   )2716276238U,      (uint32_t const   )3841122214U,      (uint32_t const   )1765724805, 
        (uint32_t const   )1955612312,      (uint32_t const   )1277890269,      (uint32_t const   )1333098070,      (uint32_t const   )1564029816, 
        (uint32_t const   )2704417615U,      (uint32_t const   )1026694237,      (uint32_t const   )3287671188U,      (uint32_t const   )1260819201, 
        (uint32_t const   )3349086767U,      (uint32_t const   )1016692350,      (uint32_t const   )1582273796,      (uint32_t const   )1073413053, 
        (uint32_t const   )1995943182,      (uint32_t const   )694588404,      (uint32_t const   )1025494639,      (uint32_t const   )3323872702U, 
        (uint32_t const   )3551898420U,      (uint32_t const   )4146854327U,      (uint32_t const   )453260480,      (uint32_t const   )1316140391, 
        (uint32_t const   )1435673405,      (uint32_t const   )3038941953U,      (uint32_t const   )3486689407U,      (uint32_t const   )1622062951, 
        (uint32_t const   )403978347,      (uint32_t const   )817677117,      (uint32_t const   )950059133,      (uint32_t const   )4246079218U, 
        (uint32_t const   )3278066075U,      (uint32_t const   )1486738320,      (uint32_t const   )1417279718,      (uint32_t const   )481875527, 
        (uint32_t const   )2549965225U,      (uint32_t const   )3933690356U,      (uint32_t const   )760697757,      (uint32_t const   )1452955855, 
        (uint32_t const   )3897451437U,      (uint32_t const   )1177426808,      (uint32_t const   )1702951038,      (uint32_t const   )4085348628U, 
        (uint32_t const   )2447005172U,      (uint32_t const   )1084371187,      (uint32_t const   )3516436277U,      (uint32_t const   )3068336338U, 
        (uint32_t const   )1073369276,      (uint32_t const   )1027665953,      (uint32_t const   )3284188590U,      (uint32_t const   )1230553676, 
        (uint32_t const   )1368340146,      (uint32_t const   )2226246512U,      (uint32_t const   )267243139,      (uint32_t const   )2274220762U, 
        (uint32_t const   )4070734279U,      (uint32_t const   )2497715176U,      (uint32_t const   )2423353163U,      (uint32_t const   )2504755875U};
#line 479 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128_sboxes.h"
static uint32_t const   cast_sbox8[256]  = 
#line 479
  {      (uint32_t const   )3793104909U,      (uint32_t const   )3151888380U,      (uint32_t const   )2817252029U,      (uint32_t const   )895778965, 
        (uint32_t const   )2005530807,      (uint32_t const   )3871412763U,      (uint32_t const   )237245952,      (uint32_t const   )86829237, 
        (uint32_t const   )296341424,      (uint32_t const   )3851759377U,      (uint32_t const   )3974600970U,      (uint32_t const   )2475086196U, 
        (uint32_t const   )709006108,      (uint32_t const   )1994621201,      (uint32_t const   )2972577594U,      (uint32_t const   )937287164, 
        (uint32_t const   )3734691505U,      (uint32_t const   )168608556,      (uint32_t const   )3189338153U,      (uint32_t const   )2225080640U, 
        (uint32_t const   )3139713551U,      (uint32_t const   )3033610191U,      (uint32_t const   )3025041904U,      (uint32_t const   )77524477, 
        (uint32_t const   )185966941,      (uint32_t const   )1208824168,      (uint32_t const   )2344345178U,      (uint32_t const   )1721625922, 
        (uint32_t const   )3354191921U,      (uint32_t const   )1066374631,      (uint32_t const   )1927223579,      (uint32_t const   )1971335949, 
        (uint32_t const   )2483503697U,      (uint32_t const   )1551748602,      (uint32_t const   )2881383779U,      (uint32_t const   )2856329572U, 
        (uint32_t const   )3003241482U,      (uint32_t const   )48746954,      (uint32_t const   )1398218158,      (uint32_t const   )2050065058, 
        (uint32_t const   )313056748,      (uint32_t const   )4255789917U,      (uint32_t const   )393167848,      (uint32_t const   )1912293076, 
        (uint32_t const   )940740642,      (uint32_t const   )3465845460U,      (uint32_t const   )3091687853U,      (uint32_t const   )2522601570U, 
        (uint32_t const   )2197016661U,      (uint32_t const   )1727764327,      (uint32_t const   )364383054,      (uint32_t const   )492521376, 
        (uint32_t const   )1291706479,      (uint32_t const   )3264136376U,      (uint32_t const   )1474851438,      (uint32_t const   )1685747964, 
        (uint32_t const   )2575719748U,      (uint32_t const   )1619776915,      (uint32_t const   )1814040067,      (uint32_t const   )970743798, 
        (uint32_t const   )1561002147,      (uint32_t const   )2925768690U,      (uint32_t const   )2123093554,      (uint32_t const   )1880132620, 
        (uint32_t const   )3151188041U,      (uint32_t const   )697884420,      (uint32_t const   )2550985770U,      (uint32_t const   )2607674513U, 
        (uint32_t const   )2659114323U,      (uint32_t const   )110200136,      (uint32_t const   )1489731079,      (uint32_t const   )997519150, 
        (uint32_t const   )1378877361,      (uint32_t const   )3527870668U,      (uint32_t const   )478029773,      (uint32_t const   )2766872923U, 
        (uint32_t const   )1022481122,      (uint32_t const   )431258168,      (uint32_t const   )1112503832,      (uint32_t const   )897933369, 
        (uint32_t const   )2635587303U,      (uint32_t const   )669726182,      (uint32_t const   )3383752315U,      (uint32_t const   )918222264, 
        (uint32_t const   )163866573,      (uint32_t const   )3246985393U,      (uint32_t const   )3776823163U,      (uint32_t const   )114105080, 
        (uint32_t const   )1903216136,      (uint32_t const   )761148244,      (uint32_t const   )3571337562U,      (uint32_t const   )1690750982, 
        (uint32_t const   )3166750252U,      (uint32_t const   )1037045171,      (uint32_t const   )1888456500,      (uint32_t const   )2010454850, 
        (uint32_t const   )642736655,      (uint32_t const   )616092351,      (uint32_t const   )365016990,      (uint32_t const   )1185228132, 
        (uint32_t const   )4174898510U,      (uint32_t const   )1043824992,      (uint32_t const   )2023083429,      (uint32_t const   )2241598885U, 
        (uint32_t const   )3863320456U,      (uint32_t const   )3279669087U,      (uint32_t const   )3674716684U,      (uint32_t const   )108438443, 
        (uint32_t const   )2132974366,      (uint32_t const   )830746235,      (uint32_t const   )606445527,      (uint32_t const   )4173263986U, 
        (uint32_t const   )2204105912U,      (uint32_t const   )1844756978,      (uint32_t const   )2532684181U,      (uint32_t const   )4245352700U, 
        (uint32_t const   )2969441100U,      (uint32_t const   )3796921661U,      (uint32_t const   )1335562986,      (uint32_t const   )4061524517U, 
        (uint32_t const   )2720232303U,      (uint32_t const   )2679424040U,      (uint32_t const   )634407289,      (uint32_t const   )885462008, 
        (uint32_t const   )3294724487U,      (uint32_t const   )3933892248U,      (uint32_t const   )2094100220,      (uint32_t const   )339117932, 
        (uint32_t const   )4048830727U,      (uint32_t const   )3202280980U,      (uint32_t const   )1458155303,      (uint32_t const   )2689246273U, 
        (uint32_t const   )1022871705,      (uint32_t const   )2464987878U,      (uint32_t const   )3714515309U,      (uint32_t const   )353796843, 
        (uint32_t const   )2822958815U,      (uint32_t const   )4256850100U,      (uint32_t const   )4052777845U,      (uint32_t const   )551748367, 
        (uint32_t const   )618185374,      (uint32_t const   )3778635579U,      (uint32_t const   )4020649912U,      (uint32_t const   )1904685140, 
        (uint32_t const   )3069366075U,      (uint32_t const   )2670879810U,      (uint32_t const   )3407193292U,      (uint32_t const   )2954511620U, 
        (uint32_t const   )4058283405U,      (uint32_t const   )2219449317U,      (uint32_t const   )3135758300U,      (uint32_t const   )1120655984, 
        (uint32_t const   )3447565834U,      (uint32_t const   )1474845562,      (uint32_t const   )3577699062U,      (uint32_t const   )550456716, 
        (uint32_t const   )3466908712U,      (uint32_t const   )2043752612,      (uint32_t const   )881257467,      (uint32_t const   )869518812, 
        (uint32_t const   )2005220179,      (uint32_t const   )938474677,      (uint32_t const   )3305539448U,      (uint32_t const   )3850417126U, 
        (uint32_t const   )1315485940,      (uint32_t const   )3318264702U,      (uint32_t const   )226533026,      (uint32_t const   )965733244, 
        (uint32_t const   )321539988,      (uint32_t const   )1136104718,      (uint32_t const   )804158748,      (uint32_t const   )573969341, 
        (uint32_t const   )3708209826U,      (uint32_t const   )937399083,      (uint32_t const   )3290727049U,      (uint32_t const   )2901666755U, 
        (uint32_t const   )1461057207,      (uint32_t const   )4013193437U,      (uint32_t const   )4066861423U,      (uint32_t const   )3242773476U, 
        (uint32_t const   )2421326174U,      (uint32_t const   )1581322155,      (uint32_t const   )3028952165U,      (uint32_t const   )786071460, 
        (uint32_t const   )3900391652U,      (uint32_t const   )3918438532U,      (uint32_t const   )1485433313,      (uint32_t const   )4023619836U, 
        (uint32_t const   )3708277595U,      (uint32_t const   )3678951060U,      (uint32_t const   )953673138,      (uint32_t const   )1467089153, 
        (uint32_t const   )1930354364,      (uint32_t const   )1533292819,      (uint32_t const   )2492563023U,      (uint32_t const   )1346121658, 
        (uint32_t const   )1685000834,      (uint32_t const   )1965281866,      (uint32_t const   )3765933717U,      (uint32_t const   )4190206607U, 
        (uint32_t const   )2052792609,      (uint32_t const   )3515332758U,      (uint32_t const   )690371149,      (uint32_t const   )3125873887U, 
        (uint32_t const   )2180283551U,      (uint32_t const   )2903598061U,      (uint32_t const   )3933952357U,      (uint32_t const   )436236910, 
        (uint32_t const   )289419410,      (uint32_t const   )14314871,      (uint32_t const   )1242357089,      (uint32_t const   )2904507907U, 
        (uint32_t const   )1616633776,      (uint32_t const   )2666382180U,      (uint32_t const   )585885352,      (uint32_t const   )3471299210U, 
        (uint32_t const   )2699507360U,      (uint32_t const   )1432659641,      (uint32_t const   )277164553,      (uint32_t const   )3354103607U, 
        (uint32_t const   )770115018,      (uint32_t const   )2303809295U,      (uint32_t const   )3741942315U,      (uint32_t const   )3177781868U, 
        (uint32_t const   )2853364978U,      (uint32_t const   )2269453327U,      (uint32_t const   )3774259834U,      (uint32_t const   )987383833, 
        (uint32_t const   )1290892879,      (uint32_t const   )225909803,      (uint32_t const   )1741533526,      (uint32_t const   )890078084, 
        (uint32_t const   )1496906255,      (uint32_t const   )1111072499,      (uint32_t const   )916028167,      (uint32_t const   )243534141, 
        (uint32_t const   )1252605537,      (uint32_t const   )2204162171U,      (uint32_t const   )531204876,      (uint32_t const   )290011180, 
        (uint32_t const   )3916834213U,      (uint32_t const   )102027703,      (uint32_t const   )237315147,      (uint32_t const   )209093447, 
        (uint32_t const   )1486785922,      (uint32_t const   )220223953,      (uint32_t const   )2758195998U,      (uint32_t const   )4175039106U, 
        (uint32_t const   )82940208,      (uint32_t const   )3127791296U,      (uint32_t const   )2569425252U,      (uint32_t const   )518464269, 
        (uint32_t const   )1353887104,      (uint32_t const   )3941492737U,      (uint32_t const   )2377294467U,      (uint32_t const   )3935040926U};
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128.c"
void nettle_cast128_encrypt(struct cast128_ctx *ctx , unsigned int length , uint8_t *dst ,
                            uint8_t const   *src ) 
{ 
  uint32_t t ;
  uint32_t l ;
  uint32_t r ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 78
  if (! (! (length % 8U))) {
    {
    {
#line 78
    __assert_fail("!((length) % (8))", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128.c",
                  78U, "nettle_cast128_encrypt");
    }
    }
  }
  {
  {
#line 78
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 78
    if (! length) {
#line 78
      goto while_break;
    }
#line 83
    l = ((((uint32_t )*(src + 0) << 24) | ((uint32_t )*(src + 1) << 16)) | ((uint32_t )*(src + 2) << 8)) | (uint32_t )*(src + 3);
#line 84
    r = ((((uint32_t )*((src + 4) + 0) << 24) | ((uint32_t )*((src + 4) + 1) << 16)) | ((uint32_t )*((src + 4) + 2) << 8)) | (uint32_t )*((src + 4) + 3);
#line 87
    t = ((ctx->keys[0] + r) << ctx->keys[16]) | ((ctx->keys[0] + r) >> (32U - ctx->keys[16]));
#line 87
    l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] ^ cast_sbox2[(uint8_t )((t >> 16) & 255U)]) - cast_sbox3[(uint8_t )((t >> 8) & 255U)]) + cast_sbox4[(uint8_t )(t & 255U)]);
#line 88
    t = ((ctx->keys[1] ^ l) << ctx->keys[17]) | ((ctx->keys[1] ^ l) >> (32U - ctx->keys[17]));
#line 88
    r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] - cast_sbox2[(uint8_t )((t >> 16) & 255U)]) + cast_sbox3[(uint8_t )((t >> 8) & 255U)]) ^ cast_sbox4[(uint8_t )(t & 255U)]);
#line 89
    t = ((ctx->keys[2] - r) << ctx->keys[18]) | ((ctx->keys[2] - r) >> (32U - ctx->keys[18]));
#line 89
    l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] + cast_sbox2[(uint8_t )((t >> 16) & 255U)]) ^ cast_sbox3[(uint8_t )((t >> 8) & 255U)]) - cast_sbox4[(uint8_t )(t & 255U)]);
#line 90
    t = ((ctx->keys[3] + l) << ctx->keys[19]) | ((ctx->keys[3] + l) >> (32U - ctx->keys[19]));
#line 90
    r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] ^ cast_sbox2[(uint8_t )((t >> 16) & 255U)]) - cast_sbox3[(uint8_t )((t >> 8) & 255U)]) + cast_sbox4[(uint8_t )(t & 255U)]);
#line 91
    t = ((ctx->keys[4] ^ r) << ctx->keys[20]) | ((ctx->keys[4] ^ r) >> (32U - ctx->keys[20]));
#line 91
    l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] - cast_sbox2[(uint8_t )((t >> 16) & 255U)]) + cast_sbox3[(uint8_t )((t >> 8) & 255U)]) ^ cast_sbox4[(uint8_t )(t & 255U)]);
#line 92
    t = ((ctx->keys[5] - l) << ctx->keys[21]) | ((ctx->keys[5] - l) >> (32U - ctx->keys[21]));
#line 92
    r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] + cast_sbox2[(uint8_t )((t >> 16) & 255U)]) ^ cast_sbox3[(uint8_t )((t >> 8) & 255U)]) - cast_sbox4[(uint8_t )(t & 255U)]);
#line 93
    t = ((ctx->keys[6] + r) << ctx->keys[22]) | ((ctx->keys[6] + r) >> (32U - ctx->keys[22]));
#line 93
    l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] ^ cast_sbox2[(uint8_t )((t >> 16) & 255U)]) - cast_sbox3[(uint8_t )((t >> 8) & 255U)]) + cast_sbox4[(uint8_t )(t & 255U)]);
#line 94
    t = ((ctx->keys[7] ^ l) << ctx->keys[23]) | ((ctx->keys[7] ^ l) >> (32U - ctx->keys[23]));
#line 94
    r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] - cast_sbox2[(uint8_t )((t >> 16) & 255U)]) + cast_sbox3[(uint8_t )((t >> 8) & 255U)]) ^ cast_sbox4[(uint8_t )(t & 255U)]);
#line 95
    t = ((ctx->keys[8] - r) << ctx->keys[24]) | ((ctx->keys[8] - r) >> (32U - ctx->keys[24]));
#line 95
    l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] + cast_sbox2[(uint8_t )((t >> 16) & 255U)]) ^ cast_sbox3[(uint8_t )((t >> 8) & 255U)]) - cast_sbox4[(uint8_t )(t & 255U)]);
#line 96
    t = ((ctx->keys[9] + l) << ctx->keys[25]) | ((ctx->keys[9] + l) >> (32U - ctx->keys[25]));
#line 96
    r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] ^ cast_sbox2[(uint8_t )((t >> 16) & 255U)]) - cast_sbox3[(uint8_t )((t >> 8) & 255U)]) + cast_sbox4[(uint8_t )(t & 255U)]);
#line 97
    t = ((ctx->keys[10] ^ r) << ctx->keys[26]) | ((ctx->keys[10] ^ r) >> (32U - ctx->keys[26]));
#line 97
    l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] - cast_sbox2[(uint8_t )((t >> 16) & 255U)]) + cast_sbox3[(uint8_t )((t >> 8) & 255U)]) ^ cast_sbox4[(uint8_t )(t & 255U)]);
#line 98
    t = ((ctx->keys[11] - l) << ctx->keys[27]) | ((ctx->keys[11] - l) >> (32U - ctx->keys[27]));
#line 98
    r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] + cast_sbox2[(uint8_t )((t >> 16) & 255U)]) ^ cast_sbox3[(uint8_t )((t >> 8) & 255U)]) - cast_sbox4[(uint8_t )(t & 255U)]);
#line 100
    if (ctx->rounds > 12U) {
#line 101
      t = ((ctx->keys[12] + r) << ctx->keys[28]) | ((ctx->keys[12] + r) >> (32U - ctx->keys[28]));
#line 101
      l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] ^ cast_sbox2[(uint8_t )((t >> 16) & 255U)]) - cast_sbox3[(uint8_t )((t >> 8) & 255U)]) + cast_sbox4[(uint8_t )(t & 255U)]);
#line 102
      t = ((ctx->keys[13] ^ l) << ctx->keys[29]) | ((ctx->keys[13] ^ l) >> (32U - ctx->keys[29]));
#line 102
      r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] - cast_sbox2[(uint8_t )((t >> 16) & 255U)]) + cast_sbox3[(uint8_t )((t >> 8) & 255U)]) ^ cast_sbox4[(uint8_t )(t & 255U)]);
#line 103
      t = ((ctx->keys[14] - r) << ctx->keys[30]) | ((ctx->keys[14] - r) >> (32U - ctx->keys[30]));
#line 103
      l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] + cast_sbox2[(uint8_t )((t >> 16) & 255U)]) ^ cast_sbox3[(uint8_t )((t >> 8) & 255U)]) - cast_sbox4[(uint8_t )(t & 255U)]);
#line 104
      t = ((ctx->keys[15] + l) << ctx->keys[31]) | ((ctx->keys[15] + l) >> (32U - ctx->keys[31]));
#line 104
      r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] ^ cast_sbox2[(uint8_t )((t >> 16) & 255U)]) - cast_sbox3[(uint8_t )((t >> 8) & 255U)]) + cast_sbox4[(uint8_t )(t & 255U)]);
    }
    {
    {
#line 107
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 107
      *(dst + 0) = (uint8_t )((r >> 24) & 255U);
#line 107
      *(dst + 1) = (uint8_t )((r >> 16) & 255U);
#line 107
      *(dst + 2) = (uint8_t )((r >> 8) & 255U);
#line 107
      *(dst + 3) = (uint8_t )(r & 255U);
#line 107
      goto while_break___0;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
    {
    {
#line 108
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 108
      *((dst + 4) + 0) = (uint8_t )((l >> 24) & 255U);
#line 108
      *((dst + 4) + 1) = (uint8_t )((l >> 16) & 255U);
#line 108
      *((dst + 4) + 2) = (uint8_t )((l >> 8) & 255U);
#line 108
      *((dst + 4) + 3) = (uint8_t )(l & 255U);
#line 108
      goto while_break___1;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 110
    r = (uint32_t )0;
#line 110
    l = r;
#line 110
    t = l;
#line 78
    length -= 8U;
#line 78
    dst += 8;
#line 78
    src += 8;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 112
  return;
}
}
#line 117 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128.c"
void nettle_cast128_decrypt(struct cast128_ctx *ctx , unsigned int length , uint8_t *dst ,
                            uint8_t const   *src ) 
{ 
  uint32_t t ;
  uint32_t l ;
  uint32_t r ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 122
  if (! (! (length % 8U))) {
    {
    {
#line 122
    __assert_fail("!((length) % (8))", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128.c",
                  122U, "nettle_cast128_decrypt");
    }
    }
  }
  {
  {
#line 122
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 122
    if (! length) {
#line 122
      goto while_break;
    }
#line 127
    r = ((((uint32_t )*(src + 0) << 24) | ((uint32_t )*(src + 1) << 16)) | ((uint32_t )*(src + 2) << 8)) | (uint32_t )*(src + 3);
#line 128
    l = ((((uint32_t )*((src + 4) + 0) << 24) | ((uint32_t )*((src + 4) + 1) << 16)) | ((uint32_t )*((src + 4) + 2) << 8)) | (uint32_t )*((src + 4) + 3);
#line 132
    if (ctx->rounds > 12U) {
#line 133
      t = ((ctx->keys[15] + l) << ctx->keys[31]) | ((ctx->keys[15] + l) >> (32U - ctx->keys[31]));
#line 133
      r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] ^ cast_sbox2[(uint8_t )((t >> 16) & 255U)]) - cast_sbox3[(uint8_t )((t >> 8) & 255U)]) + cast_sbox4[(uint8_t )(t & 255U)]);
#line 134
      t = ((ctx->keys[14] - r) << ctx->keys[30]) | ((ctx->keys[14] - r) >> (32U - ctx->keys[30]));
#line 134
      l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] + cast_sbox2[(uint8_t )((t >> 16) & 255U)]) ^ cast_sbox3[(uint8_t )((t >> 8) & 255U)]) - cast_sbox4[(uint8_t )(t & 255U)]);
#line 135
      t = ((ctx->keys[13] ^ l) << ctx->keys[29]) | ((ctx->keys[13] ^ l) >> (32U - ctx->keys[29]));
#line 135
      r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] - cast_sbox2[(uint8_t )((t >> 16) & 255U)]) + cast_sbox3[(uint8_t )((t >> 8) & 255U)]) ^ cast_sbox4[(uint8_t )(t & 255U)]);
#line 136
      t = ((ctx->keys[12] + r) << ctx->keys[28]) | ((ctx->keys[12] + r) >> (32U - ctx->keys[28]));
#line 136
      l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] ^ cast_sbox2[(uint8_t )((t >> 16) & 255U)]) - cast_sbox3[(uint8_t )((t >> 8) & 255U)]) + cast_sbox4[(uint8_t )(t & 255U)]);
    }
#line 138
    t = ((ctx->keys[11] - l) << ctx->keys[27]) | ((ctx->keys[11] - l) >> (32U - ctx->keys[27]));
#line 138
    r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] + cast_sbox2[(uint8_t )((t >> 16) & 255U)]) ^ cast_sbox3[(uint8_t )((t >> 8) & 255U)]) - cast_sbox4[(uint8_t )(t & 255U)]);
#line 139
    t = ((ctx->keys[10] ^ r) << ctx->keys[26]) | ((ctx->keys[10] ^ r) >> (32U - ctx->keys[26]));
#line 139
    l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] - cast_sbox2[(uint8_t )((t >> 16) & 255U)]) + cast_sbox3[(uint8_t )((t >> 8) & 255U)]) ^ cast_sbox4[(uint8_t )(t & 255U)]);
#line 140
    t = ((ctx->keys[9] + l) << ctx->keys[25]) | ((ctx->keys[9] + l) >> (32U - ctx->keys[25]));
#line 140
    r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] ^ cast_sbox2[(uint8_t )((t >> 16) & 255U)]) - cast_sbox3[(uint8_t )((t >> 8) & 255U)]) + cast_sbox4[(uint8_t )(t & 255U)]);
#line 141
    t = ((ctx->keys[8] - r) << ctx->keys[24]) | ((ctx->keys[8] - r) >> (32U - ctx->keys[24]));
#line 141
    l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] + cast_sbox2[(uint8_t )((t >> 16) & 255U)]) ^ cast_sbox3[(uint8_t )((t >> 8) & 255U)]) - cast_sbox4[(uint8_t )(t & 255U)]);
#line 142
    t = ((ctx->keys[7] ^ l) << ctx->keys[23]) | ((ctx->keys[7] ^ l) >> (32U - ctx->keys[23]));
#line 142
    r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] - cast_sbox2[(uint8_t )((t >> 16) & 255U)]) + cast_sbox3[(uint8_t )((t >> 8) & 255U)]) ^ cast_sbox4[(uint8_t )(t & 255U)]);
#line 143
    t = ((ctx->keys[6] + r) << ctx->keys[22]) | ((ctx->keys[6] + r) >> (32U - ctx->keys[22]));
#line 143
    l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] ^ cast_sbox2[(uint8_t )((t >> 16) & 255U)]) - cast_sbox3[(uint8_t )((t >> 8) & 255U)]) + cast_sbox4[(uint8_t )(t & 255U)]);
#line 144
    t = ((ctx->keys[5] - l) << ctx->keys[21]) | ((ctx->keys[5] - l) >> (32U - ctx->keys[21]));
#line 144
    r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] + cast_sbox2[(uint8_t )((t >> 16) & 255U)]) ^ cast_sbox3[(uint8_t )((t >> 8) & 255U)]) - cast_sbox4[(uint8_t )(t & 255U)]);
#line 145
    t = ((ctx->keys[4] ^ r) << ctx->keys[20]) | ((ctx->keys[4] ^ r) >> (32U - ctx->keys[20]));
#line 145
    l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] - cast_sbox2[(uint8_t )((t >> 16) & 255U)]) + cast_sbox3[(uint8_t )((t >> 8) & 255U)]) ^ cast_sbox4[(uint8_t )(t & 255U)]);
#line 146
    t = ((ctx->keys[3] + l) << ctx->keys[19]) | ((ctx->keys[3] + l) >> (32U - ctx->keys[19]));
#line 146
    r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] ^ cast_sbox2[(uint8_t )((t >> 16) & 255U)]) - cast_sbox3[(uint8_t )((t >> 8) & 255U)]) + cast_sbox4[(uint8_t )(t & 255U)]);
#line 147
    t = ((ctx->keys[2] - r) << ctx->keys[18]) | ((ctx->keys[2] - r) >> (32U - ctx->keys[18]));
#line 147
    l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] + cast_sbox2[(uint8_t )((t >> 16) & 255U)]) ^ cast_sbox3[(uint8_t )((t >> 8) & 255U)]) - cast_sbox4[(uint8_t )(t & 255U)]);
#line 148
    t = ((ctx->keys[1] ^ l) << ctx->keys[17]) | ((ctx->keys[1] ^ l) >> (32U - ctx->keys[17]));
#line 148
    r ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] - cast_sbox2[(uint8_t )((t >> 16) & 255U)]) + cast_sbox3[(uint8_t )((t >> 8) & 255U)]) ^ cast_sbox4[(uint8_t )(t & 255U)]);
#line 149
    t = ((ctx->keys[0] + r) << ctx->keys[16]) | ((ctx->keys[0] + r) >> (32U - ctx->keys[16]));
#line 149
    l ^= (unsigned int )(((cast_sbox1[(uint8_t )(t >> 24)] ^ cast_sbox2[(uint8_t )((t >> 16) & 255U)]) - cast_sbox3[(uint8_t )((t >> 8) & 255U)]) + cast_sbox4[(uint8_t )(t & 255U)]);
    {
    {
#line 152
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 152
      *(dst + 0) = (uint8_t )((l >> 24) & 255U);
#line 152
      *(dst + 1) = (uint8_t )((l >> 16) & 255U);
#line 152
      *(dst + 2) = (uint8_t )((l >> 8) & 255U);
#line 152
      *(dst + 3) = (uint8_t )(l & 255U);
#line 152
      goto while_break___0;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
    {
    {
#line 153
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 153
      *((dst + 4) + 0) = (uint8_t )((r >> 24) & 255U);
#line 153
      *((dst + 4) + 1) = (uint8_t )((r >> 16) & 255U);
#line 153
      *((dst + 4) + 2) = (uint8_t )((r >> 8) & 255U);
#line 153
      *((dst + 4) + 3) = (uint8_t )(r & 255U);
#line 153
      goto while_break___1;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 156
    r = (uint32_t )0;
#line 156
    l = r;
#line 156
    t = l;
#line 122
    length -= 8U;
#line 122
    dst += 8;
#line 122
    src += 8;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 158
  return;
}
}
#line 162 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128.c"
void nettle_cast128_set_key(struct cast128_ctx *ctx , unsigned int keybytes , uint8_t const   *rawkey ) 
{ 
  uint32_t t[4] ;
  uint32_t z[4] ;
  uint32_t x[4] ;
  unsigned int i ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;

  {
#line 170
  if (keybytes <= 10U) {
#line 170
    ctx->rounds = 12U;
  } else {
#line 170
    ctx->rounds = 16U;
  }
#line 174
  i = 0U;
  {
  {
#line 174
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 174
    if (! (i < 4U)) {
#line 174
      goto while_break;
    }
#line 175
    x[i] = (uint32_t )0;
#line 176
    if (i * 4U < keybytes) {
#line 176
      x[i] = (uint32_t )*(rawkey + i * 4U) << 24;
    }
#line 177
    if (i * 4U + 1U < keybytes) {
#line 177
      x[i] |= (uint32_t )*(rawkey + (i * 4U + 1U)) << 16;
    }
#line 178
    if (i * 4U + 2U < keybytes) {
#line 178
      x[i] |= (uint32_t )*(rawkey + (i * 4U + 2U)) << 8;
    }
#line 179
    if (i * 4U + 3U < keybytes) {
#line 179
      x[i] |= (uint32_t )*(rawkey + (i * 4U + 3U));
    }
#line 174
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 182
  i = 0U;
  {
  {
#line 182
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 182
    if (! (i < 32U)) {
#line 182
      goto while_break___0;
    }
#line 184
    if ((i & 4U) == 0U) {
#line 184
      goto case_0;
    }
#line 198
    if ((i & 4U) == 4U) {
#line 198
      goto case_4;
    }
#line 183
    goto switch_break;
    case_0: 
#line 185
    z[0] = ((((x[0] ^ (unsigned int )cast_sbox5[(uint8_t )((x[3] >> 16) & 255U)]) ^ (unsigned int )cast_sbox6[(uint8_t )(x[3] & 255U)]) ^ (unsigned int )cast_sbox7[(uint8_t )(x[3] >> 24)]) ^ (unsigned int )cast_sbox8[(uint8_t )((x[3] >> 8) & 255U)]) ^ (unsigned int )cast_sbox7[(uint8_t )(x[2] >> 24)];
#line 185
    t[0] = z[0];
#line 188
    z[1] = ((((x[2] ^ (unsigned int )cast_sbox5[(uint8_t )(z[0] >> 24)]) ^ (unsigned int )cast_sbox6[(uint8_t )((z[0] >> 8) & 255U)]) ^ (unsigned int )cast_sbox7[(uint8_t )((z[0] >> 16) & 255U)]) ^ (unsigned int )cast_sbox8[(uint8_t )(z[0] & 255U)]) ^ (unsigned int )cast_sbox8[(uint8_t )((x[2] >> 8) & 255U)];
#line 188
    t[1] = z[1];
#line 191
    z[2] = ((((x[3] ^ (unsigned int )cast_sbox5[(uint8_t )(z[1] & 255U)]) ^ (unsigned int )cast_sbox6[(uint8_t )((z[1] >> 8) & 255U)]) ^ (unsigned int )cast_sbox7[(uint8_t )((z[1] >> 16) & 255U)]) ^ (unsigned int )cast_sbox8[(uint8_t )(z[1] >> 24)]) ^ (unsigned int )cast_sbox5[(uint8_t )((x[2] >> 16) & 255U)];
#line 191
    t[2] = z[2];
#line 194
    z[3] = ((((x[1] ^ (unsigned int )cast_sbox5[(uint8_t )((z[2] >> 8) & 255U)]) ^ (unsigned int )cast_sbox6[(uint8_t )((z[2] >> 16) & 255U)]) ^ (unsigned int )cast_sbox7[(uint8_t )(z[2] & 255U)]) ^ (unsigned int )cast_sbox8[(uint8_t )(z[2] >> 24)]) ^ (unsigned int )cast_sbox6[(uint8_t )(x[2] & 255U)];
#line 194
    t[3] = z[3];
#line 197
    goto switch_break;
    case_4: 
#line 199
    x[0] = ((((z[2] ^ (unsigned int )cast_sbox5[(uint8_t )((z[1] >> 16) & 255U)]) ^ (unsigned int )cast_sbox6[(uint8_t )(z[1] & 255U)]) ^ (unsigned int )cast_sbox7[(uint8_t )(z[1] >> 24)]) ^ (unsigned int )cast_sbox8[(uint8_t )((z[1] >> 8) & 255U)]) ^ (unsigned int )cast_sbox7[(uint8_t )(z[0] >> 24)];
#line 199
    t[0] = x[0];
#line 202
    x[1] = ((((z[0] ^ (unsigned int )cast_sbox5[(uint8_t )(x[0] >> 24)]) ^ (unsigned int )cast_sbox6[(uint8_t )((x[0] >> 8) & 255U)]) ^ (unsigned int )cast_sbox7[(uint8_t )((x[0] >> 16) & 255U)]) ^ (unsigned int )cast_sbox8[(uint8_t )(x[0] & 255U)]) ^ (unsigned int )cast_sbox8[(uint8_t )((z[0] >> 8) & 255U)];
#line 202
    t[1] = x[1];
#line 205
    x[2] = ((((z[1] ^ (unsigned int )cast_sbox5[(uint8_t )(x[1] & 255U)]) ^ (unsigned int )cast_sbox6[(uint8_t )((x[1] >> 8) & 255U)]) ^ (unsigned int )cast_sbox7[(uint8_t )((x[1] >> 16) & 255U)]) ^ (unsigned int )cast_sbox8[(uint8_t )(x[1] >> 24)]) ^ (unsigned int )cast_sbox5[(uint8_t )((z[0] >> 16) & 255U)];
#line 205
    t[2] = x[2];
#line 208
    x[3] = ((((z[3] ^ (unsigned int )cast_sbox5[(uint8_t )((x[2] >> 8) & 255U)]) ^ (unsigned int )cast_sbox6[(uint8_t )((x[2] >> 16) & 255U)]) ^ (unsigned int )cast_sbox7[(uint8_t )(x[2] & 255U)]) ^ (unsigned int )cast_sbox8[(uint8_t )(x[2] >> 24)]) ^ (unsigned int )cast_sbox6[(uint8_t )(z[0] & 255U)];
#line 208
    t[3] = x[3];
#line 211
    goto switch_break;
    switch_break: ;
#line 215
    if ((i & 12U) == 12U) {
#line 215
      goto case_12;
    }
#line 215
    if ((i & 12U) == 0U) {
#line 215
      goto case_12;
    }
#line 226
    if ((i & 12U) == 8U) {
#line 226
      goto case_8;
    }
#line 226
    if ((i & 12U) == 4U) {
#line 226
      goto case_8;
    }
#line 213
    goto switch_break___0;
    case_12: 
#line 216
    ctx->keys[i] = (uint32_t )(((cast_sbox5[(uint8_t )(t[2] >> 24)] ^ cast_sbox6[(uint8_t )((t[2] >> 16) & 255U)]) ^ cast_sbox7[(uint8_t )(t[1] & 255U)]) ^ cast_sbox8[(uint8_t )((t[1] >> 8) & 255U)]);
#line 218
    ctx->keys[i + 1U] = (uint32_t )(((cast_sbox5[(uint8_t )((t[2] >> 8) & 255U)] ^ cast_sbox6[(uint8_t )(t[2] & 255U)]) ^ cast_sbox7[(uint8_t )((t[1] >> 16) & 255U)]) ^ cast_sbox8[(uint8_t )(t[1] >> 24)]);
#line 220
    ctx->keys[i + 2U] = (uint32_t )(((cast_sbox5[(uint8_t )(t[3] >> 24)] ^ cast_sbox6[(uint8_t )((t[3] >> 16) & 255U)]) ^ cast_sbox7[(uint8_t )(t[0] & 255U)]) ^ cast_sbox8[(uint8_t )((t[0] >> 8) & 255U)]);
#line 222
    ctx->keys[i + 3U] = (uint32_t )(((cast_sbox5[(uint8_t )((t[3] >> 8) & 255U)] ^ cast_sbox6[(uint8_t )(t[3] & 255U)]) ^ cast_sbox7[(uint8_t )((t[0] >> 16) & 255U)]) ^ cast_sbox8[(uint8_t )(t[0] >> 24)]);
#line 224
    goto switch_break___0;
    case_8: 
#line 227
    ctx->keys[i] = (uint32_t )(((cast_sbox5[(uint8_t )(t[0] & 255U)] ^ cast_sbox6[(uint8_t )((t[0] >> 8) & 255U)]) ^ cast_sbox7[(uint8_t )(t[3] >> 24)]) ^ cast_sbox8[(uint8_t )((t[3] >> 16) & 255U)]);
#line 229
    ctx->keys[i + 1U] = (uint32_t )(((cast_sbox5[(uint8_t )((t[0] >> 16) & 255U)] ^ cast_sbox6[(uint8_t )(t[0] >> 24)]) ^ cast_sbox7[(uint8_t )((t[3] >> 8) & 255U)]) ^ cast_sbox8[(uint8_t )(t[3] & 255U)]);
#line 231
    ctx->keys[i + 2U] = (uint32_t )(((cast_sbox5[(uint8_t )(t[1] & 255U)] ^ cast_sbox6[(uint8_t )((t[1] >> 8) & 255U)]) ^ cast_sbox7[(uint8_t )(t[2] >> 24)]) ^ cast_sbox8[(uint8_t )((t[2] >> 16) & 255U)]);
#line 233
    ctx->keys[i + 3U] = (uint32_t )(((cast_sbox5[(uint8_t )((t[1] >> 16) & 255U)] ^ cast_sbox6[(uint8_t )(t[1] >> 24)]) ^ cast_sbox7[(uint8_t )((t[2] >> 8) & 255U)]) ^ cast_sbox8[(uint8_t )(t[2] & 255U)]);
#line 235
    goto switch_break___0;
    switch_break___0: ;
#line 238
    if ((i & 12U) == 0U) {
#line 238
      goto case_0___1;
    }
#line 244
    if ((i & 12U) == 4U) {
#line 244
      goto case_4___1;
    }
#line 250
    if ((i & 12U) == 8U) {
#line 250
      goto case_8___0;
    }
#line 256
    if ((i & 12U) == 12U) {
#line 256
      goto case_12___0;
    }
#line 237
    goto switch_break___1;
    case_0___1: 
#line 239
    ctx->keys[i] ^= (unsigned int )cast_sbox5[(uint8_t )((z[0] >> 8) & 255U)];
#line 240
    ctx->keys[i + 1U] ^= (unsigned int )cast_sbox6[(uint8_t )((z[1] >> 8) & 255U)];
#line 241
    ctx->keys[i + 2U] ^= (unsigned int )cast_sbox7[(uint8_t )((z[2] >> 16) & 255U)];
#line 242
    ctx->keys[i + 3U] ^= (unsigned int )cast_sbox8[(uint8_t )(z[3] >> 24)];
#line 243
    goto switch_break___1;
    case_4___1: 
#line 245
    ctx->keys[i] ^= (unsigned int )cast_sbox5[(uint8_t )(x[2] >> 24)];
#line 246
    ctx->keys[i + 1U] ^= (unsigned int )cast_sbox6[(uint8_t )((x[3] >> 16) & 255U)];
#line 247
    ctx->keys[i + 2U] ^= (unsigned int )cast_sbox7[(uint8_t )(x[0] & 255U)];
#line 248
    ctx->keys[i + 3U] ^= (unsigned int )cast_sbox8[(uint8_t )(x[1] & 255U)];
#line 249
    goto switch_break___1;
    case_8___0: 
#line 251
    ctx->keys[i] ^= (unsigned int )cast_sbox5[(uint8_t )((z[2] >> 16) & 255U)];
#line 252
    ctx->keys[i + 1U] ^= (unsigned int )cast_sbox6[(uint8_t )(z[3] >> 24)];
#line 253
    ctx->keys[i + 2U] ^= (unsigned int )cast_sbox7[(uint8_t )((z[0] >> 8) & 255U)];
#line 254
    ctx->keys[i + 3U] ^= (unsigned int )cast_sbox8[(uint8_t )((z[1] >> 8) & 255U)];
#line 255
    goto switch_break___1;
    case_12___0: 
#line 257
    ctx->keys[i] ^= (unsigned int )cast_sbox5[(uint8_t )(x[0] & 255U)];
#line 258
    ctx->keys[i + 1U] ^= (unsigned int )cast_sbox6[(uint8_t )(x[1] & 255U)];
#line 259
    ctx->keys[i + 2U] ^= (unsigned int )cast_sbox7[(uint8_t )(x[2] >> 24)];
#line 260
    ctx->keys[i + 3U] ^= (unsigned int )cast_sbox8[(uint8_t )((x[3] >> 16) & 255U)];
#line 261
    goto switch_break___1;
    switch_break___1: ;
#line 263
    if (i >= 16U) {
#line 264
      ctx->keys[i] &= 31U;
#line 265
      ctx->keys[i + 1U] &= 31U;
#line 266
      ctx->keys[i + 2U] &= 31U;
#line 267
      ctx->keys[i + 3U] &= 31U;
    }
#line 182
    i += 4U;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 271
  i = 0U;
  {
  {
#line 271
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;

#line 271
    if (! (i < 4U)) {
#line 271
      goto while_break___1;
    }
#line 272
    tmp___0 = (uint32_t )0;
#line 272
    z[i] = tmp___0;
#line 272
    tmp = tmp___0;
#line 272
    x[i] = tmp;
#line 272
    t[i] = tmp;
#line 271
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 274
  return;
}
}
#line 102 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_cipher  const  nettle_cast128 ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128-meta.c"
struct nettle_cipher  const  nettle_cast128  = 
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/cast128-meta.c"
     {"cast128", (unsigned int )sizeof(struct cast128_ctx ), 8U, 16U, (void (*)(void *ctx ,
                                                                              unsigned int length ,
                                                                              uint8_t const   *key ))(& nettle_cast128_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_cast128_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_cast128_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_cast128_decrypt)};
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.h"
void nettle_buffer_init_realloc(struct nettle_buffer *buffer , void *realloc_ctx ,
                                nettle_realloc_func *realloc___0 ) ;
#line 54
void nettle_buffer_init_size(struct nettle_buffer *buffer , unsigned int length ,
                             uint8_t *space ) ;
#line 58
void nettle_buffer_clear(struct nettle_buffer *buffer ) ;
#line 62
void nettle_buffer_reset(struct nettle_buffer *buffer ) ;
#line 86
int nettle_buffer_copy(struct nettle_buffer *dst , struct nettle_buffer  const  *src ) ;
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.c"
int nettle_buffer_grow(struct nettle_buffer *buffer , unsigned int length ) 
{ 
  unsigned int alloc ;
  uint8_t *p ;
  void *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 40
  if (! (buffer->size <= buffer->alloc)) {
    {
    {
#line 40
    __assert_fail("buffer->size <= buffer->alloc", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.c",
                  40U, "nettle_buffer_grow");
    }
    }
  }
#line 42
  if (buffer->size + length > buffer->alloc) {
#line 47
    if (! buffer->realloc) {
#line 48
      return (0);
    }
    {
#line 50
    alloc = (buffer->alloc * 2U + length) + 100U;
    {
#line 51
    tmp = (*(buffer->realloc))(buffer->realloc_ctx, (void *)buffer->contents, alloc);
    }
#line 51
    p = (uint8_t *)tmp;
    }
#line 52
    if (! p) {
#line 53
      return (0);
    }
#line 55
    buffer->contents = p;
#line 56
    buffer->alloc = alloc;
  }
#line 58
  return (1);
}
}
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.c"
void nettle_buffer_init_realloc(struct nettle_buffer *buffer , void *realloc_ctx ,
                                nettle_realloc_func *realloc___0 ) 
{ 


  {
#line 66
  buffer->contents = (uint8_t *)((void *)0);
#line 67
  buffer->alloc = 0U;
#line 68
  buffer->realloc = realloc___0;
#line 69
  buffer->realloc_ctx = realloc_ctx;
#line 70
  buffer->size = 0U;
#line 71
  return;
}
}
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.c"
void nettle_buffer_init_size(struct nettle_buffer *buffer , unsigned int length ,
                             uint8_t *space ) 
{ 


  {
#line 77
  buffer->contents = space;
#line 78
  buffer->alloc = length;
#line 79
  buffer->realloc = (nettle_realloc_func *)((void *)0);
#line 80
  buffer->realloc_ctx = (void *)0;
#line 81
  buffer->size = 0U;
#line 82
  return;
}
}
#line 84 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.c"
void nettle_buffer_clear(struct nettle_buffer *buffer ) 
{ 


  {
#line 87
  if (buffer->realloc) {
    {
    {
#line 88
    (*(buffer->realloc))(buffer->realloc_ctx, (void *)buffer->contents, 0U);
    }
    }
  }
#line 90
  buffer->contents = (uint8_t *)((void *)0);
#line 91
  buffer->alloc = 0U;
#line 92
  buffer->size = 0U;
#line 93
  return;
}
}
#line 95 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.c"
void nettle_buffer_reset(struct nettle_buffer *buffer ) 
{ 


  {
#line 98
  buffer->size = 0U;
#line 99
  return;
}
}
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.c"
uint8_t *nettle_buffer_space(struct nettle_buffer *buffer , unsigned int length ) 
{ 
  uint8_t *p ;
  int tmp ;

  {
  {
  {
#line 107
  tmp = nettle_buffer_grow(buffer, length);
  }
  }
#line 107
  if (! tmp) {
#line 108
    return ((uint8_t *)((void *)0));
  }
#line 110
  p = buffer->contents + buffer->size;
#line 111
  buffer->size += length;
#line 112
  return (p);
}
}
#line 115 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.c"
int nettle_buffer_write(struct nettle_buffer *buffer , unsigned int length , uint8_t const   *data ) 
{ 
  uint8_t *p ;
  uint8_t *tmp ;

  {
  {
  {
#line 119
  tmp = nettle_buffer_space(buffer, length);
  }
#line 119
  p = tmp;
  }
#line 120
  if (p) {
    {
    {
#line 122
    memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)data),
           length);
    }
    }
#line 123
    return (1);
  } else {
#line 126
    return (0);
  }
}
}
#line 129 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.c"
int nettle_buffer_copy(struct nettle_buffer *dst , struct nettle_buffer  const  *src ) 
{ 
  int tmp ;

  {
  {
  {
#line 133
  tmp = nettle_buffer_write(dst, (unsigned int )src->size, (uint8_t const   *)src->contents);
  }
  }
#line 133
  return (tmp);
}
}
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer.h"
void nettle_buffer_init(struct nettle_buffer *buffer ) ;
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/buffer-init.c"
void nettle_buffer_init(struct nettle_buffer *buffer ) 
{ 


  {
  {
  {
#line 40
  nettle_buffer_init_realloc(buffer, (void *)0, & nettle_realloc);
  }
  }
#line 41
  return;
}
}
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/blowfish.c"
static struct blowfish_ctx  const  initial_ctx  =    {{{3509652390U, 2564797868U, (uint32_t )805139163, 3491422135U, 3101798381U, (uint32_t )1780907670,
      3128725573U, 4046225305U, (uint32_t )614570311, 3012652279U, (uint32_t )134345442,
      2240740374U, (uint32_t )1667834072, (uint32_t )1901547113, 2757295779U, 4103290238U,
      (uint32_t )227898511, (uint32_t )1921955416, (uint32_t )1904987480, 2182433518U,
      (uint32_t )2069144605, 3260701109U, 2620446009U, (uint32_t )720527379, 3318853667U,
      (uint32_t )677414384, 3393288472U, 3101374703U, 2390351024U, (uint32_t )1614419982,
      (uint32_t )1822297739, 2954791486U, 3608508353U, 3174124327U, (uint32_t )2024746970,
      (uint32_t )1432378464, 3864339955U, 2857741204U, (uint32_t )1464375394, (uint32_t )1676153920,
      (uint32_t )1439316330, (uint32_t )715854006, 3033291828U, (uint32_t )289532110,
      2706671279U, (uint32_t )2087905683, 3018724369U, (uint32_t )1668267050, (uint32_t )732546397,
      (uint32_t )1947742710, 3462151702U, 2609353502U, 2950085171U, (uint32_t )1814351708,
      (uint32_t )2050118529, (uint32_t )680887927, (uint32_t )999245976, (uint32_t )1800124847,
      3300911131U, (uint32_t )1713906067, (uint32_t )1641548236, 4213287313U, (uint32_t )1216130144,
      (uint32_t )1575780402, 4018429277U, 3917837745U, 3693486850U, 3949271944U, (uint32_t )596196993,
      3549867205U, (uint32_t )258830323, 2213823033U, (uint32_t )772490370, 2760122372U,
      (uint32_t )1774776394, 2652871518U, (uint32_t )566650946, 4142492826U, (uint32_t )1728879713,
      2882767088U, (uint32_t )1783734482, 3629395816U, 2517608232U, 2874225571U, (uint32_t )1861159788,
      (uint32_t )326777828, 3124490320U, (uint32_t )2130389656, 2716951837U, (uint32_t )967770486,
      (uint32_t )1724537150, 2185432712U, 2364442137U, (uint32_t )1164943284, (uint32_t )2105845187,
      (uint32_t )998989502, 3765401048U, 2244026483U, (uint32_t )1075463327, (uint32_t )1455516326,
      (uint32_t )1322494562, (uint32_t )910128902, (uint32_t )469688178, (uint32_t )1117454909,
      (uint32_t )936433444, 3490320968U, 3675253459U, (uint32_t )1240580251, (uint32_t )122909385,
      2157517691U, (uint32_t )634681816, 4142456567U, 3825094682U, 3061402683U, 2540495037U,
      (uint32_t )79693498, 3249098678U, (uint32_t )1084186820, (uint32_t )1583128258,
      (uint32_t )426386531, (uint32_t )1761308591, (uint32_t )1047286709, (uint32_t )322548459,
      (uint32_t )995290223, (uint32_t )1845252383, 2603652396U, 3431023940U, 2942221577U,
      3202600964U, 3727903485U, (uint32_t )1712269319, (uint32_t )422464435, 3234572375U,
      (uint32_t )1170764815, 3523960633U, 3117677531U, (uint32_t )1434042557, (uint32_t )442511882,
      3600875718U, (uint32_t )1076654713, (uint32_t )1738483198, 4213154764U, 2393238008U,
      3677496056U, (uint32_t )1014306527, 4251020053U, (uint32_t )793779912, 2902807211U,
      (uint32_t )842905082, 4246964064U, (uint32_t )1395751752, (uint32_t )1040244610,
      2656851899U, 3396308128U, (uint32_t )445077038, 3742853595U, 3577915638U, (uint32_t )679411651,
      2892444358U, 2354009459U, (uint32_t )1767581616, 3150600392U, 3791627101U, 3102740896U,
      (uint32_t )284835224, 4246832056U, (uint32_t )1258075500, (uint32_t )768725851,
      2589189241U, 3069724005U, 3532540348U, (uint32_t )1274779536, 3789419226U, 2764799539U,
      (uint32_t )1660621633, 3471099624U, 4011903706U, (uint32_t )913787905, 3497959166U,
      (uint32_t )737222580, 2514213453U, 2928710040U, 3937242737U, (uint32_t )1804850592,
      3499020752U, 2949064160U, 2386320175U, 2390070455U, 2415321851U, 4061277028U,
      2290661394U, 2416832540U, (uint32_t )1336762016, (uint32_t )1754252060, 3520065937U,
      3014181293U, (uint32_t )791618072, 3188594551U, 3933548030U, 2332172193U, 3852520463U,
      3043980520U, (uint32_t )413987798, 3465142937U, 3030929376U, 4245938359U, (uint32_t )2093235073,
      3534596313U, (uint32_t )375366246, 2157278981U, 2479649556U, (uint32_t )555357303,
      3870105701U, (uint32_t )2008414854, 3344188149U, 4221384143U, 3956125452U, (uint32_t )2067696032,
      3594591187U, 2921233993U, (uint32_t )2428461, (uint32_t )544322398, (uint32_t )577241275,
      (uint32_t )1471733935, (uint32_t )610547355, 4027169054U, (uint32_t )1432588573,
      (uint32_t )1507829418, (uint32_t )2025931657, 3646575487U, (uint32_t )545086370,
      (uint32_t )48609733, 2200306550U, (uint32_t )1653985193, (uint32_t )298326376,
      (uint32_t )1316178497, 3007786442U, (uint32_t )2064951626, (uint32_t )458293330,
      2589141269U, 3591329599U, 3164325604U, (uint32_t )727753846, 2179363840U, (uint32_t )146436021,
      (uint32_t )1461446943, 4069977195U, (uint32_t )705550613, 3059967265U, 3887724982U,
      4281599278U, 3313849956U, (uint32_t )1404054877, 2845806497U, (uint32_t )146425753,
      (uint32_t )1854211946}, {(uint32_t )1266315497, 3048417604U, 3681880366U, 3289982499U,
                               2909710000U, (uint32_t )1235738493, 2632868024U, 2414719590U,
                               3970600049U, (uint32_t )1771706367, (uint32_t )1449415276,
                               3266420449U, (uint32_t )422970021, (uint32_t )1963543593,
                               2690192192U, 3826793022U, (uint32_t )1062508698, (uint32_t )1531092325,
                               (uint32_t )1804592342, 2583117782U, 2714934279U, 4024971509U,
                               (uint32_t )1294809318, 4028980673U, (uint32_t )1289560198,
                               2221992742U, (uint32_t )1669523910, (uint32_t )35572830,
                               (uint32_t )157838143, (uint32_t )1052438473, (uint32_t )1016535060,
                               (uint32_t )1802137761, (uint32_t )1753167236, (uint32_t )1386275462,
                               3080475397U, 2857371447U, (uint32_t )1040679964, (uint32_t )2145300060,
                               2390574316U, (uint32_t )1461121720, 2956646967U, 4031777805U,
                               4028374788U, (uint32_t )33600511, 2920084762U, (uint32_t )1018524850,
                               (uint32_t )629373528, 3691585981U, 3515945977U, (uint32_t )2091462646,
                               2486323059U, (uint32_t )586499841, (uint32_t )988145025,
                               (uint32_t )935516892, 3367335476U, 2599673255U, 2839830854U,
                               (uint32_t )265290510, 3972581182U, 2759138881U, 3795373465U,
                               (uint32_t )1005194799, (uint32_t )847297441, (uint32_t )406762289,
                               (uint32_t )1314163512, (uint32_t )1332590856, (uint32_t )1866599683,
                               4127851711U, (uint32_t )750260880, (uint32_t )613907577,
                               (uint32_t )1450815602, 3165620655U, 3734664991U, 3650291728U,
                               3012275730U, 3704569646U, (uint32_t )1427272223, (uint32_t )778793252,
                               (uint32_t )1343938022, 2676280711U, (uint32_t )2052605720,
                               (uint32_t )1946737175, 3164576444U, 3914038668U, 3967478842U,
                               3682934266U, (uint32_t )1661551462, 3294938066U, 4011595847U,
                               (uint32_t )840292616, 3712170807U, (uint32_t )616741398,
                               (uint32_t )312560963, (uint32_t )711312465, (uint32_t )1351876610,
                               (uint32_t )322626781, (uint32_t )1910503582, (uint32_t )271666773,
                               2175563734U, (uint32_t )1594956187, (uint32_t )70604529,
                               3617834859U, (uint32_t )1007753275, (uint32_t )1495573769,
                               4069517037U, 2549218298U, 2663038764U, (uint32_t )504708206,
                               2263041392U, 3941167025U, 2249088522U, (uint32_t )1514023603,
                               (uint32_t )1998579484, (uint32_t )1312622330, (uint32_t )694541497,
                               2582060303U, 2151582166U, (uint32_t )1382467621, (uint32_t )776784248,
                               2618340202U, 3323268794U, 2497899128U, 2784771155U,
                               (uint32_t )503983604, 4076293799U, (uint32_t )907881277,
                               (uint32_t )423175695, (uint32_t )432175456, (uint32_t )1378068232,
                               4145222326U, 3954048622U, 3938656102U, 3820766613U,
                               2793130115U, 2977904593U, (uint32_t )26017576, 3274890735U,
                               3194772133U, (uint32_t )1700274565, (uint32_t )1756076034,
                               4006520079U, 3677328699U, (uint32_t )720338349, (uint32_t )1533947780,
                               (uint32_t )354530856, (uint32_t )688349552, 3973924725U,
                               (uint32_t )1637815568, (uint32_t )332179504, 3949051286U,
                               (uint32_t )53804574, 2852348879U, 3044236432U, (uint32_t )1282449977,
                               3583942155U, 3416972820U, 4006381244U, (uint32_t )1617046695,
                               2628476075U, 3002303598U, (uint32_t )1686838959, (uint32_t )431878346,
                               2686675385U, (uint32_t )1700445008, (uint32_t )1080580658,
                               (uint32_t )1009431731, (uint32_t )832498133, 3223435511U,
                               2605976345U, 2271191193U, 2516031870U, (uint32_t )1648197032,
                               4164389018U, 2548247927U, (uint32_t )300782431, (uint32_t )375919233,
                               (uint32_t )238389289, 3353747414U, 2531188641U, (uint32_t )2019080857,
                               (uint32_t )1475708069, (uint32_t )455242339, 2609103871U,
                               (uint32_t )448939670, 3451063019U, (uint32_t )1395535956,
                               2413381860U, (uint32_t )1841049896, (uint32_t )1491858159,
                               (uint32_t )885456874, 4264095073U, 4001119347U, (uint32_t )1565136089,
                               3898914787U, (uint32_t )1108368660, (uint32_t )540939232,
                               (uint32_t )1173283510, 2745871338U, 3681308437U, 4207628240U,
                               3343053890U, 4016749493U, (uint32_t )1699691293, (uint32_t )1103962373,
                               3625875870U, 2256883143U, 3830138730U, (uint32_t )1031889488,
                               3479347698U, (uint32_t )1535977030, 4236805024U, 3251091107U,
                               (uint32_t )2132092099, (uint32_t )1774941330, (uint32_t )1199868427,
                               (uint32_t )1452454533, (uint32_t )157007616, 2904115357U,
                               (uint32_t )342012276, (uint32_t )595725824, (uint32_t )1480756522,
                               (uint32_t )206960106, (uint32_t )497939518, (uint32_t )591360097,
                               (uint32_t )863170706, 2375253569U, 3596610801U, (uint32_t )1814182875,
                               (uint32_t )2094937945, 3421402208U, (uint32_t )1082520231,
                               3463918190U, 2785509508U, (uint32_t )435703966, 3908032597U,
                               (uint32_t )1641649973, 2842273706U, 3305899714U, (uint32_t )1510255612,
                               2148256476U, 2655287854U, 3276092548U, 4258621189U,
                               (uint32_t )236887753, 3681803219U, (uint32_t )274041037,
                               (uint32_t )1734335097, 3815195456U, 3317970021U, (uint32_t )1899903192,
                               (uint32_t )1026095262, 4050517792U, (uint32_t )356393447,
                               2410691914U, 3873677099U, 3682840055U}, {3913112168U,
                                                                        2491498743U,
                                                                        4132185628U,
                                                                        2489919796U,
                                                                        (uint32_t )1091903735,
                                                                        (uint32_t )1979897079,
                                                                        3170134830U,
                                                                        3567386728U,
                                                                        3557303409U,
                                                                        (uint32_t )857797738,
                                                                        (uint32_t )1136121015,
                                                                        (uint32_t )1342202287,
                                                                        (uint32_t )507115054,
                                                                        2535736646U,
                                                                        (uint32_t )337727348,
                                                                        3213592640U,
                                                                        (uint32_t )1301675037,
                                                                        2528481711U,
                                                                        (uint32_t )1895095763,
                                                                        (uint32_t )1721773893,
                                                                        3216771564U,
                                                                        (uint32_t )62756741,
                                                                        (uint32_t )2142006736,
                                                                        (uint32_t )835421444,
                                                                        2531993523U,
                                                                        (uint32_t )1442658625,
                                                                        3659876326U,
                                                                        2882144922U,
                                                                        (uint32_t )676362277,
                                                                        (uint32_t )1392781812,
                                                                        (uint32_t )170690266,
                                                                        3921047035U,
                                                                        (uint32_t )1759253602,
                                                                        3611846912U,
                                                                        (uint32_t )1745797284,
                                                                        (uint32_t )664899054,
                                                                        (uint32_t )1329594018,
                                                                        3901205900U,
                                                                        3045908486U,
                                                                        (uint32_t )2062866102,
                                                                        2865634940U,
                                                                        3543621612U,
                                                                        3464012697U,
                                                                        (uint32_t )1080764994,
                                                                        (uint32_t )553557557,
                                                                        3656615353U,
                                                                        3996768171U,
                                                                        (uint32_t )991055499,
                                                                        (uint32_t )499776247,
                                                                        (uint32_t )1265440854,
                                                                        (uint32_t )648242737,
                                                                        3940784050U,
                                                                        (uint32_t )980351604,
                                                                        3713745714U,
                                                                        (uint32_t )1749149687,
                                                                        3396870395U,
                                                                        4211799374U,
                                                                        3640570775U,
                                                                        (uint32_t )1161844396,
                                                                        3125318951U,
                                                                        (uint32_t )1431517754,
                                                                        (uint32_t )545492359,
                                                                        4268468663U,
                                                                        3499529547U,
                                                                        (uint32_t )1437099964,
                                                                        2702547544U,
                                                                        3433638243U,
                                                                        2581715763U,
                                                                        2787789398U,
                                                                        (uint32_t )1060185593,
                                                                        (uint32_t )1593081372,
                                                                        2418618748U,
                                                                        4260947970U,
                                                                        (uint32_t )69676912,
                                                                        2159744348U,
                                                                        (uint32_t )86519011,
                                                                        2512459080U,
                                                                        3838209314U,
                                                                        (uint32_t )1220612927,
                                                                        3339683548U,
                                                                        (uint32_t )133810670,
                                                                        (uint32_t )1090789135,
                                                                        (uint32_t )1078426020,
                                                                        (uint32_t )1569222167,
                                                                        (uint32_t )845107691,
                                                                        3583754449U,
                                                                        4072456591U,
                                                                        (uint32_t )1091646820,
                                                                        (uint32_t )628848692,
                                                                        (uint32_t )1613405280,
                                                                        3757631651U,
                                                                        (uint32_t )526609435,
                                                                        (uint32_t )236106946,
                                                                        (uint32_t )48312990,
                                                                        2942717905U,
                                                                        3402727701U,
                                                                        (uint32_t )1797494240,
                                                                        (uint32_t )859738849,
                                                                        (uint32_t )992217954,
                                                                        4005476642U,
                                                                        2243076622U,
                                                                        3870952857U,
                                                                        3732016268U,
                                                                        (uint32_t )765654824,
                                                                        3490871365U,
                                                                        2511836413U,
                                                                        (uint32_t )1685915746,
                                                                        3888969200U,
                                                                        (uint32_t )1414112111,
                                                                        2273134842U,
                                                                        3281911079U,
                                                                        4080962846U,
                                                                        (uint32_t )172450625,
                                                                        2569994100U,
                                                                        (uint32_t )980381355,
                                                                        4109958455U,
                                                                        2819808352U,
                                                                        2716589560U,
                                                                        2568741196U,
                                                                        3681446669U,
                                                                        3329971472U,
                                                                        (uint32_t )1835478071,
                                                                        (uint32_t )660984891,
                                                                        3704678404U,
                                                                        4045999559U,
                                                                        3422617507U,
                                                                        3040415634U,
                                                                        (uint32_t )1762651403,
                                                                        (uint32_t )1719377915,
                                                                        3470491036U,
                                                                        2693910283U,
                                                                        3642056355U,
                                                                        3138596744U,
                                                                        (uint32_t )1364962596,
                                                                        (uint32_t )2073328063,
                                                                        (uint32_t )1983633131,
                                                                        (uint32_t )926494387,
                                                                        3423689081U,
                                                                        2150032023U,
                                                                        4096667949U,
                                                                        (uint32_t )1749200295,
                                                                        3328846651U,
                                                                        (uint32_t )309677260,
                                                                        (uint32_t )2016342300,
                                                                        (uint32_t )1779581495,
                                                                        3079819751U,
                                                                        (uint32_t )111262694,
                                                                        (uint32_t )1274766160,
                                                                        (uint32_t )443224088,
                                                                        (uint32_t )298511866,
                                                                        (uint32_t )1025883608,
                                                                        3806446537U,
                                                                        (uint32_t )1145181785,
                                                                        (uint32_t )168956806,
                                                                        3641502830U,
                                                                        3584813610U,
                                                                        (uint32_t )1689216846,
                                                                        3666258015U,
                                                                        3200248200U,
                                                                        (uint32_t )1692713982,
                                                                        2646376535U,
                                                                        4042768518U,
                                                                        (uint32_t )1618508792,
                                                                        (uint32_t )1610833997,
                                                                        3523052358U,
                                                                        4130873264U,
                                                                        (uint32_t )2001055236,
                                                                        3610705100U,
                                                                        2202168115U,
                                                                        4028541809U,
                                                                        2961195399U,
                                                                        (uint32_t )1006657119,
                                                                        (uint32_t )2006996926,
                                                                        3186142756U,
                                                                        (uint32_t )1430667929,
                                                                        3210227297U,
                                                                        (uint32_t )1314452623,
                                                                        4074634658U,
                                                                        4101304120U,
                                                                        2273951170U,
                                                                        (uint32_t )1399257539,
                                                                        3367210612U,
                                                                        3027628629U,
                                                                        (uint32_t )1190975929,
                                                                        (uint32_t )2062231137,
                                                                        2333990788U,
                                                                        2221543033U,
                                                                        2438960610U,
                                                                        (uint32_t )1181637006,
                                                                        (uint32_t )548689776,
                                                                        2362791313U,
                                                                        3372408396U,
                                                                        3104550113U,
                                                                        3145860560U,
                                                                        (uint32_t )296247880,
                                                                        (uint32_t )1970579870,
                                                                        3078560182U,
                                                                        3769228297U,
                                                                        (uint32_t )1714227617,
                                                                        3291629107U,
                                                                        3898220290U,
                                                                        (uint32_t )166772364,
                                                                        (uint32_t )1251581989,
                                                                        (uint32_t )493813264,
                                                                        (uint32_t )448347421,
                                                                        (uint32_t )195405023,
                                                                        2709975567U,
                                                                        (uint32_t )677966185,
                                                                        3703036547U,
                                                                        (uint32_t )1463355134,
                                                                        2715995803U,
                                                                        (uint32_t )1338867538,
                                                                        (uint32_t )1343315457,
                                                                        2802222074U,
                                                                        2684532164U,
                                                                        (uint32_t )233230375,
                                                                        2599980071U,
                                                                        (uint32_t )2000651841,
                                                                        3277868038U,
                                                                        (uint32_t )1638401717,
                                                                        4028070440U,
                                                                        3237316320U,
                                                                        (uint32_t )6314154,
                                                                        (uint32_t )819756386,
                                                                        (uint32_t )300326615,
                                                                        (uint32_t )590932579,
                                                                        (uint32_t )1405279636,
                                                                        3267499572U,
                                                                        3150704214U,
                                                                        2428286686U,
                                                                        3959192993U,
                                                                        3461946742U,
                                                                        (uint32_t )1862657033,
                                                                        (uint32_t )1266418056,
                                                                        (uint32_t )963775037,
                                                                        (uint32_t )2089974820,
                                                                        2263052895U,
                                                                        (uint32_t )1917689273,
                                                                        (uint32_t )448879540,
                                                                        3550394620U,
                                                                        3981727096U,
                                                                        (uint32_t )150775221,
                                                                        3627908307U,
                                                                        (uint32_t )1303187396,
                                                                        (uint32_t )508620638,
                                                                        2975983352U,
                                                                        2726630617U,
                                                                        (uint32_t )1817252668,
                                                                        (uint32_t )1876281319,
                                                                        (uint32_t )1457606340,
                                                                        (uint32_t )908771278,
                                                                        3720792119U,
                                                                        3617206836U,
                                                                        2455994898U,
                                                                        (uint32_t )1729034894,
                                                                        (uint32_t )1080033504},
     {(uint32_t )976866871, 3556439503U, 2881648439U, (uint32_t )1522871579, (uint32_t )1555064734,
      (uint32_t )1336096578, 3548522304U, 2579274686U, 3574697629U, 3205460757U, 3593280638U,
      3338716283U, 3079412587U, (uint32_t )564236357, 2993598910U, (uint32_t )1781952180,
      (uint32_t )1464380207, 3163844217U, 3332601554U, (uint32_t )1699332808, (uint32_t )1393555694,
      (uint32_t )1183702653, 3581086237U, (uint32_t )1288719814, (uint32_t )691649499,
      2847557200U, 2895455976U, 3193889540U, 2717570544U, (uint32_t )1781354906, (uint32_t )1676643554,
      2592534050U, 3230253752U, (uint32_t )1126444790, 2770207658U, 2633158820U, 2210423226U,
      2615765581U, 2414155088U, 3127139286U, (uint32_t )673620729, 2805611233U, (uint32_t )1269405062,
      4015350505U, 3341807571U, 4149409754U, (uint32_t )1057255273, (uint32_t )2012875353,
      2162469141U, 2276492801U, 2601117357U, (uint32_t )993977747, 3918593370U, 2654263191U,
      (uint32_t )753973209, (uint32_t )36408145, 2530585658U, (uint32_t )25011837,
      3520020182U, (uint32_t )2088578344, (uint32_t )530523599, 2918365339U, (uint32_t )1524020338,
      (uint32_t )1518925132, 3760827505U, 3759777254U, (uint32_t )1202760957, 3985898139U,
      3906192525U, (uint32_t )674977740, 4174734889U, (uint32_t )2031300136, (uint32_t )2019492241,
      3983892565U, 4153806404U, 3822280332U, (uint32_t )352677332, 2297720250U, (uint32_t )60907813,
      (uint32_t )90501309, 3286998549U, (uint32_t )1016092578, 2535922412U, 2839152426U,
      (uint32_t )457141659, (uint32_t )509813237, 4120667899U, (uint32_t )652014361,
      (uint32_t )1966332200, 2975202805U, (uint32_t )55981186, 2327461051U, (uint32_t )676427537,
      3255491064U, 2882294119U, 3433927263U, (uint32_t )1307055953, (uint32_t )942726286,
      (uint32_t )933058658, 2468411793U, 3933900994U, 4215176142U, (uint32_t )1361170020,
      (uint32_t )2001714738, 2830558078U, 3274259782U, (uint32_t )1222529897, (uint32_t )1679025792,
      2729314320U, 3714953764U, (uint32_t )1770335741, (uint32_t )151462246, 3013232138U,
      (uint32_t )1682292957, (uint32_t )1483529935, (uint32_t )471910574, (uint32_t )1539241949,
      (uint32_t )458788160, 3436315007U, (uint32_t )1807016891, 3718408830U, (uint32_t )978976581,
      (uint32_t )1043663428, 3165965781U, (uint32_t )1927990952, 4200891579U, 2372276910U,
      3208408903U, 3533431907U, (uint32_t )1412390302, 2931980059U, 4132332400U, (uint32_t )1947078029,
      3881505623U, 4168226417U, 2941484381U, (uint32_t )1077988104, (uint32_t )1320477388,
      (uint32_t )886195818, (uint32_t )18198404, 3786409000U, 2509781533U, (uint32_t )112762804,
      3463356488U, (uint32_t )1866414978, (uint32_t )891333506, (uint32_t )18488651,
      (uint32_t )661792760, (uint32_t )1628790961, 3885187036U, 3141171499U, (uint32_t )876946877,
      2693282273U, (uint32_t )1372485963, (uint32_t )791857591, 2686433993U, 3759982718U,
      3167212022U, 3472953795U, 2716379847U, (uint32_t )445679433, 3561995674U, 3504004811U,
      3574258232U, (uint32_t )54117162, 3331405415U, 2381918588U, 3769707343U, 4154350007U,
      (uint32_t )1140177722, 4074052095U, (uint32_t )668550556, 3214352940U, (uint32_t )367459370,
      (uint32_t )261225585, 2610173221U, 4209349473U, 3468074219U, 3265815641U, (uint32_t )314222801,
      3066103646U, 3808782860U, (uint32_t )282218597, 3406013506U, 3773591054U, (uint32_t )379116347,
      (uint32_t )1285071038, (uint32_t )846784868, 2669647154U, 3771962079U, 3550491691U,
      2305946142U, (uint32_t )453669953, (uint32_t )1268987020, 3317592352U, 3279303384U,
      3744833421U, 2610507566U, 3859509063U, (uint32_t )266596637, 3847019092U, (uint32_t )517658769,
      3462560207U, 3443424879U, (uint32_t )370717030, 4247526661U, 2224018117U, 4143653529U,
      4112773975U, 2788324899U, 2477274417U, (uint32_t )1456262402, 2901442914U, (uint32_t )1517677493,
      (uint32_t )1846949527, 2295493580U, 3734397586U, 2176403920U, (uint32_t )1280348187,
      (uint32_t )1908823572, 3871786941U, (uint32_t )846861322, (uint32_t )1172426758,
      3287448474U, 3383383037U, (uint32_t )1655181056, 3139813346U, (uint32_t )901632758,
      (uint32_t )1897031941, 2986607138U, 3066810236U, 3447102507U, (uint32_t )1393639104,
      (uint32_t )373351379, (uint32_t )950779232, (uint32_t )625454576, 3124240540U,
      4148612726U, (uint32_t )2007998917, (uint32_t )544563296, 2244738638U, 2330496472U,
      (uint32_t )2058025392, (uint32_t )1291430526, (uint32_t )424198748, (uint32_t )50039436,
      (uint32_t )29584100, 3605783033U, 2429876329U, 2791104160U, (uint32_t )1057563949,
      3255363231U, 3075367218U, 3463963227U, (uint32_t )1469046755, (uint32_t )985887462}},
    {(uint32_t )608135816, 2242054355U, (uint32_t )320440878, (uint32_t )57701188,
     2752067618U, (uint32_t )698298832, (uint32_t )137296536, 3964562569U, (uint32_t )1160258022,
     (uint32_t )953160567, 3193202383U, (uint32_t )887688300, 3232508343U, 3380367581U,
     (uint32_t )1065670069, 3041331479U, 2450970073U, 2306472731U}, (enum blowfish_error )1};
#line 249 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/blowfish.c"
static void encrypt(struct blowfish_ctx *bc , uint32_t *ret_xl , uint32_t *ret_xr ) 
{ 
  uint32_t xl ;
  uint32_t xr ;

  {
#line 254
  xl = *ret_xl;
#line 255
  xr = *ret_xr;
  {
  {
#line 256
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 256
    xl ^= bc->p[0];
#line 256
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 256
    goto while_break;
  }
  while_break___31: /* CIL Label */ ;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 257
  while (1) {
    while_continue___16: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 257
    xr ^= bc->p[1];
#line 257
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 257
    goto while_break___0;
  }
  while_break___32: /* CIL Label */ ;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___0: ;
  {
  {
#line 258
  while (1) {
    while_continue___17: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 258
    xl ^= bc->p[2];
#line 258
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 258
    goto while_break___1;
  }
  while_break___33: /* CIL Label */ ;
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___1: ;
  {
  {
#line 259
  while (1) {
    while_continue___18: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 259
    xr ^= bc->p[3];
#line 259
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 259
    goto while_break___2;
  }
  while_break___34: /* CIL Label */ ;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___2: ;
  {
  {
#line 260
  while (1) {
    while_continue___19: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 260
    xl ^= bc->p[4];
#line 260
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 260
    goto while_break___3;
  }
  while_break___35: /* CIL Label */ ;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___3: ;
  {
  {
#line 261
  while (1) {
    while_continue___20: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 261
    xr ^= bc->p[5];
#line 261
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 261
    goto while_break___4;
  }
  while_break___36: /* CIL Label */ ;
  }
  while_break___20: /* CIL Label */ ;
  }
  while_break___4: ;
  {
  {
#line 262
  while (1) {
    while_continue___21: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 262
    xl ^= bc->p[6];
#line 262
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 262
    goto while_break___5;
  }
  while_break___37: /* CIL Label */ ;
  }
  while_break___21: /* CIL Label */ ;
  }
  while_break___5: ;
  {
  {
#line 263
  while (1) {
    while_continue___22: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;
#line 263
    xr ^= bc->p[7];
#line 263
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 263
    goto while_break___6;
  }
  while_break___38: /* CIL Label */ ;
  }
  while_break___22: /* CIL Label */ ;
  }
  while_break___6: ;
  {
  {
#line 264
  while (1) {
    while_continue___23: /* CIL Label */ ;
    while_continue___7: /* CIL Label */ ;
#line 264
    xl ^= bc->p[8];
#line 264
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 264
    goto while_break___7;
  }
  while_break___39: /* CIL Label */ ;
  }
  while_break___23: /* CIL Label */ ;
  }
  while_break___7: ;
  {
  {
#line 265
  while (1) {
    while_continue___24: /* CIL Label */ ;
    while_continue___8: /* CIL Label */ ;
#line 265
    xr ^= bc->p[9];
#line 265
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 265
    goto while_break___8;
  }
  while_break___40: /* CIL Label */ ;
  }
  while_break___24: /* CIL Label */ ;
  }
  while_break___8: ;
  {
  {
#line 266
  while (1) {
    while_continue___25: /* CIL Label */ ;
    while_continue___9: /* CIL Label */ ;
#line 266
    xl ^= bc->p[10];
#line 266
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 266
    goto while_break___9;
  }
  while_break___41: /* CIL Label */ ;
  }
  while_break___25: /* CIL Label */ ;
  }
  while_break___9: ;
  {
  {
#line 267
  while (1) {
    while_continue___26: /* CIL Label */ ;
    while_continue___10: /* CIL Label */ ;
#line 267
    xr ^= bc->p[11];
#line 267
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 267
    goto while_break___10;
  }
  while_break___42: /* CIL Label */ ;
  }
  while_break___26: /* CIL Label */ ;
  }
  while_break___10: ;
  {
  {
#line 268
  while (1) {
    while_continue___27: /* CIL Label */ ;
    while_continue___11: /* CIL Label */ ;
#line 268
    xl ^= bc->p[12];
#line 268
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 268
    goto while_break___11;
  }
  while_break___43: /* CIL Label */ ;
  }
  while_break___27: /* CIL Label */ ;
  }
  while_break___11: ;
  {
  {
#line 269
  while (1) {
    while_continue___28: /* CIL Label */ ;
    while_continue___12: /* CIL Label */ ;
#line 269
    xr ^= bc->p[13];
#line 269
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 269
    goto while_break___12;
  }
  while_break___44: /* CIL Label */ ;
  }
  while_break___28: /* CIL Label */ ;
  }
  while_break___12: ;
  {
  {
#line 270
  while (1) {
    while_continue___29: /* CIL Label */ ;
    while_continue___13: /* CIL Label */ ;
#line 270
    xl ^= bc->p[14];
#line 270
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 270
    goto while_break___13;
  }
  while_break___45: /* CIL Label */ ;
  }
  while_break___29: /* CIL Label */ ;
  }
  while_break___13: ;
  {
  {
#line 271
  while (1) {
    while_continue___30: /* CIL Label */ ;
    while_continue___14: /* CIL Label */ ;
#line 271
    xr ^= bc->p[15];
#line 271
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 271
    goto while_break___14;
  }
  while_break___46: /* CIL Label */ ;
  }
  while_break___30: /* CIL Label */ ;
  }
  while_break___14: 
#line 273
  xl ^= bc->p[16];
#line 274
  xr ^= bc->p[17];
#line 276
  *ret_xl = xr;
#line 277
  *ret_xr = xl;
#line 278
  return;
}
}
#line 280 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/blowfish.c"
static void decrypt(struct blowfish_ctx *bc , uint32_t *ret_xl , uint32_t *ret_xr ) 
{ 
  uint32_t xl ;
  uint32_t xr ;

  {
#line 285
  xl = *ret_xl;
#line 286
  xr = *ret_xr;
  {
  {
#line 288
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 288
    xl ^= bc->p[17];
#line 288
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 288
    goto while_break;
  }
  while_break___31: /* CIL Label */ ;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 289
  while (1) {
    while_continue___16: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 289
    xr ^= bc->p[16];
#line 289
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 289
    goto while_break___0;
  }
  while_break___32: /* CIL Label */ ;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___0: ;
  {
  {
#line 290
  while (1) {
    while_continue___17: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 290
    xl ^= bc->p[15];
#line 290
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 290
    goto while_break___1;
  }
  while_break___33: /* CIL Label */ ;
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___1: ;
  {
  {
#line 291
  while (1) {
    while_continue___18: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 291
    xr ^= bc->p[14];
#line 291
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 291
    goto while_break___2;
  }
  while_break___34: /* CIL Label */ ;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___2: ;
  {
  {
#line 292
  while (1) {
    while_continue___19: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 292
    xl ^= bc->p[13];
#line 292
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 292
    goto while_break___3;
  }
  while_break___35: /* CIL Label */ ;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___3: ;
  {
  {
#line 293
  while (1) {
    while_continue___20: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 293
    xr ^= bc->p[12];
#line 293
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 293
    goto while_break___4;
  }
  while_break___36: /* CIL Label */ ;
  }
  while_break___20: /* CIL Label */ ;
  }
  while_break___4: ;
  {
  {
#line 294
  while (1) {
    while_continue___21: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 294
    xl ^= bc->p[11];
#line 294
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 294
    goto while_break___5;
  }
  while_break___37: /* CIL Label */ ;
  }
  while_break___21: /* CIL Label */ ;
  }
  while_break___5: ;
  {
  {
#line 295
  while (1) {
    while_continue___22: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;
#line 295
    xr ^= bc->p[10];
#line 295
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 295
    goto while_break___6;
  }
  while_break___38: /* CIL Label */ ;
  }
  while_break___22: /* CIL Label */ ;
  }
  while_break___6: ;
  {
  {
#line 296
  while (1) {
    while_continue___23: /* CIL Label */ ;
    while_continue___7: /* CIL Label */ ;
#line 296
    xl ^= bc->p[9];
#line 296
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 296
    goto while_break___7;
  }
  while_break___39: /* CIL Label */ ;
  }
  while_break___23: /* CIL Label */ ;
  }
  while_break___7: ;
  {
  {
#line 297
  while (1) {
    while_continue___24: /* CIL Label */ ;
    while_continue___8: /* CIL Label */ ;
#line 297
    xr ^= bc->p[8];
#line 297
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 297
    goto while_break___8;
  }
  while_break___40: /* CIL Label */ ;
  }
  while_break___24: /* CIL Label */ ;
  }
  while_break___8: ;
  {
  {
#line 298
  while (1) {
    while_continue___25: /* CIL Label */ ;
    while_continue___9: /* CIL Label */ ;
#line 298
    xl ^= bc->p[7];
#line 298
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 298
    goto while_break___9;
  }
  while_break___41: /* CIL Label */ ;
  }
  while_break___25: /* CIL Label */ ;
  }
  while_break___9: ;
  {
  {
#line 299
  while (1) {
    while_continue___26: /* CIL Label */ ;
    while_continue___10: /* CIL Label */ ;
#line 299
    xr ^= bc->p[6];
#line 299
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 299
    goto while_break___10;
  }
  while_break___42: /* CIL Label */ ;
  }
  while_break___26: /* CIL Label */ ;
  }
  while_break___10: ;
  {
  {
#line 300
  while (1) {
    while_continue___27: /* CIL Label */ ;
    while_continue___11: /* CIL Label */ ;
#line 300
    xl ^= bc->p[5];
#line 300
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 300
    goto while_break___11;
  }
  while_break___43: /* CIL Label */ ;
  }
  while_break___27: /* CIL Label */ ;
  }
  while_break___11: ;
  {
  {
#line 301
  while (1) {
    while_continue___28: /* CIL Label */ ;
    while_continue___12: /* CIL Label */ ;
#line 301
    xr ^= bc->p[4];
#line 301
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 301
    goto while_break___12;
  }
  while_break___44: /* CIL Label */ ;
  }
  while_break___28: /* CIL Label */ ;
  }
  while_break___12: ;
  {
  {
#line 302
  while (1) {
    while_continue___29: /* CIL Label */ ;
    while_continue___13: /* CIL Label */ ;
#line 302
    xl ^= bc->p[3];
#line 302
    xr ^= (((bc->s[0][(xl >> 24) & 255U] + bc->s[1][(xl >> 16) & 255U]) ^ bc->s[2][(xl >> 8) & 255U]) + bc->s[3][xl & 255U]) & 4294967295U;
#line 302
    goto while_break___13;
  }
  while_break___45: /* CIL Label */ ;
  }
  while_break___29: /* CIL Label */ ;
  }
  while_break___13: ;
  {
  {
#line 303
  while (1) {
    while_continue___30: /* CIL Label */ ;
    while_continue___14: /* CIL Label */ ;
#line 303
    xr ^= bc->p[2];
#line 303
    xl ^= (((bc->s[0][(xr >> 24) & 255U] + bc->s[1][(xr >> 16) & 255U]) ^ bc->s[2][(xr >> 8) & 255U]) + bc->s[3][xr & 255U]) & 4294967295U;
#line 303
    goto while_break___14;
  }
  while_break___46: /* CIL Label */ ;
  }
  while_break___30: /* CIL Label */ ;
  }
  while_break___14: 
#line 305
  xl ^= bc->p[1];
#line 306
  xr ^= bc->p[0];
#line 308
  *ret_xl = xr;
#line 309
  *ret_xr = xl;
#line 310
  return;
}
}
#line 315 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/blowfish.c"
void nettle_blowfish_encrypt(struct blowfish_ctx *bc , unsigned int length , uint8_t *outbuf ,
                             uint8_t const   *inbuf ) 
{ 
  uint32_t d1 ;
  uint32_t d2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 321
  if (! (! bc->status)) {
    {
    {
#line 321
    __assert_fail("!bc->status", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/blowfish.c",
                  321U, "nettle_blowfish_encrypt");
    }
    }
  }
#line 323
  if (! (! (length % 8U))) {
    {
    {
#line 323
    __assert_fail("!((length) % (8))", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/blowfish.c",
                  323U, "nettle_blowfish_encrypt");
    }
    }
  }
  {
  {
#line 323
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 323
    if (! length) {
#line 323
      goto while_break;
    }
    {
#line 325
    d1 = ((((uint32_t )*(inbuf + 0) << 24) | ((uint32_t )*(inbuf + 1) << 16)) | ((uint32_t )*(inbuf + 2) << 8)) | (uint32_t )*(inbuf + 3);
#line 326
    d2 = ((((uint32_t )*((inbuf + 4) + 0) << 24) | ((uint32_t )*((inbuf + 4) + 1) << 16)) | ((uint32_t )*((inbuf + 4) + 2) << 8)) | (uint32_t )*((inbuf + 4) + 3);
    {
#line 328
    encrypt(bc, & d1, & d2);
    }
    }
    {
    {
#line 330
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 330
      *(outbuf + 0) = (uint8_t )((d1 >> 24) & 255U);
#line 330
      *(outbuf + 1) = (uint8_t )((d1 >> 16) & 255U);
#line 330
      *(outbuf + 2) = (uint8_t )((d1 >> 8) & 255U);
#line 330
      *(outbuf + 3) = (uint8_t )(d1 & 255U);
#line 330
      goto while_break___0;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
    {
    {
#line 331
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 331
      *((outbuf + 4) + 0) = (uint8_t )((d2 >> 24) & 255U);
#line 331
      *((outbuf + 4) + 1) = (uint8_t )((d2 >> 16) & 255U);
#line 331
      *((outbuf + 4) + 2) = (uint8_t )((d2 >> 8) & 255U);
#line 331
      *((outbuf + 4) + 3) = (uint8_t )(d2 & 255U);
#line 331
      goto while_break___1;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 323
    length -= 8U;
#line 323
    outbuf += 8;
#line 323
    inbuf += 8;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 333
  return;
}
}
#line 336 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/blowfish.c"
void nettle_blowfish_decrypt(struct blowfish_ctx *bc , unsigned int length , uint8_t *outbuf ,
                             uint8_t const   *inbuf ) 
{ 
  uint32_t d1 ;
  uint32_t d2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 342
  if (! (! bc->status)) {
    {
    {
#line 342
    __assert_fail("!bc->status", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/blowfish.c",
                  342U, "nettle_blowfish_decrypt");
    }
    }
  }
#line 344
  if (! (! (length % 8U))) {
    {
    {
#line 344
    __assert_fail("!((length) % (8))", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/blowfish.c",
                  344U, "nettle_blowfish_decrypt");
    }
    }
  }
  {
  {
#line 344
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 344
    if (! length) {
#line 344
      goto while_break;
    }
    {
#line 346
    d1 = ((((uint32_t )*(inbuf + 0) << 24) | ((uint32_t )*(inbuf + 1) << 16)) | ((uint32_t )*(inbuf + 2) << 8)) | (uint32_t )*(inbuf + 3);
#line 347
    d2 = ((((uint32_t )*((inbuf + 4) + 0) << 24) | ((uint32_t )*((inbuf + 4) + 1) << 16)) | ((uint32_t )*((inbuf + 4) + 2) << 8)) | (uint32_t )*((inbuf + 4) + 3);
    {
#line 349
    decrypt(bc, & d1, & d2);
    }
    }
    {
    {
#line 351
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 351
      *(outbuf + 0) = (uint8_t )((d1 >> 24) & 255U);
#line 351
      *(outbuf + 1) = (uint8_t )((d1 >> 16) & 255U);
#line 351
      *(outbuf + 2) = (uint8_t )((d1 >> 8) & 255U);
#line 351
      *(outbuf + 3) = (uint8_t )(d1 & 255U);
#line 351
      goto while_break___0;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
    {
    {
#line 352
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 352
      *((outbuf + 4) + 0) = (uint8_t )((d2 >> 24) & 255U);
#line 352
      *((outbuf + 4) + 1) = (uint8_t )((d2 >> 16) & 255U);
#line 352
      *((outbuf + 4) + 2) = (uint8_t )((d2 >> 8) & 255U);
#line 352
      *((outbuf + 4) + 3) = (uint8_t )(d2 & 255U);
#line 352
      goto while_break___1;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 344
    length -= 8U;
#line 344
    outbuf += 8;
#line 344
    inbuf += 8;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 354
  return;
}
}
#line 356 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/blowfish.c"
int nettle_blowfish_set_key(struct blowfish_ctx *ctx , unsigned int keylen , uint8_t const   *key ) 
{ 
  int i ;
  int j ;
  uint32_t data ;
  uint32_t datal ;
  uint32_t datar ;

  {
#line 372
  *ctx = (struct blowfish_ctx )initial_ctx;
#line 374
  j = 0;
#line 374
  i = j;
  {
  {
#line 374
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 374
    if (! (i < 18)) {
#line 374
      goto while_break;
    }
#line 376
    data = (uint32_t )(((((int const   )*(key + j) << 24) | ((int const   )*(key + (unsigned int )(j + 1) % keylen) << 16)) | ((int const   )*(key + (unsigned int )(j + 2) % keylen) << 8)) | (int const   )*(key + (unsigned int )(j + 3) % keylen));
#line 379
    ctx->p[i] ^= data;
#line 380
    j = (int )((unsigned int )(j + 4) % keylen);
#line 374
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: 
#line 383
  datar = (uint32_t )0;
#line 383
  datal = datar;
#line 384
  i = 0;
  {
  {
#line 384
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 384
    if (! (i < 18)) {
#line 384
      goto while_break___0;
    }
    {
    {
#line 386
    encrypt(ctx, & datal, & datar);
    }
#line 387
    ctx->p[i] = datal;
#line 388
    ctx->p[i + 1] = datar;
#line 384
    i += 2;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___0: 
#line 390
  i = 0;
  {
  {
#line 390
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;

#line 390
    if (! (i < 256)) {
#line 390
      goto while_break___1;
    }
    {
    {
#line 392
    encrypt(ctx, & datal, & datar);
    }
#line 393
    ctx->s[0][i] = datal;
#line 394
    ctx->s[0][i + 1] = datar;
#line 390
    i += 2;
    }
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___1: 
#line 396
  i = 0;
  {
  {
#line 396
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;

#line 396
    if (! (i < 256)) {
#line 396
      goto while_break___2;
    }
    {
    {
#line 398
    encrypt(ctx, & datal, & datar);
    }
#line 399
    ctx->s[1][i] = datal;
#line 400
    ctx->s[1][i + 1] = datar;
#line 396
    i += 2;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___2: 
#line 402
  i = 0;
  {
  {
#line 402
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;

#line 402
    if (! (i < 256)) {
#line 402
      goto while_break___3;
    }
    {
    {
#line 404
    encrypt(ctx, & datal, & datar);
    }
#line 405
    ctx->s[2][i] = datal;
#line 406
    ctx->s[2][i + 1] = datar;
#line 402
    i += 2;
    }
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___3: 
#line 408
  i = 0;
  {
  {
#line 408
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;

#line 408
    if (! (i < 256)) {
#line 408
      goto while_break___4;
    }
    {
    {
#line 410
    encrypt(ctx, & datal, & datar);
    }
#line 411
    ctx->s[3][i] = datal;
#line 412
    ctx->s[3][i + 1] = datar;
#line 408
    i += 2;
    }
  }
  while_break___20: /* CIL Label */ ;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___4: 
#line 417
  i = 0;
  {
  {
#line 417
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;

#line 417
    if (! (i < 255)) {
#line 417
      goto while_break___5;
    }
#line 418
    j = i + 1;
    {
    {
#line 418
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;

#line 418
      if (! (j < 256)) {
#line 418
        goto while_break___6;
      }
#line 419
      if (ctx->s[0][i] == ctx->s[0][j]) {
#line 421
        return (0);
      } else
#line 419
      if (ctx->s[1][i] == ctx->s[1][j]) {
#line 421
        return (0);
      } else
#line 419
      if (ctx->s[2][i] == ctx->s[2][j]) {
#line 421
        return (0);
      } else
#line 419
      if (ctx->s[3][i] == ctx->s[3][j]) {
#line 421
        return (0);
      }
#line 418
      j ++;
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___6: 
#line 417
    i ++;
  }
  while_break___21: /* CIL Label */ ;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___5: 
#line 423
  ctx->status = (enum blowfish_error )0;
#line 424
  return (1);
}
}
#line 774 "/usr/include/gmp-i386.h"
extern void __gmpz_com(mpz_ptr  , mpz_srcptr  ) ;
#line 904
extern void __gmpz_import(mpz_ptr  , size_t  , int  , size_t  , int  , size_t  , void const   * ) ;
#line 925
extern void __gmpz_init_set_ui(mpz_ptr  , unsigned long  ) ;
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.h"
void nettle_mpz_init_set_str_256_s(__mpz_struct *x , unsigned int length , uint8_t const   *s ) ;
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.c"
unsigned int nettle_mpz_sizeinbase_256_s(__mpz_struct * const  x ) 
{ 
  size_t tmp ;
  unsigned int size ;
  mpz_t c ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 54
  if (x->_mp_size < 0) {
#line 54
    tmp___1 = -1;
  } else {
#line 54
    tmp___1 = x->_mp_size > 0;
  }
#line 54
  if (tmp___1 >= 0) {
    {
    {
#line 55
    tmp = __gmpz_sizeinbase((mpz_srcptr )x, 2);
    }
    }
#line 55
    return (1U + tmp / 8U);
  } else {
    {
    {
#line 62
    __gmpz_init(c);
    }
    {
#line 63
    __gmpz_com(c, (mpz_srcptr )x);
    }
    {
#line 64
    tmp___0 = __gmpz_sizeinbase((mpz_srcptr )(c), 2);
    }
#line 64
    size = 1U + tmp___0 / 8U;
    {
#line 65
    __gmpz_clear(c);
    }
    }
#line 67
    return (size);
  }
}
}
#line 71 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.c"
unsigned int nettle_mpz_sizeinbase_256_u(__mpz_struct * const  x ) 
{ 
  size_t tmp ;

  {
  {
  {
#line 74
  tmp = __gmpz_sizeinbase((mpz_srcptr )x, 2);
  }
  }
#line 74
  return ((tmp + 7U) / 8U);
}
}
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.c"
static void nettle_mpz_to_octets(unsigned int length , uint8_t *s , __mpz_struct * const  x ,
                                 uint8_t sign ) 
{ 
  uint8_t *dst ;
  unsigned int size ;
  size_t tmp ;
  unsigned int i ;
  mp_limb_t limb ;
  mp_limb_t tmp___0 ;
  unsigned int j ;
  uint8_t *tmp___1 ;

  {
  {
#line 81
  dst = (s + length) - 1;
  {
#line 82
  tmp = __gmpz_size((mpz_srcptr )x);
  }
#line 82
  size = tmp;
#line 85
  i = 0U;
  }
  {
  {
#line 85
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 85
    if (! (i < size)) {
#line 85
      goto while_break;
    }
    {
    {
#line 87
    tmp___0 = __gmpz_getlimbn((mpz_srcptr )x, (mp_size_t )i);
    }
#line 87
    limb = tmp___0;
#line 90
    j = 0U;
    }
    {
    {
#line 90
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 90
      if (length) {
#line 90
        if (! ((unsigned long )j < sizeof(mp_limb_t ))) {
#line 90
          goto while_break___0;
        }
      } else {
#line 90
        goto while_break___0;
      }
#line 92
      tmp___1 = dst;
#line 92
      dst --;
#line 92
      *tmp___1 = (uint8_t )((unsigned long )sign ^ (limb & 255UL));
#line 93
      limb >>= 8;
#line 94
      length --;
#line 90
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 85
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 98
  if (length) {
    {
    {
#line 99
    memset((void *)s, (int )sign, length);
    }
    }
  }
#line 100
  return;
}
}
#line 102 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.c"
void nettle_mpz_get_str_256(unsigned int length , uint8_t *s , __mpz_struct * const  x ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;
  mpz_t c ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 105
  if (! length) {
#line 108
    if (x->_mp_size < 0) {
#line 108
      tmp = -1;
    } else {
#line 108
      tmp = x->_mp_size > 0;
    }
#line 108
    if (tmp) {
      {
      {
#line 108
      __assert_fail("!((x)->_mp_size < 0 ? -1 : (x)->_mp_size > 0)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.c",
                    108U, "nettle_mpz_get_str_256");
      }
      }
    }
#line 109
    return;
  }
#line 112
  if (x->_mp_size < 0) {
#line 112
    tmp___2 = -1;
  } else {
#line 112
    tmp___2 = x->_mp_size > 0;
  }
#line 112
  if (tmp___2 >= 0) {
    {
    {
#line 114
    tmp___0 = nettle_mpz_sizeinbase_256_u(x);
    }
    }
#line 114
    if (! (tmp___0 <= length)) {
      {
      {
#line 114
      __assert_fail("nettle_mpz_sizeinbase_256_u(x) <= length", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.c",
                    114U, "nettle_mpz_get_str_256");
      }
      }
    }
    {
    {
#line 115
    nettle_mpz_to_octets(length, s, x, (uint8_t )0);
    }
    }
  } else {
    {
    {
#line 120
    __gmpz_init(c);
    }
    {
#line 121
    __gmpz_com(c, (mpz_srcptr )x);
    }
    {
#line 126
    tmp___1 = nettle_mpz_sizeinbase_256_u((__mpz_struct */* const  */)(c));
    }
    }
#line 126
    if (! (tmp___1 <= length)) {
      {
      {
#line 126
      __assert_fail("nettle_mpz_sizeinbase_256_u(c) <= length", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.c",
                    126U, "nettle_mpz_get_str_256");
      }
      }
    }
    {
    {
#line 127
    nettle_mpz_to_octets(length, s, (__mpz_struct */* const  */)(c), (uint8_t )255);
    }
    {
#line 129
    __gmpz_clear(c);
    }
    }
  }
#line 131
  return;
}
}
#line 156 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.c"
void nettle_mpz_set_str_256_u(__mpz_struct *x , unsigned int length , uint8_t const   *s ) 
{ 


  {
  {
  {
#line 160
  __gmpz_import(x, length, 1, (size_t )1, 0, (size_t )0, (void const   *)s);
  }
  }
#line 161
  return;
}
}
#line 163 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.c"
void nettle_mpz_init_set_str_256_u(__mpz_struct *x , unsigned int length , uint8_t const   *s ) 
{ 


  {
  {
  {
#line 167
  __gmpz_init(x);
  }
  {
#line 168
  __gmpz_import(x, length, 1, (size_t )1, 0, (size_t )0, (void const   *)s);
  }
  }
#line 169
  return;
}
}
#line 171 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.c"
void nettle_mpz_set_str_256_s(__mpz_struct *x , unsigned int length , uint8_t const   *s ) 
{ 
  mpz_t t ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 175
  if (! length) {
    {
    {
#line 177
    __gmpz_set_ui(x, 0UL);
    }
    }
#line 178
    return;
  }
  {
  {
#line 181
  __gmpz_import(x, length, 1, (size_t )1, 0, (size_t )0, (void const   *)s);
  }
  }
#line 183
  if ((int const   )*(s + 0) & 128) {
    {
    {
#line 187
    __gmpz_init_set_ui(t, 1UL);
    }
    {
#line 188
    __gmpz_mul_2exp(t, (mpz_srcptr )(t), (unsigned long )(length * 8U));
    }
    {
#line 189
    __gmpz_sub(x, (mpz_srcptr )x, (mpz_srcptr )(t));
    }
    {
#line 190
    __gmpz_clear(t);
    }
    }
  }
#line 192
  return;
}
}
#line 194 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum.c"
void nettle_mpz_init_set_str_256_s(__mpz_struct *x , unsigned int length , uint8_t const   *s ) 
{ 


  {
  {
  {
#line 198
  __gmpz_init(x);
  }
  {
#line 199
  nettle_mpz_set_str_256_s(x, length, s);
  }
  }
#line 200
  return;
}
}
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum-random.c"
void nettle_mpz_random_size(__mpz_struct *x , void *ctx , void (*random___0)(void *ctx ,
                                                                             unsigned int length ,
                                                                             uint8_t *dst ) ,
                            unsigned int bits ) 
{ 
  unsigned int length ;
  uint8_t *data ;
  void *tmp ;

  {
  {
#line 42
  length = (bits + 7U) / 8U;
  {
#line 44
  tmp = __builtin_alloca(sizeof(*data) * (unsigned long )length);
  }
#line 44
  data = (uint8_t *)tmp;
  {
#line 46
  (*random___0)(ctx, length, data);
  }
  {
#line 48
  nettle_mpz_set_str_256_u(x, length, (uint8_t const   *)data);
  }
  }
#line 50
  if (bits % 8U) {
    {
    {
#line 51
    __gmpz_fdiv_r_2exp(x, (mpz_srcptr )x, (unsigned long )bits);
    }
    }
  }
#line 52
  return;
}
}
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/bignum-random.c"
void nettle_mpz_random(__mpz_struct *x , void *ctx , void (*random___0)(void *ctx ,
                                                                        unsigned int length ,
                                                                        uint8_t *dst ) ,
                       __mpz_struct * const  n ) 
{ 
  size_t tmp ;

  {
  {
  {
#line 82
  tmp = __gmpz_sizeinbase((mpz_srcptr )n, 2);
  }
  {
#line 82
  nettle_mpz_random_size(x, ctx, random___0, tmp + 16U);
  }
  {
#line 86
  __gmpz_fdiv_r(x, (mpz_srcptr )x, (mpz_srcptr )n);
  }
  }
#line 87
  return;
}
}
#line 231 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_armor  const  nettle_base64 ;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-meta.c"
static unsigned int base64_encode_length(unsigned int length ) 
{ 


  {
#line 35
  return ((length * 8U + 4U) / 6U);
}
}
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-meta.c"
static unsigned int base64_decode_length(unsigned int length ) 
{ 


  {
#line 41
  return (((length + 1U) * 6U) / 8U);
}
}
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-meta.c"
struct nettle_armor  const  nettle_base64  = 
#line 44
     {"base64", (unsigned int )sizeof(struct base64_encode_ctx ), (unsigned int )sizeof(struct base64_decode_ctx ),
    3U, (void (*)(void *ctx ))(& nettle_base64_encode_init), & base64_encode_length,
    (unsigned int (*)(void *ctx , uint8_t *dst , unsigned int src_length , uint8_t const   *src ))(& nettle_base64_encode_update),
    (unsigned int (*)(void *ctx , uint8_t *dst ))(& nettle_base64_encode_final), (void (*)(void *ctx ))(& nettle_base64_decode_init),
    & base64_decode_length, (int (*)(void *ctx , unsigned int *dst_length , uint8_t *dst ,
                                     unsigned int src_length , uint8_t const   *src ))(& nettle_base64_decode_update),
    (int (*)(void *ctx ))(& nettle_base64_decode_final)};
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64.h"
unsigned int nettle_base64_encode_single(struct base64_encode_ctx *ctx , uint8_t *dst ,
                                         uint8_t src ) ;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c"
static uint8_t const   encode_table[64]  = 
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c"
  {      (uint8_t const   )'A',      (uint8_t const   )'B',      (uint8_t const   )'C',      (uint8_t const   )'D', 
        (uint8_t const   )'E',      (uint8_t const   )'F',      (uint8_t const   )'G',      (uint8_t const   )'H', 
        (uint8_t const   )'I',      (uint8_t const   )'J',      (uint8_t const   )'K',      (uint8_t const   )'L', 
        (uint8_t const   )'M',      (uint8_t const   )'N',      (uint8_t const   )'O',      (uint8_t const   )'P', 
        (uint8_t const   )'Q',      (uint8_t const   )'R',      (uint8_t const   )'S',      (uint8_t const   )'T', 
        (uint8_t const   )'U',      (uint8_t const   )'V',      (uint8_t const   )'W',      (uint8_t const   )'X', 
        (uint8_t const   )'Y',      (uint8_t const   )'Z',      (uint8_t const   )'a',      (uint8_t const   )'b', 
        (uint8_t const   )'c',      (uint8_t const   )'d',      (uint8_t const   )'e',      (uint8_t const   )'f', 
        (uint8_t const   )'g',      (uint8_t const   )'h',      (uint8_t const   )'i',      (uint8_t const   )'j', 
        (uint8_t const   )'k',      (uint8_t const   )'l',      (uint8_t const   )'m',      (uint8_t const   )'n', 
        (uint8_t const   )'o',      (uint8_t const   )'p',      (uint8_t const   )'q',      (uint8_t const   )'r', 
        (uint8_t const   )'s',      (uint8_t const   )'t',      (uint8_t const   )'u',      (uint8_t const   )'v', 
        (uint8_t const   )'w',      (uint8_t const   )'x',      (uint8_t const   )'y',      (uint8_t const   )'z', 
        (uint8_t const   )'0',      (uint8_t const   )'1',      (uint8_t const   )'2',      (uint8_t const   )'3', 
        (uint8_t const   )'4',      (uint8_t const   )'5',      (uint8_t const   )'6',      (uint8_t const   )'7', 
        (uint8_t const   )'8',      (uint8_t const   )'9',      (uint8_t const   )'+',      (uint8_t const   )'/'};
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c"
void nettle_base64_encode_raw(uint8_t *dst , unsigned int length , uint8_t const   *src ) 
{ 
  uint8_t const   *in ;
  uint8_t *out ;
  unsigned int left_over ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 44
  in = src + length;
#line 45
  out = dst + ((length + 2U) / 3U) * 4U;
#line 47
  left_over = length % 3U;
#line 49
  if (left_over) {
#line 51
    in -= left_over;
#line 52
    out --;
#line 52
    *out = (uint8_t )'=';
#line 55
    if (left_over == 1U) {
#line 55
      goto case_1;
    }
#line 60
    if (left_over == 2U) {
#line 60
      goto case_2;
    }
#line 65
    goto switch_default;
    case_1: 
#line 56
    out --;
#line 56
    *out = (uint8_t )'=';
#line 57
    out --;
#line 57
    *out = (uint8_t )encode_table[63 & (int )((int const   )*(in + 0) << 4)];
#line 58
    goto switch_break;
    case_2: 
#line 61
    out --;
#line 61
    *out = (uint8_t )encode_table[63 & (int )((int const   )*(in + 1) << 2)];
#line 62
    out --;
#line 62
    *out = (uint8_t )encode_table[63 & (int )(((int const   )*(in + 0) << 4) | ((int const   )*(in + 1) >> 4))];
#line 63
    goto switch_break;
    switch_default: 
    {
    {
#line 66
    abort();
    }
    }
    switch_break: 
#line 68
    out --;
#line 68
    *out = (uint8_t )encode_table[63 & (int )((int const   )*(in + 0) >> 2)];
  }
  {
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 71
    if (! ((unsigned long )in > (unsigned long )src)) {
#line 71
      goto while_break;
    }
#line 73
    in -= 3;
#line 74
    out --;
#line 74
    *out = (uint8_t )encode_table[63 & (int )*(in + 2)];
#line 75
    out --;
#line 75
    *out = (uint8_t )encode_table[63 & (int )(((int const   )*(in + 1) << 2) | ((int const   )*(in + 2) >> 6))];
#line 76
    out --;
#line 76
    *out = (uint8_t )encode_table[63 & (int )(((int const   )*(in + 0) << 4) | ((int const   )*(in + 1) >> 4))];
#line 77
    out --;
#line 77
    *out = (uint8_t )encode_table[63 & (int )((int const   )*(in + 0) >> 2)];
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 79
  if (! ((unsigned long )in == (unsigned long )src)) {
    {
    {
#line 79
    __assert_fail("in == src", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c",
                  79U, "nettle_base64_encode_raw");
    }
    }
  }
#line 80
  if (! ((unsigned long )out == (unsigned long )dst)) {
    {
    {
#line 80
    __assert_fail("out == dst", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c",
                  80U, "nettle_base64_encode_raw");
    }
    }
  }
#line 81
  return;
}
}
#line 127 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c"
void nettle_base64_encode_group(uint8_t *dst , uint32_t group ) 
{ 
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;

  {
#line 130
  tmp = dst;
#line 130
  dst ++;
#line 130
  *tmp = (uint8_t )encode_table[63U & (group >> 18)];
#line 131
  tmp___0 = dst;
#line 131
  dst ++;
#line 131
  *tmp___0 = (uint8_t )encode_table[63U & (group >> 12)];
#line 132
  tmp___1 = dst;
#line 132
  dst ++;
#line 132
  *tmp___1 = (uint8_t )encode_table[63U & (group >> 6)];
#line 133
  tmp___2 = dst;
#line 133
  dst ++;
#line 133
  *tmp___2 = (uint8_t )encode_table[63U & group];
#line 134
  return;
}
}
#line 136 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c"
void nettle_base64_encode_init(struct base64_encode_ctx *ctx ) 
{ 
  unsigned int tmp ;

  {
#line 139
  tmp = 0U;
#line 139
  ctx->bits = tmp;
#line 139
  ctx->word = tmp;
#line 140
  return;
}
}
#line 143 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c"
unsigned int nettle_base64_encode_single(struct base64_encode_ctx *ctx , uint8_t *dst ,
                                         uint8_t src ) 
{ 
  unsigned int done ;
  unsigned int word ;
  unsigned int bits ;
  unsigned int tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 148
  done = 0U;
#line 149
  word = (ctx->word << 8) | (unsigned int )src;
#line 150
  bits = ctx->bits + 8U;
  {
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 152
    if (! (bits >= 6U)) {
#line 152
      goto while_break;
    }
#line 154
    bits -= 6U;
#line 155
    tmp = done;
#line 155
    done ++;
#line 155
    *(dst + tmp) = (uint8_t )encode_table[63U & (word >> bits)];
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 158
  ctx->bits = bits;
#line 159
  ctx->word = word;
#line 161
  if (! (done <= 2U)) {
    {
    {
#line 161
    __assert_fail("done <= 2", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c",
                  161U, "nettle_base64_encode_single");
    }
    }
  }
#line 163
  return (done);
}
}
#line 168 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c"
unsigned int nettle_base64_encode_update(struct base64_encode_ctx *ctx , uint8_t *dst ,
                                         unsigned int length , uint8_t const   *src ) 
{ 
  unsigned int done ;
  unsigned int left ;
  unsigned int left_over ;
  unsigned int bulk ;
  uint8_t const   *tmp ;
  unsigned int tmp___0 ;
  uint8_t const   *tmp___1 ;
  unsigned int tmp___2 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 174
  done = 0U;
#line 175
  left = length;
  {
  {
#line 179
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 179
    if (ctx->bits) {
#line 179
      if (! left) {
#line 179
        goto while_break;
      }
    } else {
#line 179
      goto while_break;
    }
    {
#line 181
    left --;
#line 182
    tmp = src;
#line 182
    src ++;
    {
#line 182
    tmp___0 = nettle_base64_encode_single(ctx, dst + done, (uint8_t )*tmp);
    }
#line 182
    done += tmp___0;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 185
  left_over = left % 3U;
#line 186
  bulk = left - left_over;
#line 188
  if (bulk) {
#line 190
    if (! (! (bulk % 3U))) {
      {
      {
#line 190
      __assert_fail("!(bulk % 3)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c",
                    190U, "nettle_base64_encode_update");
      }
      }
    }
    {
    {
#line 192
    nettle_base64_encode_raw(dst + done, bulk, src);
    }
#line 193
    done += ((bulk + 2U) / 3U) * 4U;
#line 194
    src += bulk;
#line 195
    left = left_over;
    }
  }
  {
  {
#line 198
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 198
    if (! left) {
#line 198
      goto while_break___0;
    }
    {
#line 200
    left --;
#line 201
    tmp___1 = src;
#line 201
    src ++;
    {
#line 201
    tmp___2 = nettle_base64_encode_single(ctx, dst + done, (uint8_t )*tmp___1);
    }
#line 201
    done += tmp___2;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 204
  if (! (done <= (length * 8U + 4U) / 6U)) {
    {
    {
#line 204
    __assert_fail("done <= (((length) * 8 + 4)/6)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c",
                  204U, "nettle_base64_encode_update");
    }
    }
  }
#line 206
  return (done);
}
}
#line 211 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c"
unsigned int nettle_base64_encode_final(struct base64_encode_ctx *ctx , uint8_t *dst ) 
{ 
  unsigned int done ;
  unsigned int bits ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 215
  done = 0U;
#line 216
  bits = ctx->bits;
#line 218
  if (bits) {
#line 220
    tmp = done;
#line 220
    done ++;
#line 220
    *(dst + tmp) = (uint8_t )encode_table[63U & (ctx->word << (6U - ctx->bits))];
    {
    {
#line 221
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 221
      if (! (bits < 6U)) {
#line 221
        goto while_break;
      }
#line 222
      tmp___0 = done;
#line 222
      done ++;
#line 222
      *(dst + tmp___0) = (uint8_t )'=';
#line 221
      bits += 2U;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 224
    ctx->bits = 0U;
  }
#line 227
  if (! (done <= 3U)) {
    {
    {
#line 227
    __assert_fail("done <= 3", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-encode.c",
                  227U, "nettle_base64_encode_final");
    }
    }
  }
#line 228
  return (done);
}
}
#line 121 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64.h"
int nettle_base64_decode_single(struct base64_decode_ctx *ctx , uint8_t *dst , uint8_t src ) ;
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-decode.c"
static signed char const   decode_table[256]  = 
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-decode.c"
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-2,      (signed char const   )-2,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-2,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-2,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )62, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )63, 
        (signed char const   )52,      (signed char const   )53,      (signed char const   )54,      (signed char const   )55, 
        (signed char const   )56,      (signed char const   )57,      (signed char const   )58,      (signed char const   )59, 
        (signed char const   )60,      (signed char const   )61,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-3,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )1,      (signed char const   )2, 
        (signed char const   )3,      (signed char const   )4,      (signed char const   )5,      (signed char const   )6, 
        (signed char const   )7,      (signed char const   )8,      (signed char const   )9,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )14, 
        (signed char const   )15,      (signed char const   )16,      (signed char const   )17,      (signed char const   )18, 
        (signed char const   )19,      (signed char const   )20,      (signed char const   )21,      (signed char const   )22, 
        (signed char const   )23,      (signed char const   )24,      (signed char const   )25,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )29,      (signed char const   )30,      (signed char const   )31,      (signed char const   )32, 
        (signed char const   )33,      (signed char const   )34,      (signed char const   )35,      (signed char const   )36, 
        (signed char const   )37,      (signed char const   )38,      (signed char const   )39,      (signed char const   )40, 
        (signed char const   )41,      (signed char const   )42,      (signed char const   )43,      (signed char const   )44, 
        (signed char const   )45,      (signed char const   )46,      (signed char const   )47,      (signed char const   )48, 
        (signed char const   )49,      (signed char const   )50,      (signed char const   )51,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-decode.c"
void nettle_base64_decode_init(struct base64_decode_ctx *ctx ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 64
  tmp___0 = 0U;
#line 64
  ctx->padding = tmp___0;
#line 64
  tmp = tmp___0;
#line 64
  ctx->bits = tmp;
#line 64
  ctx->word = tmp;
#line 65
  return;
}
}
#line 67 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-decode.c"
int nettle_base64_decode_single(struct base64_decode_ctx *ctx , uint8_t *dst , uint8_t src ) 
{ 
  int data ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 74
  data = (int )decode_table[src];
#line 95
  if (data == -1) {
#line 95
    goto case_neg_1;
  }
#line 98
  if (data == -2) {
#line 98
    goto case_neg_2;
  }
#line 101
  if (data == -3) {
#line 101
    goto case_neg_3;
  }
#line 78
  goto switch_default;
  switch_default: 
#line 79
  if (data >= 0) {
#line 79
    if (! (data < 64)) {
      {
      {
#line 79
      __assert_fail("data >= 0 && data < 0x40", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-decode.c",
                    79U, "nettle_base64_decode_single");
      }
      }
    }
  } else {
    {
    {
#line 79
    __assert_fail("data >= 0 && data < 0x40", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-decode.c",
                  79U, "nettle_base64_decode_single");
    }
    }
  }
#line 81
  if (ctx->padding) {
#line 82
    return (-1);
  }
#line 84
  ctx->word = (ctx->word << 6) | (unsigned int )data;
#line 85
  ctx->bits += 6U;
#line 87
  if (ctx->bits >= 8U) {
#line 89
    ctx->bits -= 8U;
#line 90
    *(dst + 0) = (uint8_t )(ctx->word >> ctx->bits);
#line 91
    return (1);
  } else {
#line 93
    return (0);
  }
  case_neg_1: 
#line 96
  return (-1);
  case_neg_2: 
#line 99
  return (0);
  case_neg_3: 
#line 103
  if (! ctx->bits) {
#line 104
    return (-1);
  } else
#line 103
  if (ctx->padding > 2U) {
#line 104
    return (-1);
  }
#line 106
  if (ctx->word & (unsigned int )((1 << ctx->bits) - 1)) {
#line 108
    return (-1);
  }
#line 110
  (ctx->padding) ++;
#line 111
  ctx->bits -= 2U;
#line 112
  return (0);

#line 116
  return (0);
}
}
#line 116 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-decode.c"
int nettle_base64_decode_update(struct base64_decode_ctx *ctx , unsigned int *dst_length ,
                                uint8_t *dst , unsigned int src_length , uint8_t const   *src ) 
{ 
  unsigned int done ;
  unsigned int i ;
  int tmp ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 126
  if (! (*dst_length >= ((src_length + 1U) * 6U) / 8U)) {
    {
    {
#line 126
    __assert_fail("*dst_length >= ((((src_length) + 1) * 6) / 8)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-decode.c",
                  126U, "nettle_base64_decode_update");
    }
    }
  }
#line 128
  i = 0U;
#line 128
  done = 0U;
  {
  {
#line 128
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 128
    if (! (i < src_length)) {
#line 128
      goto while_break;
    }
    {
    {
#line 129
    tmp = nettle_base64_decode_single(ctx, dst + done, (uint8_t )*(src + i));
    }
    }
#line 131
    if (tmp == -1) {
#line 131
      goto case_neg_1;
    }
#line 133
    if (tmp == 1) {
#line 133
      goto case_1;
    }
#line 136
    if (tmp == 0) {
#line 136
      goto case_0;
    }
#line 138
    goto switch_default;
    case_neg_1: 
#line 132
    return (0);
    case_1: 
#line 134
    done ++;
    case_0: 
#line 137
    goto switch_break;
    switch_default: 
    {
    {
#line 139
    abort();
    }
    }
    switch_break: 
#line 128
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 142
  if (! (done <= ((src_length + 1U) * 6U) / 8U)) {
    {
    {
#line 142
    __assert_fail("done <= ((((src_length) + 1) * 6) / 8)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-decode.c",
                  142U, "nettle_base64_decode_update");
    }
    }
  }
#line 144
  *dst_length = done;
#line 145
  return (1);
}
}
#line 148 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base64-decode.c"
int nettle_base64_decode_final(struct base64_decode_ctx *ctx ) 
{ 


  {
#line 151
  return (ctx->bits == 0U);
}
}
#line 232 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_armor  const  nettle_base16 ;
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16.h"
void nettle_base16_encode_update(uint8_t *dst , unsigned int length , uint8_t const   *src ) ;
#line 69
void nettle_base16_decode_init(struct base16_decode_ctx *ctx ) ;
#line 87
int nettle_base16_decode_update(struct base16_decode_ctx *ctx , unsigned int *dst_length ,
                                uint8_t *dst , unsigned int src_length , uint8_t const   *src ) ;
#line 95
int nettle_base16_decode_final(struct base16_decode_ctx *ctx ) ;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-meta.c"
static unsigned int base16_encode_length(unsigned int length ) 
{ 


  {
#line 35
  return (length * 2U);
}
}
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-meta.c"
static unsigned int base16_decode_length(unsigned int length ) 
{ 


  {
#line 41
  return ((length + 1U) / 2U);
}
}
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-meta.c"
static void base16_encode_init(void *ctx ) 
{ 


  {
#line 46
  return;
}
}
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-meta.c"
static unsigned int base16_encode_update_wrapper(void *ctx , uint8_t *dst , unsigned int length ,
                                                 uint8_t const   *src ) 
{ 


  {
  {
  {
#line 54
  nettle_base16_encode_update(dst, length, src);
  }
  }
#line 55
  return (length * 2U);
}
}
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-meta.c"
static unsigned int base16_encode_final(void *ctx , uint8_t *dst ) 
{ 


  {
#line 63
  return (0U);
}
}
#line 68 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-meta.c"
struct nettle_armor  const  nettle_base16  = 
#line 68
     {"base16", 0U, (unsigned int )sizeof(struct base16_decode_ctx ), 0U, & base16_encode_init,
    & base16_encode_length, & base16_encode_update_wrapper, & base16_encode_final,
    (void (*)(void *ctx ))(& nettle_base16_decode_init), & base16_decode_length, (int (*)(void *ctx ,
                                                                                          unsigned int *dst_length ,
                                                                                          uint8_t *dst ,
                                                                                          unsigned int src_length ,
                                                                                          uint8_t const   *src ))(& nettle_base16_decode_update),
    (int (*)(void *ctx ))(& nettle_base16_decode_final)};
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16.h"
void nettle_base16_encode_single(uint8_t *dst , uint8_t src ) ;
#line 33 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-encode.c"
static uint8_t const   hex_digits[16]  = 
#line 33 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-encode.c"
  {      (uint8_t const   )'0',      (uint8_t const   )'1',      (uint8_t const   )'2',      (uint8_t const   )'3', 
        (uint8_t const   )'4',      (uint8_t const   )'5',      (uint8_t const   )'6',      (uint8_t const   )'7', 
        (uint8_t const   )'8',      (uint8_t const   )'9',      (uint8_t const   )'a',      (uint8_t const   )'b', 
        (uint8_t const   )'c',      (uint8_t const   )'d',      (uint8_t const   )'e',      (uint8_t const   )'f'};
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-encode.c"
void nettle_base16_encode_single(uint8_t *dst , uint8_t src ) 
{ 


  {
#line 44
  *(dst + 0) = (uint8_t )hex_digits[(int )src / 16 & 15];
#line 45
  *(dst + 1) = (uint8_t )hex_digits[(int )src & 15];
#line 46
  return;
}
}
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-encode.c"
void nettle_base16_encode_update(uint8_t *dst , unsigned int length , uint8_t const   *src ) 
{ 
  unsigned int i ;

  {
#line 56
  i = 0U;
  {
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 56
    if (! (i < length)) {
#line 56
      goto while_break;
    }
    {
    {
#line 57
    nettle_base16_encode_single(dst, (uint8_t )*(src + i));
    }
#line 56
    i ++;
#line 56
    dst += 2;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 58
  return;
}
}
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16.h"
int nettle_base16_decode_single(struct base16_decode_ctx *ctx , uint8_t *dst , uint8_t src ) ;
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-decode.c"
void nettle_base16_decode_init(struct base16_decode_ctx *ctx ) 
{ 
  unsigned int tmp ;

  {
#line 38
  tmp = 0U;
#line 38
  ctx->bits = tmp;
#line 38
  ctx->word = tmp;
#line 39
  return;
}
}
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-decode.c"
static signed char const   hex_decode_table[128]  = 
#line 43
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-2,      (signed char const   )-2,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-2,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-2,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )10,      (signed char const   )11,      (signed char const   )12, 
        (signed char const   )13,      (signed char const   )14,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )10,      (signed char const   )11,      (signed char const   )12, 
        (signed char const   )13,      (signed char const   )14,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-decode.c"
int nettle_base16_decode_single(struct base16_decode_ctx *ctx , uint8_t *dst , uint8_t src ) 
{ 
  int digit ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 65
  if ((int )src >= 128) {
#line 66
    return (-1);
  }
#line 69
  digit = (int )hex_decode_table[src];
#line 72
  if (digit == -1) {
#line 72
    goto case_neg_1;
  }
#line 74
  if (digit == -2) {
#line 74
    goto case_neg_2;
  }
#line 76
  goto switch_default;
  case_neg_1: 
#line 73
  return (-1);
  case_neg_2: 
#line 75
  return (0);
  switch_default: 
#line 77
  if (! (digit >= 0)) {
    {
    {
#line 77
    __assert_fail("digit >= 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-decode.c",
                  77U, "nettle_base16_decode_single");
    }
    }
  }
#line 78
  if (! (digit < 16)) {
    {
    {
#line 78
    __assert_fail("digit < 0x10", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-decode.c",
                  78U, "nettle_base16_decode_single");
    }
    }
  }
#line 80
  if (ctx->bits) {
#line 82
    *dst = (uint8_t )((ctx->word << 4) | (unsigned int )digit);
#line 83
    ctx->bits = 0U;
#line 84
    return (1);
  } else {
#line 88
    ctx->word = (unsigned int )digit;
#line 89
    ctx->bits = 4U;
#line 90
    return (0);
  }

#line 95
  return (0);
}
}
#line 95 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-decode.c"
int nettle_base16_decode_update(struct base16_decode_ctx *ctx , unsigned int *dst_length ,
                                uint8_t *dst , unsigned int src_length , uint8_t const   *src ) 
{ 
  unsigned int done ;
  unsigned int i ;
  int tmp ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 105
  if (! (*dst_length >= (src_length + 1U) / 2U)) {
    {
    {
#line 105
    __assert_fail("*dst_length >= (((src_length) + 1) / 2)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-decode.c",
                  105U, "nettle_base16_decode_update");
    }
    }
  }
#line 107
  i = 0U;
#line 107
  done = 0U;
  {
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 107
    if (! (i < src_length)) {
#line 107
      goto while_break;
    }
    {
    {
#line 108
    tmp = nettle_base16_decode_single(ctx, dst + done, (uint8_t )*(src + i));
    }
    }
#line 110
    if (tmp == -1) {
#line 110
      goto case_neg_1;
    }
#line 112
    if (tmp == 1) {
#line 112
      goto case_1;
    }
#line 115
    if (tmp == 0) {
#line 115
      goto case_0;
    }
#line 117
    goto switch_default;
    case_neg_1: 
#line 111
    return (0);
    case_1: 
#line 113
    done ++;
    case_0: 
#line 116
    goto switch_break;
    switch_default: 
    {
    {
#line 118
    abort();
    }
    }
    switch_break: 
#line 107
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 121
  if (! (done <= (src_length + 1U) / 2U)) {
    {
    {
#line 121
    __assert_fail("done <= (((src_length) + 1) / 2)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-decode.c",
                  121U, "nettle_base16_decode_update");
    }
    }
  }
#line 123
  *dst_length = done;
#line 124
  return (1);
}
}
#line 127 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/base16-decode.c"
int nettle_base16_decode_final(struct base16_decode_ctx *ctx ) 
{ 


  {
#line 130
  return (ctx->bits == 0U);
}
}
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.h"
void nettle_arctwo_set_key_ekb(struct arctwo_ctx *ctx , unsigned int length , uint8_t const   *key ,
                               unsigned int ekb ) ;
#line 59
void nettle_arctwo_set_key(struct arctwo_ctx *ctx , unsigned int length , uint8_t const   *key ) ;
#line 65
void nettle_arctwo_set_key_gutmann(struct arctwo_ctx *ctx , unsigned int length ,
                                   uint8_t const   *key ) ;
#line 69
void nettle_arctwo_encrypt(struct arctwo_ctx *ctx , unsigned int length , uint8_t *dst ,
                           uint8_t const   *src ) ;
#line 72
void nettle_arctwo_decrypt(struct arctwo_ctx *ctx , unsigned int length , uint8_t *dst ,
                           uint8_t const   *src ) ;
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.c"
static uint8_t const   arctwo_sbox[256]  = 
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.c"
  {      (uint8_t const   )217,      (uint8_t const   )120,      (uint8_t const   )249,      (uint8_t const   )196, 
        (uint8_t const   )25,      (uint8_t const   )221,      (uint8_t const   )181,      (uint8_t const   )237, 
        (uint8_t const   )40,      (uint8_t const   )233,      (uint8_t const   )253,      (uint8_t const   )121, 
        (uint8_t const   )74,      (uint8_t const   )160,      (uint8_t const   )216,      (uint8_t const   )157, 
        (uint8_t const   )198,      (uint8_t const   )126,      (uint8_t const   )55,      (uint8_t const   )131, 
        (uint8_t const   )43,      (uint8_t const   )118,      (uint8_t const   )83,      (uint8_t const   )142, 
        (uint8_t const   )98,      (uint8_t const   )76,      (uint8_t const   )100,      (uint8_t const   )136, 
        (uint8_t const   )68,      (uint8_t const   )139,      (uint8_t const   )251,      (uint8_t const   )162, 
        (uint8_t const   )23,      (uint8_t const   )154,      (uint8_t const   )89,      (uint8_t const   )245, 
        (uint8_t const   )135,      (uint8_t const   )179,      (uint8_t const   )79,      (uint8_t const   )19, 
        (uint8_t const   )97,      (uint8_t const   )69,      (uint8_t const   )109,      (uint8_t const   )141, 
        (uint8_t const   )9,      (uint8_t const   )129,      (uint8_t const   )125,      (uint8_t const   )50, 
        (uint8_t const   )189,      (uint8_t const   )143,      (uint8_t const   )64,      (uint8_t const   )235, 
        (uint8_t const   )134,      (uint8_t const   )183,      (uint8_t const   )123,      (uint8_t const   )11, 
        (uint8_t const   )240,      (uint8_t const   )149,      (uint8_t const   )33,      (uint8_t const   )34, 
        (uint8_t const   )92,      (uint8_t const   )107,      (uint8_t const   )78,      (uint8_t const   )130, 
        (uint8_t const   )84,      (uint8_t const   )214,      (uint8_t const   )101,      (uint8_t const   )147, 
        (uint8_t const   )206,      (uint8_t const   )96,      (uint8_t const   )178,      (uint8_t const   )28, 
        (uint8_t const   )115,      (uint8_t const   )86,      (uint8_t const   )192,      (uint8_t const   )20, 
        (uint8_t const   )167,      (uint8_t const   )140,      (uint8_t const   )241,      (uint8_t const   )220, 
        (uint8_t const   )18,      (uint8_t const   )117,      (uint8_t const   )202,      (uint8_t const   )31, 
        (uint8_t const   )59,      (uint8_t const   )190,      (uint8_t const   )228,      (uint8_t const   )209, 
        (uint8_t const   )66,      (uint8_t const   )61,      (uint8_t const   )212,      (uint8_t const   )48, 
        (uint8_t const   )163,      (uint8_t const   )60,      (uint8_t const   )182,      (uint8_t const   )38, 
        (uint8_t const   )111,      (uint8_t const   )191,      (uint8_t const   )14,      (uint8_t const   )218, 
        (uint8_t const   )70,      (uint8_t const   )105,      (uint8_t const   )7,      (uint8_t const   )87, 
        (uint8_t const   )39,      (uint8_t const   )242,      (uint8_t const   )29,      (uint8_t const   )155, 
        (uint8_t const   )188,      (uint8_t const   )148,      (uint8_t const   )67,      (uint8_t const   )3, 
        (uint8_t const   )248,      (uint8_t const   )17,      (uint8_t const   )199,      (uint8_t const   )246, 
        (uint8_t const   )144,      (uint8_t const   )239,      (uint8_t const   )62,      (uint8_t const   )231, 
        (uint8_t const   )6,      (uint8_t const   )195,      (uint8_t const   )213,      (uint8_t const   )47, 
        (uint8_t const   )200,      (uint8_t const   )102,      (uint8_t const   )30,      (uint8_t const   )215, 
        (uint8_t const   )8,      (uint8_t const   )232,      (uint8_t const   )234,      (uint8_t const   )222, 
        (uint8_t const   )128,      (uint8_t const   )82,      (uint8_t const   )238,      (uint8_t const   )247, 
        (uint8_t const   )132,      (uint8_t const   )170,      (uint8_t const   )114,      (uint8_t const   )172, 
        (uint8_t const   )53,      (uint8_t const   )77,      (uint8_t const   )106,      (uint8_t const   )42, 
        (uint8_t const   )150,      (uint8_t const   )26,      (uint8_t const   )210,      (uint8_t const   )113, 
        (uint8_t const   )90,      (uint8_t const   )21,      (uint8_t const   )73,      (uint8_t const   )116, 
        (uint8_t const   )75,      (uint8_t const   )159,      (uint8_t const   )208,      (uint8_t const   )94, 
        (uint8_t const   )4,      (uint8_t const   )24,      (uint8_t const   )164,      (uint8_t const   )236, 
        (uint8_t const   )194,      (uint8_t const   )224,      (uint8_t const   )65,      (uint8_t const   )110, 
        (uint8_t const   )15,      (uint8_t const   )81,      (uint8_t const   )203,      (uint8_t const   )204, 
        (uint8_t const   )36,      (uint8_t const   )145,      (uint8_t const   )175,      (uint8_t const   )80, 
        (uint8_t const   )161,      (uint8_t const   )244,      (uint8_t const   )112,      (uint8_t const   )57, 
        (uint8_t const   )153,      (uint8_t const   )124,      (uint8_t const   )58,      (uint8_t const   )133, 
        (uint8_t const   )35,      (uint8_t const   )184,      (uint8_t const   )180,      (uint8_t const   )122, 
        (uint8_t const   )252,      (uint8_t const   )2,      (uint8_t const   )54,      (uint8_t const   )91, 
        (uint8_t const   )37,      (uint8_t const   )85,      (uint8_t const   )151,      (uint8_t const   )49, 
        (uint8_t const   )45,      (uint8_t const   )93,      (uint8_t const   )250,      (uint8_t const   )152, 
        (uint8_t const   )227,      (uint8_t const   )138,      (uint8_t const   )146,      (uint8_t const   )174, 
        (uint8_t const   )5,      (uint8_t const   )223,      (uint8_t const   )41,      (uint8_t const   )16, 
        (uint8_t const   )103,      (uint8_t const   )108,      (uint8_t const   )186,      (uint8_t const   )201, 
        (uint8_t const   )211,      (uint8_t const   )0,      (uint8_t const   )230,      (uint8_t const   )207, 
        (uint8_t const   )225,      (uint8_t const   )158,      (uint8_t const   )168,      (uint8_t const   )44, 
        (uint8_t const   )99,      (uint8_t const   )22,      (uint8_t const   )1,      (uint8_t const   )63, 
        (uint8_t const   )88,      (uint8_t const   )226,      (uint8_t const   )137,      (uint8_t const   )169, 
        (uint8_t const   )13,      (uint8_t const   )56,      (uint8_t const   )52,      (uint8_t const   )27, 
        (uint8_t const   )171,      (uint8_t const   )51,      (uint8_t const   )255,      (uint8_t const   )176, 
        (uint8_t const   )187,      (uint8_t const   )72,      (uint8_t const   )12,      (uint8_t const   )95, 
        (uint8_t const   )185,      (uint8_t const   )177,      (uint8_t const   )205,      (uint8_t const   )46, 
        (uint8_t const   )197,      (uint8_t const   )243,      (uint8_t const   )219,      (uint8_t const   )71, 
        (uint8_t const   )229,      (uint8_t const   )165,      (uint8_t const   )156,      (uint8_t const   )119, 
        (uint8_t const   )10,      (uint8_t const   )166,      (uint8_t const   )32,      (uint8_t const   )104, 
        (uint8_t const   )254,      (uint8_t const   )127,      (uint8_t const   )193,      (uint8_t const   )173};
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.c"
void nettle_arctwo_encrypt(struct arctwo_ctx *ctx , unsigned int length , uint8_t *dst ,
                           uint8_t const   *src ) 
{ 
  register unsigned int i ;
  uint16_t w0 ;
  uint16_t w1 ;
  uint16_t w2 ;
  uint16_t w3 ;
  register unsigned int j ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 90
  if (! (! (length % 8U))) {
    {
    {
#line 90
    __assert_fail("!((length) % (8))", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.c",
                  90U, "nettle_arctwo_encrypt");
    }
    }
  }
  {
  {
#line 90
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 90
    if (! length) {
#line 90
      goto while_break;
    }
#line 95
    w0 = (uint16_t )(((uint32_t )*((src + 0) + 1) << 8) | (uint32_t )*((src + 0) + 0));
#line 96
    w1 = (uint16_t )(((uint32_t )*((src + 2) + 1) << 8) | (uint32_t )*((src + 2) + 0));
#line 97
    w2 = (uint16_t )(((uint32_t )*((src + 4) + 1) << 8) | (uint32_t )*((src + 4) + 0));
#line 98
    w3 = (uint16_t )(((uint32_t )*((src + 6) + 1) << 8) | (uint32_t )*((src + 6) + 0));
#line 100
    i = 0U;
    {
    {
#line 100
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 100
      if (! (i < 16U)) {
#line 100
        goto while_break___0;
      }
#line 102
      j = i * 4U;
#line 104
      w0 = (uint16_t )((int )w0 + ((((int )w1 & ~ ((int )w3)) + ((int )w2 & (int )w3)) + (int )ctx->S[j]));
#line 105
      w0 = (uint16_t )(((int )w0 << 1) | ((int )w0 >> 15));
#line 107
      w1 = (uint16_t )((int )w1 + ((((int )w2 & ~ ((int )w0)) + ((int )w3 & (int )w0)) + (int )ctx->S[j + 1U]));
#line 108
      w1 = (uint16_t )(((int )w1 << 2) | ((int )w1 >> 14));
#line 110
      w2 = (uint16_t )((int )w2 + ((((int )w3 & ~ ((int )w1)) + ((int )w0 & (int )w1)) + (int )ctx->S[j + 2U]));
#line 111
      w2 = (uint16_t )(((int )w2 << 3) | ((int )w2 >> 13));
#line 113
      w3 = (uint16_t )((int )w3 + ((((int )w0 & ~ ((int )w2)) + ((int )w1 & (int )w2)) + (int )ctx->S[j + 3U]));
#line 114
      w3 = (uint16_t )(((int )w3 << 5) | ((int )w3 >> 11));
#line 116
      if (i == 4U) {
#line 118
        w0 = (uint16_t )((int )w0 + (int )ctx->S[(int )w3 & 63]);
#line 119
        w1 = (uint16_t )((int )w1 + (int )ctx->S[(int )w0 & 63]);
#line 120
        w2 = (uint16_t )((int )w2 + (int )ctx->S[(int )w1 & 63]);
#line 121
        w3 = (uint16_t )((int )w3 + (int )ctx->S[(int )w2 & 63]);
      } else
#line 116
      if (i == 10U) {
#line 118
        w0 = (uint16_t )((int )w0 + (int )ctx->S[(int )w3 & 63]);
#line 119
        w1 = (uint16_t )((int )w1 + (int )ctx->S[(int )w0 & 63]);
#line 120
        w2 = (uint16_t )((int )w2 + (int )ctx->S[(int )w1 & 63]);
#line 121
        w3 = (uint16_t )((int )w3 + (int )ctx->S[(int )w2 & 63]);
      }
#line 100
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: ;
    {
    {
#line 124
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 124
      *((dst + 0) + 1) = (uint8_t )(((int )w0 >> 8) & 255);
#line 124
      *((dst + 0) + 0) = (uint8_t )((int )w0 & 255);
#line 124
      goto while_break___1;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: ;
    {
    {
#line 125
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 125
      *((dst + 2) + 1) = (uint8_t )(((int )w1 >> 8) & 255);
#line 125
      *((dst + 2) + 0) = (uint8_t )((int )w1 & 255);
#line 125
      goto while_break___2;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: ;
    {
    {
#line 126
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 126
      *((dst + 4) + 1) = (uint8_t )(((int )w2 >> 8) & 255);
#line 126
      *((dst + 4) + 0) = (uint8_t )((int )w2 & 255);
#line 126
      goto while_break___3;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: ;
    {
    {
#line 127
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 127
      *((dst + 6) + 1) = (uint8_t )(((int )w3 >> 8) & 255);
#line 127
      *((dst + 6) + 0) = (uint8_t )((int )w3 & 255);
#line 127
      goto while_break___4;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: 
#line 90
    length -= 8U;
#line 90
    dst += 8;
#line 90
    src += 8;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 129
  return;
}
}
#line 131 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.c"
void nettle_arctwo_decrypt(struct arctwo_ctx *ctx , unsigned int length , uint8_t *dst ,
                           uint8_t const   *src ) 
{ 
  register unsigned int i ;
  uint16_t w0 ;
  uint16_t w1 ;
  uint16_t w2 ;
  uint16_t w3 ;
  register unsigned int j ;
  unsigned int tmp ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 135
  if (! (! (length % 8U))) {
    {
    {
#line 135
    __assert_fail("!((length) % (8))", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.c",
                  135U, "nettle_arctwo_decrypt");
    }
    }
  }
  {
  {
#line 135
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 135
    if (! length) {
#line 135
      goto while_break;
    }
#line 140
    w0 = (uint16_t )(((uint32_t )*((src + 0) + 1) << 8) | (uint32_t )*((src + 0) + 0));
#line 141
    w1 = (uint16_t )(((uint32_t )*((src + 2) + 1) << 8) | (uint32_t )*((src + 2) + 0));
#line 142
    w2 = (uint16_t )(((uint32_t )*((src + 4) + 1) << 8) | (uint32_t )*((src + 4) + 0));
#line 143
    w3 = (uint16_t )(((uint32_t )*((src + 6) + 1) << 8) | (uint32_t )*((src + 6) + 0));
#line 145
    i = 16U;
    {
    {
#line 145
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 145
      tmp = i;
#line 145
      i --;
#line 145
      if (! (tmp > 0U)) {
#line 145
        goto while_break___0;
      }
#line 147
      j = i * 4U;
#line 149
      w3 = (uint16_t )(((int )w3 >> 5) | ((int )w3 << 11));
#line 150
      w3 = (uint16_t )((int )w3 - ((((int )w0 & ~ ((int )w2)) + ((int )w1 & (int )w2)) + (int )ctx->S[j + 3U]));
#line 152
      w2 = (uint16_t )(((int )w2 >> 3) | ((int )w2 << 13));
#line 153
      w2 = (uint16_t )((int )w2 - ((((int )w3 & ~ ((int )w1)) + ((int )w0 & (int )w1)) + (int )ctx->S[j + 2U]));
#line 155
      w1 = (uint16_t )(((int )w1 >> 2) | ((int )w1 << 14));
#line 156
      w1 = (uint16_t )((int )w1 - ((((int )w2 & ~ ((int )w0)) + ((int )w3 & (int )w0)) + (int )ctx->S[j + 1U]));
#line 158
      w0 = (uint16_t )(((int )w0 >> 1) | ((int )w0 << 15));
#line 159
      w0 = (uint16_t )((int )w0 - ((((int )w1 & ~ ((int )w3)) + ((int )w2 & (int )w3)) + (int )ctx->S[j]));
#line 161
      if (i == 5U) {
#line 163
        w3 = (uint16_t )((int )w3 - (int )ctx->S[(int )w2 & 63]);
#line 164
        w2 = (uint16_t )((int )w2 - (int )ctx->S[(int )w1 & 63]);
#line 165
        w1 = (uint16_t )((int )w1 - (int )ctx->S[(int )w0 & 63]);
#line 166
        w0 = (uint16_t )((int )w0 - (int )ctx->S[(int )w3 & 63]);
      } else
#line 161
      if (i == 11U) {
#line 163
        w3 = (uint16_t )((int )w3 - (int )ctx->S[(int )w2 & 63]);
#line 164
        w2 = (uint16_t )((int )w2 - (int )ctx->S[(int )w1 & 63]);
#line 165
        w1 = (uint16_t )((int )w1 - (int )ctx->S[(int )w0 & 63]);
#line 166
        w0 = (uint16_t )((int )w0 - (int )ctx->S[(int )w3 & 63]);
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: ;
    {
    {
#line 170
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 170
      *((dst + 0) + 1) = (uint8_t )(((int )w0 >> 8) & 255);
#line 170
      *((dst + 0) + 0) = (uint8_t )((int )w0 & 255);
#line 170
      goto while_break___1;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: ;
    {
    {
#line 171
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 171
      *((dst + 2) + 1) = (uint8_t )(((int )w1 >> 8) & 255);
#line 171
      *((dst + 2) + 0) = (uint8_t )((int )w1 & 255);
#line 171
      goto while_break___2;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: ;
    {
    {
#line 172
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 172
      *((dst + 4) + 1) = (uint8_t )(((int )w2 >> 8) & 255);
#line 172
      *((dst + 4) + 0) = (uint8_t )((int )w2 & 255);
#line 172
      goto while_break___3;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: ;
    {
    {
#line 173
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 173
      *((dst + 6) + 1) = (uint8_t )(((int )w3 >> 8) & 255);
#line 173
      *((dst + 6) + 0) = (uint8_t )((int )w3 & 255);
#line 173
      goto while_break___4;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: 
#line 135
    length -= 8U;
#line 135
    dst += 8;
#line 135
    src += 8;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 175
  return;
}
}
#line 177 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.c"
void nettle_arctwo_set_key_ekb(struct arctwo_ctx *ctx , unsigned int length , uint8_t const   *key ,
                               unsigned int ekb ) 
{ 
  unsigned int i ;
  uint8_t S___0[128] ;
  uint8_t x ;
  int len ;
  unsigned int tmp ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 186
  if (! (length >= 1U)) {
    {
    {
#line 186
    __assert_fail("length >= 1", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.c",
                  186U, "nettle_arctwo_set_key_ekb");
    }
    }
  }
#line 187
  if (! (length <= 128U)) {
    {
    {
#line 187
    __assert_fail("length <= 128", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.c",
                  187U, "nettle_arctwo_set_key_ekb");
    }
    }
  }
#line 188
  if (! (ekb <= 1024U)) {
    {
    {
#line 188
    __assert_fail("ekb <= 1024", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.c",
                  188U, "nettle_arctwo_set_key_ekb");
    }
    }
  }
#line 190
  i = 0U;
  {
  {
#line 190
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 190
    if (! (i < length)) {
#line 190
      goto while_break;
    }
#line 191
    S___0[i] = (uint8_t )*(key + i);
#line 190
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 194
  i = length;
  {
  {
#line 194
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 194
    if (! (i < 128U)) {
#line 194
      goto while_break___0;
    }
#line 195
    S___0[i] = (uint8_t )arctwo_sbox[((int )S___0[i - length] + (int )S___0[i - 1U]) & 255];
#line 194
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 197
  S___0[0] = (uint8_t )arctwo_sbox[S___0[0]];
#line 200
  if (ekb > 0U) {
#line 200
    if (ekb < 1024U) {
#line 202
      len = (int )((ekb + 7U) >> 3);
#line 203
      i = (unsigned int )(128 - len);
#line 204
      x = (uint8_t )arctwo_sbox[(int )S___0[i] & (255 >> (7U & - ekb))];
#line 205
      S___0[i] = x;
      {
      {
#line 207
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 207
        tmp = i;
#line 207
        i --;
#line 207
        if (! tmp) {
#line 207
          goto while_break___1;
        }
#line 209
        x = (uint8_t )arctwo_sbox[(int )x ^ (int )S___0[i + (unsigned int )len]];
#line 210
        S___0[i] = x;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: ;
    }
  }
#line 215
  i = 0U;
  {
  {
#line 215
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;

#line 215
    if (! (i < 64U)) {
#line 215
      goto while_break___2;
    }
#line 216
    ctx->S[i] = (uint16_t )(((uint32_t )*((S___0 + i * 2U) + 1) << 8) | (uint32_t )*((S___0 + i * 2U) + 0));
#line 215
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 217
  return;
}
}
#line 219 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.c"
void nettle_arctwo_set_key(struct arctwo_ctx *ctx , unsigned int length , uint8_t const   *key ) 
{ 


  {
  {
  {
#line 222
  nettle_arctwo_set_key_ekb(ctx, length, key, 8U * length);
  }
  }
#line 223
  return;
}
}
#line 225 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo.c"
void nettle_arctwo_set_key_gutmann(struct arctwo_ctx *ctx , unsigned int length ,
                                   uint8_t const   *key ) 
{ 


  {
  {
  {
#line 229
  nettle_arctwo_set_key_ekb(ctx, length, key, 0U);
  }
  }
#line 230
  return;
}
}
#line 112 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_cipher  const  nettle_arctwo40 ;
#line 113
struct nettle_cipher  const  nettle_arctwo64 ;
#line 114
struct nettle_cipher  const  nettle_arctwo128 ;
#line 115
struct nettle_cipher  const  nettle_arctwo_gutmann128 ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo-meta.c"
struct nettle_cipher  const  nettle_arctwo40  = 
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo-meta.c"
     {"arctwo40", (unsigned int )sizeof(struct arctwo_ctx ), 8U, 5U, (void (*)(void *ctx ,
                                                                             unsigned int length ,
                                                                             uint8_t const   *key ))(& nettle_arctwo_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_arctwo_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_arctwo_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_arctwo_decrypt)};
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo-meta.c"
struct nettle_cipher  const  nettle_arctwo64  = 
#line 34
     {"arctwo64", (unsigned int )sizeof(struct arctwo_ctx ), 8U, 8U, (void (*)(void *ctx ,
                                                                             unsigned int length ,
                                                                             uint8_t const   *key ))(& nettle_arctwo_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_arctwo_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_arctwo_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_arctwo_decrypt)};
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo-meta.c"
struct nettle_cipher  const  nettle_arctwo128  = 
#line 37
     {"arctwo128", (unsigned int )sizeof(struct arctwo_ctx ), 8U, 16U, (void (*)(void *ctx ,
                                                                               unsigned int length ,
                                                                               uint8_t const   *key ))(& nettle_arctwo_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_arctwo_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_arctwo_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_arctwo_decrypt)};
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arctwo-meta.c"
struct nettle_cipher  const  nettle_arctwo_gutmann128  = 
#line 47
     {"arctwo_gutmann128", (unsigned int )sizeof(struct arctwo_ctx ), 8U, 16U, (void (*)(void *ctx ,
                                                                                       unsigned int length ,
                                                                                       uint8_t const   *key ))(& nettle_arctwo_set_key_gutmann),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_arctwo_set_key_gutmann),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_arctwo_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_arctwo_decrypt)};
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arcfour.h"
void nettle_arcfour_set_key(struct arcfour_ctx *ctx , unsigned int length , uint8_t const   *key ) ;
#line 58
void nettle_arcfour_stream(struct arcfour_ctx *ctx , unsigned int length , uint8_t *dst ) ;
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arcfour.c"
void nettle_arcfour_set_key(struct arcfour_ctx *ctx , unsigned int length , uint8_t const   *key ) 
{ 
  unsigned int i ;
  unsigned int j ;
  unsigned int k ;
  int _t ;
  uint8_t tmp ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 42
  if (! (length >= 1U)) {
    {
    {
#line 42
    __assert_fail("length >= 1", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arcfour.c",
                  42U, "nettle_arcfour_set_key");
    }
    }
  }
#line 43
  if (! (length <= 256U)) {
    {
    {
#line 43
    __assert_fail("length <= 256", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arcfour.c",
                  43U, "nettle_arcfour_set_key");
    }
    }
  }
#line 46
  i = 0U;
  {
  {
#line 46
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 46
    if (! (i < 256U)) {
#line 46
      goto while_break;
    }
#line 47
    ctx->S[i] = (uint8_t )i;
#line 46
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 49
  k = 0U;
#line 49
  j = k;
#line 49
  i = j;
  {
  {
#line 49
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 49
    if (! (i < 256U)) {
#line 49
      goto while_break___0;
    }
#line 51
    j += (unsigned int )((int )ctx->S[i] + (int )*(key + k));
#line 51
    j &= 255U;
    {
    {
#line 52
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 52
      _t = (int )ctx->S[i];
#line 52
      ctx->S[i] = ctx->S[j];
#line 52
      ctx->S[j] = (uint8_t )_t;
#line 52
      goto while_break___1;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 54
    k = (k + 1U) % length;
#line 49
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 56
  tmp = (uint8_t )0;
#line 56
  ctx->j = tmp;
#line 56
  ctx->i = tmp;
#line 57
  return;
}
}
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arcfour.c"
void nettle_arcfour_stream(struct arcfour_ctx *ctx , unsigned int length , uint8_t *dst ) 
{ 
  register uint8_t i ;
  register uint8_t j ;
  register int si ;
  register int sj ;
  uint8_t tmp ;
  uint8_t *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 66
  i = ctx->i;
#line 66
  j = ctx->j;
  {
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 67
    tmp___1 = length;
#line 67
    length --;
#line 67
    if (! tmp___1) {
#line 67
      goto while_break;
    }
#line 69
    i = (uint8_t )((int )i + 1);
#line 69
    i = (uint8_t )((int )i & 255);
#line 70
    si = (int )ctx->S[i];
#line 71
    j = (uint8_t )((int )j + si);
#line 71
    j = (uint8_t )((int )j & 255);
#line 72
    tmp = ctx->S[j];
#line 72
    ctx->S[i] = tmp;
#line 72
    sj = (int )tmp;
#line 73
    ctx->S[j] = (uint8_t )si;
#line 74
    tmp___0 = dst;
#line 74
    dst ++;
#line 74
    *tmp___0 = ctx->S[(si + sj) & 255];
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 76
  ctx->i = i;
#line 76
  ctx->j = j;
#line 77
  return;
}
}
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_cipher  const  nettle_arcfour128 ;
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arcfour.h"
extern void nettle_arcfour_crypt(struct arcfour_ctx *ctx , unsigned int length , uint8_t *dst ,
                                 uint8_t const   *src ) ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arcfour-meta.c"
struct nettle_cipher  const  nettle_arcfour128  = 
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/arcfour-meta.c"
     {"arcfour128", (unsigned int )sizeof(struct arcfour_ctx ), 0U, 16U, (void (*)(void *ctx ,
                                                                                 unsigned int length ,
                                                                                 uint8_t const   *key ))(& nettle_arcfour_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_arcfour_set_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_arcfour_crypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_arcfour_crypt)};
#line 93 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-internal.h"
struct aes_table  const  _nettle_aes_encrypt_table ;
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-set-encrypt-key.c"
static unsigned int xtime(unsigned int x ) 
{ 
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 39
  if (! (x < 256U)) {
    {
    {
#line 39
    __assert_fail("x < 0x100", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-set-encrypt-key.c",
                  39U, "xtime");
    }
    }
  }
#line 41
  x <<= 1;
#line 42
  if (x & 256U) {
#line 43
    x ^= 283U;
  }
#line 45
  if (! (x < 256U)) {
    {
    {
#line 45
    __assert_fail("x < 0x100", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-set-encrypt-key.c",
                  45U, "xtime");
    }
    }
  }
#line 47
  return (x);
}
}
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-set-encrypt-key.c"
void nettle_aes_set_encrypt_key(struct aes_ctx *ctx , unsigned int keysize , uint8_t const   *key ) 
{ 
  unsigned int nk ;
  unsigned int nr ;
  unsigned int i ;
  unsigned int lastkey ;
  uint32_t temp ;
  uint32_t rcon ;
  unsigned int tmp ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 57
  if (! (keysize >= 16U)) {
    {
    {
#line 57
    __assert_fail("keysize >= 16", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-set-encrypt-key.c",
                  57U, "nettle_aes_set_encrypt_key");
    }
    }
  }
#line 58
  if (! (keysize <= 32U)) {
    {
    {
#line 58
    __assert_fail("keysize <= 32", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-set-encrypt-key.c",
                  58U, "nettle_aes_set_encrypt_key");
    }
    }
  }
#line 61
  if (keysize == 32U) {
#line 62
    nk = 8U;
#line 63
    nr = 14U;
  } else
#line 64
  if (keysize >= 24U) {
#line 65
    nk = 6U;
#line 66
    nr = 12U;
  } else {
#line 68
    nk = 4U;
#line 69
    nr = 10U;
  }
#line 72
  lastkey = 4U * (nr + 1U);
#line 73
  ctx->nrounds = nr;
#line 74
  rcon = (uint32_t )1;
#line 75
  i = 0U;
  {
  {
#line 75
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 75
    if (! (i < nk)) {
#line 75
      goto while_break;
    }
#line 77
    ctx->keys[i] = (uint32_t )((((int const   )*(key + i * 4U) + ((int const   )*(key + (i * 4U + 1U)) << 8)) + ((int const   )*(key + (i * 4U + 2U)) << 16)) + ((int const   )*(key + (i * 4U + 3U)) << 24));
#line 75
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 81
  i = nk;
  {
  {
#line 81
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 81
    if (! (i < lastkey)) {
#line 81
      goto while_break___0;
    }
#line 83
    temp = ctx->keys[i - 1U];
#line 84
    if (i % nk == 0U) {
      {
#line 86
      temp = (unsigned int )((((int )_nettle_aes_encrypt_table.sbox[((temp >> 8) | ((temp & 255U) << 24)) & 255U] | ((int )_nettle_aes_encrypt_table.sbox[(((temp >> 8) | ((temp & 255U) << 24)) >> 8) & 255U] << 8)) | ((int )_nettle_aes_encrypt_table.sbox[(((temp >> 8) | ((temp & 255U) << 24)) >> 16) & 255U] << 16)) | ((int )_nettle_aes_encrypt_table.sbox[(((temp >> 8) | ((temp & 255U) << 24)) >> 24) & 255U] << 24)) ^ rcon;
      {
#line 87
      tmp = xtime((unsigned int )((int )((uint8_t )rcon) & 255));
      }
#line 87
      rcon = tmp;
      }
    } else
#line 89
    if (nk > 6U) {
#line 89
      if (i % nk == 4U) {
#line 91
        temp = (uint32_t )((((int )_nettle_aes_encrypt_table.sbox[temp & 255U] | ((int )_nettle_aes_encrypt_table.sbox[(temp >> 8) & 255U] << 8)) | ((int )_nettle_aes_encrypt_table.sbox[(temp >> 16) & 255U] << 16)) | ((int )_nettle_aes_encrypt_table.sbox[(temp >> 24) & 255U] << 24));
      }
    }
#line 93
    ctx->keys[i] = ctx->keys[i - nk] ^ temp;
#line 81
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 95
  return;
}
}
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes.h"
void nettle_aes_set_decrypt_key(struct aes_ctx *ctx , unsigned int keysize , uint8_t const   *key ) ;
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-set-decrypt-key.c"
static uint8_t const   gf2_log[256]  = 
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-set-decrypt-key.c"
  {      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )25,      (uint8_t const   )1, 
        (uint8_t const   )50,      (uint8_t const   )2,      (uint8_t const   )26,      (uint8_t const   )198, 
        (uint8_t const   )75,      (uint8_t const   )199,      (uint8_t const   )27,      (uint8_t const   )104, 
        (uint8_t const   )51,      (uint8_t const   )238,      (uint8_t const   )223,      (uint8_t const   )3, 
        (uint8_t const   )100,      (uint8_t const   )4,      (uint8_t const   )224,      (uint8_t const   )14, 
        (uint8_t const   )52,      (uint8_t const   )141,      (uint8_t const   )129,      (uint8_t const   )239, 
        (uint8_t const   )76,      (uint8_t const   )113,      (uint8_t const   )8,      (uint8_t const   )200, 
        (uint8_t const   )248,      (uint8_t const   )105,      (uint8_t const   )28,      (uint8_t const   )193, 
        (uint8_t const   )125,      (uint8_t const   )194,      (uint8_t const   )29,      (uint8_t const   )181, 
        (uint8_t const   )249,      (uint8_t const   )185,      (uint8_t const   )39,      (uint8_t const   )106, 
        (uint8_t const   )77,      (uint8_t const   )228,      (uint8_t const   )166,      (uint8_t const   )114, 
        (uint8_t const   )154,      (uint8_t const   )201,      (uint8_t const   )9,      (uint8_t const   )120, 
        (uint8_t const   )101,      (uint8_t const   )47,      (uint8_t const   )138,      (uint8_t const   )5, 
        (uint8_t const   )33,      (uint8_t const   )15,      (uint8_t const   )225,      (uint8_t const   )36, 
        (uint8_t const   )18,      (uint8_t const   )240,      (uint8_t const   )130,      (uint8_t const   )69, 
        (uint8_t const   )53,      (uint8_t const   )147,      (uint8_t const   )218,      (uint8_t const   )142, 
        (uint8_t const   )150,      (uint8_t const   )143,      (uint8_t const   )219,      (uint8_t const   )189, 
        (uint8_t const   )54,      (uint8_t const   )208,      (uint8_t const   )206,      (uint8_t const   )148, 
        (uint8_t const   )19,      (uint8_t const   )92,      (uint8_t const   )210,      (uint8_t const   )241, 
        (uint8_t const   )64,      (uint8_t const   )70,      (uint8_t const   )131,      (uint8_t const   )56, 
        (uint8_t const   )102,      (uint8_t const   )221,      (uint8_t const   )253,      (uint8_t const   )48, 
        (uint8_t const   )191,      (uint8_t const   )6,      (uint8_t const   )139,      (uint8_t const   )98, 
        (uint8_t const   )179,      (uint8_t const   )37,      (uint8_t const   )226,      (uint8_t const   )152, 
        (uint8_t const   )34,      (uint8_t const   )136,      (uint8_t const   )145,      (uint8_t const   )16, 
        (uint8_t const   )126,      (uint8_t const   )110,      (uint8_t const   )72,      (uint8_t const   )195, 
        (uint8_t const   )163,      (uint8_t const   )182,      (uint8_t const   )30,      (uint8_t const   )66, 
        (uint8_t const   )58,      (uint8_t const   )107,      (uint8_t const   )40,      (uint8_t const   )84, 
        (uint8_t const   )250,      (uint8_t const   )133,      (uint8_t const   )61,      (uint8_t const   )186, 
        (uint8_t const   )43,      (uint8_t const   )121,      (uint8_t const   )10,      (uint8_t const   )21, 
        (uint8_t const   )155,      (uint8_t const   )159,      (uint8_t const   )94,      (uint8_t const   )202, 
        (uint8_t const   )78,      (uint8_t const   )212,      (uint8_t const   )172,      (uint8_t const   )229, 
        (uint8_t const   )243,      (uint8_t const   )115,      (uint8_t const   )167,      (uint8_t const   )87, 
        (uint8_t const   )175,      (uint8_t const   )88,      (uint8_t const   )168,      (uint8_t const   )80, 
        (uint8_t const   )244,      (uint8_t const   )234,      (uint8_t const   )214,      (uint8_t const   )116, 
        (uint8_t const   )79,      (uint8_t const   )174,      (uint8_t const   )233,      (uint8_t const   )213, 
        (uint8_t const   )231,      (uint8_t const   )230,      (uint8_t const   )173,      (uint8_t const   )232, 
        (uint8_t const   )44,      (uint8_t const   )215,      (uint8_t const   )117,      (uint8_t const   )122, 
        (uint8_t const   )235,      (uint8_t const   )22,      (uint8_t const   )11,      (uint8_t const   )245, 
        (uint8_t const   )89,      (uint8_t const   )203,      (uint8_t const   )95,      (uint8_t const   )176, 
        (uint8_t const   )156,      (uint8_t const   )169,      (uint8_t const   )81,      (uint8_t const   )160, 
        (uint8_t const   )127,      (uint8_t const   )12,      (uint8_t const   )246,      (uint8_t const   )111, 
        (uint8_t const   )23,      (uint8_t const   )196,      (uint8_t const   )73,      (uint8_t const   )236, 
        (uint8_t const   )216,      (uint8_t const   )67,      (uint8_t const   )31,      (uint8_t const   )45, 
        (uint8_t const   )164,      (uint8_t const   )118,      (uint8_t const   )123,      (uint8_t const   )183, 
        (uint8_t const   )204,      (uint8_t const   )187,      (uint8_t const   )62,      (uint8_t const   )90, 
        (uint8_t const   )251,      (uint8_t const   )96,      (uint8_t const   )177,      (uint8_t const   )134, 
        (uint8_t const   )59,      (uint8_t const   )82,      (uint8_t const   )161,      (uint8_t const   )108, 
        (uint8_t const   )170,      (uint8_t const   )85,      (uint8_t const   )41,      (uint8_t const   )157, 
        (uint8_t const   )151,      (uint8_t const   )178,      (uint8_t const   )135,      (uint8_t const   )144, 
        (uint8_t const   )97,      (uint8_t const   )190,      (uint8_t const   )220,      (uint8_t const   )252, 
        (uint8_t const   )188,      (uint8_t const   )149,      (uint8_t const   )207,      (uint8_t const   )205, 
        (uint8_t const   )55,      (uint8_t const   )63,      (uint8_t const   )91,      (uint8_t const   )209, 
        (uint8_t const   )83,      (uint8_t const   )57,      (uint8_t const   )132,      (uint8_t const   )60, 
        (uint8_t const   )65,      (uint8_t const   )162,      (uint8_t const   )109,      (uint8_t const   )71, 
        (uint8_t const   )20,      (uint8_t const   )42,      (uint8_t const   )158,      (uint8_t const   )93, 
        (uint8_t const   )86,      (uint8_t const   )242,      (uint8_t const   )211,      (uint8_t const   )171, 
        (uint8_t const   )68,      (uint8_t const   )17,      (uint8_t const   )146,      (uint8_t const   )217, 
        (uint8_t const   )35,      (uint8_t const   )32,      (uint8_t const   )46,      (uint8_t const   )137, 
        (uint8_t const   )180,      (uint8_t const   )124,      (uint8_t const   )184,      (uint8_t const   )38, 
        (uint8_t const   )119,      (uint8_t const   )153,      (uint8_t const   )227,      (uint8_t const   )165, 
        (uint8_t const   )103,      (uint8_t const   )74,      (uint8_t const   )237,      (uint8_t const   )222, 
        (uint8_t const   )197,      (uint8_t const   )49,      (uint8_t const   )254,      (uint8_t const   )24, 
        (uint8_t const   )13,      (uint8_t const   )99,      (uint8_t const   )140,      (uint8_t const   )128, 
        (uint8_t const   )192,      (uint8_t const   )247,      (uint8_t const   )112,      (uint8_t const   )7};
#line 71 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-set-decrypt-key.c"
static uint8_t const   gf2_exp[256]  = 
#line 71
  {      (uint8_t const   )1,      (uint8_t const   )3,      (uint8_t const   )5,      (uint8_t const   )15, 
        (uint8_t const   )17,      (uint8_t const   )51,      (uint8_t const   )85,      (uint8_t const   )255, 
        (uint8_t const   )26,      (uint8_t const   )46,      (uint8_t const   )114,      (uint8_t const   )150, 
        (uint8_t const   )161,      (uint8_t const   )248,      (uint8_t const   )19,      (uint8_t const   )53, 
        (uint8_t const   )95,      (uint8_t const   )225,      (uint8_t const   )56,      (uint8_t const   )72, 
        (uint8_t const   )216,      (uint8_t const   )115,      (uint8_t const   )149,      (uint8_t const   )164, 
        (uint8_t const   )247,      (uint8_t const   )2,      (uint8_t const   )6,      (uint8_t const   )10, 
        (uint8_t const   )30,      (uint8_t const   )34,      (uint8_t const   )102,      (uint8_t const   )170, 
        (uint8_t const   )229,      (uint8_t const   )52,      (uint8_t const   )92,      (uint8_t const   )228, 
        (uint8_t const   )55,      (uint8_t const   )89,      (uint8_t const   )235,      (uint8_t const   )38, 
        (uint8_t const   )106,      (uint8_t const   )190,      (uint8_t const   )217,      (uint8_t const   )112, 
        (uint8_t const   )144,      (uint8_t const   )171,      (uint8_t const   )230,      (uint8_t const   )49, 
        (uint8_t const   )83,      (uint8_t const   )245,      (uint8_t const   )4,      (uint8_t const   )12, 
        (uint8_t const   )20,      (uint8_t const   )60,      (uint8_t const   )68,      (uint8_t const   )204, 
        (uint8_t const   )79,      (uint8_t const   )209,      (uint8_t const   )104,      (uint8_t const   )184, 
        (uint8_t const   )211,      (uint8_t const   )110,      (uint8_t const   )178,      (uint8_t const   )205, 
        (uint8_t const   )76,      (uint8_t const   )212,      (uint8_t const   )103,      (uint8_t const   )169, 
        (uint8_t const   )224,      (uint8_t const   )59,      (uint8_t const   )77,      (uint8_t const   )215, 
        (uint8_t const   )98,      (uint8_t const   )166,      (uint8_t const   )241,      (uint8_t const   )8, 
        (uint8_t const   )24,      (uint8_t const   )40,      (uint8_t const   )120,      (uint8_t const   )136, 
        (uint8_t const   )131,      (uint8_t const   )158,      (uint8_t const   )185,      (uint8_t const   )208, 
        (uint8_t const   )107,      (uint8_t const   )189,      (uint8_t const   )220,      (uint8_t const   )127, 
        (uint8_t const   )129,      (uint8_t const   )152,      (uint8_t const   )179,      (uint8_t const   )206, 
        (uint8_t const   )73,      (uint8_t const   )219,      (uint8_t const   )118,      (uint8_t const   )154, 
        (uint8_t const   )181,      (uint8_t const   )196,      (uint8_t const   )87,      (uint8_t const   )249, 
        (uint8_t const   )16,      (uint8_t const   )48,      (uint8_t const   )80,      (uint8_t const   )240, 
        (uint8_t const   )11,      (uint8_t const   )29,      (uint8_t const   )39,      (uint8_t const   )105, 
        (uint8_t const   )187,      (uint8_t const   )214,      (uint8_t const   )97,      (uint8_t const   )163, 
        (uint8_t const   )254,      (uint8_t const   )25,      (uint8_t const   )43,      (uint8_t const   )125, 
        (uint8_t const   )135,      (uint8_t const   )146,      (uint8_t const   )173,      (uint8_t const   )236, 
        (uint8_t const   )47,      (uint8_t const   )113,      (uint8_t const   )147,      (uint8_t const   )174, 
        (uint8_t const   )233,      (uint8_t const   )32,      (uint8_t const   )96,      (uint8_t const   )160, 
        (uint8_t const   )251,      (uint8_t const   )22,      (uint8_t const   )58,      (uint8_t const   )78, 
        (uint8_t const   )210,      (uint8_t const   )109,      (uint8_t const   )183,      (uint8_t const   )194, 
        (uint8_t const   )93,      (uint8_t const   )231,      (uint8_t const   )50,      (uint8_t const   )86, 
        (uint8_t const   )250,      (uint8_t const   )21,      (uint8_t const   )63,      (uint8_t const   )65, 
        (uint8_t const   )195,      (uint8_t const   )94,      (uint8_t const   )226,      (uint8_t const   )61, 
        (uint8_t const   )71,      (uint8_t const   )201,      (uint8_t const   )64,      (uint8_t const   )192, 
        (uint8_t const   )91,      (uint8_t const   )237,      (uint8_t const   )44,      (uint8_t const   )116, 
        (uint8_t const   )156,      (uint8_t const   )191,      (uint8_t const   )218,      (uint8_t const   )117, 
        (uint8_t const   )159,      (uint8_t const   )186,      (uint8_t const   )213,      (uint8_t const   )100, 
        (uint8_t const   )172,      (uint8_t const   )239,      (uint8_t const   )42,      (uint8_t const   )126, 
        (uint8_t const   )130,      (uint8_t const   )157,      (uint8_t const   )188,      (uint8_t const   )223, 
        (uint8_t const   )122,      (uint8_t const   )142,      (uint8_t const   )137,      (uint8_t const   )128, 
        (uint8_t const   )155,      (uint8_t const   )182,      (uint8_t const   )193,      (uint8_t const   )88, 
        (uint8_t const   )232,      (uint8_t const   )35,      (uint8_t const   )101,      (uint8_t const   )175, 
        (uint8_t const   )234,      (uint8_t const   )37,      (uint8_t const   )111,      (uint8_t const   )177, 
        (uint8_t const   )200,      (uint8_t const   )67,      (uint8_t const   )197,      (uint8_t const   )84, 
        (uint8_t const   )252,      (uint8_t const   )31,      (uint8_t const   )33,      (uint8_t const   )99, 
        (uint8_t const   )165,      (uint8_t const   )244,      (uint8_t const   )7,      (uint8_t const   )9, 
        (uint8_t const   )27,      (uint8_t const   )45,      (uint8_t const   )119,      (uint8_t const   )153, 
        (uint8_t const   )176,      (uint8_t const   )203,      (uint8_t const   )70,      (uint8_t const   )202, 
        (uint8_t const   )69,      (uint8_t const   )207,      (uint8_t const   )74,      (uint8_t const   )222, 
        (uint8_t const   )121,      (uint8_t const   )139,      (uint8_t const   )134,      (uint8_t const   )145, 
        (uint8_t const   )168,      (uint8_t const   )227,      (uint8_t const   )62,      (uint8_t const   )66, 
        (uint8_t const   )198,      (uint8_t const   )81,      (uint8_t const   )243,      (uint8_t const   )14, 
        (uint8_t const   )18,      (uint8_t const   )54,      (uint8_t const   )90,      (uint8_t const   )238, 
        (uint8_t const   )41,      (uint8_t const   )123,      (uint8_t const   )141,      (uint8_t const   )140, 
        (uint8_t const   )143,      (uint8_t const   )138,      (uint8_t const   )133,      (uint8_t const   )148, 
        (uint8_t const   )167,      (uint8_t const   )242,      (uint8_t const   )13,      (uint8_t const   )23, 
        (uint8_t const   )57,      (uint8_t const   )75,      (uint8_t const   )221,      (uint8_t const   )124, 
        (uint8_t const   )132,      (uint8_t const   )151,      (uint8_t const   )162,      (uint8_t const   )253, 
        (uint8_t const   )28,      (uint8_t const   )36,      (uint8_t const   )108,      (uint8_t const   )180, 
        (uint8_t const   )199,      (uint8_t const   )82,      (uint8_t const   )246,      (uint8_t const   )1};
#line 107 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-set-decrypt-key.c"
static unsigned int mult(unsigned int a , unsigned int b ) 
{ 
  int tmp ;

  {
#line 110
  if (a) {
#line 110
    if (b) {
#line 110
      tmp = (int )((int const   )gf2_exp[((int const   )gf2_log[a] + (int const   )gf2_log[b]) % 255]);
    } else {
#line 110
      tmp = (int )((int const   )0);
    }
  } else {
#line 110
    tmp = (int )((int const   )0);
  }
#line 110
  return ((unsigned int )tmp);
}
}
#line 113 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-set-decrypt-key.c"
static void inv_mix_column(uint32_t *a ) 
{ 
  uint8_t c[4][4] ;
  unsigned int i ;
  unsigned int j ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 119
  j = 0U;
  {
  {
#line 119
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 119
    if (! (j < 4U)) {
#line 119
      goto while_break;
    }
#line 121
    i = 0U;
    {
    {
#line 121
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 121
      if (! (i < 4U)) {
#line 121
        goto while_break___0;
      }
      {
      {
#line 123
      tmp = mult(14U, (*(a + j) >> i * 8U) & 255U);
      }
      {
#line 123
      tmp___0 = mult(11U, (*(a + j) >> ((i + 1U) % 4U) * 8U) & 255U);
      }
      {
#line 123
      tmp___1 = mult(13U, (*(a + j) >> ((i + 2U) % 4U) * 8U) & 255U);
      }
      {
#line 123
      tmp___2 = mult(9U, (*(a + j) >> ((i + 3U) % 4U) * 8U) & 255U);
      }
#line 123
      c[j][i] = (uint8_t )(((tmp ^ tmp___0) ^ tmp___1) ^ tmp___2);
#line 121
      i ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 119
    j ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 129
  i = 0U;
  {
  {
#line 129
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;

#line 129
    if (! (i < 4U)) {
#line 129
      goto while_break___1;
    }
#line 131
    *(a + i) = (uint32_t )0;
#line 132
    j = 0U;
    {
    {
#line 132
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;

#line 132
      if (! (j < 4U)) {
#line 132
        goto while_break___2;
      }
#line 133
      *(a + i) |= (unsigned int )((int )c[i][j] << j * 8U);
#line 132
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 129
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 135
  return;
}
}
#line 140 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-set-decrypt-key.c"
void nettle_aes_set_decrypt_key(struct aes_ctx *ctx , unsigned int keysize , uint8_t const   *key ) 
{ 
  unsigned int nkeys ;
  unsigned int i ;
  unsigned int j ;
  unsigned int k ;
  uint32_t t_swap ;

  {
  {
  {
#line 149
  nettle_aes_set_encrypt_key(ctx, keysize, key);
  }
#line 151
  nkeys = 4U * (ctx->nrounds + 1U);
#line 154
  i = 0U;
#line 154
  j = ctx->nrounds * 4U;
  }
  {
  {
#line 154
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 154
    if (! (i < j)) {
#line 154
      goto while_break;
    }
#line 157
    k = 0U;
    {
    {
#line 157
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 157
      if (! (k < 4U)) {
#line 157
        goto while_break___0;
      }
      {
      {
#line 158
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 158
        t_swap = ctx->keys[i + k];
#line 158
        ctx->keys[i + k] = ctx->keys[j + k];
#line 158
        ctx->keys[j + k] = t_swap;
#line 158
        goto while_break___1;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 157
      k ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 154
    i += 4U;
#line 154
    j -= 4U;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 161
  i = 4U;
  {
  {
#line 161
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;

#line 161
    if (! (i < 4U * ctx->nrounds)) {
#line 161
      goto while_break___2;
    }
    {
    {
#line 162
    inv_mix_column(ctx->keys + i);
    }
#line 161
    i += 4U;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 163
  return;
}
}
#line 97 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/nettle-meta.h"
struct nettle_cipher  const  nettle_aes128 ;
#line 98
struct nettle_cipher  const  nettle_aes192 ;
#line 99
struct nettle_cipher  const  nettle_aes256 ;
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes.h"
void nettle_aes_decrypt(struct aes_ctx *ctx , unsigned int length , uint8_t *dst ,
                        uint8_t const   *src ) ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-meta.c"
struct nettle_cipher  const  nettle_aes128  = 
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-meta.c"
     {"aes128", (unsigned int )sizeof(struct aes_ctx ), 16U, 16U, (void (*)(void *ctx ,
                                                                          unsigned int length ,
                                                                          uint8_t const   *key ))(& nettle_aes_set_encrypt_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_aes_set_decrypt_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_aes_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_aes_decrypt)};
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-meta.c"
struct nettle_cipher  const  nettle_aes192  = 
#line 34
     {"aes192", (unsigned int )sizeof(struct aes_ctx ), 16U, 24U, (void (*)(void *ctx ,
                                                                          unsigned int length ,
                                                                          uint8_t const   *key ))(& nettle_aes_set_encrypt_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_aes_set_decrypt_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_aes_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_aes_decrypt)};
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-meta.c"
struct nettle_cipher  const  nettle_aes256  = 
#line 37
     {"aes256", (unsigned int )sizeof(struct aes_ctx ), 16U, 32U, (void (*)(void *ctx ,
                                                                          unsigned int length ,
                                                                          uint8_t const   *key ))(& nettle_aes_set_encrypt_key),
    (void (*)(void *ctx , unsigned int length , uint8_t const   *key ))(& nettle_aes_set_decrypt_key),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_aes_encrypt),
    (void (*)(void *ctx , unsigned int length , uint8_t *dst , uint8_t const   *src ))(& nettle_aes_decrypt)};
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-internal.h"
extern void _nettle_aes_encrypt(struct aes_ctx  const  *ctx , struct aes_table  const  *T ,
                                unsigned int length , uint8_t *dst , uint8_t const   *src ) ;
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-encrypt.c"
void nettle_aes_encrypt(struct aes_ctx *ctx , unsigned int length , uint8_t *dst ,
                        uint8_t const   *src ) 
{ 
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 42
  if (! (! (length % 16U))) {
    {
    {
#line 42
    __assert_fail("!(length % 16)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-encrypt.c",
                  42U, "nettle_aes_encrypt");
    }
    }
  }
  {
  {
#line 43
  _nettle_aes_encrypt((struct aes_ctx  const  *)ctx, & _nettle_aes_encrypt_table,
                      length, dst, src);
  }
  }
#line 45
  return;
}
}
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-encrypt-table.c"
struct aes_table  const  _nettle_aes_encrypt_table  =    {{(uint8_t )99, (uint8_t )124, (uint8_t )119, (uint8_t )123, (uint8_t )242, (uint8_t )107,
     (uint8_t )111, (uint8_t )197, (uint8_t )48, (uint8_t )1, (uint8_t )103, (uint8_t )43,
     (uint8_t )254, (uint8_t )215, (uint8_t )171, (uint8_t )118, (uint8_t )202, (uint8_t )130,
     (uint8_t )201, (uint8_t )125, (uint8_t )250, (uint8_t )89, (uint8_t )71, (uint8_t )240,
     (uint8_t )173, (uint8_t )212, (uint8_t )162, (uint8_t )175, (uint8_t )156, (uint8_t )164,
     (uint8_t )114, (uint8_t )192, (uint8_t )183, (uint8_t )253, (uint8_t )147, (uint8_t )38,
     (uint8_t )54, (uint8_t )63, (uint8_t )247, (uint8_t )204, (uint8_t )52, (uint8_t )165,
     (uint8_t )229, (uint8_t )241, (uint8_t )113, (uint8_t )216, (uint8_t )49, (uint8_t )21,
     (uint8_t )4, (uint8_t )199, (uint8_t )35, (uint8_t )195, (uint8_t )24, (uint8_t )150,
     (uint8_t )5, (uint8_t )154, (uint8_t )7, (uint8_t )18, (uint8_t )128, (uint8_t )226,
     (uint8_t )235, (uint8_t )39, (uint8_t )178, (uint8_t )117, (uint8_t )9, (uint8_t )131,
     (uint8_t )44, (uint8_t )26, (uint8_t )27, (uint8_t )110, (uint8_t )90, (uint8_t )160,
     (uint8_t )82, (uint8_t )59, (uint8_t )214, (uint8_t )179, (uint8_t )41, (uint8_t )227,
     (uint8_t )47, (uint8_t )132, (uint8_t )83, (uint8_t )209, (uint8_t )0, (uint8_t )237,
     (uint8_t )32, (uint8_t )252, (uint8_t )177, (uint8_t )91, (uint8_t )106, (uint8_t )203,
     (uint8_t )190, (uint8_t )57, (uint8_t )74, (uint8_t )76, (uint8_t )88, (uint8_t )207,
     (uint8_t )208, (uint8_t )239, (uint8_t )170, (uint8_t )251, (uint8_t )67, (uint8_t )77,
     (uint8_t )51, (uint8_t )133, (uint8_t )69, (uint8_t )249, (uint8_t )2, (uint8_t )127,
     (uint8_t )80, (uint8_t )60, (uint8_t )159, (uint8_t )168, (uint8_t )81, (uint8_t )163,
     (uint8_t )64, (uint8_t )143, (uint8_t )146, (uint8_t )157, (uint8_t )56, (uint8_t )245,
     (uint8_t )188, (uint8_t )182, (uint8_t )218, (uint8_t )33, (uint8_t )16, (uint8_t )255,
     (uint8_t )243, (uint8_t )210, (uint8_t )205, (uint8_t )12, (uint8_t )19, (uint8_t )236,
     (uint8_t )95, (uint8_t )151, (uint8_t )68, (uint8_t )23, (uint8_t )196, (uint8_t )167,
     (uint8_t )126, (uint8_t )61, (uint8_t )100, (uint8_t )93, (uint8_t )25, (uint8_t )115,
     (uint8_t )96, (uint8_t )129, (uint8_t )79, (uint8_t )220, (uint8_t )34, (uint8_t )42,
     (uint8_t )144, (uint8_t )136, (uint8_t )70, (uint8_t )238, (uint8_t )184, (uint8_t )20,
     (uint8_t )222, (uint8_t )94, (uint8_t )11, (uint8_t )219, (uint8_t )224, (uint8_t )50,
     (uint8_t )58, (uint8_t )10, (uint8_t )73, (uint8_t )6, (uint8_t )36, (uint8_t )92,
     (uint8_t )194, (uint8_t )211, (uint8_t )172, (uint8_t )98, (uint8_t )145, (uint8_t )149,
     (uint8_t )228, (uint8_t )121, (uint8_t )231, (uint8_t )200, (uint8_t )55, (uint8_t )109,
     (uint8_t )141, (uint8_t )213, (uint8_t )78, (uint8_t )169, (uint8_t )108, (uint8_t )86,
     (uint8_t )244, (uint8_t )234, (uint8_t )101, (uint8_t )122, (uint8_t )174, (uint8_t )8,
     (uint8_t )186, (uint8_t )120, (uint8_t )37, (uint8_t )46, (uint8_t )28, (uint8_t )166,
     (uint8_t )180, (uint8_t )198, (uint8_t )232, (uint8_t )221, (uint8_t )116, (uint8_t )31,
     (uint8_t )75, (uint8_t )189, (uint8_t )139, (uint8_t )138, (uint8_t )112, (uint8_t )62,
     (uint8_t )181, (uint8_t )102, (uint8_t )72, (uint8_t )3, (uint8_t )246, (uint8_t )14,
     (uint8_t )97, (uint8_t )53, (uint8_t )87, (uint8_t )185, (uint8_t )134, (uint8_t )193,
     (uint8_t )29, (uint8_t )158, (uint8_t )225, (uint8_t )248, (uint8_t )152, (uint8_t )17,
     (uint8_t )105, (uint8_t )217, (uint8_t )142, (uint8_t )148, (uint8_t )155, (uint8_t )30,
     (uint8_t )135, (uint8_t )233, (uint8_t )206, (uint8_t )85, (uint8_t )40, (uint8_t )223,
     (uint8_t )140, (uint8_t )161, (uint8_t )137, (uint8_t )13, (uint8_t )191, (uint8_t )230,
     (uint8_t )66, (uint8_t )104, (uint8_t )65, (uint8_t )153, (uint8_t )45, (uint8_t )15,
     (uint8_t )176, (uint8_t )84, (uint8_t )187, (uint8_t )22}, {{2774754246U, 2222750968U,
                                                                  2574743534U, 2373680118U,
                                                                  (uint32_t )234025727,
                                                                  3177933782U, 2976870366U,
                                                                  (uint32_t )1422247313,
                                                                  (uint32_t )1345335392,
                                                                  (uint32_t )50397442,
                                                                  2842126286U, (uint32_t )2099981142,
                                                                  (uint32_t )436141799,
                                                                  (uint32_t )1658312629,
                                                                  3870010189U, 2591454956U,
                                                                  (uint32_t )1170918031,
                                                                  2642575903U, (uint32_t )1086966153,
                                                                  2273148410U, (uint32_t )368769775,
                                                                  3948501426U, 3376891790U,
                                                                  (uint32_t )200339707,
                                                                  3970805057U, (uint32_t )1742001331,
                                                                  4255294047U, 3937382213U,
                                                                  3214711843U, 4154762323U,
                                                                  2524082916U, (uint32_t )1539358875,
                                                                  3266819957U, (uint32_t )486407649,
                                                                  2928907069U, (uint32_t )1780885068,
                                                                  (uint32_t )1513502316,
                                                                  (uint32_t )1094664062,
                                                                  (uint32_t )49805301,
                                                                  (uint32_t )1338821763,
                                                                  (uint32_t )1546925160,
                                                                  4104496465U, (uint32_t )887481809,
                                                                  (uint32_t )150073849,
                                                                  2473685474U, (uint32_t )1943591083,
                                                                  (uint32_t )1395732834,
                                                                  (uint32_t )1058346282,
                                                                  (uint32_t )201589768,
                                                                  (uint32_t )1388824469,
                                                                  (uint32_t )1696801606,
                                                                  (uint32_t )1589887901,
                                                                  (uint32_t )672667696,
                                                                  2711000631U, (uint32_t )251987210,
                                                                  3046808111U, (uint32_t )151455502,
                                                                  (uint32_t )907153956,
                                                                  2608889883U, (uint32_t )1038279391,
                                                                  (uint32_t )652995533,
                                                                  (uint32_t )1764173646,
                                                                  3451040383U, 2675275242U,
                                                                  (uint32_t )453576978,
                                                                  2659418909U, (uint32_t )1949051992,
                                                                  (uint32_t )773462580,
                                                                  (uint32_t )756751158,
                                                                  2993581788U, 3998898868U,
                                                                  4221608027U, 4132590244U,
                                                                  (uint32_t )1295727478,
                                                                  (uint32_t )1641469623,
                                                                  3467883389U, (uint32_t )2066295122,
                                                                  (uint32_t )1055122397,
                                                                  (uint32_t )1898917726,
                                                                  2542044179U, 4115878822U,
                                                                  (uint32_t )1758581177,
                                                                  (uint32_t )0, (uint32_t )753790401,
                                                                  (uint32_t )1612718144,
                                                                  (uint32_t )536673507,
                                                                  3367088505U, 3982187446U,
                                                                  3194645204U, (uint32_t )1187761037,
                                                                  3653156455U, (uint32_t )1262041458,
                                                                  3729410708U, 3561770136U,
                                                                  3898103984U, (uint32_t )1255133061,
                                                                  (uint32_t )1808847035,
                                                                  (uint32_t )720367557,
                                                                  3853167183U, (uint32_t )385612781,
                                                                  3309519750U, 3612167578U,
                                                                  (uint32_t )1429418854,
                                                                  2491778321U, 3477423498U,
                                                                  (uint32_t )284817897,
                                                                  (uint32_t )100794884,
                                                                  2172616702U, 4031795360U,
                                                                  (uint32_t )1144798328,
                                                                  3131023141U, 3819481163U,
                                                                  4082192802U, 4272137053U,
                                                                  3225436288U, 2324664069U,
                                                                  2912064063U, 3164445985U,
                                                                  (uint32_t )1211644016,
                                                                  (uint32_t )83228145,
                                                                  3753688163U, 3249976951U,
                                                                  (uint32_t )1977277103,
                                                                  (uint32_t )1663115586,
                                                                  (uint32_t )806359072,
                                                                  (uint32_t )452984805,
                                                                  (uint32_t )250868733,
                                                                  (uint32_t )1842533055,
                                                                  (uint32_t )1288555905,
                                                                  (uint32_t )336333848,
                                                                  (uint32_t )890442534,
                                                                  (uint32_t )804056259,
                                                                  3781124030U, 2727843637U,
                                                                  3427026056U, (uint32_t )957814574,
                                                                  (uint32_t )1472513171,
                                                                  4071073621U, 2189328124U,
                                                                  (uint32_t )1195195770,
                                                                  2892260552U, 3881655738U,
                                                                  (uint32_t )723065138,
                                                                  2507371494U, 2690670784U,
                                                                  2558624025U, 3511635870U,
                                                                  (uint32_t )2145180835,
                                                                  (uint32_t )1713513028,
                                                                  (uint32_t )2116692564,
                                                                  2878378043U, 2206763019U,
                                                                  3393603212U, (uint32_t )703524551,
                                                                  3552098411U, (uint32_t )1007948840,
                                                                  (uint32_t )2044649127,
                                                                  3797835452U, (uint32_t )487262998,
                                                                  (uint32_t )1994120109,
                                                                  (uint32_t )1004593371,
                                                                  (uint32_t )1446130276,
                                                                  (uint32_t )1312438900,
                                                                  (uint32_t )503974420,
                                                                  3679013266U, (uint32_t )168166924,
                                                                  (uint32_t )1814307912,
                                                                  3831258296U, (uint32_t )1573044895,
                                                                  (uint32_t )1859376061,
                                                                  4021070915U, 2791465668U,
                                                                  2828112185U, 2761266481U,
                                                                  (uint32_t )937747667,
                                                                  2339994098U, (uint32_t )854058965,
                                                                  (uint32_t )1137232011,
                                                                  (uint32_t )1496790894,
                                                                  3077402074U, 2358086913U,
                                                                  (uint32_t )1691735473,
                                                                  3528347292U, 3769215305U,
                                                                  3027004632U, 4199962284U,
                                                                  (uint32_t )133494003,
                                                                  (uint32_t )636152527,
                                                                  2942657994U, 2390391540U,
                                                                  3920539207U, (uint32_t )403179536,
                                                                  3585784431U, 2289596656U,
                                                                  (uint32_t )1864705354,
                                                                  (uint32_t )1915629148,
                                                                  (uint32_t )605822008,
                                                                  4054230615U, 3350508659U,
                                                                  (uint32_t )1371981463,
                                                                  (uint32_t )602466507,
                                                                  (uint32_t )2094914977,
                                                                  2624877800U, (uint32_t )555687742,
                                                                  3712699286U, 3703422305U,
                                                                  2257292045U, 2240449039U,
                                                                  2423288032U, (uint32_t )1111375484,
                                                                  3300242801U, 2858837708U,
                                                                  3628615824U, (uint32_t )84083462,
                                                                  (uint32_t )32962295,
                                                                  (uint32_t )302911004,
                                                                  2741068226U, (uint32_t )1597322602,
                                                                  4183250862U, 3501832553U,
                                                                  2441512471U, (uint32_t )1489093017,
                                                                  (uint32_t )656219450,
                                                                  3114180135U, (uint32_t )954327513,
                                                                  (uint32_t )335083755,
                                                                  3013122091U, (uint32_t )856756514,
                                                                  3144247762U, (uint32_t )1893325225,
                                                                  2307821063U, 2811532339U,
                                                                  3063651117U, (uint32_t )572399164,
                                                                  2458355477U, (uint32_t )552200649,
                                                                  (uint32_t )1238290055,
                                                                  4283782570U, (uint32_t )2015897680,
                                                                  (uint32_t )2061492133,
                                                                  2408352771U, 4171342169U,
                                                                  2156497161U, (uint32_t )386731290,
                                                                  3669999461U, (uint32_t )837215959,
                                                                  3326231172U, 3093850320U,
                                                                  3275833730U, 2962856233U,
                                                                  (uint32_t )1999449434,
                                                                  (uint32_t )286199582,
                                                                  3417354363U, 4233385128U,
                                                                  3602627437U, (uint32_t )974525996},
                                                                 {(uint32_t )1667483301,
                                                                  (uint32_t )2088564868,
                                                                  (uint32_t )2004348569,
                                                                  (uint32_t )2071721613,
                                                                  4076011277U, (uint32_t )1802229437,
                                                                  (uint32_t )1869602481,
                                                                  3318059348U, (uint32_t )808476752,
                                                                  (uint32_t )16843267,
                                                                  (uint32_t )1734856361,
                                                                  (uint32_t )724260477,
                                                                  4278118169U, 3621238114U,
                                                                  2880130534U, (uint32_t )1987505306,
                                                                  3402272581U, 2189565853U,
                                                                  3385428288U, (uint32_t )2105408135,
                                                                  4210749205U, (uint32_t )1499050731,
                                                                  (uint32_t )1195871945,
                                                                  4042324747U, 2913812972U,
                                                                  3570709351U, 2728550397U,
                                                                  2947499498U, 2627478463U,
                                                                  2762232823U, (uint32_t )1920132246,
                                                                  3233848155U, 3082253762U,
                                                                  4261273884U, 2475900334U,
                                                                  (uint32_t )640044138,
                                                                  (uint32_t )909536346,
                                                                  (uint32_t )1061125697,
                                                                  4160222466U, 3435955023U,
                                                                  (uint32_t )875849820,
                                                                  2779075060U, 3857043764U,
                                                                  4059166984U, (uint32_t )1903288979,
                                                                  3638078323U, (uint32_t )825320019,
                                                                  (uint32_t )353708607,
                                                                  (uint32_t )67373068,
                                                                  3351745874U, (uint32_t )589514341,
                                                                  3284376926U, (uint32_t )404238376,
                                                                  2526427041U, (uint32_t )84216335,
                                                                  2593796021U, (uint32_t )117902857,
                                                                  (uint32_t )303178806,
                                                                  2155879323U, 3806519101U,
                                                                  3958099238U, (uint32_t )656887401,
                                                                  2998042573U, (uint32_t )1970662047,
                                                                  (uint32_t )151589403,
                                                                  2206408094U, (uint32_t )741103732,
                                                                  (uint32_t )437924910,
                                                                  (uint32_t )454768173,
                                                                  (uint32_t )1852759218,
                                                                  (uint32_t )1515893998,
                                                                  2694863867U, (uint32_t )1381147894,
                                                                  (uint32_t )993752653,
                                                                  3604395873U, 3014884814U,
                                                                  (uint32_t )690573947,
                                                                  3823361342U, (uint32_t )791633521,
                                                                  2223248279U, (uint32_t )1397991157,
                                                                  3520182632U, (uint32_t )0,
                                                                  3991781676U, (uint32_t )538984544,
                                                                  4244431647U, 2981198280U,
                                                                  (uint32_t )1532737261,
                                                                  (uint32_t )1785386174,
                                                                  3419114822U, 3200149465U,
                                                                  (uint32_t )960066123,
                                                                  (uint32_t )1246401758,
                                                                  (uint32_t )1280088276,
                                                                  (uint32_t )1482207464,
                                                                  3486483786U, 3503340395U,
                                                                  4025468202U, 2863288293U,
                                                                  4227591446U, (uint32_t )1128498885,
                                                                  (uint32_t )1296931543,
                                                                  (uint32_t )859006549,
                                                                  2240090516U, (uint32_t )1162185423,
                                                                  4193904912U, (uint32_t )33686534,
                                                                  (uint32_t )2139094657,
                                                                  (uint32_t )1347461360,
                                                                  (uint32_t )1010595908,
                                                                  2678007226U, 2829601763U,
                                                                  (uint32_t )1364304627,
                                                                  2745392638U, (uint32_t )1077969088,
                                                                  2408514954U, 2459058093U,
                                                                  2644320700U, (uint32_t )943222856,
                                                                  4126535940U, 3166462943U,
                                                                  3065411521U, 3671764853U,
                                                                  (uint32_t )555827811,
                                                                  (uint32_t )269492272,
                                                                  4294960410U, 4092853518U,
                                                                  3537026925U, 3452797260U,
                                                                  (uint32_t )202119188,
                                                                  (uint32_t )320022069,
                                                                  3974939439U, (uint32_t )1600110305,
                                                                  2543269282U, (uint32_t )1145342156,
                                                                  (uint32_t )387395129,
                                                                  3301217111U, 2812761586U,
                                                                  (uint32_t )2122251394,
                                                                  (uint32_t )1027439175,
                                                                  (uint32_t )1684326572,
                                                                  (uint32_t )1566423783,
                                                                  (uint32_t )421081643,
                                                                  (uint32_t )1936975509,
                                                                  (uint32_t )1616953504,
                                                                  2172721560U, (uint32_t )1330618065,
                                                                  3705447295U, (uint32_t )572671078,
                                                                  (uint32_t )707417214,
                                                                  2425371563U, 2290617219U,
                                                                  (uint32_t )1179028682,
                                                                  4008625961U, 3099093971U,
                                                                  (uint32_t )336865340,
                                                                  3739133817U, (uint32_t )1583267042,
                                                                  (uint32_t )185275933,
                                                                  3688607094U, 3772832571U,
                                                                  (uint32_t )842163286,
                                                                  (uint32_t )976909390,
                                                                  (uint32_t )168432670,
                                                                  (uint32_t )1229558491,
                                                                  (uint32_t )101059594,
                                                                  (uint32_t )606357612,
                                                                  (uint32_t )1549580516,
                                                                  3267534685U, 3553869166U,
                                                                  2896970735U, (uint32_t )1650640038,
                                                                  2442213800U, 2509582756U,
                                                                  3840201527U, (uint32_t )2038035083,
                                                                  3890730290U, 3368586051U,
                                                                  (uint32_t )926379609,
                                                                  (uint32_t )1835915959,
                                                                  2374828428U, 3587551588U,
                                                                  (uint32_t )1313774802,
                                                                  2846444000U, (uint32_t )1819072692,
                                                                  (uint32_t )1448520954,
                                                                  4109693703U, 3941256997U,
                                                                  (uint32_t )1701169839,
                                                                  (uint32_t )2054878350,
                                                                  2930657257U, (uint32_t )134746136,
                                                                  3132780501U, (uint32_t )2021191816,
                                                                  (uint32_t )623200879,
                                                                  (uint32_t )774790258,
                                                                  (uint32_t )471611428,
                                                                  2795919345U, 3031724999U,
                                                                  3334903633U, 3907570467U,
                                                                  3722289532U, (uint32_t )1953818780,
                                                                  (uint32_t )522141217,
                                                                  (uint32_t )1263245021,
                                                                  3183305180U, 2341145990U,
                                                                  2324303749U, (uint32_t )1886445712,
                                                                  (uint32_t )1044282434,
                                                                  3048567236U, (uint32_t )1718013098,
                                                                  (uint32_t )1212715224,
                                                                  (uint32_t )50529797,
                                                                  4143380225U, (uint32_t )235805714,
                                                                  (uint32_t )1633796771,
                                                                  (uint32_t )892693087,
                                                                  (uint32_t )1465364217,
                                                                  3115936208U, 2256934801U,
                                                                  3250690392U, (uint32_t )488454695,
                                                                  2661164985U, 3789674808U,
                                                                  4177062675U, 2560109491U,
                                                                  (uint32_t )286335539,
                                                                  (uint32_t )1768542907,
                                                                  3654920560U, 2391672713U,
                                                                  2492740519U, 2610638262U,
                                                                  (uint32_t )505297954,
                                                                  2273777042U, 3924412704U,
                                                                  3469641545U, (uint32_t )1431677695,
                                                                  (uint32_t )673730680,
                                                                  3755976058U, 2357986191U,
                                                                  2711706104U, 2307459456U,
                                                                  (uint32_t )218962455,
                                                                  3216991706U, 3873888049U,
                                                                  (uint32_t )1111655622,
                                                                  (uint32_t )1751699640,
                                                                  (uint32_t )1094812355,
                                                                  2576951728U, (uint32_t )757946999,
                                                                  (uint32_t )252648977,
                                                                  2964356043U, (uint32_t )1414834428,
                                                                  3149622742U, (uint32_t )370551866},
                                                                 {(uint32_t )1673962851,
                                                                  (uint32_t )2096661628,
                                                                  (uint32_t )2012125559,
                                                                  (uint32_t )2079755643,
                                                                  4076801522U, (uint32_t )1809235307,
                                                                  (uint32_t )1876865391,
                                                                  3314635973U, (uint32_t )811618352,
                                                                  (uint32_t )16909057,
                                                                  (uint32_t )1741597031,
                                                                  (uint32_t )727088427,
                                                                  4276558334U, 3618988759U,
                                                                  2874009259U, (uint32_t )1995217526,
                                                                  3398387146U, 2183110018U,
                                                                  3381215433U, (uint32_t )2113570685,
                                                                  4209972730U, (uint32_t )1504897881,
                                                                  (uint32_t )1200539975,
                                                                  4042984432U, 2906778797U,
                                                                  3568527316U, 2724199842U,
                                                                  2940594863U, 2619588508U,
                                                                  2756966308U, (uint32_t )1927583346,
                                                                  3231407040U, 3077948087U,
                                                                  4259388669U, 2470293139U,
                                                                  (uint32_t )642542118,
                                                                  (uint32_t )913070646,
                                                                  (uint32_t )1065238847,
                                                                  4160029431U, 3431157708U,
                                                                  (uint32_t )879254580,
                                                                  2773611685U, 3855693029U,
                                                                  4059629809U, (uint32_t )1910674289,
                                                                  3635114968U, (uint32_t )828527409,
                                                                  (uint32_t )355090197,
                                                                  (uint32_t )67636228,
                                                                  3348452039U, (uint32_t )591815971,
                                                                  3281870531U, (uint32_t )405809176,
                                                                  2520228246U, (uint32_t )84545285,
                                                                  2586817946U, (uint32_t )118360327,
                                                                  (uint32_t )304363026,
                                                                  2149292928U, 3806281186U,
                                                                  3956090603U, (uint32_t )659450151,
                                                                  2994720178U, (uint32_t )1978310517,
                                                                  (uint32_t )152181513,
                                                                  2199756419U, (uint32_t )743994412,
                                                                  (uint32_t )439627290,
                                                                  (uint32_t )456535323,
                                                                  (uint32_t )1859957358,
                                                                  (uint32_t )1521806938,
                                                                  2690382752U, (uint32_t )1386542674,
                                                                  (uint32_t )997608763,
                                                                  3602342358U, 3011366579U,
                                                                  (uint32_t )693271337,
                                                                  3822927587U, (uint32_t )794718511,
                                                                  2215876484U, (uint32_t )1403450707,
                                                                  3518589137U, (uint32_t )0,
                                                                  3988860141U, (uint32_t )541089824,
                                                                  4242743292U, 2977548465U,
                                                                  (uint32_t )1538714971,
                                                                  (uint32_t )1792327274,
                                                                  3415033547U, 3194476990U,
                                                                  (uint32_t )963791673,
                                                                  (uint32_t )1251270218,
                                                                  (uint32_t )1285084236,
                                                                  (uint32_t )1487988824,
                                                                  3481619151U, 3501943760U,
                                                                  4022676207U, 2857362858U,
                                                                  4226619131U, (uint32_t )1132905795,
                                                                  (uint32_t )1301993293,
                                                                  (uint32_t )862344499,
                                                                  2232521861U, (uint32_t )1166724933,
                                                                  4192801017U, (uint32_t )33818114,
                                                                  (uint32_t )2147385727,
                                                                  (uint32_t )1352724560,
                                                                  (uint32_t )1014514748,
                                                                  2670049951U, 2823545768U,
                                                                  (uint32_t )1369633617,
                                                                  2740846243U, (uint32_t )1082179648,
                                                                  2399505039U, 2453646738U,
                                                                  2636233885U, (uint32_t )946882616,
                                                                  4126213365U, 3160661948U,
                                                                  3061301686U, 3668932058U,
                                                                  (uint32_t )557998881,
                                                                  (uint32_t )270544912,
                                                                  4293204735U, 4093447923U,
                                                                  3535760850U, 3447803085U,
                                                                  (uint32_t )202904588,
                                                                  (uint32_t )321271059,
                                                                  3972214764U, (uint32_t )1606345055,
                                                                  2536874647U, (uint32_t )1149815876,
                                                                  (uint32_t )388905239,
                                                                  3297990596U, 2807427751U,
                                                                  (uint32_t )2130477694,
                                                                  (uint32_t )1031423805,
                                                                  (uint32_t )1690872932,
                                                                  (uint32_t )1572530013,
                                                                  (uint32_t )422718233,
                                                                  (uint32_t )1944491379,
                                                                  (uint32_t )1623236704,
                                                                  2165938305U, (uint32_t )1335808335,
                                                                  3701702620U, (uint32_t )574907938,
                                                                  (uint32_t )710180394,
                                                                  2419829648U, 2282455944U,
                                                                  (uint32_t )1183631942,
                                                                  4006029806U, 3094074296U,
                                                                  (uint32_t )338181140,
                                                                  3735517662U, (uint32_t )1589437022,
                                                                  (uint32_t )185998603,
                                                                  3685578459U, 3772464096U,
                                                                  (uint32_t )845436466,
                                                                  (uint32_t )980700730,
                                                                  (uint32_t )169090570,
                                                                  (uint32_t )1234361161,
                                                                  (uint32_t )101452294,
                                                                  (uint32_t )608726052,
                                                                  (uint32_t )1555620956,
                                                                  3265224130U, 3552407251U,
                                                                  2890133420U, (uint32_t )1657054818,
                                                                  2436475025U, 2503058581U,
                                                                  3839047652U, (uint32_t )2045938553,
                                                                  3889509095U, 3364570056U,
                                                                  (uint32_t )929978679,
                                                                  (uint32_t )1843050349,
                                                                  2365688973U, 3585172693U,
                                                                  (uint32_t )1318900302,
                                                                  2840191145U, (uint32_t )1826141292,
                                                                  (uint32_t )1454176854,
                                                                  4109567988U, 3939444202U,
                                                                  (uint32_t )1707781989,
                                                                  (uint32_t )2062847610,
                                                                  2923948462U, (uint32_t )135272456,
                                                                  3127891386U, (uint32_t )2029029496,
                                                                  (uint32_t )625635109,
                                                                  (uint32_t )777810478,
                                                                  (uint32_t )473441308,
                                                                  2790781350U, 3027486644U,
                                                                  3331805638U, 3905627112U,
                                                                  3718347997U, (uint32_t )1961401460,
                                                                  (uint32_t )524165407,
                                                                  (uint32_t )1268178251,
                                                                  3177307325U, 2332919435U,
                                                                  2316273034U, (uint32_t )1893765232,
                                                                  (uint32_t )1048330814,
                                                                  3044132021U, (uint32_t )1724688998,
                                                                  (uint32_t )1217452104,
                                                                  (uint32_t )50726147,
                                                                  4143383030U, (uint32_t )236720654,
                                                                  (uint32_t )1640145761,
                                                                  (uint32_t )896163637,
                                                                  (uint32_t )1471084887,
                                                                  3110719673U, 2249691526U,
                                                                  3248052417U, (uint32_t )490350365,
                                                                  2653403550U, 3789109473U,
                                                                  4176155640U, 2553000856U,
                                                                  (uint32_t )287453969,
                                                                  (uint32_t )1775418217,
                                                                  3651760345U, 2382858638U,
                                                                  2486413204U, 2603464347U,
                                                                  (uint32_t )507257374,
                                                                  2266337927U, 3922272489U,
                                                                  3464972750U, (uint32_t )1437269845,
                                                                  (uint32_t )676362280,
                                                                  3752164063U, 2349043596U,
                                                                  2707028129U, 2299101321U,
                                                                  (uint32_t )219813645,
                                                                  3211123391U, 3872862694U,
                                                                  (uint32_t )1115997762,
                                                                  (uint32_t )1758509160,
                                                                  (uint32_t )1099088705,
                                                                  2569646233U, (uint32_t )760903469,
                                                                  (uint32_t )253628687,
                                                                  2960903088U, (uint32_t )1420360788,
                                                                  3144537787U, (uint32_t )371997206},
                                                                 {3332727651U, 4169432188U,
                                                                  4003034999U, 4136467323U,
                                                                  4279104242U, 3602738027U,
                                                                  3736170351U, 2438251973U,
                                                                  (uint32_t )1615867952,
                                                                  (uint32_t )33751297,
                                                                  3467208551U, (uint32_t )1451043627,
                                                                  3877240574U, 3043153879U,
                                                                  (uint32_t )1306962859,
                                                                  3969545846U, 2403715786U,
                                                                  (uint32_t )530416258,
                                                                  2302724553U, 4203183485U,
                                                                  4011195130U, 3001768281U,
                                                                  2395555655U, 4211863792U,
                                                                  (uint32_t )1106029997,
                                                                  3009926356U, (uint32_t )1610457762,
                                                                  (uint32_t )1173008303,
                                                                  (uint32_t )599760028,
                                                                  (uint32_t )1408738468,
                                                                  3835064946U, 2606481600U,
                                                                  (uint32_t )1975695287,
                                                                  3776773629U, (uint32_t )1034851219,
                                                                  (uint32_t )1282024998,
                                                                  (uint32_t )1817851446,
                                                                  (uint32_t )2118205247,
                                                                  4110612471U, 2203045068U,
                                                                  (uint32_t )1750873140,
                                                                  (uint32_t )1374987685,
                                                                  3509904869U, 4178113009U,
                                                                  3801313649U, 2876496088U,
                                                                  (uint32_t )1649619249,
                                                                  (uint32_t )708777237,
                                                                  (uint32_t )135005188,
                                                                  2505230279U, (uint32_t )1181033251,
                                                                  2640233411U, (uint32_t )807933976,
                                                                  (uint32_t )933336726,
                                                                  (uint32_t )168756485,
                                                                  (uint32_t )800430746,
                                                                  (uint32_t )235472647,
                                                                  (uint32_t )607523346,
                                                                  (uint32_t )463175808,
                                                                  3745374946U, 3441880043U,
                                                                  (uint32_t )1315514151,
                                                                  (uint32_t )2144187058,
                                                                  3936318837U, (uint32_t )303761673,
                                                                  (uint32_t )496927619,
                                                                  (uint32_t )1484008492,
                                                                  (uint32_t )875436570,
                                                                  (uint32_t )908925723,
                                                                  3702681198U, 3035519578U,
                                                                  (uint32_t )1543217312,
                                                                  2767606354U, (uint32_t )1984772923,
                                                                  3076642518U, (uint32_t )2110698419,
                                                                  (uint32_t )1383803177,
                                                                  3711886307U, (uint32_t )1584475951,
                                                                  (uint32_t )328696964,
                                                                  2801095507U, 3110654417U,
                                                                  (uint32_t )0, 3240947181U,
                                                                  (uint32_t )1080041504,
                                                                  3810524412U, (uint32_t )2043195825,
                                                                  3069008731U, 3569248874U,
                                                                  2370227147U, (uint32_t )1742323390,
                                                                  (uint32_t )1917532473,
                                                                  2497595978U, 2564049996U,
                                                                  2968016984U, 2236272591U,
                                                                  3144405200U, 3307925487U,
                                                                  (uint32_t )1340451498,
                                                                  3977706491U, 2261074755U,
                                                                  2597801293U, (uint32_t )1716859699,
                                                                  (uint32_t )294946181,
                                                                  2328839493U, 3910203897U,
                                                                  (uint32_t )67502594,
                                                                  4269899647U, 2700103760U,
                                                                  (uint32_t )2017737788,
                                                                  (uint32_t )632987551,
                                                                  (uint32_t )1273211048,
                                                                  2733855057U, (uint32_t )1576969123,
                                                                  2160083008U, (uint32_t )92966799,
                                                                  (uint32_t )1068339858,
                                                                  (uint32_t )566009245,
                                                                  (uint32_t )1883781176,
                                                                  4043634165U, (uint32_t )1675607228,
                                                                  (uint32_t )2009183926,
                                                                  2943736538U, (uint32_t )1113792801,
                                                                  (uint32_t )540020752,
                                                                  3843751935U, 4245615603U,
                                                                  3211645650U, 2169294285U,
                                                                  (uint32_t )403966988,
                                                                  (uint32_t )641012499,
                                                                  3274697964U, 3202441055U,
                                                                  (uint32_t )899848087,
                                                                  2295088196U, (uint32_t )775493399,
                                                                  2472002756U, (uint32_t )1441965991,
                                                                  4236410494U, (uint32_t )2051489085,
                                                                  3366741092U, 3135724893U,
                                                                  (uint32_t )841685273,
                                                                  3868554099U, 3231735904U,
                                                                  (uint32_t )429425025,
                                                                  2664517455U, 2743065820U,
                                                                  (uint32_t )1147544098,
                                                                  (uint32_t )1417554474,
                                                                  (uint32_t )1001099408,
                                                                  (uint32_t )193169544,
                                                                  2362066502U, 3341414126U,
                                                                  (uint32_t )1809037496,
                                                                  (uint32_t )675025940,
                                                                  2809781982U, 3168951902U,
                                                                  (uint32_t )371002123,
                                                                  2910247899U, 3678134496U,
                                                                  (uint32_t )1683370546,
                                                                  (uint32_t )1951283770,
                                                                  (uint32_t )337512970,
                                                                  2463844681U, (uint32_t )201983494,
                                                                  (uint32_t )1215046692,
                                                                  3101973596U, 2673722050U,
                                                                  3178157011U, (uint32_t )1139780780,
                                                                  3299238498U, (uint32_t )967348625,
                                                                  (uint32_t )832869781,
                                                                  3543655652U, 4069226873U,
                                                                  3576883175U, 2336475336U,
                                                                  (uint32_t )1851340599,
                                                                  3669454189U, (uint32_t )25988493,
                                                                  2976175573U, 2631028302U,
                                                                  (uint32_t )1239460265,
                                                                  3635702892U, 2902087254U,
                                                                  4077384948U, 3475368682U,
                                                                  3400492389U, 4102978170U,
                                                                  (uint32_t )1206496942,
                                                                  (uint32_t )270010376,
                                                                  (uint32_t )1876277946,
                                                                  4035475576U, (uint32_t )1248797989,
                                                                  (uint32_t )1550986798,
                                                                  (uint32_t )941890588,
                                                                  (uint32_t )1475454630,
                                                                  (uint32_t )1942467764,
                                                                  2538718918U, 3408128232U,
                                                                  2709315037U, 3902567540U,
                                                                  (uint32_t )1042358047,
                                                                  2531085131U, (uint32_t )1641856445,
                                                                  (uint32_t )226921355,
                                                                  (uint32_t )260409994,
                                                                  3767562352U, (uint32_t )2084716094,
                                                                  (uint32_t )1908716981,
                                                                  3433719398U, 2430093384U,
                                                                  (uint32_t )100991747,
                                                                  4144101110U, (uint32_t )470945294,
                                                                  3265487201U, (uint32_t )1784624437,
                                                                  2935576407U, (uint32_t )1775286713,
                                                                  (uint32_t )395413126,
                                                                  2572730817U, (uint32_t )975641885,
                                                                  (uint32_t )666476190,
                                                                  3644383713U, 3943954680U,
                                                                  (uint32_t )733190296,
                                                                  (uint32_t )573772049,
                                                                  3535497577U, 2842745305U,
                                                                  (uint32_t )126455438,
                                                                  (uint32_t )866620564,
                                                                  (uint32_t )766942107,
                                                                  (uint32_t )1008868894,
                                                                  (uint32_t )361924487,
                                                                  3374377449U, 2269761230U,
                                                                  2868860245U, (uint32_t )1350051880,
                                                                  2776293343U, (uint32_t )59739276,
                                                                  (uint32_t )1509466529,
                                                                  (uint32_t )159418761,
                                                                  (uint32_t )437718285,
                                                                  (uint32_t )1708834751,
                                                                  3610371814U, 2227585602U,
                                                                  3501746280U, 2193834305U,
                                                                  (uint32_t )699439513,
                                                                  (uint32_t )1517759789,
                                                                  (uint32_t )504434447,
                                                                  (uint32_t )2076946608,
                                                                  2835108948U, (uint32_t )1842789307,
                                                                  (uint32_t )742004246}}};
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-internal.h"
extern void _nettle_aes_decrypt(struct aes_ctx  const  *ctx , struct aes_table  const  *T ,
                                unsigned int length , uint8_t *dst , uint8_t const   *src ) ;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-decrypt.c"
static struct aes_table  const  _aes_decrypt_table  =    {{(uint8_t )82, (uint8_t )9, (uint8_t )106, (uint8_t )213, (uint8_t )48, (uint8_t )54,
     (uint8_t )165, (uint8_t )56, (uint8_t )191, (uint8_t )64, (uint8_t )163, (uint8_t )158,
     (uint8_t )129, (uint8_t )243, (uint8_t )215, (uint8_t )251, (uint8_t )124, (uint8_t )227,
     (uint8_t )57, (uint8_t )130, (uint8_t )155, (uint8_t )47, (uint8_t )255, (uint8_t )135,
     (uint8_t )52, (uint8_t )142, (uint8_t )67, (uint8_t )68, (uint8_t )196, (uint8_t )222,
     (uint8_t )233, (uint8_t )203, (uint8_t )84, (uint8_t )123, (uint8_t )148, (uint8_t )50,
     (uint8_t )166, (uint8_t )194, (uint8_t )35, (uint8_t )61, (uint8_t )238, (uint8_t )76,
     (uint8_t )149, (uint8_t )11, (uint8_t )66, (uint8_t )250, (uint8_t )195, (uint8_t )78,
     (uint8_t )8, (uint8_t )46, (uint8_t )161, (uint8_t )102, (uint8_t )40, (uint8_t )217,
     (uint8_t )36, (uint8_t )178, (uint8_t )118, (uint8_t )91, (uint8_t )162, (uint8_t )73,
     (uint8_t )109, (uint8_t )139, (uint8_t )209, (uint8_t )37, (uint8_t )114, (uint8_t )248,
     (uint8_t )246, (uint8_t )100, (uint8_t )134, (uint8_t )104, (uint8_t )152, (uint8_t )22,
     (uint8_t )212, (uint8_t )164, (uint8_t )92, (uint8_t )204, (uint8_t )93, (uint8_t )101,
     (uint8_t )182, (uint8_t )146, (uint8_t )108, (uint8_t )112, (uint8_t )72, (uint8_t )80,
     (uint8_t )253, (uint8_t )237, (uint8_t )185, (uint8_t )218, (uint8_t )94, (uint8_t )21,
     (uint8_t )70, (uint8_t )87, (uint8_t )167, (uint8_t )141, (uint8_t )157, (uint8_t )132,
     (uint8_t )144, (uint8_t )216, (uint8_t )171, (uint8_t )0, (uint8_t )140, (uint8_t )188,
     (uint8_t )211, (uint8_t )10, (uint8_t )247, (uint8_t )228, (uint8_t )88, (uint8_t )5,
     (uint8_t )184, (uint8_t )179, (uint8_t )69, (uint8_t )6, (uint8_t )208, (uint8_t )44,
     (uint8_t )30, (uint8_t )143, (uint8_t )202, (uint8_t )63, (uint8_t )15, (uint8_t )2,
     (uint8_t )193, (uint8_t )175, (uint8_t )189, (uint8_t )3, (uint8_t )1, (uint8_t )19,
     (uint8_t )138, (uint8_t )107, (uint8_t )58, (uint8_t )145, (uint8_t )17, (uint8_t )65,
     (uint8_t )79, (uint8_t )103, (uint8_t )220, (uint8_t )234, (uint8_t )151, (uint8_t )242,
     (uint8_t )207, (uint8_t )206, (uint8_t )240, (uint8_t )180, (uint8_t )230, (uint8_t )115,
     (uint8_t )150, (uint8_t )172, (uint8_t )116, (uint8_t )34, (uint8_t )231, (uint8_t )173,
     (uint8_t )53, (uint8_t )133, (uint8_t )226, (uint8_t )249, (uint8_t )55, (uint8_t )232,
     (uint8_t )28, (uint8_t )117, (uint8_t )223, (uint8_t )110, (uint8_t )71, (uint8_t )241,
     (uint8_t )26, (uint8_t )113, (uint8_t )29, (uint8_t )41, (uint8_t )197, (uint8_t )137,
     (uint8_t )111, (uint8_t )183, (uint8_t )98, (uint8_t )14, (uint8_t )170, (uint8_t )24,
     (uint8_t )190, (uint8_t )27, (uint8_t )252, (uint8_t )86, (uint8_t )62, (uint8_t )75,
     (uint8_t )198, (uint8_t )210, (uint8_t )121, (uint8_t )32, (uint8_t )154, (uint8_t )219,
     (uint8_t )192, (uint8_t )254, (uint8_t )120, (uint8_t )205, (uint8_t )90, (uint8_t )244,
     (uint8_t )31, (uint8_t )221, (uint8_t )168, (uint8_t )51, (uint8_t )136, (uint8_t )7,
     (uint8_t )199, (uint8_t )49, (uint8_t )177, (uint8_t )18, (uint8_t )16, (uint8_t )89,
     (uint8_t )39, (uint8_t )128, (uint8_t )236, (uint8_t )95, (uint8_t )96, (uint8_t )81,
     (uint8_t )127, (uint8_t )169, (uint8_t )25, (uint8_t )181, (uint8_t )74, (uint8_t )13,
     (uint8_t )45, (uint8_t )229, (uint8_t )122, (uint8_t )159, (uint8_t )147, (uint8_t )201,
     (uint8_t )156, (uint8_t )239, (uint8_t )160, (uint8_t )224, (uint8_t )59, (uint8_t )77,
     (uint8_t )174, (uint8_t )42, (uint8_t )245, (uint8_t )176, (uint8_t )200, (uint8_t )235,
     (uint8_t )187, (uint8_t )60, (uint8_t )131, (uint8_t )83, (uint8_t )153, (uint8_t )97,
     (uint8_t )23, (uint8_t )43, (uint8_t )4, (uint8_t )126, (uint8_t )186, (uint8_t )119,
     (uint8_t )214, (uint8_t )38, (uint8_t )225, (uint8_t )105, (uint8_t )20, (uint8_t )99,
     (uint8_t )85, (uint8_t )33, (uint8_t )12, (uint8_t )125}, {{(uint32_t )1353184337,
                                                                 (uint32_t )1399144830,
                                                                 3282310938U, 2522752826U,
                                                                 3412831035U, 4047871263U,
                                                                 2874735276U, 2466505547U,
                                                                 (uint32_t )1442459680,
                                                                 4134368941U, 2440481928U,
                                                                 (uint32_t )625738485,
                                                                 4242007375U, 3620416197U,
                                                                 2151953702U, 2409849525U,
                                                                 (uint32_t )1230680542,
                                                                 (uint32_t )1729870373,
                                                                 2551114309U, 3787521629U,
                                                                 (uint32_t )41234371,
                                                                 (uint32_t )317738113,
                                                                 2744600205U, 3338261355U,
                                                                 3881799427U, 2510066197U,
                                                                 3950669247U, 3663286933U,
                                                                 (uint32_t )763608788,
                                                                 3542185048U, (uint32_t )694804553,
                                                                 (uint32_t )1154009486,
                                                                 (uint32_t )1787413109,
                                                                 (uint32_t )2021232372,
                                                                 (uint32_t )1799248025,
                                                                 3715217703U, 3058688446U,
                                                                 (uint32_t )397248752,
                                                                 (uint32_t )1722556617,
                                                                 3023752829U, (uint32_t )407560035,
                                                                 2184256229U, (uint32_t )1613975959,
                                                                 (uint32_t )1165972322,
                                                                 3765920945U, 2226023355U,
                                                                 (uint32_t )480281086,
                                                                 2485848313U, (uint32_t )1483229296,
                                                                 (uint32_t )436028815,
                                                                 2272059028U, 3086515026U,
                                                                 (uint32_t )601060267,
                                                                 3791801202U, (uint32_t )1468997603,
                                                                 (uint32_t )715871590,
                                                                 (uint32_t )120122290,
                                                                 (uint32_t )63092015,
                                                                 2591802758U, 2768779219U,
                                                                 4068943920U, 2997206819U,
                                                                 3127509762U, (uint32_t )1552029421,
                                                                 (uint32_t )723308426,
                                                                 2461301159U, 4042393587U,
                                                                 2715969870U, 3455375973U,
                                                                 3586000134U, (uint32_t )526529745,
                                                                 2331944644U, 2639474228U,
                                                                 2689987490U, (uint32_t )853641733,
                                                                 (uint32_t )1978398372,
                                                                 (uint32_t )971801355,
                                                                 2867814464U, (uint32_t )111112542,
                                                                 (uint32_t )1360031421,
                                                                 4186579262U, (uint32_t )1023860118,
                                                                 2919579357U, (uint32_t )1186850381,
                                                                 3045938321U, (uint32_t )90031217,
                                                                 (uint32_t )1876166148,
                                                                 4279586912U, (uint32_t )620468249,
                                                                 2548678102U, 3426959497U,
                                                                 (uint32_t )2006899047,
                                                                 3175278768U, 2290845959U,
                                                                 (uint32_t )945494503,
                                                                 3689859193U, (uint32_t )1191869601,
                                                                 3910091388U, 3374220536U,
                                                                 (uint32_t )0, 2206629897U,
                                                                 (uint32_t )1223502642,
                                                                 2893025566U, (uint32_t )1316117100,
                                                                 4227796733U, (uint32_t )1446544655,
                                                                 (uint32_t )517320253,
                                                                 (uint32_t )658058550,
                                                                 (uint32_t )1691946762,
                                                                 (uint32_t )564550760,
                                                                 3511966619U, (uint32_t )976107044,
                                                                 2976320012U, (uint32_t )266819475,
                                                                 3533106868U, 2660342555U,
                                                                 (uint32_t )1338359936,
                                                                 2720062561U, (uint32_t )1766553434,
                                                                 (uint32_t )370807324,
                                                                 (uint32_t )179999714,
                                                                 3844776128U, (uint32_t )1138762300,
                                                                 (uint32_t )488053522,
                                                                 (uint32_t )185403662,
                                                                 2915535858U, 3114841645U,
                                                                 3366526484U, 2233069911U,
                                                                 (uint32_t )1275557295,
                                                                 3151862254U, 4250959779U,
                                                                 2670068215U, 3170202204U,
                                                                 3309004356U, (uint32_t )880737115,
                                                                 (uint32_t )1982415755,
                                                                 3703972811U, (uint32_t )1761406390,
                                                                 (uint32_t )1676797112,
                                                                 3403428311U, (uint32_t )277177154,
                                                                 (uint32_t )1076008723,
                                                                 (uint32_t )538035844,
                                                                 (uint32_t )2099530373,
                                                                 4164795346U, (uint32_t )288553390,
                                                                 (uint32_t )1839278535,
                                                                 (uint32_t )1261411869,
                                                                 4080055004U, 3964831245U,
                                                                 3504587127U, (uint32_t )1813426987,
                                                                 2579067049U, 4199060497U,
                                                                 (uint32_t )577038663,
                                                                 3297574056U, (uint32_t )440397984,
                                                                 3626794326U, 4019204898U,
                                                                 3343796615U, 3251714265U,
                                                                 4272081548U, (uint32_t )906744984,
                                                                 3481400742U, (uint32_t )685669029,
                                                                 (uint32_t )646887386,
                                                                 2764025151U, 3835509292U,
                                                                 (uint32_t )227702864,
                                                                 2613862250U, (uint32_t )1648787028,
                                                                 3256061430U, 3904428176U,
                                                                 (uint32_t )1593260334,
                                                                 4121936770U, 3196083615U,
                                                                 (uint32_t )2090061929,
                                                                 2838353263U, 3004310991U,
                                                                 (uint32_t )999926984,
                                                                 2809993232U, (uint32_t )1852021992,
                                                                 (uint32_t )2075868123,
                                                                 (uint32_t )158869197,
                                                                 4095236462U, (uint32_t )28809964,
                                                                 2828685187U, (uint32_t )1701746150,
                                                                 (uint32_t )2129067946,
                                                                 (uint32_t )147831841,
                                                                 3873969647U, 3650873274U,
                                                                 3459673930U, 3557400554U,
                                                                 3598495785U, 2947720241U,
                                                                 (uint32_t )824393514,
                                                                 (uint32_t )815048134,
                                                                 3227951669U, (uint32_t )935087732,
                                                                 2798289660U, 2966458592U,
                                                                 (uint32_t )366520115,
                                                                 (uint32_t )1251476721,
                                                                 4158319681U, (uint32_t )240176511,
                                                                 (uint32_t )804688151,
                                                                 2379631990U, (uint32_t )1303441219,
                                                                 (uint32_t )1414376140,
                                                                 3741619940U, 3820343710U,
                                                                 (uint32_t )461924940,
                                                                 3089050817U, (uint32_t )2136040774,
                                                                 (uint32_t )82468509,
                                                                 (uint32_t )1563790337,
                                                                 (uint32_t )1937016826,
                                                                 (uint32_t )776014843,
                                                                 (uint32_t )1511876531,
                                                                 (uint32_t )1389550482,
                                                                 (uint32_t )861278441,
                                                                 (uint32_t )323475053,
                                                                 2355222426U, (uint32_t )2047648055,
                                                                 2383738969U, 2302415851U,
                                                                 3995576782U, (uint32_t )902390199,
                                                                 3991215329U, (uint32_t )1018251130,
                                                                 (uint32_t )1507840668,
                                                                 (uint32_t )1064563285,
                                                                 (uint32_t )2043548696,
                                                                 3208103795U, 3939366739U,
                                                                 (uint32_t )1537932639,
                                                                 (uint32_t )342834655,
                                                                 2262516856U, 2180231114U,
                                                                 (uint32_t )1053059257,
                                                                 (uint32_t )741614648,
                                                                 (uint32_t )1598071746,
                                                                 (uint32_t )1925389590,
                                                                 (uint32_t )203809468,
                                                                 2336832552U, (uint32_t )1100287487,
                                                                 (uint32_t )1895934009,
                                                                 3736275976U, 2632234200U,
                                                                 2428589668U, (uint32_t )1636092795,
                                                                 (uint32_t )1890988757,
                                                                 (uint32_t )1952214088,
                                                                 (uint32_t )1113045200},
                                                                {2817806672U, (uint32_t )1698790995,
                                                                 2752977603U, (uint32_t )1579629206,
                                                                 (uint32_t )1806384075,
                                                                 (uint32_t )1167925233,
                                                                 (uint32_t )1492823211,
                                                                 (uint32_t )65227667,
                                                                 4197458005U, (uint32_t )1836494326,
                                                                 (uint32_t )1993115793,
                                                                 (uint32_t )1275262245,
                                                                 3622129660U, 3408578007U,
                                                                 (uint32_t )1144333952,
                                                                 2741155215U, (uint32_t )1521606217,
                                                                 (uint32_t )465184103,
                                                                 (uint32_t )250234264,
                                                                 3237895649U, (uint32_t )1966064386,
                                                                 4031545618U, 2537983395U,
                                                                 4191382470U, (uint32_t )1603208167,
                                                                 2626819477U, (uint32_t )2054012907,
                                                                 (uint32_t )1498584538,
                                                                 2210321453U, (uint32_t )561273043,
                                                                 (uint32_t )1776306473,
                                                                 3368652356U, 2311222634U,
                                                                 (uint32_t )2039411832,
                                                                 (uint32_t )1045993835,
                                                                 (uint32_t )1907959773,
                                                                 (uint32_t )1340194486,
                                                                 2911432727U, 2887829862U,
                                                                 (uint32_t )986611124,
                                                                 (uint32_t )1256153880,
                                                                 (uint32_t )823846274,
                                                                 (uint32_t )860985184,
                                                                 (uint32_t )2136171077,
                                                                 (uint32_t )2003087840,
                                                                 2926295940U, 2692873756U,
                                                                 (uint32_t )722008468,
                                                                 (uint32_t )1749577816,
                                                                 4249194265U, (uint32_t )1826526343,
                                                                 4168831671U, 3547573027U,
                                                                 (uint32_t )38499042,
                                                                 2401231703U, 2874500650U,
                                                                 (uint32_t )686535175,
                                                                 3266653955U, (uint32_t )2076542618,
                                                                 (uint32_t )137876389,
                                                                 2267558130U, 2780767154U,
                                                                 (uint32_t )1778582202,
                                                                 2182540636U, (uint32_t )483363371,
                                                                 3027871634U, 4060607472U,
                                                                 3798552225U, 4107953613U,
                                                                 3188000469U, (uint32_t )1647628575,
                                                                 4272342154U, (uint32_t )1395537053,
                                                                 (uint32_t )1442030240,
                                                                 3783918898U, 3958809717U,
                                                                 3968011065U, 4016062634U,
                                                                 2675006982U, (uint32_t )275692881,
                                                                 2317434617U, (uint32_t )115185213,
                                                                 (uint32_t )88006062,
                                                                 3185986886U, 2371129781U,
                                                                 (uint32_t )1573155077,
                                                                 3557164143U, (uint32_t )357589247,
                                                                 4221049124U, 3921532567U,
                                                                 (uint32_t )1128303052,
                                                                 2665047927U, (uint32_t )1122545853,
                                                                 2341013384U, (uint32_t )1528424248,
                                                                 4006115803U, (uint32_t )175939911,
                                                                 (uint32_t )256015593,
                                                                 (uint32_t )512030921,
                                                                 (uint32_t )0, 2256537987U,
                                                                 3979031112U, (uint32_t )1880170156,
                                                                 (uint32_t )1918528590,
                                                                 4279172603U, (uint32_t )948244310,
                                                                 3584965918U, (uint32_t )959264295,
                                                                 3641641572U, 2791073825U,
                                                                 (uint32_t )1415289809,
                                                                 (uint32_t )775300154,
                                                                 (uint32_t )1728711857,
                                                                 3881276175U, 2532226258U,
                                                                 2442861470U, 3317727311U,
                                                                 (uint32_t )551313826,
                                                                 (uint32_t )1266113129,
                                                                 (uint32_t )437394454,
                                                                 3130253834U, (uint32_t )715178213,
                                                                 3760340035U, (uint32_t )387650077,
                                                                 (uint32_t )218697227,
                                                                 3347837613U, 2830511545U,
                                                                 2837320904U, (uint32_t )435246981,
                                                                 (uint32_t )125153100,
                                                                 3717852859U, (uint32_t )1618977789,
                                                                 (uint32_t )637663135,
                                                                 4117912764U, (uint32_t )996558021,
                                                                 (uint32_t )2130402100,
                                                                 (uint32_t )692292470,
                                                                 3324234716U, 4243437160U,
                                                                 4058298467U, 3694254026U,
                                                                 2237874704U, (uint32_t )580326208,
                                                                 (uint32_t )298222624,
                                                                 (uint32_t )608863613,
                                                                 (uint32_t )1035719416,
                                                                 (uint32_t )855223825,
                                                                 2703869805U, (uint32_t )798891339,
                                                                 (uint32_t )817028339,
                                                                 (uint32_t )1384517100,
                                                                 3821107152U, (uint32_t )380840812,
                                                                 3111168409U, (uint32_t )1217663482,
                                                                 (uint32_t )1693009698,
                                                                 2365368516U, (uint32_t )1072734234,
                                                                 (uint32_t )746411736,
                                                                 2419270383U, (uint32_t )1313441735,
                                                                 3510163905U, 2731183358U,
                                                                 (uint32_t )198481974,
                                                                 2180359887U, 3732579624U,
                                                                 2394413606U, 3215802276U,
                                                                 2637835492U, 2457358349U,
                                                                 3428805275U, (uint32_t )1182684258,
                                                                 (uint32_t )328070850,
                                                                 3101200616U, 4147719774U,
                                                                 2948825845U, 2153619390U,
                                                                 2479909244U, (uint32_t )768962473,
                                                                 (uint32_t )304467891,
                                                                 2578237499U, (uint32_t )2098729127,
                                                                 (uint32_t )1671227502,
                                                                 3141262203U, (uint32_t )2015808777,
                                                                 (uint32_t )408514292,
                                                                 3080383489U, 2588902312U,
                                                                 (uint32_t )1855317605,
                                                                 3875515006U, 3485212936U,
                                                                 3893751782U, 2615655129U,
                                                                 (uint32_t )913263310,
                                                                 (uint32_t )161475284,
                                                                 (uint32_t )2091919830,
                                                                 2997105071U, (uint32_t )591342129,
                                                                 2493892144U, (uint32_t )1721906624,
                                                                 3159258167U, 3397581990U,
                                                                 3499155632U, 3634836245U,
                                                                 2550460746U, 3672916471U,
                                                                 (uint32_t )1355644686,
                                                                 4136703791U, 3595400845U,
                                                                 2968470349U, (uint32_t )1303039060,
                                                                 (uint32_t )76997855,
                                                                 3050413795U, 2288667675U,
                                                                 (uint32_t )523026872,
                                                                 (uint32_t )1365591679,
                                                                 3932069124U, (uint32_t )898367837,
                                                                 (uint32_t )1955068531,
                                                                 (uint32_t )1091304238,
                                                                 (uint32_t )493335386,
                                                                 3537605202U, (uint32_t )1443948851,
                                                                 (uint32_t )1205234963,
                                                                 (uint32_t )1641519756,
                                                                 (uint32_t )211892090,
                                                                 (uint32_t )351820174,
                                                                 (uint32_t )1007938441,
                                                                 (uint32_t )665439982,
                                                                 3378624309U, 3843875309U,
                                                                 2974251580U, 3755121753U,
                                                                 (uint32_t )1945261375,
                                                                 3457423481U, (uint32_t )935818175,
                                                                 3455538154U, 2868731739U,
                                                                 (uint32_t )1866325780,
                                                                 3678697606U, 4088384129U,
                                                                 3295197502U, (uint32_t )874788908,
                                                                 (uint32_t )1084473951,
                                                                 3273463410U, (uint32_t )635616268,
                                                                 (uint32_t )1228679307,
                                                                 2500722497U, (uint32_t )27801969,
                                                                 3003910366U, 3837057180U,
                                                                 3243664528U, 2227927905U,
                                                                 3056784752U, (uint32_t )1550600308,
                                                                 (uint32_t )1471729730},
                                                                {4098969767U, (uint32_t )1098797925,
                                                                 (uint32_t )387629988,
                                                                 (uint32_t )658151006,
                                                                 2872822635U, 2636116293U,
                                                                 4205620056U, 3813380867U,
                                                                 (uint32_t )807425530,
                                                                 (uint32_t )1991112301,
                                                                 3431502198U, (uint32_t )49620300,
                                                                 3847224535U, (uint32_t )717608907,
                                                                 (uint32_t )891715652,
                                                                 (uint32_t )1656065955,
                                                                 2984135002U, 3123013403U,
                                                                 3930429454U, 4267565504U,
                                                                 (uint32_t )801309301,
                                                                 (uint32_t )1283527408,
                                                                 (uint32_t )1183687575,
                                                                 3547055865U, 2399397727U,
                                                                 2450888092U, (uint32_t )1841294202,
                                                                 (uint32_t )1385552473,
                                                                 3201576323U, (uint32_t )1951978273,
                                                                 3762891113U, 3381544136U,
                                                                 3262474889U, 2398386297U,
                                                                 (uint32_t )1486449470,
                                                                 3106397553U, 3787372111U,
                                                                 2297436077U, (uint32_t )550069932,
                                                                 3464344634U, 3747813450U,
                                                                 (uint32_t )451248689,
                                                                 (uint32_t )1368875059,
                                                                 (uint32_t )1398949247,
                                                                 (uint32_t )1689378935,
                                                                 (uint32_t )1807451310,
                                                                 2180914336U, (uint32_t )150574123,
                                                                 (uint32_t )1215322216,
                                                                 (uint32_t )1167006205,
                                                                 3734275948U, (uint32_t )2069018616,
                                                                 (uint32_t )1940595667,
                                                                 (uint32_t )1265820162,
                                                                 (uint32_t )534992783,
                                                                 (uint32_t )1432758955,
                                                                 3954313000U, 3039757250U,
                                                                 3313932923U, (uint32_t )936617224,
                                                                 (uint32_t )674296455,
                                                                 3206787749U, (uint32_t )50510442,
                                                                 (uint32_t )384654466,
                                                                 3481938716U, (uint32_t )2041025204,
                                                                 (uint32_t )133427442,
                                                                 (uint32_t )1766760930,
                                                                 3664104948U, (uint32_t )84334014,
                                                                 (uint32_t )886120290,
                                                                 2797898494U, (uint32_t )775200083,
                                                                 4087521365U, 2315596513U,
                                                                 4137973227U, 2198551020U,
                                                                 (uint32_t )1614850799,
                                                                 (uint32_t )1901987487,
                                                                 (uint32_t )1857900816,
                                                                 (uint32_t )557775242,
                                                                 3717610758U, (uint32_t )1054715397,
                                                                 3863824061U, (uint32_t )1418835341,
                                                                 3295741277U, (uint32_t )100954068,
                                                                 (uint32_t )1348534037,
                                                                 2551784699U, 3184957417U,
                                                                 (uint32_t )1082772547,
                                                                 3647436702U, 3903896898U,
                                                                 2298972299U, (uint32_t )434583643,
                                                                 3363429358U, (uint32_t )2090944266,
                                                                 (uint32_t )1115482383,
                                                                 2230896926U, (uint32_t )0,
                                                                 2148107142U, (uint32_t )724715757,
                                                                 (uint32_t )287222896,
                                                                 (uint32_t )1517047410,
                                                                 (uint32_t )251526143,
                                                                 2232374840U, 2923241173U,
                                                                 (uint32_t )758523705,
                                                                 (uint32_t )252339417,
                                                                 (uint32_t )1550328230,
                                                                 (uint32_t )1536938324,
                                                                 (uint32_t )908343854,
                                                                 (uint32_t )168604007,
                                                                 (uint32_t )1469255655,
                                                                 4004827798U, 2602278545U,
                                                                 3229634501U, 3697386016U,
                                                                 (uint32_t )2002413899,
                                                                 (uint32_t )303830554,
                                                                 2481064634U, 2696996138U,
                                                                 (uint32_t )574374880,
                                                                 (uint32_t )454171927,
                                                                 (uint32_t )151915277,
                                                                 2347937223U, 3056449960U,
                                                                 (uint32_t )504678569,
                                                                 4049044761U, (uint32_t )1974422535,
                                                                 2582559709U, (uint32_t )2141453664,
                                                                 (uint32_t )33005350,
                                                                 (uint32_t )1918680309,
                                                                 (uint32_t )1715782971,
                                                                 4217058430U, (uint32_t )1133213225,
                                                                 (uint32_t )600562886,
                                                                 3988154620U, 3837289457U,
                                                                 (uint32_t )836225756,
                                                                 (uint32_t )1665273989,
                                                                 2534621218U, 3330547729U,
                                                                 (uint32_t )1250262308,
                                                                 3151165501U, 4188934450U,
                                                                 (uint32_t )700935585,
                                                                 2652719919U, 3000824624U,
                                                                 2249059410U, 3245854947U,
                                                                 3005967382U, (uint32_t )1890163129,
                                                                 2484206152U, 3913753188U,
                                                                 4238918796U, 4037024319U,
                                                                 (uint32_t )2102843436,
                                                                 (uint32_t )857927568,
                                                                 (uint32_t )1233635150,
                                                                 (uint32_t )953795025,
                                                                 3398237858U, 3566745099U,
                                                                 4121350017U, (uint32_t )2057644254,
                                                                 3084527246U, 2906629311U,
                                                                 (uint32_t )976020637,
                                                                 (uint32_t )2018512274,
                                                                 (uint32_t )1600822220,
                                                                 (uint32_t )2119459398,
                                                                 2381758995U, 3633375416U,
                                                                 (uint32_t )959340279,
                                                                 3280139695U, (uint32_t )1570750080,
                                                                 3496574099U, 3580864813U,
                                                                 (uint32_t )634368786,
                                                                 2898803609U, (uint32_t )403744637,
                                                                 2632478307U, (uint32_t )1004239803,
                                                                 (uint32_t )650971512,
                                                                 (uint32_t )1500443672,
                                                                 2599158199U, (uint32_t )1334028442,
                                                                 2514904430U, 4289363686U,
                                                                 3156281551U, (uint32_t )368043752,
                                                                 3887782299U, (uint32_t )1867173430,
                                                                 2682967049U, 2955531900U,
                                                                 2754719666U, (uint32_t )1059729699,
                                                                 2781229204U, 2721431654U,
                                                                 (uint32_t )1316239292,
                                                                 2197595850U, 2430644432U,
                                                                 2805143000U, (uint32_t )82922136,
                                                                 3963746266U, 3447656016U,
                                                                 2434215926U, (uint32_t )1299615190,
                                                                 4014165424U, 2865517645U,
                                                                 2531581700U, 3516851125U,
                                                                 (uint32_t )1783372680,
                                                                 (uint32_t )750893087,
                                                                 (uint32_t )1699118929,
                                                                 (uint32_t )1587348714,
                                                                 2348899637U, 2281337716U,
                                                                 (uint32_t )201010753,
                                                                 (uint32_t )1739807261,
                                                                 3683799762U, (uint32_t )283718486,
                                                                 3597472583U, 3617229921U,
                                                                 2704767500U, 4166618644U,
                                                                 (uint32_t )334203196,
                                                                 2848910887U, (uint32_t )1639396809,
                                                                 (uint32_t )484568549,
                                                                 (uint32_t )1199193265,
                                                                 3533461983U, 4065673075U,
                                                                 (uint32_t )337148366,
                                                                 3346251575U, 4149471949U,
                                                                 4250885034U, (uint32_t )1038029935,
                                                                 (uint32_t )1148749531,
                                                                 2949284339U, (uint32_t )1756970692,
                                                                 (uint32_t )607661108,
                                                                 2747424576U, (uint32_t )488010435,
                                                                 3803974693U, (uint32_t )1009290057,
                                                                 (uint32_t )234832277,
                                                                 2822336769U, (uint32_t )201907891,
                                                                 3034094820U, (uint32_t )1449431233,
                                                                 3413860740U, (uint32_t )852848822,
                                                                 (uint32_t )1816687708,
                                                                 3100656215U}, {(uint32_t )1364240372,
                                                                                (uint32_t )2119394625,
                                                                                (uint32_t )449029143,
                                                                                (uint32_t )982933031,
                                                                                (uint32_t )1003187115,
                                                                                (uint32_t )535905693,
                                                                                2896910586U,
                                                                                (uint32_t )1267925987,
                                                                                (uint32_t )542505520,
                                                                                2918608246U,
                                                                                2291234508U,
                                                                                4112862210U,
                                                                                (uint32_t )1341970405,
                                                                                3319253802U,
                                                                                (uint32_t )645940277,
                                                                                3046089570U,
                                                                                3729349297U,
                                                                                (uint32_t )627514298,
                                                                                (uint32_t )1167593194,
                                                                                (uint32_t )1575076094,
                                                                                3271718191U,
                                                                                2165502028U,
                                                                                2376308550U,
                                                                                (uint32_t )1808202195,
                                                                                (uint32_t )65494927,
                                                                                (uint32_t )362126482,
                                                                                3219880557U,
                                                                                2514114898U,
                                                                                3559752638U,
                                                                                (uint32_t )1490231668,
                                                                                (uint32_t )1227450848,
                                                                                2386872521U,
                                                                                (uint32_t )1969916354,
                                                                                4101536142U,
                                                                                2573942360U,
                                                                                (uint32_t )668823993,
                                                                                3199619041U,
                                                                                4028083592U,
                                                                                3378949152U,
                                                                                (uint32_t )2108963534,
                                                                                (uint32_t )1662536415,
                                                                                3850514714U,
                                                                                2539664209U,
                                                                                (uint32_t )1648721747,
                                                                                2984277860U,
                                                                                3146034795U,
                                                                                4263288961U,
                                                                                4187237128U,
                                                                                (uint32_t )1884842056,
                                                                                2400845125U,
                                                                                2491903198U,
                                                                                (uint32_t )1387788411,
                                                                                2871251827U,
                                                                                (uint32_t )1927414347,
                                                                                3814166303U,
                                                                                (uint32_t )1714072405,
                                                                                2986813675U,
                                                                                (uint32_t )788775605,
                                                                                2258271173U,
                                                                                3550808119U,
                                                                                (uint32_t )821200680,
                                                                                (uint32_t )598910399,
                                                                                (uint32_t )45771267,
                                                                                3982262806U,
                                                                                2318081231U,
                                                                                2811409529U,
                                                                                4092654087U,
                                                                                (uint32_t )1319232105,
                                                                                (uint32_t )1707996378,
                                                                                (uint32_t )114671109,
                                                                                3508494900U,
                                                                                3297443494U,
                                                                                (uint32_t )882725678,
                                                                                2728416755U,
                                                                                (uint32_t )87220618,
                                                                                2759191542U,
                                                                                (uint32_t )188345475,
                                                                                (uint32_t )1084944224,
                                                                                (uint32_t )1577492337,
                                                                                3176206446U,
                                                                                (uint32_t )1056541217,
                                                                                2520581853U,
                                                                                3719169342U,
                                                                                (uint32_t )1296481766,
                                                                                2444594516U,
                                                                                (uint32_t )1896177092,
                                                                                (uint32_t )74437638,
                                                                                (uint32_t )1627329872,
                                                                                (uint32_t )421854104,
                                                                                3600279997U,
                                                                                2311865152U,
                                                                                (uint32_t )1735892697,
                                                                                2965193448U,
                                                                                (uint32_t )126389129,
                                                                                3879230233U,
                                                                                (uint32_t )2044456648,
                                                                                2705787516U,
                                                                                (uint32_t )2095648578,
                                                                                4173930116U,
                                                                                (uint32_t )0,
                                                                                (uint32_t )159614592,
                                                                                (uint32_t )843640107,
                                                                                (uint32_t )514617361,
                                                                                (uint32_t )1817080410,
                                                                                4261150478U,
                                                                                (uint32_t )257308805,
                                                                                (uint32_t )1025430958,
                                                                                (uint32_t )908540205,
                                                                                (uint32_t )174381327,
                                                                                (uint32_t )1747035740,
                                                                                2614187099U,
                                                                                (uint32_t )607792694,
                                                                                (uint32_t )212952842,
                                                                                2467293015U,
                                                                                3033700078U,
                                                                                (uint32_t )463376795,
                                                                                2152711616U,
                                                                                (uint32_t )1638015196,
                                                                                (uint32_t )1516850039,
                                                                                (uint32_t )471210514,
                                                                                3792353939U,
                                                                                3236244128U,
                                                                                (uint32_t )1011081250,
                                                                                (uint32_t )303896347,
                                                                                (uint32_t )235605257,
                                                                                4071475083U,
                                                                                (uint32_t )767142070,
                                                                                (uint32_t )348694814,
                                                                                (uint32_t )1468340721,
                                                                                2940995445U,
                                                                                4005289369U,
                                                                                2751291519U,
                                                                                4154402305U,
                                                                                (uint32_t )1555887474,
                                                                                (uint32_t )1153776486,
                                                                                (uint32_t )1530167035,
                                                                                2339776835U,
                                                                                3420243491U,
                                                                                3060333805U,
                                                                                3093557732U,
                                                                                3620396081U,
                                                                                (uint32_t )1108378979,
                                                                                (uint32_t )322970263,
                                                                                2216694214U,
                                                                                2239571018U,
                                                                                3539484091U,
                                                                                2920362745U,
                                                                                3345850665U,
                                                                                (uint32_t )491466654,
                                                                                3706925234U,
                                                                                (uint32_t )233591430,
                                                                                (uint32_t )2010178497,
                                                                                (uint32_t )728503987,
                                                                                2845423984U,
                                                                                (uint32_t )301615252,
                                                                                (uint32_t )1193436393,
                                                                                2831453436U,
                                                                                2686074864U,
                                                                                (uint32_t )1457007741,
                                                                                (uint32_t )586125363,
                                                                                2277985865U,
                                                                                3653357880U,
                                                                                2365498058U,
                                                                                2553678804U,
                                                                                2798617077U,
                                                                                2770919034U,
                                                                                3659959991U,
                                                                                (uint32_t )1067761581,
                                                                                (uint32_t )753179962,
                                                                                (uint32_t )1343066744,
                                                                                (uint32_t )1788595295,
                                                                                (uint32_t )1415726718,
                                                                                4139914125U,
                                                                                2431170776U,
                                                                                (uint32_t )777975609,
                                                                                2197139395U,
                                                                                2680062045U,
                                                                                (uint32_t )1769771984,
                                                                                (uint32_t )1873358293,
                                                                                3484619301U,
                                                                                3359349164U,
                                                                                (uint32_t )279411992,
                                                                                3899548572U,
                                                                                3682319163U,
                                                                                3439949862U,
                                                                                (uint32_t )1861490777,
                                                                                3959535514U,
                                                                                2208864847U,
                                                                                3865407125U,
                                                                                2860443391U,
                                                                                (uint32_t )554225596,
                                                                                4024887317U,
                                                                                3134823399U,
                                                                                (uint32_t )1255028335,
                                                                                3939764639U,
                                                                                (uint32_t )701922480,
                                                                                (uint32_t )833598116,
                                                                                (uint32_t )707863359,
                                                                                3325072549U,
                                                                                (uint32_t )901801634,
                                                                                (uint32_t )1949809742,
                                                                                4238789250U,
                                                                                3769684112U,
                                                                                (uint32_t )857069735,
                                                                                4048197636U,
                                                                                (uint32_t )1106762476,
                                                                                (uint32_t )2131644621,
                                                                                (uint32_t )389019281,
                                                                                (uint32_t )1989006925,
                                                                                (uint32_t )1129165039,
                                                                                3428076970U,
                                                                                3839820950U,
                                                                                2665723345U,
                                                                                (uint32_t )1276872810,
                                                                                3250069292U,
                                                                                (uint32_t )1182749029,
                                                                                2634345054U,
                                                                                (uint32_t )22885772,
                                                                                4201870471U,
                                                                                4214112523U,
                                                                                3009027431U,
                                                                                2454901467U,
                                                                                3912455696U,
                                                                                (uint32_t )1829980118,
                                                                                2592891351U,
                                                                                (uint32_t )930745505,
                                                                                (uint32_t )1502483704,
                                                                                3951639571U,
                                                                                3471714217U,
                                                                                3073755489U,
                                                                                3790464284U,
                                                                                (uint32_t )2050797895,
                                                                                2623135698U,
                                                                                (uint32_t )1430221810,
                                                                                (uint32_t )410635796,
                                                                                (uint32_t )1941911495,
                                                                                (uint32_t )1407897079,
                                                                                (uint32_t )1599843069,
                                                                                3742658365U,
                                                                                (uint32_t )2022103876,
                                                                                3397514159U,
                                                                                3107898472U,
                                                                                (uint32_t )942421028,
                                                                                3261022371U,
                                                                                (uint32_t )376619805,
                                                                                3154912738U,
                                                                                (uint32_t )680216892,
                                                                                4282488077U,
                                                                                (uint32_t )963707304,
                                                                                (uint32_t )148812556,
                                                                                3634160820U,
                                                                                (uint32_t )1687208278,
                                                                                (uint32_t )2069988555,
                                                                                3580933682U,
                                                                                (uint32_t )1215585388,
                                                                                3494008760U}}};
#line 345 "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-decrypt.c"
void nettle_aes_decrypt(struct aes_ctx *ctx , unsigned int length , uint8_t *dst ,
                        uint8_t const   *src ) 
{ 
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 350
  if (! (! (length % 16U))) {
    {
    {
#line 350
    __assert_fail("!(length % 16)", "/home/ysko/Works/test-src/lsh-2.0.4/src/nettle/aes-decrypt.c",
                  350U, "nettle_aes_decrypt");
    }
    }
  }
  {
  {
#line 351
  _nettle_aes_decrypt((struct aes_ctx  const  *)ctx, & _aes_decrypt_table, length,
                      dst, src);
  }
  }
#line 353
  return;
}
}
#line 279 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
int spki_verify(void *ctx  __attribute__((__unused__)) , struct spki_hash_value  const  *hash___2 ,
                struct spki_principal *principal , struct spki_iterator *signature ) ;
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.h"
enum spki_type spki_iterator_first(struct spki_iterator *i , unsigned int length ,
                                   uint8_t const   *expr ) ;
#line 88
enum spki_type spki_parse_type(struct spki_iterator *i ) ;
#line 94
enum spki_type spki_parse_end(struct spki_iterator *i ) ;
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/verify.c"
static int spki_verify_rsa(int (*verify)(struct rsa_public_key  const  *key , uint8_t const   *digest ,
                                         __mpz_struct * const  signature ) , uint8_t const   *digest ,
                           struct spki_iterator *key , struct spki_iterator *signature ) 
{ 
  struct rsa_public_key rsa ;
  mpz_t s ;
  int res ;
  int tmp ;
  enum spki_type tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  enum spki_type tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;

  {
  {
  {
#line 49
  nettle_rsa_public_key_init(& rsa);
  }
  {
#line 50
  __gmpz_init(s);
  }
  {
#line 52
  tmp = nettle_rsa_keypair_from_sexp_alist(& rsa, (struct rsa_private_key *)((void *)0),
                                           3000U, & key->sexp);
  }
  }
#line 52
  if (tmp) {
    {
    {
#line 52
    tmp___0 = spki_parse_type(key);
    }
    }
#line 52
    if (tmp___0) {
      {
      {
#line 52
      tmp___1 = __gmpz_sizeinbase((mpz_srcptr )(rsa.n), 2);
      }
      {
#line 52
      tmp___2 = nettle_mpz_set_sexp(s, tmp___1, & signature->sexp);
      }
      }
#line 52
      if (tmp___2) {
        {
        {
#line 52
        tmp___3 = spki_parse_end(signature);
        }
        }
#line 52
        if (tmp___3) {
          {
          {
#line 52
          tmp___4 = (*verify)((struct rsa_public_key  const  *)(& rsa), digest, (__mpz_struct */* const  */)(s));
          }
          }
#line 52
          if (tmp___4) {
#line 52
            tmp___5 = 1;
          } else {
#line 52
            tmp___5 = 0;
          }
        } else {
#line 52
          tmp___5 = 0;
        }
      } else {
#line 52
        tmp___5 = 0;
      }
    } else {
#line 52
      tmp___5 = 0;
    }
  } else {
#line 52
    tmp___5 = 0;
  }
  {
#line 52
  res = tmp___5;
  {
#line 60
  __gmpz_clear(s);
  }
  {
#line 61
  nettle_rsa_public_key_clear(& rsa);
  }
  }
#line 62
  return (res);
}
}
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/verify.c"
static int spki_verify_dsa(uint8_t const   *digest , struct spki_iterator *key , struct spki_iterator *signature ) 
{ 
  struct dsa_public_key dsa ;
  struct dsa_signature rs ;
  int res ;
  int tmp ;
  enum spki_type tmp___0 ;
  int tmp___1 ;
  enum spki_type tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;

  {
  {
  {
#line 74
  nettle_dsa_public_key_init(& dsa);
  }
  {
#line 75
  nettle_dsa_signature_init(& rs);
  }
  {
#line 77
  tmp = nettle_dsa_keypair_from_sexp_alist(& dsa, (struct dsa_private_key *)((void *)0),
                                           3000U, & key->sexp);
  }
  }
#line 77
  if (tmp) {
    {
    {
#line 77
    tmp___0 = spki_parse_type(key);
    }
    }
#line 77
    if (tmp___0) {
      {
      {
#line 77
      tmp___1 = nettle_dsa_signature_from_sexp(& rs, & signature->sexp);
      }
      }
#line 77
      if (tmp___1) {
        {
        {
#line 77
        tmp___2 = spki_parse_type(signature);
        }
        }
#line 77
        if (tmp___2) {
          {
          {
#line 77
          tmp___3 = nettle_dsa_verify_digest((struct dsa_public_key  const  *)(& dsa),
                                             digest, (struct dsa_signature  const  *)(& rs));
          }
          }
#line 77
          if (tmp___3) {
#line 77
            tmp___4 = 1;
          } else {
#line 77
            tmp___4 = 0;
          }
        } else {
#line 77
          tmp___4 = 0;
        }
      } else {
#line 77
        tmp___4 = 0;
      }
    } else {
#line 77
      tmp___4 = 0;
    }
  } else {
#line 77
    tmp___4 = 0;
  }
  {
#line 77
  res = tmp___4;
  {
#line 84
  nettle_dsa_signature_clear(& rs);
  }
  {
#line 85
  nettle_dsa_public_key_clear(& dsa);
  }
  }
#line 87
  return (res);
}
}
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/verify.c"
int spki_verify(void *ctx  __attribute__((__unused__)) , struct spki_hash_value  const  *hash___2 ,
                struct spki_principal *principal , struct spki_iterator *signature ) 
{ 
  struct spki_iterator key ;
  enum spki_type signature_type ;
  enum spki_type tmp ;
  enum spki_type tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
#line 99
  if (! principal->key) {
#line 101
    return (0);
  }
  {
#line 103
  signature_type = signature->type;
  {
#line 105
  tmp = spki_iterator_first(& key, principal->key_length, (uint8_t const   *)principal->key);
  }
  }
#line 105
  if ((unsigned int )tmp != 17U) {
#line 108
    return (0);
  }
  {
  {
#line 110
  tmp___0 = spki_parse_type(& key);
  }
  }
#line 112
  if ((unsigned int )tmp___0 == 18U) {
#line 112
    goto case_18;
  }
#line 120
  if ((unsigned int )tmp___0 == 19U) {
#line 120
    goto case_19;
  }
#line 145
  if ((unsigned int )tmp___0 == 6U) {
#line 145
    goto case_6;
  }
#line 150
  goto switch_default;
  case_18: 
#line 113
  if ((unsigned int const   )hash___2->type == 11U) {
#line 113
    if (hash___2->length == 16U) {
#line 113
      if ((unsigned int )signature_type == 18U) {
        {
        {
#line 113
        tmp___1 = spki_verify_rsa(& nettle_rsa_md5_verify_digest, (uint8_t const   *)hash___2->digest,
                                  & key, signature);
        }
        }
#line 113
        if (tmp___1) {
#line 113
          tmp___2 = 1;
        } else {
#line 113
          tmp___2 = 0;
        }
      } else {
#line 113
        tmp___2 = 0;
      }
    } else {
#line 113
      tmp___2 = 0;
    }
  } else {
#line 113
    tmp___2 = 0;
  }
#line 113
  return (tmp___2);
  case_19: 
#line 121
  if ((unsigned int const   )hash___2->type == 21U) {
#line 121
    if (hash___2->length == 20U) {
#line 121
      if ((unsigned int )signature_type == 19U) {
        {
        {
#line 121
        tmp___3 = spki_verify_rsa(& nettle_rsa_sha1_verify_digest, (uint8_t const   *)hash___2->digest,
                                  & key, signature);
        }
        }
#line 121
        if (tmp___3) {
#line 121
          tmp___4 = 1;
        } else {
#line 121
          tmp___4 = 0;
        }
      } else {
#line 121
        tmp___4 = 0;
      }
    } else {
#line 121
      tmp___4 = 0;
    }
  } else {
#line 121
    tmp___4 = 0;
  }
#line 121
  return (tmp___4);
  case_6: 
#line 146
  if ((unsigned int const   )hash___2->type == 21U) {
#line 146
    if (hash___2->length == 20U) {
      {
      {
#line 146
      tmp___5 = spki_verify_dsa((uint8_t const   *)hash___2->digest, & key, signature);
      }
      }
#line 146
      if (tmp___5) {
#line 146
        tmp___6 = 1;
      } else {
#line 146
        tmp___6 = 0;
      }
    } else {
#line 146
      tmp___6 = 0;
    }
  } else {
#line 146
    tmp___6 = 0;
  }
#line 146
  return (tmp___6);
  switch_default: 
#line 151
  return (0);

#line 155
  return (0);
}
}
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.h"
struct spki_tag *spki_tag_compile(void *ctx , nettle_realloc_func *realloc___0 , struct sexp_iterator *i ) ;
#line 39
struct spki_tag *spki_tag_from_sexp(void *ctx , nettle_realloc_func *realloc___0 ,
                                    unsigned int length , uint8_t const   *expr ) ;
#line 44
void spki_tag_release(void *ctx , nettle_realloc_func *realloc___0 , struct spki_tag *tag ) ;
#line 51
int spki_tag_includes(struct spki_tag *delegated , struct spki_tag *request ) ;
#line 55
struct spki_tag *spki_tag_intersect(void *ctx , nettle_realloc_func *realloc___0 ,
                                    struct spki_tag *a , struct spki_tag *b ) ;
#line 60
unsigned int spki_tag_format(struct spki_tag *tag , struct nettle_buffer *buffer ) ;
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_string *spki_string_new(void *ctx , nettle_realloc_func *realloc___0 ,
                                           unsigned int length , uint8_t const   *data ) 
{ 
  struct spki_string *s ;
  void *tmp ;
  uint8_t *p ;
  void *tmp___0 ;

  {
  {
  {
#line 64
  tmp = (*realloc___0)(ctx, (void *)0, (unsigned int )sizeof(struct spki_string ));
  }
#line 64
  s = (struct spki_string *)tmp;
  }
#line 67
  if (! s) {
#line 68
    return ((struct spki_string *)((void *)0));
  }
  {
  {
#line 70
  tmp___0 = (*realloc___0)(ctx, (void *)0, length);
  }
#line 70
  p = (uint8_t *)tmp___0;
  }
#line 71
  if (! p) {
    {
    {
#line 73
    (*realloc___0)(ctx, (void *)s, 0U);
    }
    }
#line 74
    return ((struct spki_string *)((void *)0));
  }
  {
  {
#line 77
  memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)data),
         length);
  }
#line 78
  s->refs = 1U;
#line 79
  s->length = length;
#line 80
  s->data = (uint8_t const   *)p;
  }
#line 82
  return (s);
}
}
#line 85 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static void spki_string_release(void *ctx , nettle_realloc_func *realloc___0 , struct spki_string *s ) 
{ 


  {
#line 89
  if (! s) {
#line 90
    return;
  }
#line 92
  (s->refs) --;
#line 92
  if (s->refs) {
#line 93
    return;
  }
  {
  {
#line 95
  (*realloc___0)(ctx, (void *)s->data, 0U);
  }
  {
#line 96
  (*realloc___0)(ctx, (void *)s, 0U);
  }
  }
#line 97
  return;
}
}
#line 107 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static int string_equal(struct spki_string *a , struct spki_string *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 110
  if ((unsigned long )a == (unsigned long )b) {
#line 111
    return (1);
  }
#line 113
  if (! a) {
#line 114
    return (0);
  } else
#line 113
  if (! b) {
#line 114
    return (0);
  }
#line 116
  if (a->length == b->length) {
    {
    {
#line 116
    tmp = memcmp((void const   *)a->data, (void const   *)b->data, a->length);
    }
    }
#line 116
    if (tmp) {
#line 116
      tmp___0 = 0;
    } else {
#line 116
      tmp___0 = 1;
    }
  } else {
#line 116
    tmp___0 = 0;
  }
#line 116
  return (tmp___0);
}
}
#line 121 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static int string_prefix(struct spki_string *prefix___0 , struct spki_string *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 124
  if (! prefix___0) {
    {
    {
#line 124
    __assert_fail("prefix", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  124U, "string_prefix");
    }
    }
  }
#line 125
  if (! s) {
    {
    {
#line 125
    __assert_fail("s", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c", 125U,
                  "string_prefix");
    }
    }
  }
#line 127
  if (prefix___0->length <= s->length) {
    {
    {
#line 127
    tmp = memcmp((void const   *)prefix___0->data, (void const   *)s->data, prefix___0->length);
    }
    }
#line 127
    if (tmp) {
#line 127
      tmp___0 = 0;
    } else {
#line 127
      tmp___0 = 1;
    }
  } else {
#line 127
    tmp___0 = 0;
  }
#line 127
  return (tmp___0);
}
}
#line 138 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static void spki_cons_release(void *ctx , nettle_realloc_func *realloc___0 , struct spki_cons *c ) 
{ 
  struct spki_cons *cdr ;

  {
  {
  {
#line 142
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 142
    if (! c) {
#line 142
      goto while_break;
    }
    {
#line 144
    cdr = c->cdr;
    {
#line 145
    spki_tag_release(ctx, realloc___0, c->car);
    }
    {
#line 146
    (*realloc___0)(ctx, (void *)c, 0U);
    }
#line 147
    c = cdr;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 149
  return;
}
}
#line 153 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_cons *spki_cons(void *ctx , nettle_realloc_func *realloc___0 ,
                                   struct spki_tag *car , struct spki_cons *cdr ) 
{ 
  struct spki_cons *c ;
  void *tmp ;

  {
  {
  {
#line 157
  tmp = (*realloc___0)(ctx, (void *)0, (unsigned int )sizeof(struct spki_cons ));
  }
#line 157
  c = (struct spki_cons *)tmp;
  }
#line 158
  if (! c) {
    {
    {
#line 160
    spki_tag_release(ctx, realloc___0, car);
    }
    {
#line 161
    spki_cons_release(ctx, realloc___0, cdr);
    }
    }
#line 162
    return ((struct spki_cons *)((void *)0));
  }
#line 164
  c->car = car;
#line 165
  c->cdr = cdr;
#line 167
  return (c);
}
}
#line 171 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_cons *spki_cons_nreverse(struct spki_cons *c ) 
{ 
  struct spki_cons *head ;
  struct spki_cons *next ;

  {
#line 174
  head = (struct spki_cons *)((void *)0);
  {
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 176
    if (! c) {
#line 176
      goto while_break;
    }
#line 178
    next = c->cdr;
#line 181
    c->cdr = head;
#line 182
    head = c;
#line 184
    c = next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 187
  return (head);
}
}
#line 211 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_tag  const  spki_tag_any  =    {(enum spki_tag_type )1, 0U};
#line 221 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_tag_list *tag_list(struct spki_tag *tag ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 224
  if (! ((unsigned int )tag->type == 3U)) {
#line 224
    if (! ((unsigned int )tag->type == 2U)) {
      {
      {
#line 224
      __assert_fail("tag->type == SPKI_TAG_LIST || tag->type == SPKI_TAG_SET", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                    225U, "tag_list");
      }
      }
    }
  }
#line 227
  return ((struct spki_tag_list *)tag);
}
}
#line 238 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_tag_atom *tag_atom(struct spki_tag *tag ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 241
  if (! ((unsigned int )tag->type == 6U)) {
#line 241
    if (! ((unsigned int )tag->type == 4U)) {
      {
      {
#line 241
      __assert_fail("tag->type == SPKI_TAG_ATOM || tag->type == SPKI_TAG_PREFIX",
                    "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c", 242U, "tag_atom");
      }
      }
    }
  }
#line 244
  return ((struct spki_tag_atom *)tag);
}
}
#line 270 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_tag_range *tag_range(struct spki_tag *tag ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 273
  if (! ((unsigned int )tag->type == 5U)) {
    {
    {
#line 273
    __assert_fail("tag->type == SPKI_TAG_RANGE", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  273U, "tag_range");
    }
    }
  }
#line 275
  return ((struct spki_tag_range *)tag);
}
}
#line 278 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static void spki_tag_init(struct spki_tag *tag , enum spki_tag_type type ) 
{ 


  {
#line 282
  tag->type = type;
#line 283
  tag->refs = 1U;
#line 284
  return;
}
}
#line 286 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_tag *spki_tag_dup(struct spki_tag *tag ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 289
  if (! tag) {
    {
    {
#line 289
    __assert_fail("tag", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c", 289U,
                  "spki_tag_dup");
    }
    }
  }
#line 290
  if ((unsigned long )tag != (unsigned long )(& spki_tag_any)) {
#line 291
    (tag->refs) ++;
  }
#line 292
  return (tag);
}
}
#line 295 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_tag *spki_tag_atom_alloc(void *ctx , nettle_realloc_func *realloc___0 ,
                                            enum spki_tag_type type , struct sexp_iterator *i ) 
{ 
  struct spki_string *display ;
  struct spki_string *atom ;
  int tmp ;
  struct spki_tag_atom *tag ;
  void *tmp___0 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 303
  if (! ((unsigned int )i->type == 0U)) {
    {
    {
#line 303
    __assert_fail("i->type == SEXP_ATOM", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  303U, "spki_tag_atom_alloc");
    }
    }
  }
#line 304
  if (! i->atom) {
    {
    {
#line 304
    __assert_fail("i->atom", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  304U, "spki_tag_atom_alloc");
    }
    }
  }
#line 306
  if (i->display) {
    {
    {
#line 308
    display = spki_string_new(ctx, realloc___0, i->display_length, i->display);
    }
    }
#line 311
    if (! display) {
#line 312
      return ((struct spki_tag *)((void *)0));
    }
  } else {
#line 315
    display = (struct spki_string *)((void *)0);
  }
  {
  {
#line 317
  atom = spki_string_new(ctx, realloc___0, i->atom_length, i->atom);
  }
  }
#line 320
  if (! atom) {
    {
    {
#line 322
    spki_string_release(ctx, realloc___0, display);
    }
    }
#line 323
    return ((struct spki_tag *)((void *)0));
  }
  {
  {
#line 326
  tmp = nettle_sexp_iterator_next(i);
  }
  }
#line 326
  if (! tmp) {
    {
    {
#line 328
    spki_string_release(ctx, realloc___0, display);
    }
    {
#line 329
    spki_string_release(ctx, realloc___0, atom);
    }
    }
#line 330
    return ((struct spki_tag *)((void *)0));
  }
  {
  {
#line 334
  tmp___0 = (*realloc___0)(ctx, (void *)0, (unsigned int )sizeof(struct spki_tag_atom ));
  }
#line 334
  tag = (struct spki_tag_atom *)tmp___0;
  }
#line 335
  if (! tag) {
    {
    {
#line 337
    spki_string_release(ctx, realloc___0, display);
    }
    {
#line 338
    spki_string_release(ctx, realloc___0, atom);
    }
    }
#line 339
    return ((struct spki_tag *)((void *)0));
  }
  {
  {
#line 342
  spki_tag_init(& tag->super, type);
  }
#line 343
  tag->display = display;
#line 344
  tag->atom = atom;
  }
#line 346
  return (& tag->super);
}
}
#line 350 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_tag *spki_tag_list_alloc(void *ctx , nettle_realloc_func *realloc___0 ,
                                            enum spki_tag_type type , struct spki_cons *children ) 
{ 
  struct spki_tag_list *tag ;
  void *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 355
  tmp = (*realloc___0)(ctx, (void *)0, (unsigned int )sizeof(struct spki_tag_list ));
  }
#line 355
  tag = (struct spki_tag_list *)tmp;
  }
#line 357
  if (! ((unsigned int )type == 2U)) {
#line 357
    if (! ((unsigned int )type == 3U)) {
      {
      {
#line 357
      __assert_fail("type == SPKI_TAG_SET || type == SPKI_TAG_LIST", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                    357U, "spki_tag_list_alloc");
      }
      }
    }
  }
#line 359
  if (! tag) {
#line 360
    return ((struct spki_tag *)((void *)0));
  }
  {
  {
#line 362
  spki_tag_init(& tag->super, type);
  }
#line 363
  tag->children = children;
  }
#line 365
  return (& tag->super);
}
}
#line 389 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
void spki_tag_release(void *ctx , nettle_realloc_func *realloc___0 , struct spki_tag *tag ) 
{ 
  struct spki_tag_atom *self ;
  struct spki_tag_atom *tmp ;
  struct spki_tag_list *self___0 ;
  struct spki_tag_list *tmp___0 ;
  struct spki_tag_range *self___1 ;
  struct spki_tag_range *tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 393
  if (! tag) {
#line 394
    return;
  } else
#line 393
  if ((unsigned long )tag == (unsigned long )(& spki_tag_any)) {
#line 394
    return;
  }
#line 396
  if (! tag->refs) {
    {
    {
#line 396
    __assert_fail("tag->refs", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  396U, "spki_tag_release");
    }
    }
  }
#line 398
  (tag->refs) --;
#line 398
  if (tag->refs) {
#line 399
    return;
  }
#line 404
  if ((unsigned int )tag->type == 4U) {
#line 404
    goto case_4;
  }
#line 404
  if ((unsigned int )tag->type == 6U) {
#line 404
    goto case_4;
  }
#line 414
  if ((unsigned int )tag->type == 2U) {
#line 414
    goto case_2;
  }
#line 414
  if ((unsigned int )tag->type == 3U) {
#line 414
    goto case_2;
  }
#line 421
  if ((unsigned int )tag->type == 5U) {
#line 421
    goto case_5;
  }
#line 428
  goto switch_default;
  case_4: 
  {
  {
#line 406
  tmp = tag_atom(tag);
  }
#line 406
  self = tmp;
  {
#line 408
  spki_string_release(ctx, realloc___0, self->display);
  }
  {
#line 409
  spki_string_release(ctx, realloc___0, self->atom);
  }
  }
#line 411
  goto switch_break;
  case_2: 
  {
  {
#line 416
  tmp___0 = tag_list(tag);
  }
#line 416
  self___0 = tmp___0;
  {
#line 417
  spki_cons_release(ctx, realloc___0, self___0->children);
  }
  }
#line 419
  goto switch_break;
  case_5: 
  {
  {
#line 423
  tmp___1 = tag_range(tag);
  }
#line 423
  self___1 = tmp___1;
  {
#line 425
  spki_string_release(ctx, realloc___0, self___1->lower);
  }
  {
#line 426
  spki_string_release(ctx, realloc___0, self___1->upper);
  }
  }
  switch_default: 
  {
  {
#line 429
  abort();
  }
  }
  switch_break: 
  {
  {
#line 432
  (*realloc___0)(ctx, (void *)tag, 0U);
  }
  }
#line 433
  return;
}
}
#line 446 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_tag *spki_tag_set_new(void *ctx , nettle_realloc_func *realloc___0 ,
                                         struct spki_cons *c ) 
{ 
  struct spki_cons *subsets ;
  struct spki_tag *tag ;
  struct spki_tag *tmp ;
  struct spki_tag *tmp___0 ;
  struct spki_tag_list *set ;
  struct spki_tag_list *tmp___1 ;
  struct spki_cons *p ;
  struct spki_tag *tmp___2 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  void *ctx18 ;
  nettle_realloc_func *realloc___019 ;
  enum spki_tag_type type20 ;
  struct spki_cons *children21 ;
  struct spki_tag_list *tag22 ;
  void *tmp23 ;
  char *__cil_tmp1024 ;
  char *__cil_tmp1125 ;
  char *__cil_tmp1226 ;
  struct spki_tag *ret_spki_tag_list_alloc27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 450
  subsets = (struct spki_cons *)((void *)0);
#line 453
  if (c) {
#line 453
    if (! c->cdr) {
      {
      {
#line 454
      tmp = spki_tag_dup(c->car);
      }
      }
#line 454
      return (tmp);
    }
  }
  {
  {
#line 456
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 456
    if (! c) {
#line 456
      goto while_break;
    }
#line 458
    if ((unsigned int )(c->car)->type != 2U) {
      {
      {
#line 460
      tmp___0 = spki_tag_dup(c->car);
      }
      {
#line 460
      subsets = spki_cons(ctx, realloc___0, tmp___0, subsets);
      }
      }
#line 461
      if (! subsets) {
#line 462
        return ((struct spki_tag *)((void *)0));
      }
    } else {
      {
      {
#line 466
      tmp___1 = tag_list(c->car);
      }
#line 466
      set = tmp___1;
#line 469
      p = set->children;
      }
      {
      {
#line 469
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;

#line 469
        if (! p) {
#line 469
          goto while_break___0;
        }
#line 472
        if (! ((unsigned int )(p->car)->type != 2U)) {
          {
          {
#line 472
          __assert_fail("p->car->type != SPKI_TAG_SET", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                        472U, "spki_tag_set_new");
          }
          }
        }
        {
        {
#line 473
        tmp___2 = spki_tag_dup(p->car);
        }
        {
#line 473
        subsets = spki_cons(ctx, realloc___0, tmp___2, subsets);
        }
        }
#line 474
        if (! subsets) {
#line 475
          return ((struct spki_tag *)((void *)0));
        }
#line 469
        p = p->cdr;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
    }
#line 456
    c = c->cdr;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 479
  ctx18 = ctx;
#line 479
  realloc___019 = realloc___0;
#line 479
  type20 = (enum spki_tag_type )2;
#line 479
  children21 = subsets;
  {
  {
  {
#line 355
  tmp23 = (*realloc___019)(ctx18, (void *)0, (unsigned int )sizeof(struct spki_tag_list ));
  }
#line 355
  tag22 = (struct spki_tag_list *)tmp23;
  }
#line 357
  if (! ((unsigned int )type20 == 2U)) {
#line 357
    if (! ((unsigned int )type20 == 3U)) {
      {
      {
#line 357
      __assert_fail("type == SPKI_TAG_SET || type == SPKI_TAG_LIST", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                    357U, "spki_tag_list_alloc");
      }
      }
    }
  }
#line 359
  if (! tag22) {
    {
#line 360
    ret_spki_tag_list_alloc27 = (struct spki_tag *)((void *)0);
#line 360
    goto Lret_spki_tag_list_alloc;
    }
  }
  {
  {
#line 362
  spki_tag_init(& tag22->super, type20);
  }
#line 363
  tag22->children = children21;
  }
  {
#line 365
  ret_spki_tag_list_alloc27 = & tag22->super;
#line 365
  goto Lret_spki_tag_list_alloc;
  }
  }
  Lret_spki_tag_list_alloc: /* CIL Label */ 
#line 479
  tag = ret_spki_tag_list_alloc27;
  }
  }
#line 481
  if (tag) {
#line 482
    return (tag);
  }
  {
  {
#line 484
  spki_cons_release(ctx, realloc___0, subsets);
  }
  }
#line 485
  return ((struct spki_tag *)((void *)0));
}
}
#line 491 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static enum spki_tag_type spki_tag_classify(struct sexp_iterator *i ) 
{ 
  int tmp ;
  enum spki_tag_type type ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 499
  if ((unsigned int )i->type == 2U) {
#line 499
    goto case_2;
  }
#line 502
  if ((unsigned int )i->type == 0U) {
#line 502
    goto case_0;
  }
#line 505
  if ((unsigned int )i->type == 1U) {
#line 505
    goto case_1;
  }
#line 496
  goto switch_default;
  switch_default: 
  {
  {
#line 497
  abort();
  }
  }
  case_2: 
#line 500
  return ((enum spki_tag_type )0);
  case_0: 
#line 503
  return ((enum spki_tag_type )6);
  case_1: 
  {
  {
#line 506
  tmp = nettle_sexp_iterator_enter_list(i);
  }
  }
#line 506
  if (tmp) {
#line 506
    if ((unsigned int )i->type != 0U) {
#line 508
      return ((enum spki_tag_type )0);
    }
  } else {
#line 508
    return ((enum spki_tag_type )0);
  }
#line 510
  if (! i->display) {
#line 510
    if (i->atom_length == 1U) {
#line 510
      if ((int const   )*(i->atom + 0) == 42) {
        {
        {
#line 515
        tmp___0 = nettle_sexp_iterator_next(i);
        }
        }
#line 515
        if (! tmp___0) {
#line 516
          return ((enum spki_tag_type )0);
        }
#line 518
        if ((unsigned int )i->type == 2U) {
          {
          {
#line 519
          tmp___3 = nettle_sexp_iterator_exit_list(i);
          }
          }
#line 519
          if (tmp___3) {
#line 519
            tmp___2 = 1;
          } else {
#line 519
            tmp___2 = 0;
          }
#line 519
          return ((enum spki_tag_type )tmp___2);
        }
#line 521
        if ((unsigned int )i->type != 0U) {
#line 522
          return ((enum spki_tag_type )0);
        } else
#line 521
        if (i->display) {
#line 522
          return ((enum spki_tag_type )0);
        }
#line 535
        if (i->atom_length == (unsigned int )(sizeof("set") - 1UL)) {
#line 535
          goto case_exp;
        }
#line 536
        if (i->atom_length == (unsigned int )(sizeof("range") - 1UL)) {
#line 536
          goto case_exp___0;
        }
#line 537
        if (i->atom_length == (unsigned int )(sizeof("prefix") - 1UL)) {
#line 537
          goto case_exp___1;
        }
#line 532
        goto switch_default___0;
        switch_default___0: 
#line 533
        return ((enum spki_tag_type )0);
        case_exp: 
        {
        {
#line 535
        tmp___4 = memcmp((void const   *)i->atom, (void const   *)"set", (size_t )(sizeof("set") - 1UL));
        }
        }
#line 535
        if (! tmp___4) {
#line 535
          type = (enum spki_tag_type )2;
#line 535
          goto switch_break___0;
        }
#line 535
        return ((enum spki_tag_type )0);
        case_exp___0: 
        {
        {
#line 536
        tmp___5 = memcmp((void const   *)i->atom, (void const   *)"range", (size_t )(sizeof("range") - 1UL));
        }
        }
#line 536
        if (! tmp___5) {
#line 536
          type = (enum spki_tag_type )5;
#line 536
          goto switch_break___0;
        }
#line 536
        return ((enum spki_tag_type )0);
        case_exp___1: 
        {
        {
#line 537
        tmp___6 = memcmp((void const   *)i->atom, (void const   *)"prefix", (size_t )(sizeof("prefix") - 1UL));
        }
        }
#line 537
        if (! tmp___6) {
#line 537
          type = (enum spki_tag_type )4;
#line 537
          goto switch_break___0;
        }
#line 537
        return ((enum spki_tag_type )0);
        switch_break___0: 
        {
        {
#line 540
        tmp___9 = nettle_sexp_iterator_next(i);
        }
        }
#line 540
        if (tmp___9) {
#line 540
          tmp___8 = (unsigned int )type;
        } else {
#line 540
          tmp___8 = 0U;
        }
#line 540
        return ((enum spki_tag_type )tmp___8);
      } else {
#line 543
        return ((enum spki_tag_type )3);
      }
    } else {
#line 543
      return ((enum spki_tag_type )3);
    }
  } else {
#line 543
    return ((enum spki_tag_type )3);
  }

#line 548
  return ((enum spki_tag_type )0);
}
}
#line 547
static struct spki_cons *spki_tag_compile_list(void *ctx , nettle_realloc_func *realloc___0 ,
                                               struct sexp_iterator *i ) ;
#line 551 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
struct spki_tag *spki_tag_compile(void *ctx , nettle_realloc_func *realloc___0 , struct sexp_iterator *i ) 
{ 
  enum spki_tag_type type ;
  enum spki_tag_type tmp ;
  struct spki_tag *tmp___0 ;
  struct spki_tag *tag ;
  struct spki_cons *children ;
  struct spki_tag *tmp___1 ;
  struct spki_tag *tag___0 ;
  struct spki_cons *children___0 ;
  struct spki_cons *tmp___2 ;
  struct spki_cons *tmp___3 ;
  struct spki_tag *tag___1 ;
  struct spki_tag *tmp___4 ;
  int tmp___5 ;
  void *ctx17 ;
  nettle_realloc_func *realloc___018 ;
  enum spki_tag_type type19 ;
  struct sexp_iterator *i20 ;
  struct spki_string *display21 ;
  struct spki_string *atom22 ;
  int tmp23 ;
  struct spki_tag_atom *tag24 ;
  void *tmp___025 ;
  char *__cil_tmp1626 ;
  char *__cil_tmp1727 ;
  char *__cil_tmp1828 ;
  char *__cil_tmp1929 ;
  char *__cil_tmp2030 ;
  char *__cil_tmp2131 ;
  struct spki_tag *ret_spki_tag_atom_alloc32 ;
  void *ctx33 ;
  nettle_realloc_func *realloc___034 ;
  enum spki_tag_type type35 ;
  struct spki_cons *children36 ;
  struct spki_tag_list *tag37 ;
  void *tmp38 ;
  char *__cil_tmp1039 ;
  char *__cil_tmp1140 ;
  char *__cil_tmp1241 ;
  struct spki_tag *ret_spki_tag_list_alloc42 ;
  void *ctx43 ;
  nettle_realloc_func *realloc___044 ;
  enum spki_tag_type type45 ;
  struct sexp_iterator *i46 ;
  struct spki_string *display47 ;
  struct spki_string *atom48 ;
  int tmp49 ;
  struct spki_tag_atom *tag50 ;
  void *tmp___051 ;
  char *__cil_tmp1652 ;
  char *__cil_tmp1753 ;
  char *__cil_tmp1854 ;
  char *__cil_tmp1955 ;
  char *__cil_tmp2056 ;
  char *__cil_tmp2157 ;
  struct spki_tag *ret_spki_tag_atom_alloc58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
  {
  {
#line 555
  tmp = spki_tag_classify(i);
  }
#line 555
  type = tmp;
  }
#line 562
  if ((unsigned int )type == 6U) {
#line 562
    goto case_6;
  }
#line 566
  if ((unsigned int )type == 2U) {
#line 566
    goto case_2;
  }
#line 586
  if ((unsigned int )type == 3U) {
#line 586
    goto case_3;
  }
#line 606
  if ((unsigned int )type == 1U) {
#line 606
    goto case_1;
  }
#line 611
  if ((unsigned int )type == 4U) {
#line 611
    goto case_4;
  }
#line 626
  if ((unsigned int )type == 5U) {
#line 626
    goto case_5;
  }
#line 559
  goto switch_default;
  switch_default: 
#line 560
  return ((struct spki_tag *)((void *)0));
  case_6: 
  {
  {
#line 563
  ctx17 = ctx;
#line 563
  realloc___018 = realloc___0;
#line 563
  type19 = (enum spki_tag_type )6;
#line 563
  i20 = i;
  {
#line 303
  if (! ((unsigned int )i20->type == 0U)) {
    {
    {
#line 303
    __assert_fail("i->type == SEXP_ATOM", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  303U, "spki_tag_atom_alloc");
    }
    }
  }
#line 304
  if (! i20->atom) {
    {
    {
#line 304
    __assert_fail("i->atom", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  304U, "spki_tag_atom_alloc");
    }
    }
  }
#line 306
  if (i20->display) {
    {
    {
#line 308
    display21 = spki_string_new(ctx17, realloc___018, i20->display_length, i20->display);
    }
    }
#line 311
    if (! display21) {
      {
#line 312
      ret_spki_tag_atom_alloc32 = (struct spki_tag *)((void *)0);
#line 312
      goto Lret_spki_tag_atom_alloc;
      }
    }
  } else {
#line 315
    display21 = (struct spki_string *)((void *)0);
  }
  {
  {
#line 317
  atom22 = spki_string_new(ctx17, realloc___018, i20->atom_length, i20->atom);
  }
  }
#line 320
  if (! atom22) {
    {
    {
#line 322
    spki_string_release(ctx17, realloc___018, display21);
    }
    }
    {
#line 323
    ret_spki_tag_atom_alloc32 = (struct spki_tag *)((void *)0);
#line 323
    goto Lret_spki_tag_atom_alloc;
    }
  }
  {
  {
#line 326
  tmp23 = nettle_sexp_iterator_next(i20);
  }
  }
#line 326
  if (! tmp23) {
    {
    {
#line 328
    spki_string_release(ctx17, realloc___018, display21);
    }
    {
#line 329
    spki_string_release(ctx17, realloc___018, atom22);
    }
    }
    {
#line 330
    ret_spki_tag_atom_alloc32 = (struct spki_tag *)((void *)0);
#line 330
    goto Lret_spki_tag_atom_alloc;
    }
  }
  {
  {
#line 334
  tmp___025 = (*realloc___018)(ctx17, (void *)0, (unsigned int )sizeof(struct spki_tag_atom ));
  }
#line 334
  tag24 = (struct spki_tag_atom *)tmp___025;
  }
#line 335
  if (! tag24) {
    {
    {
#line 337
    spki_string_release(ctx17, realloc___018, display21);
    }
    {
#line 338
    spki_string_release(ctx17, realloc___018, atom22);
    }
    }
    {
#line 339
    ret_spki_tag_atom_alloc32 = (struct spki_tag *)((void *)0);
#line 339
    goto Lret_spki_tag_atom_alloc;
    }
  }
  {
  {
#line 342
  spki_tag_init(& tag24->super, type19);
  }
#line 343
  tag24->display = display21;
#line 344
  tag24->atom = atom22;
  }
  {
#line 346
  ret_spki_tag_atom_alloc32 = & tag24->super;
#line 346
  goto Lret_spki_tag_atom_alloc;
  }
  }
  Lret_spki_tag_atom_alloc: /* CIL Label */ 
#line 563
  tmp___0 = ret_spki_tag_atom_alloc32;
  }
  }
#line 563
  return (tmp___0);
  case_2: 
#line 572
  if ((unsigned int )i->type == 2U) {
    {
    {
#line 573
    tmp___1 = spki_tag_set_new(ctx, realloc___0, (struct spki_cons *)((void *)0));
    }
    }
#line 573
    return (tmp___1);
  }
  {
  {
#line 575
  children = spki_tag_compile_list(ctx, realloc___0, i);
  }
  }
#line 577
  if (! children) {
#line 578
    return ((struct spki_tag *)((void *)0));
  }
  {
  {
#line 580
  tag = spki_tag_set_new(ctx, realloc___0, children);
  }
  {
#line 581
  spki_cons_release(ctx, realloc___0, children);
  }
  }
#line 583
  return (tag);
  case_3: 
  {
  {
#line 590
  tmp___2 = spki_tag_compile_list(ctx, realloc___0, i);
  }
#line 590
  children___0 = tmp___2;
  }
#line 593
  if (! children___0) {
#line 594
    return ((struct spki_tag *)((void *)0));
  }
  {
  {
#line 596
  tmp___3 = spki_cons_nreverse(children___0);
  }
  {
#line 596
  ctx33 = ctx;
#line 596
  realloc___034 = realloc___0;
#line 596
  type35 = type;
#line 596
  children36 = tmp___3;
  {
  {
  {
#line 355
  tmp38 = (*realloc___034)(ctx33, (void *)0, (unsigned int )sizeof(struct spki_tag_list ));
  }
#line 355
  tag37 = (struct spki_tag_list *)tmp38;
  }
#line 357
  if (! ((unsigned int )type35 == 2U)) {
#line 357
    if (! ((unsigned int )type35 == 3U)) {
      {
      {
#line 357
      __assert_fail("type == SPKI_TAG_SET || type == SPKI_TAG_LIST", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                    357U, "spki_tag_list_alloc");
      }
      }
    }
  }
#line 359
  if (! tag37) {
    {
#line 360
    ret_spki_tag_list_alloc42 = (struct spki_tag *)((void *)0);
#line 360
    goto Lret_spki_tag_list_alloc;
    }
  }
  {
  {
#line 362
  spki_tag_init(& tag37->super, type35);
  }
#line 363
  tag37->children = children36;
  }
  {
#line 365
  ret_spki_tag_list_alloc42 = & tag37->super;
#line 365
  goto Lret_spki_tag_list_alloc;
  }
  }
  Lret_spki_tag_list_alloc: /* CIL Label */ 
#line 596
  tag___0 = ret_spki_tag_list_alloc42;
  }
  }
#line 599
  if (tag___0) {
#line 600
    return (tag___0);
  }
  {
  {
#line 602
  spki_cons_release(ctx, realloc___0, children___0);
  }
  }
#line 603
  return ((struct spki_tag *)((void *)0));
  case_1: 
#line 609
  return ((struct spki_tag *)(& spki_tag_any));
  case_4: 
  {
  {
#line 613
  ctx43 = ctx;
#line 613
  realloc___044 = realloc___0;
#line 613
  type45 = (enum spki_tag_type )4;
#line 613
  i46 = i;
  {
#line 303
  if (! ((unsigned int )i46->type == 0U)) {
    {
    {
#line 303
    __assert_fail("i->type == SEXP_ATOM", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  303U, "spki_tag_atom_alloc");
    }
    }
  }
#line 304
  if (! i46->atom) {
    {
    {
#line 304
    __assert_fail("i->atom", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  304U, "spki_tag_atom_alloc");
    }
    }
  }
#line 306
  if (i46->display) {
    {
    {
#line 308
    display47 = spki_string_new(ctx43, realloc___044, i46->display_length, i46->display);
    }
    }
#line 311
    if (! display47) {
      {
#line 312
      ret_spki_tag_atom_alloc58 = (struct spki_tag *)((void *)0);
#line 312
      goto Lret_spki_tag_atom_alloc___0;
      }
    }
  } else {
#line 315
    display47 = (struct spki_string *)((void *)0);
  }
  {
  {
#line 317
  atom48 = spki_string_new(ctx43, realloc___044, i46->atom_length, i46->atom);
  }
  }
#line 320
  if (! atom48) {
    {
    {
#line 322
    spki_string_release(ctx43, realloc___044, display47);
    }
    }
    {
#line 323
    ret_spki_tag_atom_alloc58 = (struct spki_tag *)((void *)0);
#line 323
    goto Lret_spki_tag_atom_alloc___0;
    }
  }
  {
  {
#line 326
  tmp49 = nettle_sexp_iterator_next(i46);
  }
  }
#line 326
  if (! tmp49) {
    {
    {
#line 328
    spki_string_release(ctx43, realloc___044, display47);
    }
    {
#line 329
    spki_string_release(ctx43, realloc___044, atom48);
    }
    }
    {
#line 330
    ret_spki_tag_atom_alloc58 = (struct spki_tag *)((void *)0);
#line 330
    goto Lret_spki_tag_atom_alloc___0;
    }
  }
  {
  {
#line 334
  tmp___051 = (*realloc___044)(ctx43, (void *)0, (unsigned int )sizeof(struct spki_tag_atom ));
  }
#line 334
  tag50 = (struct spki_tag_atom *)tmp___051;
  }
#line 335
  if (! tag50) {
    {
    {
#line 337
    spki_string_release(ctx43, realloc___044, display47);
    }
    {
#line 338
    spki_string_release(ctx43, realloc___044, atom48);
    }
    }
    {
#line 339
    ret_spki_tag_atom_alloc58 = (struct spki_tag *)((void *)0);
#line 339
    goto Lret_spki_tag_atom_alloc___0;
    }
  }
  {
  {
#line 342
  spki_tag_init(& tag50->super, type45);
  }
#line 343
  tag50->display = display47;
#line 344
  tag50->atom = atom48;
  }
  {
#line 346
  ret_spki_tag_atom_alloc58 = & tag50->super;
#line 346
  goto Lret_spki_tag_atom_alloc___0;
  }
  }
  Lret_spki_tag_atom_alloc___0: /* CIL Label */ 
#line 613
  tmp___4 = ret_spki_tag_atom_alloc58;
  }
#line 613
  tag___1 = tmp___4;
  }
#line 616
  if (! tag___1) {
#line 617
    return ((struct spki_tag *)((void *)0));
  }
#line 619
  if ((unsigned int )i->type == 2U) {
    {
    {
#line 619
    tmp___5 = nettle_sexp_iterator_exit_list(i);
    }
    }
#line 619
    if (tmp___5) {
#line 620
      return (tag___1);
    }
  }
  {
  {
#line 622
  spki_tag_release(ctx, realloc___0, tag___1);
  }
  }
#line 623
  return ((struct spki_tag *)((void *)0));
  case_5: 
#line 628
  return ((struct spki_tag *)((void *)0));

#line 632
  return ((struct spki_tag *)0);
}
}
#line 634 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_cons *spki_tag_compile_list(void *ctx , nettle_realloc_func *realloc___0 ,
                                               struct sexp_iterator *i ) 
{ 
  struct spki_cons *c ;
  struct spki_tag *tag ;
  struct spki_tag *tmp ;
  struct spki_cons *n ;
  int tmp___0 ;

  {
#line 638
  c = (struct spki_cons *)((void *)0);
  {
  {
#line 640
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 640
    if (! ((unsigned int )i->type != 2U)) {
#line 640
      goto while_break;
    }
    {
    {
#line 642
    tmp = spki_tag_compile(ctx, realloc___0, i);
    }
#line 642
    tag = tmp;
    }
#line 645
    if (! tag) {
      {
      {
#line 647
      spki_cons_release(ctx, realloc___0, c);
      }
      }
#line 648
      return ((struct spki_cons *)((void *)0));
    }
    {
    {
#line 650
    n = spki_cons(ctx, realloc___0, tag, c);
    }
    }
#line 651
    if (! n) {
#line 653
      return ((struct spki_cons *)((void *)0));
    }
#line 655
    c = n;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 658
  tmp___0 = nettle_sexp_iterator_exit_list(i);
  }
  }
#line 658
  if (! tmp___0) {
    {
    {
#line 660
    spki_cons_release(ctx, realloc___0, c);
    }
    }
#line 661
    return ((struct spki_cons *)((void *)0));
  }
#line 663
  return (c);
}
}
#line 666 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
struct spki_tag *spki_tag_from_sexp(void *ctx , nettle_realloc_func *realloc___0 ,
                                    unsigned int length , uint8_t const   *expr ) 
{ 
  struct sexp_iterator i ;
  struct spki_tag *tag ;
  int tmp ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
  {
#line 674
  tmp = nettle_sexp_iterator_first(& i, length, expr);
  }
  }
#line 674
  if (! tmp) {
#line 675
    return ((struct spki_tag *)((void *)0));
  }
  {
  {
#line 677
  tag = spki_tag_compile(ctx, realloc___0, & i);
  }
  }
#line 677
  if (tag) {
#line 677
    if ((unsigned int )i.type == 2U) {
#line 679
      return (tag);
    }
  }
  {
  {
#line 681
  spki_tag_release(ctx, realloc___0, tag);
  }
  }
#line 682
  return ((struct spki_tag *)((void *)0));
}
}
#line 688 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static int atom_prefix(struct spki_tag_atom *a , struct spki_tag_atom *b ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 691
  if (! ((unsigned int )a->super.type == 4U)) {
    {
    {
#line 691
    __assert_fail("a->super.type == SPKI_TAG_PREFIX", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  691U, "atom_prefix");
    }
    }
  }
#line 692
  if (! ((unsigned int )b->super.type == 6U)) {
    {
    {
#line 692
    __assert_fail("b->super.type == SPKI_TAG_ATOM", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  692U, "atom_prefix");
    }
    }
  }
  {
  {
#line 694
  tmp = string_equal(a->display, b->display);
  }
  }
#line 694
  if (tmp) {
    {
    {
#line 694
    tmp___0 = string_prefix(a->atom, b->atom);
    }
    }
#line 694
    if (tmp___0) {
#line 694
      tmp___1 = 1;
    } else {
#line 694
      tmp___1 = 0;
    }
  } else {
#line 694
    tmp___1 = 0;
  }
#line 694
  return (tmp___1);
}
}
#line 698 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static int atom_equal(struct spki_tag_atom *a , struct spki_tag_atom *b ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 701
  if (! ((unsigned int )a->super.type == 6U)) {
    {
    {
#line 701
    __assert_fail("a->super.type == SPKI_TAG_ATOM", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  701U, "atom_equal");
    }
    }
  }
#line 702
  if (! ((unsigned int )b->super.type == 6U)) {
    {
    {
#line 702
    __assert_fail("b->super.type == SPKI_TAG_ATOM", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  702U, "atom_equal");
    }
    }
  }
  {
  {
#line 704
  tmp = string_equal(a->display, b->display);
  }
  }
#line 704
  if (tmp) {
    {
    {
#line 704
    tmp___0 = string_equal(a->atom, b->atom);
    }
    }
#line 704
    if (tmp___0) {
#line 704
      tmp___1 = 1;
    } else {
#line 704
      tmp___1 = 0;
    }
  } else {
#line 704
    tmp___1 = 0;
  }
#line 704
  return (tmp___1);
}
}
#line 708 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static int set_includes(struct spki_cons *set , struct spki_tag *request ) 
{ 
  struct spki_cons *c ;
  struct spki_tag_list *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 715
  if ((unsigned int )request->type == 2U) {
    {
    {
#line 722
    tmp = tag_list(request);
    }
#line 722
    c = tmp->children;
    }
    {
    {
#line 722
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 722
      if (! c) {
#line 722
        goto while_break;
      }
      {
      {
#line 724
      tmp___0 = set_includes(set, c->car);
      }
      }
#line 724
      if (! tmp___0) {
#line 725
        return (0);
      }
#line 722
      c = c->cdr;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
#line 728
    return (1);
  }
  {
  {
#line 731
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 731
    if (! set) {
#line 731
      goto while_break___0;
    }
    {
    {
#line 732
    tmp___1 = spki_tag_includes(set->car, request);
    }
    }
#line 732
    if (tmp___1) {
#line 733
      return (1);
    }
#line 731
    set = set->cdr;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 735
  return (0);
}
}
#line 738 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static int list_includes(struct spki_cons *list , struct spki_tag *request ) 
{ 
  struct spki_cons *c ;
  struct spki_tag_list *tmp ;
  int tmp___0 ;

  {
#line 751
  if ((unsigned int )request->type != 3U) {
#line 752
    return (0);
  }
  {
  {
#line 754
  tmp = tag_list(request);
  }
#line 754
  c = tmp->children;
  }
  {
  {
#line 754
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 754
    if (c) {
#line 754
      if (! list) {
#line 754
        goto while_break;
      }
    } else {
#line 754
      goto while_break;
    }
    {
    {
#line 758
    tmp___0 = spki_tag_includes(list->car, c->car);
    }
    }
#line 758
    if (! tmp___0) {
#line 759
      return (0);
    }
#line 754
    list = list->cdr;
#line 754
    c = c->cdr;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 764
  return ((unsigned long )list == (unsigned long )((void *)0));
}
}
#line 769 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
int spki_tag_includes(struct spki_tag *delegated , struct spki_tag *request ) 
{ 
  struct spki_tag_atom *tmp ;
  struct spki_tag_atom *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct spki_tag_atom *tmp___3 ;
  struct spki_tag_atom *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct spki_tag_list *tmp___7 ;
  int tmp___8 ;
  struct spki_tag_list *tmp___9 ;
  int tmp___10 ;

  {
#line 778
  if ((unsigned int )delegated->type == 6U) {
#line 778
    goto case_6;
  }
#line 782
  if ((unsigned int )delegated->type == 4U) {
#line 782
    goto case_4;
  }
#line 789
  if ((unsigned int )delegated->type == 3U) {
#line 789
    goto case_3;
  }
#line 792
  if ((unsigned int )delegated->type == 1U) {
#line 792
    goto case_1;
  }
#line 795
  if ((unsigned int )delegated->type == 2U) {
#line 795
    goto case_2;
  }
#line 775
  goto switch_default;
  switch_default: 
#line 776
  return (0);
  case_6: 
#line 779
  if ((unsigned int )request->type == 6U) {
    {
    {
#line 779
    tmp = tag_atom(request);
    }
    {
#line 779
    tmp___0 = tag_atom(delegated);
    }
    {
#line 779
    tmp___1 = atom_equal(tmp___0, tmp);
    }
    }
#line 779
    if (tmp___1) {
#line 779
      tmp___2 = 1;
    } else {
#line 779
      tmp___2 = 0;
    }
  } else {
#line 779
    tmp___2 = 0;
  }
#line 779
  return (tmp___2);
  case_4: 
#line 785
  if ((unsigned int )request->type == 6U) {
#line 785
    goto _L;
  } else
#line 785
  if ((unsigned int )request->type == 4U) {
    _L: 
    {
    {
#line 785
    tmp___3 = tag_atom(request);
    }
    {
#line 785
    tmp___4 = tag_atom(delegated);
    }
    {
#line 785
    tmp___5 = atom_prefix(tmp___4, tmp___3);
    }
    }
#line 785
    if (tmp___5) {
#line 785
      tmp___6 = 1;
    } else {
#line 785
      tmp___6 = 0;
    }
  } else {
#line 785
    tmp___6 = 0;
  }
#line 785
  return (tmp___6);
  case_3: 
  {
  {
#line 790
  tmp___7 = tag_list(delegated);
  }
  {
#line 790
  tmp___8 = list_includes(tmp___7->children, request);
  }
  }
#line 790
  return (tmp___8);
  case_1: 
#line 793
  return (1);
  case_2: 
  {
  {
#line 796
  tmp___9 = tag_list(delegated);
  }
  {
#line 796
  tmp___10 = set_includes(tmp___9->children, request);
  }
  }
#line 796
  return (tmp___10);

#line 800
  return (0);
}
}
#line 805 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_tag *set_intersect(void *ctx , nettle_realloc_func *realloc___0 ,
                                      struct spki_cons *set , struct spki_tag *b ) 
{ 
  struct spki_cons *head ;
  struct spki_cons *children ;
  struct spki_tag_list *tmp ;
  struct spki_cons *p ;
  struct spki_tag *tag ;
  struct spki_tag *tmp___0 ;
  struct spki_tag *tmp___1 ;

  {
#line 810
  head = (struct spki_cons *)((void *)0);
#line 812
  if ((unsigned int )b->type == 2U) {
    {
    {
#line 814
    tmp = tag_list(b);
    }
#line 814
    children = tmp->children;
    }
    {
    {
#line 817
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 817
      if (! set) {
#line 817
        goto while_break;
      }
#line 818
      p = children;
      {
      {
#line 818
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;

#line 818
        if (! p) {
#line 818
          goto while_break___0;
        }
        {
        {
#line 820
        tmp___0 = spki_tag_intersect(ctx, realloc___0, set->car, p->car);
        }
#line 820
        tag = tmp___0;
        }
#line 822
        if (tag) {
          {
          {
#line 823
          head = spki_cons(ctx, realloc___0, tag, head);
          }
          }
#line 823
          if (! head) {
#line 824
            return ((struct spki_tag *)((void *)0));
          }
        }
#line 818
        p = p->cdr;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 817
      set = set->cdr;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 828
  if (! head) {
#line 829
    return ((struct spki_tag *)((void *)0));
  }
  {
  {
#line 831
  tmp___1 = spki_tag_set_new(ctx, realloc___0, head);
  }
  }
#line 831
  return (tmp___1);
}
}
#line 834 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_tag *list_intersect(void *ctx , nettle_realloc_func *realloc___0 ,
                                       struct spki_cons *a , struct spki_cons *b ) 
{ 
  struct spki_cons *head ;
  struct spki_tag *tag ;
  struct spki_tag *tmp ;
  struct spki_tag *tmp___0 ;
  struct spki_cons *tmp___1 ;
  struct spki_tag *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  void *ctx17 ;
  nettle_realloc_func *realloc___018 ;
  enum spki_tag_type type19 ;
  struct spki_cons *children20 ;
  struct spki_tag_list *tag21 ;
  void *tmp22 ;
  char *__cil_tmp1023 ;
  char *__cil_tmp1124 ;
  char *__cil_tmp1225 ;
  struct spki_tag *ret_spki_tag_list_alloc26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 839
  head = (struct spki_cons *)((void *)0);
  {
  {
#line 841
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 841
    if (a) {
#line 841
      if (! b) {
#line 841
        goto while_break;
      }
    } else {
#line 841
      goto while_break;
    }
    {
    {
#line 843
    tmp = spki_tag_intersect(ctx, realloc___0, a->car, b->car);
    }
#line 843
    tag = tmp;
    }
#line 845
    if (tag) {
      {
      {
#line 846
      head = spki_cons(ctx, realloc___0, tag, head);
      }
      }
#line 846
      if (! head) {
#line 847
        return ((struct spki_tag *)((void *)0));
      }
    }
#line 841
    a = a->cdr;
#line 841
    b = b->cdr;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 850
  if (! head) {
    {
    {
#line 850
    __assert_fail("head", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c", 850U,
                  "list_intersect");
    }
    }
  }
#line 853
  if (! a) {
#line 854
    a = b;
  }
  {
  {
#line 856
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 856
    if (! a) {
#line 856
      goto while_break___0;
    }
    {
    {
#line 857
    tmp___0 = spki_tag_dup(a->car);
    }
    {
#line 857
    head = spki_cons(ctx, realloc___0, tmp___0, head);
    }
    }
#line 857
    if (! head) {
#line 858
      return ((struct spki_tag *)((void *)0));
    }
#line 856
    a = a->cdr;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
  {
#line 860
  tmp___1 = spki_cons_nreverse(head);
  }
  {
#line 860
  ctx17 = ctx;
#line 860
  realloc___018 = realloc___0;
#line 860
  type19 = (enum spki_tag_type )3;
#line 860
  children20 = tmp___1;
  {
  {
  {
#line 355
  tmp22 = (*realloc___018)(ctx17, (void *)0, (unsigned int )sizeof(struct spki_tag_list ));
  }
#line 355
  tag21 = (struct spki_tag_list *)tmp22;
  }
#line 357
  if (! ((unsigned int )type19 == 2U)) {
#line 357
    if (! ((unsigned int )type19 == 3U)) {
      {
      {
#line 357
      __assert_fail("type == SPKI_TAG_SET || type == SPKI_TAG_LIST", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                    357U, "spki_tag_list_alloc");
      }
      }
    }
  }
#line 359
  if (! tag21) {
    {
#line 360
    ret_spki_tag_list_alloc26 = (struct spki_tag *)((void *)0);
#line 360
    goto Lret_spki_tag_list_alloc;
    }
  }
  {
  {
#line 362
  spki_tag_init(& tag21->super, type19);
  }
#line 363
  tag21->children = children20;
  }
  {
#line 365
  ret_spki_tag_list_alloc26 = & tag21->super;
#line 365
  goto Lret_spki_tag_list_alloc;
  }
  }
  Lret_spki_tag_list_alloc: /* CIL Label */ 
#line 860
  tmp___2 = ret_spki_tag_list_alloc26;
  }
  }
#line 860
  return (tmp___2);
}
}
#line 864 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static struct spki_tag *prefix_intersect(struct spki_tag_atom *prefix___0 , struct spki_tag *b ) 
{ 
  struct spki_tag *tmp___1 ;
  struct spki_tag *tmp___2 ;
  struct spki_tag_atom *tmp___3 ;
  int tmp___4 ;

  {
#line 868
  if ((unsigned int )b->type == 6U) {
#line 868
    goto _L;
  } else
#line 868
  if ((unsigned int )b->type == 4U) {
    _L: 
    {
    {
#line 868
    tmp___3 = tag_atom(b);
    }
    {
#line 868
    tmp___4 = atom_prefix(prefix___0, tmp___3);
    }
    }
#line 868
    if (tmp___4) {
      {
      {
#line 868
      tmp___1 = spki_tag_dup(b);
      }
#line 868
      tmp___2 = tmp___1;
      }
    } else {
#line 868
      tmp___2 = (struct spki_tag *)((void *)0);
    }
  } else {
#line 868
    tmp___2 = (struct spki_tag *)((void *)0);
  }
#line 868
  return (tmp___2);
}
}
#line 874 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
struct spki_tag *spki_tag_intersect(void *ctx , nettle_realloc_func *realloc___0 ,
                                    struct spki_tag *a , struct spki_tag *b ) 
{ 
  struct spki_tag *t ;
  struct spki_tag *tmp ;
  struct spki_tag_list *tmp___0 ;
  struct spki_tag *tmp___1 ;
  struct spki_tag_list *tmp___2 ;
  struct spki_tag_list *tmp___3 ;
  struct spki_tag *tmp___4 ;
  struct spki_tag_atom *tmp___5 ;
  struct spki_tag *tmp___6 ;
  struct spki_tag *tmp___7 ;
  struct spki_tag_atom *tmp___8 ;
  struct spki_tag_atom *tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 881
  if ((unsigned int )a->type > (unsigned int )b->type) {
#line 883
    t = a;
#line 884
    a = b;
#line 885
    b = t;
  }
#line 893
  if ((unsigned int )a->type == 1U) {
#line 893
    goto case_1;
  }
#line 896
  if ((unsigned int )a->type == 2U) {
#line 896
    goto case_2;
  }
#line 900
  if ((unsigned int )a->type == 3U) {
#line 900
    goto case_3;
  }
#line 907
  if ((unsigned int )a->type == 4U) {
#line 907
    goto case_4;
  }
#line 910
  if ((unsigned int )a->type == 5U) {
#line 910
    goto case_5;
  }
#line 914
  if ((unsigned int )a->type == 6U) {
#line 914
    goto case_6;
  }
#line 890
  goto switch_default;
  switch_default: 
  {
  {
#line 891
  abort();
  }
  }
  case_1: 
  {
  {
#line 894
  tmp = spki_tag_dup(b);
  }
  }
#line 894
  return (tmp);
  case_2: 
  {
  {
#line 897
  tmp___0 = tag_list(a);
  }
  {
#line 897
  tmp___1 = set_intersect(ctx, realloc___0, tmp___0->children, b);
  }
  }
#line 897
  return (tmp___1);
  case_3: 
#line 902
  if ((unsigned int )b->type != 3U) {
#line 903
    return ((struct spki_tag *)((void *)0));
  }
  {
  {
#line 904
  tmp___2 = tag_list(b);
  }
  {
#line 904
  tmp___3 = tag_list(a);
  }
  {
#line 904
  tmp___4 = list_intersect(ctx, realloc___0, tmp___3->children, tmp___2->children);
  }
  }
#line 904
  return (tmp___4);
  case_4: 
  {
  {
#line 908
  tmp___5 = tag_atom(a);
  }
  {
#line 908
  tmp___6 = prefix_intersect(tmp___5, b);
  }
  }
#line 908
  return (tmp___6);
  case_5: 
#line 912
  return ((struct spki_tag *)((void *)0));
  case_6: 
#line 915
  if (! ((unsigned int )b->type == 6U)) {
    {
    {
#line 915
    __assert_fail("b->type == SPKI_TAG_ATOM", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  915U, "spki_tag_intersect");
    }
    }
  }
  {
  {
#line 916
  tmp___8 = tag_atom(b);
  }
  {
#line 916
  tmp___9 = tag_atom(a);
  }
  {
#line 916
  tmp___10 = atom_equal(tmp___9, tmp___8);
  }
  }
#line 916
  if (tmp___10) {
    {
    {
#line 917
    tmp___7 = spki_tag_dup(b);
    }
    }
#line 917
    return (tmp___7);
  }
#line 919
  return ((struct spki_tag *)((void *)0));

#line 923
  return ((struct spki_tag *)0);
}
}
#line 926 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
static unsigned int list_format(struct spki_cons *c , struct nettle_buffer *buffer ) 
{ 
  unsigned int done ;
  unsigned int length ;
  unsigned int tmp ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 929
  done = 0U;
  {
  {
#line 930
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 930
    if (! c) {
#line 930
      goto while_break;
    }
    {
    {
#line 932
    tmp = spki_tag_format(c->car, buffer);
    }
#line 932
    length = tmp;
    }
#line 933
    if (! length) {
#line 934
      return (0U);
    }
#line 936
    done += length;
#line 930
    c = c->cdr;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 939
  tmp___2 = nettle_sexp_format(buffer, "%)");
  }
  }
#line 939
  if (tmp___2) {
#line 939
    tmp___1 = done + 1U;
  } else {
#line 939
    tmp___1 = 0U;
  }
#line 939
  return (tmp___1);
}
}
#line 944 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c"
unsigned int spki_tag_format(struct spki_tag *tag , struct nettle_buffer *buffer ) 
{ 
  unsigned int tmp ;
  struct spki_tag_list *self ;
  struct spki_tag_list *tmp___0 ;
  unsigned int length ;
  unsigned int prefix___0 ;
  unsigned int tmp___1 ;
  struct spki_tag_list *self___0 ;
  struct spki_tag_list *tmp___2 ;
  unsigned int length___0 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  struct spki_tag_atom *self___1 ;
  struct spki_tag_atom *tmp___5 ;
  uint8_t const   *tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  struct spki_tag_atom *self___2 ;
  struct spki_tag_atom *tmp___9 ;
  uint8_t const   *tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
#line 952
  if ((unsigned int )tag->type == 1U) {
#line 952
    goto case_1;
  }
#line 955
  if ((unsigned int )tag->type == 2U) {
#line 955
    goto case_2;
  }
#line 970
  if ((unsigned int )tag->type == 3U) {
#line 970
    goto case_3;
  }
#line 985
  if ((unsigned int )tag->type == 4U) {
#line 985
    goto case_4;
  }
#line 994
  if ((unsigned int )tag->type == 5U) {
#line 994
    goto case_5;
  }
#line 998
  if ((unsigned int )tag->type == 6U) {
#line 998
    goto case_6;
  }
#line 949
  goto switch_default;
  switch_default: 
  {
  {
#line 950
  abort();
  }
  }
  case_1: 
  {
  {
#line 953
  tmp = nettle_sexp_format(buffer, "%l", sizeof("(1:*)") - 1UL, "(1:*)");
  }
  }
#line 953
  return (tmp);
  case_2: 
  {
  {
#line 957
  tmp___0 = tag_list(tag);
  }
#line 957
  self = tmp___0;
  {
#line 961
  prefix___0 = nettle_sexp_format(buffer, "%l", sizeof("(1:*3:set") - 1UL, "(1:*3:set");
  }
  }
#line 962
  if (! prefix___0) {
#line 963
    return (0U);
  }
  {
  {
#line 965
  length = list_format(self->children, buffer);
  }
  }
#line 967
  if (length) {
#line 967
    tmp___1 = length + prefix___0;
  } else {
#line 967
    tmp___1 = 0U;
  }
#line 967
  return (tmp___1);
  case_3: 
  {
  {
#line 972
  tmp___2 = tag_list(tag);
  }
#line 972
  self___0 = tmp___2;
  {
#line 975
  tmp___3 = nettle_sexp_format(buffer, "%(");
  }
  }
#line 975
  if (! tmp___3) {
#line 976
    return (0U);
  }
#line 978
  if (! self___0->children) {
    {
    {
#line 978
    __assert_fail("self->children", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/tag.c",
                  978U, "spki_tag_format");
    }
    }
  }
  {
  {
#line 980
  length___0 = list_format(self___0->children, buffer);
  }
  }
#line 982
  if (length___0) {
#line 982
    tmp___4 = length___0 + 1U;
  } else {
#line 982
    tmp___4 = 0U;
  }
#line 982
  return (tmp___4);
  case_4: 
  {
  {
#line 987
  tmp___5 = tag_atom(tag);
  }
#line 987
  self___1 = tmp___5;
  }
#line 988
  if (self___1->display) {
#line 988
    tmp___6 = (self___1->display)->data;
  } else {
#line 988
    tmp___6 = (uint8_t const   *)((void *)0);
  }
#line 988
  if (self___1->display) {
#line 988
    tmp___7 = (self___1->display)->length;
  } else {
#line 988
    tmp___7 = 0U;
  }
  {
  {
#line 988
  tmp___8 = nettle_sexp_format(buffer, "(%l%t%s)", sizeof("1:*6:prefix") - 1UL, "1:*6:prefix",
                               tmp___7, tmp___6, (self___1->atom)->length, (self___1->atom)->data);
  }
  }
#line 988
  return (tmp___8);
  case_5: 
  {
  {
#line 996
  abort();
  }
  }
  case_6: 
  {
  {
#line 1000
  tmp___9 = tag_atom(tag);
  }
#line 1000
  self___2 = tmp___9;
  }
#line 1001
  if (self___2->display) {
#line 1001
    tmp___10 = (self___2->display)->data;
  } else {
#line 1001
    tmp___10 = (uint8_t const   *)((void *)0);
  }
#line 1001
  if (self___2->display) {
#line 1001
    tmp___11 = (self___2->display)->length;
  } else {
#line 1001
    tmp___11 = 0U;
  }
  {
  {
#line 1001
  tmp___12 = nettle_sexp_format(buffer, "%t%s", tmp___11, tmp___10, (self___2->atom)->length,
                                (self___2->atom)->data);
  }
  }
#line 1001
  return (tmp___12);

#line 1005
  return (0U);
}
}
#line 117 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
struct spki_date  const  spki_date_since_ever ;
#line 118
struct spki_date  const  spki_date_for_ever ;
#line 164
struct spki_5_tuple *spki_5_tuple_cons_new(struct spki_acl_db *db , struct spki_5_tuple_list **list ) ;
#line 168
void spki_5_tuple_list_release(struct spki_acl_db *db , struct spki_5_tuple_list *list ) ;
#line 184
struct spki_5_tuple_list *spki_5_tuple_list_filter(struct spki_acl_db *db , struct spki_5_tuple_list *list ,
                                                   void *ctx , spki_5_tuple_filter_func *filter ) ;
#line 189
struct spki_5_tuple  const  *spki_5_tuple_by_subject_next(struct spki_5_tuple_list  const  **i ,
                                                          struct spki_principal  const  *subject ) ;
#line 306
struct spki_5_tuple_list *spki_5_tuple_reduce(struct spki_acl_db *db , struct spki_5_tuple_list *sequence ) ;
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/reduce.c"
static void validity_sanity_check(struct spki_5_tuple  const  *tuple ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 39
  if (! ((unsigned int const   )tuple->flags & 2U)) {
    {
    {
#line 40
    tmp = memcmp((void const   *)(tuple->not_before.date), (void const   *)(spki_date_since_ever.date),
                 (size_t )19);
    }
    }
#line 40
    if (tmp) {
      {
      {
#line 40
      __assert_fail("!memcmp((tuple->not_before).date, (spki_date_since_ever).date, 19)",
                    "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/reduce.c", 40U,
                    "validity_sanity_check");
      }
      }
    }
  }
#line 42
  if (! ((unsigned int const   )tuple->flags & 4U)) {
    {
    {
#line 43
    tmp___0 = memcmp((void const   *)(tuple->not_after.date), (void const   *)(spki_date_for_ever.date),
                     (size_t )19);
    }
    }
#line 43
    if (tmp___0) {
      {
      {
#line 43
      __assert_fail("!memcmp((tuple->not_after).date, (spki_date_for_ever).date, 19)",
                    "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/reduce.c", 43U,
                    "validity_sanity_check");
      }
      }
    }
  }
#line 44
  return;
}
}
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/reduce.c"
static int validity_intersect(struct spki_5_tuple *result , struct spki_5_tuple  const  *a ,
                              struct spki_5_tuple  const  *b ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 51
  validity_sanity_check(a);
  }
  {
#line 52
  validity_sanity_check(b);
  }
  {
#line 54
  tmp = memcmp((void const   *)(a->not_before.date), (void const   *)(b->not_after.date),
               (size_t )19);
  }
  }
#line 54
  if (tmp > 0) {
#line 55
    return (0);
  }
  {
  {
#line 57
  tmp___0 = memcmp((void const   *)(b->not_before.date), (void const   *)(a->not_after.date),
                   (size_t )19);
  }
  }
#line 57
  if (tmp___0 > 0) {
#line 58
    return (0);
  }
#line 60
  if (result) {
    {
    {
#line 66
    tmp___1 = memcmp((void const   *)(a->not_before.date), (void const   *)(b->not_before.date),
                     (size_t )19);
    }
    }
#line 66
    if (tmp___1 > 0) {
#line 67
      result->not_before = (struct spki_date )a->not_before;
    } else {
#line 69
      result->not_before = (struct spki_date )b->not_before;
    }
    {
    {
#line 71
    tmp___2 = memcmp((void const   *)(a->not_after.date), (void const   *)(b->not_after.date),
                     (size_t )19);
    }
    }
#line 71
    if (tmp___2 < 0) {
#line 72
      result->not_after = (struct spki_date )a->not_after;
    } else {
#line 74
      result->not_after = (struct spki_date )b->not_after;
    }
#line 76
    if (! (! ((unsigned int )result->flags & 6U))) {
      {
      {
#line 76
      __assert_fail("! (result->flags & (SPKI_NOT_BEFORE | SPKI_NOT_AFTER))", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/reduce.c",
                    76U, "validity_intersect");
      }
      }
    }
    {
#line 78
    result->flags = (enum spki_5_tuple_flags )((unsigned int )result->flags | (6U & (unsigned int )((unsigned int const   )a->flags | (unsigned int const   )b->flags)));
    {
#line 81
    validity_sanity_check((struct spki_5_tuple  const  *)result);
    }
    }
  }
#line 83
  return (1);
}
}
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/reduce.c"
static int reduce_with_list(struct spki_acl_db *db , struct spki_5_tuple_list **list ,
                            struct spki_5_tuple  const  *tuple ) 
{ 
  struct spki_5_tuple  const  *known ;
  struct spki_5_tuple_list  const  *i ;
  struct spki_tag *tag ;
  struct spki_tag *tmp ;
  struct spki_5_tuple *result ;
  struct spki_5_tuple *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 97
  if (! tuple->issuer) {
    {
    {
#line 97
    __assert_fail("tuple->issuer", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/reduce.c",
                  97U, "reduce_with_list");
    }
    }
  }
#line 99
  i = (struct spki_5_tuple_list  const  *)*list;
  {
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 99
    known = spki_5_tuple_by_subject_next(& i, (struct spki_principal  const  *)tuple->issuer);
    }
    }
#line 99
    if (! known) {
#line 99
      goto while_break;
    }
#line 101
    if ((unsigned int const   )known->flags & 1U) {
      {
      {
#line 101
      tmp___2 = validity_intersect((struct spki_5_tuple *)((void *)0), known, tuple);
      }
      }
#line 101
      if (tmp___2) {
        {
        {
#line 104
        tmp = spki_tag_intersect(db->realloc_ctx, db->realloc, (struct spki_tag *)known->tag,
                                 (struct spki_tag *)tuple->tag);
        }
#line 104
        tag = tmp;
        }
#line 106
        if (tag) {
          {
          {
#line 108
          tmp___0 = spki_5_tuple_cons_new(db, list);
          }
#line 108
          result = tmp___0;
          }
#line 109
          if (! result) {
#line 110
            return (0);
          }
          {
#line 112
          result->issuer = (struct spki_principal *)known->issuer;
#line 113
          result->subject = (struct spki_principal *)tuple->subject;
#line 114
          result->tag = tag;
          {
#line 116
          tmp___1 = validity_intersect(result, known, tuple);
          }
          }
#line 116
          if (! tmp___1) {
            {
            {
#line 117
            abort();
            }
            }
          }
#line 119
          if ((unsigned int const   )tuple->flags & 1U) {
#line 120
            result->flags = (enum spki_5_tuple_flags )((unsigned int )result->flags | 1U);
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 123
  return (1);
}
}
#line 131 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/reduce.c"
struct spki_5_tuple_list *spki_5_tuple_reduce(struct spki_acl_db *db , struct spki_5_tuple_list *sequence ) 
{ 
  struct spki_5_tuple_list *result ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 137
  result = spki_5_tuple_list_filter(db, db->acls, (void *)0, (spki_5_tuple_filter_func *)((void *)0));
  }
  }
  {
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 137
    if (! sequence) {
#line 137
      goto while_break;
    }
#line 140
    if (! (sequence->car)->issuer) {
      {
      {
#line 140
      __assert_fail("sequence->car->issuer", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/reduce.c",
                    140U, "spki_5_tuple_reduce");
      }
      }
    }
    {
    {
#line 142
    tmp = reduce_with_list(db, & result, (struct spki_5_tuple  const  *)sequence->car);
    }
    }
#line 142
    if (! tmp) {
      {
      {
#line 144
      spki_5_tuple_list_release(db, result);
      }
      }
#line 145
      return ((struct spki_5_tuple_list *)((void *)0));
    }
#line 137
    sequence = sequence->cdr;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 148
  return (result);
}
}
#line 219 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
struct spki_principal *spki_principal_by_key(struct spki_acl_db *db , unsigned int key_length ,
                                             uint8_t const   *key ) ;
#line 223
struct spki_principal *spki_principal_by_md5(struct spki_acl_db *db , uint8_t const   *digest ) ;
#line 226
struct spki_principal *spki_principal_by_sha1(struct spki_acl_db *db , uint8_t const   *digest ) ;
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.h"
enum spki_type spki_iterator_first_sexp(struct spki_iterator *i , struct sexp_iterator  const  *sexp ) ;
#line 74
enum spki_type spki_parse_fail(struct spki_iterator *i ) ;
#line 77
enum spki_type spki_intern(struct spki_iterator *i ) ;
#line 80
uint8_t const   *spki_parse_prevexpr(struct spki_iterator *i , unsigned int start ,
                                     unsigned int *length ) ;
#line 84
uint8_t const   *spki_parse_string(struct spki_iterator *i , unsigned int *length ) ;
#line 91
enum spki_type spki_check_type(struct spki_iterator *i , enum spki_type type ) ;
#line 97
enum spki_type spki_parse_skip(struct spki_iterator *i ) ;
#line 102
enum spki_type spki_parse_hash(struct spki_iterator *i , struct spki_hash_value *hash___2 ) ;
#line 106
enum spki_type spki_parse_principal(struct spki_acl_db *db , struct spki_iterator *i ,
                                    struct spki_principal **principal ) ;
#line 110
enum spki_type spki_parse_subject(struct spki_acl_db *db , struct spki_iterator *i ,
                                  struct spki_principal **principal ) ;
#line 114
enum spki_type spki_parse_issuer(struct spki_acl_db *db , struct spki_iterator *i ,
                                 struct spki_principal **principal ) ;
#line 118
enum spki_type spki_parse_tag(struct spki_acl_db *db , struct spki_iterator *i , struct spki_tag **tag ) ;
#line 122
enum spki_type spki_parse_date(struct spki_iterator *i , struct spki_date *d ) ;
#line 126
enum spki_type spki_parse_valid(struct spki_iterator *i , struct spki_5_tuple *tuple ) ;
#line 130
enum spki_type spki_parse_version(struct spki_iterator *i ) ;
#line 133
enum spki_type spki_parse_acl_entry(struct spki_acl_db *db , struct spki_iterator *i ,
                                    struct spki_5_tuple *acl ) ;
#line 137
struct spki_5_tuple_list *spki_parse_acl(struct spki_acl_db *db , struct spki_iterator *i ) ;
#line 140
enum spki_type spki_parse_cert(struct spki_acl_db *db , struct spki_iterator *i ,
                               struct spki_5_tuple *cert ) ;
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
__inline struct spki_assoc  const  *spki_gperf(char const   *str , unsigned int len ) ;
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/spki-gperf.h"
__inline static unsigned int hash___0(char const   *str , unsigned int len ) ;
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/spki-gperf.h"
static unsigned char const   asso_values[256]  = 
#line 49
  {      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )15,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )0,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )10,      (unsigned char const   )45,      (unsigned char const   )15, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )45,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )5,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )5,      (unsigned char const   )45,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )10,      (unsigned char const   )45,      (unsigned char const   )15,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )0,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45, 
        (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45,      (unsigned char const   )45};
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/spki-gperf.h"
__inline static unsigned int hash___0(char const   *str , unsigned int len ) 
{ 


  {
#line 78
  return ((len + (unsigned int )asso_values[(unsigned char )*(str + (len - 1U))]) + (unsigned int )asso_values[(unsigned char )*(str + 0)]);
}
}
#line 96 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/spki-gperf.h"
static unsigned char const   lengthtable[45]  = 
#line 96
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )0,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )3,      (unsigned char const   )9,      (unsigned char const   )10, 
        (unsigned char const   )11,      (unsigned char const   )7,      (unsigned char const   )3,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )13,      (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )14};
#line 103 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/spki-gperf.h"
static struct spki_assoc  const  wordlist[45]  = 
#line 103
  {      {"", (enum spki_type )0}, 
        {"", (enum spki_type )0}, 
        {"do", (enum spki_type )5}, 
        {"md5", (enum spki_type )11}, 
        {"name", (enum spki_type )12}, 
        {"entry", (enum spki_type )7}, 
        {"", (enum spki_type )0}, 
        {"display", (enum spki_type )4}, 
        {"sequence", (enum spki_type )20}, 
        {"signature", (enum spki_type )22}, 
        {"not-before", (enum spki_type )14}, 
        {"issuer-info", (enum spki_type )10}, 
        {"subject-info", (enum spki_type )24}, 
        {"tag", (enum spki_type )25}, 
        {"propagate", (enum spki_type )15}, 
        {"public-key", (enum spki_type )17}, 
        {"private-key", (enum spki_type )16}, 
        {"subject", (enum spki_type )23}, 
        {"acl", (enum spki_type )1}, 
        {"sha1", (enum spki_type )21}, 
        {"valid", (enum spki_type )26}, 
        {"issuer", (enum spki_type )9}, 
        {"version", (enum spki_type )27}, 
        {"dsa-sha1", (enum spki_type )6}, 
        {"not-after", (enum spki_type )13}, 
        {"", (enum spki_type )0}, 
        {"", (enum spki_type )0}, 
        {"", (enum spki_type )0}, 
        {"rsa-pkcs1-md5", (enum spki_type )18}, 
        {"cert", (enum spki_type )2}, 
        {"", (enum spki_type )0}, 
        {"", (enum spki_type )0}, 
        {"comment", (enum spki_type )3}, 
        {"", (enum spki_type )0}, 
        {"hash", (enum spki_type )8}, 
        {"", (enum spki_type )0}, 
        {"", (enum spki_type )0}, 
        {"", (enum spki_type )0}, 
        {"", (enum spki_type )0}, 
        {"", (enum spki_type )0}, 
        {"", (enum spki_type )0}, 
        {"", (enum spki_type )0}, 
        {"", (enum spki_type )0}, 
        {"", (enum spki_type )0}, 
        {"rsa-pkcs1-sha1", (enum spki_type )19}};
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/spki-gperf.h"
__inline struct spki_assoc  const  *spki_gperf(char const   *str , unsigned int len ) 
{ 
  register int key ;
  unsigned int tmp ;
  register char const   *s ;
  int tmp___0 ;

  {
#line 140
  if (len <= 14U) {
#line 140
    if (len >= 2U) {
      {
      {
#line 142
      tmp = hash___0(str, len);
      }
#line 142
      key = (int )tmp;
      }
#line 144
      if (key <= 44) {
#line 144
        if (key >= 0) {
#line 145
          if (len == (unsigned int )lengthtable[key]) {
#line 147
            s = (char const   *)wordlist[key].name;
#line 149
            if ((int const   )*str == (int const   )*s) {
              {
              {
#line 149
              tmp___0 = memcmp((void const   *)(str + 1), (void const   *)(s + 1),
                               len - 1U);
              }
              }
#line 149
              if (! tmp___0) {
#line 150
                return (& wordlist[key]);
              }
            }
          }
        }
      }
    }
  }
#line 153
  return ((struct spki_assoc  const  *)0);
}
}
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_fail(struct spki_iterator *i ) 
{ 


  {
#line 49
  i->type = (enum spki_type )0;
#line 50
  return ((enum spki_type )0);
}
}
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_intern(struct spki_iterator *i ) 
{ 
  struct spki_assoc  const  *assoc ;
  struct spki_assoc  const  *tmp ;
  int tmp___0 ;
  enum spki_type tmp___1 ;

  {
#line 56
  if ((unsigned int )i->sexp.type == 0U) {
#line 56
    if (! i->sexp.display) {
      {
      {
#line 59
      tmp = spki_gperf((char const   *)i->sexp.atom, i->sexp.atom_length);
      }
#line 59
      assoc = tmp;
      }
#line 62
      if (assoc) {
        {
        {
#line 62
        tmp___0 = nettle_sexp_iterator_next(& i->sexp);
        }
        }
#line 62
        if (tmp___0) {
#line 63
          return ((enum spki_type )assoc->id);
        }
      }
    }
  }
  {
  {
#line 66
  tmp___1 = spki_parse_fail(i);
  }
  }
#line 66
  return (tmp___1);
}
}
#line 71 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_type(struct spki_iterator *i ) 
{ 
  enum spki_type tmp___0 ;
  int tmp___1 ;

  {
#line 74
  i->start = i->sexp.start;
#line 77
  if ((unsigned int )i->sexp.type == 2U) {
#line 77
    goto case_2;
  }
#line 81
  if ((unsigned int )i->sexp.type == 1U) {
#line 81
    goto case_1;
  }
#line 87
  if ((unsigned int )i->sexp.type == 0U) {
#line 87
    goto case_0;
  }
#line 75
  goto switch_break;
  case_2: 
#line 78
  i->type = (enum spki_type )28;
#line 79
  goto switch_break;
  case_1: 
  {
  {
#line 82
  tmp___1 = nettle_sexp_iterator_enter_list(& i->sexp);
  }
  }
#line 82
  if (tmp___1) {
    {
    {
#line 82
    tmp___0 = spki_intern(i);
    }
#line 82
    i->type = tmp___0;
    }
  } else {
#line 82
    i->type = (enum spki_type )0;
  }
#line 85
  goto switch_break;
  case_0: 
#line 88
  i->type = (enum spki_type )0;
#line 89
  goto switch_break;
  switch_break: ;
#line 91
  return (i->type);
}
}
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_iterator_first(struct spki_iterator *i , unsigned int length ,
                                   uint8_t const   *expr ) 
{ 
  enum spki_type tmp ;
  int tmp___0 ;
  enum spki_type tmp___1 ;

  {
  {
#line 98
  i->start = 0U;
  {
#line 99
  tmp___0 = nettle_sexp_iterator_first(& i->sexp, length, expr);
  }
  }
#line 99
  if (tmp___0) {
    {
    {
#line 100
    tmp = spki_parse_type(i);
    }
    }
#line 100
    return (tmp);
  }
  {
  {
#line 102
  tmp___1 = spki_parse_fail(i);
  }
  }
#line 102
  return (tmp___1);
}
}
#line 106 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_iterator_first_sexp(struct spki_iterator *i , struct sexp_iterator  const  *sexp ) 
{ 
  enum spki_type tmp ;

  {
  {
#line 110
  i->start = 0U;
#line 111
  i->sexp = (struct sexp_iterator )*sexp;
  {
#line 113
  tmp = spki_parse_type(i);
  }
  }
#line 113
  return (tmp);
}
}
#line 116 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_end(struct spki_iterator *i ) 
{ 
  enum spki_type tmp ;
  enum spki_type tmp___0 ;
  int tmp___1 ;

  {
#line 119
  if (i->type) {
#line 119
    if ((unsigned int )i->sexp.type == 2U) {
      {
      {
#line 119
      tmp___1 = nettle_sexp_iterator_exit_list(& i->sexp);
      }
      }
#line 119
      if (tmp___1) {
        {
        {
#line 121
        tmp = spki_parse_type(i);
        }
        }
#line 121
        return (tmp);
      } else {
        {
        {
#line 123
        tmp___0 = spki_parse_fail(i);
        }
        }
#line 123
        return (tmp___0);
      }
    } else {
      {
      {
#line 123
      tmp___0 = spki_parse_fail(i);
      }
      }
#line 123
      return (tmp___0);
    }
  } else {
    {
    {
#line 123
    tmp___0 = spki_parse_fail(i);
    }
    }
#line 123
    return (tmp___0);
  }
}
}
#line 128 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_check_type(struct spki_iterator *i , enum spki_type type ) 
{ 
  enum spki_type tmp ;
  enum spki_type tmp___0 ;

  {
#line 131
  if ((unsigned int )i->type != (unsigned int )type) {
    {
    {
#line 132
    tmp = spki_parse_fail(i);
    }
    }
#line 132
    return (tmp);
  }
  {
  {
#line 134
  tmp___0 = spki_parse_type(i);
  }
  }
#line 134
  return (tmp___0);
}
}
#line 137 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_skip(struct spki_iterator *i ) 
{ 
  enum spki_type tmp ;
  enum spki_type tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 140
  tmp___1 = nettle_sexp_iterator_exit_list(& i->sexp);
  }
  }
#line 140
  if (tmp___1) {
    {
    {
#line 141
    tmp = spki_parse_type(i);
    }
    }
#line 141
    return (tmp);
  } else {
    {
    {
#line 143
    tmp___0 = spki_parse_fail(i);
    }
    }
#line 143
    return (tmp___0);
  }
}
}
#line 146 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
uint8_t const   *spki_parse_prevexpr(struct spki_iterator *i , unsigned int start ,
                                     unsigned int *length ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 150
  if (! (start < i->start)) {
    {
    {
#line 150
    __assert_fail("start < i->start", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c",
                  150U, "spki_parse_prevexpr");
    }
    }
  }
#line 151
  *length = i->start - start;
#line 152
  return (i->sexp.buffer + start);
}
}
#line 155 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
uint8_t const   *spki_parse_string(struct spki_iterator *i , unsigned int *length ) 
{ 
  uint8_t const   *contents ;
  int tmp ;

  {
#line 159
  if ((unsigned int )i->sexp.type == 0U) {
#line 159
    if (! i->sexp.display) {
      {
#line 162
      contents = i->sexp.atom;
#line 163
      *length = i->sexp.atom_length;
      {
#line 165
      tmp = nettle_sexp_iterator_next(& i->sexp);
      }
      }
#line 165
      if (tmp) {
#line 166
        return (contents);
      }
    }
  }
#line 168
  return ((uint8_t const   *)((void *)0));
}
}
#line 171 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_hash(struct spki_iterator *i , struct spki_hash_value *hash___2 ) 
{ 
  enum spki_type tmp ;
  enum spki_type tmp___0 ;
  enum spki_type tmp___1 ;
  uint8_t const   *tmp___2 ;

  {
#line 175
  if ((unsigned int )i->type == 8U) {
    {
    {
#line 175
    tmp___1 = spki_intern(i);
    }
#line 175
    hash___2->type = tmp___1;
    }
#line 175
    if (tmp___1) {
      {
      {
#line 175
      tmp___2 = spki_parse_string(i, & hash___2->length);
      }
#line 175
      hash___2->digest = tmp___2;
      }
#line 175
      if (tmp___2) {
        {
        {
#line 178
        tmp = spki_parse_end(i);
        }
        }
#line 178
        return (tmp);
      } else {
        {
        {
#line 180
        tmp___0 = spki_parse_fail(i);
        }
        }
#line 180
        return (tmp___0);
      }
    } else {
      {
      {
#line 180
      tmp___0 = spki_parse_fail(i);
      }
      }
#line 180
      return (tmp___0);
    }
  } else {
    {
    {
#line 180
    tmp___0 = spki_parse_fail(i);
    }
    }
#line 180
    return (tmp___0);
  }
}
}
#line 183 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_principal(struct spki_acl_db *db , struct spki_iterator *i ,
                                    struct spki_principal **principal ) 
{ 
  enum spki_type tmp ;
  unsigned int start ;
  unsigned int key_length ;
  uint8_t const   *key ;
  enum spki_type tmp___0 ;
  enum spki_type tmp___1 ;
  enum spki_type tmp___2 ;
  struct spki_principal *tmp___3 ;
  struct spki_hash_value hash___2 ;
  enum spki_type tmp___4 ;
  enum spki_type tmp___5 ;
  enum spki_type tmp___6 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 192
  if ((unsigned int )i->type == 17U) {
#line 192
    goto case_17;
  }
#line 212
  if ((unsigned int )i->type == 8U) {
#line 212
    goto case_8;
  }
#line 189
  goto switch_default;
  switch_default: 
  {
  {
#line 190
  tmp = spki_parse_fail(i);
  }
  }
#line 190
  return (tmp);
  case_17: 
  {
#line 194
  start = i->start;
  {
#line 199
  tmp___1 = spki_parse_skip(i);
  }
  }
#line 199
  if (! tmp___1) {
    {
    {
#line 200
    tmp___0 = spki_parse_fail(i);
    }
    }
#line 200
    return (tmp___0);
  }
  {
  {
#line 202
  key = spki_parse_prevexpr(i, start, & key_length);
  }
  }
#line 204
  if (! key) {
    {
    {
#line 204
    __assert_fail("key", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c", 204U,
                  "spki_parse_principal");
    }
    }
  }
  {
  {
#line 206
  tmp___3 = spki_principal_by_key(db, key_length, key);
  }
#line 206
  *principal = tmp___3;
  }
#line 206
  if (tmp___3) {
#line 207
    return (i->type);
  } else {
    {
    {
#line 209
    tmp___2 = spki_parse_fail(i);
    }
    }
#line 209
    return (tmp___2);
  }
  case_8: 
  {
  {
#line 216
  tmp___5 = spki_parse_hash(i, & hash___2);
  }
  }
#line 216
  if (tmp___5) {
#line 218
    if ((unsigned int )hash___2.type == 11U) {
#line 218
      if (hash___2.length == 16U) {
        {
        {
#line 220
        *principal = spki_principal_by_md5(db, hash___2.digest);
        }
        }
      } else {
#line 218
        goto _L;
      }
    } else
    _L: 
#line 222
    if ((unsigned int )hash___2.type == 21U) {
#line 222
      if (hash___2.length == 20U) {
        {
        {
#line 224
        *principal = spki_principal_by_sha1(db, hash___2.digest);
        }
        }
      } else {
        {
        {
#line 226
        tmp___4 = spki_parse_fail(i);
        }
        }
#line 226
        return (tmp___4);
      }
    } else {
      {
      {
#line 226
      tmp___4 = spki_parse_fail(i);
      }
      }
#line 226
      return (tmp___4);
    }
#line 228
    return (i->type);
  }
  {
  {
#line 230
  tmp___6 = spki_parse_fail(i);
  }
  }
#line 230
  return (tmp___6);

#line 234
  return ((enum spki_type )0);
}
}
#line 235 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_subject(struct spki_acl_db *db , struct spki_iterator *i ,
                                  struct spki_principal **principal ) 
{ 
  enum spki_type tmp ;
  enum spki_type tmp___0 ;
  enum spki_type tmp___1 ;
  enum spki_type tmp___2 ;

  {
  {
  {
#line 239
  tmp___0 = spki_check_type(i, (enum spki_type )23);
  }
  }
#line 239
  if (tmp___0) {
    {
    {
#line 239
    tmp___1 = spki_parse_principal(db, i, principal);
    }
    }
#line 239
    if (! tmp___1) {
      {
      {
#line 241
      tmp = spki_parse_fail(i);
      }
      }
#line 241
      return (tmp);
    }
  } else {
    {
    {
#line 241
    tmp = spki_parse_fail(i);
    }
    }
#line 241
    return (tmp);
  }
  {
  {
#line 243
  tmp___2 = spki_parse_end(i);
  }
  }
#line 243
  return (tmp___2);
}
}
#line 246 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_issuer(struct spki_acl_db *db , struct spki_iterator *i ,
                                 struct spki_principal **principal ) 
{ 
  enum spki_type tmp ;
  enum spki_type tmp___0 ;
  enum spki_type tmp___1 ;
  enum spki_type tmp___2 ;

  {
  {
  {
#line 250
  tmp___0 = spki_check_type(i, (enum spki_type )9);
  }
  }
#line 250
  if (tmp___0) {
    {
    {
#line 250
    tmp___1 = spki_parse_principal(db, i, principal);
    }
    }
#line 250
    if (! tmp___1) {
      {
      {
#line 252
      tmp = spki_parse_fail(i);
      }
      }
#line 252
      return (tmp);
    }
  } else {
    {
    {
#line 252
    tmp = spki_parse_fail(i);
    }
    }
#line 252
    return (tmp);
  }
  {
  {
#line 254
  tmp___2 = spki_parse_end(i);
  }
  }
#line 254
  return (tmp___2);
}
}
#line 257 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_tag(struct spki_acl_db *db , struct spki_iterator *i , struct spki_tag **tag ) 
{ 
  enum spki_type tmp ;
  enum spki_type tmp___0 ;
  struct spki_tag *tmp___1 ;

  {
#line 261
  if ((unsigned int )i->type == 25U) {
    {
    {
#line 261
    tmp___1 = spki_tag_compile(db->realloc_ctx, db->realloc, & i->sexp);
    }
#line 261
    *tag = tmp___1;
    }
#line 261
    if (tmp___1) {
      {
      {
#line 264
      tmp = spki_parse_end(i);
      }
      }
#line 264
      return (tmp);
    } else {
      {
      {
#line 266
      tmp___0 = spki_parse_fail(i);
      }
      }
#line 266
      return (tmp___0);
    }
  } else {
    {
    {
#line 266
    tmp___0 = spki_parse_fail(i);
    }
    }
#line 266
    return (tmp___0);
  }
}
}
#line 269 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_date(struct spki_iterator *i , struct spki_date *d ) 
{ 
  unsigned int date_length ;
  uint8_t const   *date_string ;
  enum spki_type next ;
  enum spki_type tmp ;

  {
  {
  {
#line 277
  date_string = spki_parse_string(i, & date_length);
  }
  }
#line 277
  if (date_string) {
#line 277
    if (date_length == 19U) {
#line 277
      if ((int const   )*(date_string + 4) == 45) {
#line 277
        if ((int const   )*(date_string + 7) == 45) {
#line 277
          if ((int const   )*(date_string + 10) == 95) {
#line 277
            if ((int const   )*(date_string + 13) == 58) {
#line 277
              if ((int const   )*(date_string + 16) == 58) {
                {
                {
#line 277
                next = spki_parse_end(i);
                }
                }
#line 277
                if (next) {
                  {
                  {
#line 286
                  memcpy((void */* __restrict  */)((void *)(d->date)), (void const   */* __restrict  */)((void const   *)date_string),
                         (size_t )19);
                  }
                  }
#line 287
                  return (next);
                }
              }
            }
          }
        }
      }
    }
  }
  {
  {
#line 289
  tmp = spki_parse_fail(i);
  }
  }
#line 289
  return (tmp);
}
}
#line 292 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_valid(struct spki_iterator *i , struct spki_5_tuple *tuple ) 
{ 
  enum spki_type tmp ;
  enum spki_type tmp___0 ;
  enum spki_type tmp___1 ;
  enum spki_type tmp___2 ;
  enum spki_type tmp___3 ;

  {
  {
  {
#line 296
  tmp___0 = spki_check_type(i, (enum spki_type )26);
  }
  }
#line 296
  if (! tmp___0) {
    {
    {
#line 297
    tmp = spki_parse_fail(i);
    }
    }
#line 297
    return (tmp);
  }
#line 299
  if ((unsigned int )i->type == 14U) {
    {
    {
#line 301
    tmp___1 = spki_parse_date(i, & tuple->not_before);
    }
    }
#line 301
    if (tmp___1) {
#line 302
      tuple->flags = (enum spki_5_tuple_flags )((unsigned int )tuple->flags | 2U);
    }
  }
#line 305
  if ((unsigned int )i->type == 13U) {
    {
    {
#line 307
    tmp___2 = spki_parse_date(i, & tuple->not_after);
    }
    }
#line 307
    if (tmp___2) {
#line 308
      tuple->flags = (enum spki_5_tuple_flags )((unsigned int )tuple->flags | 4U);
    }
  }
  {
  {
#line 312
  tmp___3 = spki_parse_end(i);
  }
  }
#line 312
  return (tmp___3);
}
}
#line 315 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
static int spki_parse_uint32(struct spki_iterator *i , uint32_t *x ) 
{ 
  int tmp ;

  {
  {
  {
#line 318
  tmp = nettle_sexp_iterator_get_uint32(& i->sexp, x);
  }
  }
#line 318
  return (tmp);
}
}
#line 322 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_version(struct spki_iterator *i ) 
{ 
  uint32_t version ;
  enum spki_type tmp ;
  enum spki_type tmp___0 ;
  int tmp___1 ;

  {
#line 327
  if ((unsigned int )i->type == 27U) {
    {
    {
#line 327
    tmp___1 = spki_parse_uint32(i, & version);
    }
    }
#line 327
    if (tmp___1) {
#line 327
      if (version == 0U) {
        {
        {
#line 330
        tmp = spki_parse_end(i);
        }
        }
#line 330
        return (tmp);
      } else {
        {
        {
#line 332
        tmp___0 = spki_parse_fail(i);
        }
        }
#line 332
        return (tmp___0);
      }
    } else {
      {
      {
#line 332
      tmp___0 = spki_parse_fail(i);
      }
      }
#line 332
      return (tmp___0);
    }
  } else {
    {
    {
#line 332
    tmp___0 = spki_parse_fail(i);
    }
    }
#line 332
    return (tmp___0);
  }
}
}
#line 336 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_acl_entry(struct spki_acl_db *db , struct spki_iterator *i ,
                                    struct spki_5_tuple *acl ) 
{ 
  enum spki_type tmp ;
  enum spki_type tmp___0 ;
  enum spki_type tmp___1 ;

  {
  {
  {
#line 344
  tmp___0 = spki_check_type(i, (enum spki_type )7);
  }
  }
#line 344
  if (! tmp___0) {
    {
    {
#line 345
    tmp = spki_parse_fail(i);
    }
    }
#line 345
    return (tmp);
  }
  {
  {
#line 350
  spki_parse_subject(db, i, & acl->subject);
  }
  }
#line 352
  if ((unsigned int )i->type == 15U) {
    {
#line 354
    acl->flags = (enum spki_5_tuple_flags )((unsigned int )acl->flags | 1U);
    {
#line 355
    spki_parse_end(i);
    }
    }
  }
  {
  {
#line 358
  spki_parse_tag(db, i, & acl->tag);
  }
  }
#line 360
  if ((unsigned int )i->type == 3U) {
    {
    {
#line 361
    spki_parse_skip(i);
    }
    }
  }
#line 363
  if ((unsigned int )i->type == 26U) {
    {
    {
#line 364
    spki_parse_valid(i, acl);
    }
    }
  }
  {
  {
#line 366
  tmp___1 = spki_parse_end(i);
  }
  }
#line 366
  return (tmp___1);
}
}
#line 369 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
struct spki_5_tuple_list *spki_parse_acl(struct spki_acl_db *db , struct spki_iterator *i ) 
{ 
  struct spki_5_tuple_list *list ;
  enum spki_type tmp ;
  enum spki_type tmp___0 ;
  struct spki_5_tuple *acl ;
  struct spki_5_tuple *tmp___1 ;
  enum spki_type tmp___2 ;

  {
  {
#line 372
  list = (struct spki_5_tuple_list *)((void *)0);
  {
#line 374
  tmp = spki_check_type(i, (enum spki_type )1);
  }
  }
#line 374
  if (! tmp) {
#line 375
    return ((struct spki_5_tuple_list *)0);
  }
#line 377
  if ((unsigned int )i->type == 27U) {
    {
    {
#line 378
    spki_parse_version(i);
    }
    }
  }
  {
  {
#line 380
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 383
    if ((unsigned int )i->type == 28U) {
#line 383
      goto case_28;
    }
#line 392
    if ((unsigned int )i->type == 7U) {
#line 392
      goto case_7;
    }
#line 388
    goto fail;
    case_28: 
    {
    {
#line 384
    tmp___0 = spki_parse_end(i);
    }
    }
#line 384
    if (tmp___0) {
#line 385
      return (list);
    }
    fail: 
    {
    {
#line 390
    spki_5_tuple_list_release(db, list);
    }
    }
#line 391
    return ((struct spki_5_tuple_list *)((void *)0));
    case_7: 
    {
    {
#line 394
    tmp___1 = spki_5_tuple_cons_new(db, & list);
    }
#line 394
    acl = tmp___1;
    }
#line 395
    if (! acl) {
#line 396
      goto fail;
    }
    {
    {
#line 398
    tmp___2 = spki_parse_acl_entry(db, i, acl);
    }
    }
#line 398
    if (! tmp___2) {
#line 399
      goto fail;
    }

  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 407
  return ((struct spki_5_tuple_list *)0);
}
}
#line 405 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.c"
enum spki_type spki_parse_cert(struct spki_acl_db *db , struct spki_iterator *i ,
                               struct spki_5_tuple *cert ) 
{ 
  enum spki_type tmp ;
  enum spki_type tmp___0 ;
  enum spki_type tmp___1 ;

  {
  {
  {
#line 409
  tmp___0 = spki_check_type(i, (enum spki_type )2);
  }
  }
#line 409
  if (! tmp___0) {
    {
    {
#line 410
    tmp = spki_parse_fail(i);
    }
    }
#line 410
    return (tmp);
  }
#line 412
  if ((unsigned int )i->type == 27U) {
    {
    {
#line 413
    spki_parse_version(i);
    }
    }
  }
#line 415
  if ((unsigned int )i->type == 4U) {
    {
    {
#line 416
    spki_parse_skip(i);
    }
    }
  }
  {
  {
#line 418
  spki_parse_issuer(db, i, & cert->issuer);
  }
  }
#line 420
  if ((unsigned int )i->type == 10U) {
    {
    {
#line 421
    spki_parse_skip(i);
    }
    }
  }
  {
  {
#line 423
  spki_parse_subject(db, i, & cert->subject);
  }
  }
#line 425
  if ((unsigned int )i->type == 24U) {
    {
    {
#line 426
    spki_parse_skip(i);
    }
    }
  }
#line 428
  if ((unsigned int )i->type == 15U) {
    {
#line 430
    cert->flags = (enum spki_5_tuple_flags )((unsigned int )cert->flags | 1U);
    {
#line 431
    spki_parse_end(i);
    }
    }
  }
  {
  {
#line 434
  spki_parse_tag(db, i, & cert->tag);
  }
  }
#line 436
  if ((unsigned int )i->type == 26U) {
    {
    {
#line 437
    spki_parse_valid(i, cert);
    }
    }
  }
#line 439
  if ((unsigned int )i->type == 3U) {
    {
    {
#line 440
    spki_parse_skip(i);
    }
    }
  }
  {
  {
#line 442
  tmp___1 = spki_parse_end(i);
  }
  }
#line 442
  return (tmp___1);
}
}
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse.h"
enum spki_type spki_transport_iterator_first(struct spki_iterator *i , unsigned int length ,
                                             uint8_t *expr ) ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/parse-transport.c"
enum spki_type spki_transport_iterator_first(struct spki_iterator *i , unsigned int length ,
                                             uint8_t *expr ) 
{ 
  enum spki_type tmp ;
  int tmp___0 ;
  enum spki_type tmp___1 ;

  {
  {
#line 35
  i->start = 0U;
  {
#line 36
  tmp___0 = nettle_sexp_transport_iterator_first(& i->sexp, length, expr);
  }
  }
#line 36
  if (tmp___0) {
    {
    {
#line 37
    tmp = spki_parse_type(i);
    }
    }
#line 37
    return (tmp);
  }
  {
  {
#line 39
  tmp___1 = spki_parse_fail(i);
  }
  }
#line 39
  return (tmp___1);
}
}
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
struct spki_type_name  const  spki_type_names[28] ;
#line 25 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/names.c"
struct spki_type_name  const  spki_type_names[28]  = 
#line 25 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/names.c"
  {      {0U, (uint8_t const   *)((void *)0)}, 
        {3U, (uint8_t const   *)"acl"}, 
        {4U, (uint8_t const   *)"cert"}, 
        {7U, (uint8_t const   *)"comment"}, 
        {7U, (uint8_t const   *)"display"}, 
        {2U, (uint8_t const   *)"do"}, 
        {8U, (uint8_t const   *)"dsa-sha1"}, 
        {5U, (uint8_t const   *)"entry"}, 
        {4U, (uint8_t const   *)"hash"}, 
        {6U, (uint8_t const   *)"issuer"}, 
        {11U, (uint8_t const   *)"issuer-info"}, 
        {3U, (uint8_t const   *)"md5"}, 
        {4U, (uint8_t const   *)"name"}, 
        {9U, (uint8_t const   *)"not-after"}, 
        {10U, (uint8_t const   *)"not-before"}, 
        {9U, (uint8_t const   *)"propagate"}, 
        {11U, (uint8_t const   *)"private-key"}, 
        {10U, (uint8_t const   *)"public-key"}, 
        {13U, (uint8_t const   *)"rsa-pkcs1-md5"}, 
        {14U, (uint8_t const   *)"rsa-pkcs1-sha1"}, 
        {8U, (uint8_t const   *)"sequence"}, 
        {4U, (uint8_t const   *)"sha1"}, 
        {9U, (uint8_t const   *)"signature"}, 
        {7U, (uint8_t const   *)"subject"}, 
        {12U, (uint8_t const   *)"subject-info"}, 
        {3U, (uint8_t const   *)"tag"}, 
        {5U, (uint8_t const   *)"valid"}, 
        {7U, (uint8_t const   *)"version"}};
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t const   * __restrict  __timer ,
                                                         struct tm * __restrict  __tp ) ;
#line 122 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.h"
void spki_date_from_time_t(struct spki_date *d , time_t t ) ;
#line 126
int spki_date_cmp_time_t(struct spki_date *d , time_t t ) ;
#line 154
void spki_5_tuple_init(struct spki_5_tuple *tuple ) ;
#line 172
struct spki_5_tuple_list *spki_5_tuple_list_nappend(struct spki_5_tuple_list *a ,
                                                    struct spki_5_tuple_list *b ) ;
#line 176
struct spki_5_tuple_list *spki_5_tuple_list_nreverse(struct spki_5_tuple_list *c ) ;
#line 193
struct spki_5_tuple  const  *spki_5_tuple_by_authorization_next(struct spki_5_tuple_list  const  **i ,
                                                                struct spki_tag *request ) ;
#line 209
void spki_acl_init(struct spki_acl_db *db ) ;
#line 212
void spki_acl_clear(struct spki_acl_db *db ) ;
#line 229
void spki_principal_free_chain(struct spki_acl_db *db , struct spki_principal *chain ) ;
#line 233
struct spki_principal  const  *spki_principal_normalize(struct spki_principal  const  *principal ) ;
#line 239
struct spki_5_tuple  const  *spki_acl_by_subject_first(struct spki_acl_db *db , struct spki_5_tuple_list  const  **i ,
                                                       struct spki_principal  const  *subject ) ;
#line 244
struct spki_5_tuple  const  *spki_acl_by_subject_next(struct spki_5_tuple_list  const  **i ,
                                                      struct spki_principal  const  *subject ) ;
#line 248
struct spki_5_tuple  const  *spki_acl_by_authorization_first(struct spki_acl_db *db ,
                                                             struct spki_5_tuple_list  const  **i ,
                                                             struct spki_tag *request ) ;
#line 253
struct spki_5_tuple  const  *spki_acl_by_authorization_next(struct spki_5_tuple_list  const  **i ,
                                                            struct spki_tag *request ) ;
#line 257
int spki_acl_process(struct spki_acl_db *db , struct spki_iterator *i ) ;
#line 261
unsigned int spki_acl_format(struct spki_5_tuple_list  const  *list , struct nettle_buffer *buffer ) ;
#line 268
int spki_hash_verify(struct spki_hash_value  const  *hash___2 , unsigned int length ,
                     uint8_t const   *data ) ;
#line 284
void spki_tag_free(struct spki_acl_db *db , struct spki_tag *tag ) ;
#line 292
int spki_parse_sequence_no_signatures(struct spki_acl_db *db , struct spki_iterator *i ,
                                      struct spki_5_tuple_list **list , struct spki_principal  const  **subject ) ;
#line 298
int spki_parse_sequence(struct spki_acl_db *db , struct spki_iterator *i , struct spki_5_tuple_list **list ,
                        struct spki_principal  const  **subject , void *verify_ctx ,
                        spki_verify_func *verify ) ;
#line 319
uint8_t *spki_dup(struct spki_acl_db *db , unsigned int length , uint8_t const   *data ) ;
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
void spki_acl_init(struct spki_acl_db *db ) 
{ 


  {
#line 42
  db->realloc_ctx = (void *)0;
#line 43
  db->realloc = & nettle_realloc;
#line 44
  db->first_principal = (struct spki_principal *)((void *)0);
#line 45
  db->acls = (struct spki_5_tuple_list *)((void *)0);
#line 46
  return;
}
}
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
void spki_acl_clear(struct spki_acl_db *db ) 
{ 


  {
  {
  {
#line 51
  spki_principal_free_chain(db, db->first_principal);
  }
#line 52
  db->first_principal = (struct spki_principal *)((void *)0);
  {
#line 53
  spki_5_tuple_list_release(db, db->acls);
  }
#line 54
  db->acls = (struct spki_5_tuple_list *)((void *)0);
  }
#line 55
  return;
}
}
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
uint8_t *spki_dup(struct spki_acl_db *db , unsigned int length , uint8_t const   *data ) 
{ 
  uint8_t *n ;
  void *tmp ;

  {
  {
  {
#line 61
  tmp = (*(db->realloc))(db->realloc_ctx, (void *)0, length);
  }
#line 61
  n = (uint8_t *)tmp;
  }
#line 63
  if (n) {
    {
    {
#line 64
    memcpy((void */* __restrict  */)((void *)n), (void const   */* __restrict  */)((void const   *)data),
           length);
    }
    }
  }
#line 66
  return (n);
}
}
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
static void hash_data(struct spki_hashes *hashes , unsigned int length , uint8_t const   *data ) 
{ 
  struct md5_ctx ctx ;
  struct sha1_ctx ctx___0 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;

  {
  {
  {
#line 81
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 81
    nettle_md5_init(& ctx);
    }
    {
#line 81
    nettle_md5_update(& ctx, length, data);
    }
    {
#line 81
    nettle_md5_digest(& ctx, (unsigned int )sizeof(hashes->md5), hashes->md5);
    }
    }
#line 81
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 82
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 82
    nettle_sha1_init(& ctx___0);
    }
    {
#line 82
    nettle_sha1_update(& ctx___0, length, data);
    }
    {
#line 82
    nettle_sha1_digest(& ctx___0, (unsigned int )sizeof(hashes->sha1), hashes->sha1);
    }
    }
#line 82
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 83
  return;
}
}
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
static struct spki_principal *spki_principal_add_key(struct spki_acl_db *db , unsigned int key_length ,
                                                     uint8_t const   *key , struct spki_hashes  const  *hashes ) 
{ 
  struct spki_principal *principal ;
  void *tmp ;
  uint8_t *tmp___0 ;

  {
  {
  {
#line 91
  tmp = (*(db->realloc))(db->realloc_ctx, (void *)0, (unsigned int )sizeof(struct spki_principal ));
  }
#line 91
  principal = (struct spki_principal *)tmp;
  }
#line 92
  if (! principal) {
#line 93
    return ((struct spki_principal *)((void *)0));
  }
  {
#line 95
  principal->alias = (struct spki_principal *)((void *)0);
#line 96
  principal->verifier = (void *)0;
  {
#line 98
  tmp___0 = spki_dup(db, key_length, key);
  }
#line 98
  principal->key = tmp___0;
  }
#line 98
  if (! tmp___0) {
    {
    {
#line 100
    (*(db->realloc))(db->realloc_ctx, (void *)principal, 0U);
    }
    }
#line 101
    return ((struct spki_principal *)((void *)0));
  }
#line 104
  principal->key_length = key_length;
#line 106
  if (hashes) {
#line 107
    principal->hashes = (struct spki_hashes )*hashes;
  } else {
    {
    {
#line 109
    hash_data(& principal->hashes, key_length, key);
    }
    }
  }
#line 111
  principal->flags = (enum spki_principal_flags )3;
#line 113
  principal->next = db->first_principal;
#line 114
  db->first_principal = principal;
#line 116
  return (principal);
}
}
#line 119 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
static struct spki_principal *spki_principal_add_md5(struct spki_acl_db *db , uint8_t const   *md5 ) 
{ 
  struct spki_principal *principal ;
  void *tmp ;

  {
  {
  {
#line 123
  tmp = (*(db->realloc))(db->realloc_ctx, (void *)0, (unsigned int )sizeof(struct spki_principal ));
  }
#line 123
  principal = (struct spki_principal *)tmp;
  }
#line 124
  if (! principal) {
#line 125
    return ((struct spki_principal *)((void *)0));
  }
  {
#line 127
  principal->key = (uint8_t *)((void *)0);
#line 128
  principal->alias = (struct spki_principal *)((void *)0);
#line 129
  principal->verifier = (void *)0;
  {
#line 131
  memcpy((void */* __restrict  */)((void *)(principal->hashes.md5)), (void const   */* __restrict  */)((void const   *)md5),
         (size_t )sizeof(principal->hashes.md5));
  }
#line 132
  principal->flags = (enum spki_principal_flags )1;
#line 134
  principal->next = db->first_principal;
#line 135
  db->first_principal = principal;
  }
#line 137
  return (principal);
}
}
#line 140 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
static struct spki_principal *spki_principal_add_sha1(struct spki_acl_db *db , uint8_t const   *sha1 ) 
{ 
  struct spki_principal *principal ;
  void *tmp ;

  {
  {
  {
#line 144
  tmp = (*(db->realloc))(db->realloc_ctx, (void *)0, (unsigned int )sizeof(struct spki_principal ));
  }
#line 144
  principal = (struct spki_principal *)tmp;
  }
#line 145
  if (! principal) {
#line 146
    return ((struct spki_principal *)((void *)0));
  }
  {
#line 148
  principal->key = (uint8_t *)((void *)0);
#line 149
  principal->alias = (struct spki_principal *)((void *)0);
#line 150
  principal->verifier = (void *)0;
  {
#line 152
  memcpy((void */* __restrict  */)((void *)(principal->hashes.sha1)), (void const   */* __restrict  */)((void const   *)sha1),
         (size_t )sizeof(principal->hashes.sha1));
  }
#line 153
  principal->flags = (enum spki_principal_flags )2;
#line 155
  principal->next = db->first_principal;
#line 156
  db->first_principal = principal;
  }
#line 158
  return (principal);
}
}
#line 167 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
static void spki_principal_fix_aliases(struct spki_principal *principal ) 
{ 
  struct spki_principal *s ;
  int tmp ;
  int tmp___0 ;

  {
#line 172
  s = principal->next;
  {
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 172
    if (! s) {
#line 172
      goto while_break;
    }
#line 174
    if (s->key) {
#line 175
      goto __Cont;
    } else
#line 174
    if (s->alias) {
#line 175
      goto __Cont;
    }
#line 177
    if ((unsigned int )s->flags == 1U) {
      {
      {
#line 177
      tmp = memcmp((void const   *)(s->hashes.md5), (void const   *)(principal->hashes.md5),
                   (size_t )sizeof(s->hashes.md5));
      }
      }
#line 177
      if (tmp) {
#line 177
        goto _L;
      } else {
#line 178
        s->alias = principal;
      }
    } else
    _L: 
#line 177
    if ((unsigned int )s->flags == 2U) {
      {
      {
#line 177
      tmp___0 = memcmp((void const   *)(s->hashes.sha1), (void const   *)(principal->hashes.sha1),
                       (size_t )sizeof(s->hashes.sha1));
      }
      }
#line 177
      if (! tmp___0) {
#line 178
        s->alias = principal;
      }
    }
    __Cont: 
#line 172
    s = s->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 180
  return;
}
}
#line 182 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_principal *spki_principal_by_key(struct spki_acl_db *db , unsigned int key_length ,
                                             uint8_t const   *key ) 
{ 
  struct spki_principal *s ;
  struct spki_hashes hashes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct spki_principal *tmp___2 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;

  {
  {
  {
#line 189
  hash_data(& hashes, key_length, key);
  }
#line 191
  s = db->first_principal;
  }
  {
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 191
    if (! s) {
#line 191
      goto while_break;
    }
#line 193
    if (s->key) {
#line 196
      if (s->key_length == key_length) {
        {
        {
#line 196
        tmp = memcmp((void const   *)s->key, (void const   *)key, key_length);
        }
        }
#line 196
        if (! tmp) {
#line 198
          return (s);
        }
      }
    } else
#line 202
    if ((unsigned int )s->flags == 1U) {
      {
      {
#line 202
      tmp___0 = memcmp((void const   *)(s->hashes.md5), (void const   *)(hashes.md5),
                       (size_t )sizeof(s->hashes.md5));
      }
      }
#line 202
      if (tmp___0) {
#line 202
        goto _L___0;
      } else {
#line 202
        goto _L;
      }
    } else
    _L___0: 
#line 202
    if ((unsigned int )s->flags == 2U) {
      {
      {
#line 202
      tmp___1 = memcmp((void const   *)(s->hashes.sha1), (void const   *)(hashes.sha1),
                       (size_t )sizeof(s->hashes.sha1));
      }
      }
#line 202
      if (! tmp___1) {
        _L: 
        {
        {
#line 204
        s->key = spki_dup(db, key_length, key);
        }
        }
#line 205
        if (! s->key) {
#line 206
          return ((struct spki_principal *)((void *)0));
        }
        {
#line 207
        s->key_length = key_length;
#line 208
        s->hashes = hashes;
#line 209
        s->flags = (enum spki_principal_flags )((unsigned int )s->flags | 3U);
        {
#line 211
        spki_principal_fix_aliases(s);
        }
        }
#line 212
        return (s);
      }
    }
#line 191
    s = s->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 217
  tmp___2 = spki_principal_add_key(db, key_length, key, (struct spki_hashes  const  *)(& hashes));
  }
  }
#line 217
  return (tmp___2);
}
}
#line 220 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_principal *spki_principal_by_md5(struct spki_acl_db *db , uint8_t const   *digest ) 
{ 
  struct spki_principal *s ;
  int tmp ;
  struct spki_principal *tmp___0 ;

  {
#line 225
  s = db->first_principal;
  {
  {
#line 225
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 225
    if (! s) {
#line 225
      goto while_break;
    }
#line 226
    if ((unsigned int )s->flags & 1U) {
      {
      {
#line 226
      tmp = memcmp((void const   *)(s->hashes.md5), (void const   *)digest, (size_t )sizeof(s->hashes.md5));
      }
      }
#line 226
      if (! tmp) {
#line 228
        return (s);
      }
    }
#line 225
    s = s->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 230
  tmp___0 = spki_principal_add_md5(db, digest);
  }
  }
#line 230
  return (tmp___0);
}
}
#line 233 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_principal *spki_principal_by_sha1(struct spki_acl_db *db , uint8_t const   *digest ) 
{ 
  struct spki_principal *s ;
  int tmp ;
  struct spki_principal *tmp___0 ;

  {
#line 238
  s = db->first_principal;
  {
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 238
    if (! s) {
#line 238
      goto while_break;
    }
#line 239
    if ((unsigned int )s->flags & 2U) {
      {
      {
#line 239
      tmp = memcmp((void const   *)(s->hashes.sha1), (void const   *)digest, (size_t )sizeof(s->hashes.sha1));
      }
      }
#line 239
      if (! tmp) {
#line 241
        return (s);
      }
    }
#line 238
    s = s->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 243
  tmp___0 = spki_principal_add_sha1(db, digest);
  }
  }
#line 243
  return (tmp___0);
}
}
#line 246 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
void spki_principal_free_chain(struct spki_acl_db *db , struct spki_principal *chain ) 
{ 
  struct spki_principal *next ;

  {
  {
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 250
    if (! chain) {
#line 250
      goto while_break;
    }
    {
#line 252
    next = chain->next;
    {
#line 254
    (*(db->realloc))(db->realloc_ctx, (void *)chain->key, 0U);
    }
    {
#line 255
    (*(db->realloc))(db->realloc_ctx, (void *)chain, 0U);
    }
#line 257
    chain = next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 259
  return;
}
}
#line 261 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_principal  const  *spki_principal_normalize(struct spki_principal  const  *principal ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 264
  if (! principal) {
    {
    {
#line 264
    __assert_fail("principal", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                  264U, "spki_principal_normalize");
    }
    }
  }
  {
  {
#line 265
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 265
    if (! principal->alias) {
#line 265
      goto while_break;
    }
#line 266
    principal = (struct spki_principal  const  *)principal->alias;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 268
  return (principal);
}
}
#line 273 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
void spki_5_tuple_init(struct spki_5_tuple *tuple ) 
{ 


  {
#line 277
  tuple->refs = 0U;
#line 278
  tuple->issuer = (struct spki_principal *)((void *)0);
#line 279
  tuple->subject = (struct spki_principal *)((void *)0);
#line 280
  tuple->flags = (enum spki_5_tuple_flags )0;
#line 281
  tuple->tag = (struct spki_tag *)((void *)0);
#line 283
  tuple->not_before = (struct spki_date )spki_date_since_ever;
#line 284
  tuple->not_after = (struct spki_date )spki_date_for_ever;
#line 285
  return;
}
}
#line 289 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
void spki_tag_free(struct spki_acl_db *db , struct spki_tag *tag ) 
{ 


  {
  {
  {
#line 293
  spki_tag_release(db->realloc_ctx, db->realloc, tag);
  }
  }
#line 294
  return;
}
}
#line 296 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_5_tuple *spki_5_tuple_cons_new(struct spki_acl_db *db , struct spki_5_tuple_list **list ) 
{ 
  struct spki_5_tuple *tuple ;
  void *tmp ;
  struct spki_5_tuple_list *cons ;
  void *tmp___0 ;

  {
  {
  {
#line 300
  tmp = (*(db->realloc))(db->realloc_ctx, (void *)0, (unsigned int )sizeof(struct spki_5_tuple ));
  }
#line 300
  tuple = (struct spki_5_tuple *)tmp;
  }
#line 301
  if (tuple) {
    {
    {
#line 303
    tmp___0 = (*(db->realloc))(db->realloc_ctx, (void *)0, (unsigned int )sizeof(struct spki_5_tuple_list ));
    }
#line 303
    cons = (struct spki_5_tuple_list *)tmp___0;
    }
#line 304
    if (cons) {
      {
      {
#line 306
      spki_5_tuple_init(tuple);
      }
#line 307
      (tuple->refs) ++;
#line 308
      cons->car = tuple;
#line 309
      cons->cdr = *list;
#line 310
      *list = cons;
      }
#line 311
      return (tuple);
    } else {
      {
      {
#line 314
      (*(db->realloc))(db->realloc_ctx, (void *)tuple, 0U);
      }
      }
    }
  }
#line 316
  return ((struct spki_5_tuple *)((void *)0));
}
}
#line 319 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
void spki_5_tuple_list_release(struct spki_acl_db *db , struct spki_5_tuple_list *list ) 
{ 
  struct spki_5_tuple_list *cdr ;
  struct spki_5_tuple *car ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 323
    if (! list) {
#line 323
      goto while_break;
    }
#line 325
    cdr = list->cdr;
#line 326
    car = list->car;
#line 328
    if (! car->refs) {
      {
      {
#line 328
      __assert_fail("car->refs", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                    328U, "spki_5_tuple_list_release");
      }
      }
    }
#line 330
    (car->refs) --;
#line 330
    if (! car->refs) {
      {
      {
#line 332
      spki_tag_free(db, car->tag);
      }
      {
#line 333
      (*(db->realloc))(db->realloc_ctx, (void *)car, 0U);
      }
      }
    }
    {
    {
#line 335
    (*(db->realloc))(db->realloc_ctx, (void *)list, 0U);
    }
#line 337
    list = cdr;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 339
  return;
}
}
#line 341 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_5_tuple_list *spki_5_tuple_list_nappend(struct spki_5_tuple_list *a ,
                                                    struct spki_5_tuple_list *b ) 
{ 
  struct spki_5_tuple_list *p ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 345
  if (! a) {
#line 346
    return (b);
  }
#line 348
  if (! b) {
#line 349
    return (a);
  }
#line 354
  p = a;
  {
  {
#line 354
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 354
    if (! p->cdr) {
#line 354
      goto while_break;
    }
#line 354
    p = p->cdr;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 357
  if (! p) {
    {
    {
#line 357
    __assert_fail("p", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                  357U, "spki_5_tuple_list_nappend");
    }
    }
  }
#line 358
  if (! (! p->cdr)) {
    {
    {
#line 358
    __assert_fail("!p->cdr", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                  358U, "spki_5_tuple_list_nappend");
    }
    }
  }
#line 360
  p->cdr = b;
#line 362
  return (a);
}
}
#line 366 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_5_tuple_list *spki_5_tuple_list_nreverse(struct spki_5_tuple_list *c ) 
{ 
  struct spki_5_tuple_list *head ;
  struct spki_5_tuple_list *next ;

  {
#line 369
  head = (struct spki_5_tuple_list *)((void *)0);
  {
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 371
    if (! c) {
#line 371
      goto while_break;
    }
#line 373
    next = c->cdr;
#line 376
    c->cdr = head;
#line 377
    head = c;
#line 379
    c = next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 382
  return (head);
}
}
#line 388 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_5_tuple_list *spki_5_tuple_list_filter(struct spki_acl_db *db , struct spki_5_tuple_list *list ,
                                                   void *ctx , spki_5_tuple_filter_func *filter ) 
{ 
  struct spki_5_tuple_list *head ;
  struct spki_5_tuple_list *tail ;
  struct spki_5_tuple_list *cons ;
  void *tmp ;
  int tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 396
  tail = (struct spki_5_tuple_list *)((void *)0);
#line 396
  head = tail;
  {
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 396
    if (! list) {
#line 396
      goto while_break;
    }
#line 398
    if (! filter) {
#line 398
      goto _L;
    } else {
      {
      {
#line 398
      tmp___0 = (*filter)(db, ctx, list->car);
      }
      }
#line 398
      if (tmp___0) {
        _L: 
        {
        {
#line 400
        tmp = (*(db->realloc))(db->realloc_ctx, (void *)0, (unsigned int )sizeof(struct spki_5_tuple_list ));
        }
#line 400
        cons = (struct spki_5_tuple_list *)tmp;
        }
#line 401
        if (! cons) {
          {
          {
#line 403
          spki_5_tuple_list_release(db, head);
          }
          }
#line 404
          return ((struct spki_5_tuple_list *)((void *)0));
        }
#line 406
        ((list->car)->refs) ++;
#line 408
        cons->car = list->car;
#line 409
        cons->cdr = (struct spki_5_tuple_list *)((void *)0);
#line 411
        if (tail) {
#line 412
          tail->cdr = cons;
        } else {
#line 415
          if (! (! head)) {
            {
            {
#line 415
            __assert_fail("!head", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                          415U, "spki_5_tuple_list_filter");
            }
            }
          }
#line 416
          head = cons;
        }
#line 418
        tail = cons;
      }
    }
#line 396
    list = list->cdr;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 421
  return (head);
}
}
#line 424 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_5_tuple  const  *spki_5_tuple_by_subject_next(struct spki_5_tuple_list  const  **i ,
                                                          struct spki_principal  const  *subject ) 
{ 
  struct spki_5_tuple_list  const  *p ;
  struct spki_5_tuple *tuple ;
  struct spki_principal  const  *tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
  {
#line 429
  subject = spki_principal_normalize(subject);
  }
  }
#line 431
  if (! (! subject->alias)) {
    {
    {
#line 431
    __assert_fail("!subject->alias", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                  431U, "spki_5_tuple_by_subject_next");
    }
    }
  }
#line 433
  p = *i;
  {
  {
#line 433
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 433
    if (! p) {
#line 433
      goto while_break;
    }
#line 435
    tuple = (struct spki_5_tuple *)p->car;
#line 436
    if (! tuple->subject) {
      {
      {
#line 436
      __assert_fail("tuple->subject", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                    436U, "spki_5_tuple_by_subject_next");
      }
      }
    }
    {
    {
#line 438
    tmp = spki_principal_normalize((struct spki_principal  const  *)tuple->subject);
    }
    }
#line 438
    if ((unsigned long )tmp == (unsigned long )subject) {
#line 440
      *i = (struct spki_5_tuple_list  const  *)p->cdr;
#line 441
      return ((struct spki_5_tuple  const  *)tuple);
    }
#line 433
    p = (struct spki_5_tuple_list  const  *)p->cdr;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 444
  return ((struct spki_5_tuple  const  *)((void *)0));
}
}
#line 449 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_5_tuple  const  *spki_acl_by_subject_first(struct spki_acl_db *db , struct spki_5_tuple_list  const  **i ,
                                                       struct spki_principal  const  *subject ) 
{ 
  struct spki_5_tuple  const  *tmp ;

  {
  {
#line 454
  *i = (struct spki_5_tuple_list  const  *)db->acls;
  {
#line 455
  tmp = spki_5_tuple_by_subject_next(i, subject);
  }
  }
#line 455
  return (tmp);
}
}
#line 459 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_5_tuple  const  *spki_acl_by_subject_next(struct spki_5_tuple_list  const  **i ,
                                                      struct spki_principal  const  *subject ) 
{ 
  struct spki_5_tuple  const  *tmp ;

  {
  {
  {
#line 463
  tmp = spki_5_tuple_by_subject_next(i, subject);
  }
  }
#line 463
  return (tmp);
}
}
#line 466 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_5_tuple  const  *spki_5_tuple_by_authorization_next(struct spki_5_tuple_list  const  **i ,
                                                                struct spki_tag *request ) 
{ 
  struct spki_5_tuple_list  const  *p ;
  struct spki_5_tuple  const  *acl ;
  int tmp ;

  {
#line 473
  p = *i;
  {
  {
#line 473
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 473
    if (! p) {
#line 473
      goto while_break;
    }
    {
#line 475
    acl = (struct spki_5_tuple  const  *)p->car;
    {
#line 476
    tmp = spki_tag_includes((struct spki_tag *)acl->tag, request);
    }
    }
#line 476
    if (tmp) {
#line 478
      *i = (struct spki_5_tuple_list  const  *)p->cdr;
#line 479
      return (acl);
    }
#line 473
    p = (struct spki_5_tuple_list  const  *)p->cdr;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 482
  return ((struct spki_5_tuple  const  *)((void *)0));
}
}
#line 485 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_5_tuple  const  *spki_acl_by_authorization_first(struct spki_acl_db *db ,
                                                             struct spki_5_tuple_list  const  **i ,
                                                             struct spki_tag *request ) 
{ 
  struct spki_5_tuple  const  *tmp ;

  {
  {
#line 490
  *i = (struct spki_5_tuple_list  const  *)db->acls;
  {
#line 491
  tmp = spki_5_tuple_by_authorization_next(i, request);
  }
  }
#line 491
  return (tmp);
}
}
#line 494 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_5_tuple  const  *spki_acl_by_authorization_next(struct spki_5_tuple_list  const  **i ,
                                                            struct spki_tag *request ) 
{ 
  struct spki_5_tuple  const  *tmp ;

  {
  {
  {
#line 498
  tmp = spki_5_tuple_by_authorization_next(i, request);
  }
  }
#line 498
  return (tmp);
}
}
#line 501 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
int spki_acl_process(struct spki_acl_db *db , struct spki_iterator *i ) 
{ 
  struct spki_5_tuple_list *acl ;
  struct spki_5_tuple_list *tmp ;

  {
  {
  {
#line 505
  tmp = spki_parse_acl(db, i);
  }
#line 505
  acl = tmp;
  }
#line 506
  if (! acl) {
#line 507
    return (0);
  }
  {
  {
#line 509
  db->acls = spki_5_tuple_list_nappend(db->acls, acl);
  }
  }
#line 510
  return (1);
}
}
#line 513 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
static unsigned int format_valid(struct spki_5_tuple  const  *tuple , struct nettle_buffer *buffer ) 
{ 
  unsigned int done ;
  unsigned int tmp ;
  unsigned int length ;
  unsigned int tmp___0 ;
  unsigned int length___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
  {
#line 517
  tmp = nettle_sexp_format(buffer, "%0l", "(5:valid");
  }
#line 517
  done = tmp;
  }
#line 518
  if (! done) {
#line 519
    return (0U);
  }
#line 521
  if ((unsigned int const   )tuple->flags & 2U) {
    {
    {
#line 523
    tmp___0 = nettle_sexp_format(buffer, "(%0s%s)", "not-before", sizeof(tuple->not_before),
                                 tuple->not_before);
    }
#line 523
    length = tmp___0;
    }
#line 526
    if (! length) {
#line 527
      return (0U);
    }
#line 528
    done += length;
  }
#line 531
  if ((unsigned int const   )tuple->flags & 4U) {
    {
    {
#line 533
    tmp___1 = nettle_sexp_format(buffer, "(%0s%s)", "not-after", sizeof(tuple->not_after),
                                 tuple->not_after);
    }
#line 533
    length___0 = tmp___1;
    }
#line 536
    if (! length___0) {
#line 537
      return (0U);
    }
#line 538
    done += length___0;
  }
  {
  {
#line 540
  tmp___4 = nettle_sexp_format(buffer, "%l", 1, ")");
  }
  }
#line 540
  if (tmp___4) {
#line 540
    tmp___3 = done + 1U;
  } else {
#line 540
    tmp___3 = 0U;
  }
#line 540
  return (tmp___3);
}
}
#line 544 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
unsigned int spki_acl_format(struct spki_5_tuple_list  const  *list , struct nettle_buffer *buffer ) 
{ 
  unsigned int done ;
  unsigned int tmp ;
  unsigned int length ;
  struct spki_5_tuple  const  *acl ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
  {
  {
#line 548
  tmp = nettle_sexp_format(buffer, "%(acl");
  }
#line 548
  done = tmp;
  }
#line 549
  if (! done) {
#line 550
    return (0U);
  }
  {
  {
#line 554
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 554
    if (! list) {
#line 554
      goto while_break;
    }
#line 557
    acl = (struct spki_5_tuple  const  *)list->car;
#line 559
    if (! (! acl->issuer)) {
      {
      {
#line 559
      __assert_fail("!acl->issuer", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                    559U, "spki_acl_format");
      }
      }
    }
#line 560
    if (! acl->subject) {
      {
      {
#line 560
      __assert_fail("acl->subject", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                    560U, "spki_acl_format");
      }
      }
    }
    {
    {
#line 562
    length = nettle_sexp_format(buffer, "%(entry");
    }
    }
#line 563
    if (length) {
#line 564
      done += length;
    } else {
#line 566
      return (0U);
    }
#line 569
    if (! (acl->subject)->key) {
      {
      {
#line 569
      __assert_fail("acl->subject->key", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                    569U, "spki_acl_format");
      }
      }
    }
    {
    {
#line 571
    length = nettle_sexp_format(buffer, "%l", (acl->subject)->key_length, (acl->subject)->key);
    }
    }
#line 573
    if (length) {
#line 574
      done += length;
    } else {
#line 576
      return (0U);
    }
#line 578
    if ((unsigned int const   )acl->flags & 1U) {
      {
      {
#line 580
      length = nettle_sexp_format(buffer, "(%0s)", "propagate");
      }
      }
#line 581
      if (length) {
#line 582
        done += length;
      } else {
#line 584
        return (0U);
      }
    }
    {
    {
#line 587
    length = nettle_sexp_format(buffer, "%(tag");
    }
    }
#line 588
    if (length) {
#line 589
      done += length;
    } else {
#line 591
      return (0U);
    }
    {
    {
#line 593
    length = spki_tag_format((struct spki_tag *)acl->tag, buffer);
    }
    }
#line 594
    if (length) {
#line 595
      done += length;
    } else {
#line 597
      return (0U);
    }
    {
    {
#line 599
    length = nettle_sexp_format(buffer, "%)");
    }
    }
#line 600
    if (length) {
#line 601
      done += length;
    } else {
#line 603
      return (0U);
    }
#line 605
    if ((unsigned int const   )acl->flags & 6U) {
      {
      {
#line 607
      length = format_valid(acl, buffer);
      }
      }
#line 608
      if (length) {
#line 609
        done += length;
      } else {
#line 611
        return (0U);
      }
    }
    {
    {
#line 614
    tmp___0 = nettle_sexp_format(buffer, "%)");
    }
    }
#line 614
    if (tmp___0) {
#line 615
      done ++;
    } else {
#line 616
      return (0U);
    }
#line 554
    list = (struct spki_5_tuple_list  const  *)list->cdr;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 618
  tmp___3 = nettle_sexp_format(buffer, "%)");
  }
  }
#line 618
  if (tmp___3) {
#line 618
    tmp___2 = done + 1U;
  } else {
#line 618
    tmp___2 = 0U;
  }
#line 618
  return (tmp___2);
}
}
#line 638 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
int spki_hash_verify(struct spki_hash_value  const  *hash___2 , unsigned int length ,
                     uint8_t const   *data ) 
{ 
  struct md5_ctx ctx ;
  uint8_t digest[16] ;
  int tmp ;
  struct sha1_ctx ctx___0 ;
  uint8_t digest___0[20] ;
  int tmp___0 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;

  {
#line 647
  if ((unsigned int const   )hash___2->type == 11U) {
#line 647
    goto case_11;
  }
#line 650
  if ((unsigned int const   )hash___2->type == 21U) {
#line 650
    goto case_21;
  }
#line 645
  goto switch_default;
  switch_default: 
#line 646
  return (0);
  case_11: 
  {
  {
#line 648
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 648
    if (hash___2->length != 16U) {
#line 648
      return (0);
    }
    {
    {
#line 648
    nettle_md5_init(& ctx);
    }
    {
#line 648
    nettle_md5_update(& ctx, length, data);
    }
    {
#line 648
    nettle_md5_digest(& ctx, (unsigned int )sizeof(digest), digest);
    }
    {
#line 648
    tmp = memcmp((void const   *)(digest), (void const   *)hash___2->digest, (size_t )16);
    }
    }
#line 648
    if (tmp) {
#line 648
      return (0);
    }
#line 648
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 649
  goto switch_break;
  case_21: 
  {
  {
#line 651
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 651
    if (hash___2->length != 20U) {
#line 651
      return (0);
    }
    {
    {
#line 651
    nettle_sha1_init(& ctx___0);
    }
    {
#line 651
    nettle_sha1_update(& ctx___0, length, data);
    }
    {
#line 651
    nettle_sha1_digest(& ctx___0, (unsigned int )sizeof(digest___0), digest___0);
    }
    {
#line 651
    tmp___0 = memcmp((void const   *)(digest___0), (void const   *)hash___2->digest,
                     (size_t )20);
    }
    }
#line 651
    if (tmp___0) {
#line 651
      return (0);
    }
#line 651
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 652
  goto switch_break;
  switch_break: ;
#line 654
  return (1);
}
}
#line 672 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
static int parse_sequence(struct spki_acl_db *db , struct spki_iterator *i , struct spki_5_tuple_list **list ,
                          struct spki_principal  const  **subject , void *verify_ctx ,
                          spki_verify_func *verify ) 
{ 
  uint8_t const   *cert_to_verify ;
  unsigned int cert_length ;
  struct spki_principal *issuer ;
  enum spki_type tmp ;
  enum spki_type tmp___0 ;
  unsigned int start ;
  struct spki_5_tuple *cert ;
  struct spki_5_tuple *tmp___1 ;
  enum spki_type tmp___2 ;
  unsigned int start___0 ;
  unsigned int key_length ;
  uint8_t const   *key ;
  struct spki_principal *tmp___3 ;
  enum spki_type tmp___4 ;
  struct spki_hash_value hash___2 ;
  struct spki_principal *principal ;
  enum spki_type tmp___5 ;
  enum spki_type tmp___6 ;
  int tmp___7 ;
  enum spki_type tmp___8 ;
  struct spki_principal  const  *tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  void *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;

  {
  {
#line 683
  cert_to_verify = (uint8_t const   *)((void *)0);
#line 685
  issuer = (struct spki_principal *)((void *)0);
#line 687
  *list = (struct spki_5_tuple_list *)((void *)0);
#line 688
  *subject = (struct spki_principal  const  *)((void *)0);
  {
#line 690
  tmp = spki_check_type(i, (enum spki_type )20);
  }
  }
#line 690
  if (! tmp) {
#line 691
    return (0);
  }
  {
  {
#line 693
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 697
    if ((unsigned int )i->type == 28U) {
#line 697
      goto case_28;
    }
#line 716
    if ((unsigned int )i->type == 2U) {
#line 716
      goto case_2;
    }
#line 742
    if ((unsigned int )i->type == 17U) {
#line 742
      goto case_17;
    }
#line 760
    if ((unsigned int )i->type == 22U) {
#line 760
      goto case_22;
    }
#line 786
    if ((unsigned int )i->type == 5U) {
#line 786
      goto case_5;
    }
#line 709
    goto fail;
    case_28: 
    {
    {
#line 698
    tmp___0 = spki_parse_end(i);
    }
    }
#line 698
    if (tmp___0) {
#line 698
      if (*subject) {
#line 698
        if (! cert_to_verify) {
          {
          {
#line 704
          *subject = spki_principal_normalize(*subject);
          }
          }
#line 705
          return (1);
        }
      }
    }
    fail: 
    {
    {
#line 711
    spki_5_tuple_list_release(db, *list);
    }
#line 712
    *list = (struct spki_5_tuple_list *)((void *)0);
#line 713
    *subject = (struct spki_principal  const  *)((void *)0);
    }
#line 714
    return (0);
    case_2: 
#line 717
    if (cert_to_verify) {
#line 719
      goto fail;
    }
    {
#line 721
    start = i->start;
    {
#line 722
    tmp___1 = spki_5_tuple_cons_new(db, list);
    }
#line 722
    cert = tmp___1;
    }
#line 724
    if (! cert) {
#line 725
      goto fail;
    }
    {
    {
#line 727
    tmp___2 = spki_parse_cert(db, i, cert);
    }
    }
#line 727
    if (! tmp___2) {
#line 728
      goto fail;
    }
#line 730
    if (! cert->subject) {
      {
      {
#line 730
      __assert_fail("cert->subject", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                    730U, "parse_sequence");
      }
      }
    }
#line 731
    if (! cert->issuer) {
      {
      {
#line 731
      __assert_fail("cert->issuer", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                    731U, "parse_sequence");
      }
      }
    }
#line 733
    if (verify) {
      {
      {
#line 735
      cert_to_verify = spki_parse_prevexpr(i, start, & cert_length);
      }
      }
#line 736
      if (! cert_to_verify) {
        {
        {
#line 736
        __assert_fail("cert_to_verify", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                      736U, "parse_sequence");
        }
        }
      }
    }
#line 738
    *subject = (struct spki_principal  const  *)cert->subject;
#line 739
    issuer = cert->issuer;
#line 740
    goto switch_break;
    case_17: 
    {
#line 745
    start___0 = i->start;
    {
#line 750
    tmp___4 = spki_parse_skip(i);
    }
    }
#line 750
    if (tmp___4) {
      {
      {
#line 752
      key = spki_parse_prevexpr(i, start___0, & key_length);
      }
      }
#line 753
      if (! key) {
        {
        {
#line 753
        __assert_fail("key", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                      753U, "parse_sequence");
        }
        }
      }
      {
      {
#line 754
      tmp___3 = spki_principal_by_key(db, key_length, key);
      }
#line 754
      *subject = (struct spki_principal  const  *)tmp___3;
      }
#line 755
      if (! *subject) {
#line 756
        goto fail;
      }
    }
#line 758
    goto switch_break;
    case_22: 
#line 762
    if (cert_to_verify) {
#line 767
      if (! issuer) {
        {
        {
#line 767
        __assert_fail("issuer", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                      767U, "parse_sequence");
        }
        }
      }
#line 768
      if (! verify) {
        {
        {
#line 768
        __assert_fail("verify", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                      768U, "parse_sequence");
        }
        }
      }
      {
      {
#line 770
      tmp___5 = spki_parse_type(i);
      }
      }
#line 770
      if ((unsigned int )tmp___5 == 8U) {
        {
        {
#line 770
        tmp___6 = spki_parse_hash(i, & hash___2);
        }
        }
#line 770
        if (tmp___6) {
          {
          {
#line 770
          tmp___7 = spki_hash_verify((struct spki_hash_value  const  *)(& hash___2),
                                     cert_length, cert_to_verify);
          }
          }
#line 770
          if (tmp___7) {
            {
            {
#line 770
            tmp___8 = spki_parse_principal(db, i, & principal);
            }
            }
#line 770
            if (tmp___8) {
              {
              {
#line 770
              tmp___9 = spki_principal_normalize((struct spki_principal  const  *)issuer);
              }
              }
#line 770
              if ((unsigned long )principal == (unsigned long )tmp___9) {
                {
                {
#line 770
                tmp___10 = (*verify)(verify_ctx, (struct spki_hash_value  const  *)(& hash___2),
                                     issuer, i);
                }
                }
#line 770
                if (tmp___10) {
#line 778
                  cert_to_verify = (uint8_t const   *)((void *)0);
#line 779
                  goto switch_break;
                } else {
#line 782
                  goto fail;
                }
              } else {
#line 782
                goto fail;
              }
            } else {
#line 782
              goto fail;
            }
          } else {
#line 782
            goto fail;
          }
        } else {
#line 782
          goto fail;
        }
      } else {
#line 782
        goto fail;
      }
    } else {
      case_5: 
      {
      {
#line 788
      spki_parse_skip(i);
      }
      }
    }
#line 789
    goto switch_break;
    switch_break: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 796
  return (0);
}
}
#line 794 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
int spki_parse_sequence(struct spki_acl_db *db , struct spki_iterator *i , struct spki_5_tuple_list **list ,
                        struct spki_principal  const  **subject , void *verify_ctx ,
                        spki_verify_func *verify ) 
{ 
  int tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 802
  if (! verify) {
    {
    {
#line 802
    __assert_fail("verify", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                  802U, "spki_parse_sequence");
    }
    }
  }
  {
  {
#line 803
  tmp = parse_sequence(db, i, list, subject, verify_ctx, verify);
  }
  }
#line 803
  return (tmp);
}
}
#line 806 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
int spki_parse_sequence_no_signatures(struct spki_acl_db *db , struct spki_iterator *i ,
                                      struct spki_5_tuple_list **list , struct spki_principal  const  **subject ) 
{ 
  int tmp ;

  {
  {
  {
#line 812
  tmp = parse_sequence(db, i, list, subject, (void *)0, (spki_verify_func *)((void *)0));
  }
  }
#line 812
  return (tmp);
}
}
#line 819 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_date  const  spki_date_since_ever  =    {{(uint8_t )'\000', (uint8_t )'\000', (uint8_t )'\000', (uint8_t )'\000', (uint8_t )'\000',
     (uint8_t )'\000', (uint8_t )'\000', (uint8_t )'\000', (uint8_t )'\000', (uint8_t )'\000',
     (uint8_t )'\000', (uint8_t )'\000', (uint8_t )'\000', (uint8_t )'\000', (uint8_t )'\000',
     (uint8_t )'\000', (uint8_t )'\000', (uint8_t )'\000', (uint8_t )'\000'}};
#line 823 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
struct spki_date  const  spki_date_for_ever  =    {{(uint8_t )'\377', (uint8_t )'\377', (uint8_t )'\377', (uint8_t )'\377', (uint8_t )'\377',
     (uint8_t )'\377', (uint8_t )'\377', (uint8_t )'\377', (uint8_t )'\377', (uint8_t )'\377',
     (uint8_t )'\377', (uint8_t )'\377', (uint8_t )'\377', (uint8_t )'\377', (uint8_t )'\377',
     (uint8_t )'\377', (uint8_t )'\377', (uint8_t )'\377', (uint8_t )'\377'}};
#line 828 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
static void write_decimal(unsigned int length , uint8_t *buffer , unsigned int x ) 
{ 
  unsigned int msd[5] ;
  unsigned int digit ;
  uint8_t *tmp ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 831
  msd[0] = 0U;
#line 831
  msd[1] = 1U;
#line 831
  msd[2] = 10U;
#line 831
  msd[3] = 100U;
#line 831
  msd[4] = 1000U;
#line 834
  if (! (length <= 4U)) {
    {
    {
#line 834
    __assert_fail("length <= 4", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c",
                  834U, "write_decimal");
    }
    }
  }
#line 836
  digit = msd[length];
  {
  {
#line 836
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 836
    if (! digit) {
#line 836
      goto while_break;
    }
#line 839
    tmp = buffer;
#line 839
    buffer ++;
#line 839
    *tmp = (uint8_t )(48U + x / digit);
#line 840
    x %= digit;
#line 836
    digit /= 10U;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 842
  return;
}
}
#line 844 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
void spki_date_from_time_t(struct spki_date *d , time_t t ) 
{ 
  struct tm *tm ;
  struct tm tm_storage ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
  {
#line 850
  tm = gmtime_r((time_t const   */* __restrict  */)((time_t const   *)(& t)), (struct tm */* __restrict  */)(& tm_storage));
  }
  }
#line 855
  if (! tm) {
    {
    {
#line 857
    abort();
    }
    }
  }
  {
#line 859
  tmp = (uint8_t )'-';
#line 859
  d->date[7] = tmp;
#line 859
  d->date[4] = tmp;
#line 860
  d->date[10] = (uint8_t )'_';
#line 861
  tmp___0 = (uint8_t )':';
#line 861
  d->date[16] = tmp___0;
#line 861
  d->date[13] = tmp___0;
  {
#line 863
  write_decimal(4U, d->date, (unsigned int )(1900 + tm->tm_year));
  }
  {
#line 864
  write_decimal(2U, d->date + 5, (unsigned int )(1 + tm->tm_mon));
  }
  {
#line 865
  write_decimal(2U, d->date + 8, (unsigned int )tm->tm_mday);
  }
  {
#line 866
  write_decimal(2U, d->date + 11, (unsigned int )tm->tm_hour);
  }
  {
#line 867
  write_decimal(2U, d->date + 14, (unsigned int )tm->tm_min);
  }
  {
#line 868
  write_decimal(2U, d->date + 17, (unsigned int )tm->tm_sec);
  }
  }
#line 869
  return;
}
}
#line 872 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki/certificate.c"
int spki_date_cmp_time_t(struct spki_date *d , time_t t ) 
{ 
  struct spki_date d2 ;
  int tmp ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
  {
#line 876
  spki_date_from_time_t(& d2, t);
  }
  {
#line 877
  tmp = memcmp((void const   *)d, (void const   *)(& d2), (size_t )19);
  }
  }
#line 877
  return (tmp);
}
}
#line 92 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.h"
void lsh_string_free(struct lsh_string  const  *s ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/compress.h.x"
struct lsh_class compress_instance_class ;
#line 34
struct lsh_class compress_algorithm_class ;
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/compress.h"
struct compress_algorithm *make_zlib_algorithm(int level ) ;
#line 64
struct compress_algorithm *make_zlib(void) ;
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.h"
struct lsh_string *ssh_format(char const   *format  , ...) ;
#line 245 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 331
extern int deflateEnd(z_streamp strm ) ;
#line 370
extern int inflate(z_streamp strm , int flush ) ;
#line 469
extern int inflateEnd(z_streamp strm ) ;
#line 1337
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1339
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
uint32_t lsh_string_length(struct lsh_string  const  *s ) ;
#line 73
uint8_t const   *lsh_string_data(struct lsh_string  const  *s ) ;
#line 187
int lsh_string_zlib(struct lsh_string *s , uint32_t start , int (*f)(z_stream *z ,
                                                                     int flush ) ,
                    z_stream *z , int flush , uint32_t length ) ;
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/string_buffer.h"
void string_buffer_init(struct string_buffer *buffer , uint32_t guess ) ;
#line 70
void string_buffer_clear(struct string_buffer *buffer ) ;
#line 73
void string_buffer_grow(struct string_buffer *buffer , uint32_t increment ) ;
#line 75
struct lsh_string *string_buffer_final(struct string_buffer *buffer , uint32_t left_over ) ;
#line 76 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.h"
void werror(char const   *format  , ...) ;
#line 78
void debug(char const   *format  , ...) ;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.h"
void gc_kill(struct lsh_object *o ) ;
#line 56 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.h"
struct lsh_object *lsh_object_alloc(struct lsh_class *class ) ;
#line 71
void *lsh_space_alloc(size_t size ) ;
#line 72
void lsh_space_free(void const   *p ) ;
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
static void do_free_zstream(z_stream *z ) ;
#line 13 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c.x"
struct lsh_class zlib_instance_class ;
#line 17 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c.x"
static void do_zlib_instance_free(struct lsh_object *o ) 
{ 
  struct zlib_instance *i ;

  {
  {
#line 20
  i = (struct zlib_instance *)o;
  {
#line 21
  do_free_zstream(& i->z);
  }
  }
#line 22
  return;
}
}
#line 23 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c.x"
struct lsh_class zlib_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & compress_instance_class, (char *)"zlib_instance", (size_t )sizeof(struct zlib_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_zlib_instance_free};
#line 43
struct lsh_class zlib_algorithm_class ;
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c.x"
struct lsh_class zlib_algorithm_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & compress_algorithm_class, (char *)"zlib_algorithm", (size_t )sizeof(struct zlib_algorithm ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 80 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
static struct zlib_type  const  zlib_inflate  =    {& inflateEnd, "inflate"};
#line 83 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
static struct zlib_type  const  zlib_deflate  =    {& deflateEnd, "deflate"};
#line 87 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
static void *zlib_alloc(void *opaque  __attribute__((__unused__)) , unsigned int items ,
                        unsigned int size ) 
{ 
  void *tmp ;
  size_t size5 ;
  void *tmp6 ;
  void *ret_lsh_space_alloc7 ;

  {
  {
  {
#line 90
  size5 = items * size;
  {
  {
  {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
  tmp6 = malloc(size5);
  }
  }
  {
#line 262
  ret_lsh_space_alloc7 = tmp6;
#line 262
  goto Lret_lsh_space_alloc;
  }
  }
  Lret_lsh_space_alloc: /* CIL Label */ 
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
  tmp = ret_lsh_space_alloc7;
  }
  }
#line 90
  return (tmp);
}
}
#line 93 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
static void zlib_free(void *opaque  __attribute__((__unused__)) , void *address ) 
{ 


  {
  {
  {
#line 96
  lsh_space_free((void const   *)address);
  }
  }
#line 97
  return;
}
}
#line 99 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
static void do_free_zstream(z_stream *z ) 
{ 
  struct zlib_type  const  *type ;
  int res ;
  int tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 105
  type = (struct zlib_type  const  *)((struct zlib_type *)z->opaque);
  {
#line 107
  tmp = (*(type->free_func))(z);
  }
#line 107
  res = tmp;
  }
#line 109
  if (res != 0) {
#line 110
    if (z->msg) {
#line 110
      tmp___0 = (char const   *)z->msg;
    } else {
#line 110
      tmp___0 = "No error";
    }
    {
    {
#line 110
    debug("do_free_zstream (%z): Freeing failed: %z\n", type->operation, tmp___0);
    }
    }
  }
#line 112
  return;
}
}
#line 125 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
static uint32_t estimate_size(uint32_t rate , uint32_t input , uint32_t max ) 
{ 
  uint32_t guess ;
  uint32_t tmp ;

  {
#line 127
  guess = (rate * input) / 1024U + 200U;
#line 128
  if (max > guess) {
#line 128
    tmp = guess;
  } else {
#line 128
    tmp = max;
  }
#line 128
  return (tmp);
}
}
#line 132 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
static uint32_t estimate_update(uint32_t rate , uint32_t input , uint32_t output ) 
{ 
  uint32_t estimate ;
  uint32_t tmp ;

  {
#line 135
  rate = (rate * 15U) / 16U;
#line 145
  if (input > 100U) {
#line 147
    estimate = (output * 1024U) / input;
#line 149
    if (estimate > 16384U) {
#line 150
      return ((uint32_t )16384);
    }
#line 153
    if (estimate < rate) {
#line 153
      rate = rate;
    } else {
#line 153
      rate = estimate;
    }
  }
#line 156
  if (rate < 64U) {
#line 156
    tmp = (uint32_t )64;
  } else {
#line 156
    tmp = rate;
  }
#line 156
  return (tmp);
}
}
#line 160 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
static struct lsh_string *do_zlib(struct compress_instance *c , struct lsh_string *packet ,
                                  int free___0 ) 
{ 
  struct zlib_instance *self ;
  struct string_buffer buffer ;
  uint32_t limit ;
  uint32_t input ;
  uint32_t tmp ;
  uint32_t estimate ;
  struct lsh_string *tmp___0 ;
  struct lsh_string *tmp___1 ;
  uint32_t tmp___2 ;
  uint8_t const   *tmp___3 ;
  int rc ;
  char const   *tmp___4 ;
  uint32_t plength ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t output ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  void *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
  {
#line 165
  self = (struct zlib_instance *)c;
#line 171
  limit = self->max + 1U;
  {
#line 172
  tmp = lsh_string_length((struct lsh_string  const  *)packet);
  }
#line 172
  input = tmp;
  {
#line 175
  debug("do_zlib (%z): length in: %i\n", ((struct zlib_type *)self->z.opaque)->operation,
        input);
  }
  }
#line 178
  if (! input) {
    {
    {
#line 180
    werror("do_zlib (%z): Compressing empty packet.\n", ((struct zlib_type *)self->z.opaque)->operation);
    }
    }
#line 182
    if (free___0) {
#line 182
      tmp___1 = packet;
    } else {
      {
      {
#line 182
      tmp___0 = ssh_format("%lS", packet);
      }
#line 182
      tmp___1 = tmp___0;
      }
    }
#line 182
    return (tmp___1);
  }
  {
  {
#line 185
  estimate = estimate_size(self->rate, input, limit);
  }
  {
#line 186
  debug("do_zlib (%z): estimate:  %i\n", ((struct zlib_type *)self->z.opaque)->operation,
        estimate);
  }
  {
#line 190
  string_buffer_init(& buffer, estimate);
  }
  {
#line 192
  tmp___2 = lsh_string_length((struct lsh_string  const  *)buffer.partial);
  }
#line 192
  limit -= tmp___2;
  {
#line 196
  tmp___3 = lsh_string_data((struct lsh_string  const  *)packet);
  }
#line 196
  self->z.next_in = (uint8_t *)tmp___3;
#line 197
  self->z.avail_in = input;
  }
  {
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 203
    if (! buffer.left) {
      {
      {
#line 203
      __assert_fail("buffer.left", "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c",
                    203U, "do_zlib");
      }
      }
    }
    {
    {
#line 205
    rc = lsh_string_zlib(buffer.partial, buffer.pos, self->f, & self->z, 2, buffer.left);
    }
    }
#line 211
    if (rc == -5) {
#line 211
      goto case_neg_5;
    }
#line 220
    if (rc == 0) {
#line 220
      goto case_0;
    }
#line 222
    goto switch_default;
    case_neg_5: 
#line 214
    if (self->z.avail_in) {
      {
      {
#line 215
      werror("do_zlib (%z): Z_BUF_ERROR (probably harmless),\n  avail_in = %i, avail_out = %i\n",
             ((struct zlib_type *)self->z.opaque)->operation, self->z.avail_in, self->z.avail_out);
      }
      }
    }
    case_0: 
#line 221
    goto switch_break;
    switch_default: 
#line 223
    if (self->z.msg) {
#line 223
      tmp___4 = (char const   *)self->z.msg;
    } else {
#line 223
      tmp___4 = "No error(?)";
    }
    {
    {
#line 223
    werror("do_zlib: %z failed: %z\n", ((struct zlib_type *)self->z.opaque)->operation,
           tmp___4);
    }
    }
#line 226
    if (free___0) {
      {
      {
#line 227
      lsh_string_free((struct lsh_string  const  *)packet);
      }
      }
    }
#line 229
    return ((struct lsh_string *)((void *)0));
    switch_break: ;
#line 238
    if (! self->z.avail_in) {
#line 238
      if (! self->z.avail_out) {
        {
        {
#line 239
        debug("do_zlib (%z): Both avail_in and avail_out are zero.\n", ((struct zlib_type *)self->z.opaque)->operation);
        }
        }
      }
    }
#line 242
    if (! self->z.avail_out) {
      {
      {
#line 244
      tmp___5 = lsh_string_length((struct lsh_string  const  *)buffer.partial);
      }
#line 244
      plength = tmp___5;
      }
#line 246
      if (! limit) {
        {
        {
#line 248
        werror("do_zlib (%z): Packet grew too large!\n", ((struct zlib_type *)self->z.opaque)->operation);
        }
        }
#line 251
        if (free___0) {
          {
          {
#line 252
          lsh_string_free((struct lsh_string  const  *)packet);
          }
          }
        }
        {
        {
#line 254
        string_buffer_clear(& buffer);
        }
        }
#line 255
        return ((struct lsh_string *)((void *)0));
      }
#line 259
      if (limit > (plength + buffer.total) + 100U) {
#line 259
        tmp___6 = (plength + buffer.total) + 100U;
      } else {
#line 259
        tmp___6 = limit;
      }
      {
      {
#line 259
      string_buffer_grow(& buffer, tmp___6);
      }
#line 261
      limit -= plength;
      }
    } else
#line 263
    if (! self->z.avail_in) {
#line 267
      if (free___0) {
        {
        {
#line 268
        lsh_string_free((struct lsh_string  const  *)packet);
        }
        }
      }
      {
      {
#line 270
      packet = string_buffer_final(& buffer, self->z.avail_out);
      }
      {
#line 273
      output = lsh_string_length((struct lsh_string  const  *)packet);
      }
      }
#line 274
      if (! (output <= self->max)) {
        {
        {
#line 274
        __assert_fail("output <= self->max", "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c",
                      274U, "do_zlib");
        }
        }
      }
      {
      {
#line 276
      debug("do_zlib (%z): length out: %i\n", ((struct zlib_type *)self->z.opaque)->operation,
            output);
      }
      }
#line 280
      if (output > estimate) {
        {
        {
#line 281
        debug("do_zlib (%z): Estimated size exceeded: input = %i, estimate = %i, output = %i\n",
              ((struct zlib_type *)self->z.opaque)->operation, input, estimate, output);
        }
        }
      }
      {
      {
#line 285
      self->rate = estimate_update(self->rate, input, output);
      }
      }
#line 287
      return (packet);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 293
  return ((struct lsh_string *)0);
}
}
#line 292 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
static struct compress_instance *make_zlib_instance(struct compress_algorithm *c ,
                                                    int mode ) 
{ 
  struct zlib_algorithm *closure ;
  struct zlib_instance *res ;
  struct lsh_object *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 295
  closure = (struct zlib_algorithm *)c;
  {
#line 296
  tmp = lsh_object_alloc(& zlib_instance_class);
  }
#line 296
  res = (struct zlib_instance *)tmp;
#line 298
  res->z.zalloc = & zlib_alloc;
#line 299
  res->z.zfree = & zlib_free;
  }
#line 303
  if (mode == 0) {
#line 303
    goto case_0;
  }
#line 327
  if (mode == 1) {
#line 327
    goto case_1;
  }
#line 301
  goto switch_break;
  case_0: 
  {
#line 304
  res->z.opaque = (void *)(& zlib_deflate);
#line 305
  res->f = & deflate;
#line 306
  res->super.codec = & do_zlib;
#line 315
  res->max = (uint32_t )33107;
#line 316
  res->rate = (uint32_t )1024;
  {
#line 318
  tmp___1 = deflateInit_(& res->z, closure->level, "1.2.3.3", (int )sizeof(z_stream ));
  }
  }
#line 318
  if (tmp___1 != 0) {
#line 320
    if (res->z.msg) {
#line 320
      tmp___0 = (char const   *)res->z.msg;
    } else {
#line 320
      tmp___0 = "No error(?)";
    }
    {
    {
#line 320
    werror("deflateInit failed: %z\n", tmp___0);
    }
    {
#line 322
    gc_kill((struct lsh_object *)res);
    }
    }
#line 323
    return ((struct compress_instance *)((void *)0));
  }
#line 325
  goto switch_break;
  case_1: 
  {
#line 328
  res->z.opaque = (void *)(& zlib_inflate);
#line 329
  res->f = & inflate;
#line 330
  res->super.codec = & do_zlib;
#line 334
  res->max = (uint32_t )32768;
#line 335
  res->rate = (uint32_t )2048;
  {
#line 337
  tmp___3 = inflateInit_(& res->z, "1.2.3.3", (int )sizeof(z_stream ));
  }
  }
#line 337
  if (tmp___3 != 0) {
#line 339
    if (res->z.msg) {
#line 339
      tmp___2 = (char const   *)res->z.msg;
    } else {
#line 339
      tmp___2 = "No error(?)";
    }
    {
    {
#line 339
    werror("inflateInit failed: %z\n", tmp___2);
    }
    {
#line 341
    gc_kill((struct lsh_object *)res);
    }
    }
#line 342
    return ((struct compress_instance *)((void *)0));
  }
#line 344
  goto switch_break;
  switch_break: ;
#line 346
  return (& res->super);
}
}
#line 349 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
struct compress_algorithm *make_zlib_algorithm(int level ) 
{ 
  struct zlib_algorithm *closure ;
  struct lsh_object *tmp ;

  {
#line 351
  if (level != -1) {
#line 351
    if (level < 0) {
#line 354
      return ((struct compress_algorithm *)((void *)0));
    } else
#line 351
    if (level > 9) {
#line 354
      return ((struct compress_algorithm *)((void *)0));
    } else {
      {
      {
#line 357
      tmp = lsh_object_alloc(& zlib_algorithm_class);
      }
#line 357
      closure = (struct zlib_algorithm *)tmp;
#line 359
      closure->super.make_compress = & make_zlib_instance;
#line 360
      closure->level = level;
      }
#line 362
      return (& closure->super);
    }
  } else {
    {
    {
#line 357
    tmp = lsh_object_alloc(& zlib_algorithm_class);
    }
#line 357
    closure = (struct zlib_algorithm *)tmp;
#line 359
    closure->super.make_compress = & make_zlib_instance;
#line 360
    closure->level = level;
    }
#line 362
    return (& closure->super);
  }
}
}
#line 366 "/home/ysko/Works/test-src/lsh-2.0.4/src/zlib.c"
struct compress_algorithm *make_zlib(void) 
{ 
  struct compress_algorithm *tmp ;

  {
  {
  {
#line 368
  tmp = make_zlib_algorithm(-1);
  }
  }
#line 368
  return (tmp);
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 62 "/usr/include/X11/Xauth.h"
extern char *XauFileName(void) ;
#line 64
extern Xauth *XauReadAuth(FILE * ) ;
#line 68
extern int XauLockAuth(char const   * , int  , int  , long  ) ;
#line 75
extern int XauUnlockAuth(char const   * ) ;
#line 127
extern void XauDisposeAuth(Xauth * ) ;
#line 895 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/xauth.h"
int xauth_lookup(struct sockaddr *sa , unsigned int number_length , char const   *number ,
                 struct lsh_string **name , struct lsh_string **data ) ;
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/xauth.c"
static int xauth_process(char const   *filename , unsigned int family , unsigned int address_length ,
                         char const   *address , unsigned int number_length , char const   *number ,
                         struct lsh_string **name , struct lsh_string **data ) 
{ 
  FILE *f ;
  FILE *tmp ;
  Xauth *xa ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
  {
#line 52
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 52
  f = tmp;
  }
#line 55
  if (! f) {
#line 56
    return (0);
  }
  {
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 58
    xa = XauReadAuth(f);
    }
    }
#line 58
    if (! xa) {
#line 58
      goto while_break;
    }
    {
    {
#line 60
    debug("xauth: family: %i\n", (int )xa->family);
    }
    {
#line 61
    debug("       address: %ps\n", (int )xa->address_length, xa->address);
    }
    {
#line 62
    debug("       display: %s\n", (int )xa->number_length, xa->number);
    }
    {
#line 63
    debug("       name: %s\n", (int )xa->name_length, xa->name);
    }
    {
#line 64
    debug("       data length: %i\n", (int )xa->data_length);
    }
    }
#line 66
    if ((unsigned int )xa->family == family) {
#line 66
      if ((unsigned int )xa->address_length == address_length) {
#line 66
        if ((unsigned int )xa->number_length == number_length) {
          {
          {
#line 66
          tmp___0 = memcmp((void const   *)xa->address, (void const   *)address, address_length);
          }
          }
#line 66
          if (! tmp___0) {
            {
            {
#line 66
            tmp___1 = memcmp((void const   *)xa->number, (void const   *)number, number_length);
            }
            }
#line 66
            if (! tmp___1) {
              {
              {
#line 72
              *name = ssh_format("%ls", (int )xa->name_length, xa->name);
              }
              {
#line 73
              *data = ssh_format("%ls", (int )xa->data_length, xa->data);
              }
              {
#line 75
              XauDisposeAuth(xa);
              }
              {
#line 76
              fclose(f);
              }
              }
#line 78
              return (1);
            }
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 81
  XauDisposeAuth(xa);
  }
  {
#line 82
  fclose(f);
  }
  }
#line 84
  return (0);
}
}
#line 87 "/home/ysko/Works/test-src/lsh-2.0.4/src/xauth.c"
int xauth_lookup(struct sockaddr *sa , unsigned int number_length , char const   *number ,
                 struct lsh_string **name , struct lsh_string **data ) 
{ 
  int res ;
  unsigned int family ;
  char const   *address ;
  unsigned int address_length ;
  char host[200] ;
  char const   *filename ;
  char *tmp ;
  int tmp___0 ;
  struct sockaddr_in *s ;
  struct sockaddr_in6 *s___0 ;
  int tmp___1 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 94
  res = 0;
  {
#line 104
  tmp = XauFileName();
  }
#line 104
  filename = (char const   *)tmp;
  }
#line 106
  if (! filename) {
#line 107
    return (0);
  }
#line 111
  if ((int )sa->sa_family == 1) {
#line 111
    goto case_1;
  }
#line 119
  if ((int )sa->sa_family == 2) {
#line 119
    goto case_2;
  }
#line 130
  if ((int )sa->sa_family == 10) {
#line 130
    goto case_10;
  }
#line 140
  goto switch_default;
  case_1: 
  {
  {
#line 112
  tmp___0 = gethostname(host, (size_t )(sizeof(host) - 1UL));
  }
  }
#line 112
  if (tmp___0 < 0) {
#line 113
    return (0);
  }
  {
#line 114
  address = (char const   *)(host);
  {
#line 115
  address_length = strlen((char const   *)(host));
  }
#line 116
  family = 256U;
  }
#line 117
  goto switch_break;
  case_2: 
#line 121
  s = (struct sockaddr_in *)sa;
#line 123
  address = (char const   *)((char *)(& s->sin_addr));
#line 124
  address_length = 4U;
#line 125
  family = 0U;
#line 126
  goto switch_break;
  case_10: 
#line 132
  s___0 = (struct sockaddr_in6 *)sa;
#line 134
  address = (char const   *)((char *)(& s___0->sin6_addr));
#line 135
  address_length = 16U;
#line 136
  family = 0U;
#line 137
  goto switch_break;
  switch_default: 
#line 141
  return (0);
  switch_break: 
  {
  {
#line 145
  tmp___1 = XauLockAuth(filename, 5, 1, 0L);
  }
  }
#line 145
  if (tmp___1 != 0) {
#line 146
    return (0);
  }
  {
  {
#line 148
  res = xauth_process(filename, family, address_length, address, number_length, number,
                      name, data);
  }
  {
#line 154
  XauUnlockAuth(filename);
  }
  }
#line 156
  return (res);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.h"
void gc_register(struct lsh_object *o ) ;
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.h"
struct lsh_object *lsh_var_alloc(struct lsh_class *class , size_t size ) ;
#line 59
void lsh_object_free(struct lsh_object  const  *o ) ;
#line 65
struct lsh_object *lsh_var_clone(struct lsh_object *o , size_t size ) ;
#line 68
struct lsh_object *lsh_object_clone(struct lsh_object *o ) ;
#line 85 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.h"
 __attribute__((__noreturn__)) void fatal(char const   *format  , ...) ;
#line 99 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
static void *xalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 101
  tmp = malloc(size);
  }
#line 101
  res = tmp;
  }
#line 102
  if (! res) {
    {
    {
#line 103
    fatal("Virtual memory exhausted");
    }
    }
  }
  {
  {
#line 111
  memset(res, 0, size);
  }
  }
#line 113
  return (res);
}
}
#line 118 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
struct lsh_object *lsh_var_alloc(struct lsh_class *class , size_t size ) 
{ 
  struct lsh_object *instance ;
  void *tmp ;

  {
  {
  {
#line 122
  tmp = xalloc(size);
  }
#line 122
  instance = (struct lsh_object *)tmp;
#line 124
  instance->isa = class;
#line 125
  instance->alloc_method = (char)0;
  {
#line 127
  gc_register(instance);
  }
  }
#line 129
  return (instance);
}
}
#line 132 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
struct lsh_object *lsh_object_alloc(struct lsh_class *class ) 
{ 
  struct lsh_object *tmp ;

  {
  {
  {
#line 135
  tmp = lsh_var_alloc(class, class->size);
  }
  }
#line 135
  return (tmp);
}
}
#line 138 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
struct lsh_object *lsh_var_clone(struct lsh_object *o , size_t size ) 
{ 
  struct lsh_object *i ;
  void *tmp ;

  {
  {
  {
#line 141
  tmp = xalloc(size);
  }
#line 141
  i = (struct lsh_object *)tmp;
  {
#line 146
  memcpy((void */* __restrict  */)((void *)i), (void const   */* __restrict  */)((void const   *)o),
         size);
  }
#line 148
  i->alloc_method = (char)0;
  {
#line 149
  gc_register(i);
  }
  }
#line 151
  return (i);
}
}
#line 154 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
struct lsh_object *lsh_object_clone(struct lsh_object *o ) 
{ 
  struct lsh_object *tmp ;

  {
  {
  {
#line 157
  tmp = lsh_var_clone(o, (o->isa)->size);
  }
  }
#line 157
  return (tmp);
}
}
#line 162 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
void lsh_object_free(struct lsh_object  const  *o ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 165
  if (! o) {
#line 166
    return;
  }
#line 168
  if ((int const   )o->alloc_method != 0) {
    {
    {
#line 169
    fatal("lsh_object_free: Object not allocated on the heap!\n");
    }
    }
  }
  {
  {
#line 171
  free((void *)o);
  }
  }
#line 172
  return;
}
}
#line 260 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
void *lsh_space_alloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
  {
#line 262
  tmp = malloc(size);
  }
  }
#line 262
  return (tmp);
}
}
#line 265 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
void lsh_space_free(void const   *p ) 
{ 


  {
  {
  {
#line 267
  free((void *)p);
  }
  }
#line 268
  return;
}
}
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_io.h.x"
struct lsh_class abstract_write_pipe_class ;
#line 278 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h"
struct abstract_write *make_write_packet(struct ssh_connection *connection , struct randomness *random___0 ,
                                         struct abstract_write *next ) ;
#line 169 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
void lsh_string_write_random(struct lsh_string *s , uint32_t start , struct randomness *r ,
                             uint32_t length ) ;
#line 12 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_packet.c.x"
struct lsh_class write_packet_class ;
#line 16 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_packet.c.x"
static void do_write_packet_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct write_packet *i ;

  {
  {
#line 20
  i = (struct write_packet *)o;
  {
#line 21
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 22
  (*mark)((struct lsh_object *)i->random);
  }
  }
#line 23
  return;
}
}
#line 24 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_packet.c.x"
struct lsh_class write_packet_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & abstract_write_pipe_class, (char *)"write_packet", (size_t )sizeof(struct write_packet ),
    & do_write_packet_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_packet.c"
static void do_write_packet(struct abstract_write *s , struct lsh_string *packet ) 
{ 
  struct write_packet *self ;
  struct ssh_connection *connection ;
  uint32_t block_size ;
  uint32_t new_size ;
  uint8_t padding_length ;
  uint32_t padding ;
  uint32_t mac_length ;
  uint32_t mac ;
  uint32_t length ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint8_t s___0[4] ;
  uint8_t const   *tmp___1 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  void *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
  {
#line 51
  self = (struct write_packet *)s;
#line 52
  connection = self->connection;
  {
#line 61
  tmp = lsh_string_length((struct lsh_string  const  *)packet);
  }
#line 61
  length = tmp;
  }
#line 62
  if (! length) {
    {
    {
#line 62
    __assert_fail("length", "/home/ysko/Works/test-src/lsh-2.0.4/src/write_packet.c",
                  62U, "do_write_packet");
    }
    }
  }
#line 65
  if (connection->send_compress) {
    {
    {
#line 67
    packet = (*((connection->send_compress)->codec))(connection->send_compress, packet,
                                                     1);
    }
    }
#line 68
    if (! packet) {
      {
      {
#line 68
      __assert_fail("packet", "/home/ysko/Works/test-src/lsh-2.0.4/src/write_packet.c",
                    68U, "do_write_packet");
      }
      }
    }
    {
    {
#line 69
    length = lsh_string_length((struct lsh_string  const  *)packet);
    }
    }
  }
#line 72
  if (connection->send_crypto) {
#line 72
    block_size = (connection->send_crypto)->block_size;
  } else {
#line 72
    block_size = (uint32_t )8;
  }
#line 74
  if (connection->send_mac) {
#line 74
    mac_length = (connection->send_mac)->mac_size;
  } else {
#line 74
    mac_length = (uint32_t )0;
  }
#line 79
  new_size = block_size * (1U + (8U + length) / block_size);
#line 81
  padding_length = (uint8_t )((new_size - length) - 5U);
#line 82
  if (! ((int )padding_length >= 4)) {
    {
    {
#line 82
    __assert_fail("padding_length >= 4", "/home/ysko/Works/test-src/lsh-2.0.4/src/write_packet.c",
                  82U, "do_write_packet");
    }
    }
  }
  {
  {
#line 84
  packet = ssh_format("%i%c%lfS%lr%lr", (length + (uint32_t )padding_length) + 1U,
                      (int )padding_length, packet, (int )padding_length, & padding,
                      mac_length, & mac);
  }
  {
#line 91
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  }
#line 91
  if (! (new_size + mac_length == tmp___0)) {
    {
    {
#line 91
    __assert_fail("new_size + mac_length == lsh_string_length(packet)", "/home/ysko/Works/test-src/lsh-2.0.4/src/write_packet.c",
                  91U, "do_write_packet");
    }
    }
  }
  {
  {
#line 93
  lsh_string_write_random(packet, padding, self->random, (uint32_t )padding_length);
  }
  }
#line 95
  if (connection->send_mac) {
#line 98
    if (! (new_size == mac)) {
      {
      {
#line 98
      __assert_fail("new_size == mac", "/home/ysko/Works/test-src/lsh-2.0.4/src/write_packet.c",
                    98U, "do_write_packet");
      }
      }
    }
    {
    {
#line 100
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 100
      s___0[0] = (uint8_t )((self->sequence_number >> 24) & 255U);
#line 100
      s___0[1] = (uint8_t )((self->sequence_number >> 16) & 255U);
#line 100
      s___0[2] = (uint8_t )((self->sequence_number >> 8) & 255U);
#line 100
      s___0[3] = (uint8_t )(self->sequence_number & 255U);
#line 100
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
    {
#line 101
    (*((connection->send_mac)->update))(connection->send_mac, (uint32_t )4, (uint8_t const   *)(s___0));
    }
    {
#line 102
    tmp___1 = lsh_string_data((struct lsh_string  const  *)packet);
    }
    {
#line 102
    (*((connection->send_mac)->update))(connection->send_mac, new_size, tmp___1);
    }
    {
#line 103
    (*((connection->send_mac)->digest))(connection->send_mac, packet, mac);
    }
    }
  }
#line 105
  if (connection->send_crypto) {
    {
    {
#line 106
    (*((connection->send_crypto)->crypt))(connection->send_crypto, new_size, packet,
                                          (uint32_t )0, (struct lsh_string  const  *)packet,
                                          (uint32_t )0);
    }
    }
  }
  {
#line 108
  (self->sequence_number) ++;
  {
#line 109
  (*((self->super.next)->write))(self->super.next, packet);
  }
  }
#line 110
  return;
}
}
#line 112 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_packet.c"
struct abstract_write *make_write_packet(struct ssh_connection *connection , struct randomness *random___0 ,
                                         struct abstract_write *next ) 
{ 
  struct write_packet *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 117
  tmp = lsh_object_alloc(& write_packet_class);
  }
#line 117
  self = (struct write_packet *)tmp;
#line 118
  self->super.super.write = & do_write_packet;
#line 119
  self->super.next = next;
#line 120
  self->connection = connection;
#line 121
  self->random = random___0;
#line 122
  self->sequence_number = (uint32_t )0;
  }
#line 124
  return (& self->super.super);
}
}
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_io.h.x"
struct lsh_class abstract_write_class ;
#line 64 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h"
void lsh_queue_init(struct lsh_queue *q ) ;
#line 65
int lsh_queue_is_empty(struct lsh_queue *q ) ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h.x"
void string_queue_mark(struct string_queue *i , void (*mark)(struct lsh_object *o ) ) ;
#line 33
void string_queue_free(struct string_queue *i ) ;
#line 148 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h"
void string_queue_add_tail(struct string_queue *q , struct lsh_string *s ) ;
#line 149
struct lsh_string *string_queue_remove_head(struct string_queue *q ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.h.x"
struct lsh_class flow_controlled_class ;
#line 45
struct lsh_class write_buffer_class ;
#line 75 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.h"
struct write_buffer *make_write_buffer(struct lsh_fd *fd , uint32_t size ) ;
#line 78
int write_buffer_pre_write(struct write_buffer *buffer ) ;
#line 79
void write_buffer_consume(struct write_buffer *buffer , uint32_t size ) ;
#line 241 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
void lsh_oop_register_write_fd(struct lsh_fd *fd ) ;
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
struct lsh_string *lsh_string_alloc(uint32_t length ) ;
#line 108
void lsh_string_write(struct lsh_string *s , uint32_t start , uint32_t length , uint8_t const   *data ) ;
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.h"
void trace(char const   *format  , ...) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.h.x"
struct lsh_class flow_controlled_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"flow_controlled", (size_t )sizeof(struct flow_controlled ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.h.x"
static void do_write_buffer_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct write_buffer *i ;

  {
  {
#line 53
  i = (struct write_buffer *)o;
  {
#line 54
  (*mark)((struct lsh_object *)i->fd);
  }
  {
#line 55
  (*mark)((struct lsh_object *)i->report);
  }
  {
#line 56
  string_queue_mark(& i->q, mark);
  }
  }
#line 58
  return;
}
}
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.h.x"
static void do_write_buffer_free(struct lsh_object *o ) 
{ 
  struct write_buffer *i ;

  {
  {
#line 62
  i = (struct write_buffer *)o;
  {
#line 63
  lsh_string_free((struct lsh_string  const  *)i->buffer);
  }
  {
#line 64
  string_queue_free(& i->q);
  }
  {
#line 65
  lsh_string_free((struct lsh_string  const  *)i->partial);
  }
  }
#line 66
  return;
}
}
#line 67 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.h.x"
struct lsh_class write_buffer_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & abstract_write_class, (char *)"write_buffer", (size_t )sizeof(struct write_buffer ),
    & do_write_buffer_mark, & do_write_buffer_free};
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.c"
static void do_write(struct abstract_write *w , struct lsh_string *packet ) 
{ 
  struct write_buffer *closure ;
  uint32_t length ;
  uint32_t tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 48
  closure = (struct write_buffer *)w;
  {
#line 49
  tmp = lsh_string_length((struct lsh_string  const  *)packet);
  }
#line 49
  length = tmp;
  {
#line 51
  debug("write_buffer: do_write length = %i\n", length);
  }
  }
#line 53
  if (! length) {
    {
    {
#line 55
    lsh_string_free((struct lsh_string  const  *)packet);
    }
    }
#line 56
    return;
  }
#line 59
  if (closure->closed) {
    {
    {
#line 61
    werror("write_buffer: Attempt to write data to closed buffer.\n");
    }
    {
#line 62
    lsh_string_free((struct lsh_string  const  *)packet);
    }
    }
#line 63
    return;
  }
  {
  {
#line 68
  string_queue_add_tail(& closure->q, packet);
  }
  }
#line 70
  if (! closure->length) {
    {
    {
#line 72
    lsh_oop_register_write_fd(closure->fd);
    }
    }
  }
  {
#line 74
  closure->empty = 0;
#line 76
  closure->length += length;
  {
#line 78
  debug("write_buffer: do_write closure->length = %i\n", closure->length);
  }
  }
#line 80
  return;
}
}
#line 88 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.c"
int write_buffer_pre_write(struct write_buffer *buffer ) 
{ 
  uint32_t length ;
  uint8_t const   *tmp ;
  uint32_t partial_left ;
  uint32_t tmp___0 ;
  uint32_t buffer_left ;
  uint32_t tmp___1 ;
  uint8_t const   *tmp___2 ;
  uint8_t const   *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 90
  length = buffer->end - buffer->start;
#line 92
  if (buffer->empty) {
#line 93
    return (0);
  }
#line 95
  if (buffer->start > buffer->block_size) {
    {
    {
#line 99
    tmp = lsh_string_data((struct lsh_string  const  *)buffer->buffer);
    }
    {
#line 99
    lsh_string_write(buffer->buffer, (uint32_t )0, length, tmp + buffer->start);
    }
#line 101
    buffer->start = (uint32_t )0;
#line 102
    buffer->end = length;
    }
  }
  {
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 105
    if (! (length < buffer->block_size)) {
#line 105
      goto while_break;
    }
#line 108
    if (buffer->partial) {
      {
      {
#line 110
      tmp___0 = lsh_string_length((struct lsh_string  const  *)buffer->partial);
      }
#line 110
      partial_left = tmp___0 - buffer->pos;
#line 112
      buffer_left = 2U * buffer->block_size - buffer->end;
      }
#line 113
      if (partial_left <= buffer_left) {
        {
        {
#line 116
        tmp___1 = lsh_string_length((struct lsh_string  const  *)buffer->buffer);
        }
        {
#line 116
        trace("write_buffer_pre_write: buffer->buffer: length = %i\n  buffer->start: %i, buffer->end: %i\n  partial_left: %i, buffer->pos: %i\n",
              tmp___1, buffer->start, buffer->end, partial_left, buffer->pos);
        }
        {
#line 123
        tmp___2 = lsh_string_data((struct lsh_string  const  *)buffer->partial);
        }
        {
#line 123
        lsh_string_write(buffer->buffer, buffer->end, partial_left, tmp___2 + buffer->pos);
        }
#line 127
        buffer->end += partial_left;
#line 128
        length += partial_left;
        {
#line 130
        lsh_string_free((struct lsh_string  const  *)buffer->partial);
        }
#line 131
        buffer->partial = (struct lsh_string *)((void *)0);
        }
      } else {
        {
        {
#line 135
        tmp___3 = lsh_string_data((struct lsh_string  const  *)buffer->partial);
        }
        {
#line 135
        lsh_string_write(buffer->buffer, buffer->end, buffer_left, tmp___3 + buffer->pos);
        }
#line 139
        buffer->end += buffer_left;
#line 140
        length += buffer_left;
#line 141
        buffer->pos += buffer_left;
        }
#line 143
        if (! (length >= buffer->block_size)) {
          {
          {
#line 143
          __assert_fail("length >= buffer->block_size", "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.c",
                        143U, "write_buffer_pre_write");
          }
          }
        }
      }
    } else {
      {
      {
#line 149
      tmp___4 = lsh_queue_is_empty(& buffer->q.q);
      }
      }
#line 149
      if (tmp___4) {
#line 155
        goto while_break;
      } else {
        {
        {
#line 151
        buffer->partial = string_queue_remove_head(& buffer->q);
        }
#line 152
        buffer->pos = (uint32_t )0;
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 158
  buffer->empty = ! length;
#line 159
  return (! buffer->empty);
}
}
#line 162 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.c"
void write_buffer_consume(struct write_buffer *buffer , uint32_t size ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 164
  buffer->start += size;
#line 165
  if (! (buffer->start <= buffer->end)) {
    {
    {
#line 165
    __assert_fail("buffer->start <= buffer->end", "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.c",
                  165U, "write_buffer_consume");
    }
    }
  }
#line 166
  buffer->length -= size;
#line 168
  if (buffer->report) {
    {
    {
#line 169
    (*((buffer->report)->report))(buffer->report, size);
    }
    }
  }
#line 170
  return;
}
}
#line 172 "/home/ysko/Works/test-src/lsh-2.0.4/src/write_buffer.c"
struct write_buffer *make_write_buffer(struct lsh_fd *fd , uint32_t size ) 
{ 
  struct write_buffer *res ;
  struct lsh_object *tmp ;
  uint32_t tmp___0 ;

  {
  {
  {
#line 175
  tmp = lsh_object_alloc(& write_buffer_class);
  }
#line 175
  res = (struct write_buffer *)tmp;
#line 177
  res->super.write = & do_write;
#line 179
  res->fd = fd;
#line 181
  res->block_size = size;
  {
#line 183
  res->buffer = lsh_string_alloc(2U * size);
  }
#line 185
  res->empty = 1;
#line 186
  res->length = (uint32_t )0;
#line 188
  res->closed = 0;
  {
#line 194
  lsh_queue_init(& res->q.q);
  }
#line 196
  res->pos = (uint32_t )0;
#line 197
  res->partial = (struct lsh_string *)((void *)0);
#line 199
  tmp___0 = (uint32_t )0;
#line 199
  res->end = tmp___0;
#line 199
  res->start = tmp___0;
  }
#line 201
  return (res);
}
}
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 411 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 526
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 795
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 181 "/usr/include/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void syslog(int __pri , char const   *__fmt  , ...) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 500 "/home/ysko/Works/test-src/lsh-2.0.4/src/argp/argp.h"
extern  __attribute__((__nothrow__)) void argp_error(struct argp_state  const  *__state ,
                                                     char const   *__fmt  , ...) ;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.h"
int trace_flag ;
#line 33
int debug_flag ;
#line 34
int quiet_flag ;
#line 35
int verbose_flag ;
#line 37
struct argp  const  werror_argp ;
#line 39
void set_error_stream(int fd ) ;
#line 40
void set_error_ignore(void) ;
#line 41
void set_error_raw(int raw ) ;
#line 46
int dup_error_stream(void) ;
#line 49
void set_error_syslog(char const   *id ) ;
#line 74
void werror_vformat(char const   *f , va_list args ) ;
#line 79
void verbose(char const   *format  , ...) ;
#line 83
void werror_progress(char const   *string ) ;
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.h"
struct lsh_string *utf8_to_local(struct lsh_string *s , enum utf8_flag flags , int free___0 ) ;
#line 62
struct lsh_string *low_utf8_to_local(uint32_t length , uint8_t const   *s , enum utf8_flag flags ) ;
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms.h"
uint32_t get_atom_length(int atom ) ;
#line 36
uint8_t const   *get_atom_name(int atom ) ;
#line 98 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.h"
unsigned int format_size_in_decimal(uint32_t n ) ;
#line 281 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
struct exception  const  *write_raw(int fd , uint32_t length , uint8_t const   *data ) ;
#line 292
void io_set_close_on_exec(int fd ) ;
#line 888 "/usr/include/gmp-i386.h"
extern char *__gmpz_get_str(char * , int  , mpz_srcptr  ) ;
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
char const   *lsh_get_cstring(struct lsh_string  const  *s ) ;
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
int trace_flag  =    0;
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
int debug_flag  =    0;
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
int quiet_flag  =    0;
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
int verbose_flag  =    0;
#line 64 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static char const   *program_name  =    (char const   *)((void *)0);
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static struct argp_option  const  werror_options[6]  = {      {"quiet", 'q', (char const   *)((void *)0), 0, "Suppress all warnings and diagnostic messages",
      0}, 
        {"verbose", 'v', (char const   *)((void *)0), 0, "Verbose diagnostic messages",
      0}, 
        {"trace", -1, (char const   *)((void *)0), 0, "Detailed trace", 0}, 
        {"debug", -2, (char const   *)((void *)0), 0, "Print huge amounts of debug information",
      0}, 
        {"log-file", -3, "File name", 0, "Append messages to this file.", 0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (char const   *)((void *)0),
      0}};
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static error_t werror_argp_parser(int key , char *arg , struct argp_state *state ) 
{ 
  int fd ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 91
  if (key == 16777219) {
#line 91
    goto case_16777219;
  }
#line 91
  if (key == 16777217) {
#line 91
    goto case_16777219;
  }
#line 94
  if (key == 113) {
#line 94
    goto case_113;
  }
#line 97
  if (key == 118) {
#line 97
    goto case_118;
  }
#line 100
  if (key == -1) {
#line 100
    goto case_neg_1;
  }
#line 103
  if (key == -2) {
#line 103
    goto case_neg_2;
  }
#line 106
  if (key == -3) {
#line 106
    goto case_neg_3;
  }
#line 88
  goto switch_default;
  switch_default: 
#line 89
  return (7);
  case_16777219: 
#line 92
  program_name = (char const   *)state->name;
#line 93
  goto switch_break;
  case_113: 
#line 95
  quiet_flag = 1;
#line 96
  goto switch_break;
  case_118: 
#line 98
  verbose_flag = 1;
#line 99
  goto switch_break;
  case_neg_1: 
#line 101
  trace_flag = 1;
#line 102
  goto switch_break;
  case_neg_2: 
#line 104
  debug_flag = 1;
#line 105
  goto switch_break;
  case_neg_3: 
  {
  {
#line 113
  tmp = open((char const   *)arg, 1089, 438);
  }
#line 113
  fd = tmp;
  }
#line 114
  if (fd < 0) {
    {
    {
#line 115
    argp_error((struct argp_state  const  *)state, "Failed to open log file `%s\'.",
               arg);
    }
    }
  } else {
    {
    {
#line 118
    io_set_close_on_exec(fd);
    }
    {
#line 119
    set_error_stream(fd);
    }
    }
  }
  switch_break: ;
#line 123
  return (0);
}
}
#line 126 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
struct argp  const  werror_argp  =    {werror_options, & werror_argp_parser, (char const   *)((void *)0), (char const   *)((void *)0),
    (struct argp_child  const  *)((void *)0), (char *(*)(int __key , char const   *__text ,
                                                         void *__input ))((void *)0),
    (char const   *)((void *)0)};
#line 133 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static int error_fd  =    2;
#line 136 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static uint8_t error_buffer[500]  ;
#line 137 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static uint32_t error_pos  =    (uint32_t )0;
#line 138 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static int error_raw  =    0;
#line 140 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static struct exception  const  *(*error_write)(int fd , uint32_t length , uint8_t const   *data )  =    & write_raw;
#line 144 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static struct exception  const  *write_syslog(int fd  __attribute__((__unused__)) ,
                                              uint32_t length , uint8_t const   *data ) 
{ 
  struct lsh_string *s ;
  void *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 150
  tmp = memchr((void const   *)data, '\000', length);
  }
  }
#line 150
  if (tmp) {
    {
    {
#line 150
    __assert_fail("!memchr(data, \'\\0\', length)", "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c",
                  150U, "write_syslog");
    }
    }
  }
  {
  {
#line 153
  s = ssh_format("%ls", length, data);
  }
  {
#line 158
  tmp___0 = lsh_get_cstring((struct lsh_string  const  *)s);
  }
  {
#line 158
  syslog(5, "%s", tmp___0);
  }
  {
#line 159
  lsh_string_free((struct lsh_string  const  *)s);
  }
  }
#line 161
  return ((struct exception  const  *)((void *)0));
}
}
#line 165 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
void set_error_syslog(char const   *id ) 
{ 


  {
  {
  {
#line 168
  openlog(id, 3, 3 << 3);
  }
#line 169
  error_write = & write_syslog;
#line 170
  error_fd = -1;
  }
#line 171
  return;
}
}
#line 174 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static struct exception  const  *write_ignore(int fd  __attribute__((__unused__)) ,
                                              uint32_t length  __attribute__((__unused__)) ,
                                              uint8_t const   *data  __attribute__((__unused__)) ) 
{ 


  {
#line 177
  return ((struct exception  const  *)((void *)0));
}
}
#line 179 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
void set_error_stream(int fd ) 
{ 


  {
#line 182
  error_fd = fd;
#line 184
  error_write = & write_raw;
#line 185
  return;
}
}
#line 187 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
void set_error_raw(int raw ) 
{ 
  int tmp ;

  {
#line 193
  if (raw) {
#line 193
    if (error_fd == 2) {
      {
      {
#line 193
      tmp = isatty(2);
      }
      }
#line 193
      if (tmp) {
#line 194
        error_raw = 1;
      } else {
#line 196
        error_raw = 0;
      }
    } else {
#line 196
      error_raw = 0;
    }
  } else {
#line 196
    error_raw = 0;
  }
#line 197
  return;
}
}
#line 199 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
int dup_error_stream(void) 
{ 
  int fd ;
  int tmp ;

  {
#line 202
  if (error_fd < 0) {
#line 205
    return (1);
  } else {
    {
    {
#line 208
    tmp = dup(error_fd);
    }
#line 208
    fd = tmp;
    }
#line 213
    if (fd > 2) {
      {
      {
#line 215
      io_set_close_on_exec(fd);
      }
#line 216
      error_fd = fd;
      }
#line 217
      return (1);
    }
#line 220
    if (fd >= 0) {
      {
      {
#line 221
      close(fd);
      }
      }
    }
#line 223
    return (0);
  }
}
}
#line 227 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
void set_error_ignore(void) 
{ 


  {
#line 230
  error_write = & write_ignore;
#line 231
  error_fd = -1;
#line 232
  return;
}
}
#line 236 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static void werror_flush(void) 
{ 


  {
#line 239
  if (error_pos) {
    {
    {
#line 241
    (*error_write)(error_fd, error_pos, (uint8_t const   *)(error_buffer));
    }
#line 242
    error_pos = (uint32_t )0;
    }
  }
#line 244
  return;
}
}
#line 246 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static void werror_putc(uint8_t c ) 
{ 
  uint32_t tmp ;

  {
#line 249
  if (error_raw) {
#line 249
    if ((int )c == 10) {
      {
      {
#line 251
      werror_putc((uint8_t )'\r');
      }
      }
    }
  }
#line 253
  if (error_pos == 500U) {
    {
    {
#line 254
    werror_flush();
    }
    }
  }
#line 256
  tmp = error_pos;
#line 256
  error_pos ++;
#line 256
  error_buffer[tmp] = c;
#line 257
  return;
}
}
#line 259 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static void werror_write_raw(uint32_t length , uint8_t const   *msg ) 
{ 


  {
#line 262
  if (error_pos + length <= 500U) {
    {
    {
#line 264
    memcpy((void */* __restrict  */)((void *)(error_buffer + error_pos)), (void const   */* __restrict  */)((void const   *)msg),
           length);
    }
#line 265
    error_pos += length;
    }
  } else {
    {
    {
#line 269
    werror_flush();
    }
    {
#line 270
    (*error_write)(error_fd, length, msg);
    }
    }
  }
#line 272
  return;
}
}
#line 274 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static void werror_write(uint32_t length , uint8_t const   *msg ) 
{ 
  uint8_t const   *eol ;
  void *tmp ;

  {
#line 277
  if (error_raw) {
    {
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 280
      tmp = memchr((void const   *)msg, '\n', length);
      }
#line 280
      eol = (uint8_t const   *)tmp;
      }
#line 280
      if (! eol) {
#line 280
        goto while_break;
      }
      {
      {
#line 282
      werror_write_raw((uint32_t )(eol - msg), msg);
      }
      {
#line 283
      werror_putc((uint8_t )'\n');
      }
#line 285
      eol ++;
#line 286
      length = (uint32_t )((long )length - (eol - msg));
#line 287
      msg = eol;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
  {
#line 290
  werror_write_raw(length, msg);
  }
  }
#line 291
  return;
}
}
#line 293 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static void werror_cstring(char *s ) 
{ 
  size_t tmp ;

  {
  {
  {
#line 294
  tmp = strlen((char const   *)s);
  }
  {
#line 294
  werror_write(tmp, (uint8_t const   *)s);
  }
  }
#line 294
  return;
}
}
#line 296 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static void werror_bignum(__mpz_struct *n , int base ) 
{ 
  char *s ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 299
  tmp = __gmpz_sizeinbase((mpz_srcptr )n, base);
  }
  {
#line 299
  tmp___0 = __builtin_alloca((unsigned long )(tmp + 2U));
  }
#line 299
  s = (char *)tmp___0;
  {
#line 300
  __gmpz_get_str(s, 16, (mpz_srcptr )n);
  }
  {
#line 302
  werror_cstring(s);
  }
  }
#line 303
  return;
}
}
#line 305 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static void werror_decimal(uint32_t n ) 
{ 
  unsigned int length ;
  unsigned int tmp ;
  uint32_t e ;
  unsigned int i ;
  uint32_t digit ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 308
  tmp = format_size_in_decimal(n);
  }
#line 308
  length = tmp;
#line 309
  e = (uint32_t )1;
#line 313
  i = 1U;
  }
  {
  {
#line 313
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 313
    if (! (i < length)) {
#line 313
      goto while_break;
    }
#line 314
    e *= 10U;
#line 313
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 316
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 316
    if (! e) {
#line 316
      goto while_break___0;
    }
#line 318
    digit = n / e;
#line 319
    n %= e;
#line 320
    if (! (digit < 10U)) {
      {
      {
#line 320
      __assert_fail("digit < 10", "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c",
                    320U, "werror_decimal");
      }
      }
    }
    {
    {
#line 321
    werror_putc((uint8_t )*("0123456789" + digit));
    }
#line 316
    e /= 10U;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 323
  return;
}
}
#line 325
static unsigned int format_size_in_hex(uint32_t n ) ;
#line 327 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static void werror_hex_digit(unsigned int digit ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 330
  werror_putc((uint8_t )*("0123456789abcdef" + digit));
  }
  }
#line 331
  return;
}
}
#line 333 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static void werror_hex_putc(uint8_t c ) 
{ 


  {
  {
  {
#line 336
  werror_hex_digit((unsigned int )((int )c / 16));
  }
  {
#line 337
  werror_hex_digit((unsigned int )((int )c % 16));
  }
  }
#line 338
  return;
}
}
#line 340 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static void werror_hex(uint32_t n ) 
{ 
  unsigned int left ;
  unsigned int tmp ;

  {
#line 343
  left = 8U;
  {
  {
#line 345
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 345
    if (left > 1U) {
#line 345
      if (! (! ((unsigned long )n & 4026531840UL))) {
#line 345
        goto while_break;
      }
    } else {
#line 345
      goto while_break;
    }
#line 348
    left --;
#line 349
    n <<= 4;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 352
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 352
    tmp = left;
#line 352
    left --;
#line 352
    if (! tmp) {
#line 352
      goto while_break___0;
    }
    {
    {
#line 354
    werror_hex_digit((n >> 28) & 15U);
    }
#line 355
    n <<= 4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 357
  return;
}
}
#line 359 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static void werror_hexdump(uint32_t length , uint8_t const   *data ) 
{ 
  uint32_t i ;
  unsigned int j ;
  unsigned int tmp ;
  unsigned int r ;
  uint8_t c ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 362
  i = (uint32_t )0;
  {
#line 364
  werror("(size %i = 0x%xi)\n", length, length);
  }
#line 366
  i = (uint32_t )0;
  }
  {
  {
#line 366
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 366
    if (! (i < length)) {
#line 366
      goto while_break;
    }
    {
    {
#line 368
    tmp = format_size_in_hex(i);
    }
#line 368
    j = tmp;
#line 369
    r = length - i;
    }
    {
    {
#line 371
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 371
      if (! (j < 8U)) {
#line 371
        goto while_break___0;
      }
      {
      {
#line 372
      werror_putc((uint8_t )'0');
      }
#line 371
      j ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
    {
    {
#line 374
    werror_hex(i);
    }
    {
#line 375
    werror_cstring((char *)": ");
    }
    }
#line 377
    if (r > 16U) {
#line 378
      r = 16U;
    }
#line 380
    j = 0U;
    {
    {
#line 380
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;

#line 380
      if (! (j < r)) {
#line 380
        goto while_break___1;
      }
      {
      {
#line 381
      werror_hex_putc((uint8_t )*(data + (i + j)));
      }
#line 380
      j ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: ;
    {
    {
#line 383
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;

#line 383
      if (! (j < 17U)) {
#line 383
        goto while_break___2;
      }
      {
      {
#line 384
      werror_cstring((char *)"  ");
      }
#line 383
      j ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 386
    j = 0U;
    {
    {
#line 386
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;

#line 386
      if (! (j < r)) {
#line 386
        goto while_break___3;
      }
#line 388
      c = (uint8_t )*(data + (i + j));
#line 389
      if ((int )c < 32) {
#line 390
        c = (uint8_t )'.';
      } else
#line 389
      if ((int )c > 126) {
#line 390
        c = (uint8_t )'.';
      }
      {
      {
#line 391
      werror_putc(c);
      }
#line 386
      j ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: 
    {
    {
#line 394
    werror_cstring((char *)"\n");
    }
#line 366
    i += 16U;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 396
  return;
}
}
#line 398 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static void werror_paranoia_putc(uint8_t c ) 
{ 
  unsigned short const   **tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 403
  if ((int )c == 92) {
#line 403
    goto case_92;
  }
#line 406
  if ((int )c == 13) {
#line 406
    goto case_13;
  }
#line 417
  if ((int )c == 10) {
#line 417
    goto case_10;
  }
#line 409
  goto switch_default;
  case_92: 
  {
  {
#line 404
  werror_cstring((char *)"\\\\");
  }
  }
#line 405
  goto switch_break;
  case_13: 
#line 408
  goto switch_break;
  switch_default: 
  {
  {
#line 410
  tmp = __ctype_b_loc();
  }
  }
#line 410
  if (! ((int const   )*(*tmp + (int )c) & 16384)) {
    {
    {
#line 412
    werror_putc((uint8_t )'\\');
    }
    {
#line 413
    werror_hex_putc(c);
    }
    }
#line 414
    goto switch_break;
  }
  case_10: 
  {
  {
#line 418
  werror_putc(c);
  }
  }
#line 419
  goto switch_break;
  switch_break: ;
#line 421
  return;
}
}
#line 423 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
void werror_vformat(char const   *f , va_list args ) 
{ 
  size_t tmp ;
  int do_hex ;
  int do_free ;
  int do_paranoia ;
  int do_utf8 ;
  char const   *tmp___0 ;
  void (*tmp___1)(uint32_t n ) ;
  uint32_t tmp___3 ;
  void (*tmp___4)(uint8_t c ) ;
  int tmp___6 ;
  int tmp___7 ;
  MP_INT *tmp___9 ;
  int atom ;
  int tmp___11 ;
  uint8_t const   *tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t length ;
  uint32_t tmp___15 ;
  uint8_t const   *s ;
  uint8_t const   *tmp___17 ;
  struct lsh_string *u ;
  enum utf8_flag flags ;
  uint32_t i ;
  uint8_t const   *tmp___18 ;
  struct lsh_string *s___0 ;
  struct lsh_string *tmp___20 ;
  enum utf8_flag flags___0 ;
  uint8_t const   *tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t length___0 ;
  uint32_t tmp___23 ;
  uint8_t const   *data ;
  uint8_t const   *tmp___24 ;
  uint32_t i___0 ;
  uint8_t const   *tmp___25 ;
  uint32_t tmp___26 ;
  struct lsh_object *o ;
  struct lsh_object *tmp___28 ;
  char const   *type ;
  size_t tmp___29 ;
  char *s___1 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  char *tmp___33 ;
  size_t tmp___34 ;
  int e ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;
  char const   *tmp___39 ;
  uint32_t tmp___40 ;
  int tmp___41 ;
  MP_INT *tmp___42 ;
  int tmp___43 ;
  uint32_t tmp___44 ;
  uint8_t const   *tmp___45 ;
  struct lsh_string *tmp___46 ;
  struct lsh_object *tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;

  {
#line 426
  if (program_name) {
    {
    {
#line 428
    tmp = strlen(program_name);
    }
    {
#line 428
    werror_write(tmp, (uint8_t const   *)program_name);
    }
    {
#line 429
    werror_write((uint32_t )2, (uint8_t const   *)": ");
    }
    }
  }
  {
  {
#line 432
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 432
    if (! *f) {
#line 432
      goto while_break;
    }
#line 434
    if ((int const   )*f == 37) {
#line 436
      do_hex = 0;
#line 437
      do_free = 0;
#line 438
      do_paranoia = 0;
#line 439
      do_utf8 = 0;
      {
      {
#line 441
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 441
        f ++;
#line 441
        if (! *f) {
#line 441
          goto while_break___0;
        }
#line 444
        if ((int const   )*f == 120) {
#line 444
          goto case_120;
        }
#line 447
        if ((int const   )*f == 102) {
#line 447
          goto case_102;
        }
#line 450
        if ((int const   )*f == 112) {
#line 450
          goto case_112;
        }
#line 453
        if ((int const   )*f == 117) {
#line 453
          goto case_117;
        }
#line 456
        goto switch_default;
        case_120: 
#line 445
        do_hex = 1;
#line 446
        goto switch_break;
        case_102: 
#line 448
        do_free = 1;
#line 449
        goto switch_break;
        case_112: 
#line 451
        do_paranoia = 1;
#line 452
        goto switch_break;
        case_117: 
#line 454
        do_utf8 = 1;
#line 455
        goto switch_break;
        switch_default: 
#line 457
        goto end_options;
        switch_break: ;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: ;
      end_options: 
#line 460
      tmp___0 = f;
#line 460
      f ++;
#line 462
      if ((int const   )*tmp___0 == 37) {
#line 462
        goto case_37;
      }
#line 465
      if ((int const   )*tmp___0 == 105) {
#line 465
        goto case_105;
      }
#line 468
      if ((int const   )*tmp___0 == 99) {
#line 468
        goto case_99;
      }
#line 471
      if ((int const   )*tmp___0 == 110) {
#line 471
        goto case_110;
      }
#line 474
      if ((int const   )*tmp___0 == 97) {
#line 474
        goto case_97;
      }
#line 484
      if ((int const   )*tmp___0 == 115) {
#line 484
        goto case_115;
      }
#line 524
      if ((int const   )*tmp___0 == 83) {
#line 524
        goto case_83;
      }
#line 564
      if ((int const   )*tmp___0 == 116) {
#line 564
        goto case_116;
      }
#line 580
      if ((int const   )*tmp___0 == 122) {
#line 580
        goto case_122;
      }
#line 595
      if ((int const   )*tmp___0 == 101) {
#line 595
        goto case_101;
      }
#line 605
      goto switch_default___0;
      case_37: 
      {
      {
#line 463
      werror_putc((uint8_t )*f);
      }
      }
#line 464
      goto switch_break___0;
      case_105: 
#line 466
      if (do_hex) {
#line 466
        tmp___1 = & werror_hex;
      } else {
#line 466
        tmp___1 = & werror_decimal;
      }
      {
      {
#line 466
      tmp___40 = __builtin_va_arg(args, uint32_t );
      }
#line 466
      tmp___3 = tmp___40;
      {
#line 466
      (*tmp___1)(tmp___3);
      }
      }
#line 467
      goto switch_break___0;
      case_99: 
#line 469
      if (do_paranoia) {
#line 469
        tmp___4 = & werror_paranoia_putc;
      } else {
#line 469
        tmp___4 = & werror_putc;
      }
      {
      {
#line 469
      tmp___41 = __builtin_va_arg(args, int );
      }
#line 469
      tmp___6 = tmp___41;
      {
#line 469
      (*tmp___4)((uint8_t )tmp___6);
      }
      }
#line 470
      goto switch_break___0;
      case_110: 
#line 472
      if (do_hex) {
#line 472
        tmp___7 = 16;
      } else {
#line 472
        tmp___7 = 10;
      }
      {
      {
#line 472
      tmp___42 = __builtin_va_arg(args, MP_INT *);
      }
#line 472
      tmp___9 = tmp___42;
      {
#line 472
      werror_bignum(tmp___9, tmp___7);
      }
      }
#line 473
      goto switch_break___0;
      case_97: 
      {
      {
#line 476
      tmp___43 = __builtin_va_arg(args, int );
      }
#line 476
      tmp___11 = tmp___43;
#line 476
      atom = tmp___11;
      }
#line 478
      if (atom) {
        {
        {
#line 479
        tmp___12 = get_atom_name(atom);
        }
        {
#line 479
        tmp___13 = get_atom_length(atom);
        }
        {
#line 479
        werror_write(tmp___13, tmp___12);
        }
        }
      } else {
        {
        {
#line 481
        werror_write((uint32_t )9, (uint8_t const   *)"<unknown>");
        }
        }
      }
#line 482
      goto switch_break___0;
      case_115: 
      {
      {
#line 486
      tmp___44 = __builtin_va_arg(args, uint32_t );
      }
#line 486
      tmp___15 = tmp___44;
#line 486
      length = tmp___15;
      {
#line 487
      tmp___45 = __builtin_va_arg(args, uint8_t const   *);
      }
#line 487
      tmp___17 = tmp___45;
#line 487
      s = tmp___17;
#line 489
      u = (struct lsh_string *)((void *)0);
      }
#line 491
      if (do_utf8) {
#line 493
        flags = (enum utf8_flag )1;
#line 494
        if (do_paranoia) {
#line 495
          flags = (enum utf8_flag )((unsigned int )flags | 2U);
        }
        {
        {
#line 497
        u = low_utf8_to_local(length, s, flags);
        }
        }
#line 498
        if (! u) {
          {
          {
#line 500
          werror_cstring((char *)"<Invalid utf-8 string>");
          }
          }
#line 501
          goto switch_break___0;
        }
        {
        {
#line 503
        length = lsh_string_length((struct lsh_string  const  *)u);
        }
        {
#line 504
        s = lsh_string_data((struct lsh_string  const  *)u);
        }
        }
      }
#line 506
      if (do_hex) {
#line 508
        if (! (! do_paranoia)) {
          {
          {
#line 508
          __assert_fail("!do_paranoia", "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c",
                        508U, "werror_vformat");
          }
          }
        }
        {
        {
#line 509
        werror_hexdump(length, s);
        }
        }
      } else
#line 511
      if (do_paranoia) {
#line 514
        i = (uint32_t )0;
        {
        {
#line 514
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;

#line 514
          if (! (i < length)) {
#line 514
            goto while_break___1;
          }
          {
#line 515
          tmp___18 = s;
#line 515
          s ++;
          {
#line 515
          werror_paranoia_putc((uint8_t )*tmp___18);
          }
#line 514
          i ++;
          }
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: ;
      } else {
        {
        {
#line 518
        werror_write(length, s);
        }
        }
      }
#line 520
      if (u) {
        {
        {
#line 521
        lsh_string_free((struct lsh_string  const  *)u);
        }
        }
      }
#line 523
      goto switch_break___0;
      case_83: 
      {
      {
#line 526
      tmp___46 = __builtin_va_arg(args, struct lsh_string *);
      }
#line 526
      tmp___20 = tmp___46;
#line 526
      s___0 = tmp___20;
      }
#line 528
      if (do_utf8) {
#line 530
        flags___0 = (enum utf8_flag )1;
#line 531
        if (do_paranoia) {
#line 532
          flags___0 = (enum utf8_flag )((unsigned int )flags___0 | 2U);
        }
        {
        {
#line 534
        s___0 = utf8_to_local(s___0, flags___0, do_free);
        }
        }
#line 535
        if (! s___0) {
          {
          {
#line 537
          werror_cstring((char *)"<Invalid utf-8 string>");
          }
          }
#line 538
          goto switch_break___0;
        }
#line 540
        do_free = 1;
      }
#line 542
      if (do_hex) {
#line 544
        if (! (! do_paranoia)) {
          {
          {
#line 544
          __assert_fail("!do_paranoia", "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c",
                        544U, "werror_vformat");
          }
          }
        }
        {
        {
#line 545
        tmp___21 = lsh_string_data((struct lsh_string  const  *)s___0);
        }
        {
#line 545
        tmp___22 = lsh_string_length((struct lsh_string  const  *)s___0);
        }
        {
#line 545
        werror_hexdump(tmp___22, tmp___21);
        }
        }
      } else
#line 547
      if (do_paranoia) {
        {
        {
#line 549
        tmp___23 = lsh_string_length((struct lsh_string  const  *)s___0);
        }
#line 549
        length___0 = tmp___23;
        {
#line 550
        tmp___24 = lsh_string_data((struct lsh_string  const  *)s___0);
        }
#line 550
        data = tmp___24;
#line 553
        i___0 = (uint32_t )0;
        }
        {
        {
#line 553
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;

#line 553
          if (! (i___0 < length___0)) {
#line 553
            goto while_break___2;
          }
          {
          {
#line 554
          werror_paranoia_putc((uint8_t )*(data + i___0));
          }
#line 553
          i___0 ++;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: ;
      } else {
        {
        {
#line 557
        tmp___25 = lsh_string_data((struct lsh_string  const  *)s___0);
        }
        {
#line 557
        tmp___26 = lsh_string_length((struct lsh_string  const  *)s___0);
        }
        {
#line 557
        werror_write(tmp___26, tmp___25);
        }
        }
      }
#line 559
      if (do_free) {
        {
        {
#line 560
        lsh_string_free((struct lsh_string  const  *)s___0);
        }
        }
      }
#line 562
      goto switch_break___0;
      case_116: 
      {
      {
#line 566
      tmp___47 = __builtin_va_arg(args, struct lsh_object *);
      }
#line 566
      tmp___28 = tmp___47;
#line 566
      o = tmp___28;
      }
#line 569
      if (! o) {
#line 570
        type = "<NULL>";
      } else
#line 571
      if (o->isa) {
#line 572
        type = (char const   *)(o->isa)->name;
      } else {
#line 574
        type = "<STATIC>";
      }
      {
      {
#line 576
      tmp___29 = strlen(type);
      }
      {
#line 576
      werror_write(tmp___29, (uint8_t const   *)type);
      }
      }
#line 578
      goto switch_break___0;
      case_122: 
      {
      {
#line 582
      tmp___48 = __builtin_va_arg(args, char *);
      }
#line 582
      tmp___31 = tmp___48;
#line 582
      s___1 = tmp___31;
      }
#line 584
      if (do_hex) {
        {
        {
#line 585
        tmp___32 = strlen((char const   *)s___1);
        }
        {
#line 585
        werror_hexdump(tmp___32, (uint8_t const   *)s___1);
        }
        }
      } else
#line 587
      if (do_paranoia) {
        {
        {
#line 588
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;

#line 588
          if (! *s___1) {
#line 588
            goto while_break___3;
          }
          {
#line 589
          tmp___33 = s___1;
#line 589
          s___1 ++;
          {
#line 589
          werror_paranoia_putc((uint8_t )*tmp___33);
          }
          }
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: ;
      } else {
        {
        {
#line 591
        tmp___34 = strlen((char const   *)s___1);
        }
        {
#line 591
        werror_write(tmp___34, (uint8_t const   *)s___1);
        }
        }
      }
#line 593
      goto switch_break___0;
      case_101: 
      {
      {
#line 597
      tmp___49 = __builtin_va_arg(args, int );
      }
#line 597
      tmp___36 = tmp___49;
#line 597
      e = tmp___36;
      {
#line 598
      werror_cstring((char *)"(errno = ");
      }
      {
#line 599
      werror_decimal((uint32_t )e);
      }
      {
#line 600
      werror_cstring((char *)"): ");
      }
      {
#line 601
      tmp___37 = __errno_location();
      }
      {
#line 601
      tmp___38 = strerror(*tmp___37);
      }
      {
#line 601
      werror_cstring(tmp___38);
      }
      }
#line 603
      goto switch_break___0;
      switch_default___0: 
      {
      {
#line 606
      fatal("werror_vformat: bad format string!\n");
      }
      }
#line 607
      goto switch_break___0;
      switch_break___0: ;
    } else {
      {
#line 611
      tmp___39 = f;
#line 611
      f ++;
      {
#line 611
      werror_putc((uint8_t )*tmp___39);
      }
      }
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 613
  return;
}
}
#line 627 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
void werror(char const   *format  , ...) 
{ 
  va_list args ;

  {
#line 634
  if (verbose_flag) {
    {
    {
#line 636
    __builtin_va_start(args, format);
    }
    {
#line 637
    werror_vformat(format, args);
    }
    {
#line 638
    __builtin_va_end(args);
    }
    {
#line 639
    werror_flush();
    }
    }
  } else
#line 634
  if (! quiet_flag) {
    {
    {
#line 636
    __builtin_va_start(args, format);
    }
    {
#line 637
    werror_vformat(format, args);
    }
    {
#line 638
    __builtin_va_end(args);
    }
    {
#line 639
    werror_flush();
    }
    }
  }
#line 641
  return;
}
}
#line 643 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
void werror_progress(char const   *string ) 
{ 
  size_t tmp ;

  {
#line 646
  if (verbose_flag) {
    {
    {
#line 648
    tmp = strlen(string);
    }
    {
#line 648
    werror_write(tmp, (uint8_t const   *)string);
    }
    {
#line 649
    werror_flush();
    }
    }
  } else
#line 646
  if (! quiet_flag) {
    {
    {
#line 648
    tmp = strlen(string);
    }
    {
#line 648
    werror_write(tmp, (uint8_t const   *)string);
    }
    {
#line 649
    werror_flush();
    }
    }
  }
#line 651
  return;
}
}
#line 653 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
void trace(char const   *format  , ...) 
{ 
  va_list args ;

  {
#line 658
  if (trace_flag) {
    {
    {
#line 660
    __builtin_va_start(args, format);
    }
    {
#line 661
    werror_vformat(format, args);
    }
    {
#line 662
    __builtin_va_end(args);
    }
    {
#line 663
    werror_flush();
    }
    }
  }
#line 665
  return;
}
}
#line 667 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
void debug(char const   *format  , ...) 
{ 
  va_list args ;

  {
#line 672
  if (debug_flag) {
    {
    {
#line 674
    __builtin_va_start(args, format);
    }
    {
#line 675
    werror_vformat(format, args);
    }
    {
#line 676
    __builtin_va_end(args);
    }
    {
#line 677
    werror_flush();
    }
    }
  }
#line 679
  return;
}
}
#line 681 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
void verbose(char const   *format  , ...) 
{ 
  va_list args ;

  {
#line 686
  if (verbose_flag) {
    {
    {
#line 688
    __builtin_va_start(args, format);
    }
    {
#line 689
    werror_vformat(format, args);
    }
    {
#line 690
    __builtin_va_end(args);
    }
    {
#line 691
    werror_flush();
    }
    }
  }
#line 693
  return;
}
}
#line 700
 __attribute__((__noreturn__)) void fatal(char const   *format  , ...) ;
#line 700 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
void fatal(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
  {
#line 705
  __builtin_va_start(args, format);
  }
  {
#line 706
  werror_vformat(format, args);
  }
  {
#line 707
  __builtin_va_end(args);
  }
  {
#line 708
  werror_flush();
  }
  {
#line 724
  abort();
  }
  }
}
}
#line 734 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static uint32_t const   powers[3]  = {      (uint32_t const   )16UL,      (uint32_t const   )256UL,      (uint32_t const   )65536UL};
#line 727 "/home/ysko/Works/test-src/lsh-2.0.4/src/werror.c"
static unsigned int format_size_in_hex(uint32_t n ) 
{ 
  int i ;
  int e ;

  {
#line 739
  i = (int )(sizeof(powers) / sizeof(powers[0]) - 1UL);
#line 739
  e = 0;
  {
  {
#line 739
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 739
    if (! (i >= 0)) {
#line 739
      goto while_break;
    }
#line 741
    if (n >= (uint32_t )powers[i]) {
#line 743
      e = (int )((unsigned long )e + (1UL << i));
#line 744
      n /= (uint32_t )powers[i];
    }
#line 739
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 750
  return ((unsigned int )(e + 1));
}
}
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h.x"
struct lsh_class exception_class ;
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.h.x"
struct lsh_class resource_class ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h.x"
struct lsh_class userauth_special_exception_class ;
#line 40
struct lsh_class lsh_process_class ;
#line 69
struct lsh_class lsh_user_class ;
#line 56 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h"
struct exception *make_userauth_special_exception(struct lsh_string *reply , char const   *msg ) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h.x"
static void do_userauth_special_exception_free(struct lsh_object *o ) 
{ 
  struct userauth_special_exception *i ;

  {
  {
#line 17
  i = (struct userauth_special_exception *)o;
  {
#line 18
  lsh_string_free((struct lsh_string  const  *)i->reply);
  }
  }
#line 19
  return;
}
}
#line 20 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h.x"
struct lsh_class userauth_special_exception_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_class, (char *)"userauth_special_exception", (size_t )sizeof(struct userauth_special_exception ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_userauth_special_exception_free};
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h.x"
struct lsh_class lsh_process_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & resource_class, (char *)"lsh_process", (size_t )sizeof(struct lsh_process ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h.x"
static void do_lsh_user_free(struct lsh_object *o ) 
{ 
  struct lsh_user *i ;

  {
  {
#line 76
  i = (struct lsh_user *)o;
  {
#line 77
  lsh_string_free((struct lsh_string  const  *)i->name);
  }
  }
#line 78
  return;
}
}
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h.x"
struct lsh_class lsh_user_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"lsh_user", (size_t )sizeof(struct lsh_user ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_lsh_user_free};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.c"
struct exception *make_userauth_special_exception(struct lsh_string *reply , char const   *msg ) 
{ 
  struct userauth_special_exception *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 41
  tmp = lsh_object_alloc(& userauth_special_exception_class);
  }
#line 41
  self = (struct userauth_special_exception *)tmp;
#line 42
  self->super.type = (uint32_t )16386;
  }
#line 43
  if (msg) {
#line 43
    self->super.msg = msg;
  } else {
#line 43
    self->super.msg = "userauth special reply";
  }
#line 44
  self->reply = reply;
#line 46
  return (& self->super);
}
}
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 493
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 529
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 546
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execve)(char const   *__path ,
                                                                                   char * const  *__argv ,
                                                                                   char * const  *__envp ) ;
#line 568
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execl)(char const   *__path ,
                                                                                  char const   *__arg 
                                                                                  , ...) ;
#line 598
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 684
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 692
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 695
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 727
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 734
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 1123
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) crypt)(char const   *__key ,
                                                                                      char const   *__salt ) ;
#line 117 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 178 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 87 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h.x"
struct lsh_class exception_handler_class ;
#line 139 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h"
struct exception_handler default_exception_handler ;
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_io.h"
struct read_handler *make_read_file(struct abstract_write *c , uint32_t max_size ) ;
#line 138 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
struct io_callback *make_buffered_read(uint32_t buffer_size , struct read_handler *handler ) ;
#line 217
struct exception *make_io_exception(uint32_t type , struct lsh_fd *fd , int error ,
                                    char const   *msg ) ;
#line 295
struct lsh_fd *make_lsh_fd(int fd , enum io_type type , char const   *label , struct exception_handler *e ) ;
#line 365
struct lsh_fd *io_read(struct lsh_fd *fd , struct io_callback *read___0 , struct lsh_callback *close_callback ) ;
#line 369
struct lsh_fd *io_write(struct lsh_fd *fd , uint32_t block_size , struct lsh_callback *close_callback ) ;
#line 395
int lsh_make_pipe(int *fds ) ;
#line 406
int lsh_copy_file(int src , int dst ) ;
#line 142 "/home/ysko/Works/test-src/lsh-2.0.4/src/userauth.h"
struct lsh_process *unix_process_setup(pid_t pid , struct lsh_user *user , struct exit_callback **c ,
                                       struct address_info *peer , struct lsh_string *tty ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.h.x"
struct lsh_class user_db_class ;
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.h"
struct user_db *make_unix_user_db(struct reaper *reaper , char const   *pw_helper ,
                                  char const   *login_shell , int allow_root ) ;
#line 59
struct lsh_user *make_unix_user_self(struct lsh_string *name , struct reaper *reaper ,
                                     char const   *home , char const   *shell ) ;
#line 108
struct userauth server_userauth_none_preauth ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.h.x"
struct lsh_class exit_callback_class ;
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_pty.h"
int pty_open_slave(struct pty_info *pty ) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
struct lsh_class unix_user_class ;
#line 18 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
static void do_unix_user_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct unix_user *i ;

  {
  {
#line 22
  i = (struct unix_user *)o;
  {
#line 23
  (*mark)((struct lsh_object *)i->ctx);
  }
  }
#line 24
  return;
}
}
#line 25 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
static void do_unix_user_free(struct lsh_object *o ) 
{ 
  struct unix_user *i ;

  {
  {
#line 28
  i = (struct unix_user *)o;
  {
#line 29
  lsh_string_free((struct lsh_string  const  *)i->passwd);
  }
  {
#line 30
  lsh_string_free((struct lsh_string  const  *)i->home);
  }
  {
#line 31
  lsh_string_free((struct lsh_string  const  *)i->shell);
  }
  }
#line 32
  return;
}
}
#line 33 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
struct lsh_class unix_user_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & lsh_user_class, (char *)"unix_user", (size_t )sizeof(struct unix_user ),
    & do_unix_user_mark, & do_unix_user_free};
#line 55
struct lsh_class pwhelper_callback_class ;
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
static void do_pwhelper_callback_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct pwhelper_callback *i ;

  {
  {
#line 63
  i = (struct pwhelper_callback *)o;
  {
#line 64
  (*mark)((struct lsh_object *)i->user);
  }
  {
#line 65
  (*mark)((struct lsh_object *)i->c);
  }
  {
#line 66
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 67
  return;
}
}
#line 68 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
struct lsh_class pwhelper_callback_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exit_callback_class, (char *)"pwhelper_callback", (size_t )sizeof(struct pwhelper_callback ),
    & do_pwhelper_callback_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 88
struct lsh_class exc_read_user_file_handler_class ;
#line 92 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
static void do_exc_read_user_file_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct exc_read_user_file_handler *i ;

  {
  {
#line 96
  i = (struct exc_read_user_file_handler *)o;
  {
#line 97
  (*mark)((struct lsh_object *)i->c);
  }
  }
#line 98
  return;
}
}
#line 99 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
struct lsh_class exc_read_user_file_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"exc_read_user_file_handler", (size_t )sizeof(struct exc_read_user_file_handler ),
    & do_exc_read_user_file_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 122
struct lsh_class unix_user_db_class ;
#line 126 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
static void do_unix_user_db_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct unix_user_db *i ;

  {
  {
#line 130
  i = (struct unix_user_db *)o;
  {
#line 131
  (*mark)((struct lsh_object *)i->reaper);
  }
  }
#line 132
  return;
}
}
#line 133 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
struct lsh_class unix_user_db_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & user_db_class, (char *)"unix_user_db", (size_t )sizeof(struct unix_user_db ),
    & do_unix_user_db_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 155
struct lsh_class unix_user_self_class ;
#line 159 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
static void do_unix_user_self_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct unix_user_self *i ;

  {
  {
#line 163
  i = (struct unix_user_self *)o;
  {
#line 164
  (*mark)((struct lsh_object *)i->reaper);
  }
  }
#line 165
  return;
}
}
#line 166 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c.x"
struct lsh_class unix_user_self_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & lsh_user_class, (char *)"unix_user_self", (size_t )sizeof(struct unix_user_self ),
    & do_unix_user_self_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 126 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static void do_pwhelper_callback(struct exit_callback *s , int signaled , int core  __attribute__((__unused__)) ,
                                 int value ) ;
#line 126 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct exception  const  invalid_password  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "Invalid password according to helper program."};
#line 118 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static void do_pwhelper_callback(struct exit_callback *s , int signaled , int core  __attribute__((__unused__)) ,
                                 int value ) 
{ 
  struct pwhelper_callback *self ;

  {
#line 122
  self = (struct pwhelper_callback *)s;
#line 124
  if (signaled) {
    {
    {
#line 128
    (*((self->e)->raise))(self->e, & invalid_password);
    }
    }
  } else
#line 124
  if (value) {
    {
    {
#line 128
    (*((self->e)->raise))(self->e, & invalid_password);
    }
    }
  } else {
    {
    {
#line 131
    (*((self->c)->c))(self->c, (struct lsh_object *)self->user);
    }
    }
  }
#line 132
  return;
}
}
#line 134 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct exit_callback *make_pwhelper_callback(struct unix_user *user , struct command_continuation *c ,
                                                    struct exception_handler *e ) 
{ 
  struct pwhelper_callback *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 139
  tmp = lsh_object_alloc(& pwhelper_callback_class);
  }
#line 139
  self = (struct pwhelper_callback *)tmp;
#line 140
  self->super.exit = & do_pwhelper_callback;
#line 141
  self->user = user;
#line 142
  self->c = c;
#line 143
  self->e = e;
  }
#line 145
  return (& self->super);
}
}
#line 150 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static int kerberos_check_pw(struct unix_user *user , struct lsh_string *pw , struct command_continuation *c ,
                             struct exception_handler *e ) 
{ 
  int in[2] ;
  pid_t child ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int null_fd ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  struct lsh_fd *fd ;
  uint32_t tmp___7 ;
  struct lsh_fd *tmp___8 ;
  struct exit_callback *tmp___9 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
  {
#line 162
  tmp___0 = access((user->ctx)->pw_helper, 1);
  }
  }
#line 162
  if (tmp___0 < 0) {
    {
    {
#line 165
    tmp = __errno_location();
    }
    {
#line 165
    werror("Password helper program \'%z\' not available %e\n", (user->ctx)->pw_helper,
           *tmp);
    }
    }
#line 167
    return (0);
  }
  {
  {
#line 170
  tmp___1 = lsh_make_pipe(in);
  }
  }
#line 170
  if (! tmp___1) {
    {
    {
#line 172
    werror("kerberos_check_pw: Failed to create pipe.\n");
    }
    }
#line 173
    return (0);
  }
  {
  {
#line 176
  child = fork();
  }
  }
#line 180
  if (child == -1) {
#line 180
    goto case_neg_1;
  }
#line 184
  if (child == 0) {
#line 184
    goto case_0;
  }
#line 218
  goto switch_default;
  case_neg_1: 
  {
  {
#line 181
  tmp___2 = __errno_location();
  }
  {
#line 181
  werror("kerberos_check_pw: fork failed %e\n", *tmp___2);
  }
  }
#line 182
  return (0);
  case_0: 
  {
  {
#line 188
  null_fd = open("/dev/null", 2);
  }
  }
#line 189
  if (null_fd < 0) {
    {
    {
#line 191
    werror("kerberos_check_pw: Failed to open /dev/null.\n");
    }
    {
#line 192
    _exit(1);
    }
    }
  }
  {
  {
#line 194
  tmp___3 = dup2(in[0], 0);
  }
  }
#line 194
  if (tmp___3 < 0) {
    {
    {
#line 196
    werror("kerberos_check_pw: Can\'t dup stdin!\n");
    }
    {
#line 197
    _exit(1);
    }
    }
  }
  {
  {
#line 200
  tmp___4 = dup2(null_fd, 1);
  }
  }
#line 200
  if (tmp___4 < 0) {
    {
    {
#line 202
    werror("kerberos_check_pw: Can\'t dup stdout!\n");
    }
    {
#line 203
    _exit(1);
    }
    }
  }
  {
  {
#line 206
  tmp___5 = dup2(null_fd, 2);
  }
  }
#line 206
  if (tmp___5 < 0) {
    {
    {
#line 208
    _exit(1);
    }
    }
  }
  {
  {
#line 211
  close(in[1]);
  }
  {
#line 212
  close(null_fd);
  }
  {
#line 214
  tmp___6 = lsh_get_cstring((struct lsh_string  const  *)user->super.name);
  }
  {
#line 214
  execl((user->ctx)->pw_helper, (user->ctx)->pw_helper, tmp___6, (void *)0);
  }
  {
#line 216
  _exit(1);
  }
  }
  switch_default: 
  {
  {
#line 223
  close(in[0]);
  }
  {
#line 225
  tmp___7 = lsh_string_length((struct lsh_string  const  *)pw);
  }
  {
#line 225
  tmp___8 = make_lsh_fd(in[1], (enum io_type )0, "password helper stdin", e);
  }
  {
#line 225
  fd = io_write(tmp___8, tmp___7, (struct lsh_callback *)((void *)0));
  }
  {
#line 229
  (*((fd->write_buffer)->super.write))(& (fd->write_buffer)->super, pw);
  }
  {
#line 231
  tmp___9 = make_pwhelper_callback(user, c, e);
  }
  {
#line 231
  (*(((user->ctx)->reaper)->reap))((user->ctx)->reaper, child, tmp___9);
  }
  }
#line 233
  return (1);

#line 237
  return (0);
}
}
#line 258
static void do_verify_password(struct lsh_user *s , struct lsh_string *password ,
                               struct command_continuation *c , struct exception_handler *e ) ;
#line 258 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct exception  const  invalid_passwd  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "NUL character in password."};
#line 269 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct exception  const  no_passwd  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "No password in passwd db."};
#line 290 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct exception  const  invalid_passwd___0  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "Incorrect password."};
#line 242 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static void do_verify_password(struct lsh_user *s , struct lsh_string *password ,
                               struct command_continuation *c , struct exception_handler *e ) 
{ 
  struct unix_user *user ;
  struct exception  const  *x ;
  uint8_t const   *cpasswd ;
  char const   *tmp ;
  uint32_t tmp___0 ;
  char const   *salt ;
  uint8_t const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 248
  user = (struct unix_user *)s;
#line 249
  x = (struct exception  const  *)((void *)0);
  {
#line 255
  tmp = lsh_get_cstring((struct lsh_string  const  *)password);
  }
#line 255
  cpasswd = (uint8_t const   *)tmp;
  }
#line 256
  if (! cpasswd) {
    {
    {
#line 261
    (*(e->raise))(e, & invalid_passwd);
    }
    }
#line 262
    return;
  }
#line 267
  if (! user->passwd) {
#line 272
    x = & no_passwd;
#line 276
    goto try_helper;
  } else {
    {
    {
#line 267
    tmp___0 = lsh_string_length((struct lsh_string  const  *)user->passwd);
    }
    }
#line 267
    if (tmp___0 < 5U) {
#line 272
      x = & no_passwd;
#line 276
      goto try_helper;
    }
  }
  {
  {
#line 281
  tmp___1 = lsh_string_data((struct lsh_string  const  *)user->passwd);
  }
#line 281
  salt = (char const   *)tmp___1;
  {
#line 286
  tmp___2 = lsh_get_cstring((struct lsh_string  const  *)user->passwd);
  }
  {
#line 286
  tmp___3 = crypt((char const   *)cpasswd, salt);
  }
  {
#line 286
  tmp___4 = strcmp((char const   *)tmp___3, tmp___2);
  }
  }
#line 286
  if (tmp___4) {
#line 293
    x = & invalid_passwd___0;
#line 295
    goto try_helper;
  }
  {
  {
#line 298
  lsh_string_free((struct lsh_string  const  *)password);
  }
  {
#line 299
  (*(c->c))(c, (struct lsh_object *)user);
  }
  }
#line 300
  return;
  try_helper: 
#line 306
  if (! x) {
    {
    {
#line 306
    __assert_fail("x", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c", 306U,
                  "do_verify_password");
    }
    }
  }
#line 308
  if ((user->ctx)->pw_helper) {
    {
    {
#line 308
    tmp___5 = kerberos_check_pw(user, password, c, e);
    }
    }
#line 308
    if (! tmp___5) {
      {
      {
#line 315
      lsh_string_free((struct lsh_string  const  *)password);
      }
      {
#line 316
      (*(e->raise))(e, x);
      }
      }
    }
  } else {
    {
    {
#line 315
    lsh_string_free((struct lsh_string  const  *)password);
    }
    {
#line 316
    (*(e->raise))(e, x);
    }
    }
  }
#line 318
  return;
}
}
#line 322 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static int do_file_exists(struct lsh_user *u , struct lsh_string *name , int free___0 ) 
{ 
  struct unix_user *user ;
  struct lsh_string *path ;
  struct stat st ;
  char const   *s ;
  char const   *tmp ;
  int tmp___0 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 327
  user = (struct unix_user *)u;
#line 332
  if (! user->home) {
#line 334
    if (free___0) {
      {
      {
#line 335
      lsh_string_free((struct lsh_string  const  *)name);
      }
      }
    }
#line 336
    return (0);
  }
#line 339
  if (free___0) {
#line 339
    tmp = "%lS/%lfS";
  } else {
#line 339
    tmp = "%lS/%lS";
  }
  {
  {
#line 339
  path = ssh_format(tmp, user->home, name);
  }
  {
#line 341
  s = lsh_get_cstring((struct lsh_string  const  *)path);
  }
  }
#line 343
  if (s) {
    {
    {
#line 343
    tmp___0 = stat((char const   */* __restrict  */)s, (struct stat */* __restrict  */)(& st));
    }
    }
#line 343
    if (tmp___0 == 0) {
      {
      {
#line 345
      lsh_string_free((struct lsh_string  const  *)path);
      }
      }
#line 346
      return (1);
    }
  }
  {
  {
#line 348
  lsh_string_free((struct lsh_string  const  *)path);
  }
  }
#line 349
  return (0);
}
}
#line 352 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct exception  const  *check_user_permissions(struct stat *sbuf , char const   *fname ,
                                                        uid_t uid , int secret ) 
{ 
  mode_t bad ;
  int tmp ;
  struct exception *tmp___0 ;
  struct exception *tmp___1 ;
  struct exception *tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 356
  if (secret) {
#line 356
    tmp = (448 >> 3) | ((448 >> 3) >> 3);
  } else {
#line 356
    tmp = (128 >> 3) | ((128 >> 3) >> 3);
  }
#line 356
  bad = (mode_t )tmp;
#line 358
  if (! ((sbuf->st_mode & 61440U) == 32768U)) {
    {
    {
#line 360
    werror("io.c: %z is not a regular file.\n", fname);
    }
    {
#line 362
    tmp___0 = make_io_exception((uint32_t )8200, (struct lsh_fd *)((void *)0), 0,
                                "Not a regular file");
    }
    }
#line 362
    return ((struct exception  const  *)tmp___0);
  }
#line 364
  if (sbuf->st_uid != uid) {
    {
    {
#line 366
    werror("io.c: %z not owned by the right user (%i)\n", fname, uid);
    }
    {
#line 368
    tmp___1 = make_io_exception((uint32_t )8200, (struct lsh_fd *)((void *)0), 0,
                                "Bad owner");
    }
    }
#line 368
    return ((struct exception  const  *)tmp___1);
  }
#line 371
  if (sbuf->st_mode & bad) {
    {
    {
#line 373
    werror("io.c: Permissions on %z too loose.\n", fname);
    }
    {
#line 375
    tmp___2 = make_io_exception((uint32_t )8200, (struct lsh_fd *)((void *)0), 0,
                                "Bad permissions");
    }
    }
#line 375
    return ((struct exception  const  *)tmp___2);
  }
#line 378
  return ((struct exception  const  *)((void *)0));
}
}
#line 389 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static void do_exc_read_user_file_handler(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct exc_read_user_file_handler *self ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 393
  self = (struct exc_read_user_file_handler *)s;
  {
#line 395
  verbose("reading user file failed: %z\n", e->msg);
  }
  }
#line 399
  if (e->type == 8197U) {
#line 399
    goto case_8197;
  }
#line 402
  goto switch_default;
  case_8197: 
  {
  {
#line 400
  (*((self->c)->write))(self->c, (struct lsh_string *)((void *)0));
  }
  }
#line 401
  goto switch_break;
  switch_default: 
  {
  {
#line 403
  werror("reading user file failed: %z\n", e->msg);
  }
  {
#line 404
  (*((self->super.parent)->raise))(self->super.parent, e);
  }
  }
  switch_break: ;
#line 406
  return;
}
}
#line 408 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct exception_handler *make_exc_read_user_file_handler(struct abstract_write *c ,
                                                                 struct exception_handler *parent ,
                                                                 char const   *context ) 
{ 
  struct exc_read_user_file_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 413
  tmp = lsh_object_alloc(& exc_read_user_file_handler_class);
  }
#line 413
  self = (struct exc_read_user_file_handler *)tmp;
#line 415
  self->super.parent = parent;
#line 416
  self->super.raise = & do_exc_read_user_file_handler;
#line 417
  self->super.context = context;
#line 419
  self->c = c;
  }
#line 421
  return (& self->super);
}
}
#line 430 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct exception  const  *do_read_file(struct lsh_user *u , char const   *name ,
                                              int secret , uint32_t limit , struct abstract_write *c ) 
{ 
  struct unix_user *user ;
  struct lsh_string *f ;
  struct stat sbuf ;
  struct exception  const  *x ;
  pid_t child ;
  int out[2] ;
  uid_t me ;
  __uid_t tmp ;
  struct exception *tmp___0 ;
  struct exception *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  struct exception *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int *tmp___9 ;
  struct exception *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  struct exception *tmp___13 ;
  struct read_handler *tmp___14 ;
  struct io_callback *tmp___15 ;
  struct exception_handler *tmp___16 ;
  struct lsh_fd *tmp___17 ;
  int fd ;
  int *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int tmp___23 ;
  __uid_t tmp___24 ;
  char const   *tmp___25 ;
  int *tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  int tmp___29 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  void *__cil_tmp83 ;
  void *__cil_tmp84 ;
  void *__cil_tmp85 ;
  void *__cil_tmp86 ;
  void *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;

  {
  {
#line 436
  user = (struct unix_user *)u;
  {
#line 445
  tmp = geteuid();
  }
#line 445
  me = tmp;
  }
#line 450
  if (me) {
#line 450
    if (me != user->super.uid) {
      {
      {
#line 451
      tmp___0 = make_io_exception((uint32_t )8200, (struct lsh_fd *)((void *)0), 0,
                                  "Access denied.");
      }
      }
#line 451
      return ((struct exception  const  *)tmp___0);
    }
  }
#line 453
  if (! user->home) {
    {
    {
#line 454
    tmp___1 = make_io_exception((uint32_t )8200, (struct lsh_fd *)((void *)0), 2,
                                "No home directory");
    }
    }
#line 454
    return ((struct exception  const  *)tmp___1);
  }
  {
  {
#line 457
  f = ssh_format("%lS/.lsh/%lz", user->home, name);
  }
  {
#line 459
  tmp___6 = lsh_get_cstring((struct lsh_string  const  *)f);
  }
  {
#line 459
  tmp___7 = stat((char const   */* __restrict  */)tmp___6, (struct stat */* __restrict  */)(& sbuf));
  }
  }
#line 459
  if (tmp___7 < 0) {
    {
    {
#line 461
    tmp___3 = __errno_location();
    }
    }
#line 461
    if (*tmp___3 != 2) {
      {
      {
#line 462
      tmp___2 = __errno_location();
      }
      {
#line 462
      werror("io_read_user_file: Failed to stat %S %e\n", f, *tmp___2);
      }
      }
    }
    {
    {
#line 464
    lsh_string_free((struct lsh_string  const  *)f);
    }
    {
#line 466
    tmp___4 = __errno_location();
    }
    {
#line 466
    tmp___5 = make_io_exception((uint32_t )8200, (struct lsh_fd *)((void *)0), *tmp___4,
                                (char const   *)((void *)0));
    }
    }
#line 466
    return ((struct exception  const  *)tmp___5);
  }
  {
  {
#line 472
  tmp___8 = lsh_get_cstring((struct lsh_string  const  *)f);
  }
  {
#line 472
  x = check_user_permissions(& sbuf, tmp___8, user->super.uid, secret);
  }
  }
#line 473
  if (x) {
    {
    {
#line 475
    lsh_string_free((struct lsh_string  const  *)f);
    }
    }
#line 476
    return (x);
  }
  {
  {
#line 479
  tmp___11 = lsh_make_pipe(out);
  }
  }
#line 479
  if (! tmp___11) {
    {
    {
#line 481
    lsh_string_free((struct lsh_string  const  *)f);
    }
    {
#line 482
    tmp___9 = __errno_location();
    }
    {
#line 482
    tmp___10 = make_io_exception((uint32_t )8200, (struct lsh_fd *)((void *)0), *tmp___9,
                                 (char const   *)((void *)0));
    }
    }
#line 482
    return ((struct exception  const  *)tmp___10);
  }
  {
  {
#line 485
  child = fork();
  }
  }
#line 489
  if (child == -1) {
#line 489
    goto case_neg_1;
  }
#line 515
  if (child == 0) {
#line 515
    goto case_0;
  }
#line 496
  goto switch_default;
  case_neg_1: 
  {
  {
#line 492
  close(out[0]);
  }
  {
#line 492
  close(out[1]);
  }
  {
#line 493
  lsh_string_free((struct lsh_string  const  *)f);
  }
  {
#line 494
  tmp___12 = __errno_location();
  }
  {
#line 494
  tmp___13 = make_io_exception((uint32_t )8200, (struct lsh_fd *)((void *)0), *tmp___12,
                               (char const   *)((void *)0));
  }
  }
#line 494
  return ((struct exception  const  *)tmp___13);
  switch_default: 
  {
  {
#line 498
  close(out[1]);
  }
  {
#line 500
  lsh_string_free((struct lsh_string  const  *)f);
  }
  {
#line 504
  tmp___14 = make_read_file(c, limit);
  }
  {
#line 504
  tmp___15 = make_buffered_read((uint32_t )1000, tmp___14);
  }
  {
#line 504
  tmp___16 = make_exc_read_user_file_handler(c, & default_exception_handler, "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c:508");
  }
  {
#line 504
  tmp___17 = make_lsh_fd(out[0], (enum io_type )0, "stdout, reading a user file",
                         tmp___16);
  }
  {
#line 504
  io_read(tmp___17, tmp___15, (struct lsh_callback *)((void *)0));
  }
  }
#line 513
  return ((struct exception  const  *)((void *)0));
  case_0: 
  {
  {
#line 519
  close(out[0]);
  }
  }
#line 521
  if (me != user->super.uid) {
    {
    {
#line 526
    tmp___19 = setgid(user->gid);
    }
    }
#line 526
    if (tmp___19 < 0) {
      {
      {
#line 528
      tmp___18 = __errno_location();
      }
      {
#line 528
      werror("unix_user.c: do_read_file: setgid failed %e\n", *tmp___18);
      }
      {
#line 529
      _exit(1);
      }
      }
    }
    {
    {
#line 535
    tmp___21 = setgroups((size_t )0, (__gid_t const   *)((void *)0));
    }
    }
#line 535
    if (tmp___21 < 0) {
      {
      {
#line 537
      tmp___20 = __errno_location();
      }
      {
#line 537
      werror("unix_user.c: do_read_file: setgroups failed %e\n", *tmp___20);
      }
      {
#line 538
      _exit(1);
      }
      }
    }
    {
    {
#line 541
    tmp___23 = seteuid(user->super.uid);
    }
    }
#line 541
    if (tmp___23 < 0) {
      {
      {
#line 543
      tmp___22 = __errno_location();
      }
      {
#line 543
      werror("unix_user.c: do_read_file: seteuid failed %e\n", *tmp___22);
      }
      {
#line 544
      _exit(1);
      }
      }
    }
  }
  {
  {
#line 547
  tmp___24 = geteuid();
  }
  }
#line 547
  if (! (user->super.uid == tmp___24)) {
    {
    {
#line 547
    __assert_fail("user->super.uid == geteuid()", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c",
                  547U, "do_read_file");
    }
    }
  }
  {
  {
#line 549
  tmp___25 = lsh_get_cstring((struct lsh_string  const  *)f);
  }
  {
#line 549
  fd = open(tmp___25, 0);
  }
  {
#line 554
  tmp___27 = fstat(fd, & sbuf);
  }
  }
#line 554
  if (tmp___27 < 0) {
    {
    {
#line 556
    tmp___26 = __errno_location();
    }
    {
#line 556
    werror("unix_user.c: do_read_file: fstat failed %e\n", *tmp___26);
    }
    {
#line 557
    _exit(1);
    }
    }
  }
  {
  {
#line 560
  tmp___28 = lsh_get_cstring((struct lsh_string  const  *)f);
  }
  {
#line 560
  x = check_user_permissions(& sbuf, tmp___28, user->super.uid, secret);
  }
  }
#line 563
  if (x) {
    {
    {
#line 565
    werror("unix_user.c: do_read_file: %z\n", x->msg);
    }
    {
#line 566
    _exit(1);
    }
    }
  }
  {
  {
#line 569
  tmp___29 = lsh_copy_file(fd, out[1]);
  }
  }
#line 569
  if (tmp___29) {
    {
    {
#line 570
    _exit(0);
    }
    }
  } else {
    {
    {
#line 572
    _exit(1);
    }
    }
  }

#line 578
  return ((struct exception  const  *)0);
}
}
#line 579 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static char const   *format_env_pair(char const   *name , struct lsh_string *value ) 
{ 
  char const   *tmp ;
  struct lsh_string *tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 582
  tmp = lsh_get_cstring((struct lsh_string  const  *)value);
  }
  }
#line 582
  if (! tmp) {
    {
    {
#line 582
    __assert_fail("lsh_get_cstring(value)", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c",
                  582U, "format_env_pair");
    }
    }
  }
  {
  {
#line 583
  tmp___0 = ssh_format("%lz=%lS", name, value);
  }
  {
#line 583
  tmp___1 = lsh_get_cstring((struct lsh_string  const  *)tmp___0);
  }
  }
#line 583
  return (tmp___1);
}
}
#line 586 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static char const   *format_env_pair_c(char const   *name , char const   *value ) 
{ 
  struct lsh_string *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 589
  tmp = ssh_format("%lz=%lz", name, value);
  }
  {
#line 589
  tmp___0 = lsh_get_cstring((struct lsh_string  const  *)tmp);
  }
  }
#line 589
  return (tmp___0);
}
}
#line 592 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static void exec_shell(struct spawn_info *info , char const   *shell , char const   *home ,
                       char const   *name , uid_t uid , gid_t gid ) 
{ 
  char const   **envp ;
  char const   **argv ;
  char const   *program ;
  char const   *argv0 ;
  char *tz ;
  char *tmp ;
  unsigned int i ;
  unsigned int j ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  char const   *p ;
  char *s ;
  size_t length ;
  size_t tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  struct lsh_string *tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  struct lsh_string *tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  void *tmp___24 ;
  __uid_t tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  int *tmp___29 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;

  {
  {
  {
#line 605
  tmp = getenv("TZ");
  }
#line 605
  tz = tmp;
  {
#line 608
  trace("unix_user: exec_shell\n");
  }
  }
#line 609
  if (! shell) {
    {
    {
#line 609
    __assert_fail("shell", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c",
                  609U, "exec_shell");
    }
    }
  }
  {
  {
#line 612
  debug("exec_shell: Setting up environment.\n");
  }
  {
#line 622
  tmp___0 = __builtin_alloca(sizeof(char *) * (unsigned long )((info->env_length + 6U) + 1U));
  }
#line 622
  envp = (char const   **)tmp___0;
#line 624
  i = 0U;
#line 625
  tmp___1 = i;
#line 625
  i ++;
  {
#line 625
  *(envp + tmp___1) = format_env_pair_c("SHELL", shell);
  }
  }
#line 627
  if (home) {
    {
#line 628
    tmp___2 = i;
#line 628
    i ++;
    {
#line 628
    *(envp + tmp___2) = format_env_pair_c("HOME", home);
    }
    }
  }
  {
#line 631
  tmp___3 = i;
#line 631
  i ++;
#line 631
  *(envp + tmp___3) = "PATH=/bin:/usr/bin";
#line 632
  tmp___4 = i;
#line 632
  i ++;
  {
#line 632
  *(envp + tmp___4) = format_env_pair_c("USER", name);
  }
#line 633
  tmp___5 = i;
#line 633
  i ++;
  {
#line 633
  *(envp + tmp___5) = format_env_pair_c("LOGNAME", name);
  }
  }
#line 635
  if (tz) {
    {
#line 636
    tmp___6 = i;
#line 636
    i ++;
    {
#line 636
    *(envp + tmp___6) = format_env_pair_c("TZ", (char const   *)tz);
    }
    }
  }
#line 638
  if (! (i <= 6U)) {
    {
    {
#line 638
    __assert_fail("i <= 6", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c",
                  638U, "exec_shell");
    }
    }
  }
#line 641
  j = 0U;
  {
  {
#line 641
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 641
    if (! (j < info->env_length)) {
#line 641
      goto while_break;
    }
    {
#line 642
    tmp___7 = i;
#line 642
    i ++;
    {
#line 642
    *(envp + tmp___7) = format_env_pair((char const   *)(info->env + j)->name, (struct lsh_string *)(info->env + j)->value);
    }
#line 641
    j ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 644
  *(envp + i) = (char const   *)((void *)0);
  {
#line 646
  debug("exec_shell: Environment:\n");
  }
#line 647
  i = 0U;
  }
  {
  {
#line 647
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 647
    if (! *(envp + i)) {
#line 647
      goto while_break___0;
    }
    {
    {
#line 648
    debug("    \'%z\'\n", *(envp + i));
    }
#line 647
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: ;
#line 651
  if (info->login) {
    {
    {
#line 656
    tmp___8 = strlen(shell);
    }
#line 656
    length = tmp___8;
    }
#line 659
    if (length > 1000U) {
      {
      {
#line 661
      werror("exec_shell: shell name far too long.\n");
      }
      {
#line 662
      _exit(1);
      }
      }
    }
    {
    {
#line 665
    debug("do_exec_shell: fixing up name of shell...\n");
    }
    {
#line 667
    tmp___9 = __builtin_alloca((unsigned long )(length + 2U));
    }
#line 667
    s = (char *)tmp___9;
    {
#line 670
    tmp___10 = strrchr(shell, '/');
    }
#line 670
    p = (char const   *)tmp___10;
    }
#line 671
    if (! p) {
#line 672
      p = shell;
    } else {
#line 674
      p ++;
    }
    {
#line 676
    *(s + 0) = (char )'-';
    {
#line 677
    strncpy((char */* __restrict  */)(s + 1), (char const   */* __restrict  */)p,
            length + 1U);
    }
#line 678
    argv0 = (char const   *)s;
    }
  } else {
#line 682
    argv0 = shell;
  }
  {
  {
#line 684
  debug("exec_shell: argv0 = \'%z\'.\n", argv0);
  }
#line 686
  i = 0U;
  {
#line 689
  tmp___25 = getuid();
  }
  }
#line 689
  if (uid != tmp___25) {
    {
#line 698
    program = "/usr/local/sbin/lsh-execuv";
    {
#line 700
    tmp___11 = __builtin_alloca(sizeof(char *) * (unsigned long )((10U + info->argc) + 2U));
    }
#line 700
    argv = (char const   **)tmp___11;
#line 701
    tmp___12 = i;
#line 701
    i ++;
#line 701
    *(argv + tmp___12) = "lsh-execuv";
#line 702
    tmp___13 = i;
#line 702
    i ++;
#line 702
    *(argv + tmp___13) = "-u";
    {
#line 703
    trace("exec_shell: After -u\n");
    }
#line 704
    tmp___14 = i;
#line 704
    i ++;
    {
#line 704
    tmp___15 = ssh_format("%di", uid);
    }
    {
#line 704
    *(argv + tmp___14) = lsh_get_cstring((struct lsh_string  const  *)tmp___15);
    }
#line 705
    tmp___16 = i;
#line 705
    i ++;
#line 705
    *(argv + tmp___16) = "-g";
    {
#line 706
    trace("exec_shell: After -g\n");
    }
#line 707
    tmp___17 = i;
#line 707
    i ++;
    {
#line 707
    tmp___18 = ssh_format("%di", gid);
    }
    {
#line 707
    *(argv + tmp___17) = lsh_get_cstring((struct lsh_string  const  *)tmp___18);
    }
#line 708
    tmp___19 = i;
#line 708
    i ++;
#line 708
    *(argv + tmp___19) = "-n";
#line 709
    tmp___20 = i;
#line 709
    i ++;
#line 709
    *(argv + tmp___20) = name;
#line 710
    tmp___21 = i;
#line 710
    i ++;
#line 710
    *(argv + tmp___21) = "-i";
    {
#line 711
    trace("exec_shell: After -i\n");
    }
#line 712
    tmp___22 = i;
#line 712
    i ++;
#line 712
    *(argv + tmp___22) = "--";
#line 713
    tmp___23 = i;
#line 713
    i ++;
#line 713
    *(argv + tmp___23) = shell;
    }
#line 714
    if (! (i <= 10U)) {
      {
      {
#line 714
      __assert_fail("i <= 10", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c",
                    714U, "exec_shell");
      }
      }
    }
  } else {
    {
#line 720
    program = shell;
    {
#line 721
    tmp___24 = __builtin_alloca(sizeof(char *) * (unsigned long )(info->argc + 2U));
    }
#line 721
    argv = (char const   **)tmp___24;
    }
  }
#line 723
  tmp___26 = i;
#line 723
  i ++;
#line 723
  *(argv + tmp___26) = argv0;
#line 725
  j = 0U;
  {
  {
#line 725
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;

#line 725
    if (! (j < info->argc)) {
#line 725
      goto while_break___1;
    }
#line 726
    tmp___27 = i;
#line 726
    i ++;
#line 726
    *(argv + tmp___27) = *(info->argv + j);
#line 725
    j ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 727
  tmp___28 = i;
#line 727
  i ++;
#line 727
  *(argv + tmp___28) = (char const   *)((void *)0);
  {
#line 729
  debug("exec_shell: Argument list:\n");
  }
#line 730
  i = 0U;
  }
  {
  {
#line 730
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;

#line 730
    if (! *(argv + i)) {
#line 730
      goto while_break___2;
    }
    {
    {
#line 731
    debug("    \'%z\'\n", *(argv + i));
    }
#line 730
    i ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: 
  {
  {
#line 736
  trace("exec_shell: before exec\n");
  }
  {
#line 738
  execve(program, (char * const  *)((char **)argv), (char * const  *)((char **)envp));
  }
  {
#line 740
  tmp___29 = __errno_location();
  }
  {
#line 740
  werror("unix_user: exec of `%z\' failed %e\n", program, *tmp___29);
  }
  {
#line 741
  _exit(1);
  }
  }
}
}
#line 744 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static void safe_close(int fd ) 
{ 
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 747
  if (fd != -1) {
    {
    {
#line 747
    tmp___0 = close(fd);
    }
    }
#line 747
    if (tmp___0 < 0) {
      {
      {
#line 748
      tmp = __errno_location();
      }
      {
#line 748
      werror("close failed %e\n", *tmp);
      }
      }
    }
  }
#line 749
  return;
}
}
#line 777 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static void spawn_error(struct spawn_info *info , int const   *sync___0 ) 
{ 


  {
  {
  {
#line 781
  safe_close((int )*(sync___0 + 0));
  }
  {
#line 781
  safe_close((int )*(sync___0 + 1));
  }
  {
#line 783
  safe_close(info->in[0]);
  }
  {
#line 783
  safe_close(info->in[1]);
  }
  {
#line 784
  safe_close(info->out[0]);
  }
  {
#line 784
  safe_close(info->out[1]);
  }
  {
#line 785
  safe_close(info->err[0]);
  }
  }
#line 788
  if (info->err[1] != info->out[1]) {
    {
    {
#line 789
    safe_close(info->err[1]);
    }
    }
  }
#line 790
  return;
}
}
#line 793 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct lsh_process *spawn_parent(struct lsh_user *user , struct spawn_info *info ,
                                        struct exit_callback *c , struct reaper *reaper ,
                                        pid_t child , int const   *sync___0 ) 
{ 
  struct lsh_process *process ;
  char dummy ;
  int res ;
  int *tmp ;
  struct lsh_string *tmp___0 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 806
  safe_close(info->in[0]);
  }
  {
#line 807
  safe_close(info->out[1]);
  }
  }
#line 811
  if (info->err[1] != info->out[1]) {
    {
    {
#line 812
    safe_close(info->err[1]);
    }
    }
  }
  {
  {
#line 814
  safe_close((int )*(sync___0 + 1));
  }
  }
  {
  {
#line 825
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 826
    res = read((int )*(sync___0 + 0), (void *)(& dummy), (size_t )1);
    }
    }
#line 825
    if (res < 0) {
      {
      {
#line 825
      tmp = __errno_location();
      }
      }
#line 825
      if (! (*tmp == 4)) {
#line 825
        goto while_break;
      }
    } else {
#line 825
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 829
  safe_close((int )*(sync___0 + 0));
  }
  {
#line 831
  trace("do_spawn: parent after sync\n");
  }
  }
#line 833
  if (info->pty) {
#line 833
    tmp___0 = (info->pty)->tty_name;
  } else {
#line 833
    tmp___0 = (struct lsh_string *)((void *)0);
  }
  {
  {
#line 833
  process = unix_process_setup(child, user, & c, info->peer, tmp___0);
  }
  {
#line 837
  trace("do_spawn: parent after process setup\n");
  }
  {
#line 839
  (*(reaper->reap))(reaper, child, c);
  }
  }
#line 840
  return (process);
}
}
#line 843 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static void spawn_child(struct spawn_info *info , char const   *home , int const   *sync___0 ) 
{ 
  int tty ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  __pid_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
#line 848
  tty = -1;
#line 850
  if (! home) {
#line 851
    goto cd_root;
  }
  {
  {
#line 853
  tmp___2 = chdir(home);
  }
  }
#line 853
  if (tmp___2 < 0) {
    {
    {
#line 855
    tmp = __errno_location();
    }
    {
#line 855
    werror("chdir to home directory `%z\' failed %e\n", home, *tmp);
    }
    }
    cd_root: 
    {
    {
#line 858
    tmp___1 = chdir("/");
    }
    }
#line 858
    if (tmp___1 < 0) {
      {
      {
#line 860
      tmp___0 = __errno_location();
      }
      {
#line 860
      werror("chdir to `/\' failed %e\n", *tmp___0);
      }
      {
#line 861
      _exit(1);
      }
      }
    }
  }
  {
  {
#line 865
  trace("spawn_child: child after chdir\n");
  }
  {
#line 868
  tmp___4 = setsid();
  }
  }
#line 868
  if (tmp___4 < 0) {
    {
    {
#line 870
    tmp___3 = __errno_location();
    }
    {
#line 870
    werror("unix_user: setsid failed, already process group leader?\n   %e\n", *tmp___3);
    }
    {
#line 872
    _exit(1);
    }
    }
  }
#line 876
  if (info->pty) {
    {
    {
#line 878
    debug("lshd: unix_user.c: Opening slave tty...\n");
    }
    {
#line 879
    tty = pty_open_slave(info->pty);
    }
    }
#line 879
    if (tty < 0) {
      {
      {
#line 881
      debug("lshd: unix_user.c: Opening slave tty... Failed!\n");
      }
      {
#line 883
      werror("lshd: Can\'t open controlling tty for child!\n");
      }
      {
#line 884
      _exit(1);
      }
      }
    } else {
      {
      {
#line 887
      debug("lshd: unix_user.c: Opening slave tty... Ok.\n");
      }
      }
    }
  }
  {
  {
#line 891
  trace("spawn_child: after pty\n");
  }
  {
#line 896
  safe_close((int )*(sync___0 + 0));
  }
  {
#line 896
  safe_close((int )*(sync___0 + 1));
  }
  }
#line 900
  if (info->in[0] >= 0) {
#line 900
    tmp___5 = info->in[0];
  } else {
#line 900
    tmp___5 = tty;
  }
  {
  {
#line 900
  tmp___6 = dup2(tmp___5, 0);
  }
  }
#line 900
  if (tmp___6 < 0) {
    {
    {
#line 902
    werror("Can\'t dup stdin!\n");
    }
    {
#line 903
    _exit(1);
    }
    }
  }
#line 906
  if (info->out[1] >= 0) {
#line 906
    tmp___7 = info->out[1];
  } else {
#line 906
    tmp___7 = tty;
  }
  {
  {
#line 906
  tmp___8 = dup2(tmp___7, 1);
  }
  }
#line 906
  if (tmp___8 < 0) {
    {
    {
#line 908
    werror("Can\'t dup stdout!\n");
    }
    {
#line 909
    _exit(1);
    }
    }
  }
  {
  {
#line 912
  trace("spawn_child: child before stderr dup\n");
  }
  {
#line 913
  tmp___9 = dup_error_stream();
  }
  }
#line 913
  if (! tmp___9) {
    {
    {
#line 915
    werror("unix_user.c: Failed to dup old stderr. Bye.\n");
    }
    {
#line 916
    set_error_ignore();
    }
    }
  }
#line 919
  if (info->err[1] >= 0) {
#line 919
    tmp___10 = info->err[1];
  } else {
#line 919
    tmp___10 = tty;
  }
  {
  {
#line 919
  tmp___11 = dup2(tmp___10, 2);
  }
  }
#line 919
  if (tmp___11 < 0) {
    {
    {
#line 921
    werror("Can\'t dup stderr!\n");
    }
    {
#line 922
    _exit(1);
    }
    }
  }
  {
  {
#line 926
  trace("spawn_child: after stderr dup\n");
  }
  {
#line 929
  safe_close(info->in[0]);
  }
  {
#line 930
  safe_close(info->in[1]);
  }
  {
#line 931
  safe_close(info->out[0]);
  }
  {
#line 932
  safe_close(info->out[1]);
  }
  {
#line 933
  safe_close(info->err[0]);
  }
  }
#line 936
  if (info->err[1] != info->out[1]) {
    {
    {
#line 937
    safe_close(info->err[1]);
    }
    }
  }
  {
  {
#line 939
  safe_close(tty);
  }
  }
#line 940
  return;
}
}
#line 942 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct lsh_process *do_spawn(struct lsh_user *u , struct spawn_info *info ,
                                    struct exit_callback *c ) 
{ 
  struct unix_user *user ;
  int sync___0[2] ;
  pid_t child ;
  int tmp ;
  int *tmp___0 ;
  struct lsh_process *tmp___1 ;
  char const   *home ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 947
  user = (struct unix_user *)u;
  {
#line 952
  tmp = lsh_make_pipe(sync___0);
  }
  }
#line 952
  if (! tmp) {
    {
    {
#line 954
    werror("do_spawn: Failed to create syncronization pipe.\n");
    }
    }
#line 955
    return ((struct lsh_process *)((void *)0));
  }
  {
  {
#line 958
  child = fork();
  }
  }
#line 959
  if (child < 0) {
    {
    {
#line 961
    tmp___0 = __errno_location();
    }
    {
#line 961
    werror("unix_user: do_spawn: fork failed %e\n", *tmp___0);
    }
    {
#line 962
    spawn_error(info, (int const   *)(sync___0));
    }
    }
#line 964
    return ((struct lsh_process *)((void *)0));
  } else
#line 966
  if (child) {
    {
    {
#line 969
    trace("do_spawn: parent process\n");
    }
    {
#line 971
    tmp___1 = spawn_parent(u, info, c, (user->ctx)->reaper, child, (int const   *)(sync___0));
    }
    }
#line 971
    return (tmp___1);
  } else {
    {
    {
#line 979
    trace("do_spawn: child process\n");
    }
    }
#line 980
    if (user->home) {
      {
      {
#line 982
      home = lsh_get_cstring((struct lsh_string  const  *)user->home);
      }
      }
#line 983
      if (! home) {
        {
        {
#line 983
        __assert_fail("home", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c",
                      983U, "do_spawn");
        }
        }
      }
    } else {
#line 986
      home = "/";
    }
    {
    {
#line 988
    spawn_child(info, home, (int const   *)(sync___0));
    }
    {
#line 990
    tmp___2 = lsh_get_cstring((struct lsh_string  const  *)user->super.name);
    }
    {
#line 990
    tmp___3 = lsh_get_cstring((struct lsh_string  const  *)user->shell);
    }
    {
#line 990
    exec_shell(info, tmp___3, home, tmp___2, user->super.uid, user->gid);
    }
    {
#line 992
    _exit(1);
    }
    }
  }
}
}
#line 996 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct lsh_user *make_unix_user(struct lsh_string *name , uid_t uid , gid_t gid ,
                                       struct unix_user_db *ctx , char const   *passwd ,
                                       char const   *home , char const   *shell ) 
{ 
  struct unix_user *user ;
  struct lsh_object *tmp ;
  char const   *tmp___0 ;
  struct lsh_string *tmp___1 ;
  struct lsh_string *tmp___2 ;
  struct lsh_string *tmp___3 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
  {
#line 1004
  tmp = lsh_object_alloc(& unix_user_class);
  }
#line 1004
  user = (struct unix_user *)tmp;
  {
#line 1006
  tmp___0 = lsh_get_cstring((struct lsh_string  const  *)name);
  }
  }
#line 1006
  if (! tmp___0) {
    {
    {
#line 1006
    __assert_fail("lsh_get_cstring(name)", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c",
                  1006U, "make_unix_user");
    }
    }
  }
#line 1008
  user->super.name = name;
#line 1009
  user->super.verify_password = & do_verify_password;
#line 1010
  user->super.file_exists = & do_file_exists;
#line 1011
  user->super.read_file = & do_read_file;
#line 1012
  user->super.spawn = & do_spawn;
#line 1014
  user->super.uid = uid;
#line 1015
  user->gid = gid;
#line 1017
  user->ctx = ctx;
#line 1022
  if (passwd) {
#line 1022
    if (*passwd) {
      {
      {
#line 1022
      tmp___1 = ssh_format("%lz", passwd);
      }
#line 1022
      user->passwd = tmp___1;
      }
    } else {
#line 1022
      user->passwd = (struct lsh_string *)((void *)0);
    }
  } else {
#line 1022
    user->passwd = (struct lsh_string *)((void *)0);
  }
#line 1023
  if (home) {
#line 1023
    if (*home) {
      {
      {
#line 1023
      tmp___2 = ssh_format("%lz", home);
      }
#line 1023
      user->home = tmp___2;
      }
    } else {
#line 1023
      user->home = (struct lsh_string *)((void *)0);
    }
  } else {
#line 1023
    user->home = (struct lsh_string *)((void *)0);
  }
#line 1024
  if (shell) {
#line 1024
    if (*shell) {
      {
      {
#line 1024
      tmp___3 = ssh_format("%lz", shell);
      }
#line 1024
      user->shell = tmp___3;
      }
    } else {
#line 1024
      user->shell = (struct lsh_string *)((void *)0);
    }
  } else {
#line 1024
    user->shell = (struct lsh_string *)((void *)0);
  }
#line 1027
  return (& user->super);
}
}
#line 1083 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct lsh_user *do_lookup_user(struct user_db *s , struct lsh_string *name ,
                                       int free___0 ) 
{ 
  struct unix_user_db *self ;
  struct passwd *passwd ;
  char const   *home ;
  char const   *shell ;
  char const   *cname ;
  char const   *tmp ;
  char *crypted ;
  uid_t me ;
  char *tmp___0 ;
  struct spwd *shadowpwd ;
  long now ;
  time_t tmp___1 ;
  int tmp___2 ;
  struct lsh_string *tmp___3 ;
  struct lsh_string *tmp___4 ;
  struct lsh_user *tmp___5 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 1087
  self = (struct unix_user_db *)s;
  {
#line 1092
  tmp = lsh_get_cstring((struct lsh_string  const  *)name);
  }
#line 1092
  cname = tmp;
  }
#line 1096
  if (! cname) {
#line 1098
    if (free___0) {
      {
      {
#line 1099
      lsh_string_free((struct lsh_string  const  *)name);
      }
      }
    }
#line 1100
    return ((struct lsh_user *)((void *)0));
  }
  {
  {
#line 1103
  me = getuid();
  }
  {
#line 1104
  passwd = getpwnam(cname);
  }
  }
#line 1106
  if (! passwd) {
    fail: 
#line 1109
    if (free___0) {
      {
      {
#line 1110
      lsh_string_free((struct lsh_string  const  *)name);
      }
      }
    }
#line 1111
    return ((struct lsh_user *)((void *)0));
  }
#line 1114
  crypted = passwd->pw_passwd;
#line 1116
  if (! crypted) {
#line 1118
    goto fail;
  } else
#line 1116
  if (! *crypted) {
#line 1118
    goto fail;
  }
#line 1120
  if (me) {
#line 1123
    if (passwd->pw_uid != me) {
#line 1124
      goto fail;
    }
    {
    {
#line 1129
    tmp___0 = getenv("HOME");
    }
#line 1129
    home = (char const   *)tmp___0;
    }
#line 1130
    if (! home) {
#line 1131
      home = (char const   *)passwd->pw_dir;
    }
  } else {
#line 1136
    if (! passwd->pw_uid) {
#line 1136
      if (! self->allow_root) {
#line 1137
        goto fail;
      }
    }
    {
    {
#line 1148
    tmp___2 = strcmp((char const   *)crypted, "x");
    }
    }
#line 1148
    if (tmp___2 == 0) {
      {
      {
#line 1148
      shadowpwd = getspnam(cname);
      }
      }
#line 1148
      if (shadowpwd) {
        {
        {
#line 1154
        tmp___1 = time((time_t *)((void *)0));
        }
#line 1154
        now = tmp___1 / 86400L;
        {
#line 1156
        shadowpwd = getspnam(cname);
        }
        }
#line 1156
        if (! shadowpwd) {
#line 1157
          goto fail;
        }
#line 1161
        if (shadowpwd->sp_expire >= 0L) {
#line 1161
          if (now > shadowpwd->sp_expire) {
            {
            {
#line 1164
            werror("Access denied for user \'%pS\', account expired.\n", name);
            }
            }
#line 1165
            goto fail;
          }
        }
#line 1178
        if (shadowpwd->sp_inact >= 0L) {
#line 1178
          if (now > shadowpwd->sp_lstchg + shadowpwd->sp_max) {
            {
            {
#line 1181
            werror("Access denied for user \'%pS\', password too old.\n", name);
            }
            }
#line 1182
            goto fail;
          }
        }
#line 1196
        crypted = shadowpwd->sp_pwdp;
      }
    }
#line 1202
    if (! crypted) {
#line 1203
      goto fail;
    } else
#line 1202
    if (! *crypted) {
#line 1203
      goto fail;
    }
#line 1207
    if ((int )*(crypted + 0) == 42) {
#line 1207
      if (*(crypted + 1)) {
#line 1208
        goto fail;
      }
    }
#line 1210
    home = (char const   *)passwd->pw_dir;
  }
#line 1213
  if (self->login_shell) {
#line 1215
    shell = self->login_shell;
  } else
#line 1218
  if (passwd->pw_shell) {
#line 1218
    shell = (char const   *)passwd->pw_shell;
  } else {
#line 1218
    shell = "/bin/sh";
  }
#line 1220
  if (free___0) {
#line 1220
    tmp___4 = name;
  } else {
    {
    {
#line 1220
    tmp___3 = ssh_format("%lS", name);
    }
#line 1220
    tmp___4 = tmp___3;
    }
  }
  {
  {
#line 1220
  tmp___5 = make_unix_user(tmp___4, passwd->pw_uid, passwd->pw_gid, self, (char const   *)crypted,
                           home, shell);
  }
  }
#line 1220
  return (tmp___5);
}
}
#line 1227 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
struct user_db *make_unix_user_db(struct reaper *reaper , char const   *pw_helper ,
                                  char const   *login_shell , int allow_root ) 
{ 
  struct unix_user_db *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 1232
  tmp = lsh_object_alloc(& unix_user_db_class);
  }
#line 1232
  self = (struct unix_user_db *)tmp;
#line 1234
  self->super.lookup = & do_lookup_user;
#line 1235
  self->reaper = reaper;
#line 1236
  self->pw_helper = pw_helper;
#line 1237
  self->login_shell = login_shell;
#line 1238
  self->allow_root = allow_root;
  }
#line 1240
  return (& self->super);
}
}
#line 1265
static void do_verify_password_fail(struct lsh_user *s  __attribute__((__unused__)) ,
                                    struct lsh_string *password  __attribute__((__unused__)) ,
                                    struct command_continuation *c  __attribute__((__unused__)) ,
                                    struct exception_handler *e ) ;
#line 1265 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct exception  const  invalid_passwd___1  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "Incorrect password."};
#line 1259 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static void do_verify_password_fail(struct lsh_user *s  __attribute__((__unused__)) ,
                                    struct lsh_string *password  __attribute__((__unused__)) ,
                                    struct command_continuation *c  __attribute__((__unused__)) ,
                                    struct exception_handler *e ) 
{ 


  {
  {
  {
#line 1268
  (*(e->raise))(e, & invalid_passwd___1);
  }
  }
#line 1269
  return;
}
}
#line 1271 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static int do_file_exists_fail(struct lsh_user *u  __attribute__((__unused__)) , struct lsh_string *name ,
                               int free___0 ) 
{ 


  {
#line 1276
  if (free___0) {
    {
    {
#line 1277
    lsh_string_free((struct lsh_string  const  *)name);
    }
    }
  }
#line 1279
  return (0);
}
}
#line 1282 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct exception  const  *do_read_file_fail(struct lsh_user *u  __attribute__((__unused__)) ,
                                                   char const   *name  __attribute__((__unused__)) ,
                                                   int secret  __attribute__((__unused__)) ,
                                                   uint32_t limit  __attribute__((__unused__)) ,
                                                   struct abstract_write *c  __attribute__((__unused__)) ) 
{ 
  struct exception *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 1288
  tmp = make_io_exception((uint32_t )8200, (struct lsh_fd *)((void *)0), 0, "Access denied.");
  }
  }
#line 1288
  return ((struct exception  const  *)tmp);
}
}
#line 1291 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
static struct lsh_process *do_spawn_self(struct lsh_user *u , struct spawn_info *info ,
                                         struct exit_callback *c ) 
{ 
  struct unix_user_self *self ;
  int sync___0[2] ;
  pid_t child ;
  int tmp ;
  int *tmp___0 ;
  struct lsh_process *tmp___1 ;
  __uid_t tmp___2 ;
  char const   *tmp___3 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 1296
  self = (struct unix_user_self *)u;
  {
#line 1301
  tmp = lsh_make_pipe(sync___0);
  }
  }
#line 1301
  if (! tmp) {
    {
    {
#line 1303
    werror("do_spawn: Failed to create syncronization pipe.\n");
    }
    }
#line 1304
    return ((struct lsh_process *)((void *)0));
  }
  {
  {
#line 1307
  child = fork();
  }
  }
#line 1308
  if (child < 0) {
    {
    {
#line 1310
    tmp___0 = __errno_location();
    }
    {
#line 1310
    werror("unix_user: do_spawn_self: fork failed %e\n", *tmp___0);
    }
    {
#line 1311
    spawn_error(info, (int const   *)(sync___0));
    }
    }
#line 1313
    return ((struct lsh_process *)((void *)0));
  } else
#line 1315
  if (child) {
    {
    {
#line 1318
    trace("do_spawn_self: parent process\n");
    }
    {
#line 1320
    tmp___1 = spawn_parent(u, info, c, self->reaper, child, (int const   *)(sync___0));
    }
    }
#line 1320
    return (tmp___1);
  } else {
    {
    {
#line 1326
    trace("do_spawn_self: child process\n");
    }
    {
#line 1327
    spawn_child(info, self->home, (int const   *)(sync___0));
    }
    {
#line 1329
    tmp___2 = getuid();
    }
    {
#line 1329
    tmp___3 = lsh_get_cstring((struct lsh_string  const  *)self->super.name);
    }
    {
#line 1329
    exec_shell(info, self->shell, self->home, tmp___3, tmp___2, (gid_t )-1);
    }
    {
#line 1331
    _exit(1);
    }
    }
  }
}
}
#line 1335 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_user.c"
struct lsh_user *make_unix_user_self(struct lsh_string *name , struct reaper *reaper ,
                                     char const   *home , char const   *shell ) 
{ 
  struct unix_user_self *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 1340
  tmp = lsh_object_alloc(& unix_user_self_class);
  }
#line 1340
  self = (struct unix_user_self *)tmp;
#line 1341
  self->super.name = name;
  {
#line 1342
  self->super.uid = getuid();
  }
#line 1343
  self->super.verify_password = & do_verify_password_fail;
#line 1344
  self->super.file_exists = & do_file_exists_fail;
#line 1345
  self->super.read_file = & do_read_file_fail;
#line 1346
  self->super.spawn = & do_spawn_self;
#line 1348
  self->reaper = reaper;
#line 1349
  self->shell = shell;
#line 1350
  self->home = home;
  }
#line 1352
  return (& self->super);
}
}
#line 331 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 623
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 88 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 12 "/home/ysko/Works/test-src/lsh-2.0.4/src/randomness.h.x"
struct lsh_class randomness_class ;
#line 71 "/home/ysko/Works/test-src/lsh-2.0.4/src/randomness.h"
struct randomness *random_init(struct lsh_string *seed_file_name ) ;
#line 79
struct randomness *make_user_random(char const   *home ) ;
#line 82
struct randomness *make_system_random(void) ;
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.h"
struct lsh_file_lock_info *make_lsh_file_lock_info(struct lsh_string *name ) ;
#line 284 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
struct exception  const  *read_raw(int fd , uint32_t length , uint8_t *data ) ;
#line 287
struct lsh_string *io_read_file_raw(int fd , uint32_t guess ) ;
#line 17 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c.x"
struct lsh_class unix_random_class ;
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c.x"
static void do_unix_random_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct unix_random *i ;

  {
  {
#line 25
  i = (struct unix_random *)o;
  {
#line 26
  (*mark)((struct lsh_object *)i->lock);
  }
  }
#line 27
  return;
}
}
#line 28 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c.x"
struct lsh_class unix_random_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & randomness_class, (char *)"unix_random", (size_t )sizeof(struct unix_random ),
    & do_unix_random_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c"
static struct unix_random *the_random  =    (struct unix_random *)((void *)0);
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c"
static int write_seed_file(struct yarrow256_ctx *ctx , int fd ) 
{ 
  struct exception  const  *e ;
  int *tmp ;
  __off_t tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 85
  tmp___0 = lseek(fd, (__off_t )0, 0);
  }
  }
#line 85
  if (tmp___0 < 0L) {
    {
    {
#line 87
    tmp = __errno_location();
    }
    {
#line 87
    werror("Seeking to beginning of seed file failed!? %e\n", *tmp);
    }
    }
#line 88
    return (0);
  }
  {
  {
#line 91
  e = write_raw(fd, (uint32_t )32, (uint8_t const   *)(ctx->seed_file));
  }
  }
#line 93
  if (e) {
    {
    {
#line 95
    werror("Overwriting seed file failed: %z\n", e->msg);
    }
    }
#line 97
    return (0);
  }
#line 100
  return (1);
}
}
#line 103 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c"
static struct lsh_string *read_seed_file(int fd ) 
{ 
  struct lsh_string *seed ;
  int *tmp ;
  __off_t tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 108
  tmp___0 = lseek(fd, (__off_t )0, 0);
  }
  }
#line 108
  if (tmp___0 < 0L) {
    {
    {
#line 110
    tmp = __errno_location();
    }
    {
#line 110
    werror("Seeking to beginning of seed file failed!? %e\n", *tmp);
    }
    }
#line 111
    return ((struct lsh_string *)((void *)0));
  }
  {
  {
#line 114
  seed = io_read_file_raw(fd, (uint32_t )33);
  }
  }
#line 115
  if (! seed) {
    {
    {
#line 116
    tmp___1 = __errno_location();
    }
    {
#line 116
    werror("Couldn\'t read seed file %e\n", *tmp___1);
    }
    }
  }
#line 117
  return (seed);
}
}
#line 120 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c"
static int read_initial_seed_file(struct yarrow256_ctx *ctx , int fd ) 
{ 
  struct lsh_string *seed ;
  struct stat sbuf ;
  int *tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  uint32_t tmp___2 ;
  uint8_t const   *tmp___3 ;
  uint32_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  __off_t tmp___7 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
  {
#line 127
  tmp___0 = fstat(fd, & sbuf);
  }
  }
#line 127
  if (tmp___0 < 0) {
    {
    {
#line 129
    tmp = __errno_location();
    }
    {
#line 129
    werror("Couldn\'t stat seed file %e\n", *tmp);
    }
    }
#line 130
    return (0);
  }
  {
  {
#line 134
  tmp___1 = getuid();
  }
  }
#line 134
  if (sbuf.st_uid != tmp___1) {
    {
    {
#line 136
    werror("Seed file not owned by you!\n");
    }
    }
#line 137
    return (0);
  }
#line 140
  if (sbuf.st_mode & (unsigned int )((448 >> 3) | ((448 >> 3) >> 3))) {
    {
    {
#line 142
    werror("Too permissive permissions on seed-file.\n");
    }
    }
#line 143
    return (0);
  }
  {
  {
#line 146
  seed = read_seed_file(fd);
  }
  }
#line 147
  if (! seed) {
#line 148
    return (0);
  }
  {
  {
#line 150
  tmp___2 = lsh_string_length((struct lsh_string  const  *)seed);
  }
  }
#line 150
  if (tmp___2 < 32U) {
    {
    {
#line 152
    werror("Seed file too short\n");
    }
    {
#line 153
    lsh_string_free((struct lsh_string  const  *)seed);
    }
    }
#line 154
    return (0);
  }
  {
  {
#line 157
  tmp___3 = lsh_string_data((struct lsh_string  const  *)seed);
  }
  {
#line 157
  tmp___4 = lsh_string_length((struct lsh_string  const  *)seed);
  }
  {
#line 157
  nettle_yarrow256_seed(ctx, tmp___4, tmp___3);
  }
  {
#line 158
  lsh_string_free((struct lsh_string  const  *)seed);
  }
  {
#line 160
  tmp___5 = nettle_yarrow256_is_seeded(ctx);
  }
  }
#line 160
  if (! tmp___5) {
    {
    {
#line 160
    __assert_fail("nettle_yarrow256_is_seeded(ctx)", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c",
                  160U, "read_initial_seed_file");
    }
    }
  }
  {
  {
#line 162
  tmp___7 = lseek(fd, (__off_t )0, 0);
  }
  }
#line 162
  if (tmp___7 < 0L) {
    {
    {
#line 164
    tmp___6 = __errno_location();
    }
    {
#line 164
    werror("Seeking to beginning of seed file failed!? %e\n", *tmp___6);
    }
    }
#line 165
    return (0);
  }
#line 168
  return (1);
}
}
#line 171 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c"
static void update_seed_file(struct unix_random *self ) 
{ 
  struct resource *lock ;
  struct lsh_string *s ;
  struct lsh_string *tmp ;
  uint8_t const   *tmp___0 ;
  uint32_t tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 175
  verbose("Overwriting seed file.\n");
  }
  {
#line 177
  lock = (*((self->lock)->lock))(self->lock, 0U);
  }
  }
#line 178
  if (! lock) {
    {
    {
#line 180
    werror("Failed to lock seed file, so not overwriting it now.\n");
    }
    }
  } else {
    {
    {
#line 184
    tmp = read_seed_file(self->seed_file_fd);
    }
#line 184
    s = tmp;
    {
#line 186
    write_seed_file(& self->yarrow, self->seed_file_fd);
    }
    {
#line 187
    (*(lock->kill))(lock);
    }
    }
#line 191
    if (s) {
      {
      {
#line 193
      tmp___0 = lsh_string_data((struct lsh_string  const  *)s);
      }
      {
#line 193
      tmp___1 = lsh_string_length((struct lsh_string  const  *)s);
      }
      {
#line 193
      nettle_yarrow256_update(& self->yarrow, 4U, 0U, tmp___1, tmp___0);
      }
      {
#line 195
      lsh_string_free((struct lsh_string  const  *)s);
      }
      }
    }
  }
#line 198
  return;
}
}
#line 200 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c"
static int do_trivia_source(struct unix_random *self , int init ) 
{ 
  struct __anonstruct_event_68 event ;
  unsigned int entropy ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 212
  entropy = 0U;
  {
#line 214
  tmp___0 = gettimeofday((struct timeval */* __restrict  */)(& event.now), (__timezone_ptr_t )((void *)0));
  }
  }
#line 214
  if (tmp___0 < 0) {
    {
    {
#line 215
    tmp = __errno_location();
    }
    {
#line 215
    fatal("gettimeofday failed %e\n", *tmp);
    }
    }
  }
  {
  {
#line 217
  tmp___2 = getrusage((__rusage_who_t )0, & event.rusage);
  }
  }
#line 217
  if (tmp___2 < 0) {
    {
    {
#line 218
    tmp___1 = __errno_location();
    }
    {
#line 218
    fatal("getrusage failed %e\n", *tmp___1);
    }
    }
  }
#line 221
  event.count = 0U;
#line 222
  if (init) {
#line 224
    self->time_count = 0U;
  } else {
#line 228
    tmp___3 = self->time_count;
#line 228
    (self->time_count) ++;
#line 228
    event.count = tmp___3;
#line 230
    if (event.now.tv_sec != self->previous_time) {
#line 235
      if (self->time_count > 2U) {
#line 237
        entropy ++;
      } else
#line 235
      if (event.now.tv_sec - self->previous_time > 2L) {
#line 237
        entropy ++;
      }
#line 239
      self->time_count = 0U;
    }
  }
  {
#line 242
  self->previous_time = event.now.tv_sec;
  {
#line 243
  event.pid = getpid();
  }
  {
#line 245
  tmp___4 = nettle_yarrow256_update(& self->yarrow, 0U, entropy, (unsigned int )sizeof(event),
                                    (uint8_t const   *)(& event));
  }
  }
#line 245
  return (tmp___4);
}
}
#line 250 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c"
static int do_device_source(struct unix_random *self , int init ) 
{ 
  time_t now ;
  time_t tmp ;
  uint8_t buf[10] ;
  struct exception  const  *e ;
  struct exception  const  *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 253
  tmp = time((time_t *)((void *)0));
  }
#line 253
  now = tmp;
  }
#line 255
  if (init) {
    {
    {
#line 257
    self->device_fd = open("/dev/urandom", 0);
    }
    }
#line 258
    if (self->device_fd < 0) {
#line 259
      return (0);
    }
    {
    {
#line 261
    io_set_close_on_exec(self->device_fd);
    }
#line 262
    self->device_last_read = now;
    }
  }
#line 265
  if (self->device_fd > 0) {
#line 265
    if (init) {
#line 265
      goto _L;
    } else
#line 265
    if (now - self->device_last_read > 60L) {
      _L: 
      {
      {
#line 270
      tmp___0 = read_raw(self->device_fd, (uint32_t )sizeof(buf), buf);
      }
#line 270
      e = tmp___0;
      }
#line 273
      if (e) {
        {
        {
#line 275
        tmp___1 = __errno_location();
        }
        {
#line 275
        werror("Failed to read /dev/urandom %e\n", *tmp___1);
        }
        }
#line 276
        return (0);
      }
      {
#line 279
      self->device_last_read = now;
      {
#line 281
      tmp___2 = nettle_yarrow256_update(& self->yarrow, 2U, 10U, (unsigned int )sizeof(buf),
                                        (uint8_t const   *)(buf));
      }
      }
#line 281
      return (tmp___2);
    }
  }
#line 285
  return (0);
}
}
#line 290 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c"
static void do_unix_random(struct randomness *s , uint32_t length , uint8_t *dst ) 
{ 
  struct unix_random *self ;
  int trivia_reseed ;
  int tmp ;
  int device_reseed ;
  int tmp___0 ;

  {
  {
#line 295
  self = (struct unix_random *)s;
  {
#line 298
  tmp = do_trivia_source(self, 0);
  }
#line 298
  trivia_reseed = tmp;
  {
#line 299
  tmp___0 = do_device_source(self, 0);
  }
#line 299
  device_reseed = tmp___0;
  }
#line 301
  if (trivia_reseed) {
    {
    {
#line 302
    update_seed_file(self);
    }
    }
  } else
#line 301
  if (device_reseed) {
    {
    {
#line 302
    update_seed_file(self);
    }
    }
  }
  {
  {
#line 305
  nettle_yarrow256_random(& self->yarrow, length, dst);
  }
  }
#line 306
  return;
}
}
#line 308 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c"
static void do_unix_random_add(struct randomness *s , enum random_source_type type ,
                               uint32_t length , uint8_t const   *data ) 
{ 
  struct unix_random *self ;
  unsigned int entropy ;
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 314
  self = (struct unix_random *)s;
#line 320
  if ((unsigned int )type == 3U) {
#line 320
    goto case_3;
  }
#line 325
  if ((unsigned int )type == 1U) {
#line 325
    goto case_1;
  }
#line 330
  goto switch_default;
  case_3: 
#line 323
  entropy = length;
#line 324
  goto switch_break;
  case_1: 
#line 327
  entropy = (unsigned int )(length >= 2U);
#line 328
  goto switch_break;
  switch_default: 
  {
  {
#line 331
  fatal("Internal error\n");
  }
  }
  switch_break: 
  {
  {
#line 334
  tmp = nettle_yarrow256_update(& self->yarrow, (unsigned int )type, entropy, length,
                                data);
  }
  }
#line 334
  if (tmp) {
    {
    {
#line 337
    update_seed_file(self);
    }
    }
  }
#line 338
  return;
}
}
#line 340 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c"
struct randomness *random_init(struct lsh_string *seed_file_name ) 
{ 
  struct unix_random *self ;
  struct lsh_object *tmp ;
  struct resource *lock ;
  struct lsh_string *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
#line 343
  if (! (! the_random)) {
    {
    {
#line 343
    __assert_fail("!the_random", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c",
                  343U, "random_init");
    }
    }
  }
  {
  {
#line 345
  trace("random_init\n");
  }
  {
#line 347
  tmp = lsh_object_alloc(& unix_random_class);
  }
#line 347
  self = (struct unix_random *)tmp;
#line 350
  self->super.quality = (enum randomness_quality )0;
#line 351
  self->super.random = & do_unix_random;
#line 352
  self->super.add = & do_unix_random_add;
  {
#line 354
  nettle_yarrow256_init(& self->yarrow, 5U, self->sources);
  }
  {
#line 356
  verbose("Reading seed-file `%S\'\n", seed_file_name);
  }
  {
#line 358
  tmp___0 = ssh_format("%lS.lock", seed_file_name);
  }
  {
#line 358
  self->lock = make_lsh_file_lock_info(tmp___0);
  }
  {
#line 361
  trace("random_init, locking seed file...\n");
  }
  {
#line 363
  lock = (*((self->lock)->lock))(self->lock, 5U);
  }
  }
#line 365
  if (! lock) {
    {
    {
#line 367
    werror("Could not lock seed-file `%S\'\n", seed_file_name);
    }
    {
#line 368
    gc_kill((struct lsh_object *)self);
    }
    }
#line 369
    return ((struct randomness *)((void *)0));
  }
  {
  {
#line 372
  trace("random_init, seed file locked successfully.\n");
  }
  {
#line 374
  tmp___1 = lsh_get_cstring((struct lsh_string  const  *)seed_file_name);
  }
  {
#line 374
  self->seed_file_fd = open(tmp___1, 2);
  }
  }
#line 375
  if (self->seed_file_fd < 0) {
    {
    {
#line 377
    werror("No seed file. Please create one by running\n");
    }
    {
#line 378
    werror("lsh-make-seed -o \"%S\".\n", seed_file_name);
    }
    {
#line 380
    (*(lock->kill))(lock);
    }
    {
#line 381
    gc_kill((struct lsh_object *)self);
    }
    }
#line 382
    return ((struct randomness *)((void *)0));
  }
  {
  {
#line 385
  io_set_close_on_exec(self->seed_file_fd);
  }
  {
#line 386
  trace("random_init, reading seed file...\n");
  }
  {
#line 388
  tmp___2 = read_initial_seed_file(& self->yarrow, self->seed_file_fd);
  }
  }
#line 388
  if (! tmp___2) {
    {
    {
#line 390
    (*(lock->kill))(lock);
    }
    {
#line 391
    gc_kill((struct lsh_object *)self);
    }
    }
#line 392
    return ((struct randomness *)((void *)0));
  }
  {
  {
#line 395
  trace("random_init, seed file read successfully.\n");
  }
  {
#line 397
  tmp___3 = nettle_yarrow256_is_seeded(& self->yarrow);
  }
  }
#line 397
  if (! tmp___3) {
    {
    {
#line 397
    __assert_fail("nettle_yarrow256_is_seeded(&self->yarrow)", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c",
                  397U, "random_init");
    }
    }
  }
  {
  {
#line 400
  do_device_source(self, 1);
  }
  {
#line 401
  do_trivia_source(self, 1);
  }
  {
#line 404
  nettle_yarrow256_force_reseed(& self->yarrow);
  }
  {
#line 407
  tmp___4 = write_seed_file(& self->yarrow, self->seed_file_fd);
  }
  }
#line 407
  if (! tmp___4) {
    {
    {
#line 409
    (*(lock->kill))(lock);
    }
    {
#line 410
    gc_kill((struct lsh_object *)self);
    }
    }
#line 411
    return ((struct randomness *)((void *)0));
  }
  {
  {
#line 414
  trace("random_init: All done, releasing lock.\n");
  }
  {
#line 416
  (*(lock->kill))(lock);
  }
#line 418
  the_random = self;
  }
#line 419
  return (& self->super);
}
}
#line 423 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c"
struct randomness *make_user_random(char const   *home ) 
{ 
  struct randomness *r ;
  struct lsh_string *file_name ;
  char const   *env_name ;
  char *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 430
  tmp = getenv("LSH_YARROW_SEED_FILE");
  }
#line 430
  env_name = (char const   *)tmp;
  }
#line 431
  if (env_name) {
    {
    {
#line 432
    file_name = ssh_format("%lz", env_name);
    }
    }
  } else {
#line 435
    if (! home) {
      {
      {
#line 437
      werror("Please set HOME in your environment.\n");
      }
      }
#line 438
      return ((struct randomness *)((void *)0));
    }
    {
    {
#line 441
    file_name = ssh_format("%lz/.lsh/yarrow-seed-file", home);
    }
    }
  }
  {
  {
#line 443
  r = random_init(file_name);
  }
  {
#line 445
  lsh_string_free((struct lsh_string  const  *)file_name);
  }
  }
#line 447
  return (r);
}
}
#line 450 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_random.c"
struct randomness *make_system_random(void) 
{ 
  struct randomness *r ;
  struct lsh_string *file_name ;
  char const   *env_name ;
  char *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 458
  tmp = getenv("LSH_YARROW_SEED_FILE");
  }
#line 458
  env_name = (char const   *)tmp;
  }
#line 461
  if (env_name) {
#line 461
    tmp___0 = env_name;
  } else {
#line 461
    tmp___0 = "/var/spool/lsh/yarrow-seed-file";
  }
  {
  {
#line 461
  file_name = ssh_format("%lz", tmp___0);
  }
  {
#line 464
  r = random_init(file_name);
  }
  {
#line 466
  lsh_string_free((struct lsh_string  const  *)file_name);
  }
  }
#line 468
  return (r);
}
}
#line 126 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 52 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 54 "/usr/include/utmpx.h"
extern void setutxent(void) ;
#line 84
extern struct utmpx *pututxline(struct utmpx  const  *__utmpx ) ;
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.h"
void init_resource(struct resource *self , void (*k)(struct resource * ) ) ;
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c.x"
struct lsh_class unix_process_class ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c.x"
struct lsh_class unix_process_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & lsh_process_class, (char *)"unix_process", (size_t )sizeof(struct unix_process ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 36
struct lsh_class logout_notice_class ;
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c.x"
static void do_logout_notice_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct logout_notice *i ;

  {
  {
#line 44
  i = (struct logout_notice *)o;
  {
#line 45
  (*mark)((struct lsh_object *)i->process);
  }
  {
#line 46
  (*mark)((struct lsh_object *)i->c);
  }
  }
#line 47
  return;
}
}
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c.x"
struct lsh_class logout_notice_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exit_callback_class, (char *)"logout_notice", (size_t )sizeof(struct logout_notice ),
    & do_logout_notice_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 70
struct lsh_class utmp_cleanup_class ;
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c.x"
static void do_utmp_cleanup_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct utmp_cleanup *i ;

  {
  {
#line 78
  i = (struct utmp_cleanup *)o;
  {
#line 79
  (*mark)((struct lsh_object *)i->c);
  }
  }
#line 80
  return;
}
}
#line 81 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c.x"
static void do_utmp_cleanup_free(struct lsh_object *o ) 
{ 
  struct utmp_cleanup *i ;

  {
  {
#line 84
  i = (struct utmp_cleanup *)o;
  {
#line 85
  lsh_string_free((struct lsh_string  const  *)i->id);
  }
  {
#line 86
  lsh_string_free((struct lsh_string  const  *)i->line);
  }
  }
#line 87
  return;
}
}
#line 88 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c.x"
struct lsh_class utmp_cleanup_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exit_callback_class, (char *)"utmp_cleanup", (size_t )sizeof(struct utmp_cleanup ),
    & do_utmp_cleanup_mark, & do_utmp_cleanup_free};
#line 135 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c"
static void do_kill_process(struct resource *r ) 
{ 
  struct unix_process *self ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 138
  self = (struct unix_process *)r;
#line 140
  if (self->super.super.alive) {
    {
#line 142
    self->super.super.alive = 0;
    {
#line 148
    tmp___0 = kill(self->pid, self->signal);
    }
    }
#line 148
    if (tmp___0 < 0) {
      {
      {
#line 150
      tmp = __errno_location();
      }
      {
#line 150
      werror("do_kill_process: kill failed %e\n", *tmp);
      }
      }
    }
  }
#line 153
  return;
}
}
#line 155 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c"
static int do_signal_process(struct lsh_process *s , int signal___0 ) 
{ 
  struct unix_process *self ;
  int tmp ;
  int tmp___0 ;

  {
#line 158
  self = (struct unix_process *)s;
#line 160
  if (self->super.super.alive) {
    {
    {
#line 160
    tmp = kill(self->pid, signal___0);
    }
    }
#line 160
    if (tmp == 0) {
#line 160
      tmp___0 = 1;
    } else {
#line 160
      tmp___0 = 0;
    }
  } else {
#line 160
    tmp___0 = 0;
  }
#line 160
  return (tmp___0);
}
}
#line 165 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c"
static struct lsh_process *make_unix_process(pid_t pid , int signal___0 ) 
{ 
  struct unix_process *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 168
  tmp = lsh_object_alloc(& unix_process_class);
  }
#line 168
  self = (struct unix_process *)tmp;
  {
#line 170
  trace("unix_process.c: make_unix_process\n");
  }
  {
#line 172
  init_resource(& self->super.super, & do_kill_process);
  }
#line 173
  self->super.signal = & do_signal_process;
#line 175
  self->pid = pid;
#line 176
  self->signal = signal___0;
  }
#line 178
  return (& self->super);
}
}
#line 190 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c"
static void do_logout_notice(struct exit_callback *s , int signaled , int core , int value ) 
{ 
  struct logout_notice *self ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 194
  self = (struct logout_notice *)s;
  {
#line 196
  trace("unix_process: do_logout_notice\n");
  }
#line 199
  (self->process)->alive = 0;
  {
#line 201
  (*((self->c)->exit))(self->c, signaled, core, value);
  }
  }
#line 202
  return;
}
}
#line 204 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c"
static struct exit_callback *make_logout_notice(struct resource *process , struct exit_callback *c ) 
{ 
  struct logout_notice *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 208
  tmp = lsh_object_alloc(& logout_notice_class);
  }
#line 208
  self = (struct logout_notice *)tmp;
#line 209
  self->super.exit = & do_logout_notice;
#line 210
  self->process = process;
#line 211
  self->c = c;
  }
#line 213
  return (& self->super);
}
}
#line 232 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c"
static void lsh_strncpy(char *dst , unsigned int n , struct lsh_string *s ) 
{ 
  unsigned int length ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint8_t const   *tmp___3 ;

  {
  {
  {
#line 235
  tmp___2 = lsh_string_length((struct lsh_string  const  *)s);
  }
  }
#line 235
  if (n > tmp___2) {
    {
    {
#line 235
    tmp___0 = lsh_string_length((struct lsh_string  const  *)s);
    }
#line 235
    tmp___1 = tmp___0;
    }
  } else {
#line 235
    tmp___1 = n;
  }
  {
#line 235
  length = tmp___1;
  {
#line 236
  tmp___3 = lsh_string_data((struct lsh_string  const  *)s);
  }
  {
#line 236
  memcpy((void */* __restrict  */)((void *)dst), (void const   */* __restrict  */)((void const   *)tmp___3),
         length);
  }
  }
#line 237
  if (length < n) {
#line 238
    *(dst + length) = (char )'\000';
  }
#line 239
  return;
}
}
#line 242 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c"
static void do_utmp_cleanup(struct exit_callback *s , int signaled , int core , int value ) 
{ 
  struct utmp_cleanup *self ;
  struct utmpx entry ;
  int *tmp ;
  struct utmpx *tmp___0 ;
  char const   *tmp___1 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
  {
#line 246
  self = (struct utmp_cleanup *)s;
  {
#line 255
  trace("unix_process.c: do_utmp_cleanup (HAVE_UTMPX_H) \n");
  }
  {
#line 258
  setutxent();
  }
  {
#line 261
  memset((void *)(& entry), 0, (size_t )sizeof(entry));
  }
  {
#line 264
  lsh_strncpy(entry.ut_id, (unsigned int )sizeof(entry.ut_id), self->id);
  }
#line 265
  entry.ut_type = (short)8;
  }
#line 272
  if (signaled) {
#line 272
    entry.ut_exit.e_exit = (short)0;
  } else {
#line 272
    entry.ut_exit.e_exit = (short )value;
  }
#line 273
  if (signaled) {
#line 273
    entry.ut_exit.e_termination = (short )value;
  } else {
#line 273
    entry.ut_exit.e_termination = (short)0;
  }
  {
  {
#line 310
  tmp___0 = pututxline((struct utmpx  const  *)(& entry));
  }
  }
#line 310
  if (! tmp___0) {
    {
    {
#line 311
    tmp = __errno_location();
    }
    {
#line 311
    werror("Updating utmpx for logout failed %e\n", *tmp);
    }
    }
  }
  {
  {
#line 330
  tmp___1 = lsh_get_cstring((struct lsh_string  const  *)self->line);
  }
  {
#line 330
  logwtmp(tmp___1, "", "");
  }
  {
#line 338
  (*((self->c)->exit))(self->c, signaled, core, value);
  }
  }
#line 339
  return;
}
}
#line 341 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c"
static struct utmp_cleanup *make_utmp_cleanup(struct lsh_string *tty , struct exit_callback *c ) 
{ 
  struct utmp_cleanup *self ;
  struct lsh_object *tmp ;
  uint32_t length ;
  uint32_t tmp___0 ;
  uint8_t const   *data ;
  uint8_t const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
  {
#line 345
  tmp = lsh_object_alloc(& utmp_cleanup_class);
  }
#line 345
  self = (struct utmp_cleanup *)tmp;
  {
#line 346
  tmp___0 = lsh_string_length((struct lsh_string  const  *)tty);
  }
#line 346
  length = tmp___0;
  {
#line 347
  tmp___1 = lsh_string_data((struct lsh_string  const  *)tty);
  }
#line 347
  data = tmp___1;
#line 349
  self->super.exit = & do_utmp_cleanup;
#line 350
  self->c = c;
  }
#line 352
  if (length > 5U) {
    {
    {
#line 352
    tmp___2 = memcmp((void const   *)data, (void const   *)"/dev/", (size_t )5);
    }
    }
#line 352
    if (! tmp___2) {
#line 354
      data += 5;
#line 354
      length -= 5U;
    }
  }
  {
  {
#line 356
  self->line = ssh_format("%ls", length, data);
  }
  }
#line 366
  if (length > 4U) {
    {
    {
#line 366
    tmp___4 = memcmp((void const   *)data, (void const   *)"pts/", (size_t )4);
    }
    }
#line 366
    if (tmp___4) {
#line 366
      goto _L;
    } else {
#line 367
      data += 4;
#line 367
      length -= 4U;
    }
  } else
  _L: 
#line 368
  if (length > 3U) {
    {
    {
#line 368
    tmp___3 = memcmp((void const   *)data, (void const   *)"tty", (size_t )3);
    }
    }
#line 368
    if (tmp___3) {
#line 372
      length = (uint32_t )0;
    } else {
#line 369
      data += 3;
#line 369
      length -= 3U;
    }
  } else {
#line 372
    length = (uint32_t )0;
  }
  {
  {
#line 374
  self->id = ssh_format("%ls", length, data);
  }
  }
#line 376
  return (self);
}
}
#line 379 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c"
static struct exit_callback *utmp_book_keeping(struct lsh_string *name , pid_t pid ,
                                               struct address_info *peer , struct lsh_string *tty ,
                                               struct exit_callback *c ) 
{ 
  struct utmp_cleanup *cleanup ;
  struct utmp_cleanup *tmp ;
  struct utmpx entry ;
  int *tmp___0 ;
  struct utmpx *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;

  {
  {
  {
#line 386
  tmp = make_utmp_cleanup(tty, c);
  }
#line 386
  cleanup = tmp;
  {
#line 390
  memset((void *)(& entry), 0, (size_t )sizeof(entry));
  }
  {
#line 392
  setutxent();
  }
  {
#line 394
  trace("unix_process.c: utmp_book_keeping\n");
  }
#line 399
  entry.ut_type = (short)7;
  {
#line 401
  lsh_strncpy(entry.ut_line, (unsigned int )sizeof(entry.ut_line), cleanup->line);
  }
  {
#line 402
  lsh_strncpy(entry.ut_id, (unsigned int )sizeof(entry.ut_id), cleanup->id);
  }
#line 405
  entry.ut_pid = pid;
  {
#line 409
  lsh_strncpy(entry.ut_user, (unsigned int )sizeof(entry.ut_user), name);
  }
  {
#line 413
  gettimeofday((struct timeval */* __restrict  */)(& entry.ut_tv), (__timezone_ptr_t )((void *)0));
  }
  {
#line 420
  trace("unix_process.c: utmp_book_keeping, after name (HAVE_UTMPX_H)\n");
  }
  {
#line 427
  memset((void *)(& entry.ut_addr_v6), 0, (size_t )sizeof(entry.ut_addr_v6));
  }
  {
#line 432
  lsh_strncpy(entry.ut_host, (unsigned int )sizeof(entry.ut_host), peer->ip);
  }
  {
#line 445
  trace("unix_process.c: utmp_book_keeping, after host (HAVE_UTMPX_H)\n");
  }
  {
#line 447
  tmp___1 = pututxline((struct utmpx  const  *)(& entry));
  }
  }
#line 447
  if (! tmp___1) {
    {
    {
#line 448
    tmp___0 = __errno_location();
    }
    {
#line 448
    werror("Updating utmp for login failed %e\n", *tmp___0);
    }
    }
  }
  {
  {
#line 450
  trace("unix_process.c: utmp_book_keeping, after pututline (HAVE_UTMPX_H)\n");
  }
  {
#line 453
  tmp___2 = lsh_get_cstring((struct lsh_string  const  *)peer->ip);
  }
  {
#line 453
  tmp___3 = lsh_get_cstring((struct lsh_string  const  *)name);
  }
  {
#line 453
  tmp___4 = lsh_get_cstring((struct lsh_string  const  *)cleanup->line);
  }
  {
#line 453
  logwtmp(tmp___4, tmp___3, tmp___2);
  }
  {
#line 464
  trace("unix_process.c: utmp_book_keeping, after logwtmp\n");
  }
  }
#line 466
  return (& cleanup->super);
}
}
#line 470 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_process.c"
struct lsh_process *unix_process_setup(pid_t pid , struct lsh_user *user , struct exit_callback **c ,
                                       struct address_info *peer , struct lsh_string *tty ) 
{ 
  struct lsh_process *process ;
  struct lsh_process *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 477
  tmp = make_unix_process(pid, 1);
  }
#line 477
  process = tmp;
  {
#line 479
  trace("unix_process.c: unix_process_setup\n");
  }
  }
#line 482
  if (tty) {
    {
    {
#line 483
    *c = utmp_book_keeping(user->name, pid, peer, tty, *c);
    }
    }
  }
  {
  {
#line 486
  trace("unix_process.c: unix_process_setup, after utmp\n");
  }
  {
#line 488
  *c = make_logout_notice(& process->super, *c);
  }
  }
#line 490
  return (process);
}
}
#line 964 "/usr/include/unistd.h"
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.h.x"
struct lsh_class terminal_attributes_class ;
#line 114
struct lsh_class interact_class ;
#line 119 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.h"
struct interact *make_unix_interact(void) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_class lsh_callback_class ;
#line 247 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
struct resource *io_signal_handler(int signum , struct lsh_callback *action ) ;
#line 402
struct lsh_string *lsh_popen_read(char const   *program , char const   **argv , int in ,
                                  unsigned int guess ) ;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/suspend.h"
void suspend_handle_tty(int fd ) ;
#line 77 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) void cfmakeraw(struct termios *__termios_p ) ;
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.h"
int tty_getattr(int fd , struct termios *ios ) ;
#line 40
int tty_setattr(int fd , struct termios *ios ) ;
#line 42
int tty_getwinsize(int fd , struct terminal_dimensions *dims ) ;
#line 45
struct lsh_string *tty_encode_term_mode(struct termios *ios ) ;
#line 12 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c.x"
struct lsh_class window_subscriber_class ;
#line 16 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c.x"
static void do_window_subscriber_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct window_subscriber *i ;

  {
  {
#line 20
  i = (struct window_subscriber *)o;
  {
#line 21
  (*mark)((struct lsh_object *)i->interact);
  }
  {
#line 22
  (*mark)((struct lsh_object *)i->next);
  }
  {
#line 23
  (*mark)((struct lsh_object *)i->callback);
  }
  }
#line 24
  return;
}
}
#line 25 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c.x"
struct lsh_class window_subscriber_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & resource_class, (char *)"window_subscriber", (size_t )sizeof(struct window_subscriber ),
    & do_window_subscriber_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 49
struct lsh_class unix_interact_class ;
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c.x"
static void do_unix_interact_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct unix_interact *i ;

  {
  {
#line 57
  i = (struct unix_interact *)o;
  {
#line 58
  (*mark)((struct lsh_object *)i->winch_handler);
  }
  {
#line 59
  (*mark)((struct lsh_object *)i->subscribers);
  }
  }
#line 60
  return;
}
}
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c.x"
struct lsh_class unix_interact_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & interact_class, (char *)"unix_interact", (size_t )sizeof(struct unix_interact ),
    & do_unix_interact_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 81
struct lsh_class unix_termios_class ;
#line 85 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c.x"
struct lsh_class unix_termios_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & terminal_attributes_class, (char *)"unix_termios", (size_t )sizeof(struct unix_termios ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 105
struct lsh_class winch_handler_class ;
#line 109 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c.x"
static void do_winch_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct winch_handler *i ;

  {
  {
#line 113
  i = (struct winch_handler *)o;
  {
#line 114
  (*mark)((struct lsh_object *)i->interact);
  }
  }
#line 115
  return;
}
}
#line 116 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c.x"
struct lsh_class winch_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & lsh_callback_class, (char *)"winch_handler", (size_t )sizeof(struct winch_handler ),
    & do_winch_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static uint32_t read_line(int fd , uint32_t size , uint8_t *buffer ) 
{ 
  uint32_t i ;
  int res ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  uint32_t j ;
  uint8_t b[512] ;
  int res___0 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  uint32_t j___0 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 61
  i = (uint32_t )0;
  {
  {
#line 63
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 63
    if (! (i < size)) {
#line 63
      goto while_break;
    }
    {
    {
#line 65
    tmp = read(fd, (void *)(buffer + i), size - i);
    }
#line 65
    res = tmp;
    }
#line 66
    if (! res) {
#line 68
      return (i);
    } else
#line 69
    if (res < 0) {
      {
      {
#line 70
      tmp___0 = __errno_location();
      }
      }
#line 73
      if (*tmp___0 == 4) {
#line 73
        goto case_4;
      }
#line 73
      if (*tmp___0 == 11) {
#line 73
        goto case_4;
      }
#line 75
      goto switch_default;
      case_4: 
#line 74
      goto switch_break;
      switch_default: 
      {
      {
#line 77
      tmp___1 = __errno_location();
      }
      {
#line 77
      werror("unix_interact.c: read_line, %e\n", *tmp___1);
      }
      }
#line 78
      return ((uint32_t )0);
      switch_break: ;
    } else {
#line 83
      j = (uint32_t )0;
      {
      {
#line 83
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;

#line 83
        if (! (j < (unsigned int )res)) {
#line 83
          goto while_break___0;
        }
#line 84
        if ((int )*(buffer + i) == 10) {
#line 85
          return (i);
        }
#line 83
        j ++;
#line 83
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 90
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
    {
#line 93
    tmp___2 = read(fd, (void *)(b), (size_t )512);
    }
#line 93
    res___0 = tmp___2;
    }
#line 94
    if (! res___0) {
#line 96
      return (size);
    } else
#line 97
    if (res___0 < 0) {
      {
      {
#line 98
      tmp___3 = __errno_location();
      }
      }
#line 101
      if (*tmp___3 == 4) {
#line 101
        goto case_4___0;
      }
#line 101
      if (*tmp___3 == 11) {
#line 101
        goto case_4___0;
      }
#line 103
      goto switch_default___0;
      case_4___0: 
#line 102
      goto switch_break___0;
      switch_default___0: 
      {
      {
#line 105
      tmp___4 = __errno_location();
      }
      {
#line 105
      werror("tty_read_line %e\n", *tmp___4);
      }
      }
#line 106
      return ((uint32_t )0);
      switch_break___0: ;
    } else {
#line 111
      j___0 = (uint32_t )0;
      {
      {
#line 111
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;

#line 111
        if (! (j___0 < (unsigned int )res___0)) {
#line 111
          goto while_break___2;
        }
#line 112
        if ((int )b[j___0] == 10) {
#line 113
          return (size);
        }
#line 111
        j___0 ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: ;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }

#line 120
  return (0U);
}
}
#line 134 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static void do_kill_window_subscriber(struct resource *s ) 
{ 
  struct window_subscriber *self ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 137
  self = (struct window_subscriber *)s;
#line 139
  if (self->super.alive) {
#line 141
    self->super.alive = 0;
#line 142
    if (! (self->interact)->nsubscribers) {
      {
      {
#line 142
      __assert_fail("self->interact->nsubscribers", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c",
                    142U, "do_kill_window_subscriber");
      }
      }
    }
#line 143
    if (! (self->interact)->winch_handler) {
      {
      {
#line 143
      __assert_fail("self->interact->winch_handler", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c",
                    143U, "do_kill_window_subscriber");
      }
      }
    }
#line 145
    ((self->interact)->nsubscribers) --;
#line 145
    if (! (self->interact)->nsubscribers) {
      {
      {
#line 147
      (*(((self->interact)->winch_handler)->kill))((self->interact)->winch_handler);
      }
#line 148
      (self->interact)->winch_handler = (struct resource *)((void *)0);
      }
    }
  }
#line 151
  return;
}
}
#line 170 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static int unix_is_tty(struct interact *s ) 
{ 
  struct unix_interact *self ;

  {
#line 173
  self = (struct unix_interact *)s;
#line 175
  return (self->tty_fd >= 0);
}
}
#line 179 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static struct lsh_string *read_password(struct unix_interact *self , struct lsh_string  const  *prompt ) 
{ 
  char const   *argv[3] ;
  int null ;
  int tmp ;
  struct lsh_string *tmp___0 ;
  char *password ;
  char const   *cprompt ;
  struct lsh_string *tmp___1 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 183
  if (self->askpass) {
    {
    {
#line 187
    tmp = open("/dev/null", 0);
    }
#line 187
    null = tmp;
    }
#line 189
    if (null < 0) {
      {
      {
#line 191
      werror("Failed to open /dev/null!\n");
      }
      }
#line 193
      return ((struct lsh_string *)((void *)0));
    }
    {
#line 196
    argv[0] = self->askpass;
    {
#line 197
    argv[1] = lsh_get_cstring(prompt);
    }
    }
#line 198
    if (! argv[1]) {
      {
      {
#line 200
      close(null);
      }
      }
#line 202
      return ((struct lsh_string *)((void *)0));
    }
    {
#line 204
    argv[2] = (char const   *)((void *)0);
    {
#line 206
    trace("unix_interact.c: spawning askpass program `%z\'\n", self->askpass);
    }
    {
#line 209
    tmp___0 = lsh_popen_read(self->askpass, argv, null, 100U);
    }
    }
#line 209
    return (tmp___0);
  } else {
#line 218
    if (! (self->tty_fd >= 0)) {
#line 219
      return ((struct lsh_string *)((void *)0));
    }
    {
    {
#line 221
    cprompt = lsh_get_cstring(prompt);
    }
    }
#line 222
    if (! cprompt) {
#line 223
      return ((struct lsh_string *)((void *)0));
    }
    {
    {
#line 226
    password = getpass(cprompt);
    }
    }
#line 228
    if (! password) {
#line 229
      return ((struct lsh_string *)((void *)0));
    }
    {
    {
#line 231
    tmp___1 = ssh_format("%lz", password);
    }
    }
#line 231
    return (tmp___1);
  }
}
}
#line 235 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static struct lsh_string *unix_read_password(struct interact *s , uint32_t max_length  __attribute__((__unused__)) ,
                                             struct lsh_string  const  *prompt ) 
{ 
  struct unix_interact *self ;
  struct lsh_string *password ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 240
  self = (struct unix_interact *)s;
  {
#line 243
  trace("unix_interact.c:unix_read_password\n");
  }
  {
#line 245
  password = read_password(self, prompt);
  }
  {
#line 246
  lsh_string_free(prompt);
  }
  }
#line 248
  return (password);
}
}
#line 251 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static void unix_set_askpass(struct interact *s , char const   *askpass ) 
{ 
  struct unix_interact *self ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 255
  self = (struct unix_interact *)s;
  {
#line 256
  trace("unix_interact.c:unix_set_askpass\n");
  }
  }
#line 257
  if (! askpass) {
    {
    {
#line 257
    __assert_fail("askpass", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c",
                  257U, "unix_set_askpass");
    }
    }
  }
#line 259
  self->askpass = askpass;
#line 260
  return;
}
}
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static int unix_yes_or_no(struct interact *s , struct lsh_string  const  *prompt ,
                          int def , int free___0 ) 
{ 
  struct unix_interact *self ;
  uint8_t buffer[10] ;
  struct exception  const  *e ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
#line 269
  self = (struct unix_interact *)s;
#line 270
  if (! (self->tty_fd >= 0)) {
#line 270
    goto _L;
  } else
#line 270
  if (quiet_flag) {
    _L: 
#line 272
    if (free___0) {
      {
      {
#line 273
      lsh_string_free(prompt);
      }
      }
    }
#line 274
    return (def);
  } else {
    {
    {
#line 281
    tmp = lsh_string_data(prompt);
    }
    {
#line 281
    tmp___0 = lsh_string_length(prompt);
    }
    {
#line 281
    e = write_raw(self->tty_fd, tmp___0, tmp);
    }
    }
#line 283
    if (free___0) {
      {
      {
#line 284
      lsh_string_free(prompt);
      }
      }
    }
#line 286
    if (e) {
#line 287
      return (def);
    }
    {
    {
#line 289
    tmp___1 = read_line(self->tty_fd, (uint32_t )10, buffer);
    }
    }
#line 289
    if (! tmp___1) {
#line 290
      return (def);
    }
#line 295
    if ((int )buffer[0] == 89) {
#line 295
      goto case_89;
    }
#line 295
    if ((int )buffer[0] == 121) {
#line 295
      goto case_89;
    }
#line 297
    goto switch_default;
    case_89: 
#line 296
    return (1);
    switch_default: 
#line 298
    return (0);

  }
#line 303
  return (0);
}
}
#line 306 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static int unix_dialog(struct interact *s , struct interact_dialog  const  *dialog ) 
{ 
  struct unix_interact *self ;
  struct exception  const  *e ;
  unsigned int i ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct lsh_string *prompt ;
  uint8_t buffer[150] ;
  uint32_t length ;
  uint8_t const   *tmp___1 ;
  uint32_t tmp___2 ;
  struct lsh_string *tmp___3 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 311
  self = (struct unix_interact *)s;
  {
#line 315
  tmp = lsh_string_data((struct lsh_string  const  *)dialog->instruction);
  }
  {
#line 315
  tmp___0 = lsh_string_length((struct lsh_string  const  *)dialog->instruction);
  }
  {
#line 315
  e = write_raw(self->tty_fd, tmp___0, tmp);
  }
  }
#line 317
  if (e) {
#line 318
    return (0);
  }
#line 320
  i = 0U;
  {
  {
#line 320
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 320
    if (! (i < (unsigned int )dialog->nprompt)) {
#line 320
      goto while_break;
    }
#line 322
    prompt = *(dialog->prompt + i);
#line 323
    if (*(dialog->echo + i)) {
      {
      {
#line 328
      tmp___1 = lsh_string_data((struct lsh_string  const  *)prompt);
      }
      {
#line 328
      tmp___2 = lsh_string_length((struct lsh_string  const  *)prompt);
      }
      {
#line 328
      e = write_raw(self->tty_fd, tmp___2, tmp___1);
      }
      }
#line 329
      if (e) {
#line 330
        return (0);
      }
      {
      {
#line 331
      length = read_line(self->tty_fd, (uint32_t )150, buffer);
      }
      }
#line 332
      if (! length) {
#line 333
        return (0);
      }
      {
      {
#line 335
      *(dialog->response + i) = ssh_format("%ls", length, buffer);
      }
      }
    } else {
      {
      {
#line 339
      tmp___3 = read_password(self, (struct lsh_string  const  *)prompt);
      }
#line 339
      *(dialog->response + i) = tmp___3;
      }
#line 339
      if (! tmp___3) {
#line 340
        return (0);
      }
    }
#line 320
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 343
  return (1);
}
}
#line 355 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static struct terminal_attributes *do_make_raw(struct terminal_attributes *s ) 
{ 
  struct unix_termios *self ;
  struct unix_termios *res ;
  struct lsh_object *tmp ;

  {
  {
#line 358
  self = (struct unix_termios *)s;
  {
#line 359
  tmp = lsh_object_clone((struct lsh_object *)self);
  }
#line 359
  res = (struct unix_termios *)tmp;
  {
#line 361
  cfmakeraw(& res->ios);
  }
#line 365
  res->ios.c_cc[6] = (cc_t )4;
#line 367
  res->ios.c_cc[5] = (cc_t )1;
  }
#line 369
  return (& res->super);
}
}
#line 372 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static struct lsh_string *do_encode(struct terminal_attributes *s ) 
{ 
  struct unix_termios *self ;
  struct lsh_string *tmp ;

  {
  {
#line 375
  self = (struct unix_termios *)s;
  {
#line 376
  tmp = tty_encode_term_mode(& self->ios);
  }
  }
#line 376
  return (tmp);
}
}
#line 379 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static struct terminal_attributes *unix_get_attributes(struct interact *s ) 
{ 
  struct unix_interact *self ;
  struct unix_termios *res ;
  struct lsh_object *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 382
  self = (struct unix_interact *)s;
#line 384
  if (! (self->tty_fd >= 0)) {
#line 385
    return ((struct terminal_attributes *)((void *)0));
  } else {
    {
    {
#line 388
    tmp = lsh_object_alloc(& unix_termios_class);
    }
#line 388
    res = (struct unix_termios *)tmp;
#line 389
    res->super.make_raw = & do_make_raw;
#line 390
    res->super.encode = & do_encode;
    {
#line 392
    tmp___0 = tty_getattr(self->tty_fd, & res->ios);
    }
    }
#line 392
    if (tmp___0) {
#line 392
      tmp___1 = 0;
    } else {
#line 392
      tmp___1 = 1;
    }
#line 392
    if (tmp___1 < 0) {
      {
      {
#line 394
      gc_kill((struct lsh_object *)res);
      }
      }
#line 395
      return ((struct terminal_attributes *)((void *)0));
    }
#line 397
    return (& res->super);
  }
}
}
#line 401 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static int unix_set_attributes(struct interact *s , struct terminal_attributes *a ) 
{ 
  struct unix_interact *self ;
  struct unix_termios *attr ;
  int tmp ;
  int tmp___0 ;

  {
#line 405
  self = (struct unix_interact *)s;
#line 406
  attr = (struct unix_termios *)a;
#line 408
  if (self->tty_fd >= 0) {
    {
    {
#line 408
    tmp = tty_setattr(self->tty_fd, & attr->ios);
    }
    }
#line 408
    if (tmp) {
#line 408
      tmp___0 = 1;
    } else {
#line 408
      tmp___0 = 0;
    }
  } else {
#line 408
    tmp___0 = 0;
  }
#line 408
  return (tmp___0);
}
}
#line 412 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static int unix_window_size(struct interact *s , struct terminal_dimensions *d ) 
{ 
  struct unix_interact *self ;
  int tmp ;
  int tmp___0 ;

  {
#line 416
  self = (struct unix_interact *)s;
#line 418
  if (self->tty_fd >= 0) {
    {
    {
#line 418
    tmp = tty_getwinsize(self->tty_fd, d);
    }
    }
#line 418
    if (tmp) {
#line 418
      tmp___0 = 1;
    } else {
#line 418
      tmp___0 = 0;
    }
  } else {
#line 418
    tmp___0 = 0;
  }
#line 418
  return (tmp___0);
}
}
#line 431 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static void do_winch_handler(struct lsh_callback *s ) 
{ 
  struct winch_handler *self ;
  struct unix_interact *i ;
  struct window_subscriber *s___0 ;
  struct window_subscriber **s_p ;
  unsigned int alive ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 434
  self = (struct winch_handler *)s;
#line 435
  i = self->interact;
#line 437
  if (! (! (! i->nsubscribers) == ! (! i->winch_handler))) {
    {
    {
#line 437
    __assert_fail("!!i->nsubscribers == !!i->winch_handler", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c",
                  437U, "do_winch_handler");
    }
    }
  }
#line 439
  if (i->subscribers) {
#line 445
    alive = 0U;
#line 445
    s_p = & i->subscribers;
    {
    {
#line 445
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 445
      s___0 = *s_p;
#line 445
      if (! s___0) {
#line 445
        goto while_break;
      }
#line 447
      if (! s___0->super.alive) {
#line 448
        *s_p = s___0->next;
      } else {
        {
        {
#line 451
        (*((s___0->callback)->f))(s___0->callback, & i->super);
        }
#line 452
        s_p = & s___0->next;
#line 453
        alive ++;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
#line 457
    if (! (alive == i->nsubscribers)) {
      {
      {
#line 457
      __assert_fail("alive == i->nsubscribers", "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c",
                    457U, "do_winch_handler");
      }
      }
    }
  }
#line 459
  return;
}
}
#line 461 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static struct lsh_callback *make_winch_handler(struct unix_interact *i ) 
{ 
  struct winch_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 464
  tmp = lsh_object_alloc(& winch_handler_class);
  }
#line 464
  self = (struct winch_handler *)tmp;
#line 465
  self->super.f = & do_winch_handler;
#line 466
  self->interact = i;
  }
#line 468
  return (& self->super);
}
}
#line 471 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
static struct resource *unix_window_change_subscribe(struct interact *s , struct window_change_callback *callback ) 
{ 
  struct unix_interact *self ;
  struct window_subscriber *subscriber ;
  struct lsh_object *tmp ;
  struct lsh_callback *tmp___0 ;

  {
  {
#line 475
  self = (struct unix_interact *)s;
  {
#line 477
  tmp = lsh_object_alloc(& window_subscriber_class);
  }
#line 477
  subscriber = (struct window_subscriber *)tmp;
  {
#line 479
  init_resource(& subscriber->super, & do_kill_window_subscriber);
  }
#line 481
  subscriber->interact = self;
#line 482
  subscriber->next = self->subscribers;
#line 483
  subscriber->callback = callback;
#line 485
  self->subscribers = subscriber;
#line 486
  (self->nsubscribers) ++;
  }
#line 488
  if (! self->winch_handler) {
    {
    {
#line 491
    tmp___0 = make_winch_handler(self);
    }
    {
#line 491
    self->winch_handler = io_signal_handler(28, tmp___0);
    }
    }
  }
#line 496
  return (& subscriber->super);
}
}
#line 499 "/home/ysko/Works/test-src/lsh-2.0.4/src/unix_interact.c"
struct interact *make_unix_interact(void) 
{ 
  struct unix_interact *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 502
  tmp = lsh_object_alloc(& unix_interact_class);
  }
#line 502
  self = (struct unix_interact *)tmp;
#line 504
  self->super.is_tty = & unix_is_tty;
#line 505
  self->super.read_password = & unix_read_password;
#line 506
  self->super.set_askpass = & unix_set_askpass;
#line 507
  self->super.yes_or_no = & unix_yes_or_no;
#line 508
  self->super.dialog = & unix_dialog;
#line 509
  self->super.get_attributes = & unix_get_attributes;
#line 510
  self->super.set_attributes = & unix_set_attributes;
#line 511
  self->super.window_size = & unix_window_size;
#line 512
  self->super.window_change_subscribe = & unix_window_change_subscribe;
#line 514
  self->tty_fd = -1;
#line 515
  self->askpass = (char const   *)((void *)0);
  {
#line 521
  self->tty_fd = open("/dev/tty", 2);
  }
  }
#line 524
  if (self->tty_fd >= 0) {
    {
    {
#line 526
    io_set_close_on_exec(self->tty_fd);
    }
    {
#line 528
    suspend_handle_tty(self->tty_fd);
    }
    }
  }
#line 530
  return (& self->super);
}
}
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.h"
int tty_setwinsize(int fd , struct terminal_dimensions  const  *dims ) ;
#line 47
int tty_decode_term_mode(struct termios *ios , uint32_t t_len , uint8_t const   *t_modes ) ;
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.h"
void simple_buffer_init(struct simple_buffer *buffer , uint32_t capacity , uint8_t const   *data ) ;
#line 48
int parse_uint32(struct simple_buffer *buffer , uint32_t *result ) ;
#line 70
int parse_uint8(struct simple_buffer *buffer , unsigned int *result ) ;
#line 102 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
void lsh_string_putc(struct lsh_string *s , uint32_t i , uint8_t c ) ;
#line 112
void lsh_string_write_uint32(struct lsh_string *s , uint32_t start , uint32_t n ) ;
#line 129
struct lsh_string *lsh_string_trunc(struct lsh_string *s , uint32_t length ) ;
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.c"
int tty_getattr(int fd , struct termios *ios ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 49
  tmp___1 = tcgetattr(fd, ios);
  }
  }
#line 49
  if (tmp___1 != -1) {
#line 49
    tmp___0 = 1;
  } else {
#line 49
    tmp___0 = 0;
  }
#line 49
  return (tmp___0);
}
}
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.c"
int tty_setattr(int fd , struct termios *ios ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 55
  tmp___1 = tcsetattr(fd, 1, (struct termios  const  *)ios);
  }
  }
#line 55
  if (tmp___1 != -1) {
#line 55
    tmp___0 = 1;
  } else {
#line 55
    tmp___0 = 0;
  }
#line 55
  return (tmp___0);
}
}
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.c"
int tty_getwinsize(int fd , struct terminal_dimensions *dims ) 
{ 
  struct winsize ws ;
  int rc ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
  {
#line 64
  rc = ioctl(fd, 21523UL, & ws);
  }
  }
#line 65
  if (rc != -1) {
#line 67
    dims->char_width = (uint32_t )ws.ws_col;
#line 68
    dims->char_height = (uint32_t )ws.ws_row;
#line 69
    dims->pixel_width = (uint32_t )ws.ws_xpixel;
#line 70
    dims->pixel_height = (uint32_t )ws.ws_ypixel;
#line 71
    return (1);
  }
#line 73
  return (0);
}
}
#line 76 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.c"
int tty_setwinsize(int fd , struct terminal_dimensions  const  *dims ) 
{ 
  struct winsize ws ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 81
  ws.ws_col = (unsigned short )dims->char_width;
#line 82
  ws.ws_row = (unsigned short )dims->char_height;
#line 83
  ws.ws_xpixel = (unsigned short )dims->pixel_width;
#line 84
  ws.ws_ypixel = (unsigned short )dims->pixel_height;
  {
#line 86
  tmp___1 = ioctl(fd, 21524UL, & ws);
  }
  }
#line 86
  if (tmp___1 == -1) {
#line 86
    tmp___0 = 0;
  } else {
#line 86
    tmp___0 = 1;
  }
#line 86
  return (tmp___0);
}
}
#line 89 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.c"
static int cc_ndx[18]  = 
#line 89
  {      0,      1,      2,      3, 
        4,      11,      16,      8, 
        9,      10,      -1,      12, 
        14,      15,      -1,      -1, 
        -1,      13};
#line 183 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.c"
static int cc_iflags[12]  = 
#line 183
  {      4,      8,      16,      32, 
        64,      128,      256,      512, 
        1024,      2048,      4096,      8192};
#line 246 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.c"
static int cc_oflags[6]  = {      1,      2,      4,      8, 
        16,      32};
#line 279 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.c"
static int cc_cflags[4]  = {      32,      48,      256,      512};
#line 302 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.c"
static int cc_lflags[13]  = 
#line 302
  {      1,      2,      4,      8, 
        16,      32,      64,      128, 
        256,      32768,      512,      2048, 
        16384};
#line 391 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.c"
struct lsh_string *tty_encode_term_mode(struct termios *ios ) 
{ 
  unsigned int i ;
  struct lsh_string *new ;
  uint32_t p ;
  uint32_t length ;
  uint32_t tmp ;
  uint32_t r ;
  uint32_t tmp___0 ;
  uint32_t r___0 ;
  uint32_t tmp___1 ;
  uint32_t r___1 ;
  uint32_t tmp___2 ;
  uint32_t r___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 396
  p = (uint32_t )0;
#line 397
  length = (uint32_t )650;
  {
#line 398
  new = lsh_string_alloc(length);
  }
#line 400
  i = 0U;
  }
  {
  {
#line 400
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 400
    if (! ((unsigned long )i < sizeof(cc_ndx) / sizeof(cc_ndx[0]))) {
#line 400
      goto while_break;
    }
#line 402
    if (cc_ndx[i] != -1) {
#line 404
      if (p + 5U > length) {
#line 405
        goto fail;
      }
      {
#line 407
      tmp = p;
#line 407
      p ++;
      {
#line 407
      lsh_string_putc(new, tmp, (uint8_t )(i + 1U));
      }
      {
#line 408
      lsh_string_write_uint32(new, p, (uint32_t )ios->c_cc[cc_ndx[i]]);
      }
#line 409
      p += 4U;
      }
    }
#line 400
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 412
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 412
    debug("tty_encode_term_mode: termios bits %xi (offset %i)\n", ios->c_iflag, 30);
    }
#line 412
    i = 0U;
    }
    {
    {
#line 412
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;

#line 412
      if (! ((unsigned long )i < sizeof(cc_iflags) / sizeof(cc_iflags[0]))) {
#line 412
        goto while_break___1;
      }
#line 412
      if (cc_iflags[i]) {
#line 412
        if (p + 5U > length) {
#line 412
          goto fail;
        }
#line 412
        if (ios->c_iflag & (unsigned int )cc_iflags[i]) {
#line 412
          r = (uint32_t )1;
        } else {
#line 412
          r = (uint32_t )0;
        }
        {
#line 412
        tmp___0 = p;
#line 412
        p ++;
        {
#line 412
        lsh_string_putc(new, tmp___0, (uint8_t )(i + 30U));
        }
        {
#line 412
        lsh_string_write_uint32(new, p, r);
        }
#line 412
        p += 4U;
        }
      }
#line 412
      i ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___1: ;
#line 412
    goto while_break___0;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___0: ;
  {
  {
#line 413
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
    {
    {
#line 413
    debug("tty_encode_term_mode: termios bits %xi (offset %i)\n", ios->c_lflag, 50);
    }
#line 413
    i = 0U;
    }
    {
    {
#line 413
    while (1) {
      while_continue___12: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;

#line 413
      if (! ((unsigned long )i < sizeof(cc_lflags) / sizeof(cc_lflags[0]))) {
#line 413
        goto while_break___3;
      }
#line 413
      if (cc_lflags[i]) {
#line 413
        if (p + 5U > length) {
#line 413
          goto fail;
        }
#line 413
        if (ios->c_lflag & (unsigned int )cc_lflags[i]) {
#line 413
          r___0 = (uint32_t )1;
        } else {
#line 413
          r___0 = (uint32_t )0;
        }
        {
#line 413
        tmp___1 = p;
#line 413
        p ++;
        {
#line 413
        lsh_string_putc(new, tmp___1, (uint8_t )(i + 50U));
        }
        {
#line 413
        lsh_string_write_uint32(new, p, r___0);
        }
#line 413
        p += 4U;
        }
      }
#line 413
      i ++;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___3: ;
#line 413
    goto while_break___2;
  }
  while_break___20: /* CIL Label */ ;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___2: ;
  {
  {
#line 414
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
    {
    {
#line 414
    debug("tty_encode_term_mode: termios bits %xi (offset %i)\n", ios->c_oflag, 70);
    }
#line 414
    i = 0U;
    }
    {
    {
#line 414
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;

#line 414
      if (! ((unsigned long )i < sizeof(cc_oflags) / sizeof(cc_oflags[0]))) {
#line 414
        goto while_break___5;
      }
#line 414
      if (cc_oflags[i]) {
#line 414
        if (p + 5U > length) {
#line 414
          goto fail;
        }
#line 414
        if (ios->c_oflag & (unsigned int )cc_oflags[i]) {
#line 414
          r___1 = (uint32_t )1;
        } else {
#line 414
          r___1 = (uint32_t )0;
        }
        {
#line 414
        tmp___2 = p;
#line 414
        p ++;
        {
#line 414
        lsh_string_putc(new, tmp___2, (uint8_t )(i + 70U));
        }
        {
#line 414
        lsh_string_write_uint32(new, p, r___1);
        }
#line 414
        p += 4U;
        }
      }
#line 414
      i ++;
    }
    while_break___23: /* CIL Label */ ;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___5: ;
#line 414
    goto while_break___4;
  }
  while_break___22: /* CIL Label */ ;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___4: ;
  {
  {
#line 415
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;
    {
    {
#line 415
    debug("tty_encode_term_mode: termios bits %xi (offset %i)\n", ios->c_cflag, 90);
    }
#line 415
    i = 0U;
    }
    {
    {
#line 415
    while (1) {
      while_continue___16: /* CIL Label */ ;
      while_continue___7: /* CIL Label */ ;

#line 415
      if (! ((unsigned long )i < sizeof(cc_cflags) / sizeof(cc_cflags[0]))) {
#line 415
        goto while_break___7;
      }
#line 415
      if (cc_cflags[i]) {
#line 415
        if (p + 5U > length) {
#line 415
          goto fail;
        }
#line 415
        if (ios->c_cflag & (unsigned int )cc_cflags[i]) {
#line 415
          r___2 = (uint32_t )1;
        } else {
#line 415
          r___2 = (uint32_t )0;
        }
        {
#line 415
        tmp___3 = p;
#line 415
        p ++;
        {
#line 415
        lsh_string_putc(new, tmp___3, (uint8_t )(i + 90U));
        }
        {
#line 415
        lsh_string_write_uint32(new, p, r___2);
        }
#line 415
        p += 4U;
        }
      }
#line 415
      i ++;
    }
    while_break___25: /* CIL Label */ ;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___7: ;
#line 415
    goto while_break___6;
  }
  while_break___24: /* CIL Label */ ;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___6: ;
#line 417
  if (p + 1U > length) {
#line 418
    goto fail;
  }
  {
#line 420
  tmp___4 = p;
#line 420
  p ++;
  {
#line 420
  lsh_string_putc(new, tmp___4, (uint8_t )0);
  }
  {
#line 421
  lsh_string_trunc(new, p);
  }
  }
#line 423
  return (new);
  fail: 
  {
  {
#line 426
  lsh_string_free((struct lsh_string  const  *)new);
  }
  }
#line 427
  return ((struct lsh_string *)((void *)0));
}
}
#line 454 "/home/ysko/Works/test-src/lsh-2.0.4/src/tty.c"
int tty_decode_term_mode(struct termios *ios , uint32_t t_len , uint8_t const   *t_modes ) 
{ 
  struct simple_buffer buffer ;
  unsigned int opcode ;
  int tmp ;
  uint32_t param ;
  int tmp___0 ;
  int _value ;
  int _mask ;
  int _mask___0 ;
  int _mask___1 ;
  int _mask___2 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 459
  simple_buffer_init(& buffer, t_len, t_modes);
  }
  }
  {
  {
#line 461
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 465
    tmp = parse_uint8(& buffer, & opcode);
    }
    }
#line 465
    if (! tmp) {
#line 466
      return (0);
    }
#line 471
    if (opcode == 0U) {
#line 473
      goto while_break;
    } else
#line 471
    if (opcode > 160U) {
#line 473
      goto while_break;
    }
    {
    {
#line 475
    tmp___0 = parse_uint32(& buffer, & param);
    }
    }
#line 475
    if (! tmp___0) {
#line 476
      return (0);
    }
#line 489
    if (opcode < 30U) {
      {
      {
#line 490
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;

#line 490
        if ((unsigned long )(opcode - 1U) < sizeof(cc_ndx) / sizeof(cc_ndx[0])) {
#line 490
          _value = cc_ndx[opcode - 1U];
#line 490
          if (_value >= 0) {
#line 490
            ios->c_cc[_value] = (cc_t )param;
          }
        }
#line 490
        goto while_break___0;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___0: ;
    } else
#line 491
    if (opcode < 50U) {
      {
      {
#line 492
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;

#line 492
        if ((unsigned long )(opcode - 30U) < sizeof(cc_iflags) / sizeof(cc_iflags[0])) {
#line 492
          _mask = cc_iflags[opcode - 30U];
#line 492
          if (_mask >= 0) {
#line 492
            if (param) {
#line 492
              ios->c_iflag |= (unsigned int )_mask;
            } else {
#line 492
              ios->c_iflag &= (unsigned int )(~ _mask);
            }
          }
        }
#line 492
        goto while_break___1;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: ;
    } else
#line 493
    if (opcode < 70U) {
      {
      {
#line 494
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;

#line 494
        if ((unsigned long )(opcode - 50U) < sizeof(cc_lflags) / sizeof(cc_lflags[0])) {
#line 494
          _mask___0 = cc_lflags[opcode - 50U];
#line 494
          if (_mask___0 >= 0) {
#line 494
            if (param) {
#line 494
              ios->c_lflag |= (unsigned int )_mask___0;
            } else {
#line 494
              ios->c_lflag &= (unsigned int )(~ _mask___0);
            }
          }
        }
#line 494
        goto while_break___2;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: ;
    } else
#line 495
    if (opcode < 90U) {
      {
      {
#line 496
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;

#line 496
        if ((unsigned long )(opcode - 70U) < sizeof(cc_oflags) / sizeof(cc_oflags[0])) {
#line 496
          _mask___1 = cc_oflags[opcode - 70U];
#line 496
          if (_mask___1 >= 0) {
#line 496
            if (param) {
#line 496
              ios->c_oflag |= (unsigned int )_mask___1;
            } else {
#line 496
              ios->c_oflag &= (unsigned int )(~ _mask___1);
            }
          }
        }
#line 496
        goto while_break___3;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: ;
    } else
#line 497
    if (opcode < 128U) {
      {
      {
#line 498
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;

#line 498
        if ((unsigned long )(opcode - 90U) < sizeof(cc_cflags) / sizeof(cc_cflags[0])) {
#line 498
          _mask___2 = cc_cflags[opcode - 90U];
#line 498
          if (_mask___2 >= 0) {
#line 498
            if (param) {
#line 498
              ios->c_cflag |= (unsigned int )_mask___2;
            } else {
#line 498
              ios->c_cflag &= (unsigned int )(~ _mask___2);
            }
          }
        }
#line 498
        goto while_break___4;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: ;
    } else {
#line 504
      if (opcode == 129U) {
#line 504
        goto case_129;
      }
#line 504
      if (opcode == 128U) {
#line 504
        goto case_129;
      }
#line 514
      goto switch_default;
      case_129: 
#line 513
      goto switch_break;
      switch_default: 
      {
      {
#line 515
      werror("Unsupported terminal mode: %i\n", opcode);
      }
      }
      switch_break: ;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 521
  return (1);
}
}
#line 30 "/home/ysko/Works/test-src/lsh-2.0.4/src/translate_signal.h"
int signal_local_to_network(int signal___0 ) ;
#line 31
int signal_network_to_local(int signal___0 ) ;
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/translate_signal.c"
static struct signal_assoc  const  translate[14]  = 
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/translate_signal.c"
  {      {71, 6}, 
        {72, 14}, 
        {73, 8}, 
        {74, 1}, 
        {75, 4}, 
        {76, 2}, 
        {77, 9}, 
        {78, 13}, 
        {79, 3}, 
        {80, 11}, 
        {81, 15}, 
        {82, 10}, 
        {83, 12}, 
        {-1, -1}};
#line 106 "/home/ysko/Works/test-src/lsh-2.0.4/src/translate_signal.c"
int signal_local_to_network(int signal___0 ) 
{ 
  int i ;

  {
#line 110
  if (! signal___0) {
#line 111
    return (0);
  }
#line 113
  i = 0;
  {
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 115
    if (translate[i].local < 0) {
#line 116
      return (84);
    }
#line 117
    if (translate[i].local == (int const   )signal___0) {
#line 118
      return ((int )translate[i].network);
    }
#line 113
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 118
  return (0);
}
}
#line 123 "/home/ysko/Works/test-src/lsh-2.0.4/src/translate_signal.c"
int signal_network_to_local(int signal___0 ) 
{ 
  int i ;

  {
#line 127
  if (! signal___0) {
#line 128
    return (0);
  }
#line 130
  i = 0;
  {
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 132
    if (translate[i].local < 0) {
#line 133
      return (0);
    }
#line 134
    if (translate[i].network == (int const   )signal___0) {
#line 135
      return ((int )translate[i].local);
    }
#line 130
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 135
  return (0);
}
}
#line 131 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct lsh_class command_frame_class ;
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h"
void do_command_2(struct command *s , struct lsh_object *a1 , struct command_continuation *c ,
                  struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 138
struct command *make_command_3_invoke(struct command_3 *f , struct lsh_object *a1 ) ;
#line 142
struct command *make_command_3_invoke_2(struct command_3 *f , struct lsh_object *a1 ,
                                        struct lsh_object *a2 ) ;
#line 183
struct command *make_command_4_invoke(struct command_4 *f , struct lsh_object *a1 ) ;
#line 187
struct command *make_command_4_invoke_2(struct command_4 *f , struct lsh_object *a1 ,
                                        struct lsh_object *a2 ) ;
#line 192
struct command *make_command_4_invoke_3(struct command_4 *f , struct lsh_object *a1 ,
                                        struct lsh_object *a2 , struct lsh_object *a3 ) ;
#line 224
struct command_continuation discard_continuation ;
#line 305
struct lsh_object *gaba_apply(struct lsh_object *f , struct lsh_object *x ) ;
#line 310
struct command command_I ;
#line 314
struct command_2 command_K ;
#line 321
struct command_3 command_S ;
#line 339
struct command_3 command_B ;
#line 347
struct command_4 command_Bp ;
#line 357
struct command_3 command_C ;
#line 366
struct command_4 command_Cp ;
#line 98 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h"
void object_queue_add_tail(struct object_queue *q , struct lsh_object *o ) ;
#line 391 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h"
struct lsh_string *format_channel_open(int type , uint32_t local_channel_number ,
                                       struct ssh_channel *channel , char const   *format 
                                       , ...) ;
#line 407
struct lsh_string *format_global_request(int type , int want_reply , char const   *format 
                                         , ...) ;
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.h"
struct remote_port *make_remote_port(struct address_info *listen___0 , struct command *callback ) ;
#line 73
struct channel_open *make_channel_open_direct_tcpip(struct command *callback ) ;
#line 78
struct global_request *make_tcpip_forward_request(struct command *callback ) ;
#line 83
struct command *make_open_tcpip_command(int type , struct address_info *port , struct listen_value *peer ) ;
#line 88
struct command *make_forward_local_port(struct address_info *local , struct address_info *target ) ;
#line 92
struct command *make_forward_remote_port(struct address_info *remote , struct address_info *target ) ;
#line 96
struct command *make_direct_tcpip_hook(void) ;
#line 99
struct command *make_tcpip_forward_hook(void) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h.x"
struct lsh_class channel_open_command_class ;
#line 58
struct lsh_class global_request_command_class ;
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h"
void do_channel_open_command(struct command *s , struct lsh_object *x , struct command_continuation *c ,
                             struct exception_handler *e ) ;
#line 95
void do_channel_global_command(struct command *s , struct lsh_object *x , struct command_continuation *c ,
                               struct exception_handler *e ) ;
#line 114
void do_install_global_request_handler(struct command_2 *s , struct lsh_object *a1 ,
                                       struct lsh_object *a2 , struct command_continuation *c ,
                                       struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 120
void do_install_channel_open_handler(struct command_2 *s , struct lsh_object *a1 ,
                                     struct lsh_object *a2 , struct command_continuation *c ,
                                     struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.h"
struct channel_forward *make_channel_forward(struct lsh_fd *socket___0 , uint32_t initial_window ) ;
#line 56
struct command start_io_command ;
#line 59
struct catch_report_collect catch_channel_open ;
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection_commands.h"
struct command_2 connection_remember ;
#line 30 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.h"
struct command_2 listen_command ;
#line 33
struct command bind_address_command ;
#line 40
struct command *make_connect_port(struct address_info *target ) ;
#line 43
struct command_2 connect_connection_command ;
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
struct command_2 open_direct_tcpip ;
#line 49
struct command_2 remote_listen_command ;
#line 53
struct command_2 open_forwarded_tcpip ;
#line 57
struct command tcpip_connect_io_command ;
#line 60
static struct install_info install_direct_tcpip_handler ;
#line 64
struct command make_direct_tcpip_handler ;
#line 67
static struct install_info install_tcpip_forward_handler ;
#line 71
struct command make_tcpip_forward_handler ;
#line 12 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
struct lsh_class open_tcpip_command_class ;
#line 16 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
static void do_open_tcpip_command_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct open_tcpip_command *i ;

  {
  {
#line 20
  i = (struct open_tcpip_command *)o;
  {
#line 21
  (*mark)((struct lsh_object *)i->port);
  }
  {
#line 22
  (*mark)((struct lsh_object *)i->peer);
  }
  }
#line 23
  return;
}
}
#line 24 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
struct lsh_class open_tcpip_command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_open_command_class, (char *)"open_tcpip_command", (size_t )sizeof(struct open_tcpip_command ),
    & do_open_tcpip_command_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 45
struct lsh_class remote_port_install_continuation_class ;
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
static void do_remote_port_install_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct remote_port_install_continuation *i ;

  {
  {
#line 53
  i = (struct remote_port_install_continuation *)o;
  {
#line 54
  (*mark)((struct lsh_object *)i->port);
  }
  {
#line 55
  (*mark)((struct lsh_object *)i->callback);
  }
  }
#line 56
  return;
}
}
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
struct lsh_class remote_port_install_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_frame_class, (char *)"remote_port_install_continuation",
    (size_t )sizeof(struct remote_port_install_continuation ), & do_remote_port_install_continuation_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 78
struct lsh_class request_tcpip_forward_command_class ;
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
static void do_request_tcpip_forward_command_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct request_tcpip_forward_command *i ;

  {
  {
#line 86
  i = (struct request_tcpip_forward_command *)o;
  {
#line 87
  (*mark)((struct lsh_object *)i->callback);
  }
  {
#line 88
  (*mark)((struct lsh_object *)i->port);
  }
  }
#line 89
  return;
}
}
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
struct lsh_class request_tcpip_forward_command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & global_request_command_class, (char *)"request_tcpip_forward_command",
    (size_t )sizeof(struct request_tcpip_forward_command ), & do_request_tcpip_forward_command_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
static struct command *forward_local_port(struct address_info *local , struct address_info *target ) 
{ 
  struct command *res ;
  struct lsh_object *tmp ;
  struct command *tmp___0 ;
  struct lsh_object *tmp___1 ;
  struct command *tmp___2 ;
  struct command *tmp___3 ;
  struct command *tmp___4 ;
  struct command *tmp___5 ;
  struct command *tmp___6 ;

  {
  {
  {
#line 131
  tmp = gaba_apply(& command_K.super.super, (struct lsh_object *)local);
  }
  {
#line 131
  tmp___0 = make_command_3_invoke_2(& command_B, & bind_address_command.super, tmp);
  }
  {
#line 131
  tmp___1 = gaba_apply(& open_direct_tcpip.super.super, (struct lsh_object *)target);
  }
  {
#line 131
  tmp___2 = make_command_4_invoke_2(& command_Cp, & catch_channel_open.super.super,
                                    tmp___1);
  }
  {
#line 131
  tmp___3 = make_command_3_invoke(& command_B, & start_io_command.super);
  }
  {
#line 131
  tmp___4 = make_command_4_invoke_3(& command_Bp, & listen_command.super.super, (struct lsh_object *)tmp___3,
                                    (struct lsh_object *)tmp___2);
  }
  {
#line 131
  tmp___5 = make_command_3_invoke_2(& command_S, (struct lsh_object *)tmp___4, (struct lsh_object *)tmp___0);
  }
  {
#line 131
  tmp___6 = make_command_3_invoke_2(& command_S, & connection_remember.super.super,
                                    (struct lsh_object *)tmp___5);
  }
#line 131
  res = (struct command *)((struct lsh_object *)tmp___6);
  }
#line 142
  return (res);
}
}
#line 170 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
static struct command *forward_remote_port(struct command *connect___0 , struct address_info *remote ) 
{ 
  struct command *res ;
  struct command *tmp ;
  struct command *tmp___0 ;
  struct command *tmp___1 ;
  struct command *tmp___2 ;

  {
  {
  {
#line 200
  tmp = make_command_4_invoke_2(& command_Bp, & tcpip_connect_io_command.super, (struct lsh_object *)connect___0);
  }
  {
#line 200
  tmp___0 = make_command_4_invoke_3(& command_Bp, & remote_listen_command.super.super,
                                    (struct lsh_object *)tmp, & command_K.super.super);
  }
  {
#line 200
  tmp___1 = make_command_3_invoke_2(& command_C, (struct lsh_object *)tmp___0, (struct lsh_object *)remote);
  }
  {
#line 200
  tmp___2 = make_command_3_invoke_2(& command_S, (struct lsh_object *)tmp___1, & command_I.super);
  }
#line 200
  res = (struct command *)((struct lsh_object *)tmp___2);
  }
#line 208
  return (res);
}
}
#line 236 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
static struct command *direct_tcpip_hook(void) 
{ 
  struct command *res ;
  struct command *tmp ;
  struct command *tmp___0 ;
  struct command *tmp___1 ;

  {
  {
  {
#line 265
  tmp = make_command_3_invoke(& command_B, & tcpip_connect_io_command.super);
  }
  {
#line 265
  tmp___0 = make_command_4_invoke_3(& command_Bp, & make_direct_tcpip_handler.super,
                                    (struct lsh_object *)tmp, & connect_connection_command.super.super);
  }
  {
#line 265
  tmp___1 = make_command_3_invoke_2(& command_S, & install_direct_tcpip_handler.super.super.super,
                                    (struct lsh_object *)tmp___0);
  }
#line 265
  res = (struct command *)((struct lsh_object *)tmp___1);
  }
#line 271
  return (res);
}
}
#line 299 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c.x"
static struct command *tcpip_forward_hook(void) 
{ 
  struct command *res ;
  struct command *tmp ;
  struct command *tmp___0 ;
  struct command *tmp___1 ;
  struct command *tmp___2 ;
  struct command *tmp___3 ;
  struct command *tmp___4 ;
  struct command *tmp___5 ;
  struct command *tmp___6 ;

  {
  {
  {
#line 328
  tmp = make_command_4_invoke(& command_Cp, & catch_channel_open.super.super);
  }
  {
#line 328
  tmp___0 = make_command_4_invoke_2(& command_Cp, (struct lsh_object *)tmp, & open_forwarded_tcpip.super.super);
  }
  {
#line 328
  tmp___1 = make_command_3_invoke(& command_B, & start_io_command.super);
  }
  {
#line 328
  tmp___2 = make_command_4_invoke_2(& command_Bp, & listen_command.super.super, (struct lsh_object *)tmp___1);
  }
  {
#line 328
  tmp___3 = make_command_4_invoke_3(& command_Bp, & command_S.super.super, (struct lsh_object *)tmp___2,
                                    (struct lsh_object *)tmp___0);
  }
  {
#line 328
  tmp___4 = make_command_3_invoke_2(& command_C, (struct lsh_object *)tmp___3, & bind_address_command.super);
  }
  {
#line 328
  tmp___5 = make_command_3_invoke_2(& command_B, & make_tcpip_forward_handler.super,
                                    (struct lsh_object *)tmp___4);
  }
  {
#line 328
  tmp___6 = make_command_3_invoke_2(& command_S, & install_tcpip_forward_handler.super.super.super,
                                    (struct lsh_object *)tmp___5);
  }
#line 328
  res = (struct command *)((struct lsh_object *)tmp___6);
  }
#line 338
  return (res);
}
}
#line 84 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
static void do_tcpip_connect_io_command(struct command *ignored  __attribute__((__unused__)) ,
                                        struct lsh_object *x , struct command_continuation *c ,
                                        struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 84 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
struct command tcpip_connect_io_command  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_tcpip_connect_io_command};
#line 84 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
static void do_tcpip_connect_io_command(struct command *ignored  __attribute__((__unused__)) ,
                                        struct lsh_object *x , struct command_continuation *c ,
                                        struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct listen_value *lv ;
  struct channel_forward *tmp ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 90
  lv = (struct listen_value *)x;
#line 92
  if (! lv) {
    {
    {
#line 92
    __assert_fail("lv", "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c",
                  92U, "do_tcpip_connect_io_command");
    }
    }
  }
#line 93
  if (! lv->fd) {
    {
    {
#line 93
    __assert_fail("lv->fd", "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c",
                  93U, "do_tcpip_connect_io_command");
    }
    }
  }
  {
  {
#line 95
  tmp = make_channel_forward(lv->fd, (uint32_t )10000);
  }
  {
#line 95
  (*(c->c))(c, (struct lsh_object *)tmp);
  }
  }
#line 96
  return;
}
}
#line 123 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
static struct ssh_channel *new_tcpip_channel(struct channel_open_command *c , struct ssh_connection *connection ,
                                             uint32_t local_channel_number , struct lsh_string **request ) 
{ 
  struct open_tcpip_command *self ;
  struct ssh_channel *channel ;
  struct channel_forward *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 129
  self = (struct open_tcpip_command *)c;
  {
#line 136
  debug("tcpforward_commands.c: new_tcpip_channel\n");
  }
  {
#line 138
  tmp = make_channel_forward((self->peer)->fd, (uint32_t )10000);
  }
#line 138
  channel = & tmp->super;
#line 139
  channel->connection = connection;
  {
#line 141
  *request = format_channel_open(self->type, local_channel_number, channel, "%S%i%S%i",
                                 (self->port)->ip, (self->port)->port, ((self->peer)->peer)->ip,
                                 ((self->peer)->peer)->port);
  }
  }
#line 147
  return (channel);
}
}
#line 150 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
struct command *make_open_tcpip_command(int type , struct address_info *port , struct listen_value *peer ) 
{ 
  struct open_tcpip_command *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 155
  tmp = lsh_object_alloc(& open_tcpip_command_class);
  }
#line 155
  self = (struct open_tcpip_command *)tmp;
  {
#line 157
  debug("tcpforward_commands.c: make_open_tcpip_command\n");
  }
#line 159
  self->super.super.call = & do_channel_open_command;
#line 160
  self->super.new_channel = & new_tcpip_channel;
#line 162
  self->type = type;
#line 164
  self->port = port;
#line 165
  self->peer = peer;
  }
#line 167
  return (& self->super.super);
}
}
#line 170
static void do_open_forwarded_tcpip(struct command_2 *s  __attribute__((__unused__)) ,
                                    struct lsh_object *a1 , struct lsh_object *a2 ,
                                    struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 170 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
struct command_2 open_forwarded_tcpip  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_2}, & do_open_forwarded_tcpip};
#line 170 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
static void do_open_forwarded_tcpip(struct command_2 *s  __attribute__((__unused__)) ,
                                    struct lsh_object *a1 , struct lsh_object *a2 ,
                                    struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct address_info *local ;
  struct listen_value *peer ;
  struct command *tmp ;

  {
  {
#line 177
  local = (struct address_info *)a1;
#line 178
  peer = (struct listen_value *)a2;
  {
#line 180
  tmp = make_open_tcpip_command(69, local, peer);
  }
  {
#line 180
  (*(c->c))(c, (struct lsh_object *)tmp);
  }
  }
#line 183
  return;
}
}
#line 185
static void do_open_direct_tcpip(struct command_2 *s  __attribute__((__unused__)) ,
                                 struct lsh_object *a1 , struct lsh_object *a2 , struct command_continuation *c ,
                                 struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 185 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
struct command_2 open_direct_tcpip  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_2}, & do_open_direct_tcpip};
#line 185 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
static void do_open_direct_tcpip(struct command_2 *s  __attribute__((__unused__)) ,
                                 struct lsh_object *a1 , struct lsh_object *a2 , struct command_continuation *c ,
                                 struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct address_info *target ;
  struct listen_value *peer ;
  struct command *tmp ;

  {
  {
#line 192
  target = (struct address_info *)a1;
#line 193
  peer = (struct listen_value *)a2;
  {
#line 195
  tmp = make_open_tcpip_command(70, target, peer);
  }
  {
#line 195
  (*(c->c))(c, (struct lsh_object *)tmp);
  }
  }
#line 198
  return;
}
}
#line 212 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
static void do_remote_port_install_continuation(struct command_continuation *s , struct lsh_object *x ) 
{ 
  struct remote_port_install_continuation *self ;
  struct ssh_connection *connection ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 216
  self = (struct remote_port_install_continuation *)s;
#line 217
  connection = (struct ssh_connection *)x;
#line 219
  if (! connection) {
    {
    {
#line 219
    __assert_fail("connection", "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c",
                  219U, "do_remote_port_install_continuation");
    }
    }
  }
  {
  {
#line 221
  debug("tcpforward_commands.c: do_remote_port_install_continuation, success.\n");
  }
#line 222
  (self->port)->callback = self->callback;
  {
#line 224
  (*((self->super.up)->c))(self->super.up, x);
  }
  }
#line 225
  return;
}
}
#line 227 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
static struct command_continuation *make_remote_port_install_continuation(struct remote_port *port ,
                                                                          struct command *callback ,
                                                                          struct command_continuation *c ) 
{ 
  struct remote_port_install_continuation *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 232
  tmp = lsh_object_alloc(& remote_port_install_continuation_class);
  }
#line 232
  self = (struct remote_port_install_continuation *)tmp;
  {
#line 234
  debug("tcpforward_commands.c: make_remote_port_install_continuation\n");
  }
#line 236
  self->super.super.c = & do_remote_port_install_continuation;
#line 237
  self->super.up = c;
#line 239
  self->port = port;
#line 240
  self->callback = callback;
  }
#line 242
  return (& self->super.super);
}
}
#line 265 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
static struct lsh_string *do_format_request_tcpip_forward(struct global_request_command *s ,
                                                          struct ssh_connection *connection ,
                                                          struct command_continuation **c ) 
{ 
  struct request_tcpip_forward_command *self ;
  struct remote_port *port ;
  int want_reply ;
  struct lsh_string *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 270
  self = (struct request_tcpip_forward_command *)s;
  {
#line 274
  debug("tcpforward_commands.c: do_format_request_tcpip_forward\n");
  }
  }
#line 276
  if ((unsigned long )*c != (unsigned long )(& discard_continuation)) {
    {
    {
#line 280
    port = make_remote_port(self->port, (struct command *)((void *)0));
    }
    {
#line 281
    *c = make_remote_port_install_continuation(port, self->callback, *c);
    }
#line 282
    want_reply = 1;
    }
  } else {
    {
    {
#line 286
    port = make_remote_port(self->port, self->callback);
    }
#line 287
    want_reply = 0;
    }
  }
  {
  {
#line 290
  object_queue_add_tail(& (connection->table)->remote_ports, & port->super.super);
  }
  {
#line 293
  tmp = format_global_request(67, want_reply, "%S%i", (self->port)->ip, (self->port)->port);
  }
  }
#line 293
  return (tmp);
}
}
#line 298
static void do_remote_listen_command(struct command_2 *s  __attribute__((__unused__)) ,
                                     struct lsh_object *a1 , struct lsh_object *a2 ,
                                     struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 298 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
struct command_2 remote_listen_command  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_2}, & do_remote_listen_command};
#line 298 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
static void do_remote_listen_command(struct command_2 *s  __attribute__((__unused__)) ,
                                     struct lsh_object *a1 , struct lsh_object *a2 ,
                                     struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct command *callback ;
  struct address_info *port ;
  struct request_tcpip_forward_command *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 305
  trace("remote_listen_command\n");
  }
#line 308
  callback = (struct command *)a1;
#line 309
  port = (struct address_info *)a2;
  {
#line 311
  tmp = lsh_object_alloc(& request_tcpip_forward_command_class);
  }
#line 311
  self = (struct request_tcpip_forward_command *)tmp;
#line 313
  self->super.super.call = & do_channel_global_command;
#line 314
  self->super.format_request = & do_format_request_tcpip_forward;
#line 316
  self->callback = callback;
#line 317
  self->port = port;
  {
#line 319
  (*(c->c))(c, (struct lsh_object *)self);
  }
  }
#line 321
  return;
}
}
#line 351 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
struct command *make_forward_local_port(struct address_info *local , struct address_info *target ) 
{ 
  struct command *res ;
  struct command *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 355
  tmp = forward_local_port(local, target);
  }
#line 355
  res = tmp;
  {
#line 358
  trace("tcpforward_commands.c: forward_local_port\n");
  }
  }
#line 360
  return (res);
}
}
#line 382 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
struct command *make_forward_remote_port(struct address_info *remote , struct address_info *target ) 
{ 
  struct command *res ;
  struct command *tmp ;
  struct command *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 386
  tmp = make_connect_port(target);
  }
  {
#line 386
  tmp___0 = forward_remote_port(tmp, remote);
  }
#line 386
  res = tmp___0;
  {
#line 389
  debug("tcpforward_commands.c: forward_remote_port\n");
  }
  }
#line 391
  return (res);
}
}
#line 396
static void do_make_direct_tcpip_handler(struct command *s  __attribute__((__unused__)) ,
                                         struct lsh_object *x , struct command_continuation *c ,
                                         struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 396 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
struct command make_direct_tcpip_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_make_direct_tcpip_handler};
#line 396 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
static void do_make_direct_tcpip_handler(struct command *s  __attribute__((__unused__)) ,
                                         struct lsh_object *x , struct command_continuation *c ,
                                         struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct command *callback ;
  struct channel_open *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 402
  callback = (struct command *)x;
  {
#line 404
  trace("tcpforward_commands.c: do_make_open_tcp_handler\n");
  }
  {
#line 406
  tmp = make_channel_open_direct_tcpip(callback);
  }
  {
#line 406
  (*(c->c))(c, & tmp->super);
  }
  }
#line 408
  return;
}
}
#line 412
static void do_make_tcpip_forward_handler(struct command *s  __attribute__((__unused__)) ,
                                          struct lsh_object *x , struct command_continuation *c ,
                                          struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 412 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
struct command make_tcpip_forward_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_make_tcpip_forward_handler};
#line 412 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
static void do_make_tcpip_forward_handler(struct command *s  __attribute__((__unused__)) ,
                                          struct lsh_object *x , struct command_continuation *c ,
                                          struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct command *callback ;
  struct global_request *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 418
  callback = (struct command *)x;
  {
#line 420
  debug("tcpforward_commands.c: make_tcpip_forward_handler\n");
  }
  {
#line 422
  tmp = make_tcpip_forward_request(callback);
  }
  {
#line 422
  (*(c->c))(c, & tmp->super);
  }
  }
#line 424
  return;
}
}
#line 427 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
static struct install_info install_direct_tcpip_handler  =    {{{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
       (char)0, (char)0}, & do_command_2}, & do_install_channel_open_handler}, 70};
#line 444 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
struct command *make_direct_tcpip_hook(void) 
{ 
  struct command *res ;
  struct command *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 447
  tmp = direct_tcpip_hook();
  }
#line 447
  res = tmp;
  {
#line 450
  debug("tcpforward_commands.c: make_direct_tcpip_hook\n");
  }
  }
#line 452
  return (res);
}
}
#line 455 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
static struct install_info install_tcpip_forward_handler  =    {{{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
       (char)0, (char)0}, & do_command_2}, & do_install_global_request_handler}, 67};
#line 481 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward_commands.c"
struct command *make_tcpip_forward_hook(void) 
{ 
  struct command *res ;
  struct command *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 484
  tmp = tcpip_forward_hook();
  }
#line 484
  res = tmp;
  {
#line 486
  debug("tcpforward_commands.c: tcpip_forward_hook\n");
  }
  }
#line 488
  return (res);
}
}
#line 163 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h"
struct exception *make_simple_exception(uint32_t type , char const   *msg ) ;
#line 167
struct exception_handler *make_exception_handler(void (*raise___0)(struct exception_handler *s ,
                                                                   struct exception  const  *x ) ,
                                                 struct exception_handler *parent ,
                                                 char const   *context ) ;
#line 186
struct exception *make_protocol_exception(uint32_t reason , char const   *msg ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct lsh_class command_continuation_class ;
#line 68 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h"
void lsh_queue_remove(struct lsh_queue_node *n ) ;
#line 97
void object_queue_add_head(struct object_queue *q , struct lsh_object *o ) ;
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.h"
void remember_resource(struct resource_list *self , struct resource *resource ) ;
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.h"
int parse_string(struct simple_buffer *buffer , uint32_t *length , uint8_t const   **start ) ;
#line 62
struct lsh_string *parse_string_copy(struct simple_buffer *buffer ) ;
#line 112
int parse_eod(struct simple_buffer *buffer ) ;
#line 148 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct lsh_class global_request_class ;
#line 196
struct lsh_class channel_open_class ;
#line 277 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h"
struct exception *make_channel_open_exception(uint32_t error_code , char const   *msg ) ;
#line 258 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
struct address_info *make_address_info(struct lsh_string *host , uint32_t port ) ;
#line 374
void close_fd(struct lsh_fd *fd ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.h.x"
struct lsh_class forwarded_port_class ;
#line 41
struct lsh_class local_port_class ;
#line 72
struct lsh_class remote_port_class ;
#line 76 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.h"
struct channel_open channel_open_forwarded_tcpip ;
#line 81
struct global_request tcpip_cancel_forward ;
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.h"
void channel_forward_start_io(struct channel_forward *channel ) ;
#line 88 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
int lsh_string_eq_l(struct lsh_string  const  *a , uint32_t length , uint8_t const   *b ) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.h.x"
static void do_forwarded_port_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct forwarded_port *i ;

  {
  {
#line 18
  i = (struct forwarded_port *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->listen);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.h.x"
struct lsh_class forwarded_port_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"forwarded_port", (size_t )sizeof(struct forwarded_port ),
    & do_forwarded_port_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.h.x"
static void do_local_port_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct local_port *i ;

  {
  {
#line 49
  i = (struct local_port *)o;
  {
#line 50
  (*mark)((struct lsh_object *)i->socket);
  }
  }
#line 51
  return;
}
}
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.h.x"
struct lsh_class local_port_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & forwarded_port_class, (char *)"local_port", (size_t )sizeof(struct local_port ),
    & do_local_port_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 76 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.h.x"
static void do_remote_port_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct remote_port *i ;

  {
  {
#line 80
  i = (struct remote_port *)o;
  {
#line 81
  (*mark)((struct lsh_object *)i->callback);
  }
  }
#line 82
  return;
}
}
#line 83 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.h.x"
struct lsh_class remote_port_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & forwarded_port_class, (char *)"remote_port", (size_t )sizeof(struct remote_port ),
    & do_remote_port_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
struct lsh_class open_forwarded_tcpip_continuation_class ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
static void do_open_forwarded_tcpip_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct open_forwarded_tcpip_continuation *i ;

  {
  {
#line 19
  i = (struct open_forwarded_tcpip_continuation *)o;
  {
#line 20
  (*mark)((struct lsh_object *)i->up);
  }
  {
#line 21
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 22
  return;
}
}
#line 23 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
struct lsh_class open_forwarded_tcpip_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"open_forwarded_tcpip_continuation",
    (size_t )sizeof(struct open_forwarded_tcpip_continuation ), & do_open_forwarded_tcpip_continuation_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 43
struct lsh_class channel_open_direct_tcpip_class ;
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
static void do_channel_open_direct_tcpip_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct channel_open_direct_tcpip *i ;

  {
  {
#line 51
  i = (struct channel_open_direct_tcpip *)o;
  {
#line 52
  (*mark)((struct lsh_object *)i->callback);
  }
  }
#line 53
  return;
}
}
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
struct lsh_class channel_open_direct_tcpip_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_open_class, (char *)"channel_open_direct_tcpip", (size_t )sizeof(struct channel_open_direct_tcpip ),
    & do_channel_open_direct_tcpip_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 76
struct lsh_class tcpip_forward_request_continuation_class ;
#line 80 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
static void do_tcpip_forward_request_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct tcpip_forward_request_continuation *i ;

  {
  {
#line 84
  i = (struct tcpip_forward_request_continuation *)o;
  {
#line 85
  (*mark)((struct lsh_object *)i->forward);
  }
  {
#line 86
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 87
  (*mark)((struct lsh_object *)i->c);
  }
  }
#line 88
  return;
}
}
#line 89 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
struct lsh_class tcpip_forward_request_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"tcpip_forward_request_continuation",
    (size_t )sizeof(struct tcpip_forward_request_continuation ), & do_tcpip_forward_request_continuation_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 110
struct lsh_class tcpip_forward_request_handler_class ;
#line 114 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
static void do_tcpip_forward_request_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct tcpip_forward_request_handler *i ;

  {
  {
#line 118
  i = (struct tcpip_forward_request_handler *)o;
  {
#line 119
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 120
  (*mark)((struct lsh_object *)i->forward);
  }
  }
#line 121
  return;
}
}
#line 122 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
struct lsh_class tcpip_forward_request_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"tcpip_forward_request_handler",
    (size_t )sizeof(struct tcpip_forward_request_handler ), & do_tcpip_forward_request_handler_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 142
struct lsh_class tcpip_forward_request_class ;
#line 146 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
static void do_tcpip_forward_request_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct tcpip_forward_request *i ;

  {
  {
#line 150
  i = (struct tcpip_forward_request *)o;
  {
#line 151
  (*mark)((struct lsh_object *)i->callback);
  }
  }
#line 152
  return;
}
}
#line 153 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c.x"
struct lsh_class tcpip_forward_request_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & global_request_class, (char *)"tcpip_forward_request", (size_t )sizeof(struct tcpip_forward_request ),
    & do_tcpip_forward_request_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static struct local_port *make_local_port(struct address_info *address , struct lsh_fd *socket___0 ) 
{ 
  struct local_port *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 54
  tmp = lsh_object_alloc(& local_port_class);
  }
#line 54
  self = (struct local_port *)tmp;
#line 56
  self->super.listen = address;
#line 57
  self->socket = socket___0;
  }
#line 58
  return (self);
}
}
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
struct remote_port *make_remote_port(struct address_info *listen___0 , struct command *callback ) 
{ 
  struct remote_port *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 65
  tmp = lsh_object_alloc(& remote_port_class);
  }
#line 65
  self = (struct remote_port *)tmp;
#line 67
  self->super.listen = listen___0;
#line 68
  self->callback = callback;
  }
#line 70
  return (self);
}
}
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static struct forwarded_port *lookup_forward(struct object_queue *q , uint32_t length ,
                                             uint8_t const   *ip , uint32_t port ) 
{ 
  struct lsh_queue_node *n_this ;
  struct lsh_queue_node *n_next ;
  struct lsh_object *n ;
  struct forwarded_port *f ;
  int tmp ;

  {
#line 77
  n_this = q->q.ht_links[0];
  {
  {
#line 77
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 77
    n = ((struct object_queue_node *)n_this)->o;
#line 77
    n_next = n_this->np_links[0];
#line 77
    if (! n_next) {
#line 77
      goto while_break;
    }
#line 79
    f = (struct forwarded_port *)n;
#line 81
    if (port == (f->listen)->port) {
      {
      {
#line 81
      tmp = lsh_string_eq_l((struct lsh_string  const  *)(f->listen)->ip, length,
                            ip);
      }
      }
#line 81
      if (tmp) {
#line 83
        return (f);
      }
    }
#line 77
    n_this = n_next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 85
  return ((struct forwarded_port *)((void *)0));
}
}
#line 88 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static struct local_port *remove_forward(struct object_queue *q , int null_ok , uint32_t length ,
                                         uint8_t const   *ip , uint32_t port ) 
{ 
  struct lsh_queue_node *n_this ;
  struct lsh_queue_node *n_next ;
  struct lsh_object *n ;
  struct local_port *f ;
  int tmp ;

  {
#line 92
  n_this = q->q.ht_links[0];
  {
  {
#line 92
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 92
    n = ((struct object_queue_node *)n_this)->o;
#line 92
    n_next = n_this->np_links[0];
#line 92
    if (! n_next) {
#line 92
      goto while_break;
    }
#line 94
    f = (struct local_port *)n;
#line 96
    if (port == (f->super.listen)->port) {
      {
      {
#line 96
      tmp = lsh_string_eq_l((struct lsh_string  const  *)(f->super.listen)->ip, length,
                            ip);
      }
      }
#line 96
      if (tmp) {
#line 99
        if (null_ok) {
#line 99
          goto _L;
        } else
#line 99
        if (f->socket) {
          _L: 
          {
          {
#line 101
          while (1) {
            while_continue___2: /* CIL Label */ ;
            while_continue___0: /* CIL Label */ ;
            {
#line 101
            (q->q.length) --;
            {
#line 101
            lsh_queue_remove(n_this);
            }
            }
#line 101
            goto while_break___0;
          }
          while_break___4: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
          while_break___0: ;
#line 102
          return (f);
        } else {
#line 104
          return ((struct local_port *)((void *)0));
        }
      }
    }
#line 92
    n_this = n_next;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 107
  return ((struct local_port *)((void *)0));
}
}
#line 116 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static void do_exc_tcip_connect_handler(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct exception *tmp ;

  {
#line 123
  if (e->type == 131073U) {
#line 123
    goto case_131073;
  }
#line 123
  if (e->type == 8193U) {
#line 123
    goto case_131073;
  }
#line 128
  goto switch_default;
  case_131073: 
  {
  {
#line 124
  tmp = make_channel_open_exception((uint32_t )2, (char const   *)e->msg);
  }
  {
#line 124
  (*((s->parent)->raise))(s->parent, (struct exception  const  *)tmp);
  }
  }
#line 127
  goto switch_break;
  switch_default: 
  {
  {
#line 129
  (*((s->parent)->raise))(s->parent, e);
  }
  }
  switch_break: ;
#line 131
  return;
}
}
#line 133 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static struct exception_handler *make_exc_tcpip_connect_handler(struct exception_handler *parent ,
                                                                char const   *context ) 
{ 
  struct exception_handler *tmp ;

  {
  {
  {
#line 137
  tmp = make_exception_handler(& do_exc_tcip_connect_handler, parent, context);
  }
  }
#line 137
  return (tmp);
}
}
#line 152 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static void do_open_forwarded_tcpip_continuation(struct command_continuation *s ,
                                                 struct lsh_object *x ) 
{ 
  struct open_forwarded_tcpip_continuation *self ;
  struct channel_forward *channel ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 156
  self = (struct open_forwarded_tcpip_continuation *)s;
#line 157
  channel = (struct channel_forward *)x;
#line 159
  if (! channel) {
    {
    {
#line 159
    __assert_fail("channel", "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c",
                  159U, "do_open_forwarded_tcpip_continuation");
    }
    }
  }
  {
  {
#line 161
  channel_forward_start_io(channel);
  }
  {
#line 163
  (*((self->up)->c))(self->up, (struct lsh_object *)channel);
  }
  }
#line 164
  return;
}
}
#line 166 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static struct command_continuation *make_open_forwarded_tcpip_continuation(struct ssh_connection *connection ,
                                                                           struct command_continuation *c ) 
{ 
  struct open_forwarded_tcpip_continuation *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 170
  tmp = lsh_object_alloc(& open_forwarded_tcpip_continuation_class);
  }
#line 170
  self = (struct open_forwarded_tcpip_continuation *)tmp;
#line 171
  self->super.c = & do_open_forwarded_tcpip_continuation;
#line 172
  self->up = c;
#line 173
  self->connection = connection;
  }
#line 175
  return (& self->super);
}
}
#line 187 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static void do_channel_open_direct_tcpip(struct channel_open *s , struct ssh_connection *connection ,
                                         struct channel_open_info *info  __attribute__((__unused__)) ,
                                         struct simple_buffer *args , struct command_continuation *c ,
                                         struct exception_handler *e ) 
{ 
  struct channel_open_direct_tcpip *closure ;
  struct lsh_string *dest_host ;
  uint32_t dest_port ;
  uint8_t const   *orig_host ;
  uint32_t orig_host_length ;
  uint32_t orig_port ;
  struct exception_handler *tmp ;
  struct command_continuation *tmp___0 ;
  struct address_info *tmp___1 ;
  struct exception *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 195
  closure = (struct channel_open_direct_tcpip *)s;
  {
#line 203
  dest_host = parse_string_copy(args);
  }
  }
#line 203
  if (dest_host) {
    {
    {
#line 203
    tmp___3 = parse_uint32(args, & dest_port);
    }
    }
#line 203
    if (tmp___3) {
      {
      {
#line 203
      tmp___4 = parse_string(args, & orig_host_length, & orig_host);
      }
      }
#line 203
      if (tmp___4) {
        {
        {
#line 203
        tmp___5 = parse_uint32(args, & orig_port);
        }
        }
#line 203
        if (tmp___5) {
          {
          {
#line 203
          tmp___6 = parse_eod(args);
          }
          }
#line 203
          if (tmp___6) {
            {
            {
#line 209
            werror("direct-tcp to %S:%i for user %S.\n", dest_host, dest_port, (connection->user)->name);
            }
            {
#line 212
            tmp = make_exc_tcpip_connect_handler(e, "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c:217");
            }
            {
#line 212
            tmp___0 = make_open_forwarded_tcpip_continuation(connection, c);
            }
            {
#line 212
            tmp___1 = make_address_info(dest_host, dest_port);
            }
            {
#line 212
            (*((closure->callback)->call))(closure->callback, (struct lsh_object *)tmp___1,
                                           tmp___0, tmp);
            }
            }
          } else {
            {
            {
#line 221
            lsh_string_free((struct lsh_string  const  *)dest_host);
            }
            {
#line 223
            werror("do_channel_open_direct_tcpip: Invalid message!\n");
            }
            {
#line 224
            tmp___2 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN direct-tcp message.");
            }
            {
#line 224
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___2);
            }
            }
          }
        } else {
          {
          {
#line 221
          lsh_string_free((struct lsh_string  const  *)dest_host);
          }
          {
#line 223
          werror("do_channel_open_direct_tcpip: Invalid message!\n");
          }
          {
#line 224
          tmp___2 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN direct-tcp message.");
          }
          {
#line 224
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___2);
          }
          }
        }
      } else {
        {
        {
#line 221
        lsh_string_free((struct lsh_string  const  *)dest_host);
        }
        {
#line 223
        werror("do_channel_open_direct_tcpip: Invalid message!\n");
        }
        {
#line 224
        tmp___2 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN direct-tcp message.");
        }
        {
#line 224
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___2);
        }
        }
      }
    } else {
      {
      {
#line 221
      lsh_string_free((struct lsh_string  const  *)dest_host);
      }
      {
#line 223
      werror("do_channel_open_direct_tcpip: Invalid message!\n");
      }
      {
#line 224
      tmp___2 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN direct-tcp message.");
      }
      {
#line 224
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___2);
      }
      }
    }
  } else {
    {
    {
#line 221
    lsh_string_free((struct lsh_string  const  *)dest_host);
    }
    {
#line 223
    werror("do_channel_open_direct_tcpip: Invalid message!\n");
    }
    {
#line 224
    tmp___2 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN direct-tcp message.");
    }
    {
#line 224
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___2);
    }
    }
  }
#line 226
  return;
}
}
#line 228 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
struct channel_open *make_channel_open_direct_tcpip(struct command *callback ) 
{ 
  struct channel_open_direct_tcpip *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 231
  tmp = lsh_object_alloc(& channel_open_direct_tcpip_class);
  }
#line 231
  self = (struct channel_open_direct_tcpip *)tmp;
#line 233
  self->super.handler = & do_channel_open_direct_tcpip;
#line 234
  self->callback = callback;
  }
#line 235
  return (& self->super);
}
}
#line 251 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static void do_tcpip_forward_request_continuation(struct command_continuation *c ,
                                                  struct lsh_object *x ) 
{ 
  struct tcpip_forward_request_continuation *self ;
  struct lsh_fd *fd ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 255
  self = (struct tcpip_forward_request_continuation *)c;
#line 256
  fd = (struct lsh_fd *)x;
  {
#line 258
  trace("do_tcpip_forward_request_continuation\n");
  }
  }
#line 259
  if (! self->forward) {
    {
    {
#line 259
    __assert_fail("self->forward", "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c",
                  259U, "do_tcpip_forward_request_continuation");
    }
    }
  }
#line 260
  if (! fd) {
    {
    {
#line 260
    __assert_fail("fd", "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c", 260U,
                  "do_tcpip_forward_request_continuation");
    }
    }
  }
  {
#line 262
  (self->forward)->socket = fd;
  {
#line 263
  remember_resource((self->connection)->resources, & fd->super);
  }
  {
#line 265
  (*((self->c)->c))(self->c, & (self->forward)->super.super);
  }
  }
#line 266
  return;
}
}
#line 268 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static struct command_continuation *make_tcpip_forward_request_continuation(struct local_port *forward ,
                                                                            struct ssh_connection *connection ,
                                                                            struct command_continuation *c ) 
{ 
  struct tcpip_forward_request_continuation *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 273
  tmp = lsh_object_alloc(& tcpip_forward_request_continuation_class);
  }
#line 273
  self = (struct tcpip_forward_request_continuation *)tmp;
  {
#line 275
  trace("make_tcpip_forward_request_continuation\n");
  }
#line 276
  self->forward = forward;
#line 277
  self->connection = connection;
#line 278
  self->c = c;
#line 280
  self->super.c = & do_tcpip_forward_request_continuation;
  }
#line 282
  return (& self->super);
}
}
#line 294 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static void do_tcpip_forward_request_exc(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct tcpip_forward_request_handler *self ;
  struct local_port *port ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct local_port *tmp___1 ;
  struct exception *tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 298
  self = (struct tcpip_forward_request_handler *)s;
#line 303
  if (e->type == 131073U) {
#line 303
    goto case_131073;
  }
#line 303
  if (e->type == 8201U) {
#line 303
    goto case_131073;
  }
#line 317
  goto switch_default;
  case_131073: 
  {
  {
#line 305
  tmp = lsh_string_data((struct lsh_string  const  *)((self->forward)->super.listen)->ip);
  }
  {
#line 305
  tmp___0 = lsh_string_length((struct lsh_string  const  *)((self->forward)->super.listen)->ip);
  }
  {
#line 305
  tmp___1 = remove_forward(& ((self->connection)->table)->local_ports, 1, tmp___0,
                           tmp, ((self->forward)->super.listen)->port);
  }
#line 305
  port = tmp___1;
  }
#line 310
  if (! port) {
    {
    {
#line 310
    __assert_fail("port", "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c",
                  310U, "do_tcpip_forward_request_exc");
    }
    }
  }
#line 311
  if (! ((unsigned long )port == (unsigned long )self->forward)) {
    {
    {
#line 311
    __assert_fail("port == self->forward", "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c",
                  311U, "do_tcpip_forward_request_exc");
    }
    }
  }
  {
  {
#line 312
  tmp___2 = make_simple_exception((uint32_t )32769, (char const   *)e->msg);
  }
  {
#line 312
  (*((s->parent)->raise))(s->parent, (struct exception  const  *)tmp___2);
  }
  }
#line 315
  goto switch_break;
  switch_default: 
#line 318
  if (e->type & 8192U) {
    {
    {
#line 320
    werror("I/O error on forwarded connection: %z\n", e->msg);
    }
    }
  } else {
    {
    {
#line 324
    (*((self->super.parent)->raise))(self->super.parent, e);
    }
    }
  }
  switch_break: ;
#line 326
  return;
}
}
#line 328 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static struct exception_handler *make_tcpip_forward_request_exc(struct ssh_connection *connection ,
                                                                struct local_port *forward ,
                                                                struct exception_handler *parent ,
                                                                char const   *context ) 
{ 
  struct tcpip_forward_request_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 334
  tmp = lsh_object_alloc(& tcpip_forward_request_handler_class);
  }
#line 334
  self = (struct tcpip_forward_request_handler *)tmp;
#line 335
  self->super.raise = & do_tcpip_forward_request_exc;
#line 336
  self->super.parent = parent;
#line 337
  self->super.context = context;
#line 339
  self->connection = connection;
#line 340
  self->forward = forward;
  }
#line 342
  return (& self->super);
}
}
#line 388
static void do_tcpip_forward_request(struct global_request *s , struct ssh_connection *connection ,
                                     uint32_t type  __attribute__((__unused__)) ,
                                     int want_reply  __attribute__((__unused__)) ,
                                     struct simple_buffer *args , struct command_continuation *c ,
                                     struct exception_handler *e ) ;
#line 388 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static struct exception  const  again  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )32769, "An already requested tcp-forward requested again"};
#line 358 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static void do_tcpip_forward_request(struct global_request *s , struct ssh_connection *connection ,
                                     uint32_t type  __attribute__((__unused__)) ,
                                     int want_reply  __attribute__((__unused__)) ,
                                     struct simple_buffer *args , struct command_continuation *c ,
                                     struct exception_handler *e ) 
{ 
  struct tcpip_forward_request *self ;
  struct lsh_string *bind_host ;
  uint32_t bind_port ;
  struct address_info *a ;
  struct address_info *tmp ;
  struct local_port *forward ;
  uint8_t const   *tmp___0 ;
  uint32_t tmp___1 ;
  struct forwarded_port *tmp___2 ;
  struct exception_handler *tmp___3 ;
  struct command_continuation *tmp___4 ;
  struct exception *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
  {
#line 367
  self = (struct tcpip_forward_request *)s;
  {
#line 371
  bind_host = parse_string_copy(args);
  }
  }
#line 371
  if (bind_host) {
    {
    {
#line 371
    tmp___6 = parse_uint32(args, & bind_port);
    }
    }
#line 371
    if (tmp___6) {
      {
      {
#line 371
      tmp___7 = parse_eod(args);
      }
      }
#line 371
      if (tmp___7) {
        {
        {
#line 375
        tmp = make_address_info(bind_host, bind_port);
        }
#line 375
        a = tmp;
        }
#line 378
        if (bind_port < 1024U) {
          {
          {
#line 380
          werror("Denying forwarding of privileged port %i.\n", bind_port);
          }
          {
#line 381
          (*(c->c))(c, (struct lsh_object *)((void *)0));
          }
          }
#line 382
          return;
        }
        {
        {
#line 385
        tmp___0 = lsh_string_data((struct lsh_string  const  *)bind_host);
        }
        {
#line 385
        tmp___1 = lsh_string_length((struct lsh_string  const  *)bind_host);
        }
        {
#line 385
        tmp___2 = lookup_forward(& (connection->table)->local_ports, tmp___1, tmp___0,
                                 bind_port);
        }
        }
#line 385
        if (tmp___2) {
          {
          {
#line 391
          verbose("An already requested tcp-forward requested again\n");
          }
          {
#line 392
          (*(e->raise))(e, & again);
          }
          }
#line 393
          return;
        }
        {
        {
#line 396
        werror("forward-tcpip request for port %i by user %S.\n", bind_port, (connection->user)->name);
        }
        {
#line 399
        forward = make_local_port(a, (struct lsh_fd *)((void *)0));
        }
        {
#line 400
        object_queue_add_head(& (connection->table)->local_ports, & forward->super.super);
        }
        {
#line 404
        tmp___3 = make_tcpip_forward_request_exc(connection, forward, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c:410");
        }
        {
#line 404
        tmp___4 = make_tcpip_forward_request_continuation(forward, connection, c);
        }
        {
#line 404
        (*((self->callback)->call))(self->callback, (struct lsh_object *)a, tmp___4,
                                    tmp___3);
        }
        }
#line 412
        return;
      } else {
        {
        {
#line 417
        werror("Incorrectly formatted tcpip-forward request\n");
        }
        {
#line 418
        tmp___5 = make_protocol_exception((uint32_t )2, "Invalid tcpip-forward message.");
        }
        {
#line 418
        (*(e->raise))(e, (struct exception  const  *)tmp___5);
        }
        }
      }
    } else {
      {
      {
#line 417
      werror("Incorrectly formatted tcpip-forward request\n");
      }
      {
#line 418
      tmp___5 = make_protocol_exception((uint32_t )2, "Invalid tcpip-forward message.");
      }
      {
#line 418
      (*(e->raise))(e, (struct exception  const  *)tmp___5);
      }
      }
    }
  } else {
    {
    {
#line 417
    werror("Incorrectly formatted tcpip-forward request\n");
    }
    {
#line 418
    tmp___5 = make_protocol_exception((uint32_t )2, "Invalid tcpip-forward message.");
    }
    {
#line 418
    (*(e->raise))(e, (struct exception  const  *)tmp___5);
    }
    }
  }
#line 420
  return;
}
}
#line 422 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
struct global_request *make_tcpip_forward_request(struct command *callback ) 
{ 
  struct tcpip_forward_request *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 424
  tmp = lsh_object_alloc(& tcpip_forward_request_class);
  }
#line 424
  self = (struct tcpip_forward_request *)tmp;
#line 426
  self->super.handler = & do_tcpip_forward_request;
#line 427
  self->callback = callback;
  }
#line 429
  return (& self->super);
}
}
#line 474
static void do_tcpip_cancel_forward(struct global_request *s  __attribute__((__unused__)) ,
                                    struct ssh_connection *connection , uint32_t type  __attribute__((__unused__)) ,
                                    int want_reply  __attribute__((__unused__)) ,
                                    struct simple_buffer *args , struct command_continuation *c ,
                                    struct exception_handler *e ) ;
#line 474 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static struct exception  const  notfound  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )32769, "Could not find tcpip-forward to cancel"};
#line 432 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static void do_tcpip_cancel_forward(struct global_request *s  __attribute__((__unused__)) ,
                                    struct ssh_connection *connection , uint32_t type  __attribute__((__unused__)) ,
                                    int want_reply  __attribute__((__unused__)) ,
                                    struct simple_buffer *args , struct command_continuation *c ,
                                    struct exception_handler *e ) 
{ 
  uint32_t bind_host_length ;
  uint8_t const   *bind_host ;
  uint32_t bind_port ;
  struct local_port *port ;
  struct local_port *tmp ;
  struct exception *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
  {
#line 445
  tmp___1 = parse_string(args, & bind_host_length, & bind_host);
  }
  }
#line 445
  if (tmp___1) {
    {
    {
#line 445
    tmp___2 = parse_uint32(args, & bind_port);
    }
    }
#line 445
    if (tmp___2) {
      {
      {
#line 445
      tmp___3 = parse_eod(args);
      }
      }
#line 445
      if (tmp___3) {
        {
        {
#line 455
        tmp = remove_forward(& (connection->table)->local_ports, 0, bind_host_length,
                             bind_host, bind_port);
        }
#line 455
        port = tmp;
        }
#line 461
        if (port) {
#line 463
          if (! port->socket) {
            {
            {
#line 463
            __assert_fail("port->socket", "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c",
                          463U, "do_tcpip_cancel_forward");
            }
            }
          }
          {
          {
#line 464
          verbose("Cancelling a requested tcpip-forward.\n");
          }
          {
#line 466
          close_fd(port->socket);
          }
#line 467
          port->socket = (struct lsh_fd *)((void *)0);
          {
#line 469
          (*(c->c))(c, (struct lsh_object *)((void *)0));
          }
          }
#line 470
          return;
        } else {
          {
          {
#line 476
          verbose("Could not find tcpip-forward to cancel\n");
          }
          {
#line 478
          (*(e->raise))(e, & notfound);
          }
          }
#line 479
          return;
        }
      } else {
        {
        {
#line 484
        werror("Incorrectly formatted cancel-tcpip-forward request\n");
        }
        {
#line 485
        tmp___0 = make_protocol_exception((uint32_t )2, "Invalid cancel-tcpip-forward message.");
        }
        {
#line 485
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___0);
        }
        }
      }
    } else {
      {
      {
#line 484
      werror("Incorrectly formatted cancel-tcpip-forward request\n");
      }
      {
#line 485
      tmp___0 = make_protocol_exception((uint32_t )2, "Invalid cancel-tcpip-forward message.");
      }
      {
#line 485
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___0);
      }
      }
    }
  } else {
    {
    {
#line 484
    werror("Incorrectly formatted cancel-tcpip-forward request\n");
    }
    {
#line 485
    tmp___0 = make_protocol_exception((uint32_t )2, "Invalid cancel-tcpip-forward message.");
    }
    {
#line 485
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___0);
    }
    }
  }
#line 487
  return;
}
}
#line 489 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
struct global_request tcpip_cancel_forward  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_tcpip_cancel_forward};
#line 495 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
static void do_channel_open_forwarded_tcpip(struct channel_open *s  __attribute__((__unused__)) ,
                                            struct ssh_connection *connection , struct channel_open_info *info  __attribute__((__unused__)) ,
                                            struct simple_buffer *args , struct command_continuation *c ,
                                            struct exception_handler *e ) 
{ 
  uint32_t listen_ip_length ;
  uint8_t const   *listen_ip ;
  uint32_t listen_port ;
  struct lsh_string *peer_host ;
  uint32_t peer_port ;
  struct remote_port *port ;
  struct forwarded_port *tmp ;
  struct exception_handler *tmp___0 ;
  struct command_continuation *tmp___1 ;
  struct address_info *tmp___2 ;
  struct exception *tmp___3 ;
  struct exception *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
  {
#line 506
  peer_host = (struct lsh_string *)((void *)0);
  {
#line 509
  tmp___5 = parse_string(args, & listen_ip_length, & listen_ip);
  }
  }
#line 509
  if (tmp___5) {
    {
    {
#line 509
    tmp___6 = parse_uint32(args, & listen_port);
    }
    }
#line 509
    if (tmp___6) {
      {
      {
#line 509
      peer_host = parse_string_copy(args);
      }
      }
#line 509
      if (peer_host) {
        {
        {
#line 509
        tmp___7 = parse_uint32(args, & peer_port);
        }
        }
#line 509
        if (tmp___7) {
          {
          {
#line 509
          tmp___8 = parse_eod(args);
          }
          }
#line 509
          if (tmp___8) {
            {
            {
#line 515
            tmp = lookup_forward(& (connection->table)->remote_ports, listen_ip_length,
                                 listen_ip, listen_port);
            }
#line 515
            port = (struct remote_port *)tmp;
            }
#line 519
            if (port) {
#line 519
              if (port->callback) {
                {
                {
#line 521
                tmp___0 = make_exc_tcpip_connect_handler(e, "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c:527");
                }
                {
#line 521
                tmp___1 = make_open_forwarded_tcpip_continuation(connection, c);
                }
                {
#line 521
                tmp___2 = make_address_info(peer_host, peer_port);
                }
                {
#line 521
                (*((port->callback)->call))(port->callback, (struct lsh_object *)tmp___2,
                                            tmp___1, tmp___0);
                }
                }
#line 528
                return;
              }
            }
            {
            {
#line 530
            werror("Received a forwarded-tcpip request on a port for which we\nhaven\'t requested forwarding. Denying.\n");
            }
            {
#line 533
            lsh_string_free((struct lsh_string  const  *)peer_host);
            }
            {
#line 534
            tmp___3 = make_channel_open_exception((uint32_t )1, "Unexpected tcpip-forward request");
            }
            {
#line 534
            (*(e->raise))(e, (struct exception  const  *)tmp___3);
            }
            }
#line 537
            return;
          } else {
            {
            {
#line 541
            werror("do_channel_open_forwarded_tcpip: Invalid message!\n");
            }
            {
#line 543
            lsh_string_free((struct lsh_string  const  *)peer_host);
            }
            {
#line 544
            tmp___4 = make_protocol_exception((uint32_t )2, "Invalid tcpip-forward message");
            }
            {
#line 544
            (*(e->raise))(e, (struct exception  const  *)tmp___4);
            }
            }
          }
        } else {
          {
          {
#line 541
          werror("do_channel_open_forwarded_tcpip: Invalid message!\n");
          }
          {
#line 543
          lsh_string_free((struct lsh_string  const  *)peer_host);
          }
          {
#line 544
          tmp___4 = make_protocol_exception((uint32_t )2, "Invalid tcpip-forward message");
          }
          {
#line 544
          (*(e->raise))(e, (struct exception  const  *)tmp___4);
          }
          }
        }
      } else {
        {
        {
#line 541
        werror("do_channel_open_forwarded_tcpip: Invalid message!\n");
        }
        {
#line 543
        lsh_string_free((struct lsh_string  const  *)peer_host);
        }
        {
#line 544
        tmp___4 = make_protocol_exception((uint32_t )2, "Invalid tcpip-forward message");
        }
        {
#line 544
        (*(e->raise))(e, (struct exception  const  *)tmp___4);
        }
        }
      }
    } else {
      {
      {
#line 541
      werror("do_channel_open_forwarded_tcpip: Invalid message!\n");
      }
      {
#line 543
      lsh_string_free((struct lsh_string  const  *)peer_host);
      }
      {
#line 544
      tmp___4 = make_protocol_exception((uint32_t )2, "Invalid tcpip-forward message");
      }
      {
#line 544
      (*(e->raise))(e, (struct exception  const  *)tmp___4);
      }
      }
    }
  } else {
    {
    {
#line 541
    werror("do_channel_open_forwarded_tcpip: Invalid message!\n");
    }
    {
#line 543
    lsh_string_free((struct lsh_string  const  *)peer_host);
    }
    {
#line 544
    tmp___4 = make_protocol_exception((uint32_t )2, "Invalid tcpip-forward message");
    }
    {
#line 544
    (*(e->raise))(e, (struct exception  const  *)tmp___4);
    }
    }
  }
#line 546
  return;
}
}
#line 548 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.c"
struct channel_open channel_open_forwarded_tcpip  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channel_open_forwarded_tcpip};
#line 222 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 266
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/suspend.h"
void suspend_install_handler(void) ;
#line 37
struct escape_callback suspend_callback ;
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/suspend.c"
static struct termios original_mode  ;
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/suspend.c"
static int tty_fd  =    -1;
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/suspend.c"
static void stop_handler(int signum ) 
{ 
  struct termios mine ;
  int need_tty_reset ;
  int stdin_flags ;
  int stdout_flags ;
  int stderr_flags ;
  int tmp ;
  __pid_t tmp___0 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 66
  if (! (signum == 20)) {
    {
    {
#line 66
    __assert_fail("signum == 20", "/home/ysko/Works/test-src/lsh-2.0.4/src/suspend.c",
                  66U, "stop_handler");
    }
    }
  }
  {
  {
#line 68
  stdin_flags = fcntl(0, 3);
  }
  {
#line 69
  stdout_flags = fcntl(1, 3);
  }
  {
#line 70
  stderr_flags = fcntl(2, 3);
  }
  }
#line 72
  if (tty_fd > 0) {
    {
    {
#line 72
    tmp = tty_getattr(tty_fd, & mine);
    }
#line 72
    need_tty_reset = tmp;
    }
  } else {
#line 72
    need_tty_reset = 0;
  }
#line 74
  if (need_tty_reset) {
    {
    {
#line 75
    tty_setattr(tty_fd, & original_mode);
    }
    }
  }
  {
  {
#line 77
  tmp___0 = getpid();
  }
  {
#line 77
  kill(tmp___0, 19);
  }
  }
#line 79
  if (need_tty_reset) {
    {
    {
#line 80
    tty_setattr(tty_fd, & mine);
    }
    }
  }
#line 82
  if (stdin_flags >= 0) {
    {
    {
#line 83
    fcntl(0, 4, stdin_flags);
    }
    }
  }
#line 85
  if (stdout_flags >= 0) {
    {
    {
#line 86
    fcntl(1, 4, stdin_flags);
    }
    }
  }
#line 88
  if (stderr_flags >= 0) {
    {
    {
#line 89
    fcntl(2, 4, stdin_flags);
    }
    }
  }
#line 90
  return;
}
}
#line 92 "/home/ysko/Works/test-src/lsh-2.0.4/src/suspend.c"
void suspend_install_handler(void) 
{ 
  struct sigaction stop ;
  int *tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 97
  memset((void *)(& stop), 0, (size_t )sizeof(stop));
  }
#line 98
  stop.__sigaction_handler.sa_handler = & stop_handler;
  {
#line 99
  sigemptyset(& stop.sa_mask);
  }
#line 100
  stop.sa_flags = 0;
  {
#line 102
  tmp___0 = sigaction(20, (struct sigaction  const  */* __restrict  */)((struct sigaction  const  *)(& stop)),
                      (struct sigaction */* __restrict  */)((struct sigaction *)((void *)0)));
  }
  }
#line 102
  if (tmp___0 < 0) {
    {
    {
#line 103
    tmp = __errno_location();
    }
    {
#line 103
    werror("Failed to install SIGTSTP handler %e\n", *tmp);
    }
    }
  }
#line 104
  return;
}
}
#line 106 "/home/ysko/Works/test-src/lsh-2.0.4/src/suspend.c"
void suspend_handle_tty(int fd ) 
{ 
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 109
  tty_fd = fd;
  {
#line 111
  tmp___0 = tty_getattr(fd, & original_mode);
  }
  }
#line 111
  if (! tmp___0) {
    {
    {
#line 112
    tmp = __errno_location();
    }
    {
#line 112
    werror("install_suspend_handler: tty_getattr failed %e\n", *tmp);
    }
    }
  }
#line 113
  return;
}
}
#line 117
static void do_suspend_callback(struct lsh_callback *self  __attribute__((__unused__)) ) ;
#line 117 "/home/ysko/Works/test-src/lsh-2.0.4/src/suspend.c"
struct escape_callback suspend_callback  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_suspend_callback}, "Suspend."};
#line 117 "/home/ysko/Works/test-src/lsh-2.0.4/src/suspend.c"
static void do_suspend_callback(struct lsh_callback *self  __attribute__((__unused__)) ) 
{ 
  int *tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 119
  tmp___0 = getpid();
  }
  {
#line 119
  tmp___1 = kill(tmp___0, 20);
  }
  }
#line 119
  if (tmp___1 < 0) {
    {
    {
#line 120
    tmp = __errno_location();
    }
    {
#line 120
    werror("do_suspend: kill failed %e\n", *tmp);
    }
    }
  }
#line 121
  return;
}
}
#line 119 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
void lsh_string_write_string(struct lsh_string *s , uint32_t pos , struct lsh_string  const  *data ) ;
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/string_buffer.c"
void string_buffer_init(struct string_buffer *buffer , uint32_t guess ) 
{ 


  {
  {
  {
#line 50
  buffer->partial = lsh_string_alloc(guess);
  }
#line 51
  buffer->left = guess;
#line 52
  buffer->pos = (uint32_t )0;
#line 54
  buffer->tail = (struct string_node *)((void *)0);
#line 57
  buffer->total = (uint32_t )0;
  }
#line 58
  return;
}
}
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/string_buffer.c"
void string_buffer_clear(struct string_buffer *buffer ) 
{ 
  struct string_node *n ;
  struct string_node *old ;

  {
  {
  {
#line 65
  lsh_string_free((struct lsh_string  const  *)buffer->partial);
  }
#line 66
  n = buffer->tail;
  }
  {
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 66
    if (! n) {
#line 66
      goto while_break;
    }
    {
#line 68
    old = n;
#line 69
    n = old->prev;
    {
#line 71
    lsh_string_free((struct lsh_string  const  *)old->s);
    }
    {
#line 72
    lsh_space_free((void const   *)old);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 74
  return;
}
}
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/string_buffer.c"
void string_buffer_grow(struct string_buffer *buffer , uint32_t increment ) 
{ 
  struct string_node *n ;
  void *tmp ;
  uint32_t tmp___0 ;
  size_t size6 ;
  void *tmp7 ;
  void *ret_lsh_space_alloc8 ;

  {
  {
  {
#line 82
  size6 = (size_t )sizeof(*n);
  {
  {
  {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
  tmp7 = malloc(size6);
  }
  }
  {
#line 262
  ret_lsh_space_alloc8 = tmp7;
#line 262
  goto Lret_lsh_space_alloc;
  }
  }
  Lret_lsh_space_alloc: /* CIL Label */ 
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/string_buffer.c"
  tmp = ret_lsh_space_alloc8;
  }
#line 82
  n = (struct string_node *)tmp;
  {
#line 84
  tmp___0 = lsh_string_length((struct lsh_string  const  *)buffer->partial);
  }
#line 84
  buffer->total += tmp___0;
#line 86
  n->s = buffer->partial;
#line 87
  n->prev = buffer->tail;
#line 88
  buffer->tail = n;
  {
#line 90
  buffer->partial = lsh_string_alloc(increment);
  }
#line 91
  buffer->pos = (uint32_t )0;
#line 92
  buffer->left = increment;
  }
#line 93
  return;
}
}
#line 179 "/home/ysko/Works/test-src/lsh-2.0.4/src/string_buffer.c"
struct lsh_string *string_buffer_final(struct string_buffer *buffer , uint32_t left_over ) 
{ 
  uint32_t length ;
  uint32_t tmp ;
  uint32_t final ;
  struct lsh_string *res ;
  struct lsh_string *tmp___0 ;
  uint32_t p ;
  struct string_node *n ;
  uint8_t const   *tmp___1 ;
  struct string_node *old ;
  uint32_t tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 183
  tmp = lsh_string_length((struct lsh_string  const  *)buffer->partial);
  }
#line 183
  length = tmp - left_over;
#line 184
  final = buffer->total + length;
  }
#line 186
  if (! buffer->tail) {
    {
    {
#line 190
    lsh_string_trunc(buffer->partial, final);
    }
    }
#line 191
    return (buffer->partial);
  } else {
    {
    {
#line 195
    tmp___0 = lsh_string_alloc(final);
    }
#line 195
    res = tmp___0;
#line 196
    p = final;
#line 199
    p -= length;
    {
#line 200
    tmp___1 = lsh_string_data((struct lsh_string  const  *)buffer->partial);
    }
    {
#line 200
    lsh_string_write(res, p, length, tmp___1);
    }
    {
#line 201
    lsh_string_free((struct lsh_string  const  *)buffer->partial);
    }
#line 203
    n = buffer->tail;
    }
    {
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 203
      if (! n) {
#line 203
        goto while_break;
      }
      {
#line 205
      old = n;
#line 206
      n = n->prev;
      {
#line 209
      tmp___2 = lsh_string_length((struct lsh_string  const  *)old->s);
      }
#line 209
      p -= tmp___2;
      {
#line 211
      lsh_string_write_string(res, p, (struct lsh_string  const  *)old->s);
      }
      {
#line 213
      lsh_string_free((struct lsh_string  const  *)old->s);
      }
      {
#line 214
      lsh_space_free((void const   *)old);
      }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
#line 217
    if (! (p == 0U)) {
      {
      {
#line 217
      __assert_fail("p == 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/string_buffer.c",
                    217U, "string_buffer_final");
      }
      }
    }
#line 219
    return (res);
  }
}
}
#line 992 "/usr/include/gmp-i386.h"
extern void __gmpz_mul_ui(mpz_ptr  , mpz_srcptr  , unsigned long  ) ;
#line 211 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h"
struct lsh_string *hash_string(struct hash_algorithm  const  *a , struct lsh_string  const  *in ,
                               int free___0 ) ;
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.h"
int parse_bignum(struct simple_buffer *buffer , __mpz_struct *result , uint32_t limit ) ;
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h"
int zn_range(struct zn_group  const  *G , __mpz_struct * const  x ) ;
#line 68
void zn_mul(struct zn_group  const  *G , __mpz_struct *res , __mpz_struct * const  a ,
            __mpz_struct * const  b ) ;
#line 71
void zn_exp(struct zn_group  const  *G , __mpz_struct *res , __mpz_struct * const  g ,
            __mpz_struct * const  e ) ;
#line 74
void zn_exp_ui(struct zn_group  const  *G , __mpz_struct *res , __mpz_struct * const  g ,
               uint32_t e ) ;
#line 78
int zn_add(struct zn_group  const  *G , __mpz_struct *res , __mpz_struct * const  a ,
           __mpz_struct * const  b ) ;
#line 82
int zn_sub(struct zn_group  const  *G , __mpz_struct *res , __mpz_struct * const  a ,
           __mpz_struct * const  b ) ;
#line 92
struct zn_group  const  *make_ssh_ring_srp_1(void) ;
#line 134
void dh_hash_update(struct dh_instance *self , struct lsh_string *s , int free___0 ) ;
#line 160
void dh_generate_secret(struct dh_method  const  *self , __mpz_struct *r , __mpz_struct *v ) ;
#line 164
void dh_hash_digest(struct dh_instance *self ) ;
#line 167
struct dh_method *make_dh(struct zn_group  const  *G , struct hash_algorithm  const  *H ,
                          struct randomness *r ) ;
#line 12 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp.h.x"
struct lsh_class srp_entry_class ;
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp.h"
struct srp_entry *make_srp_entry(struct lsh_string  const  *name , struct lsh_string  const  *expr ) ;
#line 50
struct lsh_string *srp_make_verifier(struct zn_group  const  *G , struct hash_algorithm  const  *H ,
                                     struct lsh_string *salt , struct lsh_string *name ,
                                     struct lsh_string *passwd ) ;
#line 57
void srp_hash_password(__mpz_struct *x , struct hash_algorithm  const  *H , struct lsh_string *salt ,
                       struct lsh_string *name , struct lsh_string *passwd ) ;
#line 64
struct lsh_string *srp_make_init_msg(struct dh_instance *dh , struct lsh_string *name ) ;
#line 68
struct lsh_string *srp_process_init_msg(struct dh_instance *self , struct lsh_string *packet ) ;
#line 71
struct lsh_string *srp_make_reply_msg(struct dh_instance *dh , struct srp_entry *entry ) ;
#line 75
struct lsh_string *srp_process_reply_msg(struct dh_instance *dh , struct lsh_string *packet ) ;
#line 78
struct lsh_string *srp_make_client_proof(struct dh_instance *dh , struct lsh_string **m2 ,
                                         __mpz_struct *x ) ;
#line 83
struct lsh_string *srp_process_client_proof(struct dh_instance *dh , struct lsh_string *packet ) ;
#line 86
int srp_process_server_proof(struct lsh_string *m2 , struct lsh_string *packet ) ;
#line 90
struct dh_method *make_srp1(struct randomness *r ) ;
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.h"
struct hash_algorithm  const  crypto_sha1_algorithm ;
#line 41
struct mac_algorithm *make_hmac_algorithm(struct hash_algorithm  const  *h___0 ) ;
#line 183 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
struct lsh_string *lsh_string_format_sexp(int transport , char const   *format  , ...) ;
#line 16 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp.h.x"
static void do_srp_entry_free(struct lsh_object *o ) 
{ 
  struct srp_entry *i ;

  {
  {
#line 19
  i = (struct srp_entry *)o;
  {
#line 20
  lsh_string_free((struct lsh_string  const  *)i->name);
  }
  {
#line 21
  lsh_string_free((struct lsh_string  const  *)i->salt);
  }
  {
#line 22
  __gmpz_clear(i->verifier);
  }
  }
#line 23
  return;
}
}
#line 24 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp.h.x"
struct lsh_class srp_entry_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"srp_entry", (size_t )sizeof(struct srp_entry ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_srp_entry_free};
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c"
struct srp_entry *make_srp_entry(struct lsh_string  const  *name , struct lsh_string  const  *expr ) 
{ 
  struct sexp_iterator i ;
  struct srp_entry *res ;
  struct lsh_object *tmp ;
  struct lsh_string  const  *salt ;
  struct lsh_string *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  uint8_t const   *tmp___5 ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
  {
#line 67
  tmp___5 = lsh_string_data(expr);
  }
  {
#line 67
  tmp___6 = lsh_string_length(expr);
  }
  {
#line 67
  tmp___7 = nettle_sexp_iterator_first(& i, tmp___6, tmp___5);
  }
  }
#line 67
  if (tmp___7) {
    {
    {
#line 67
    tmp___8 = nettle_sexp_iterator_check_type(& i, (uint8_t const   *)"srp-verifier");
    }
    }
#line 67
    if (tmp___8) {
      {
      {
#line 67
      tmp___9 = nettle_sexp_iterator_check_type(& i, (uint8_t const   *)"ssh-ring1");
      }
      }
#line 67
      if (tmp___9) {
        {
        {
#line 71
        tmp = lsh_object_alloc(& srp_entry_class);
        }
#line 71
        res = (struct srp_entry *)tmp;
        {
#line 74
        __gmpz_init(res->verifier);
        }
        }
#line 76
        if ((unsigned int )i.type == 0U) {
#line 76
          if (! i.display) {
            {
            {
#line 77
            tmp___0 = ssh_format("%ls", i.atom_length, i.atom);
            }
#line 77
            salt = (struct lsh_string  const  *)tmp___0;
            }
          } else {
#line 78
            goto fail;
          }
        } else {
#line 78
          goto fail;
        }
        {
        {
#line 81
        tmp___1 = nettle_sexp_iterator_next(& i);
        }
        }
#line 81
        if (tmp___1) {
          {
          {
#line 81
          tmp___2 = nettle_mpz_set_sexp(res->verifier, 0U, & i);
          }
          }
#line 81
          if (tmp___2) {
#line 81
            if (res->verifier[0]._mp_size < 0) {
#line 81
              tmp___3 = -1;
            } else {
#line 81
              tmp___3 = res->verifier[0]._mp_size > 0;
            }
#line 81
            if (tmp___3 > 0) {
              {
              {
#line 81
              tmp___4 = nettle_sexp_iterator_exit_list(& i);
              }
              }
#line 81
              if (tmp___4) {
                {
                {
#line 86
                res->name = ssh_format("%lS", name);
                }
                }
#line 88
                return (res);
              }
            }
          }
        }
        fail: 
        {
        {
#line 91
        gc_kill((struct lsh_object *)res);
        }
        }
#line 92
        return ((struct srp_entry *)((void *)0));
      } else {
#line 95
        return ((struct srp_entry *)((void *)0));
      }
    } else {
#line 95
      return ((struct srp_entry *)((void *)0));
    }
  } else {
#line 95
    return ((struct srp_entry *)((void *)0));
  }
}
}
#line 99 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c"
struct lsh_string *srp_make_verifier(struct zn_group  const  *G , struct hash_algorithm  const  *H ,
                                     struct lsh_string *salt , struct lsh_string *name ,
                                     struct lsh_string *passwd ) 
{ 
  mpz_t x ;
  struct lsh_string *expr ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 109
  __gmpz_init(x);
  }
  {
#line 111
  srp_hash_password(x, H, salt, name, passwd);
  }
  {
#line 112
  zn_exp(G, x, (__mpz_struct */* const  */)((__mpz_struct *)(G->generator)), (__mpz_struct */* const  */)(x));
  }
  {
#line 114
  tmp = lsh_string_data((struct lsh_string  const  *)salt);
  }
  {
#line 114
  tmp___0 = lsh_string_length((struct lsh_string  const  *)salt);
  }
  {
#line 114
  expr = lsh_string_format_sexp(0, "(srp-verifier ssh-ring1%s%b)", tmp___0, tmp, x);
  }
  {
#line 118
  __gmpz_clear(x);
  }
  }
#line 120
  return (expr);
}
}
#line 125 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c"
void srp_hash_password(__mpz_struct *x , struct hash_algorithm  const  *H , struct lsh_string *salt ,
                       struct lsh_string *name , struct lsh_string *passwd ) 
{ 
  struct lsh_string *h___0 ;
  struct lsh_string *tmp ;
  struct lsh_string *tmp___0 ;
  struct lsh_string *tmp___1 ;
  struct lsh_string *tmp___2 ;
  uint8_t const   *tmp___3 ;
  uint32_t tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 132
  tmp = ssh_format("%S%S", name, passwd);
  }
  {
#line 132
  tmp___0 = hash_string(H, (struct lsh_string  const  *)tmp, 1);
  }
  {
#line 132
  tmp___1 = ssh_format("%S%fS", salt, tmp___0);
  }
  {
#line 132
  tmp___2 = hash_string(H, (struct lsh_string  const  *)tmp___1, 1);
  }
#line 132
  h___0 = tmp___2;
  {
#line 137
  tmp___3 = lsh_string_data((struct lsh_string  const  *)h___0);
  }
  {
#line 137
  tmp___4 = lsh_string_length((struct lsh_string  const  *)h___0);
  }
  {
#line 137
  nettle_mpz_set_str_256_u(x, tmp___4, tmp___3);
  }
  {
#line 138
  lsh_string_free((struct lsh_string  const  *)h___0);
  }
  }
#line 139
  return;
}
}
#line 141 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c"
static void srp_format_proofs(struct dh_instance *dh , struct lsh_string **m1 , struct lsh_string **m2 ) 
{ 
  struct mac_algorithm *mac_algorithm ;
  struct mac_algorithm *tmp ;
  struct mac_instance *hmac ;
  uint8_t const   *tmp___0 ;
  uint32_t tmp___1 ;
  struct mac_instance *tmp___2 ;
  struct lsh_string *s ;
  uint8_t const   *tmp___3 ;
  uint32_t tmp___4 ;
  struct lsh_string *tmp___5 ;
  uint8_t const   *tmp___6 ;
  uint32_t tmp___7 ;
  struct lsh_string *tmp___8 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 146
  tmp = make_hmac_algorithm((struct hash_algorithm  const  *)(dh->method)->H);
  }
#line 146
  mac_algorithm = tmp;
  {
#line 148
  tmp___0 = lsh_string_data((struct lsh_string  const  *)dh->K);
  }
  {
#line 148
  tmp___1 = lsh_string_length((struct lsh_string  const  *)dh->K);
  }
  {
#line 148
  tmp___2 = (*(mac_algorithm->make_mac))(mac_algorithm, tmp___1, tmp___0);
  }
#line 148
  hmac = tmp___2;
  {
#line 153
  tmp___3 = lsh_string_data((struct lsh_string  const  *)dh->exchange_hash);
  }
  {
#line 153
  tmp___4 = lsh_string_length((struct lsh_string  const  *)dh->exchange_hash);
  }
  {
#line 153
  (*(hmac->update))(hmac, tmp___4, tmp___3);
  }
  {
#line 156
  tmp___5 = lsh_string_alloc(hmac->mac_size);
  }
  {
#line 156
  *m1 = (*(hmac->digest))(hmac, tmp___5, (uint32_t )0);
  }
  {
#line 158
  s = ssh_format("%n%S%S", dh->e, *m1, dh->exchange_hash);
  }
  {
#line 160
  tmp___6 = lsh_string_data((struct lsh_string  const  *)s);
  }
  {
#line 160
  tmp___7 = lsh_string_length((struct lsh_string  const  *)s);
  }
  {
#line 160
  (*(hmac->update))(hmac, tmp___7, tmp___6);
  }
  {
#line 161
  tmp___8 = lsh_string_alloc(hmac->mac_size);
  }
  {
#line 161
  *m2 = (*(hmac->digest))(hmac, tmp___8, (uint32_t )0);
  }
  {
#line 163
  lsh_string_free((struct lsh_string  const  *)s);
  }
  {
#line 164
  gc_kill((struct lsh_object *)hmac);
  }
  }
#line 165
  return;
}
}
#line 168 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c"
struct lsh_string *srp_make_init_msg(struct dh_instance *dh , struct lsh_string *name ) 
{ 
  struct lsh_string *tmp ;
  struct lsh_string *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 171
  dh_generate_secret(dh->method, dh->secret, dh->e);
  }
  {
#line 172
  tmp = ssh_format("%S", name);
  }
  {
#line 172
  dh_hash_update(dh, tmp, 1);
  }
  {
#line 174
  debug("srp_make_init_msg: e = %xn\n", dh->e);
  }
  {
#line 175
  tmp___0 = ssh_format("%c%S%n", 30, name, dh->e);
  }
  }
#line 175
  return (tmp___0);
}
}
#line 179 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c"
struct lsh_string *srp_process_init_msg(struct dh_instance *self , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  struct lsh_string *name ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
  {
#line 187
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 187
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 187
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 189
  tmp___1 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 189
  if (tmp___1) {
#line 189
    if (msg_number == 30U) {
      {
      {
#line 189
      name = parse_string_copy(& buffer);
      }
      }
#line 189
      if (name) {
        {
        {
#line 189
        tmp___2 = parse_bignum(& buffer, self->e, (uint32_t )0);
        }
        }
#line 189
        if (tmp___2) {
          {
          {
#line 189
          tmp___4 = __gmpz_cmp_ui((mpz_srcptr )(self->e), 1UL);
          }
          }
#line 189
          if (tmp___4 > 0) {
            {
            {
#line 189
            tmp___5 = zn_range((struct zn_group  const  *)(self->method)->G, (__mpz_struct */* const  */)(self->e));
            }
            }
#line 189
            if (tmp___5) {
              {
              {
#line 189
              tmp___6 = parse_eod(& buffer);
              }
              }
#line 189
              if (tmp___6) {
                {
                {
#line 198
                debug("srp_process_init_msg: e = %xn\n", self->e);
                }
                }
#line 199
                return (name);
              } else {
                {
                {
#line 203
                werror("Invalid SSH_MSG_KEXSRP_INIT message.\n");
                }
                }
#line 204
                return ((struct lsh_string *)((void *)0));
              }
            } else {
              {
              {
#line 203
              werror("Invalid SSH_MSG_KEXSRP_INIT message.\n");
              }
              }
#line 204
              return ((struct lsh_string *)((void *)0));
            }
          } else {
            {
            {
#line 203
            werror("Invalid SSH_MSG_KEXSRP_INIT message.\n");
            }
            }
#line 204
            return ((struct lsh_string *)((void *)0));
          }
        } else {
          {
          {
#line 203
          werror("Invalid SSH_MSG_KEXSRP_INIT message.\n");
          }
          }
#line 204
          return ((struct lsh_string *)((void *)0));
        }
      } else {
        {
        {
#line 203
        werror("Invalid SSH_MSG_KEXSRP_INIT message.\n");
        }
        }
#line 204
        return ((struct lsh_string *)((void *)0));
      }
    } else {
      {
      {
#line 203
      werror("Invalid SSH_MSG_KEXSRP_INIT message.\n");
      }
      }
#line 204
      return ((struct lsh_string *)((void *)0));
    }
  } else {
    {
    {
#line 203
    werror("Invalid SSH_MSG_KEXSRP_INIT message.\n");
    }
    }
#line 204
    return ((struct lsh_string *)((void *)0));
  }
}
}
#line 209 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c"
static uint32_t srp_select_u(struct dh_instance *dh ) 
{ 
  struct lsh_string *h___0 ;
  uint32_t u ;
  struct lsh_string *tmp ;
  uint8_t const   *tmp___0 ;
  uint8_t const   *tmp___1 ;
  uint8_t const   *tmp___2 ;
  uint8_t const   *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 215
  tmp = ssh_format("%ln", dh->f);
  }
  {
#line 215
  h___0 = hash_string((struct hash_algorithm  const  *)(dh->method)->H, (struct lsh_string  const  *)tmp,
                      1);
  }
  {
#line 217
  tmp___0 = lsh_string_data((struct lsh_string  const  *)h___0);
  }
  {
#line 217
  tmp___1 = lsh_string_data((struct lsh_string  const  *)h___0);
  }
  {
#line 217
  tmp___2 = lsh_string_data((struct lsh_string  const  *)h___0);
  }
  {
#line 217
  tmp___3 = lsh_string_data((struct lsh_string  const  *)h___0);
  }
#line 217
  u = ((((uint32_t )*(tmp___0 + 0) << 24) | ((uint32_t )*(tmp___1 + 1) << 16)) | ((uint32_t )*(tmp___2 + 2) << 8)) | (uint32_t )*(tmp___3 + 3);
  {
#line 218
  lsh_string_free((struct lsh_string  const  *)h___0);
  }
  {
#line 220
  debug("srp_select_u: u = %xi\n", u);
  }
  }
#line 221
  return (u);
}
}
#line 225 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c"
struct lsh_string *srp_make_reply_msg(struct dh_instance *dh , struct srp_entry *entry ) 
{ 
  uint32_t u ;
  mpz_t tmp ;
  int tmp___0 ;
  struct lsh_string *tmp___1 ;
  struct lsh_string *tmp___2 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
  {
#line 231
  debug("srp_make_reply_msg: v = %xn\n", entry->verifier);
  }
  }
  {
  {
#line 233
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 236
    dh_generate_secret(dh->method, dh->secret, dh->f);
    }
    {
#line 238
    debug("srp_make_reply_msg: f - v = %xn\n", dh->f);
    }
    {
#line 240
    tmp___0 = zn_add((struct zn_group  const  *)(dh->method)->G, dh->f, (__mpz_struct */* const  */)(dh->f),
                     (__mpz_struct */* const  */)(entry->verifier));
    }
    }
#line 240
    if (! tmp___0) {
      {
      {
#line 242
      werror("srp_exchange.c: Found cleartext password by mistake!\n");
      }
      }
#line 243
      goto __Cont;
    }
    {
    {
#line 246
    debug("srp_make_reply_msg: f = %xn\n", dh->f);
    }
    {
#line 248
    u = srp_select_u(dh);
    }
    }
#line 249
    if (u) {
#line 250
      goto while_break;
    }
    __Cont: ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 254
  __gmpz_init(tmp);
  }
  {
#line 256
  zn_exp_ui((struct zn_group  const  *)(dh->method)->G, tmp, (__mpz_struct */* const  */)(entry->verifier),
            u);
  }
  {
#line 257
  zn_mul((struct zn_group  const  *)(dh->method)->G, tmp, (__mpz_struct */* const  */)(dh->e),
         (__mpz_struct */* const  */)(tmp));
  }
  {
#line 258
  zn_exp((struct zn_group  const  *)(dh->method)->G, tmp, (__mpz_struct */* const  */)(tmp),
         (__mpz_struct */* const  */)(dh->secret));
  }
  {
#line 260
  debug("srp_make_reply_msg: K = %xn\n", tmp);
  }
  {
#line 262
  dh->K = ssh_format("%ln", tmp);
  }
  {
#line 264
  __gmpz_clear(tmp);
  }
  {
#line 268
  tmp___1 = ssh_format("%S%S", entry->name, entry->salt);
  }
  {
#line 268
  dh_hash_update(dh, tmp___1, 1);
  }
  {
#line 269
  dh_hash_digest(dh);
  }
  {
#line 271
  tmp___2 = ssh_format("%c%S%n", 31, entry->salt, dh->f);
  }
  }
#line 271
  return (tmp___2);
}
}
#line 275 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c"
struct lsh_string *srp_process_reply_msg(struct dh_instance *dh , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  struct lsh_string *salt ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  struct lsh_string *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
  {
  {
#line 282
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 282
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 282
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 284
  tmp___3 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 284
  if (tmp___3) {
#line 284
    if (msg_number == 31U) {
      {
      {
#line 284
      salt = parse_string_copy(& buffer);
      }
      }
#line 284
      if (salt) {
        {
        {
#line 284
        tmp___4 = parse_bignum(& buffer, dh->f, (uint32_t )0);
        }
        }
#line 284
        if (tmp___4) {
          {
          {
#line 284
          tmp___6 = __gmpz_cmp_ui((mpz_srcptr )(dh->f), 1UL);
          }
          }
#line 284
          if (tmp___6 > 0) {
            {
            {
#line 284
            tmp___7 = zn_range((struct zn_group  const  *)(dh->method)->G, (__mpz_struct */* const  */)(dh->f));
            }
            }
#line 284
            if (tmp___7) {
              {
              {
#line 284
              tmp___8 = parse_eod(& buffer);
              }
              }
#line 284
              if (tmp___8) {
                {
                {
#line 293
                debug("srp_process_reply_msg: f = %xn\n", dh->f);
                }
                {
#line 297
                tmp___1 = srp_select_u(dh);
                }
                }
#line 297
                if (! tmp___1) {
                  {
                  {
#line 299
                  werror("Recived SSH_MSG_KEXSRP_REPLY messge with u = 0.\n");
                  }
                  {
#line 300
                  lsh_string_free((struct lsh_string  const  *)salt);
                  }
                  }
#line 301
                  return ((struct lsh_string *)((void *)0));
                }
                {
                {
#line 303
                tmp___2 = ssh_format("%S", salt);
                }
                {
#line 303
                dh_hash_update(dh, tmp___2, 1);
                }
                }
#line 304
                return (salt);
              } else {
                {
                {
#line 308
                werror("Invalid SSH_MSG_KEXSRP_REPLY message.\n");
                }
                }
#line 309
                return ((struct lsh_string *)((void *)0));
              }
            } else {
              {
              {
#line 308
              werror("Invalid SSH_MSG_KEXSRP_REPLY message.\n");
              }
              }
#line 309
              return ((struct lsh_string *)((void *)0));
            }
          } else {
            {
            {
#line 308
            werror("Invalid SSH_MSG_KEXSRP_REPLY message.\n");
            }
            }
#line 309
            return ((struct lsh_string *)((void *)0));
          }
        } else {
          {
          {
#line 308
          werror("Invalid SSH_MSG_KEXSRP_REPLY message.\n");
          }
          }
#line 309
          return ((struct lsh_string *)((void *)0));
        }
      } else {
        {
        {
#line 308
        werror("Invalid SSH_MSG_KEXSRP_REPLY message.\n");
        }
        }
#line 309
        return ((struct lsh_string *)((void *)0));
      }
    } else {
      {
      {
#line 308
      werror("Invalid SSH_MSG_KEXSRP_REPLY message.\n");
      }
      }
#line 309
      return ((struct lsh_string *)((void *)0));
    }
  } else {
    {
    {
#line 308
    werror("Invalid SSH_MSG_KEXSRP_REPLY message.\n");
    }
    }
#line 309
    return ((struct lsh_string *)((void *)0));
  }
}
}
#line 316 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c"
struct lsh_string *srp_make_client_proof(struct dh_instance *dh , struct lsh_string **m2 ,
                                         __mpz_struct *x ) 
{ 
  uint32_t u ;
  uint32_t tmp ;
  mpz_t v ;
  mpz_t tmp___0 ;
  struct lsh_string *m1 ;
  int tmp___1 ;
  struct lsh_string *tmp___2 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
  {
#line 321
  tmp = srp_select_u(dh);
  }
#line 321
  u = tmp;
  }
#line 326
  if (! u) {
    {
    {
#line 326
    __assert_fail("u", "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c", 326U,
                  "srp_make_client_proof");
    }
    }
  }
  {
  {
#line 328
  __gmpz_init(v);
  }
  {
#line 331
  zn_exp((struct zn_group  const  *)(dh->method)->G, v, (__mpz_struct */* const  */)((__mpz_struct *)(((dh->method)->G)->generator)),
         (__mpz_struct */* const  */)x);
  }
  {
#line 333
  debug("srp_make_client_proof: v = %xn\n", v);
  }
  {
#line 335
  tmp___1 = zn_sub((struct zn_group  const  *)(dh->method)->G, v, (__mpz_struct */* const  */)(dh->f),
                   (__mpz_struct */* const  */)(v));
  }
  }
#line 335
  if (! tmp___1) {
    {
    {
#line 337
    __gmpz_clear(v);
    }
    }
#line 338
    return ((struct lsh_string *)((void *)0));
  }
  {
  {
#line 341
  debug("srp_make_client_proof: f - v = %xn\n", v);
  }
  {
#line 343
  __gmpz_init(tmp___0);
  }
  {
#line 346
  __gmpz_mul_ui(tmp___0, (mpz_srcptr )x, (unsigned long )u);
  }
  {
#line 347
  __gmpz_add(tmp___0, (mpz_srcptr )(tmp___0), (mpz_srcptr )(dh->secret));
  }
  {
#line 349
  zn_exp((struct zn_group  const  *)(dh->method)->G, v, (__mpz_struct */* const  */)(v),
         (__mpz_struct */* const  */)(tmp___0));
  }
  {
#line 351
  debug("srp_make_client_proof: K = %xn\n", v);
  }
  {
#line 352
  dh->K = ssh_format("%ln", v);
  }
  {
#line 354
  __gmpz_clear(v);
  }
  {
#line 355
  __gmpz_clear(tmp___0);
  }
  {
#line 357
  dh_hash_digest(dh);
  }
  {
#line 358
  srp_format_proofs(dh, & m1, m2);
  }
  {
#line 360
  tmp___2 = ssh_format("%c%fS", 32, m1);
  }
  }
#line 360
  return (tmp___2);
}
}
#line 363 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c"
struct lsh_string *srp_process_client_proof(struct dh_instance *dh , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t length ;
  uint8_t const   *client_m1 ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct lsh_string *m1 ;
  struct lsh_string *m2 ;
  int tmp___1 ;
  struct lsh_string *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
  {
#line 372
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 372
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 372
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 374
  tmp___3 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 374
  if (tmp___3) {
#line 374
    if (msg_number == 32U) {
      {
      {
#line 374
      tmp___4 = parse_string(& buffer, & length, & client_m1);
      }
      }
#line 374
      if (tmp___4) {
        {
        {
#line 374
        tmp___5 = parse_eod(& buffer);
        }
        }
#line 374
        if (tmp___5) {
          {
          {
#line 382
          srp_format_proofs(dh, & m1, & m2);
          }
          {
#line 384
          tmp___1 = lsh_string_eq_l((struct lsh_string  const  *)m1, length, client_m1);
          }
          }
#line 384
          if (! tmp___1) {
            {
            {
#line 386
            werror("SRP failed: Received invalid m1 from client.\n");
            }
            {
#line 387
            lsh_string_free((struct lsh_string  const  *)m1);
            }
            {
#line 388
            lsh_string_free((struct lsh_string  const  *)m2);
            }
            }
#line 390
            return ((struct lsh_string *)((void *)0));
          }
          {
          {
#line 392
          lsh_string_free((struct lsh_string  const  *)m1);
          }
          {
#line 393
          tmp___2 = ssh_format("%c%fS", 32, m2);
          }
          }
#line 393
          return (tmp___2);
        }
      }
    }
  }
#line 396
  return ((struct lsh_string *)((void *)0));
}
}
#line 399 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c"
int srp_process_server_proof(struct lsh_string *m2 , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t length ;
  uint8_t const   *server_m2 ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
  {
#line 409
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 409
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 409
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 411
  tmp___2 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 411
  if (tmp___2) {
#line 411
    if (msg_number == 32U) {
      {
      {
#line 411
      tmp___3 = parse_string(& buffer, & length, & server_m2);
      }
      }
#line 411
      if (tmp___3) {
        {
        {
#line 411
        tmp___4 = parse_eod(& buffer);
        }
        }
#line 411
        if (tmp___4) {
          {
          {
#line 416
          tmp___1 = lsh_string_eq_l((struct lsh_string  const  *)m2, length, server_m2);
          }
          }
#line 416
          return (tmp___1);
        }
      }
    }
  }
#line 418
  return (0);
}
}
#line 421 "/home/ysko/Works/test-src/lsh-2.0.4/src/srp_exchange.c"
struct dh_method *make_srp1(struct randomness *r ) 
{ 
  struct zn_group  const  *tmp ;
  struct dh_method *tmp___0 ;

  {
  {
  {
#line 424
  tmp = make_ssh_ring_srp_1();
  }
  {
#line 424
  tmp___0 = make_dh(tmp, & crypto_sha1_algorithm, r);
  }
  }
#line 424
  return (tmp___0);
}
}
#line 98 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h"
void hash_update(struct hash_instance *self , uint32_t length , uint8_t const   *data ) ;
#line 103
struct lsh_string *hash_digest_string(struct hash_instance *self ) ;
#line 116
struct hash_instance *make_hash(struct hash_algorithm  const  *self ) ;
#line 229
struct lsh_string *crypt_string_pad(struct crypto_instance *c , struct lsh_string  const  *in ,
                                    int free___0 ) ;
#line 234
struct lsh_string *crypt_string_unpad(struct crypto_instance *c , struct lsh_string  const  *in ,
                                      int free___0 ) ;
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.h.x"
struct lsh_class spki_context_class ;
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.h"
struct lsh_string *make_ssh_hostkey_tag(char const   *host ) ;
#line 44
struct verifier *spki_make_verifier(struct alist *algorithms , struct sexp_iterator *i ,
                                    int *type ) ;
#line 49
struct signer *spki_sexp_to_signer(struct alist *algorithms , struct sexp_iterator *i ,
                                   int *type ) ;
#line 54
struct signer *spki_make_signer(struct alist *algorithms , struct lsh_string  const  *key ,
                                int *algorithm_name ) ;
#line 59
struct lsh_string *spki_hash_data(struct hash_algorithm  const  *algorithm , int algorithm_name ,
                                  uint32_t length , uint8_t *data ) ;
#line 91
struct spki_principal *spki_lookup(struct spki_context *self , unsigned int length ,
                                   uint8_t const   *key , struct verifier *v ) ;
#line 99
int spki_authorize(struct spki_context *self , struct spki_principal  const  *user ,
                   time_t t , struct lsh_string  const  *access___0 ) ;
#line 106
struct spki_context *make_spki_context(struct alist *algorithms ) ;
#line 109
int spki_add_acl(struct spki_context *ctx , struct spki_iterator *i ) ;
#line 114
struct lsh_string *spki_pkcs5_encrypt(struct randomness *r , struct lsh_string *label ,
                                      uint32_t prf_name , struct mac_algorithm *prf ,
                                      int crypto_name , struct crypto_algorithm *crypto ,
                                      uint32_t salt_length , struct lsh_string *password ,
                                      uint32_t iterations , struct lsh_string  const  *data ) ;
#line 126
struct lsh_string *spki_pkcs5_decrypt(struct alist *mac_algorithms , struct alist *crypto_algorithms ,
                                      struct interact *interact , struct lsh_string *expr ) ;
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.h"
struct lsh_string *pkcs5_derive_key(struct mac_algorithm *prf , struct lsh_string  const  *password ,
                                    struct lsh_string  const  *salt , uint32_t iterations ,
                                    uint32_t key_length ) ;
#line 173 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
struct lsh_string *lsh_string_random(struct randomness *r , uint32_t length ) ;
#line 206
int lsh_string_transport_iterator_first(struct lsh_string *s , struct sexp_iterator *iterator ) ;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/sexp.h"
int lsh_sexp_to_atom(struct sexp_iterator *i ) ;
#line 38
int lsh_sexp_get_type(struct sexp_iterator *i ) ;
#line 41
struct lsh_string *lsh_sexp_to_string(struct sexp_iterator *i , struct lsh_string **display ) ;
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
static void do_spki_acl_db_mark(struct spki_acl_db *db , void (*mark)(struct lsh_object *o ) ) ;
#line 61
static void do_spki_acl_db_free(struct spki_acl_db *db ) ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.h.x"
static void do_spki_context_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct spki_context *i ;

  {
  {
#line 19
  i = (struct spki_context *)o;
  {
#line 20
  (*mark)((struct lsh_object *)i->algorithms);
  }
  {
#line 21
  do_spki_acl_db_mark(& i->db, mark);
  }
  }
#line 23
  return;
}
}
#line 24 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.h.x"
static void do_spki_context_free(struct lsh_object *o ) 
{ 
  struct spki_context *i ;

  {
  {
#line 27
  i = (struct spki_context *)o;
  {
#line 28
  do_spki_acl_db_free(& i->db);
  }
  }
#line 29
  return;
}
}
#line 30 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.h.x"
struct lsh_class spki_context_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"spki_context", (size_t )sizeof(struct spki_context ),
    & do_spki_context_mark, & do_spki_context_free};
#line 72 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
struct lsh_string *make_ssh_hostkey_tag(char const   *host ) 
{ 
  uint32_t left ;
  size_t tmp ;
  uint8_t const   *s ;
  struct lsh_string *tag ;
  struct lsh_string *reversed ;
  struct lsh_string *tmp___0 ;
  uint8_t *p ;
  void *tmp___1 ;
  uint32_t segment ;
  uint8_t const   *tmp___2 ;
  uint32_t tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 75
  tmp = strlen(host);
  }
#line 75
  left = tmp;
#line 76
  s = (uint8_t const   *)host;
  {
#line 78
  tmp___0 = lsh_string_alloc(left);
  }
#line 78
  reversed = tmp___0;
  }
  {
  {
#line 81
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 81
    if (! left) {
#line 81
      goto while_break;
    }
    {
    {
#line 83
    tmp___1 = memchr((void const   *)s, '.', left);
    }
#line 83
    p = (uint8_t *)tmp___1;
    }
#line 84
    if (! p) {
      {
      {
#line 86
      lsh_string_write(reversed, (uint32_t )0, left, s);
      }
      }
#line 87
      goto while_break;
    } else {
      {
#line 91
      segment = (uint32_t )(p - (uint8_t *)s);
#line 92
      left -= segment;
      {
#line 94
      lsh_string_write(reversed, left, segment, s);
      }
#line 95
      left --;
      {
#line 95
      lsh_string_putc(reversed, left, (uint8_t )'.');
      }
#line 96
      s = (uint8_t const   *)(p + 1);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 100
  tmp___2 = lsh_string_data((struct lsh_string  const  *)reversed);
  }
  {
#line 100
  tmp___3 = lsh_string_length((struct lsh_string  const  *)reversed);
  }
  {
#line 100
  tag = lsh_string_format_sexp(0, "(tag(ssh-hostkey%s))", tmp___3, tmp___2);
  }
  {
#line 102
  lsh_string_free((struct lsh_string  const  *)reversed);
  }
  }
#line 104
  return (tag);
}
}
#line 109 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
static struct lsh_object  const  *spki_algorithm_lookup(struct alist *algorithms ,
                                                        struct sexp_iterator *i ,
                                                        int *type ) 
{ 
  struct lsh_object *res ;
  int algorithm_name ;
  int tmp ;

  {
  {
  {
#line 115
  tmp = lsh_sexp_get_type(i);
  }
#line 115
  algorithm_name = tmp;
  {
#line 118
  res = (*(((struct alist_meta *)algorithms->super.isa)->get))(algorithms, algorithm_name);
  }
  }
#line 120
  if (res) {
#line 120
    if (type) {
#line 121
      *type = algorithm_name;
    }
  }
#line 123
  return ((struct lsh_object  const  *)res);
}
}
#line 126 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
struct verifier *spki_make_verifier(struct alist *algorithms , struct sexp_iterator *i ,
                                    int *type ) 
{ 
  struct signature_algorithm *algorithm ;
  struct verifier *v ;
  struct signature_algorithm *a ;
  struct lsh_object  const  *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 136
  tmp = spki_algorithm_lookup(algorithms, i, type);
  }
#line 136
  a = (struct signature_algorithm *)tmp;
#line 138
  algorithm = a;
  }
#line 141
  if (! algorithm) {
#line 142
    return ((struct verifier *)((void *)0));
  }
  {
  {
#line 144
  v = (*(algorithm->make_verifier))(algorithm, i);
  }
  }
#line 146
  if (! v) {
    {
    {
#line 148
    werror("spki_make_verifier: Invalid public-key data.\n");
    }
    }
#line 149
    return ((struct verifier *)((void *)0));
  }
#line 152
  return (v);
}
}
#line 156 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
struct signer *spki_sexp_to_signer(struct alist *algorithms , struct sexp_iterator *i ,
                                   int *type ) 
{ 
  struct signature_algorithm *algorithm ;
  struct signature_algorithm *a ;
  struct lsh_object  const  *tmp ;
  struct signer *tmp___0 ;
  struct signer *tmp___1 ;

  {
  {
  {
#line 165
  tmp = spki_algorithm_lookup(algorithms, i, type);
  }
#line 165
  a = (struct signature_algorithm *)tmp;
#line 167
  algorithm = a;
  }
#line 170
  if (algorithm) {
    {
    {
#line 170
    tmp___0 = (*(algorithm->make_signer))(algorithm, i);
    }
#line 170
    tmp___1 = tmp___0;
    }
  } else {
#line 170
    tmp___1 = (struct signer *)((void *)0);
  }
#line 170
  return (tmp___1);
}
}
#line 177 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
struct signer *spki_make_signer(struct alist *algorithms , struct lsh_string  const  *key ,
                                int *algorithm_name ) 
{ 
  struct sexp_iterator i ;
  struct lsh_string *decoded ;
  struct lsh_string *tmp ;
  struct signer *res ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 183
  tmp = ssh_format("%lS", key);
  }
#line 183
  decoded = tmp;
#line 184
  res = (struct signer *)((void *)0);
  {
#line 186
  tmp___0 = lsh_string_transport_iterator_first(decoded, & i);
  }
  }
#line 186
  if (tmp___0) {
    {
    {
#line 186
    tmp___1 = nettle_sexp_iterator_check_type(& i, (uint8_t const   *)"private-key");
    }
    }
#line 186
    if (tmp___1) {
      {
      {
#line 188
      res = spki_sexp_to_signer(algorithms, & i, algorithm_name);
      }
      }
    }
  }
  {
  {
#line 190
  lsh_string_free((struct lsh_string  const  *)decoded);
  }
  }
#line 191
  if (! res) {
    {
    {
#line 192
    werror("spki_make_signer: Expected private-key expression.\n");
    }
    }
  }
#line 193
  return (res);
}
}
#line 196 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
struct lsh_string *spki_hash_data(struct hash_algorithm  const  *algorithm , int algorithm_name ,
                                  uint32_t length , uint8_t *data ) 
{ 
  struct hash_instance *hash___2 ;
  struct hash_instance *tmp ;
  struct lsh_string *digest ;
  struct lsh_string *out ;
  uint8_t const   *tmp___0 ;
  uint32_t tmp___1 ;
  uint8_t const   *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 201
  tmp = make_hash(algorithm);
  }
#line 201
  hash___2 = tmp;
  {
#line 205
  hash_update(hash___2, length, (uint8_t const   *)data);
  }
  {
#line 206
  digest = hash_digest_string(hash___2);
  }
  {
#line 208
  tmp___0 = lsh_string_data((struct lsh_string  const  *)digest);
  }
  {
#line 208
  tmp___1 = lsh_string_length((struct lsh_string  const  *)digest);
  }
  {
#line 208
  tmp___2 = get_atom_name(algorithm_name);
  }
  {
#line 208
  out = lsh_string_format_sexp(0, "(hash%0s%s)", "hash", tmp___2, tmp___1, tmp___0);
  }
  {
#line 211
  gc_kill((struct lsh_object *)hash___2);
  }
  {
#line 212
  lsh_string_free((struct lsh_string  const  *)digest);
  }
  }
#line 214
  return (out);
}
}
#line 217 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
static void do_spki_acl_db_mark(struct spki_acl_db *db , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct spki_principal *p ;

  {
#line 223
  p = db->first_principal;
  {
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 223
    if (! p) {
#line 223
      goto while_break;
    }
    {
    {
#line 224
    (*mark)((struct lsh_object *)p->verifier);
    }
#line 223
    p = p->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 225
  return;
}
}
#line 227 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
static void do_spki_acl_db_free(struct spki_acl_db *db ) 
{ 


  {
  {
  {
#line 230
  spki_acl_clear(db);
  }
  }
#line 231
  return;
}
}
#line 236 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
int spki_add_acl(struct spki_context *ctx , struct spki_iterator *i ) 
{ 
  int tmp ;

  {
  {
  {
#line 240
  tmp = spki_acl_process(& ctx->db, i);
  }
  }
#line 240
  return (tmp);
}
}
#line 243 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
struct spki_principal *spki_lookup(struct spki_context *self , unsigned int length ,
                                   uint8_t const   *key , struct verifier *v ) 
{ 
  struct spki_principal *principal ;
  struct spki_iterator i ;
  struct sexp_iterator sexp ;
  int tmp ;
  enum spki_type tmp___0 ;
  enum spki_type tmp___1 ;
  struct verifier *tmp___2 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
  {
#line 254
  tmp = nettle_sexp_iterator_first(& sexp, length, key);
  }
  }
#line 254
  if (tmp) {
    {
    {
#line 254
    tmp___0 = spki_iterator_first_sexp(& i, (struct sexp_iterator  const  *)(& sexp));
    }
    }
#line 254
    if (tmp___0) {
      {
      {
#line 254
      tmp___1 = spki_parse_principal(& self->db, & i, & principal);
      }
      }
#line 254
      if (! tmp___1) {
        {
        {
#line 258
        werror("do_spki_lookup: Invalid expression.\n");
        }
        }
#line 259
        return ((struct spki_principal *)((void *)0));
      }
    } else {
      {
      {
#line 258
      werror("do_spki_lookup: Invalid expression.\n");
      }
      }
#line 259
      return ((struct spki_principal *)((void *)0));
    }
  } else {
    {
    {
#line 258
    werror("do_spki_lookup: Invalid expression.\n");
    }
    }
#line 259
    return ((struct spki_principal *)((void *)0));
  }
#line 262
  if (! principal->verifier) {
#line 264
    if (v) {
#line 265
      principal->verifier = (void *)v;
    } else {
      {
      {
#line 267
      tmp___2 = spki_make_verifier(self->algorithms, & sexp, (int *)((void *)0));
      }
#line 267
      principal->verifier = (void *)tmp___2;
      }
    }
  }
#line 270
  return (principal);
}
}
#line 273 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
int spki_authorize(struct spki_context *self , struct spki_principal  const  *user ,
                   time_t t , struct lsh_string  const  *access___0 ) 
{ 
  struct spki_5_tuple  const  *acl ;
  struct spki_date date ;
  struct spki_tag *tag ;
  struct spki_iterator i ;
  struct spki_5_tuple_list  const  *p ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  enum spki_type tmp___1 ;
  enum spki_type tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
  {
#line 285
  tmp = lsh_string_data(access___0);
  }
  {
#line 285
  tmp___0 = lsh_string_length(access___0);
  }
  {
#line 285
  tmp___1 = spki_iterator_first(& i, tmp___0, tmp);
  }
  }
#line 285
  if (tmp___1) {
    {
    {
#line 285
    tmp___2 = spki_parse_tag(& self->db, & i, & tag);
    }
    }
#line 285
    if (! tmp___2) {
      {
      {
#line 288
      werror("spki_authorize: Invalid tag.\n");
      }
      }
#line 289
      return (0);
    }
  } else {
    {
    {
#line 288
    werror("spki_authorize: Invalid tag.\n");
    }
    }
#line 289
    return (0);
  }
  {
  {
#line 292
  spki_date_from_time_t(& date, t);
  }
  {
#line 294
  acl = spki_acl_by_subject_first(& self->db, & p, user);
  }
  }
  {
  {
#line 294
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 294
    if (! acl) {
#line 294
      goto while_break;
    }
    {
    {
#line 298
    tmp___3 = spki_tag_includes((struct spki_tag *)acl->tag, tag);
    }
    }
#line 298
    if (tmp___3) {
      {
      {
#line 298
      tmp___4 = memcmp((void const   *)(acl->not_before.date), (void const   *)(date.date),
                       (size_t )19);
      }
      }
#line 298
      if (tmp___4 <= 0) {
        {
        {
#line 298
        tmp___5 = memcmp((void const   *)(acl->not_after.date), (void const   *)(date.date),
                         (size_t )19);
        }
        }
#line 298
        if (tmp___5 >= 0) {
          {
          {
#line 302
          spki_tag_free(& self->db, tag);
          }
          }
#line 303
          return (1);
        }
      }
    }
    {
    {
#line 294
    acl = spki_acl_by_subject_next(& p, user);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 306
  spki_tag_free(& self->db, tag);
  }
  }
#line 308
  return (0);
}
}
#line 311 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
struct spki_context *make_spki_context(struct alist *algorithms ) 
{ 
  struct spki_context *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 314
  tmp = lsh_object_alloc(& spki_context_class);
  }
#line 314
  self = (struct spki_context *)tmp;
#line 316
  self->algorithms = algorithms;
  {
#line 318
  spki_acl_init(& self->db);
  }
  }
#line 320
  return (self);
}
}
#line 337 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
struct lsh_string *spki_pkcs5_encrypt(struct randomness *r , struct lsh_string *label ,
                                      uint32_t prf_name , struct mac_algorithm *prf ,
                                      int crypto_name , struct crypto_algorithm *crypto ,
                                      uint32_t salt_length , struct lsh_string *password ,
                                      uint32_t iterations , struct lsh_string  const  *data ) 
{ 
  struct lsh_string *key ;
  struct lsh_string *salt ;
  struct lsh_string *iv ;
  struct lsh_string *encrypted ;
  struct lsh_string *value ;
  uint8_t const   *tmp ;
  uint8_t const   *tmp___0 ;
  uint8_t const   *tmp___1 ;
  struct crypto_instance *tmp___2 ;
  uint8_t const   *tmp___3 ;
  uint32_t tmp___4 ;
  uint8_t const   *tmp___5 ;
  uint32_t tmp___6 ;
  uint8_t const   *tmp___7 ;
  uint8_t const   *tmp___8 ;
  uint32_t tmp___9 ;
  uint8_t const   *tmp___10 ;
  uint8_t const   *tmp___11 ;
  uint32_t tmp___12 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
#line 355
  if (! crypto) {
    {
    {
#line 355
    __assert_fail("crypto", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c", 355U,
                  "spki_pkcs5_encrypt");
    }
    }
  }
#line 356
  if (! prf) {
    {
    {
#line 356
    __assert_fail("prf", "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c", 356U, "spki_pkcs5_encrypt");
    }
    }
  }
  {
  {
#line 359
  salt = lsh_string_random(r, salt_length);
  }
  {
#line 361
  key = pkcs5_derive_key(prf, (struct lsh_string  const  *)password, (struct lsh_string  const  *)salt,
                         iterations, crypto->key_size);
  }
  }
#line 365
  if (crypto->iv_size) {
    {
    {
#line 366
    iv = lsh_string_random(r, crypto->iv_size);
    }
    }
  } else {
#line 368
    iv = (struct lsh_string *)((void *)0);
  }
#line 370
  if (iv) {
    {
    {
#line 370
    tmp = lsh_string_data((struct lsh_string  const  *)iv);
    }
#line 370
    tmp___0 = tmp;
    }
  } else {
#line 370
    tmp___0 = (uint8_t const   *)((void *)0);
  }
  {
  {
#line 370
  tmp___1 = lsh_string_data((struct lsh_string  const  *)key);
  }
  {
#line 370
  tmp___2 = (*(crypto->make_crypt))(crypto, 0, tmp___1, tmp___0);
  }
  {
#line 370
  encrypted = crypt_string_pad(tmp___2, data, 0);
  }
  {
#line 376
  tmp___3 = lsh_string_data((struct lsh_string  const  *)encrypted);
  }
  {
#line 376
  tmp___4 = lsh_string_length((struct lsh_string  const  *)encrypted);
  }
  {
#line 376
  tmp___5 = lsh_string_data((struct lsh_string  const  *)iv);
  }
  {
#line 376
  tmp___6 = lsh_string_length((struct lsh_string  const  *)iv);
  }
  {
#line 376
  tmp___7 = get_atom_name(crypto_name);
  }
  {
#line 376
  tmp___8 = lsh_string_data((struct lsh_string  const  *)salt);
  }
  {
#line 376
  tmp___9 = lsh_string_length((struct lsh_string  const  *)salt);
  }
  {
#line 376
  tmp___10 = get_atom_name((int )prf_name);
  }
  {
#line 376
  tmp___11 = lsh_string_data((struct lsh_string  const  *)label);
  }
  {
#line 376
  tmp___12 = lsh_string_length((struct lsh_string  const  *)label);
  }
  {
#line 376
  value = lsh_string_format_sexp(0, "(password-encrypted%s(Xpkcs5v2%0s(iterations%i)(salt%s))(%0s(iv%s)(data%s)))",
                                 tmp___12, tmp___11, tmp___10, iterations, tmp___9,
                                 tmp___8, tmp___7, tmp___6, tmp___5, tmp___4, tmp___3);
  }
  {
#line 387
  lsh_string_free((struct lsh_string  const  *)key);
  }
  {
#line 388
  lsh_string_free((struct lsh_string  const  *)salt);
  }
  {
#line 389
  lsh_string_free((struct lsh_string  const  *)iv);
  }
  {
#line 390
  lsh_string_free((struct lsh_string  const  *)encrypted);
  }
  }
#line 392
  return (value);
}
}
#line 395 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
static int parse_pkcs5(struct sexp_iterator *i , struct alist *mac_algorithms , struct mac_algorithm **mac ,
                       uint32_t *iterations , struct lsh_string  const  **salt ) 
{ 
  int tmp ;
  uint8_t const   *names___3[2] ;
  struct sexp_iterator values[2] ;
  struct mac_algorithm *tmp___0 ;
  int tmp___1 ;
  struct lsh_object *tmp___2 ;
  int tmp___3 ;
  struct lsh_string  const  *tmp___4 ;
  struct lsh_string *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  int __cil_tmp35 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
  {
#line 400
  tmp = lsh_sexp_get_type(i);
  }
  }
#line 406
  if (tmp == 104) {
#line 406
    goto case_104;
  }
#line 402
  goto switch_default;
  switch_default: 
  {
  {
#line 403
  werror("Unknown key derivation mechanism.\n");
  }
  }
#line 404
  return (0);
  case_104: 
  {
#line 408
  names___3[0] = (uint8_t const   *)"salt";
#line 408
  names___3[1] = (uint8_t const   *)"iterations";
  {
#line 411
  tmp___1 = lsh_sexp_to_atom(i);
  }
  {
#line 411
  tmp___2 = (*(((struct alist_meta *)mac_algorithms->super.isa)->get))(mac_algorithms,
                                                                       tmp___1);
  }
#line 411
  tmp___0 = (struct mac_algorithm *)tmp___2;
#line 414
  *mac = tmp___0;
  }
#line 415
  if (! *mac) {
    {
    {
#line 417
    werror("Unknown mac for pkcs5v2.\n");
    }
    }
#line 418
    return (0);
  }
  {
  {
#line 421
  tmp___3 = nettle_sexp_iterator_assoc(i, 2U, (uint8_t const   * const  *)(names___3),
                                       values);
  }
  }
#line 421
  if (tmp___3) {
    {
    {
#line 421
    tmp___5 = lsh_sexp_to_string(& values[0], (struct lsh_string **)((void *)0));
    }
#line 421
    tmp___4 = (struct lsh_string  const  *)tmp___5;
#line 421
    *salt = tmp___4;
    }
#line 421
    if (tmp___4) {
      {
      {
#line 421
      tmp___6 = nettle_sexp_iterator_get_uint32(& values[1], iterations);
      }
      }
#line 421
      if (tmp___6) {
#line 421
        if (*iterations) {
#line 421
          tmp___7 = 1;
        } else {
#line 421
          tmp___7 = 0;
        }
      } else {
#line 421
        tmp___7 = 0;
      }
    } else {
#line 421
      tmp___7 = 0;
    }
  } else {
#line 421
    tmp___7 = 0;
  }
#line 421
  return (tmp___7);

#line 425
  return (0);
}
}
#line 429 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
static int parse_pkcs5_payload(struct sexp_iterator *i , struct alist *crypto_algorithms ,
                               struct crypto_algorithm **crypto , struct lsh_string  const  **iv ,
                               struct lsh_string  const  **data ) 
{ 
  uint8_t const   *names___3[2] ;
  struct sexp_iterator values[2] ;
  struct crypto_algorithm *tmp ;
  struct lsh_object  const  *tmp___0 ;
  int tmp___1 ;
  struct lsh_string *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;
  struct lsh_string *tmp___5 ;
  uint32_t tmp___6 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  int __cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  int __cil_tmp34 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 435
  names___3[0] = (uint8_t const   *)"data";
#line 435
  names___3[1] = (uint8_t const   *)"iv";
  {
#line 438
  tmp___0 = spki_algorithm_lookup(crypto_algorithms, i, (int *)((void *)0));
  }
#line 438
  tmp = (struct crypto_algorithm *)tmp___0;
#line 441
  *crypto = tmp;
  }
#line 443
  if (! *crypto) {
    {
    {
#line 445
    werror("Unknown encryption algorithm for pkcs5v2.\n");
    }
    }
#line 446
    return (0);
  }
#line 449
  if ((*crypto)->iv_size) {
    {
    {
#line 451
    tmp___1 = nettle_sexp_iterator_assoc(i, 2U, (uint8_t const   * const  *)(names___3),
                                         values);
    }
    }
#line 451
    if (! tmp___1) {
#line 452
      return (0);
    }
    {
    {
#line 454
    tmp___2 = lsh_sexp_to_string(& values[1], (struct lsh_string **)((void *)0));
    }
#line 454
    *iv = (struct lsh_string  const  *)tmp___2;
    {
#line 456
    tmp___3 = lsh_string_length(*iv);
    }
    }
#line 456
    if (tmp___3 != (*crypto)->iv_size) {
#line 457
      return (0);
    }
  } else {
    {
    {
#line 459
    tmp___4 = nettle_sexp_iterator_assoc(i, 1U, (uint8_t const   * const  *)(names___3),
                                         values);
    }
    }
#line 459
    if (! tmp___4) {
#line 460
      return (0);
    }
  }
  {
  {
#line 462
  tmp___5 = lsh_sexp_to_string(& values[0], (struct lsh_string **)((void *)0));
  }
#line 462
  *data = (struct lsh_string  const  *)tmp___5;
  }
#line 464
  if ((*crypto)->block_size) {
    {
    {
#line 464
    tmp___6 = lsh_string_length(*data);
    }
    }
#line 464
    if (tmp___6 % (*crypto)->block_size) {
      {
      {
#line 467
      werror("Payload data doesn\'t match block size for pkcs5v2.\n");
      }
      }
#line 468
      return (0);
    }
  }
#line 471
  return (1);
}
}
#line 475 "/home/ysko/Works/test-src/lsh-2.0.4/src/spki.c"
struct lsh_string *spki_pkcs5_decrypt(struct alist *mac_algorithms , struct alist *crypto_algorithms ,
                                      struct interact *interact , struct lsh_string *expr ) 
{ 
  struct sexp_iterator i ;
  struct crypto_algorithm *crypto ;
  struct mac_algorithm *mac ;
  struct lsh_string  const  *label ;
  struct lsh_string  const  *salt ;
  struct lsh_string  const  *iv ;
  struct lsh_string  const  *data ;
  uint32_t iterations ;
  struct lsh_string *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct lsh_string *password ;
  struct lsh_string *tmp___2 ;
  struct lsh_string *tmp___3 ;
  struct lsh_string *clear ;
  struct lsh_string *key ;
  uint8_t const   *tmp___4 ;
  uint8_t const   *tmp___5 ;
  uint8_t const   *tmp___6 ;
  struct crypto_instance *tmp___7 ;
  uint8_t const   *tmp___8 ;
  uint32_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
  {
#line 483
  tmp___8 = lsh_string_data((struct lsh_string  const  *)expr);
  }
  {
#line 483
  tmp___9 = lsh_string_length((struct lsh_string  const  *)expr);
  }
  {
#line 483
  tmp___10 = nettle_sexp_iterator_first(& i, tmp___9, tmp___8);
  }
  }
#line 483
  if (tmp___10) {
    {
    {
#line 483
    tmp___11 = nettle_sexp_iterator_check_type(& i, (uint8_t const   *)"password-encrypted");
    }
    }
#line 483
    if (tmp___11) {
      {
#line 492
      label = (struct lsh_string  const  *)((void *)0);
#line 493
      salt = (struct lsh_string  const  *)((void *)0);
#line 494
      iv = (struct lsh_string  const  *)((void *)0);
#line 495
      data = (struct lsh_string  const  *)((void *)0);
      {
#line 500
      tmp = lsh_sexp_to_string(& i, (struct lsh_string **)((void *)0));
      }
#line 500
      label = (struct lsh_string  const  *)tmp;
      }
#line 502
      if (! label) {
        {
        {
#line 504
        werror("Invalid label in (password-encrypted ...) expression.\n");
        }
        }
        fail: 
        {
        {
#line 506
        lsh_string_free(data);
        }
        {
#line 507
        lsh_string_free((struct lsh_string  const  *)expr);
        }
        {
#line 508
        lsh_string_free(iv);
        }
        {
#line 509
        lsh_string_free(salt);
        }
        {
#line 510
        lsh_string_free(label);
        }
        }
#line 511
        return ((struct lsh_string *)((void *)0));
      }
      {
      {
#line 514
      tmp___0 = parse_pkcs5(& i, mac_algorithms, & mac, & iterations, & salt);
      }
      }
#line 514
      if (! tmp___0) {
#line 515
        goto fail;
      }
      {
      {
#line 517
      tmp___1 = parse_pkcs5_payload(& i, crypto_algorithms, & crypto, & iv, & data);
      }
      }
#line 517
      if (! tmp___1) {
#line 519
        goto fail;
      }
      {
      {
#line 524
      tmp___2 = ssh_format("Passphrase for key `%lS\': ", label);
      }
      {
#line 524
      tmp___3 = (*(interact->read_password))(interact, (uint32_t )500, (struct lsh_string  const  *)tmp___2);
      }
#line 524
      password = tmp___3;
      }
#line 531
      if (! password) {
        {
        {
#line 533
        werror("No password provided for pkcs5v2.\n");
        }
        }
#line 534
        goto fail;
      }
      {
      {
#line 537
      key = pkcs5_derive_key(mac, (struct lsh_string  const  *)password, salt, iterations,
                             crypto->key_size);
      }
      }
#line 541
      if (iv) {
        {
        {
#line 541
        tmp___4 = lsh_string_data(iv);
        }
#line 541
        tmp___5 = tmp___4;
        }
      } else {
#line 541
        tmp___5 = (uint8_t const   *)((void *)0);
      }
      {
      {
#line 541
      tmp___6 = lsh_string_data((struct lsh_string  const  *)key);
      }
      {
#line 541
      tmp___7 = (*(crypto->make_crypt))(crypto, 1, tmp___6, tmp___5);
      }
      {
#line 541
      clear = crypt_string_unpad(tmp___7, data, 0);
      }
      {
#line 546
      lsh_string_free(data);
      }
      {
#line 547
      lsh_string_free((struct lsh_string  const  *)expr);
      }
      {
#line 548
      lsh_string_free(iv);
      }
      {
#line 549
      lsh_string_free((struct lsh_string  const  *)password);
      }
      {
#line 550
      lsh_string_free(salt);
      }
      {
#line 551
      lsh_string_free(label);
      }
      {
#line 552
      lsh_string_free((struct lsh_string  const  *)key);
      }
      }
#line 554
      if (! clear) {
        {
        {
#line 555
        werror("Bad password for pkcs5v2.\n");
        }
        }
      }
#line 557
      return (clear);
    } else {
#line 485
      return (expr);
    }
  } else {
#line 485
    return (expr);
  }
}
}
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_io.h.x"
struct lsh_class read_handler_class ;
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.h"
void channel_forward_start_io_read(struct channel_forward *channel ) ;
#line 360 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
struct lsh_fd *io_read_write(struct lsh_fd *fd , struct io_callback *read___0 , uint32_t block_size ,
                             struct lsh_callback *close_callback ) ;
#line 378
void close_fd_nicely(struct lsh_fd *fd ) ;
#line 176 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
struct lsh_string *lsh_string_ntop(int family , uint32_t length , void const   *addr ) ;
#line 102 "/home/ysko/Works/test-src/lsh-2.0.4/src/tcpforward.h"
struct command *make_socks_server(struct address_info *local ) ;
#line 99 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
struct command_2 socks_handshake ;
#line 12 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
struct lsh_class socks_connection_class ;
#line 16 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
static void do_socks_connection_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct socks_connection *i ;

  {
  {
#line 20
  i = (struct socks_connection *)o;
  {
#line 21
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 22
  (*mark)((struct lsh_object *)i->peer);
  }
  }
#line 23
  return;
}
}
#line 24 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
struct lsh_class socks_connection_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"socks_connection", (size_t )sizeof(struct socks_connection ),
    & do_socks_connection_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 44
struct lsh_class socks_continuation_class ;
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
static void do_socks_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct socks_continuation *i ;

  {
  {
#line 52
  i = (struct socks_continuation *)o;
  {
#line 53
  (*mark)((struct lsh_object *)i->socks);
  }
  }
#line 54
  return;
}
}
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
struct lsh_class socks_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"socks_continuation", (size_t )sizeof(struct socks_continuation ),
    & do_socks_continuation_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 75
struct lsh_class socks_exception_handler_class ;
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
static void do_socks_exception_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct socks_exception_handler *i ;

  {
  {
#line 83
  i = (struct socks_exception_handler *)o;
  {
#line 84
  (*mark)((struct lsh_object *)i->socks);
  }
  }
#line 85
  return;
}
}
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
struct lsh_class socks_exception_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"socks_exception_handler", (size_t )sizeof(struct socks_exception_handler ),
    & do_socks_exception_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 110
struct lsh_class read_socks_class ;
#line 114 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
static void do_read_socks_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct read_socks *i ;

  {
  {
#line 118
  i = (struct read_socks *)o;
  {
#line 119
  (*mark)((struct lsh_object *)i->socks);
  }
  }
#line 120
  return;
}
}
#line 121 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
static void do_read_socks_free(struct lsh_object *o ) 
{ 
  struct read_socks *i ;

  {
  {
#line 124
  i = (struct read_socks *)o;
  {
#line 125
  lsh_string_free((struct lsh_string  const  *)i->buffer);
  }
  }
#line 126
  return;
}
}
#line 127 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
struct lsh_class read_socks_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & read_handler_class, (char *)"read_socks", (size_t )sizeof(struct read_socks ),
    & do_read_socks_mark, & do_read_socks_free};
#line 138 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c.x"
static struct command *forward_socks(struct address_info *local ) 
{ 
  struct command *res ;
  struct lsh_object *tmp ;
  struct command *tmp___0 ;
  struct command *tmp___1 ;
  struct command *tmp___2 ;
  struct command *tmp___3 ;
  struct command *tmp___4 ;

  {
  {
  {
#line 167
  tmp = gaba_apply(& command_K.super.super, (struct lsh_object *)local);
  }
  {
#line 167
  tmp___0 = make_command_3_invoke_2(& command_B, & bind_address_command.super, tmp);
  }
  {
#line 167
  tmp___1 = make_command_3_invoke(& command_C, & socks_handshake.super.super);
  }
  {
#line 167
  tmp___2 = make_command_3_invoke_2(& command_B, & listen_command.super.super, (struct lsh_object *)tmp___1);
  }
  {
#line 167
  tmp___3 = make_command_3_invoke_2(& command_S, (struct lsh_object *)tmp___2, (struct lsh_object *)tmp___0);
  }
  {
#line 167
  tmp___4 = make_command_3_invoke_2(& command_S, & connection_remember.super.super,
                                    (struct lsh_object *)tmp___3);
  }
#line 167
  res = (struct command *)((struct lsh_object *)tmp___4);
  }
#line 175
  return (res);
}
}
#line 113 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static void socks_close(struct socks_connection *self ) 
{ 


  {
  {
  {
#line 116
  close_fd_nicely((self->peer)->fd);
  }
  }
#line 117
  return;
}
}
#line 119 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static void socks_fail(struct socks_connection *self ) 
{ 


  {
  {
  {
#line 122
  close_fd((self->peer)->fd);
  }
  }
#line 123
  return;
}
}
#line 125 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static void socks_write(struct socks_connection *self , struct lsh_string *data ) 
{ 


  {
  {
  {
#line 128
  (*((((self->peer)->fd)->write_buffer)->super.write))(& (((self->peer)->fd)->write_buffer)->super,
                                                       data);
  }
  }
#line 129
  return;
}
}
#line 131 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static void socks_method(struct socks_connection *self , uint8_t method ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 134
  tmp = ssh_format("%c%c", (int )self->version, (int )method);
  }
  {
#line 134
  socks_write(self, tmp);
  }
  }
#line 135
  return;
}
}
#line 137 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static void socks_reply(struct socks_connection *self , uint8_t status , uint8_t atype ,
                        uint32_t alength , uint8_t const   *addr , uint16_t port ) 
{ 
  struct lsh_string *tmp ;
  int tmp___0 ;
  struct lsh_string *tmp___1 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 150
  if ((int )self->version == 5) {
#line 150
    goto case_5;
  }
#line 156
  if ((int )self->version == 4) {
#line 156
    goto case_4;
  }
#line 147
  goto switch_default;
  switch_default: 
  {
  {
#line 148
  fatal("socks_reply: Internal error\n");
  }
  }
  case_5: 
  {
  {
#line 151
  tmp = ssh_format("%c%c%c%c%ls%c%c", (int )self->version, (int )status, 0, (int )atype,
                   alength, addr, (int )port >> 8, (int )port & 255);
  }
  {
#line 151
  socks_write(self, tmp);
  }
  }
#line 155
  goto switch_break;
  case_4: 
#line 157
  if (! ((int )atype == 1)) {
    {
    {
#line 157
    __assert_fail("atype == SOCKS_IP4", "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c",
                  157U, "socks_reply");
    }
    }
  }
#line 158
  if (! (alength == 4U)) {
    {
    {
#line 158
    __assert_fail("alength == 4", "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c",
                  158U, "socks_reply");
    }
    }
  }
#line 160
  if (status) {
#line 160
    tmp___0 = 91;
  } else {
#line 160
    tmp___0 = 90;
  }
  {
  {
#line 160
  tmp___1 = ssh_format("%c%c%c%c%ls", 0, tmp___0, (int )port >> 8, (int )port & 255,
                       alength, addr);
  }
  {
#line 160
  socks_write(self, tmp___1);
  }
  }
#line 164
  goto switch_break;
  switch_break: ;
#line 166
  return;
}
}
#line 168 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static struct address_info *socks2address_info(uint8_t atype , uint8_t const   *addr ,
                                               uint16_t port ) 
{ 
  struct lsh_string *host ;
  struct address_info *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 181
  if ((int )atype == 1) {
#line 181
    goto case_1;
  }
#line 184
  if ((int )atype == 4) {
#line 184
    goto case_4;
  }
#line 194
  if ((int )atype == 3) {
#line 194
    goto case_3;
  }
#line 178
  goto switch_default;
  switch_default: 
  {
  {
#line 179
  abort();
  }
  }
  case_1: 
  {
  {
#line 182
  host = ssh_format("%di.%di.%di.%di", (int const   )*(addr + 0), (int const   )*(addr + 1),
                    (int const   )*(addr + 2), (int const   )*(addr + 3));
  }
  }
#line 183
  goto switch_break;
  case_4: 
  {
  {
#line 189
  host = lsh_string_ntop(10, (uint32_t )46, (void const   *)addr);
  }
  }
#line 190
  goto switch_break;
  case_3: 
  {
  {
#line 195
  host = ssh_format("%ls", (int const   )*(addr + 0), addr + 1);
  }
  }
#line 196
  goto switch_break;
  switch_break: 
  {
  {
#line 198
  tmp = make_address_info(host, (uint32_t )port);
  }
  }
#line 198
  return (tmp);
}
}
#line 215
static void do_socks_continuation(struct command_continuation *s , struct lsh_object *x ) ;
#line 215 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static uint8_t noaddr[4]  = {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0};
#line 209 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static void do_socks_continuation(struct command_continuation *s , struct lsh_object *x ) 
{ 
  struct socks_continuation *self ;
  struct channel_forward *channel ;

  {
  {
#line 212
  self = (struct socks_continuation *)s;
#line 213
  channel = (struct channel_forward *)x;
  {
#line 218
  socks_reply(self->socks, (uint8_t )0, (uint8_t )1, (uint32_t )4, (uint8_t const   *)(noaddr),
              (uint16_t )0);
  }
  {
#line 221
  channel_forward_start_io_read(channel);
  }
  }
#line 222
  return;
}
}
#line 224 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static struct command_continuation *make_socks_continuation(struct socks_connection *socks ) 
{ 
  struct socks_continuation *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 227
  tmp = lsh_object_alloc(& socks_continuation_class);
  }
#line 227
  self = (struct socks_continuation *)tmp;
#line 228
  self->super.c = & do_socks_continuation;
#line 229
  self->socks = socks;
  }
#line 231
  return (& self->super);
}
}
#line 259
static void do_exc_socks_handler(struct exception_handler *s , struct exception  const  *e ) ;
#line 259 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static uint8_t noaddr___0[4]  = {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )0};
#line 242 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static void do_exc_socks_handler(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct socks_exception_handler *self ;
  struct io_exception *exc ;
  struct channel_open_exception *exc___0 ;
  uint8_t reply ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 246
  self = (struct socks_exception_handler *)s;
#line 247
  if (e->type & 8192U) {
#line 249
    exc = (struct io_exception *)e;
#line 250
    if (exc->fd) {
      {
      {
#line 251
      close_fd(exc->fd);
      }
      }
    }
    {
    {
#line 253
    werror("Socks: %z, (errno = %i)\n", e->msg, exc->error);
    }
    }
  } else
#line 255
  if (e->type == 32771U) {
#line 257
    exc___0 = (struct channel_open_exception *)e;
#line 258
    reply = (uint8_t )1;
#line 261
    if (exc___0->error_code == 1U) {
#line 262
      reply = (uint8_t )2;
    } else
#line 263
    if (exc___0->error_code == 2U) {
#line 264
      reply = (uint8_t )5;
    }
    {
    {
#line 266
    verbose("Socks forwarding denied by server: %z\n", e->msg);
    }
    {
#line 267
    socks_reply(self->socks, reply, (uint8_t )1, (uint32_t )4, (uint8_t const   *)(noaddr___0),
                (uint16_t )0);
    }
    }
  } else {
    {
    {
#line 270
    (*((self->super.parent)->raise))(self->super.parent, e);
    }
    }
  }
#line 271
  return;
}
}
#line 273 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static struct exception_handler *make_socks_exception_handler(struct socks_connection *socks ,
                                                              struct exception_handler *e ,
                                                              char const   *context ) 
{ 
  struct socks_exception_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 278
  tmp = lsh_object_alloc(& socks_exception_handler_class);
  }
#line 278
  self = (struct socks_exception_handler *)tmp;
#line 279
  self->super.parent = e;
#line 280
  self->super.raise = & do_exc_socks_handler;
#line 281
  self->super.context = context;
#line 283
  self->socks = socks;
  }
#line 284
  return (& self->super);
}
}
#line 292
static int socks_command(struct socks_connection *self , uint8_t command , uint8_t addr_type ,
                         uint8_t const   *addr , uint16_t port ) ;
#line 292 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static uint8_t const   noaddr___1[4]  = {      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 287 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static int socks_command(struct socks_connection *self , uint8_t command , uint8_t addr_type ,
                         uint8_t const   *addr , uint16_t port ) 
{ 
  struct address_info *target ;
  struct address_info *tmp ;
  struct command *open_command ;
  struct exception_handler *tmp___0 ;
  struct command_continuation *tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 293
  if ((int )command != 1) {
    {
    {
#line 295
    socks_reply(self, (uint8_t )7, (uint8_t )1, (uint32_t )sizeof(noaddr___1), noaddr___1,
                (uint16_t )0);
    }
    }
#line 296
    return (0);
  } else {
    {
    {
#line 300
    tmp = socks2address_info(addr_type, addr, port);
    }
#line 300
    target = tmp;
    }
#line 303
    if (! target) {
      {
      {
#line 305
      socks_reply(self, (uint8_t )8, (uint8_t )1, (uint32_t )sizeof(noaddr___1), noaddr___1,
                  (uint16_t )0);
      }
      }
#line 306
      return (0);
    }
    {
    {
#line 309
    open_command = make_open_tcpip_command(70, target, self->peer);
    }
    {
#line 310
    tmp___0 = make_socks_exception_handler(self, & default_exception_handler, "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c:314");
    }
    {
#line 310
    tmp___1 = make_socks_continuation(self);
    }
    {
#line 310
    (*(open_command->call))(open_command, (struct lsh_object *)self->connection, tmp___1,
                            tmp___0);
    }
    }
#line 315
    return (1);
  }
}
}
#line 331 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static uint32_t do_read_socks(struct read_handler **h___0 , uint32_t available , uint8_t const   *data ) 
{ 
  struct read_socks *self ;
  uint8_t const   *p ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 336
  self = (struct read_socks *)*h___0;
#line 339
  if (! self->buffer) {
    {
    {
#line 339
    __assert_fail("self->buffer", "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c",
                  339U, "do_read_socks");
    }
    }
  }
#line 341
  if (! available) {
    {
    {
#line 343
    socks_close(self->socks);
    }
#line 345
    *h___0 = (struct read_handler *)((void *)0);
    }
#line 346
    return ((uint32_t )0);
  }
#line 349
  if (self->length - self->pos > available) {
    {
    {
#line 351
    lsh_string_write(self->buffer, self->pos, available, data);
    }
#line 352
    self->pos += available;
    }
#line 353
    return (available);
  }
  {
#line 356
  available = self->length - self->pos;
  {
#line 357
  lsh_string_write(self->buffer, self->pos, available, data);
  }
#line 358
  self->pos = self->length;
  {
#line 360
  p = lsh_string_data((struct lsh_string  const  *)self->buffer);
  }
  }
#line 383
  if ((unsigned int )self->state == 0U) {
#line 383
    goto case_0;
  }
#line 406
  if ((unsigned int )self->state == 1U) {
#line 406
    goto case_1;
  }
#line 424
  if ((unsigned int )self->state == 2U) {
#line 424
    goto case_2;
  }
#line 467
  if ((unsigned int )self->state == 3U) {
#line 467
    goto case_3___0;
  }
#line 483
  if ((unsigned int )self->state == 4U) {
#line 483
    goto case_4___1;
  }
#line 364
  goto switch_default;
  switch_default: 
  {
  {
#line 365
  abort();
  }
  }
  case_0: 
  {
#line 384
  (self->socks)->version = (uint8_t )*(p + 0);
  {
#line 385
  verbose("Socks version %i connection.\n", (int )(self->socks)->version);
  }
  }
#line 394
  if ((int )(self->socks)->version == 4) {
#line 394
    goto case_4;
  }
#line 399
  if ((int )(self->socks)->version == 5) {
#line 399
    goto case_5;
  }
#line 389
  goto switch_default___0;
  switch_default___0: 
  {
  {
#line 390
  werror("Socks connection of unknown version %i.\n", (int const   )*(p + 0));
  }
  {
#line 391
  socks_fail(self->socks);
  }
  }
#line 392
  goto switch_break___0;
  case_4: 
#line 395
  self->length = (uint32_t )9;
#line 396
  self->state = (enum socks_state )4;
#line 397
  goto switch_break___0;
  case_5: 
#line 400
  self->length = (uint32_t )(2 + (int )*(p + 1));
#line 401
  self->state = (enum socks_state )1;
#line 402
  goto switch_break___0;
  switch_break___0: ;
#line 404
  goto switch_break;
  case_1: 
  {
  {
#line 408
  tmp = memchr((void const   *)(p + 2), 0, (size_t )*(p + 1));
  }
  }
#line 408
  if (tmp) {
    {
    {
#line 410
    socks_method(self->socks, (uint8_t )0);
    }
#line 412
    self->pos = (uint32_t )0;
#line 413
    self->length = (uint32_t )5;
#line 414
    self->state = (enum socks_state )2;
    }
  } else {
    {
    {
#line 418
    werror("Socks client doesn\'t support no authentication!?\n");
    }
    {
#line 419
    socks_method(self->socks, (uint8_t )255);
    }
    {
#line 420
    socks_close(self->socks);
    }
    }
  }
#line 422
  goto switch_break;
  case_2: 
#line 441
  if ((int const   )*(p + 0) != (int const   )(self->socks)->version) {
    {
    {
#line 443
    werror("Invalid socks request.\n");
    }
    {
#line 444
    socks_fail(self->socks);
    }
    }
  } else
#line 441
  if ((int const   )*(p + 2) != 0) {
    {
    {
#line 443
    werror("Invalid socks request.\n");
    }
    {
#line 444
    socks_fail(self->socks);
    }
    }
  } else {
#line 448
    self->state = (enum socks_state )3;
#line 452
    if ((int const   )*(p + 3) == 1) {
#line 452
      goto case_1___0;
    }
#line 455
    if ((int const   )*(p + 3) == 4) {
#line 455
      goto case_4___0;
    }
#line 458
    if ((int const   )*(p + 3) == 3) {
#line 458
      goto case_3;
    }
#line 450
    goto switch_break___1;
    case_1___0: 
#line 453
    self->length = (uint32_t )10;
#line 454
    goto switch_break___1;
    case_4___0: 
#line 456
    self->length = (uint32_t )22;
#line 457
    goto switch_break___1;
    case_3: 
#line 459
    if ((int const   )*(p + 4) == 0) {
      {
      {
#line 460
      socks_fail(self->socks);
      }
      }
    } else {
#line 462
      self->length = (uint32_t )(7 + (int )*(p + 4));
    }
    switch_break___1: ;
  }
#line 465
  goto switch_break;
  case_3___0: 
  {
  {
#line 468
  tmp___0 = socks_command(self->socks, (uint8_t )*(p + 1), (uint8_t )*(p + 3), p + 4,
                          (uint16_t )(((uint32_t )*(((p + self->length) - 2) + 0) << 8) | (uint32_t )*(((p + self->length) - 2) + 1)));
  }
  }
#line 468
  if (tmp___0) {
#line 471
    self->state = (enum socks_state )5;
  } else {
    {
    {
#line 475
    socks_fail(self->socks);
    }
    }
  }
  {
  {
#line 478
  lsh_string_free((struct lsh_string  const  *)self->buffer);
  }
#line 479
  self->buffer = (struct lsh_string *)((void *)0);
#line 480
  *h___0 = (struct read_handler *)((void *)0);
  }
#line 481
  goto switch_break;
  case_4___1: 
#line 484
  if ((int const   )*(p + 8) != 0) {
    {
    {
#line 488
    werror("Socks 4 usernames not yet supported. May or may not work.\n");
    }
    }
  }
  {
  {
#line 490
  tmp___1 = socks_command(self->socks, (uint8_t )*(p + 1), (uint8_t )1, p + 4, (uint16_t )(((uint32_t )*((p + 2) + 0) << 8) | (uint32_t )*((p + 2) + 1)));
  }
  }
#line 490
  if (tmp___1) {
#line 493
    self->state = (enum socks_state )5;
  } else {
    {
    {
#line 497
    socks_fail(self->socks);
    }
    }
  }
  {
  {
#line 500
  lsh_string_free((struct lsh_string  const  *)self->buffer);
  }
#line 501
  self->buffer = (struct lsh_string *)((void *)0);
#line 502
  *h___0 = (struct read_handler *)((void *)0);
  }
#line 503
  goto switch_break;
  switch_break: ;
#line 506
  return (available);
}
}
#line 509 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static struct read_handler *make_read_socks(struct socks_connection *socks ) 
{ 
  struct read_socks *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 512
  tmp = lsh_object_alloc(& read_socks_class);
  }
#line 512
  self = (struct read_socks *)tmp;
#line 514
  self->super.handler = & do_read_socks;
#line 515
  self->socks = socks;
  {
#line 516
  self->buffer = lsh_string_alloc((uint32_t )262);
  }
#line 517
  self->pos = (uint32_t )0;
#line 518
  self->state = (enum socks_state )0;
#line 519
  self->length = (uint32_t )2;
  }
#line 521
  return (& self->super);
}
}
#line 530
static void do_socks_handshake(struct command_2 *s  __attribute__((__unused__)) ,
                               struct lsh_object *a1 , struct lsh_object *a2 , struct command_continuation *c ,
                               struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 530 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
struct command_2 socks_handshake  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_2}, & do_socks_handshake};
#line 530 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
static void do_socks_handshake(struct command_2 *s  __attribute__((__unused__)) ,
                               struct lsh_object *a1 , struct lsh_object *a2 , struct command_continuation *c ,
                               struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct listen_value *peer ;
  struct ssh_connection *connection ;
  struct socks_connection *self ;
  struct lsh_object *tmp ;
  struct read_handler *tmp___0 ;
  struct io_callback *tmp___1 ;

  {
  {
#line 537
  peer = (struct listen_value *)a1;
#line 538
  connection = (struct ssh_connection *)a2;
  {
#line 539
  tmp = lsh_object_alloc(& socks_connection_class);
  }
#line 539
  self = (struct socks_connection *)tmp;
#line 541
  self->connection = connection;
#line 542
  self->peer = peer;
  {
#line 543
  remember_resource(connection->resources, & (peer->fd)->super);
  }
  {
#line 545
  tmp___0 = make_read_socks(self);
  }
  {
#line 545
  tmp___1 = make_buffered_read((uint32_t )100, tmp___0);
  }
  {
#line 545
  io_read_write(peer->fd, tmp___1, (uint32_t )327680, (struct lsh_callback *)((void *)0));
  }
  {
#line 548
  (*(c->c))(c, (struct lsh_object *)self);
  }
  }
#line 549
  return;
}
}
#line 568 "/home/ysko/Works/test-src/lsh-2.0.4/src/socks.c"
struct command *make_socks_server(struct address_info *local ) 
{ 
  struct command *tmp ;

  {
  {
  {
#line 571
  tmp = forward_socks(local);
  }
  }
#line 571
  return (tmp);
}
}
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/sexp.h"
struct lsh_string *lsh_sexp_copy(struct sexp_iterator *i ) ;
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms.h"
int lookup_atom(uint32_t length , uint8_t const   *name ) ;
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/sexp.c"
int lsh_sexp_to_atom(struct sexp_iterator *i ) 
{ 
  int type ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 48
  if ((unsigned int )i->type != 0U) {
#line 49
    return (0);
  } else
#line 48
  if (i->display) {
#line 49
    return (0);
  }
  {
  {
#line 51
  type = lookup_atom(i->atom_length, i->atom);
  }
  {
#line 53
  tmp___1 = nettle_sexp_iterator_next(i);
  }
  }
#line 53
  if (tmp___1) {
#line 53
    tmp___0 = type;
  } else {
#line 53
    tmp___0 = 0;
  }
#line 53
  return (tmp___0);
}
}
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/sexp.c"
int lsh_sexp_get_type(struct sexp_iterator *i ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 60
  tmp = nettle_sexp_iterator_enter_list(i);
  }
  }
#line 60
  if (! tmp) {
#line 61
    return (0);
  }
  {
  {
#line 63
  tmp___0 = lsh_sexp_to_atom(i);
  }
  }
#line 63
  return (tmp___0);
}
}
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/sexp.c"
struct lsh_string *lsh_sexp_to_string(struct sexp_iterator *i , struct lsh_string **display ) 
{ 
  struct lsh_string *s ;
  struct lsh_string *tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 71
  if ((unsigned int )i->type != 0U) {
#line 72
    return ((struct lsh_string *)((void *)0));
  }
#line 74
  if (display) {
#line 76
    if (i->display) {
      {
      {
#line 76
      tmp = ssh_format("%ls", i->display_length, i->display);
      }
#line 76
      *display = tmp;
      }
    } else {
#line 76
      *display = (struct lsh_string *)((void *)0);
    }
  } else
#line 79
  if (i->display) {
#line 80
    return ((struct lsh_string *)((void *)0));
  }
  {
  {
#line 82
  s = ssh_format("%ls", i->atom_length, i->atom);
  }
  {
#line 84
  tmp___0 = nettle_sexp_iterator_next(i);
  }
  }
#line 84
  if (tmp___0) {
#line 85
    return (s);
  }
  {
  {
#line 87
  lsh_string_free((struct lsh_string  const  *)s);
  }
  }
#line 88
  if (display) {
    {
    {
#line 90
    lsh_string_free((struct lsh_string  const  *)*display);
    }
#line 91
    *display = (struct lsh_string *)((void *)0);
    }
  }
#line 93
  return ((struct lsh_string *)((void *)0));
}
}
#line 97 "/home/ysko/Works/test-src/lsh-2.0.4/src/sexp.c"
struct lsh_string *lsh_sexp_copy(struct sexp_iterator *i ) 
{ 
  unsigned int length ;
  uint8_t const   *subexpr ;
  uint8_t const   *tmp ;
  struct lsh_string *tmp___0 ;
  struct lsh_string *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 101
  tmp = nettle_sexp_iterator_subexpr(i, & length);
  }
#line 101
  subexpr = tmp;
  }
#line 103
  if (subexpr) {
    {
    {
#line 103
    tmp___0 = ssh_format("%ls", length, subexpr);
    }
#line 103
    tmp___1 = tmp___0;
    }
  } else {
#line 103
    tmp___1 = (struct lsh_string *)((void *)0);
  }
#line 103
  return (tmp___1);
}
}
#line 312 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 842 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h"
struct exception_handler *make_report_exception_handler(struct report_exception_info  const  *info ,
                                                        struct exception_handler *parent ,
                                                        char const   *context ) ;
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.h.x"
struct lsh_class server_x11_info_class ;
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.h"
struct server_x11_info *server_x11_setup(struct ssh_channel *channel , struct lsh_user *user ,
                                         int single , uint32_t protocol_length , uint8_t const   *protocol ,
                                         uint32_t cookie_length , uint8_t const   *cookie ,
                                         uint32_t screen , struct command_continuation *c ,
                                         struct exception_handler *e ) ;
#line 333 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
struct lsh_fd *io_bind_sockaddr(struct sockaddr *local , socklen_t length , struct exception_handler *e ) ;
#line 338
struct lsh_fd *io_listen(struct lsh_fd *fd , struct io_callback *callback ) ;
#line 356
struct io_callback *make_listen_callback(struct command *c , struct exception_handler *e ) ;
#line 384
void close_fd_write(struct lsh_fd *fd ) ;
#line 411
int lsh_pushd_fd(int dir ) ;
#line 414
int lsh_pushd(char const   *directory , int *result , int create , int secret ) ;
#line 418
void lsh_popd(int old_cd , char const   *directory ) ;
#line 363 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int snprintf(char * __restrict  __s , size_t __maxlen ,
                                                  char const   * __restrict  __format 
                                                  , ...) ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.h.x"
static void do_server_x11_info_free(struct lsh_object *o ) 
{ 
  struct server_x11_info *i ;

  {
  {
#line 18
  i = (struct server_x11_info *)o;
  {
#line 19
  lsh_string_free((struct lsh_string  const  *)i->display);
  }
  {
#line 20
  lsh_string_free((struct lsh_string  const  *)i->xauthority);
  }
  }
#line 21
  return;
}
}
#line 22 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.h.x"
struct lsh_class server_x11_info_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"server_x11_info", (size_t )sizeof(struct server_x11_info ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_server_x11_info_free};
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c"
struct command open_forwarded_x11 ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c.x"
struct lsh_class channel_open_command_x11_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c.x"
static void do_channel_open_command_x11_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct channel_open_command_x11 *i ;

  {
  {
#line 18
  i = (struct channel_open_command_x11 *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->peer);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c.x"
struct lsh_class channel_open_command_x11_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_open_command_class, (char *)"channel_open_command_x11", (size_t )sizeof(struct channel_open_command_x11 ),
    & do_channel_open_command_x11_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c.x"
static struct command *server_x11_callback(struct ssh_connection *connection ) 
{ 
  struct command *res ;
  struct command *tmp ;
  struct command *tmp___0 ;

  {
  {
  {
#line 61
  tmp = make_command_4_invoke_3(& command_Cp, & catch_channel_open.super.super, & open_forwarded_x11.super,
                                (struct lsh_object *)connection);
  }
  {
#line 61
  tmp___0 = make_command_3_invoke_2(& command_B, & start_io_command.super, (struct lsh_object *)tmp);
  }
#line 61
  res = (struct command *)((struct lsh_object *)tmp___0);
  }
#line 67
  return (res);
}
}
#line 108
struct lsh_class server_x11_socket_class ;
#line 112 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c.x"
static void do_server_x11_socket_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct server_x11_socket *i ;

  {
  {
#line 116
  i = (struct server_x11_socket *)o;
  {
#line 117
  (*mark)((struct lsh_object *)i->fd);
  }
  }
#line 118
  return;
}
}
#line 119 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c.x"
static void do_server_x11_socket_free(struct lsh_object *o ) 
{ 
  struct server_x11_socket *i ;

  {
  {
#line 122
  i = (struct server_x11_socket *)o;
  {
#line 123
  lsh_string_free((struct lsh_string  const  *)i->name);
  }
  }
#line 124
  return;
}
}
#line 125 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c.x"
struct lsh_class server_x11_socket_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & resource_class, (char *)"server_x11_socket", (size_t )sizeof(struct server_x11_socket ),
    & do_server_x11_socket_mark, & do_server_x11_socket_free};
#line 146
struct lsh_class xauth_exit_callback_class ;
#line 150 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c.x"
static void do_xauth_exit_callback_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct xauth_exit_callback *i ;

  {
  {
#line 154
  i = (struct xauth_exit_callback *)o;
  {
#line 155
  (*mark)((struct lsh_object *)i->c);
  }
  {
#line 156
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 157
  return;
}
}
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c.x"
struct lsh_class xauth_exit_callback_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exit_callback_class, (char *)"xauth_exit_callback", (size_t )sizeof(struct xauth_exit_callback ),
    & do_xauth_exit_callback_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 84 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c"
static struct ssh_channel *new_x11_channel(struct channel_open_command *c , struct ssh_connection *connection ,
                                           uint32_t local_channel_number , struct lsh_string **request ) 
{ 
  struct channel_open_command_x11 *self ;
  struct ssh_channel *channel ;
  struct channel_forward *tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 90
  self = (struct channel_open_command_x11 *)c;
  {
#line 97
  debug("server_x11.c: new_x11_channel\n");
  }
  {
#line 99
  tmp = make_channel_forward((self->peer)->fd, (uint32_t )10000);
  }
#line 99
  channel = & tmp->super;
#line 100
  channel->connection = connection;
  {
#line 107
  *request = format_channel_open(55, local_channel_number, channel, "%z%i", "unix-domain",
                                 0);
  }
  }
#line 111
  return (channel);
}
}
#line 114
static void do_open_forwarded_x11(struct command *s  __attribute__((__unused__)) ,
                                  struct lsh_object *x , struct command_continuation *c ,
                                  struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 114 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c"
struct command open_forwarded_x11  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_open_forwarded_x11};
#line 114 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c"
static void do_open_forwarded_x11(struct command *s  __attribute__((__unused__)) ,
                                  struct lsh_object *x , struct command_continuation *c ,
                                  struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct listen_value *peer ;
  struct channel_open_command_x11 *self ;
  struct lsh_object *tmp ;

  {
  {
#line 120
  peer = (struct listen_value *)x;
  {
#line 122
  tmp = lsh_object_alloc(& channel_open_command_x11_class);
  }
#line 122
  self = (struct channel_open_command_x11 *)tmp;
#line 123
  self->super.super.call = & do_channel_open_command;
#line 124
  self->super.new_channel = & new_x11_channel;
#line 126
  self->peer = peer;
  {
#line 128
  (*(c->c))(c, (struct lsh_object *)self);
  }
  }
#line 129
  return;
}
}
#line 181 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c"
static void delete_x11_socket(struct server_x11_socket *self ) 
{ 
  int *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 184
  tmp___0 = lsh_get_cstring((struct lsh_string  const  *)self->name);
  }
  {
#line 184
  tmp___1 = unlink(tmp___0);
  }
  }
#line 184
  if (tmp___1 < 0) {
    {
    {
#line 185
    tmp = __errno_location();
    }
    {
#line 185
    werror("Failed to delete x11 socket %S for user %i %e\n", self->name, self->uid,
           *tmp);
    }
    }
  }
#line 187
  return;
}
}
#line 189 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c"
static void do_kill_x11_socket(struct resource *s ) 
{ 
  struct server_x11_socket *self ;
  uid_t me ;
  __uid_t tmp ;
  int old_cd ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  int tmp___2 ;
  __uid_t tmp___3 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
  {
#line 192
  self = (struct server_x11_socket *)s;
  {
#line 193
  tmp = geteuid();
  }
#line 193
  me = tmp;
  }
#line 196
  if (self->super.alive) {
#line 198
    self->super.alive = 0;
#line 200
    if (! self->fd) {
      {
      {
#line 200
      __assert_fail("self->fd", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c",
                    200U, "do_kill_x11_socket");
      }
      }
    }
    {
    {
#line 201
    close_fd(self->fd);
    }
    }
#line 203
    if (! (self->dir >= 0)) {
      {
      {
#line 203
      __assert_fail("self->dir >= 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c",
                    203U, "do_kill_x11_socket");
      }
      }
    }
    {
    {
#line 206
    old_cd = lsh_pushd_fd(self->dir);
    }
    }
#line 207
    if (old_cd < 0) {
#line 208
      return;
    }
    {
    {
#line 210
    close(self->dir);
    }
#line 211
    self->dir = -1;
    }
#line 213
    if (me == self->uid) {
      {
      {
#line 214
      delete_x11_socket(self);
      }
      }
    } else {
      {
      {
#line 217
      tmp___0 = seteuid(self->uid);
      }
      }
#line 217
      if (tmp___0 < 0) {
        {
        {
#line 219
        werror("Couldn\'t change euid (to %i) for deleting x11 socket.\n", self->uid);
        }
        }
#line 221
        goto done;
      }
      {
      {
#line 223
      tmp___1 = geteuid();
      }
      }
#line 223
      if (! (tmp___1 == self->uid)) {
        {
        {
#line 223
        __assert_fail("geteuid() == self->uid", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c",
                      223U, "do_kill_x11_socket");
        }
        }
      }
      {
      {
#line 225
      delete_x11_socket(self);
      }
      {
#line 227
      tmp___2 = seteuid(me);
      }
      }
#line 227
      if (tmp___2 < 0) {
        {
        {
#line 229
        fatal("Failed to restore euid after deleting x11 socket.\n");
        }
        }
      }
      {
      {
#line 231
      tmp___3 = geteuid();
      }
      }
#line 231
      if (! (tmp___3 == me)) {
        {
        {
#line 231
        __assert_fail("geteuid() == me", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c",
                      231U, "do_kill_x11_socket");
        }
        }
      }
    }
    done: 
    {
    {
#line 235
    lsh_popd(old_cd, "/tmp/.X11-unix");
    }
    }
  }
#line 237
  return;
}
}
#line 240 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c"
static struct server_x11_socket *open_x11_socket(struct ssh_channel *channel ) 
{ 
  int old_cd ;
  int dir ;
  mode_t old_umask ;
  int number ;
  struct lsh_fd *s ;
  struct lsh_string *name ;
  int *tmp ;
  struct sockaddr_un sa ;
  size_t tmp___0 ;
  struct command *callback ;
  struct command *tmp___1 ;
  struct io_callback *tmp___2 ;
  struct lsh_fd *tmp___3 ;
  struct server_x11_socket *self ;
  struct lsh_object *tmp___4 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 249
  name = (struct lsh_string *)((void *)0);
  {
#line 254
  old_umask = umask((__mode_t )63);
  }
  {
#line 256
  old_cd = lsh_pushd("/tmp/.X11-unix", & dir, 0, 0);
  }
  }
#line 257
  if (old_cd < 0) {
    {
    {
#line 259
    tmp = __errno_location();
    }
    {
#line 259
    werror("Failed to cd to `%z\' %e\n", "/tmp/.X11-unix", *tmp);
    }
    {
#line 261
    umask(old_umask);
    }
    }
#line 262
    return ((struct server_x11_socket *)((void *)0));
  }
#line 265
  number = 10;
  {
  {
#line 265
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 265
    if (! (number <= 1000)) {
#line 265
      goto while_break;
    }
    {
#line 271
    sa.sun_family = (sa_family_t )1;
#line 272
    sa.sun_path[sizeof(sa.sun_path) - 1UL] = (char )'\000';
    {
#line 273
    snprintf((char */* __restrict  */)(sa.sun_path), (size_t )sizeof(sa.sun_path),
             (char const   */* __restrict  */)"X%d", number);
    }
    {
#line 275
    tmp___0 = strlen((char const   *)(sa.sun_path));
    }
    {
#line 275
    s = io_bind_sockaddr((struct sockaddr *)(& sa), (size_t )(((struct sockaddr_un *)0)->sun_path) + tmp___0,
                         (channel->connection)->e);
    }
    }
#line 282
    if (s) {
      {
      {
#line 285
      name = ssh_format("%lz", sa.sun_path);
      }
      }
#line 286
      goto while_break;
    }
#line 265
    number ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 290
  umask(old_umask);
  }
  {
#line 292
  lsh_popd(old_cd, "/tmp/.X11-unix");
  }
  }
#line 294
  if (! name) {
    {
    {
#line 297
    close(dir);
    }
    }
#line 299
    return ((struct server_x11_socket *)((void *)0));
  }
  {
  {
#line 303
  tmp___1 = server_x11_callback(channel->connection);
  }
#line 303
  callback = tmp___1;
  {
#line 305
  tmp___2 = make_listen_callback(callback, (channel->connection)->e);
  }
  {
#line 305
  tmp___3 = io_listen(s, tmp___2);
  }
  }
#line 305
  if (! tmp___3) {
    {
    {
#line 308
    close(dir);
    }
    {
#line 309
    close_fd(s);
    }
    }
#line 310
    return ((struct server_x11_socket *)((void *)0));
  }
  {
  {
#line 314
  tmp___4 = lsh_object_alloc(& server_x11_socket_class);
  }
#line 314
  self = (struct server_x11_socket *)tmp___4;
  {
#line 315
  init_resource(& self->super, & do_kill_x11_socket);
  }
#line 317
  self->dir = dir;
#line 318
  self->name = name;
#line 319
  self->fd = s;
#line 320
  self->display_number = number;
  {
#line 322
  remember_resource(channel->resources, & self->super);
  }
  }
#line 323
  return (self);
}
}
#line 328 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c"
static struct server_x11_socket *server_x11_listen(struct ssh_channel *channel ) 
{ 
  struct server_x11_socket *s ;
  uid_t me ;
  __uid_t tmp ;
  uid_t user ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  int tmp___2 ;
  __uid_t tmp___3 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
  {
#line 333
  tmp = geteuid();
  }
#line 333
  me = tmp;
#line 334
  user = ((channel->connection)->user)->uid;
  }
#line 336
  if (me == ((channel->connection)->user)->uid) {
    {
    {
#line 337
    s = open_x11_socket(channel);
    }
    }
  } else {
    {
    {
#line 340
    tmp___0 = seteuid(user);
    }
    }
#line 340
    if (tmp___0 < 0) {
      {
      {
#line 343
      werror("Couldn\'t change euid (to %i) for creating x11 socket.\n", user);
      }
      }
#line 345
      return ((struct server_x11_socket *)((void *)0));
    }
    {
    {
#line 348
    tmp___1 = geteuid();
    }
    }
#line 348
    if (! (tmp___1 == user)) {
      {
      {
#line 348
      __assert_fail("geteuid() == user", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c",
                    348U, "server_x11_listen");
      }
      }
    }
    {
    {
#line 350
    s = open_x11_socket(channel);
    }
    {
#line 352
    tmp___2 = seteuid(me);
    }
    }
#line 352
    if (tmp___2 < 0) {
      {
      {
#line 354
      fatal("Failed to restore euid after deleting x11 socket.\n");
      }
      }
    }
    {
    {
#line 356
    tmp___3 = geteuid();
    }
    }
#line 356
    if (! (tmp___3 == me)) {
      {
      {
#line 356
      __assert_fail("geteuid() == me", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c",
                    356U, "server_x11_listen");
      }
      }
    }
  }
#line 358
  return (s);
}
}
#line 370 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c"
static void do_xauth_exit(struct exit_callback *s , int signaled , int core  __attribute__((__unused__)) ,
                          int value ) 
{ 
  struct xauth_exit_callback *self ;
  struct exception xauth_failed ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 374
  self = (struct xauth_exit_callback *)s;
#line 376
  if (signaled) {
#line 376
    goto _L;
  } else
#line 376
  if (value) {
    _L: 
    {
#line 379
    xauth_failed.super.next = (struct lsh_object *)((void *)0);
#line 379
    xauth_failed.super.isa = (struct lsh_class *)((void *)0);
#line 379
    xauth_failed.super.alloc_method = (char)1;
#line 379
    xauth_failed.super.marked = (char)0;
#line 379
    xauth_failed.super.dead = (char)0;
#line 379
    xauth_failed.type = (uint32_t )32770;
#line 379
    xauth_failed.msg = "xauth failed";
    {
#line 381
    (*((self->e)->raise))(self->e, (struct exception  const  *)(& xauth_failed));
    }
    }
#line 382
    if (signaled) {
      {
      {
#line 383
      werror("xauth invocation failed: Signal %i\n", value);
      }
      }
    } else {
      {
      {
#line 385
      werror("xauth invocation failed: exit code: %i\n", value);
      }
      }
    }
  } else {
    {
    {
#line 389
    (*((self->c)->c))(self->c, (struct lsh_object *)((void *)0));
    }
    }
  }
#line 390
  return;
}
}
#line 392 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c"
static struct exit_callback *make_xauth_exit_callback(struct command_continuation *c ,
                                                      struct exception_handler *e ) 
{ 
  struct xauth_exit_callback *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 396
  tmp = lsh_object_alloc(& xauth_exit_callback_class);
  }
#line 396
  self = (struct xauth_exit_callback *)tmp;
#line 397
  self->super.exit = & do_xauth_exit;
#line 398
  self->c = c;
#line 399
  self->e = e;
  }
#line 401
  return (& self->super);
}
}
#line 408 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c"
static int bad_string(uint32_t length , uint8_t const   *data ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
  {
#line 411
  tmp = memchr((void const   *)data, '\000', length);
  }
  }
#line 411
  if (tmp) {
#line 411
    tmp___0 = 1;
  } else {
#line 411
    tmp___0 = 0;
  }
#line 411
  return (tmp___0);
}
}
#line 517 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c"
static struct report_exception_info  const  report  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )8192, (uint32_t )8192, "writing xauth stdin"};
#line 420 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c"
struct server_x11_info *server_x11_setup(struct ssh_channel *channel , struct lsh_user *user ,
                                         int single , uint32_t protocol_length , uint8_t const   *protocol ,
                                         uint32_t cookie_length , uint8_t const   *cookie ,
                                         uint32_t screen , struct command_continuation *c ,
                                         struct exception_handler *e ) 
{ 
  struct lsh_string *display ;
  struct lsh_string *xauthority ;
  struct server_x11_socket *socket___0 ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  struct spawn_info spawn ;
  char const   *args[2] ;
  struct env_value env ;
  struct lsh_process *process ;
  int null ;
  int tmp___3 ;
  struct exit_callback *tmp___4 ;
  struct server_x11_info *info ;
  struct lsh_object *tmp___5 ;
  struct lsh_fd *in ;
  struct exception_handler *tmp___6 ;
  struct lsh_fd *tmp___7 ;
  struct lsh_fd *tmp___8 ;
  struct lsh_string *tmp___9 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;

  {
#line 435
  if (single) {
    {
    {
#line 437
    werror("server_x11_setup: Single forwardings not yet supported.\n");
    }
    }
#line 438
    return ((struct server_x11_info *)((void *)0));
  }
  {
  {
#line 441
  tmp___0 = bad_string(protocol_length, protocol);
  }
  }
#line 441
  if (tmp___0) {
    {
    {
#line 443
    werror("server_x11_setup: Bogus protocol name.\n");
    }
    }
#line 444
    return ((struct server_x11_info *)((void *)0));
  }
  {
  {
#line 447
  tmp___1 = bad_string(cookie_length, cookie);
  }
  }
#line 447
  if (tmp___1) {
    {
    {
#line 449
    werror("server_x11_setup: Bogus cookie.\n");
    }
    }
#line 450
    return ((struct server_x11_info *)((void *)0));
  }
#line 453
  if (cookie_length < 10U) {
    {
    {
#line 455
    werror("server_x11_setup: Cookie too small.\n");
    }
    }
#line 456
    return ((struct server_x11_info *)((void *)0));
  }
  {
  {
#line 460
  socket___0 = server_x11_listen(channel);
  }
  }
#line 461
  if (! socket___0) {
#line 462
    return ((struct server_x11_info *)((void *)0));
  }
  {
  {
#line 464
  tmp___2 = getenv("TMPDIR");
  }
#line 464
  tmp = (char const   *)tmp___2;
  }
#line 465
  if (! tmp) {
#line 466
    tmp = "/tmp";
  }
  {
  {
#line 468
  display = ssh_format(":%di.%di", socket___0->display_number, screen);
  }
  {
#line 469
  xauthority = ssh_format("%lz/.lshd.%lS.Xauthority", tmp, user->name);
  }
#line 473
  args[0] = "-c";
#line 473
  args[1] = "/usr/bin/xauth";
#line 480
  env.name = "XAUTHORITY";
#line 481
  env.value = xauthority;
  {
#line 483
  memset((void *)(& spawn), 0, (size_t )sizeof(spawn));
  }
  {
#line 491
  null = open("/dev/null", 1);
  }
  }
#line 493
  if (null < 0) {
#line 494
    goto fail;
  }
  {
  {
#line 497
  tmp___3 = lsh_make_pipe(spawn.in);
  }
  }
#line 497
  if (! tmp___3) {
    {
    {
#line 499
    close(null);
    }
    }
#line 500
    goto fail;
  }
  {
#line 502
  spawn.out[0] = -1;
#line 502
  spawn.out[1] = null;
#line 503
  spawn.err[0] = -1;
#line 503
  spawn.err[1] = null;
#line 505
  spawn.peer = (struct address_info *)((void *)0);
#line 506
  spawn.pty = (struct pty_info *)((void *)0);
#line 507
  spawn.login = 0;
#line 508
  spawn.argc = 2U;
#line 509
  spawn.argv = args;
#line 510
  spawn.env_length = 1U;
#line 511
  spawn.env = (struct env_value  const  *)(& env);
  {
#line 513
  tmp___4 = make_xauth_exit_callback(c, e);
  }
  {
#line 513
  process = (*(user->spawn))(user, & spawn, tmp___4);
  }
  }
#line 514
  if (process) {
    {
    {
#line 516
    tmp___5 = lsh_object_alloc(& server_x11_info_class);
    }
#line 516
    info = (struct server_x11_info *)tmp___5;
    {
#line 520
    tmp___6 = make_report_exception_handler(& report, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/server_x11.c:524");
    }
    {
#line 520
    tmp___7 = make_lsh_fd(spawn.in[1], (enum io_type )0, "xauth stdin", tmp___6);
    }
    {
#line 520
    tmp___8 = io_write(tmp___7, (uint32_t )1024, (struct lsh_callback *)((void *)0));
    }
#line 520
    in = tmp___8;
    {
#line 527
    tmp___9 = ssh_format("add %lS %ls %ls\n", display, protocol_length, protocol,
                         cookie_length, cookie);
    }
    {
#line 527
    (*((in->write_buffer)->super.write))(& (in->write_buffer)->super, tmp___9);
    }
    {
#line 534
    close_fd_write(in);
    }
    {
#line 536
    remember_resource(channel->resources, & process->super);
    }
    {
#line 537
    remember_resource(channel->resources, & in->super);
    }
#line 539
    info->display = display;
#line 540
    info->xauthority = xauthority;
    }
#line 542
    return (info);
  } else {
    {
    {
#line 546
    close(spawn.in[0]);
    }
    {
#line 547
    close(spawn.in[1]);
    }
    }
    fail: 
    {
    {
#line 549
    lsh_string_free((struct lsh_string  const  *)display);
    }
    {
#line 550
    lsh_string_free((struct lsh_string  const  *)xauthority);
    }
    }
#line 551
    return ((struct server_x11_info *)((void *)0));
  }
}
}
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct lsh_class command_class ;
#line 301 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h"
struct command_continuation *make_apply(struct command *f , struct command_continuation *c ,
                                        struct exception_handler *e ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h.x"
struct lsh_class packet_handler_class ;
#line 244 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h"
void connection_send(struct ssh_connection *self , struct lsh_string *message ) ;
#line 255
void connection_lock(struct ssh_connection *self ) ;
#line 256
void connection_unlock(struct ssh_connection *self ) ;
#line 271
struct packet_handler connection_ignore_handler ;
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.h"
int parse_atom(struct simple_buffer *buffer , int *result ) ;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.h.x"
struct lsh_class userauth_class ;
#line 60
struct lsh_class userauth_service_class ;
#line 93 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.h"
struct lsh_string *format_userauth_failure(struct int_list *methods , int partial ) ;
#line 96
struct lsh_string *format_userauth_success(void) ;
#line 110
struct userauth *make_userauth_none_permit(struct lsh_user *user ) ;
#line 113
struct command *make_userauth_service(struct int_list *advertised_methods , struct alist *methods ,
                                      struct alist *services ) ;
#line 118
struct exception_handler *make_exc_userauth_handler(struct ssh_connection *connection ,
                                                    struct int_list *advertised_methods ,
                                                    unsigned int attempts , struct exception_handler *parent ,
                                                    char const   *context ) ;
#line 85 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
int lsh_string_eq(struct lsh_string  const  *a , struct lsh_string  const  *b ) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.h.x"
struct lsh_class user_db_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"user_db", (size_t )sizeof(struct user_db ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.h.x"
struct lsh_class userauth_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"userauth", (size_t )sizeof(struct userauth ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 64 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.h.x"
static void do_userauth_service_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct userauth_service *i ;

  {
  {
#line 68
  i = (struct userauth_service *)o;
  {
#line 69
  (*mark)((struct lsh_object *)i->advertised_methods);
  }
  {
#line 70
  (*mark)((struct lsh_object *)i->methods);
  }
  {
#line 71
  (*mark)((struct lsh_object *)i->services);
  }
  }
#line 72
  return;
}
}
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.h.x"
struct lsh_class userauth_service_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"userauth_service", (size_t )sizeof(struct userauth_service ),
    & do_userauth_service_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c.x"
struct lsh_class userauth_handler_class ;
#line 18 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c.x"
static void do_userauth_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct userauth_handler *i ;

  {
  {
#line 22
  i = (struct userauth_handler *)o;
  {
#line 23
  (*mark)((struct lsh_object *)i->c);
  }
  {
#line 24
  (*mark)((struct lsh_object *)i->service_e);
  }
  {
#line 25
  (*mark)((struct lsh_object *)i->auth_e);
  }
  {
#line 26
  (*mark)((struct lsh_object *)i->methods);
  }
  {
#line 27
  (*mark)((struct lsh_object *)i->services);
  }
  }
#line 28
  return;
}
}
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c.x"
struct lsh_class userauth_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & packet_handler_class, (char *)"userauth_handler", (size_t )sizeof(struct userauth_handler ),
    & do_userauth_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 50
struct lsh_class userauth_continuation_class ;
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c.x"
static void do_userauth_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct userauth_continuation *i ;

  {
  {
#line 58
  i = (struct userauth_continuation *)o;
  {
#line 59
  (*mark)((struct lsh_object *)i->up);
  }
  {
#line 60
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 61
  return;
}
}
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c.x"
struct lsh_class userauth_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"userauth_continuation", (size_t )sizeof(struct userauth_continuation ),
    & do_userauth_continuation_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 84
struct lsh_class exc_userauth_handler_class ;
#line 88 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c.x"
static void do_exc_userauth_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct exc_userauth_handler *i ;

  {
  {
#line 92
  i = (struct exc_userauth_handler *)o;
  {
#line 93
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 94
  (*mark)((struct lsh_object *)i->advertised_methods);
  }
  }
#line 95
  return;
}
}
#line 96 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c.x"
struct lsh_class exc_userauth_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"exc_userauth_handler", (size_t )sizeof(struct exc_userauth_handler ),
    & do_exc_userauth_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 116
struct lsh_class userauth_none_permit_class ;
#line 120 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c.x"
static void do_userauth_none_permit_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct userauth_none_permit *i ;

  {
  {
#line 124
  i = (struct userauth_none_permit *)o;
  {
#line 125
  (*mark)((struct lsh_object *)i->user);
  }
  }
#line 126
  return;
}
}
#line 127 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c.x"
struct lsh_class userauth_none_permit_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & userauth_class, (char *)"userauth_none_permit", (size_t )sizeof(struct userauth_none_permit ),
    & do_userauth_none_permit_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
struct lsh_string *format_userauth_failure(struct int_list *methods , int partial ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 52
  tmp = ssh_format("%c%A%c", 51, methods, partial);
  }
  }
#line 52
  return (tmp);
}
}
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
struct lsh_string *format_userauth_success(void) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 58
  tmp = ssh_format("%c", 52);
  }
  }
#line 58
  return (tmp);
}
}
#line 108 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
static void do_userauth_continuation(struct command_continuation *s , struct lsh_object *a ) 
{ 
  struct userauth_continuation *self ;
  struct lsh_user *user ;
  unsigned int i ;
  struct lsh_string *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 112
  self = (struct userauth_continuation *)s;
#line 113
  user = (struct lsh_user *)a;
#line 119
  if (! user) {
    {
    {
#line 119
    __assert_fail("user", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c",
                  119U, "do_userauth_continuation");
    }
    }
  }
  {
#line 120
  (self->connection)->user = user;
  {
#line 123
  connection_unlock(self->connection);
  }
  {
#line 125
  tmp = format_userauth_success();
  }
  {
#line 125
  connection_send(self->connection, tmp);
  }
#line 128
  i = 50U;
  }
  {
  {
#line 128
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 128
    if (! (i < 80U)) {
#line 128
      goto while_break;
    }
#line 129
    (self->connection)->dispatch[i] = & connection_ignore_handler;
#line 128
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 131
  (*((self->up)->c))(self->up, (struct lsh_object *)self->connection);
  }
  }
#line 140
  return;
}
}
#line 142 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
static struct command_continuation *make_userauth_continuation(struct ssh_connection *connection ,
                                                               struct command_continuation *c ) 
{ 
  struct userauth_continuation *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 146
  tmp = lsh_object_alloc(& userauth_continuation_class);
  }
#line 146
  self = (struct userauth_continuation *)tmp;
#line 147
  self->super.c = & do_userauth_continuation;
#line 148
  self->up = c;
#line 150
  self->connection = connection;
  }
#line 152
  return (& self->super);
}
}
#line 191
static void do_handle_userauth(struct packet_handler *s , struct ssh_connection *connection ,
                               struct lsh_string *packet ) ;
#line 191 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
static struct exception  const  userauth_failed  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "Unknown auth method or service."};
#line 161 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
static void do_handle_userauth(struct packet_handler *s , struct ssh_connection *connection ,
                               struct lsh_string *packet ) 
{ 
  struct userauth_handler *self ;
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  struct lsh_string *user ;
  int requested_service ;
  int method ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct userauth *auth ;
  struct lsh_object *tmp___1 ;
  struct command *service ;
  struct lsh_object *tmp___2 ;
  struct command_continuation *tmp___3 ;
  struct command_continuation *tmp___4 ;
  struct exception *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 166
  self = (struct userauth_handler *)s;
#line 170
  user = (struct lsh_string *)((void *)0);
  {
#line 174
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 174
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 174
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 176
  tmp___6 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 176
  if (tmp___6) {
#line 176
    if (msg_number == 50U) {
      {
      {
#line 176
      user = parse_string_copy(& buffer);
      }
      }
#line 176
      if (user) {
        {
        {
#line 176
        tmp___7 = parse_atom(& buffer, & requested_service);
        }
        }
#line 176
        if (tmp___7) {
          {
          {
#line 176
          tmp___8 = parse_atom(& buffer, & method);
          }
          }
#line 176
          if (tmp___8) {
            {
            {
#line 182
            tmp___1 = (*(((struct alist_meta *)(self->methods)->super.isa)->get))(self->methods,
                                                                                  method);
            }
#line 182
            auth = (struct userauth *)tmp___1;
            {
#line 183
            tmp___2 = (*(((struct alist_meta *)(self->services)->super.isa)->get))(self->services,
                                                                                   requested_service);
            }
#line 183
            service = (struct command *)tmp___2;
            {
#line 187
            connection_lock(connection);
            }
            }
#line 189
            if (auth) {
#line 189
              if (! service) {
                {
                {
#line 195
                (*((self->auth_e)->raise))(self->auth_e, & userauth_failed);
                }
                {
#line 197
                lsh_string_free((struct lsh_string  const  *)user);
                }
                }
#line 198
                return;
              }
            } else {
              {
              {
#line 195
              (*((self->auth_e)->raise))(self->auth_e, & userauth_failed);
              }
              {
#line 197
              lsh_string_free((struct lsh_string  const  *)user);
              }
              }
#line 198
              return;
            }
            {
            {
#line 202
            tmp___3 = make_apply(service, self->c, self->service_e);
            }
            {
#line 202
            tmp___4 = make_userauth_continuation(connection, tmp___3);
            }
            {
#line 202
            (*(auth->authenticate))(auth, connection, user, (uint32_t )requested_service,
                                    & buffer, tmp___4, self->auth_e);
            }
            }
          } else {
            {
            {
#line 209
            lsh_string_free((struct lsh_string  const  *)user);
            }
            {
#line 210
            tmp___5 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH message.");
            }
            {
#line 210
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___5);
            }
            }
          }
        } else {
          {
          {
#line 209
          lsh_string_free((struct lsh_string  const  *)user);
          }
          {
#line 210
          tmp___5 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH message.");
          }
          {
#line 210
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___5);
          }
          }
        }
      } else {
        {
        {
#line 209
        lsh_string_free((struct lsh_string  const  *)user);
        }
        {
#line 210
        tmp___5 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH message.");
        }
        {
#line 210
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___5);
        }
        }
      }
    } else {
      {
      {
#line 209
      lsh_string_free((struct lsh_string  const  *)user);
      }
      {
#line 210
      tmp___5 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH message.");
      }
      {
#line 210
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___5);
      }
      }
    }
  } else {
    {
    {
#line 209
    lsh_string_free((struct lsh_string  const  *)user);
    }
    {
#line 210
    tmp___5 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH message.");
    }
    {
#line 210
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___5);
    }
    }
  }
#line 212
  return;
}
}
#line 214 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
static struct packet_handler *make_userauth_handler(struct alist *methods , struct alist *services ,
                                                    struct command_continuation *c ,
                                                    struct exception_handler *service_e ,
                                                    struct exception_handler *auth_e ) 
{ 
  struct userauth_handler *auth ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 221
  tmp = lsh_object_alloc(& userauth_handler_class);
  }
#line 221
  auth = (struct userauth_handler *)tmp;
#line 223
  auth->super.handler = & do_handle_userauth;
#line 224
  auth->methods = methods;
#line 225
  auth->services = services;
#line 226
  auth->c = c;
#line 227
  auth->service_e = service_e;
#line 228
  auth->auth_e = auth_e;
  }
#line 230
  return (& auth->super);
}
}
#line 248 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
static void do_exc_userauth_handler(struct exception_handler *s , struct exception  const  *x ) 
{ 
  struct exc_userauth_handler *self ;
  struct lsh_string *tmp ;
  struct exception *tmp___0 ;
  struct userauth_special_exception *e ;
  struct lsh_string *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 252
  self = (struct exc_userauth_handler *)s;
#line 260
  if (x->type == 4096U) {
#line 260
    goto case_4096;
  }
#line 266
  if (x->type == 16385U) {
#line 266
    goto case_16385;
  }
#line 287
  if (x->type == 16386U) {
#line 287
    goto case_16386;
  }
#line 256
  goto switch_default;
  switch_default: 
  {
  {
#line 257
  (*((self->super.parent)->raise))(self->super.parent, x);
  }
  }
#line 258
  goto switch_break;
  case_4096: 
  {
  {
#line 263
  (*(((self->connection)->e)->raise))((self->connection)->e, x);
  }
  }
#line 264
  goto switch_break;
  case_16385: 
  {
  {
#line 269
  connection_unlock(self->connection);
  }
  }
#line 271
  if (self->attempts) {
    {
#line 273
    (self->attempts) --;
    {
#line 274
    tmp = format_userauth_failure(self->advertised_methods, 0);
    }
    {
#line 274
    connection_send(self->connection, tmp);
    }
    }
  } else {
    {
    {
#line 279
    tmp___0 = make_protocol_exception((uint32_t )7, "Access denied");
    }
    {
#line 279
    (*(((self->connection)->e)->raise))((self->connection)->e, (struct exception  const  *)tmp___0);
    }
    }
  }
#line 285
  goto switch_break;
  case_16386: 
  {
#line 289
  e = (struct userauth_special_exception *)x;
  {
#line 292
  connection_unlock(self->connection);
  }
  {
#line 296
  tmp___1 = ssh_format("%lS", e->reply);
  }
  {
#line 296
  connection_send(self->connection, tmp___1);
  }
  }
#line 299
  goto switch_break;
  switch_break: ;
#line 302
  return;
}
}
#line 304 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
struct exception_handler *make_exc_userauth_handler(struct ssh_connection *connection ,
                                                    struct int_list *advertised_methods ,
                                                    unsigned int attempts , struct exception_handler *parent ,
                                                    char const   *context ) 
{ 
  struct exc_userauth_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 311
  tmp = lsh_object_alloc(& exc_userauth_handler_class);
  }
#line 311
  self = (struct exc_userauth_handler *)tmp;
#line 312
  self->super.raise = & do_exc_userauth_handler;
#line 313
  self->super.parent = parent;
#line 314
  self->super.context = context;
#line 316
  self->connection = connection;
#line 317
  self->advertised_methods = advertised_methods;
#line 318
  self->attempts = attempts;
  }
#line 320
  return (& self->super);
}
}
#line 324 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
static void do_userauth(struct command *s , struct lsh_object *x , struct command_continuation *c ,
                        struct exception_handler *e ) 
{ 
  struct userauth_service *self ;
  struct ssh_connection *connection ;
  struct exception_handler *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 330
  self = (struct userauth_service *)s;
#line 331
  connection = (struct ssh_connection *)x;
#line 333
  if (connection->user) {
    {
    {
#line 335
    werror("do_userauth: Dropping previous authentication for user \'%pS\'.\n", (connection->user)->name);
    }
#line 337
    connection->user = (struct lsh_user *)((void *)0);
    }
  }
  {
  {
#line 340
  tmp = make_exc_userauth_handler(connection, self->advertised_methods, 20U, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c:346");
  }
  {
#line 340
  connection->dispatch[50] = make_userauth_handler(self->methods, self->services,
                                                   c, e, tmp);
  }
  }
#line 347
  return;
}
}
#line 349 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
struct command *make_userauth_service(struct int_list *advertised_methods , struct alist *methods ,
                                      struct alist *services ) 
{ 
  struct userauth_service *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 354
  tmp = lsh_object_alloc(& userauth_service_class);
  }
#line 354
  self = (struct userauth_service *)tmp;
#line 356
  self->super.call = & do_userauth;
#line 357
  self->advertised_methods = advertised_methods;
#line 358
  self->methods = methods;
#line 359
  self->services = services;
  }
#line 361
  return (& self->super);
}
}
#line 384
static void do_none_preauth(struct userauth *s  __attribute__((__unused__)) , struct ssh_connection *connection  __attribute__((__unused__)) ,
                            struct lsh_string *username , uint32_t service  __attribute__((__unused__)) ,
                            struct simple_buffer *args , struct command_continuation *c ,
                            struct exception_handler *e ) ;
#line 384 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
static struct exception  const  wrong_user  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "User needs to authenticate properly"};
#line 366 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
static void do_none_preauth(struct userauth *s  __attribute__((__unused__)) , struct ssh_connection *connection  __attribute__((__unused__)) ,
                            struct lsh_string *username , uint32_t service  __attribute__((__unused__)) ,
                            struct simple_buffer *args , struct command_continuation *c ,
                            struct exception_handler *e ) 
{ 
  struct exception *tmp ;
  int tmp___0 ;
  struct exception *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 375
  username = utf8_to_local(username, (enum utf8_flag )2, 1);
  }
  }
#line 376
  if (! username) {
    {
    {
#line 378
    tmp = make_protocol_exception((uint32_t )2, "Invalid utf8 in username.");
    }
    {
#line 378
    (*(e->raise))(e, (struct exception  const  *)tmp);
    }
    }
#line 379
    return;
  }
  {
  {
#line 382
  tmp___2 = parse_eod(args);
  }
  }
#line 382
  if (tmp___2) {
#line 388
    if (connection->user) {
      {
      {
#line 388
      tmp___0 = lsh_string_eq((struct lsh_string  const  *)username, (struct lsh_string  const  *)(connection->user)->name);
      }
      }
#line 388
      if (tmp___0) {
        {
        {
#line 390
        (*(c->c))(c, (struct lsh_object *)connection->user);
        }
        }
      } else {
        {
        {
#line 392
        (*(e->raise))(e, & wrong_user);
        }
        }
      }
    } else {
      {
      {
#line 392
      (*(e->raise))(e, & wrong_user);
      }
      }
    }
  } else {
    {
    {
#line 395
    tmp___1 = make_protocol_exception((uint32_t )2, "Invalid none USERAUTH message.");
    }
    {
#line 395
    (*(e->raise))(e, (struct exception  const  *)tmp___1);
    }
    }
  }
  {
  {
#line 397
  lsh_string_free((struct lsh_string  const  *)username);
  }
  }
#line 398
  return;
}
}
#line 400 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
struct userauth server_userauth_none_preauth  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_none_preauth};
#line 412 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
static void do_none_permit(struct userauth *s , struct ssh_connection *connection  __attribute__((__unused__)) ,
                           struct lsh_string *username , uint32_t service  __attribute__((__unused__)) ,
                           struct simple_buffer *args , struct command_continuation *c ,
                           struct exception_handler *e ) 
{ 
  struct userauth_none_permit *self ;
  struct exception *tmp ;
  int tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 421
  self = (struct userauth_none_permit *)s;
  {
#line 424
  lsh_string_free((struct lsh_string  const  *)username);
  }
  {
#line 426
  tmp___0 = parse_eod(args);
  }
  }
#line 426
  if (tmp___0) {
    {
    {
#line 428
    (*(c->c))(c, (struct lsh_object *)self->user);
    }
    }
  } else {
    {
    {
#line 431
    tmp = make_protocol_exception((uint32_t )2, "Invalid none USERAUTH message.");
    }
    {
#line 431
    (*(e->raise))(e, (struct exception  const  *)tmp);
    }
    }
  }
#line 432
  return;
}
}
#line 434 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.c"
struct userauth *make_userauth_none_permit(struct lsh_user *user ) 
{ 
  struct userauth_none_permit *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 437
  tmp = lsh_object_alloc(& userauth_none_permit_class);
  }
#line 437
  self = (struct userauth_none_permit *)tmp;
  {
#line 439
  trace("make_userauth_none\n");
  }
#line 440
  self->super.authenticate = & do_none_permit;
#line 441
  self->user = user;
  }
#line 443
  return (& self->super);
}
}
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_pty.h"
struct pty_info *make_pty_info(void) ;
#line 66
int pty_open_master(struct pty_info *pty , uid_t user ) ;
#line 28 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct lsh_class ssh_channel_class ;
#line 220
struct lsh_class channel_request_class ;
#line 339 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h"
void init_channel(struct ssh_channel *channel ) ;
#line 363
struct io_callback *make_channel_read_data(struct ssh_channel *channel ) ;
#line 364
struct io_callback *make_channel_read_stderr(struct ssh_channel *channel ) ;
#line 381
void channel_start_receive(struct ssh_channel *channel , uint32_t initial_window_size ) ;
#line 401
struct lsh_string *format_channel_request(int type , struct ssh_channel *channel ,
                                          int want_reply , char const   *format  , ...) ;
#line 414
void channel_close(struct ssh_channel *channel ) ;
#line 417
struct lsh_callback *make_channel_read_close_callback(struct ssh_channel *channel ) ;
#line 420
struct exception_handler *make_channel_io_exception_handler(struct ssh_channel *channel ,
                                                            char const   *prefix___0 ,
                                                            int silent , struct exception_handler *parent ,
                                                            char const   *context ) ;
#line 235 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
void lsh_oop_register_read_fd(struct lsh_fd *fd ) ;
#line 564 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.h"
struct ssh_channel *make_server_session(uint32_t initial_window , struct alist *request_types ) ;
#line 38
struct channel_open *make_open_session(struct alist *session_requests ) ;
#line 41
struct channel_request shell_request_handler ;
#line 44
struct channel_request exec_request_handler ;
#line 47
struct channel_request *make_subsystem_handler(char const   **subsystems ) ;
#line 50
struct lsh_string *format_exit_signal(struct ssh_channel *channel , int core , int signal___0 ) ;
#line 53
struct lsh_string *format_exit(struct ssh_channel *channel , int value ) ;
#line 56
struct channel_request pty_request_handler ;
#line 59
struct channel_request window_change_request_handler ;
#line 62
struct channel_request x11_req_handler ;
#line 18 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c.x"
struct lsh_class server_session_class ;
#line 22 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c.x"
static void do_server_session_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct server_session *i ;

  {
  {
#line 26
  i = (struct server_session *)o;
  {
#line 27
  (*mark)((struct lsh_object *)i->process);
  }
  {
#line 28
  (*mark)((struct lsh_object *)i->pty);
  }
  {
#line 29
  (*mark)((struct lsh_object *)i->x11);
  }
  {
#line 30
  (*mark)((struct lsh_object *)i->in);
  }
  {
#line 31
  (*mark)((struct lsh_object *)i->out);
  }
  {
#line 32
  (*mark)((struct lsh_object *)i->err);
  }
  }
#line 33
  return;
}
}
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c.x"
static void do_server_session_free(struct lsh_object *o ) 
{ 
  struct server_session *i ;

  {
  {
#line 37
  i = (struct server_session *)o;
  {
#line 38
  lsh_string_free((struct lsh_string  const  *)i->term);
  }
  {
#line 39
  lsh_string_free((struct lsh_string  const  *)i->client);
  }
  }
#line 40
  return;
}
}
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c.x"
struct lsh_class server_session_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & ssh_channel_class, (char *)"server_session", (size_t )sizeof(struct server_session ),
    & do_server_session_mark, & do_server_session_free};
#line 61
struct lsh_class open_session_class ;
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c.x"
static void do_open_session_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct open_session *i ;

  {
  {
#line 69
  i = (struct open_session *)o;
  {
#line 70
  (*mark)((struct lsh_object *)i->session_requests);
  }
  }
#line 71
  return;
}
}
#line 72 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c.x"
struct lsh_class open_session_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_open_class, (char *)"open_session", (size_t )sizeof(struct open_session ),
    & do_open_session_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 92
struct lsh_class exit_shell_class ;
#line 96 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c.x"
static void do_exit_shell_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct exit_shell *i ;

  {
  {
#line 100
  i = (struct exit_shell *)o;
  {
#line 101
  (*mark)((struct lsh_object *)i->session);
  }
  }
#line 102
  return;
}
}
#line 103 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c.x"
struct lsh_class exit_shell_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exit_callback_class, (char *)"exit_shell", (size_t )sizeof(struct exit_shell ),
    & do_exit_shell_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 123
static struct lsh_class subsystem_request_class___0 ;
#line 127 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c.x"
static struct lsh_class subsystem_request_class___0  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_request_class, (char *)"subsystem_request", (size_t )sizeof(struct subsystem_request ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 95 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static void do_receive(struct ssh_channel *c , int type , struct lsh_string *data ) 
{ 
  struct server_session *closure ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 99
  closure = (struct server_session *)c;
#line 103
  if (type == 0) {
#line 103
    goto case_0;
  }
#line 106
  if (type == 1) {
#line 106
    goto case_1;
  }
#line 110
  goto switch_default;
  case_0: 
  {
  {
#line 104
  (*(((closure->in)->write_buffer)->super.write))(& ((closure->in)->write_buffer)->super,
                                                  data);
  }
  }
#line 105
  goto switch_break;
  case_1: 
  {
  {
#line 107
  werror("Ignoring unexpected stderr data.\n");
  }
  {
#line 108
  lsh_string_free((struct lsh_string  const  *)data);
  }
  }
#line 109
  goto switch_break;
  switch_default: 
  {
  {
#line 111
  fatal("Internal error!\n");
  }
  }
  switch_break: ;
#line 113
  return;
}
}
#line 116 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static void do_send_adjust(struct ssh_channel *s , uint32_t i  __attribute__((__unused__)) ) 
{ 
  struct server_session *session ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 120
  session = (struct server_session *)s;
#line 124
  if ((session->out)->super.alive) {
#line 126
    if (! (session->out)->read) {
      {
      {
#line 126
      __assert_fail("session->out->read", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c",
                    126U, "do_send_adjust");
      }
      }
    }
    {
    {
#line 128
    lsh_oop_register_read_fd(session->out);
    }
    }
  }
#line 131
  if (session->err) {
#line 131
    if ((session->err)->super.alive) {
#line 133
      if (! (session->err)->read) {
        {
        {
#line 133
        __assert_fail("session->err->read", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c",
                      133U, "do_send_adjust");
        }
        }
      }
      {
      {
#line 135
      lsh_oop_register_read_fd(session->err);
      }
      }
    }
  }
#line 137
  return;
}
}
#line 139 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static void do_eof(struct ssh_channel *channel ) 
{ 
  struct server_session *session ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 142
  session = (struct server_session *)channel;
  {
#line 144
  trace("server_session.c: do_eof\n");
  }
  {
#line 146
  close_fd_write(session->in);
  }
  }
#line 147
  return;
}
}
#line 149 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
struct ssh_channel *make_server_session(uint32_t initial_window , struct alist *request_types ) 
{ 
  struct server_session *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 153
  tmp = lsh_object_alloc(& server_session_class);
  }
#line 153
  self = (struct server_session *)tmp;
  {
#line 155
  init_channel(& self->super);
  }
#line 157
  self->initial_window = initial_window;
#line 161
  self->super.rec_window_size = (uint32_t )0;
#line 164
  self->super.rec_max_packet = (uint32_t )32768;
#line 165
  self->super.request_types = request_types;
#line 170
  self->process = (struct lsh_process *)((void *)0);
#line 172
  self->pty = (struct pty_info *)((void *)0);
#line 173
  self->term = (struct lsh_string *)((void *)0);
#line 174
  self->client = (struct lsh_string *)((void *)0);
#line 176
  self->in = (struct lsh_fd *)((void *)0);
#line 177
  self->out = (struct lsh_fd *)((void *)0);
#line 178
  self->err = (struct lsh_fd *)((void *)0);
  }
#line 180
  return (& self->super);
}
}
#line 194 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static void do_open_session(struct channel_open *s , struct ssh_connection *connection  __attribute__((__unused__)) ,
                            struct channel_open_info *info  __attribute__((__unused__)) ,
                            struct simple_buffer *args , struct command_continuation *c ,
                            struct exception_handler *e ) 
{ 
  struct open_session *self ;
  struct ssh_channel *tmp ;
  struct exception *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 202
  self = (struct open_session *)s;
  {
#line 204
  debug("server.c: do_open_session\n");
  }
  }
#line 206
  if (! connection->user) {
    {
    {
#line 206
    __assert_fail("connection->user", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c",
                  206U, "do_open_session");
    }
    }
  }
  {
  {
#line 208
  tmp___1 = parse_eod(args);
  }
  }
#line 208
  if (tmp___1) {
    {
    {
#line 210
    tmp = make_server_session((uint32_t )10000, self->session_requests);
    }
    {
#line 210
    (*(c->c))(c, (struct lsh_object *)tmp);
    }
    }
  } else {
    {
    {
#line 215
    tmp___0 = make_protocol_exception((uint32_t )2, "trailing garbage in open message");
    }
    {
#line 215
    (*(e->raise))(e, (struct exception  const  *)tmp___0);
    }
    }
  }
#line 217
  return;
}
}
#line 219 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
struct channel_open *make_open_session(struct alist *session_requests ) 
{ 
  struct open_session *closure ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 222
  tmp = lsh_object_alloc(& open_session_class);
  }
#line 222
  closure = (struct open_session *)tmp;
#line 224
  closure->super.handler = & do_open_session;
#line 225
  closure->session_requests = session_requests;
  }
#line 227
  return (& closure->super);
}
}
#line 231 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
struct lsh_string *format_exit_signal(struct ssh_channel *channel , int core , int signal___0 ) 
{ 
  struct lsh_string *msg ;
  char *tmp ;
  struct lsh_string *tmp___0 ;
  int tmp___1 ;
  struct lsh_string *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 235
  tmp = strsignal(signal___0);
  }
  {
#line 235
  tmp___0 = ssh_format("%lz.\n", tmp);
  }
#line 235
  msg = tmp___0;
  {
#line 238
  tmp___1 = signal_local_to_network(signal___0);
  }
  {
#line 238
  tmp___2 = format_channel_request(66, channel, 0, "%a%c%fS%z", tmp___1, core, msg,
                                   "");
  }
  }
#line 238
  return (tmp___2);
}
}
#line 247 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
struct lsh_string *format_exit(struct ssh_channel *channel , int value ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 250
  tmp = format_channel_request(65, channel, 0, "%i", value);
  }
  }
#line 250
  return (tmp);
}
}
#line 264 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static void do_exit_shell(struct exit_callback *c , int signaled , int core , int value ) 
{ 
  struct exit_shell *closure ;
  struct server_session *session ;
  struct ssh_channel *channel ;
  int tmp ;
  struct lsh_string *tmp___0 ;
  struct lsh_string *tmp___1 ;
  struct lsh_string *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 268
  closure = (struct exit_shell *)c;
#line 269
  session = closure->session;
#line 270
  channel = & session->super;
  {
#line 272
  trace("server_session.c: do_exit_shell\n");
  }
  }
#line 276
  if (! (channel->flags & 1)) {
#line 278
    if (signaled) {
#line 278
      tmp = 66;
    } else {
#line 278
      tmp = 65;
    }
    {
    {
#line 278
    verbose("server_session.c: Sending %a message on channel %i\n", tmp, channel->channel_number);
    }
    }
#line 282
    if (signaled) {
      {
      {
#line 282
      tmp___0 = format_exit_signal(channel, core, value);
      }
#line 282
      tmp___2 = tmp___0;
      }
    } else {
      {
      {
#line 282
      tmp___1 = format_exit(channel, value);
      }
#line 282
      tmp___2 = tmp___1;
      }
    }
    {
    {
#line 282
    connection_send(channel->connection, tmp___2);
    }
#line 291
    channel->flags |= 48;
    }
#line 293
    if (channel->flags & 4) {
      {
      {
#line 296
      channel_close(channel);
      }
      }
    }
  }
#line 299
  return;
}
}
#line 301 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static struct exit_callback *make_exit_shell(struct server_session *session ) 
{ 
  struct exit_shell *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 304
  tmp = lsh_object_alloc(& exit_shell_class);
  }
#line 304
  self = (struct exit_shell *)tmp;
#line 306
  self->super.exit = & do_exit_shell;
#line 307
  self->session = session;
  }
#line 309
  return (& self->super);
}
}
#line 313 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static int make_pipes(int *in , int *out , int *err ) 
{ 
  int saved_errno ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
  {
  {
#line 318
  tmp___4 = lsh_make_pipe(in);
  }
  }
#line 318
  if (tmp___4) {
    {
    {
#line 320
    tmp___2 = lsh_make_pipe(out);
    }
    }
#line 320
    if (tmp___2) {
      {
      {
#line 322
      tmp = lsh_make_pipe(err);
      }
      }
#line 322
      if (tmp) {
#line 324
        return (1);
      }
      {
      {
#line 326
      tmp___0 = __errno_location();
      }
#line 326
      saved_errno = *tmp___0;
      {
#line 327
      close(*(out + 0));
      }
      {
#line 328
      close(*(out + 1));
      }
      }
    } else {
      {
      {
#line 331
      tmp___1 = __errno_location();
      }
#line 331
      saved_errno = *tmp___1;
      }
    }
    {
    {
#line 332
    close(*(in + 0));
    }
    {
#line 333
    close(*(in + 1));
    }
    }
  } else {
    {
    {
#line 336
    tmp___3 = __errno_location();
    }
#line 336
    saved_errno = *tmp___3;
    }
  }
  {
  {
#line 338
  tmp___5 = __errno_location();
  }
#line 338
  *tmp___5 = saved_errno;
  }
#line 339
  return (0);
}
}
#line 349 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static int make_pty(struct pty_info *pty , int *in , int *out , int *err ) 
{ 
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
  {
#line 352
  debug("make_pty... ");
  }
  }
#line 354
  if (! pty) {
    {
    {
#line 354
    __assert_fail("pty", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c",
                  354U, "make_pty");
    }
    }
  }
  {
  {
#line 356
  debug("exists: \n  alive = %i\n  master = %i\n... ", pty->super.alive, pty->master);
  }
  {
#line 361
  debug("\n");
  }
  }
#line 363
  if (pty) {
#line 365
    if (! pty->super.alive) {
      {
      {
#line 365
      __assert_fail("pty->super.alive", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c",
                    365U, "make_pty");
      }
      }
    }
    {
    {
#line 367
    debug("make_pty: Using allocated pty.\n");
    }
#line 374
    pty->super.alive = 0;
#line 381
    *(in + 0) = -1;
#line 382
    *(in + 1) = pty->master;
    {
#line 384
    tmp___0 = dup(pty->master);
    }
#line 384
    *(out + 0) = tmp___0;
    }
#line 384
    if (tmp___0 < 0) {
      {
      {
#line 386
      tmp = __errno_location();
      }
      {
#line 386
      werror("make_pty: duping master pty to stdout failed %e\n", *tmp);
      }
      }
#line 388
      return (0);
    }
#line 391
    *(out + 1) = -1;
#line 394
    pty->master = -1;
#line 400
    *(err + 0) = -1;
#line 401
    *(err + 1) = -1;
#line 412
    return (1);
  }
#line 414
  return (0);
}
}
#line 423 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static int spawn_process(struct server_session *session , struct lsh_user *user ,
                         struct spawn_info *info ) 
{ 
  struct lsh_callback *read_close_callback ;
  int tmp ;
  int tmp___0 ;
  struct exit_callback *tmp___1 ;
  struct exception_handler *tmp___2 ;
  int tmp___3 ;
  struct lsh_fd *tmp___4 ;
  struct io_callback *tmp___5 ;
  struct exception_handler *tmp___6 ;
  struct lsh_fd *tmp___7 ;
  struct io_callback *tmp___8 ;
  struct exception_handler *tmp___9 ;
  struct lsh_fd *tmp___10 ;
  struct lsh_fd *tmp___11 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
#line 432
  if (! (! session->process)) {
    {
    {
#line 432
    __assert_fail("!session->process", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c",
                  432U, "spawn_process");
    }
    }
  }
#line 434
  if (session->pty) {
    {
    {
#line 434
    tmp = make_pty(session->pty, info->in, info->out, info->err);
    }
    }
#line 434
    if (! tmp) {
      {
      {
#line 437
      (*((session->pty)->super.kill))(& (session->pty)->super);
      }
      {
#line 438
      gc_kill((struct lsh_object *)session->pty);
      }
#line 439
      session->pty = (struct pty_info *)((void *)0);
      }
    }
  }
#line 442
  if (! session->pty) {
    {
    {
#line 442
    tmp___0 = make_pipes(info->in, info->out, info->err);
    }
    }
#line 442
    if (! tmp___0) {
#line 443
      return (0);
    }
  }
  {
  {
#line 445
  tmp___1 = make_exit_shell(session);
  }
  {
#line 445
  session->process = (*(user->spawn))(user, info, tmp___1);
  }
  }
#line 447
  if (! session->process) {
#line 448
    return (0);
  }
  {
  {
#line 451
  read_close_callback = make_channel_read_close_callback(& session->super);
  }
  {
#line 454
  tmp___2 = make_channel_io_exception_handler(& session->super, "Child stdin: ", 0,
                                              & default_exception_handler, "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c:461");
  }
  }
#line 454
  if (session->pty) {
#line 454
    tmp___3 = 1;
  } else {
#line 454
    tmp___3 = 0;
  }
  {
  {
#line 454
  tmp___4 = make_lsh_fd(info->in[1], (enum io_type )tmp___3, "child stdin", tmp___2);
  }
  {
#line 454
  session->in = io_write(tmp___4, (uint32_t )32768, (struct lsh_callback *)((void *)0));
  }
#line 465
  ((session->in)->write_buffer)->report = & session->super.super;
  {
#line 470
  tmp___5 = make_channel_read_data(& session->super);
  }
  {
#line 470
  tmp___6 = make_channel_io_exception_handler(& session->super, "Child stdout: ",
                                              1, & default_exception_handler, "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c:476");
  }
  {
#line 470
  tmp___7 = make_lsh_fd(info->out[0], (enum io_type )0, "child stdout", tmp___6);
  }
  {
#line 470
  session->out = io_read(tmp___7, tmp___5, read_close_callback);
  }
  }
#line 479
  if (info->err[0] != -1) {
    {
    {
#line 479
    tmp___8 = make_channel_read_stderr(& session->super);
    }
    {
#line 479
    tmp___9 = make_channel_io_exception_handler(& session->super, "Child stderr: ",
                                                0, & default_exception_handler, "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c:486");
    }
    {
#line 479
    tmp___10 = make_lsh_fd(info->err[0], (enum io_type )0, "child stderr", tmp___9);
    }
    {
#line 479
    tmp___11 = io_read(tmp___10, tmp___8, read_close_callback);
    }
#line 479
    session->err = tmp___11;
    }
  } else {
#line 479
    session->err = (struct lsh_fd *)((void *)0);
  }
  {
#line 491
  session->super.receive = & do_receive;
#line 492
  session->super.send_adjust = & do_send_adjust;
#line 493
  session->super.eof = & do_eof;
  {
#line 497
  remember_resource(session->super.resources, & (session->process)->super);
  }
  {
#line 501
  remember_resource(session->super.resources, & (session->in)->super);
  }
  {
#line 502
  remember_resource(session->super.resources, & (session->out)->super);
  }
  }
#line 503
  if (session->err) {
    {
    {
#line 504
    remember_resource(session->super.resources, & (session->err)->super);
    }
    }
  }
  {
#line 508
  session->super.flags &= -17;
  {
#line 510
  channel_start_receive(& session->super, session->initial_window);
  }
  }
#line 512
  return (1);
}
}
#line 515 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static void init_spawn_info(struct spawn_info *info , struct server_session *session ,
                            unsigned int argc , char const   **argv , unsigned int env_length ,
                            struct env_value *env ) 
{ 
  unsigned int i ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
  {
#line 520
  i = 0U;
  {
#line 522
  memset((void *)info, 0, (size_t )sizeof(*info));
  }
#line 523
  info->peer = (session->super.connection)->peer;
#line 524
  info->pty = session->pty;
#line 526
  info->argc = argc;
#line 527
  info->argv = argv;
  }
#line 529
  if (! (env_length >= 5U)) {
    {
    {
#line 529
    __assert_fail("env_length >= 5", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c",
                  529U, "init_spawn_info");
    }
    }
  }
#line 532
  if (session->term) {
#line 534
    (env + i)->name = "TERM";
#line 535
    (env + i)->value = session->term;
#line 536
    i ++;
  }
#line 539
  if (info->pty) {
#line 539
    if ((info->pty)->tty_name) {
#line 541
      (env + i)->name = "SSH_TTY";
#line 542
      (env + i)->value = (info->pty)->tty_name;
#line 543
      i ++;
    }
  }
#line 546
  if (info->peer) {
#line 550
    if (! (! session->client)) {
      {
      {
#line 550
      __assert_fail("!session->client", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c",
                    550U, "init_spawn_info");
      }
      }
    }
#line 552
    if ((session->super.connection)->local) {
      {
      {
#line 553
      session->client = ssh_format("%lS %di %di", (info->peer)->ip, (info->peer)->port,
                                   ((session->super.connection)->local)->port);
      }
      }
    } else {
      {
      {
#line 558
      session->client = ssh_format("%lS %di UNKNOWN", (info->peer)->ip, (info->peer)->port);
      }
      }
    }
#line 562
    (env + i)->name = "SSH_CLIENT";
#line 563
    (env + i)->value = session->client;
#line 565
    i ++;
  }
#line 569
  if (session->x11) {
#line 571
    (env + i)->name = "DISPLAY";
#line 572
    (env + i)->value = (session->x11)->display;
#line 573
    i ++;
#line 575
    (env + i)->name = "XAUTHORITY";
#line 576
    (env + i)->value = (session->x11)->xauthority;
#line 577
    i ++;
  }
#line 580
  if (! (i <= env_length)) {
    {
    {
#line 580
    __assert_fail("i <= env_length", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c",
                  580U, "init_spawn_info");
    }
    }
  }
#line 581
  info->env_length = i;
#line 582
  info->env = (struct env_value  const  *)env;
#line 583
  return;
}
}
#line 585
static void do_shell_request_handler(struct channel_request *s  __attribute__((__unused__)) ,
                                     struct ssh_channel *channel , struct channel_request_info *info  __attribute__((__unused__)) ,
                                     struct simple_buffer *args , struct command_continuation *c ,
                                     struct exception_handler *e ) ;
#line 585 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
struct channel_request shell_request_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_shell_request_handler};
#line 597 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static struct exception  const  shell_request_failed  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )32770, "Shell request failed"};
#line 585 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static void do_shell_request_handler(struct channel_request *s  __attribute__((__unused__)) ,
                                     struct ssh_channel *channel , struct channel_request_info *info  __attribute__((__unused__)) ,
                                     struct simple_buffer *args , struct command_continuation *c ,
                                     struct exception_handler *e ) 
{ 
  struct server_session *session ;
  struct spawn_info spawn ;
  struct env_value env[5] ;
  struct exception *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  int __cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  int __cil_tmp34 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 593
  session = (struct server_session *)channel;
  {
#line 600
  tmp___0 = parse_eod(args);
  }
  }
#line 600
  if (! tmp___0) {
    {
    {
#line 602
    tmp = make_protocol_exception((uint32_t )2, "Invalid shell CHANNEL_REQUEST message.");
    }
    {
#line 602
    (*(e->raise))(e, (struct exception  const  *)tmp);
    }
    }
#line 603
    return;
  }
#line 606
  if (session->process) {
#line 608
    goto fail;
  }
  {
  {
#line 610
  init_spawn_info(& spawn, session, 0U, (char const   **)((void *)0), 5U, env);
  }
#line 611
  spawn.login = 1;
  {
#line 613
  tmp___1 = spawn_process(session, (channel->connection)->user, & spawn);
  }
  }
#line 613
  if (tmp___1) {
    {
    {
#line 614
    (*(c->c))(c, (struct lsh_object *)channel);
    }
    }
  } else {
    fail: 
    {
    {
#line 618
    (*(e->raise))(e, & shell_request_failed);
    }
    }
  }
#line 620
  return;
}
}
#line 622
static void do_exec_request_handler(struct channel_request *s  __attribute__((__unused__)) ,
                                    struct ssh_channel *channel , struct channel_request_info *info  __attribute__((__unused__)) ,
                                    struct simple_buffer *args , struct command_continuation *c ,
                                    struct exception_handler *e ) ;
#line 622 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
struct channel_request exec_request_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_exec_request_handler};
#line 632 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static struct exception  const  exec_request_failed  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )32770, "Exec request failed"};
#line 622 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static void do_exec_request_handler(struct channel_request *s  __attribute__((__unused__)) ,
                                    struct ssh_channel *channel , struct channel_request_info *info  __attribute__((__unused__)) ,
                                    struct simple_buffer *args , struct command_continuation *c ,
                                    struct exception_handler *e ) 
{ 
  struct server_session *session ;
  uint32_t command_len ;
  uint8_t const   *command ;
  struct exception *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct spawn_info spawn ;
  char const   *args___0[2] ;
  struct env_value env[5] ;
  struct lsh_string *s___0 ;
  struct lsh_string *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  int __cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  int __cil_tmp50 ;
  void *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
  {
#line 630
  session = (struct server_session *)channel;
  {
#line 638
  tmp___0 = parse_string(args, & command_len, & command);
  }
  }
#line 638
  if (tmp___0) {
    {
    {
#line 638
    tmp___1 = parse_eod(args);
    }
    }
#line 638
    if (! tmp___1) {
      {
      {
#line 641
      tmp = make_protocol_exception((uint32_t )2, "Invalid exec CHANNEL_REQUEST message.");
      }
      {
#line 641
      (*(e->raise))(e, (struct exception  const  *)tmp);
      }
      }
#line 642
      return;
    }
  } else {
    {
    {
#line 641
    tmp = make_protocol_exception((uint32_t )2, "Invalid exec CHANNEL_REQUEST message.");
    }
    {
#line 641
    (*(e->raise))(e, (struct exception  const  *)tmp);
    }
    }
#line 642
    return;
  }
#line 645
  if (session->process) {
    {
    {
#line 650
    (*(e->raise))(e, & exec_request_failed);
    }
    }
  } else {
    {
    {
#line 645
    tmp___4 = memchr((void const   *)command, '\000', command_len);
    }
    }
#line 645
    if (tmp___4) {
      {
      {
#line 650
      (*(e->raise))(e, & exec_request_failed);
      }
      }
    } else {
      {
      {
#line 657
      tmp___2 = ssh_format("%ls", command_len, command);
      }
#line 657
      s___0 = tmp___2;
      {
#line 659
      init_spawn_info(& spawn, session, 2U, args___0, 5U, env);
      }
#line 660
      spawn.login = 0;
#line 662
      args___0[0] = "-c";
      {
#line 663
      args___0[1] = lsh_get_cstring((struct lsh_string  const  *)s___0);
      }
      {
#line 665
      tmp___3 = spawn_process(session, (channel->connection)->user, & spawn);
      }
      }
#line 665
      if (tmp___3) {
        {
        {
#line 666
        (*(c->c))(c, (struct lsh_object *)channel);
        }
        }
      } else {
        {
        {
#line 668
        (*(e->raise))(e, & exec_request_failed);
        }
        }
      }
      {
      {
#line 670
      lsh_string_free((struct lsh_string  const  *)s___0);
      }
      }
    }
  }
#line 672
  return;
}
}
#line 694 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static char const   *lookup_subsystem(struct subsystem_request *self , uint32_t length ,
                                      uint8_t const   *name ) 
{ 
  unsigned int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 699
  tmp = memchr((void const   *)name, 0, length);
  }
  }
#line 699
  if (tmp) {
#line 700
    return ((char const   *)((void *)0));
  }
#line 702
  i = 0U;
  {
  {
#line 702
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 702
    if (! *(self->subsystems + i)) {
#line 702
      goto while_break;
    }
#line 704
    if (! *(self->subsystems + (i + 1U))) {
      {
      {
#line 704
      __assert_fail("self->subsystems[i+1]", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c",
                    704U, "lookup_subsystem");
      }
      }
    }
    {
    {
#line 705
    tmp___0 = strlen(*(self->subsystems + i));
    }
    }
#line 705
    if (length == tmp___0) {
      {
      {
#line 705
      tmp___1 = memcmp((void const   *)name, (void const   *)*(self->subsystems + i),
                       length);
      }
      }
#line 705
      if (! tmp___1) {
#line 707
        return (*(self->subsystems + (i + 1U)));
      }
    }
#line 702
    i += 2U;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 709
  return ((char const   *)((void *)0));
}
}
#line 723
static void do_spawn_subsystem(struct channel_request *s , struct ssh_channel *channel ,
                               struct channel_request_info *info  __attribute__((__unused__)) ,
                               struct simple_buffer *args , struct command_continuation *c ,
                               struct exception_handler *e ) ;
#line 723 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static struct exception subsystem_request_failed  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )32770, "Subsystem request failed"};
#line 712 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static void do_spawn_subsystem(struct channel_request *s , struct ssh_channel *channel ,
                               struct channel_request_info *info  __attribute__((__unused__)) ,
                               struct simple_buffer *args , struct command_continuation *c ,
                               struct exception_handler *e ) 
{ 
  struct subsystem_request *self ;
  struct server_session *session ;
  uint8_t const   *name ;
  uint32_t name_length ;
  char const   *program ;
  struct exception *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct spawn_info spawn ;
  char const   *args___0[2] ;
  struct env_value env[5] ;
  int tmp___2 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  int __cil_tmp36 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  int __cil_tmp47 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
  {
#line 720
  self = (struct subsystem_request *)s;
#line 721
  session = (struct server_session *)channel;
  {
#line 731
  tmp___0 = parse_string(args, & name_length, & name);
  }
  }
#line 731
  if (tmp___0) {
    {
    {
#line 731
    tmp___1 = parse_eod(args);
    }
    }
#line 731
    if (! tmp___1) {
      {
      {
#line 733
      tmp = make_protocol_exception((uint32_t )2, "Invalid subsystem CHANNEL_REQUEST message.");
      }
      {
#line 733
      (*(e->raise))(e, (struct exception  const  *)tmp);
      }
      }
#line 734
      return;
    }
  } else {
    {
    {
#line 733
    tmp = make_protocol_exception((uint32_t )2, "Invalid subsystem CHANNEL_REQUEST message.");
    }
    {
#line 733
    (*(e->raise))(e, (struct exception  const  *)tmp);
    }
    }
#line 734
    return;
  }
  {
  {
#line 737
  program = lookup_subsystem(self, name_length, name);
  }
  }
#line 739
  if (! session->process) {
#line 739
    if (program) {
#line 746
      if (session->pty) {
        {
        {
#line 748
        (*((session->pty)->super.kill))(& (session->pty)->super);
        }
#line 749
        session->pty = (struct pty_info *)((void *)0);
        }
      }
      {
#line 752
      args___0[0] = "-c";
#line 752
      args___0[1] = program;
      {
#line 754
      init_spawn_info(& spawn, session, 2U, args___0, 5U, env);
      }
#line 755
      spawn.login = 0;
      {
#line 757
      tmp___2 = spawn_process(session, (channel->connection)->user, & spawn);
      }
      }
#line 757
      if (tmp___2) {
        {
        {
#line 759
        (*(c->c))(c, (struct lsh_object *)channel);
        }
        }
#line 760
        return;
      }
    }
  }
  {
  {
#line 763
  (*(e->raise))(e, (struct exception  const  *)(& subsystem_request_failed));
  }
  }
#line 764
  return;
}
}
#line 766 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
struct channel_request *make_subsystem_handler(char const   **subsystems ) 
{ 
  struct subsystem_request *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 769
  tmp = lsh_object_alloc(& subsystem_request_class___0);
  }
#line 769
  self = (struct subsystem_request *)tmp;
#line 771
  self->super.handler = & do_spawn_subsystem;
#line 772
  self->subsystems = subsystems;
  }
#line 774
  return (& self->super);
}
}
#line 791
static void do_alloc_pty(struct channel_request *c  __attribute__((__unused__)) ,
                         struct ssh_channel *channel , struct channel_request_info *info  __attribute__((__unused__)) ,
                         struct simple_buffer *args , struct command_continuation *s ,
                         struct exception_handler *e ) ;
#line 791 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static struct exception pty_request_failed  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )32770, "pty request failed"};
#line 781 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static void do_alloc_pty(struct channel_request *c  __attribute__((__unused__)) ,
                         struct ssh_channel *channel , struct channel_request_info *info  __attribute__((__unused__)) ,
                         struct simple_buffer *args , struct command_continuation *s ,
                         struct exception_handler *e ) 
{ 
  struct lsh_string *term ;
  struct pty_info *pty ;
  struct pty_info *tmp ;
  struct server_session *session ;
  int tmp___0 ;
  struct exception *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct lsh_string *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;

  {
  {
#line 789
  term = (struct lsh_string *)((void *)0);
  {
#line 794
  tmp = make_pty_info();
  }
#line 794
  pty = tmp;
#line 796
  session = (struct server_session *)channel;
  {
#line 798
  verbose("Client requesting a tty...\n");
  }
  {
#line 800
  term = parse_string_copy(args);
  }
  }
#line 800
  if (term) {
    {
    {
#line 800
    tmp___2 = parse_uint32(args, & pty->dims.char_width);
    }
    }
#line 800
    if (tmp___2) {
      {
      {
#line 800
      tmp___3 = parse_uint32(args, & pty->dims.char_height);
      }
      }
#line 800
      if (tmp___3) {
        {
        {
#line 800
        tmp___4 = parse_uint32(args, & pty->dims.pixel_width);
        }
        }
#line 800
        if (tmp___4) {
          {
          {
#line 800
          tmp___5 = parse_uint32(args, & pty->dims.pixel_height);
          }
          }
#line 800
          if (tmp___5) {
            {
            {
#line 800
            tmp___6 = parse_string_copy(args);
            }
#line 800
            pty->mode = tmp___6;
            }
#line 800
            if (tmp___6) {
              {
              {
#line 800
              tmp___7 = parse_eod(args);
              }
              }
#line 800
              if (tmp___7) {
#line 810
                if (session->pty) {
                  {
                  {
#line 813
                  verbose("Pty allocation failed.\n");
                  }
                  {
#line 814
                  (*(e->raise))(e, (struct exception  const  *)(& pty_request_failed));
                  }
                  }
                } else
#line 810
                if (session->process) {
                  {
                  {
#line 813
                  verbose("Pty allocation failed.\n");
                  }
                  {
#line 814
                  (*(e->raise))(e, (struct exception  const  *)(& pty_request_failed));
                  }
                  }
                } else {
                  {
                  {
#line 810
                  tmp___0 = pty_open_master(pty, ((channel->connection)->user)->uid);
                  }
                  }
#line 810
                  if (tmp___0) {
                    {
#line 820
                    session->term = term;
#line 821
                    session->pty = pty;
                    {
#line 822
                    remember_resource(channel->resources, & pty->super);
                    }
                    {
#line 824
                    verbose(" ... granted.\n");
                    }
                    {
#line 825
                    (*(s->c))(s, (struct lsh_object *)channel);
                    }
                    }
#line 828
                    return;
                  } else {
                    {
                    {
#line 813
                    verbose("Pty allocation failed.\n");
                    }
                    {
#line 814
                    (*(e->raise))(e, (struct exception  const  *)(& pty_request_failed));
                    }
                    }
                  }
                }
              } else {
                {
                {
#line 834
                werror("Invalid pty request.\n");
                }
                {
#line 835
                tmp___1 = make_protocol_exception((uint32_t )2, "Invalid pty request.");
                }
                {
#line 835
                (*(e->raise))(e, (struct exception  const  *)tmp___1);
                }
                }
              }
            } else {
              {
              {
#line 834
              werror("Invalid pty request.\n");
              }
              {
#line 835
              tmp___1 = make_protocol_exception((uint32_t )2, "Invalid pty request.");
              }
              {
#line 835
              (*(e->raise))(e, (struct exception  const  *)tmp___1);
              }
              }
            }
          } else {
            {
            {
#line 834
            werror("Invalid pty request.\n");
            }
            {
#line 835
            tmp___1 = make_protocol_exception((uint32_t )2, "Invalid pty request.");
            }
            {
#line 835
            (*(e->raise))(e, (struct exception  const  *)tmp___1);
            }
            }
          }
        } else {
          {
          {
#line 834
          werror("Invalid pty request.\n");
          }
          {
#line 835
          tmp___1 = make_protocol_exception((uint32_t )2, "Invalid pty request.");
          }
          {
#line 835
          (*(e->raise))(e, (struct exception  const  *)tmp___1);
          }
          }
        }
      } else {
        {
        {
#line 834
        werror("Invalid pty request.\n");
        }
        {
#line 835
        tmp___1 = make_protocol_exception((uint32_t )2, "Invalid pty request.");
        }
        {
#line 835
        (*(e->raise))(e, (struct exception  const  *)tmp___1);
        }
        }
      }
    } else {
      {
      {
#line 834
      werror("Invalid pty request.\n");
      }
      {
#line 835
      tmp___1 = make_protocol_exception((uint32_t )2, "Invalid pty request.");
      }
      {
#line 835
      (*(e->raise))(e, (struct exception  const  *)tmp___1);
      }
      }
    }
  } else {
    {
    {
#line 834
    werror("Invalid pty request.\n");
    }
    {
#line 835
    tmp___1 = make_protocol_exception((uint32_t )2, "Invalid pty request.");
    }
    {
#line 835
    (*(e->raise))(e, (struct exception  const  *)tmp___1);
    }
    }
  }
  {
  {
#line 838
  lsh_string_free((struct lsh_string  const  *)term);
  }
  {
#line 839
  (*(pty->super.kill))(& pty->super);
  }
  {
#line 840
  gc_kill((struct lsh_object *)pty);
  }
  }
#line 841
  return;
}
}
#line 843 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
struct channel_request pty_request_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_alloc_pty};
#line 866
static void do_window_change_request(struct channel_request *c  __attribute__((__unused__)) ,
                                     struct ssh_channel *channel , struct channel_request_info *info  __attribute__((__unused__)) ,
                                     struct simple_buffer *args , struct command_continuation *s ,
                                     struct exception_handler *e ) ;
#line 866 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static struct exception  const  winch_request_failed  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )32770, "window-change request failed: No pty"};
#line 847 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static void do_window_change_request(struct channel_request *c  __attribute__((__unused__)) ,
                                     struct ssh_channel *channel , struct channel_request_info *info  __attribute__((__unused__)) ,
                                     struct simple_buffer *args , struct command_continuation *s ,
                                     struct exception_handler *e ) 
{ 
  struct terminal_dimensions dims ;
  struct server_session *session ;
  int tmp ;
  struct exception *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 856
  session = (struct server_session *)channel;
  {
#line 858
  verbose("Receiving window-change request...\n");
  }
  {
#line 860
  tmp___1 = parse_uint32(args, & dims.char_width);
  }
  }
#line 860
  if (tmp___1) {
    {
    {
#line 860
    tmp___2 = parse_uint32(args, & dims.char_height);
    }
    }
#line 860
    if (tmp___2) {
      {
      {
#line 860
      tmp___3 = parse_uint32(args, & dims.pixel_width);
      }
      }
#line 860
      if (tmp___3) {
        {
        {
#line 860
        tmp___4 = parse_uint32(args, & dims.pixel_height);
        }
        }
#line 860
        if (tmp___4) {
          {
          {
#line 860
          tmp___5 = parse_eod(args);
          }
          }
#line 860
          if (tmp___5) {
#line 869
            if (session->pty) {
#line 869
              if (session->in) {
#line 869
                if ((session->in)->super.alive) {
                  {
                  {
#line 869
                  tmp = tty_setwinsize((session->in)->fd, (struct terminal_dimensions  const  *)(& dims));
                  }
                  }
#line 869
                  if (tmp) {
                    {
                    {
#line 872
                    (*(s->c))(s, (struct lsh_object *)channel);
                    }
                    }
                  } else {
                    {
                    {
#line 874
                    (*(e->raise))(e, & winch_request_failed);
                    }
                    }
                  }
                } else {
                  {
                  {
#line 874
                  (*(e->raise))(e, & winch_request_failed);
                  }
                  }
                }
              } else {
                {
                {
#line 874
                (*(e->raise))(e, & winch_request_failed);
                }
                }
              }
            } else {
              {
              {
#line 874
              (*(e->raise))(e, & winch_request_failed);
              }
              }
            }
          } else {
            {
            {
#line 877
            tmp___0 = make_protocol_exception((uint32_t )2, "Invalid window-change request.");
            }
            {
#line 877
            (*(((channel->connection)->e)->raise))((channel->connection)->e, (struct exception  const  *)tmp___0);
            }
            }
          }
        } else {
          {
          {
#line 877
          tmp___0 = make_protocol_exception((uint32_t )2, "Invalid window-change request.");
          }
          {
#line 877
          (*(((channel->connection)->e)->raise))((channel->connection)->e, (struct exception  const  *)tmp___0);
          }
          }
        }
      } else {
        {
        {
#line 877
        tmp___0 = make_protocol_exception((uint32_t )2, "Invalid window-change request.");
        }
        {
#line 877
        (*(((channel->connection)->e)->raise))((channel->connection)->e, (struct exception  const  *)tmp___0);
        }
        }
      }
    } else {
      {
      {
#line 877
      tmp___0 = make_protocol_exception((uint32_t )2, "Invalid window-change request.");
      }
      {
#line 877
      (*(((channel->connection)->e)->raise))((channel->connection)->e, (struct exception  const  *)tmp___0);
      }
      }
    }
  } else {
    {
    {
#line 877
    tmp___0 = make_protocol_exception((uint32_t )2, "Invalid window-change request.");
    }
    {
#line 877
    (*(((channel->connection)->e)->raise))((channel->connection)->e, (struct exception  const  *)tmp___0);
    }
    }
  }
#line 878
  return;
}
}
#line 880 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
struct channel_request window_change_request_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_window_change_request};
#line 898
static void do_x11_req(struct channel_request *s  __attribute__((__unused__)) , struct ssh_channel *channel ,
                       struct channel_request_info *info  __attribute__((__unused__)) ,
                       struct simple_buffer *args , struct command_continuation *c ,
                       struct exception_handler *e ) ;
#line 898 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static struct exception x11_request_failed  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )32770, "x11-req failed"};
#line 890 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
static void do_x11_req(struct channel_request *s  __attribute__((__unused__)) , struct ssh_channel *channel ,
                       struct channel_request_info *info  __attribute__((__unused__)) ,
                       struct simple_buffer *args , struct command_continuation *c ,
                       struct exception_handler *e ) 
{ 
  uint8_t const   *protocol ;
  uint32_t protocol_length ;
  uint8_t const   *cookie ;
  uint32_t cookie_length ;
  uint32_t screen ;
  unsigned int single ;
  struct server_session *session ;
  struct server_x11_info *tmp ;
  struct exception *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
  {
#line 908
  session = (struct server_session *)channel;
  {
#line 910
  verbose("Client requesting x11 forwarding...\n");
  }
  {
#line 912
  tmp___1 = parse_uint8(args, & single);
  }
  }
#line 912
  if (tmp___1) {
    {
    {
#line 912
    tmp___2 = parse_string(args, & protocol_length, & protocol);
    }
    }
#line 912
    if (tmp___2) {
      {
      {
#line 912
      tmp___3 = parse_string(args, & cookie_length, & cookie);
      }
      }
#line 912
      if (tmp___3) {
        {
        {
#line 912
        tmp___4 = parse_uint32(args, & screen);
        }
        }
#line 912
        if (tmp___4) {
#line 919
          if (session->x11) {
            {
            {
#line 927
            verbose("X11 request failed.\n");
            }
            {
#line 928
            (*(e->raise))(e, (struct exception  const  *)(& x11_request_failed));
            }
            }
          } else
#line 919
          if (session->process) {
            {
            {
#line 927
            verbose("X11 request failed.\n");
            }
            {
#line 928
            (*(e->raise))(e, (struct exception  const  *)(& x11_request_failed));
            }
            }
          } else {
            {
            {
#line 919
            tmp = server_x11_setup(channel, (channel->connection)->user, (int )single,
                                   protocol_length, protocol, cookie_length, cookie,
                                   screen, c, e);
            }
#line 919
            session->x11 = tmp;
            }
#line 919
            if (tmp) {
#line 932
              return;
            } else {
              {
              {
#line 927
              verbose("X11 request failed.\n");
              }
              {
#line 928
              (*(e->raise))(e, (struct exception  const  *)(& x11_request_failed));
              }
              }
            }
          }
        } else {
          {
          {
#line 937
          werror("Invalid x11 request.\n");
          }
          {
#line 938
          tmp___0 = make_protocol_exception((uint32_t )2, "Invalid x11 request.");
          }
          {
#line 938
          (*(e->raise))(e, (struct exception  const  *)tmp___0);
          }
          }
        }
      } else {
        {
        {
#line 937
        werror("Invalid x11 request.\n");
        }
        {
#line 938
        tmp___0 = make_protocol_exception((uint32_t )2, "Invalid x11 request.");
        }
        {
#line 938
        (*(e->raise))(e, (struct exception  const  *)tmp___0);
        }
        }
      }
    } else {
      {
      {
#line 937
      werror("Invalid x11 request.\n");
      }
      {
#line 938
      tmp___0 = make_protocol_exception((uint32_t )2, "Invalid x11 request.");
      }
      {
#line 938
      (*(e->raise))(e, (struct exception  const  *)tmp___0);
      }
      }
    }
  } else {
    {
    {
#line 937
    werror("Invalid x11 request.\n");
    }
    {
#line 938
    tmp___0 = make_protocol_exception((uint32_t )2, "Invalid x11 request.");
    }
    {
#line 938
    (*(e->raise))(e, (struct exception  const  *)tmp___0);
    }
    }
  }
#line 940
  return;
}
}
#line 942 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_session.c"
struct channel_request x11_req_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_x11_req};
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.h"
int parse_boolean(struct simple_buffer *buffer , int *result ) ;
#line 104 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.h"
struct userauth *make_userauth_publickey(struct user_db *db , struct alist *verifiers ) ;
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_publickey.c.x"
struct lsh_class userauth_publickey_class ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_publickey.c.x"
static void do_userauth_publickey_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct userauth_publickey *i ;

  {
  {
#line 19
  i = (struct userauth_publickey *)o;
  {
#line 20
  (*mark)((struct lsh_object *)i->db);
  }
  {
#line 21
  (*mark)((struct lsh_object *)i->verifiers);
  }
  }
#line 22
  return;
}
}
#line 23 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_publickey.c.x"
struct lsh_class userauth_publickey_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & userauth_class, (char *)"userauth_publickey", (size_t )sizeof(struct userauth_publickey ),
    & do_userauth_publickey_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_publickey.c"
static struct lsh_string *format_userauth_pk_ok(int algorithm , struct lsh_string *keyblob ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 57
  tmp = ssh_format("%c%a%S", 60, algorithm, keyblob);
  }
  }
#line 57
  return (tmp);
}
}
#line 107
static void do_authenticate(struct userauth *s , struct ssh_connection *connection ,
                            struct lsh_string *username , uint32_t service  __attribute__((__unused__)) ,
                            struct simple_buffer *args , struct command_continuation *c ,
                            struct exception_handler *e ) ;
#line 107 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_publickey.c"
static struct exception  const  unsupported_publickey_algorithm  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "Unsupported public key algorithm."};
#line 124 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_publickey.c"
static struct exception  const  unknown_user  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "Unknown user."};
#line 136 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_publickey.c"
static struct exception  const  unauthorized_key  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "Unauthorized public key."};
#line 174 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_publickey.c"
static struct exception  const  bad_sign  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "Bad signature in userauth request"};
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_publickey.c"
static void do_authenticate(struct userauth *s , struct ssh_connection *connection ,
                            struct lsh_string *username , uint32_t service  __attribute__((__unused__)) ,
                            struct simple_buffer *args , struct command_continuation *c ,
                            struct exception_handler *e ) 
{ 
  struct userauth_publickey *self ;
  struct lsh_string *keyblob ;
  struct lookup_verifier *lookup ;
  struct verifier *v ;
  uint8_t const   *signature_blob ;
  uint32_t signature_length ;
  uint32_t signature_start ;
  int algorithm ;
  int check_key ;
  struct exception *tmp ;
  struct lsh_user *user ;
  struct lookup_verifier *l ;
  struct lsh_object *tmp___0 ;
  struct lsh_string *tmp___1 ;
  struct exception *tmp___2 ;
  struct lsh_string *signed_data ;
  uint8_t const   *tmp___3 ;
  uint32_t tmp___4 ;
  int tmp___5 ;
  struct exception *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;

  {
  {
#line 70
  self = (struct userauth_publickey *)s;
#line 72
  keyblob = (struct lsh_string *)((void *)0);
#line 77
  signature_start = (uint32_t )0;
  {
#line 81
  username = utf8_to_local(username, (enum utf8_flag )2, 1);
  }
  }
#line 82
  if (! username) {
    {
    {
#line 84
    tmp = make_protocol_exception((uint32_t )2, "Invalid utf8 in username.");
    }
    {
#line 84
    (*(e->raise))(e, (struct exception  const  *)tmp);
    }
    }
#line 85
    return;
  }
  {
  {
#line 88
  tmp___7 = parse_boolean(args, & check_key);
  }
  }
#line 88
  if (tmp___7) {
    {
    {
#line 88
    tmp___8 = parse_atom(args, & algorithm);
    }
    }
#line 88
    if (tmp___8) {
      {
      {
#line 88
      keyblob = parse_string_copy(args);
      }
      }
#line 88
      if (keyblob) {
#line 88
        if (check_key) {
          {
#line 88
          signature_start = args->pos;
          {
#line 88
          tmp___9 = parse_string(args, & signature_length, & signature_blob);
          }
          }
#line 88
          if (tmp___9) {
            {
            {
#line 88
            tmp___10 = parse_eod(args);
            }
            }
#line 88
            if (tmp___10) {
#line 88
              tmp___11 = 1;
            } else {
#line 88
              tmp___11 = 0;
            }
          } else {
#line 88
            tmp___11 = 0;
          }
#line 88
          tmp___13 = tmp___11;
        } else {
          {
          {
#line 88
          tmp___12 = parse_eod(args);
          }
#line 88
          tmp___13 = tmp___12;
          }
        }
#line 88
        if (tmp___13) {
          {
          {
#line 100
          tmp___0 = (*(((struct alist_meta *)(self->verifiers)->super.isa)->get))(self->verifiers,
                                                                                  algorithm);
          }
#line 100
          l = (struct lookup_verifier *)tmp___0;
#line 102
          lookup = l;
          }
#line 105
          if (! lookup) {
            {
            {
#line 111
            verbose("Unknown publickey algorithm %a\n", algorithm);
            }
            {
#line 112
            (*(e->raise))(e, & unsupported_publickey_algorithm);
            }
            }
            fail: 
            {
            {
#line 115
            lsh_string_free((struct lsh_string  const  *)keyblob);
            }
            {
#line 116
            lsh_string_free((struct lsh_string  const  *)username);
            }
            }
#line 117
            return;
          }
          {
          {
#line 120
          user = (*((self->db)->lookup))(self->db, username, 0);
          }
          }
#line 122
          if (! user) {
            {
            {
#line 128
            (*(e->raise))(e, & unknown_user);
            }
            }
#line 129
            goto fail;
          }
          {
          {
#line 132
          v = (*(lookup->lookup))(lookup, algorithm, user, keyblob);
          }
          }
#line 134
          if (! v) {
            {
            {
#line 140
            (*(e->raise))(e, & unauthorized_key);
            }
            }
#line 141
            goto fail;
          }
#line 144
          if (! check_key) {
#line 146
            if (! v) {
              {
              {
#line 146
              __assert_fail("v", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_publickey.c",
                            146U, "do_authenticate");
              }
              }
            }
            {
            {
#line 147
            tmp___1 = format_userauth_pk_ok(algorithm, keyblob);
            }
            {
#line 147
            tmp___2 = make_userauth_special_exception(tmp___1, (char const   *)((void *)0));
            }
            {
#line 147
            (*(e->raise))(e, (struct exception  const  *)tmp___2);
            }
            }
#line 150
            goto fail;
          } else {
#line 156
            if (! v) {
              {
              {
#line 156
              __assert_fail("v", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_publickey.c",
                            156U, "do_authenticate");
              }
              }
            }
            {
            {
#line 161
            signed_data = ssh_format("%S%ls", connection->session_id, signature_start,
                                     args->data);
            }
            {
#line 164
            lsh_string_free((struct lsh_string  const  *)keyblob);
            }
            {
#line 165
            tmp___3 = lsh_string_data((struct lsh_string  const  *)signed_data);
            }
            {
#line 165
            tmp___4 = lsh_string_length((struct lsh_string  const  *)signed_data);
            }
            {
#line 165
            tmp___5 = (*(v->verify))(v, algorithm, tmp___4, tmp___3, signature_length,
                                     signature_blob);
            }
            }
#line 165
            if (tmp___5) {
              {
              {
#line 169
              werror("publickey authentication for user %S succeeded.\n", username);
              }
              {
#line 170
              (*(c->c))(c, (struct lsh_object *)user);
              }
              }
            } else {
              {
              {
#line 177
              (*(e->raise))(e, & bad_sign);
              }
              }
            }
            {
            {
#line 179
            lsh_string_free((struct lsh_string  const  *)username);
            }
            {
#line 180
            lsh_string_free((struct lsh_string  const  *)signed_data);
            }
            }
#line 181
            return;
          }
        } else {
          {
          {
#line 186
          lsh_string_free((struct lsh_string  const  *)username);
          }
          {
#line 187
          lsh_string_free((struct lsh_string  const  *)keyblob);
          }
          {
#line 189
          werror("Badly formatted publickey authentication request\n");
          }
          {
#line 190
          tmp___6 = make_protocol_exception((uint32_t )2, "Invalid publickey authentication request");
          }
          {
#line 190
          (*(e->raise))(e, (struct exception  const  *)tmp___6);
          }
          }
        }
      } else {
        {
        {
#line 186
        lsh_string_free((struct lsh_string  const  *)username);
        }
        {
#line 187
        lsh_string_free((struct lsh_string  const  *)keyblob);
        }
        {
#line 189
        werror("Badly formatted publickey authentication request\n");
        }
        {
#line 190
        tmp___6 = make_protocol_exception((uint32_t )2, "Invalid publickey authentication request");
        }
        {
#line 190
        (*(e->raise))(e, (struct exception  const  *)tmp___6);
        }
        }
      }
    } else {
      {
      {
#line 186
      lsh_string_free((struct lsh_string  const  *)username);
      }
      {
#line 187
      lsh_string_free((struct lsh_string  const  *)keyblob);
      }
      {
#line 189
      werror("Badly formatted publickey authentication request\n");
      }
      {
#line 190
      tmp___6 = make_protocol_exception((uint32_t )2, "Invalid publickey authentication request");
      }
      {
#line 190
      (*(e->raise))(e, (struct exception  const  *)tmp___6);
      }
      }
    }
  } else {
    {
    {
#line 186
    lsh_string_free((struct lsh_string  const  *)username);
    }
    {
#line 187
    lsh_string_free((struct lsh_string  const  *)keyblob);
    }
    {
#line 189
    werror("Badly formatted publickey authentication request\n");
    }
    {
#line 190
    tmp___6 = make_protocol_exception((uint32_t )2, "Invalid publickey authentication request");
    }
    {
#line 190
    (*(e->raise))(e, (struct exception  const  *)tmp___6);
    }
    }
  }
#line 192
  return;
}
}
#line 194 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_publickey.c"
struct userauth *make_userauth_publickey(struct user_db *db , struct alist *verifiers ) 
{ 
  struct userauth_publickey *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 198
  tmp = lsh_object_alloc(& userauth_publickey_class);
  }
#line 198
  self = (struct userauth_publickey *)tmp;
#line 200
  self->super.authenticate = & do_authenticate;
#line 201
  self->db = db;
#line 202
  self->verifiers = verifiers;
  }
#line 203
  return (& self->super);
}
}
#line 284 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 469 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
#line 698
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 45 "/usr/include/stropts.h"
extern  __attribute__((__nothrow__)) int isastream(int __fildes ) ;
#line 915 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int grantpt(int __fd ) ;
#line 919
extern  __attribute__((__nothrow__)) int unlockpt(int __fd ) ;
#line 924
extern  __attribute__((__nothrow__)) char *ptsname(int __fd ) ;
#line 13 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_pty.h.x"
struct lsh_class pty_info_class ;
#line 17 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_pty.h.x"
static void do_pty_info_free(struct lsh_object *o ) 
{ 
  struct pty_info *i ;

  {
  {
#line 20
  i = (struct pty_info *)o;
  {
#line 21
  lsh_string_free((struct lsh_string  const  *)i->tty_name);
  }
  {
#line 22
  lsh_string_free((struct lsh_string  const  *)i->mode);
  }
  }
#line 23
  return;
}
}
#line 24 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_pty.h.x"
struct lsh_class pty_info_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & resource_class, (char *)"pty_info", (size_t )sizeof(struct pty_info ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_pty_info_free};
#line 64 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_pty.c"
static void do_kill_pty_info(struct resource *r ) 
{ 
  struct pty_info *pty ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 67
  pty = (struct pty_info *)r;
#line 69
  if (pty->super.alive) {
#line 71
    pty->super.alive = 0;
#line 72
    if (pty->master >= 0) {
      {
      {
#line 72
      tmp___0 = close(pty->master);
      }
      }
#line 72
      if (tmp___0 < 0) {
        {
        {
#line 73
        tmp = __errno_location();
        }
        {
#line 73
        werror("do_kill_pty_info: closing master failed %e\n", *tmp);
        }
        }
      }
    }
  }
#line 75
  return;
}
}
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_pty.c"
struct pty_info *make_pty_info(void) 
{ 
  struct pty_info *pty ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 80
  tmp = lsh_object_alloc(& pty_info_class);
  }
#line 80
  pty = (struct pty_info *)tmp;
  {
#line 82
  init_resource(& pty->super, & do_kill_pty_info);
  }
#line 83
  pty->tty_name = (struct lsh_string *)((void *)0);
#line 84
  pty->mode = (struct lsh_string *)((void *)0);
#line 85
  pty->master = -1;
  }
#line 86
  return (pty);
}
}
#line 105 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_pty.c"
static int pty_check_permissions(char const   *name , uid_t user ) 
{ 
  struct stat st ;
  struct group *grp ;
  gid_t tty_gid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
  {
#line 112
  tmp = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
  }
  }
#line 112
  if (tmp < 0) {
#line 113
    return (0);
  }
#line 116
  if (st.st_uid != user) {
    {
    {
#line 116
    tmp___0 = chown(name, user, st.st_gid);
    }
    }
#line 116
    if (tmp___0 < 0) {
#line 118
      return (0);
    }
  }
  {
  {
#line 121
  grp = getgrnam("tty");
  }
  }
#line 123
  if (! grp) {
    {
    {
#line 125
    grp = getgrnam("system");
    }
    }
  }
#line 127
  if (grp) {
#line 128
    tty_gid = grp->gr_gid;
  } else {
    {
    {
#line 132
    werror("lshd: server_pty.c: No tty group found.\n");
    }
    {
#line 133
    tty_gid = getgid();
    }
    }
  }
#line 136
  if (st.st_gid != tty_gid) {
    {
    {
#line 136
    tmp___1 = chown(name, user, tty_gid);
    }
    }
#line 136
    if (tmp___1 < 0) {
#line 138
      return (0);
    }
  }
#line 143
  if ((st.st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3))) != (unsigned int )(384 | (128 >> 3))) {
    {
    {
#line 143
    tmp___2 = chmod(name, (__mode_t )(384 | (128 >> 3)));
    }
    }
#line 143
    if (tmp___2 < 0) {
#line 145
      return (0);
    }
  }
#line 148
  return (1);
}
}
#line 156 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_pty.c"
static struct lsh_string *pty_grantpt_uid(int master , uid_t user ) 
{ 
  uid_t me ;
  __uid_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  struct lsh_string *tmp___2 ;
  char *name ;
  char *tmp___3 ;
  struct lsh_string *tmp___5 ;
  struct lsh_string *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 159
  tmp = getuid();
  }
#line 159
  me = tmp;
  }
#line 160
  if (me == user) {
    {
    {
#line 163
    tmp___0 = grantpt(master);
    }
    }
#line 163
    if (tmp___0 < 0) {
#line 164
      return ((struct lsh_string *)((void *)0));
    }
    {
    {
#line 166
    tmp___1 = ptsname(master);
    }
    {
#line 166
    tmp___2 = ssh_format("%lz", tmp___1);
    }
    }
#line 166
    return (tmp___2);
  } else {
    {
    {
#line 172
    tmp___3 = ptsname(master);
    }
#line 172
    name = tmp___3;
    {
#line 173
    tmp___7 = pty_check_permissions((char const   *)name, user);
    }
    }
#line 173
    if (tmp___7) {
      {
      {
#line 173
      tmp___5 = ssh_format("%lz", name);
      }
#line 173
      tmp___6 = tmp___5;
      }
    } else {
#line 173
      tmp___6 = (struct lsh_string *)((void *)0);
    }
#line 173
    return (tmp___6);
  }
}
}
#line 180 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_pty.c"
int pty_open_master(struct pty_info *pty , uid_t user ) 
{ 
  struct lsh_string *name ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 189
  name = (struct lsh_string *)((void *)0);
  {
#line 190
  tmp___0 = open("/dev/ptmx", 258);
  }
#line 190
  pty->master = tmp___0;
  }
#line 190
  if (tmp___0 < 0) {
    {
    {
#line 192
    tmp = __errno_location();
    }
    {
#line 192
    werror("pty_open_master: Opening /dev/ptmx failed %e\n", *tmp);
    }
    }
#line 193
    return (0);
  }
  {
  {
#line 196
  io_set_close_on_exec(pty->master);
  }
  {
#line 198
  name = pty_grantpt_uid(pty->master, user);
  }
  }
#line 198
  if (name) {
    {
    {
#line 198
    tmp___1 = unlockpt(pty->master);
    }
    }
#line 198
    if (tmp___1 == 0) {
#line 201
      pty->tty_name = name;
#line 202
      return (1);
    }
  }
  {
  {
#line 205
  close(pty->master);
  }
#line 205
  pty->master = -1;
  }
#line 207
  if (name) {
    {
    {
#line 208
    lsh_string_free((struct lsh_string  const  *)name);
    }
    }
  }
#line 209
  return (0);
}
}
#line 272 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_pty.c"
int pty_open_slave(struct pty_info *pty ) 
{ 
  struct termios ios ;
  int fd ;
  char const   *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  uint8_t const   *tmp___10 ;
  uint32_t tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
  {
  {
#line 278
  trace("pty_open_slave\n");
  }
  {
#line 281
  tmp = lsh_get_cstring((struct lsh_string  const  *)pty->tty_name);
  }
  {
#line 281
  fd = open(tmp, 2);
  }
  }
#line 283
  if (fd < 0) {
    {
    {
#line 285
    tmp___0 = __errno_location();
    }
    {
#line 285
    werror("pty_open_slave: open(\"%S\") failed,\n   %e\n", pty->tty_name, *tmp___0);
    }
    }
#line 288
    return (-1);
  }
  {
  {
#line 291
  io_set_close_on_exec(fd);
  }
  {
#line 297
  tmp___5 = isastream(fd);
  }
  }
#line 297
  if (tmp___5) {
    {
    {
#line 299
    tmp___2 = ioctl(fd, (unsigned long )((83 << 8) | 2), "ptem");
    }
    }
#line 299
    if (tmp___2 < 0) {
      {
      {
#line 301
      tmp___1 = __errno_location();
      }
      {
#line 301
      werror("pty_open_slave: Failed to push streams module `ptem\'.\n   %e\n", *tmp___1);
      }
      {
#line 304
      close(fd);
      }
      }
#line 305
      return (-1);
    }
    {
    {
#line 307
    tmp___4 = ioctl(fd, (unsigned long )((83 << 8) | 2), "ldterm");
    }
    }
#line 307
    if (tmp___4 < 0) {
      {
      {
#line 309
      tmp___3 = __errno_location();
      }
      {
#line 309
      werror("pty_open_slave: Failed to push streams module `ldterm\'.\n   %e\n",
             *tmp___3);
      }
      {
#line 312
      close(fd);
      }
      }
#line 313
      return (-1);
    }
  }
  {
  {
#line 321
  tmp___7 = ioctl(fd, 21518UL, (void *)0);
  }
  }
#line 321
  if (tmp___7 < 0) {
    {
    {
#line 323
    tmp___6 = __errno_location();
    }
    {
#line 323
    werror("pty_open_slave: Failed to set the controlling tty.\n   %e\n", *tmp___6);
    }
    {
#line 325
    close(fd);
    }
    }
#line 326
    return (-1);
  }
  {
  {
#line 331
  tmp___9 = tty_getattr(fd, & ios);
  }
  }
#line 331
  if (! tmp___9) {
    {
    {
#line 333
    tmp___8 = __errno_location();
    }
    {
#line 333
    werror("pty_open_slave: Failed to get tty attributes.\n   %e\n", *tmp___8);
    }
    {
#line 335
    close(fd);
    }
    }
#line 336
    return (-1);
  }
  {
  {
#line 339
  tmp___10 = lsh_string_data((struct lsh_string  const  *)pty->mode);
  }
  {
#line 339
  tmp___11 = lsh_string_length((struct lsh_string  const  *)pty->mode);
  }
  {
#line 339
  tmp___12 = tty_decode_term_mode(& ios, tmp___11, tmp___10);
  }
  }
#line 339
  if (! tmp___12) {
    {
    {
#line 341
    werror("pty_open_slave: Invalid terminal modes from client.\n");
    }
    {
#line 342
    close(fd);
    }
    }
#line 343
    return (-1);
  }
  {
  {
#line 346
  tmp___14 = tty_setattr(fd, & ios);
  }
  }
#line 346
  if (! tmp___14) {
    {
    {
#line 348
    tmp___13 = __errno_location();
    }
    {
#line 348
    werror("pty_open_slave: Failed to set tty attributes.\n   %e\n", *tmp___13);
    }
    {
#line 350
    close(fd);
    }
    }
#line 351
    return (-1);
  }
  {
  {
#line 354
  tmp___16 = tty_setwinsize(fd, (struct terminal_dimensions  const  *)(& pty->dims));
  }
  }
#line 354
  if (! tmp___16) {
    {
    {
#line 356
    tmp___15 = __errno_location();
    }
    {
#line 356
    werror("pty_open_slave: Failed to set tty window size.\n   %e\n", *tmp___15);
    }
    {
#line 358
    close(fd);
    }
    }
#line 359
    return (-1);
  }
#line 362
  return (fd);
}
}
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_userauth.h"
struct userauth *make_userauth_password(struct user_db *db ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_password.c.x"
struct lsh_class userauth_password_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_password.c.x"
static void do_userauth_password_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct userauth_password *i ;

  {
  {
#line 18
  i = (struct userauth_password *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->db);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_password.c.x"
struct lsh_class userauth_password_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & userauth_class, (char *)"userauth_password", (size_t )sizeof(struct userauth_password ),
    & do_userauth_password_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_password.c"
static void do_authenticate___0(struct userauth *s , struct ssh_connection *connection  __attribute__((__unused__)) ,
                                struct lsh_string *username , uint32_t service  __attribute__((__unused__)) ,
                                struct simple_buffer *args , struct command_continuation *c ,
                                struct exception_handler *e ) ;
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_password.c"
static struct exception  const  passwd_change_not_implemented  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "Password change not implemented."};
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_password.c"
static struct exception  const  no_such_user  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "No such user"};
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_password.c"
static void do_authenticate___0(struct userauth *s , struct ssh_connection *connection  __attribute__((__unused__)) ,
                                struct lsh_string *username , uint32_t service  __attribute__((__unused__)) ,
                                struct simple_buffer *args , struct command_continuation *c ,
                                struct exception_handler *e ) 
{ 
  struct userauth_password *self ;
  int change_passwd ;
  struct exception *tmp ;
  struct lsh_string *password ;
  struct lsh_user *user ;
  struct exception *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct exception *tmp___3 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 57
  self = (struct userauth_password *)s;
  {
#line 61
  username = utf8_to_local(username, (enum utf8_flag )2, 1);
  }
  }
#line 62
  if (! username) {
    {
    {
#line 64
    tmp = make_protocol_exception((uint32_t )2, "Invalid utf8 in username.");
    }
    {
#line 64
    (*(e->raise))(e, (struct exception  const  *)tmp);
    }
    }
#line 65
    return;
  }
  {
  {
#line 68
  tmp___2 = parse_boolean(args, & change_passwd);
  }
  }
#line 68
  if (tmp___2) {
#line 70
    password = (struct lsh_string *)((void *)0);
#line 72
    if (change_passwd) {
      {
      {
#line 78
      lsh_string_free((struct lsh_string  const  *)username);
      }
      {
#line 79
      (*(e->raise))(e, & passwd_change_not_implemented);
      }
      }
#line 81
      return;
    }
    {
    {
#line 83
    password = parse_string_copy(args);
    }
    }
#line 83
    if (password) {
      {
      {
#line 83
      tmp___1 = parse_eod(args);
      }
      }
#line 83
      if (tmp___1) {
        {
        {
#line 88
        password = utf8_to_local(password, (enum utf8_flag )0, 1);
        }
        }
#line 90
        if (! password) {
          {
          {
#line 92
          lsh_string_free((struct lsh_string  const  *)username);
          }
          {
#line 93
          tmp___0 = make_protocol_exception((uint32_t )2, "Invalid utf8 in password.");
          }
          {
#line 93
          (*(e->raise))(e, (struct exception  const  *)tmp___0);
          }
          }
#line 94
          return;
        }
        {
        {
#line 97
        user = (*((self->db)->lookup))(self->db, username, 1);
        }
        }
#line 99
        if (! user) {
          {
          {
#line 104
          lsh_string_free((struct lsh_string  const  *)password);
          }
          {
#line 105
          (*(e->raise))(e, & no_such_user);
          }
          }
#line 106
          return;
        }
        {
        {
#line 109
        (*(user->verify_password))(user, password, c, e);
        }
        }
#line 110
        return;
      }
    }
#line 112
    if (password) {
      {
      {
#line 113
      lsh_string_free((struct lsh_string  const  *)password);
      }
      }
    }
  }
  {
  {
#line 117
  lsh_string_free((struct lsh_string  const  *)username);
  }
  {
#line 119
  tmp___3 = make_protocol_exception((uint32_t )2, "Invalid password USERAUTH message.");
  }
  {
#line 119
  (*(e->raise))(e, (struct exception  const  *)tmp___3);
  }
  }
#line 120
  return;
}
}
#line 122 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_password.c"
struct userauth *make_userauth_password(struct user_db *db ) 
{ 
  struct userauth_password *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 125
  tmp = lsh_object_alloc(& userauth_password_class);
  }
#line 125
  self = (struct userauth_password *)tmp;
#line 126
  self->super.authenticate = & do_authenticate___0;
#line 127
  self->db = db;
  }
#line 129
  return (& self->super);
}
}
#line 239 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h"
void connection_send_kex(struct ssh_connection *self , struct lsh_string *message ) ;
#line 273
struct packet_handler connection_fail_handler ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.h.x"
struct lsh_class keyexchange_algorithm_class ;
#line 95 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.h"
void disconnect_kex_failed(struct ssh_connection *connection , char const   *msg ) ;
#line 141
void keyexchange_finish(struct ssh_connection *connection , struct object_list *algorithms ,
                        struct hash_algorithm  const  *H , struct lsh_string *exchange_hash ,
                        struct lsh_string *K___0 ) ;
#line 120 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
void dh_instance_mark(struct dh_instance *i , void (*mark)(struct lsh_object *o ) ) ;
#line 122
void dh_instance_free(struct dh_instance *i ) ;
#line 129 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h"
int dh_process_client_msg(struct dh_instance *self , struct lsh_string *packet ) ;
#line 139
void dh_make_server_secret(struct dh_instance *self ) ;
#line 143
struct lsh_string *dh_make_server_msg(struct dh_instance *self , struct lsh_string *server_key ,
                                      int hostkey_algorithm , struct signer *s ) ;
#line 178
void init_dh_instance(struct dh_method  const  *m , struct dh_instance *self , struct ssh_connection *c ) ;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.h"
struct keyexchange_algorithm *make_dh_server(struct dh_method *dh ) ;
#line 37
struct keyexchange_algorithm *make_srp_server(struct dh_method  const  *dh , struct user_db *db ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
struct lsh_class dh_server_exchange_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
static void do_dh_server_exchange_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct dh_server_exchange *i ;

  {
  {
#line 18
  i = (struct dh_server_exchange *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->dh);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
struct lsh_class dh_server_exchange_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & keyexchange_algorithm_class, (char *)"dh_server_exchange", (size_t )sizeof(struct dh_server_exchange ),
    & do_dh_server_exchange_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 45
struct lsh_class dh_server_class ;
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
static void do_dh_server_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct dh_server *i ;

  {
  {
#line 53
  i = (struct dh_server *)o;
  {
#line 54
  dh_instance_mark(& i->dh, mark);
  }
  {
#line 56
  (*mark)((struct lsh_object *)i->signer);
  }
  {
#line 57
  (*mark)((struct lsh_object *)i->algorithms);
  }
  }
#line 58
  return;
}
}
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
static void do_dh_server_free(struct lsh_object *o ) 
{ 
  struct dh_server *i ;

  {
  {
#line 62
  i = (struct dh_server *)o;
  {
#line 63
  dh_instance_free(& i->dh);
  }
  {
#line 64
  lsh_string_free((struct lsh_string  const  *)i->server_key);
  }
  }
#line 65
  return;
}
}
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
struct lsh_class dh_server_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & packet_handler_class, (char *)"dh_server", (size_t )sizeof(struct dh_server ),
    & do_dh_server_mark, & do_dh_server_free};
#line 90
struct lsh_class srp_server_instance_class ;
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
static void do_srp_server_instance_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct srp_server_instance *i ;

  {
  {
#line 98
  i = (struct srp_server_instance *)o;
  {
#line 99
  dh_instance_mark(& i->dh, mark);
  }
  {
#line 101
  (*mark)((struct lsh_object *)i->algorithms);
  }
  {
#line 102
  (*mark)((struct lsh_object *)i->db);
  }
  {
#line 103
  (*mark)((struct lsh_object *)i->user);
  }
  {
#line 104
  (*mark)((struct lsh_object *)i->entry);
  }
  }
#line 105
  return;
}
}
#line 106 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
static void do_srp_server_instance_free(struct lsh_object *o ) 
{ 
  struct srp_server_instance *i ;

  {
  {
#line 109
  i = (struct srp_server_instance *)o;
  {
#line 110
  dh_instance_free(& i->dh);
  }
  }
#line 111
  return;
}
}
#line 112 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
struct lsh_class srp_server_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"srp_server_instance", (size_t )sizeof(struct srp_server_instance ),
    & do_srp_server_instance_mark, & do_srp_server_instance_free};
#line 132
struct lsh_class srp_server_handler_class ;
#line 136 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
static void do_srp_server_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct srp_server_handler *i ;

  {
  {
#line 140
  i = (struct srp_server_handler *)o;
  {
#line 141
  (*mark)((struct lsh_object *)i->srp);
  }
  }
#line 142
  return;
}
}
#line 143 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
struct lsh_class srp_server_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & packet_handler_class, (char *)"srp_server_handler", (size_t )sizeof(struct srp_server_handler ),
    & do_srp_server_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 164
struct lsh_class server_srp_read_verifier_class ;
#line 168 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
static void do_server_srp_read_verifier_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct server_srp_read_verifier *i ;

  {
  {
#line 172
  i = (struct server_srp_read_verifier *)o;
  {
#line 173
  (*mark)((struct lsh_object *)i->srp);
  }
  {
#line 174
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 175
  return;
}
}
#line 176 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
struct lsh_class server_srp_read_verifier_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & abstract_write_class, (char *)"server_srp_read_verifier", (size_t )sizeof(struct server_srp_read_verifier ),
    & do_server_srp_read_verifier_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 197
struct lsh_class srp_server_exchange_class ;
#line 201 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
static void do_srp_server_exchange_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct srp_server_exchange *i ;

  {
  {
#line 205
  i = (struct srp_server_exchange *)o;
  {
#line 206
  (*mark)((struct lsh_object *)i->dh);
  }
  {
#line 207
  (*mark)((struct lsh_object *)i->db);
  }
  }
#line 208
  return;
}
}
#line 209 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c.x"
struct lsh_class srp_server_exchange_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & keyexchange_algorithm_class, (char *)"srp_server_exchange", (size_t )sizeof(struct srp_server_exchange ),
    & do_srp_server_exchange_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 64 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c"
static void do_handle_dh_init(struct packet_handler *c , struct ssh_connection *connection ,
                              struct lsh_string *packet ) 
{ 
  struct dh_server *closure ;
  int res ;
  struct lsh_string *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 69
  closure = (struct dh_server *)c;
  {
#line 72
  trace("handle_dh_init\n");
  }
  {
#line 74
  res = dh_process_client_msg(& closure->dh, packet);
  }
  }
#line 76
  if (! res) {
    {
    {
#line 78
    disconnect_kex_failed(connection, "Bad dh-init\r\n");
    }
    }
#line 79
    return;
  }
  {
  {
#line 83
  tmp = dh_make_server_msg(& closure->dh, closure->server_key, closure->hostkey_algorithm,
                           closure->signer);
  }
  {
#line 83
  connection_send_kex(connection, tmp);
  }
#line 89
  connection->dispatch[30] = & connection_fail_handler;
  {
#line 91
  keyexchange_finish(connection, closure->algorithms, (struct hash_algorithm  const  *)(closure->dh.method)->H,
                     closure->dh.exchange_hash, closure->dh.K);
  }
#line 97
  closure->dh.K = (struct lsh_string *)((void *)0);
#line 98
  closure->dh.exchange_hash = (struct lsh_string *)((void *)0);
  {
#line 101
  gc_kill((struct lsh_object *)closure);
  }
  }
#line 102
  return;
}
}
#line 104 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c"
static void do_init_server_dh(struct keyexchange_algorithm *c , struct ssh_connection *connection ,
                              int hostkey_algorithm , struct lsh_object *extra , struct object_list *algorithms ) 
{ 
  struct dh_server_exchange *closure ;
  struct alist *keys ;
  struct keypair *key ;
  struct lsh_object *tmp ;
  struct dh_server *dh ;
  struct lsh_object *tmp___0 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 111
  closure = (struct dh_server_exchange *)c;
#line 112
  keys = (struct alist *)extra;
  {
#line 113
  tmp = (*(((struct alist_meta *)keys->super.isa)->get))(keys, hostkey_algorithm);
  }
#line 113
  key = (struct keypair *)tmp;
  }
#line 116
  if (! key) {
    {
    {
#line 118
    werror("Keypair for for selected signature-algorithm not found!\n");
    }
    {
#line 119
    disconnect_kex_failed(connection, "Configuration error");
    }
    }
#line 120
    return;
  } else {
    {
    {
#line 124
    tmp___0 = lsh_object_alloc(& dh_server_class);
    }
#line 124
    dh = (struct dh_server *)tmp___0;
#line 127
    dh->super.handler = & do_handle_dh_init;
    {
#line 128
    init_dh_instance((struct dh_method  const  *)closure->dh, & dh->dh, connection);
    }
    {
#line 130
    dh->server_key = ssh_format("%lS", key->public);
    }
#line 131
    dh->signer = key->private;
#line 133
    dh->hostkey_algorithm = hostkey_algorithm;
#line 135
    dh->algorithms = algorithms;
    {
#line 138
    dh_make_server_secret(& dh->dh);
    }
#line 141
    connection->dispatch[30] = & dh->super;
    }
  }
#line 143
  return;
}
}
#line 146 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c"
struct keyexchange_algorithm *make_dh_server(struct dh_method *dh ) 
{ 
  struct dh_server_exchange *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 149
  tmp = lsh_object_alloc(& dh_server_exchange_class);
  }
#line 149
  self = (struct dh_server_exchange *)tmp;
#line 151
  self->super.init = & do_init_server_dh;
#line 152
  self->dh = dh;
  }
#line 154
  return (& self->super);
}
}
#line 180 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c"
static void do_srp_server_proof_handler(struct packet_handler *s , struct ssh_connection *connection ,
                                        struct lsh_string *packet ) 
{ 
  struct srp_server_handler *self ;
  struct lsh_string *response ;
  struct lsh_string *tmp ;
  struct exception *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 185
  self = (struct srp_server_handler *)s;
  {
#line 187
  tmp = srp_process_client_proof(& (self->srp)->dh, packet);
  }
#line 187
  response = tmp;
#line 189
  connection->dispatch[32] = & connection_fail_handler;
  }
#line 191
  if (response) {
    {
    {
#line 193
    connection_send_kex(connection, response);
    }
#line 196
    connection->user = (self->srp)->user;
#line 197
    connection->flags = (enum connection_flag )((unsigned int )connection->flags | 2U);
    {
#line 199
    keyexchange_finish(connection, (self->srp)->algorithms, (struct hash_algorithm  const  *)((self->srp)->dh.method)->H,
                       (self->srp)->dh.exchange_hash, (self->srp)->dh.K);
    }
#line 204
    (self->srp)->dh.K = (struct lsh_string *)((void *)0);
#line 205
    (self->srp)->dh.exchange_hash = (struct lsh_string *)((void *)0);
    }
  } else {
    {
    {
#line 208
    tmp___0 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_KEXSRP_PROOF message");
    }
    {
#line 208
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___0);
    }
    }
  }
  {
  {
#line 211
  gc_kill((struct lsh_object *)self->srp);
  }
  {
#line 212
  gc_kill((struct lsh_object *)self);
  }
  }
#line 213
  return;
}
}
#line 215 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c"
static struct packet_handler *make_srp_server_proof_handler(struct srp_server_instance *srp ) 
{ 
  struct srp_server_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 218
  tmp = lsh_object_alloc(& srp_server_handler_class);
  }
#line 218
  self = (struct srp_server_handler *)tmp;
#line 219
  self->super.handler = & do_srp_server_proof_handler;
#line 220
  self->srp = srp;
  }
#line 222
  return (& self->super);
}
}
#line 225 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c"
static void do_exc_srp(struct exception_handler *e , struct exception  const  *x ) 
{ 
  struct exception *tmp ;

  {
  {
  {
#line 231
  tmp = make_protocol_exception((uint32_t )3, (char const   *)x->msg);
  }
  {
#line 231
  (*((e->parent)->raise))(e->parent, (struct exception  const  *)tmp);
  }
  }
#line 234
  return;
}
}
#line 246 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c"
static void do_server_srp_read_verifier(struct abstract_write *s , struct lsh_string *file ) 
{ 
  struct server_srp_read_verifier *self ;
  struct lsh_string *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 250
  self = (struct server_srp_read_verifier *)s;
#line 252
  if (! file) {
    {
    {
#line 254
    disconnect_kex_failed(self->connection, "Can\'t read verifier file");
    }
    }
  } else {
    {
    {
#line 259
    (self->srp)->entry = make_srp_entry((struct lsh_string  const  *)((self->srp)->user)->name,
                                        (struct lsh_string  const  *)file);
    }
    }
#line 261
    if (! (self->srp)->entry) {
      {
      {
#line 262
      disconnect_kex_failed(self->connection, "Invalid SRP verifier");
      }
      }
    } else {
      {
      {
#line 267
      tmp = srp_make_reply_msg(& (self->srp)->dh, (self->srp)->entry);
      }
      {
#line 267
      connection_send_kex(self->connection, tmp);
      }
      {
#line 270
      (self->connection)->dispatch[32] = make_srp_server_proof_handler(self->srp);
      }
      }
    }
  }
#line 274
  return;
}
}
#line 276 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c"
static struct abstract_write *make_server_srp_read_verifier(struct srp_server_instance *srp ,
                                                            struct ssh_connection *connection ) 
{ 
  struct server_srp_read_verifier *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 280
  tmp = lsh_object_alloc(& server_srp_read_verifier_class);
  }
#line 280
  self = (struct server_srp_read_verifier *)tmp;
#line 281
  self->super.write = & do_server_srp_read_verifier;
#line 282
  self->srp = srp;
#line 283
  self->connection = connection;
  }
#line 285
  return (& self->super);
}
}
#line 290 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c"
static void do_handle_srp_init(struct packet_handler *s , struct ssh_connection *connection ,
                               struct lsh_string *packet ) 
{ 
  struct srp_server_handler *self ;
  struct lsh_string *name ;
  struct lsh_string *tmp ;
  struct exception_handler *e ;
  struct exception *tmp___0 ;
  struct exception *tmp___1 ;
  struct abstract_write *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 295
  self = (struct srp_server_handler *)s;
  {
#line 296
  tmp = srp_process_init_msg(& (self->srp)->dh, packet);
  }
#line 296
  name = tmp;
#line 299
  connection->dispatch[30] = & connection_fail_handler;
  }
#line 301
  if (! name) {
    {
    {
#line 303
    tmp___0 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_KEXSRP_INIT message");
    }
    {
#line 303
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___0);
    }
    }
#line 304
    return;
  }
  {
  {
#line 307
  (self->srp)->user = (*(((self->srp)->db)->lookup))((self->srp)->db, name, 1);
  }
  }
#line 308
  if (! (self->srp)->user) {
    {
    {
#line 310
    tmp___1 = make_protocol_exception((uint32_t )15, (char const   *)((void *)0));
    }
    {
#line 310
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
    }
    }
#line 312
    return;
  }
  {
  {
#line 316
  e = make_exception_handler(& do_exc_srp, connection->e, "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c:316");
  }
  {
#line 318
  tmp___2 = make_server_srp_read_verifier(self->srp, connection);
  }
  {
#line 318
  (*(((self->srp)->user)->read_file))((self->srp)->user, "srp-verifier", 1, (uint32_t )2000,
                                      tmp___2);
  }
  }
#line 320
  return;
}
}
#line 322 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c"
static struct packet_handler *make_srp_init_handler(struct srp_server_instance *srp ) 
{ 
  struct srp_server_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 325
  tmp = lsh_object_alloc(& srp_server_handler_class);
  }
#line 325
  self = (struct srp_server_handler *)tmp;
#line 326
  self->super.handler = & do_handle_srp_init;
#line 327
  self->srp = srp;
  }
#line 329
  return (& self->super);
}
}
#line 341 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c"
static void do_init_server_srp(struct keyexchange_algorithm *s , struct ssh_connection *connection ,
                               int hostkey_algorithm  __attribute__((__unused__)) ,
                               struct lsh_object *extra  __attribute__((__unused__)) ,
                               struct object_list *algorithms ) 
{ 
  struct srp_server_exchange *self ;
  struct srp_server_instance *srp ;
  struct lsh_object *tmp ;

  {
  {
#line 348
  self = (struct srp_server_exchange *)s;
  {
#line 350
  tmp = lsh_object_alloc(& srp_server_instance_class);
  }
#line 350
  srp = (struct srp_server_instance *)tmp;
  {
#line 353
  init_dh_instance(self->dh, & srp->dh, connection);
  }
#line 355
  srp->algorithms = algorithms;
#line 356
  srp->db = self->db;
#line 357
  srp->user = (struct lsh_user *)((void *)0);
#line 358
  srp->entry = (struct srp_entry *)((void *)0);
  {
#line 361
  connection->dispatch[30] = make_srp_init_handler(srp);
  }
  }
#line 362
  return;
}
}
#line 364 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_keyexchange.c"
struct keyexchange_algorithm *make_srp_server(struct dh_method  const  *dh , struct user_db *db ) 
{ 
  struct srp_server_exchange *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 368
  tmp = lsh_object_alloc(& srp_server_exchange_class);
  }
#line 368
  self = (struct srp_server_exchange *)tmp;
#line 370
  self->super.init = & do_init_server_srp;
#line 371
  self->dh = dh;
#line 372
  self->db = db;
  }
#line 374
  return (& self->super);
}
}
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/lookup_verifier.h.x"
struct lsh_class lookup_verifier_class ;
#line 190 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h"
struct verifier *make_ssh_rsa_verifier(struct lsh_string  const  *public ) ;
#line 203
struct verifier *make_ssh_dss_verifier(struct lsh_string  const  *public ) ;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_authorization.h"
struct lookup_verifier *make_authorization_db(struct lsh_string *index_name , struct hash_algorithm  const  *h___0 ) ;
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_authorization.c.x"
struct lsh_class authorization_db_class ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_authorization.c.x"
static void do_authorization_db_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct authorization_db *i ;

  {
  {
#line 19
  i = (struct authorization_db *)o;
  {
#line 20
  (*mark)((struct lsh_object *)i->hashalgo);
  }
  }
#line 21
  return;
}
}
#line 22 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_authorization.c.x"
static void do_authorization_db_free(struct lsh_object *o ) 
{ 
  struct authorization_db *i ;

  {
  {
#line 25
  i = (struct authorization_db *)o;
  {
#line 26
  lsh_string_free((struct lsh_string  const  *)i->index_name);
  }
  }
#line 27
  return;
}
}
#line 28 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_authorization.c.x"
struct lsh_class authorization_db_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & lookup_verifier_class, (char *)"authorization_db", (size_t )sizeof(struct authorization_db ),
    & do_authorization_db_mark, & do_authorization_db_free};
#line 56 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_authorization.c"
static struct verifier *do_key_lookup(struct lookup_verifier *c , int method , struct lsh_user *keyholder ,
                                      struct lsh_string *key ) 
{ 
  struct authorization_db *closure ;
  struct lsh_string *filename ;
  struct verifier *v ;
  struct lsh_string *tmp ;
  struct lsh_string *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 62
  closure = (struct authorization_db *)c;
#line 65
  v = (struct verifier *)((void *)0);
#line 67
  if (! keyholder) {
    {
    {
#line 67
    __assert_fail("keyholder", "/home/ysko/Works/test-src/lsh-2.0.4/src/server_authorization.c",
                  67U, "do_key_lookup");
    }
    }
  }
#line 76
  if (method == 36) {
#line 76
    goto case_36;
  }
#line 80
  if (method == 37) {
#line 80
    goto case_37;
  }
#line 71
  goto switch_default;
  switch_default: 
#line 72
  return ((struct verifier *)((void *)0));
  case_36: 
  {
  {
#line 77
  v = make_ssh_dss_verifier((struct lsh_string  const  *)key);
  }
  }
#line 78
  goto switch_break;
  case_37: 
  {
  {
#line 81
  v = make_ssh_rsa_verifier((struct lsh_string  const  *)key);
  }
  }
#line 82
  goto switch_break;
  switch_break: ;
#line 85
  if (! v) {
#line 86
    return ((struct verifier *)((void *)0));
  }
  {
  {
#line 90
  tmp = (*(v->public_spki_key))(v, 0);
  }
  {
#line 90
  tmp___0 = hash_string(closure->hashalgo, (struct lsh_string  const  *)tmp, 1);
  }
  {
#line 90
  filename = ssh_format(".lsh/%lS/%lxfS", closure->index_name, tmp___0);
  }
  {
#line 96
  tmp___1 = (*(keyholder->file_exists))(keyholder, filename, 1);
  }
  }
#line 96
  if (tmp___1) {
#line 97
    return (v);
  }
#line 99
  return ((struct verifier *)((void *)0));
}
}
#line 102 "/home/ysko/Works/test-src/lsh-2.0.4/src/server_authorization.c"
struct lookup_verifier *make_authorization_db(struct lsh_string *index_name , struct hash_algorithm  const  *h___0 ) 
{ 
  struct authorization_db *res ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 107
  tmp = lsh_object_alloc(& authorization_db_class);
  }
#line 107
  res = (struct authorization_db *)tmp;
#line 109
  res->super.lookup = & do_key_lookup;
#line 110
  res->index_name = index_name;
#line 112
  res->hashalgo = h___0;
  }
#line 114
  return (& res->super);
}
}
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.h"
struct command *make_offer_service(struct alist *services ) ;
#line 31
int read_host_key(char const   *file , struct alist *signature_algorithms , struct alist *keys ) ;
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h"
struct keypair *make_keypair(uint32_t type , struct lsh_string *public , struct signer *private ) ;
#line 12 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c.x"
struct lsh_class service_handler_class ;
#line 16 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c.x"
static void do_service_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct service_handler *i ;

  {
  {
#line 20
  i = (struct service_handler *)o;
  {
#line 21
  (*mark)((struct lsh_object *)i->services);
  }
  {
#line 22
  (*mark)((struct lsh_object *)i->c);
  }
  {
#line 23
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 24
  return;
}
}
#line 25 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c.x"
struct lsh_class service_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & packet_handler_class, (char *)"service_handler", (size_t )sizeof(struct service_handler ),
    & do_service_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 45
struct lsh_class offer_service_class ;
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c.x"
static void do_offer_service_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct offer_service *i ;

  {
  {
#line 53
  i = (struct offer_service *)o;
  {
#line 54
  (*mark)((struct lsh_object *)i->services);
  }
  }
#line 55
  return;
}
}
#line 56 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c.x"
struct lsh_class offer_service_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"offer_service", (size_t )sizeof(struct offer_service ),
    & do_offer_service_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c"
static struct lsh_string *format_service_accept(int name ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 58
  tmp = ssh_format("%c%a", 6, name);
  }
  }
#line 58
  return (tmp);
}
}
#line 72 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c"
static void do_service_request(struct packet_handler *c , struct ssh_connection *connection ,
                               struct lsh_string *packet ) 
{ 
  struct service_handler *closure ;
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  int name ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct command *service ;
  struct lsh_object *tmp___1 ;
  struct lsh_string *tmp___2 ;
  struct exception *tmp___3 ;
  struct exception *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 77
  closure = (struct service_handler *)c;
  {
#line 83
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 83
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 83
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 85
  tmp___5 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 85
  if (tmp___5) {
#line 85
    if (msg_number == 5U) {
      {
      {
#line 85
      tmp___6 = parse_atom(& buffer, & name);
      }
      }
#line 85
      if (tmp___6) {
        {
        {
#line 85
        tmp___7 = parse_eod(& buffer);
        }
        }
#line 85
        if (tmp___7) {
#line 90
          if (name) {
            {
            {
#line 92
            tmp___1 = (*(((struct alist_meta *)(closure->services)->super.isa)->get))(closure->services,
                                                                                      name);
            }
#line 92
            service = (struct command *)tmp___1;
            }
#line 93
            if (service) {
              {
#line 96
              connection->dispatch[5] = & connection_fail_handler;
              {
#line 100
              tmp___2 = format_service_accept(name);
              }
              {
#line 100
              connection_send(connection, tmp___2);
              }
              {
#line 102
              (*(service->call))(service, (struct lsh_object *)connection, closure->c,
                                 closure->e);
              }
              }
#line 104
              return;
            }
          }
          {
          {
#line 107
          tmp___3 = make_protocol_exception((uint32_t )7, (char const   *)((void *)0));
          }
          {
#line 107
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
          }
          }
        } else {
          {
          {
#line 112
          tmp___4 = make_protocol_exception((uint32_t )2, "Invalid SERVICE_REQUEST message");
          }
          {
#line 112
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
          }
          }
        }
      } else {
        {
        {
#line 112
        tmp___4 = make_protocol_exception((uint32_t )2, "Invalid SERVICE_REQUEST message");
        }
        {
#line 112
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
        }
        }
      }
    } else {
      {
      {
#line 112
      tmp___4 = make_protocol_exception((uint32_t )2, "Invalid SERVICE_REQUEST message");
      }
      {
#line 112
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
      }
      }
    }
  } else {
    {
    {
#line 112
    tmp___4 = make_protocol_exception((uint32_t )2, "Invalid SERVICE_REQUEST message");
    }
    {
#line 112
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
    }
    }
  }
#line 113
  return;
}
}
#line 115 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c"
static struct packet_handler *make_service_request_handler(struct alist *services ,
                                                           struct command_continuation *c ,
                                                           struct exception_handler *e ) 
{ 
  struct service_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 120
  tmp = lsh_object_alloc(& service_handler_class);
  }
#line 120
  self = (struct service_handler *)tmp;
#line 122
  self->super.handler = & do_service_request;
#line 123
  self->services = services;
#line 124
  self->c = c;
#line 125
  self->e = e;
  }
#line 127
  return (& self->super);
}
}
#line 139 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c"
static void do_offer_service(struct command *s , struct lsh_object *x , struct command_continuation *c ,
                             struct exception_handler *e ) 
{ 
  struct offer_service *self ;
  struct ssh_connection *connection ;

  {
  {
#line 145
  self = (struct offer_service *)s;
#line 146
  connection = (struct ssh_connection *)x;
  {
#line 148
  connection->dispatch[5] = make_service_request_handler(self->services, c, e);
  }
  }
#line 150
  return;
}
}
#line 152 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c"
struct command *make_offer_service(struct alist *services ) 
{ 
  struct offer_service *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 154
  tmp = lsh_object_alloc(& offer_service_class);
  }
#line 154
  self = (struct offer_service *)tmp;
#line 156
  self->super.call = & do_offer_service;
#line 157
  self->services = services;
  }
#line 159
  return (& self->super);
}
}
#line 165 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c"
static void add_key(struct alist *keys , struct keypair *key ) 
{ 
  struct lsh_object *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 169
  tmp = (*(((struct alist_meta *)keys->super.isa)->get))(keys, key->type);
  }
  }
#line 169
  if (tmp) {
    {
    {
#line 170
    werror("Multiple host keys for algorithm %a\n", key->type);
    }
    }
  }
  {
  {
#line 171
  (*(((struct alist_meta *)keys->super.isa)->set))(keys, key->type, & key->super);
  }
  }
#line 172
  return;
}
}
#line 174 "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c"
int read_host_key(char const   *file , struct alist *signature_algorithms , struct alist *keys ) 
{ 
  int fd ;
  int tmp ;
  struct lsh_string *contents ;
  struct signer *s ;
  struct verifier *v ;
  struct lsh_string *spki_public ;
  int algorithm_name ;
  int *tmp___0 ;
  int *tmp___1 ;
  struct lsh_string *tmp___2 ;
  struct keypair *tmp___3 ;
  struct keypair *tmp___4 ;
  struct lsh_string *tmp___5 ;
  struct keypair *tmp___6 ;
  struct keypair *tmp___7 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
  {
#line 179
  tmp = open(file, 0);
  }
#line 179
  fd = tmp;
  }
#line 187
  if (fd < 0) {
    {
    {
#line 189
    tmp___0 = __errno_location();
    }
    {
#line 189
    werror("Failed to open `%z\' for reading %e\n", file, *tmp___0);
    }
    }
#line 190
    return (0);
  }
  {
  {
#line 193
  contents = io_read_file_raw(fd, (uint32_t )5000);
  }
  }
#line 194
  if (! contents) {
    {
    {
#line 196
    tmp___1 = __errno_location();
    }
    {
#line 196
    werror("Failed to read host key file `%z\': %e\n", file, *tmp___1);
    }
    {
#line 197
    close(fd);
    }
    }
#line 198
    return (0);
  }
  {
  {
#line 200
  close(fd);
  }
  {
#line 202
  s = spki_make_signer(signature_algorithms, (struct lsh_string  const  *)contents,
                       & algorithm_name);
  }
  {
#line 205
  lsh_string_free((struct lsh_string  const  *)contents);
  }
  }
#line 207
  if (! s) {
    {
    {
#line 209
    werror("Invalid host key\n");
    }
    }
#line 210
    return (0);
  }
  {
  {
#line 213
  v = (*(s->get_verifier))(s);
  }
  }
#line 214
  if (! v) {
    {
    {
#line 214
    __assert_fail("v", "/home/ysko/Works/test-src/lsh-2.0.4/src/server.c", 214U, "read_host_key");
    }
    }
  }
  {
  {
#line 216
  spki_public = (*(v->public_spki_key))(v, 0);
  }
  }
#line 220
  if (algorithm_name == 87) {
#line 220
    goto case_87;
  }
#line 228
  if (algorithm_name == 96) {
#line 228
    goto case_96;
  }
#line 228
  if (algorithm_name == 95) {
#line 228
    goto case_96;
  }
#line 233
  if (algorithm_name == 97) {
#line 233
    goto case_97;
  }
#line 238
  goto switch_default;
  case_87: 
  {
  {
#line 221
  tmp___2 = (*(v->public_key))(v);
  }
  {
#line 221
  tmp___3 = make_keypair((uint32_t )36, tmp___2, s);
  }
  {
#line 221
  add_key(keys, tmp___3);
  }
  {
#line 223
  tmp___4 = make_keypair((uint32_t )41, spki_public, s);
  }
  {
#line 223
  add_key(keys, tmp___4);
  }
  }
#line 225
  goto switch_break;
  case_96: 
  {
  {
#line 229
  tmp___5 = (*(v->public_key))(v);
  }
  {
#line 229
  tmp___6 = make_keypair((uint32_t )37, tmp___5, s);
  }
  {
#line 229
  add_key(keys, tmp___6);
  }
  }
  case_97: 
  {
  {
#line 234
  tmp___7 = make_keypair((uint32_t )40, spki_public, s);
  }
  {
#line 234
  add_key(keys, tmp___7);
  }
  }
#line 236
  goto switch_break;
  switch_default: 
  {
  {
#line 239
  werror("read_host_key: Unexpected algorithm %a.\n", algorithm_name);
  }
  {
#line 240
  lsh_string_free((struct lsh_string  const  *)spki_public);
  }
  }
  switch_break: ;
#line 242
  return (1);
}
}
#line 165 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct lsh_class verifier_class ;
#line 190
struct lsh_class signer_class ;
#line 184 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h"
struct signature_algorithm rsa_sha1_algorithm ;
#line 187
struct verifier *parse_ssh_rsa_public(struct simple_buffer *buffer ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c.x"
struct lsh_class rsa_verifier_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c.x"
static void do_rsa_verifier_free(struct lsh_object *o ) 
{ 
  struct rsa_verifier *i ;

  {
  {
#line 17
  i = (struct rsa_verifier *)o;
  {
#line 18
  nettle_rsa_public_key_clear(& i->key);
  }
  }
#line 19
  return;
}
}
#line 20 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c.x"
struct lsh_class rsa_verifier_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & verifier_class, (char *)"rsa_verifier", (size_t )sizeof(struct rsa_verifier ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_rsa_verifier_free};
#line 41
struct lsh_class rsa_signer_class ;
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c.x"
static void do_rsa_signer_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct rsa_signer *i ;

  {
  {
#line 49
  i = (struct rsa_signer *)o;
  {
#line 50
  (*mark)((struct lsh_object *)i->verifier);
  }
  }
#line 51
  return;
}
}
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c.x"
static void do_rsa_signer_free(struct lsh_object *o ) 
{ 
  struct rsa_signer *i ;

  {
  {
#line 55
  i = (struct rsa_signer *)o;
  {
#line 56
  nettle_rsa_private_key_clear(& i->key);
  }
  }
#line 57
  return;
}
}
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c.x"
struct lsh_class rsa_signer_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & signer_class, (char *)"rsa_signer", (size_t )sizeof(struct rsa_signer ),
    & do_rsa_signer_mark, & do_rsa_signer_free};
#line 75 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c"
static int do_rsa_verify(struct verifier *v , int algorithm , uint32_t length , uint8_t const   *msg ,
                         uint32_t signature_length , uint8_t const   *signature_data ) 
{ 
  struct rsa_verifier *self ;
  struct sha1_ctx hash___2 ;
  mpz_t s ;
  int res ;
  struct simple_buffer buffer ;
  uint32_t length___0 ;
  uint8_t const   *digits ;
  int atom ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct sexp_iterator i ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
  {
#line 83
  self = (struct rsa_verifier *)v;
#line 87
  res = 0;
  {
#line 89
  trace("do_rsa_verify: Verifying %a signature\n", algorithm);
  }
  {
#line 91
  __gmpz_init(s);
  }
  }
#line 95
  if (algorithm == 37) {
#line 95
    goto case_37;
  }
#line 119
  if (algorithm == 44) {
#line 119
    goto case_44;
  }
#line 119
  if (algorithm == 41) {
#line 119
    goto case_44;
  }
#line 119
  if (algorithm == 40) {
#line 119
    goto case_44;
  }
#line 130
  goto switch_default;
  case_37: 
  {
  {
#line 102
  simple_buffer_init(& buffer, signature_length, signature_data);
  }
  {
#line 104
  tmp = parse_atom(& buffer, & atom);
  }
  }
#line 104
  if (tmp) {
#line 104
    if (atom == 37) {
      {
      {
#line 104
      tmp___0 = parse_string(& buffer, & length___0, & digits);
      }
      }
#line 104
      if (tmp___0) {
#line 104
        if (length___0 <= self->key.size) {
          {
          {
#line 104
          tmp___1 = parse_eod(& buffer);
          }
          }
#line 104
          if (! tmp___1) {
#line 109
            goto fail;
          }
        } else {
#line 109
          goto fail;
        }
      } else {
#line 109
        goto fail;
      }
    } else {
#line 109
      goto fail;
    }
  } else {
#line 109
    goto fail;
  }
  {
  {
#line 111
  nettle_mpz_set_str_256_u(s, length___0, digits);
  }
  }
#line 113
  goto switch_break;
  case_44: 
  {
  {
#line 123
  tmp___2 = nettle_sexp_iterator_first(& i, signature_length, signature_data);
  }
  }
#line 123
  if (tmp___2) {
    {
    {
#line 123
    tmp___3 = nettle_mpz_set_sexp(s, 8U * self->key.size, & i);
    }
    }
#line 123
    if (! tmp___3) {
#line 125
      goto fail;
    }
  } else {
#line 125
    goto fail;
  }
#line 127
  goto switch_break;
  switch_default: 
  {
  {
#line 131
  fatal("do_rsa_verify: Internal error!\n");
  }
  }
  switch_break: 
  {
  {
#line 134
  nettle_sha1_init(& hash___2);
  }
  {
#line 135
  nettle_sha1_update(& hash___2, length, msg);
  }
  {
#line 136
  res = nettle_rsa_sha1_verify((struct rsa_public_key  const  *)(& self->key), & hash___2,
                               (__mpz_struct */* const  */)(s));
  }
  }
  fail: 
  {
  {
#line 139
  __gmpz_clear(s);
  }
  }
#line 141
  return (res);
}
}
#line 144 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c"
static struct lsh_string *do_rsa_public_key(struct verifier *s ) 
{ 
  struct rsa_verifier *self ;
  struct lsh_string *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 147
  self = (struct rsa_verifier *)s;
  {
#line 149
  tmp = ssh_format("%a%n%n", 37, self->key.e, self->key.n);
  }
  }
#line 149
  return (tmp);
}
}
#line 153 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c"
static struct lsh_string *do_rsa_public_spki_key(struct verifier *s , int transport ) 
{ 
  struct rsa_verifier *self ;
  struct lsh_string *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 156
  self = (struct rsa_verifier *)s;
  {
#line 166
  tmp = lsh_string_format_sexp(transport, "(public-key(rsa-pkcs1-sha1(n%b)(e%b)))",
                               self->key.n, self->key.e);
  }
  }
#line 166
  return (tmp);
}
}
#line 177 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c"
static void init_rsa_verifier(struct rsa_verifier *self ) 
{ 


  {
  {
  {
#line 182
  nettle_rsa_public_key_init(& self->key);
  }
#line 184
  self->super.verify = & do_rsa_verify;
#line 185
  self->super.public_key = & do_rsa_public_key;
#line 186
  self->super.public_spki_key = & do_rsa_public_spki_key;
  }
#line 187
  return;
}
}
#line 191 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c"
struct verifier *parse_ssh_rsa_public(struct simple_buffer *buffer ) 
{ 
  struct rsa_verifier *res ;
  struct lsh_object *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
  {
#line 194
  tmp = lsh_object_alloc(& rsa_verifier_class);
  }
#line 194
  res = (struct rsa_verifier *)tmp;
  {
#line 195
  init_rsa_verifier(res);
  }
  {
#line 197
  tmp___0 = parse_bignum(buffer, res->key.e, (uint32_t )625);
  }
  }
#line 197
  if (tmp___0) {
#line 197
    if (res->key.e[0]._mp_size < 0) {
#line 197
      tmp___1 = -1;
    } else {
#line 197
      tmp___1 = res->key.e[0]._mp_size > 0;
    }
#line 197
    if (tmp___1 == 1) {
      {
      {
#line 197
      tmp___2 = parse_bignum(buffer, res->key.n, (uint32_t )625);
      }
      }
#line 197
      if (tmp___2) {
#line 197
        if (res->key.n[0]._mp_size < 0) {
#line 197
          tmp___3 = -1;
        } else {
#line 197
          tmp___3 = res->key.n[0]._mp_size > 0;
        }
#line 197
        if (tmp___3 == 1) {
          {
          {
#line 197
          tmp___4 = __gmpz_cmp((mpz_srcptr )(res->key.e), (mpz_srcptr )(res->key.n));
          }
          }
#line 197
          if (tmp___4 < 0) {
            {
            {
#line 197
            tmp___5 = parse_eod(buffer);
            }
            }
#line 197
            if (tmp___5) {
              {
              {
#line 197
              tmp___6 = nettle_rsa_public_key_prepare(& res->key);
              }
              }
#line 197
              if (tmp___6) {
#line 204
                return (& res->super);
              } else {
                {
                {
#line 208
                gc_kill((struct lsh_object *)res);
                }
                }
#line 209
                return ((struct verifier *)((void *)0));
              }
            } else {
              {
              {
#line 208
              gc_kill((struct lsh_object *)res);
              }
              }
#line 209
              return ((struct verifier *)((void *)0));
            }
          } else {
            {
            {
#line 208
            gc_kill((struct lsh_object *)res);
            }
            }
#line 209
            return ((struct verifier *)((void *)0));
          }
        } else {
          {
          {
#line 208
          gc_kill((struct lsh_object *)res);
          }
          }
#line 209
          return ((struct verifier *)((void *)0));
        }
      } else {
        {
        {
#line 208
        gc_kill((struct lsh_object *)res);
        }
        }
#line 209
        return ((struct verifier *)((void *)0));
      }
    } else {
      {
      {
#line 208
      gc_kill((struct lsh_object *)res);
      }
      }
#line 209
      return ((struct verifier *)((void *)0));
    }
  } else {
    {
    {
#line 208
    gc_kill((struct lsh_object *)res);
    }
    }
#line 209
    return ((struct verifier *)((void *)0));
  }
}
}
#line 215 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c"
static struct lsh_string *do_rsa_sign(struct signer *s , int algorithm , uint32_t msg_length ,
                                      uint8_t const   *msg ) 
{ 
  struct rsa_signer *self ;
  struct lsh_string *res ;
  struct sha1_ctx hash___2 ;
  mpz_t signature ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 221
  self = (struct rsa_signer *)s;
  {
#line 226
  trace("do_rsa_sign: Signing according to %a\n", algorithm);
  }
  {
#line 228
  __gmpz_init(signature);
  }
  {
#line 229
  nettle_sha1_init(& hash___2);
  }
  {
#line 230
  nettle_sha1_update(& hash___2, msg_length, msg);
  }
  {
#line 232
  nettle_rsa_sha1_sign((struct rsa_private_key  const  *)(& self->key), & hash___2,
                       signature);
  }
  }
#line 236
  if (algorithm == 37) {
#line 236
    goto case_37;
  }
#line 249
  if (algorithm == 44) {
#line 249
    goto case_44;
  }
#line 249
  if (algorithm == 41) {
#line 249
    goto case_44;
  }
#line 249
  if (algorithm == 40) {
#line 249
    goto case_44;
  }
#line 253
  goto switch_default;
  case_37: 
  {
  {
#line 243
  res = ssh_format("%a%un", 37, signature);
  }
  }
#line 244
  goto switch_break;
  case_44: 
  {
  {
#line 251
  res = lsh_string_format_sexp(0, "%b", signature);
  }
  }
#line 252
  goto switch_break;
  switch_default: 
  {
  {
#line 254
  fatal("do_rsa_sign: Internal error!\n");
  }
  }
  switch_break: 
  {
  {
#line 256
  __gmpz_clear(signature);
  }
  }
#line 257
  return (res);
}
}
#line 260 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c"
static struct verifier *do_rsa_get_verifier(struct signer *s ) 
{ 
  struct rsa_signer *self ;

  {
#line 263
  self = (struct rsa_signer *)s;
#line 265
  return (& (self->verifier)->super);
}
}
#line 268 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c"
static struct verifier *make_rsa_verifier(struct signature_algorithm *s  __attribute__((__unused__)) ,
                                          struct sexp_iterator *i ) 
{ 
  struct rsa_verifier *res ;
  struct lsh_object *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 272
  tmp = lsh_object_alloc(& rsa_verifier_class);
  }
#line 272
  res = (struct rsa_verifier *)tmp;
  {
#line 273
  init_rsa_verifier(res);
  }
  {
#line 275
  tmp___0 = nettle_rsa_keypair_from_sexp_alist(& res->key, (struct rsa_private_key *)((void *)0),
                                               5000U, i);
  }
  }
#line 275
  if (tmp___0) {
    {
    {
#line 275
    tmp___1 = nettle_rsa_public_key_prepare(& res->key);
    }
    }
#line 275
    if (tmp___1) {
#line 277
      return (& res->super);
    }
  }
  {
  {
#line 279
  gc_kill((struct lsh_object *)res);
  }
  }
#line 280
  return ((struct verifier *)((void *)0));
}
}
#line 284 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c"
static struct signer *make_rsa_signer(struct signature_algorithm *s  __attribute__((__unused__)) ,
                                      struct sexp_iterator *i ) 
{ 
  struct rsa_verifier *verifier ;
  struct lsh_object *tmp ;
  struct rsa_signer *res ;
  struct lsh_object *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  {
#line 288
  tmp = lsh_object_alloc(& rsa_verifier_class);
  }
#line 288
  verifier = (struct rsa_verifier *)tmp;
  {
#line 289
  tmp___0 = lsh_object_alloc(& rsa_signer_class);
  }
#line 289
  res = (struct rsa_signer *)tmp___0;
  {
#line 291
  init_rsa_verifier(verifier);
  }
  {
#line 293
  nettle_rsa_private_key_init(& res->key);
  }
  {
#line 294
  tmp___1 = nettle_rsa_keypair_from_sexp_alist(& verifier->key, & res->key, 5000U,
                                               i);
  }
  }
#line 294
  if (tmp___1) {
    {
    {
#line 294
    tmp___2 = nettle_rsa_public_key_prepare(& verifier->key);
    }
    }
#line 294
    if (tmp___2) {
      {
      {
#line 294
      tmp___3 = nettle_rsa_private_key_prepare(& res->key);
      }
      }
#line 294
      if (tmp___3) {
#line 294
        if (res->key.size == verifier->key.size) {
#line 299
          res->verifier = verifier;
#line 301
          res->super.sign = & do_rsa_sign;
#line 302
          res->super.get_verifier = & do_rsa_get_verifier;
#line 304
          return (& res->super);
        }
      }
    }
  }
  {
  {
#line 306
  gc_kill((struct lsh_object *)res);
  }
  {
#line 307
  gc_kill((struct lsh_object *)res->verifier);
  }
  }
#line 308
  return ((struct signer *)((void *)0));
}
}
#line 311 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c"
struct signature_algorithm rsa_sha1_algorithm  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & make_rsa_signer, & make_rsa_verifier};
#line 314 "/home/ysko/Works/test-src/lsh-2.0.4/src/rsa.c"
struct verifier *make_ssh_rsa_verifier(struct lsh_string  const  *public ) 
{ 
  struct simple_buffer buffer ;
  int atom ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct verifier *tmp___2 ;
  struct verifier *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  {
  {
#line 320
  tmp = lsh_string_data(public);
  }
  {
#line 320
  tmp___0 = lsh_string_length(public);
  }
  {
#line 320
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 322
  tmp___4 = parse_atom(& buffer, & atom);
  }
  }
#line 322
  if (tmp___4) {
#line 322
    if (atom == 37) {
      {
      {
#line 322
      tmp___2 = parse_ssh_rsa_public(& buffer);
      }
#line 322
      tmp___3 = tmp___2;
      }
    } else {
#line 322
      tmp___3 = (struct verifier *)((void *)0);
    }
  } else {
#line 322
    tmp___3 = (struct verifier *)((void *)0);
  }
#line 322
  return (tmp___3);
}
}
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.h.x"
struct lsh_class resource_list_class ;
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.h"
struct resource_list *make_resource_list(void) ;
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.c"
void dont_free_live_resource(int alive ) ;
#line 44
void do_mark_resources(struct resource_node **q , void (*mark)(struct lsh_object *o ) ) ;
#line 47
void do_free_resources(struct resource_node **q ) ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.h.x"
static void do_resource_free(struct lsh_object *o ) 
{ 
  struct resource *i ;

  {
  {
#line 18
  i = (struct resource *)o;
  {
#line 19
  dont_free_live_resource(i->alive);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.h.x"
struct lsh_class resource_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"resource", (size_t )sizeof(struct resource ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_resource_free};
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.h.x"
static void do_resource_list_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct resource_list *i ;

  {
  {
#line 49
  i = (struct resource_list *)o;
  {
#line 50
  do_mark_resources(& i->q, mark);
  }
  }
#line 52
  return;
}
}
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.h.x"
static void do_resource_list_free(struct lsh_object *o ) 
{ 
  struct resource_list *i ;

  {
  {
#line 56
  i = (struct resource_list *)o;
  {
#line 57
  do_free_resources(& i->q);
  }
  }
#line 58
  return;
}
}
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.h.x"
struct lsh_class resource_list_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & resource_class, (char *)"resource_list", (size_t )sizeof(struct resource_list ),
    & do_resource_list_mark, & do_resource_list_free};
#line 56 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.c"
void dont_free_live_resource(int alive ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 59
  if (alive) {
    {
    {
#line 60
    fatal("dont_free_live_resource: garbage collecting a live resource!\n");
    }
    }
  }
#line 62
  return;
}
}
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.c"
static void do_resource_kill(struct resource *self ) 
{ 


  {
#line 68
  self->alive = 0;
#line 68
  return;
}
}
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.c"
void init_resource(struct resource *self , void (*k)(struct resource * ) ) 
{ 


  {
#line 74
  self->alive = 1;
#line 75
  if (k) {
#line 75
    self->kill = k;
  } else {
#line 75
    self->kill = & do_resource_kill;
  }
#line 76
  return;
}
}
#line 89 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.c"
void do_mark_resources(struct resource_node **q , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct resource_node *n ;

  {
  {
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 95
    n = *q;
#line 95
    if (! n) {
#line 95
      goto while_break;
    }
#line 97
    if ((n->resource)->alive) {
      {
      {
#line 99
      (*mark)(& (n->resource)->super);
      }
#line 100
      q = & n->next;
      }
    } else {
      {
#line 104
      *q = n->next;
      {
#line 105
      lsh_space_free((void const   *)n);
      }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 108
  return;
}
}
#line 111 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.c"
void do_free_resources(struct resource_node **q ) 
{ 
  struct resource_node *n ;
  struct resource_node *old ;

  {
#line 116
  n = *q;
  {
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 116
    if (! n) {
#line 116
      goto while_break;
    }
    {
#line 118
    old = n;
#line 119
    n = n->next;
    {
#line 120
    lsh_space_free((void const   *)old);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 122
  return;
}
}
#line 125 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.c"
void remember_resource(struct resource_list *self , struct resource *resource ) 
{ 
  struct resource_node *n ;
  void *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  size_t size13 ;
  void *tmp14 ;
  void *ret_lsh_space_alloc15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 131
  if (! resource) {
    {
    {
#line 131
    __assert_fail("resource", "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.c",
                  131U, "remember_resource");
    }
    }
  }
#line 133
  if (! self->super.alive) {
    {
    {
#line 135
    werror("do_remember_resource: resource list is already dead.\n");
    }
    {
#line 136
    (*(resource->kill))(resource);
    }
    }
#line 137
    return;
  }
  {
  {
#line 140
  size13 = (size_t )sizeof(*n);
  {
  {
  {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
  tmp14 = malloc(size13);
  }
  }
  {
#line 262
  ret_lsh_space_alloc15 = tmp14;
#line 262
  goto Lret_lsh_space_alloc;
  }
  }
  Lret_lsh_space_alloc: /* CIL Label */ 
#line 140 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.c"
  tmp = ret_lsh_space_alloc15;
  }
#line 140
  n = (struct resource_node *)tmp;
#line 142
  n->resource = resource;
#line 143
  n->next = self->q;
#line 144
  self->q = n;
  }
#line 145
  return;
}
}
#line 147 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.c"
static void do_kill_all(struct resource *s ) 
{ 
  struct resource_list *self ;
  struct resource_node *n ;
  struct resource *r ;
  struct resource_node *old ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 150
  self = (struct resource_list *)s;
  {
#line 152
  trace("do_kill_all: resource_list %xi\n", self);
  }
  }
#line 154
  if (self->super.alive) {
#line 158
    self->super.alive = 0;
#line 160
    n = self->q;
    {
    {
#line 160
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 160
      if (! n) {
#line 160
        goto while_break;
      }
      {
#line 162
      r = n->resource;
#line 163
      old = n;
      {
#line 165
      (*(r->kill))(r);
      }
#line 166
      n = n->next;
      {
#line 168
      lsh_space_free((void const   *)old);
      }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 170
    self->q = (struct resource_node *)((void *)0);
  }
#line 172
  return;
}
}
#line 174 "/home/ysko/Works/test-src/lsh-2.0.4/src/resource.c"
struct resource_list *make_resource_list(void) 
{ 
  struct resource_list *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 177
  tmp = lsh_object_alloc(& resource_list_class);
  }
#line 177
  self = (struct resource_list *)tmp;
  {
#line 178
  init_resource(& self->super, & do_kill_all);
  }
  {
#line 180
  trace("make_resource_list: created %xi\n", self);
  }
#line 182
  self->q = (struct resource_node *)((void *)0);
  }
#line 184
  return (self);
}
}
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.h.x"
struct lsh_class reaper_class ;
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.h"
struct reaper *make_reaper(void) ;
#line 75 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.h"
struct alist *make_linked_alist(unsigned int n  , ...) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.h.x"
struct lsh_class exit_callback_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"exit_callback", (size_t )sizeof(struct exit_callback ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.h.x"
static void do_reaper_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct reaper *i ;

  {
  {
#line 43
  i = (struct reaper *)o;
  {
#line 44
  (*mark)((struct lsh_object *)i->children);
  }
  }
#line 45
  return;
}
}
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.h.x"
struct lsh_class reaper_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"reaper", (size_t )sizeof(struct reaper ),
    & do_reaper_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c.x"
struct lsh_class reaper_callback_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c.x"
static void do_reaper_callback_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct reaper_callback *i ;

  {
  {
#line 18
  i = (struct reaper_callback *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->reaper);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c.x"
struct lsh_class reaper_callback_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & lsh_callback_class, (char *)"reaper_callback", (size_t )sizeof(struct reaper_callback ),
    & do_reaper_callback_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c"
static void do_reap(struct reaper *c , pid_t pid , struct exit_callback *callback ) 
{ 
  struct reaper *closure ;

  {
  {
#line 53
  closure = c;
  {
#line 55
  (*(((struct alist_meta *)(closure->children)->super.isa)->set))(closure->children,
                                                                  pid, & callback->super);
  }
  }
#line 56
  return;
}
}
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c"
static void do_reaper_callback(struct lsh_callback *s ) 
{ 
  struct reaper_callback *self ;
  struct reaper *r ;
  pid_t pid ;
  int status ;
  int signaled ;
  int value ;
  int core ;
  struct exit_callback *callback ;
  union __anonunion_59 __constr_expr_0 ;
  union __anonunion_60 __constr_expr_1 ;
  union __anonunion_61 __constr_expr_2 ;
  union __anonunion_62 __constr_expr_3 ;
  int tmp ;
  union __anonunion_63 __constr_expr_4 ;
  union __anonunion_64 __constr_expr_5 ;
  union __anonunion_65 __constr_expr_6 ;
  struct exit_callback *c ;
  struct lsh_object *tmp___0 ;
  union __anonunion_66 __constr_expr_7 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;

  {
#line 69
  self = (struct reaper_callback *)s;
#line 70
  r = self->reaper;
  {
  {
#line 75
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 75
    pid = waitpid(-1, & status, 1);
    }
    }
#line 75
    if (! pid) {
#line 75
      goto while_break;
    }
#line 77
    if (pid > 0) {
#line 84
      __constr_expr_6.__in = status;
#line 84
      if ((__constr_expr_6.__i & 127) == 0) {
        {
#line 86
        __constr_expr_0.__in = status;
        {
#line 86
        verbose("Child %i died with exit code %i.\n", pid, (__constr_expr_0.__i & 65280) >> 8);
        }
#line 88
        signaled = 0;
#line 89
        core = 0;
#line 90
        __constr_expr_1.__in = status;
#line 90
        value = (__constr_expr_1.__i & 65280) >> 8;
        }
      } else {
#line 92
        __constr_expr_5.__in = status;
#line 92
        if ((int )((signed char )((__constr_expr_5.__i & 127) + 1)) >> 1 > 0) {
          {
#line 94
          __constr_expr_2.__in = status;
          {
#line 94
          verbose("Child %i killed by signal %i.\n", pid, __constr_expr_2.__i & 127);
          }
#line 96
          signaled = 1;
#line 98
          __constr_expr_3.__in = status;
          }
#line 98
          if (__constr_expr_3.__i & 128) {
#line 98
            tmp = 1;
          } else {
#line 98
            tmp = 0;
          }
#line 98
          core = tmp;
#line 102
          __constr_expr_4.__in = status;
#line 102
          value = __constr_expr_4.__i & 127;
        } else {
          {
          {
#line 105
          fatal("Child died, but neither WIFEXITED or WIFSIGNALED is true.\n");
          }
          }
        }
      }
      {
      {
#line 108
      tmp___0 = (*(((struct alist_meta *)(r->children)->super.isa)->get))(r->children,
                                                                          pid);
      }
#line 108
      c = (struct exit_callback *)tmp___0;
#line 109
      callback = c;
      }
#line 112
      if (callback) {
        {
        {
#line 114
        (*(((struct alist_meta *)(r->children)->super.isa)->set))(r->children, pid,
                                                                  (struct lsh_object *)((void *)0));
        }
        {
#line 115
        (*(callback->exit))(callback, signaled, core, value);
        }
        }
      } else {
#line 119
        __constr_expr_7.__in = status;
#line 119
        if ((int )((signed char )((__constr_expr_7.__i & 127) + 1)) >> 1 > 0) {
          {
          {
#line 120
          werror("Unregistered child %i killed by signal %i.\n", pid, value);
          }
          }
        } else {
          {
          {
#line 123
          werror("Unregistered child %i died with exit status %i.\n", pid, value);
          }
          }
        }
      }
    } else {
      {
      {
#line 127
      tmp___1 = __errno_location();
      }
      }
#line 129
      if (*tmp___1 == 4) {
#line 129
        goto case_4;
      }
#line 132
      if (*tmp___1 == 10) {
#line 132
        goto case_10;
      }
#line 135
      goto switch_default;
      case_4: 
      {
      {
#line 130
      werror("reaper.c: waitpid returned EINTR.\n");
      }
      }
#line 131
      goto switch_break;
      case_10: 
#line 134
      return;
      switch_default: 
      {
      {
#line 136
      tmp___2 = __errno_location();
      }
      {
#line 136
      fatal("reaper.c: waitpid failed %e\n", *tmp___2);
      }
      }
      switch_break: ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 139
  return;
}
}
#line 141 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c"
static struct lsh_callback *make_reaper_callback(struct reaper *reaper ) 
{ 
  struct reaper_callback *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 144
  tmp = lsh_object_alloc(& reaper_callback_class);
  }
#line 144
  self = (struct reaper_callback *)tmp;
#line 145
  self->super.f = & do_reaper_callback;
#line 146
  self->reaper = reaper;
  }
#line 148
  return (& self->super);
}
}
#line 151 "/home/ysko/Works/test-src/lsh-2.0.4/src/reaper.c"
struct reaper *make_reaper(void) 
{ 
  struct reaper *self ;
  struct lsh_object *tmp ;
  struct lsh_callback *tmp___0 ;

  {
  {
  {
#line 154
  tmp = lsh_object_alloc(& reaper_class);
  }
#line 154
  self = (struct reaper *)tmp;
#line 156
  self->reap = & do_reap;
  {
#line 157
  self->children = make_linked_alist(0U, -1);
  }
  {
#line 159
  tmp___0 = make_reaper_callback(self);
  }
  {
#line 159
  io_signal_handler(17, tmp___0);
  }
  }
#line 161
  return (self);
}
}
#line 33 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.h"
struct read_handler *make_read_packet(struct abstract_write *handler , struct ssh_connection *connection ) ;
#line 224 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
struct exception  const  finish_read_exception ;
#line 95 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
uint32_t lsh_string_sequence_number(struct lsh_string  const  *s ) ;
#line 98
void lsh_string_set_sequence_number(struct lsh_string *s , uint32_t n ) ;
#line 20 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c.x"
struct lsh_class read_packet_class ;
#line 24 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c.x"
static void do_read_packet_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct read_packet *i ;

  {
  {
#line 28
  i = (struct read_packet *)o;
  {
#line 29
  (*mark)((struct lsh_object *)i->handler);
  }
  {
#line 30
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 31
  return;
}
}
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c.x"
static void do_read_packet_free(struct lsh_object *o ) 
{ 
  struct read_packet *i ;

  {
  {
#line 35
  i = (struct read_packet *)o;
  {
#line 36
  lsh_string_free((struct lsh_string  const  *)i->block_buffer);
  }
  {
#line 37
  lsh_string_free((struct lsh_string  const  *)i->mac_buffer);
  }
  {
#line 38
  lsh_string_free((struct lsh_string  const  *)i->mac_computed);
  }
  {
#line 39
  lsh_string_free((struct lsh_string  const  *)i->packet_buffer);
  }
  }
#line 40
  return;
}
}
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c.x"
struct lsh_class read_packet_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & read_handler_class, (char *)"read_packet", (size_t )sizeof(struct read_packet ),
    & do_read_packet_mark, & do_read_packet_free};
#line 170 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c"
static uint32_t do_read_packet(struct read_handler **h___0 , uint32_t available ,
                               uint8_t const   *data ) ;
#line 170 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c"
static struct protocol_exception  const  too_large  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, (uint32_t )4096, "Packet too large"}, (uint32_t )2};
#line 187 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c"
static struct protocol_exception  const  invalid  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, (uint32_t )4096, "Invalid packet length"}, (uint32_t )2};
#line 337 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c"
static struct protocol_exception  const  mac_error  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, (uint32_t )4096, "MAC error"}, (uint32_t )5};
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c"
static uint32_t do_read_packet(struct read_handler **h___0 , uint32_t available ,
                               uint8_t const   *data ) 
{ 
  struct read_packet *closure ;
  uint32_t total ;
  struct exception *tmp ;
  uint32_t block_size ;
  uint32_t tmp___0 ;
  uint32_t left ;
  uint32_t length ;
  uint8_t const   *block ;
  uint8_t pad_length ;
  uint8_t s[4] ;
  struct exception *tmp___1 ;
  unsigned int done ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t length___0 ;
  uint32_t tmp___4 ;
  uint32_t left___0 ;
  uint8_t const   *tmp___5 ;
  uint32_t mac_size ;
  uint32_t left___1 ;
  uint8_t const   *tmp___6 ;
  uint8_t const   *tmp___7 ;
  int tmp___8 ;
  struct lsh_string *packet ;
  uint32_t sequence_number ;
  uint32_t tmp___9 ;
  struct exception *tmp___10 ;
  void *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  void *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;

  {
#line 99
  closure = (struct read_packet *)*h___0;
#line 100
  total = (uint32_t )0;
#line 102
  if (! available) {
    {
    {
#line 104
    debug("read_packet: EOF in state %i\n", closure->state);
    }
    }
#line 106
    if (closure->state != 0) {
      {
      {
#line 107
      tmp = make_protocol_exception((uint32_t )0, "Unexpected EOF");
      }
      {
#line 107
      (*(((closure->connection)->e)->raise))((closure->connection)->e, (struct exception  const  *)tmp);
      }
      }
    } else {
      {
      {
#line 113
      (*(((closure->connection)->e)->raise))((closure->connection)->e, & finish_read_exception);
      }
      }
    }
#line 115
    *h___0 = (struct read_handler *)((void *)0);
#line 116
    return ((uint32_t )0);
  }
  {
  {
#line 119
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 122
    if (closure->state == 0) {
#line 122
      goto case_0;
    }
#line 132
    if (closure->state == 1) {
#line 132
      goto case_1;
    }
#line 264
    if (closure->state == 2) {
#line 264
      goto case_2;
    }
#line 305
    if (closure->state == 3) {
#line 305
      goto case_3;
    }
#line 378
    goto switch_default;
    case_0: 
#line 123
    if (! (! (closure->connection)->rec_crypto)) {
#line 123
      if (! (((closure->connection)->rec_crypto)->block_size <= 16U)) {
        {
        {
#line 123
        __assert_fail("! closure->connection->rec_crypto || closure->connection->rec_crypto->block_size <= 16",
                      "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c", 124U,
                      "do_read_packet");
        }
        }
      }
    }
#line 125
    if (! (! (closure->connection)->rec_mac)) {
#line 125
      if (! (((closure->connection)->rec_mac)->mac_size <= 20U)) {
        {
        {
#line 125
        __assert_fail("! closure->connection->rec_mac || closure->connection->rec_mac->mac_size <= 20",
                      "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c", 126U,
                      "do_read_packet");
        }
        }
      }
    }
#line 128
    closure->state = 1;
#line 129
    closure->pos = (uint32_t )0;
    case_1: 
#line 134
    if ((closure->connection)->rec_crypto) {
#line 134
      tmp___0 = ((closure->connection)->rec_crypto)->block_size;
    } else {
#line 134
      tmp___0 = (uint32_t )8;
    }
#line 134
    block_size = tmp___0;
#line 138
    left = block_size - closure->pos;
#line 139
    if (! left) {
      {
      {
#line 139
      __assert_fail("left", "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c",
                    139U, "do_read_packet");
      }
      }
    }
#line 141
    if (available < left) {
      {
      {
#line 143
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 143
        lsh_string_write(closure->block_buffer, closure->pos, available, data);
        }
#line 143
        closure->pos += available;
#line 143
        data += available;
#line 143
        total += available;
#line 143
        available -= available;
        }
#line 143
        goto while_break___0;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___0: ;
#line 145
      return (total);
    } else {
      {
      {
#line 154
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 154
        lsh_string_write(closure->block_buffer, closure->pos, left, data);
        }
#line 154
        closure->pos += left;
#line 154
        data += left;
#line 154
        total += left;
#line 154
        available -= left;
        }
#line 154
        goto while_break___1;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___1: ;
#line 156
      if ((closure->connection)->rec_crypto) {
        {
        {
#line 157
        (*(((closure->connection)->rec_crypto)->crypt))((closure->connection)->rec_crypto,
                                                        block_size, closure->block_buffer,
                                                        (uint32_t )0, (struct lsh_string  const  *)closure->block_buffer,
                                                        (uint32_t )0);
        }
        }
      }
      {
      {
#line 162
      block = lsh_string_data((struct lsh_string  const  *)closure->block_buffer);
      }
#line 163
      length = ((((uint32_t )*(block + 0) << 24) | ((uint32_t )*(block + 1) << 16)) | ((uint32_t )*(block + 2) << 8)) | (uint32_t )*(block + 3);
      }
#line 168
      if (length > (closure->connection)->rec_max_packet + 2232U) {
        {
        {
#line 174
        werror("read_packet: Receiving too large packet.\n  %i octets, limit is %i\n",
               length, (closure->connection)->rec_max_packet);
        }
        {
#line 178
        (*(((closure->connection)->e)->raise))((closure->connection)->e, & too_large.super);
        }
        }
#line 180
        return (total);
      }
#line 183
      if (length < 12U) {
        {
        {
#line 191
        werror("read_packet: Bad packet length %i\n", length);
        }
        {
#line 193
        (*(((closure->connection)->e)->raise))((closure->connection)->e, & invalid.super);
        }
        }
#line 195
        return (total);
      } else
#line 183
      if (length < block_size - 4U) {
        {
        {
#line 191
        werror("read_packet: Bad packet length %i\n", length);
        }
        {
#line 193
        (*(((closure->connection)->e)->raise))((closure->connection)->e, & invalid.super);
        }
        }
#line 195
        return (total);
      } else
#line 183
      if ((length + 4U) % block_size) {
        {
        {
#line 191
        werror("read_packet: Bad packet length %i\n", length);
        }
        {
#line 193
        (*(((closure->connection)->e)->raise))((closure->connection)->e, & invalid.super);
        }
        }
#line 195
        return (total);
      }
#line 199
      if ((closure->connection)->rec_mac) {
        {
        {
#line 202
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 202
          s[0] = (uint8_t )((closure->sequence_number >> 24) & 255U);
#line 202
          s[1] = (uint8_t )((closure->sequence_number >> 16) & 255U);
#line 202
          s[2] = (uint8_t )((closure->sequence_number >> 8) & 255U);
#line 202
          s[3] = (uint8_t )(closure->sequence_number & 255U);
#line 202
          goto while_break___2;
        }
        while_break___17: /* CIL Label */ ;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___2: 
        {
        {
#line 203
        (*(((closure->connection)->rec_mac)->update))((closure->connection)->rec_mac,
                                                      (uint32_t )4, (uint8_t const   *)(s));
        }
        {
#line 204
        (*(((closure->connection)->rec_mac)->update))((closure->connection)->rec_mac,
                                                      block_size, block);
        }
        }
      }
      {
#line 209
      pad_length = (uint8_t )*(block + 4);
      {
#line 211
      debug("do_read_packet: length = %i, pad_length = %i\n", length, (int )pad_length);
      }
#line 214
      length --;
      }
#line 216
      if ((int )pad_length < 4) {
        {
        {
#line 219
        tmp___1 = make_protocol_exception((uint32_t )2, "Bogus padding length.");
        }
        {
#line 219
        (*(((closure->connection)->e)->raise))((closure->connection)->e, (struct exception  const  *)tmp___1);
        }
        }
#line 221
        return (total);
      } else
#line 216
      if ((uint32_t )pad_length >= length) {
        {
        {
#line 219
        tmp___1 = make_protocol_exception((uint32_t )2, "Bogus padding length.");
        }
        {
#line 219
        (*(((closure->connection)->e)->raise))((closure->connection)->e, (struct exception  const  *)tmp___1);
        }
        }
#line 221
        return (total);
      }
#line 224
      closure->payload_length = length - (uint32_t )pad_length;
#line 228
      done = block_size - 5U;
#line 230
      if (! (! closure->packet_buffer)) {
        {
        {
#line 230
        __assert_fail("!closure->packet_buffer", "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c",
                      230U, "do_read_packet");
        }
        }
      }
      {
      {
#line 232
      closure->packet_buffer = ssh_format("%ls%lr", done, block + 5, length - done,
                                          & closure->crypt_pos);
      }
      {
#line 237
      tmp___2 = lsh_string_length((struct lsh_string  const  *)closure->packet_buffer);
      }
      }
#line 237
      if (! (tmp___2 == length)) {
        {
        {
#line 237
        __assert_fail("lsh_string_length(closure->packet_buffer) == length", "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c",
                      237U, "do_read_packet");
        }
        }
      }
      {
#line 241
      tmp___3 = closure->sequence_number;
#line 241
      (closure->sequence_number) ++;
      {
#line 241
      lsh_string_set_sequence_number(closure->packet_buffer, tmp___3);
      }
#line 243
      closure->pos = done;
      }
#line 245
      if (done == length) {
        {
        {
#line 249
        debug("read_packet.c: Going directly to the WAIT_MAC state\n");
        }
        }
#line 252
        goto do_mac;
      } else {
#line 255
        goto do_contents;
      }
    }
    {
    {
#line 259
    fatal("read_packet: Supposedly not happening???\n");
    }
    }
    do_contents: 
#line 262
    closure->state = 2;
    case_2: 
    {
    {
#line 266
    tmp___4 = lsh_string_length((struct lsh_string  const  *)closure->packet_buffer);
    }
#line 266
    length___0 = tmp___4;
#line 267
    left___0 = length___0 - closure->pos;
    }
#line 269
    if (! left___0) {
      {
      {
#line 269
      __assert_fail("left", "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c",
                    269U, "do_read_packet");
      }
      }
    }
#line 271
    if (available < left___0) {
      {
      {
#line 273
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
        {
        {
#line 273
        lsh_string_write(closure->packet_buffer, closure->pos, available, data);
        }
#line 273
        closure->pos += available;
#line 273
        data += available;
#line 273
        total += available;
#line 273
        available -= available;
        }
#line 273
        goto while_break___3;
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: ;
#line 275
      return (total);
    } else {
      {
      {
#line 280
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
        {
        {
#line 280
        lsh_string_write(closure->packet_buffer, closure->pos, left___0, data);
        }
#line 280
        closure->pos += left___0;
#line 280
        data += left___0;
#line 280
        total += left___0;
#line 280
        available -= left___0;
        }
#line 280
        goto while_break___4;
      }
      while_break___19: /* CIL Label */ ;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: 
#line 282
      left___0 = length___0 - closure->crypt_pos;
#line 284
      if ((closure->connection)->rec_crypto) {
        {
        {
#line 285
        (*(((closure->connection)->rec_crypto)->crypt))((closure->connection)->rec_crypto,
                                                        left___0, closure->packet_buffer,
                                                        closure->crypt_pos, (struct lsh_string  const  *)closure->packet_buffer,
                                                        closure->crypt_pos);
        }
        }
      }
#line 290
      if ((closure->connection)->rec_mac) {
        {
        {
#line 291
        tmp___5 = lsh_string_data((struct lsh_string  const  *)closure->packet_buffer);
        }
        {
#line 291
        (*(((closure->connection)->rec_mac)->update))((closure->connection)->rec_mac,
                                                      left___0, tmp___5 + closure->crypt_pos);
        }
        }
      }
#line 296
      goto do_mac;
    }
    {
    {
#line 299
    fatal("read_packet: Supposedly not happening???\n");
    }
    }
    do_mac: 
#line 302
    closure->state = 3;
#line 303
    closure->pos = (uint32_t )0;
    case_3: 
#line 313
    if ((closure->connection)->rec_mac) {
#line 315
      mac_size = ((closure->connection)->rec_mac)->mac_size;
#line 316
      left___1 = mac_size - closure->pos;
#line 318
      if (! left___1) {
        {
        {
#line 318
        __assert_fail("left", "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c",
                      318U, "do_read_packet");
        }
        }
      }
#line 320
      if (available < left___1) {
        {
        {
#line 322
        while (1) {
          while_continue___13: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
          {
          {
#line 322
          lsh_string_write(closure->mac_buffer, closure->pos, available, data);
          }
#line 322
          closure->pos += available;
#line 322
          data += available;
#line 322
          total += available;
#line 322
          available -= available;
          }
#line 322
          goto while_break___5;
        }
        while_break___20: /* CIL Label */ ;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___5: ;
#line 324
        return (total);
      } else {
        {
        {
#line 329
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___6: /* CIL Label */ ;
          {
          {
#line 329
          lsh_string_write(closure->mac_buffer, closure->pos, left___1, data);
          }
#line 329
          closure->pos += left___1;
#line 329
          data += left___1;
#line 329
          total += left___1;
#line 329
          available -= left___1;
          }
#line 329
          goto while_break___6;
        }
        while_break___21: /* CIL Label */ ;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___6: 
        {
        {
#line 331
        (*(((closure->connection)->rec_mac)->digest))((closure->connection)->rec_mac,
                                                      closure->mac_computed, (uint32_t )0);
        }
        {
#line 333
        tmp___6 = lsh_string_data((struct lsh_string  const  *)closure->mac_computed);
        }
        {
#line 333
        tmp___7 = lsh_string_data((struct lsh_string  const  *)closure->mac_buffer);
        }
        {
#line 333
        tmp___8 = memcmp((void const   *)tmp___7, (void const   *)tmp___6, mac_size);
        }
        }
#line 333
        if (tmp___8) {
          {
          {
#line 340
          (*(((closure->connection)->e)->raise))((closure->connection)->e, & mac_error.super);
          }
          }
#line 341
          return (total);
        }
      }
    }
    {
#line 348
    packet = closure->packet_buffer;
#line 350
    closure->packet_buffer = (struct lsh_string *)((void *)0);
#line 351
    closure->state = 0;
    {
#line 354
    lsh_string_trunc(packet, closure->payload_length);
    }
    }
#line 356
    if ((closure->connection)->rec_compress) {
      {
      {
#line 358
      tmp___9 = lsh_string_sequence_number((struct lsh_string  const  *)packet);
      }
#line 358
      sequence_number = tmp___9;
      {
#line 359
      packet = (*(((closure->connection)->rec_compress)->codec))((closure->connection)->rec_compress,
                                                                 packet, 1);
      }
      }
#line 361
      if (! packet) {
        {
        {
#line 365
        tmp___10 = make_protocol_exception((uint32_t )6, "Inflating compressed data failed.");
        }
        {
#line 365
        (*(((closure->connection)->e)->raise))((closure->connection)->e, (struct exception  const  *)tmp___10);
        }
        }
#line 369
        return (total);
      }
      {
      {
#line 372
      lsh_string_set_sequence_number(packet, sequence_number);
      }
      }
    }
    {
    {
#line 375
    (*((closure->handler)->write))(closure->handler, packet);
    }
    }
#line 376
    return (total);
    switch_default: 
    {
    {
#line 379
    fatal("Internal error\n");
    }
    }

  }
  while_break___14: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 387
  return (0U);
}
}
#line 383 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_packet.c"
struct read_handler *make_read_packet(struct abstract_write *handler , struct ssh_connection *connection ) 
{ 
  struct read_packet *closure ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 387
  tmp = lsh_object_alloc(& read_packet_class);
  }
#line 387
  closure = (struct read_packet *)tmp;
#line 389
  closure->super.handler = & do_read_packet;
#line 391
  closure->connection = connection;
#line 392
  closure->handler = handler;
#line 394
  closure->state = 0;
#line 395
  closure->sequence_number = (uint32_t )0;
  {
#line 397
  closure->block_buffer = lsh_string_alloc((uint32_t )16);
  }
  {
#line 398
  closure->mac_buffer = lsh_string_alloc((uint32_t )20);
  }
  {
#line 399
  closure->mac_computed = lsh_string_alloc((uint32_t )20);
  }
#line 400
  closure->packet_buffer = (struct lsh_string *)((void *)0);
  }
#line 402
  return (& closure->super);
}
}
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_line.h.x"
struct lsh_class line_handler_class ;
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_line.h"
struct read_handler *make_read_line(struct line_handler *handler , struct exception_handler *e ) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_line.h.x"
struct lsh_class line_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"line_handler", (size_t )sizeof(struct line_handler ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 13 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_line.c.x"
struct lsh_class read_line_class ;
#line 17 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_line.c.x"
static void do_read_line_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct read_line *i ;

  {
  {
#line 21
  i = (struct read_line *)o;
  {
#line 22
  (*mark)((struct lsh_object *)i->handler);
  }
  {
#line 23
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 24
  return;
}
}
#line 25 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_line.c.x"
static void do_read_line_free(struct lsh_object *o ) 
{ 
  struct read_line *i ;

  {
  {
#line 28
  i = (struct read_line *)o;
  {
#line 29
  lsh_string_free((struct lsh_string  const  *)i->buffer);
  }
  }
#line 30
  return;
}
}
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_line.c.x"
struct lsh_class read_line_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & read_handler_class, (char *)"read_line", (size_t )sizeof(struct read_line ),
    & do_read_line_mark, & do_read_line_free};
#line 56 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_line.c"
static uint32_t do_read_line(struct read_handler **h___0 , uint32_t available , uint8_t const   *data ) 
{ 
  struct read_line *self ;
  uint8_t *eol ;
  uint32_t consumed ;
  uint32_t tail ;
  uint32_t length ;
  struct exception *tmp ;
  void *tmp___0 ;
  struct exception *tmp___1 ;
  struct exception *tmp___2 ;
  uint8_t const   *tmp___3 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 61
  self = (struct read_line *)*h___0;
#line 68
  if (! available) {
    {
    {
#line 71
    tmp = make_protocol_exception((uint32_t )0, "Unexpected EOF");
    }
    {
#line 71
    (*((self->e)->raise))(self->e, (struct exception  const  *)tmp);
    }
#line 73
    *h___0 = (struct read_handler *)((void *)0);
    }
#line 74
    return ((uint32_t )0);
  }
  {
  {
#line 77
  tmp___0 = memchr((void const   *)data, 10, available);
  }
#line 77
  eol = (uint8_t *)tmp___0;
  }
#line 79
  if (! eol) {
#line 82
    if (available + self->pos >= 255U) {
      {
      {
#line 85
      tmp___1 = make_protocol_exception((uint32_t )0, "Line too long.");
      }
      {
#line 85
      (*((self->e)->raise))(self->e, (struct exception  const  *)tmp___1);
      }
      }
    } else {
      {
      {
#line 90
      lsh_string_write(self->buffer, self->pos, available, data);
      }
#line 91
      self->pos += available;
      }
    }
#line 93
    return (available);
  }
#line 96
  tail = (uint32_t )(eol - (uint8_t *)data);
#line 97
  consumed = tail + 1U;
#line 99
  if (self->pos + consumed > 255U) {
    {
    {
#line 102
    tmp___2 = make_protocol_exception((uint32_t )0, "Line too long.");
    }
    {
#line 102
    (*((self->e)->raise))(self->e, (struct exception  const  *)tmp___2);
    }
    }
#line 104
    return (available);
  }
  {
  {
#line 108
  lsh_string_write(self->buffer, self->pos, tail, data);
  }
#line 109
  length = self->pos + tail;
  }
#line 112
  if (length) {
#line 112
    if ((int const   )*(data + (length - 1U)) == 13) {
#line 113
      length --;
    }
  }
  {
  {
#line 116
  tmp___3 = lsh_string_data((struct lsh_string  const  *)self->buffer);
  }
  {
#line 116
  (*((self->handler)->handler))(& self->handler, h___0, length, tmp___3, self->e);
  }
#line 120
  self->pos = (uint32_t )0;
  }
#line 122
  return (consumed);
}
}
#line 125 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_line.c"
struct read_handler *make_read_line(struct line_handler *handler , struct exception_handler *e ) 
{ 
  struct read_line *closure ;
  struct lsh_object *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 128
  tmp = lsh_object_alloc(& read_line_class);
  }
#line 128
  closure = (struct read_line *)tmp;
  }
#line 129
  if (! e) {
    {
    {
#line 129
    __assert_fail("e", "/home/ysko/Works/test-src/lsh-2.0.4/src/read_line.c", 129U,
                  "make_read_line");
    }
    }
  }
  {
#line 131
  closure->super.handler = & do_read_line;
#line 132
  closure->pos = (uint32_t )0;
  {
#line 134
  closure->buffer = lsh_string_alloc((uint32_t )255);
  }
#line 135
  closure->handler = handler;
#line 136
  closure->e = e;
  }
#line 138
  return (& closure->super);
}
}
#line 12 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_file.c.x"
struct lsh_class read_file_class ;
#line 16 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_file.c.x"
static void do_read_file_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct read_file *i ;

  {
  {
#line 20
  i = (struct read_file *)o;
  {
#line 21
  (*mark)((struct lsh_object *)i->c);
  }
  }
#line 22
  return;
}
}
#line 23 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_file.c.x"
static void do_read_file_free(struct lsh_object *o ) 
{ 
  struct read_file *i ;

  {
  {
#line 26
  i = (struct read_file *)o;
  {
#line 27
  lsh_string_free((struct lsh_string  const  *)i->buffer);
  }
  }
#line 28
  return;
}
}
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_file.c.x"
struct lsh_class read_file_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & read_handler_class, (char *)"read_file", (size_t )sizeof(struct read_file ),
    & do_read_file_mark, & do_read_file_free};
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_file.c"
static uint32_t do_read_file___0(struct read_handler **h___0 , uint32_t available ,
                                 uint8_t const   *data ) 
{ 
  struct read_file *self ;
  uint32_t left ;
  uint32_t tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 57
  self = (struct read_file *)*h___0;
#line 59
  if (! self->buffer) {
    {
    {
#line 62
    werror("do_read_file: buffer == NULL, ignoring extra data.\n");
    }
    }
#line 63
    return (available);
  }
#line 66
  if (! available) {
    {
    {
#line 69
    lsh_string_trunc(self->buffer, self->pos);
    }
    {
#line 71
    (*((self->c)->write))(self->c, self->buffer);
    }
#line 72
    self->buffer = (struct lsh_string *)((void *)0);
#line 74
    *h___0 = (struct read_handler *)((void *)0);
    }
#line 75
    return ((uint32_t )0);
  } else {
    {
    {
#line 79
    tmp = lsh_string_length((struct lsh_string  const  *)self->buffer);
    }
#line 79
    left = tmp - self->pos;
    }
#line 80
    if (available >= left) {
      {
      {
#line 82
      lsh_string_write(self->buffer, self->pos, left, data);
      }
      {
#line 83
      (*((self->c)->write))(self->c, self->buffer);
      }
#line 84
      self->buffer = (struct lsh_string *)((void *)0);
#line 86
      *h___0 = (struct read_handler *)((void *)0);
      }
#line 87
      return (available);
    } else {
      {
      {
#line 91
      lsh_string_write(self->buffer, self->pos, available, data);
      }
#line 92
      self->pos += available;
      }
#line 93
      return (available);
    }
  }
}
}
#line 98 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_file.c"
struct read_handler *make_read_file(struct abstract_write *c , uint32_t max_size ) 
{ 
  struct read_file *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 102
  tmp = lsh_object_alloc(& read_file_class);
  }
#line 102
  self = (struct read_file *)tmp;
  }
#line 103
  if (! max_size) {
    {
    {
#line 103
    __assert_fail("max_size", "/home/ysko/Works/test-src/lsh-2.0.4/src/read_file.c",
                  103U, "make_read_file");
    }
    }
  }
  {
#line 105
  self->super.handler = & do_read_file___0;
#line 106
  self->c = c;
  {
#line 107
  self->buffer = lsh_string_alloc(max_size);
  }
#line 108
  self->pos = (uint32_t )0;
  }
#line 110
  return (& self->super);
}
}
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_data.h"
struct io_callback *make_read_data(struct ssh_channel *channel , struct abstract_write *write___0 ) ;
#line 135 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_class io_consuming_read_class ;
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
void init_consuming_read(struct io_consuming_read *self , struct abstract_write *consumer ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_data.c.x"
struct lsh_class read_data_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_data.c.x"
static void do_read_data_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct read_data *i ;

  {
  {
#line 18
  i = (struct read_data *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->channel);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_data.c.x"
struct lsh_class read_data_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & io_consuming_read_class, (char *)"read_data", (size_t )sizeof(struct read_data ),
    & do_read_data_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_data.c"
static uint32_t do_read_data_query(struct io_consuming_read *s ) 
{ 
  struct read_data *self ;
  uint32_t tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 54
  self = (struct read_data *)s;
#line 56
  if (! (self->channel)->sources) {
    {
    {
#line 56
    __assert_fail("self->channel->sources", "/home/ysko/Works/test-src/lsh-2.0.4/src/read_data.c",
                  56U, "do_read_data_query");
    }
    }
  }
#line 58
  if ((self->channel)->flags & 7) {
    {
    {
#line 61
    werror("read_data: Receiving data on closed channel. Ignoring.\n");
    }
    }
#line 62
    return ((uint32_t )0);
  }
#line 67
  if (((self->channel)->connection)->send_kex_only) {
    {
    {
#line 69
    trace("read_data: Data arrived during key exchange. Won\'t read it now.\n");
    }
    }
#line 71
    return ((uint32_t )0);
  }
#line 74
  if (((self->channel)->connection)->hard_limit) {
    {
    {
#line 76
    trace("read_data: Data arrived, but connection\' write_buffer is full.\n");
    }
    }
#line 78
    return ((uint32_t )0);
  }
#line 95
  if ((self->channel)->send_window_size > (self->channel)->send_max_packet) {
#line 95
    tmp = (self->channel)->send_max_packet;
  } else {
#line 95
    tmp = (self->channel)->send_window_size;
  }
#line 95
  return (tmp);
}
}
#line 99 "/home/ysko/Works/test-src/lsh-2.0.4/src/read_data.c"
struct io_callback *make_read_data(struct ssh_channel *channel , struct abstract_write *write___0 ) 
{ 
  struct read_data *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 103
  tmp = lsh_object_alloc(& read_data_class);
  }
#line 103
  self = (struct read_data *)tmp;
  {
#line 105
  init_consuming_read(& self->super, write___0);
  }
#line 107
  self->super.query = & do_read_data_query;
#line 108
  self->super.consumer = write___0;
#line 110
  self->channel = channel;
#line 112
  (channel->sources) ++;
  }
#line 114
  return (& self->super.super);
}
}
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/randomness.h"
void lsh_random(void *x , unsigned int length , uint8_t *data ) ;
#line 16 "/home/ysko/Works/test-src/lsh-2.0.4/src/randomness.h.x"
struct lsh_class randomness_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"randomness", (size_t )sizeof(struct randomness ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/randomness.c"
void lsh_random(void *x , unsigned int length , uint8_t *data ) 
{ 
  struct randomness *r ;

  {
  {
#line 40
  r = (struct randomness *)x;
  {
#line 41
  (*(r->random))(r, length, data);
  }
  }
#line 42
  return;
}
}
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h"
void lsh_queue_add_head(struct lsh_queue *q , struct lsh_queue_node *n ) ;
#line 67
void lsh_queue_add_tail(struct lsh_queue *q , struct lsh_queue_node *n ) ;
#line 69
struct lsh_queue_node *lsh_queue_remove_head(struct lsh_queue *q ) ;
#line 70
struct lsh_queue_node *lsh_queue_remove_tail(struct lsh_queue *q ) ;
#line 72
struct lsh_queue_node *lsh_queue_peek_head(struct lsh_queue *q ) ;
#line 73
struct lsh_queue_node *lsh_queue_peek_tail(struct lsh_queue *q ) ;
#line 6 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h.x"
void object_queue_mark(struct object_queue *i , void (*mark)(struct lsh_object *o ) ) ;
#line 8
void object_queue_free(struct object_queue *i ) ;
#line 54
void addr_queue_mark(struct addr_queue *i , void (*mark)(struct lsh_object *o ) ) ;
#line 56
void addr_queue_free(struct addr_queue *i ) ;
#line 99 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h"
struct lsh_object *object_queue_remove_head(struct object_queue *q ) ;
#line 100
struct lsh_object *object_queue_remove_tail(struct object_queue *q ) ;
#line 102
struct lsh_object *object_queue_peek_head(struct object_queue *q ) ;
#line 103
struct lsh_object *object_queue_peek_tail(struct object_queue *q ) ;
#line 107
void object_queue_kill(struct object_queue *q ) ;
#line 111
struct object_list *queue_to_list(struct object_queue *q ) ;
#line 112
struct object_list *queue_to_list_and_kill(struct object_queue *q ) ;
#line 147
void string_queue_add_head(struct string_queue *q , struct lsh_string *s ) ;
#line 150
struct lsh_string *string_queue_remove_tail(struct string_queue *q ) ;
#line 152
struct lsh_string *string_queue_peek_head(struct string_queue *q ) ;
#line 153
struct lsh_string *string_queue_peek_tail(struct string_queue *q ) ;
#line 174
struct sockaddr *addr_queue_add_head(struct addr_queue *q , socklen_t size ) ;
#line 177
struct sockaddr *addr_queue_add_tail(struct addr_queue *q , socklen_t size ) ;
#line 180
void addr_queue_remove_head(struct addr_queue *q ) ;
#line 181
void addr_queue_remove_tail(struct addr_queue *q ) ;
#line 183
struct sockaddr *addr_queue_peek_head(struct addr_queue *q , socklen_t *size ) ;
#line 185
struct sockaddr *addr_queue_peek_tail(struct addr_queue *q , socklen_t *size ) ;
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.h.x"
struct lsh_class object_list_class ;
#line 67 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.h"
struct list_header *lsh_list_alloc(struct lsh_class *class , unsigned int length ,
                                   size_t element_size ) ;
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
static void do_object_queue_mark(struct lsh_queue *q , void (*mark)(struct lsh_object *o ) ) ;
#line 39
static void do_object_queue_free(struct lsh_queue *q ) ;
#line 40
static void do_string_queue_free(struct lsh_queue *q ) ;
#line 41
static void do_addr_queue_free(struct lsh_queue *q ) ;
#line 12 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h.x"
void object_queue_mark(struct object_queue *i , void (*mark)(struct lsh_object *o ) ) 
{ 


  {
  {
  {
#line 16
  do_object_queue_mark(& i->q, mark);
  }
  }
#line 18
  return;
}
}
#line 19 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h.x"
void object_queue_free(struct object_queue *i ) 
{ 


  {
  {
  {
#line 22
  do_object_queue_free(& i->q);
  }
  }
#line 23
  return;
}
}
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h.x"
void string_queue_mark(struct string_queue *i , void (*mark)(struct lsh_object *o ) ) 
{ 


  {
#line 41
  return;
}
}
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h.x"
void string_queue_free(struct string_queue *i ) 
{ 


  {
  {
  {
#line 45
  do_string_queue_free(& i->q);
  }
  }
#line 46
  return;
}
}
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h.x"
void addr_queue_mark(struct addr_queue *i , void (*mark)(struct lsh_object *o ) ) 
{ 


  {
#line 64
  return;
}
}
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.h.x"
void addr_queue_free(struct addr_queue *i ) 
{ 


  {
  {
  {
#line 68
  do_addr_queue_free(& i->q);
  }
  }
#line 69
  return;
}
}
#line 105 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
void lsh_queue_init(struct lsh_queue *q ) 
{ 


  {
#line 108
  q->ht_links[0] = (struct lsh_queue_node *)(& q->ht_links[1]);
#line 109
  q->ht_links[1] = (struct lsh_queue_node *)((void *)0);
#line 110
  q->ht_links[2] = (struct lsh_queue_node *)(& q->ht_links[0]);
#line 111
  q->length = 0U;
#line 113
  return;
}
}
#line 115 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
int lsh_queue_is_empty(struct lsh_queue *q ) 
{ 


  {
#line 119
  return (! q->length);
}
}
#line 122 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
void lsh_queue_add_head(struct lsh_queue *q , struct lsh_queue_node *n ) 
{ 


  {
#line 126
  n->np_links[0] = q->ht_links[0];
#line 127
  n->np_links[1] = (struct lsh_queue_node *)(& q->ht_links[0]);
#line 128
  (n->np_links[1])->np_links[0] = n;
#line 129
  (n->np_links[0])->np_links[1] = n;
#line 130
  (q->length) ++;
#line 133
  return;
}
}
#line 135 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
void lsh_queue_add_tail(struct lsh_queue *q , struct lsh_queue_node *n ) 
{ 


  {
#line 139
  n->np_links[0] = (struct lsh_queue_node *)(& q->ht_links[1]);
#line 140
  n->np_links[1] = q->ht_links[2];
#line 141
  (n->np_links[1])->np_links[0] = n;
#line 142
  (n->np_links[0])->np_links[1] = n;
#line 143
  (q->length) ++;
#line 146
  return;
}
}
#line 148 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
void lsh_queue_remove(struct lsh_queue_node *n ) 
{ 
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 151
  if (! n->np_links[0]) {
    {
    {
#line 151
    __assert_fail("n->np_links[0]", "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c",
                  151U, "lsh_queue_remove");
    }
    }
  }
#line 152
  if (! n->np_links[1]) {
    {
    {
#line 152
    __assert_fail("n->np_links[1]", "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c",
                  152U, "lsh_queue_remove");
    }
    }
  }
#line 153
  (n->np_links[0])->np_links[1] = n->np_links[1];
#line 154
  (n->np_links[1])->np_links[0] = n->np_links[0];
#line 155
  return;
}
}
#line 157 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct lsh_queue_node *lsh_queue_remove_head(struct lsh_queue *q ) 
{ 
  struct lsh_queue_node *n ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 160
  n = q->ht_links[0];
#line 163
  if (! (! (! q->length))) {
    {
    {
#line 163
    __assert_fail("!(!(q)->length)", "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c",
                  163U, "lsh_queue_remove_head");
    }
    }
  }
  {
  {
#line 164
  lsh_queue_remove(n);
  }
#line 165
  (q->length) --;
  }
#line 168
  return (n);
}
}
#line 171 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct lsh_queue_node *lsh_queue_remove_tail(struct lsh_queue *q ) 
{ 
  struct lsh_queue_node *n ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 174
  n = q->ht_links[2];
#line 177
  if (! (! (! q->length))) {
    {
    {
#line 177
    __assert_fail("!(!(q)->length)", "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c",
                  177U, "lsh_queue_remove_tail");
    }
    }
  }
  {
  {
#line 178
  lsh_queue_remove(n);
  }
#line 179
  (q->length) --;
  }
#line 182
  return (n);
}
}
#line 185 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct lsh_queue_node *lsh_queue_peek_head(struct lsh_queue *q ) 
{ 
  struct lsh_queue_node *tmp ;

  {
#line 188
  if (! q->length) {
#line 188
    tmp = (struct lsh_queue_node *)((void *)0);
  } else {
#line 188
    tmp = q->ht_links[0];
  }
#line 188
  return (tmp);
}
}
#line 191 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct lsh_queue_node *lsh_queue_peek_tail(struct lsh_queue *q ) 
{ 
  struct lsh_queue_node *tmp ;

  {
#line 194
  if (! q->length) {
#line 194
    tmp = (struct lsh_queue_node *)((void *)0);
  } else {
#line 194
    tmp = q->ht_links[2];
  }
#line 194
  return (tmp);
}
}
#line 199 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
static struct object_queue_node *make_object_queue_node(struct lsh_object *o ) 
{ 
  struct object_queue_node *n ;
  void *tmp ;
  size_t size4 ;
  void *tmp5 ;
  void *ret_lsh_space_alloc6 ;

  {
  {
  {
#line 204
  size4 = (size_t )sizeof(*n);
  {
  {
  {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
  tmp5 = malloc(size4);
  }
  }
  {
#line 262
  ret_lsh_space_alloc6 = tmp5;
#line 262
  goto Lret_lsh_space_alloc;
  }
  }
  Lret_lsh_space_alloc: /* CIL Label */ 
#line 204 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
  tmp = ret_lsh_space_alloc6;
  }
#line 204
  n = (struct object_queue_node *)tmp;
#line 205
  n->o = o;
  }
#line 207
  return (n);
}
}
#line 210 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
void object_queue_add_head(struct object_queue *q , struct lsh_object *o ) 
{ 
  struct object_queue_node *tmp ;

  {
  {
  {
#line 213
  tmp = make_object_queue_node(o);
  }
  {
#line 213
  lsh_queue_add_head(& q->q, & tmp->header);
  }
  }
#line 214
  return;
}
}
#line 216 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
void object_queue_add_tail(struct object_queue *q , struct lsh_object *o ) 
{ 
  struct object_queue_node *tmp ;

  {
  {
  {
#line 219
  tmp = make_object_queue_node(o);
  }
  {
#line 219
  lsh_queue_add_tail(& q->q, & tmp->header);
  }
  }
#line 220
  return;
}
}
#line 222 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
static struct lsh_object *object_queue_get_contents(struct lsh_queue_node *l ) 
{ 
  struct object_queue_node *n ;
  struct lsh_object *res ;

  {
  {
#line 225
  n = (struct object_queue_node *)l;
#line 227
  res = n->o;
  {
#line 228
  lsh_space_free((void const   *)n);
  }
  }
#line 230
  return (res);
}
}
#line 233 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
static struct lsh_object *object_queue_peek(struct lsh_queue_node *n ) 
{ 


  {
#line 236
  return (((struct object_queue_node *)n)->o);
}
}
#line 239 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct lsh_object *object_queue_remove_head(struct object_queue *q ) 
{ 
  struct lsh_queue_node *tmp ;
  struct lsh_object *tmp___0 ;

  {
  {
  {
#line 242
  tmp = lsh_queue_remove_head(& q->q);
  }
  {
#line 242
  tmp___0 = object_queue_get_contents(tmp);
  }
  }
#line 242
  return (tmp___0);
}
}
#line 245 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct lsh_object *object_queue_remove_tail(struct object_queue *q ) 
{ 
  struct lsh_queue_node *tmp ;
  struct lsh_object *tmp___0 ;

  {
  {
  {
#line 248
  tmp = lsh_queue_remove_tail(& q->q);
  }
  {
#line 248
  tmp___0 = object_queue_get_contents(tmp);
  }
  }
#line 248
  return (tmp___0);
}
}
#line 251 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct lsh_object *object_queue_peek_head(struct object_queue *q ) 
{ 
  struct lsh_object *tmp ;
  struct lsh_object *tmp___0 ;

  {
#line 254
  if (! q->q.length) {
#line 254
    tmp___0 = (struct lsh_object *)((void *)0);
  } else {
    {
    {
#line 254
    tmp = object_queue_peek(q->q.ht_links[0]);
    }
#line 254
    tmp___0 = tmp;
    }
  }
#line 254
  return (tmp___0);
}
}
#line 257 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct lsh_object *object_queue_peek_tail(struct object_queue *q ) 
{ 
  struct lsh_object *tmp ;
  struct lsh_object *tmp___0 ;

  {
#line 260
  if (! q->q.length) {
#line 260
    tmp___0 = (struct lsh_object *)((void *)0);
  } else {
    {
    {
#line 260
    tmp = object_queue_peek(q->q.ht_links[2]);
    }
#line 260
    tmp___0 = tmp;
    }
  }
#line 260
  return (tmp___0);
}
}
#line 263 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct object_list *queue_to_list(struct object_queue *q ) 
{ 
  struct object_list *l ;
  struct list_header *tmp ;
  unsigned int i ;
  struct lsh_queue_node *n_this ;
  struct lsh_queue_node *n_next ;
  struct lsh_object *n ;
  unsigned int tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  struct lsh_class *class15 ;
  unsigned int length16 ;
  size_t element_size17 ;
  struct list_header *list18 ;
  struct lsh_object *tmp19 ;
  char *__cil_tmp920 ;
  char *__cil_tmp1021 ;
  char *__cil_tmp1122 ;
  struct list_header *ret_lsh_list_alloc23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
  {
#line 266
  class15 = & object_list_class;
#line 266
  length16 = q->q.length;
#line 266
  element_size17 = (size_t )sizeof(struct lsh_object *);
  {
#line 49
  if (! (element_size17 < 1024U)) {
    {
    {
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c"
    __assert_fail("element_size < 1024", "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c",
                  49U, "lsh_list_alloc");
    }
    }
  }
  {
  {
#line 51
  tmp19 = lsh_var_alloc(class15, (class15->size + element_size17 * length16) - element_size17);
  }
#line 51
  list18 = (struct list_header *)tmp19;
#line 57
  list18->length = length16;
  }
  {
#line 59
  ret_lsh_list_alloc23 = list18;
#line 59
  goto Lret_lsh_list_alloc;
  }
  }
  Lret_lsh_list_alloc: /* CIL Label */ 
#line 266 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
  tmp = ret_lsh_list_alloc23;
  }
#line 266
  l = (struct object_list *)tmp;
#line 267
  i = 0U;
#line 269
  n_this = q->q.ht_links[0];
  }
  {
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 269
    n = ((struct object_queue_node *)n_this)->o;
#line 269
    n_next = n_this->np_links[0];
#line 269
    if (! n_next) {
#line 269
      goto while_break;
    }
#line 271
    tmp___0 = i;
#line 271
    i ++;
#line 271
    l->elements[tmp___0] = n;
#line 269
    n_this = n_next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 273
  if (! (i == q->q.length)) {
    {
    {
#line 273
    __assert_fail("i == q->q.length", "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c",
                  273U, "queue_to_list");
    }
    }
  }
#line 275
  return (l);
}
}
#line 278 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct object_list *queue_to_list_and_kill(struct object_queue *q ) 
{ 
  struct object_list *l ;
  struct object_list *tmp ;

  {
  {
  {
#line 281
  tmp = queue_to_list(q);
  }
#line 281
  l = tmp;
  {
#line 282
  object_queue_kill(q);
  }
  }
#line 284
  return (l);
}
}
#line 288 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
static void do_object_queue_mark(struct lsh_queue *q , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct lsh_queue_node *n_this ;
  struct lsh_queue_node *n_next ;
  struct object_queue_node *n ;

  {
#line 292
  n_this = q->ht_links[0];
  {
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 292
    n = (struct object_queue_node *)n_this;
#line 292
    n_next = n_this->np_links[0];
#line 292
    if (! n_next) {
#line 292
      goto while_break;
    }
    {
    {
#line 293
    (*mark)(n->o);
    }
#line 292
    n_this = n_next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 294
  return;
}
}
#line 296 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
static void do_object_queue_free(struct lsh_queue *q ) 
{ 
  struct lsh_queue_node *n_this ;
  struct lsh_queue_node *n_next ;
  struct object_queue_node *n ;

  {
#line 299
  n_this = q->ht_links[0];
  {
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 299
    n = (struct object_queue_node *)n_this;
#line 299
    n_next = n_this->np_links[0];
#line 299
    if (! n_next) {
#line 299
      goto while_break;
    }
    {
    {
#line 300
    lsh_space_free((void const   *)n);
    }
#line 299
    n_this = n_next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 301
  return;
}
}
#line 303 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
void object_queue_kill(struct object_queue *q ) 
{ 


  {
  {
  {
#line 306
  do_object_queue_free(& q->q);
  }
  }
#line 307
  return;
}
}
#line 312 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
static struct string_queue_node *make_string_queue_node(struct lsh_string *s ) 
{ 
  struct string_queue_node *n ;
  void *tmp ;
  size_t size4 ;
  void *tmp5 ;
  void *ret_lsh_space_alloc6 ;

  {
  {
  {
#line 317
  size4 = (size_t )sizeof(*n);
  {
  {
  {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
  tmp5 = malloc(size4);
  }
  }
  {
#line 262
  ret_lsh_space_alloc6 = tmp5;
#line 262
  goto Lret_lsh_space_alloc;
  }
  }
  Lret_lsh_space_alloc: /* CIL Label */ 
#line 317 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
  tmp = ret_lsh_space_alloc6;
  }
#line 317
  n = (struct string_queue_node *)tmp;
#line 318
  n->s = s;
  }
#line 320
  return (n);
}
}
#line 323 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
void string_queue_add_head(struct string_queue *q , struct lsh_string *s ) 
{ 
  struct string_queue_node *tmp ;

  {
  {
  {
#line 326
  tmp = make_string_queue_node(s);
  }
  {
#line 326
  lsh_queue_add_head(& q->q, & tmp->header);
  }
  }
#line 327
  return;
}
}
#line 329 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
void string_queue_add_tail(struct string_queue *q , struct lsh_string *s ) 
{ 
  struct string_queue_node *tmp ;

  {
  {
  {
#line 332
  tmp = make_string_queue_node(s);
  }
  {
#line 332
  lsh_queue_add_tail(& q->q, & tmp->header);
  }
  }
#line 333
  return;
}
}
#line 335 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
static struct lsh_string *string_queue_get_contents(struct lsh_queue_node *l ) 
{ 
  struct string_queue_node *n ;
  struct lsh_string *res ;

  {
  {
#line 338
  n = (struct string_queue_node *)l;
#line 340
  res = n->s;
  {
#line 341
  lsh_space_free((void const   *)n);
  }
  }
#line 343
  return (res);
}
}
#line 346 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
static struct lsh_string *string_queue_peek(struct lsh_queue_node *n ) 
{ 


  {
#line 349
  return (((struct string_queue_node *)n)->s);
}
}
#line 352 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct lsh_string *string_queue_remove_head(struct string_queue *q ) 
{ 
  struct lsh_queue_node *tmp ;
  struct lsh_string *tmp___0 ;

  {
  {
  {
#line 355
  tmp = lsh_queue_remove_head(& q->q);
  }
  {
#line 355
  tmp___0 = string_queue_get_contents(tmp);
  }
  }
#line 355
  return (tmp___0);
}
}
#line 358 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct lsh_string *string_queue_remove_tail(struct string_queue *q ) 
{ 
  struct lsh_queue_node *tmp ;
  struct lsh_string *tmp___0 ;

  {
  {
  {
#line 361
  tmp = lsh_queue_remove_tail(& q->q);
  }
  {
#line 361
  tmp___0 = string_queue_get_contents(tmp);
  }
  }
#line 361
  return (tmp___0);
}
}
#line 364 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct lsh_string *string_queue_peek_head(struct string_queue *q ) 
{ 
  struct lsh_string *tmp ;
  struct lsh_string *tmp___0 ;

  {
#line 367
  if (! q->q.length) {
#line 367
    tmp___0 = (struct lsh_string *)((void *)0);
  } else {
    {
    {
#line 367
    tmp = string_queue_peek(q->q.ht_links[0]);
    }
#line 367
    tmp___0 = tmp;
    }
  }
#line 367
  return (tmp___0);
}
}
#line 370 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct lsh_string *string_queue_peek_tail(struct string_queue *q ) 
{ 
  struct lsh_string *tmp ;
  struct lsh_string *tmp___0 ;

  {
#line 373
  if (! q->q.length) {
#line 373
    tmp___0 = (struct lsh_string *)((void *)0);
  } else {
    {
    {
#line 373
    tmp = string_queue_peek(q->q.ht_links[2]);
    }
#line 373
    tmp___0 = tmp;
    }
  }
#line 373
  return (tmp___0);
}
}
#line 376 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
static void do_string_queue_free(struct lsh_queue *q ) 
{ 
  struct lsh_queue_node *n_this ;
  struct lsh_queue_node *n_next ;
  struct string_queue_node *n ;

  {
#line 379
  n_this = q->ht_links[0];
  {
  {
#line 379
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 379
    n = (struct string_queue_node *)n_this;
#line 379
    n_next = n_this->np_links[0];
#line 379
    if (! n_next) {
#line 379
      goto while_break;
    }
    {
    {
#line 381
    lsh_string_free((struct lsh_string  const  *)n->s);
    }
    {
#line 382
    lsh_space_free((void const   *)n);
    }
#line 379
    n_this = n_next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 384
  return;
}
}
#line 388 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
static struct addr_queue_node *make_addr_queue_node(socklen_t size ) 
{ 
  struct addr_queue_node *n ;
  void *tmp ;
  size_t size4 ;
  void *tmp5 ;
  void *ret_lsh_space_alloc6 ;

  {
  {
  {
#line 391
  size4 = (size_t )((unsigned long )(& ((struct addr_queue_node *)0)->addr) + (unsigned long )size);
  {
  {
  {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
  tmp5 = malloc(size4);
  }
  }
  {
#line 262
  ret_lsh_space_alloc6 = tmp5;
#line 262
  goto Lret_lsh_space_alloc;
  }
  }
  Lret_lsh_space_alloc: /* CIL Label */ 
#line 391 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
  tmp = ret_lsh_space_alloc6;
  }
#line 391
  n = (struct addr_queue_node *)tmp;
#line 394
  n->size = size;
  }
#line 395
  return (n);
}
}
#line 398 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct sockaddr *addr_queue_add_head(struct addr_queue *q , socklen_t size ) 
{ 
  struct addr_queue_node *n ;
  struct addr_queue_node *tmp ;

  {
  {
  {
#line 401
  tmp = make_addr_queue_node(size);
  }
#line 401
  n = tmp;
  {
#line 402
  lsh_queue_add_head(& q->q, & n->header);
  }
  }
#line 403
  return (& n->addr);
}
}
#line 406 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct sockaddr *addr_queue_add_tail(struct addr_queue *q , socklen_t size ) 
{ 
  struct addr_queue_node *n ;
  struct addr_queue_node *tmp ;

  {
  {
  {
#line 409
  tmp = make_addr_queue_node(size);
  }
#line 409
  n = tmp;
  {
#line 410
  lsh_queue_add_tail(& q->q, & n->header);
  }
  }
#line 411
  return (& n->addr);
}
}
#line 414 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
void addr_queue_remove_head(struct addr_queue *q ) 
{ 
  struct lsh_queue_node *tmp ;

  {
  {
  {
#line 417
  tmp = lsh_queue_remove_head(& q->q);
  }
  {
#line 417
  lsh_space_free((void const   *)tmp);
  }
  }
#line 418
  return;
}
}
#line 420 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
void addr_queue_remove_tail(struct addr_queue *q ) 
{ 
  struct lsh_queue_node *tmp ;

  {
  {
  {
#line 423
  tmp = lsh_queue_remove_tail(& q->q);
  }
  {
#line 423
  lsh_space_free((void const   *)tmp);
  }
  }
#line 424
  return;
}
}
#line 426 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
static struct sockaddr *addr_queue_peek(struct lsh_queue_node *n , socklen_t *size ) 
{ 
  struct addr_queue_node *self ;

  {
#line 429
  self = (struct addr_queue_node *)n;
#line 430
  *size = self->size;
#line 431
  return (& self->addr);
}
}
#line 434 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct sockaddr *addr_queue_peek_head(struct addr_queue *q , socklen_t *size ) 
{ 
  struct sockaddr *tmp ;
  struct sockaddr *tmp___0 ;

  {
#line 437
  if (q->q.length) {
    {
    {
#line 437
    tmp = addr_queue_peek(q->q.ht_links[0], size);
    }
#line 437
    tmp___0 = tmp;
    }
  } else {
#line 437
    tmp___0 = (struct sockaddr *)((void *)0);
  }
#line 437
  return (tmp___0);
}
}
#line 441 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
struct sockaddr *addr_queue_peek_tail(struct addr_queue *q , socklen_t *size ) 
{ 
  struct sockaddr *tmp ;
  struct sockaddr *tmp___0 ;

  {
#line 444
  if (q->q.length) {
    {
    {
#line 444
    tmp = addr_queue_peek(q->q.ht_links[2], size);
    }
#line 444
    tmp___0 = tmp;
    }
  } else {
#line 444
    tmp___0 = (struct sockaddr *)((void *)0);
  }
#line 444
  return (tmp___0);
}
}
#line 448 "/home/ysko/Works/test-src/lsh-2.0.4/src/queue.c"
static void do_addr_queue_free(struct lsh_queue *q ) 
{ 
  struct lsh_queue_node *n_this ;
  struct lsh_queue_node *n_next ;
  struct addr_queue_node *n ;

  {
#line 451
  n_this = q->ht_links[0];
  {
  {
#line 451
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 451
    n = (struct addr_queue_node *)n_this;
#line 451
    n_next = n_this->np_links[0];
#line 451
    if (! n_next) {
#line 451
      goto while_break;
    }
    {
    {
#line 453
    lsh_space_free((void const   *)n);
    }
#line 451
    n_this = n_next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 455
  return;
}
}
#line 816 "/usr/include/gmp-i386.h"
extern void __gmpz_fdiv_q_2exp(mpz_ptr  , mpz_srcptr  , unsigned long  ) ;
#line 922
extern int __gmpz_init_set_str(mpz_ptr  , char const   * , int  ) ;
#line 1032
extern void __gmpz_powm_ui(mpz_ptr  , mpz_srcptr  , unsigned long  , mpz_srcptr  ) ;
#line 12 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
struct lsh_class keypair_class ;
#line 51
struct lsh_class zn_group_class ;
#line 85
struct lsh_class dh_method_class ;
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h"
void zn_invert(struct zn_group  const  *G , __mpz_struct *res , __mpz_struct * const  x ) ;
#line 86
struct zn_group  const  *make_ssh_group1(void) ;
#line 89
struct zn_group  const  *make_ssh_group14(void) ;
#line 16 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
static void do_keypair_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct keypair *i ;

  {
  {
#line 20
  i = (struct keypair *)o;
  {
#line 21
  (*mark)((struct lsh_object *)i->private);
  }
  }
#line 22
  return;
}
}
#line 23 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
static void do_keypair_free(struct lsh_object *o ) 
{ 
  struct keypair *i ;

  {
  {
#line 26
  i = (struct keypair *)o;
  {
#line 27
  lsh_string_free((struct lsh_string  const  *)i->public);
  }
  }
#line 28
  return;
}
}
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
struct lsh_class keypair_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"keypair", (size_t )sizeof(struct keypair ),
    & do_keypair_mark, & do_keypair_free};
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
static void do_zn_group_free(struct lsh_object *o ) 
{ 
  struct zn_group *i ;

  {
  {
#line 58
  i = (struct zn_group *)o;
  {
#line 59
  __gmpz_clear(i->modulo);
  }
  {
#line 60
  __gmpz_clear(i->generator);
  }
  {
#line 61
  __gmpz_clear(i->order);
  }
  }
#line 62
  return;
}
}
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
struct lsh_class zn_group_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"zn_group", (size_t )sizeof(struct zn_group ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_zn_group_free};
#line 89 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
static void do_dh_method_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct dh_method *i ;

  {
  {
#line 93
  i = (struct dh_method *)o;
  {
#line 94
  (*mark)((struct lsh_object *)i->G);
  }
  {
#line 95
  (*mark)((struct lsh_object *)i->H);
  }
  {
#line 96
  (*mark)((struct lsh_object *)i->random);
  }
  }
#line 97
  return;
}
}
#line 98 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
struct lsh_class dh_method_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"dh_method", (size_t )sizeof(struct dh_method ),
    & do_dh_method_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 126 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
void dh_instance_mark(struct dh_instance *i , void (*mark)(struct lsh_object *o ) ) 
{ 


  {
  {
  {
#line 130
  (*mark)((struct lsh_object *)i->method);
  }
  {
#line 131
  (*mark)((struct lsh_object *)i->hash);
  }
  }
#line 132
  return;
}
}
#line 133 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h.x"
void dh_instance_free(struct dh_instance *i ) 
{ 


  {
  {
  {
#line 136
  __gmpz_clear(i->e);
  }
  {
#line 137
  __gmpz_clear(i->f);
  }
  {
#line 138
  __gmpz_clear(i->secret);
  }
  {
#line 139
  lsh_string_free((struct lsh_string  const  *)i->K);
  }
  {
#line 140
  lsh_string_free((struct lsh_string  const  *)i->exchange_hash);
  }
  }
#line 141
  return;
}
}
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.c"
struct keypair *make_keypair(uint32_t type , struct lsh_string *public , struct signer *private ) 
{ 
  struct keypair *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 50
  tmp = lsh_object_alloc(& keypair_class);
  }
#line 50
  self = (struct keypair *)tmp;
#line 52
  self->type = (int )type;
#line 53
  self->public = public;
#line 54
  self->private = private;
  }
#line 55
  return (self);
}
}
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.c"
int zn_range(struct zn_group  const  *G , __mpz_struct * const  x ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 61
  if (x->_mp_size < 0) {
#line 61
    tmp = -1;
  } else {
#line 61
    tmp = x->_mp_size > 0;
  }
#line 61
  if (tmp == 1) {
    {
    {
#line 61
    tmp___0 = __gmpz_cmp((mpz_srcptr )x, (mpz_srcptr )(G->modulo));
    }
    }
#line 61
    if (tmp___0 < 0) {
#line 61
      tmp___1 = 1;
    } else {
#line 61
      tmp___1 = 0;
    }
  } else {
#line 61
    tmp___1 = 0;
  }
#line 61
  return (tmp___1);
}
}
#line 64 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.c"
void zn_invert(struct zn_group  const  *G , __mpz_struct *res , __mpz_struct * const  x ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 67
  tmp = __gmpz_invert(res, (mpz_srcptr )x, (mpz_srcptr )(G->modulo));
  }
  }
#line 67
  if (! tmp) {
    {
    {
#line 68
    fatal("zn_invert: element is non-invertible\n");
    }
    }
  }
#line 71
  if (res->_mp_size < 0) {
#line 71
    tmp___0 = -1;
  } else {
#line 71
    tmp___0 = res->_mp_size > 0;
  }
#line 71
  if (! (tmp___0 > 0)) {
    {
    {
#line 71
    __assert_fail("((res)->_mp_size < 0 ? -1 : (res)->_mp_size > 0) > 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.c",
                  71U, "zn_invert");
    }
    }
  }
#line 72
  return;
}
}
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.c"
void zn_mul(struct zn_group  const  *G , __mpz_struct *res , __mpz_struct * const  a ,
            __mpz_struct * const  b ) 
{ 


  {
  {
  {
#line 77
  __gmpz_mul(res, (mpz_srcptr )a, (mpz_srcptr )b);
  }
  {
#line 78
  __gmpz_fdiv_r(res, (mpz_srcptr )res, (mpz_srcptr )(G->modulo));
  }
  }
#line 79
  return;
}
}
#line 81 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.c"
void zn_exp(struct zn_group  const  *G , __mpz_struct *res , __mpz_struct * const  g ,
            __mpz_struct * const  e ) 
{ 


  {
  {
  {
#line 84
  __gmpz_powm(res, (mpz_srcptr )g, (mpz_srcptr )e, (mpz_srcptr )(G->modulo));
  }
  }
#line 85
  return;
}
}
#line 87 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.c"
void zn_exp_ui(struct zn_group  const  *G , __mpz_struct *res , __mpz_struct * const  g ,
               uint32_t e ) 
{ 


  {
  {
  {
#line 90
  __gmpz_powm_ui(res, (mpz_srcptr )g, (unsigned long )e, (mpz_srcptr )(G->modulo));
  }
  }
#line 91
  return;
}
}
#line 93 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.c"
int zn_add(struct zn_group  const  *G , __mpz_struct *res , __mpz_struct * const  a ,
           __mpz_struct * const  b ) 
{ 
  int tmp ;

  {
  {
  {
#line 97
  __gmpz_add(res, (mpz_srcptr )a, (mpz_srcptr )b);
  }
  {
#line 98
  __gmpz_fdiv_r(res, (mpz_srcptr )res, (mpz_srcptr )(G->modulo));
  }
  }
#line 100
  if (res->_mp_size < 0) {
#line 100
    tmp = -1;
  } else {
#line 100
    tmp = res->_mp_size > 0;
  }
#line 100
  return (tmp);
}
}
#line 103 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.c"
int zn_sub(struct zn_group  const  *G , __mpz_struct *res , __mpz_struct * const  a ,
           __mpz_struct * const  b ) 
{ 
  int tmp ;

  {
  {
  {
#line 107
  __gmpz_sub(res, (mpz_srcptr )a, (mpz_srcptr )b);
  }
  {
#line 108
  __gmpz_fdiv_r(res, (mpz_srcptr )res, (mpz_srcptr )(G->modulo));
  }
  }
#line 110
  if (res->_mp_size < 0) {
#line 110
    tmp = -1;
  } else {
#line 110
    tmp = res->_mp_size > 0;
  }
#line 110
  return (tmp);
}
}
#line 113 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.c"
static struct zn_group *make_ssh_group(char const   *prime , unsigned int g , int primitive ) 
{ 
  struct zn_group *G ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 116
  tmp = lsh_object_alloc(& zn_group_class);
  }
#line 116
  G = (struct zn_group *)tmp;
  {
#line 121
  __gmpz_init_set_str(G->modulo, prime, 16);
  }
  {
#line 123
  __gmpz_init_set_ui(G->generator, (unsigned long )g);
  }
  {
#line 124
  __gmpz_init(G->order);
  }
  {
#line 125
  __gmpz_sub_ui(G->order, (mpz_srcptr )(G->modulo), 1UL);
  }
  }
#line 127
  if (! primitive) {
    {
    {
#line 128
    __gmpz_fdiv_q_2exp(G->order, (mpz_srcptr )(G->order), 1UL);
    }
    }
  }
#line 130
  return (G);
}
}
#line 135 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.c"
struct zn_group  const  *make_ssh_group1(void) 
{ 
  struct zn_group *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 139
  tmp = make_ssh_group("FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF",
                       2U, 0);
  }
  }
#line 139
  return ((struct zn_group  const  *)tmp);
}
}
#line 149 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.c"
struct zn_group  const  *make_ssh_group14(void) 
{ 
  struct zn_group *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 153
  tmp = make_ssh_group("FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF",
                       2U, 0);
  }
  }
#line 153
  return ((struct zn_group  const  *)tmp);
}
}
#line 166 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.c"
struct zn_group  const  *make_ssh_ring_srp_1(void) 
{ 
  struct zn_group *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 171
  tmp = make_ssh_group("FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF",
                       5U, 1);
  }
  }
#line 171
  return ((struct zn_group  const  *)tmp);
}
}
#line 115 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
void lsh_string_write_xor(struct lsh_string *s , uint32_t start , uint32_t length ,
                          uint8_t const   *data ) ;
#line 75 "/home/ysko/Works/test-src/lsh-2.0.4/src/pkcs5.c"
struct lsh_string *pkcs5_derive_key(struct mac_algorithm *prf , struct lsh_string  const  *password ,
                                    struct lsh_string  const  *salt , uint32_t iterations ,
                                    uint32_t key_length ) 
{ 
  struct mac_instance *m ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct mac_instance *tmp___1 ;
  struct lsh_string *key ;
  struct lsh_string *tmp___2 ;
  uint32_t left ;
  uint32_t pos ;
  uint8_t block_count[4] ;
  struct lsh_string *digest ;
  struct lsh_string *tmp___3 ;
  struct lsh_string *buffer ;
  struct lsh_string *tmp___4 ;
  uint32_t i ;
  uint8_t const   *tmp___5 ;
  uint32_t tmp___6 ;
  uint8_t const   *tmp___7 ;
  uint8_t const   *tmp___8 ;
  uint32_t tmp___9 ;
  uint8_t const   *tmp___10 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  void *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
  {
  {
#line 82
  tmp = lsh_string_data(password);
  }
  {
#line 82
  tmp___0 = lsh_string_length(password);
  }
  {
#line 82
  tmp___1 = (*(prf->make_mac))(prf, tmp___0, tmp);
  }
#line 82
  m = tmp___1;
  {
#line 85
  tmp___2 = lsh_string_alloc(key_length);
  }
#line 85
  key = tmp___2;
#line 86
  left = key_length;
#line 87
  pos = (uint32_t )0;
#line 93
  block_count[0] = (uint8_t )0;
#line 93
  block_count[1] = (uint8_t )0;
#line 93
  block_count[2] = (uint8_t )0;
#line 93
  block_count[3] = (uint8_t )1;
  {
#line 95
  tmp___3 = lsh_string_alloc(prf->mac_size);
  }
#line 95
  digest = tmp___3;
  {
#line 96
  tmp___4 = lsh_string_alloc(prf->mac_size);
  }
#line 96
  buffer = tmp___4;
  }
#line 98
  if (! iterations) {
    {
    {
#line 98
    __assert_fail("iterations", "/home/ysko/Works/test-src/lsh-2.0.4/src/pkcs5.c",
                  98U, "pkcs5_derive_key");
    }
    }
  }
#line 99
  if (! (key_length <= 255U * prf->mac_size)) {
    {
    {
#line 99
    __assert_fail("key_length <= 255 * prf->mac_size", "/home/ysko/Works/test-src/lsh-2.0.4/src/pkcs5.c",
                  99U, "pkcs5_derive_key");
    }
    }
  }
  {
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 104
    if (! block_count[3]) {
      {
      {
#line 104
      __assert_fail("block_count[3]", "/home/ysko/Works/test-src/lsh-2.0.4/src/pkcs5.c",
                    104U, "pkcs5_derive_key");
      }
      }
    }
    {
    {
#line 107
    tmp___5 = lsh_string_data(salt);
    }
    {
#line 107
    tmp___6 = lsh_string_length(salt);
    }
    {
#line 107
    (*(m->update))(m, tmp___6, tmp___5);
    }
    {
#line 108
    (*(m->update))(m, (uint32_t )4, (uint8_t const   *)(block_count));
    }
    {
#line 109
    (*(m->digest))(m, buffer, (uint32_t )0);
    }
#line 111
    i = (uint32_t )1;
    }
    {
    {
#line 111
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 111
      if (! (i < iterations)) {
#line 111
        goto while_break___0;
      }
      {
      {
#line 113
      tmp___7 = lsh_string_data((struct lsh_string  const  *)buffer);
      }
      {
#line 113
      (*(m->update))(m, prf->mac_size, tmp___7);
      }
      {
#line 114
      (*(m->digest))(m, digest, (uint32_t )0);
      }
      {
#line 115
      tmp___8 = lsh_string_data((struct lsh_string  const  *)digest);
      }
      {
#line 115
      tmp___9 = lsh_string_length((struct lsh_string  const  *)digest);
      }
      {
#line 115
      lsh_string_write_xor(buffer, (uint32_t )0, tmp___9, tmp___8);
      }
#line 111
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 118
    if (! (pos + left == key_length)) {
      {
      {
#line 118
      __assert_fail("pos + left == key_length", "/home/ysko/Works/test-src/lsh-2.0.4/src/pkcs5.c",
                    118U, "pkcs5_derive_key");
      }
      }
    }
#line 120
    if (left <= prf->mac_size) {
      {
      {
#line 122
      tmp___10 = lsh_string_data((struct lsh_string  const  *)buffer);
      }
      {
#line 122
      lsh_string_write(key, pos, left, tmp___10);
      }
      }
#line 123
      goto while_break;
    } else {
      {
      {
#line 127
      lsh_string_write_string(key, pos, (struct lsh_string  const  *)buffer);
      }
#line 128
      pos += prf->mac_size;
#line 129
      left -= prf->mac_size;
      }
    }
#line 101
    block_count[3] = (uint8_t )((int )block_count[3] + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 132
  gc_kill((struct lsh_object *)m);
  }
  {
#line 133
  lsh_string_free((struct lsh_string  const  *)digest);
  }
  {
#line 134
  lsh_string_free((struct lsh_string  const  *)buffer);
  }
  }
#line 136
  return (key);
}
}
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.h"
struct config_group *config_parse_string(uint32_t length , uint8_t const   *data ) ;
#line 44
int config_lookup_host(struct config_group  const  *groups , char const   *host ,
                       struct config_match *match ) ;
#line 49
struct lsh_string  const  *config_get_setting(enum config_type type , struct config_match  const  *match ) ;
#line 12 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c.x"
struct lsh_class config_setting_class ;
#line 16 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c.x"
static void do_config_setting_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct config_setting *i ;

  {
  {
#line 20
  i = (struct config_setting *)o;
  {
#line 21
  (*mark)((struct lsh_object *)i->next);
  }
  }
#line 22
  return;
}
}
#line 23 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c.x"
static void do_config_setting_free(struct lsh_object *o ) 
{ 
  struct config_setting *i ;

  {
  {
#line 26
  i = (struct config_setting *)o;
  {
#line 27
  lsh_string_free((struct lsh_string  const  *)i->value);
  }
  }
#line 28
  return;
}
}
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c.x"
struct lsh_class config_setting_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"config_setting", (size_t )sizeof(struct config_setting ),
    & do_config_setting_mark, & do_config_setting_free};
#line 51
struct lsh_class config_host_class ;
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c.x"
static void do_config_host_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct config_host *i ;

  {
  {
#line 59
  i = (struct config_host *)o;
  {
#line 60
  (*mark)((struct lsh_object *)i->next);
  }
  {
#line 61
  (*mark)((struct lsh_object *)i->settings);
  }
  }
#line 62
  return;
}
}
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c.x"
static void do_config_host_free(struct lsh_object *o ) 
{ 
  struct config_host *i ;

  {
  {
#line 66
  i = (struct config_host *)o;
  {
#line 67
  lsh_string_free((struct lsh_string  const  *)i->name);
  }
  }
#line 68
  return;
}
}
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c.x"
struct lsh_class config_host_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"config_host", (size_t )sizeof(struct config_host ),
    & do_config_host_mark, & do_config_host_free};
#line 92
struct lsh_class config_group_class ;
#line 96 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c.x"
static void do_config_group_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct config_group *i ;

  {
  {
#line 100
  i = (struct config_group *)o;
  {
#line 101
  (*mark)((struct lsh_object *)i->next);
  }
  {
#line 102
  (*mark)((struct lsh_object *)i->settings);
  }
  {
#line 103
  (*mark)((struct lsh_object *)i->hosts);
  }
  }
#line 104
  return;
}
}
#line 105 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c.x"
static void do_config_group_free(struct lsh_object *o ) 
{ 
  struct config_group *i ;

  {
  {
#line 108
  i = (struct config_group *)o;
  {
#line 109
  lsh_string_free((struct lsh_string  const  *)i->name);
  }
  }
#line 110
  return;
}
}
#line 111 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c.x"
struct lsh_class config_group_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"config_group", (size_t )sizeof(struct config_group ),
    & do_config_group_mark, & do_config_group_free};
#line 96 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
static void tokenizer_init(struct tokenizer *self , unsigned int length , unsigned char const   *data ) 
{ 


  {
  {
  {
#line 100
  simple_buffer_init(& self->buffer, length, data);
  }
#line 101
  self->lineno = 1U;
  }
#line 102
  return;
}
}
#line 107
static enum token_type next_token(struct tokenizer *self ) ;
#line 107 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
static char const   char_class[256]  = 
#line 107
  {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )1,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )2, 
        (char const   )0,      (char const   )2,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0};
#line 104 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
static enum token_type next_token(struct tokenizer *self ) 
{ 
  unsigned int i ;

  {
  {
  {
#line 124
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

    {
    {
#line 126
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 126
      if (self->buffer.capacity - self->buffer.pos) {
#line 126
        if (! ((int const   )char_class[*(self->buffer.data + self->buffer.pos)] & 1)) {
#line 126
          goto while_break___0;
        }
      } else {
#line 126
        goto while_break___0;
      }
#line 128
      if ((int const   )*(self->buffer.data + self->buffer.pos) == 10) {
#line 129
        (self->lineno) ++;
      }
#line 130
      (self->buffer.pos) ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
#line 133
    if (! (self->buffer.capacity - self->buffer.pos)) {
#line 134
      self->type = (enum token_type )0;
    } else {
#line 137
      if ((int const   )*(self->buffer.data + self->buffer.pos) == 123) {
#line 137
        goto case_123;
      }
#line 141
      if ((int const   )*(self->buffer.data + self->buffer.pos) == 125) {
#line 141
        goto case_125;
      }
#line 145
      if ((int const   )*(self->buffer.data + self->buffer.pos) == 35) {
#line 145
        goto case_35;
      }
#line 151
      goto switch_default;
      case_123: 
#line 138
      self->type = (enum token_type )1;
#line 139
      (self->buffer.pos) ++;
#line 140
      goto switch_break;
      case_125: 
#line 142
      self->type = (enum token_type )2;
#line 143
      (self->buffer.pos) ++;
#line 144
      goto switch_break;
      case_35: 
      {
      {
#line 147
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;

#line 147
        if (self->buffer.capacity - self->buffer.pos) {
#line 147
          if (! ((int const   )*(self->buffer.data + self->buffer.pos) != 10)) {
#line 147
            goto while_break___1;
          }
        } else {
#line 147
          goto while_break___1;
        }
#line 148
        (self->buffer.pos) ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
#line 149
      goto __Cont;
      switch_default: 
#line 154
      self->type = (enum token_type )3;
#line 156
      self->token = (char const   *)(self->buffer.data + self->buffer.pos);
#line 158
      i = 0U;
      {
      {
#line 158
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;

#line 158
        if (i < self->buffer.capacity - self->buffer.pos) {
#line 158
          if (! (! ((int const   )char_class[*((self->buffer.data + self->buffer.pos) + i)] & 3))) {
#line 158
            goto while_break___2;
          }
        } else {
#line 158
          goto while_break___2;
        }
#line 158
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___2: 
#line 160
      self->token_length = i;
#line 161
      self->buffer.pos += i;
      switch_break: ;
    }
#line 166
    return (self->type);
    __Cont: ;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 172
  return ((enum token_type )0);
}
}
#line 171 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
static void parse_error(struct tokenizer *self , char const   *msg ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 174
  werror("Parse error: %z, config file:%i\n", msg, self->lineno);
  }
  }
#line 176
  return;
}
}
#line 181 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
static int looking_at(struct tokenizer *self , char const   *word ) 
{ 
  unsigned int length ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  {
#line 184
  tmp = strlen(word);
  }
#line 184
  length = tmp;
  }
#line 186
  if (length == self->token_length) {
    {
    {
#line 186
    tmp___0 = memcmp((void const   *)self->token, (void const   *)word, length);
    }
    }
#line 186
    if (tmp___0) {
#line 193
      return (0);
    } else {
      {
      {
#line 189
      next_token(self);
      }
      }
#line 190
      return (1);
    }
  } else {
#line 193
    return (0);
  }
}
}
#line 196 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
static struct lsh_string *parse_word(struct tokenizer *self ) 
{ 
  struct lsh_string *s ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 200
  if ((unsigned int )self->type != 3U) {
    {
    {
#line 201
    parse_error(self, "expected word");
    }
    }
#line 201
    return ((struct lsh_string *)((void *)0));
  }
  {
  {
#line 203
  s = ssh_format("%ls", self->token_length, self->token);
  }
  {
#line 204
  next_token(self);
  }
  }
#line 205
  return (s);
}
}
#line 208 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
static int parse_setting(struct tokenizer *self , struct config_setting **settings ) 
{ 
  struct lsh_string *s ;
  enum config_type type ;
  int tmp ;
  int tmp___0 ;
  struct config_setting *n ;
  struct lsh_object *tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 214
  if ((unsigned int )self->type != 3U) {
    {
    {
#line 215
    parse_error(self, "syntax error");
    }
    }
#line 215
    return (0);
  }
  {
  {
#line 217
  tmp___0 = looking_at(self, "address");
  }
  }
#line 217
  if (tmp___0) {
#line 218
    type = (enum config_type )0;
  } else {
    {
    {
#line 219
    tmp = looking_at(self, "user");
    }
    }
#line 219
    if (tmp) {
#line 220
      type = (enum config_type )1;
    } else {
      {
      {
#line 223
      werror("Unknown keyword `%s\'\n", self->token_length, self->token);
      }
      {
#line 224
      next_token(self);
      }
      }
#line 226
      if ((unsigned int )self->type == 3U) {
        {
        {
#line 227
        next_token(self);
        }
        }
      }
#line 229
      return (1);
    }
  }
  {
  {
#line 232
  s = parse_word(self);
  }
  }
#line 233
  if (! s) {
#line 234
    return (0);
  }
  {
  {
#line 238
  tmp___1 = lsh_object_alloc(& config_setting_class);
  }
#line 238
  n = (struct config_setting *)tmp___1;
#line 239
  n->next = *settings;
#line 240
  *settings = n;
#line 242
  n->type = type;
#line 243
  n->value = s;
  }
#line 245
  return (1);
}
}
#line 249 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
static struct config_setting *parse_host_settings(struct tokenizer *self ) 
{ 
  struct config_setting *settings ;
  int tmp ;

  {
#line 252
  settings = (struct config_setting *)((void *)0);
  {
  {
#line 254
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 254
    if (! ((unsigned int )self->type == 3U)) {
#line 254
      goto while_break;
    }
    {
    {
#line 256
    tmp = parse_setting(self, & settings);
    }
    }
#line 256
    if (! tmp) {
#line 257
      return ((struct config_setting *)((void *)0));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 259
  return (settings);
}
}
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
static int parse_token(struct tokenizer *self , enum token_type type ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 265
  if ((unsigned int )self->type == (unsigned int )type) {
    {
    {
#line 267
    next_token(self);
    }
    }
#line 268
    return (1);
  } else {
    {
    {
#line 271
    parse_error(self, "syntax error");
    }
    }
#line 271
    return (0);
  }
}
}
#line 274 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
static int parse_hosts(struct tokenizer *self , struct config_host **hosts ) 
{ 
  struct config_host *n ;
  struct lsh_object *tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 277
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 277
    if (! ((unsigned int )self->type == 3U)) {
#line 277
      goto while_break;
    }
    {
    {
#line 281
    tmp = lsh_object_alloc(& config_host_class);
    }
#line 281
    n = (struct config_host *)tmp;
#line 282
    n->next = *hosts;
#line 283
    *hosts = n;
    {
#line 285
    n->name = parse_word(self);
    }
    }
#line 286
    if (! n->name) {
      {
      {
#line 286
      __assert_fail("n->name", "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c",
                    286U, "parse_hosts");
      }
      }
    }
#line 287
    if ((unsigned int )self->type == 1U) {
      {
      {
#line 289
      next_token(self);
      }
      {
#line 290
      n->settings = parse_host_settings(self);
      }
      {
#line 291
      tmp___0 = parse_token(self, (enum token_type )2);
      }
      }
#line 291
      if (! tmp___0) {
#line 292
        return (0);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 296
  return (1);
}
}
#line 299 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
static struct config_group *parse_groups(struct tokenizer *self ) 
{ 
  struct config_group *groups ;
  struct config_group *n ;
  struct lsh_object *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 302
  groups = (struct config_group *)((void *)0);
  {
  {
#line 303
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 303
    if (! ((unsigned int )self->type != 0U)) {
#line 303
      goto while_break;
    }
    {
    {
#line 307
    tmp = lsh_object_alloc(& config_group_class);
    }
#line 307
    n = (struct config_group *)tmp;
#line 308
    n->next = groups;
#line 309
    groups = n;
    }
#line 312
    if ((unsigned int )self->type == 3U) {
      {
      {
#line 313
      groups->name = parse_word(self);
      }
      }
    } else {
#line 315
      groups->name = (struct lsh_string *)((void *)0);
    }
    {
#line 316
    groups->settings = (struct config_setting *)((void *)0);
#line 317
    groups->hosts = (struct config_host *)((void *)0);
    {
#line 319
    tmp___0 = parse_token(self, (enum token_type )1);
    }
    }
#line 319
    if (! tmp___0) {
#line 320
      return ((struct config_group *)((void *)0));
    }
    {
    {
#line 322
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 322
      if (! ((unsigned int )self->type != 2U)) {
#line 322
        goto while_break___0;
      }
      {
      {
#line 324
      tmp___5 = looking_at(self, "hosts");
      }
      }
#line 324
      if (tmp___5) {
        {
        {
#line 326
        tmp___1 = parse_token(self, (enum token_type )1);
        }
        }
#line 326
        if (! tmp___1) {
#line 327
          return ((struct config_group *)((void *)0));
        }
        {
        {
#line 329
        tmp___2 = parse_hosts(self, & groups->hosts);
        }
        }
#line 329
        if (! tmp___2) {
#line 330
          return ((struct config_group *)((void *)0));
        }
        {
        {
#line 331
        tmp___3 = parse_token(self, (enum token_type )2);
        }
        }
#line 331
        if (! tmp___3) {
#line 332
          return ((struct config_group *)((void *)0));
        }
      } else {
        {
        {
#line 336
        tmp___4 = parse_setting(self, & groups->settings);
        }
        }
#line 336
        if (! tmp___4) {
#line 337
          return ((struct config_group *)((void *)0));
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
    {
#line 340
    tmp___6 = parse_token(self, (enum token_type )2);
    }
    }
#line 340
    if (! tmp___6) {
#line 341
      return ((struct config_group *)((void *)0));
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 343
  return (groups);
}
}
#line 346 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
struct config_group *config_parse_string(uint32_t length , uint8_t const   *data ) 
{ 
  struct tokenizer t ;
  struct config_group *tmp ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
  {
#line 350
  tokenizer_init(& t, length, data);
  }
  {
#line 351
  next_token(& t);
  }
  {
#line 353
  tmp = parse_groups(& t);
  }
  }
#line 353
  return (tmp);
}
}
#line 356 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
int config_lookup_host(struct config_group  const  *groups , char const   *host ,
                       struct config_match *match ) 
{ 
  unsigned int length ;
  size_t tmp ;
  int found ;
  struct config_host  const  *hosts ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 361
  tmp = strlen(host);
  }
#line 361
  length = tmp;
#line 362
  found = 0;
  }
  {
  {
#line 364
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 364
    if (! groups) {
#line 364
      goto while_break;
    }
#line 367
    hosts = (struct config_host  const  *)groups->hosts;
    {
    {
#line 367
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 367
      if (! hosts) {
#line 367
        goto while_break___0;
      }
      {
      {
#line 368
      tmp___0 = lsh_string_eq_l((struct lsh_string  const  *)hosts->name, length,
                                (uint8_t const   *)host);
      }
      }
#line 368
      if (tmp___0) {
#line 370
        if (found) {
          {
          {
#line 372
          werror("Ambigous host name `%z\' in configuration.\n");
          }
          }
#line 373
          return (1);
        } else {
#line 377
          found = 1;
#line 378
          match->group = (struct config_setting  const  *)groups->settings;
#line 379
          match->host = (struct config_setting  const  *)hosts->settings;
        }
      }
#line 367
      hosts = (struct config_host  const  *)hosts->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 364
    groups = (struct config_group  const  *)groups->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 383
  return (found);
}
}
#line 386 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse_config.c"
struct lsh_string  const  *config_get_setting(enum config_type type , struct config_match  const  *match ) 
{ 
  struct config_setting  const  *p ;

  {
#line 392
  p = (struct config_setting  const  *)match->host;
  {
  {
#line 392
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 392
    if (! p) {
#line 392
      goto while_break;
    }
#line 393
    if ((unsigned int const   )p->type == (unsigned int const   )type) {
#line 394
      return ((struct lsh_string  const  *)p->value);
    }
#line 392
    p = (struct config_setting  const  *)p->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 396
  p = (struct config_setting  const  *)match->group;
  {
  {
#line 396
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 396
    if (! p) {
#line 396
      goto while_break___0;
    }
#line 397
    if ((unsigned int const   )p->type == (unsigned int const   )type) {
#line 398
      return ((struct lsh_string  const  *)p->value);
    }
#line 396
    p = (struct config_setting  const  *)p->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 400
  return ((struct lsh_string  const  *)((void *)0));
}
}
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.h"
int parse_octets(struct simple_buffer *buffer , uint32_t length , uint8_t *start ) ;
#line 66
int parse_sub_buffer(struct simple_buffer *buffer , struct simple_buffer *subbuffer ) ;
#line 74
int parse_utf8(struct simple_buffer *buffer , uint32_t *result , unsigned int *utf8_length ) ;
#line 88
struct int_list *parse_atoms(struct simple_buffer *buffer , unsigned int limit ) ;
#line 93
struct int_list *parse_atom_list(struct simple_buffer *buffer , unsigned int limit ) ;
#line 96
int parse_uint16(struct simple_buffer *buffer , uint32_t *result ) ;
#line 99
int parse_string16(struct simple_buffer *buffer , uint32_t *length , uint8_t const   **start ) ;
#line 103
void parse_rest(struct simple_buffer *buffer , uint32_t *length , uint8_t const   **start ) ;
#line 108
struct lsh_string *parse_rest_copy(struct simple_buffer *buffer ) ;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.h.x"
struct lsh_class int_list_class ;
#line 75 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.h"
struct int_list *make_int_list(unsigned int n  , ...) ;
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
void simple_buffer_init(struct simple_buffer *buffer , uint32_t capacity , uint8_t const   *data ) 
{ 


  {
#line 47
  buffer->capacity = capacity;
#line 48
  buffer->pos = (uint32_t )0;
#line 49
  buffer->data = data;
#line 50
  return;
}
}
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
int parse_uint32(struct simple_buffer *buffer , uint32_t *result ) 
{ 


  {
#line 55
  if (buffer->capacity - buffer->pos < 4U) {
#line 56
    return (0);
  }
#line 58
  *result = ((((uint32_t )*((buffer->data + buffer->pos) + 0) << 24) | ((uint32_t )*((buffer->data + buffer->pos) + 1) << 16)) | ((uint32_t )*((buffer->data + buffer->pos) + 2) << 8)) | (uint32_t )*((buffer->data + buffer->pos) + 3);
#line 59
  buffer->pos += 4U;
#line 60
  return (1);
}
}
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
int parse_string(struct simple_buffer *buffer , uint32_t *length , uint8_t const   **start ) 
{ 
  uint32_t l ;
  int tmp ;

  {
  {
  {
#line 69
  tmp = parse_uint32(buffer, & l);
  }
  }
#line 69
  if (! tmp) {
#line 70
    return (0);
  }
#line 72
  if (buffer->capacity - buffer->pos < l) {
#line 73
    return (0);
  }
#line 75
  *length = l;
#line 76
  *start = buffer->data + buffer->pos;
#line 77
  buffer->pos += l;
#line 78
  return (1);
}
}
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
int parse_octets(struct simple_buffer *buffer , uint32_t length , uint8_t *start ) 
{ 


  {
#line 86
  if (buffer->capacity - buffer->pos < length) {
#line 87
    return (0);
  }
  {
  {
#line 88
  memcpy((void */* __restrict  */)((void *)start), (void const   */* __restrict  */)((void const   *)(buffer->data + buffer->pos)),
         length);
  }
#line 89
  buffer->pos += length;
  }
#line 90
  return (1);
}
}
#line 93 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
struct lsh_string *parse_string_copy(struct simple_buffer *buffer ) 
{ 
  uint32_t length ;
  uint8_t const   *start ;
  int tmp ;
  struct lsh_string *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 99
  tmp = parse_string(buffer, & length, & start);
  }
  }
#line 99
  if (! tmp) {
#line 100
    return ((struct lsh_string *)((void *)0));
  }
  {
  {
#line 102
  tmp___0 = ssh_format("%ls", length, start);
  }
  }
#line 102
  return (tmp___0);
}
}
#line 106 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
int parse_sub_buffer(struct simple_buffer *buffer , struct simple_buffer *subbuffer ) 
{ 
  uint32_t length ;
  uint8_t const   *data ;
  int tmp ;

  {
  {
  {
#line 113
  tmp = parse_string(buffer, & length, & data);
  }
  }
#line 113
  if (! tmp) {
#line 114
    return (0);
  }
  {
  {
#line 116
  simple_buffer_init(subbuffer, length, data);
  }
  }
#line 117
  return (1);
}
}
#line 120 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
int parse_uint8(struct simple_buffer *buffer , unsigned int *result ) 
{ 


  {
#line 123
  if (! (buffer->capacity - buffer->pos)) {
#line 124
    return (0);
  }
#line 126
  *result = (unsigned int )*((buffer->data + buffer->pos) + 0);
#line 127
  (buffer->pos) ++;
#line 128
  return (1);
}
}
#line 134 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
static uint32_t const   min_value[7]  = {      (uint32_t const   )0,      (uint32_t const   )0,      (uint32_t const   )128,      (uint32_t const   )2048, 
        (uint32_t const   )65536,      (uint32_t const   )2097152,      (uint32_t const   )67108864};
#line 131 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
int parse_utf8(struct simple_buffer *buffer , uint32_t *result , unsigned int *utf8_length ) 
{ 
  uint32_t c ;
  uint32_t value ;
  unsigned int length ;
  unsigned int i ;

  {
#line 149
  if (! (buffer->capacity - buffer->pos)) {
#line 150
    return (-1);
  }
#line 152
  c = (uint32_t )*((buffer->data + buffer->pos) + 0);
#line 154
  if (c < 128U) {
#line 156
    *result = c;
#line 157
    *utf8_length = 1U;
#line 158
    (buffer->pos) ++;
#line 159
    return (1);
  }
#line 169
  if ((c & 240U) == 208U) {
#line 169
    goto case_208;
  }
#line 169
  if ((c & 240U) == 192U) {
#line 169
    goto case_208;
  }
#line 174
  if ((c & 240U) == 224U) {
#line 174
    goto case_224;
  }
#line 179
  if ((c & 240U) == 240U) {
#line 179
    goto case_240;
  }
#line 164
  goto switch_default;
  switch_default: 
#line 165
  (buffer->pos) ++;
#line 166
  *utf8_length = 1U;
#line 167
  return (0);
  case_208: 
#line 171
  length = 2U;
#line 172
  value = c & 31U;
#line 173
  goto switch_break;
  case_224: 
#line 176
  length = 3U;
#line 177
  value = c & 15U;
#line 178
  goto switch_break;
  case_240: 
#line 182
  if ((c & 14U) == 6U) {
#line 182
    goto case_6;
  }
#line 182
  if ((c & 14U) == 4U) {
#line 182
    goto case_6;
  }
#line 182
  if ((c & 14U) == 2U) {
#line 182
    goto case_6;
  }
#line 182
  if ((c & 14U) == 0U) {
#line 182
    goto case_6;
  }
#line 187
  if ((c & 14U) == 10U) {
#line 187
    goto case_10;
  }
#line 187
  if ((c & 14U) == 8U) {
#line 187
    goto case_10;
  }
#line 192
  if ((c & 14U) == 12U) {
#line 192
    goto case_12;
  }
#line 197
  goto switch_default___0;
  case_6: 
#line 184
  length = 4U;
#line 185
  value = c & 7U;
#line 186
  goto switch_break___0;
  case_10: 
#line 189
  length = 5U;
#line 190
  value = c & 3U;
#line 191
  goto switch_break___0;
  case_12: 
#line 194
  length = 6U;
#line 195
  value = c & 1U;
#line 196
  goto switch_break___0;
  switch_default___0: 
#line 199
  (buffer->pos) ++;
#line 200
  return (0);
  switch_break___0: ;
#line 202
  goto switch_break;
  switch_break: ;
#line 204
  if (buffer->capacity - buffer->pos < length) {
#line 206
    buffer->pos += buffer->capacity - buffer->pos;
#line 207
    *utf8_length = 1U;
#line 208
    return (0);
  }
#line 210
  c = (uint32_t )*((buffer->data + buffer->pos) + 1);
#line 212
  if ((c & 192U) != 128U) {
#line 214
    (buffer->pos) ++;
#line 215
    *utf8_length = 1U;
#line 216
    return (0);
  }
#line 218
  value = (value << 6) | (c & 63U);
#line 220
  i = 2U;
  {
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 220
    if (! (i < length)) {
#line 220
      goto while_break;
    }
#line 222
    c = (uint32_t )*((buffer->data + buffer->pos) + i);
#line 223
    if ((c & 192U) != 128U) {
#line 225
      buffer->pos += i;
#line 226
      *utf8_length = i;
#line 227
      return (0);
    }
#line 229
    value = (value << 6) | (c & 63U);
#line 220
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 232
  buffer->pos += length;
#line 233
  *utf8_length = length;
#line 236
  if (value < (uint32_t )min_value[length]) {
#line 237
    return (0);
  }
#line 240
  if (value >= 55296U) {
#line 240
    if (value < 57344U) {
#line 242
      return (0);
    } else {
#line 240
      goto _L;
    }
  } else
  _L: 
#line 240
  if (value == 65534U) {
#line 242
    return (0);
  } else
#line 240
  if (value == 65535U) {
#line 242
    return (0);
  }
#line 244
  *result = value;
#line 246
  return (1);
}
}
#line 249 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
int parse_boolean(struct simple_buffer *buffer , int *result ) 
{ 


  {
#line 252
  if (! (buffer->capacity - buffer->pos)) {
#line 253
    return (0);
  }
#line 254
  *result = (int )*((buffer->data + buffer->pos) + 0);
#line 255
  (buffer->pos) ++;
#line 256
  return (1);
}
}
#line 259 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
int parse_bignum(struct simple_buffer *buffer , __mpz_struct *result , uint32_t limit ) 
{ 
  uint32_t length ;
  uint8_t const   *digits ;
  int tmp ;

  {
  {
  {
#line 265
  tmp = parse_string(buffer, & length, & digits);
  }
  }
#line 265
  if (! tmp) {
#line 266
    return (0);
  }
#line 271
  if (limit) {
#line 271
    if (length > limit + 1U) {
#line 272
      return (0);
    }
  }
  {
  {
#line 274
  nettle_mpz_set_str_256_s(result, length, digits);
  }
  }
#line 276
  return (1);
}
}
#line 279 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
int parse_atom(struct simple_buffer *buffer , int *result ) 
{ 
  uint32_t length ;
  uint8_t const   *start ;
  int tmp ;

  {
  {
  {
#line 285
  tmp = parse_string(buffer, & length, & start);
  }
  }
#line 285
  if (tmp) {
#line 285
    if (length > 64U) {
#line 287
      return (0);
    }
  } else {
#line 287
    return (0);
  }
  {
  {
#line 289
  *result = lookup_atom(length, start);
  }
  }
#line 291
  return (1);
}
}
#line 297 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
static int parse_next_atom(struct simple_buffer *buffer , int *result ) 
{ 
  uint32_t i ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 302
  if (! (buffer->pos <= buffer->capacity)) {
    {
    {
#line 302
    __assert_fail("buffer->pos <=buffer->capacity", "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c",
                  302U, "parse_next_atom");
    }
    }
  }
#line 304
  i = (uint32_t )0;
  {
  {
#line 304
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 304
    if (! (i < buffer->capacity - buffer->pos)) {
#line 304
      goto while_break;
    }
#line 306
    if ((int const   )*((buffer->data + buffer->pos) + i) == 44) {
#line 307
      goto while_break;
    }
#line 308
    if (i == 64U) {
#line 310
      return (0);
    }
#line 304
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 318
  if (! i) {
    {
    {
#line 320
    verbose("parse_next_atom: Received an empty atom.\n");
    }
#line 322
    *result = 0;
    }
  } else {
    {
    {
#line 325
    *result = lookup_atom(i, buffer->data + buffer->pos);
    }
    }
  }
#line 327
  buffer->pos += i + 1U;
#line 330
  return (1);
}
}
#line 333 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
struct int_list *parse_atoms(struct simple_buffer *buffer , unsigned int limit ) 
{ 
  unsigned int count ;
  unsigned int i ;
  struct int_list *res ;
  struct int_list *tmp ;
  struct list_header *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  struct lsh_class *class15 ;
  unsigned int length16 ;
  size_t element_size17 ;
  struct list_header *list18 ;
  struct lsh_object *tmp19 ;
  char *__cil_tmp920 ;
  char *__cil_tmp1021 ;
  char *__cil_tmp1122 ;
  struct list_header *ret_lsh_list_alloc23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 340
  if (! limit) {
    {
    {
#line 340
    __assert_fail("limit", "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c", 340U,
                  "parse_atoms");
    }
    }
  }
#line 342
  if (! (buffer->capacity - buffer->pos)) {
    {
    {
#line 343
    tmp = make_int_list(0U, -1);
    }
    }
#line 343
    return (tmp);
  }
#line 346
  i = buffer->pos;
#line 346
  count = 1U;
  {
  {
#line 346
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 346
    if (! (i < buffer->capacity)) {
#line 346
      goto while_break;
    }
#line 347
    if ((int const   )*(buffer->data + i) == 44) {
#line 349
      if (count >= limit) {
#line 350
        return ((struct int_list *)((void *)0));
      }
#line 351
      count ++;
    }
#line 346
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 354
  class15 = & int_list_class;
#line 354
  length16 = count;
#line 354
  element_size17 = (size_t )sizeof(int );
  {
#line 49
  if (! (element_size17 < 1024U)) {
    {
    {
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c"
    __assert_fail("element_size < 1024", "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c",
                  49U, "lsh_list_alloc");
    }
    }
  }
  {
  {
#line 51
  tmp19 = lsh_var_alloc(class15, (class15->size + element_size17 * length16) - element_size17);
  }
#line 51
  list18 = (struct list_header *)tmp19;
#line 57
  list18->length = length16;
  }
  {
#line 59
  ret_lsh_list_alloc23 = list18;
#line 59
  goto Lret_lsh_list_alloc;
  }
  }
  Lret_lsh_list_alloc: /* CIL Label */ 
#line 354 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
  tmp___0 = ret_lsh_list_alloc23;
  }
#line 354
  res = (struct int_list *)tmp___0;
#line 356
  i = 0U;
  }
  {
  {
#line 356
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 356
    if (! (i < count)) {
#line 356
      goto while_break___0;
    }
    {
    {
#line 358
    tmp___1 = parse_next_atom(buffer, res->elements + i);
    }
    }
#line 358
    if (! tmp___1) {
      {
      {
#line 360
      gc_kill((struct lsh_object *)res);
      }
      }
#line 361
      return ((struct int_list *)((void *)0));
    }
#line 356
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 365
  return (res);
}
}
#line 368 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
struct int_list *parse_atom_list(struct simple_buffer *buffer , unsigned int limit ) 
{ 
  struct simple_buffer sub_buffer ;
  int tmp ;
  struct int_list *tmp___0 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
  {
#line 373
  tmp = parse_sub_buffer(buffer, & sub_buffer);
  }
  }
#line 373
  if (! tmp) {
#line 374
    return ((struct int_list *)((void *)0));
  }
  {
  {
#line 376
  tmp___0 = parse_atoms(& sub_buffer, limit);
  }
  }
#line 376
  return (tmp___0);
}
}
#line 380 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
int parse_uint16(struct simple_buffer *buffer , uint32_t *result ) 
{ 


  {
#line 383
  if (buffer->capacity - buffer->pos < 2U) {
#line 384
    return (0);
  }
#line 386
  *result = ((uint32_t )*((buffer->data + buffer->pos) + 0) << 8) | (uint32_t )*((buffer->data + buffer->pos) + 1);
#line 387
  buffer->pos += 2U;
#line 388
  return (1);
}
}
#line 391 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
int parse_string16(struct simple_buffer *buffer , uint32_t *length , uint8_t const   **start ) 
{ 
  uint32_t l ;
  int tmp ;

  {
  {
  {
#line 397
  tmp = parse_uint16(buffer, & l);
  }
  }
#line 397
  if (! tmp) {
#line 398
    return (0);
  }
#line 400
  if (buffer->capacity - buffer->pos < l) {
#line 401
    return (0);
  }
#line 403
  *length = l;
#line 404
  *start = buffer->data + buffer->pos;
#line 405
  buffer->pos += l;
#line 406
  return (1);
}
}
#line 409 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
void parse_rest(struct simple_buffer *buffer , uint32_t *length , uint8_t const   **start ) 
{ 


  {
#line 413
  *length = buffer->capacity - buffer->pos;
#line 414
  *start = buffer->data + buffer->pos;
#line 416
  buffer->pos += *length;
#line 417
  return;
}
}
#line 419 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
struct lsh_string *parse_rest_copy(struct simple_buffer *buffer ) 
{ 
  uint32_t length ;
  struct lsh_string *s ;
  struct lsh_string *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 422
  length = buffer->capacity - buffer->pos;
  {
#line 423
  tmp = ssh_format("%ls", length, buffer->data + buffer->pos);
  }
#line 423
  s = tmp;
#line 425
  buffer->pos += length;
  }
#line 426
  if (! (! (buffer->capacity - buffer->pos))) {
    {
    {
#line 426
    __assert_fail("!(buffer->capacity - buffer->pos)", "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c",
                  426U, "parse_rest_copy");
    }
    }
  }
#line 428
  return (s);
}
}
#line 432 "/home/ysko/Works/test-src/lsh-2.0.4/src/parse.c"
int parse_eod(struct simple_buffer *buffer ) 
{ 


  {
#line 435
  return (! (buffer->capacity - buffer->pos));
}
}
#line 65 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
#line 91 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.h"
int lsh_string_prefixp(struct lsh_string  const  *prefix___0 , struct lsh_string  const  *s ) ;
#line 105
void lsh_string_set(struct lsh_string *s , uint32_t start , uint32_t length , uint8_t c ) ;
#line 124
void lsh_string_write_bignum(struct lsh_string *s , uint32_t start , uint32_t length ,
                             __mpz_struct * const  n ) ;
#line 133
void lsh_string_crypt(struct lsh_string *dst , uint32_t di , struct lsh_string  const  *src ,
                      uint32_t si , uint32_t length , void (*f)(void *ctx , unsigned int length ,
                                                                uint8_t *dst , uint8_t const   *src ) ,
                      void *ctx ) ;
#line 139
void lsh_string_cbc_encrypt(struct lsh_string *dst , uint32_t di , struct lsh_string  const  *src ,
                            uint32_t si , uint32_t length , uint32_t block_size ,
                            uint8_t *iv , void (*f)(void *ctx , unsigned int length ,
                                                    uint8_t *dst , uint8_t const   *src ) ,
                            void *ctx ) ;
#line 146
void lsh_string_cbc_decrypt(struct lsh_string *dst , uint32_t di , struct lsh_string  const  *src ,
                            uint32_t si , uint32_t length , uint32_t block_size ,
                            uint8_t *iv , void (*f)(void *ctx , unsigned int length ,
                                                    uint8_t *dst , uint8_t const   *src ) ,
                            void *ctx ) ;
#line 153
void lsh_string_ctr_crypt(struct lsh_string *dst , uint32_t di , struct lsh_string  const  *src ,
                          uint32_t si , uint32_t length , uint32_t block_size , uint8_t *iv ,
                          void (*f)(void *ctx , unsigned int length , uint8_t *dst ,
                                    uint8_t const   *src ) , void *ctx ) ;
#line 160
void lsh_string_write_hash(struct lsh_string *s , uint32_t start , struct nettle_hash  const  *type ,
                           void *ctx ) ;
#line 164
void lsh_string_write_hmac(struct lsh_string *s , uint32_t start , struct nettle_hash  const  *type ,
                           uint32_t length , void const   *outer , void const   *inner ,
                           void *state ) ;
#line 179
int lsh_string_read(struct lsh_string *s , uint32_t start , int fd , uint32_t length ) ;
#line 194
int lsh_string_base64_decode(struct lsh_string *s ) ;
#line 197
unsigned int lsh_string_base64_encode_update(struct lsh_string *s , uint32_t start ,
                                             struct base64_encode_ctx *ctx , uint32_t length ,
                                             uint8_t const   *src ) ;
#line 202
unsigned int lsh_string_base64_encode_final(struct lsh_string *s , uint32_t start ,
                                            struct base64_encode_ctx *ctx ) ;
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
int lsh_string_eq_l(struct lsh_string  const  *a , uint32_t length , uint8_t const   *b ) 
{ 
  uint32_t tmp ;
  uint8_t const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 61
  tmp = lsh_string_length(a);
  }
  }
#line 61
  if (tmp == length) {
    {
    {
#line 61
    tmp___0 = lsh_string_data(a);
    }
    {
#line 61
    tmp___1 = memcmp((void const   *)tmp___0, (void const   *)b, length);
    }
    }
#line 61
    if (tmp___1) {
#line 61
      tmp___2 = 0;
    } else {
#line 61
      tmp___2 = 1;
    }
  } else {
#line 61
    tmp___2 = 0;
  }
#line 61
  return (tmp___2);
}
}
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
int lsh_string_eq(struct lsh_string  const  *a , struct lsh_string  const  *b ) 
{ 
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 68
  tmp = lsh_string_data(b);
  }
  {
#line 68
  tmp___0 = lsh_string_length(b);
  }
  {
#line 68
  tmp___1 = lsh_string_eq_l(a, tmp___0, tmp);
  }
  }
#line 68
  return (tmp___1);
}
}
#line 71 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
int lsh_string_prefixp(struct lsh_string  const  *prefix___0 , struct lsh_string  const  *s ) 
{ 
  uint32_t plength ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint8_t const   *tmp___1 ;
  uint8_t const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 75
  tmp = lsh_string_length(prefix___0);
  }
#line 75
  plength = tmp;
  {
#line 76
  tmp___0 = lsh_string_length(s);
  }
  }
#line 76
  if (plength <= tmp___0) {
    {
    {
#line 76
    tmp___1 = lsh_string_data(s);
    }
    {
#line 76
    tmp___2 = lsh_string_data(prefix___0);
    }
    {
#line 76
    tmp___3 = memcmp((void const   *)tmp___2, (void const   *)tmp___1, plength);
    }
    }
#line 76
    if (tmp___3) {
#line 76
      tmp___4 = 0;
    } else {
#line 76
      tmp___4 = 1;
    }
  } else {
#line 76
    tmp___4 = 0;
  }
#line 76
  return (tmp___4);
}
}
#line 81 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_write_string(struct lsh_string *s , uint32_t pos , struct lsh_string  const  *data ) 
{ 
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;

  {
  {
  {
#line 85
  tmp = lsh_string_data(data);
  }
  {
#line 85
  tmp___0 = lsh_string_length(data);
  }
  {
#line 85
  lsh_string_write(s, pos, tmp___0, tmp);
  }
  }
#line 86
  return;
}
}
#line 88 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
struct lsh_string *lsh_string_random(struct randomness *r , uint32_t length ) 
{ 
  struct lsh_string *s ;
  struct lsh_string *tmp ;

  {
  {
  {
#line 91
  tmp = lsh_string_alloc(length);
  }
#line 91
  s = tmp;
  {
#line 92
  lsh_string_write_random(s, (uint32_t )0, r, length);
  }
  }
#line 94
  return (s);
}
}
#line 122 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
uint32_t lsh_string_length(struct lsh_string  const  *s ) 
{ 


  {
#line 125
  return ((uint32_t )s->length);
}
}
#line 128 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
uint8_t const   *lsh_string_data(struct lsh_string  const  *s ) 
{ 


  {
#line 131
  return ((uint8_t const   *)(s->data));
}
}
#line 136 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
char const   *lsh_get_cstring(struct lsh_string  const  *s ) 
{ 
  uint8_t *tmp___0 ;
  void *tmp___1 ;

  {
#line 139
  if (s) {
    {
    {
#line 139
    tmp___1 = memchr((void const   *)(s->data), '\000', (size_t )s->length);
    }
    }
#line 139
    if (tmp___1) {
#line 139
      tmp___0 = (uint8_t *)((void *)0);
    } else {
#line 139
      tmp___0 = (uint8_t *)(s->data);
    }
  } else {
#line 139
    tmp___0 = (uint8_t *)((void *)0);
  }
#line 139
  return ((char const   *)tmp___0);
}
}
#line 142 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
uint32_t lsh_string_sequence_number(struct lsh_string  const  *s ) 
{ 


  {
#line 145
  return ((uint32_t )s->sequence_number);
}
}
#line 148 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_set_sequence_number(struct lsh_string *s , uint32_t n ) 
{ 


  {
#line 151
  s->sequence_number = n;
#line 152
  return;
}
}
#line 154 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_putc(struct lsh_string *s , uint32_t i , uint8_t c ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 157
  if (! (i < s->length)) {
    {
    {
#line 157
    __assert_fail("i < s->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  157U, "lsh_string_putc");
    }
    }
  }
#line 158
  s->data[i] = c;
#line 159
  return;
}
}
#line 166 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_set(struct lsh_string *s , uint32_t start , uint32_t length , uint8_t c ) 
{ 
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
  {
#line 169
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 169
    if (! (start <= s->length)) {
      {
      {
#line 169
      __assert_fail("(start) <= (s)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    169U, "lsh_string_set");
      }
      }
    }
#line 169
    if (! (length <= s->length - start)) {
      {
      {
#line 169
      __assert_fail("(length) <= (s)->length - (start)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    169U, "lsh_string_set");
      }
      }
    }
#line 169
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 170
  memset((void *)(s->data + start), (int )c, length);
  }
  }
#line 171
  if (! (! s->data[s->length])) {
    {
    {
#line 171
    __assert_fail("!s->data[s->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  171U, "lsh_string_set");
    }
    }
  }
#line 172
  return;
}
}
#line 174 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_write(struct lsh_string *s , uint32_t start , uint32_t length , uint8_t const   *data ) 
{ 
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 178
    if (! (start <= s->length)) {
      {
      {
#line 178
      __assert_fail("(start) <= (s)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    178U, "lsh_string_write");
      }
      }
    }
#line 178
    if (! (length <= s->length - start)) {
      {
      {
#line 178
      __assert_fail("(length) <= (s)->length - (start)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    178U, "lsh_string_write");
      }
      }
    }
#line 178
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 180
  memcpy((void */* __restrict  */)((void *)(s->data + start)), (void const   */* __restrict  */)((void const   *)data),
         length);
  }
  }
#line 182
  if (! (! s->data[s->length])) {
    {
    {
#line 182
    __assert_fail("!s->data[s->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  182U, "lsh_string_write");
    }
    }
  }
#line 183
  return;
}
}
#line 185 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_write_uint32(struct lsh_string *s , uint32_t start , uint32_t n ) 
{ 
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
  {
#line 188
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 188
    if (! (start <= s->length)) {
      {
      {
#line 188
      __assert_fail("(start) <= (s)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    188U, "lsh_string_write_uint32");
      }
      }
    }
#line 188
    if (! (4U <= s->length - start)) {
      {
      {
#line 188
      __assert_fail("(4) <= (s)->length - (start)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    188U, "lsh_string_write_uint32");
      }
      }
    }
#line 188
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 190
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 190
    *((s->data + start) + 0) = (uint8_t )((n >> 24) & 255U);
#line 190
    *((s->data + start) + 1) = (uint8_t )((n >> 16) & 255U);
#line 190
    *((s->data + start) + 2) = (uint8_t )((n >> 8) & 255U);
#line 190
    *((s->data + start) + 3) = (uint8_t )(n & 255U);
#line 190
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 192
  if (! (! s->data[s->length])) {
    {
    {
#line 192
    __assert_fail("!s->data[s->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  192U, "lsh_string_write_uint32");
    }
    }
  }
#line 193
  return;
}
}
#line 195 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_write_xor(struct lsh_string *s , uint32_t start , uint32_t length ,
                          uint8_t const   *data ) 
{ 
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 199
  if (! length) {
    {
    {
#line 199
    __assert_fail("length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  199U, "lsh_string_write_xor");
    }
    }
  }
  {
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 200
    if (! (start <= s->length)) {
      {
      {
#line 200
      __assert_fail("(start) <= (s)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    200U, "lsh_string_write_xor");
      }
      }
    }
#line 200
    if (! (length <= s->length - start)) {
      {
      {
#line 200
      __assert_fail("(length) <= (s)->length - (start)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    200U, "lsh_string_write_xor");
      }
      }
    }
#line 200
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 202
  memxor(s->data + start, data, length);
  }
  }
#line 204
  if (! (! s->data[s->length])) {
    {
    {
#line 204
    __assert_fail("!s->data[s->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  204U, "lsh_string_write_xor");
    }
    }
  }
#line 205
  return;
}
}
#line 207 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_write_bignum(struct lsh_string *s , uint32_t start , uint32_t length ,
                             __mpz_struct * const  n ) 
{ 
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
  {
#line 211
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 211
    if (! (start <= s->length)) {
      {
      {
#line 211
      __assert_fail("(start) <= (s)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    211U, "lsh_string_write_bignum");
      }
      }
    }
#line 211
    if (! (length <= s->length - start)) {
      {
      {
#line 211
      __assert_fail("(length) <= (s)->length - (start)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    211U, "lsh_string_write_bignum");
      }
      }
    }
#line 211
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 212
  nettle_mpz_get_str_256(length, s->data + start, n);
  }
  }
#line 214
  if (! (! s->data[s->length])) {
    {
    {
#line 214
    __assert_fail("!s->data[s->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  214U, "lsh_string_write_bignum");
    }
    }
  }
#line 215
  return;
}
}
#line 219 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
struct lsh_string *lsh_string_trunc(struct lsh_string *s , uint32_t length ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 222
  if (! (length <= s->length)) {
    {
    {
#line 222
    __assert_fail("length <= s->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  222U, "lsh_string_trunc");
    }
    }
  }
#line 223
  s->length = length;
#line 225
  s->data[length] = (uint8_t )0;
#line 227
  return (s);
}
}
#line 230 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_crypt(struct lsh_string *dst , uint32_t di , struct lsh_string  const  *src ,
                      uint32_t si , uint32_t length , void (*f)(void *ctx , unsigned int length ,
                                                                uint8_t *dst , uint8_t const   *src ) ,
                      void *ctx ) 
{ 
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
  {
  {
#line 236
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 236
    if (! (di <= dst->length)) {
      {
      {
#line 236
      __assert_fail("(di) <= (dst)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    236U, "lsh_string_crypt");
      }
      }
    }
#line 236
    if (! (length <= dst->length - di)) {
      {
      {
#line 236
      __assert_fail("(length) <= (dst)->length - (di)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    236U, "lsh_string_crypt");
      }
      }
    }
#line 236
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 237
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 237
    if (! (si <= (uint32_t )src->length)) {
      {
      {
#line 237
      __assert_fail("(si) <= (src)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    237U, "lsh_string_crypt");
      }
      }
    }
#line 237
    if (! (length <= (uint32_t )(src->length - (uint32_t const   )si))) {
      {
      {
#line 237
      __assert_fail("(length) <= (src)->length - (si)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    237U, "lsh_string_crypt");
      }
      }
    }
#line 237
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 239
  if (! ((unsigned long )src != (unsigned long )dst)) {
#line 239
    if (! (di == si)) {
      {
      {
#line 239
      __assert_fail("src != dst || di == si", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    239U, "lsh_string_crypt");
      }
      }
    }
  }
  {
  {
#line 240
  (*f)(ctx, length, dst->data + di, (uint8_t const   *)(src->data + si));
  }
  }
#line 242
  if (! (! dst->data[dst->length])) {
    {
    {
#line 242
    __assert_fail("!dst->data[dst->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  242U, "lsh_string_crypt");
    }
    }
  }
#line 243
  return;
}
}
#line 245 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_cbc_encrypt(struct lsh_string *dst , uint32_t di , struct lsh_string  const  *src ,
                            uint32_t si , uint32_t length , uint32_t block_size ,
                            uint8_t *iv , void (*f)(void *ctx , unsigned int length ,
                                                    uint8_t *dst , uint8_t const   *src ) ,
                            void *ctx ) 
{ 
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
  {
  {
#line 252
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 252
    if (! (di <= dst->length)) {
      {
      {
#line 252
      __assert_fail("(di) <= (dst)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    252U, "lsh_string_cbc_encrypt");
      }
      }
    }
#line 252
    if (! (length <= dst->length - di)) {
      {
      {
#line 252
      __assert_fail("(length) <= (dst)->length - (di)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    252U, "lsh_string_cbc_encrypt");
      }
      }
    }
#line 252
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 253
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 253
    if (! (si <= (uint32_t )src->length)) {
      {
      {
#line 253
      __assert_fail("(si) <= (src)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    253U, "lsh_string_cbc_encrypt");
      }
      }
    }
#line 253
    if (! (length <= (uint32_t )(src->length - (uint32_t const   )si))) {
      {
      {
#line 253
      __assert_fail("(length) <= (src)->length - (si)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    253U, "lsh_string_cbc_encrypt");
      }
      }
    }
#line 253
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 256
  if (! ((unsigned long )src != (unsigned long )dst)) {
#line 256
    if (! (di == si)) {
      {
      {
#line 256
      __assert_fail("src != dst || di == si", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    256U, "lsh_string_cbc_encrypt");
      }
      }
    }
  }
  {
  {
#line 257
  nettle_cbc_encrypt(ctx, f, block_size, iv, length, dst->data + di, (uint8_t const   *)(src->data + si));
  }
  }
#line 260
  if (! (! dst->data[dst->length])) {
    {
    {
#line 260
    __assert_fail("!dst->data[dst->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  260U, "lsh_string_cbc_encrypt");
    }
    }
  }
#line 261
  return;
}
}
#line 263 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_cbc_decrypt(struct lsh_string *dst , uint32_t di , struct lsh_string  const  *src ,
                            uint32_t si , uint32_t length , uint32_t block_size ,
                            uint8_t *iv , void (*f)(void *ctx , unsigned int length ,
                                                    uint8_t *dst , uint8_t const   *src ) ,
                            void *ctx ) 
{ 
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
  {
  {
#line 270
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 270
    if (! (di <= dst->length)) {
      {
      {
#line 270
      __assert_fail("(di) <= (dst)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    270U, "lsh_string_cbc_decrypt");
      }
      }
    }
#line 270
    if (! (length <= dst->length - di)) {
      {
      {
#line 270
      __assert_fail("(length) <= (dst)->length - (di)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    270U, "lsh_string_cbc_decrypt");
      }
      }
    }
#line 270
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 271
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 271
    if (! (si <= (uint32_t )src->length)) {
      {
      {
#line 271
      __assert_fail("(si) <= (src)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    271U, "lsh_string_cbc_decrypt");
      }
      }
    }
#line 271
    if (! (length <= (uint32_t )(src->length - (uint32_t const   )si))) {
      {
      {
#line 271
      __assert_fail("(length) <= (src)->length - (si)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    271U, "lsh_string_cbc_decrypt");
      }
      }
    }
#line 271
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 274
  if (! ((unsigned long )src != (unsigned long )dst)) {
#line 274
    if (! (di == si)) {
      {
      {
#line 274
      __assert_fail("src != dst || di == si", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    274U, "lsh_string_cbc_decrypt");
      }
      }
    }
  }
  {
  {
#line 275
  nettle_cbc_decrypt(ctx, f, block_size, iv, length, dst->data + di, (uint8_t const   *)(src->data + si));
  }
  }
#line 278
  if (! (! dst->data[dst->length])) {
    {
    {
#line 278
    __assert_fail("!dst->data[dst->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  278U, "lsh_string_cbc_decrypt");
    }
    }
  }
#line 279
  return;
}
}
#line 281 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_ctr_crypt(struct lsh_string *dst , uint32_t di , struct lsh_string  const  *src ,
                          uint32_t si , uint32_t length , uint32_t block_size , uint8_t *iv ,
                          void (*f)(void *ctx , unsigned int length , uint8_t *dst ,
                                    uint8_t const   *src ) , void *ctx ) 
{ 
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
  {
  {
#line 288
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 288
    if (! (di <= dst->length)) {
      {
      {
#line 288
      __assert_fail("(di) <= (dst)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    288U, "lsh_string_ctr_crypt");
      }
      }
    }
#line 288
    if (! (length <= dst->length - di)) {
      {
      {
#line 288
      __assert_fail("(length) <= (dst)->length - (di)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    288U, "lsh_string_ctr_crypt");
      }
      }
    }
#line 288
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 289
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 289
    if (! (si <= (uint32_t )src->length)) {
      {
      {
#line 289
      __assert_fail("(si) <= (src)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    289U, "lsh_string_ctr_crypt");
      }
      }
    }
#line 289
    if (! (length <= (uint32_t )(src->length - (uint32_t const   )si))) {
      {
      {
#line 289
      __assert_fail("(length) <= (src)->length - (si)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    289U, "lsh_string_ctr_crypt");
      }
      }
    }
#line 289
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 292
  if (! ((unsigned long )src != (unsigned long )dst)) {
#line 292
    if (! (di == si)) {
      {
      {
#line 292
      __assert_fail("src != dst || di == si", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    292U, "lsh_string_ctr_crypt");
      }
      }
    }
  }
  {
  {
#line 293
  nettle_ctr_crypt(ctx, f, block_size, iv, length, dst->data + di, (uint8_t const   *)(src->data + si));
  }
  }
#line 296
  if (! (! dst->data[dst->length])) {
    {
    {
#line 296
    __assert_fail("!dst->data[dst->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  296U, "lsh_string_ctr_crypt");
    }
    }
  }
#line 297
  return;
}
}
#line 299 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_write_hash(struct lsh_string *s , uint32_t start , struct nettle_hash  const  *type ,
                           void *ctx ) 
{ 
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
  {
#line 303
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 303
    if (! (start <= s->length)) {
      {
      {
#line 303
      __assert_fail("(start) <= (s)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    303U, "lsh_string_write_hash");
      }
      }
    }
#line 303
    if (! (type->digest_size <= (unsigned int const   )(s->length - start))) {
      {
      {
#line 303
      __assert_fail("(type->digest_size) <= (s)->length - (start)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    303U, "lsh_string_write_hash");
      }
      }
    }
#line 303
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 304
  (*(type->digest))(ctx, (unsigned int )type->digest_size, s->data + start);
  }
  }
#line 305
  if (! (! s->data[s->length])) {
    {
    {
#line 305
    __assert_fail("!s->data[s->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  305U, "lsh_string_write_hash");
    }
    }
  }
#line 306
  return;
}
}
#line 309 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_write_hmac(struct lsh_string *s , uint32_t start , struct nettle_hash  const  *type ,
                           uint32_t length , void const   *outer , void const   *inner ,
                           void *state ) 
{ 
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 314
    if (! (start <= s->length)) {
      {
      {
#line 314
      __assert_fail("(start) <= (s)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    314U, "lsh_string_write_hmac");
      }
      }
    }
#line 314
    if (! (length <= s->length - start)) {
      {
      {
#line 314
      __assert_fail("(length) <= (s)->length - (start)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    314U, "lsh_string_write_hmac");
      }
      }
    }
#line 314
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 315
  nettle_hmac_digest(outer, inner, state, type, length, s->data + start);
  }
  }
#line 317
  if (! (! s->data[s->length])) {
    {
    {
#line 317
    __assert_fail("!s->data[s->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  317U, "lsh_string_write_hmac");
    }
    }
  }
#line 318
  return;
}
}
#line 320 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_write_random(struct lsh_string *s , uint32_t start , struct randomness *r ,
                             uint32_t length ) 
{ 
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
  {
#line 324
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 324
    if (! (start <= s->length)) {
      {
      {
#line 324
      __assert_fail("(start) <= (s)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    324U, "lsh_string_write_random");
      }
      }
    }
#line 324
    if (! (length <= s->length - start)) {
      {
      {
#line 324
      __assert_fail("(length) <= (s)->length - (start)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    324U, "lsh_string_write_random");
      }
      }
    }
#line 324
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 325
  (*(r->random))(r, length, s->data + start);
  }
  }
#line 326
  if (! (! s->data[s->length])) {
    {
    {
#line 326
    __assert_fail("!s->data[s->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  326U, "lsh_string_write_random");
    }
    }
  }
#line 327
  return;
}
}
#line 330 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
struct lsh_string *lsh_string_ntop(int family , uint32_t length , void const   *addr ) 
{ 
  struct lsh_string *s ;
  struct lsh_string *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 333
  tmp = lsh_string_alloc(length + 1U);
  }
#line 333
  s = tmp;
  {
#line 338
  tmp___0 = inet_ntop(family, (void const   */* __restrict  */)addr, (char */* __restrict  */)((char *)(s->data)),
                      s->length);
  }
  }
#line 338
  if (! tmp___0) {
    {
    {
#line 340
    fatal("inet_ntop failed for IPv6 address.\n");
    }
    }
  }
  {
  {
#line 342
  tmp___1 = strlen((char const   *)(s->data));
  }
  {
#line 342
  lsh_string_trunc(s, tmp___1);
  }
  }
#line 344
  return (s);
}
}
#line 349 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
int lsh_string_read(struct lsh_string *s , uint32_t start , int fd , uint32_t length ) 
{ 
  int res ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 354
  if (! length) {
    {
    {
#line 354
    __assert_fail("length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  354U, "lsh_string_read");
    }
    }
  }
  {
  {
#line 355
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 355
    if (! (start <= s->length)) {
      {
      {
#line 355
      __assert_fail("(start) <= (s)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    355U, "lsh_string_read");
      }
      }
    }
#line 355
    if (! (length <= s->length - start)) {
      {
      {
#line 355
      __assert_fail("(length) <= (s)->length - (start)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    355U, "lsh_string_read");
      }
      }
    }
#line 355
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 357
  res = read(fd, (void *)(s->data + start), length);
  }
  }
#line 359
  if (! (! s->data[s->length])) {
    {
    {
#line 359
    __assert_fail("!s->data[s->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  359U, "lsh_string_read");
    }
    }
  }
#line 361
  return (res);
}
}
#line 365 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
struct lsh_string *lsh_string_format_sexp(int transport , char const   *format  , ...) 
{ 
  struct lsh_string *s ;
  va_list args ;
  unsigned int length ;
  struct nettle_buffer buffer ;
  unsigned int (*vformat)(struct nettle_buffer * , char const   * , va_list  ) ;
  unsigned int (*tmp)(struct nettle_buffer *buffer , char const   *format , va_list args ) ;
  uint32_t tmp___0 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 373
  if (transport) {
#line 373
    tmp = & nettle_sexp_transport_vformat;
  } else {
#line 373
    tmp = & nettle_sexp_vformat;
  }
  {
#line 373
  vformat = tmp;
  {
#line 376
  __builtin_va_start(args, format);
  }
  {
#line 377
  length = (*vformat)((struct nettle_buffer *)((void *)0), format, args);
  }
  {
#line 378
  __builtin_va_end(args);
  }
  {
#line 380
  s = lsh_string_alloc(length);
  }
  {
#line 381
  nettle_buffer_init_size(& buffer, s->length, s->data);
  }
  {
#line 383
  __builtin_va_start(args, format);
  }
  {
#line 384
  length = (*vformat)(& buffer, format, args);
  }
  {
#line 385
  __builtin_va_end(args);
  }
  {
#line 387
  tmp___0 = lsh_string_length((struct lsh_string  const  *)s);
  }
  }
#line 387
  if (! (length == tmp___0)) {
    {
    {
#line 387
    __assert_fail("length == lsh_string_length(s)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  387U, "lsh_string_format_sexp");
    }
    }
  }
#line 389
  return (s);
}
}
#line 394 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
int lsh_string_zlib(struct lsh_string *s , uint32_t start , int (*f)(z_stream *z ,
                                                                     int flush ) ,
                    z_stream *z , int flush , uint32_t length ) 
{ 
  int res ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
  {
#line 401
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 401
    if (! (start <= s->length)) {
      {
      {
#line 401
      __assert_fail("(start) <= (s)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    401U, "lsh_string_zlib");
      }
      }
    }
#line 401
    if (! (length <= s->length - start)) {
      {
      {
#line 401
      __assert_fail("(length) <= (s)->length - (start)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    401U, "lsh_string_zlib");
      }
      }
    }
#line 401
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 403
  z->next_out = s->data + start;
#line 404
  z->avail_out = length;
  {
#line 406
  res = (*f)(z, flush);
  }
  }
#line 408
  if (! (! s->data[s->length])) {
    {
    {
#line 408
    __assert_fail("!s->data[s->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  408U, "lsh_string_zlib");
    }
    }
  }
#line 409
  return (res);
}
}
#line 414 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
int lsh_string_base64_decode(struct lsh_string *s ) 
{ 
  struct base64_decode_ctx ctx ;
  uint32_t done ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 418
  done = s->length;
  {
#line 420
  nettle_base64_decode_init(& ctx);
  }
  {
#line 422
  tmp = nettle_base64_decode_update(& ctx, & done, s->data, s->length, (uint8_t const   *)(s->data));
  }
  }
#line 422
  if (tmp) {
    {
    {
#line 422
    tmp___0 = nettle_base64_decode_final(& ctx);
    }
    }
#line 422
    if (tmp___0) {
      {
      {
#line 426
      lsh_string_trunc(s, done);
      }
      }
#line 427
      return (1);
    }
  }
#line 429
  return (0);
}
}
#line 445 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
unsigned int lsh_string_base64_encode_update(struct lsh_string *s , uint32_t start ,
                                             struct base64_encode_ctx *ctx , uint32_t length ,
                                             uint8_t const   *src ) 
{ 
  unsigned int res ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
  {
#line 451
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 451
    if (! (start <= s->length)) {
      {
      {
#line 451
      __assert_fail("(start) <= (s)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    451U, "lsh_string_base64_encode_update");
      }
      }
    }
#line 451
    if (! ((length * 8U + 4U) / 6U <= s->length - start)) {
      {
      {
#line 451
      __assert_fail("((((length) * 8 + 4)/6)) <= (s)->length - (start)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    451U, "lsh_string_base64_encode_update");
      }
      }
    }
#line 451
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 452
  res = nettle_base64_encode_update(ctx, s->data + start, length, src);
  }
  }
#line 453
  if (! (! s->data[s->length])) {
    {
    {
#line 453
    __assert_fail("!s->data[s->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  453U, "lsh_string_base64_encode_update");
    }
    }
  }
#line 454
  return (res);
}
}
#line 457 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
unsigned int lsh_string_base64_encode_final(struct lsh_string *s , uint32_t start ,
                                            struct base64_encode_ctx *ctx ) 
{ 
  unsigned int res ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
  {
#line 462
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 462
    if (! (start <= s->length)) {
      {
      {
#line 462
      __assert_fail("(start) <= (s)->length", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    462U, "lsh_string_base64_encode_final");
      }
      }
    }
#line 462
    if (! (3U <= s->length - start)) {
      {
      {
#line 462
      __assert_fail("(3) <= (s)->length - (start)", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                    462U, "lsh_string_base64_encode_final");
      }
      }
    }
#line 462
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 463
  res = nettle_base64_encode_final(ctx, s->data + start);
  }
  }
#line 464
  if (! (! s->data[s->length])) {
    {
    {
#line 464
    __assert_fail("!s->data[s->length]", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c",
                  464U, "lsh_string_base64_encode_final");
    }
    }
  }
#line 465
  return (res);
}
}
#line 469 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
int lsh_string_transport_iterator_first(struct lsh_string *s , struct sexp_iterator *iterator ) 
{ 
  int tmp ;

  {
  {
  {
#line 473
  tmp = nettle_sexp_transport_iterator_first(iterator, s->length, s->data);
  }
  }
#line 473
  return (tmp);
}
}
#line 512 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
struct lsh_string *lsh_string_alloc(uint32_t length ) 
{ 
  struct lsh_string *s ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 518
  tmp = malloc((size_t )(sizeof(struct lsh_string ) + (unsigned long )length));
  }
#line 518
  s = (struct lsh_string *)tmp;
  }
#line 521
  if (! s) {
    {
    {
#line 522
    fatal("Virtual memory exhausted");
    }
    }
  }
#line 524
  s->length = length;
#line 525
  s->data[length] = (uint8_t )'\000';
#line 526
  s->sequence_number = (uint32_t )0;
#line 528
  return (s);
}
}
#line 575 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh_string.c"
void lsh_string_free(struct lsh_string  const  *s ) 
{ 


  {
#line 578
  if (! s) {
#line 579
    return;
  }
  {
  {
#line 606
  free((void *)s);
  }
  }
#line 607
  return;
}
}
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/lookup_verifier.h.x"
struct lsh_class lookup_verifier_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"lookup_verifier", (size_t )sizeof(struct lookup_verifier ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 441 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 12 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.h.x"
struct lsh_class lsh_file_lock_info_class ;
#line 16 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.h.x"
static void do_lsh_file_lock_info_free(struct lsh_object *o ) 
{ 
  struct lsh_file_lock_info *i ;

  {
  {
#line 19
  i = (struct lsh_file_lock_info *)o;
  {
#line 20
  lsh_string_free((struct lsh_string  const  *)i->lockname);
  }
  }
#line 21
  return;
}
}
#line 22 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.h.x"
struct lsh_class lsh_file_lock_info_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"lsh_file_lock_info", (size_t )sizeof(struct lsh_file_lock_info ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_lsh_file_lock_info_free};
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.c.x"
struct lsh_class lsh_file_lock_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.c.x"
static void do_lsh_file_lock_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct lsh_file_lock *i ;

  {
  {
#line 18
  i = (struct lsh_file_lock *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->info);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.c.x"
struct lsh_class lsh_file_lock_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & resource_class, (char *)"lsh_file_lock", (size_t )sizeof(struct lsh_file_lock ),
    & do_lsh_file_lock_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.c"
static void do_kill_file_lock(struct resource *s ) 
{ 
  struct lsh_file_lock *self ;
  char const   *tmp ;

  {
#line 68
  self = (struct lsh_file_lock *)s;
#line 70
  if (self->super.alive) {
    {
#line 72
    self->super.alive = 0;
    {
#line 73
    tmp = lsh_get_cstring((struct lsh_string  const  *)(self->info)->lockname);
    }
    {
#line 73
    unlink(tmp);
    }
    }
  }
#line 75
  return;
}
}
#line 78 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.c"
static struct resource *do_lsh_file_lock(struct lsh_file_lock_info *self , unsigned int retries ) 
{ 
  int fd ;
  unsigned int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  struct lsh_file_lock *lock ;
  struct lsh_object *tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 81
  fd = -1;
  {
#line 84
  tmp = lsh_get_cstring((struct lsh_string  const  *)self->lockname);
  }
  {
#line 84
  fd = open(tmp, 193, 438);
  }
#line 88
  i = 0U;
  }
  {
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 88
    if (fd < 0) {
      {
      {
#line 88
      tmp___1 = __errno_location();
      }
      }
#line 88
      if (*tmp___1 == 17) {
#line 88
        if (! (i < retries)) {
#line 88
          goto while_break;
        }
      } else {
#line 88
        goto while_break;
      }
    } else {
#line 88
      goto while_break;
    }
    {
    {
#line 91
    sleep(17U);
    }
    {
#line 93
    tmp___0 = lsh_get_cstring((struct lsh_string  const  *)self->lockname);
    }
    {
#line 93
    fd = open(tmp___0, 193, 438);
    }
#line 88
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 98
  if (fd < 0) {
    {
    {
#line 100
    tmp___3 = __errno_location();
    }
    }
#line 100
    if (*tmp___3 != 17) {
      {
      {
#line 101
      tmp___2 = __errno_location();
      }
      {
#line 101
      werror("Could not create lock file `%S\' %e\n", self->lockname, *tmp___2);
      }
      }
    }
#line 103
    return ((struct resource *)((void *)0));
  } else {
    {
    {
#line 107
    tmp___4 = lsh_object_alloc(& lsh_file_lock_class);
    }
#line 107
    lock = (struct lsh_file_lock *)tmp___4;
    {
#line 109
    trace("lock_file.c: Creation of lock file `%S\' succeeded.\n", self->lockname);
    }
    {
#line 111
    init_resource(& lock->super, & do_kill_file_lock);
    }
#line 113
    lock->info = self;
    {
#line 115
    close(fd);
    }
    }
#line 116
    return (& lock->super);
  }
}
}
#line 121 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.c"
static int do_lsh_file_lock_p(struct lsh_file_lock_info *self ) 
{ 
  struct stat sbuf ;
  char const   *tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
  {
  {
#line 126
  tmp = lsh_get_cstring((struct lsh_string  const  *)self->lockname);
  }
  {
#line 126
  tmp___0 = stat((char const   */* __restrict  */)tmp, (struct stat */* __restrict  */)(& sbuf));
  }
  }
#line 126
  return (tmp___0 == 0);
}
}
#line 129 "/home/ysko/Works/test-src/lsh-2.0.4/src/lock_file.c"
struct lsh_file_lock_info *make_lsh_file_lock_info(struct lsh_string *name ) 
{ 
  struct lsh_file_lock_info *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 132
  tmp = lsh_object_alloc(& lsh_file_lock_info_class);
  }
#line 132
  self = (struct lsh_file_lock_info *)tmp;
#line 133
  self->lockname = name;
#line 134
  self->lock = & do_lsh_file_lock;
#line 135
  self->lock_p = & do_lsh_file_lock_p;
  }
#line 137
  return (self);
}
}
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.h.x"
struct lsh_class list_header_class ;
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.h"
struct int_list *make_int_listv(unsigned int n , va_list args ) ;
#line 81
struct object_list *make_object_listv(unsigned int n , va_list args ) ;
#line 82
struct object_list *make_object_list(unsigned int n  , ...) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.h.x"
struct lsh_class list_header_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"list_header", (size_t )sizeof(struct list_header ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.h.x"
struct lsh_class int_list_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & list_header_class, (char *)"int_list", (size_t )sizeof(struct int_list ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.h.x"
static void do_object_list_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct object_list *i ;
  unsigned int k3 ;

  {
#line 66
  i = (struct object_list *)o;
#line 69
  k3 = 0U;
  {
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 69
    if (! (k3 < i->super.length)) {
#line 69
      goto while_break;
    }
    {
    {
#line 70
    (*mark)(i->elements[k3]);
    }
#line 69
    k3 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 72
  return;
}
}
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.h.x"
struct lsh_class object_list_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & list_header_class, (char *)"object_list", (size_t )sizeof(struct object_list ),
    & do_object_list_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c"
struct list_header *lsh_list_alloc(struct lsh_class *class , unsigned int length ,
                                   size_t element_size ) 
{ 
  struct list_header *list ;
  struct lsh_object *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 49
  if (! (element_size < 1024U)) {
    {
    {
#line 49
    __assert_fail("element_size < 1024", "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c",
                  49U, "lsh_list_alloc");
    }
    }
  }
  {
  {
#line 51
  tmp = lsh_var_alloc(class, (class->size + element_size * length) - element_size);
  }
#line 51
  list = (struct list_header *)tmp;
#line 57
  list->length = length;
  }
#line 59
  return (list);
}
}
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c"
struct int_list *make_int_listv(unsigned int n , va_list args ) 
{ 
  unsigned int i ;
  struct int_list *l ;
  struct list_header *tmp ;
  int atom ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  struct lsh_class *class23 ;
  unsigned int length24 ;
  size_t element_size25 ;
  struct list_header *list26 ;
  struct lsh_object *tmp27 ;
  char *__cil_tmp928 ;
  char *__cil_tmp1029 ;
  char *__cil_tmp1130 ;
  struct list_header *ret_lsh_list_alloc31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
  {
#line 67
  class23 = & int_list_class;
#line 67
  length24 = n;
#line 67
  element_size25 = (size_t )sizeof(int );
  {
#line 49
  if (! (element_size25 < 1024U)) {
    {
    {
#line 49
    __assert_fail("element_size < 1024", "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c",
                  49U, "lsh_list_alloc");
    }
    }
  }
  {
  {
#line 51
  tmp27 = lsh_var_alloc(class23, (class23->size + element_size25 * length24) - element_size25);
  }
#line 51
  list26 = (struct list_header *)tmp27;
#line 57
  list26->length = length24;
  }
  {
#line 59
  ret_lsh_list_alloc31 = list26;
#line 59
  goto Lret_lsh_list_alloc;
  }
  }
  Lret_lsh_list_alloc: /* CIL Label */ 
#line 67
  tmp = ret_lsh_list_alloc31;
  }
#line 67
  l = (struct int_list *)tmp;
#line 69
  i = 0U;
  }
  {
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 69
    if (! (i < n)) {
#line 69
      goto while_break;
    }
    {
    {
#line 71
    tmp___4 = __builtin_va_arg(args, int );
    }
#line 71
    tmp___1 = tmp___4;
#line 71
    atom = tmp___1;
    }
#line 72
    if (! (atom >= 0)) {
      {
      {
#line 72
      __assert_fail("atom >= 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c",
                    72U, "make_int_listv");
      }
      }
    }
#line 73
    l->elements[i] = atom;
#line 69
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 76
  tmp___5 = __builtin_va_arg(args, int );
  }
#line 76
  tmp___3 = tmp___5;
  }
#line 76
  if (! (tmp___3 == -1)) {
    {
    {
#line 76
    __assert_fail("__builtin_va_arg(args,int) == -1", "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c",
                  76U, "make_int_listv");
    }
    }
  }
#line 78
  return (l);
}
}
#line 81 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c"
struct int_list *make_int_list(unsigned int n  , ...) 
{ 
  va_list args ;
  struct int_list *l ;

  {
  {
  {
#line 87
  __builtin_va_start(args, n);
  }
  {
#line 88
  l = make_int_listv(n, args);
  }
  {
#line 89
  __builtin_va_end(args);
  }
  }
#line 91
  return (l);
}
}
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c"
struct object_list *make_object_listv(unsigned int n , va_list args ) 
{ 
  unsigned int i ;
  struct object_list *l ;
  struct list_header *tmp ;
  struct lsh_object *tmp___0 ;
  int tmp___2 ;
  struct lsh_object *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  struct lsh_class *class16 ;
  unsigned int length17 ;
  size_t element_size18 ;
  struct list_header *list19 ;
  struct lsh_object *tmp20 ;
  char *__cil_tmp921 ;
  char *__cil_tmp1022 ;
  char *__cil_tmp1123 ;
  struct list_header *ret_lsh_list_alloc24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
  {
#line 99
  class16 = & object_list_class;
#line 99
  length17 = n;
#line 99
  element_size18 = (size_t )sizeof(struct lsh_object *);
  {
#line 49
  if (! (element_size18 < 1024U)) {
    {
    {
#line 49
    __assert_fail("element_size < 1024", "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c",
                  49U, "lsh_list_alloc");
    }
    }
  }
  {
  {
#line 51
  tmp20 = lsh_var_alloc(class16, (class16->size + element_size18 * length17) - element_size18);
  }
#line 51
  list19 = (struct list_header *)tmp20;
#line 57
  list19->length = length17;
  }
  {
#line 59
  ret_lsh_list_alloc24 = list19;
#line 59
  goto Lret_lsh_list_alloc;
  }
  }
  Lret_lsh_list_alloc: /* CIL Label */ 
#line 99
  tmp = ret_lsh_list_alloc24;
  }
#line 99
  l = (struct object_list *)tmp;
#line 102
  i = 0U;
  }
  {
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 102
    if (! (i < n)) {
#line 102
      goto while_break;
    }
    {
    {
#line 103
    tmp___3 = __builtin_va_arg(args, struct lsh_object *);
    }
#line 103
    tmp___0 = tmp___3;
#line 103
    l->elements[i] = tmp___0;
#line 102
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 105
  tmp___4 = __builtin_va_arg(args, int );
  }
#line 105
  tmp___2 = tmp___4;
  }
#line 105
  if (! (tmp___2 == -1)) {
    {
    {
#line 105
    __assert_fail("__builtin_va_arg(args,int) == -1", "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c",
                  105U, "make_object_listv");
    }
    }
  }
#line 107
  return (l);
}
}
#line 110 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c"
struct object_list *make_object_list(unsigned int n  , ...) 
{ 
  va_list args ;
  struct object_list *l ;

  {
  {
  {
#line 116
  __builtin_va_start(args, n);
  }
  {
#line 117
  l = make_object_listv(n, args);
  }
  {
#line 118
  __builtin_va_end(args);
  }
  }
#line 120
  return (l);
}
}
#line 106 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h"
struct hash_instance *hash_copy(struct hash_instance *self ) ;
#line 248 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h"
void connection_send_kex_start(struct ssh_connection *self ) ;
#line 251
void connection_send_kex_end(struct ssh_connection *self ) ;
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.h.x"
struct lsh_class kexinit_class ;
#line 86
struct lsh_class make_kexinit_class ;
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.h"
struct lsh_string *format_kex(struct kexinit *kex ) ;
#line 97
int kex_make_encrypt(struct crypto_instance **c , struct hash_instance *secret , struct object_list *algorithms ,
                     int type , struct lsh_string *session_id ) ;
#line 104
int kex_make_decrypt(struct crypto_instance **c , struct hash_instance *secret , struct object_list *algorithms ,
                     int type , struct lsh_string *session_id ) ;
#line 111
struct mac_instance *kex_make_mac(struct hash_instance *secret , struct object_list *algorithms ,
                                  int type , struct lsh_string *session_id ) ;
#line 117
struct make_kexinit *make_simple_kexinit(struct randomness *r , struct int_list *kex_algorithms ,
                                         struct int_list *hostkey_algorithms , struct int_list *crypto_algorithms ,
                                         struct int_list *mac_algorithms , struct int_list *compression_algorithms ,
                                         struct int_list *languages ) ;
#line 130
void send_kexinit(struct ssh_connection *connection ) ;
#line 132
struct packet_handler *make_kexinit_handler(struct lsh_object *extra , struct alist *algorithms ) ;
#line 136
struct packet_handler *make_newkeys_handler(struct crypto_instance *crypto , struct mac_instance *mac ,
                                            struct compress_instance *compression ) ;
#line 251 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
struct resource *io_callout(struct lsh_callback *action , unsigned int seconds ) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.h.x"
struct lsh_class keyexchange_algorithm_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"keyexchange_algorithm", (size_t )sizeof(struct keyexchange_algorithm ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.h.x"
static void do_kexinit_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct kexinit *i ;
  unsigned int k2 ;

  {
  {
#line 49
  i = (struct kexinit *)o;
  {
#line 50
  (*mark)((struct lsh_object *)i->kex_algorithms);
  }
  {
#line 51
  (*mark)((struct lsh_object *)i->server_hostkey_algorithms);
  }
#line 54
  k2 = 0U;
  }
  {
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 54
    if (! (k2 < 6U)) {
#line 54
      goto while_break;
    }
    {
    {
#line 55
    (*mark)((struct lsh_object *)i->parameters[k2]);
    }
#line 54
    k2 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 57
  (*mark)((struct lsh_object *)i->languages_client_to_server);
  }
  {
#line 58
  (*mark)((struct lsh_object *)i->languages_server_to_client);
  }
  }
#line 59
  return;
}
}
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.h.x"
static void do_kexinit_free(struct lsh_object *o ) 
{ 
  struct kexinit *i ;

  {
  {
#line 63
  i = (struct kexinit *)o;
  {
#line 64
  lsh_string_free((struct lsh_string  const  *)i->first_kex_packet);
  }
  }
#line 65
  return;
}
}
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.h.x"
struct lsh_class kexinit_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"kexinit", (size_t )sizeof(struct kexinit ),
    & do_kexinit_mark, & do_kexinit_free};
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.h.x"
struct lsh_class make_kexinit_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"make_kexinit", (size_t )sizeof(struct make_kexinit ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c.x"
struct lsh_class kexinit_handler_class ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c.x"
static void do_kexinit_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct kexinit_handler *i ;

  {
  {
#line 19
  i = (struct kexinit_handler *)o;
  {
#line 20
  (*mark)(i->extra);
  }
  {
#line 21
  (*mark)((struct lsh_object *)i->algorithms);
  }
  }
#line 22
  return;
}
}
#line 23 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c.x"
struct lsh_class kexinit_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & packet_handler_class, (char *)"kexinit_handler", (size_t )sizeof(struct kexinit_handler ),
    & do_kexinit_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 43
struct lsh_class reexchange_timeout_class ;
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c.x"
static void do_reexchange_timeout_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct reexchange_timeout *i ;

  {
  {
#line 51
  i = (struct reexchange_timeout *)o;
  {
#line 52
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 53
  return;
}
}
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c.x"
struct lsh_class reexchange_timeout_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & lsh_callback_class, (char *)"reexchange_timeout", (size_t )sizeof(struct reexchange_timeout ),
    & do_reexchange_timeout_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 76
struct lsh_class newkeys_handler_class ;
#line 80 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c.x"
static void do_newkeys_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct newkeys_handler *i ;

  {
  {
#line 84
  i = (struct newkeys_handler *)o;
  {
#line 85
  (*mark)((struct lsh_object *)i->crypto);
  }
  {
#line 86
  (*mark)((struct lsh_object *)i->mac);
  }
  {
#line 87
  (*mark)((struct lsh_object *)i->compression);
  }
  }
#line 88
  return;
}
}
#line 89 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c.x"
struct lsh_class newkeys_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & packet_handler_class, (char *)"newkeys_handler", (size_t )sizeof(struct newkeys_handler ),
    & do_newkeys_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 115
struct lsh_class simple_kexinit_class ;
#line 119 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c.x"
static void do_simple_kexinit_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct simple_kexinit *i ;

  {
  {
#line 123
  i = (struct simple_kexinit *)o;
  {
#line 124
  (*mark)((struct lsh_object *)i->r);
  }
  {
#line 125
  (*mark)((struct lsh_object *)i->kex_algorithms);
  }
  {
#line 126
  (*mark)((struct lsh_object *)i->hostkey_algorithms);
  }
  {
#line 127
  (*mark)((struct lsh_object *)i->crypto_algorithms);
  }
  {
#line 128
  (*mark)((struct lsh_object *)i->mac_algorithms);
  }
  {
#line 129
  (*mark)((struct lsh_object *)i->compression_algorithms);
  }
  {
#line 130
  (*mark)((struct lsh_object *)i->languages);
  }
  }
#line 131
  return;
}
}
#line 132 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c.x"
struct lsh_class simple_kexinit_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & make_kexinit_class, (char *)"simple_kexinit", (size_t )sizeof(struct simple_kexinit ),
    & do_simple_kexinit_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
static struct kexinit *parse_kexinit(struct lsh_string *packet ) 
{ 
  struct kexinit *res ;
  struct lsh_object *tmp ;
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t reserved ;
  struct int_list *lists[10] ;
  int i ;
  uint8_t const   *tmp___0 ;
  uint32_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct int_list *tmp___4 ;
  int j ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;

  {
  {
  {
#line 85
  tmp = lsh_object_alloc(& kexinit_class);
  }
#line 85
  res = (struct kexinit *)tmp;
  {
#line 93
  tmp___0 = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 93
  tmp___1 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 93
  simple_buffer_init(& buffer, tmp___1, tmp___0);
  }
  {
#line 95
  tmp___2 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 95
  if (tmp___2) {
#line 95
    if (msg_number != 20U) {
      {
      {
#line 98
      gc_kill((struct lsh_object *)res);
      }
      }
#line 99
      return ((struct kexinit *)((void *)0));
    }
  } else {
    {
    {
#line 98
    gc_kill((struct lsh_object *)res);
    }
    }
#line 99
    return ((struct kexinit *)((void *)0));
  }
  {
  {
#line 102
  tmp___3 = parse_octets(& buffer, (uint32_t )16, res->cookie);
  }
  }
#line 102
  if (! tmp___3) {
    {
    {
#line 104
    gc_kill((struct lsh_object *)res);
    }
    }
#line 105
    return ((struct kexinit *)((void *)0));
  }
#line 108
  i = 0;
  {
  {
#line 108
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 108
    if (! (i < 10)) {
#line 108
      goto while_break;
    }
    {
    {
#line 109
    tmp___4 = parse_atom_list(& buffer, 500U);
    }
#line 109
    lists[i] = tmp___4;
    }
#line 109
    if (! tmp___4) {
#line 110
      goto while_break;
    }
#line 108
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 112
  if (i < 10) {
#line 112
    goto _L;
  } else {
    {
    {
#line 112
    tmp___5 = parse_boolean(& buffer, & res->first_kex_packet_follows);
    }
    }
#line 112
    if (tmp___5) {
      {
      {
#line 112
      tmp___6 = parse_uint32(& buffer, & reserved);
      }
      }
#line 112
      if (tmp___6) {
#line 112
        if (reserved) {
#line 112
          goto _L;
        } else {
          {
          {
#line 112
          tmp___7 = parse_eod(& buffer);
          }
          }
#line 112
          if (! tmp___7) {
            _L: 
#line 119
            j = 0;
            {
            {
#line 119
            while (1) {
              while_continue___3: /* CIL Label */ ;
              while_continue___0: /* CIL Label */ ;

#line 119
              if (! (j < i)) {
#line 119
                goto while_break___0;
              }
              {
              {
#line 120
              gc_kill((struct lsh_object *)lists[j]);
              }
#line 119
              j ++;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
            while_break___3: /* CIL Label */ ;
            }
            while_break___0: 
            {
            {
#line 121
            gc_kill((struct lsh_object *)res);
            }
            }
#line 122
            return ((struct kexinit *)((void *)0));
          }
        }
      } else {
#line 112
        goto _L;
      }
    } else {
#line 112
      goto _L;
    }
  }
#line 125
  res->kex_algorithms = lists[0];
#line 126
  res->server_hostkey_algorithms = lists[1];
#line 128
  i = 0;
  {
  {
#line 128
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;

#line 128
    if (! (i < 6)) {
#line 128
      goto while_break___1;
    }
#line 129
    res->parameters[i] = lists[2 + i];
#line 128
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
#line 131
  res->languages_client_to_server = lists[8];
#line 132
  res->languages_server_to_client = lists[9];
#line 134
  return (res);
}
}
#line 137 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
struct lsh_string *format_kex(struct kexinit *kex ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 140
  tmp = ssh_format("%c%ls%A%A%A%A%A%A%A%A%A%A%c%i", 20, 16, kex->cookie, kex->kex_algorithms,
                   kex->server_hostkey_algorithms, kex->parameters[0], kex->parameters[1],
                   kex->parameters[2], kex->parameters[3], kex->parameters[4], kex->parameters[5],
                   kex->languages_client_to_server, kex->languages_server_to_client,
                   kex->first_kex_packet_follows, 0);
  }
  }
#line 140
  return (tmp);
}
}
#line 156 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
void send_kexinit(struct ssh_connection *connection ) 
{ 
  struct lsh_string *s ;
  int mode ;
  struct kexinit *kex ;
  struct kexinit *tmp ;
  struct lsh_string *tmp___0 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 160
  mode = (int )((unsigned int )connection->flags & 1U);
  {
#line 162
  tmp = (*((connection->kexinit)->make))(connection->kexinit);
  }
#line 162
  connection->kexinits[mode] = tmp;
#line 162
  kex = tmp;
  }
#line 166
  if (! (kex->first_kex_packet_follows == ! (! kex->first_kex_packet))) {
    {
    {
#line 166
    __assert_fail("kex->first_kex_packet_follows == !!kex->first_kex_packet", "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c",
                  166U, "send_kexinit");
    }
    }
  }
#line 167
  if (! ((unsigned int )connection->read_kex_state == 0U)) {
    {
    {
#line 167
    __assert_fail("connection->read_kex_state == KEX_STATE_INIT", "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c",
                  167U, "send_kexinit");
    }
    }
  }
#line 170
  if (connection->key_expire) {
    {
    {
#line 172
    (*((connection->key_expire)->kill))(connection->key_expire);
    }
#line 173
    connection->key_expire = (struct resource *)((void *)0);
    }
  }
  {
  {
#line 176
  s = format_kex(kex);
  }
#line 183
  connection->literal_kexinits[mode] = s;
  {
#line 184
  connection_send_kex_start(connection);
  }
  {
#line 186
  tmp___0 = ssh_format("%lS", s);
  }
  {
#line 186
  connection_send_kex(connection, tmp___0);
  }
  }
#line 190
  if (kex->first_kex_packet_follows) {
    {
#line 192
    s = kex->first_kex_packet;
#line 193
    kex->first_kex_packet = (struct lsh_string *)((void *)0);
    {
#line 195
    connection_send_kex(connection, s);
    }
    }
  }
#line 197
  return;
}
}
#line 199 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
static int select_algorithm(struct int_list *client_list , struct int_list *server_list ) 
{ 
  unsigned int i ;
  unsigned int j ;
  int a ;

  {
#line 208
  i = 0U;
  {
  {
#line 208
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 208
    if (! (i < client_list->super.length)) {
#line 208
      goto while_break;
    }
#line 210
    a = client_list->elements[i];
#line 211
    if (! a) {
#line 213
      goto __Cont;
    }
#line 214
    j = 0U;
    {
    {
#line 214
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 214
      if (! (j < server_list->super.length)) {
#line 214
        goto while_break___0;
      }
#line 215
      if (a == server_list->elements[j]) {
#line 216
        return (a);
      }
#line 214
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
    __Cont: 
#line 208
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 219
  return (0);
}
}
#line 222 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
void disconnect_kex_failed(struct ssh_connection *connection , char const   *msg ) 
{ 
  struct exception *tmp ;

  {
  {
  {
#line 225
  tmp = make_protocol_exception((uint32_t )3, msg);
  }
  {
#line 225
  (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp);
  }
  }
#line 229
  return;
}
}
#line 231 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
static void do_handle_kexinit(struct packet_handler *c , struct ssh_connection *connection ,
                              struct lsh_string *packet ) 
{ 
  struct kexinit_handler *closure ;
  int kex_algorithm_atom ;
  int hostkey_algorithm_atom ;
  int parameters[6] ;
  struct object_list *algorithms ;
  int mode ;
  struct kexinit *msg ;
  struct kexinit *tmp ;
  int i ;
  struct exception *tmp___0 ;
  struct list_header *tmp___1 ;
  struct keyexchange_algorithm *kex_algorithm ;
  struct lsh_object *tmp___2 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  struct lsh_class *class39 ;
  unsigned int length40 ;
  size_t element_size41 ;
  struct list_header *list42 ;
  struct lsh_object *tmp43 ;
  char *__cil_tmp944 ;
  char *__cil_tmp1045 ;
  char *__cil_tmp1146 ;
  struct list_header *ret_lsh_list_alloc47 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
  {
#line 236
  closure = (struct kexinit_handler *)c;
#line 244
  mode = (int )((unsigned int )connection->flags & 1U);
  {
#line 245
  tmp = parse_kexinit(packet);
  }
#line 245
  msg = tmp;
  {
#line 249
  verbose("Received KEXINIT message. Key exchange initated.\n");
  }
  }
#line 251
  if ((unsigned int )connection->read_kex_state != 0U) {
    {
    {
#line 253
    tmp___0 = make_protocol_exception((uint32_t )2, "Unexpected KEXINIT message.");
    }
    {
#line 253
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___0);
    }
    }
#line 254
    return;
  }
#line 257
  if (! msg) {
    {
    {
#line 259
    disconnect_kex_failed(connection, "Invalid KEXINIT message.");
    }
    }
#line 260
    return;
  }
#line 263
  if (! (msg->kex_algorithms)->super.length) {
    {
    {
#line 265
    disconnect_kex_failed(connection, "No keyexchange method.");
    }
    }
#line 266
    return;
  }
  {
  {
#line 274
  connection->literal_kexinits[! mode] = ssh_format("%lS", packet);
  }
#line 276
  connection->kexinits[! mode] = msg;
  }
#line 279
  if (! connection->kexinits[mode]) {
    {
    {
#line 280
    send_kexinit(connection);
    }
    }
  }
#line 285
  if (((connection->kexinits[0])->kex_algorithms)->elements[0] == ((connection->kexinits[1])->kex_algorithms)->elements[0]) {
#line 289
    kex_algorithm_atom = ((connection->kexinits[0])->kex_algorithms)->elements[0];
#line 292
    connection->read_kex_state = (enum kex_state )2;
  } else {
#line 296
    if (msg->first_kex_packet_follows) {
#line 299
      connection->read_kex_state = (enum kex_state )1;
    }
    {
    {
#line 305
    kex_algorithm_atom = select_algorithm((connection->kexinits[0])->kex_algorithms,
                                          (connection->kexinits[1])->kex_algorithms);
    }
    }
#line 310
    if (! kex_algorithm_atom) {
      {
      {
#line 312
      disconnect_kex_failed(connection, "No common key exchange method.\r\n");
      }
      }
#line 314
      return;
    }
  }
  {
  {
#line 318
  hostkey_algorithm_atom = select_algorithm((connection->kexinits[0])->server_hostkey_algorithms,
                                            (connection->kexinits[1])->server_hostkey_algorithms);
  }
  }
#line 322
  if (! hostkey_algorithm_atom) {
    {
    {
#line 324
    disconnect_kex_failed(connection, "No common hostkey algorithm.\r\n");
    }
    }
#line 325
    return;
  }
  {
  {
#line 328
  verbose("Selected keyexchange algorithm: %a\n  with hostkey algorithm:       %a\n",
          kex_algorithm_atom, hostkey_algorithm_atom);
  }
#line 332
  i = 0;
  }
  {
  {
#line 332
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 332
    if (! (i < 6)) {
#line 332
      goto while_break;
    }
    {
    {
#line 334
    parameters[i] = select_algorithm((connection->kexinits[0])->parameters[i], (connection->kexinits[1])->parameters[i]);
    }
    }
#line 338
    if (! parameters[i]) {
      {
      {
#line 340
      disconnect_kex_failed(connection, "Algorithm negotiation failed.");
      }
      }
#line 341
      return;
    }
#line 332
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 345
  verbose("Selected bulk algorithms: (client to server, server to client)\n  Encryption:             (%a, %a)\n  Message authentication: (%a, %a)\n  Compression:            (%a, %a)\n",
          parameters[0], parameters[1], parameters[2], parameters[3], parameters[4],
          parameters[5]);
  }
  {
#line 353
  class39 = & object_list_class;
#line 353
  length40 = 6U;
#line 353
  element_size41 = (size_t )sizeof(struct lsh_object *);
  {
#line 49
  if (! (element_size41 < 1024U)) {
    {
    {
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c"
    __assert_fail("element_size < 1024", "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c",
                  49U, "lsh_list_alloc");
    }
    }
  }
  {
  {
#line 51
  tmp43 = lsh_var_alloc(class39, (class39->size + element_size41 * length40) - element_size41);
  }
#line 51
  list42 = (struct list_header *)tmp43;
#line 57
  list42->length = length40;
  }
  {
#line 59
  ret_lsh_list_alloc47 = list42;
#line 59
  goto Lret_lsh_list_alloc;
  }
  }
  Lret_lsh_list_alloc: /* CIL Label */ 
#line 353 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
  tmp___1 = ret_lsh_list_alloc47;
  }
#line 353
  algorithms = (struct object_list *)tmp___1;
#line 355
  i = 0;
  }
  {
  {
#line 355
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 355
    if (! (i < 6)) {
#line 355
      goto while_break___0;
    }
    {
    {
#line 356
    algorithms->elements[i] = (*(((struct alist_meta *)(closure->algorithms)->super.isa)->get))(closure->algorithms,
                                                                                                parameters[i]);
    }
#line 355
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
  {
#line 359
  tmp___2 = (*(((struct alist_meta *)(closure->algorithms)->super.isa)->get))(closure->algorithms,
                                                                              kex_algorithm_atom);
  }
#line 359
  kex_algorithm = (struct keyexchange_algorithm *)tmp___2;
  {
#line 362
  (*(kex_algorithm->init))(kex_algorithm, connection, hostkey_algorithm_atom, closure->extra,
                           algorithms);
  }
  }
#line 368
  return;
}
}
#line 370 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
struct packet_handler *make_kexinit_handler(struct lsh_object *extra , struct alist *algorithms ) 
{ 
  struct kexinit_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 374
  tmp = lsh_object_alloc(& kexinit_handler_class);
  }
#line 374
  self = (struct kexinit_handler *)tmp;
#line 376
  self->super.handler = & do_handle_kexinit;
#line 378
  self->extra = extra;
#line 379
  self->algorithms = algorithms;
  }
#line 381
  return (& self->super);
}
}
#line 393
static struct lsh_string *kex_make_key(struct hash_instance *secret , uint32_t key_length ,
                                       int type , struct lsh_string *session_id ) ;
#line 393 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
static uint8_t const   tags[7]  = {      (uint8_t const   )'C',      (uint8_t const   )'D',      (uint8_t const   )'E',      (uint8_t const   )'F', 
        (uint8_t const   )'A',      (uint8_t const   )'B',      (uint8_t const   )'\000'};
#line 386 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
static struct lsh_string *kex_make_key(struct hash_instance *secret , uint32_t key_length ,
                                       int type , struct lsh_string *session_id ) 
{ 
  struct lsh_string *key ;
  struct hash_instance *hash___2 ;
  struct lsh_string *digest ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  uint8_t const   *tmp___1 ;
  unsigned int left ;
  uint32_t pos ;
  struct hash_instance *tmp___2 ;
  uint8_t const   *tmp___3 ;
  uint8_t const   *tmp___4 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
  {
#line 399
  key = lsh_string_alloc(key_length);
  }
  {
#line 401
  debug("\nConstructing session key of type %i\n", type);
  }
  }
#line 403
  if (! key_length) {
#line 404
    return (key);
  }
  {
  {
#line 406
  hash___2 = hash_copy(secret);
  }
  {
#line 408
  hash_update(hash___2, (uint32_t )1, tags + type);
  }
  {
#line 409
  tmp = lsh_string_data((struct lsh_string  const  *)session_id);
  }
  {
#line 409
  tmp___0 = lsh_string_length((struct lsh_string  const  *)session_id);
  }
  {
#line 409
  hash_update(hash___2, tmp___0, tmp);
  }
  {
#line 410
  digest = hash_digest_string(hash___2);
  }
  }
#line 413
  if (key_length <= (uint32_t )(hash___2->type)->digest_size) {
    {
    {
#line 414
    tmp___1 = lsh_string_data((struct lsh_string  const  *)digest);
    }
    {
#line 414
    lsh_string_write(key, (uint32_t )0, key_length, tmp___1);
    }
    }
  } else {
    {
#line 418
    left = key_length;
#line 419
    pos = (uint32_t )0;
    {
#line 421
    gc_kill((struct lsh_object *)hash___2);
    }
    {
#line 422
    hash___2 = hash_copy(secret);
    }
    }
    {
    {
#line 424
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 435
      if (! (pos + left == key_length)) {
        {
        {
#line 435
        __assert_fail("pos + left == key_length", "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c",
                      435U, "kex_make_key");
        }
        }
      }
      {
      {
#line 438
      lsh_string_write_string(key, pos, (struct lsh_string  const  *)digest);
      }
#line 439
      pos += (uint32_t )(hash___2->type)->digest_size;
#line 440
      left -= (unsigned int )(hash___2->type)->digest_size;
      {
#line 443
      tmp___3 = lsh_string_data((struct lsh_string  const  *)digest);
      }
      {
#line 443
      hash_update(hash___2, (uint32_t )(hash___2->type)->digest_size, tmp___3);
      }
      {
#line 444
      lsh_string_free((struct lsh_string  const  *)digest);
      }
      }
#line 446
      if (left <= (unsigned int )(hash___2->type)->digest_size) {
#line 447
        goto while_break;
      }
      {
      {
#line 453
      tmp___2 = hash_copy(hash___2);
      }
      {
#line 454
      digest = hash_digest_string(tmp___2);
      }
      {
#line 455
      gc_kill((struct lsh_object *)tmp___2);
      }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
    {
#line 459
    digest = hash_digest_string(hash___2);
    }
    {
#line 460
    tmp___4 = lsh_string_data((struct lsh_string  const  *)digest);
    }
    {
#line 460
    lsh_string_write(key, pos, left, tmp___4);
    }
    }
  }
  {
  {
#line 463
  lsh_string_free((struct lsh_string  const  *)digest);
  }
  {
#line 464
  gc_kill((struct lsh_object *)hash___2);
  }
  {
#line 466
  debug("Expanded key: %xS", key);
  }
  }
#line 468
  return (key);
}
}
#line 471 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
int kex_make_encrypt(struct crypto_instance **c , struct hash_instance *secret , struct object_list *algorithms ,
                     int type , struct lsh_string *session_id ) 
{ 
  struct crypto_algorithm *algorithm ;
  struct lsh_string *key ;
  struct lsh_string *iv ;
  uint8_t const   *tmp ;
  uint8_t const   *tmp___0 ;
  uint8_t const   *tmp___1 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 478
  algorithm = (struct crypto_algorithm *)algorithms->elements[type];
#line 481
  iv = (struct lsh_string *)((void *)0);
#line 483
  if (! (algorithms->super.length == 6U)) {
    {
    {
#line 483
    __assert_fail("((algorithms)->super.length) == 6", "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c",
                  483U, "kex_make_encrypt");
    }
    }
  }
#line 485
  *c = (struct crypto_instance *)((void *)0);
#line 487
  if (! algorithm) {
#line 488
    return (1);
  }
  {
  {
#line 490
  key = kex_make_key(secret, algorithm->key_size, type, session_id);
  }
  }
#line 493
  if (algorithm->iv_size) {
    {
    {
#line 494
    iv = kex_make_key(secret, algorithm->iv_size, type + 4, session_id);
    }
    }
  }
#line 497
  if (iv) {
    {
    {
#line 497
    tmp = lsh_string_data((struct lsh_string  const  *)iv);
    }
#line 497
    tmp___0 = tmp;
    }
  } else {
#line 497
    tmp___0 = (uint8_t const   *)((void *)0);
  }
  {
  {
#line 497
  tmp___1 = lsh_string_data((struct lsh_string  const  *)key);
  }
  {
#line 497
  *c = (*(algorithm->make_crypt))(algorithm, 0, tmp___1, tmp___0);
  }
  {
#line 500
  lsh_string_free((struct lsh_string  const  *)key);
  }
  {
#line 501
  lsh_string_free((struct lsh_string  const  *)iv);
  }
  }
#line 503
  return ((unsigned long )*c != (unsigned long )((void *)0));
}
}
#line 506 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
int kex_make_decrypt(struct crypto_instance **c , struct hash_instance *secret , struct object_list *algorithms ,
                     int type , struct lsh_string *session_id ) 
{ 
  struct crypto_algorithm *algorithm ;
  struct lsh_string *key ;
  struct lsh_string *iv ;
  uint8_t const   *tmp ;
  uint8_t const   *tmp___0 ;
  uint8_t const   *tmp___1 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 513
  algorithm = (struct crypto_algorithm *)algorithms->elements[type];
#line 516
  iv = (struct lsh_string *)((void *)0);
#line 518
  if (! (algorithms->super.length == 6U)) {
    {
    {
#line 518
    __assert_fail("((algorithms)->super.length) == 6", "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c",
                  518U, "kex_make_decrypt");
    }
    }
  }
#line 520
  *c = (struct crypto_instance *)((void *)0);
#line 522
  if (! algorithm) {
#line 523
    return (1);
  }
  {
  {
#line 525
  key = kex_make_key(secret, algorithm->key_size, type, session_id);
  }
  }
#line 528
  if (algorithm->iv_size) {
    {
    {
#line 529
    iv = kex_make_key(secret, algorithm->iv_size, type + 4, session_id);
    }
    }
  }
#line 532
  if (iv) {
    {
    {
#line 532
    tmp = lsh_string_data((struct lsh_string  const  *)iv);
    }
#line 532
    tmp___0 = tmp;
    }
  } else {
#line 532
    tmp___0 = (uint8_t const   *)((void *)0);
  }
  {
  {
#line 532
  tmp___1 = lsh_string_data((struct lsh_string  const  *)key);
  }
  {
#line 532
  *c = (*(algorithm->make_crypt))(algorithm, 1, tmp___1, tmp___0);
  }
  {
#line 535
  lsh_string_free((struct lsh_string  const  *)key);
  }
  {
#line 536
  lsh_string_free((struct lsh_string  const  *)iv);
  }
  }
#line 538
  return ((unsigned long )*c != (unsigned long )((void *)0));
}
}
#line 541 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
struct mac_instance *kex_make_mac(struct hash_instance *secret , struct object_list *algorithms ,
                                  int type , struct lsh_string *session_id ) 
{ 
  struct mac_algorithm *algorithm ;
  struct mac_instance *mac ;
  struct lsh_string *key ;
  uint8_t const   *tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 547
  algorithm = (struct mac_algorithm *)algorithms->elements[type];
#line 552
  if (! (algorithms->super.length == 6U)) {
    {
    {
#line 552
    __assert_fail("((algorithms)->super.length) == 6", "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c",
                  552U, "kex_make_mac");
    }
    }
  }
#line 554
  if (! algorithm) {
#line 555
    return ((struct mac_instance *)((void *)0));
  }
  {
  {
#line 557
  key = kex_make_key(secret, algorithm->key_size, type, session_id);
  }
  {
#line 560
  tmp = lsh_string_data((struct lsh_string  const  *)key);
  }
  {
#line 560
  mac = (*(algorithm->make_mac))(algorithm, algorithm->key_size, tmp);
  }
  {
#line 562
  lsh_string_free((struct lsh_string  const  *)key);
  }
  }
#line 563
  return (mac);
}
}
#line 566 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
static struct compress_instance *kex_make_deflate(struct object_list *algorithms ,
                                                  int type ) 
{ 
  struct compress_algorithm *algorithm ;
  struct compress_instance *tmp ;
  struct compress_instance *tmp___0 ;

  {
#line 570
  algorithm = (struct compress_algorithm *)algorithms->elements[type];
#line 572
  if (algorithm) {
    {
    {
#line 572
    tmp = (*(algorithm->make_compress))(algorithm, 0);
    }
#line 572
    tmp___0 = tmp;
    }
  } else {
#line 572
    tmp___0 = (struct compress_instance *)((void *)0);
  }
#line 572
  return (tmp___0);
}
}
#line 575 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
static struct compress_instance *kex_make_inflate(struct object_list *algorithms ,
                                                  int type ) 
{ 
  struct compress_algorithm *algorithm ;
  struct compress_instance *tmp ;
  struct compress_instance *tmp___0 ;

  {
#line 579
  algorithm = (struct compress_algorithm *)algorithms->elements[type];
#line 581
  if (algorithm) {
    {
    {
#line 581
    tmp = (*(algorithm->make_compress))(algorithm, 1);
    }
#line 581
    tmp___0 = tmp;
    }
  } else {
#line 581
    tmp___0 = (struct compress_instance *)((void *)0);
  }
#line 581
  return (tmp___0);
}
}
#line 592 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
static void do_reexchange_timeout(struct lsh_callback *s ) 
{ 
  struct reexchange_timeout *self ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 595
  self = (struct reexchange_timeout *)s;
#line 596
  if (! (! (self->connection)->send_kex_only)) {
    {
    {
#line 596
    __assert_fail("!self->connection->send_kex_only", "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c",
                  596U, "do_reexchange_timeout");
    }
    }
  }
  {
  {
#line 598
  verbose("Session key expired. Initiating key re-exchange.\n");
  }
  {
#line 599
  send_kexinit(self->connection);
  }
  }
#line 600
  return;
}
}
#line 602 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
static void set_reexchange_timeout(struct ssh_connection *connection , unsigned int seconds ) 
{ 
  struct reexchange_timeout *timeout ;
  struct lsh_object *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 606
  tmp = lsh_object_alloc(& reexchange_timeout_class);
  }
#line 606
  timeout = (struct reexchange_timeout *)tmp;
  {
#line 608
  verbose("Setting session key lifetime to %i seconds\n", seconds);
  }
#line 610
  timeout->super.f = & do_reexchange_timeout;
#line 611
  timeout->connection = connection;
  }
#line 613
  if (! (! connection->key_expire)) {
    {
    {
#line 613
    __assert_fail("!connection->key_expire", "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c",
                  613U, "set_reexchange_timeout");
    }
    }
  }
  {
  {
#line 614
  connection->key_expire = io_callout(& timeout->super, seconds);
  }
  {
#line 617
  remember_resource(connection->resources, connection->key_expire);
  }
  }
#line 618
  return;
}
}
#line 643 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
static void do_handle_newkeys(struct packet_handler *c , struct ssh_connection *connection ,
                              struct lsh_string *packet ) 
{ 
  struct newkeys_handler *closure ;
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct kexinit *tmp___1 ;
  struct lsh_string *tmp___2 ;
  int tmp___3 ;
  struct exception *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 648
  closure = (struct newkeys_handler *)c;
  {
#line 652
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 652
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 652
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 654
  verbose("Received NEWKEYS. Key exchange finished.\n");
  }
  {
#line 656
  tmp___5 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 656
  if (tmp___5) {
#line 656
    if (msg_number == 21U) {
      {
      {
#line 656
      tmp___6 = parse_eod(& buffer);
      }
      }
#line 656
      if (tmp___6) {
        {
#line 660
        connection->rec_crypto = closure->crypto;
#line 661
        connection->rec_mac = closure->mac;
#line 662
        connection->rec_compress = closure->compression;
#line 664
        connection->read_kex_state = (enum kex_state )0;
#line 666
        tmp___1 = (struct kexinit *)((void *)0);
#line 666
        connection->kexinits[1] = tmp___1;
#line 666
        connection->kexinits[0] = tmp___1;
        {
#line 669
        lsh_string_free((struct lsh_string  const  *)connection->literal_kexinits[0]);
        }
        {
#line 670
        lsh_string_free((struct lsh_string  const  *)connection->literal_kexinits[1]);
        }
#line 672
        tmp___2 = (struct lsh_string *)((void *)0);
#line 672
        connection->literal_kexinits[1] = tmp___2;
#line 672
        connection->literal_kexinits[0] = tmp___2;
#line 680
        connection->dispatch[21] = & connection_fail_handler;
        }
#line 685
        if (((unsigned int )connection->flags & 1U) == 1U) {
#line 685
          tmp___3 = 5400;
        } else {
#line 685
          tmp___3 = 2400;
        }
        {
        {
#line 685
        set_reexchange_timeout(connection, (unsigned int )tmp___3);
        }
        {
#line 689
        gc_kill((struct lsh_object *)closure);
        }
        }
      } else {
        {
        {
#line 692
        tmp___4 = make_protocol_exception((uint32_t )2, "Invalid NEWKEYS message");
        }
        {
#line 692
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
        }
        }
      }
    } else {
      {
      {
#line 692
      tmp___4 = make_protocol_exception((uint32_t )2, "Invalid NEWKEYS message");
      }
      {
#line 692
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
      }
      }
    }
  } else {
    {
    {
#line 692
    tmp___4 = make_protocol_exception((uint32_t )2, "Invalid NEWKEYS message");
    }
    {
#line 692
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
    }
    }
  }
#line 693
  return;
}
}
#line 695 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
struct packet_handler *make_newkeys_handler(struct crypto_instance *crypto , struct mac_instance *mac ,
                                            struct compress_instance *compression ) 
{ 
  struct newkeys_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 700
  tmp = lsh_object_alloc(& newkeys_handler_class);
  }
#line 700
  self = (struct newkeys_handler *)tmp;
#line 702
  self->super.handler = & do_handle_newkeys;
#line 703
  self->crypto = crypto;
#line 704
  self->mac = mac;
#line 705
  self->compression = compression;
  }
#line 707
  return (& self->super);
}
}
#line 725 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
static struct kexinit *do_make_simple_kexinit(struct make_kexinit *c ) 
{ 
  struct simple_kexinit *closure ;
  struct kexinit *kex ;
  struct lsh_object *tmp ;

  {
  {
#line 728
  closure = (struct simple_kexinit *)c;
  {
#line 729
  tmp = lsh_object_alloc(& kexinit_class);
  }
#line 729
  kex = (struct kexinit *)tmp;
  {
#line 731
  (*((closure->r)->random))(closure->r, (uint32_t )16, kex->cookie);
  }
#line 733
  kex->kex_algorithms = closure->kex_algorithms;
#line 734
  kex->server_hostkey_algorithms = closure->hostkey_algorithms;
#line 735
  kex->parameters[0] = closure->crypto_algorithms;
#line 737
  kex->parameters[1] = closure->crypto_algorithms;
#line 739
  kex->parameters[2] = closure->mac_algorithms;
#line 740
  kex->parameters[3] = closure->mac_algorithms;
#line 741
  kex->parameters[4] = closure->compression_algorithms;
#line 743
  kex->parameters[5] = closure->compression_algorithms;
#line 745
  kex->languages_client_to_server = closure->languages;
#line 746
  kex->languages_server_to_client = closure->languages;
#line 747
  kex->first_kex_packet_follows = 0;
#line 749
  kex->first_kex_packet = (struct lsh_string *)((void *)0);
  }
#line 751
  return (kex);
}
}
#line 754 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
struct make_kexinit *make_simple_kexinit(struct randomness *r , struct int_list *kex_algorithms ,
                                         struct int_list *hostkey_algorithms , struct int_list *crypto_algorithms ,
                                         struct int_list *mac_algorithms , struct int_list *compression_algorithms ,
                                         struct int_list *languages ) 
{ 
  struct simple_kexinit *res ;
  struct lsh_object *tmp ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 763
  tmp = lsh_object_alloc(& simple_kexinit_class);
  }
#line 763
  res = (struct simple_kexinit *)tmp;
  }
#line 765
  if (! ((unsigned int )r->quality == 0U)) {
    {
    {
#line 765
    __assert_fail("r->quality == RANDOM_GOOD", "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c",
                  765U, "make_simple_kexinit");
    }
    }
  }
#line 767
  res->super.make = & do_make_simple_kexinit;
#line 768
  res->r = r;
#line 769
  res->kex_algorithms = kex_algorithms;
#line 770
  res->hostkey_algorithms = hostkey_algorithms;
#line 771
  res->crypto_algorithms = crypto_algorithms;
#line 772
  res->mac_algorithms = mac_algorithms;
#line 773
  res->compression_algorithms = compression_algorithms;
#line 774
  res->languages = languages;
#line 776
  return (& res->super);
}
}
#line 779 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
static int install_keys(struct object_list *algorithms , struct ssh_connection *connection ,
                        struct hash_instance *secret ) 
{ 
  struct crypto_instance *rec ;
  struct crypto_instance *send___0 ;
  int is_server ;
  int tmp ;
  int tmp___0 ;
  struct compress_instance *tmp___1 ;
  struct mac_instance *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 786
  is_server = (int )((unsigned int )connection->flags & 1U);
#line 788
  if (! (algorithms->super.length == 6U)) {
    {
    {
#line 788
    __assert_fail("((algorithms)->super.length) == 6", "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c",
                  788U, "install_keys");
    }
    }
  }
  {
  {
#line 790
  tmp = kex_make_decrypt(& rec, secret, algorithms, 1 ^ is_server, connection->session_id);
  }
  }
#line 790
  if (! tmp) {
#line 794
    return (0);
  }
  {
  {
#line 796
  tmp___0 = kex_make_encrypt(& send___0, secret, algorithms, is_server, connection->session_id);
  }
  }
#line 796
  if (! tmp___0) {
    {
    {
#line 800
    gc_kill((struct lsh_object *)rec);
    }
    }
#line 801
    return (0);
  }
  {
  {
#line 805
  tmp___1 = kex_make_inflate(algorithms, 5 ^ is_server);
  }
  {
#line 805
  tmp___2 = kex_make_mac(secret, algorithms, 3 ^ is_server, connection->session_id);
  }
  {
#line 805
  connection->dispatch[21] = make_newkeys_handler(rec, tmp___2, tmp___1);
  }
#line 816
  connection->send_crypto = send___0;
  {
#line 818
  connection->send_mac = kex_make_mac(secret, algorithms, 2 ^ is_server, connection->session_id);
  }
  {
#line 823
  connection->send_compress = kex_make_deflate(algorithms, 4 ^ is_server);
  }
  }
#line 827
  return (1);
}
}
#line 834 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
static struct hash_instance *kex_build_secret(struct hash_algorithm  const  *H , struct lsh_string *exchange_hash ,
                                              struct lsh_string *K___0 ) 
{ 
  struct hash_instance *hash___2 ;
  struct hash_instance *tmp ;
  struct lsh_string *s ;
  struct lsh_string *tmp___0 ;
  uint8_t const   *tmp___1 ;
  uint32_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 842
  tmp = make_hash(H);
  }
#line 842
  hash___2 = tmp;
  {
#line 843
  tmp___0 = ssh_format("%S%lS", K___0, exchange_hash);
  }
#line 843
  s = tmp___0;
  {
#line 845
  tmp___1 = lsh_string_data((struct lsh_string  const  *)s);
  }
  {
#line 845
  tmp___2 = lsh_string_length((struct lsh_string  const  *)s);
  }
  {
#line 845
  hash_update(hash___2, tmp___2, tmp___1);
  }
  {
#line 846
  lsh_string_free((struct lsh_string  const  *)s);
  }
  }
#line 848
  return (hash___2);
}
}
#line 853 "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c"
void keyexchange_finish(struct ssh_connection *connection , struct object_list *algorithms ,
                        struct hash_algorithm  const  *H , struct lsh_string *exchange_hash ,
                        struct lsh_string *K___0 ) 
{ 
  struct hash_instance *hash___2 ;
  struct lsh_string *tmp ;
  struct exception *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 865
  if (! connection->send_kex_only) {
    {
    {
#line 865
    __assert_fail("connection->send_kex_only", "/home/ysko/Works/test-src/lsh-2.0.4/src/keyexchange.c",
                  865U, "keyexchange_finish");
    }
    }
  }
  {
  {
#line 866
  tmp = ssh_format("%c", 21);
  }
  {
#line 866
  connection_send_kex(connection, tmp);
  }
  {
#line 870
  hash___2 = kex_build_secret(H, exchange_hash, K___0);
  }
  {
#line 871
  lsh_string_free((struct lsh_string  const  *)K___0);
  }
  }
#line 874
  if (! connection->session_id) {
#line 875
    connection->session_id = exchange_hash;
  } else {
    {
    {
#line 877
    lsh_string_free((struct lsh_string  const  *)exchange_hash);
    }
    }
  }
  {
  {
#line 879
  tmp___1 = install_keys(algorithms, connection, hash___2);
  }
  }
#line 879
  if (! tmp___1) {
    {
    {
#line 881
    werror("Installing new keys failed. Hanging up.\n");
    }
    {
#line 882
    gc_kill((struct lsh_object *)hash___2);
    }
    {
#line 884
    tmp___0 = make_protocol_exception((uint32_t )2, "Refusing to use weak key.");
    }
    {
#line 884
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___0);
    }
    }
#line 886
    return;
  }
  {
  {
#line 889
  gc_kill((struct lsh_object *)hash___2);
  }
  {
#line 893
  connection_send_kex_end(connection);
  }
#line 895
  connection->read_kex_state = (enum kex_state )3;
  }
#line 896
  return;
}
}
#line 199 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
struct listen_value *make_listen_value(struct lsh_fd *fd , struct address_info *peer ,
                                       struct address_info *local ) ;
#line 262
struct address_info *fd2info(struct lsh_fd *fd , int side ) ;
#line 269
struct sockaddr *address_info2sockaddr(socklen_t *length , struct address_info *a ,
                                       int const   *preference , int lookup ) ;
#line 318
struct resource *io_connect_list(struct connect_list_state *state , struct command_continuation *c ,
                                 struct exception_handler *e ) ;
#line 324
struct lsh_fd *io_connect(struct sockaddr *remote , socklen_t remote_length , struct io_callback *c ,
                          struct exception_handler *e ) ;
#line 330
struct io_callback *make_connect_callback(struct command_continuation *c ) ;
#line 347
struct lsh_fd *io_bind_local(struct local_info *info , struct exception_handler *e ) ;
#line 351
struct lsh_fd *io_connect_local(struct local_info *info , struct command_continuation *c ,
                                struct exception_handler *e ) ;
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.h"
struct command bind_local_command ;
#line 46
struct command connect_simple_command ;
#line 49
struct command connect_list_command ;
#line 52
struct command connect_local_command ;
#line 55
struct command io_log_peer_command ;
#line 59
struct command *make_tcp_wrapper(struct lsh_string *name , struct lsh_string *msg ) ;
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c.x"
struct lsh_class connect_continuation_class ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c.x"
static void do_connect_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct connect_continuation *i ;

  {
  {
#line 19
  i = (struct connect_continuation *)o;
  {
#line 20
  (*mark)((struct lsh_object *)i->target);
  }
  {
#line 21
  (*mark)((struct lsh_object *)i->up);
  }
  }
#line 22
  return;
}
}
#line 23 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c.x"
struct lsh_class connect_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"connect_continuation", (size_t )sizeof(struct connect_continuation ),
    & do_connect_continuation_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 43
struct lsh_class connect_port_class ;
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c.x"
static void do_connect_port_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct connect_port *i ;

  {
  {
#line 51
  i = (struct connect_port *)o;
  {
#line 52
  (*mark)((struct lsh_object *)i->target);
  }
  }
#line 53
  return;
}
}
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c.x"
struct lsh_class connect_port_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"connect_port", (size_t )sizeof(struct connect_port ),
    & do_connect_port_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 75
struct lsh_class tcp_wrapper_class ;
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c.x"
static void do_tcp_wrapper_free(struct lsh_object *o ) 
{ 
  struct tcp_wrapper *i ;

  {
  {
#line 82
  i = (struct tcp_wrapper *)o;
  {
#line 83
  lsh_string_free((struct lsh_string  const  *)i->name);
  }
  {
#line 84
  lsh_string_free((struct lsh_string  const  *)i->msg);
  }
  }
#line 85
  return;
}
}
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c.x"
struct lsh_class tcp_wrapper_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"tcp_wrapper", (size_t )sizeof(struct tcp_wrapper ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_tcp_wrapper_free};
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static void do_listen_command(struct command_2 *s  __attribute__((__unused__)) , struct lsh_object *a1 ,
                              struct lsh_object *a2 , struct command_continuation *c ,
                              struct exception_handler *e ) ;
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
struct command_2 listen_command  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_2}, & do_listen_command};
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static void do_listen_command(struct command_2 *s  __attribute__((__unused__)) , struct lsh_object *a1 ,
                              struct lsh_object *a2 , struct command_continuation *c ,
                              struct exception_handler *e ) 
{ 
  struct command *callback ;
  struct lsh_fd *fd ;
  int *tmp ;
  struct exception *tmp___0 ;
  struct io_callback *tmp___1 ;
  struct lsh_fd *tmp___2 ;

  {
  {
#line 67
  callback = (struct command *)a1;
#line 68
  fd = (struct lsh_fd *)a2;
  {
#line 70
  tmp___1 = make_listen_callback(callback, e);
  }
  {
#line 70
  tmp___2 = io_listen(fd, tmp___1);
  }
  }
#line 70
  if (tmp___2) {
    {
    {
#line 71
    (*(c->c))(c, (struct lsh_object *)fd);
    }
    }
  } else {
    {
    {
#line 73
    tmp = __errno_location();
    }
    {
#line 73
    tmp___0 = make_io_exception((uint32_t )8201, (struct lsh_fd *)((void *)0), *tmp,
                                (char const   *)((void *)0));
    }
    {
#line 73
    (*(e->raise))(e, (struct exception  const  *)tmp___0);
    }
    }
  }
#line 75
  return;
}
}
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static struct exception resolve_exception  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )131073, "address could not be resolved"};
#line 80
static void do_bind_address_command(struct command *self  __attribute__((__unused__)) ,
                                    struct lsh_object *x , struct command_continuation *c ,
                                    struct exception_handler *e ) ;
#line 80 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
struct command bind_address_command  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_bind_address_command};
#line 80 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static void do_bind_address_command(struct command *self  __attribute__((__unused__)) ,
                                    struct lsh_object *x , struct command_continuation *c ,
                                    struct exception_handler *e ) 
{ 
  struct address_info *a ;
  struct sockaddr *addr ;
  socklen_t addr_length ;
  struct lsh_fd *fd ;
  int *tmp ;
  struct exception *tmp___0 ;

  {
  {
#line 86
  a = (struct address_info *)x;
  {
#line 92
  addr = address_info2sockaddr(& addr_length, a, (int const   *)((void *)0), 0);
  }
  }
#line 93
  if (! addr) {
    {
    {
#line 95
    (*(e->raise))(e, (struct exception  const  *)(& resolve_exception));
    }
    }
#line 96
    return;
  }
  {
  {
#line 99
  fd = io_bind_sockaddr(addr, addr_length, e);
  }
  {
#line 100
  lsh_space_free((void const   *)addr);
  }
  }
#line 102
  if (fd) {
    {
    {
#line 103
    (*(c->c))(c, (struct lsh_object *)fd);
    }
    }
  } else {
    {
    {
#line 106
    tmp = __errno_location();
    }
    {
#line 106
    tmp___0 = make_io_exception((uint32_t )8201, (struct lsh_fd *)((void *)0), *tmp,
                                (char const   *)((void *)0));
    }
    {
#line 106
    (*(e->raise))(e, (struct exception  const  *)tmp___0);
    }
    }
  }
#line 108
  return;
}
}
#line 110
static void do_bind_local_command(struct command *self  __attribute__((__unused__)) ,
                                  struct lsh_object *x , struct command_continuation *c ,
                                  struct exception_handler *e ) ;
#line 110 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
struct command bind_local_command  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_bind_local_command};
#line 110 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static void do_bind_local_command(struct command *self  __attribute__((__unused__)) ,
                                  struct lsh_object *x , struct command_continuation *c ,
                                  struct exception_handler *e ) 
{ 
  struct local_info *info ;
  struct lsh_fd *fd ;
  struct lsh_fd *tmp ;
  int *tmp___0 ;
  struct exception *tmp___1 ;

  {
  {
#line 116
  info = (struct local_info *)x;
  {
#line 117
  tmp = io_bind_local(info, e);
  }
#line 117
  fd = tmp;
  }
#line 119
  if (fd) {
    {
    {
#line 120
    (*(c->c))(c, (struct lsh_object *)fd);
    }
    }
  } else {
    {
    {
#line 123
    tmp___0 = __errno_location();
    }
    {
#line 123
    tmp___1 = make_io_exception((uint32_t )8201, (struct lsh_fd *)((void *)0), *tmp___0,
                                (char const   *)((void *)0));
    }
    {
#line 123
    (*(e->raise))(e, (struct exception  const  *)tmp___1);
    }
    }
  }
#line 125
  return;
}
}
#line 137 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static void do_connect_continuation(struct command_continuation *c , struct lsh_object *x ) 
{ 
  struct connect_continuation *self ;
  struct lsh_fd *fd ;
  struct address_info *tmp ;
  struct listen_value *tmp___0 ;

  {
  {
#line 141
  self = (struct connect_continuation *)c;
#line 142
  fd = (struct lsh_fd *)x;
  {
#line 144
  tmp = fd2info(fd, 0);
  }
  {
#line 144
  tmp___0 = make_listen_value(fd, self->target, tmp);
  }
  {
#line 144
  (*((self->up)->c))(self->up, (struct lsh_object *)tmp___0);
  }
  }
#line 145
  return;
}
}
#line 148 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static struct command_continuation *make_connect_continuation(struct address_info *target ,
                                                              struct command_continuation *up ) 
{ 
  struct connect_continuation *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 152
  tmp = lsh_object_alloc(& connect_continuation_class);
  }
#line 152
  self = (struct connect_continuation *)tmp;
#line 153
  self->super.c = & do_connect_continuation;
#line 154
  self->target = target;
#line 155
  self->up = up;
  }
#line 157
  return (& self->super);
}
}
#line 160 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static void do_connect(struct address_info *a , struct resource_list *resources ,
                       struct command_continuation *c , struct exception_handler *e ) 
{ 
  struct sockaddr *addr ;
  socklen_t addr_length ;
  struct lsh_fd *fd ;
  struct command_continuation *tmp ;
  struct io_callback *tmp___0 ;
  int *tmp___1 ;
  struct exception *tmp___2 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 171
  if (! a->ip) {
    {
    {
#line 171
    __assert_fail("a->ip", "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c",
                  171U, "do_connect");
    }
    }
  }
  {
  {
#line 174
  addr = address_info2sockaddr(& addr_length, a, (int const   *)((void *)0), 1);
  }
  }
#line 175
  if (! addr) {
    {
    {
#line 177
    (*(e->raise))(e, (struct exception  const  *)(& resolve_exception));
    }
    }
#line 178
    return;
  }
  {
  {
#line 183
  tmp = make_connect_continuation(a, c);
  }
  {
#line 183
  tmp___0 = make_connect_callback(tmp);
  }
  {
#line 183
  fd = io_connect(addr, addr_length, tmp___0, e);
  }
  {
#line 186
  lsh_space_free((void const   *)addr);
  }
  }
#line 188
  if (! fd) {
    {
    {
#line 190
    tmp___1 = __errno_location();
    }
    {
#line 190
    tmp___2 = make_io_exception((uint32_t )8193, (struct lsh_fd *)((void *)0), *tmp___1,
                                (char const   *)((void *)0));
    }
    {
#line 190
    (*(e->raise))(e, (struct exception  const  *)tmp___2);
    }
    }
#line 191
    return;
  }
#line 194
  if (resources) {
    {
    {
#line 195
    remember_resource(resources, & fd->super);
    }
    }
  }
#line 197
  return;
}
}
#line 213 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static void do_connect_port(struct command *s , struct lsh_object *x , struct command_continuation *c ,
                            struct exception_handler *e ) 
{ 
  struct connect_port *self ;
  struct ssh_connection *connection ;

  {
  {
#line 219
  self = (struct connect_port *)s;
#line 220
  connection = (struct ssh_connection *)x;
  {
#line 222
  do_connect(self->target, connection->resources, c, e);
  }
  }
#line 223
  return;
}
}
#line 226 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
struct command *make_connect_port(struct address_info *target ) 
{ 
  struct connect_port *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 229
  tmp = lsh_object_alloc(& connect_port_class);
  }
#line 229
  self = (struct connect_port *)tmp;
#line 230
  self->super.call = & do_connect_port;
#line 231
  self->target = target;
  }
#line 233
  return (& self->super);
}
}
#line 237
static void do_connect_simple_command(struct command *self  __attribute__((__unused__)) ,
                                      struct lsh_object *a , struct command_continuation *c ,
                                      struct exception_handler *e ) ;
#line 237 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
struct command connect_simple_command  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_connect_simple_command};
#line 237 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static void do_connect_simple_command(struct command *self  __attribute__((__unused__)) ,
                                      struct lsh_object *a , struct command_continuation *c ,
                                      struct exception_handler *e ) 
{ 
  struct address_info *address ;

  {
  {
#line 243
  address = (struct address_info *)a;
  {
#line 245
  do_connect(address, (struct resource_list *)((void *)0), c, e);
  }
  }
#line 246
  return;
}
}
#line 249
static void do_connect_list_command(struct command *self  __attribute__((__unused__)) ,
                                    struct lsh_object *a , struct command_continuation *c ,
                                    struct exception_handler *e ) ;
#line 249 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
struct command connect_list_command  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_connect_list_command};
#line 249 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static void do_connect_list_command(struct command *self  __attribute__((__unused__)) ,
                                    struct lsh_object *a , struct command_continuation *c ,
                                    struct exception_handler *e ) 
{ 
  struct connect_list_state *addresses ;
  struct command_continuation *tmp ;

  {
  {
#line 255
  addresses = (struct connect_list_state *)a;
  {
#line 257
  tmp = make_connect_continuation((struct address_info *)((void *)0), c);
  }
  {
#line 257
  io_connect_list(addresses, tmp, e);
  }
  }
#line 261
  return;
}
}
#line 264
static void do_connect_connection_command(struct command_2 *self  __attribute__((__unused__)) ,
                                          struct lsh_object *a1 , struct lsh_object *a2 ,
                                          struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 264 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
struct command_2 connect_connection_command  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_2}, & do_connect_connection_command};
#line 264 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static void do_connect_connection_command(struct command_2 *self  __attribute__((__unused__)) ,
                                          struct lsh_object *a1 , struct lsh_object *a2 ,
                                          struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct ssh_connection *connection ;
  struct address_info *address ;

  {
  {
#line 271
  connection = (struct ssh_connection *)a1;
#line 272
  address = (struct address_info *)a2;
  {
#line 274
  do_connect(address, connection->resources, c, e);
  }
  }
#line 275
  return;
}
}
#line 278
static void do_connect_local_command(struct command *s  __attribute__((__unused__)) ,
                                     struct lsh_object *a , struct command_continuation *c ,
                                     struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 278 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
struct command connect_local_command  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_connect_local_command};
#line 286 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static struct exception gateway_exception  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )8193, "no usable gateway socket found"};
#line 278 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static void do_connect_local_command(struct command *s  __attribute__((__unused__)) ,
                                     struct lsh_object *a , struct command_continuation *c ,
                                     struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct local_info *info ;
  struct lsh_fd *fd ;
  struct command_continuation *tmp ;
  struct lsh_fd *tmp___0 ;

  {
  {
#line 284
  info = (struct local_info *)a;
  {
#line 289
  tmp = make_connect_continuation((struct address_info *)((void *)0), c);
  }
  {
#line 289
  tmp___0 = io_connect_local(info, tmp, e);
  }
#line 289
  fd = tmp___0;
  }
#line 293
  if (! fd) {
    {
    {
#line 294
    (*(e->raise))(e, (struct exception  const  *)(& gateway_exception));
    }
    }
  }
#line 295
  return;
}
}
#line 302
static void do_io_log_peer_command(struct command *s  __attribute__((__unused__)) ,
                                   struct lsh_object *a , struct command_continuation *c ,
                                   struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 302 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
struct command io_log_peer_command  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_io_log_peer_command};
#line 302 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static void do_io_log_peer_command(struct command *s  __attribute__((__unused__)) ,
                                   struct lsh_object *a , struct command_continuation *c ,
                                   struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct listen_value *lv ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 308
  lv = (struct listen_value *)a;
  {
#line 310
  verbose("Accepting connection from %S, port %i\n", (lv->peer)->ip, (lv->peer)->port);
  }
  {
#line 313
  (*(c->c))(c, (struct lsh_object *)lv);
  }
  }
#line 314
  return;
}
}
#line 333 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
static void do_tcp_wrapper(struct command *s  __attribute__((__unused__)) , struct lsh_object *a ,
                           struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct listen_value *lv ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 339
  lv = (struct listen_value *)a;
  {
#line 377
  verbose("Accepting connection from %S, port %i\n", (lv->peer)->ip, (lv->peer)->port);
  }
  {
#line 380
  (*(c->c))(c, (struct lsh_object *)lv);
  }
  }
#line 381
  return;
}
}
#line 385 "/home/ysko/Works/test-src/lsh-2.0.4/src/io_commands.c"
struct command *make_tcp_wrapper(struct lsh_string *name , struct lsh_string *msg ) 
{ 
  struct tcp_wrapper *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 388
  tmp = lsh_object_alloc(& tcp_wrapper_class);
  }
#line 388
  self = (struct tcp_wrapper *)tmp;
#line 389
  self->super.call = & do_tcp_wrapper;
#line 390
  self->name = name;
#line 391
  self->msg = msg;
  }
#line 393
  return (& self->super);
}
}
#line 363 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 497
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 558
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execv)(char const   *__path ,
                                                                                  char * const  *__argv ) ;
#line 626
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 58 "/usr/include/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 321 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 111
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 115
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 119
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 129
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 133
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 190
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 197
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 204
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 214
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 232
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 365 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong )  __attribute__((__const__)) ;
#line 366
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
#line 28 "/usr/local/include/oop.h"
static struct timeval  const  OOP_TIME_NOW  =    {(__time_t )0, (__suseconds_t )0};
#line 34
extern int _oop_continue ;
#line 34
extern int _oop_error ;
#line 69
extern oop_source_sys *oop_sys_new(void) ;
#line 76
extern void *oop_sys_run(oop_source_sys * ) ;
#line 83
extern void oop_sys_delete(oop_source_sys * ) ;
#line 86
extern oop_source *oop_sys_source(oop_source_sys * ) ;
#line 113
extern oop_adapter_signal *oop_signal_new(oop_source * ) ;
#line 114
extern void oop_signal_delete(oop_adapter_signal * ) ;
#line 115
extern oop_source *oop_signal_source(oop_adapter_signal * ) ;
#line 289 "/usr/include/netdb.h"
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 638
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 644
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 647
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 184 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_class io_callback_class ;
#line 67
struct lsh_class lsh_fd_class ;
#line 103
struct lsh_class io_buffered_read_class ;
#line 167
struct lsh_class address_info_class ;
#line 198
struct lsh_class local_info_class ;
#line 231
struct lsh_class listen_value_class ;
#line 265
struct lsh_class io_exception_class ;
#line 298
struct lsh_class connect_list_state_class ;
#line 122 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h"
unsigned int io_nfiles(void) ;
#line 184
struct local_info *make_local_info(struct lsh_string *directory , struct lsh_string *name ) ;
#line 225
struct exception  const  finish_io_exception ;
#line 227
void io_init(void) ;
#line 230
void io_final(void) ;
#line 233
void io_run(void) ;
#line 238
void lsh_oop_cancel_read_fd(struct lsh_fd *fd ) ;
#line 244
void lsh_oop_cancel_write_fd(struct lsh_fd *fd ) ;
#line 256
int get_portno(char const   *service , char const   *protocol ) ;
#line 265
struct address_info *sockaddr2info(size_t addr_len , struct sockaddr *addr ) ;
#line 275
unsigned int io_resolv_address(char const   *host , char const   *service , unsigned int default_port ,
                               struct addr_queue *q ) ;
#line 290
void io_set_nonblocking(int fd ) ;
#line 293
void io_init_fd(int fd , int shared ) ;
#line 299
struct exception_handler *make_exc_finish_read_handler(struct lsh_fd *fd , struct exception_handler *parent ,
                                                       char const   *context ) ;
#line 315
struct connect_list_state *make_connect_list_state(void) ;
#line 342
struct resource *io_listen_list(struct addr_queue *addresses , struct io_callback *callback ,
                                struct exception_handler *e ) ;
#line 381
void close_fd_read(struct lsh_fd *fd ) ;
#line 387
struct abstract_write *make_io_write_file(int fd , struct exception_handler *e ) ;
#line 390
struct abstract_write *io_write_file(char const   *fname , int flags , int mode ,
                                     struct exception_handler *e ) ;
#line 398
int lsh_popen(char const   *program , char const   **argv , int in , pid_t *child ) ;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.h"
void gc_global(struct resource *o ) ;
#line 38
void gc_final(void) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_class lsh_callback_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"lsh_callback", (size_t )sizeof(struct lsh_callback ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_class io_callback_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"io_callback", (size_t )sizeof(struct io_callback ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 71 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
static void do_lsh_fd_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct lsh_fd *i ;

  {
  {
#line 75
  i = (struct lsh_fd *)o;
  {
#line 76
  (*mark)((struct lsh_object *)i->e);
  }
  {
#line 77
  (*mark)((struct lsh_object *)i->close_callback);
  }
  {
#line 78
  (*mark)((struct lsh_object *)i->read);
  }
  {
#line 79
  (*mark)((struct lsh_object *)i->write);
  }
  {
#line 80
  (*mark)((struct lsh_object *)i->write_buffer);
  }
  }
#line 81
  return;
}
}
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_class lsh_fd_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & resource_class, (char *)"lsh_fd", (size_t )sizeof(struct lsh_fd ),
    & do_lsh_fd_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 107 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
static void do_io_buffered_read_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct io_buffered_read *i ;

  {
  {
#line 111
  i = (struct io_buffered_read *)o;
  {
#line 112
  (*mark)((struct lsh_object *)i->handler);
  }
  }
#line 113
  return;
}
}
#line 114 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_class io_buffered_read_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & io_callback_class, (char *)"io_buffered_read", (size_t )sizeof(struct io_buffered_read ),
    & do_io_buffered_read_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 139 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
static void do_io_consuming_read_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct io_consuming_read *i ;

  {
  {
#line 143
  i = (struct io_consuming_read *)o;
  {
#line 144
  (*mark)((struct lsh_object *)i->consumer);
  }
  }
#line 145
  return;
}
}
#line 146 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_class io_consuming_read_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & io_callback_class, (char *)"io_consuming_read", (size_t )sizeof(struct io_consuming_read ),
    & do_io_consuming_read_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 171 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
static void do_address_info_free(struct lsh_object *o ) 
{ 
  struct address_info *i ;

  {
  {
#line 174
  i = (struct address_info *)o;
  {
#line 175
  lsh_string_free((struct lsh_string  const  *)i->ip);
  }
  }
#line 176
  return;
}
}
#line 177 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_class address_info_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"address_info", (size_t )sizeof(struct address_info ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_address_info_free};
#line 202 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
static void do_local_info_free(struct lsh_object *o ) 
{ 
  struct local_info *i ;

  {
  {
#line 205
  i = (struct local_info *)o;
  {
#line 206
  lsh_string_free((struct lsh_string  const  *)i->directory);
  }
  {
#line 207
  lsh_string_free((struct lsh_string  const  *)i->name);
  }
  }
#line 208
  return;
}
}
#line 209 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_class local_info_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"local_info", (size_t )sizeof(struct local_info ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_local_info_free};
#line 235 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
static void do_listen_value_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct listen_value *i ;

  {
  {
#line 239
  i = (struct listen_value *)o;
  {
#line 240
  (*mark)((struct lsh_object *)i->fd);
  }
  {
#line 241
  (*mark)((struct lsh_object *)i->peer);
  }
  {
#line 242
  (*mark)((struct lsh_object *)i->local);
  }
  }
#line 243
  return;
}
}
#line 244 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_class listen_value_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"listen_value", (size_t )sizeof(struct listen_value ),
    & do_listen_value_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 269 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
static void do_io_exception_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct io_exception *i ;

  {
  {
#line 273
  i = (struct io_exception *)o;
  {
#line 274
  (*mark)((struct lsh_object *)i->fd);
  }
  }
#line 275
  return;
}
}
#line 276 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_class io_exception_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_class, (char *)"io_exception", (size_t )sizeof(struct io_exception ),
    & do_io_exception_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 302 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
static void do_connect_list_state_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct connect_list_state *i ;
  unsigned int k1 ;

  {
  {
#line 306
  i = (struct connect_list_state *)o;
  {
#line 307
  addr_queue_mark(& i->q, mark);
  }
#line 311
  k1 = 0U;
  }
  {
  {
#line 311
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 311
    if (! (k1 < 3U)) {
#line 311
      goto while_break;
    }
    {
    {
#line 312
    (*mark)((struct lsh_object *)i->fds[k1]);
    }
#line 311
    k1 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 314
  return;
}
}
#line 315 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
static void do_connect_list_state_free(struct lsh_object *o ) 
{ 
  struct connect_list_state *i ;

  {
  {
#line 318
  i = (struct connect_list_state *)o;
  {
#line 319
  addr_queue_free(& i->q);
  }
  }
#line 320
  return;
}
}
#line 321 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.h.x"
struct lsh_class connect_list_state_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & resource_class, (char *)"connect_list_state", (size_t )sizeof(struct connect_list_state ),
    & do_connect_list_state_mark, & do_connect_list_state_free};
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct lsh_class lsh_signal_handler_class ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
static void do_lsh_signal_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct lsh_signal_handler *i ;

  {
  {
#line 19
  i = (struct lsh_signal_handler *)o;
  {
#line 20
  (*mark)((struct lsh_object *)i->action);
  }
  }
#line 21
  return;
}
}
#line 22 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct lsh_class lsh_signal_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & resource_class, (char *)"lsh_signal_handler", (size_t )sizeof(struct lsh_signal_handler ),
    & do_lsh_signal_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 43
struct lsh_class lsh_callout_class ;
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
static void do_lsh_callout_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct lsh_callout *i ;

  {
  {
#line 51
  i = (struct lsh_callout *)o;
  {
#line 52
  (*mark)((struct lsh_object *)i->action);
  }
  }
#line 53
  return;
}
}
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct lsh_class lsh_callout_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & resource_class, (char *)"lsh_callout", (size_t )sizeof(struct lsh_callout ),
    & do_lsh_callout_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 75
struct lsh_class io_listen_callback_class ;
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
static void do_io_listen_callback_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct io_listen_callback *i ;

  {
  {
#line 83
  i = (struct io_listen_callback *)o;
  {
#line 84
  (*mark)((struct lsh_object *)i->c);
  }
  {
#line 85
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 86
  return;
}
}
#line 87 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct lsh_class io_listen_callback_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & io_callback_class, (char *)"io_listen_callback", (size_t )sizeof(struct io_listen_callback ),
    & do_io_listen_callback_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 107
struct lsh_class io_connect_callback_class ;
#line 111 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
static void do_io_connect_callback_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct io_connect_callback *i ;

  {
  {
#line 115
  i = (struct io_connect_callback *)o;
  {
#line 116
  (*mark)((struct lsh_object *)i->c);
  }
  }
#line 117
  return;
}
}
#line 118 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct lsh_class io_connect_callback_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & io_callback_class, (char *)"io_connect_callback", (size_t )sizeof(struct io_connect_callback ),
    & do_io_connect_callback_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 141
struct lsh_class connect_list_callback_class ;
#line 145 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
static void do_connect_list_callback_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct connect_list_callback *i ;

  {
  {
#line 149
  i = (struct connect_list_callback *)o;
  {
#line 150
  (*mark)((struct lsh_object *)i->state);
  }
  {
#line 151
  (*mark)((struct lsh_object *)i->c);
  }
  {
#line 152
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 153
  return;
}
}
#line 154 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct lsh_class connect_list_callback_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & io_callback_class, (char *)"connect_list_callback", (size_t )sizeof(struct connect_list_callback ),
    & do_connect_list_callback_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 175
struct lsh_class write_only_file_class ;
#line 179 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
static void do_write_only_file_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct write_only_file *i ;

  {
  {
#line 183
  i = (struct write_only_file *)o;
  {
#line 184
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 185
  return;
}
}
#line 186 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct lsh_class write_only_file_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & abstract_write_class, (char *)"write_only_file", (size_t )sizeof(struct write_only_file ),
    & do_write_only_file_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 206
struct lsh_class exc_finish_read_handler_class ;
#line 210 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
static void do_exc_finish_read_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct exc_finish_read_handler *i ;

  {
  {
#line 214
  i = (struct exc_finish_read_handler *)o;
  {
#line 215
  (*mark)((struct lsh_object *)i->fd);
  }
  }
#line 216
  return;
}
}
#line 217 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c.x"
struct lsh_class exc_finish_read_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"exc_finish_read_handler", (size_t )sizeof(struct exc_finish_read_handler ),
    & do_exc_finish_read_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static oop_source_sys *global_oop_sys  =    (oop_source_sys *)((void *)0);
#line 88 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static oop_adapter_signal *global_oop_signal  =    (oop_adapter_signal *)((void *)0);
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static oop_source *source  =    (oop_source *)((void *)0);
#line 91 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static unsigned int nfiles  =    0U;
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void *lsh_oop_signal_callback(oop_source *s  __attribute__((__unused__)) ,
                                     int sig , void *data ) 
{ 
  struct lsh_signal_handler *self ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 97
  self = (struct lsh_signal_handler *)((struct lsh_object *)data);
  {
#line 99
  trace("lsh_oop_signal_callback: Signal %i, handler: %t\n", sig, self->action);
  }
  }
#line 102
  if (! (sig == self->signum)) {
    {
    {
#line 102
    __assert_fail("sig == self->signum", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  102U, "lsh_oop_signal_callback");
    }
    }
  }
  {
  {
#line 104
  (*((self->action)->f))(self->action);
  }
  }
#line 106
  return ((void *)(& _oop_continue));
}
}
#line 109 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void lsh_oop_register_signal(struct lsh_signal_handler *handler ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 112
  trace("lsh_oop_register_signal: signal: %i, handler: %t\n", handler->signum, handler);
  }
  }
#line 115
  if (! source) {
    {
    {
#line 115
    __assert_fail("source", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 115U,
                  "lsh_oop_register_signal");
    }
    }
  }
#line 116
  if (handler->super.alive) {
    {
    {
#line 117
    (*(source->on_signal))(source, handler->signum, & lsh_oop_signal_callback, (void *)handler);
    }
    }
  }
#line 119
  return;
}
}
#line 121 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void lsh_oop_cancel_signal(struct lsh_signal_handler *handler ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 124
  trace("lsh_oop_cancel_signal: signal: %i, handler: %t\n", handler->signum, handler);
  }
  }
#line 127
  if (! source) {
    {
    {
#line 127
    __assert_fail("source", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 127U,
                  "lsh_oop_cancel_signal");
    }
    }
  }
#line 128
  if (handler->super.alive) {
    {
    {
#line 129
    (*(source->cancel_signal))(source, handler->signum, & lsh_oop_signal_callback,
                               (void *)handler);
    }
    }
  }
#line 131
  return;
}
}
#line 133 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void *lsh_oop_fd_read_callback(oop_source *s  __attribute__((__unused__)) ,
                                      int fileno___0 , oop_event event , void *data ) 
{ 
  struct lsh_fd *fd ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 137
  fd = (struct lsh_fd *)((struct lsh_object *)data);
#line 139
  if (! (fileno___0 == fd->fd)) {
    {
    {
#line 139
    __assert_fail("fileno == fd->fd", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  139U, "lsh_oop_fd_read_callback");
    }
    }
  }
#line 140
  if (! ((unsigned int )event == 0U)) {
    {
    {
#line 140
    __assert_fail("event == OOP_READ", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  140U, "lsh_oop_fd_read_callback");
    }
    }
  }
#line 141
  if (! fd->super.alive) {
    {
    {
#line 141
    __assert_fail("fd->super.alive", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  141U, "lsh_oop_fd_read_callback");
    }
    }
  }
  {
  {
#line 143
  trace("lsh_oop_fd_read_callback: fd %i: %z\n", fd->fd, fd->label);
  }
  {
#line 146
  (*((fd->read)->f))(fd->read, fd);
  }
  }
#line 148
  return ((void *)(& _oop_continue));
}
}
#line 151 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void lsh_oop_register_read_fd(struct lsh_fd *fd ) 
{ 
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
  {
#line 154
  trace("lsh_oop_register_read_fd: fd: %i, %z\n", fd->fd, fd->label);
  }
  }
#line 157
  if (! source) {
    {
    {
#line 157
    __assert_fail("source", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 157U,
                  "lsh_oop_register_read_fd");
    }
    }
  }
#line 158
  if (fd->super.alive) {
#line 158
    if (! fd->want_read) {
#line 160
      if (! fd->read) {
        {
        {
#line 160
        __assert_fail("fd->read", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                      160U, "lsh_oop_register_read_fd");
        }
        }
      }
      {
      {
#line 162
      (*(source->on_fd))(source, fd->fd, (oop_event )0, & lsh_oop_fd_read_callback,
                         (void *)fd);
      }
#line 163
      fd->want_read = 1;
      }
    }
  }
#line 165
  return;
}
}
#line 167 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void lsh_oop_cancel_read_fd(struct lsh_fd *fd ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 170
  trace("lsh_oop_cancel_read_fd: fd: %i, %z\n", fd->fd, fd->label);
  }
  }
#line 173
  if (! source) {
    {
    {
#line 173
    __assert_fail("source", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 173U,
                  "lsh_oop_cancel_read_fd");
    }
    }
  }
#line 174
  if (fd->super.alive) {
    {
    {
#line 176
    (*(source->cancel_fd))(source, fd->fd, (oop_event )0);
    }
#line 177
    fd->want_read = 0;
    }
  }
#line 179
  return;
}
}
#line 181 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void *lsh_oop_fd_write_callback(oop_source *s  __attribute__((__unused__)) ,
                                       int fileno___0 , oop_event event , void *data ) 
{ 
  struct lsh_fd *fd ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 185
  fd = (struct lsh_fd *)((struct lsh_object *)data);
#line 187
  if (! (fileno___0 == fd->fd)) {
    {
    {
#line 187
    __assert_fail("fileno == fd->fd", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  187U, "lsh_oop_fd_write_callback");
    }
    }
  }
#line 188
  if (! ((unsigned int )event == 1U)) {
    {
    {
#line 188
    __assert_fail("event == OOP_WRITE", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  188U, "lsh_oop_fd_write_callback");
    }
    }
  }
#line 189
  if (! fd->super.alive) {
    {
    {
#line 189
    __assert_fail("fd->super.alive", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  189U, "lsh_oop_fd_write_callback");
    }
    }
  }
  {
  {
#line 191
  trace("lsh_oop_fd_write_callback: fd %i: %z\n", fd->fd, fd->label);
  }
  {
#line 194
  (*((fd->write)->f))(fd->write, fd);
  }
  }
#line 196
  return ((void *)(& _oop_continue));
}
}
#line 199 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void lsh_oop_register_write_fd(struct lsh_fd *fd ) 
{ 
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
  {
#line 202
  trace("lsh_oop_register_write_fd: fd: %i, %z\n", fd->fd, fd->label);
  }
  }
#line 205
  if (! source) {
    {
    {
#line 205
    __assert_fail("source", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 205U,
                  "lsh_oop_register_write_fd");
    }
    }
  }
#line 206
  if (fd->super.alive) {
#line 206
    if (! fd->want_write) {
#line 208
      if (! fd->write) {
        {
        {
#line 208
        __assert_fail("fd->write", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                      208U, "lsh_oop_register_write_fd");
        }
        }
      }
      {
      {
#line 210
      (*(source->on_fd))(source, fd->fd, (oop_event )1, & lsh_oop_fd_write_callback,
                         (void *)fd);
      }
#line 211
      fd->want_write = 1;
      }
    }
  }
#line 213
  return;
}
}
#line 215 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void lsh_oop_cancel_write_fd(struct lsh_fd *fd ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 218
  trace("lsh_oop_cancel_write_fd: fd: %i, %z\n", fd->fd, fd->label);
  }
  }
#line 221
  if (! source) {
    {
    {
#line 221
    __assert_fail("source", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 221U,
                  "lsh_oop_cancel_write_fd");
    }
    }
  }
#line 222
  if (fd->super.alive) {
    {
    {
#line 224
    (*(source->cancel_fd))(source, fd->fd, (oop_event )1);
    }
#line 225
    fd->want_write = 0;
    }
  }
#line 227
  return;
}
}
#line 229 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void *lsh_oop_time_callback(oop_source *source___0  __attribute__((__unused__)) ,
                                   struct timeval time___0  __attribute__((__unused__)) ,
                                   void *data ) 
{ 
  struct lsh_callout *callout ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 233
  callout = (struct lsh_callout *)((struct lsh_object *)data);
#line 235
  if (! callout->super.alive) {
    {
    {
#line 235
    __assert_fail("callout->super.alive", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  235U, "lsh_oop_time_callback");
    }
    }
  }
  {
  {
#line 237
  trace("lsh_oop_time_callback: action: %t\n", callout->action);
  }
#line 240
  callout->super.alive = 0;
  {
#line 242
  (*((callout->action)->f))(callout->action);
  }
  }
#line 244
  return ((void *)(& _oop_continue));
}
}
#line 247 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void lsh_oop_register_callout(struct lsh_callout *callout ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 250
  if (! source) {
    {
    {
#line 250
    __assert_fail("source", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 250U,
                  "lsh_oop_register_callout");
    }
    }
  }
  {
  {
#line 251
  trace("lsh_oop_register_callout: action: %t\n", callout->action);
  }
  }
#line 254
  if (callout->super.alive) {
    {
    {
#line 255
    (*(source->on_time))(source, callout->when, & lsh_oop_time_callback, (void *)callout);
    }
    }
  }
#line 256
  return;
}
}
#line 258 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void lsh_oop_cancel_callout(struct lsh_callout *callout ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 261
  if (! source) {
    {
    {
#line 261
    __assert_fail("source", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 261U,
                  "lsh_oop_cancel_callout");
    }
    }
  }
  {
  {
#line 262
  trace("lsh_oop_cancel_callout: action: %t\n", callout->action);
  }
  }
#line 264
  if (callout->super.alive) {
    {
    {
#line 265
    (*(source->cancel_time))(source, callout->when, & lsh_oop_time_callback, (void *)callout);
    }
    }
  }
#line 266
  return;
}
}
#line 268 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void *lsh_oop_stop_callback(oop_source *source___0  __attribute__((__unused__)) ,
                                   struct timeval time___0  __attribute__((__unused__)) ,
                                   void *data  __attribute__((__unused__)) ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 272
  trace("lsh_oop_stop_callback\n");
  }
  }
#line 274
  if (! nfiles) {
#line 276
    return ((void *)0);
  } else {
#line 278
    return ((void *)(& _oop_continue));
  }
}
}
#line 281 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void lsh_oop_stop(void) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 284
  if (! source) {
    {
    {
#line 284
    __assert_fail("source", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 284U,
                  "lsh_oop_stop");
    }
    }
  }
  {
  {
#line 285
  trace("lsh_oop_stop\n");
  }
  {
#line 286
  (*(source->on_time))(source, (struct timeval )OOP_TIME_NOW, & lsh_oop_stop_callback,
                       (void *)0);
  }
  }
#line 287
  return;
}
}
#line 289 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void lsh_oop_cancel_stop(void) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 292
  if (! source) {
    {
    {
#line 292
    __assert_fail("source", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 292U,
                  "lsh_oop_cancel_stop");
    }
    }
  }
  {
  {
#line 293
  trace("lsh_oop_cancel_stop\n");
  }
  {
#line 294
  (*(source->cancel_time))(source, (struct timeval )OOP_TIME_NOW, & lsh_oop_stop_callback,
                           (void *)0);
  }
  }
#line 295
  return;
}
}
#line 314 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void io_init(void) 
{ 
  struct sigaction pipe___0 ;
  int tmp ;
  oop_source *tmp___0 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
  {
#line 318
  memset((void *)(& pipe___0), 0, (size_t )sizeof(pipe___0));
  }
#line 320
  pipe___0.__sigaction_handler.sa_handler = (void (*)(int  ))1;
  {
#line 321
  sigemptyset(& pipe___0.sa_mask);
  }
#line 322
  pipe___0.sa_flags = 0;
  {
#line 324
  tmp = sigaction(13, (struct sigaction  const  */* __restrict  */)((struct sigaction  const  *)(& pipe___0)),
                  (struct sigaction */* __restrict  */)((struct sigaction *)((void *)0)));
  }
  }
#line 324
  if (tmp < 0) {
    {
    {
#line 325
    fatal("Failed to ignore SIGPIPE.\n");
    }
    }
  }
#line 327
  if (! (! global_oop_sys)) {
    {
    {
#line 327
    __assert_fail("!global_oop_sys", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  327U, "io_init");
    }
    }
  }
  {
  {
#line 328
  global_oop_sys = oop_sys_new();
  }
  }
#line 329
  if (! global_oop_sys) {
    {
    {
#line 330
    fatal("Failed to initialize liboop oop_sys.\n");
    }
    }
  }
  {
  {
#line 333
  tmp___0 = oop_sys_source(global_oop_sys);
  }
  {
#line 333
  global_oop_signal = oop_signal_new(tmp___0);
  }
  }
#line 334
  if (! global_oop_signal) {
    {
    {
#line 335
    fatal("Failed to initialize liboop oop_signal.\n");
    }
    }
  }
  {
  {
#line 336
  source = oop_signal_source(global_oop_signal);
  }
  }
#line 340
  return;
}
}
#line 342 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void io_final(void) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 345
  if (! source) {
    {
    {
#line 345
    __assert_fail("source", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 345U,
                  "io_final");
    }
    }
  }
  {
  {
#line 346
  gc_final();
  }
  {
#line 350
  lsh_oop_cancel_stop();
  }
  }
#line 353
  if (! (nfiles == 0U)) {
    {
    {
#line 353
    __assert_fail("nfiles == 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 353U,
                  "io_final");
    }
    }
  }
  {
  {
#line 356
  oop_signal_delete(global_oop_signal);
  }
#line 357
  global_oop_signal = (oop_adapter_signal *)((void *)0);
  {
#line 359
  oop_sys_delete(global_oop_sys);
  }
#line 360
  global_oop_sys = (oop_source_sys *)((void *)0);
#line 361
  source = (oop_source *)((void *)0);
  }
#line 362
  return;
}
}
#line 364 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void io_run(void) 
{ 
  void *res ;
  void *tmp ;
  int *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 367
  tmp = oop_sys_run(global_oop_sys);
  }
#line 367
  res = tmp;
  }
#line 371
  if ((unsigned long )res == (unsigned long )((void *)(& _oop_error))) {
    {
    {
#line 372
    tmp___0 = __errno_location();
    }
    {
#line 372
    werror("oop_sys_run %e\n", *tmp___0);
    }
    }
  }
  {
  {
#line 374
  trace("io_run: Exiting\n");
  }
  }
#line 375
  return;
}
}
#line 398 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void do_kill_signal_handler(struct resource *s ) 
{ 
  struct lsh_signal_handler *self ;

  {
#line 401
  self = (struct lsh_signal_handler *)s;
#line 403
  if (self->super.alive) {
    {
    {
#line 405
    lsh_oop_cancel_signal(self);
    }
#line 406
    self->super.alive = 0;
    }
  }
#line 408
  return;
}
}
#line 410 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct resource *io_signal_handler(int signum , struct lsh_callback *action ) 
{ 
  struct lsh_signal_handler *handler ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 414
  tmp = lsh_object_alloc(& lsh_signal_handler_class);
  }
#line 414
  handler = (struct lsh_signal_handler *)tmp;
  {
#line 416
  init_resource(& handler->super, & do_kill_signal_handler);
  }
#line 418
  handler->signum = signum;
#line 419
  handler->action = action;
  {
#line 421
  lsh_oop_register_signal(handler);
  }
  {
#line 422
  gc_global(& handler->super);
  }
  }
#line 424
  return (& handler->super);
}
}
#line 427 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void do_kill_callout(struct resource *s ) 
{ 
  struct lsh_callout *self ;

  {
#line 430
  self = (struct lsh_callout *)s;
#line 432
  if (self->super.alive) {
    {
    {
#line 434
    lsh_oop_cancel_callout(self);
    }
#line 435
    self->super.alive = 0;
    }
  }
#line 437
  return;
}
}
#line 439 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct resource *io_callout(struct lsh_callback *action , unsigned int seconds ) 
{ 
  struct lsh_callout *self ;
  struct lsh_object *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 442
  tmp = lsh_object_alloc(& lsh_callout_class);
  }
#line 442
  self = (struct lsh_callout *)tmp;
  {
#line 443
  init_resource(& self->super, & do_kill_callout);
  }
  }
#line 445
  if (seconds) {
    {
    {
#line 449
    tmp___0 = gettimeofday((struct timeval */* __restrict  */)(& self->when), (__timezone_ptr_t )((void *)0));
    }
    }
#line 449
    if (tmp___0 < 0) {
      {
      {
#line 450
      fatal("io_callout: gettimeofday failed!\n");
      }
      }
    }
#line 451
    self->when.tv_sec += (__time_t )seconds;
  } else {
#line 454
    self->when = (struct timeval )OOP_TIME_NOW;
  }
  {
#line 456
  self->action = action;
  {
#line 458
  lsh_oop_register_callout(self);
  }
  {
#line 460
  gc_global(& self->super);
  }
  }
#line 461
  return (& self->super);
}
}
#line 466 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void do_buffered_read(struct io_callback *s , struct lsh_fd *fd ) 
{ 
  struct io_buffered_read *self ;
  uint8_t *buffer ;
  void *tmp ;
  int res ;
  int *tmp___0 ;
  int *tmp___1 ;
  struct exception *tmp___2 ;
  uint32_t left ;
  uint32_t done ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;

  {
  {
#line 470
  self = (struct io_buffered_read *)s;
  {
#line 471
  tmp = __builtin_alloca((unsigned long )self->buffer_size);
  }
#line 471
  buffer = (uint8_t *)tmp;
  }
#line 474
  if (! fd->want_read) {
    {
    {
#line 474
    __assert_fail("fd->want_read", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  474U, "do_buffered_read");
    }
    }
  }
  {
  {
#line 477
  res = read(fd->fd, (void *)buffer, self->buffer_size);
  }
  }
#line 479
  if (res < 0) {
    {
    {
#line 480
    tmp___0 = __errno_location();
    }
    }
#line 482
    if (*tmp___0 == 4) {
#line 482
      goto case_4;
    }
#line 484
    if (*tmp___0 == 11) {
#line 484
      goto case_11;
    }
#line 487
    if (*tmp___0 == 32) {
#line 487
      goto case_32;
    }
#line 491
    goto switch_default;
    case_4: 
#line 483
    goto switch_break;
    case_11: 
    {
    {
#line 485
    werror("io.c: read_callback: Unexpected EWOULDBLOCK\n");
    }
    }
#line 486
    goto switch_break;
    case_32: 
    {
    {
#line 490
    werror("Unexpected EPIPE from read.\n");
    }
    }
    switch_default: 
    {
    {
#line 492
    tmp___1 = __errno_location();
    }
    {
#line 492
    tmp___2 = make_io_exception((uint32_t )8197, fd, *tmp___1, (char const   *)((void *)0));
    }
    {
#line 492
    (*((fd->e)->raise))(fd->e, (struct exception  const  *)tmp___2);
    }
    {
#line 496
    close_fd_read(fd);
    }
    }
#line 498
    goto switch_break;
    switch_break: ;
  } else
#line 500
  if (res > 0) {
#line 502
    left = (uint32_t )res;
    {
    {
#line 504
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 504
      if (fd->super.alive) {
#line 504
        if (fd->read) {
#line 504
          if (! left) {
#line 504
            goto while_break;
          }
        } else {
#line 504
          goto while_break;
        }
      } else {
#line 504
        goto while_break;
      }
#line 526
      if (! self->handler) {
        {
        {
#line 526
        __assert_fail("self->handler", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                      526U, "do_buffered_read");
        }
        }
      }
      {
      {
#line 529
      done = (*((self->handler)->handler))(& self->handler, left, (uint8_t const   *)buffer);
      }
#line 531
      buffer += done;
#line 532
      left -= done;
      }
#line 534
      if (! fd->want_read) {
        {
        {
#line 535
        debug("do_buffered_read: want_read = 0; handler needs a pause.\n");
        }
        }
      }
#line 537
      if (fd->want_read) {
#line 537
        if (! self->handler) {
          {
          {
#line 539
          werror("do_buffered_read: Handler disappeared! Ignoring %i bytes\n", left);
          }
          {
#line 541
          lsh_oop_cancel_read_fd(fd);
          }
          }
#line 542
          return;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
#line 546
    if (left) {
      {
      {
#line 547
      verbose("read_buffered: fd died, %i buffered bytes discarded\n", left);
      }
      }
    }
  } else {
#line 553
    if (! fd->super.alive) {
      {
      {
#line 553
      __assert_fail("fd->super.alive", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                    553U, "do_buffered_read");
      }
      }
    }
#line 554
    if (! fd->read) {
      {
      {
#line 554
      __assert_fail("fd->read", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 554U,
                    "do_buffered_read");
      }
      }
    }
#line 555
    if (! fd->want_read) {
      {
      {
#line 555
      __assert_fail("fd->want_read", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                    555U, "do_buffered_read");
      }
      }
    }
#line 556
    if (! self->handler) {
      {
      {
#line 556
      __assert_fail("self->handler", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                    556U, "do_buffered_read");
      }
      }
    }
    {
    {
#line 558
    trace("io.c: do_buffered_read: EOF on fd %i: %z\n", fd->fd, fd->label);
    }
    {
#line 562
    close_fd_read(fd);
    }
    {
#line 564
    (*((self->handler)->handler))(& self->handler, (uint32_t )0, (uint8_t const   *)((void *)0));
    }
    }
  }
#line 567
  return;
}
}
#line 569 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct io_callback *make_buffered_read(uint32_t buffer_size , struct read_handler *handler ) 
{ 
  struct io_buffered_read *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 573
  tmp = lsh_object_alloc(& io_buffered_read_class);
  }
#line 573
  self = (struct io_buffered_read *)tmp;
#line 575
  self->super.f = & do_buffered_read;
#line 576
  self->buffer_size = buffer_size;
#line 577
  self->handler = handler;
  }
#line 579
  return (& self->super);
}
}
#line 582 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void do_consuming_read(struct io_callback *c , struct lsh_fd *fd ) 
{ 
  struct io_consuming_read *self ;
  uint32_t wanted ;
  uint32_t tmp ;
  struct lsh_string *s ;
  struct lsh_string *tmp___0 ;
  int res ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  struct exception *tmp___4 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 586
  self = (struct io_consuming_read *)c;
  {
#line 587
  tmp = (*(self->query))(self);
  }
#line 587
  wanted = tmp;
  }
#line 589
  if (! fd->want_read) {
    {
    {
#line 589
    __assert_fail("fd->want_read", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  589U, "do_consuming_read");
    }
    }
  }
#line 591
  if (! wanted) {
    {
    {
#line 593
    lsh_oop_cancel_read_fd(fd);
    }
    }
  } else {
    {
    {
#line 597
    tmp___0 = lsh_string_alloc(wanted);
    }
#line 597
    s = tmp___0;
    {
#line 598
    tmp___1 = lsh_string_read(s, (uint32_t )0, fd->fd, wanted);
    }
#line 598
    res = tmp___1;
    }
#line 600
    if (res < 0) {
      {
      {
#line 602
      tmp___2 = __errno_location();
      }
      }
#line 604
      if (*tmp___2 == 4) {
#line 604
        goto case_4;
      }
#line 606
      if (*tmp___2 == 11) {
#line 606
        goto case_11;
      }
#line 609
      if (*tmp___2 == 32) {
#line 609
        goto case_32;
      }
#line 615
      goto switch_default;
      case_4: 
#line 605
      goto switch_break;
      case_11: 
      {
      {
#line 607
      werror("io.c: read_consume: Unexpected EWOULDBLOCK\n");
      }
      }
#line 608
      goto switch_break;
      case_32: 
      {
      {
#line 613
      werror("io.c: read_consume: Unexpected EPIPE.\n");
      }
      }
      switch_default: 
      {
      {
#line 616
      tmp___3 = __errno_location();
      }
      {
#line 616
      tmp___4 = make_io_exception((uint32_t )8197, fd, *tmp___3, (char const   *)((void *)0));
      }
      {
#line 616
      (*((fd->e)->raise))(fd->e, (struct exception  const  *)tmp___4);
      }
      }
#line 619
      goto switch_break;
      switch_break: 
      {
      {
#line 621
      lsh_string_free((struct lsh_string  const  *)s);
      }
      }
    } else
#line 623
    if (res > 0) {
      {
      {
#line 625
      lsh_string_trunc(s, (uint32_t )res);
      }
      {
#line 626
      (*((self->consumer)->write))(self->consumer, s);
      }
      }
    } else {
      {
      {
#line 630
      trace("io.c: do_consuming_read: EOF on fd %i: %z\n", fd->fd, fd->label);
      }
      {
#line 633
      lsh_string_free((struct lsh_string  const  *)s);
      }
      {
#line 636
      (*((self->consumer)->write))(self->consumer, (struct lsh_string *)((void *)0));
      }
      {
#line 637
      close_fd_read(fd);
      }
      }
    }
  }
#line 640
  return;
}
}
#line 644 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void init_consuming_read(struct io_consuming_read *self , struct abstract_write *consumer ) 
{ 


  {
#line 647
  self->super.f = & do_consuming_read;
#line 648
  self->consumer = consumer;
#line 649
  return;
}
}
#line 653 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void do_write_callback(struct io_callback *s  __attribute__((__unused__)) ,
                              struct lsh_fd *fd ) 
{ 
  uint32_t size ;
  int res ;
  uint8_t const   *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  struct exception *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 658
  if (! fd->super.alive) {
    {
    {
#line 658
    __assert_fail("fd->super.alive", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  658U, "do_write_callback");
    }
    }
  }
  {
  {
#line 660
  tmp___4 = write_buffer_pre_write(fd->write_buffer);
  }
  }
#line 660
  if (tmp___4) {
#line 673
    if ((fd->write_buffer)->end - (fd->write_buffer)->start > (fd->write_buffer)->block_size) {
#line 673
      size = (fd->write_buffer)->block_size;
    } else {
#line 673
      size = (fd->write_buffer)->end - (fd->write_buffer)->start;
    }
#line 675
    if (! size) {
      {
      {
#line 675
      __assert_fail("size", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 675U,
                    "do_write_callback");
      }
      }
    }
    {
    {
#line 677
    tmp = lsh_string_data((struct lsh_string  const  *)(fd->write_buffer)->buffer);
    }
    {
#line 677
    res = write(fd->fd, (void const   *)(tmp + (fd->write_buffer)->start), size);
    }
    }
#line 680
    if (! res) {
      {
      {
#line 681
      fatal("Closed?");
      }
      }
    }
#line 682
    if (res < 0) {
      {
      {
#line 683
      tmp___0 = __errno_location();
      }
      }
#line 686
      if (*tmp___0 == 11) {
#line 686
        goto case_11;
      }
#line 686
      if (*tmp___0 == 4) {
#line 686
        goto case_11;
      }
#line 688
      if (*tmp___0 == 32) {
#line 688
        goto case_32;
      }
#line 692
      goto switch_default;
      case_11: 
#line 687
      goto switch_break;
      case_32: 
      {
      {
#line 689
      debug("io.c: Broken pipe.\n");
      }
      }
      switch_default: 
      {
      {
#line 700
      tmp___1 = __errno_location();
      }
      {
#line 700
      werror("io.c: write failed %e\n", *tmp___1);
      }
      {
#line 701
      tmp___2 = __errno_location();
      }
      {
#line 701
      tmp___3 = make_io_exception((uint32_t )8198, fd, *tmp___2, (char const   *)((void *)0));
      }
      {
#line 701
      (*((fd->e)->raise))(fd->e, (struct exception  const  *)tmp___3);
      }
      {
#line 704
      close_fd(fd);
      }
      }
#line 706
      goto switch_break;
      switch_break: ;
    } else {
      {
      {
#line 709
      write_buffer_consume(fd->write_buffer, (uint32_t )res);
      }
      }
    }
  } else
#line 663
  if ((fd->write_buffer)->closed) {
    {
    {
#line 664
    close_fd_write(fd);
    }
    }
  } else {
    {
    {
#line 666
    lsh_oop_cancel_write_fd(fd);
    }
    }
  }
#line 711
  return;
}
}
#line 713 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static struct io_callback io_write_callback  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_write_callback};
#line 717 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct listen_value *make_listen_value(struct lsh_fd *fd , struct address_info *peer ,
                                       struct address_info *local ) 
{ 
  struct listen_value *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 722
  tmp = lsh_object_alloc(& listen_value_class);
  }
#line 722
  self = (struct listen_value *)tmp;
#line 724
  self->fd = fd;
#line 725
  self->peer = peer;
#line 726
  self->local = local;
  }
#line 728
  return (self);
}
}
#line 745 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void do_listen_callback(struct io_callback *s , struct lsh_fd *fd ) 
{ 
  struct io_listen_callback *self ;
  struct sockaddr_storage peer ;
  socklen_t addr_len ;
  int conn ;
  int *tmp ;
  struct address_info *tmp___0 ;
  struct address_info *tmp___1 ;
  struct lsh_fd *tmp___2 ;
  struct listen_value *tmp___3 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 749
  self = (struct io_listen_callback *)s;
#line 757
  addr_len = (socklen_t )sizeof(peer);
  {
#line 760
  conn = accept(fd->fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peer)),
                (socklen_t */* __restrict  */)(& addr_len));
  }
  }
#line 762
  if (conn < 0) {
    {
    {
#line 764
    tmp = __errno_location();
    }
    {
#line 764
    werror("io.c: accept failed %e", *tmp);
    }
    }
#line 765
    return;
  }
  {
  {
#line 768
  trace("io.c: accept on fd %i\n", conn);
  }
  {
#line 769
  tmp___0 = fd2info(fd, 0);
  }
  {
#line 769
  tmp___1 = sockaddr2info(addr_len, (struct sockaddr *)(& peer));
  }
  {
#line 769
  tmp___2 = make_lsh_fd(conn, (enum io_type )0, "accepted socket", self->e);
  }
  {
#line 769
  tmp___3 = make_listen_value(tmp___2, tmp___1, tmp___0);
  }
  {
#line 769
  (*((self->c)->call))(self->c, (struct lsh_object *)tmp___3, & discard_continuation,
                       self->e);
  }
  }
#line 776
  return;
}
}
#line 778 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct io_callback *make_listen_callback(struct command *c , struct exception_handler *e ) 
{ 
  struct io_listen_callback *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 782
  tmp = lsh_object_alloc(& io_listen_callback_class);
  }
#line 782
  self = (struct io_listen_callback *)tmp;
#line 783
  self->super.f = & do_listen_callback;
#line 784
  self->c = c;
#line 785
  self->e = e;
  }
#line 787
  return (& self->super);
}
}
#line 801 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void do_connect_callback(struct io_callback *s , struct lsh_fd *fd ) 
{ 
  struct io_connect_callback *self ;
  int socket_error ;
  socklen_t len ;
  struct exception *tmp ;
  int tmp___0 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 805
  self = (struct io_connect_callback *)s;
#line 807
  len = (socklen_t )sizeof(socket_error);
  {
#line 810
  tmp___0 = getsockopt(fd->fd, 1, 4, (void */* __restrict  */)((void *)((char *)(& socket_error))),
                       (socklen_t */* __restrict  */)(& len));
  }
  }
#line 810
  if (tmp___0 < 0) {
    {
    {
#line 814
    trace("io.c: connect_callback: Connect on fd %i failed.\n", fd->fd);
    }
    {
#line 815
    tmp = make_io_exception((uint32_t )8193, fd, 0, "Connect failed.");
    }
    {
#line 815
    (*((fd->e)->raise))(fd->e, (struct exception  const  *)tmp);
    }
    {
#line 818
    close_fd(fd);
    }
    }
  } else
#line 810
  if (socket_error) {
    {
    {
#line 814
    trace("io.c: connect_callback: Connect on fd %i failed.\n", fd->fd);
    }
    {
#line 815
    tmp = make_io_exception((uint32_t )8193, fd, 0, "Connect failed.");
    }
    {
#line 815
    (*((fd->e)->raise))(fd->e, (struct exception  const  *)tmp);
    }
    {
#line 818
    close_fd(fd);
    }
    }
  } else {
    {
    {
#line 822
    trace("io.c: connect_callback: fd %i connected.\n", fd->fd);
    }
#line 823
    fd->write = (struct io_callback *)((void *)0);
    {
#line 824
    lsh_oop_cancel_write_fd(fd);
    }
#line 825
    fd->label = "connected socket";
    {
#line 826
    (*((self->c)->c))(self->c, (struct lsh_object *)fd);
    }
    }
  }
#line 828
  return;
}
}
#line 830 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct io_callback *make_connect_callback(struct command_continuation *c ) 
{ 
  struct io_connect_callback *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 833
  tmp = lsh_object_alloc(& io_connect_callback_class);
  }
#line 833
  self = (struct io_connect_callback *)tmp;
#line 835
  self->super.f = & do_connect_callback;
#line 836
  self->c = c;
  }
#line 838
  return (& self->super);
}
}
#line 847 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void do_kill_fd(struct resource *r ) 
{ 
  struct lsh_fd *fd ;

  {
#line 849
  fd = (struct lsh_fd *)r;
#line 853
  if (r->alive) {
    {
    {
#line 854
    close_fd_nicely(fd);
    }
    }
  }
#line 855
  return;
}
}
#line 859 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void do_exc_io_handler(struct exception_handler *self , struct exception  const  *x ) 
{ 
  struct io_exception *e ;

  {
#line 863
  if (x->type & 8192U) {
#line 865
    e = (struct io_exception *)x;
#line 867
    if (e->fd) {
      {
      {
#line 868
      close_fd(e->fd);
      }
      }
    }
  }
  {
  {
#line 870
  (*((self->parent)->raise))(self->parent, x);
  }
  }
#line 871
  return;
}
}
#line 878 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct exception  const  *write_raw(int fd , uint32_t length , uint8_t const   *data ) 
{ 
  int written ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  struct exception *tmp___2 ;

  {
  {
  {
#line 881
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 881
    if (! length) {
#line 881
      goto while_break;
    }
    {
    {
#line 883
    tmp = write(fd, (void const   *)data, length);
    }
#line 883
    written = tmp;
    }
#line 885
    if (written < 0) {
      {
      {
#line 886
      tmp___0 = __errno_location();
      }
      }
#line 889
      if (*tmp___0 == 11) {
#line 889
        goto case_11;
      }
#line 889
      if (*tmp___0 == 4) {
#line 889
        goto case_11;
      }
#line 891
      goto switch_default;
      case_11: 
#line 890
      goto while_continue;
      switch_default: 
      {
      {
#line 892
      tmp___1 = __errno_location();
      }
      {
#line 892
      tmp___2 = make_io_exception((uint32_t )8195, (struct lsh_fd *)((void *)0), *tmp___1,
                                  (char const   *)((void *)0));
      }
      }
#line 892
      return ((struct exception  const  *)tmp___2);

    }
#line 896
    length -= (uint32_t )written;
#line 897
    data += written;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 899
  return ((struct exception  const  *)((void *)0));
}
}
#line 903 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct exception  const  *read_raw(int fd , uint32_t length , uint8_t *data ) 
{ 
  int done ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  struct exception *tmp___2 ;
  struct exception *tmp___3 ;

  {
  {
  {
#line 906
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 906
    if (! length) {
#line 906
      goto while_break;
    }
    {
    {
#line 908
    tmp = read(fd, (void *)data, length);
    }
#line 908
    done = tmp;
    }
#line 910
    if (done < 0) {
      {
      {
#line 911
      tmp___0 = __errno_location();
      }
      }
#line 914
      if (*tmp___0 == 11) {
#line 914
        goto case_11;
      }
#line 914
      if (*tmp___0 == 4) {
#line 914
        goto case_11;
      }
#line 916
      goto switch_default;
      case_11: 
#line 915
      goto while_continue;
      switch_default: 
      {
      {
#line 917
      tmp___1 = __errno_location();
      }
      {
#line 917
      tmp___2 = make_io_exception((uint32_t )8196, (struct lsh_fd *)((void *)0), *tmp___1,
                                  (char const   *)((void *)0));
      }
      }
#line 917
      return ((struct exception  const  *)tmp___2);

    } else
#line 920
    if (done == 0) {
      {
      {
#line 924
      tmp___3 = make_io_exception((uint32_t )8196, (struct lsh_fd *)((void *)0), 0,
                                  (char const   *)((void *)0));
      }
      }
#line 924
      return ((struct exception  const  *)tmp___3);
    }
#line 928
    length -= (uint32_t )done;
#line 929
    data += done;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 931
  return ((struct exception  const  *)((void *)0));
}
}
#line 934 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct lsh_string *io_read_file_raw(int fd , uint32_t guess ) 
{ 
  struct string_buffer buffer ;
  int res ;
  uint32_t tmp ;
  int *tmp___0 ;
  struct lsh_string *tmp___1 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 938
  string_buffer_init(& buffer, guess);
  }
  }
  {
  {
#line 940
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 944
    if (! buffer.left) {
      {
      {
#line 946
      tmp = lsh_string_length((struct lsh_string  const  *)buffer.partial);
      }
      {
#line 946
      string_buffer_grow(& buffer, (tmp + buffer.total) + 100U);
      }
      }
    }
    {
    {
#line 949
    res = lsh_string_read(buffer.partial, buffer.pos, fd, buffer.left);
    }
    }
#line 952
    if (res < 0) {
      {
      {
#line 954
      tmp___0 = __errno_location();
      }
      }
#line 954
      if (*tmp___0 == 4) {
#line 955
        goto __Cont;
      }
      {
      {
#line 957
      string_buffer_clear(& buffer);
      }
      }
#line 958
      return ((struct lsh_string *)((void *)0));
    } else
#line 960
    if (! res) {
      {
      {
#line 963
      tmp___1 = string_buffer_final(& buffer, buffer.left);
      }
      }
#line 963
      return (tmp___1);
    }
#line 965
    if (! ((unsigned int )res <= buffer.left)) {
      {
      {
#line 965
      __assert_fail("(unsigned) res <= buffer.left", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                    965U, "io_read_file_raw");
      }
      }
    }
#line 967
    buffer.pos += (uint32_t )res;
#line 968
    buffer.left -= (uint32_t )res;
    __Cont: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 974
  return ((struct lsh_string *)0);
}
}
#line 978 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
int get_portno(char const   *service , char const   *protocol ) 
{ 
  char *end ;
  long portno ;
  struct servent *serv ;
  uint16_t tmp ;

  {
#line 980
  if ((unsigned long )service == (unsigned long )((void *)0)) {
#line 981
    return (0);
  } else {
    {
    {
#line 987
    portno = strtol((char const   */* __restrict  */)service, (char **/* __restrict  */)(& end),
                    10);
    }
    }
#line 988
    if (portno > 0L) {
#line 988
      if (portno <= 65535L) {
#line 988
        if ((unsigned long )end != (unsigned long )service) {
#line 988
          if ((int )*end == 0) {
#line 992
            return ((int )portno);
          } else {
#line 988
            goto _L___1;
          }
        } else {
#line 988
          goto _L___1;
        }
      } else {
#line 988
        goto _L___1;
      }
    } else {
      _L___1: 
      {
      {
#line 997
      serv = getservbyname(service, protocol);
      }
      }
#line 998
      if (! serv) {
#line 999
        return (0);
      }
      {
      {
#line 1000
      tmp = ntohs((uint16_t )serv->s_port);
      }
      }
#line 1000
      return ((int )tmp);
    }
  }
}
}
#line 1005 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct address_info *make_address_info(struct lsh_string *host , uint32_t port ) 
{ 
  struct address_info *info ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 1008
  tmp = lsh_object_alloc(& address_info_class);
  }
#line 1008
  info = (struct address_info *)tmp;
#line 1010
  info->port = port;
#line 1011
  info->ip = host;
  }
#line 1012
  return (info);
}
}
#line 1015 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct address_info *sockaddr2info(size_t addr_len , struct sockaddr *addr ) 
{ 
  struct address_info *info ;
  struct lsh_object *tmp ;
  struct sockaddr_in *in ;
  uint32_t ip ;
  uint32_t tmp___0 ;
  uint16_t tmp___1 ;
  struct sockaddr_in6 *in___0 ;
  uint16_t tmp___2 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
  {
#line 1019
  tmp = lsh_object_alloc(& address_info_class);
  }
#line 1019
  info = (struct address_info *)tmp;
  }
#line 1023
  if ((int )addr->sa_family == 2) {
#line 1023
    goto case_2;
  }
#line 1039
  if ((int )addr->sa_family == 10) {
#line 1039
    goto case_10;
  }
#line 1052
  if ((int )addr->sa_family == 1) {
#line 1052
    goto case_1;
  }
#line 1056
  goto switch_default;
  case_2: 
#line 1024
  if (! ((unsigned long )addr_len == sizeof(struct sockaddr_in ))) {
    {
    {
#line 1024
    __assert_fail("addr_len == sizeof(struct sockaddr_in)", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  1024U, "sockaddr2info");
    }
    }
  }
  {
#line 1026
  in = (struct sockaddr_in *)addr;
  {
#line 1027
  tmp___0 = ntohl(in->sin_addr.s_addr);
  }
#line 1027
  ip = tmp___0;
  {
#line 1029
  tmp___1 = ntohs(in->sin_port);
  }
#line 1029
  info->port = (uint32_t )tmp___1;
  {
#line 1030
  info->ip = ssh_format("%di.%di.%di.%di", (ip >> 24) & 255U, (ip >> 16) & 255U, (ip >> 8) & 255U,
                        ip & 255U);
  }
  }
#line 1036
  return (info);
  case_10: 
#line 1040
  if (! ((unsigned long )addr_len == sizeof(struct sockaddr_in6 ))) {
    {
    {
#line 1040
    __assert_fail("addr_len == sizeof(struct sockaddr_in6)", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  1040U, "sockaddr2info");
    }
    }
  }
  {
#line 1042
  in___0 = (struct sockaddr_in6 *)addr;
  {
#line 1044
  tmp___2 = ntohs(in___0->sin6_port);
  }
#line 1044
  info->port = (uint32_t )tmp___2;
  {
#line 1045
  info->ip = lsh_string_ntop((int )addr->sa_family, (uint32_t )46, (void const   *)(& in___0->sin6_addr));
  }
  }
#line 1049
  return (info);
  case_1: 
#line 1055
  return ((struct address_info *)((void *)0));
  switch_default: 
  {
  {
#line 1057
  werror("io.c: sockaddr2info: Unsupported address family.\n");
  }
  }
#line 1058
  return ((struct address_info *)((void *)0));

#line 1062
  return ((struct address_info *)0);
}
}
#line 1062 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct address_info *fd2info(struct lsh_fd *fd , int side ) 
{ 
  struct sockaddr_storage sock ;
  socklen_t s_len ;
  int get ;
  int *tmp ;
  struct address_info *tmp___0 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1071
  s_len = (socklen_t )sizeof(sock);
#line 1075
  if (! side) {
    {
    {
#line 1076
    get = getsockname(fd->fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sock)),
                      (socklen_t */* __restrict  */)(& s_len));
    }
    }
  } else {
    {
    {
#line 1078
    get = getpeername(fd->fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sock)),
                      (socklen_t */* __restrict  */)(& s_len));
    }
    }
  }
#line 1080
  if (get < 0) {
    {
    {
#line 1082
    tmp = __errno_location();
    }
    {
#line 1082
    werror("io.c: getXXXXname failed %e", *tmp);
    }
    }
#line 1083
    return ((struct address_info *)((void *)0));
  }
  {
  {
#line 1086
  tmp___0 = sockaddr2info(s_len, (struct sockaddr *)(& sock));
  }
  }
#line 1086
  return (tmp___0);
}
}
#line 1091 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static struct addrinfo *choose_address(struct addrinfo *list , int const   *preference ) 
{ 
  int i ;
  struct addrinfo *p ;

  {
#line 1096
  i = 0;
  {
  {
#line 1096
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 1096
    if (! *(preference + i)) {
#line 1096
      goto while_break;
    }
#line 1099
    p = list;
    {
    {
#line 1099
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 1099
      if (! p) {
#line 1099
        goto while_break___0;
      }
#line 1100
      if (*(preference + i) == (int const   )p->ai_family) {
#line 1101
        return (p);
      }
#line 1099
      p = p->ai_next;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 1096
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1103
  return ((struct addrinfo *)((void *)0));
}
}
#line 1110 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
unsigned int io_resolv_address(char const   *host , char const   *service , unsigned int default_port ,
                               struct addr_queue *q ) 
{ 
  unsigned int naddresses ;
  struct addrinfo hints ;
  struct addrinfo *list ;
  struct addrinfo *p ;
  int err ;
  struct lsh_string *port ;
  struct lsh_string *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  struct sockaddr *n ;
  struct sockaddr *tmp___2 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 1115
  naddresses = 0U;
  {
#line 1127
  memset((void *)(& hints), 0, (size_t )sizeof(hints));
  }
#line 1128
  hints.ai_family = 0;
#line 1129
  hints.ai_socktype = 1;
#line 1130
  hints.ai_flags = 1;
  }
#line 1132
  if (! service) {
    {
    {
#line 1138
    tmp = ssh_format("%di", default_port);
    }
#line 1138
    port = tmp;
    {
#line 1139
    tmp___0 = lsh_get_cstring((struct lsh_string  const  *)port);
    }
    {
#line 1139
    err = getaddrinfo((char const   */* __restrict  */)host, (char const   */* __restrict  */)tmp___0,
                      (struct addrinfo  const  */* __restrict  */)((struct addrinfo  const  *)(& hints)),
                      (struct addrinfo **/* __restrict  */)(& list));
    }
    {
#line 1140
    lsh_string_free((struct lsh_string  const  *)port);
    }
    }
  } else {
    {
    {
#line 1132
    err = getaddrinfo((char const   */* __restrict  */)host, (char const   */* __restrict  */)service,
                      (struct addrinfo  const  */* __restrict  */)((struct addrinfo  const  *)(& hints)),
                      (struct addrinfo **/* __restrict  */)(& list));
    }
    }
#line 1132
    if (err) {
      {
      {
#line 1138
      tmp = ssh_format("%di", default_port);
      }
#line 1138
      port = tmp;
      {
#line 1139
      tmp___0 = lsh_get_cstring((struct lsh_string  const  *)port);
      }
      {
#line 1139
      err = getaddrinfo((char const   */* __restrict  */)host, (char const   */* __restrict  */)tmp___0,
                        (struct addrinfo  const  */* __restrict  */)((struct addrinfo  const  *)(& hints)),
                        (struct addrinfo **/* __restrict  */)(& list));
      }
      {
#line 1140
      lsh_string_free((struct lsh_string  const  *)port);
      }
      }
    }
  }
#line 1143
  if (err) {
    {
    {
#line 1145
    tmp___1 = gai_strerror(err);
    }
    {
#line 1145
    debug("io_listen_address: getaddrinfo failed (err = %i): %z\n", err, tmp___1);
    }
    }
#line 1147
    return (0U);
  }
#line 1150
  p = list;
  {
  {
#line 1150
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 1150
    if (! p) {
#line 1150
      goto while_break;
    }
    {
    {
#line 1153
    tmp___2 = addr_queue_add_tail(q, p->ai_addrlen);
    }
#line 1153
    n = tmp___2;
    {
#line 1154
    memcpy((void */* __restrict  */)((void *)n), (void const   */* __restrict  */)((void const   *)p->ai_addr),
           p->ai_addrlen);
    }
#line 1155
    naddresses ++;
#line 1150
    p = p->ai_next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 1158
  freeaddrinfo(list);
  }
  }
#line 1231
  return (naddresses);
}
}
#line 1237 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct sockaddr *address_info2sockaddr(socklen_t *length , struct address_info *a ,
                                       int const   *preference , int lookup ) 
{ 
  char const   *host ;
  struct addrinfo hints ;
  struct addrinfo *list ;
  struct addrinfo *chosen ;
  struct sockaddr *res ;
  int default_preference[3] ;
  int err ;
  struct lsh_string *service ;
  struct lsh_string *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int const   *tmp___2 ;
  void *tmp___3 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  size_t size28 ;
  void *tmp29 ;
  void *ret_lsh_space_alloc30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 1246
  if (a->ip) {
    {
    {
#line 1248
    host = lsh_get_cstring((struct lsh_string  const  *)a->ip);
    }
    }
#line 1249
    if (! host) {
      {
      {
#line 1251
      debug("address_info2sockaddr: hostname contains NUL characters.\n");
      }
      }
#line 1252
      return ((struct sockaddr *)((void *)0));
    }
  } else {
#line 1256
    host = (char const   *)((void *)0);
  }
  {
#line 1267
  default_preference[0] = 2;
#line 1267
  default_preference[1] = 10;
#line 1267
  default_preference[2] = 0;
  {
#line 1277
  tmp = ssh_format("%di", a->port);
  }
#line 1277
  service = tmp;
  {
#line 1279
  memset((void *)(& hints), 0, (size_t )sizeof(hints));
  }
#line 1280
  hints.ai_family = 0;
#line 1281
  hints.ai_socktype = 1;
#line 1282
  hints.ai_flags = 1;
  }
#line 1284
  if (! lookup) {
#line 1285
    hints.ai_flags |= 4;
  }
  {
  {
#line 1287
  tmp___0 = lsh_get_cstring((struct lsh_string  const  *)service);
  }
  {
#line 1287
  err = getaddrinfo((char const   */* __restrict  */)host, (char const   */* __restrict  */)tmp___0,
                    (struct addrinfo  const  */* __restrict  */)((struct addrinfo  const  *)(& hints)),
                    (struct addrinfo **/* __restrict  */)(& list));
  }
  {
#line 1288
  lsh_string_free((struct lsh_string  const  *)service);
  }
  }
#line 1290
  if (err) {
    {
    {
#line 1292
    tmp___1 = gai_strerror(err);
    }
    {
#line 1292
    debug("address_info2sockaddr: getaddrinfo failed (err = %i): %z\n", err, tmp___1);
    }
    }
#line 1294
    return ((struct sockaddr *)((void *)0));
  }
#line 1297
  if (preference) {
#line 1297
    tmp___2 = preference;
  } else {
#line 1297
    tmp___2 = (int const   *)(default_preference);
  }
  {
  {
#line 1297
  chosen = choose_address(list, tmp___2);
  }
  }
#line 1299
  if (! chosen) {
    {
    {
#line 1301
    freeaddrinfo(list);
    }
    }
#line 1302
    return ((struct sockaddr *)((void *)0));
  }
  {
#line 1305
  *length = chosen->ai_addrlen;
  {
#line 1307
  size28 = *length;
  {
  {
  {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
  tmp29 = malloc(size28);
  }
  }
  {
#line 262
  ret_lsh_space_alloc30 = tmp29;
#line 262
  goto Lret_lsh_space_alloc;
  }
  }
  Lret_lsh_space_alloc: /* CIL Label */ 
#line 1307 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
  tmp___3 = ret_lsh_space_alloc30;
  }
#line 1307
  res = (struct sockaddr *)tmp___3;
  {
#line 1308
  memcpy((void */* __restrict  */)((void *)res), (void const   */* __restrict  */)((void const   *)chosen->ai_addr),
         *length);
  }
  {
#line 1309
  freeaddrinfo(list);
  }
  }
#line 1311
  return (res);
}
}
#line 1376 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void handle_nonblock_error(char const   *msg ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 1388
  tmp___1 = __errno_location();
  }
  }
#line 1388
  if (*tmp___1 == 19) {
    {
    {
#line 1389
    tmp = __errno_location();
    }
    {
#line 1389
    werror("%z %e\n", msg, *tmp);
    }
    }
  } else {
    {
    {
#line 1388
    tmp___2 = __errno_location();
    }
    }
#line 1388
    if (*tmp___2 == 25) {
      {
      {
#line 1389
      tmp = __errno_location();
      }
      {
#line 1389
      werror("%z %e\n", msg, *tmp);
      }
      }
    } else {
      {
      {
#line 1391
      tmp___0 = __errno_location();
      }
      {
#line 1391
      fatal("%z %e\n", msg, *tmp___0);
      }
      }
    }
  }
#line 1392
  return;
}
}
#line 1394 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void io_set_nonblocking(int fd ) 
{ 
  int old ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 1396
  tmp = fcntl(fd, 3);
  }
#line 1396
  old = tmp;
  }
#line 1398
  if (old < 0) {
    {
    {
#line 1399
    tmp___0 = __errno_location();
    }
    {
#line 1399
    fatal("io_set_nonblocking: fcntl(F_GETFL) failed %e\n", *tmp___0);
    }
    }
  }
  {
  {
#line 1401
  tmp___1 = fcntl(fd, 4, old | 2048);
  }
  }
#line 1401
  if (tmp___1 < 0) {
    {
    {
#line 1402
    handle_nonblock_error("io_set_nonblocking: fcntl(F_SETFL) failed");
    }
    }
  }
#line 1403
  return;
}
}
#line 1405 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void io_set_close_on_exec(int fd ) 
{ 
  int old ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 1410
  tmp = fcntl(fd, 1);
  }
#line 1410
  old = tmp;
  }
#line 1412
  if (old < 0) {
    {
    {
#line 1413
    tmp___0 = __errno_location();
    }
    {
#line 1413
    fatal("io_set_close_on_exec: fcntl(F_GETFD) failed %e\n", *tmp___0);
    }
    }
  }
  {
  {
#line 1415
  tmp___2 = fcntl(fd, 2, old | 1);
  }
  }
#line 1415
  if (tmp___2 < 0) {
    {
    {
#line 1416
    tmp___1 = __errno_location();
    }
    {
#line 1416
    fatal("Can\'t set close-on-exec flag for fd %i %e\n", fd, *tmp___1);
    }
    }
  }
#line 1417
  return;
}
}
#line 1424 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void io_init_fd(int fd , int shared ) 
{ 


  {
  {
  {
#line 1426
  io_set_close_on_exec(fd);
  }
  }
#line 1428
  if (! shared) {
    {
    {
#line 1429
    io_set_nonblocking(fd);
    }
    }
  }
#line 1430
  return;
}
}
#line 1432 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct lsh_fd *make_lsh_fd(int fd , enum io_type type , char const   *label , struct exception_handler *e ) 
{ 
  struct lsh_fd *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 1436
  tmp = lsh_object_alloc(& lsh_fd_class);
  }
#line 1436
  self = (struct lsh_fd *)tmp;
#line 1438
  nfiles ++;
  {
#line 1440
  io_init_fd(fd, (unsigned int )type >= 2U);
  }
  {
#line 1442
  init_resource(& self->super, & do_kill_fd);
  }
#line 1444
  self->fd = fd;
#line 1445
  self->type = type;
#line 1446
  self->label = label;
  {
#line 1448
  self->e = make_exception_handler(& do_exc_io_handler, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c:1448");
  }
#line 1450
  self->close_callback = (struct lsh_callback *)((void *)0);
#line 1452
  self->want_read = 0;
#line 1453
  self->read = (struct io_callback *)((void *)0);
#line 1455
  self->want_write = 0;
#line 1456
  self->write = (struct io_callback *)((void *)0);
  {
#line 1458
  gc_global(& self->super);
  }
  }
#line 1459
  return (self);
}
}
#line 1462 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
unsigned int io_nfiles(void) 
{ 


  {
#line 1465
  return (nfiles);
}
}
#line 1469 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct lsh_fd *io_connect(struct sockaddr *remote , socklen_t remote_length , struct io_callback *c ,
                          struct exception_handler *e ) 
{ 
  int s ;
  int tmp ;
  struct lsh_fd *fd ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 1475
  tmp = socket((int )remote->sa_family, 1, 0);
  }
#line 1475
  s = tmp;
  }
#line 1478
  if (s < 0) {
#line 1479
    return ((struct lsh_fd *)((void *)0));
  }
  {
  {
#line 1481
  trace("io_connect: Connecting using fd %i\n", s);
  }
  {
#line 1483
  io_init_fd(s, 0);
  }
  {
#line 1495
  tmp___2 = connect(s, (struct sockaddr  const  */* __restrict  */)((struct sockaddr  const  *)remote),
                    remote_length);
  }
  }
#line 1495
  if (tmp___2 < 0) {
    {
    {
#line 1495
    tmp___3 = __errno_location();
    }
    }
#line 1495
    if (*tmp___3 != 115) {
      {
      {
#line 1498
      tmp___0 = __errno_location();
      }
#line 1498
      saved_errno = *tmp___0;
      {
#line 1499
      close(s);
      }
      {
#line 1500
      tmp___1 = __errno_location();
      }
#line 1500
      *tmp___1 = saved_errno;
      }
#line 1501
      return ((struct lsh_fd *)((void *)0));
    }
  }
  {
  {
#line 1504
  fd = make_lsh_fd(s, (enum io_type )0, "connecting socket", e);
  }
#line 1506
  fd->write = c;
  {
#line 1507
  lsh_oop_register_write_fd(fd);
  }
  }
#line 1509
  return (fd);
}
}
#line 1513 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void do_connect_list_kill(struct resource *s ) 
{ 
  struct connect_list_state *self ;
  unsigned int i ;
  struct lsh_fd *fd ;

  {
#line 1516
  self = (struct connect_list_state *)s;
#line 1518
  if (self->super.alive) {
#line 1521
    self->super.alive = 0;
#line 1522
    i = 0U;
    {
    {
#line 1522
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 1522
      if (! (i < 3U)) {
#line 1522
        goto while_break;
      }
#line 1524
      fd = self->fds[i];
#line 1525
      if (fd) {
        {
        {
#line 1526
        (*(fd->super.kill))(& fd->super);
        }
        }
      }
#line 1522
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 1529
  return;
}
}
#line 1531 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct connect_list_state *make_connect_list_state(void) 
{ 
  struct connect_list_state *self ;
  struct lsh_object *tmp ;
  unsigned int i ;

  {
  {
  {
#line 1534
  tmp = lsh_object_alloc(& connect_list_state_class);
  }
#line 1534
  self = (struct connect_list_state *)tmp;
  {
#line 1537
  init_resource(& self->super, & do_connect_list_kill);
  }
  {
#line 1538
  lsh_queue_init(& self->q.q);
  }
#line 1539
  self->nfds = 0U;
#line 1541
  i = 0U;
  }
  {
  {
#line 1541
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 1541
    if (! (i < 3U)) {
#line 1541
      goto while_break;
    }
#line 1542
    self->fds[i] = (struct lsh_fd *)((void *)0);
#line 1541
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1544
  return (self);
}
}
#line 1558 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void connect_attempt(struct connect_list_callback *self ) 
{ 
  struct connect_list_state *state ;
  struct lsh_fd *fd ;
  socklen_t addr_length ;
  struct sockaddr *addr ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1561
  state = self->state;
#line 1566
  if (! state->super.alive) {
    {
    {
#line 1566
    __assert_fail("state->super.alive", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  1566U, "connect_attempt");
    }
    }
  }
#line 1568
  state->fds[self->index] = (struct lsh_fd *)((void *)0);
  {
  {
#line 1570
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1570
    addr = addr_queue_peek_head(& state->q, & addr_length);
    }
    }
#line 1570
    if (! addr) {
#line 1570
      goto while_break;
    }
    {
    {
#line 1572
    fd = io_connect(addr, addr_length, & self->super, self->e);
    }
    {
#line 1574
    addr_queue_remove_head(& state->q);
    }
    }
#line 1576
    if (fd) {
#line 1578
      state->fds[self->index] = fd;
#line 1579
      (state->nfds) ++;
#line 1580
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1583
  return;
}
}
#line 1585 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void do_connect_list_callback(struct io_callback *s , struct lsh_fd *fd ) 
{ 
  struct connect_list_callback *self ;
  int socket_error ;
  socklen_t len ;
  struct exception *tmp ;
  int tmp___0 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 1589
  self = (struct connect_list_callback *)s;
#line 1591
  len = (socklen_t )sizeof(socket_error);
#line 1593
  if (! (self->state)->nfds) {
    {
    {
#line 1593
    __assert_fail("self->state->nfds", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  1593U, "do_connect_list_callback");
    }
    }
  }
#line 1594
  if (! (self->index < 3U)) {
    {
    {
#line 1594
    __assert_fail("self->index < 3", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  1594U, "do_connect_list_callback");
    }
    }
  }
#line 1595
  if (! ((unsigned long )fd == (unsigned long )(self->state)->fds[self->index])) {
    {
    {
#line 1595
    __assert_fail("fd == self->state->fds[self->index]", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  1595U, "do_connect_list_callback");
    }
    }
  }
  {
  {
#line 1598
  tmp___0 = getsockopt(fd->fd, 1, 4, (void */* __restrict  */)((void *)((char *)(& socket_error))),
                       (socklen_t */* __restrict  */)(& len));
  }
  }
#line 1598
  if (tmp___0 < 0) {
#line 1598
    goto _L;
  } else
#line 1598
  if (socket_error) {
    _L: 
    {
    {
#line 1602
    trace("io.c: connect_callback: Connect on fd %i failed.\n", fd->fd);
    }
    {
#line 1603
    close_fd(fd);
    }
#line 1604
    ((self->state)->nfds) --;
    {
#line 1606
    connect_attempt(self);
    }
    }
#line 1607
    if (! (self->state)->nfds) {
      {
      {
#line 1610
      tmp = make_io_exception((uint32_t )8193, (struct lsh_fd *)((void *)0), 0, "Connect failed");
      }
      {
#line 1610
      (*((self->e)->raise))(self->e, (struct exception  const  *)tmp);
      }
      {
#line 1613
      (*((self->state)->super.kill))(& (self->state)->super);
      }
      }
#line 1614
      return;
    }
  } else {
    {
#line 1620
    (self->state)->fds[self->index] = (struct lsh_fd *)((void *)0);
    {
#line 1621
    (*((self->state)->super.kill))(& (self->state)->super);
    }
#line 1622
    fd->label = "connected socket";
    {
#line 1623
    (*((self->c)->c))(self->c, (struct lsh_object *)fd);
    }
    }
  }
#line 1625
  return;
}
}
#line 1627 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static struct connect_list_callback *make_connect_list_callback(struct connect_list_state *state ,
                                                                unsigned int index___0 ,
                                                                struct command_continuation *c ,
                                                                struct exception_handler *e ) 
{ 
  struct connect_list_callback *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 1633
  tmp = lsh_object_alloc(& connect_list_callback_class);
  }
#line 1633
  self = (struct connect_list_callback *)tmp;
#line 1635
  self->super.f = & do_connect_list_callback;
#line 1636
  self->state = state;
#line 1637
  self->index = index___0;
#line 1638
  self->c = c;
#line 1639
  self->e = e;
  }
#line 1641
  return (self);
}
}
#line 1651 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct resource *io_connect_list(struct connect_list_state *state , struct command_continuation *c ,
                                 struct exception_handler *e ) 
{ 
  unsigned int i ;
  struct connect_list_callback *tmp ;
  int tmp___0 ;
  struct exception *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1658
  i = 0U;
  {
  {
#line 1658
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1658
    tmp___0 = lsh_queue_is_empty(& state->q.q);
    }
    }
#line 1658
    if (tmp___0) {
#line 1658
      goto while_break;
    } else
#line 1658
    if (! (i < 3U)) {
#line 1658
      goto while_break;
    }
    {
    {
#line 1662
    tmp = make_connect_list_callback(state, i, c, e);
    }
    {
#line 1662
    connect_attempt(tmp);
    }
#line 1658
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1664
  if (! state->nfds) {
    {
    {
#line 1667
    tmp___1 = make_io_exception((uint32_t )8193, (struct lsh_fd *)((void *)0), 0,
                                "Connect failed");
    }
    {
#line 1667
    (*(e->raise))(e, (struct exception  const  *)tmp___1);
    }
    {
#line 1670
    (*(state->super.kill))(& state->super);
    }
    }
#line 1671
    return ((struct resource *)((void *)0));
  }
#line 1674
  return (& state->super);
}
}
#line 1678 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct lsh_fd *io_bind_sockaddr(struct sockaddr *local , socklen_t length , struct exception_handler *e ) 
{ 
  int s ;
  int tmp ;
  int yes ;
  int *tmp___0 ;
  int tmp___1 ;
  struct lsh_fd *tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 1683
  tmp = socket((int )local->sa_family, 1, 0);
  }
#line 1683
  s = tmp;
  }
#line 1685
  if (s < 0) {
#line 1686
    return ((struct lsh_fd *)((void *)0));
  }
  {
  {
#line 1688
  trace("io.c: Trying to bind fd %i\n", s);
  }
#line 1691
  yes = 1;
  {
#line 1692
  setsockopt(s, 1, 2, (void const   *)((char *)(& yes)), (socklen_t )sizeof(yes));
  }
  {
#line 1695
  tmp___1 = bind(s, (struct sockaddr  const  */* __restrict  */)((struct sockaddr  const  *)local),
                 length);
  }
  }
#line 1695
  if (tmp___1 < 0) {
    {
    {
#line 1697
    tmp___0 = __errno_location();
    }
    {
#line 1697
    trace("io.c: bind failed %e\n", *tmp___0);
    }
    {
#line 1698
    close(s);
    }
    }
#line 1699
    return ((struct lsh_fd *)((void *)0));
  }
  {
  {
#line 1702
  tmp___2 = make_lsh_fd(s, (enum io_type )0, "bound socket", e);
  }
  }
#line 1702
  return (tmp___2);
}
}
#line 1705 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct lsh_fd *io_listen(struct lsh_fd *fd , struct io_callback *callback ) 
{ 
  int tmp ;

  {
#line 1710
  if (! fd) {
#line 1711
    return ((struct lsh_fd *)((void *)0));
  }
  {
  {
#line 1713
  tmp = listen(fd->fd, 256);
  }
  }
#line 1713
  if (tmp < 0) {
    {
    {
#line 1718
    close_fd(fd);
    }
    }
#line 1719
    return ((struct lsh_fd *)((void *)0));
  }
  {
#line 1722
  fd->read = callback;
  {
#line 1723
  lsh_oop_register_read_fd(fd);
  }
  }
#line 1725
  return (fd);
}
}
#line 1728 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct resource *io_listen_list(struct addr_queue *addresses , struct io_callback *callback ,
                                struct exception_handler *e ) 
{ 
  struct resource_list *resources ;
  struct resource_list *tmp ;
  unsigned int nbound ;
  socklen_t addr_length ;
  struct sockaddr *addr ;
  struct lsh_fd *fd ;
  struct lsh_fd *tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 1733
  tmp = make_resource_list();
  }
#line 1733
  resources = tmp;
#line 1734
  nbound = 0U;
#line 1738
  nbound = 0U;
  }
  {
  {
#line 1738
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1738
    addr = addr_queue_peek_head(addresses, & addr_length);
    }
    }
#line 1738
    if (! addr) {
#line 1738
      goto while_break;
    }
    {
    {
#line 1743
    debug("listen_list: Trying to bind address of type %i\n", (int )addr->sa_family);
    }
    {
#line 1746
    fd = io_bind_sockaddr(addr, addr_length, e);
    }
    }
#line 1747
    if (fd) {
      {
      {
#line 1749
      tmp___0 = io_listen(fd, callback);
      }
      }
#line 1749
      if (tmp___0) {
        {
        {
#line 1751
        remember_resource(resources, & fd->super);
        }
#line 1752
        nbound ++;
        }
      } else {
        {
        {
#line 1755
        close_fd(fd);
        }
        }
      }
    }
    {
    {
#line 1738
    addr_queue_remove_head(addresses);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1758
  if (nbound) {
#line 1759
    return (& resources->super);
  } else {
    {
    {
#line 1762
    (*(resources->super.kill))(& resources->super);
    }
    }
#line 1763
    return ((struct resource *)((void *)0));
  }
}
}
#line 1772 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct local_info *make_local_info(struct lsh_string *directory , struct lsh_string *name ) 
{ 
  uint32_t tmp ;
  uint8_t const   *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  struct local_info *self ;
  struct lsh_object *tmp___4 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 1776
  if (! directory) {
#line 1778
    return ((struct local_info *)((void *)0));
  } else
#line 1776
  if (! name) {
#line 1778
    return ((struct local_info *)((void *)0));
  } else {
    {
    {
#line 1776
    tmp = lsh_string_length((struct lsh_string  const  *)name);
    }
    {
#line 1776
    tmp___0 = lsh_string_data((struct lsh_string  const  *)name);
    }
    {
#line 1776
    tmp___1 = memchr((void const   *)tmp___0, '/', tmp);
    }
    }
#line 1776
    if (tmp___1) {
#line 1778
      return ((struct local_info *)((void *)0));
    }
  }
  {
  {
#line 1780
  tmp___2 = lsh_get_cstring((struct lsh_string  const  *)directory);
  }
  }
#line 1780
  if (! tmp___2) {
    {
    {
#line 1780
    __assert_fail("lsh_get_cstring(directory)", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  1780U, "make_local_info");
    }
    }
  }
  {
  {
#line 1781
  tmp___3 = lsh_get_cstring((struct lsh_string  const  *)name);
  }
  }
#line 1781
  if (! tmp___3) {
    {
    {
#line 1781
    __assert_fail("lsh_get_cstring(name)", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  1781U, "make_local_info");
    }
    }
  }
  {
  {
#line 1784
  tmp___4 = lsh_object_alloc(& local_info_class);
  }
#line 1784
  self = (struct local_info *)tmp___4;
#line 1785
  self->directory = directory;
#line 1786
  self->name = name;
  }
#line 1787
  return (self);
}
}
#line 1791 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void lsh_popd(int old_cd , char const   *directory ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 1794
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1794
    tmp___1 = fchdir(old_cd);
    }
    }
#line 1794
    if (! (tmp___1 < 0)) {
#line 1794
      goto while_break;
    }
    {
    {
#line 1795
    tmp___0 = __errno_location();
    }
    }
#line 1795
    if (*tmp___0 != 4) {
      {
      {
#line 1796
      tmp = __errno_location();
      }
      {
#line 1796
      fatal("io.c: Failed to cd back from %z %e\n", directory, *tmp);
      }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 1799
  close(old_cd);
  }
  }
#line 1800
  return;
}
}
#line 1802 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
int lsh_pushd_fd(int dir ) 
{ 
  int old_cd ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 1809
  old_cd = open(".", 0);
  }
  }
#line 1810
  if (old_cd < 0) {
    {
    {
#line 1812
    werror("io.c: open(`.\') failed.\n");
    }
    }
#line 1813
    return (-1);
  }
  {
  {
#line 1816
  io_set_close_on_exec(old_cd);
  }
  }
  {
  {
#line 1819
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1819
    tmp___1 = fchdir(old_cd);
    }
    }
#line 1819
    if (! (tmp___1 < 0)) {
#line 1819
      goto while_break;
    }
    {
    {
#line 1820
    tmp___0 = __errno_location();
    }
    }
#line 1820
    if (*tmp___0 != 4) {
      {
      {
#line 1822
      tmp = __errno_location();
      }
      {
#line 1822
      werror("io.c: fchdir(`.\') failed %e\n", *tmp);
      }
      {
#line 1823
      close(old_cd);
      }
      }
#line 1824
      return (-1);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 1832
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 1832
    tmp___3 = fchdir(dir);
    }
    }
#line 1832
    if (! (tmp___3 < 0)) {
#line 1832
      goto while_break___0;
    }
    {
    {
#line 1833
    tmp___2 = __errno_location();
    }
    }
#line 1833
    if (*tmp___2 != 4) {
      {
      {
#line 1835
      close(old_cd);
      }
      }
#line 1836
      return (-1);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 1839
  return (old_cd);
}
}
#line 1844 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
int lsh_pushd(char const   *directory , int *result , int create , int secret ) 
{ 
  int old_cd ;
  int fd ;
  struct stat sbuf ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
#line 1855
  if (create) {
    {
    {
#line 1858
    tmp___0 = mkdir(directory, (__mode_t )448);
    }
    }
#line 1858
    if (tmp___0 < 0) {
      {
      {
#line 1858
      tmp___1 = __errno_location();
      }
      }
#line 1858
      if (*tmp___1 != 17) {
        {
        {
#line 1861
        tmp = __errno_location();
        }
        {
#line 1861
        werror("io.c: Creating directory %z failed %e\n", directory, *tmp);
        }
        }
      }
    }
  }
  {
  {
#line 1866
  fd = open(directory, 0);
  }
  }
#line 1867
  if (fd < 0) {
#line 1868
    return (-1);
  }
  {
  {
#line 1870
  tmp___3 = fstat(fd, & sbuf);
  }
  }
#line 1870
  if (tmp___3 < 0) {
    {
    {
#line 1872
    tmp___2 = __errno_location();
    }
    {
#line 1872
    werror("io.c: Failed to stat `%z\'.\n  %e\n", directory, *tmp___2);
    }
    }
#line 1874
    return (-1);
  }
#line 1877
  if (! ((sbuf.st_mode & 61440U) == 16384U)) {
    {
    {
#line 1879
    close(fd);
    }
    }
#line 1880
    return (-1);
  }
#line 1883
  if (secret) {
    {
    {
#line 1886
    tmp___4 = getuid();
    }
    }
#line 1886
    if (sbuf.st_uid != tmp___4) {
      {
      {
#line 1888
      werror("io.c: Socket directory %z not owned by user.\n", directory);
      }
      {
#line 1890
      close(fd);
      }
      }
#line 1891
      return (-1);
    }
#line 1894
    if (sbuf.st_mode & (unsigned int )((448 >> 3) | ((448 >> 3) >> 3))) {
      {
      {
#line 1896
      werror("io.c: Permission bits on %z are too loose.\n", directory);
      }
      {
#line 1898
      close(fd);
      }
      }
#line 1899
      return (-1);
    }
  }
  {
  {
#line 1905
  old_cd = open(".", 0);
  }
  }
#line 1906
  if (old_cd < 0) {
    {
    {
#line 1908
    werror("io.c: open(\'.\') failed.\n");
    }
    {
#line 1910
    close(fd);
    }
    }
#line 1911
    return (-1);
  }
  {
  {
#line 1914
  io_set_close_on_exec(old_cd);
  }
  }
  {
  {
#line 1917
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1917
    tmp___7 = fchdir(old_cd);
    }
    }
#line 1917
    if (! (tmp___7 < 0)) {
#line 1917
      goto while_break;
    }
    {
    {
#line 1918
    tmp___6 = __errno_location();
    }
    }
#line 1918
    if (*tmp___6 != 4) {
      {
      {
#line 1920
      tmp___5 = __errno_location();
      }
      {
#line 1920
      werror("io.c: fchdir(\".\") failed %e\n", *tmp___5);
      }
      {
#line 1921
      close(fd);
      }
      {
#line 1922
      close(old_cd);
      }
      }
#line 1923
      return (-1);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
  {
#line 1931
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 1931
    tmp___8 = fchdir(fd);
    }
    }
#line 1931
    if (! (tmp___8 < 0)) {
#line 1931
      goto while_break___0;
    }
    {
    {
#line 1933
    close(fd);
    }
    {
#line 1934
    close(old_cd);
    }
    }
#line 1935
    return (-1);
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 1938
  if (result) {
#line 1939
    *result = fd;
  } else {
    {
    {
#line 1941
    close(fd);
    }
    }
  }
#line 1943
  return (old_cd);
}
}
#line 1947 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct lsh_fd *io_bind_local(struct local_info *info , struct exception_handler *e ) 
{ 
  int old_cd ;
  mode_t old_umask ;
  struct sockaddr_un *local ;
  socklen_t local_length ;
  struct lsh_fd *fd ;
  char const   *cdir ;
  char const   *tmp ;
  char const   *cname ;
  char const   *tmp___0 ;
  uint32_t length ;
  uint32_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
  {
  {
#line 1959
  tmp = lsh_get_cstring((struct lsh_string  const  *)info->directory);
  }
#line 1959
  cdir = tmp;
  {
#line 1960
  tmp___0 = lsh_get_cstring((struct lsh_string  const  *)info->name);
  }
#line 1960
  cname = tmp___0;
  {
#line 1961
  tmp___1 = lsh_string_length((struct lsh_string  const  *)info->name);
  }
#line 1961
  length = tmp___1;
  }
#line 1963
  if (! cdir) {
    {
    {
#line 1963
    __assert_fail("cdir", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 1963U, "io_bind_local");
    }
    }
  }
#line 1964
  if (! cname) {
    {
    {
#line 1964
    __assert_fail("cname", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 1964U,
                  "io_bind_local");
    }
    }
  }
  {
  {
#line 1968
  tmp___2 = memchr((void const   *)cname, '/', length);
  }
  }
#line 1968
  if (tmp___2) {
    {
    {
#line 1968
    __assert_fail("!memchr(cname, \'/\', length)", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  1968U, "io_bind_local");
    }
    }
  }
  {
#line 1970
  local_length = (socklen_t )((unsigned long )(& ((struct sockaddr_un *)0)->sun_path) + (unsigned long )length);
  {
#line 1971
  tmp___3 = __builtin_alloca((unsigned long )(local_length + 1U));
  }
#line 1971
  local = (struct sockaddr_un *)tmp___3;
#line 1973
  local->sun_family = (sa_family_t )1;
  {
#line 1974
  memcpy((void */* __restrict  */)((void *)(local->sun_path)), (void const   */* __restrict  */)((void const   *)cname),
         length);
  }
#line 1975
  local->sun_path[length] = (char)0;
  {
#line 1979
  old_cd = lsh_pushd(cdir, (int *)((void *)0), 1, 1);
  }
  }
#line 1980
  if (old_cd < 0) {
#line 1981
    return ((struct lsh_fd *)((void *)0));
  }
  {
  {
#line 1987
  tmp___5 = unlink(cname);
  }
  }
#line 1987
  if (tmp___5 < 0) {
    {
    {
#line 1987
    tmp___6 = __errno_location();
    }
    }
#line 1987
    if (*tmp___6 != 2) {
      {
      {
#line 1990
      tmp___4 = __errno_location();
      }
      {
#line 1990
      werror("io.c: unlink \'%S\'/\'%S\' failed %e\n", info->directory, info->name,
             *tmp___4);
      }
      {
#line 1992
      lsh_popd(old_cd, cdir);
      }
      }
#line 1993
      return ((struct lsh_fd *)((void *)0));
    }
  }
  {
  {
#line 1999
  old_umask = umask((__mode_t )63);
  }
  {
#line 2002
  fd = io_bind_sockaddr((struct sockaddr *)local, local_length, e);
  }
  {
#line 2006
  umask(old_umask);
  }
  {
#line 2008
  lsh_popd(old_cd, cdir);
  }
  }
#line 2010
  return (fd);
}
}
#line 2014 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct lsh_fd *io_connect_local(struct local_info *info , struct command_continuation *c ,
                                struct exception_handler *e ) 
{ 
  int old_cd ;
  struct sockaddr_un *addr ;
  socklen_t addr_length ;
  struct lsh_fd *fd ;
  char const   *cdir ;
  char const   *tmp ;
  char const   *cname ;
  char const   *tmp___0 ;
  uint32_t length ;
  uint32_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  struct io_callback *tmp___4 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
  {
#line 2026
  tmp = lsh_get_cstring((struct lsh_string  const  *)info->directory);
  }
#line 2026
  cdir = tmp;
  {
#line 2027
  tmp___0 = lsh_get_cstring((struct lsh_string  const  *)info->name);
  }
#line 2027
  cname = tmp___0;
  {
#line 2028
  tmp___1 = lsh_string_length((struct lsh_string  const  *)info->name);
  }
#line 2028
  length = tmp___1;
  }
#line 2030
  if (! cname) {
    {
    {
#line 2030
    __assert_fail("cname", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 2030U,
                  "io_connect_local");
    }
    }
  }
#line 2031
  if (! cdir) {
    {
    {
#line 2031
    __assert_fail("cdir", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 2031U, "io_connect_local");
    }
    }
  }
  {
  {
#line 2035
  tmp___2 = memchr((void const   *)cname, '/', length);
  }
  }
#line 2035
  if (tmp___2) {
    {
    {
#line 2035
    __assert_fail("!memchr(cname, \'/\', length)", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  2035U, "io_connect_local");
    }
    }
  }
  {
#line 2037
  addr_length = (socklen_t )((unsigned long )(& ((struct sockaddr_un *)0)->sun_path) + (unsigned long )length);
  {
#line 2038
  tmp___3 = __builtin_alloca((unsigned long )addr_length);
  }
#line 2038
  addr = (struct sockaddr_un *)tmp___3;
#line 2040
  addr->sun_family = (sa_family_t )1;
  {
#line 2041
  memcpy((void */* __restrict  */)((void *)(addr->sun_path)), (void const   */* __restrict  */)((void const   *)cname),
         length);
  }
  {
#line 2045
  old_cd = lsh_pushd(cdir, (int *)((void *)0), 0, 1);
  }
  }
#line 2046
  if (old_cd < 0) {
#line 2047
    return ((struct lsh_fd *)((void *)0));
  }
  {
  {
#line 2049
  tmp___4 = make_connect_callback(c);
  }
  {
#line 2049
  fd = io_connect((struct sockaddr *)addr, addr_length, tmp___4, e);
  }
  {
#line 2052
  lsh_popd(old_cd, cdir);
  }
  }
#line 2054
  return (fd);
}
}
#line 2059 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct lsh_fd *io_read_write(struct lsh_fd *fd , struct io_callback *read___0 , uint32_t block_size ,
                             struct lsh_callback *close_callback ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 2065
  trace("io.c: Preparing fd %i for reading and writing\n", fd->fd);
  }
#line 2069
  fd->read = read___0;
  }
#line 2070
  if (read___0) {
    {
    {
#line 2071
    lsh_oop_register_read_fd(fd);
    }
    }
  }
  {
  {
#line 2074
  fd->write_buffer = make_write_buffer(fd, block_size);
  }
#line 2075
  fd->write = & io_write_callback;
#line 2078
  fd->close_callback = close_callback;
  }
#line 2080
  return (fd);
}
}
#line 2083 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct lsh_fd *io_read(struct lsh_fd *fd , struct io_callback *read___0 , struct lsh_callback *close_callback ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 2088
  trace("io.c: Preparing fd %i for reading\n", fd->fd);
  }
#line 2091
  fd->read = read___0;
  }
#line 2092
  if (fd->read) {
    {
    {
#line 2093
    lsh_oop_register_read_fd(fd);
    }
    }
  }
#line 2095
  fd->close_callback = close_callback;
#line 2097
  return (fd);
}
}
#line 2100 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct lsh_fd *io_write(struct lsh_fd *fd , uint32_t block_size , struct lsh_callback *close_callback ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 2105
  trace("io.c: Preparing fd %i for writing\n", fd->fd);
  }
  {
#line 2108
  fd->write_buffer = make_write_buffer(fd, block_size);
  }
#line 2109
  fd->write = & io_write_callback;
#line 2111
  fd->close_callback = close_callback;
  }
#line 2113
  return (fd);
}
}
#line 2126 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void do_write_only_file(struct abstract_write *s , struct lsh_string *data ) 
{ 
  struct write_only_file *self ;
  struct exception  const  *e ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 2129
  self = (struct write_only_file *)s;
  {
#line 2132
  tmp = lsh_string_data((struct lsh_string  const  *)data);
  }
  {
#line 2132
  tmp___0 = lsh_string_length((struct lsh_string  const  *)data);
  }
  {
#line 2132
  e = write_raw(self->fd, tmp___0, tmp);
  }
  }
#line 2134
  if (e) {
    {
    {
#line 2135
    (*((self->e)->raise))(self->e, e);
    }
    }
  }
  {
  {
#line 2137
  lsh_string_free((struct lsh_string  const  *)data);
  }
  }
#line 2138
  return;
}
}
#line 2140 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct abstract_write *make_io_write_file(int fd , struct exception_handler *e ) 
{ 
  struct write_only_file *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 2143
  tmp = lsh_object_alloc(& write_only_file_class);
  }
#line 2143
  self = (struct write_only_file *)tmp;
#line 2144
  self->super.write = & do_write_only_file;
#line 2145
  self->fd = fd;
#line 2146
  self->e = e;
  }
#line 2148
  return (& self->super);
}
}
#line 2151 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct abstract_write *io_write_file(char const   *fname , int flags , int mode ,
                                     struct exception_handler *e ) 
{ 
  int fd ;
  int tmp ;
  struct abstract_write *tmp___0 ;

  {
  {
  {
#line 2155
  tmp = open(fname, flags, mode);
  }
#line 2155
  fd = tmp;
  }
#line 2156
  if (fd < 0) {
#line 2157
    return ((struct abstract_write *)((void *)0));
  }
  {
  {
#line 2159
  io_set_close_on_exec(fd);
  }
  {
#line 2161
  tmp___0 = make_io_write_file(fd, e);
  }
  }
#line 2161
  return (tmp___0);
}
}
#line 2164 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void close_fd(struct lsh_fd *fd ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  struct exception *tmp___1 ;
  int tmp___2 ;
  int null ;
  int tmp___3 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
  {
#line 2167
  trace("io.c: Closing fd %i: %z, type %i.\n", fd->fd, fd->label, (unsigned int )fd->type);
  }
  }
#line 2170
  if (fd->super.alive) {
    {
    {
#line 2172
    lsh_oop_cancel_read_fd(fd);
    }
    {
#line 2173
    lsh_oop_cancel_write_fd(fd);
    }
#line 2175
    fd->super.alive = 0;
    }
#line 2179
    if (! (fd->fd >= 0)) {
      {
      {
#line 2179
      __assert_fail("fd->fd >= 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                    2179U, "close_fd");
      }
      }
    }
#line 2183
    if (fd->write_buffer) {
#line 2184
      (fd->write_buffer)->closed = 1;
    }
#line 2186
    if (fd->close_callback) {
      {
      {
#line 2187
      (*((fd->close_callback)->f))(fd->close_callback);
      }
      }
    }
#line 2189
    if ((unsigned int )fd->type != 3U) {
      {
      {
#line 2191
      tmp___2 = close(fd->fd);
      }
      }
#line 2191
      if (tmp___2 < 0) {
        {
        {
#line 2193
        tmp = __errno_location();
        }
        {
#line 2193
        werror("io.c: close failed %e\n", *tmp);
        }
        {
#line 2194
        tmp___0 = __errno_location();
        }
        {
#line 2194
        tmp___1 = make_io_exception((uint32_t )8202, fd, *tmp___0, (char const   *)((void *)0));
        }
        {
#line 2194
        (*((fd->e)->raise))(fd->e, (struct exception  const  *)tmp___1);
        }
        }
      }
#line 2198
      if ((unsigned int )fd->type == 2U) {
        {
        {
#line 2200
        tmp___3 = open("/dev/null", 2);
        }
#line 2200
        null = tmp___3;
        }
#line 2201
        if (null < 0) {
          {
          {
#line 2202
          fatal("Failed to open /dev/null!\n");
          }
          }
        }
#line 2203
        if (null != fd->fd) {
          {
          {
#line 2204
          fatal("Failed to map stdio fd %i to /dev/null.\n", fd->fd);
          }
          }
        }
      }
    }
#line 2207
    if (! nfiles) {
      {
      {
#line 2207
      __assert_fail("nfiles", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 2207U,
                    "close_fd");
      }
      }
    }
#line 2208
    nfiles --;
#line 2208
    if (! nfiles) {
      {
      {
#line 2209
      lsh_oop_stop();
      }
      }
    }
  } else {
    {
    {
#line 2212
    werror("Closed already.\n");
    }
    }
  }
#line 2213
  return;
}
}
#line 2215 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void close_fd_nicely(struct lsh_fd *fd ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 2221
  trace("io.c: close_fd_nicely called on fd %i: %z\n", fd->fd, fd->label);
  }
#line 2225
  fd->read = (struct io_callback *)((void *)0);
  {
#line 2226
  lsh_oop_cancel_read_fd(fd);
  }
  }
#line 2228
  if (fd->write_buffer) {
    {
    {
#line 2230
    close_fd_write(fd);
    }
    }
  } else {
    {
    {
#line 2233
    close_fd(fd);
    }
    }
  }
#line 2234
  return;
}
}
#line 2237 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void close_fd_read(struct lsh_fd *fd ) 
{ 


  {
  {
#line 2240
  fd->read = (struct io_callback *)((void *)0);
  {
#line 2242
  lsh_oop_cancel_read_fd(fd);
  }
  }
#line 2244
  if (! fd->write) {
    {
    {
#line 2246
    close_fd(fd);
    }
    }
  }
#line 2247
  return;
}
}
#line 2250 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
void close_fd_write(struct lsh_fd *fd ) 
{ 
  struct lsh_string *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 2253
  trace("io.c: close_fd_write called on fd %i: %z\n", fd->fd, fd->label);
  }
  }
#line 2256
  if (fd->write_buffer) {
#line 2259
    (fd->write_buffer)->closed = 1;
#line 2261
    if ((unsigned int )fd->type == 1U) {
      {
      {
#line 2263
      debug("Writing ^D to pty.\n");
      }
      {
#line 2266
      tmp = ssh_format("%lc", 4);
      }
      {
#line 2266
      (*((fd->write_buffer)->super.write))(& (fd->write_buffer)->super, tmp);
      }
#line 2270
      fd->type = (enum io_type )0;
      }
    }
#line 2273
    if ((fd->write_buffer)->empty) {
#line 2275
      if (! fd->read) {
        {
        {
#line 2276
        close_fd(fd);
        }
        }
      } else {
        {
#line 2281
        fd->write = (struct io_callback *)((void *)0);
        {
#line 2282
        lsh_oop_cancel_write_fd(fd);
        }
        {
#line 2285
        tmp___1 = shutdown(fd->fd, 1);
        }
        }
#line 2285
        if (tmp___1 < 0) {
          {
          {
#line 2285
          tmp___2 = __errno_location();
          }
          }
#line 2285
          if (*tmp___2 != 88) {
            {
            {
#line 2287
            tmp___0 = __errno_location();
            }
            {
#line 2287
            werror("close_fd_write, shutdown failed, %e\n", *tmp___0);
            }
            }
          }
        }
      }
    }
  } else
#line 2292
  if (! fd->read) {
    {
    {
#line 2293
    close_fd(fd);
    }
    }
  }
#line 2294
  return;
}
}
#line 2308 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
static void do_exc_finish_read_handler(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct exc_finish_read_handler *self ;

  {
#line 2312
  self = (struct exc_finish_read_handler *)s;
#line 2315
  if (e->type == 65538U) {
#line 2315
    goto case_65538;
  }
#line 2318
  if (e->type == 65539U) {
#line 2318
    goto case_65539;
  }
#line 2321
  if (e->type == 1048577U) {
#line 2321
    goto case_1048577;
  }
#line 2324
  if (e->type == 1048578U) {
#line 2324
    goto case_1048578;
  }
#line 2328
  goto switch_default;
  case_65538: 
  {
  {
#line 2316
  close_fd_nicely(self->fd);
  }
  }
#line 2317
  goto switch_break;
  case_65539: 
  {
  {
#line 2319
  close_fd(self->fd);
  }
  }
#line 2320
  goto switch_break;
  case_1048577: 
  {
  {
#line 2322
  lsh_oop_cancel_read_fd(self->fd);
  }
  }
#line 2323
  goto switch_break;
  case_1048578: 
#line 2325
  if ((self->fd)->read) {
    {
    {
#line 2326
    lsh_oop_register_read_fd(self->fd);
    }
    }
  }
#line 2327
  goto switch_break;
  switch_default: 
  {
  {
#line 2329
  (*((self->super.parent)->raise))(self->super.parent, e);
  }
  }
  switch_break: ;
#line 2331
  return;
}
}
#line 2333 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct exception_handler *make_exc_finish_read_handler(struct lsh_fd *fd , struct exception_handler *parent ,
                                                       char const   *context ) 
{ 
  struct exc_finish_read_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 2338
  tmp = lsh_object_alloc(& exc_finish_read_handler_class);
  }
#line 2338
  self = (struct exc_finish_read_handler *)tmp;
#line 2340
  self->super.parent = parent;
#line 2341
  self->super.raise = & do_exc_finish_read_handler;
#line 2342
  self->super.context = context;
#line 2344
  self->fd = fd;
  }
#line 2346
  return (& self->super);
}
}
#line 2349 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct exception  const  finish_read_exception  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )65538, "Stop reading"};
#line 2352 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct exception  const  finish_io_exception  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )65539, "Stop i/o"};
#line 2355 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct exception *make_io_exception(uint32_t type , struct lsh_fd *fd , int error ,
                                    char const   *msg ) 
{ 
  struct io_exception *self ;
  struct lsh_object *tmp ;
  char *tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 2358
  tmp = lsh_object_alloc(& io_exception_class);
  }
#line 2358
  self = (struct io_exception *)tmp;
  }
#line 2359
  if (! (type & 8192U)) {
    {
    {
#line 2359
    __assert_fail("type & 0x2000", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                  2359U, "make_io_exception");
    }
    }
  }
#line 2361
  self->super.type = type;
#line 2363
  if (msg) {
#line 2364
    self->super.msg = msg;
  } else
#line 2366
  if (error) {
    {
    {
#line 2366
    tmp___0 = strerror(error);
    }
#line 2366
    self->super.msg = (char const   *)tmp___0;
    }
  } else {
#line 2366
    self->super.msg = "Unknown i/o error";
  }
#line 2368
  self->error = error;
#line 2369
  self->fd = fd;
#line 2371
  return (& self->super);
}
}
#line 2378 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
int lsh_make_pipe(int *fds ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int saved_errno ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
  {
#line 2381
  tmp___0 = socketpair(1, 1, 0, fds);
  }
  }
#line 2381
  if (tmp___0 < 0) {
    {
    {
#line 2383
    tmp = __errno_location();
    }
    {
#line 2383
    werror("socketpair failed %e\n", *tmp);
    }
    }
#line 2384
    return (0);
  }
  {
  {
#line 2386
  trace("Created socket pair. Using fd:s %i <-- %i\n", *(fds + 0), *(fds + 1));
  }
  {
#line 2388
  tmp___2 = shutdown(*(fds + 0), 1);
  }
  }
#line 2388
  if (tmp___2 < 0) {
    {
    {
#line 2390
    tmp___1 = __errno_location();
    }
    {
#line 2390
    werror("shutdown(%i, SHUT_WR) failed %e\n", *(fds + 0), *tmp___1);
    }
    }
#line 2391
    goto fail;
  }
  {
  {
#line 2393
  tmp___6 = shutdown(*(fds + 1), 0);
  }
  }
#line 2393
  if (tmp___6 < 0) {
    {
    {
#line 2395
    tmp___3 = __errno_location();
    }
    {
#line 2395
    werror("shutdown(%i, SHUT_RD_UNIX) failed %e\n", *(fds + 0), *tmp___3);
    }
    }
    fail: 
    {
    {
#line 2398
    tmp___4 = __errno_location();
    }
#line 2398
    saved_errno = *tmp___4;
    {
#line 2400
    close(*(fds + 0));
    }
    {
#line 2401
    close(*(fds + 1));
    }
    {
#line 2403
    tmp___5 = __errno_location();
    }
#line 2403
    *tmp___5 = saved_errno;
    }
#line 2404
    return (0);
  }
#line 2408
  return (1);
}
}
#line 2413 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
int lsh_popen(char const   *program , char const   **argv , int in , pid_t *child ) 
{ 
  int out[2] ;
  pid_t pid ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
  {
#line 2421
  tmp = lsh_make_pipe(out);
  }
  }
#line 2421
  if (! tmp) {
    {
    {
#line 2423
    close(in);
    }
    }
#line 2424
    return (-1);
  }
  {
  {
#line 2426
  pid = fork();
  }
  }
#line 2428
  if (pid < 0) {
    {
    {
#line 2430
    close(in);
    }
    {
#line 2431
    close(out[0]);
    }
    {
#line 2432
    close(out[1]);
    }
    }
#line 2433
    return (-1);
  } else
#line 2435
  if (! pid) {
    {
    {
#line 2438
    tmp___1 = dup2(in, 0);
    }
    }
#line 2438
    if (tmp___1 < 0) {
      {
      {
#line 2440
      tmp___0 = __errno_location();
      }
      {
#line 2440
      werror("lsh_popen: dup2 for stdin failed %e.\n", *tmp___0);
      }
      {
#line 2441
      _exit(1);
      }
      }
    }
    {
    {
#line 2443
    tmp___3 = dup2(out[1], 1);
    }
    }
#line 2443
    if (tmp___3 < 0) {
      {
      {
#line 2445
      tmp___2 = __errno_location();
      }
      {
#line 2445
      werror("lsh_popen: dup2 for stdout failed %e.\n", *tmp___2);
      }
      {
#line 2446
      _exit(1);
      }
      }
    }
    {
    {
#line 2449
    close(in);
    }
    {
#line 2450
    close(out[0]);
    }
    {
#line 2451
    close(out[1]);
    }
    {
#line 2454
    execv(program, (char * const  *)((char **)argv));
    }
    {
#line 2456
    tmp___4 = __errno_location();
    }
    {
#line 2456
    werror("lsh_popen: execv `%z\' failed %e.\n", program, *tmp___4);
    }
    {
#line 2458
    _exit(1);
    }
    }
  } else {
    {
    {
#line 2463
    close(in);
    }
    {
#line 2464
    close(out[1]);
    }
#line 2465
    *child = pid;
    }
#line 2466
    return (out[0]);
  }
}
}
#line 2470 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
struct lsh_string *lsh_popen_read(char const   *program , char const   **argv , int in ,
                                  unsigned int guess ) 
{ 
  pid_t pid ;
  int status ;
  int fd ;
  int tmp ;
  struct lsh_string *s ;
  struct lsh_string *tmp___0 ;
  int *tmp___1 ;
  __pid_t tmp___2 ;
  union __anonunion_70 __constr_expr_8 ;
  union __anonunion_71 __constr_expr_9 ;
  union __anonunion_72 __constr_expr_10 ;
  char *tmp___3 ;
  union __anonunion_73 __constr_expr_11 ;
  union __anonunion_74 __constr_expr_12 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
  {
#line 2476
  tmp = lsh_popen(program, argv, in, & pid);
  }
#line 2476
  fd = tmp;
  {
#line 2477
  tmp___0 = io_read_file_raw(fd, guess);
  }
#line 2477
  s = tmp___0;
  {
#line 2479
  tmp___2 = waitpid(pid, & status, 0);
  }
  }
#line 2479
  if (tmp___2 < 0) {
    {
    {
#line 2481
    tmp___1 = __errno_location();
    }
    {
#line 2481
    werror("lsh_popen_read: waitpid failed: %e\n", *tmp___1);
    }
    {
#line 2482
    lsh_string_free((struct lsh_string  const  *)s);
    }
    }
#line 2483
    return ((struct lsh_string *)((void *)0));
  }
#line 2486
  if (! s) {
#line 2487
    return ((struct lsh_string *)((void *)0));
  }
#line 2489
  __constr_expr_12.__in = status;
#line 2489
  if ((__constr_expr_12.__i & 127) == 0) {
#line 2491
    __constr_expr_8.__in = status;
#line 2491
    if (! ((__constr_expr_8.__i & 65280) >> 8)) {
#line 2493
      return (s);
    }
    {
#line 2495
    __constr_expr_9.__in = status;
    {
#line 2495
    werror("Program `%z\' exited with status %i.\n", program, (__constr_expr_9.__i & 65280) >> 8);
    }
    }
  } else {
    {
#line 2499
    __constr_expr_10.__in = status;
    {
#line 2499
    tmp___3 = strsignal(__constr_expr_10.__i & 127);
    }
#line 2499
    __constr_expr_11.__in = status;
    {
#line 2499
    werror("Program `%z\' terminated by signal %i (%z).\n", program, __constr_expr_11.__i & 127,
           tmp___3);
    }
    }
  }
  {
  {
#line 2502
  lsh_string_free((struct lsh_string  const  *)s);
  }
  }
#line 2503
  return ((struct lsh_string *)((void *)0));
}
}
#line 2514 "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c"
int lsh_copy_file(int src , int dst ) 
{ 
  char buf[1024] ;
  struct pollfd src_poll ;
  struct pollfd dst_poll ;
  int res ;
  uint32_t i ;
  uint32_t length ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  __pid_t tmp___2 ;
  __pid_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;

  {
#line 2522
  src_poll.fd = src;
#line 2523
  dst_poll.fd = dst;
  {
  {
#line 2525
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2533
    dst_poll.events = (short)4;
    {
    {
#line 2535
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 2536
      res = poll(& dst_poll, (nfds_t )1, -1);
      }
      }
#line 2535
      if (res < 0) {
        {
        {
#line 2535
        tmp = __errno_location();
        }
        }
#line 2535
        if (! (*tmp == 4)) {
#line 2535
          goto while_break___0;
        }
      } else {
#line 2535
        goto while_break___0;
      }
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: 
    {
    {
#line 2539
    debug("lsh_copy_file, initial poll on destination:\n  res = %i, src = %i, dst = %i, events = %xi, revents = %xi.\n",
          res, src, dst, (int )dst_poll.events, (int )dst_poll.revents);
    }
    }
#line 2543
    if (! (res == 1)) {
      {
      {
#line 2543
      __assert_fail("res == 1", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 2543U,
                    "lsh_copy_file");
      }
      }
    }
#line 2545
    if (! ((int )dst_poll.revents & 4)) {
#line 2547
      return (1);
    }
#line 2550
    src_poll.events = (short)65;
    {
    {
#line 2552
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 2553
      res = poll(& src_poll, (nfds_t )1, -1);
      }
      }
#line 2552
      if (res < 0) {
        {
        {
#line 2552
        tmp___0 = __errno_location();
        }
        }
#line 2552
        if (! (*tmp___0 == 4)) {
#line 2552
          goto while_break___1;
        }
      } else {
#line 2552
        goto while_break___1;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___1: ;
#line 2556
    if (res < 0) {
#line 2557
      return (0);
    }
    {
    {
#line 2559
    debug("lsh_copy_file, poll on src:\n  res = %i, src = %i, dst = %i, events = %xi, revents = %xi.\n",
          res, src, dst, (int )src_poll.events, (int )src_poll.revents);
    }
    }
#line 2563
    if (! (res == 1)) {
      {
      {
#line 2563
      __assert_fail("res == 1", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c", 2563U,
                    "lsh_copy_file");
      }
      }
    }
#line 2566
    if (! ((int )src_poll.revents & 65)) {
#line 2568
      return (1);
    }
#line 2570
    if (! ((int )src_poll.revents & 65)) {
      {
      {
#line 2570
      __assert_fail("src_poll.revents & (0x001 | 0x040)", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                    2570U, "lsh_copy_file");
      }
      }
    }
#line 2575
    dst_poll.events = (short)4;
    {
    {
#line 2576
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
      {
      {
#line 2577
      res = poll(& dst_poll, (nfds_t )1, 0);
      }
      }
#line 2576
      if (res < 0) {
        {
        {
#line 2576
        tmp___1 = __errno_location();
        }
        }
#line 2576
        if (! (*tmp___1 == 4)) {
#line 2576
          goto while_break___2;
        }
      } else {
#line 2576
        goto while_break___2;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: 
    {
    {
#line 2580
    debug("lsh_copy_file, second poll on destination:\n  res = %i, src = %i, dst = %i, events = %xi, revents = %xi.\n",
          res, src, dst, (int )dst_poll.events, (int )dst_poll.revents);
    }
    }
#line 2584
    if (res) {
#line 2584
      if (! ((int )dst_poll.revents & 4)) {
        {
        {
#line 2593
        tmp___2 = getppid();
        }
        {
#line 2593
        debug("lsh_copy_file: ppid = %i\n", tmp___2);
        }
        {
#line 2595
        tmp___3 = getppid();
        }
        }
#line 2595
        if (tmp___3 == 1) {
#line 2596
          return (1);
        }
      }
    }
    {
    {
#line 2599
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
      {
      {
#line 2600
      res = read(src, (void *)(buf), (size_t )1024);
      }
      }
#line 2599
      if (res < 0) {
        {
        {
#line 2599
        tmp___4 = __errno_location();
        }
        }
#line 2599
        if (! (*tmp___4 == 4)) {
#line 2599
          goto while_break___3;
        }
      } else {
#line 2599
        goto while_break___3;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___3: 
    {
    {
#line 2603
    debug("lsh_copy_file: read on fd %i returned = %i\n", src, res);
    }
    }
#line 2605
    if (res < 0) {
#line 2606
      return (0);
    } else
#line 2607
    if (! res) {
#line 2609
      return (1);
    }
#line 2611
    length = (uint32_t )res;
#line 2613
    i = (uint32_t )0;
    {
    {
#line 2613
    while (1) {
      while_continue___12: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;

#line 2613
      if (! (i < length)) {
#line 2613
        goto while_break___4;
      }
#line 2615
      dst_poll.events = (short)4;
      {
      {
#line 2616
      while (1) {
        while_continue___13: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
        {
        {
#line 2617
        res = poll(& dst_poll, (nfds_t )1, -1);
        }
        }
#line 2616
        if (res < 0) {
          {
          {
#line 2616
          tmp___5 = __errno_location();
          }
          }
#line 2616
          if (! (*tmp___5 == 4)) {
#line 2616
            goto while_break___5;
          }
        } else {
#line 2616
          goto while_break___5;
        }
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___5: 
      {
      {
#line 2620
      debug("lsh_copy_file, inner poll on destination:\n  res = %i, src = %i, dst = %i, events = %xi, revents = %xi.\n",
            res, src, dst, (int )dst_poll.events, (int )dst_poll.revents);
      }
      }
#line 2624
      if (res < 0) {
#line 2625
        return (0);
      }
#line 2627
      if (! (res == 1)) {
        {
        {
#line 2627
        __assert_fail("res == 1", "/home/ysko/Works/test-src/lsh-2.0.4/src/io.c",
                      2627U, "lsh_copy_file");
        }
        }
      }
#line 2629
      if (! ((int )dst_poll.revents & 4)) {
#line 2630
        return (0);
      }
      {
      {
#line 2632
      while (1) {
        while_continue___14: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
        {
        {
#line 2633
        res = write(dst, (void const   *)(buf + i), length - i);
        }
        }
#line 2632
        if (res < 0) {
          {
          {
#line 2632
          tmp___6 = __errno_location();
          }
          }
#line 2632
          if (! (*tmp___6 == 4)) {
#line 2632
            goto while_break___6;
          }
        } else {
#line 2632
          goto while_break___6;
        }
      }
      while_break___21: /* CIL Label */ ;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___6: 
      {
      {
#line 2636
      debug("lsh_copy_file: write on fd %i returned = %i\n", dst, res);
      }
      }
#line 2638
      if (res < 0) {
#line 2639
        return (0);
      }
#line 2641
      i += (uint32_t )res;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___4: ;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 2649
  return (0);
}
}
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.h.x"
struct lsh_class window_change_callback_class ;
#line 63
struct lsh_class interact_dialog_class ;
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.h"
struct interact_dialog *make_interact_dialog(unsigned int nprompt ) ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.h.x"
struct lsh_class terminal_attributes_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"terminal_attributes", (size_t )sizeof(struct terminal_attributes ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.h.x"
struct lsh_class window_change_callback_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"window_change_callback",
    (size_t )sizeof(struct window_change_callback ), (void (*)(struct lsh_object *instance ,
                                                               void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 67 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.h.x"
static void do_interact_dialog_free(struct lsh_object *o ) 
{ 
  struct interact_dialog *i ;
  unsigned int k4 ;
  unsigned int k5 ;

  {
  {
#line 70
  i = (struct interact_dialog *)o;
  {
#line 71
  lsh_string_free((struct lsh_string  const  *)i->instruction);
  }
#line 74
  k4 = 0U;
  }
  {
  {
#line 74
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 74
    if (! (k4 < i->nprompt)) {
#line 74
      goto while_break;
    }
    {
    {
#line 75
    lsh_string_free((struct lsh_string  const  *)*(i->prompt + k4));
    }
#line 74
    k4 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 76
  lsh_space_free((void const   *)i->prompt);
  }
#line 80
  k5 = 0U;
  }
  {
  {
#line 80
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 80
    if (! (k5 < i->nprompt)) {
#line 80
      goto while_break___0;
    }
    {
    {
#line 81
    lsh_string_free((struct lsh_string  const  *)*(i->response + k5));
    }
#line 80
    k5 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
  {
#line 82
  lsh_space_free((void const   *)i->response);
  }
  {
#line 84
  lsh_space_free((void const   *)i->echo);
  }
  }
#line 85
  return;
}
}
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.h.x"
struct lsh_class interact_dialog_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"interact_dialog", (size_t )sizeof(struct interact_dialog ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_interact_dialog_free};
#line 118 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.h.x"
struct lsh_class interact_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"interact", (size_t )sizeof(struct interact ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.c"
struct interact_dialog *make_interact_dialog(unsigned int nprompt ) 
{ 
  struct interact_dialog *self ;
  struct lsh_object *tmp ;
  unsigned int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct lsh_string *tmp___3 ;
  size_t size9 ;
  void *tmp10 ;
  void *ret_lsh_space_alloc11 ;
  size_t size12 ;
  void *tmp13 ;
  void *ret_lsh_space_alloc14 ;
  size_t size15 ;
  void *tmp16 ;
  void *ret_lsh_space_alloc17 ;

  {
  {
  {
#line 52
  tmp = lsh_object_alloc(& interact_dialog_class);
  }
#line 52
  self = (struct interact_dialog *)tmp;
#line 55
  self->instruction = (struct lsh_string *)((void *)0);
#line 56
  self->nprompt = nprompt;
  {
#line 57
  size9 = (size_t )((unsigned long )nprompt * sizeof(struct lsh_string *));
  {
  {
  {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
  tmp10 = malloc(size9);
  }
  }
  {
#line 262
  ret_lsh_space_alloc11 = tmp10;
#line 262
  goto Lret_lsh_space_alloc;
  }
  }
  Lret_lsh_space_alloc: /* CIL Label */ 
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.c"
  tmp___0 = ret_lsh_space_alloc11;
  }
#line 57
  self->prompt = (struct lsh_string **)tmp___0;
  {
#line 58
  size12 = (size_t )((unsigned long )nprompt * sizeof(struct lsh_string *));
  {
  {
  {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
  tmp13 = malloc(size12);
  }
  }
  {
#line 262
  ret_lsh_space_alloc14 = tmp13;
#line 262
  goto Lret_lsh_space_alloc___0;
  }
  }
  Lret_lsh_space_alloc___0: /* CIL Label */ 
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.c"
  tmp___1 = ret_lsh_space_alloc14;
  }
#line 58
  self->response = (struct lsh_string **)tmp___1;
  {
#line 59
  size15 = (size_t )((unsigned long )nprompt * sizeof(int ));
  {
  {
  {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
  tmp16 = malloc(size15);
  }
  }
  {
#line 262
  ret_lsh_space_alloc17 = tmp16;
#line 262
  goto Lret_lsh_space_alloc___1;
  }
  }
  Lret_lsh_space_alloc___1: /* CIL Label */ 
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/interact.c"
  tmp___2 = ret_lsh_space_alloc17;
  }
#line 59
  self->echo = (int *)tmp___2;
#line 61
  i = 0U;
  }
  {
  {
#line 61
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 61
    if (! (i < nprompt)) {
#line 61
      goto while_break;
    }
#line 62
    tmp___3 = (struct lsh_string *)((void *)0);
#line 62
    *(self->response + i) = tmp___3;
#line 62
    *(self->prompt + i) = tmp___3;
#line 61
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 64
  return (self);
}
}
#line 216 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h"
struct ssh_connection *make_ssh_connection(enum connection_flag flags , struct address_info *peer ,
                                           struct address_info *local , char const   *debug_comment ,
                                           struct exception_handler *e ) ;
#line 223
void connection_init_io(struct ssh_connection *connection , struct lsh_fd *socket___0 ) ;
#line 227
void connection_after_keyexchange(struct ssh_connection *self , struct command_continuation *c ) ;
#line 235
struct lsh_callback *make_connection_close_handler(struct ssh_connection *c ) ;
#line 259
void connection_set_timeout(struct ssh_connection *connection , unsigned int seconds ,
                            char const   *msg ) ;
#line 284
struct abstract_write *make_packet_debug(struct abstract_write *next , struct lsh_string *prefix___0 ) ;
#line 17 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.h.x"
struct lsh_class handshake_info_class ;
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.h"
struct handshake_info *make_handshake_info(enum connection_flag flags , char const   *id_comment ,
                                           char const   *debug_comment , uint32_t block_size ,
                                           struct randomness *r , struct alist *algorithms ,
                                           struct make_kexinit *kexinit , struct lsh_string *banner_text ) ;
#line 63
struct command_4 handshake_command ;
#line 177 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h"
void do_command_4(struct command *s , struct lsh_object *a1 , struct command_continuation *c ,
                  struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.h.x"
static void do_handshake_info_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct handshake_info *i ;

  {
  {
#line 25
  i = (struct handshake_info *)o;
  {
#line 26
  (*mark)((struct lsh_object *)i->random);
  }
  {
#line 27
  (*mark)((struct lsh_object *)i->algorithms);
  }
  {
#line 28
  (*mark)((struct lsh_object *)i->kexinit);
  }
  }
#line 29
  return;
}
}
#line 30 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.h.x"
static void do_handshake_info_free(struct lsh_object *o ) 
{ 
  struct handshake_info *i ;

  {
  {
#line 33
  i = (struct handshake_info *)o;
  {
#line 34
  lsh_string_free((struct lsh_string  const  *)i->banner_text);
  }
  }
#line 35
  return;
}
}
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.h.x"
struct lsh_class handshake_info_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"handshake_info", (size_t )sizeof(struct handshake_info ),
    & do_handshake_info_mark, & do_handshake_info_free};
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.c.x"
struct lsh_class connection_line_handler_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.c.x"
static void do_connection_line_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct connection_line_handler *i ;

  {
  {
#line 18
  i = (struct connection_line_handler *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.c.x"
struct lsh_class connection_line_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & line_handler_class, (char *)"connection_line_handler", (size_t )sizeof(struct connection_line_handler ),
    & do_connection_line_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 103 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.c"
static int split_version_string(uint32_t length , uint8_t const   *line , uint32_t *protover_len ,
                                uint8_t const   **protover , uint32_t *swver_len ,
                                uint8_t const   **swver , uint32_t *comment_len ,
                                uint8_t const   **comment ) 
{ 
  uint8_t *sep ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 111
  if (length < 4U) {
#line 114
    return (-1);
  } else {
    {
    {
#line 111
    tmp = memcmp((void const   *)line, (void const   *)"SSH-", (size_t )4);
    }
    }
#line 111
    if (tmp != 0) {
#line 114
      return (-1);
    }
  }
  {
#line 116
  line += 4;
#line 116
  length -= 4U;
  {
#line 117
  tmp___0 = memchr((void const   *)line, '-', length);
  }
#line 117
  sep = (uint8_t *)tmp___0;
  }
#line 118
  if (! sep) {
#line 120
    return (0);
  }
  {
#line 122
  *protover_len = (uint32_t )(sep - (uint8_t *)line);
#line 123
  *protover = line;
#line 125
  line = (uint8_t const   *)(sep + 1);
#line 126
  length -= *protover_len + 1U;
  {
#line 130
  tmp___1 = memchr((void const   *)line, ' ', length);
  }
#line 130
  sep = (uint8_t *)tmp___1;
  }
#line 131
  if (! sep) {
#line 133
    *swver_len = length;
#line 134
    *swver = line;
#line 135
    *comment = (uint8_t const   *)((void *)0);
#line 136
    *comment_len = (uint32_t )0;
#line 137
    return (1);
  }
#line 140
  *swver_len = (uint32_t )(sep - (uint8_t *)line);
#line 141
  *swver = line;
#line 142
  *comment = (uint8_t const   *)(sep + 1);
#line 143
  *comment_len = (length - *swver_len) - 1U;
#line 144
  return (1);
}
}
#line 147 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.c"
static void do_line(struct line_handler **h___0 , struct read_handler **r , uint32_t length ,
                    uint8_t const   *line , struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct connection_line_handler *closure ;
  uint32_t protover_len ;
  uint32_t swver_len ;
  uint32_t comment_len ;
  uint8_t const   *protover ;
  uint8_t const   *swver ;
  uint8_t const   *comment ;
  struct ssh_connection *connection ;
  int mode ;
  int tmp ;
  struct read_handler *new ;
  struct lsh_string *tmp___0 ;
  struct lsh_string *tmp___1 ;
  struct lsh_string *tmp___2 ;
  struct abstract_write *tmp___3 ;
  struct exception *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct exception *tmp___7 ;
  struct exception *tmp___8 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
  {
#line 155
  closure = (struct connection_line_handler *)*h___0;
#line 159
  connection = closure->connection;
#line 160
  mode = (int )((unsigned int )connection->flags & 1U);
  {
#line 162
  tmp = split_version_string(length, line, & protover_len, & protover, & swver_len,
                             & swver, & comment_len, & comment);
  }
  }
#line 167
  if (tmp == 1) {
#line 167
    goto case_1;
  }
#line 215
  if (tmp == 0) {
#line 215
    goto case_0;
  }
#line 224
  if (tmp == -1) {
#line 224
    goto case_neg_1;
  }
#line 242
  goto switch_default;
  case_1: 
#line 175
  if (protover_len >= 3U) {
    {
    {
#line 175
    tmp___5 = memcmp((void const   *)protover, (void const   *)"2.0", (size_t )3);
    }
    }
#line 175
    if (tmp___5) {
#line 175
      goto _L___0;
    } else {
#line 175
      goto _L;
    }
  } else
  _L___0: 
#line 175
  if (protover_len == 4U) {
    {
    {
#line 175
    tmp___6 = memcmp((void const   *)protover, (void const   *)"1.99", (size_t )4);
    }
    }
#line 175
    if (tmp___6) {
      {
      {
#line 202
      werror("Unsupported protocol version: %ps\n", length, line);
      }
#line 205
      *h___0 = (struct line_handler *)((void *)0);
      {
#line 207
      tmp___4 = make_protocol_exception((uint32_t )8, (char const   *)((void *)0));
      }
      {
#line 207
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
      }
      }
#line 211
      return;
    } else {
      _L: 
#line 180
      connection->peer_flags = (enum peer_flag )0;
#line 182
      if (connection->debug_comment) {
        {
        {
#line 182
        tmp___0 = ssh_format("%lz received", connection->debug_comment);
        }
#line 182
        tmp___2 = tmp___0;
        }
      } else {
        {
        {
#line 182
        tmp___1 = ssh_format("Received");
        }
#line 182
        tmp___2 = tmp___1;
        }
      }
      {
      {
#line 182
      tmp___3 = make_packet_debug(& connection->super, tmp___2);
      }
      {
#line 182
      new = make_read_packet(tmp___3, connection);
      }
      {
#line 189
      connection->versions[! mode] = ssh_format("%ls", length, line);
      }
      {
#line 192
      verbose("Client version: %pS\nServer version: %pS\n", connection->versions[0],
              connection->versions[1]);
      }
#line 197
      *r = new;
      }
#line 198
      return;
    }
  } else {
    {
    {
#line 202
    werror("Unsupported protocol version: %ps\n", length, line);
    }
#line 205
    *h___0 = (struct line_handler *)((void *)0);
    {
#line 207
    tmp___4 = make_protocol_exception((uint32_t )8, (char const   *)((void *)0));
    }
    {
#line 207
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
    }
    }
#line 211
    return;
  }
  {
  {
#line 213
  fatal("Internal error!\n");
  }
  }
  case_0: 
  {
  {
#line 216
  werror("Incorrectly formatted version string: %s\n", length, line);
  }
  {
#line 217
  gc_kill((struct lsh_object *)closure);
  }
#line 218
  *h___0 = (struct line_handler *)((void *)0);
  {
#line 220
  tmp___7 = make_protocol_exception((uint32_t )2, "Incorrectly formatted version string.");
  }
  {
#line 220
  (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___7);
  }
  }
#line 223
  return;
  case_neg_1: 
#line 226
  if (((unsigned int )connection->flags & 1U) == 0U) {
    {
    {
#line 228
    werror("%ps\n", length, line);
    }
    }
#line 231
    goto switch_break;
  } else {
    {
    {
#line 235
    werror("Client tries to send a banner string. Disconnecting.\n");
    }
    {
#line 236
    gc_kill((struct lsh_object *)closure);
    }
#line 237
    *h___0 = (struct line_handler *)((void *)0);
    {
#line 239
    tmp___8 = make_protocol_exception((uint32_t )2, "Invalid handshake line.");
    }
    {
#line 239
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___8);
    }
    }
#line 240
    return;
  }
  switch_default: 
  {
  {
#line 243
  fatal("Internal error!\n");
  }
  }
  switch_break: ;
#line 245
  return;
}
}
#line 247 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.c"
static struct read_handler *make_connection_read_line(struct ssh_connection *connection ) 
{ 
  struct connection_line_handler *closure ;
  struct lsh_object *tmp ;
  struct read_handler *tmp___0 ;

  {
  {
  {
#line 250
  tmp = lsh_object_alloc(& connection_line_handler_class);
  }
#line 250
  closure = (struct connection_line_handler *)tmp;
#line 252
  closure->super.handler = & do_line;
#line 253
  closure->connection = connection;
  {
#line 254
  tmp___0 = make_read_line(& closure->super, connection->e);
  }
  }
#line 254
  return (tmp___0);
}
}
#line 258 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.c"
struct handshake_info *make_handshake_info(enum connection_flag flags , char const   *id_comment ,
                                           char const   *debug_comment , uint32_t block_size ,
                                           struct randomness *r , struct alist *algorithms ,
                                           struct make_kexinit *kexinit , struct lsh_string *banner_text ) 
{ 
  struct handshake_info *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 268
  tmp = lsh_object_alloc(& handshake_info_class);
  }
#line 268
  self = (struct handshake_info *)tmp;
#line 269
  self->flags = flags;
#line 270
  self->id_comment = id_comment;
#line 271
  self->debug_comment = debug_comment;
#line 272
  self->block_size = block_size;
#line 273
  self->random = r;
#line 274
  self->algorithms = algorithms;
#line 275
  self->kexinit = kexinit;
#line 276
  self->banner_text = banner_text;
  }
#line 278
  return (self);
}
}
#line 293
static void do_handshake_command(struct lsh_object *a1 , struct lsh_object *a2 , struct lsh_object *extra ,
                                 struct lsh_object *a4 , struct command_continuation *c ,
                                 struct exception_handler *e ) ;
#line 293 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.c"
struct command_4 handshake_command  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_4}, & do_handshake_command};
#line 293 "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.c"
static void do_handshake_command(struct lsh_object *a1 , struct lsh_object *a2 , struct lsh_object *extra ,
                                 struct lsh_object *a4 , struct command_continuation *c ,
                                 struct exception_handler *e ) 
{ 
  struct resource *resource ;
  struct handshake_info *info ;
  struct listen_value *lv ;
  struct lsh_string *version ;
  struct ssh_connection *connection ;
  int mode ;
  struct exception_handler *tmp ;
  struct lsh_callback *tmp___0 ;
  struct read_handler *tmp___1 ;
  struct io_callback *tmp___2 ;
  struct lsh_fd *tmp___3 ;
  struct lsh_string *tmp___4 ;
  struct lsh_string *tmp___5 ;
  struct lsh_string *tmp___6 ;
  struct abstract_write *tmp___7 ;
  struct lsh_string *tmp___8 ;
  struct lsh_string *tmp___9 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
#line 301
  resource = (struct resource *)a1;
#line 302
  info = (struct handshake_info *)a2;
#line 305
  lv = (struct listen_value *)a4;
#line 309
  mode = (int )((unsigned int )info->flags & 1U);
#line 311
  if (lv->peer) {
    {
    {
#line 312
    verbose("Initiating handshake with %S\n", (lv->peer)->ip);
    }
    }
  }
#line 316
  if (mode == 0) {
#line 316
    goto case_0;
  }
#line 322
  if (mode == 1) {
#line 322
    goto case_1;
  }
#line 328
  goto switch_default;
  case_0: 
  {
  {
#line 317
  version = ssh_format("SSH-%lz-%lz %lz", "2.0", "lsh-2.0.4", info->id_comment);
  }
  }
#line 321
  goto switch_break;
  case_1: 
  {
  {
#line 323
  version = ssh_format("SSH-%lz-%lz %lz", "2.0", "lshd-2.0.4", info->id_comment);
  }
  }
#line 327
  goto switch_break;
  switch_default: 
  {
  {
#line 329
  fatal("do_handshake: Internal error\n");
  }
  }
  switch_break: 
  {
  {
#line 341
  tmp = make_exc_finish_read_handler(lv->fd, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/handshake.c:344");
  }
  {
#line 341
  connection = make_ssh_connection(info->flags, lv->peer, lv->local, info->debug_comment,
                                   tmp);
  }
  }
#line 347
  if (resource) {
    {
    {
#line 348
    remember_resource(connection->resources, resource);
    }
    }
  }
  {
  {
#line 350
  connection_after_keyexchange(connection, c);
  }
  {
#line 352
  tmp___0 = make_connection_close_handler(connection);
  }
  {
#line 352
  tmp___1 = make_connection_read_line(connection);
  }
  {
#line 352
  tmp___2 = make_buffered_read((uint32_t )(1 << 14), tmp___1);
  }
  {
#line 352
  tmp___3 = io_read_write(lv->fd, tmp___2, info->block_size, tmp___0);
  }
  {
#line 352
  connection_init_io(connection, tmp___3);
  }
  }
#line 361
  if (info->debug_comment) {
    {
    {
#line 361
    tmp___4 = ssh_format("%lz sent", info->debug_comment);
    }
#line 361
    tmp___6 = tmp___4;
    }
  } else {
    {
    {
#line 361
    tmp___5 = ssh_format("Sent");
    }
#line 361
    tmp___6 = tmp___5;
    }
  }
  {
  {
#line 361
  tmp___7 = make_write_packet(connection, info->random, & ((connection->socket)->write_buffer)->super);
  }
  {
#line 361
  connection->write_packet = make_packet_debug(tmp___7, tmp___6);
  }
  {
#line 369
  connection_set_timeout(connection, 600U, "Handshake timed out");
  }
#line 373
  connection->versions[mode] = version;
#line 374
  connection->kexinit = info->kexinit;
  {
#line 375
  connection->dispatch[20] = make_kexinit_handler(extra, info->algorithms);
  }
  }
#line 378
  if (info->banner_text) {
    {
    {
#line 380
    tmp___8 = ssh_format("%lS\r\n", info->banner_text);
    }
    {
#line 380
    (*(((connection->socket)->write_buffer)->super.write))(& ((connection->socket)->write_buffer)->super,
                                                           tmp___8);
    }
    }
  }
  {
  {
#line 384
  tmp___9 = ssh_format("%lS\r\n", version);
  }
  {
#line 384
  (*(((connection->socket)->write_buffer)->super.write))(& ((connection->socket)->write_buffer)->super,
                                                         tmp___9);
  }
  {
#line 387
  send_kexinit(connection);
  }
  }
#line 388
  return;
}
}
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.h"
void gc(void) ;
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
static struct lsh_object *all_objects  =    (struct lsh_object *)((void *)0);
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
static unsigned int number_of_objects  =    0U;
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
static unsigned int live_objects  =    0U;
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
static struct resource_list *root_set  =    (struct resource_list *)((void *)0);
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
static int gc_scheduled  =    0;
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
static void gc_mark(struct lsh_object *o ) 
{ 
  struct lsh_class *class ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 79
  if (! o) {
#line 80
    return;
  }
#line 84
  if ((int )o->alloc_method == 2) {
#line 84
    goto case_2;
  }
#line 87
  if ((int )o->alloc_method == 0) {
#line 87
    goto case_0;
  }
#line 92
  if ((int )o->alloc_method == 1) {
#line 92
    goto case_1;
  }
#line 111
  goto switch_default;
  case_2: 
  {
  {
#line 85
  fatal("gc_mark: Unexpected stack object!\n");
  }
  }
  case_0: 
#line 88
  if (o->marked) {
#line 89
    return;
  }
#line 90
  o->marked = (char)1;
  case_1: 
#line 95
  if (! (! o->dead)) {
    {
    {
#line 95
    __assert_fail("!o->dead", "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c", 95U,
                  "gc_mark");
    }
    }
  }
#line 104
  class = o->isa;
  {
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 104
    if (! class) {
#line 104
      goto while_break;
    }
#line 106
    if (class->mark_instance) {
      {
      {
#line 107
      (*(class->mark_instance))(o, & gc_mark);
      }
      }
    }
#line 104
    class = class->super_class;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 110
  goto switch_break;
  switch_default: 
  {
  {
#line 112
  fatal("gc_mark: Memory corrupted!\n");
  }
  }
  switch_break: ;
#line 114
  return;
}
}
#line 116 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
static void gc_sweep(void) 
{ 
  struct lsh_object *o ;
  struct lsh_object **o_p ;
  struct lsh_class *class ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 121
  live_objects = 0U;
#line 123
  o_p = & all_objects;
  {
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 123
    o = *o_p;
#line 123
    if (! o) {
#line 123
      goto while_break;
    }
#line 125
    if (o->marked) {
#line 128
      live_objects ++;
#line 129
      o->marked = (char)0;
    } else {
#line 140
      class = o->isa;
      {
      {
#line 140
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;

#line 140
        if (! class) {
#line 140
          goto while_break___0;
        }
#line 141
        if (class->free_instance) {
          {
          {
#line 142
          (*(class->free_instance))(o);
          }
          }
        }
#line 140
        class = class->super_class;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
      {
#line 144
      *o_p = o->next;
#line 145
      number_of_objects --;
      {
#line 147
      lsh_object_free((struct lsh_object  const  *)o);
      }
      }
#line 148
      goto __Cont;
    }
#line 150
    o_p = & o->next;
    __Cont: ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 152
  if (! (live_objects == number_of_objects)) {
    {
    {
#line 152
    __assert_fail("live_objects == number_of_objects", "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c",
                  152U, "gc_sweep");
    }
    }
  }
#line 153
  return;
}
}
#line 155 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
static void do_gc(struct lsh_callback *s  __attribute__((__unused__)) ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 158
  if (! gc_scheduled) {
    {
    {
#line 158
    __assert_fail("gc_scheduled", "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c",
                  158U, "do_gc");
    }
    }
  }
  {
#line 159
  gc_scheduled = 0;
  {
#line 161
  gc();
  }
  }
#line 162
  return;
}
}
#line 164 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
struct lsh_callback gc_callback  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_gc};
#line 167 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
void gc_register(struct lsh_object *o ) 
{ 
  char tmp ;

  {
#line 172
  tmp = (char)0;
#line 172
  o->dead = tmp;
#line 172
  o->marked = tmp;
#line 173
  o->next = all_objects;
#line 174
  all_objects = o;
#line 176
  number_of_objects ++;
#line 178
  if (! gc_scheduled) {
#line 178
    if (number_of_objects > 100U + 2U * live_objects) {
      {
#line 180
      gc_scheduled = 1;
      {
#line 181
      io_callout(& gc_callback, 0U);
      }
      }
    }
  }
#line 185
  return;
}
}
#line 191 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
void gc_kill(struct lsh_object *o ) 
{ 
  struct lsh_class *class ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 195
  if (! o) {
#line 196
    return;
  }
#line 198
  if (! (! o->dead)) {
    {
    {
#line 198
    __assert_fail("!o->dead", "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c", 198U,
                  "gc_kill");
    }
    }
  }
#line 200
  o->dead = (char)1;
#line 207
  if ((unsigned long )o == (unsigned long )all_objects) {
#line 215
    class = o->isa;
    {
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 215
      if (! class) {
#line 215
        goto while_break;
      }
#line 216
      if (class->free_instance) {
        {
        {
#line 217
        (*(class->free_instance))(o);
        }
        }
      }
#line 215
      class = class->super_class;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 219
    all_objects = o->next;
#line 220
    number_of_objects --;
    {
#line 221
    lsh_object_free((struct lsh_object  const  *)o);
    }
    }
  }
#line 231
  return;
}
}
#line 233 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
void gc_global(struct resource *o ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 236
  if (! root_set) {
    {
    {
#line 237
    root_set = make_resource_list();
    }
    }
  }
#line 239
  if (! root_set->super.alive) {
    {
    {
#line 239
    __assert_fail("root_set->super.alive", "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c",
                  239U, "gc_global");
    }
    }
  }
  {
  {
#line 241
  remember_resource(root_set, o);
  }
  }
#line 242
  return;
}
}
#line 244 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
void gc(void) 
{ 
  unsigned int objects_before ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 246
  objects_before = number_of_objects;
  {
#line 252
  verbose("garbage collecting...\n");
  }
  {
#line 254
  gc_mark(& root_set->super.super);
  }
  {
#line 255
  gc_sweep();
  }
  {
#line 257
  verbose("Objects alive: %i, garbage collected: %i\n", live_objects, objects_before - live_objects);
  }
  }
#line 264
  return;
}
}
#line 269 "/home/ysko/Works/test-src/lsh-2.0.4/src/gc.c"
void gc_final(void) 
{ 


  {
#line 271
  if (root_set) {
    {
    {
#line 273
    (*(root_set->super.kill))(& root_set->super);
    }
#line 274
    root_set = (struct resource_list *)((void *)0);
    }
  }
#line 284
  return;
}
}
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.h"
struct command_2 gateway_init ;
#line 32
struct command_2 gateway_accept ;
#line 35
struct command *make_gateway_setup(struct local_info *local ) ;
#line 274 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h"
struct packet_handler connection_forward_handler ;
#line 434 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h"
void init_connection_service(struct ssh_connection *connection ) ;
#line 56 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.h"
struct channel_open gateway_channel_open_forward ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c.x"
struct lsh_class read_gateway_packet_class ;
#line 18 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c.x"
static void do_read_gateway_packet_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct read_gateway_packet *i ;

  {
  {
#line 22
  i = (struct read_gateway_packet *)o;
  {
#line 23
  (*mark)((struct lsh_object *)i->handler);
  }
  {
#line 24
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 25
  return;
}
}
#line 26 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c.x"
static void do_read_gateway_packet_free(struct lsh_object *o ) 
{ 
  struct read_gateway_packet *i ;

  {
  {
#line 29
  i = (struct read_gateway_packet *)o;
  {
#line 30
  lsh_string_free((struct lsh_string  const  *)i->header);
  }
  {
#line 31
  lsh_string_free((struct lsh_string  const  *)i->payload);
  }
  }
#line 32
  return;
}
}
#line 33 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c.x"
struct lsh_class read_gateway_packet_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & read_handler_class, (char *)"read_gateway_packet", (size_t )sizeof(struct read_gateway_packet ),
    & do_read_gateway_packet_mark, & do_read_gateway_packet_free};
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c.x"
static struct command *gateway_setup(struct local_info *local ) 
{ 
  struct command *res ;
  struct lsh_object *tmp ;
  struct command *tmp___0 ;
  struct command *tmp___1 ;
  struct command *tmp___2 ;
  struct command *tmp___3 ;

  {
  {
  {
#line 73
  tmp = gaba_apply(& command_K.super.super, (struct lsh_object *)local);
  }
  {
#line 73
  tmp___0 = make_command_3_invoke_2(& command_B, & bind_local_command.super, tmp);
  }
  {
#line 73
  tmp___1 = make_command_3_invoke_2(& command_B, & listen_command.super.super, & gateway_accept.super.super);
  }
  {
#line 73
  tmp___2 = make_command_3_invoke_2(& command_S, (struct lsh_object *)tmp___1, (struct lsh_object *)tmp___0);
  }
  {
#line 73
  tmp___3 = make_command_3_invoke_2(& command_S, & connection_remember.super.super,
                                    (struct lsh_object *)tmp___2);
  }
#line 73
  res = (struct command *)((struct lsh_object *)tmp___3);
  }
#line 81
  return (res);
}
}
#line 57 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c"
static void do_gateway_pad(struct abstract_write *w , struct lsh_string *packet ) 
{ 
  struct abstract_write_pipe *self ;
  struct lsh_string *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 61
  self = (struct abstract_write_pipe *)w;
  {
#line 63
  tmp = ssh_format("%fS", packet);
  }
  {
#line 63
  (*((self->next)->write))(self->next, tmp);
  }
  }
#line 64
  return;
}
}
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c"
static struct abstract_write *make_gateway_pad(struct abstract_write *next ) 
{ 
  struct abstract_write_pipe *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 69
  tmp = lsh_object_alloc(& abstract_write_pipe_class);
  }
#line 69
  self = (struct abstract_write_pipe *)tmp;
#line 71
  self->super.write = & do_gateway_pad;
#line 72
  self->next = next;
  }
#line 74
  return (& self->super);
}
}
#line 132
static uint32_t do_read_gateway(struct read_handler **h___0 , uint32_t available ,
                                uint8_t const   *data ) ;
#line 132 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c"
static struct protocol_exception  const  too_large___0  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, (uint32_t )4096, "Packet too large"}, (uint32_t )2};
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c"
static uint32_t do_read_gateway(struct read_handler **h___0 , uint32_t available ,
                                uint8_t const   *data ) 
{ 
  struct read_gateway_packet *self ;
  struct exception *tmp ;
  uint32_t left ;
  uint32_t length ;
  uint8_t const   *tmp___0 ;
  uint8_t const   *tmp___1 ;
  uint8_t const   *tmp___2 ;
  uint8_t const   *tmp___3 ;
  uint32_t left___0 ;
  uint32_t tmp___4 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 95
  self = (struct read_gateway_packet *)*h___0;
#line 97
  if (! available) {
    {
    {
#line 99
    debug("read_gateway: Got EOF.\n");
    }
    }
#line 101
    if (self->payload) {
      {
      {
#line 102
      tmp = make_protocol_exception((uint32_t )0, "Unexpected EOF");
      }
      {
#line 102
      (*(((self->connection)->e)->raise))((self->connection)->e, (struct exception  const  *)tmp);
      }
      }
    } else {
      {
      {
#line 105
      (*(((self->connection)->e)->raise))((self->connection)->e, & finish_read_exception);
      }
      }
    }
#line 107
    *h___0 = (struct read_handler *)((void *)0);
#line 108
    return ((uint32_t )0);
  }
#line 111
  if (! self->payload) {
#line 117
    if (! (self->pos < 4U)) {
      {
      {
#line 117
      __assert_fail("self->pos < 4", "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c",
                    117U, "do_read_gateway");
      }
      }
    }
#line 118
    left = 4U - self->pos;
#line 120
    if (available < left) {
      {
      {
#line 122
      lsh_string_write(self->header, self->pos, available, data);
      }
#line 123
      self->pos += available;
      }
#line 124
      return (available);
    }
    {
    {
#line 127
    lsh_string_write(self->header, self->pos, left, data);
    }
    {
#line 129
    tmp___0 = lsh_string_data((struct lsh_string  const  *)self->header);
    }
    {
#line 129
    tmp___1 = lsh_string_data((struct lsh_string  const  *)self->header);
    }
    {
#line 129
    tmp___2 = lsh_string_data((struct lsh_string  const  *)self->header);
    }
    {
#line 129
    tmp___3 = lsh_string_data((struct lsh_string  const  *)self->header);
    }
#line 129
    length = ((((uint32_t )*(tmp___0 + 0) << 24) | ((uint32_t )*(tmp___1 + 1) << 16)) | ((uint32_t )*(tmp___2 + 2) << 8)) | (uint32_t )*(tmp___3 + 3);
    }
#line 130
    if (length > (self->connection)->rec_max_packet) {
      {
      {
#line 136
      werror("read_gateway: Receiving too large packet.\n  %i octets, limit is %i\n",
             length, (self->connection)->rec_max_packet);
      }
      {
#line 140
      (*(((self->connection)->e)->raise))((self->connection)->e, & too_large___0.super);
      }
#line 141
      *h___0 = (struct read_handler *)((void *)0);
      }
    } else {
      {
      {
#line 145
      self->payload = lsh_string_alloc(length);
      }
#line 146
      self->pos = (uint32_t )0;
      }
    }
#line 149
    return (left);
  } else {
    {
    {
#line 154
    tmp___4 = lsh_string_length((struct lsh_string  const  *)self->payload);
    }
#line 154
    left___0 = tmp___4 - self->pos;
    }
#line 156
    if (available < left___0) {
      {
      {
#line 158
      lsh_string_write(self->payload, self->pos, available, data);
      }
#line 159
      self->pos += available;
      }
#line 160
      return (available);
    }
    {
    {
#line 163
    lsh_string_write(self->payload, self->pos, left___0, data);
    }
    {
#line 165
    (*((self->handler)->write))(self->handler, self->payload);
    }
#line 166
    self->payload = (struct lsh_string *)((void *)0);
#line 167
    self->pos = (uint32_t )0;
    }
#line 169
    return (left___0);
  }
}
}
#line 173 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c"
static struct read_handler *make_read_gateway(struct abstract_write *handler , struct ssh_connection *connection ) 
{ 
  struct read_gateway_packet *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 177
  tmp = lsh_object_alloc(& read_gateway_packet_class);
  }
#line 177
  self = (struct read_gateway_packet *)tmp;
#line 178
  self->super.handler = & do_read_gateway;
#line 180
  self->connection = connection;
#line 181
  self->handler = handler;
  {
#line 183
  self->header = lsh_string_alloc((uint32_t )4);
  }
#line 184
  self->pos = (uint32_t )0;
#line 185
  self->payload = (struct lsh_string *)((void *)0);
  }
#line 187
  return (& self->super);
}
}
#line 197 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c"
static struct ssh_connection *gateway_make_connection(struct listen_value *lv , struct resource *resource ,
                                                      struct exception_handler *e ) 
{ 
  struct ssh_connection *connection ;
  struct exception_handler *tmp ;
  struct ssh_connection *tmp___0 ;
  struct lsh_callback *tmp___1 ;
  struct lsh_string *tmp___2 ;
  struct abstract_write *tmp___3 ;
  struct read_handler *tmp___4 ;
  struct io_callback *tmp___5 ;
  struct lsh_fd *tmp___6 ;
  struct lsh_string *tmp___7 ;
  struct abstract_write *tmp___8 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
  {
#line 203
  tmp = make_exc_finish_read_handler(lv->fd, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c:206");
  }
  {
#line 203
  tmp___0 = make_ssh_connection((enum connection_flag )0, lv->peer, lv->local, "gateway",
                                tmp);
  }
#line 203
  connection = tmp___0;
  }
#line 209
  if (resource) {
    {
    {
#line 210
    remember_resource(connection->resources, resource);
    }
    }
  }
  {
  {
#line 212
  tmp___1 = make_connection_close_handler(connection);
  }
  {
#line 212
  tmp___2 = ssh_format("%lz received", connection->debug_comment);
  }
  {
#line 212
  tmp___3 = make_packet_debug(& connection->super, tmp___2);
  }
  {
#line 212
  tmp___4 = make_read_gateway(tmp___3, connection);
  }
  {
#line 212
  tmp___5 = make_buffered_read((uint32_t )(1 << 14), tmp___4);
  }
  {
#line 212
  tmp___6 = io_read_write(lv->fd, tmp___5, (uint32_t )2000, tmp___1);
  }
  {
#line 212
  connection_init_io(connection, tmp___6);
  }
  {
#line 225
  tmp___7 = ssh_format("%lz sent", connection->debug_comment);
  }
  {
#line 225
  tmp___8 = make_gateway_pad(& ((connection->socket)->write_buffer)->super);
  }
  {
#line 225
  connection->write_packet = make_packet_debug(tmp___8, tmp___7);
  }
  {
#line 229
  init_connection_service(connection);
  }
#line 231
  (connection->table)->open_fallback = & gateway_channel_open_forward;
#line 233
  connection->dispatch[4] = & connection_forward_handler;
#line 234
  connection->dispatch[2] = & connection_forward_handler;
  }
#line 236
  return (connection);
}
}
#line 239
static void do_gateway_init(struct command_2 *s  __attribute__((__unused__)) , struct lsh_object *a1 ,
                            struct lsh_object *a2 , struct command_continuation *c ,
                            struct exception_handler *e ) ;
#line 239 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c"
struct command_2 gateway_init  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_2}, & do_gateway_init};
#line 239 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c"
static void do_gateway_init(struct command_2 *s  __attribute__((__unused__)) , struct lsh_object *a1 ,
                            struct lsh_object *a2 , struct command_continuation *c ,
                            struct exception_handler *e ) 
{ 
  struct resource *resource ;
  struct listen_value *lv ;
  struct ssh_connection *tmp ;

  {
  {
#line 246
  resource = (struct resource *)a1;
#line 247
  lv = (struct listen_value *)a2;
  {
#line 249
  tmp = gateway_make_connection(lv, resource, e);
  }
  {
#line 249
  (*(c->c))(c, (struct lsh_object *)tmp);
  }
  }
#line 250
  return;
}
}
#line 254
static void do_gateway_accept(struct command_2 *s  __attribute__((__unused__)) , struct lsh_object *a1 ,
                              struct lsh_object *a2 , struct command_continuation *c ,
                              struct exception_handler *e ) ;
#line 254 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c"
struct command_2 gateway_accept  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_2}, & do_gateway_accept};
#line 254 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c"
static void do_gateway_accept(struct command_2 *s  __attribute__((__unused__)) , struct lsh_object *a1 ,
                              struct lsh_object *a2 , struct command_continuation *c ,
                              struct exception_handler *e ) 
{ 
  struct ssh_connection *connection ;
  struct listen_value *lv ;
  struct ssh_connection *gateway ;
  struct ssh_connection *tmp ;

  {
  {
#line 261
  connection = (struct ssh_connection *)a1;
#line 262
  lv = (struct listen_value *)a2;
  {
#line 264
  tmp = gateway_make_connection(lv, (struct resource *)((void *)0), e);
  }
#line 264
  gateway = tmp;
  {
#line 267
  remember_resource(connection->resources, & (lv->fd)->super);
  }
#line 269
  gateway->chain = connection;
  {
#line 271
  (*(c->c))(c, (struct lsh_object *)gateway);
  }
  }
#line 272
  return;
}
}
#line 290 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_commands.c"
struct command *make_gateway_setup(struct local_info *local ) 
{ 
  struct command *res ;
  struct command *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 293
  tmp = gateway_setup(local);
  }
#line 293
  res = tmp;
  {
#line 296
  trace("make_gateway_setup\n");
  }
  }
#line 298
  return (res);
}
}
#line 385 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h"
struct lsh_string *format_channel_open_s(struct lsh_string *type , uint32_t local_channel_number ,
                                         struct ssh_channel *channel , struct lsh_string *args ) ;
#line 396
struct lsh_string *format_channel_request_i(struct channel_request_info *info , struct ssh_channel *channel ,
                                            uint32_t args_length , uint8_t const   *args_data ) ;
#line 415
void channel_eof(struct ssh_channel *channel ) ;
#line 427
struct lsh_string *channel_transmit_data(struct ssh_channel *channel , struct lsh_string *data ) ;
#line 430
struct lsh_string *channel_transmit_extended(struct ssh_channel *channel , uint32_t type ,
                                             struct lsh_string *data ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.h.x"
struct lsh_class gateway_channel_class ;
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.h"
struct gateway_channel *make_gateway_channel(struct alist *request_types ) ;
#line 44
struct command *make_gateway_channel_open_command(struct channel_open_info *info ,
                                                  struct lsh_string *args , struct alist *requests ) ;
#line 49
struct command_continuation *make_gateway_channel_open_continuation(struct command_continuation *up ,
                                                                    struct channel_request *fallback ) ;
#line 53
struct channel_request gateway_channel_request ;
#line 54
struct global_request gateway_global_request ;
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h.x"
struct lsh_class channel_request_command_class ;
#line 76 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h"
void do_channel_request_command(struct command *s , struct lsh_object *x , struct command_continuation *c ,
                                struct exception_handler *e ) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.h.x"
static void do_gateway_channel_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct gateway_channel *i ;

  {
  {
#line 18
  i = (struct gateway_channel *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->chain);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.h.x"
struct lsh_class gateway_channel_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & ssh_channel_class, (char *)"gateway_channel", (size_t )sizeof(struct gateway_channel ),
    & do_gateway_channel_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
struct lsh_class gateway_channel_open_command_class ;
#line 18 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
static void do_gateway_channel_open_command_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct gateway_channel_open_command *i ;

  {
  {
#line 22
  i = (struct gateway_channel_open_command *)o;
  {
#line 23
  (*mark)((struct lsh_object *)i->requests);
  }
  }
#line 24
  return;
}
}
#line 25 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
static void do_gateway_channel_open_command_free(struct lsh_object *o ) 
{ 
  struct gateway_channel_open_command *i ;

  {
  {
#line 28
  i = (struct gateway_channel_open_command *)o;
  {
#line 29
  lsh_string_free((struct lsh_string  const  *)i->type);
  }
  {
#line 30
  lsh_string_free((struct lsh_string  const  *)i->args);
  }
  }
#line 31
  return;
}
}
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
struct lsh_class gateway_channel_open_command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_open_command_class, (char *)"gateway_channel_open_command",
    (size_t )sizeof(struct gateway_channel_open_command ), & do_gateway_channel_open_command_mark,
    & do_gateway_channel_open_command_free};
#line 52
struct lsh_class general_channel_request_command_class ;
#line 56 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
static void do_general_channel_request_command_free(struct lsh_object *o ) 
{ 
  struct general_channel_request_command *i ;

  {
  {
#line 59
  i = (struct general_channel_request_command *)o;
  {
#line 60
  lsh_string_free((struct lsh_string  const  *)i->request);
  }
  }
#line 61
  return;
}
}
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
struct lsh_class general_channel_request_command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_request_command_class, (char *)"general_channel_request_command",
    (size_t )sizeof(struct general_channel_request_command ), (void (*)(struct lsh_object *instance ,
                                                                        void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_general_channel_request_command_free};
#line 82
struct lsh_class general_global_request_command_class ;
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
static void do_general_global_request_command_free(struct lsh_object *o ) 
{ 
  struct general_global_request_command *i ;

  {
  {
#line 89
  i = (struct general_global_request_command *)o;
  {
#line 90
  lsh_string_free((struct lsh_string  const  *)i->request);
  }
  }
#line 91
  return;
}
}
#line 92 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
struct lsh_class general_global_request_command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & global_request_command_class, (char *)"general_global_request_command",
    (size_t )sizeof(struct general_global_request_command ), (void (*)(struct lsh_object *instance ,
                                                                       void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_general_global_request_command_free};
#line 113
struct lsh_class gateway_channel_open_continuation_class ;
#line 117 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
static void do_gateway_channel_open_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct gateway_channel_open_continuation *i ;

  {
  {
#line 121
  i = (struct gateway_channel_open_continuation *)o;
  {
#line 122
  (*mark)((struct lsh_object *)i->up);
  }
  {
#line 123
  (*mark)((struct lsh_object *)i->fallback);
  }
  }
#line 124
  return;
}
}
#line 125 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c.x"
struct lsh_class gateway_channel_open_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"gateway_channel_open_continuation",
    (size_t )sizeof(struct gateway_channel_open_continuation ), & do_gateway_channel_open_continuation_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static void do_receive___0(struct ssh_channel *c , int type , struct lsh_string *data ) 
{ 
  struct gateway_channel *channel ;
  struct lsh_string *tmp ;
  struct lsh_string *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 66
  channel = (struct gateway_channel *)c;
#line 70
  if (type == 0) {
#line 70
    goto case_0;
  }
#line 74
  if (type == 1) {
#line 74
    goto case_1;
  }
#line 79
  goto switch_default;
  case_0: 
  {
  {
#line 71
  tmp = channel_transmit_data(& (channel->chain)->super, data);
  }
  {
#line 71
  connection_send((channel->chain)->super.connection, tmp);
  }
  }
#line 73
  goto switch_break;
  case_1: 
  {
  {
#line 75
  tmp___0 = channel_transmit_extended(& (channel->chain)->super, (uint32_t )1, data);
  }
  {
#line 75
  connection_send((channel->chain)->super.connection, tmp___0);
  }
  }
#line 78
  goto switch_break;
  switch_default: 
  {
  {
#line 80
  fatal("Internal error!\n");
  }
  }
  switch_break: ;
#line 82
  return;
}
}
#line 85 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static void do_send_adjust___0(struct ssh_channel *s , uint32_t i ) 
{ 
  struct gateway_channel *self ;

  {
#line 89
  self = (struct gateway_channel *)s;
#line 90
  if (i) {
    {
    {
#line 91
    (*((self->chain)->super.super.report))(& (self->chain)->super.super, i);
    }
    }
  }
#line 92
  return;
}
}
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static void do_eof___0(struct ssh_channel *c ) 
{ 
  struct gateway_channel *channel ;

  {
  {
#line 97
  channel = (struct gateway_channel *)c;
  {
#line 98
  channel_eof(& (channel->chain)->super);
  }
  }
#line 99
  return;
}
}
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static void do_close(struct ssh_channel *c ) 
{ 
  struct gateway_channel *channel ;

  {
  {
#line 104
  channel = (struct gateway_channel *)c;
  {
#line 105
  channel_close(& (channel->chain)->super);
  }
  }
#line 106
  return;
}
}
#line 108 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static void gateway_init_io(struct gateway_channel *channel ) 
{ 


  {
#line 111
  channel->super.send_adjust = & do_send_adjust___0;
#line 112
  channel->super.receive = & do_receive___0;
#line 113
  channel->super.eof = & do_eof___0;
#line 114
  channel->super.close = & do_close;
#line 115
  return;
}
}
#line 124 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
struct gateway_channel *make_gateway_channel(struct alist *request_types ) 
{ 
  struct gateway_channel *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 127
  tmp = lsh_object_alloc(& gateway_channel_class);
  }
#line 127
  self = (struct gateway_channel *)tmp;
  {
#line 128
  init_channel(& self->super);
  }
#line 130
  self->super.request_types = request_types;
#line 134
  self->super.flags &= -17;
  }
#line 136
  return (self);
}
}
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static struct ssh_channel *do_gateway_channel_open(struct channel_open_command *c ,
                                                   struct ssh_connection *connection ,
                                                   uint32_t local_channel_number ,
                                                   struct lsh_string **request ) 
{ 
  struct gateway_channel_open_command *closure ;
  struct gateway_channel *target ;
  struct gateway_channel *tmp ;

  {
  {
#line 164
  closure = (struct gateway_channel_open_command *)c;
  {
#line 166
  tmp = make_gateway_channel(closure->requests);
  }
#line 166
  target = tmp;
#line 169
  target->super.rec_window_size = closure->rec_window_size;
#line 170
  target->super.rec_max_packet = closure->rec_max_packet;
#line 172
  target->super.connection = connection;
  {
#line 174
  *request = format_channel_open_s(closure->type, local_channel_number, & target->super,
                                   closure->args);
  }
  }
#line 179
  return (& target->super);
}
}
#line 182 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
struct command *make_gateway_channel_open_command(struct channel_open_info *info ,
                                                  struct lsh_string *args , struct alist *requests ) 
{ 
  struct gateway_channel_open_command *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 187
  tmp = lsh_object_alloc(& gateway_channel_open_command_class);
  }
#line 187
  self = (struct gateway_channel_open_command *)tmp;
#line 189
  self->super.new_channel = & do_gateway_channel_open;
#line 190
  self->super.super.call = & do_channel_open_command;
  {
#line 192
  self->type = ssh_format("%ls", info->type_length, info->type_data);
  }
#line 195
  self->rec_window_size = info->send_window_size;
#line 196
  self->rec_max_packet = info->send_max_packet;
#line 197
  self->requests = requests;
#line 198
  self->args = args;
  }
#line 200
  return (& self->super.super);
}
}
#line 215 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static struct lsh_string *do_format_channel_general(struct channel_request_command *s ,
                                                    struct ssh_channel *ch  __attribute__((__unused__)) ,
                                                    struct command_continuation **c  __attribute__((__unused__)) ) 
{ 
  struct general_channel_request_command *self ;
  struct lsh_string *r ;

  {
#line 220
  self = (struct general_channel_request_command *)s;
#line 222
  r = self->request;
#line 223
  self->request = (struct lsh_string *)((void *)0);
#line 224
  return (r);
}
}
#line 227 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static struct command *make_general_channel_request_command(struct lsh_string *request ) 
{ 
  struct general_channel_request_command *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 230
  tmp = lsh_object_alloc(& general_channel_request_command_class);
  }
#line 230
  self = (struct general_channel_request_command *)tmp;
#line 231
  self->super.super.call = & do_channel_request_command;
#line 232
  self->super.format_request = & do_format_channel_general;
#line 233
  self->request = request;
  }
#line 234
  return (& self->super.super);
}
}
#line 237 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static void do_gateway_channel_request(struct channel_request *s  __attribute__((__unused__)) ,
                                       struct ssh_channel *ch , struct channel_request_info *info ,
                                       struct simple_buffer *args , struct command_continuation *c ,
                                       struct exception_handler *e ) 
{ 
  struct gateway_channel *channel ;
  uint32_t args_length ;
  uint8_t const   *args_data ;
  struct command *command ;
  struct lsh_string *tmp ;

  {
  {
#line 245
  channel = (struct gateway_channel *)ch;
  {
#line 250
  parse_rest(args, & args_length, & args_data);
  }
  {
#line 252
  tmp = format_channel_request_i(info, & (channel->chain)->super, args_length, args_data);
  }
  {
#line 252
  command = make_general_channel_request_command(tmp);
  }
  {
#line 258
  (*(command->call))(command, (struct lsh_object *)channel->chain, c, e);
  }
  }
#line 259
  return;
}
}
#line 261 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
struct channel_request gateway_channel_request  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_gateway_channel_request};
#line 273 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static struct lsh_string *do_format_general_global_request(struct global_request_command *s ,
                                                           struct ssh_connection *connection  __attribute__((__unused__)) ,
                                                           struct command_continuation **c  __attribute__((__unused__)) ) 
{ 
  struct general_global_request_command *self ;
  struct lsh_string *r ;

  {
#line 278
  self = (struct general_global_request_command *)s;
#line 280
  r = self->request;
#line 281
  self->request = (struct lsh_string *)((void *)0);
#line 282
  return (r);
}
}
#line 285 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static struct command *make_general_global_request_command(struct lsh_string *request ) 
{ 
  struct general_global_request_command *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 288
  tmp = lsh_object_alloc(& general_global_request_command_class);
  }
#line 288
  self = (struct general_global_request_command *)tmp;
#line 290
  self->super.super.call = & do_channel_global_command;
#line 291
  self->super.format_request = & do_format_general_global_request;
#line 292
  self->request = request;
  }
#line 293
  return (& self->super.super);
}
}
#line 296 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static void do_gateway_global_request(struct global_request *s  __attribute__((__unused__)) ,
                                      struct ssh_connection *connection , uint32_t type ,
                                      int want_reply , struct simple_buffer *args ,
                                      struct command_continuation *c , struct exception_handler *e ) 
{ 
  struct lsh_string *request ;
  struct lsh_string *tmp ;
  struct command *send___0 ;
  struct command *tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 305
  tmp = format_global_request((int )type, want_reply, "%ls", args->capacity - args->pos,
                              args->data + args->pos);
  }
#line 305
  request = tmp;
  {
#line 309
  tmp___0 = make_general_global_request_command(request);
  }
#line 309
  send___0 = tmp___0;
  {
#line 311
  (*(send___0->call))(send___0, (struct lsh_object *)connection->chain, c, e);
  }
  }
#line 312
  return;
}
}
#line 314 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
struct global_request gateway_global_request  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_gateway_global_request};
#line 335 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static void do_gateway_channel_open_continuation(struct command_continuation *c ,
                                                 struct lsh_object *x ) 
{ 
  struct gateway_channel_open_continuation *self ;
  struct gateway_channel *target ;
  struct gateway_channel *origin ;
  struct gateway_channel *tmp ;

  {
  {
#line 339
  self = (struct gateway_channel_open_continuation *)c;
#line 340
  target = (struct gateway_channel *)x;
  {
#line 342
  tmp = make_gateway_channel((struct alist *)((void *)0));
  }
#line 342
  origin = tmp;
#line 345
  origin->super.request_fallback = & gateway_channel_request;
#line 347
  origin->chain = target;
#line 348
  target->chain = origin;
#line 350
  origin->super.rec_window_size = target->super.send_window_size;
#line 351
  origin->super.rec_max_packet = target->super.send_max_packet;
  {
#line 353
  gateway_init_io(origin);
  }
  {
#line 354
  gateway_init_io(target);
  }
#line 356
  target->super.request_fallback = self->fallback;
  {
#line 358
  (*((self->up)->c))(self->up, (struct lsh_object *)origin);
  }
  }
#line 359
  return;
}
}
#line 361 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
struct command_continuation *make_gateway_channel_open_continuation(struct command_continuation *up ,
                                                                    struct channel_request *fallback ) 
{ 
  struct gateway_channel_open_continuation *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 365
  tmp = lsh_object_alloc(& gateway_channel_open_continuation_class);
  }
#line 365
  self = (struct gateway_channel_open_continuation *)tmp;
#line 367
  self->super.c = & do_gateway_channel_open_continuation;
#line 368
  self->fallback = fallback;
#line 369
  self->up = up;
  }
#line 371
  return (& self->super);
}
}
#line 374 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
static void do_channel_open_forward(struct channel_open *s  __attribute__((__unused__)) ,
                                    struct ssh_connection *connection , struct channel_open_info *info ,
                                    struct simple_buffer *args , struct command_continuation *c ,
                                    struct exception_handler *e ) 
{ 
  struct command *command ;
  struct lsh_string *tmp ;
  struct command *tmp___0 ;
  struct command_continuation *tmp___1 ;

  {
  {
  {
#line 382
  tmp = parse_rest_copy(args);
  }
  {
#line 382
  tmp___0 = make_gateway_channel_open_command(info, tmp, (struct alist *)((void *)0));
  }
#line 382
  command = tmp___0;
  {
#line 385
  tmp___1 = make_gateway_channel_open_continuation(c, & gateway_channel_request);
  }
  {
#line 385
  (*(command->call))(command, (struct lsh_object *)connection->chain, tmp___1, e);
  }
  }
#line 393
  return;
}
}
#line 395 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway_channel.c"
struct channel_open gateway_channel_open_forward  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channel_open_forward};
#line 33 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway.h"
struct local_info *make_gateway_address(char const   *local_user , char const   *remote_user ,
                                        char const   *target ) ;
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway.c"
static int check_string_l(unsigned int length , uint8_t const   *s ) 
{ 
  unsigned int i ;
  uint8_t const   *tmp ;

  {
#line 54
  i = 0U;
  {
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 54
    if (! (i < length)) {
#line 54
      goto while_break;
    }
#line 55
    tmp = s;
#line 55
    s ++;
#line 59
    if ((int const   )*tmp == 47) {
#line 59
      goto case_47;
    }
#line 59
    if ((int const   )*tmp == 37) {
#line 59
      goto case_47;
    }
#line 59
    if ((int const   )*tmp == 0) {
#line 59
      goto case_47;
    }
#line 61
    goto switch_default;
    case_47: 
#line 60
    return (0);
    switch_default: 
#line 62
    goto switch_break;
    switch_break: 
#line 54
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 64
  return (1);
}
}
#line 67 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway.c"
static int check_string(uint8_t const   *s ) 
{ 
  uint8_t const   *tmp ;

  {
  {
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 71
    tmp = s;
#line 71
    s ++;
#line 73
    if ((int const   )*tmp == 0) {
#line 73
      goto case_0;
    }
#line 76
    if ((int const   )*tmp == 47) {
#line 76
      goto case_47;
    }
#line 76
    if ((int const   )*tmp == 37) {
#line 76
      goto case_47;
    }
#line 78
    goto switch_default;
    case_0: 
#line 74
    return (1);
    case_47: 
#line 77
    return (0);
    switch_default: 
#line 79
    goto switch_break;
    switch_break: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 86
  return (0);
}
}
#line 83 "/home/ysko/Works/test-src/lsh-2.0.4/src/gateway.c"
struct local_info *make_gateway_address(char const   *local_user , char const   *remote_user ,
                                        char const   *target ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int length ;
  size_t tmp___1 ;
  struct lsh_string *tmp___2 ;
  struct lsh_string *tmp___3 ;
  struct local_info *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
  {
#line 87
  tmp___0 = getenv("TMPDIR");
  }
#line 87
  tmp = tmp___0;
  {
#line 88
  tmp___1 = strlen(target);
  }
#line 88
  length = tmp___1;
  }
#line 89
  if (! tmp) {
#line 90
    tmp = (char *)"/tmp";
  }
  {
  {
#line 92
  tmp___5 = check_string((uint8_t const   *)local_user);
  }
  }
#line 92
  if (tmp___5) {
    {
    {
#line 92
    tmp___6 = check_string((uint8_t const   *)remote_user);
    }
    }
#line 92
    if (tmp___6) {
      {
      {
#line 92
      tmp___7 = check_string_l(length, (uint8_t const   *)target);
      }
      }
#line 92
      if (tmp___7) {
        {
        {
#line 95
        tmp___2 = ssh_format("%lz:%lz", target, remote_user);
        }
        {
#line 95
        tmp___3 = ssh_format("%lz/x-lsh-%lz", tmp, local_user);
        }
        {
#line 95
        tmp___4 = make_local_info(tmp___3, tmp___2);
        }
        }
#line 95
        return (tmp___4);
      } else {
#line 98
        return ((struct local_info *)((void *)0));
      }
    } else {
#line 98
      return ((struct local_info *)((void *)0));
    }
  } else {
#line 98
    return ((struct local_info *)((void *)0));
  }
}
}
#line 80 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.h"
uint32_t ssh_format_length(char const   *format  , ...) ;
#line 81
void ssh_format_write(char const   *format , struct lsh_string *buffer , uint32_t start 
                      , ...) ;
#line 84
uint32_t ssh_vformat_length(char const   *f , va_list args ) ;
#line 85
void ssh_vformat_write(char const   *f , struct lsh_string *buffer , uint32_t pos ,
                       va_list args ) ;
#line 88
void format_hex_string(struct lsh_string *buffer , uint32_t pos , uint32_t length ,
                       uint8_t const   *data ) ;
#line 99
void format_decimal(struct lsh_string *buffer , uint32_t start , uint32_t length ,
                    uint32_t n ) ;
#line 106
struct lsh_string *lsh_string_colonize(struct lsh_string  const  *s , int every ,
                                       int freeflag ) ;
#line 109
struct lsh_string *lsh_string_bubblebabble(struct lsh_string  const  *s , int freeflag ) ;
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
struct lsh_string *ssh_format(char const   *format  , ...) 
{ 
  va_list args ;
  uint32_t length ;
  struct lsh_string *packet ;

  {
  {
  {
#line 46
  __builtin_va_start(args, format);
  }
  {
#line 47
  length = ssh_vformat_length(format, args);
  }
  {
#line 48
  __builtin_va_end(args);
  }
  {
#line 53
  packet = lsh_string_alloc(length);
  }
  {
#line 56
  __builtin_va_start(args, format);
  }
  {
#line 57
  ssh_vformat_write(format, packet, (uint32_t )0, args);
  }
  {
#line 58
  __builtin_va_end(args);
  }
  }
#line 60
  return (packet);
}
}
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
uint32_t ssh_format_length(char const   *format  , ...) 
{ 
  va_list args ;
  uint32_t length ;

  {
  {
  {
#line 68
  __builtin_va_start(args, format);
  }
  {
#line 69
  length = ssh_vformat_length(format, args);
  }
  {
#line 70
  __builtin_va_end(args);
  }
  }
#line 72
  return (length);
}
}
#line 75 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
void ssh_format_write(char const   *format , struct lsh_string *buffer , uint32_t start 
                      , ...) 
{ 
  va_list args ;

  {
  {
  {
#line 80
  __builtin_va_start(args, start);
  }
  {
#line 81
  ssh_vformat_write(format, buffer, start, args);
  }
  {
#line 82
  __builtin_va_end(args);
  }
  }
#line 83
  return;
}
}
#line 85
static int write_decimal_length(struct lsh_string *buffer , uint32_t start , uint32_t n ) ;
#line 88 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
uint32_t ssh_vformat_length(char const   *f , va_list args ) 
{ 
  uint32_t length ;
  int literal ;
  int decimal ;
  int unsigned_form ;
  int hex ;
  char const   *tmp ;
  int tmp___1 ;
  uint32_t i ;
  uint32_t tmp___3 ;
  unsigned int tmp___4 ;
  uint32_t l ;
  uint32_t tmp___6 ;
  uint8_t const   *tmp___8 ;
  unsigned int tmp___9 ;
  struct lsh_string *s ;
  struct lsh_string *tmp___11 ;
  uint32_t l___0 ;
  uint32_t tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int l___1 ;
  char const   *tmp___15 ;
  size_t tmp___16 ;
  unsigned int tmp___17 ;
  uint32_t l___2 ;
  uint32_t tmp___19 ;
  uint8_t **tmp___21 ;
  unsigned int tmp___22 ;
  int atom ;
  int tmp___24 ;
  int l___3 ;
  uint32_t tmp___25 ;
  unsigned int tmp___26 ;
  struct int_list *l___4 ;
  struct int_list *tmp___28 ;
  uint32_t n ;
  uint32_t i___0 ;
  uint32_t tmp___29 ;
  MP_INT *n___0 ;
  MP_INT *tmp___31 ;
  unsigned int l___5 ;
  int tmp___32 ;
  unsigned int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  uint32_t tmp___37 ;
  uint32_t tmp___38 ;
  uint8_t const   *tmp___39 ;
  struct lsh_string *tmp___40 ;
  char const   *tmp___41 ;
  uint32_t tmp___42 ;
  uint8_t **tmp___43 ;
  int tmp___44 ;
  struct int_list *tmp___45 ;
  MP_INT *tmp___46 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;

  {
#line 90
  length = (uint32_t )0;
  {
  {
#line 92
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 92
    if (! *f) {
#line 92
      goto while_break;
    }
#line 94
    if ((int const   )*f == 37) {
#line 96
      literal = 0;
#line 97
      decimal = 0;
#line 98
      unsigned_form = 0;
#line 99
      hex = 0;
      {
      {
#line 101
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 101
        f ++;
#line 101
        if (! *f) {
#line 101
          goto while_break___0;
        }
#line 105
        if ((int const   )*f == 108) {
#line 105
          goto case_108;
        }
#line 108
        if ((int const   )*f == 100) {
#line 108
          goto case_100;
        }
#line 111
        if ((int const   )*f == 102) {
#line 111
          goto case_102;
        }
#line 114
        if ((int const   )*f == 117) {
#line 114
          goto case_117;
        }
#line 117
        if ((int const   )*f == 120) {
#line 117
          goto case_120;
        }
#line 120
        goto switch_default;
        case_108: 
#line 106
        literal = 1;
#line 107
        goto switch_break;
        case_100: 
#line 109
        decimal = 1;
#line 110
        goto switch_break;
        case_102: 
#line 113
        goto switch_break;
        case_117: 
#line 115
        unsigned_form = 1;
#line 116
        goto switch_break;
        case_120: 
#line 118
        hex = 1;
#line 119
        goto switch_break;
        switch_default: 
#line 121
        goto end_options;
        switch_break: ;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
      end_options: 
#line 126
      if (literal) {
#line 126
        if (decimal) {
          {
          {
#line 127
          fatal("Internal error!\n");
          }
          }
        }
      }
#line 129
      tmp = f;
#line 129
      f ++;
#line 131
      if ((int const   )*tmp == 99) {
#line 131
        goto case_99;
      }
#line 134
      if ((int const   )*tmp == 37) {
#line 134
        goto case_37;
      }
#line 138
      if ((int const   )*tmp == 105) {
#line 138
        goto case_105;
      }
#line 148
      if ((int const   )*tmp == 115) {
#line 148
        goto case_115;
      }
#line 165
      if ((int const   )*tmp == 83) {
#line 165
        goto case_83;
      }
#line 181
      if ((int const   )*tmp == 122) {
#line 181
        goto case_122;
      }
#line 193
      if ((int const   )*tmp == 114) {
#line 193
        goto case_114;
      }
#line 206
      if ((int const   )*tmp == 97) {
#line 206
        goto case_97;
      }
#line 223
      if ((int const   )*tmp == 65) {
#line 223
        goto case_65;
      }
#line 248
      if ((int const   )*tmp == 110) {
#line 248
        goto case_110;
      }
#line 276
      goto switch_default___0;
      case_99: 
      {
      {
#line 132
      tmp___36 = __builtin_va_arg(args, int );
      }
#line 132
      tmp___1 = tmp___36;
      }
      case_37: 
#line 135
      length ++;
#line 136
      goto switch_break___0;
      case_105: 
      {
      {
#line 140
      tmp___37 = __builtin_va_arg(args, uint32_t );
      }
#line 140
      tmp___3 = tmp___37;
#line 140
      i = tmp___3;
      }
#line 141
      if (decimal) {
        {
        {
#line 142
        tmp___4 = format_size_in_decimal(i);
        }
#line 142
        length += tmp___4;
        }
      } else {
#line 144
        length += 4U;
      }
#line 145
      goto switch_break___0;
      case_115: 
      {
      {
#line 150
      tmp___38 = __builtin_va_arg(args, uint32_t );
      }
#line 150
      tmp___6 = tmp___38;
#line 150
      l = tmp___6;
      {
#line 151
      tmp___39 = __builtin_va_arg(args, uint8_t const   *);
      }
#line 151
      tmp___8 = tmp___39;
#line 153
      length += l;
      }
#line 155
      if (hex) {
#line 156
        length += l;
      }
#line 158
      if (decimal) {
        {
        {
#line 159
        tmp___9 = format_size_in_decimal(l);
        }
#line 159
        length += tmp___9 + 1U;
        }
      } else
#line 160
      if (! literal) {
#line 161
        length += 4U;
      }
#line 163
      goto switch_break___0;
      case_83: 
      {
      {
#line 167
      tmp___40 = __builtin_va_arg(args, struct lsh_string *);
      }
#line 167
      tmp___11 = tmp___40;
#line 167
      s = tmp___11;
      {
#line 168
      tmp___12 = lsh_string_length((struct lsh_string  const  *)s);
      }
#line 168
      l___0 = tmp___12;
#line 169
      length += l___0;
      }
#line 171
      if (hex) {
#line 172
        length += l___0;
      }
#line 174
      if (decimal) {
        {
        {
#line 175
        tmp___13 = format_size_in_decimal(l___0);
        }
#line 175
        length += tmp___13 + 1U;
        }
      } else
#line 176
      if (! literal) {
#line 177
        length += 4U;
      }
#line 179
      goto switch_break___0;
      case_122: 
      {
      {
#line 183
      tmp___41 = __builtin_va_arg(args, char const   *);
      }
#line 183
      tmp___15 = tmp___41;
      {
#line 183
      tmp___16 = strlen(tmp___15);
      }
#line 183
      l___1 = tmp___16;
#line 184
      length += l___1;
      }
#line 186
      if (decimal) {
        {
        {
#line 187
        tmp___17 = format_size_in_decimal(l___1);
        }
#line 187
        length += tmp___17 + 1U;
        }
      } else
#line 189
      if (! literal) {
#line 190
        length += 4U;
      }
#line 191
      goto switch_break___0;
      case_114: 
      {
      {
#line 195
      tmp___42 = __builtin_va_arg(args, uint32_t );
      }
#line 195
      tmp___19 = tmp___42;
#line 195
      l___2 = tmp___19;
#line 196
      length += l___2;
      {
#line 197
      tmp___43 = __builtin_va_arg(args, uint8_t **);
      }
#line 197
      tmp___21 = tmp___43;
      }
#line 199
      if (decimal) {
        {
        {
#line 200
        tmp___22 = format_size_in_decimal(l___2);
        }
#line 200
        length += tmp___22 + 1U;
        }
      } else
#line 201
      if (! literal) {
#line 202
        length += 4U;
      }
#line 204
      goto switch_break___0;
      case_97: 
      {
      {
#line 208
      tmp___44 = __builtin_va_arg(args, int );
      }
#line 208
      tmp___24 = tmp___44;
#line 208
      atom = tmp___24;
      }
#line 211
      if (! atom) {
        {
        {
#line 211
        __assert_fail("atom", "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c",
                      211U, "ssh_vformat_length");
        }
        }
      }
      {
      {
#line 213
      tmp___25 = get_atom_length(atom);
      }
#line 213
      l___3 = (int )tmp___25;
#line 214
      length += (uint32_t )l___3;
      }
#line 216
      if (decimal) {
        {
        {
#line 217
        tmp___26 = format_size_in_decimal((uint32_t )l___3);
        }
#line 217
        length += tmp___26 + 1U;
        }
      } else
#line 218
      if (! literal) {
#line 219
        length += 4U;
      }
#line 221
      goto switch_break___0;
      case_65: 
      {
      {
#line 225
      tmp___45 = __builtin_va_arg(args, struct int_list *);
      }
#line 225
      tmp___28 = tmp___45;
#line 225
      l___4 = tmp___28;
      }
#line 228
      if (decimal) {
        {
        {
#line 229
        fatal("ssh_format: Decimal lengths not supported for %%A\n");
        }
        }
      }
#line 231
      i___0 = (uint32_t )0;
#line 231
      n = i___0;
      {
      {
#line 231
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;

#line 231
        if (! (i___0 < l___4->super.length)) {
#line 231
          goto while_break___1;
        }
#line 233
        if (l___4->elements[i___0]) {
          {
#line 235
          n ++;
          {
#line 236
          tmp___29 = get_atom_length(l___4->elements[i___0]);
          }
#line 236
          length += tmp___29;
          }
        }
#line 231
        i___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
#line 239
      if (n) {
#line 241
        length += n - 1U;
      }
#line 243
      if (! literal) {
#line 244
        length += 4U;
      }
#line 246
      goto switch_break___0;
      case_110: 
      {
      {
#line 250
      tmp___46 = __builtin_va_arg(args, MP_INT *);
      }
#line 250
      tmp___31 = tmp___46;
#line 250
      n___0 = tmp___31;
      }
#line 254
      if (unsigned_form) {
#line 256
        if (n___0->_mp_size < 0) {
#line 256
          tmp___32 = -1;
        } else {
#line 256
          tmp___32 = n___0->_mp_size > 0;
        }
#line 256
        if (! (tmp___32 >= 0)) {
          {
          {
#line 256
          __assert_fail("((n)->_mp_size < 0 ? -1 : (n)->_mp_size > 0) >= 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c",
                        256U, "ssh_vformat_length");
          }
          }
        }
        {
        {
#line 257
        l___5 = nettle_mpz_sizeinbase_256_u((__mpz_struct */* const  */)n___0);
        }
        }
      } else {
#line 264
        if (n___0->_mp_size < 0) {
#line 264
          tmp___35 = -1;
        } else {
#line 264
          tmp___35 = n___0->_mp_size > 0;
        }
#line 264
        if (tmp___35) {
          {
          {
#line 264
          tmp___34 = nettle_mpz_sizeinbase_256_s((__mpz_struct */* const  */)n___0);
          }
#line 264
          l___5 = tmp___34;
          }
        } else {
#line 264
          l___5 = 0U;
        }
      }
#line 266
      length += l___5;
#line 269
      if (! (! decimal)) {
        {
        {
#line 269
        __assert_fail("!decimal", "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c",
                      269U, "ssh_vformat_length");
        }
        }
      }
#line 271
      if (! literal) {
#line 272
        length += 4U;
      }
#line 274
      goto switch_break___0;
      switch_default___0: 
      {
      {
#line 277
      fatal("ssh_vformat_length: bad format string");
      }
      }
#line 278
      goto switch_break___0;
      switch_break___0: ;
    } else {
#line 283
      length ++;
#line 284
      f ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 287
  return (length);
}
}
#line 290 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
void ssh_vformat_write(char const   *f , struct lsh_string *buffer , uint32_t pos ,
                       va_list args ) 
{ 
  int literal ;
  int do_free ;
  int decimal ;
  int hex ;
  int unsigned_form ;
  uint32_t size ;
  uint8_t const   *data ;
  char const   *tmp ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t i ;
  uint32_t tmp___5 ;
  unsigned int length ;
  unsigned int tmp___6 ;
  uint8_t const   *tmp___7 ;
  uint32_t tmp___8 ;
  uint8_t const   *tmp___9 ;
  uint32_t length___0 ;
  uint32_t tmp___10 ;
  int tmp___11 ;
  struct lsh_string *s ;
  struct lsh_string *tmp___13 ;
  uint32_t length___1 ;
  int tmp___14 ;
  uint32_t length___2 ;
  uint32_t tmp___16 ;
  uint32_t *p ;
  uint32_t *tmp___18 ;
  int tmp___19 ;
  uint32_t length___3 ;
  int atom ;
  int tmp___21 ;
  int tmp___22 ;
  uint8_t const   *tmp___23 ;
  struct int_list *l ;
  struct int_list *tmp___25 ;
  uint32_t start ;
  uint32_t n ;
  uint32_t i___0 ;
  uint32_t length___4 ;
  uint32_t tmp___26 ;
  uint32_t tmp___27 ;
  uint8_t const   *tmp___28 ;
  uint32_t total ;
  MP_INT *n___0 ;
  MP_INT *tmp___30 ;
  uint32_t length___5 ;
  int tmp___31 ;
  unsigned int tmp___33 ;
  int tmp___34 ;
  char const   *tmp___35 ;
  uint32_t tmp___36 ;
  int tmp___37 ;
  uint32_t tmp___38 ;
  uint8_t const   *tmp___39 ;
  uint32_t tmp___40 ;
  uint8_t const   *tmp___41 ;
  struct lsh_string *tmp___42 ;
  uint32_t tmp___43 ;
  uint32_t *tmp___44 ;
  int tmp___45 ;
  struct int_list *tmp___46 ;
  MP_INT *tmp___47 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;

  {
  {
  {
#line 293
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 293
    if (! *f) {
#line 293
      goto while_break;
    }
#line 295
    if ((int const   )*f == 37) {
#line 297
      literal = 0;
#line 298
      do_free = 0;
#line 299
      decimal = 0;
#line 300
      hex = 0;
#line 301
      unsigned_form = 0;
      {
      {
#line 306
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 306
        f ++;
#line 306
        if (! *f) {
#line 306
          goto while_break___0;
        }
#line 310
        if ((int const   )*f == 108) {
#line 310
          goto case_108;
        }
#line 313
        if ((int const   )*f == 100) {
#line 313
          goto case_100;
        }
#line 316
        if ((int const   )*f == 102) {
#line 316
          goto case_102;
        }
#line 319
        if ((int const   )*f == 117) {
#line 319
          goto case_117;
        }
#line 322
        if ((int const   )*f == 120) {
#line 322
          goto case_120;
        }
#line 325
        goto switch_default;
        case_108: 
#line 311
        literal = 1;
#line 312
        goto switch_break;
        case_100: 
#line 314
        decimal = 1;
#line 315
        goto switch_break;
        case_102: 
#line 317
        do_free = 1;
#line 318
        goto switch_break;
        case_117: 
#line 320
        unsigned_form = 1;
#line 321
        goto switch_break;
        case_120: 
#line 323
        hex = 1;
#line 324
        goto switch_break;
        switch_default: 
#line 326
        goto end_options;
        switch_break: ;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
      end_options: 
#line 331
      if (literal) {
#line 331
        if (decimal) {
          {
          {
#line 332
          fatal("Internal error!\n");
          }
          }
        }
      }
#line 334
      tmp = f;
#line 334
      f ++;
#line 336
      if ((int const   )*tmp == 99) {
#line 336
        goto case_99;
      }
#line 340
      if ((int const   )*tmp == 37) {
#line 340
        goto case_37;
      }
#line 344
      if ((int const   )*tmp == 105) {
#line 344
        goto case_105;
      }
#line 361
      if ((int const   )*tmp == 122) {
#line 361
        goto case_122;
      }
#line 367
      if ((int const   )*tmp == 115) {
#line 367
        goto case_115;
      }
#line 394
      if ((int const   )*tmp == 83) {
#line 394
        goto case_83;
      }
#line 426
      if ((int const   )*tmp == 114) {
#line 426
        goto case_114;
      }
#line 446
      if ((int const   )*tmp == 97) {
#line 446
        goto case_97;
      }
#line 468
      if ((int const   )*tmp == 65) {
#line 468
        goto case_65;
      }
#line 504
      if ((int const   )*tmp == 110) {
#line 504
        goto case_110;
      }
#line 531
      goto switch_default___0;
      case_99: 
      {
      {
#line 337
      tmp___37 = __builtin_va_arg(args, int );
      }
#line 337
      tmp___1 = tmp___37;
#line 337
      tmp___2 = pos;
#line 337
      pos ++;
      {
#line 337
      lsh_string_putc(buffer, tmp___2, (uint8_t )tmp___1);
      }
      }
#line 338
      goto switch_break___0;
      case_37: 
      {
#line 341
      tmp___3 = pos;
#line 341
      pos ++;
      {
#line 341
      lsh_string_putc(buffer, tmp___3, (uint8_t )'%');
      }
      }
#line 342
      goto switch_break___0;
      case_105: 
      {
      {
#line 346
      tmp___38 = __builtin_va_arg(args, uint32_t );
      }
#line 346
      tmp___5 = tmp___38;
#line 346
      i = tmp___5;
      }
#line 347
      if (decimal) {
        {
        {
#line 349
        tmp___6 = format_size_in_decimal(i);
        }
#line 349
        length = tmp___6;
        {
#line 350
        format_decimal(buffer, pos, length, i);
        }
#line 351
        pos += length;
        }
      } else {
        {
        {
#line 355
        lsh_string_write_uint32(buffer, pos, i);
        }
#line 356
        pos += 4U;
        }
      }
#line 358
      goto switch_break___0;
      case_122: 
      {
      {
#line 362
      tmp___39 = __builtin_va_arg(args, char const   *);
      }
#line 362
      tmp___7 = tmp___39;
#line 362
      data = tmp___7;
      {
#line 363
      size = strlen((char const   *)data);
      }
      }
#line 365
      goto do_string;
      case_115: 
      {
      {
#line 368
      tmp___40 = __builtin_va_arg(args, uint32_t );
      }
#line 368
      tmp___8 = tmp___40;
#line 368
      size = tmp___8;
      {
#line 369
      tmp___41 = __builtin_va_arg(args, uint8_t const   *);
      }
#line 369
      tmp___9 = tmp___41;
#line 369
      data = tmp___9;
      }
      do_string: 
#line 373
      if (hex) {
#line 373
        tmp___10 = 2U * size;
      } else {
#line 373
        tmp___10 = size;
      }
#line 373
      length___0 = tmp___10;
#line 375
      if (! (! do_free)) {
        {
        {
#line 375
        __assert_fail("!do_free", "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c",
                      375U, "ssh_vformat_write");
        }
        }
      }
#line 377
      if (decimal) {
        {
        {
#line 378
        tmp___11 = write_decimal_length(buffer, pos, length___0);
        }
#line 378
        pos += (uint32_t )tmp___11;
        }
      } else
#line 379
      if (! literal) {
        {
        {
#line 381
        lsh_string_write_uint32(buffer, pos, length___0);
        }
#line 382
        pos += 4U;
        }
      }
#line 385
      if (hex) {
        {
        {
#line 386
        format_hex_string(buffer, pos, size, data);
        }
        }
      } else {
        {
        {
#line 388
        lsh_string_write(buffer, pos, size, data);
        }
        }
      }
#line 390
      pos += length___0;
#line 391
      goto switch_break___0;
      case_83: 
      {
      {
#line 396
      tmp___42 = __builtin_va_arg(args, struct lsh_string *);
      }
#line 396
      tmp___13 = tmp___42;
#line 396
      s = tmp___13;
      {
#line 399
      size = lsh_string_length((struct lsh_string  const  *)s);
      }
      {
#line 400
      data = lsh_string_data((struct lsh_string  const  *)s);
      }
      }
#line 403
      if (hex) {
#line 403
        length___1 = 2U * size;
      } else {
#line 403
        length___1 = size;
      }
#line 405
      if (decimal) {
        {
        {
#line 406
        tmp___14 = write_decimal_length(buffer, pos, length___1);
        }
#line 406
        pos += (uint32_t )tmp___14;
        }
      } else
#line 407
      if (! literal) {
        {
        {
#line 409
        lsh_string_write_uint32(buffer, pos, length___1);
        }
#line 410
        pos += 4U;
        }
      }
#line 413
      if (hex) {
        {
        {
#line 414
        format_hex_string(buffer, pos, size, data);
        }
        }
      } else {
        {
        {
#line 416
        lsh_string_write(buffer, pos, size, data);
        }
        }
      }
#line 418
      pos += length___1;
#line 420
      if (do_free) {
        {
        {
#line 421
        lsh_string_free((struct lsh_string  const  *)s);
        }
        }
      }
#line 423
      goto switch_break___0;
      case_114: 
      {
      {
#line 428
      tmp___43 = __builtin_va_arg(args, uint32_t );
      }
#line 428
      tmp___16 = tmp___43;
#line 428
      length___2 = tmp___16;
      {
#line 429
      tmp___44 = __builtin_va_arg(args, uint32_t *);
      }
#line 429
      tmp___18 = tmp___44;
#line 429
      p = tmp___18;
      }
#line 431
      if (decimal) {
        {
        {
#line 432
        tmp___19 = write_decimal_length(buffer, pos, length___2);
        }
#line 432
        pos += (uint32_t )tmp___19;
        }
      } else
#line 433
      if (! literal) {
        {
        {
#line 435
        lsh_string_write_uint32(buffer, pos, length___2);
        }
#line 436
        pos += 4U;
        }
      }
#line 439
      if (p) {
#line 440
        *p = pos;
      }
#line 441
      pos += length___2;
#line 443
      goto switch_break___0;
      case_97: 
      {
      {
#line 449
      tmp___45 = __builtin_va_arg(args, int );
      }
#line 449
      tmp___21 = tmp___45;
#line 449
      atom = tmp___21;
      }
#line 451
      if (! atom) {
        {
        {
#line 451
        __assert_fail("atom", "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c",
                      451U, "ssh_vformat_write");
        }
        }
      }
      {
      {
#line 453
      length___3 = get_atom_length(atom);
      }
      }
#line 455
      if (decimal) {
        {
        {
#line 456
        tmp___22 = write_decimal_length(buffer, pos, length___3);
        }
#line 456
        pos += (uint32_t )tmp___22;
        }
      } else
#line 457
      if (! literal) {
        {
        {
#line 459
        lsh_string_write_uint32(buffer, pos, length___3);
        }
#line 460
        pos += 4U;
        }
      }
      {
      {
#line 463
      tmp___23 = get_atom_name(atom);
      }
      {
#line 463
      lsh_string_write(buffer, pos, length___3, tmp___23);
      }
#line 464
      pos += length___3;
      }
#line 466
      goto switch_break___0;
      case_65: 
      {
      {
#line 470
      tmp___46 = __builtin_va_arg(args, struct int_list *);
      }
#line 470
      tmp___25 = tmp___46;
#line 470
      l = tmp___25;
#line 471
      start = pos;
      }
#line 474
      if (decimal) {
        {
        {
#line 475
        fatal("ssh_format: Decimal lengths not supported for %%A\n");
        }
        }
      }
#line 477
      if (! literal) {
#line 478
        pos += 4U;
      }
#line 480
      i___0 = (uint32_t )0;
#line 480
      n = i___0;
      {
      {
#line 480
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;

#line 480
        if (! (i___0 < l->super.length)) {
#line 480
          goto while_break___1;
        }
#line 482
        if (l->elements[i___0]) {
          {
          {
#line 484
          tmp___26 = get_atom_length(l->elements[i___0]);
          }
#line 484
          length___4 = tmp___26;
          }
#line 486
          if (n) {
            {
#line 488
            tmp___27 = pos;
#line 488
            pos ++;
            {
#line 488
            lsh_string_putc(buffer, tmp___27, (uint8_t )',');
            }
            }
          }
          {
          {
#line 490
          tmp___28 = get_atom_name(l->elements[i___0]);
          }
          {
#line 490
          lsh_string_write(buffer, pos, length___4, tmp___28);
          }
#line 491
          pos += length___4;
#line 493
          n ++;
          }
        }
#line 480
        i___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
#line 497
      if (! literal) {
        {
#line 499
        total = (pos - start) - 4U;
        {
#line 500
        lsh_string_write_uint32(buffer, start, total);
        }
        }
      }
#line 502
      goto switch_break___0;
      case_110: 
      {
      {
#line 506
      tmp___47 = __builtin_va_arg(args, MP_INT *);
      }
#line 506
      tmp___30 = tmp___47;
#line 506
      n___0 = tmp___30;
      }
#line 510
      if (! (! decimal)) {
        {
        {
#line 510
        __assert_fail("!decimal", "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c",
                      510U, "ssh_vformat_write");
        }
        }
      }
#line 512
      if (unsigned_form) {
#line 514
        if (n___0->_mp_size < 0) {
#line 514
          tmp___31 = -1;
        } else {
#line 514
          tmp___31 = n___0->_mp_size > 0;
        }
#line 514
        if (! (tmp___31 >= 0)) {
          {
          {
#line 514
          __assert_fail("((n)->_mp_size < 0 ? -1 : (n)->_mp_size > 0) >= 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c",
                        514U, "ssh_vformat_write");
          }
          }
        }
        {
        {
#line 516
        length___5 = nettle_mpz_sizeinbase_256_u((__mpz_struct */* const  */)n___0);
        }
        }
      } else {
#line 519
        if (n___0->_mp_size < 0) {
#line 519
          tmp___34 = -1;
        } else {
#line 519
          tmp___34 = n___0->_mp_size > 0;
        }
#line 519
        if (tmp___34) {
          {
          {
#line 519
          tmp___33 = nettle_mpz_sizeinbase_256_s((__mpz_struct */* const  */)n___0);
          }
#line 519
          length___5 = tmp___33;
          }
        } else {
#line 519
          length___5 = (uint32_t )0;
        }
      }
#line 521
      if (! literal) {
        {
        {
#line 523
        lsh_string_write_uint32(buffer, pos, length___5);
        }
#line 524
        pos += 4U;
        }
      }
      {
      {
#line 526
      lsh_string_write_bignum(buffer, pos, length___5, (__mpz_struct */* const  */)n___0);
      }
#line 527
      pos += length___5;
      }
#line 529
      goto switch_break___0;
      switch_default___0: 
      {
      {
#line 532
      fatal("ssh_vformat_write: bad format string");
      }
      }
#line 533
      goto switch_break___0;
      switch_break___0: ;
    } else {
      {
#line 537
      tmp___35 = f;
#line 537
      f ++;
#line 537
      tmp___36 = pos;
#line 537
      pos ++;
      {
#line 537
      lsh_string_putc(buffer, tmp___36, (uint8_t )*tmp___35);
      }
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 539
  return;
}
}
#line 548 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
static uint32_t const   powers___0[4]  = {      (uint32_t const   )10UL,      (uint32_t const   )100UL,      (uint32_t const   )10000UL,      (uint32_t const   )100000000UL};
#line 541 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
unsigned int format_size_in_decimal(uint32_t n ) 
{ 
  int i ;
  int e ;

  {
#line 553
  i = (int )(sizeof(powers___0) / sizeof(powers___0[0]) - 1UL);
#line 553
  e = 0;
  {
  {
#line 553
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 553
    if (! (i >= 0)) {
#line 553
      goto while_break;
    }
#line 555
    if (n >= (uint32_t )powers___0[i]) {
#line 557
      e = (int )((unsigned long )e + (1UL << i));
#line 558
      n /= (uint32_t )powers___0[i];
    }
#line 553
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 564
  return ((unsigned int )(e + 1));
}
}
#line 572 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
static uint8_t const   hexchars[16]  = 
#line 572
  {      (uint8_t const   )'0',      (uint8_t const   )'1',      (uint8_t const   )'2',      (uint8_t const   )'3', 
        (uint8_t const   )'4',      (uint8_t const   )'5',      (uint8_t const   )'6',      (uint8_t const   )'7', 
        (uint8_t const   )'8',      (uint8_t const   )'9',      (uint8_t const   )'a',      (uint8_t const   )'b', 
        (uint8_t const   )'c',      (uint8_t const   )'d',      (uint8_t const   )'e',      (uint8_t const   )'f'};
#line 568 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
void format_hex_string(struct lsh_string *buffer , uint32_t pos , uint32_t length ,
                       uint8_t const   *data ) 
{ 
  uint32_t i ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 575
  i = (uint32_t )0;
  {
  {
#line 575
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 575
    if (! (i < length)) {
#line 575
      goto while_break;
    }
    {
#line 577
    tmp = pos;
#line 577
    pos ++;
    {
#line 577
    lsh_string_putc(buffer, tmp, (uint8_t )hexchars[((int const   )*(data + i) & 240) >> 4]);
    }
#line 578
    tmp___0 = pos;
#line 578
    pos ++;
    {
#line 578
    lsh_string_putc(buffer, tmp___0, (uint8_t )hexchars[(int const   )*(data + i) & 15]);
    }
#line 575
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 580
  return;
}
}
#line 582 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
void format_decimal(struct lsh_string *buffer , uint32_t start , uint32_t length ,
                    uint32_t n ) 
{ 
  unsigned int i ;

  {
#line 588
  i = 0U;
  {
  {
#line 588
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 588
    if (! (i < length)) {
#line 588
      goto while_break;
    }
    {
    {
#line 590
    lsh_string_putc(buffer, ((start + length) - i) - 1U, (uint8_t )(48U + n % 10U));
    }
#line 591
    n /= 10U;
#line 588
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 593
  return;
}
}
#line 595 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
static int write_decimal_length(struct lsh_string *buffer , uint32_t start , uint32_t n ) 
{ 
  int length ;
  unsigned int tmp ;

  {
  {
  {
#line 598
  tmp = format_size_in_decimal(n);
  }
#line 598
  length = (int )tmp;
  {
#line 600
  format_decimal(buffer, start, (uint32_t )length, n);
  }
  {
#line 601
  lsh_string_putc(buffer, start + (uint32_t )length, (uint8_t )':');
  }
  }
#line 603
  return (length + 1);
}
}
#line 608 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
struct lsh_string *lsh_string_colonize(struct lsh_string  const  *s , int every ,
                                       int freeflag ) 
{ 
  uint32_t i ;
  uint32_t j ;
  struct lsh_string *packet ;
  uint8_t const   *data ;
  uint32_t length ;
  uint32_t size ;
  int colons ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 611
  i = (uint32_t )0;
#line 612
  j = (uint32_t )0;
  {
#line 622
  length = lsh_string_length(s);
  }
  {
#line 623
  data = lsh_string_data(s);
  }
  }
#line 625
  if (length) {
#line 625
    colons = (int )((length - 1U) / (uint32_t )every);
  } else {
#line 625
    colons = 0;
  }
  {
#line 626
  size = length + (uint32_t )colons;
  {
#line 628
  packet = lsh_string_alloc(size);
  }
  }
  {
  {
#line 630
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 630
    if (! (i < length)) {
#line 630
      goto while_break;
    }
#line 632
    if (i) {
#line 632
      if (! (i % (unsigned int )every)) {
        {
#line 633
        tmp = j;
#line 633
        j ++;
        {
#line 633
        lsh_string_putc(packet, tmp, (uint8_t )':');
        }
        }
      }
    }
    {
#line 635
    tmp___0 = j;
#line 635
    j ++;
    {
#line 635
    lsh_string_putc(packet, tmp___0, (uint8_t )*(data + i));
    }
#line 630
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 638
  if (! (j == size)) {
    {
    {
#line 638
    __assert_fail("j == size", "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c",
                  638U, "lsh_string_colonize");
    }
    }
  }
#line 640
  if (freeflag) {
    {
    {
#line 641
    lsh_string_free(s);
    }
    }
  }
#line 643
  return (packet);
}
}
#line 646 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
static uint8_t lsh_string_bubblebabble_c(struct lsh_string  const  *s , uint32_t i ) 
{ 
  uint8_t c ;
  uint32_t j ;
  uint32_t k ;
  uint32_t length ;
  uint32_t tmp ;
  uint8_t const   *data ;
  uint8_t const   *tmp___0 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
  {
#line 654
  tmp = lsh_string_length(s);
  }
#line 654
  length = tmp;
  {
#line 655
  tmp___0 = lsh_string_data(s);
  }
#line 655
  data = tmp___0;
  }
#line 656
  if (! (0U != i)) {
    {
    {
#line 656
    __assert_fail("0 != i", "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c", 656U,
                  "lsh_string_bubblebabble_c");
    }
    }
  }
#line 658
  if (1U == i) {
#line 659
    return ((uint8_t )1);
  }
#line 661
  j = (i * 2U - 3U) - 1U;
#line 662
  k = (i * 2U - 2U) - 1U;
#line 664
  if (j < length) {
#line 664
    if (! (k < length)) {
      {
      {
#line 664
      __assert_fail("j < length && k < length", "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c",
                    664U, "lsh_string_bubblebabble_c");
      }
      }
    }
  } else {
    {
    {
#line 664
    __assert_fail("j < length && k < length", "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c",
                  664U, "lsh_string_bubblebabble_c");
    }
    }
  }
  {
  {
#line 666
  c = lsh_string_bubblebabble_c(s, i - 1U);
  }
  }
#line 668
  return ((uint8_t )((5 * (int )c + (int )((int const   )*(data + j) * 7 + (int const   )*(data + k))) % 36));
}
}
#line 671 "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c"
struct lsh_string *lsh_string_bubblebabble(struct lsh_string  const  *s , int freeflag ) 
{ 
  uint32_t length ;
  uint32_t tmp ;
  uint32_t i ;
  uint32_t babblelen ;
  struct lsh_string *p ;
  struct lsh_string *tmp___0 ;
  uint32_t r ;
  uint8_t const   *q ;
  uint8_t const   *tmp___1 ;
  uint8_t a ;
  uint8_t b ;
  uint8_t c ;
  uint8_t d ;
  uint8_t e ;
  char vowels[6] ;
  char cons[17] ;
  uint32_t tmp___2 ;
  uint8_t tmp___3 ;
  uint8_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint8_t tmp___11 ;
  uint8_t tmp___12 ;
  uint8_t tmp___13 ;
  uint8_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
  {
  {
#line 677
  tmp = lsh_string_length(s);
  }
#line 677
  length = tmp;
#line 678
  i = (uint32_t )0;
#line 679
  babblelen = (2U + 6U * (length / 2U)) + 3U;
  {
#line 680
  tmp___0 = lsh_string_alloc(babblelen);
  }
#line 680
  p = tmp___0;
#line 682
  r = (uint32_t )0;
  {
#line 683
  tmp___1 = lsh_string_data(s);
  }
#line 683
  q = tmp___1;
#line 691
  vowels[0] = (char )'a';
#line 691
  vowels[1] = (char )'e';
#line 691
  vowels[2] = (char )'i';
#line 691
  vowels[3] = (char )'o';
#line 691
  vowels[4] = (char )'u';
#line 691
  vowels[5] = (char )'y';
#line 693
  cons[0] = (char )'b';
#line 693
  cons[1] = (char )'c';
#line 693
  cons[2] = (char )'d';
#line 693
  cons[3] = (char )'f';
#line 693
  cons[4] = (char )'g';
#line 693
  cons[5] = (char )'h';
#line 693
  cons[6] = (char )'k';
#line 693
  cons[7] = (char )'l';
#line 693
  cons[8] = (char )'m';
#line 693
  cons[9] = (char )'n';
#line 693
  cons[10] = (char )'p';
#line 693
  cons[11] = (char )'r';
#line 693
  cons[12] = (char )'s';
#line 693
  cons[13] = (char )'t';
#line 693
  cons[14] = (char )'v';
#line 693
  cons[15] = (char )'z';
#line 693
  cons[16] = (char )'x';
#line 696
  tmp___2 = r;
#line 696
  r ++;
  {
#line 696
  lsh_string_putc(p, tmp___2, (uint8_t )'x');
  }
  }
  {
  {
#line 698
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 698
    if (! (i < length / 2U)) {
#line 698
      goto while_break;
    }
#line 700
    if (! (i * 2U + 1U < length)) {
      {
      {
#line 700
      __assert_fail("i*2+1 < length", "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c",
                    700U, "lsh_string_bubblebabble");
      }
      }
    }
    {
    {
#line 702
    tmp___3 = lsh_string_bubblebabble_c(s, i + 1U);
    }
#line 702
    a = (uint8_t )(((((int const   )*(q + i * 2U) >> 6) & 3) + (int const   )tmp___3) % 6);
#line 703
    b = (uint8_t )(((int const   )*(q + i * 2U) >> 2) & 15);
    {
#line 704
    tmp___4 = lsh_string_bubblebabble_c(s, i + 1U);
    }
#line 704
    c = (uint8_t )((((int const   )*(q + i * 2U) & 3) + (int const   )((int )tmp___4 / 6)) % 6);
#line 705
    d = (uint8_t )(((int const   )*(q + (i * 2U + 1U)) >> 4) & 15);
#line 706
    e = (uint8_t )((int const   )*(q + (i * 2U + 1U)) & 15);
#line 708
    tmp___5 = r;
#line 708
    r ++;
    {
#line 708
    lsh_string_putc(p, tmp___5, (uint8_t )vowels[a]);
    }
#line 709
    tmp___6 = r;
#line 709
    r ++;
    {
#line 709
    lsh_string_putc(p, tmp___6, (uint8_t )cons[b]);
    }
#line 710
    tmp___7 = r;
#line 710
    r ++;
    {
#line 710
    lsh_string_putc(p, tmp___7, (uint8_t )vowels[c]);
    }
#line 711
    tmp___8 = r;
#line 711
    r ++;
    {
#line 711
    lsh_string_putc(p, tmp___8, (uint8_t )cons[d]);
    }
#line 712
    tmp___9 = r;
#line 712
    r ++;
    {
#line 712
    lsh_string_putc(p, tmp___9, (uint8_t )'-');
    }
#line 713
    tmp___10 = r;
#line 713
    r ++;
    {
#line 713
    lsh_string_putc(p, tmp___10, (uint8_t )cons[e]);
    }
#line 715
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 718
  if (length % 2U) {
    {
    {
#line 720
    tmp___11 = lsh_string_bubblebabble_c(s, i + 1U);
    }
#line 720
    a = (uint8_t )(((((int const   )*(q + (length - 1U)) >> 6) & 3) + (int const   )tmp___11) % 6);
#line 721
    b = (uint8_t )(((int const   )*(q + (length - 1U)) >> 2) & 15);
    {
#line 722
    tmp___12 = lsh_string_bubblebabble_c(s, i + 1U);
    }
#line 722
    c = (uint8_t )((((int const   )*(q + (length - 1U)) & 3) + (int const   )((int )tmp___12 / 6)) % 6);
    }
  } else {
    {
    {
#line 726
    tmp___13 = lsh_string_bubblebabble_c(s, i + 1U);
    }
#line 726
    a = (uint8_t )((int )tmp___13 % 6);
#line 727
    b = (uint8_t )16;
    {
#line 728
    tmp___14 = lsh_string_bubblebabble_c(s, i + 1U);
    }
#line 728
    c = (uint8_t )((int )tmp___14 / 6);
    }
  }
  {
#line 731
  tmp___15 = r;
#line 731
  r ++;
  {
#line 731
  lsh_string_putc(p, tmp___15, (uint8_t )vowels[a]);
  }
#line 732
  tmp___16 = r;
#line 732
  r ++;
  {
#line 732
  lsh_string_putc(p, tmp___16, (uint8_t )cons[b]);
  }
#line 733
  tmp___17 = r;
#line 733
  r ++;
  {
#line 733
  lsh_string_putc(p, tmp___17, (uint8_t )vowels[c]);
  }
#line 735
  tmp___18 = r;
#line 735
  r ++;
  {
#line 735
  lsh_string_putc(p, tmp___18, (uint8_t )'x');
  }
  {
#line 737
  tmp___19 = lsh_string_length((struct lsh_string  const  *)p);
  }
  }
#line 737
  if (! (r == tmp___19)) {
    {
    {
#line 737
    __assert_fail("r == lsh_string_length(p)", "/home/ysko/Works/test-src/lsh-2.0.4/src/format.c",
                  737U, "lsh_string_bubblebabble");
    }
    }
  }
#line 739
  if (freeflag) {
    {
    {
#line 740
    lsh_string_free(s);
    }
    }
  }
#line 742
  return (p);
}
}
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h.x"
struct lsh_class report_exception_info_class ;
#line 94
struct lsh_class protocol_exception_class ;
#line 140 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h"
struct exception_handler ignore_exception_handler ;
#line 151
struct report_exception_info *make_report_exception_info(uint32_t mask , uint32_t value ,
                                                         char const   *prefix___0 ) ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h.x"
struct lsh_class exception_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"exception", (size_t )sizeof(struct exception ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h.x"
static void do_exception_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct exception_handler *i ;

  {
  {
#line 45
  i = (struct exception_handler *)o;
  {
#line 46
  (*mark)((struct lsh_object *)i->parent);
  }
  }
#line 47
  return;
}
}
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h.x"
struct lsh_class exception_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"exception_handler", (size_t )sizeof(struct exception_handler ),
    & do_exception_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h.x"
struct lsh_class report_exception_info_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"report_exception_info", (size_t )sizeof(struct report_exception_info ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 98 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.h.x"
struct lsh_class protocol_exception_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_class, (char *)"protocol_exception", (size_t )sizeof(struct protocol_exception ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c.x"
struct lsh_class report_exception_handler_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c.x"
static void do_report_exception_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct report_exception_handler *i ;

  {
  {
#line 18
  i = (struct report_exception_handler *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->info);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c.x"
struct lsh_class report_exception_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"report_exception_handler", (size_t )sizeof(struct report_exception_handler ),
    & do_report_exception_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c"
static void do_default_handler(struct exception_handler *ignored  __attribute__((__unused__)) ,
                               struct exception  const  *e ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 47
  fatal("Unhandled exception of type 0x%xi: %z\n", e->type, e->msg);
  }
  }
}
}
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c"
struct exception_handler default_exception_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_default_handler, (struct exception_handler *)((void *)0), "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c:51"};
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c"
static void do_ignore_exception_handler(struct exception_handler *self  __attribute__((__unused__)) ,
                                        struct exception  const  *e  __attribute__((__unused__)) ) 
{ 


  {
#line 56
  return;
}
}
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c"
struct exception_handler ignore_exception_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_ignore_exception_handler, (struct exception_handler *)((void *)0),
    "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c:59"};
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c"
struct exception_handler *make_exception_handler(void (*raise___0)(struct exception_handler *s ,
                                                                   struct exception  const  *x ) ,
                                                 struct exception_handler *parent ,
                                                 char const   *context ) 
{ 
  struct exception_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 67
  tmp = lsh_object_alloc(& exception_handler_class);
  }
#line 67
  self = (struct exception_handler *)tmp;
#line 68
  self->raise = raise___0;
#line 69
  self->parent = parent;
#line 70
  self->context = context;
  }
#line 72
  return (self);
}
}
#line 75 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c"
struct report_exception_info *make_report_exception_info(uint32_t mask , uint32_t value ,
                                                         char const   *prefix___0 ) 
{ 
  struct report_exception_info *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 79
  tmp = lsh_object_alloc(& report_exception_info_class);
  }
#line 79
  self = (struct report_exception_info *)tmp;
#line 81
  self->mask = mask;
#line 82
  self->value = value;
#line 83
  self->prefix = prefix___0;
  }
#line 85
  return (self);
}
}
#line 96 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c"
static void do_report_exception_handler(struct exception_handler *s , struct exception  const  *x ) 
{ 
  struct report_exception_handler *self ;
  struct report_exception_info  const  *info ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 100
  self = (struct report_exception_handler *)s;
#line 101
  info = self->info;
#line 103
  if ((x->type & info->mask) == info->value) {
    {
    {
#line 104
    werror("%z exception: %z\n", info->prefix, x->msg);
    }
    }
  } else {
    {
    {
#line 106
    (*((self->super.parent)->raise))(self->super.parent, x);
    }
    }
  }
#line 107
  return;
}
}
#line 109 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c"
struct exception_handler *make_report_exception_handler(struct report_exception_info  const  *info ,
                                                        struct exception_handler *parent ,
                                                        char const   *context ) 
{ 
  struct report_exception_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 114
  tmp = lsh_object_alloc(& report_exception_handler_class);
  }
#line 114
  self = (struct report_exception_handler *)tmp;
#line 115
  self->super.raise = & do_report_exception_handler;
#line 116
  self->super.parent = parent;
#line 117
  self->super.context = context;
#line 119
  self->info = info;
  }
#line 121
  return (& self->super);
}
}
#line 124 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c"
struct exception *make_simple_exception(uint32_t type , char const   *msg ) 
{ 
  struct exception *e ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 126
  tmp = lsh_object_alloc(& exception_class);
  }
#line 126
  e = (struct exception *)tmp;
#line 127
  e->type = type;
#line 128
  e->msg = msg;
  }
#line 130
  return (e);
}
}
#line 136 "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c"
struct exception *make_protocol_exception(uint32_t reason , char const   *msg ) 
{ 
  struct protocol_exception *self ;
  struct lsh_object *tmp ;
  char const   *messages[16] ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  void *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;

  {
  {
  {
#line 139
  tmp = lsh_object_alloc(& protocol_exception_class);
  }
#line 139
  self = (struct protocol_exception *)tmp;
#line 142
  messages[0] = (char const   *)((void *)0);
#line 142
  messages[1] = "Host not allowed to connect";
#line 142
  messages[2] = "Protocol error";
#line 142
  messages[3] = "Key exchange failed";
#line 142
  messages[4] = "Host authentication failed";
#line 142
  messages[5] = "MAC error";
#line 142
  messages[6] = "Compression error";
#line 142
  messages[7] = "Service not available";
#line 142
  messages[8] = "Protocol version not supported";
#line 142
  messages[9] = "Host key not verifiable";
#line 142
  messages[10] = "Connection lost";
#line 142
  messages[11] = "By application";
#line 142
  messages[12] = "Too many connections";
#line 142
  messages[13] = "Auth cancelled by user";
#line 142
  messages[14] = "No more auth methods available";
#line 142
  messages[15] = "Illegal user name";
  }
#line 154
  if (! (reason <= 15U)) {
    {
    {
#line 154
    __assert_fail("reason <= 15", "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c",
                  154U, "make_protocol_exception");
    }
    }
  }
#line 155
  if (! (reason != 4U)) {
    {
    {
#line 155
    __assert_fail("reason != 4", "/home/ysko/Works/test-src/lsh-2.0.4/src/exception.c",
                  155U, "make_protocol_exception");
    }
    }
  }
#line 158
  self->super.type = (uint32_t )4096;
#line 159
  if (msg) {
#line 159
    self->super.msg = msg;
  } else {
#line 159
    self->super.msg = messages[reason];
  }
#line 161
  self->reason = reason;
#line 163
  return (& self->super);
}
}
#line 215 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct lsh_class signature_algorithm_class ;
#line 196 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h"
struct signature_algorithm *make_dsa_algorithm(struct randomness *random___0 ) ;
#line 200
struct verifier *parse_ssh_dss_public(struct simple_buffer *buffer ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c.x"
struct lsh_class dsa_algorithm_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c.x"
static void do_dsa_algorithm_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct dsa_algorithm *i ;

  {
  {
#line 18
  i = (struct dsa_algorithm *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->random);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c.x"
struct lsh_class dsa_algorithm_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & signature_algorithm_class, (char *)"dsa_algorithm", (size_t )sizeof(struct dsa_algorithm ),
    & do_dsa_algorithm_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 41
struct lsh_class dsa_verifier_class ;
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c.x"
static void do_dsa_verifier_free(struct lsh_object *o ) 
{ 
  struct dsa_verifier *i ;

  {
  {
#line 48
  i = (struct dsa_verifier *)o;
  {
#line 49
  nettle_dsa_public_key_clear(& i->key);
  }
  }
#line 50
  return;
}
}
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c.x"
struct lsh_class dsa_verifier_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & verifier_class, (char *)"dsa_verifier", (size_t )sizeof(struct dsa_verifier ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_dsa_verifier_free};
#line 73
struct lsh_class dsa_signer_class ;
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c.x"
static void do_dsa_signer_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct dsa_signer *i ;

  {
  {
#line 81
  i = (struct dsa_signer *)o;
  {
#line 82
  (*mark)((struct lsh_object *)i->verifier);
  }
  {
#line 83
  (*mark)((struct lsh_object *)i->random);
  }
  }
#line 84
  return;
}
}
#line 85 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c.x"
static void do_dsa_signer_free(struct lsh_object *o ) 
{ 
  struct dsa_signer *i ;

  {
  {
#line 88
  i = (struct dsa_signer *)o;
  {
#line 89
  nettle_dsa_private_key_clear(& i->key);
  }
  }
#line 90
  return;
}
}
#line 91 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c.x"
struct lsh_class dsa_signer_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & signer_class, (char *)"dsa_signer", (size_t )sizeof(struct dsa_signer ),
    & do_dsa_signer_mark, & do_dsa_signer_free};
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c"
static int do_dsa_verify(struct verifier *c , int algorithm , uint32_t length , uint8_t const   *msg ,
                         uint32_t signature_length , uint8_t const   *signature_data ) 
{ 
  struct dsa_verifier *self ;
  struct sha1_ctx hash___2 ;
  struct simple_buffer buffer ;
  int res ;
  struct dsa_signature sv ;
  uint32_t buf_length ;
  uint8_t const   *buf ;
  int atom ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct sexp_iterator i ;
  uint8_t const   *names___3[2] ;
  struct sexp_iterator values[2] ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  int __cil_tmp52 ;
  void *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  int __cil_tmp68 ;
  void *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
  {
#line 93
  self = (struct dsa_verifier *)c;
#line 98
  res = 0;
  {
#line 102
  trace("do_dsa_verify: Verifying %a signature\n", algorithm);
  }
  {
#line 103
  nettle_dsa_signature_init(& sv);
  }
  }
#line 107
  if (algorithm == 36) {
#line 107
    goto case_36;
  }
#line 136
  if (algorithm == 44) {
#line 136
    goto case_44;
  }
#line 136
  if (algorithm == 41) {
#line 136
    goto case_44;
  }
#line 136
  if (algorithm == 40) {
#line 136
    goto case_44;
  }
#line 152
  goto switch_default;
  case_36: 
  {
  {
#line 116
  simple_buffer_init(& buffer, signature_length, signature_data);
  }
  {
#line 117
  tmp = parse_atom(& buffer, & atom);
  }
  }
#line 117
  if (tmp) {
#line 117
    if (atom == 36) {
      {
      {
#line 117
      tmp___0 = parse_string(& buffer, & buf_length, & buf);
      }
      }
#line 117
      if (tmp___0) {
#line 117
        if (! (buf_length % 2U)) {
#line 117
          if (buf_length <= 40U) {
            {
            {
#line 117
            tmp___1 = parse_eod(& buffer);
            }
            }
#line 117
            if (! tmp___1) {
#line 123
              goto fail;
            }
          } else {
#line 123
            goto fail;
          }
        } else {
#line 123
          goto fail;
        }
      } else {
#line 123
        goto fail;
      }
    } else {
#line 123
      goto fail;
    }
  } else {
#line 123
    goto fail;
  }
  {
#line 125
  buf_length /= 2U;
  {
#line 127
  nettle_mpz_set_str_256_u(sv.r, buf_length, buf);
  }
  {
#line 128
  nettle_mpz_set_str_256_u(sv.s, buf_length, buf + buf_length);
  }
  }
#line 130
  goto switch_break;
  case_44: 
  {
#line 140
  names___3[0] = (uint8_t const   *)"r";
#line 140
  names___3[1] = (uint8_t const   *)"s";
  {
#line 143
  tmp___2 = nettle_sexp_iterator_first(& i, signature_length, signature_data);
  }
  }
#line 143
  if (tmp___2) {
    {
    {
#line 143
    tmp___3 = nettle_sexp_iterator_enter_list(& i);
    }
    }
#line 143
    if (tmp___3) {
      {
      {
#line 143
      tmp___4 = nettle_sexp_iterator_assoc(& i, 2U, (uint8_t const   * const  *)(names___3),
                                           values);
      }
      }
#line 143
      if (tmp___4) {
        {
        {
#line 143
        tmp___5 = nettle_mpz_set_sexp(sv.r, 160U, & values[0]);
        }
        }
#line 143
        if (tmp___5) {
          {
          {
#line 143
          tmp___6 = nettle_mpz_set_sexp(sv.s, 160U, & values[1]);
          }
          }
#line 143
          if (! tmp___6) {
#line 148
            goto fail;
          }
        } else {
#line 148
          goto fail;
        }
      } else {
#line 148
        goto fail;
      }
    } else {
#line 148
      goto fail;
    }
  } else {
#line 148
    goto fail;
  }
#line 150
  goto switch_break;
  switch_default: 
  {
  {
#line 153
  fatal("do_dsa_verify: Internal error!\n");
  }
  }
  switch_break: 
  {
  {
#line 156
  nettle_sha1_init(& hash___2);
  }
  {
#line 157
  nettle_sha1_update(& hash___2, length, msg);
  }
  {
#line 159
  res = nettle_dsa_verify((struct dsa_public_key  const  *)(& self->key), & hash___2,
                          (struct dsa_signature  const  *)(& sv));
  }
  }
  fail: 
  {
  {
#line 162
  nettle_dsa_signature_clear(& sv);
  }
  }
#line 164
  return (res);
}
}
#line 168 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c"
static struct lsh_string *do_dsa_public_key(struct verifier *s ) 
{ 
  struct dsa_verifier *self ;
  struct lsh_string *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 171
  self = (struct dsa_verifier *)s;
  {
#line 172
  tmp = ssh_format("%a%n%n%n%n", 36, self->key.p, self->key.q, self->key.g, self->key.y);
  }
  }
#line 172
  return (tmp);
}
}
#line 178 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c"
static struct lsh_string *do_dsa_public_spki_key(struct verifier *s , int transport ) 
{ 
  struct dsa_verifier *self ;
  struct lsh_string *tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 181
  self = (struct dsa_verifier *)s;
  {
#line 183
  tmp = lsh_string_format_sexp(transport, "(%0s(%0s(%0s%b)(%0s%b)(%0s%b)(%0s%b)))",
                               "public-key", "dsa", "p", self->key.p, "q", self->key.q,
                               "g", self->key.g, "y", self->key.y);
  }
  }
#line 183
  return (tmp);
}
}
#line 192 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c"
static void init_dsa_verifier(struct dsa_verifier *self ) 
{ 


  {
  {
  {
#line 197
  nettle_dsa_public_key_init(& self->key);
  }
#line 199
  self->super.verify = & do_dsa_verify;
#line 200
  self->super.public_spki_key = & do_dsa_public_spki_key;
#line 201
  self->super.public_key = & do_dsa_public_key;
  }
#line 202
  return;
}
}
#line 207 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c"
struct verifier *parse_ssh_dss_public(struct simple_buffer *buffer ) 
{ 
  struct dsa_verifier *res ;
  struct lsh_object *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
  {
#line 210
  tmp = lsh_object_alloc(& dsa_verifier_class);
  }
#line 210
  res = (struct dsa_verifier *)tmp;
  {
#line 211
  init_dsa_verifier(res);
  }
  {
#line 213
  tmp___0 = parse_bignum(buffer, res->key.p, (uint32_t )256);
  }
  }
#line 213
  if (tmp___0) {
#line 213
    if (res->key.p[0]._mp_size < 0) {
#line 213
      tmp___1 = -1;
    } else {
#line 213
      tmp___1 = res->key.p[0]._mp_size > 0;
    }
#line 213
    if (tmp___1 == 1) {
      {
      {
#line 213
      tmp___2 = parse_bignum(buffer, res->key.q, (uint32_t )20);
      }
      }
#line 213
      if (tmp___2) {
#line 213
        if (res->key.q[0]._mp_size < 0) {
#line 213
          tmp___3 = -1;
        } else {
#line 213
          tmp___3 = res->key.q[0]._mp_size > 0;
        }
#line 213
        if (tmp___3 == 1) {
          {
          {
#line 213
          tmp___4 = __gmpz_cmp((mpz_srcptr )(res->key.q), (mpz_srcptr )(res->key.p));
          }
          }
#line 213
          if (tmp___4 < 0) {
            {
            {
#line 213
            tmp___5 = parse_bignum(buffer, res->key.g, (uint32_t )256);
            }
            }
#line 213
            if (tmp___5) {
#line 213
              if (res->key.g[0]._mp_size < 0) {
#line 213
                tmp___6 = -1;
              } else {
#line 213
                tmp___6 = res->key.g[0]._mp_size > 0;
              }
#line 213
              if (tmp___6 == 1) {
                {
                {
#line 213
                tmp___7 = __gmpz_cmp((mpz_srcptr )(res->key.g), (mpz_srcptr )(res->key.p));
                }
                }
#line 213
                if (tmp___7 < 0) {
                  {
                  {
#line 213
                  tmp___8 = parse_bignum(buffer, res->key.y, (uint32_t )256);
                  }
                  }
#line 213
                  if (tmp___8) {
#line 213
                    if (res->key.y[0]._mp_size < 0) {
#line 213
                      tmp___9 = -1;
                    } else {
#line 213
                      tmp___9 = res->key.y[0]._mp_size > 0;
                    }
#line 213
                    if (tmp___9 == 1) {
                      {
                      {
#line 213
                      tmp___10 = __gmpz_cmp((mpz_srcptr )(res->key.y), (mpz_srcptr )(res->key.p));
                      }
                      }
#line 213
                      if (tmp___10 < 0) {
                        {
                        {
#line 213
                        tmp___11 = parse_eod(buffer);
                        }
                        }
#line 213
                        if (tmp___11) {
#line 226
                          return (& res->super);
                        } else {
                          {
                          {
#line 230
                          gc_kill((struct lsh_object *)res);
                          }
                          }
#line 231
                          return ((struct verifier *)((void *)0));
                        }
                      } else {
                        {
                        {
#line 230
                        gc_kill((struct lsh_object *)res);
                        }
                        }
#line 231
                        return ((struct verifier *)((void *)0));
                      }
                    } else {
                      {
                      {
#line 230
                      gc_kill((struct lsh_object *)res);
                      }
                      }
#line 231
                      return ((struct verifier *)((void *)0));
                    }
                  } else {
                    {
                    {
#line 230
                    gc_kill((struct lsh_object *)res);
                    }
                    }
#line 231
                    return ((struct verifier *)((void *)0));
                  }
                } else {
                  {
                  {
#line 230
                  gc_kill((struct lsh_object *)res);
                  }
                  }
#line 231
                  return ((struct verifier *)((void *)0));
                }
              } else {
                {
                {
#line 230
                gc_kill((struct lsh_object *)res);
                }
                }
#line 231
                return ((struct verifier *)((void *)0));
              }
            } else {
              {
              {
#line 230
              gc_kill((struct lsh_object *)res);
              }
              }
#line 231
              return ((struct verifier *)((void *)0));
            }
          } else {
            {
            {
#line 230
            gc_kill((struct lsh_object *)res);
            }
            }
#line 231
            return ((struct verifier *)((void *)0));
          }
        } else {
          {
          {
#line 230
          gc_kill((struct lsh_object *)res);
          }
          }
#line 231
          return ((struct verifier *)((void *)0));
        }
      } else {
        {
        {
#line 230
        gc_kill((struct lsh_object *)res);
        }
        }
#line 231
        return ((struct verifier *)((void *)0));
      }
    } else {
      {
      {
#line 230
      gc_kill((struct lsh_object *)res);
      }
      }
#line 231
      return ((struct verifier *)((void *)0));
    }
  } else {
    {
    {
#line 230
    gc_kill((struct lsh_object *)res);
    }
    }
#line 231
    return ((struct verifier *)((void *)0));
  }
}
}
#line 238 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c"
static uint32_t dsa_blob_length(struct dsa_signature  const  *signature ) 
{ 
  uint32_t r_length ;
  unsigned int tmp ;
  uint32_t s_length ;
  unsigned int tmp___0 ;
  uint32_t tmp___1 ;

  {
  {
  {
#line 241
  tmp = nettle_mpz_sizeinbase_256_u((__mpz_struct */* const  */)((__mpz_struct *)(signature->r)));
  }
#line 241
  r_length = tmp;
  {
#line 242
  tmp___0 = nettle_mpz_sizeinbase_256_u((__mpz_struct */* const  */)((__mpz_struct *)(signature->s)));
  }
#line 242
  s_length = tmp___0;
  }
#line 244
  if (r_length < s_length) {
#line 244
    tmp___1 = s_length;
  } else {
#line 244
    tmp___1 = r_length;
  }
#line 244
  return (tmp___1);
}
}
#line 247 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c"
static void dsa_blob_write(struct lsh_string *buf , uint32_t pos , struct dsa_signature  const  *signature ,
                           uint32_t length ) 
{ 


  {
  {
  {
#line 252
  lsh_string_write_bignum(buf, pos, length, (__mpz_struct */* const  */)((__mpz_struct *)(signature->r)));
  }
  {
#line 253
  lsh_string_write_bignum(buf, pos + length, length, (__mpz_struct */* const  */)((__mpz_struct *)(signature->s)));
  }
  }
#line 254
  return;
}
}
#line 256 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c"
static struct lsh_string *do_dsa_sign(struct signer *c , int algorithm , uint32_t msg_length ,
                                      uint8_t const   *msg ) 
{ 
  struct dsa_signer *self ;
  struct dsa_signature sv ;
  struct sha1_ctx hash___2 ;
  struct lsh_string *signature ;
  uint32_t blob_pos ;
  uint32_t buf_length ;
  uint32_t tmp ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
  {
#line 262
  self = (struct dsa_signer *)c;
  {
#line 267
  trace("do_dsa_sign: Signing according to %a\n", algorithm);
  }
  {
#line 269
  nettle_dsa_signature_init(& sv);
  }
  {
#line 270
  nettle_sha1_init(& hash___2);
  }
  {
#line 271
  nettle_sha1_update(& hash___2, msg_length, msg);
  }
  {
#line 272
  nettle_dsa_sign((struct dsa_public_key  const  *)(& (self->verifier)->key), (struct dsa_private_key  const  *)(& self->key),
                  (void *)self->random, & lsh_random, & hash___2, & sv);
  }
  {
#line 275
  debug("do_dsa_sign: r = %xn, s = %xn\n", sv.r, sv.s);
  }
  }
#line 281
  if (algorithm == 36) {
#line 281
    goto case_36;
  }
#line 296
  if (algorithm == 44) {
#line 296
    goto case_44;
  }
#line 296
  if (algorithm == 41) {
#line 296
    goto case_44;
  }
#line 296
  if (algorithm == 40) {
#line 296
    goto case_44;
  }
#line 302
  goto switch_default;
  case_36: 
  {
  {
#line 284
  tmp = dsa_blob_length((struct dsa_signature  const  *)(& sv));
  }
#line 284
  buf_length = tmp;
  {
#line 288
  signature = ssh_format("%a%r", 36, buf_length * 2U, & blob_pos);
  }
  {
#line 289
  dsa_blob_write(signature, blob_pos, (struct dsa_signature  const  *)(& sv), buf_length);
  }
  }
#line 291
  goto switch_break;
  case_44: 
  {
  {
#line 298
  signature = lsh_string_format_sexp(0, "((r%b)(s%b))", sv.r, sv.s);
  }
  }
#line 301
  goto switch_break;
  switch_default: 
  {
  {
#line 303
  fatal("do_dsa_sign: Internal error, unexpected algorithm %a.\n", algorithm);
  }
  }
  switch_break: 
  {
  {
#line 306
  nettle_dsa_signature_clear(& sv);
  }
  }
#line 308
  return (signature);
}
}
#line 311 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c"
static struct verifier *do_dsa_get_verifier(struct signer *s ) 
{ 
  struct dsa_signer *self ;

  {
#line 314
  self = (struct dsa_signer *)s;
#line 315
  return (& (self->verifier)->super);
}
}
#line 319 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c"
static struct verifier *make_dsa_verifier(struct signature_algorithm *self  __attribute__((__unused__)) ,
                                          struct sexp_iterator *i ) 
{ 
  struct dsa_verifier *res ;
  struct lsh_object *tmp ;
  int tmp___0 ;

  {
  {
  {
#line 323
  tmp = lsh_object_alloc(& dsa_verifier_class);
  }
#line 323
  res = (struct dsa_verifier *)tmp;
  {
#line 324
  init_dsa_verifier(res);
  }
  {
#line 326
  tmp___0 = nettle_dsa_keypair_from_sexp_alist(& res->key, (struct dsa_private_key *)((void *)0),
                                               2048U, i);
  }
  }
#line 326
  if (tmp___0) {
#line 327
    return (& res->super);
  }
  {
  {
#line 329
  gc_kill((struct lsh_object *)res);
  }
  }
#line 330
  return ((struct verifier *)((void *)0));
}
}
#line 333 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c"
static struct signer *make_dsa_signer(struct signature_algorithm *c , struct sexp_iterator *i ) 
{ 
  struct dsa_algorithm *self ;
  struct dsa_verifier *verifier ;
  struct lsh_object *tmp ;
  struct dsa_signer *res ;
  struct lsh_object *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 337
  self = (struct dsa_algorithm *)c;
  {
#line 338
  tmp = lsh_object_alloc(& dsa_verifier_class);
  }
#line 338
  verifier = (struct dsa_verifier *)tmp;
  {
#line 339
  tmp___0 = lsh_object_alloc(& dsa_signer_class);
  }
#line 339
  res = (struct dsa_signer *)tmp___0;
  {
#line 341
  init_dsa_verifier(verifier);
  }
  {
#line 343
  nettle_dsa_private_key_init(& res->key);
  }
  {
#line 345
  tmp___1 = nettle_dsa_keypair_from_sexp_alist(& verifier->key, & res->key, 2048U,
                                               i);
  }
  }
#line 345
  if (tmp___1) {
#line 347
    res->random = self->random;
#line 348
    res->verifier = verifier;
#line 349
    res->super.sign = & do_dsa_sign;
#line 350
    res->super.get_verifier = & do_dsa_get_verifier;
#line 352
    return (& res->super);
  }
  {
  {
#line 355
  gc_kill((struct lsh_object *)res);
  }
  {
#line 356
  gc_kill((struct lsh_object *)verifier);
  }
  }
#line 357
  return ((struct signer *)((void *)0));
}
}
#line 360 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c"
struct signature_algorithm *make_dsa_algorithm(struct randomness *random___0 ) 
{ 
  struct dsa_algorithm *dsa ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 363
  tmp = lsh_object_alloc(& dsa_algorithm_class);
  }
#line 363
  dsa = (struct dsa_algorithm *)tmp;
#line 365
  dsa->super.make_signer = & make_dsa_signer;
#line 366
  dsa->super.make_verifier = & make_dsa_verifier;
#line 367
  dsa->random = random___0;
  }
#line 369
  return (& dsa->super);
}
}
#line 373 "/home/ysko/Works/test-src/lsh-2.0.4/src/dsa.c"
struct verifier *make_ssh_dss_verifier(struct lsh_string  const  *public ) 
{ 
  struct simple_buffer buffer ;
  int atom ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct verifier *tmp___2 ;
  struct verifier *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  {
  {
#line 379
  tmp = lsh_string_data(public);
  }
  {
#line 379
  tmp___0 = lsh_string_length(public);
  }
  {
#line 379
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 381
  tmp___4 = parse_atom(& buffer, & atom);
  }
  }
#line 381
  if (tmp___4) {
#line 381
    if (atom == 36) {
      {
      {
#line 381
      tmp___2 = parse_ssh_dss_public(& buffer);
      }
#line 381
      tmp___3 = tmp___2;
      }
    } else {
#line 381
      tmp___3 = (struct verifier *)((void *)0);
    }
  } else {
#line 381
    tmp___3 = (struct verifier *)((void *)0);
  }
#line 381
  return (tmp___3);
}
}
#line 125 "/home/ysko/Works/test-src/lsh-2.0.4/src/publickey_crypto.h"
struct lsh_string *dh_make_client_msg(struct dh_instance *self ) ;
#line 150
struct lsh_string *dh_process_server_msg(struct dh_instance *self , struct lsh_string **signature ,
                                         struct lsh_string *packet ) ;
#line 172
struct dh_method *make_dh1(struct randomness *r ) ;
#line 175
struct dh_method *make_dh14(struct randomness *r ) ;
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/dh_exchange.c"
void init_dh_instance(struct dh_method  const  *m , struct dh_instance *self , struct ssh_connection *c ) 
{ 
  struct lsh_string *s ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 51
  __gmpz_init(self->e);
  }
  {
#line 52
  __gmpz_init(self->f);
  }
  {
#line 53
  __gmpz_init(self->secret);
  }
#line 55
  self->K = (struct lsh_string *)((void *)0);
#line 57
  self->method = m;
  {
#line 58
  self->hash = make_hash((struct hash_algorithm  const  *)m->H);
  }
#line 59
  self->exchange_hash = (struct lsh_string *)((void *)0);
  {
#line 61
  debug("init_dh_instance\n V_C: %pS\n", c->versions[0]);
  }
  {
#line 63
  debug(" V_S: %pS\n", c->versions[1]);
  }
  {
#line 64
  debug(" I_C: %xS\n", c->literal_kexinits[0]);
  }
  {
#line 65
  debug(" I_S: %xS\n", c->literal_kexinits[1]);
  }
  {
#line 67
  s = ssh_format("%S%S%S%S", c->versions[0], c->versions[1], c->literal_kexinits[0],
                 c->literal_kexinits[1]);
  }
  {
#line 72
  tmp = lsh_string_data((struct lsh_string  const  *)s);
  }
  {
#line 72
  tmp___0 = lsh_string_length((struct lsh_string  const  *)s);
  }
  {
#line 72
  hash_update(self->hash, tmp___0, tmp);
  }
  {
#line 74
  lsh_string_free((struct lsh_string  const  *)s);
  }
  }
#line 75
  return;
}
}
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/dh_exchange.c"
struct dh_method *make_dh(struct zn_group  const  *G , struct hash_algorithm  const  *H ,
                          struct randomness *r ) 
{ 
  struct dh_method *res ;
  struct lsh_object *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 82
  tmp = lsh_object_alloc(& dh_method_class);
  }
#line 82
  res = (struct dh_method *)tmp;
  }
#line 84
  if (! ((unsigned int )r->quality == 0U)) {
    {
    {
#line 84
    __assert_fail("r->quality == RANDOM_GOOD", "/home/ysko/Works/test-src/lsh-2.0.4/src/dh_exchange.c",
                  84U, "make_dh");
    }
    }
  }
#line 86
  res->G = G;
#line 87
  res->H = H;
#line 88
  res->random = r;
#line 90
  return (res);
}
}
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/dh_exchange.c"
struct dh_method *make_dh1(struct randomness *r ) 
{ 
  struct zn_group  const  *tmp ;
  struct dh_method *tmp___0 ;

  {
  {
  {
#line 97
  tmp = make_ssh_group1();
  }
  {
#line 97
  tmp___0 = make_dh(tmp, & crypto_sha1_algorithm, r);
  }
  }
#line 97
  return (tmp___0);
}
}
#line 100 "/home/ysko/Works/test-src/lsh-2.0.4/src/dh_exchange.c"
struct dh_method *make_dh14(struct randomness *r ) 
{ 
  struct zn_group  const  *tmp ;
  struct dh_method *tmp___0 ;

  {
  {
  {
#line 103
  tmp = make_ssh_group14();
  }
  {
#line 103
  tmp___0 = make_dh(tmp, & crypto_sha1_algorithm, r);
  }
  }
#line 103
  return (tmp___0);
}
}
#line 107 "/home/ysko/Works/test-src/lsh-2.0.4/src/dh_exchange.c"
void dh_generate_secret(struct dh_method  const  *self , __mpz_struct *r , __mpz_struct *v ) 
{ 
  mpz_t tmp ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
  {
#line 114
  __gmpz_init_set(tmp, (mpz_srcptr )((self->G)->order));
  }
  {
#line 115
  __gmpz_sub_ui(tmp, (mpz_srcptr )(tmp), 1UL);
  }
  {
#line 116
  nettle_mpz_random(r, (void *)self->random, & lsh_random, (__mpz_struct */* const  */)(tmp));
  }
  {
#line 117
  __gmpz_add_ui(r, (mpz_srcptr )r, 1UL);
  }
  {
#line 118
  __gmpz_clear(tmp);
  }
  {
#line 120
  zn_exp((struct zn_group  const  *)self->G, v, (__mpz_struct */* const  */)((__mpz_struct *)((self->G)->generator)),
         (__mpz_struct */* const  */)r);
  }
  }
#line 121
  return;
}
}
#line 123 "/home/ysko/Works/test-src/lsh-2.0.4/src/dh_exchange.c"
struct lsh_string *dh_make_client_msg(struct dh_instance *self ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 126
  dh_generate_secret(self->method, self->secret, self->e);
  }
  {
#line 127
  tmp = ssh_format("%c%n", 30, self->e);
  }
  }
#line 127
  return (tmp);
}
}
#line 130 "/home/ysko/Works/test-src/lsh-2.0.4/src/dh_exchange.c"
int dh_process_client_msg(struct dh_instance *self , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  mpz_t tmp ;
  uint8_t const   *tmp___0 ;
  uint32_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 138
  tmp___0 = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 138
  tmp___1 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 138
  simple_buffer_init(& buffer, tmp___1, tmp___0);
  }
  {
#line 140
  tmp___2 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 140
  if (tmp___2) {
#line 140
    if (msg_number == 30U) {
      {
      {
#line 140
      tmp___3 = parse_bignum(& buffer, self->e, (uint32_t )0);
      }
      }
#line 140
      if (tmp___3) {
        {
        {
#line 140
        tmp___5 = __gmpz_cmp_ui((mpz_srcptr )(self->e), 1UL);
        }
        }
#line 140
        if (tmp___5 > 0) {
          {
          {
#line 140
          tmp___6 = zn_range((struct zn_group  const  *)(self->method)->G, (__mpz_struct */* const  */)(self->e));
          }
          }
#line 140
          if (tmp___6) {
            {
            {
#line 140
            tmp___7 = parse_eod(& buffer);
            }
            }
#line 140
            if (! tmp___7) {
#line 146
              return (0);
            }
          } else {
#line 146
            return (0);
          }
        } else {
#line 146
          return (0);
        }
      } else {
#line 146
        return (0);
      }
    } else {
#line 146
      return (0);
    }
  } else {
#line 146
    return (0);
  }
  {
  {
#line 148
  __gmpz_init(tmp);
  }
  {
#line 150
  zn_exp((struct zn_group  const  *)(self->method)->G, tmp, (__mpz_struct */* const  */)(self->e),
         (__mpz_struct */* const  */)(self->secret));
  }
  {
#line 151
  self->K = ssh_format("%ln", tmp);
  }
  {
#line 153
  __gmpz_clear(tmp);
  }
  }
#line 155
  return (1);
}
}
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/dh_exchange.c"
void dh_hash_update(struct dh_instance *self , struct lsh_string *s , int free___0 ) 
{ 
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 162
  debug("dh_hash_update: %xS\n", s);
  }
  {
#line 164
  tmp = lsh_string_data((struct lsh_string  const  *)s);
  }
  {
#line 164
  tmp___0 = lsh_string_length((struct lsh_string  const  *)s);
  }
  {
#line 164
  hash_update(self->hash, tmp___0, tmp);
  }
  }
#line 165
  if (free___0) {
    {
    {
#line 166
    lsh_string_free((struct lsh_string  const  *)s);
    }
    }
  }
#line 167
  return;
}
}
#line 170 "/home/ysko/Works/test-src/lsh-2.0.4/src/dh_exchange.c"
void dh_hash_digest(struct dh_instance *self ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 173
  tmp = ssh_format("%n%n%S", self->e, self->f, self->K);
  }
  {
#line 173
  dh_hash_update(self, tmp, 1);
  }
  {
#line 176
  self->exchange_hash = hash_digest_string(self->hash);
  }
  {
#line 178
  debug("dh_hash_digest: %xS\n", self->exchange_hash);
  }
  }
#line 179
  return;
}
}
#line 181 "/home/ysko/Works/test-src/lsh-2.0.4/src/dh_exchange.c"
void dh_make_server_secret(struct dh_instance *self ) 
{ 


  {
  {
  {
#line 184
  dh_generate_secret(self->method, self->secret, self->f);
  }
  }
#line 185
  return;
}
}
#line 187 "/home/ysko/Works/test-src/lsh-2.0.4/src/dh_exchange.c"
struct lsh_string *dh_make_server_msg(struct dh_instance *self , struct lsh_string *server_key ,
                                      int hostkey_algorithm , struct signer *s ) 
{ 
  struct lsh_string *tmp ;
  uint8_t const   *tmp___0 ;
  uint32_t tmp___1 ;
  struct lsh_string *tmp___2 ;
  struct lsh_string *tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 193
  tmp = ssh_format("%S", server_key);
  }
  {
#line 193
  dh_hash_update(self, tmp, 1);
  }
  {
#line 194
  dh_hash_digest(self);
  }
  {
#line 196
  tmp___0 = lsh_string_data((struct lsh_string  const  *)self->exchange_hash);
  }
  {
#line 196
  tmp___1 = lsh_string_length((struct lsh_string  const  *)self->exchange_hash);
  }
  {
#line 196
  tmp___2 = (*(s->sign))(s, hostkey_algorithm, tmp___1, tmp___0);
  }
  {
#line 196
  tmp___3 = ssh_format("%c%S%n%fS", 31, server_key, self->f, tmp___2);
  }
  }
#line 196
  return (tmp___3);
}
}
#line 205 "/home/ysko/Works/test-src/lsh-2.0.4/src/dh_exchange.c"
struct lsh_string *dh_process_server_msg(struct dh_instance *self , struct lsh_string **signature ,
                                         struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  mpz_t tmp ;
  struct lsh_string *key ;
  struct lsh_string *s ;
  uint8_t const   *tmp___0 ;
  uint32_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct lsh_string *tmp___8 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 214
  key = (struct lsh_string *)((void *)0);
#line 215
  s = (struct lsh_string *)((void *)0);
  {
#line 217
  tmp___0 = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 217
  tmp___1 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 217
  simple_buffer_init(& buffer, tmp___1, tmp___0);
  }
  {
#line 219
  tmp___2 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 219
  if (tmp___2) {
#line 219
    if (msg_number == 31U) {
      {
      {
#line 219
      key = parse_string_copy(& buffer);
      }
      }
#line 219
      if (key) {
        {
        {
#line 219
        tmp___3 = parse_bignum(& buffer, self->f, (uint32_t )0);
        }
        }
#line 219
        if (tmp___3) {
          {
          {
#line 219
          tmp___5 = __gmpz_cmp_ui((mpz_srcptr )(self->f), 1UL);
          }
          }
#line 219
          if (tmp___5 > 0) {
            {
            {
#line 219
            tmp___6 = zn_range((struct zn_group  const  *)(self->method)->G, (__mpz_struct */* const  */)(self->f));
            }
            }
#line 219
            if (tmp___6) {
              {
              {
#line 219
              s = parse_string_copy(& buffer);
              }
              }
#line 219
              if (s) {
                {
                {
#line 219
                tmp___7 = parse_eod(& buffer);
                }
                }
#line 219
                if (! tmp___7) {
                  {
                  {
#line 229
                  lsh_string_free((struct lsh_string  const  *)key);
                  }
                  {
#line 230
                  lsh_string_free((struct lsh_string  const  *)s);
                  }
                  }
#line 231
                  return ((struct lsh_string *)((void *)0));
                }
              } else {
                {
                {
#line 229
                lsh_string_free((struct lsh_string  const  *)key);
                }
                {
#line 230
                lsh_string_free((struct lsh_string  const  *)s);
                }
                }
#line 231
                return ((struct lsh_string *)((void *)0));
              }
            } else {
              {
              {
#line 229
              lsh_string_free((struct lsh_string  const  *)key);
              }
              {
#line 230
              lsh_string_free((struct lsh_string  const  *)s);
              }
              }
#line 231
              return ((struct lsh_string *)((void *)0));
            }
          } else {
            {
            {
#line 229
            lsh_string_free((struct lsh_string  const  *)key);
            }
            {
#line 230
            lsh_string_free((struct lsh_string  const  *)s);
            }
            }
#line 231
            return ((struct lsh_string *)((void *)0));
          }
        } else {
          {
          {
#line 229
          lsh_string_free((struct lsh_string  const  *)key);
          }
          {
#line 230
          lsh_string_free((struct lsh_string  const  *)s);
          }
          }
#line 231
          return ((struct lsh_string *)((void *)0));
        }
      } else {
        {
        {
#line 229
        lsh_string_free((struct lsh_string  const  *)key);
        }
        {
#line 230
        lsh_string_free((struct lsh_string  const  *)s);
        }
        }
#line 231
        return ((struct lsh_string *)((void *)0));
      }
    } else {
      {
      {
#line 229
      lsh_string_free((struct lsh_string  const  *)key);
      }
      {
#line 230
      lsh_string_free((struct lsh_string  const  *)s);
      }
      }
#line 231
      return ((struct lsh_string *)((void *)0));
    }
  } else {
    {
    {
#line 229
    lsh_string_free((struct lsh_string  const  *)key);
    }
    {
#line 230
    lsh_string_free((struct lsh_string  const  *)s);
    }
    }
#line 231
    return ((struct lsh_string *)((void *)0));
  }
  {
  {
#line 234
  __gmpz_init(tmp);
  }
  {
#line 236
  zn_exp((struct zn_group  const  *)(self->method)->G, tmp, (__mpz_struct */* const  */)(self->f),
         (__mpz_struct */* const  */)(self->secret));
  }
  {
#line 237
  self->K = ssh_format("%ln", tmp);
  }
  {
#line 239
  __gmpz_clear(tmp);
  }
  {
#line 241
  tmp___8 = ssh_format("%S", key);
  }
  {
#line 241
  dh_hash_update(self, tmp___8, 1);
  }
  {
#line 242
  dh_hash_digest(self);
  }
#line 244
  *signature = s;
  }
#line 245
  return (key);
}
}
#line 268 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h"
char const   *packet_types[256] ;
#line 288
void send_debug_message(struct ssh_connection *connection , char const   *msg , int always_display ) ;
#line 291
struct packet_handler connection_debug_handler ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/debug.c.x"
struct lsh_class packet_debug_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/debug.c.x"
static void do_packet_debug_free(struct lsh_object *o ) 
{ 
  struct packet_debug *i ;

  {
  {
#line 17
  i = (struct packet_debug *)o;
  {
#line 18
  lsh_string_free((struct lsh_string  const  *)i->prefix);
  }
  }
#line 19
  return;
}
}
#line 20 "/home/ysko/Works/test-src/lsh-2.0.4/src/debug.c.x"
struct lsh_class packet_debug_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & abstract_write_pipe_class, (char *)"packet_debug", (size_t )sizeof(struct packet_debug ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_packet_debug_free};
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/debug.c"
static void do_debug(struct abstract_write *w , struct lsh_string *packet ) 
{ 
  struct packet_debug *closure ;
  uint8_t type ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 50
  closure = (struct packet_debug *)w;
  {
#line 52
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  }
#line 52
  if (tmp___0) {
    {
    {
#line 56
    tmp = lsh_string_data((struct lsh_string  const  *)packet);
    }
#line 56
    type = (uint8_t )*(tmp + 0);
    }
#line 57
    if ((int )type == 50) {
      {
      {
#line 59
      debug("DEBUG: %S %z *****\n", closure->prefix, packet_types[type]);
      }
      }
    } else
#line 57
    if ((int )type == 61) {
      {
      {
#line 59
      debug("DEBUG: %S %z *****\n", closure->prefix, packet_types[type]);
      }
      }
    } else {
      {
      {
#line 62
      debug("DEBUG: %S %z %xS\n", closure->prefix, packet_types[type], packet);
      }
      }
    }
  } else {
    {
    {
#line 53
    debug("DEBUG: %S empty packet\n", closure->prefix);
    }
    }
  }
  {
  {
#line 66
  (*((closure->super.next)->write))(closure->super.next, packet);
  }
  }
#line 67
  return;
}
}
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/debug.c"
struct abstract_write *make_packet_debug(struct abstract_write *next , struct lsh_string *prefix___0 ) 
{ 
  struct packet_debug *closure ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 73
  tmp = lsh_object_alloc(& packet_debug_class);
  }
#line 73
  closure = (struct packet_debug *)tmp;
#line 75
  closure->super.super.write = & do_debug;
#line 76
  closure->super.next = next;
#line 77
  closure->prefix = prefix___0;
  }
#line 79
  return (& closure->super.super);
}
}
#line 83 "/home/ysko/Works/test-src/lsh-2.0.4/src/debug.c"
static struct lsh_string *make_debug_packet(char const   *msg , int always_display ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 86
  tmp = ssh_format("%c%c%z%z", 4, always_display, msg, "");
  }
  }
#line 86
  return (tmp);
}
}
#line 95 "/home/ysko/Works/test-src/lsh-2.0.4/src/debug.c"
void send_debug_message(struct ssh_connection *connection , char const   *msg , int always_display ) 
{ 
  struct lsh_string *tmp ;

  {
  {
  {
#line 100
  tmp = make_debug_packet(msg, always_display);
  }
  {
#line 100
  connection_send_kex(connection, tmp);
  }
  }
#line 101
  return;
}
}
#line 103
static void do_connection_debug_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                        struct ssh_connection *connection  __attribute__((__unused__)) ,
                                        struct lsh_string *packet ) ;
#line 103 "/home/ysko/Works/test-src/lsh-2.0.4/src/debug.c"
struct packet_handler connection_debug_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_connection_debug_handler};
#line 103 "/home/ysko/Works/test-src/lsh-2.0.4/src/debug.c"
static void do_connection_debug_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                        struct ssh_connection *connection  __attribute__((__unused__)) ,
                                        struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  unsigned int always_display ;
  uint32_t length ;
  uint8_t const   *msg ;
  int language ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct exception *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
  {
#line 112
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 112
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 112
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 114
  tmp___2 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 114
  if (tmp___2) {
    {
    {
#line 114
    tmp___3 = parse_uint8(& buffer, & always_display);
    }
    }
#line 114
    if (tmp___3) {
      {
      {
#line 114
      tmp___4 = parse_string(& buffer, & length, & msg);
      }
      }
#line 114
      if (tmp___4) {
        {
        {
#line 114
        tmp___5 = parse_atom(& buffer, & language);
        }
        }
#line 114
        if (tmp___5) {
          {
          {
#line 114
          tmp___6 = parse_eod(& buffer);
          }
          }
#line 114
          if (tmp___6) {
#line 124
            if (always_display) {
              {
              {
#line 125
              werror("Received debug: %ups\n", length, msg);
              }
              }
            } else {
              {
              {
#line 128
              verbose("Received debug: %ups\n", length, msg);
              }
              }
            }
          } else {
            {
            {
#line 120
            tmp___1 = make_protocol_exception((uint32_t )2, "Invalid DEBUG message.");
            }
            {
#line 120
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
            }
            }
          }
        } else {
          {
          {
#line 120
          tmp___1 = make_protocol_exception((uint32_t )2, "Invalid DEBUG message.");
          }
          {
#line 120
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
          }
          }
        }
      } else {
        {
        {
#line 120
        tmp___1 = make_protocol_exception((uint32_t )2, "Invalid DEBUG message.");
        }
        {
#line 120
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
        }
        }
      }
    } else {
      {
      {
#line 120
      tmp___1 = make_protocol_exception((uint32_t )2, "Invalid DEBUG message.");
      }
      {
#line 120
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
      }
      }
    }
  } else {
    {
    {
#line 120
    tmp___1 = make_protocol_exception((uint32_t )2, "Invalid DEBUG message.");
    }
    {
#line 120
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
    }
    }
  }
#line 130
  return;
}
}
#line 993 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 51 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 70
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit  const  *__rlimits ) ;
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/daemon.h"
enum daemon_mode daemon_detect(void) ;
#line 42
int daemon_dup_null(int fd ) ;
#line 45
void daemon_close_fds(void) ;
#line 48
int daemon_disable_core(void) ;
#line 51
int daemon_pidfile(char const   *name ) ;
#line 53
int daemon_init(enum daemon_mode mode ) ;
#line 55
int daemon_close(char const   *name ) ;
#line 72 "/home/ysko/Works/test-src/lsh-2.0.4/src/daemon.c"
int daemon_pidfile(char const   *name ) 
{ 
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  struct lsh_string *pid ;
  __pid_t tmp___1 ;
  struct lsh_string *tmp___2 ;
  uint32_t pid_length ;
  uint32_t tmp___3 ;
  int res ;
  uint8_t const   *tmp___4 ;
  ssize_t tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
  {
#line 80
  fd = open(name, 193, 420);
  }
  }
#line 82
  if (fd < 0) {
    {
    {
#line 84
    tmp___0 = __errno_location();
    }
    }
#line 84
    if (*tmp___0 != 17) {
      {
      {
#line 86
      tmp = __errno_location();
      }
      {
#line 86
      werror("Failed to open pid file \'%z\' %e\n", name, *tmp);
      }
      }
#line 88
      return (0);
    }
    {
    {
#line 92
    werror("Pid file \'%z\' already exists.\n", name);
    }
    }
#line 93
    return (0);
  } else {
    {
    {
#line 97
    tmp___1 = getpid();
    }
    {
#line 97
    tmp___2 = ssh_format("%di", tmp___1);
    }
#line 97
    pid = tmp___2;
    {
#line 98
    tmp___3 = lsh_string_length((struct lsh_string  const  *)pid);
    }
#line 98
    pid_length = tmp___3;
    {
#line 99
    tmp___4 = lsh_string_data((struct lsh_string  const  *)pid);
    }
    {
#line 99
    tmp___5 = write(fd, (void const   *)tmp___4, pid_length);
    }
#line 99
    res = tmp___5;
    {
#line 100
    close(fd);
    }
    }
#line 102
    if (res > 0) {
#line 102
      if ((unsigned int )res == pid_length) {
        {
        {
#line 105
        lsh_string_free((struct lsh_string  const  *)pid);
        }
        }
#line 106
        return (1);
      }
    }
    {
    {
#line 108
    tmp___6 = __errno_location();
    }
    {
#line 108
    werror("Writing pid file \'%z\' failed %e\n", name, *tmp___6);
    }
    {
#line 111
    tmp___8 = unlink(name);
    }
    }
#line 111
    if (tmp___8 < 0) {
      {
      {
#line 112
      tmp___7 = __errno_location();
      }
      {
#line 112
      werror("Unlinking pid file \'%z\' failed %e\n", name, *tmp___7);
      }
      }
    }
    {
    {
#line 115
    lsh_string_free((struct lsh_string  const  *)pid);
    }
    }
#line 117
    return (0);
  }
}
}
#line 124 "/home/ysko/Works/test-src/lsh-2.0.4/src/daemon.c"
static int daemon_started_by_init(void) 
{ 
  __pid_t tmp ;

  {
  {
  {
#line 127
  tmp = getppid();
  }
  }
#line 127
  return (tmp == 1);
}
}
#line 137 "/home/ysko/Works/test-src/lsh-2.0.4/src/daemon.c"
static int daemon_started_by_inetd(void) 
{ 
  int optval ;
  socklen_t optlen ;
  int res ;
  int tmp ;

  {
  {
#line 141
  optlen = (socklen_t )sizeof(optval);
  {
#line 142
  tmp = getsockopt(0, 1, 3, (void */* __restrict  */)((void *)(& optval)), (socklen_t */* __restrict  */)(& optlen));
  }
#line 142
  res = tmp;
  }
#line 144
  return (res == 0);
}
}
#line 147 "/home/ysko/Works/test-src/lsh-2.0.4/src/daemon.c"
enum daemon_mode daemon_detect(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 150
  tmp___0 = daemon_started_by_init();
  }
  }
#line 150
  if (tmp___0) {
#line 151
    return ((enum daemon_mode )2);
  } else {
    {
    {
#line 152
    tmp = daemon_started_by_inetd();
    }
    }
#line 152
    if (tmp) {
#line 153
      return ((enum daemon_mode )3);
    } else {
#line 155
      return ((enum daemon_mode )1);
    }
  }
}
}
#line 159 "/home/ysko/Works/test-src/lsh-2.0.4/src/daemon.c"
int daemon_disable_core(void) 
{ 
  struct rlimit limit ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 162
  limit.rlim_cur = (rlim_t )0;
#line 162
  limit.rlim_max = (rlim_t )0;
  {
#line 168
  tmp = getrlimit((__rlimit_resource_t )4, & limit);
  }
  }
#line 168
  if (tmp == -1) {
#line 169
    return (0);
  }
  {
#line 171
  limit.rlim_cur = (rlim_t )0;
  {
#line 173
  tmp___0 = setrlimit((__rlimit_resource_t )4, (struct rlimit  const  *)(& limit));
  }
  }
#line 173
  if (tmp___0 == -1) {
#line 174
    return (0);
  }
#line 176
  return (1);
}
}
#line 179 "/home/ysko/Works/test-src/lsh-2.0.4/src/daemon.c"
int daemon_dup_null(int fd ) 
{ 
  int null ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 182
  tmp = open("/dev/null", 2);
  }
#line 182
  null = tmp;
  }
#line 183
  if (null < 0) {
    {
    {
#line 185
    tmp___0 = __errno_location();
    }
    {
#line 185
    werror("Opening /dev/null failed: %e\n", *tmp___0);
    }
    }
#line 186
    return (0);
  }
  {
  {
#line 188
  tmp___2 = dup2(null, fd);
  }
  }
#line 188
  if (tmp___2 < 0) {
    {
    {
#line 190
    tmp___1 = __errno_location();
    }
    {
#line 190
    werror("Failed to redirect fd %i to /dev/null: %e\n", *tmp___1);
    }
    {
#line 191
    close(null);
    }
    }
#line 192
    return (0);
  }
  {
  {
#line 195
  close(null);
  }
  }
#line 196
  return (1);
}
}
#line 219 "/home/ysko/Works/test-src/lsh-2.0.4/src/daemon.c"
void daemon_close_fds(void) 
{ 
  int fd ;
  int tmp ;
  int res ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 222
  tmp = getdtablesize();
  }
#line 222
  fd = tmp;
  }
  {
  {
#line 224
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 224
    fd --;
#line 224
    if (! (fd > 2)) {
#line 224
      goto while_break;
    }
    {
    {
#line 228
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 229
      res = close(fd);
      }
      }
#line 228
      if (res < 0) {
        {
        {
#line 228
        tmp___0 = __errno_location();
        }
        }
#line 228
        if (! (*tmp___0 == 4)) {
#line 228
          goto while_break___0;
        }
      } else {
#line 228
        goto while_break___0;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 232
    if (res == 0) {
      {
      {
#line 233
      werror("Closed spurious fd %i\n", fd);
      }
      }
    } else {
      {
      {
#line 234
      tmp___2 = __errno_location();
      }
      }
#line 234
      if (*tmp___2 != 9) {
        {
        {
#line 235
        tmp___1 = __errno_location();
        }
        {
#line 235
        werror("Closing spurious fd %i failed: %e\n", fd, *tmp___1);
        }
        }
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 237
  return;
}
}
#line 257 "/home/ysko/Works/test-src/lsh-2.0.4/src/daemon.c"
int daemon_init(enum daemon_mode mode ) 
{ 
  pid_t child ;
  __pid_t tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 263
  if ((unsigned int )mode == 1U) {
    {
    {
#line 272
    tmp = fork();
    }
    }
#line 274
    if (tmp == -1) {
#line 274
      goto case_neg_1;
    }
#line 276
    if (tmp == 0) {
#line 276
      goto case_0;
    }
#line 279
    goto switch_default;
    case_neg_1: 
#line 275
    return (0);
    case_0: 
#line 278
    goto switch_break;
    switch_default: 
    {
    {
#line 281
    _exit(0);
    }
    }
    switch_break: 
    {
    {
#line 285
    tmp___0 = setsid();
    }
    }
#line 285
    if (tmp___0 < 0) {
      {
      {
#line 287
      werror("daemon_init: setsid failed.\n");
      }
      }
#line 288
      return (0);
    }
    {
    {
#line 294
    child = fork();
    }
    }
#line 296
    if (child == -1) {
#line 296
      goto case_neg_1___0;
    }
#line 298
    if (child == 0) {
#line 298
      goto case_0___0;
    }
#line 300
    goto switch_default___0;
    case_neg_1___0: 
#line 297
    return (0);
    case_0___0: 
#line 299
    goto switch_break___0;
    switch_default___0: 
    {
    {
#line 301
    _exit(0);
    }
    }
    switch_break___0: ;
  }
  {
  {
#line 307
  tmp___1 = chdir("/");
  }
  }
#line 307
  if (tmp___1 == -1) {
#line 308
    return (0);
  }
  {
  {
#line 311
  umask((__mode_t )0);
  }
  }
#line 313
  return (1);
}
}
#line 317 "/home/ysko/Works/test-src/lsh-2.0.4/src/daemon.c"
int daemon_close(char const   *name ) 
{ 
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 320
  tmp___0 = unlink(name);
  }
  }
#line 320
  if (tmp___0 < 0) {
    {
    {
#line 322
    tmp = __errno_location();
    }
    {
#line 322
    werror("daemon_close: Unlink of pid file \'%z\' failed %e\n", name, *tmp);
    }
    }
#line 324
    return (0);
  }
#line 326
  return (1);
}
}
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct lsh_class crypto_instance_class ;
#line 63
struct lsh_class hash_instance_class ;
#line 113
struct lsh_class mac_instance_class ;
#line 139
struct lsh_class mac_algorithm_class ;
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.h"
struct crypto_algorithm crypto_aes256_cbc_algorithm ;
#line 30
struct crypto_algorithm crypto_aes256_ctr_algorithm ;
#line 31
struct crypto_algorithm crypto_arcfour_algorithm ;
#line 32
struct crypto_algorithm crypto_blowfish_cbc_algorithm ;
#line 33
struct crypto_algorithm crypto_cast128_cbc_algorithm ;
#line 34
struct crypto_algorithm crypto_des3_cbc_algorithm ;
#line 35
struct crypto_algorithm crypto_serpent256_cbc_algorithm ;
#line 36
struct crypto_algorithm crypto_twofish256_cbc_algorithm ;
#line 39
struct hash_algorithm  const  crypto_md5_algorithm ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct lsh_class arcfour_instance_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct lsh_class arcfour_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & crypto_instance_class, (char *)"arcfour_instance", (size_t )sizeof(struct arcfour_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 34
struct lsh_class aes_cbc_instance_class ;
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct lsh_class aes_cbc_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & crypto_instance_class, (char *)"aes_cbc_instance", (size_t )sizeof(struct aes_cbc_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 58
struct lsh_class aes_ctr_instance_class ;
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct lsh_class aes_ctr_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & crypto_instance_class, (char *)"aes_ctr_instance", (size_t )sizeof(struct aes_ctr_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 82
struct lsh_class des3_instance_class ;
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct lsh_class des3_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & crypto_instance_class, (char *)"des3_instance", (size_t )sizeof(struct des3_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 106
struct lsh_class cast128_instance_class ;
#line 110 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct lsh_class cast128_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & crypto_instance_class, (char *)"cast128_instance", (size_t )sizeof(struct cast128_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 130
struct lsh_class twofish_instance_class ;
#line 134 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct lsh_class twofish_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & crypto_instance_class, (char *)"twofish_instance", (size_t )sizeof(struct twofish_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 154
struct lsh_class blowfish_instance_class ;
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct lsh_class blowfish_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & crypto_instance_class, (char *)"blowfish_instance", (size_t )sizeof(struct blowfish_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 178
struct lsh_class serpent_instance_class ;
#line 182 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct lsh_class serpent_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & crypto_instance_class, (char *)"serpent_instance", (size_t )sizeof(struct serpent_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 203
struct lsh_class hmac_instance_class ;
#line 207 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct lsh_class hmac_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & mac_instance_class, (char *)"hmac_instance", (size_t )sizeof(struct hmac_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 227
struct lsh_class hmac_algorithm_class ;
#line 231 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c.x"
struct lsh_class hmac_algorithm_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & mac_algorithm_class, (char *)"hmac_algorithm", (size_t )sizeof(struct hmac_algorithm ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_crypt_arcfour(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                             uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct arcfour_instance *self ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 69
  self = (struct arcfour_instance *)s;
#line 71
  if (! (! (length % 8U))) {
    {
    {
#line 71
    __assert_fail("!(length % 8)", "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c",
                  71U, "do_crypt_arcfour");
    }
    }
  }
  {
  {
#line 73
  lsh_string_crypt(dst, di, src, si, length, (void (*)(void *ctx , unsigned int length ,
                                                       uint8_t *dst , uint8_t const   *src ))(& nettle_arcfour_crypt),
                   (void *)(& self->ctx));
  }
  }
#line 75
  return;
}
}
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static struct crypto_instance *make_arcfour_instance(struct crypto_algorithm *ignored  __attribute__((__unused__)) ,
                                                     int mode  __attribute__((__unused__)) ,
                                                     uint8_t const   *key , uint8_t const   *iv  __attribute__((__unused__)) ) 
{ 
  struct arcfour_instance *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 82
  tmp = lsh_object_alloc(& arcfour_instance_class);
  }
#line 82
  self = (struct arcfour_instance *)tmp;
#line 84
  self->super.block_size = (uint32_t )8;
#line 85
  self->super.crypt = & do_crypt_arcfour;
  {
#line 87
  nettle_arcfour_set_key(& self->ctx, 16U, key);
  }
  }
#line 89
  return (& self->super);
}
}
#line 92 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct crypto_algorithm crypto_arcfour_algorithm  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )8, (uint32_t )16, (uint32_t )0, & make_arcfour_instance};
#line 107 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_aes_cbc_encrypt(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                               uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct aes_cbc_instance *self ;

  {
  {
#line 113
  self = (struct aes_cbc_instance *)s;
  {
#line 115
  lsh_string_cbc_encrypt(dst, di, src, si, length, (uint32_t )16, self->ctx.iv, (void (*)(void *ctx ,
                                                                                          unsigned int length ,
                                                                                          uint8_t *dst ,
                                                                                          uint8_t const   *src ))(& nettle_aes_encrypt),
                         (void *)(& self->ctx.ctx));
  }
  }
#line 119
  return;
}
}
#line 121 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_aes_cbc_decrypt(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                               uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct aes_cbc_instance *self ;

  {
  {
#line 127
  self = (struct aes_cbc_instance *)s;
  {
#line 129
  lsh_string_cbc_decrypt(dst, di, src, si, length, (uint32_t )16, self->ctx.iv, (void (*)(void *ctx ,
                                                                                          unsigned int length ,
                                                                                          uint8_t *dst ,
                                                                                          uint8_t const   *src ))(& nettle_aes_decrypt),
                         (void *)(& self->ctx.ctx));
  }
  }
#line 133
  return;
}
}
#line 135 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static struct crypto_instance *make_aes_cbc_instance(struct crypto_algorithm *algorithm ,
                                                     int mode , uint8_t const   *key ,
                                                     uint8_t const   *iv ) 
{ 
  struct aes_cbc_instance *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 139
  tmp = lsh_object_alloc(& aes_cbc_instance_class);
  }
#line 139
  self = (struct aes_cbc_instance *)tmp;
#line 141
  self->super.block_size = (uint32_t )16;
  }
#line 143
  if (mode == 0) {
    {
#line 145
    self->super.crypt = & do_aes_cbc_encrypt;
    {
#line 146
    nettle_aes_set_encrypt_key(& self->ctx.ctx, algorithm->key_size, key);
    }
    }
  } else {
    {
#line 150
    self->super.crypt = & do_aes_cbc_decrypt;
    {
#line 151
    nettle_aes_set_decrypt_key(& self->ctx.ctx, algorithm->key_size, key);
    }
    }
  }
  {
  {
#line 154
  memcpy((void */* __restrict  */)((void *)(self->ctx.iv)), (void const   */* __restrict  */)((void const   *)iv),
         (size_t )sizeof(self->ctx.iv));
  }
  }
#line 156
  return (& self->super);
}
}
#line 167 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct crypto_algorithm crypto_aes256_cbc_algorithm  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16, (uint32_t )32, (uint32_t )16, & make_aes_cbc_instance};
#line 178 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_aes_ctr_crypt(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                             uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct aes_ctr_instance *self ;

  {
  {
#line 184
  self = (struct aes_ctr_instance *)s;
  {
#line 186
  lsh_string_ctr_crypt(dst, di, src, si, length, (uint32_t )16, self->ctx.ctr, (void (*)(void *ctx ,
                                                                                         unsigned int length ,
                                                                                         uint8_t *dst ,
                                                                                         uint8_t const   *src ))(& nettle_aes_encrypt),
                       (void *)(& self->ctx.ctx));
  }
  }
#line 190
  return;
}
}
#line 192 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static struct crypto_instance *make_aes_ctr_instance(struct crypto_algorithm *algorithm ,
                                                     int mode  __attribute__((__unused__)) ,
                                                     uint8_t const   *key , uint8_t const   *iv ) 
{ 
  struct aes_ctr_instance *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 196
  tmp = lsh_object_alloc(& aes_ctr_instance_class);
  }
#line 196
  self = (struct aes_ctr_instance *)tmp;
#line 198
  self->super.block_size = (uint32_t )16;
#line 200
  self->super.crypt = & do_aes_ctr_crypt;
  {
#line 201
  nettle_aes_set_encrypt_key(& self->ctx.ctx, algorithm->key_size, key);
  }
  {
#line 203
  memcpy((void */* __restrict  */)((void *)(self->ctx.ctr)), (void const   */* __restrict  */)((void const   *)iv),
         (size_t )sizeof(self->ctx.ctr));
  }
  }
#line 205
  return (& self->super);
}
}
#line 208 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct crypto_algorithm crypto_aes256_ctr_algorithm  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16, (uint32_t )32, (uint32_t )16, & make_aes_ctr_instance};
#line 220 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_des3_encrypt(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                            uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct des3_instance *self ;

  {
  {
#line 226
  self = (struct des3_instance *)s;
  {
#line 228
  lsh_string_cbc_encrypt(dst, di, src, si, length, (uint32_t )8, self->ctx.iv, (void (*)(void *ctx ,
                                                                                         unsigned int length ,
                                                                                         uint8_t *dst ,
                                                                                         uint8_t const   *src ))(& nettle_des3_encrypt),
                         (void *)(& self->ctx.ctx));
  }
  }
#line 232
  return;
}
}
#line 234 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_des3_decrypt(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                            uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct des3_instance *self ;

  {
  {
#line 240
  self = (struct des3_instance *)s;
  {
#line 242
  lsh_string_cbc_decrypt(dst, di, src, si, length, (uint32_t )8, self->ctx.iv, (void (*)(void *ctx ,
                                                                                         unsigned int length ,
                                                                                         uint8_t *dst ,
                                                                                         uint8_t const   *src ))(& nettle_des3_decrypt),
                         (void *)(& self->ctx.ctx));
  }
  }
#line 246
  return;
}
}
#line 248 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static struct crypto_instance *make_des3_cbc_instance(struct crypto_algorithm *algorithm  __attribute__((__unused__)) ,
                                                      int mode , uint8_t const   *key ,
                                                      uint8_t const   *iv ) 
{ 
  struct des3_instance *self ;
  struct lsh_object *tmp ;
  uint8_t pkey[24] ;
  int tmp___0 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
  {
#line 253
  tmp = lsh_object_alloc(& des3_instance_class);
  }
#line 253
  self = (struct des3_instance *)tmp;
  {
#line 257
  nettle_des_fix_parity(24U, pkey, key);
  }
#line 259
  self->super.block_size = (uint32_t )8;
  }
#line 260
  if (mode == 0) {
#line 260
    self->super.crypt = & do_des3_encrypt;
  } else {
#line 260
    self->super.crypt = & do_des3_decrypt;
  }
  {
  {
#line 264
  memcpy((void */* __restrict  */)((void *)(self->ctx.iv)), (void const   */* __restrict  */)((void const   *)iv),
         (size_t )sizeof(self->ctx.iv));
  }
  {
#line 266
  tmp___0 = nettle_des3_set_key(& self->ctx.ctx, (uint8_t const   *)(pkey));
  }
  }
#line 266
  if (tmp___0) {
#line 267
    return (& self->super);
  }
#line 271
  if ((unsigned int )self->ctx.ctx.status == 1U) {
#line 271
    goto case_1;
  }
#line 273
  if ((unsigned int )self->ctx.ctx.status == 2U) {
#line 273
    goto case_2;
  }
#line 277
  goto switch_default;
  case_1: 
  {
  {
#line 272
  fatal("Internal error! Bad parity in make_des3_instance.\n");
  }
  }
  case_2: 
  {
  {
#line 274
  werror("Detected weak DES key.\n");
  }
  {
#line 275
  gc_kill((struct lsh_object *)self);
  }
  }
#line 276
  return ((struct crypto_instance *)((void *)0));
  switch_default: 
  {
  {
#line 278
  fatal("Internal error!\n");
  }
  }

#line 283
  return ((struct crypto_instance *)0);
}
}
#line 282 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct crypto_algorithm crypto_des3_cbc_algorithm  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )8, (uint32_t )24, (uint32_t )8, & make_des3_cbc_instance};
#line 296 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_cast128_encrypt(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                               uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct cast128_instance *self ;

  {
  {
#line 302
  self = (struct cast128_instance *)s;
  {
#line 304
  lsh_string_cbc_encrypt(dst, di, src, si, length, (uint32_t )8, self->ctx.iv, (void (*)(void *ctx ,
                                                                                         unsigned int length ,
                                                                                         uint8_t *dst ,
                                                                                         uint8_t const   *src ))(& nettle_cast128_encrypt),
                         (void *)(& self->ctx.ctx));
  }
  }
#line 308
  return;
}
}
#line 310 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_cast128_decrypt(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                               uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct cast128_instance *self ;

  {
  {
#line 316
  self = (struct cast128_instance *)s;
  {
#line 318
  lsh_string_cbc_decrypt(dst, di, src, si, length, (uint32_t )8, self->ctx.iv, (void (*)(void *ctx ,
                                                                                         unsigned int length ,
                                                                                         uint8_t *dst ,
                                                                                         uint8_t const   *src ))(& nettle_cast128_decrypt),
                         (void *)(& self->ctx.ctx));
  }
  }
#line 322
  return;
}
}
#line 324 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static struct crypto_instance *make_cast128_cbc_instance(struct crypto_algorithm *algorithm ,
                                                         int mode , uint8_t const   *key ,
                                                         uint8_t const   *iv ) 
{ 
  struct cast128_instance *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 328
  tmp = lsh_object_alloc(& cast128_instance_class);
  }
#line 328
  self = (struct cast128_instance *)tmp;
#line 330
  self->super.block_size = (uint32_t )8;
  }
#line 331
  if (mode == 0) {
#line 331
    self->super.crypt = & do_cast128_encrypt;
  } else {
#line 331
    self->super.crypt = & do_cast128_decrypt;
  }
  {
  {
#line 335
  nettle_cast128_set_key(& self->ctx.ctx, algorithm->key_size, key);
  }
  {
#line 336
  memcpy((void */* __restrict  */)((void *)(self->ctx.iv)), (void const   */* __restrict  */)((void const   *)iv),
         (size_t )sizeof(self->ctx.iv));
  }
  }
#line 338
  return (& self->super);
}
}
#line 341 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct crypto_algorithm crypto_cast128_cbc_algorithm  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )8, (uint32_t )16, (uint32_t )8, & make_cast128_cbc_instance};
#line 356 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_twofish_encrypt(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                               uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct twofish_instance *self ;

  {
  {
#line 362
  self = (struct twofish_instance *)s;
  {
#line 364
  lsh_string_cbc_encrypt(dst, di, src, si, length, (uint32_t )16, self->ctx.iv, (void (*)(void *ctx ,
                                                                                          unsigned int length ,
                                                                                          uint8_t *dst ,
                                                                                          uint8_t const   *src ))(& nettle_twofish_encrypt),
                         (void *)(& self->ctx.ctx));
  }
  }
#line 368
  return;
}
}
#line 370 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_twofish_decrypt(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                               uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct twofish_instance *self ;

  {
  {
#line 376
  self = (struct twofish_instance *)s;
  {
#line 378
  lsh_string_cbc_decrypt(dst, di, src, si, length, (uint32_t )16, self->ctx.iv, (void (*)(void *ctx ,
                                                                                          unsigned int length ,
                                                                                          uint8_t *dst ,
                                                                                          uint8_t const   *src ))(& nettle_twofish_decrypt),
                         (void *)(& self->ctx.ctx));
  }
  }
#line 382
  return;
}
}
#line 384 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static struct crypto_instance *make_twofish_cbc_instance(struct crypto_algorithm *algorithm ,
                                                         int mode , uint8_t const   *key ,
                                                         uint8_t const   *iv ) 
{ 
  struct twofish_instance *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 388
  tmp = lsh_object_alloc(& twofish_instance_class);
  }
#line 388
  self = (struct twofish_instance *)tmp;
#line 390
  self->super.block_size = (uint32_t )16;
  }
#line 391
  if (mode == 0) {
#line 391
    self->super.crypt = & do_twofish_encrypt;
  } else {
#line 391
    self->super.crypt = & do_twofish_decrypt;
  }
  {
  {
#line 395
  nettle_twofish_set_key(& self->ctx.ctx, algorithm->key_size, key);
  }
  {
#line 396
  memcpy((void */* __restrict  */)((void *)(self->ctx.iv)), (void const   */* __restrict  */)((void const   *)iv),
         (size_t )sizeof(self->ctx.iv));
  }
  }
#line 398
  return (& self->super);
}
}
#line 401 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct crypto_algorithm crypto_twofish256_cbc_algorithm  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16, (uint32_t )32, (uint32_t )16, & make_twofish_cbc_instance};
#line 415 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_blowfish_encrypt(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                                uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct blowfish_instance *self ;

  {
  {
#line 421
  self = (struct blowfish_instance *)s;
  {
#line 423
  lsh_string_cbc_encrypt(dst, di, src, si, length, (uint32_t )8, self->ctx.iv, (void (*)(void *ctx ,
                                                                                         unsigned int length ,
                                                                                         uint8_t *dst ,
                                                                                         uint8_t const   *src ))(& nettle_blowfish_encrypt),
                         (void *)(& self->ctx.ctx));
  }
  }
#line 427
  return;
}
}
#line 429 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_blowfish_decrypt(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                                uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct blowfish_instance *self ;

  {
  {
#line 435
  self = (struct blowfish_instance *)s;
  {
#line 437
  lsh_string_cbc_decrypt(dst, di, src, si, length, (uint32_t )8, self->ctx.iv, (void (*)(void *ctx ,
                                                                                         unsigned int length ,
                                                                                         uint8_t *dst ,
                                                                                         uint8_t const   *src ))(& nettle_blowfish_decrypt),
                         (void *)(& self->ctx.ctx));
  }
  }
#line 441
  return;
}
}
#line 443 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static struct crypto_instance *make_blowfish_cbc_instance(struct crypto_algorithm *algorithm ,
                                                          int mode , uint8_t const   *key ,
                                                          uint8_t const   *iv ) 
{ 
  struct blowfish_instance *self ;
  struct lsh_object *tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 447
  tmp = lsh_object_alloc(& blowfish_instance_class);
  }
#line 447
  self = (struct blowfish_instance *)tmp;
#line 449
  self->super.block_size = (uint32_t )8;
  }
#line 450
  if (mode == 0) {
#line 450
    self->super.crypt = & do_blowfish_encrypt;
  } else {
#line 450
    self->super.crypt = & do_blowfish_decrypt;
  }
  {
  {
#line 454
  memcpy((void */* __restrict  */)((void *)(self->ctx.iv)), (void const   */* __restrict  */)((void const   *)iv),
         (size_t )sizeof(self->ctx.iv));
  }
  {
#line 456
  tmp___0 = nettle_blowfish_set_key(& self->ctx.ctx, algorithm->key_size, key);
  }
  }
#line 456
  if (tmp___0) {
#line 457
    return (& self->super);
  } else {
    {
    {
#line 460
    werror("Detected a weak blowfish key!\n");
    }
    {
#line 461
    gc_kill((struct lsh_object *)self);
    }
    }
#line 462
    return ((struct crypto_instance *)((void *)0));
  }
}
}
#line 466 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct crypto_algorithm crypto_blowfish_cbc_algorithm  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )8, (uint32_t )16, (uint32_t )8, & make_blowfish_cbc_instance};
#line 481 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_serpent_encrypt(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                               uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct serpent_instance *self ;

  {
  {
#line 487
  self = (struct serpent_instance *)s;
  {
#line 489
  lsh_string_cbc_encrypt(dst, di, src, si, length, (uint32_t )16, self->ctx.iv, (void (*)(void *ctx ,
                                                                                          unsigned int length ,
                                                                                          uint8_t *dst ,
                                                                                          uint8_t const   *src ))(& nettle_serpent_encrypt),
                         (void *)(& self->ctx.ctx));
  }
  }
#line 493
  return;
}
}
#line 495 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_serpent_decrypt(struct crypto_instance *s , uint32_t length , struct lsh_string *dst ,
                               uint32_t di , struct lsh_string  const  *src , uint32_t si ) 
{ 
  struct serpent_instance *self ;

  {
  {
#line 501
  self = (struct serpent_instance *)s;
  {
#line 503
  lsh_string_cbc_decrypt(dst, di, src, si, length, (uint32_t )16, self->ctx.iv, (void (*)(void *ctx ,
                                                                                          unsigned int length ,
                                                                                          uint8_t *dst ,
                                                                                          uint8_t const   *src ))(& nettle_serpent_decrypt),
                         (void *)(& self->ctx.ctx));
  }
  }
#line 507
  return;
}
}
#line 509 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static struct crypto_instance *make_serpent_cbc_instance(struct crypto_algorithm *algorithm ,
                                                         int mode , uint8_t const   *key ,
                                                         uint8_t const   *iv ) 
{ 
  struct serpent_instance *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 513
  tmp = lsh_object_alloc(& serpent_instance_class);
  }
#line 513
  self = (struct serpent_instance *)tmp;
#line 515
  self->super.block_size = (uint32_t )16;
  }
#line 516
  if (mode == 0) {
#line 516
    self->super.crypt = & do_serpent_encrypt;
  } else {
#line 516
    self->super.crypt = & do_serpent_decrypt;
  }
  {
  {
#line 520
  nettle_serpent_set_key(& self->ctx.ctx, algorithm->key_size, key);
  }
  {
#line 521
  memcpy((void */* __restrict  */)((void *)(self->ctx.iv)), (void const   */* __restrict  */)((void const   *)iv),
         (size_t )sizeof(self->ctx.iv));
  }
  }
#line 523
  return (& self->super);
}
}
#line 526 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct crypto_algorithm crypto_serpent256_cbc_algorithm  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16, (uint32_t )32, (uint32_t )16, & make_serpent_cbc_instance};
#line 534 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
void hash_update(struct hash_instance *self , uint32_t length , uint8_t const   *data ) 
{ 


  {
  {
  {
#line 538
  (*((self->type)->update))((void *)(self->ctx), length, data);
  }
  }
#line 539
  return;
}
}
#line 541 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct lsh_string *hash_digest_string(struct hash_instance *self ) 
{ 
  struct lsh_string *s ;
  struct lsh_string *tmp ;

  {
  {
  {
#line 544
  tmp = lsh_string_alloc((uint32_t )(self->type)->digest_size);
  }
#line 544
  s = tmp;
  {
#line 545
  lsh_string_write_hash(s, (uint32_t )0, self->type, (void *)(self->ctx));
  }
  }
#line 547
  return (s);
}
}
#line 553 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct hash_instance *hash_copy(struct hash_instance *self ) 
{ 
  struct hash_instance *copy ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 556
  tmp = lsh_var_clone((struct lsh_object *)self, (size_t )((unsigned long )(& ((struct hash_instance *)0)->ctx) + (unsigned long )(self->type)->context_size));
  }
#line 556
  copy = (struct hash_instance *)tmp;
  }
#line 559
  return (copy);
}
}
#line 562 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct hash_instance *make_hash(struct hash_algorithm  const  *self ) 
{ 
  struct hash_instance *instance ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 565
  tmp = lsh_var_alloc(& hash_instance_class, (size_t )((unsigned long )(& ((struct hash_instance *)0)->ctx) + (unsigned long )(self->type)->context_size));
  }
#line 565
  instance = (struct hash_instance *)tmp;
#line 568
  instance->type = (struct nettle_hash  const  *)self->type;
  {
#line 569
  (*((self->type)->init))((void *)(instance->ctx));
  }
  }
#line 571
  return (instance);
}
}
#line 574 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct hash_algorithm  const  crypto_md5_algorithm  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & nettle_md5};
#line 578 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct hash_algorithm  const  crypto_sha1_algorithm  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & nettle_sha1};
#line 600 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static void do_hmac_update(struct mac_instance *s , uint32_t length , uint8_t const   *data ) 
{ 
  struct hmac_instance *self ;

  {
  {
#line 604
  self = (struct hmac_instance *)s;
  {
#line 605
  (*((self->type)->update))((void *)(self->ctx + 2U * (unsigned int )(self->type)->context_size),
                            length, data);
  }
  }
#line 606
  return;
}
}
#line 608 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static struct lsh_string *do_hmac_digest(struct mac_instance *s , struct lsh_string *res ,
                                         uint32_t start ) 
{ 
  struct hmac_instance *self ;

  {
  {
#line 612
  self = (struct hmac_instance *)s;
  {
#line 613
  lsh_string_write_hmac(res, start, self->type, self->super.mac_size, (void const   *)(self->ctx),
                        (void const   *)(self->ctx + (self->type)->context_size),
                        (void *)(self->ctx + 2U * (unsigned int )(self->type)->context_size));
  }
  }
#line 615
  return (res);
}
}
#line 627 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
static struct mac_instance *make_hmac_instance(struct mac_algorithm *s , uint32_t key_length ,
                                               uint8_t const   *key ) 
{ 
  struct hmac_algorithm *self ;
  struct hmac_instance *instance ;
  struct lsh_object *tmp ;

  {
  {
#line 632
  self = (struct hmac_algorithm *)s;
  {
#line 633
  tmp = lsh_var_alloc(& hmac_instance_class, (size_t )((unsigned long )(& ((struct hmac_instance *)0)->ctx) + (unsigned long )(3U * (unsigned int )(self->type)->context_size)));
  }
#line 633
  instance = (struct hmac_instance *)tmp;
#line 636
  instance->type = self->type;
  {
#line 638
  nettle_hmac_set_key((void *)(instance->ctx), (void *)(instance->ctx + (instance->type)->context_size),
                      (void *)(instance->ctx + 2U * (unsigned int )(instance->type)->context_size),
                      self->type, key_length, key);
  }
#line 642
  instance->super.mac_size = self->super.mac_size;
#line 643
  instance->super.update = & do_hmac_update;
#line 644
  instance->super.digest = & do_hmac_digest;
  }
#line 646
  return (& instance->super);
}
}
#line 649 "/home/ysko/Works/test-src/lsh-2.0.4/src/crypto.c"
struct mac_algorithm *make_hmac_algorithm(struct hash_algorithm  const  *h___0 ) 
{ 
  struct hmac_algorithm *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 652
  tmp = lsh_object_alloc(& hmac_algorithm_class);
  }
#line 652
  self = (struct hmac_algorithm *)tmp;
#line 654
  self->super.mac_size = (uint32_t )(h___0->type)->digest_size;
#line 657
  self->super.key_size = (uint32_t )(h___0->type)->digest_size;
#line 658
  self->super.make_mac = & make_hmac_instance;
#line 660
  self->type = (struct nettle_hash  const  *)h___0->type;
  }
#line 662
  return (& self->super);
}
}
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection_commands.h.x"
struct lsh_class connection_command_class ;
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection_commands.h"
struct command connection_require_userauth ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection_commands.h.x"
static void do_connection_command_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct connection_command *i ;

  {
  {
#line 18
  i = (struct connection_command *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection_commands.h.x"
struct lsh_class connection_command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"connection_command", (size_t )sizeof(struct connection_command ),
    & do_connection_command_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection_commands.c"
static void do_connection_remember(struct command_2 *s  __attribute__((__unused__)) ,
                                   struct lsh_object *a1 , struct lsh_object *a2 ,
                                   struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection_commands.c"
struct command_2 connection_remember  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_2}, & do_connection_remember};
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection_commands.c"
static void do_connection_remember(struct command_2 *s  __attribute__((__unused__)) ,
                                   struct lsh_object *a1 , struct lsh_object *a2 ,
                                   struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct ssh_connection *connection ;
  struct resource *resource ;

  {
#line 49
  connection = (struct ssh_connection *)a1;
#line 50
  resource = (struct resource *)a2;
#line 52
  if (resource) {
    {
    {
#line 53
    remember_resource(connection->resources, resource);
    }
    }
  }
  {
  {
#line 55
  (*(c->c))(c, (struct lsh_object *)resource);
  }
  }
#line 56
  return;
}
}
#line 59
static void do_connection_require_userauth(struct command *s  __attribute__((__unused__)) ,
                                           struct lsh_object *a , struct command_continuation *c ,
                                           struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection_commands.c"
struct command connection_require_userauth  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_connection_require_userauth};
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection_commands.c"
static void do_connection_require_userauth(struct command *s  __attribute__((__unused__)) ,
                                           struct lsh_object *a , struct command_continuation *c ,
                                           struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct ssh_connection *connection ;
  struct exception *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 64
  connection = (struct ssh_connection *)a;
#line 66
  if (connection->user) {
    {
    {
#line 67
    (*(c->c))(c, (struct lsh_object *)connection);
    }
    }
  } else {
    {
    {
#line 69
    tmp = make_protocol_exception((uint32_t )7, "Access denied.");
    }
    {
#line 69
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp);
    }
    }
  }
#line 72
  return;
}
}
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h.x"
struct lsh_class ssh_connection_class ;
#line 231 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h"
void connection_wakeup(struct ssh_connection *self , struct command_continuation *c ) ;
#line 264
void connection_clear_timeout(struct ssh_connection *connection ) ;
#line 272
struct packet_handler connection_unimplemented_handler ;
#line 275
struct packet_handler connection_disconnect_handler ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h.x"
struct lsh_class packet_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"packet_handler", (size_t )sizeof(struct packet_handler ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h.x"
static void do_ssh_connection_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct ssh_connection *i ;
  unsigned int k2 ;
  unsigned int k4 ;

  {
  {
#line 78
  i = (struct ssh_connection *)o;
  {
#line 79
  (*mark)((struct lsh_object *)i->e);
  }
  {
#line 80
  (*mark)((struct lsh_object *)i->timer);
  }
  {
#line 81
  (*mark)((struct lsh_object *)i->user);
  }
  {
#line 82
  (*mark)((struct lsh_object *)i->chain);
  }
  {
#line 83
  (*mark)((struct lsh_object *)i->resources);
  }
  {
#line 84
  (*mark)((struct lsh_object *)i->peer);
  }
  {
#line 85
  (*mark)((struct lsh_object *)i->local);
  }
  {
#line 86
  (*mark)((struct lsh_object *)i->kexinit);
  }
  {
#line 87
  (*mark)((struct lsh_object *)i->rec_mac);
  }
  {
#line 88
  (*mark)((struct lsh_object *)i->rec_crypto);
  }
  {
#line 89
  (*mark)((struct lsh_object *)i->rec_compress);
  }
  {
#line 90
  (*mark)((struct lsh_object *)i->socket);
  }
  {
#line 91
  (*mark)((struct lsh_object *)i->write_packet);
  }
  {
#line 92
  (*mark)((struct lsh_object *)i->send_mac);
  }
  {
#line 93
  (*mark)((struct lsh_object *)i->send_crypto);
  }
  {
#line 94
  (*mark)((struct lsh_object *)i->send_compress);
  }
  {
#line 95
  string_queue_mark(& i->pending, mark);
  }
  {
#line 97
  string_queue_mark(& i->send_queue, mark);
  }
  {
#line 99
  (*mark)((struct lsh_object *)i->key_expire);
  }
  {
#line 100
  (*mark)((struct lsh_object *)i->keyexchange_done);
  }
  {
#line 101
  (*mark)((struct lsh_object *)i->wakeup);
  }
#line 104
  k2 = 0U;
  }
  {
  {
#line 104
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 104
    if (! (k2 < 2U)) {
#line 104
      goto while_break;
    }
    {
    {
#line 105
    (*mark)((struct lsh_object *)i->kexinits[k2]);
    }
#line 104
    k2 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 109
  k4 = 0U;
  {
  {
#line 109
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 109
    if (! (k4 < 256U)) {
#line 109
      goto while_break___0;
    }
    {
    {
#line 110
    (*mark)((struct lsh_object *)i->dispatch[k4]);
    }
#line 109
    k4 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
  {
#line 112
  (*mark)((struct lsh_object *)i->table);
  }
  }
#line 113
  return;
}
}
#line 114 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h.x"
static void do_ssh_connection_free(struct lsh_object *o ) 
{ 
  struct ssh_connection *i ;
  unsigned int k5 ;
  unsigned int k7 ;

  {
#line 117
  i = (struct ssh_connection *)o;
#line 120
  k5 = 0U;
  {
  {
#line 120
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 120
    if (! (k5 < 2U)) {
#line 120
      goto while_break;
    }
    {
    {
#line 121
    lsh_string_free((struct lsh_string  const  *)i->versions[k5]);
    }
#line 120
    k5 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 123
  lsh_string_free((struct lsh_string  const  *)i->session_id);
  }
  {
#line 124
  string_queue_free(& i->pending);
  }
  {
#line 125
  string_queue_free(& i->send_queue);
  }
#line 128
  k7 = 0U;
  }
  {
  {
#line 128
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 128
    if (! (k7 < 2U)) {
#line 128
      goto while_break___0;
    }
    {
    {
#line 129
    lsh_string_free((struct lsh_string  const  *)i->literal_kexinits[k7]);
    }
#line 128
    k7 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 131
  return;
}
}
#line 132 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.h.x"
struct lsh_class ssh_connection_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & abstract_write_class, (char *)"ssh_connection", (size_t )sizeof(struct ssh_connection ),
    & do_ssh_connection_mark, & do_ssh_connection_free};
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
struct lsh_class exc_connection_handler_class ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
static void do_exc_connection_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct exc_connection_handler *i ;

  {
  {
#line 19
  i = (struct exc_connection_handler *)o;
  {
#line 20
  (*mark)((struct lsh_object *)i->backend);
  }
  {
#line 21
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 22
  return;
}
}
#line 23 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
struct lsh_class exc_connection_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"exc_connection_handler", (size_t )sizeof(struct exc_connection_handler ),
    & do_exc_connection_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 43
struct lsh_class connection_flow_controlled_class ;
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
static void do_connection_flow_controlled_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct connection_flow_controlled *i ;

  {
  {
#line 51
  i = (struct connection_flow_controlled *)o;
  {
#line 52
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 53
  return;
}
}
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
struct lsh_class connection_flow_controlled_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & flow_controlled_class, (char *)"connection_flow_controlled", (size_t )sizeof(struct connection_flow_controlled ),
    & do_connection_flow_controlled_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 74
struct lsh_class connection_close_handler_class ;
#line 78 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
static void do_connection_close_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct connection_close_handler *i ;

  {
  {
#line 82
  i = (struct connection_close_handler *)o;
  {
#line 83
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 84
  return;
}
}
#line 85 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
struct lsh_class connection_close_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & lsh_callback_class, (char *)"connection_close_handler", (size_t )sizeof(struct connection_close_handler ),
    & do_connection_close_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 106
struct lsh_class connection_timeout_class ;
#line 110 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
static void do_connection_timeout_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct connection_timeout *i ;

  {
  {
#line 114
  i = (struct connection_timeout *)o;
  {
#line 115
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 116
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 117
  return;
}
}
#line 118 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c.x"
struct lsh_class connection_timeout_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & lsh_callback_class, (char *)"connection_timeout", (size_t )sizeof(struct connection_timeout ),
    & do_connection_timeout_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
char const   *packet_types[256]  = 
#line 50 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
  {      "Unknown",      "DISCONNECT",      "IGNORE",      "UNIMPLEMENTED", 
        "DEBUG",      "SERVICE_REQUEST",      "SERVICE_ACCEPT",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "KEXINIT",      "NEWKEYS",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "KEXDH_INIT|KEXSRP_INIT|KEX_DH_MOD_GROUPS",      "KEXDH_REPLY|KEXSRP_REPLY|KEX_DH_MOD_INIT", 
        "KEXSRP_PROOF|KEX_DH_MOD_REPLY",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "USERAUTH_REQUEST",      "USERAUTH_FAILURE", 
        "USERAUTH_SUCCESS",      "USERAUTH_BANNER",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "USERAUTH_PK_OK|USERAUTH_PASSWD_CHANGEREQ|USERAUTH_INFO_REQUEST|USERAUTH_GSSAPI_RESPONSE",      "USERAUTH_INFO_RESPONSE|USERAUTH_GSSAPI_TOKEN",      "Unknown",      "USERAUTH_GSSAPI_EXCHANGE_COMPLETE", 
        "USERAUTH_GSSAPI_ERROR",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "GLOBAL_REQUEST",      "REQUEST_SUCCESS",      "REQUEST_FAILURE",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "CHANNEL_OPEN",      "CHANNEL_OPEN_CONFIRMATION", 
        "CHANNEL_OPEN_FAILURE",      "CHANNEL_WINDOW_ADJUST",      "CHANNEL_DATA",      "CHANNEL_EXTENDED_DATA", 
        "CHANNEL_EOF",      "CHANNEL_CLOSE",      "CHANNEL_REQUEST",      "CHANNEL_SUCCESS", 
        "CHANNEL_FAILURE",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown"};
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static void connection_handle_packet(struct ssh_connection *closure , struct lsh_string *packet ) 
{ 
  uint8_t msg ;
  uint32_t length ;
  uint32_t tmp ;
  struct exception *tmp___0 ;
  struct exception *tmp___1 ;
  uint8_t const   *tmp___2 ;
  struct exception *tmp___3 ;
  struct exception *tmp___4 ;
  struct exception *tmp___5 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
  {
  {
#line 59
  tmp = lsh_string_length((struct lsh_string  const  *)packet);
  }
#line 59
  length = tmp;
  }
#line 61
  if (! (! closure->paused)) {
    {
    {
#line 61
    __assert_fail("!closure->paused", "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c",
                  61U, "connection_handle_packet");
    }
    }
  }
#line 63
  if (! length) {
    {
    {
#line 65
    werror("connection.c: Received empty packet!\n");
    }
    {
#line 66
    tmp___0 = make_protocol_exception((uint32_t )2, "Received empty packet.");
    }
    {
#line 66
    (*((closure->e)->raise))(closure->e, (struct exception  const  *)tmp___0);
    }
    {
#line 67
    lsh_string_free((struct lsh_string  const  *)packet);
    }
    }
#line 68
    return;
  }
#line 71
  if (length > closure->rec_max_packet) {
    {
    {
#line 73
    werror("connection.c: Packet too large!\n");
    }
    {
#line 74
    tmp___1 = make_protocol_exception((uint32_t )2, "Packet too large");
    }
    {
#line 74
    (*((closure->e)->raise))(closure->e, (struct exception  const  *)tmp___1);
    }
    {
#line 75
    lsh_string_free((struct lsh_string  const  *)packet);
    }
    }
#line 76
    return;
  }
  {
  {
#line 79
  tmp___2 = lsh_string_data((struct lsh_string  const  *)packet);
  }
#line 79
  msg = (uint8_t )*(tmp___2 + 0);
  {
#line 81
  debug("handle_connection: Received packet of type %i (%z)\n", (int )msg, packet_types[msg]);
  }
  }
#line 86
  if ((unsigned int )closure->read_kex_state == 0U) {
#line 86
    goto case_0;
  }
#line 95
  if ((unsigned int )closure->read_kex_state == 1U) {
#line 95
    goto case_1;
  }
#line 106
  if ((unsigned int )closure->read_kex_state == 2U) {
#line 106
    goto case_2;
  }
#line 133
  if ((unsigned int )closure->read_kex_state == 3U) {
#line 133
    goto case_3;
  }
#line 150
  goto switch_default___1;
  case_0: 
#line 87
  if ((int )msg == 21) {
    {
    {
#line 89
    werror("Unexpected NEWKEYS message!\n");
    }
    {
#line 90
    tmp___3 = make_protocol_exception((uint32_t )2, "Unexpected NEWKEYS message!");
    }
    {
#line 90
    (*((closure->e)->raise))(closure->e, (struct exception  const  *)tmp___3);
    }
    {
#line 91
    lsh_string_free((struct lsh_string  const  *)packet);
    }
    }
#line 92
    return;
  }
#line 94
  goto switch_break;
  case_1: 
  {
  {
#line 96
  debug("handle_connection: Ignoring packet %i\n", (int )msg);
  }
#line 102
  closure->read_kex_state = (enum kex_state )2;
  {
#line 103
  lsh_string_free((struct lsh_string  const  *)packet);
  }
  }
#line 104
  return;
  case_2: 
#line 111
  if ((int )msg == 1) {
#line 111
    goto case_1___0;
  }
#line 111
  if ((int )msg == 4) {
#line 111
    goto case_1___0;
  }
#line 111
  if ((int )msg == 2) {
#line 111
    goto case_1___0;
  }
#line 120
  if ((int )msg == 20) {
#line 120
    goto _L;
  }
#line 120
  if ((int )msg == 21) {
#line 120
    goto _L;
  }
#line 114
  goto switch_default;
  case_1___0: 
#line 113
  goto switch_break___0;
  switch_default: 
#line 115
  if ((int )msg < 30) {
#line 115
    goto _L;
  } else
#line 115
  if ((int )msg >= 50) {
    _L: 
    {
    {
#line 122
    werror("Unexpected message of type %i (%z)!\n", (int )msg, packet_types[msg]);
    }
    {
#line 125
    tmp___4 = make_protocol_exception((uint32_t )2, "Unexpected message during key exchange");
    }
    {
#line 125
    (*((closure->e)->raise))(closure->e, (struct exception  const  *)tmp___4);
    }
    {
#line 127
    lsh_string_free((struct lsh_string  const  *)packet);
    }
    }
#line 128
    return;
  }
  switch_break___0: ;
#line 132
  goto switch_break;
  case_3: 
#line 139
  if ((int )msg == 4) {
#line 139
    goto case_4___0;
  }
#line 139
  if ((int )msg == 2) {
#line 139
    goto case_4___0;
  }
#line 139
  if ((int )msg == 1) {
#line 139
    goto case_4___0;
  }
#line 139
  if ((int )msg == 21) {
#line 139
    goto case_4___0;
  }
#line 142
  goto switch_default___0;
  case_4___0: 
#line 141
  goto switch_break___1;
  switch_default___0: 
  {
  {
#line 143
  werror("Expected NEWKEYS message, but received message %i (%z)!\n", (int )msg, packet_types[msg]);
  }
  {
#line 145
  tmp___5 = make_protocol_exception((uint32_t )2, "Expected NEWKEYS message");
  }
  {
#line 145
  (*((closure->e)->raise))(closure->e, (struct exception  const  *)tmp___5);
  }
  {
#line 146
  lsh_string_free((struct lsh_string  const  *)packet);
  }
  }
#line 147
  return;
  switch_break___1: ;
#line 149
  goto switch_break;
  switch_default___1: 
  {
  {
#line 151
  fatal("handle_connection: Internal error.\n");
  }
  }
  switch_break: 
  {
  {
#line 154
  (*((closure->dispatch[msg])->handler))(closure->dispatch[msg], closure, packet);
  }
  {
#line 155
  lsh_string_free((struct lsh_string  const  *)packet);
  }
  }
#line 156
  return;
}
}
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static void connection_handle_pending(struct ssh_connection *self ) 
{ 
  struct lsh_string *tmp ;
  int tmp___0 ;

  {
  {
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 161
    if (! self->paused) {
      {
      {
#line 161
      tmp___0 = lsh_queue_is_empty(& self->pending.q);
      }
      }
#line 161
      if (tmp___0) {
#line 161
        goto while_break;
      }
    } else {
#line 161
      goto while_break;
    }
    {
    {
#line 162
    tmp = string_queue_remove_head(& self->pending);
    }
    {
#line 162
    connection_handle_packet(self, tmp);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 163
  return;
}
}
#line 166 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static void do_handle_connection(struct abstract_write *w , struct lsh_string *packet ) 
{ 
  struct ssh_connection *self ;
  int tmp ;

  {
#line 170
  self = (struct ssh_connection *)w;
#line 172
  if (self->paused) {
    {
    {
#line 173
    string_queue_add_tail(& self->pending, packet);
    }
    }
  } else {
    {
    {
#line 175
    tmp = lsh_queue_is_empty(& self->pending.q);
    }
    }
#line 175
    if (tmp) {
      {
      {
#line 176
      connection_handle_packet(self, packet);
      }
      }
    } else {
      {
      {
#line 180
      string_queue_add_tail(& self->pending, packet);
      }
      {
#line 181
      connection_handle_pending(self);
      }
      }
    }
  }
#line 183
  return;
}
}
#line 185
static void do_connection_ignore_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                         struct ssh_connection *connection  __attribute__((__unused__)) ,
                                         struct lsh_string *packet  __attribute__((__unused__)) ) ;
#line 185 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
struct packet_handler connection_ignore_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_connection_ignore_handler};
#line 185 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static void do_connection_ignore_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                         struct ssh_connection *connection  __attribute__((__unused__)) ,
                                         struct lsh_string *packet  __attribute__((__unused__)) ) 
{ 


  {
#line 188
  return;
}
}
#line 190
static void do_connection_fail_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                       struct ssh_connection *connection , struct lsh_string *packet  __attribute__((__unused__)) ) ;
#line 190 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
struct packet_handler connection_fail_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_connection_fail_handler};
#line 190 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static void do_connection_fail_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                       struct ssh_connection *connection , struct lsh_string *packet  __attribute__((__unused__)) ) 
{ 
  struct exception *tmp ;

  {
  {
  {
#line 192
  tmp = make_protocol_exception((uint32_t )2, (char const   *)((void *)0));
  }
  {
#line 192
  (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp);
  }
  }
#line 193
  return;
}
}
#line 195
static void do_connection_unimplemented_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                                struct ssh_connection *connection ,
                                                struct lsh_string *packet ) ;
#line 195 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
struct packet_handler connection_unimplemented_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_connection_unimplemented_handler};
#line 195 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static void do_connection_unimplemented_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                                struct ssh_connection *connection ,
                                                struct lsh_string *packet ) 
{ 
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct lsh_string *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 197
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 197
  werror("Received packet of unimplemented type %i.\n", (int const   )*(tmp + 0));
  }
  {
#line 200
  tmp___0 = lsh_string_sequence_number((struct lsh_string  const  *)packet);
  }
  {
#line 200
  tmp___1 = ssh_format("%c%i", 3, tmp___0);
  }
  {
#line 200
  connection_send(connection, tmp___1);
  }
  }
#line 204
  return;
}
}
#line 206
static void do_connection_forward_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                          struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 206 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
struct packet_handler connection_forward_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_connection_forward_handler};
#line 206 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static void do_connection_forward_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                          struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 208
  if (! connection->chain) {
    {
    {
#line 208
    __assert_fail("connection->chain", "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c",
                  208U, "do_connection_forward_handler");
    }
    }
  }
  {
  {
#line 211
  connection_send(connection->chain, packet);
  }
  }
#line 212
  return;
}
}
#line 214
static void do_connection_disconnect_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                             struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 214 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
struct packet_handler connection_disconnect_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_connection_disconnect_handler};
#line 226 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static struct exception  const  disconnect_exception  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )65539, "Received disconnect message."};
#line 214 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static void do_connection_disconnect_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                             struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t reason ;
  uint32_t length ;
  uint8_t const   *msg ;
  uint8_t const   *language ;
  uint32_t language_length ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
  {
#line 229
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 229
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 229
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 231
  tmp___1 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 231
  if (tmp___1) {
#line 231
    if (msg_number == 1U) {
      {
      {
#line 231
      tmp___2 = parse_uint32(& buffer, & reason);
      }
      }
#line 231
      if (tmp___2) {
        {
        {
#line 231
        tmp___3 = parse_string(& buffer, & length, & msg);
        }
        }
#line 231
        if (tmp___3) {
          {
          {
#line 231
          tmp___4 = parse_string(& buffer, & language_length, & language);
          }
          }
#line 231
          if (tmp___4) {
            {
            {
#line 231
            tmp___5 = parse_eod(& buffer);
            }
            }
#line 231
            if (tmp___5) {
              {
              {
#line 239
              werror("Disconnect for reason %i: %ups\n", reason, length, msg);
              }
              }
            } else {
              {
              {
#line 242
              werror("Invalid disconnect message!\n");
              }
              }
            }
          } else {
            {
            {
#line 242
            werror("Invalid disconnect message!\n");
            }
            }
          }
        } else {
          {
          {
#line 242
          werror("Invalid disconnect message!\n");
          }
          }
        }
      } else {
        {
        {
#line 242
        werror("Invalid disconnect message!\n");
        }
        }
      }
    } else {
      {
      {
#line 242
      werror("Invalid disconnect message!\n");
      }
      }
    }
  } else {
    {
    {
#line 242
    werror("Invalid disconnect message!\n");
    }
    }
  }
  {
  {
#line 244
  (*((connection->e)->raise))(connection->e, & disconnect_exception);
  }
  }
#line 245
  return;
}
}
#line 256 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static struct lsh_string *format_disconnect(int code , char const   *msg , char const   *language ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 260
  tmp = ssh_format("%c%i%z%z", 1, code, msg, language);
  }
  }
#line 260
  return (tmp);
}
}
#line 266 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static void do_exc_connection_handler(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct exc_connection_handler *self ;
  struct protocol_exception *exc ;
  struct lsh_string *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 270
  self = (struct exc_connection_handler *)s;
#line 274
  if (e->type == 4096U) {
#line 274
    goto case_4096;
  }
#line 293
  goto switch_default;
  case_4096: 
  {
#line 276
  exc = (struct protocol_exception *)e;
  {
#line 278
  werror("Protocol error: %z\n", e->msg);
  }
  }
#line 280
  if (exc->reason) {
    {
    {
#line 281
    tmp = format_disconnect((int )exc->reason, exc->super.msg, "");
    }
    {
#line 281
    connection_send_kex(self->connection, tmp);
    }
    }
  }
  {
  {
#line 284
  (*((self->super.parent)->raise))(self->super.parent, & finish_read_exception);
  }
  }
#line 286
  goto switch_break;
  switch_default: 
  {
  {
#line 294
  (*((self->super.parent)->raise))(self->super.parent, e);
  }
  }
  switch_break: ;
#line 296
  return;
}
}
#line 298 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static struct exception_handler *make_exc_connection_handler(struct ssh_connection *connection ,
                                                             struct exception_handler *parent ,
                                                             char const   *context ) 
{ 
  struct exc_connection_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 303
  tmp = lsh_object_alloc(& exc_connection_handler_class);
  }
#line 303
  self = (struct exc_connection_handler *)tmp;
#line 305
  self->super.parent = parent;
#line 306
  self->super.raise = & do_exc_connection_handler;
#line 307
  self->super.context = context;
#line 309
  self->connection = connection;
  }
#line 311
  return (& self->super);
}
}
#line 328 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static void do_connection_flow_controlled(struct flow_controlled *s , uint32_t written  __attribute__((__unused__)) ) 
{ 
  struct connection_flow_controlled *self ;
  struct ssh_connection *connection ;
  uint32_t length ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 332
  self = (struct connection_flow_controlled *)s;
#line 333
  connection = self->connection;
#line 334
  length = ((connection->socket)->write_buffer)->length;
#line 336
  if (connection->hard_limit) {
#line 336
    if (length + 10000U < connection->soft_limit) {
      {
      {
#line 339
      trace("do_connection_flow_controlled: Resetting hard_limit\n");
      }
#line 340
      connection->hard_limit = (uint32_t )0;
      }
#line 341
      if (connection->wakeup) {
        {
        {
#line 342
        (*((connection->wakeup)->c))(connection->wakeup, (struct lsh_object *)connection);
        }
        }
      }
    }
  }
#line 344
  return;
}
}
#line 346 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static struct flow_controlled *make_connection_flow_controlled(struct ssh_connection *connection ) 
{ 
  struct connection_flow_controlled *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 349
  tmp = lsh_object_alloc(& connection_flow_controlled_class);
  }
#line 349
  self = (struct connection_flow_controlled *)tmp;
#line 350
  self->super.report = & do_connection_flow_controlled;
#line 351
  self->connection = connection;
  }
#line 352
  return (& self->super);
}
}
#line 355 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
struct ssh_connection *make_ssh_connection(enum connection_flag flags , struct address_info *peer ,
                                           struct address_info *local , char const   *debug_comment ,
                                           struct exception_handler *e ) 
{ 
  int i ;
  struct ssh_connection *connection ;
  struct lsh_object *tmp ;
  struct lsh_string *tmp___0 ;
  struct lsh_string *tmp___1 ;
  struct crypto_instance *tmp___2 ;
  struct mac_instance *tmp___3 ;
  struct compress_instance *tmp___4 ;
  struct kexinit *tmp___5 ;
  struct lsh_string *tmp___6 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 364
  tmp = lsh_object_alloc(& ssh_connection_class);
  }
#line 364
  connection = (struct ssh_connection *)tmp;
#line 366
  connection->flags = flags;
#line 367
  connection->peer = peer;
#line 368
  connection->local = local;
#line 370
  connection->debug_comment = debug_comment;
#line 371
  connection->super.write = & do_handle_connection;
  {
#line 375
  connection->e = make_exc_connection_handler(connection, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c:375");
  }
#line 377
  connection->keyexchange_done = (struct command_continuation *)((void *)0);
#line 378
  connection->wakeup = (struct command_continuation *)((void *)0);
#line 380
  tmp___1 = (struct lsh_string *)((void *)0);
#line 380
  connection->session_id = tmp___1;
#line 380
  tmp___0 = tmp___1;
#line 380
  connection->versions[0] = tmp___0;
#line 380
  connection->versions[1] = tmp___0;
#line 384
  connection->peer_flags = (enum peer_flag )0;
#line 386
  connection->timer = (struct resource *)((void *)0);
#line 387
  connection->user = (struct lsh_user *)((void *)0);
  {
#line 389
  connection->resources = make_resource_list();
  }
#line 391
  connection->rec_max_packet = (uint32_t )32768;
#line 394
  connection->kexinit = (struct make_kexinit *)((void *)0);
#line 396
  tmp___2 = (struct crypto_instance *)((void *)0);
#line 396
  connection->rec_crypto = tmp___2;
#line 396
  connection->send_crypto = tmp___2;
#line 397
  tmp___3 = (struct mac_instance *)((void *)0);
#line 397
  connection->rec_mac = tmp___3;
#line 397
  connection->send_mac = tmp___3;
#line 398
  tmp___4 = (struct compress_instance *)((void *)0);
#line 398
  connection->rec_compress = tmp___4;
#line 398
  connection->send_compress = tmp___4;
#line 400
  connection->paused = 0;
  {
#line 401
  lsh_queue_init(& connection->pending.q);
  }
#line 403
  connection->read_kex_state = (enum kex_state )0;
#line 405
  connection->key_expire = (struct resource *)((void *)0);
#line 406
  connection->sent_data = (uint32_t )0;
#line 408
  connection->send_kex_only = 0;
  {
#line 409
  lsh_queue_init(& connection->send_queue.q);
  }
#line 410
  connection->soft_limit = (uint32_t )100000;
#line 411
  connection->hard_limit = (uint32_t )0;
#line 413
  tmp___5 = (struct kexinit *)((void *)0);
#line 413
  connection->kexinits[1] = tmp___5;
#line 413
  connection->kexinits[0] = tmp___5;
#line 416
  tmp___6 = (struct lsh_string *)((void *)0);
#line 416
  connection->literal_kexinits[1] = tmp___6;
#line 416
  connection->literal_kexinits[0] = tmp___6;
#line 419
  i = 0;
  }
  {
  {
#line 419
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 419
    if (! (i < 256)) {
#line 419
      goto while_break;
    }
#line 420
    connection->dispatch[i] = & connection_unimplemented_handler;
#line 419
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 422
  connection->dispatch[0] = & connection_fail_handler;
#line 423
  connection->dispatch[1] = & connection_disconnect_handler;
#line 424
  connection->dispatch[2] = & connection_ignore_handler;
#line 427
  connection->dispatch[3] = & connection_fail_handler;
#line 429
  connection->dispatch[4] = & connection_debug_handler;
#line 433
  connection->dispatch[5] = & connection_fail_handler;
#line 434
  connection->dispatch[6] = & connection_fail_handler;
#line 435
  connection->dispatch[21] = & connection_fail_handler;
#line 436
  connection->dispatch[30] = & connection_fail_handler;
#line 437
  connection->dispatch[31] = & connection_fail_handler;
#line 438
  connection->dispatch[50] = & connection_fail_handler;
#line 439
  connection->dispatch[51] = & connection_fail_handler;
#line 440
  connection->dispatch[52] = & connection_fail_handler;
#line 441
  connection->dispatch[53] = & connection_fail_handler;
#line 442
  connection->dispatch[60] = & connection_fail_handler;
#line 443
  connection->dispatch[60] = & connection_fail_handler;
#line 444
  connection->dispatch[80] = & connection_fail_handler;
#line 445
  connection->dispatch[81] = & connection_fail_handler;
#line 446
  connection->dispatch[82] = & connection_fail_handler;
#line 447
  connection->dispatch[90] = & connection_fail_handler;
#line 448
  connection->dispatch[91] = & connection_fail_handler;
#line 449
  connection->dispatch[92] = & connection_fail_handler;
#line 450
  connection->dispatch[93] = & connection_fail_handler;
#line 451
  connection->dispatch[94] = & connection_fail_handler;
#line 452
  connection->dispatch[95] = & connection_fail_handler;
#line 453
  connection->dispatch[96] = & connection_fail_handler;
#line 454
  connection->dispatch[97] = & connection_fail_handler;
#line 455
  connection->dispatch[98] = & connection_fail_handler;
#line 456
  connection->dispatch[99] = & connection_fail_handler;
#line 457
  connection->dispatch[100] = & connection_fail_handler;
#line 459
  return (connection);
}
}
#line 462 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
void connection_init_io(struct ssh_connection *connection , struct lsh_fd *socket___0 ) 
{ 


  {
  {
#line 467
  connection->socket = socket___0;
  {
#line 468
  ((connection->socket)->write_buffer)->report = make_connection_flow_controlled(connection);
  }
  }
#line 469
  return;
}
}
#line 471 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
void connection_after_keyexchange(struct ssh_connection *self , struct command_continuation *c ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 475
  if (! (! self->keyexchange_done)) {
    {
    {
#line 475
    __assert_fail("!self->keyexchange_done", "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c",
                  475U, "connection_after_keyexchange");
    }
    }
  }
#line 476
  self->keyexchange_done = c;
#line 477
  return;
}
}
#line 479 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
void connection_wakeup(struct ssh_connection *self , struct command_continuation *c ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 483
  if (! (! self->wakeup)) {
    {
    {
#line 483
    __assert_fail("!self->wakeup", "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c",
                  483U, "connection_wakeup");
    }
    }
  }
#line 484
  self->wakeup = c;
#line 485
  return;
}
}
#line 495 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static void connection_die(struct lsh_callback *c ) 
{ 
  struct connection_close_handler *closure ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 498
  closure = (struct connection_close_handler *)c;
  {
#line 500
  verbose("Connection died.\n");
  }
  {
#line 502
  (*(((closure->connection)->resources)->super.kill))(& ((closure->connection)->resources)->super);
  }
  }
#line 503
  return;
}
}
#line 505 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
struct lsh_callback *make_connection_close_handler(struct ssh_connection *c ) 
{ 
  struct connection_close_handler *closure ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 508
  tmp = lsh_object_alloc(& connection_close_handler_class);
  }
#line 508
  closure = (struct connection_close_handler *)tmp;
#line 510
  closure->connection = c;
#line 511
  closure->super.f = & connection_die;
  }
#line 513
  return (& closure->super);
}
}
#line 530 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static struct protocol_exception disconnect  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, (uint32_t )4096, "Write buffer full, peer not responding."},
    (uint32_t )0};
#line 517 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
void connection_send_kex(struct ssh_connection *self , struct lsh_string *message ) 
{ 
  uint32_t length ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 523
  (*((self->write_packet)->write))(self->write_packet, message);
  }
#line 525
  length = ((self->socket)->write_buffer)->length;
  }
#line 526
  if (self->hard_limit) {
#line 528
    if (length > self->hard_limit) {
      {
      {
#line 532
      (*((self->e)->raise))(self->e, (struct exception  const  *)(& disconnect.super));
      }
      }
    }
  } else
#line 535
  if (length > self->soft_limit) {
    {
#line 537
    self->hard_limit = length + 10000U;
    {
#line 538
    trace("connection_send_kex: Setting hard limit to %i\n", self->hard_limit);
    }
    }
  }
#line 540
  return;
}
}
#line 543 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
void connection_send(struct ssh_connection *self , struct lsh_string *message ) 
{ 
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 549
  if (self->send_kex_only) {
    {
    {
#line 550
    string_queue_add_tail(& self->send_queue, message);
    }
    }
  } else {
    {
    {
#line 553
    tmp = lsh_queue_is_empty(& self->send_queue.q);
    }
    }
#line 553
    if (! tmp) {
      {
      {
#line 553
      __assert_fail("lsh_queue_is_empty(&(&self->send_queue)->q)", "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c",
                    553U, "connection_send");
      }
      }
    }
    {
    {
#line 554
    connection_send_kex(self, message);
    }
    }
  }
#line 556
  return;
}
}
#line 558 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
void connection_send_kex_start(struct ssh_connection *self ) 
{ 
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 561
  if (! (! self->send_kex_only)) {
    {
    {
#line 561
    __assert_fail("!self->send_kex_only", "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c",
                  561U, "connection_send_kex_start");
    }
    }
  }
  {
  {
#line 562
  tmp = lsh_queue_is_empty(& self->send_queue.q);
  }
  }
#line 562
  if (! tmp) {
    {
    {
#line 562
    __assert_fail("lsh_queue_is_empty(&(&self->send_queue)->q)", "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c",
                  562U, "connection_send_kex_start");
    }
    }
  }
#line 563
  self->send_kex_only = 1;
#line 564
  return;
}
}
#line 566 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
void connection_send_kex_end(struct ssh_connection *self ) 
{ 
  struct lsh_string *tmp ;
  int tmp___0 ;
  struct command_continuation *c ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 569
  if (! self->send_kex_only) {
    {
    {
#line 569
    __assert_fail("self->send_kex_only", "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c",
                  569U, "connection_send_kex_end");
    }
    }
  }
  {
  {
#line 571
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 571
    tmp___0 = lsh_queue_is_empty(& self->send_queue.q);
    }
    }
#line 571
    if (tmp___0) {
#line 571
      goto while_break;
    }
    {
    {
#line 572
    tmp = string_queue_remove_head(& self->send_queue);
    }
    {
#line 572
    connection_send_kex(self, tmp);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 574
  self->send_kex_only = 0;
#line 576
  if (self->keyexchange_done) {
    {
#line 578
    c = self->keyexchange_done;
#line 579
    self->keyexchange_done = (struct command_continuation *)((void *)0);
    {
#line 581
    (*(c->c))(c, (struct lsh_object *)self);
    }
    }
  }
#line 583
  if (self->wakeup) {
    {
    {
#line 584
    (*((self->wakeup)->c))(self->wakeup, (struct lsh_object *)self);
    }
    }
  }
#line 585
  return;
}
}
#line 589 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
void connection_lock(struct ssh_connection *self ) 
{ 
  struct exception pause___0 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 592
  pause___0.super.next = (struct lsh_object *)((void *)0);
#line 592
  pause___0.super.isa = (struct lsh_class *)((void *)0);
#line 592
  pause___0.super.alloc_method = (char)1;
#line 592
  pause___0.super.marked = (char)0;
#line 592
  pause___0.super.dead = (char)0;
#line 592
  pause___0.type = (uint32_t )1048577;
#line 592
  pause___0.msg = "locking connection.";
#line 595
  if (! (! self->paused)) {
    {
    {
#line 595
    __assert_fail("!self->paused", "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c",
                  595U, "connection_lock");
    }
    }
  }
  {
#line 596
  self->paused = 1;
  {
#line 597
  (*((self->e)->raise))(self->e, (struct exception  const  *)(& pause___0));
  }
  }
#line 598
  return;
}
}
#line 600 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
void connection_unlock(struct ssh_connection *self ) 
{ 
  struct exception unpause ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 603
  unpause.super.next = (struct lsh_object *)((void *)0);
#line 603
  unpause.super.isa = (struct lsh_class *)((void *)0);
#line 603
  unpause.super.alloc_method = (char)1;
#line 603
  unpause.super.marked = (char)0;
#line 603
  unpause.super.dead = (char)0;
#line 603
  unpause.type = (uint32_t )1048578;
#line 603
  unpause.msg = "unlocking connection.";
#line 615
  if (! self->paused) {
    {
    {
#line 615
    __assert_fail("self->paused", "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c",
                  615U, "connection_unlock");
    }
    }
  }
  {
  {
#line 616
  (*((self->e)->raise))(self->e, (struct exception  const  *)(& unpause));
  }
#line 618
  self->paused = 0;
  }
#line 619
  return;
}
}
#line 632 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
static void do_connection_timeout(struct lsh_callback *s ) 
{ 
  struct connection_timeout *self ;

  {
  {
#line 635
  self = (struct connection_timeout *)s;
  {
#line 636
  (*(((self->connection)->e)->raise))((self->connection)->e, self->e);
  }
  }
#line 637
  return;
}
}
#line 639 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
void connection_clear_timeout(struct ssh_connection *connection ) 
{ 


  {
#line 642
  if (connection->timer) {
    {
    {
#line 644
    (*((connection->timer)->kill))(connection->timer);
    }
#line 645
    connection->timer = (struct resource *)((void *)0);
    }
  }
#line 647
  return;
}
}
#line 649 "/home/ysko/Works/test-src/lsh-2.0.4/src/connection.c"
void connection_set_timeout(struct ssh_connection *connection , unsigned int seconds ,
                            char const   *msg ) 
{ 
  struct connection_timeout *timeout ;
  struct lsh_object *tmp ;
  struct exception *tmp___0 ;

  {
  {
  {
#line 654
  tmp = lsh_object_alloc(& connection_timeout_class);
  }
#line 654
  timeout = (struct connection_timeout *)tmp;
#line 655
  timeout->super.f = & do_connection_timeout;
#line 656
  timeout->connection = connection;
  {
#line 657
  tmp___0 = make_protocol_exception((uint32_t )0, msg);
  }
#line 657
  timeout->e = (struct exception  const  *)tmp___0;
  {
#line 659
  connection_clear_timeout(connection);
  }
  {
#line 661
  connection->timer = io_callout(& timeout->super, seconds);
  }
  {
#line 663
  remember_resource(connection->resources, connection->timer);
  }
  }
#line 664
  return;
}
}
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/compress.h.x"
struct lsh_class compress_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"compress_instance", (size_t )sizeof(struct compress_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/compress.h.x"
struct lsh_class compress_algorithm_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"compress_algorithm", (size_t )sizeof(struct compress_algorithm ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct lsh_class command_2_class ;
#line 82
struct lsh_class command_3_class ;
#line 106
struct lsh_class command_4_class ;
#line 164
struct lsh_class command_context_class ;
#line 196
struct lsh_class catch_report_collect_class ;
#line 100 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h"
struct command *make_command_2_invoke(struct command_2 *f , struct lsh_object *a1 ) ;
#line 132
void do_command_3(struct command *s , struct lsh_object *a1 , struct command_continuation *c ,
                  struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 219
struct command *make_parallell_progn(struct object_list *body ) ;
#line 220
struct command progn_command ;
#line 222
struct command_2 protect_command ;
#line 249
struct command_context *make_command_context(struct command_continuation *c , struct exception_handler *e ) ;
#line 253
struct catch_handler_info *make_catch_handler_info(uint32_t mask , uint32_t value ,
                                                   int ignore_value , struct command *handler ) ;
#line 258
struct command *make_catch_apply(struct catch_handler_info *info , struct command *body ) ;
#line 271
struct command *make_catch_report_apply(struct report_exception_info  const  *info ,
                                        struct command *body ) ;
#line 275
void do_catch_report_collect(struct command *s , struct lsh_object *a , struct command_continuation *c ,
                             struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct lsh_class command_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"command_continuation", (size_t )sizeof(struct command_continuation ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct lsh_class command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"command", (size_t )sizeof(struct command ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct lsh_class command_2_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"command_2", (size_t )sizeof(struct command_2 ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct lsh_class command_3_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"command_3", (size_t )sizeof(struct command_3 ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 110 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct lsh_class command_4_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"command_4", (size_t )sizeof(struct command_4 ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 135 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
static void do_command_frame_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct command_frame *i ;

  {
  {
#line 139
  i = (struct command_frame *)o;
  {
#line 140
  (*mark)((struct lsh_object *)i->up);
  }
  {
#line 141
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 142
  return;
}
}
#line 143 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct lsh_class command_frame_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"command_frame", (size_t )sizeof(struct command_frame ),
    & do_command_frame_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 168 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
static void do_command_context_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct command_context *i ;

  {
  {
#line 172
  i = (struct command_context *)o;
  {
#line 173
  (*mark)((struct lsh_object *)i->c);
  }
  {
#line 174
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 175
  return;
}
}
#line 176 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct lsh_class command_context_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"command_context", (size_t )sizeof(struct command_context ),
    & do_command_context_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 200 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
static void do_catch_report_collect_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct catch_report_collect *i ;

  {
  {
#line 204
  i = (struct catch_report_collect *)o;
  {
#line 205
  (*mark)((struct lsh_object *)i->info);
  }
  }
#line 206
  return;
}
}
#line 207 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h.x"
struct lsh_class catch_report_collect_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"catch_report_collect", (size_t )sizeof(struct catch_report_collect ),
    & do_catch_report_collect_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class command_apply_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_command_apply_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct command_apply *i ;

  {
  {
#line 18
  i = (struct command_apply *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->f);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class command_apply_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_frame_class, (char *)"command_apply", (size_t )sizeof(struct command_apply ),
    & do_command_apply_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 41
struct lsh_class gaba_continuation_class ;
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_gaba_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct gaba_continuation *i ;

  {
  {
#line 49
  i = (struct gaba_continuation *)o;
  {
#line 50
  (*mark)(i->value);
  }
  }
#line 51
  return;
}
}
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class gaba_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"gaba_continuation", (size_t )sizeof(struct gaba_continuation ),
    & do_gaba_continuation_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 73
struct lsh_class command_2_invoke_class ;
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_command_2_invoke_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct command_2_invoke *i ;

  {
  {
#line 81
  i = (struct command_2_invoke *)o;
  {
#line 82
  (*mark)((struct lsh_object *)i->f);
  }
  {
#line 83
  (*mark)(i->a1);
  }
  }
#line 84
  return;
}
}
#line 85 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class command_2_invoke_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"command_2_invoke", (size_t )sizeof(struct command_2_invoke ),
    & do_command_2_invoke_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 107
struct lsh_class command_3_invoke_2_class ;
#line 111 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_command_3_invoke_2_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct command_3_invoke_2 *i ;

  {
  {
#line 115
  i = (struct command_3_invoke_2 *)o;
  {
#line 116
  (*mark)((struct lsh_object *)i->f);
  }
  {
#line 117
  (*mark)(i->a1);
  }
  {
#line 118
  (*mark)(i->a2);
  }
  }
#line 119
  return;
}
}
#line 120 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class command_3_invoke_2_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"command_3_invoke_2", (size_t )sizeof(struct command_3_invoke_2 ),
    & do_command_3_invoke_2_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 141
struct lsh_class command_3_invoke_class ;
#line 145 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_command_3_invoke_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct command_3_invoke *i ;

  {
  {
#line 149
  i = (struct command_3_invoke *)o;
  {
#line 150
  (*mark)((struct lsh_object *)i->f);
  }
  {
#line 151
  (*mark)(i->a1);
  }
  }
#line 152
  return;
}
}
#line 153 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class command_3_invoke_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"command_3_invoke", (size_t )sizeof(struct command_3_invoke ),
    & do_command_3_invoke_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 176
struct lsh_class command_4_invoke_3_class ;
#line 180 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_command_4_invoke_3_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct command_4_invoke_3 *i ;

  {
  {
#line 184
  i = (struct command_4_invoke_3 *)o;
  {
#line 185
  (*mark)((struct lsh_object *)i->f);
  }
  {
#line 186
  (*mark)(i->a1);
  }
  {
#line 187
  (*mark)(i->a2);
  }
  {
#line 188
  (*mark)(i->a3);
  }
  }
#line 189
  return;
}
}
#line 190 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class command_4_invoke_3_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"command_4_invoke_3", (size_t )sizeof(struct command_4_invoke_3 ),
    & do_command_4_invoke_3_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 212
struct lsh_class command_4_invoke_2_class ;
#line 216 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_command_4_invoke_2_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct command_4_invoke_2 *i ;

  {
  {
#line 220
  i = (struct command_4_invoke_2 *)o;
  {
#line 221
  (*mark)((struct lsh_object *)i->f);
  }
  {
#line 222
  (*mark)(i->a1);
  }
  {
#line 223
  (*mark)(i->a2);
  }
  }
#line 224
  return;
}
}
#line 225 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class command_4_invoke_2_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"command_4_invoke_2", (size_t )sizeof(struct command_4_invoke_2 ),
    & do_command_4_invoke_2_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 246
struct lsh_class command_4_invoke_class ;
#line 250 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_command_4_invoke_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct command_4_invoke *i ;

  {
  {
#line 254
  i = (struct command_4_invoke *)o;
  {
#line 255
  (*mark)((struct lsh_object *)i->f);
  }
  {
#line 256
  (*mark)(i->a1);
  }
  }
#line 257
  return;
}
}
#line 258 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class command_4_invoke_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"command_4_invoke", (size_t )sizeof(struct command_4_invoke ),
    & do_command_4_invoke_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 279
struct lsh_class trace_continuation_class ;
#line 283 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_trace_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct trace_continuation *i ;

  {
  {
#line 287
  i = (struct trace_continuation *)o;
  {
#line 288
  (*mark)((struct lsh_object *)i->real);
  }
  }
#line 289
  return;
}
}
#line 290 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class trace_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"trace_continuation", (size_t )sizeof(struct trace_continuation ),
    & do_trace_continuation_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 311
struct lsh_class trace_command_class ;
#line 315 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_trace_command_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct trace_command *i ;

  {
  {
#line 319
  i = (struct trace_command *)o;
  {
#line 320
  (*mark)((struct lsh_object *)i->real);
  }
  }
#line 321
  return;
}
}
#line 322 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class trace_command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"trace_command", (size_t )sizeof(struct trace_command ),
    & do_trace_command_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 342
struct lsh_class parallell_progn_class ;
#line 346 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_parallell_progn_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct parallell_progn *i ;

  {
  {
#line 350
  i = (struct parallell_progn *)o;
  {
#line 351
  (*mark)((struct lsh_object *)i->body);
  }
  }
#line 352
  return;
}
}
#line 353 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class parallell_progn_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"parallell_progn", (size_t )sizeof(struct parallell_progn ),
    & do_parallell_progn_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 376
struct lsh_class catch_handler_info_class ;
#line 380 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_catch_handler_info_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct catch_handler_info *i ;

  {
  {
#line 384
  i = (struct catch_handler_info *)o;
  {
#line 385
  (*mark)((struct lsh_object *)i->handler);
  }
  }
#line 386
  return;
}
}
#line 387 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class catch_handler_info_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"catch_handler_info", (size_t )sizeof(struct catch_handler_info ),
    & do_catch_handler_info_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 408
struct lsh_class catch_handler_class ;
#line 412 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_catch_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct catch_handler *i ;

  {
  {
#line 416
  i = (struct catch_handler *)o;
  {
#line 417
  (*mark)((struct lsh_object *)i->c);
  }
  {
#line 418
  (*mark)((struct lsh_object *)i->info);
  }
  }
#line 419
  return;
}
}
#line 420 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class catch_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"catch_handler", (size_t )sizeof(struct catch_handler ),
    & do_catch_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 441
struct lsh_class catch_apply_class ;
#line 445 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_catch_apply_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct catch_apply *i ;

  {
  {
#line 449
  i = (struct catch_apply *)o;
  {
#line 450
  (*mark)((struct lsh_object *)i->info);
  }
  {
#line 451
  (*mark)((struct lsh_object *)i->body);
  }
  }
#line 452
  return;
}
}
#line 453 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class catch_apply_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"catch_apply", (size_t )sizeof(struct catch_apply ),
    & do_catch_apply_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 474
struct lsh_class catch_report_apply_class ;
#line 478 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_catch_report_apply_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct catch_report_apply *i ;

  {
  {
#line 482
  i = (struct catch_report_apply *)o;
  {
#line 483
  (*mark)((struct lsh_object *)i->info);
  }
  {
#line 484
  (*mark)((struct lsh_object *)i->body);
  }
  }
#line 485
  return;
}
}
#line 486 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class catch_report_apply_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"catch_report_apply", (size_t )sizeof(struct catch_report_apply ),
    & do_catch_report_apply_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 506
struct lsh_class protect_handler_class ;
#line 510 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
static void do_protect_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct protect_handler *i ;

  {
  {
#line 514
  i = (struct protect_handler *)o;
  {
#line 515
  (*mark)((struct lsh_object *)i->resource);
  }
  }
#line 516
  return;
}
}
#line 517 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c.x"
struct lsh_class protect_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"protect_handler", (size_t )sizeof(struct protect_handler ),
    & do_protect_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_discard_continuation(struct command_continuation *ignored  __attribute__((__unused__)) ,
                                    struct lsh_object *x  __attribute__((__unused__)) ) 
{ 


  {
#line 46
  return;
}
}
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command_continuation discard_continuation  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_discard_continuation};
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command_context *make_command_context(struct command_continuation *c , struct exception_handler *e ) 
{ 
  struct command_context *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 55
  tmp = lsh_object_alloc(& command_context_class);
  }
#line 55
  self = (struct command_context *)tmp;
#line 56
  self->c = c;
#line 57
  self->e = e;
  }
#line 59
  return (self);
}
}
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_command_apply(struct command_continuation *s , struct lsh_object *value ) 
{ 
  struct command_apply *self ;

  {
  {
#line 74
  self = (struct command_apply *)s;
  {
#line 75
  (*((self->f)->call))(self->f, value, self->super.up, self->super.e);
  }
  }
#line 77
  return;
}
}
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command_continuation *make_apply(struct command *f , struct command_continuation *c ,
                                        struct exception_handler *e ) 
{ 
  struct command_apply *res ;
  struct lsh_object *tmp ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
  {
#line 83
  tmp = lsh_object_alloc(& command_apply_class);
  }
#line 83
  res = (struct command_apply *)tmp;
  }
#line 84
  if (! f) {
    {
    {
#line 84
    __assert_fail("f", "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c", 84U, "make_apply");
    }
    }
  }
#line 85
  if (! c) {
    {
    {
#line 85
    __assert_fail("c", "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c", 85U, "make_apply");
    }
    }
  }
#line 86
  if (! e) {
    {
    {
#line 86
    __assert_fail("e", "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c", 86U, "make_apply");
    }
    }
  }
#line 88
  res->f = f;
#line 89
  res->super.up = c;
#line 90
  res->super.e = e;
#line 91
  res->super.super.c = & do_command_apply;
#line 93
  return (& res->super.super);
}
}
#line 104 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_gaba_continuation(struct command_continuation *c , struct lsh_object *x ) 
{ 
  struct gaba_continuation *self ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 108
  self = (struct gaba_continuation *)c;
#line 110
  if (! (! self->value)) {
    {
    {
#line 110
    __assert_fail("!self->value", "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c",
                  110U, "do_gaba_continuation");
    }
    }
  }
#line 111
  self->value = x;
#line 112
  return;
}
}
#line 114 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct lsh_object *gaba_apply(struct lsh_object *f , struct lsh_object *x ) 
{ 
  struct command *cf ;
  struct gaba_continuation c ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 118
  cf = (struct command *)f;
#line 119
  c.super.super.next = (struct lsh_object *)((void *)0);
#line 119
  c.super.super.isa = (struct lsh_class *)((void *)0);
#line 119
  c.super.super.alloc_method = (char)1;
#line 119
  c.super.super.marked = (char)0;
#line 119
  c.super.super.dead = (char)0;
#line 119
  c.super.c = & do_gaba_continuation;
#line 119
  c.value = (struct lsh_object *)((void *)0);
  {
#line 122
  (*(cf->call))(cf, x, & c.super, & default_exception_handler);
  }
  }
#line 124
  if (! c.value) {
    {
    {
#line 124
    __assert_fail("c.value", "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c",
                  124U, "gaba_apply");
    }
    }
  }
#line 126
  return (c.value);
}
}
#line 139 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_command_2_invoke(struct command *s , struct lsh_object *a2 , struct command_continuation *c ,
                                struct exception_handler *e ) 
{ 
  struct command_2_invoke *self ;

  {
  {
#line 144
  self = (struct command_2_invoke *)s;
  {
#line 145
  (*((self->f)->invoke))(self->f, self->a1, a2, c, e);
  }
  }
#line 146
  return;
}
}
#line 148 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command *make_command_2_invoke(struct command_2 *f , struct lsh_object *a1 ) 
{ 
  struct command_2_invoke *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 152
  tmp = lsh_object_alloc(& command_2_invoke_class);
  }
#line 152
  self = (struct command_2_invoke *)tmp;
#line 154
  self->super.call = & do_command_2_invoke;
#line 155
  self->f = f;
#line 156
  self->a1 = a1;
  }
#line 158
  return (& self->super);
}
}
#line 161 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
void do_command_2(struct command *s , struct lsh_object *a1 , struct command_continuation *c ,
                  struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct command_2 *self ;
  struct command *tmp ;

  {
  {
#line 167
  self = (struct command_2 *)s;
  {
#line 168
  tmp = make_command_2_invoke(self, a1);
  }
  {
#line 168
  (*(c->c))(c, (struct lsh_object *)tmp);
  }
  }
#line 169
  return;
}
}
#line 182 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_command_3_invoke_2(struct command *s , struct lsh_object *a3 , struct command_continuation *c ,
                                  struct exception_handler *e ) 
{ 
  struct command_3_invoke_2 *self ;

  {
  {
#line 188
  self = (struct command_3_invoke_2 *)s;
  {
#line 189
  (*((self->f)->invoke))(self->a1, self->a2, a3, c, e);
  }
  }
#line 190
  return;
}
}
#line 192 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command *make_command_3_invoke_2(struct command_3 *f , struct lsh_object *a1 ,
                                        struct lsh_object *a2 ) 
{ 
  struct command_3_invoke_2 *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 197
  tmp = lsh_object_alloc(& command_3_invoke_2_class);
  }
#line 197
  self = (struct command_3_invoke_2 *)tmp;
#line 199
  self->super.call = & do_command_3_invoke_2;
#line 200
  self->f = f;
#line 201
  self->a1 = a1;
#line 202
  self->a2 = a2;
  }
#line 204
  return (& self->super);
}
}
#line 216 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_command_3_invoke(struct command *s , struct lsh_object *a2 , struct command_continuation *c ,
                                struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct command_3_invoke *self ;
  struct command *tmp ;

  {
  {
#line 222
  self = (struct command_3_invoke *)s;
  {
#line 223
  tmp = make_command_3_invoke_2(self->f, self->a1, a2);
  }
  {
#line 223
  (*(c->c))(c, (struct lsh_object *)tmp);
  }
  }
#line 224
  return;
}
}
#line 226 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command *make_command_3_invoke(struct command_3 *f , struct lsh_object *a1 ) 
{ 
  struct command_3_invoke *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 230
  tmp = lsh_object_alloc(& command_3_invoke_class);
  }
#line 230
  self = (struct command_3_invoke *)tmp;
#line 232
  self->super.call = & do_command_3_invoke;
#line 233
  self->f = f;
#line 234
  self->a1 = a1;
  }
#line 236
  return (& self->super);
}
}
#line 239 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
void do_command_3(struct command *s , struct lsh_object *a1 , struct command_continuation *c ,
                  struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct command_3 *self ;
  struct command *tmp ;

  {
  {
#line 245
  self = (struct command_3 *)s;
  {
#line 246
  tmp = make_command_3_invoke(self, a1);
  }
  {
#line 246
  (*(c->c))(c, (struct lsh_object *)tmp);
  }
  }
#line 247
  return;
}
}
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_command_4_invoke_3(struct command *s , struct lsh_object *a4 , struct command_continuation *c ,
                                  struct exception_handler *e ) 
{ 
  struct command_4_invoke_3 *self ;

  {
  {
#line 268
  self = (struct command_4_invoke_3 *)s;
  {
#line 269
  (*((self->f)->invoke))(self->a1, self->a2, self->a3, a4, c, e);
  }
  }
#line 270
  return;
}
}
#line 272 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command *make_command_4_invoke_3(struct command_4 *f , struct lsh_object *a1 ,
                                        struct lsh_object *a2 , struct lsh_object *a3 ) 
{ 
  struct command_4_invoke_3 *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 278
  tmp = lsh_object_alloc(& command_4_invoke_3_class);
  }
#line 278
  self = (struct command_4_invoke_3 *)tmp;
#line 280
  self->super.call = & do_command_4_invoke_3;
#line 281
  self->f = f;
#line 282
  self->a1 = a1;
#line 283
  self->a2 = a2;
#line 284
  self->a3 = a3;
  }
#line 286
  return (& self->super);
}
}
#line 299 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_command_4_invoke_2(struct command *s , struct lsh_object *a3 , struct command_continuation *c ,
                                  struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct command_4_invoke_2 *self ;
  struct command *tmp ;

  {
  {
#line 305
  self = (struct command_4_invoke_2 *)s;
  {
#line 306
  tmp = make_command_4_invoke_3(self->f, self->a1, self->a2, a3);
  }
  {
#line 306
  (*(c->c))(c, (struct lsh_object *)tmp);
  }
  }
#line 307
  return;
}
}
#line 309 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command *make_command_4_invoke_2(struct command_4 *f , struct lsh_object *a1 ,
                                        struct lsh_object *a2 ) 
{ 
  struct command_4_invoke_2 *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 314
  tmp = lsh_object_alloc(& command_4_invoke_2_class);
  }
#line 314
  self = (struct command_4_invoke_2 *)tmp;
#line 316
  self->super.call = & do_command_4_invoke_2;
#line 317
  self->f = f;
#line 318
  self->a1 = a1;
#line 319
  self->a2 = a2;
  }
#line 321
  return (& self->super);
}
}
#line 334 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_command_4_invoke(struct command *s , struct lsh_object *a2 , struct command_continuation *c ,
                                struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct command_4_invoke *self ;
  struct command *tmp ;

  {
  {
#line 340
  self = (struct command_4_invoke *)s;
  {
#line 341
  tmp = make_command_4_invoke_2(self->f, self->a1, a2);
  }
  {
#line 341
  (*(c->c))(c, (struct lsh_object *)tmp);
  }
  }
#line 342
  return;
}
}
#line 344 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command *make_command_4_invoke(struct command_4 *f , struct lsh_object *a1 ) 
{ 
  struct command_4_invoke *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 348
  tmp = lsh_object_alloc(& command_4_invoke_class);
  }
#line 348
  self = (struct command_4_invoke *)tmp;
#line 350
  self->super.call = & do_command_4_invoke;
#line 351
  self->f = f;
#line 352
  self->a1 = a1;
  }
#line 354
  return (& self->super);
}
}
#line 357 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
void do_command_4(struct command *s , struct lsh_object *a1 , struct command_continuation *c ,
                  struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct command_4 *self ;
  struct command *tmp ;

  {
  {
#line 363
  self = (struct command_4 *)s;
  {
#line 364
  tmp = make_command_4_invoke(self, a1);
  }
  {
#line 364
  (*(c->c))(c, (struct lsh_object *)tmp);
  }
  }
#line 365
  return;
}
}
#line 456 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_parallell_progn(struct command *s , struct lsh_object *x , struct command_continuation *c ,
                               struct exception_handler *e ) 
{ 
  struct parallell_progn *self ;
  unsigned int i ;
  struct command *command ;
  struct command *command___0 ;

  {
#line 462
  self = (struct parallell_progn *)s;
#line 465
  i = 0U;
  {
  {
#line 465
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 465
    if (! (i < (self->body)->super.length - 1U)) {
#line 465
      goto while_break;
    }
    {
#line 467
    command = (struct command *)(self->body)->elements[i];
    {
#line 468
    (*(command->call))(command, x, & discard_continuation, e);
    }
#line 465
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 471
  command___0 = (struct command *)(self->body)->elements[i];
  {
#line 473
  (*(command___0->call))(command___0, x, c, e);
  }
  }
#line 475
  return;
}
}
#line 477 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command *make_parallell_progn(struct object_list *body ) 
{ 
  struct parallell_progn *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 479
  if (! body->super.length) {
    {
    {
#line 479
    __assert_fail("((body)->super.length)", "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c",
                  479U, "make_parallell_progn");
    }
    }
  }
  {
  {
#line 481
  tmp = lsh_object_alloc(& parallell_progn_class);
  }
#line 481
  self = (struct parallell_progn *)tmp;
#line 482
  self->body = body;
#line 483
  self->super.call = & do_parallell_progn;
  }
#line 485
  return (& self->super);
}
}
#line 489
static void do_progn_command(struct command *s  __attribute__((__unused__)) , struct lsh_object *a ,
                             struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 489 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command progn_command  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_progn_command};
#line 489 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_progn_command(struct command *s  __attribute__((__unused__)) , struct lsh_object *a ,
                             struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct object_list *body ;
  struct command *tmp ;
  struct command *tmp___0 ;

  {
#line 495
  body = (struct object_list *)a;
#line 497
  if (body->super.length) {
    {
    {
#line 497
    tmp = make_parallell_progn(body);
    }
#line 497
    tmp___0 = tmp;
    }
  } else {
#line 497
    tmp___0 = & command_I;
  }
  {
  {
#line 497
  (*(c->c))(c, (struct lsh_object *)tmp___0);
  }
  }
#line 500
  return;
}
}
#line 524 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct catch_handler_info *make_catch_handler_info(uint32_t mask , uint32_t value ,
                                                   int ignore_value , struct command *handler ) 
{ 
  struct catch_handler_info *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 529
  tmp = lsh_object_alloc(& catch_handler_info_class);
  }
#line 529
  self = (struct catch_handler_info *)tmp;
#line 530
  self->mask = mask;
#line 531
  self->value = value;
#line 532
  self->ignore_value = ignore_value;
#line 533
  self->handler = handler;
  }
#line 535
  return (self);
}
}
#line 547 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_catch_handler(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct catch_handler *self ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 551
  self = (struct catch_handler *)s;
#line 553
  if ((e->type & (unsigned int const   )(self->info)->mask) == (unsigned int const   )(self->info)->value) {
#line 555
    if ((self->info)->handler) {
      {
      {
#line 556
      (*(((self->info)->handler)->call))((self->info)->handler, (struct lsh_object *)e,
                                         self->c, self->super.parent);
      }
      }
    } else {
      {
      {
#line 559
      trace("do_catch_handler: Ignoring exception: %z.\n", e->msg);
      }
      }
    }
  } else {
    {
    {
#line 563
    (*((self->super.parent)->raise))(self->super.parent, e);
    }
    }
  }
#line 564
  return;
}
}
#line 566 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static struct exception_handler *make_catch_handler(struct catch_handler_info *info ,
                                                    struct command_continuation *c ,
                                                    struct exception_handler *e ,
                                                    char const   *context ) 
{ 
  struct catch_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 572
  tmp = lsh_object_alloc(& catch_handler_class);
  }
#line 572
  self = (struct catch_handler *)tmp;
#line 574
  self->super.raise = & do_catch_handler;
#line 575
  self->super.parent = e;
#line 576
  self->super.context = context;
#line 578
  self->c = c;
#line 579
  self->info = info;
  }
#line 581
  return (& self->super);
}
}
#line 593 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_catch_apply(struct command *s , struct lsh_object *a , struct command_continuation *c ,
                           struct exception_handler *e ) 
{ 
  struct catch_apply *self ;
  struct exception_handler *tmp ;
  struct command_continuation *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 599
  self = (struct catch_apply *)s;
  {
#line 601
  tmp = make_catch_handler(self->info, c, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c:605");
  }
  }
#line 601
  if ((self->info)->ignore_value) {
#line 601
    tmp___0 = & discard_continuation;
  } else {
#line 601
    tmp___0 = c;
  }
  {
  {
#line 601
  (*((self->body)->call))(self->body, a, tmp___0, tmp);
  }
  }
#line 606
  return;
}
}
#line 608 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command *make_catch_apply(struct catch_handler_info *info , struct command *body ) 
{ 
  struct catch_apply *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 612
  tmp = lsh_object_alloc(& catch_apply_class);
  }
#line 612
  self = (struct catch_apply *)tmp;
#line 613
  self->super.call = & do_catch_apply;
#line 614
  self->info = info;
#line 615
  self->body = body;
  }
#line 617
  return (& self->super);
}
}
#line 634 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_catch_report_apply(struct command *s , struct lsh_object *a , struct command_continuation *c ,
                                  struct exception_handler *e ) 
{ 
  struct catch_report_apply *self ;
  struct exception_handler *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 640
  self = (struct catch_report_apply *)s;
  {
#line 642
  tmp = make_report_exception_handler(self->info, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c:644");
  }
  {
#line 642
  (*((self->body)->call))(self->body, a, c, tmp);
  }
  }
#line 645
  return;
}
}
#line 647 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command *make_catch_report_apply(struct report_exception_info  const  *info ,
                                        struct command *body ) 
{ 
  struct catch_report_apply *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 651
  tmp = lsh_object_alloc(& catch_report_apply_class);
  }
#line 651
  self = (struct catch_report_apply *)tmp;
#line 652
  self->super.call = & do_catch_report_apply;
#line 653
  self->info = info;
#line 654
  self->body = body;
  }
#line 656
  return (& self->super);
}
}
#line 659 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
void do_catch_report_collect(struct command *s , struct lsh_object *a , struct command_continuation *c ,
                             struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct catch_report_collect *self ;
  struct command *body ;
  struct command *tmp ;

  {
  {
#line 665
  self = (struct catch_report_collect *)s;
#line 666
  body = (struct command *)a;
  {
#line 668
  tmp = make_catch_report_apply(self->info, body);
  }
  {
#line 668
  (*(c->c))(c, (struct lsh_object *)tmp);
  }
  }
#line 670
  return;
}
}
#line 687 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_exc_protect_handler(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct protect_handler *self ;

  {
  {
#line 691
  self = (struct protect_handler *)s;
  {
#line 693
  (*((self->resource)->kill))(self->resource);
  }
  {
#line 695
  (*((self->super.parent)->raise))(self->super.parent, e);
  }
  }
#line 696
  return;
}
}
#line 698 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static struct exception_handler *make_protect_exception_handler(struct resource *resource ,
                                                                struct exception_handler *e ,
                                                                char const   *context ) 
{ 
  struct protect_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 703
  tmp = lsh_object_alloc(& protect_handler_class);
  }
#line 703
  self = (struct protect_handler *)tmp;
#line 704
  self->super.raise = & do_exc_protect_handler;
#line 705
  self->super.parent = e;
#line 706
  self->super.context = context;
#line 708
  self->resource = resource;
  }
#line 710
  return (& self->super);
}
}
#line 713
static void do_protect_command(struct command_2 *s  __attribute__((__unused__)) ,
                               struct lsh_object *a1 , struct lsh_object *a2 , struct command_continuation *c ,
                               struct exception_handler *e ) ;
#line 713 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
struct command_2 protect_command  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_2}, & do_protect_command};
#line 713 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c"
static void do_protect_command(struct command_2 *s  __attribute__((__unused__)) ,
                               struct lsh_object *a1 , struct lsh_object *a2 , struct command_continuation *c ,
                               struct exception_handler *e ) 
{ 
  struct resource *resource ;
  struct command *f ;
  struct exception_handler *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 720
  resource = (struct resource *)a1;
#line 721
  f = (struct command *)a2;
  {
#line 723
  tmp = make_protect_exception_handler(resource, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/command.c:724");
  }
  {
#line 723
  (*(f->call))(f, a1, c, tmp);
  }
  }
#line 725
  return;
}
}
#line 329 "/home/ysko/Works/test-src/lsh-2.0.4/src/command.h"
struct command_4 command_Sp ;
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c.x"
struct lsh_class command_S_continuation_class ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c.x"
static void do_command_S_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct command_S_continuation *i ;

  {
  {
#line 19
  i = (struct command_S_continuation *)o;
  {
#line 20
  (*mark)((struct lsh_object *)i->g);
  }
  {
#line 21
  (*mark)(i->x);
  }
  }
#line 22
  return;
}
}
#line 23 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c.x"
struct lsh_class command_S_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_frame_class, (char *)"command_S_continuation", (size_t )sizeof(struct command_S_continuation ),
    & do_command_S_continuation_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 43
struct lsh_class command_C_continuation_class ;
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c.x"
static void do_command_C_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct command_C_continuation *i ;

  {
  {
#line 51
  i = (struct command_C_continuation *)o;
  {
#line 52
  (*mark)(i->y);
  }
  }
#line 53
  return;
}
}
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c.x"
struct lsh_class command_C_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_frame_class, (char *)"command_C_continuation", (size_t )sizeof(struct command_C_continuation ),
    & do_command_C_continuation_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
static void do_command_I(struct command *s  __attribute__((__unused__)) , struct lsh_object *a ,
                         struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
struct command command_I  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_command_I};
#line 41 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
static void do_command_I(struct command *s  __attribute__((__unused__)) , struct lsh_object *a ,
                         struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) 
{ 


  {
  {
  {
#line 47
  (*(c->c))(c, a);
  }
  }
#line 48
  return;
}
}
#line 52
static void do_command_K(struct command_2 *s  __attribute__((__unused__)) , struct lsh_object *x ,
                         struct lsh_object *y  __attribute__((__unused__)) , struct command_continuation *c ,
                         struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
struct command_2 command_K  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_2}, & do_command_K};
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
static void do_command_K(struct command_2 *s  __attribute__((__unused__)) , struct lsh_object *x ,
                         struct lsh_object *y  __attribute__((__unused__)) , struct command_continuation *c ,
                         struct exception_handler *e  __attribute__((__unused__)) ) 
{ 


  {
  {
  {
#line 59
  (*(c->c))(c, x);
  }
  }
#line 60
  return;
}
}
#line 75 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
static void do_command_S_continuation(struct command_continuation *c , struct lsh_object *value ) 
{ 
  struct command_S_continuation *self ;
  struct command *op ;
  struct command_continuation *tmp ;

  {
  {
#line 79
  self = (struct command_S_continuation *)c;
#line 80
  op = (struct command *)value;
  {
#line 81
  tmp = make_apply(op, self->super.up, self->super.e);
  }
  {
#line 81
  (*((self->g)->call))(self->g, self->x, tmp, self->super.e);
  }
  }
#line 84
  return;
}
}
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
static struct command_continuation *make_command_S_continuation(struct command *g ,
                                                                struct lsh_object *x ,
                                                                struct command_continuation *up ,
                                                                struct exception_handler *e ) 
{ 
  struct command_S_continuation *c ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 92
  tmp = lsh_object_alloc(& command_S_continuation_class);
  }
#line 92
  c = (struct command_S_continuation *)tmp;
#line 93
  c->g = g;
#line 94
  c->x = x;
#line 95
  c->super.up = up;
#line 96
  c->super.e = e;
#line 97
  c->super.super.c = & do_command_S_continuation;
  }
#line 99
  return (& c->super.super);
}
}
#line 102
static void do_command_S(struct lsh_object *f , struct lsh_object *g , struct lsh_object *x ,
                         struct command_continuation *c , struct exception_handler *e ) ;
#line 102 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
struct command_3 command_S  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_3}, & do_command_S};
#line 102 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
static void do_command_S(struct lsh_object *f , struct lsh_object *g , struct lsh_object *x ,
                         struct command_continuation *c , struct exception_handler *e ) 
{ 
  struct command *cf ;
  struct command *cg ;
  struct command_continuation *tmp ;

  {
  {
#line 109
  cf = (struct command *)f;
#line 110
  cg = (struct command *)g;
  {
#line 112
  tmp = make_command_S_continuation(cg, x, c, e);
  }
  {
#line 112
  (*(cf->call))(cf, x, tmp, e);
  }
  }
#line 115
  return;
}
}
#line 119
static void do_command_Sp(struct lsh_object *k , struct lsh_object *f , struct lsh_object *g ,
                          struct lsh_object *x , struct command_continuation *c ,
                          struct exception_handler *e ) ;
#line 119 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
struct command_4 command_Sp  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_4}, & do_command_Sp};
#line 119 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
static void do_command_Sp(struct lsh_object *k , struct lsh_object *f , struct lsh_object *g ,
                          struct lsh_object *x , struct command_continuation *c ,
                          struct exception_handler *e ) 
{ 
  struct command *ck ;
  struct command *cf ;
  struct command *cg ;
  struct command_continuation *tmp ;
  struct command_continuation *tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 127
  ck = (struct command *)k;
#line 128
  cf = (struct command *)f;
#line 129
  cg = (struct command *)g;
  {
#line 131
  trace("command_Sp\n");
  }
  {
#line 133
  tmp = make_command_S_continuation(cg, x, c, e);
  }
  {
#line 133
  tmp___0 = make_apply(ck, tmp, e);
  }
  {
#line 133
  (*(cf->call))(cf, x, tmp___0, e);
  }
  }
#line 139
  return;
}
}
#line 143
static void do_command_B(struct lsh_object *f , struct lsh_object *g , struct lsh_object *x ,
                         struct command_continuation *c , struct exception_handler *e ) ;
#line 143 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
struct command_3 command_B  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_3}, & do_command_B};
#line 143 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
static void do_command_B(struct lsh_object *f , struct lsh_object *g , struct lsh_object *x ,
                         struct command_continuation *c , struct exception_handler *e ) 
{ 
  struct command *cf ;
  struct command *cg ;
  struct command_continuation *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 150
  cf = (struct command *)f;
#line 151
  cg = (struct command *)g;
  {
#line 153
  trace("command_B, f = %xi, cf = %xi, g = %xi, cg = %xi\n", f, cf, g, cg);
  }
  {
#line 156
  tmp = make_apply(cf, c, e);
  }
  {
#line 156
  (*(cg->call))(cg, x, tmp, e);
  }
  }
#line 158
  return;
}
}
#line 162
static void do_command_Bp(struct lsh_object *k , struct lsh_object *f , struct lsh_object *g ,
                          struct lsh_object *x , struct command_continuation *c ,
                          struct exception_handler *e ) ;
#line 162 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
struct command_4 command_Bp  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_4}, & do_command_Bp};
#line 162 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
static void do_command_Bp(struct lsh_object *k , struct lsh_object *f , struct lsh_object *g ,
                          struct lsh_object *x , struct command_continuation *c ,
                          struct exception_handler *e ) 
{ 
  struct command *ck ;
  struct command *cf ;
  struct command *cg ;
  struct command_continuation *tmp ;
  struct command_continuation *tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 170
  ck = (struct command *)k;
#line 171
  cf = (struct command *)f;
#line 172
  cg = (struct command *)g;
  {
#line 174
  trace("command_Bp\n");
  }
  {
#line 176
  tmp = make_apply(ck, c, e);
  }
  {
#line 176
  tmp___0 = make_apply(cf, tmp, e);
  }
  {
#line 176
  (*(cg->call))(cg, x, tmp___0, e);
  }
  }
#line 180
  return;
}
}
#line 193 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
static void do_command_C_continuation(struct command_continuation *c , struct lsh_object *value ) 
{ 
  struct command_C_continuation *self ;
  struct command *op ;

  {
  {
#line 197
  self = (struct command_C_continuation *)c;
#line 198
  op = (struct command *)value;
  {
#line 200
  (*(op->call))(op, self->y, self->super.up, self->super.e);
  }
  }
#line 201
  return;
}
}
#line 203 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
static struct command_continuation *make_command_C_continuation(struct lsh_object *y ,
                                                                struct command_continuation *up ,
                                                                struct exception_handler *e ) 
{ 
  struct command_C_continuation *c ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 208
  tmp = lsh_object_alloc(& command_C_continuation_class);
  }
#line 208
  c = (struct command_C_continuation *)tmp;
#line 209
  c->y = y;
#line 210
  c->super.up = up;
#line 211
  c->super.e = e;
#line 212
  c->super.super.c = & do_command_C_continuation;
  }
#line 214
  return (& c->super.super);
}
}
#line 217
static void do_command_C(struct lsh_object *f , struct lsh_object *y , struct lsh_object *x ,
                         struct command_continuation *c , struct exception_handler *e ) ;
#line 217 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
struct command_3 command_C  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_3}, & do_command_C};
#line 217 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
static void do_command_C(struct lsh_object *f , struct lsh_object *y , struct lsh_object *x ,
                         struct command_continuation *c , struct exception_handler *e ) 
{ 
  struct command *cf ;
  struct command_continuation *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 224
  cf = (struct command *)f;
  {
#line 226
  trace("command_C\n");
  }
  {
#line 228
  tmp = make_command_C_continuation(y, c, e);
  }
  {
#line 228
  (*(cf->call))(cf, x, tmp, e);
  }
  }
#line 231
  return;
}
}
#line 235
static void do_command_Cp(struct lsh_object *k , struct lsh_object *f , struct lsh_object *y ,
                          struct lsh_object *x , struct command_continuation *c ,
                          struct exception_handler *e ) ;
#line 235 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
struct command_4 command_Cp  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_command_4}, & do_command_Cp};
#line 235 "/home/ysko/Works/test-src/lsh-2.0.4/src/combinators.c"
static void do_command_Cp(struct lsh_object *k , struct lsh_object *f , struct lsh_object *y ,
                          struct lsh_object *x , struct command_continuation *c ,
                          struct exception_handler *e ) 
{ 
  struct command *ck ;
  struct command *cf ;
  struct command_continuation *tmp ;
  struct command_continuation *tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 243
  ck = (struct command *)k;
#line 244
  cf = (struct command *)f;
  {
#line 246
  trace("command_Cp\n");
  }
  {
#line 253
  tmp = make_command_C_continuation(y, c, e);
  }
  {
#line 253
  tmp___0 = make_apply(ck, tmp, e);
  }
  {
#line 253
  (*(cf->call))(cf, x, tmp___0, e);
  }
  }
#line 257
  return;
}
}
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 118 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h"
struct channel_open channel_open_x11 ;
#line 120
struct command *make_forward_x11(char const   *display_string , struct randomness *random___0 ) ;
#line 124
struct client_x11_display *make_client_x11_display(char const   *display , struct lsh_string *fake ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.h.x"
struct lsh_class channel_forward_class ;
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.h"
void init_channel_forward(struct channel_forward *self , struct lsh_fd *socket___0 ,
                          uint32_t initial_window ) ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct lsh_class client_x11_display_class ;
#line 19 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
static void do_client_x11_display_free(struct lsh_object *o ) 
{ 
  struct client_x11_display *i ;

  {
  {
#line 22
  i = (struct client_x11_display *)o;
  {
#line 23
  lsh_space_free((void const   *)i->address);
  }
  {
#line 24
  lsh_string_free((struct lsh_string  const  *)i->fake);
  }
  {
#line 25
  lsh_string_free((struct lsh_string  const  *)i->auth_name);
  }
  {
#line 26
  lsh_string_free((struct lsh_string  const  *)i->auth_data);
  }
  }
#line 27
  return;
}
}
#line 28 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct lsh_class client_x11_display_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"client_x11_display", (size_t )sizeof(struct client_x11_display ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_client_x11_display_free};
#line 48
struct lsh_class channel_open_x11_class ;
#line 52 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
static void do_channel_open_x11_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct channel_open_x11 *i ;

  {
  {
#line 56
  i = (struct channel_open_x11 *)o;
  {
#line 57
  (*mark)((struct lsh_object *)i->backend);
  }
  }
#line 58
  return;
}
}
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct lsh_class channel_open_x11_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_open_class, (char *)"channel_open_x11", (size_t )sizeof(struct channel_open_x11 ),
    & do_channel_open_x11_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 85
struct lsh_class client_x11_channel_class ;
#line 89 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
static void do_client_x11_channel_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_x11_channel *i ;

  {
  {
#line 93
  i = (struct client_x11_channel *)o;
  {
#line 94
  (*mark)((struct lsh_object *)i->display);
  }
  }
#line 95
  return;
}
}
#line 96 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
static void do_client_x11_channel_free(struct lsh_object *o ) 
{ 
  struct client_x11_channel *i ;

  {
  {
#line 99
  i = (struct client_x11_channel *)o;
  {
#line 100
  lsh_string_free((struct lsh_string  const  *)i->buffer);
  }
  }
#line 101
  return;
}
}
#line 102 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct lsh_class client_x11_channel_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_forward_class, (char *)"client_x11_channel", (size_t )sizeof(struct client_x11_channel ),
    & do_client_x11_channel_mark, & do_client_x11_channel_free};
#line 123
struct lsh_class channel_open_x11_continuation_class ;
#line 127 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
static void do_channel_open_x11_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct channel_open_x11_continuation *i ;

  {
  {
#line 131
  i = (struct channel_open_x11_continuation *)o;
  {
#line 132
  (*mark)((struct lsh_object *)i->display);
  }
  {
#line 133
  (*mark)((struct lsh_object *)i->up);
  }
  }
#line 134
  return;
}
}
#line 135 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct lsh_class channel_open_x11_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"channel_open_x11_continuation",
    (size_t )sizeof(struct channel_open_x11_continuation ), & do_channel_open_x11_continuation_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 156
struct lsh_class client_x11_display_resource_class ;
#line 160 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
static void do_client_x11_display_resource_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_x11_display_resource *i ;

  {
  {
#line 164
  i = (struct client_x11_display_resource *)o;
  {
#line 165
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 166
  (*mark)((struct lsh_object *)i->display);
  }
  }
#line 167
  return;
}
}
#line 168 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct lsh_class client_x11_display_resource_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & resource_class, (char *)"client_x11_display_resource", (size_t )sizeof(struct client_x11_display_resource ),
    & do_client_x11_display_resource_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 190
struct lsh_class request_x11_continuation_class ;
#line 194 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
static void do_request_x11_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct request_x11_continuation *i ;

  {
  {
#line 198
  i = (struct request_x11_continuation *)o;
  {
#line 199
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 200
  (*mark)((struct lsh_object *)i->display);
  }
  {
#line 201
  (*mark)((struct lsh_object *)i->up);
  }
  }
#line 202
  return;
}
}
#line 203 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct lsh_class request_x11_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"request_x11_continuation", (size_t )sizeof(struct request_x11_continuation ),
    & do_request_x11_continuation_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 224
struct lsh_class request_x11_forward_command_class ;
#line 228 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
static void do_request_x11_forward_command_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct request_x11_forward_command *i ;

  {
  {
#line 232
  i = (struct request_x11_forward_command *)o;
  {
#line 233
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 234
  (*mark)((struct lsh_object *)i->display);
  }
  }
#line 235
  return;
}
}
#line 236 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c.x"
struct lsh_class request_x11_forward_command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_request_command_class, (char *)"request_x11_forward_command",
    (size_t )sizeof(struct request_x11_forward_command ), & do_request_x11_forward_command_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 285 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static void do_client_channel_x11_receive(struct ssh_channel *s , int type , struct lsh_string *data ) ;
#line 285 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static uint8_t const   pad[3]  = {      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 178 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static void do_client_channel_x11_receive(struct ssh_channel *s , int type , struct lsh_string *data ) 
{ 
  struct client_x11_channel *self ;
  uint8_t const   *buffer ;
  uint32_t tmp ;
  unsigned int pad_length[4] ;
  uint32_t auth_offset ;
  uint32_t length ;
  struct lsh_string *msg ;
  uint8_t lengths[4] ;
  uint32_t nlength ;
  uint32_t tmp___0 ;
  uint32_t alength ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
#line 182
  self = (struct client_x11_channel *)s;
#line 184
  if (type != 0) {
    {
    {
#line 186
    werror("Ignoring unexpected stderr data.\n");
    }
    {
#line 187
    lsh_string_free((struct lsh_string  const  *)data);
    }
    }
  } else {
#line 191
    if (self->state == 2) {
#line 191
      goto case_2;
    }
#line 201
    if (self->state == 3) {
#line 201
      goto case_3;
    }
#line 206
    goto switch_default;
    case_2: 
    {
    {
#line 192
    (*(((self->super.socket)->write_buffer)->super.write))(& ((self->super.socket)->write_buffer)->super,
                                                           data);
    }
    }
#line 193
    goto switch_break;
    fail: 
    {
    {
#line 196
    channel_close(& self->super.super);
    }
#line 197
    self->state = 3;
    }
#line 199
    goto switch_break;
    case_3: 
    {
    {
#line 204
    fatal("Internal error!\n");
    }
    }
    switch_default: 
    {
    {
#line 213
    lsh_string_write_string(self->buffer, self->i, (struct lsh_string  const  *)data);
    }
    {
#line 214
    tmp = lsh_string_length((struct lsh_string  const  *)data);
    }
#line 214
    self->i += tmp;
    {
#line 215
    lsh_string_free((struct lsh_string  const  *)data);
    }
    {
#line 217
    buffer = lsh_string_data((struct lsh_string  const  *)self->buffer);
    }
    }
#line 221
    if (self->state == 0) {
#line 221
      goto case_0;
    }
#line 256
    if (self->state == 1) {
#line 256
      goto case_1;
    }
#line 339
    goto switch_default___1;
    case_0: 
#line 225
    if (self->i < 12U) {
#line 226
      goto switch_break___0;
    }
#line 228
    self->state = 1;
#line 232
    if ((int const   )*(buffer + 0) == 98) {
#line 232
      goto case_98;
    }
#line 232
    if ((int const   )*(buffer + 0) == 66) {
#line 232
      goto case_98;
    }
#line 238
    if ((int const   )*(buffer + 0) == 108) {
#line 238
      goto case_108;
    }
#line 238
    if ((int const   )*(buffer + 0) == 76) {
#line 238
      goto case_108;
    }
#line 243
    goto switch_default___0;
    case_98: 
#line 233
    self->little_endian = 0;
#line 234
    self->name_length = ((uint32_t )*((buffer + 6) + 0) << 8) | (uint32_t )*((buffer + 6) + 1);
#line 235
    self->auth_length = ((uint32_t )*((buffer + 8) + 0) << 8) | (uint32_t )*((buffer + 8) + 1);
#line 236
    goto switch_break___1;
    case_108: 
#line 239
    self->little_endian = 1;
#line 240
    self->name_length = ((uint32_t )*((buffer + 6) + 1) << 8) | (uint32_t )*((buffer + 6) + 0);
#line 241
    self->auth_length = ((uint32_t )*((buffer + 8) + 1) << 8) | (uint32_t )*((buffer + 8) + 0);
#line 242
    goto switch_break___1;
    switch_default___0: 
    {
    {
#line 244
    werror("client_x11.c: Bad endian indicator.\n");
    }
    }
#line 245
    goto fail;
    switch_break___1: ;
#line 247
    if (self->name_length > 20U) {
      {
      {
#line 250
      werror("client_x11.c: Too long auth name or cookie\n");
      }
      }
#line 251
      goto fail;
    } else
#line 247
    if (self->auth_length > 16U) {
      {
      {
#line 250
      werror("client_x11.c: Too long auth name or cookie\n");
      }
      }
#line 251
      goto fail;
    }
    case_1: 
#line 258
    pad_length[0] = 0U;
#line 258
    pad_length[1] = 3U;
#line 258
    pad_length[2] = 2U;
#line 258
    pad_length[3] = 1U;
#line 262
    auth_offset = (12U + self->name_length) + pad_length[self->name_length % 4U];
#line 265
    length = (auth_offset + self->auth_length) + pad_length[self->auth_length % 4U];
#line 268
    if (self->i < length) {
#line 269
      goto switch_break___0;
    }
    {
    {
#line 271
    debug("Received cookie of type `%ps\': %xs\n", self->name_length, buffer + 12,
          self->auth_length, buffer + auth_offset);
    }
    }
#line 276
    if (self->name_length == 18U) {
      {
      {
#line 276
      tmp___3 = memcmp((void const   *)(buffer + 12), (void const   *)"MIT-MAGIC-COOKIE-1",
                       (size_t )18);
      }
      }
#line 276
      if (tmp___3) {
        {
        {
#line 333
        werror("client_x11: X11 connection denied; bad cookie.\n");
        }
        }
#line 334
        goto fail;
      } else {
        {
        {
#line 276
        tmp___4 = lsh_string_eq_l((struct lsh_string  const  *)(self->display)->fake,
                                  self->auth_length, buffer + auth_offset);
        }
        }
#line 276
        if (tmp___4) {
          {
          {
#line 286
          tmp___0 = lsh_string_length((struct lsh_string  const  *)(self->display)->auth_name);
          }
#line 286
          nlength = tmp___0;
          {
#line 287
          tmp___1 = lsh_string_length((struct lsh_string  const  *)(self->display)->auth_data);
          }
#line 287
          alength = tmp___1;
          {
#line 290
          verbose("client_x11: Allowing X11 connection; cookies match.\n");
          }
          }
#line 292
          if (self->little_endian) {
            {
            {
#line 294
            while (1) {
              while_continue___3: /* CIL Label */ ;
              while_continue: /* CIL Label */ ;
#line 294
              lengths[1] = (uint8_t )((nlength >> 8) & 255U);
#line 294
              lengths[0] = (uint8_t )(nlength & 255U);
#line 294
              goto while_break;
            }
            while_break___7: /* CIL Label */ ;
            }
            while_break___3: /* CIL Label */ ;
            }
            while_break: ;
            {
            {
#line 295
            while (1) {
              while_continue___4: /* CIL Label */ ;
              while_continue___0: /* CIL Label */ ;
#line 295
              *((lengths + 2) + 1) = (uint8_t )((alength >> 8) & 255U);
#line 295
              *((lengths + 2) + 0) = (uint8_t )(alength & 255U);
#line 295
              goto while_break___0;
            }
            while_break___8: /* CIL Label */ ;
            }
            while_break___4: /* CIL Label */ ;
            }
            while_break___0: ;
          } else {
            {
            {
#line 299
            while (1) {
              while_continue___5: /* CIL Label */ ;
              while_continue___1: /* CIL Label */ ;
#line 299
              lengths[0] = (uint8_t )((nlength >> 8) & 255U);
#line 299
              lengths[1] = (uint8_t )(nlength & 255U);
#line 299
              goto while_break___1;
            }
            while_break___9: /* CIL Label */ ;
            }
            while_break___5: /* CIL Label */ ;
            }
            while_break___1: ;
            {
            {
#line 300
            while (1) {
              while_continue___6: /* CIL Label */ ;
              while_continue___2: /* CIL Label */ ;
#line 300
              *((lengths + 2) + 0) = (uint8_t )((alength >> 8) & 255U);
#line 300
              *((lengths + 2) + 1) = (uint8_t )(alength & 255U);
#line 300
              goto while_break___2;
            }
            while_break___10: /* CIL Label */ ;
            }
            while_break___6: /* CIL Label */ ;
            }
            while_break___2: ;
          }
          {
          {
#line 306
          msg = ssh_format("%ls%ls%c%c%lS%ls%lS%ls", 6, buffer, 4, lengths, 0, 0,
                           (self->display)->auth_name, pad_length[nlength % 4U], pad,
                           (self->display)->auth_data, self->i - length, buffer + self->i);
          }
          {
#line 316
          lsh_string_free((struct lsh_string  const  *)self->buffer);
          }
#line 317
          self->buffer = (struct lsh_string *)((void *)0);
          {
#line 320
          tmp___2 = lsh_string_length((struct lsh_string  const  *)msg);
          }
          {
#line 320
          channel_start_receive(& self->super.super, 10000U - tmp___2);
          }
          {
#line 323
          debug("client_x11.c: Sending real X11 setup message: %xS\n", msg);
          }
          {
#line 327
          (*(((self->super.socket)->write_buffer)->super.write))(& ((self->super.socket)->write_buffer)->super,
                                                                 msg);
          }
#line 329
          self->state = 2;
          }
        } else {
          {
          {
#line 333
          werror("client_x11: X11 connection denied; bad cookie.\n");
          }
          }
#line 334
          goto fail;
        }
      }
    } else {
      {
      {
#line 333
      werror("client_x11: X11 connection denied; bad cookie.\n");
      }
      }
#line 334
      goto fail;
    }
#line 336
    goto switch_break___0;
    switch_default___1: 
    {
    {
#line 340
    fatal("Internal error. do_client_channel_x11_receive");
    }
    }
#line 341
    goto switch_break___0;
    switch_break___0: ;
#line 344
    goto switch_break;
    switch_break: ;
  }
#line 346
  return;
}
}
#line 348 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static struct client_x11_channel *make_client_x11_channel(struct lsh_fd *fd , struct client_x11_display *display ) 
{ 
  struct client_x11_channel *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 352
  tmp = lsh_object_alloc(& client_x11_channel_class);
  }
#line 352
  self = (struct client_x11_channel *)tmp;
  {
#line 355
  init_channel_forward(& self->super, fd, (uint32_t )48);
  }
#line 356
  self->display = display;
#line 357
  self->state = 0;
  {
#line 358
  self->buffer = lsh_string_alloc((uint32_t )48);
  }
  }
#line 360
  return (self);
}
}
#line 372 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static void do_channel_open_x11_continuation(struct command_continuation *s , struct lsh_object *a ) 
{ 
  struct channel_open_x11_continuation *self ;
  struct lsh_fd *fd ;
  struct client_x11_channel *channel ;
  struct client_x11_channel *tmp ;

  {
  {
#line 376
  self = (struct channel_open_x11_continuation *)s;
#line 377
  fd = (struct lsh_fd *)a;
  {
#line 379
  tmp = make_client_x11_channel(fd, self->display);
  }
#line 379
  channel = tmp;
  {
#line 380
  channel_forward_start_io(& channel->super);
  }
#line 381
  channel->super.super.receive = & do_client_channel_x11_receive;
  {
#line 383
  (*((self->up)->c))(self->up, (struct lsh_object *)channel);
  }
  }
#line 384
  return;
}
}
#line 386 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static struct command_continuation *make_channel_open_x11_continuation(struct client_x11_display *display ,
                                                                       struct command_continuation *up ) 
{ 
  struct channel_open_x11_continuation *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 390
  tmp = lsh_object_alloc(& channel_open_x11_continuation_class);
  }
#line 390
  self = (struct channel_open_x11_continuation *)tmp;
#line 391
  self->super.c = & do_channel_open_x11_continuation;
#line 392
  self->display = display;
#line 393
  self->up = up;
  }
#line 395
  return (& self->super);
}
}
#line 401 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static void do_exc_x11_connect_handler(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct exception *tmp ;

  {
#line 407
  if (e->type == 8193U) {
#line 407
    goto case_8193;
  }
#line 412
  goto switch_default;
  case_8193: 
  {
  {
#line 408
  tmp = make_channel_open_exception((uint32_t )2, (char const   *)e->msg);
  }
  {
#line 408
  (*((s->parent)->raise))(s->parent, (struct exception  const  *)tmp);
  }
  }
#line 411
  goto switch_break;
  switch_default: 
  {
  {
#line 413
  (*((s->parent)->raise))(s->parent, e);
  }
  }
  switch_break: ;
#line 415
  return;
}
}
#line 417 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static struct exception_handler *make_exc_x11_connect_handler(struct exception_handler *parent ,
                                                              char const   *context ) 
{ 
  struct exception_handler *tmp ;

  {
  {
  {
#line 421
  tmp = make_exception_handler(& do_exc_x11_connect_handler, parent, context);
  }
  }
#line 421
  return (tmp);
}
}
#line 424
static void do_channel_open_x11(struct channel_open *s  __attribute__((__unused__)) ,
                                struct ssh_connection *connection , struct channel_open_info *info  __attribute__((__unused__)) ,
                                struct simple_buffer *args , struct command_continuation *c ,
                                struct exception_handler *e ) ;
#line 424 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
struct channel_open channel_open_x11  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channel_open_x11};
#line 424 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static void do_channel_open_x11(struct channel_open *s  __attribute__((__unused__)) ,
                                struct ssh_connection *connection , struct channel_open_info *info  __attribute__((__unused__)) ,
                                struct simple_buffer *args , struct command_continuation *c ,
                                struct exception_handler *e ) 
{ 
  uint32_t originator_length ;
  uint8_t const   *originator ;
  uint32_t originator_port ;
  struct client_x11_display *display ;
  struct lsh_fd *fd ;
  struct exception_handler *tmp ;
  struct command_continuation *tmp___0 ;
  struct io_callback *tmp___1 ;
  struct lsh_fd *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  struct exception *tmp___5 ;
  struct exception *tmp___6 ;
  struct exception *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
  {
  {
#line 436
  tmp___8 = parse_string(args, & originator_length, & originator);
  }
  }
#line 436
  if (tmp___8) {
    {
    {
#line 436
    tmp___9 = parse_uint32(args, & originator_port);
    }
    }
#line 436
    if (tmp___9) {
      {
      {
#line 436
      tmp___10 = parse_eod(args);
      }
      }
#line 436
      if (tmp___10) {
        {
#line 440
        display = (connection->table)->x11_display;
        {
#line 442
        verbose("x11 connection attempt, originator: %s:%i\n", originator_length,
                originator, originator_port);
        }
        }
#line 446
        if (display) {
          {
          {
#line 448
          tmp = make_exc_x11_connect_handler(e, "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c:454");
          }
          {
#line 448
          tmp___0 = make_channel_open_x11_continuation(display, c);
          }
          {
#line 448
          tmp___1 = make_connect_callback(tmp___0);
          }
          {
#line 448
          tmp___2 = io_connect(display->address, display->address_length, tmp___1,
                               tmp);
          }
#line 448
          fd = tmp___2;
          }
#line 456
          if (fd) {
            {
            {
#line 457
            remember_resource(connection->resources, & fd->super);
            }
            }
          } else {
            {
            {
#line 459
            tmp___3 = __errno_location();
            }
            {
#line 459
            tmp___4 = strerror(*tmp___3);
            }
            {
#line 459
            tmp___5 = make_channel_open_exception((uint32_t )2, (char const   *)tmp___4);
            }
            {
#line 459
            (*(e->raise))(e, (struct exception  const  *)tmp___5);
            }
            }
          }
        } else {
          {
          {
#line 467
          tmp___6 = make_channel_open_exception((uint32_t )2, "No X11 forwarding has been requested.");
          }
          {
#line 467
          (*(e->raise))(e, (struct exception  const  *)tmp___6);
          }
          }
        }
      } else {
        {
        {
#line 473
        werror("do_channel_open_x11: Invalid message!\n");
        }
        {
#line 474
        tmp___7 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN x11 message.");
        }
        {
#line 474
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___7);
        }
        }
      }
    } else {
      {
      {
#line 473
      werror("do_channel_open_x11: Invalid message!\n");
      }
      {
#line 474
      tmp___7 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN x11 message.");
      }
      {
#line 474
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___7);
      }
      }
    }
  } else {
    {
    {
#line 473
    werror("do_channel_open_x11: Invalid message!\n");
    }
    {
#line 474
    tmp___7 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN x11 message.");
    }
    {
#line 474
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___7);
    }
    }
  }
#line 476
  return;
}
}
#line 480 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static int parse_display(struct client_x11_display *self , char const   *display ) 
{ 
  struct lsh_string *host ;
  char const   *num ;
  unsigned int num_length ;
  unsigned int display_num ;
  char const   *separator ;
  char *tmp ;
  size_t length ;
  int tmp___0 ;
  char *end ;
  long tmp___1 ;
  long tmp___2 ;
  struct address_info *a ;
  struct address_info *tmp___3 ;
  struct lsh_string *name ;
  struct lsh_string *tmp___4 ;
  uint32_t nlength ;
  uint32_t tmp___5 ;
  struct sockaddr_un *sa ;
  void *tmp___6 ;
  uint8_t const   *tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  size_t size38 ;
  void *tmp39 ;
  void *ret_lsh_space_alloc40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 490
  if ((int const   )*(display + 0) == 58) {
#line 493
    host = (struct lsh_string *)((void *)0);
#line 494
    display ++;
  } else {
    {
    {
#line 498
    tmp = strchr(display, ':');
    }
#line 498
    separator = (char const   *)tmp;
    }
#line 501
    if (! separator) {
#line 502
      return (0);
    }
    {
#line 504
    length = (size_t )(separator - display);
    {
#line 506
    tmp___0 = strncmp("unix", display, length);
    }
    }
#line 506
    if (tmp___0) {
      {
      {
#line 509
      host = ssh_format("%ls", length, display);
      }
      }
    } else {
#line 507
      host = (struct lsh_string *)((void *)0);
    }
#line 511
    display = separator + 1;
  }
  {
#line 517
  num = display;
  {
#line 519
  tmp___1 = strtol((char const   */* __restrict  */)display, (char **/* __restrict  */)(& end),
                   0);
  }
#line 519
  display_num = (unsigned int )tmp___1;
#line 521
  num_length = (unsigned int )(end - (char *)num);
  }
#line 523
  if (! num_length) {
    {
    {
#line 525
    lsh_string_free((struct lsh_string  const  *)host);
    }
    }
#line 526
    return (0);
  }
#line 529
  if (! *end) {
#line 531
    self->screen = (uint16_t )0;
  } else
#line 532
  if ((int )*end != 46) {
    {
    {
#line 534
    lsh_string_free((struct lsh_string  const  *)host);
    }
    }
#line 535
    return (0);
  } else {
    {
#line 539
    display = (char const   *)(end + 1);
    {
#line 540
    tmp___2 = strtol((char const   */* __restrict  */)display, (char **/* __restrict  */)(& end),
                     0);
    }
#line 540
    self->screen = (uint16_t )tmp___2;
    }
#line 542
    if (*end) {
      {
      {
#line 544
      lsh_string_free((struct lsh_string  const  *)host);
      }
      }
#line 545
      return (0);
    }
  }
#line 550
  if (host) {
    {
    {
#line 555
    tmp___3 = make_address_info(host, 6000U + display_num);
    }
#line 555
    a = tmp___3;
    {
#line 557
    self->address = address_info2sockaddr(& self->address_length, a, (int const   *)((void *)0),
                                          1);
    }
    {
#line 559
    gc_kill((struct lsh_object *)a);
    }
    }
#line 561
    if (! self->address) {
#line 562
      return (0);
    }
  } else {
    {
    {
#line 567
    tmp___4 = ssh_format("/tmp/.X11-unix/X%di", display_num);
    }
#line 567
    name = tmp___4;
    {
#line 568
    tmp___5 = lsh_string_length((struct lsh_string  const  *)name);
    }
#line 568
    nlength = tmp___5;
    {
#line 571
    verbose("Using local X11 transport `%pS\'\n", name);
    }
#line 573
    self->address_length = (socklen_t )((unsigned long )(& ((struct sockaddr_un *)0)->sun_path) + (unsigned long )nlength);
    {
#line 574
    size38 = self->address_length;
    {
    {
    {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
    tmp39 = malloc(size38);
    }
    }
    {
#line 262
    ret_lsh_space_alloc40 = tmp39;
#line 262
    goto Lret_lsh_space_alloc;
    }
    }
    Lret_lsh_space_alloc: /* CIL Label */ 
#line 574 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
    tmp___6 = ret_lsh_space_alloc40;
    }
#line 574
    sa = (struct sockaddr_un *)tmp___6;
#line 575
    sa->sun_family = (sa_family_t )1;
    {
#line 576
    tmp___7 = lsh_string_data((struct lsh_string  const  *)name);
    }
    {
#line 576
    memcpy((void */* __restrict  */)((void *)(sa->sun_path)), (void const   */* __restrict  */)((void const   *)tmp___7),
           nlength);
    }
    {
#line 578
    lsh_string_free((struct lsh_string  const  *)name);
    }
#line 579
    self->address = (struct sockaddr *)sa;
    }
  }
  {
  {
#line 582
  tmp___8 = xauth_lookup(self->address, num_length, num, & self->auth_name, & self->auth_data);
  }
  }
#line 582
  if (! tmp___8) {
    {
    {
#line 589
    werror("Can\'t find any xauth information for X11 display.\n");
    }
    {
#line 591
    self->auth_name = ssh_format("");
    }
    {
#line 592
    self->auth_data = ssh_format("");
    }
    }
  }
#line 595
  return (1);
}
}
#line 598 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
struct client_x11_display *make_client_x11_display(char const   *display , struct lsh_string *fake ) 
{ 
  struct client_x11_display *self ;
  struct lsh_object *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 601
  tmp = lsh_object_alloc(& client_x11_display_class);
  }
#line 601
  self = (struct client_x11_display *)tmp;
#line 603
  self->fake = fake;
  {
#line 605
  tmp___0 = parse_display(self, display);
  }
  }
#line 605
  if (! tmp___0) {
    {
    {
#line 607
    werror("Can\'t parse X11 display: `%z\'\n", display);
    }
    {
#line 608
    gc_kill((struct lsh_object *)self);
    }
    }
#line 609
    return ((struct client_x11_display *)((void *)0));
  }
#line 612
  return (self);
}
}
#line 624 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static void do_kill_x11_display(struct resource *s ) 
{ 
  struct client_x11_display_resource *self ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 627
  self = (struct client_x11_display_resource *)s;
#line 629
  if (self->super.alive) {
#line 631
    self->super.alive = 0;
#line 633
    if ((unsigned long )((self->connection)->table)->x11_display == (unsigned long )self->display) {
#line 634
      ((self->connection)->table)->x11_display = (struct client_x11_display *)((void *)0);
    } else {
      {
      {
#line 636
      werror("do_kill_x11_display: Display has been replaced.\n");
      }
      }
    }
  }
#line 638
  return;
}
}
#line 640 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static struct resource *make_client_x11_display_resource(struct ssh_connection *connection ,
                                                         struct client_x11_display *display ) 
{ 
  struct client_x11_display_resource *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 644
  tmp = lsh_object_alloc(& client_x11_display_resource_class);
  }
#line 644
  self = (struct client_x11_display_resource *)tmp;
  {
#line 645
  init_resource(& self->super, & do_kill_x11_display);
  }
#line 647
  self->connection = connection;
#line 648
  self->display = display;
  }
#line 650
  return (& self->super);
}
}
#line 663 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static void do_request_x11_continuation(struct command_continuation *s , struct lsh_object *a ) 
{ 
  struct request_x11_continuation *self ;
  struct ssh_channel *channel ;
  struct resource *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 667
  self = (struct request_x11_continuation *)s;
#line 668
  channel = (struct ssh_channel *)a;
  {
#line 670
  verbose("X11 request succeeded\n");
  }
  }
#line 672
  if (((self->connection)->table)->x11_display) {
    {
    {
#line 673
    werror("client_x11.c: Replacing old x11 forwarding.\n");
    }
    }
  }
  {
#line 675
  ((self->connection)->table)->x11_display = self->display;
  {
#line 677
  tmp = make_client_x11_display_resource(self->connection, self->display);
  }
  {
#line 677
  remember_resource(channel->resources, tmp);
  }
  {
#line 681
  (*((self->up)->c))(self->up, a);
  }
  }
#line 682
  return;
}
}
#line 684 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static struct command_continuation *make_request_x11_continuation(struct ssh_connection *connection ,
                                                                  struct client_x11_display *display ,
                                                                  struct command_continuation *up ) 
{ 
  struct request_x11_continuation *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 689
  tmp = lsh_object_alloc(& request_x11_continuation_class);
  }
#line 689
  self = (struct request_x11_continuation *)tmp;
#line 690
  self->super.c = & do_request_x11_continuation;
#line 692
  self->connection = connection;
#line 693
  self->display = display;
#line 694
  self->up = up;
  }
#line 696
  return (& self->super);
}
}
#line 708 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
static struct lsh_string *do_format_request_x11_forward(struct channel_request_command *s ,
                                                        struct ssh_channel *channel ,
                                                        struct command_continuation **c ) 
{ 
  struct request_x11_forward_command *self ;
  struct lsh_string *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 713
  self = (struct request_x11_forward_command *)s;
  {
#line 715
  verbose("Requesting X11 forwarding.\n");
  }
  {
#line 717
  *c = make_request_x11_continuation(channel->connection, self->display, *c);
  }
  {
#line 724
  tmp = format_channel_request(54, channel, 1, "%c%s%xS%i", 0, 18, "MIT-MAGIC-COOKIE-1",
                               (self->display)->fake, (int )(self->display)->screen);
  }
  }
#line 724
  return (tmp);
}
}
#line 732 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c"
struct command *make_forward_x11(char const   *display_string , struct randomness *random___0 ) 
{ 
  struct lsh_string *fake ;
  struct client_x11_display *display ;
  struct request_x11_forward_command *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 739
  if (! ((unsigned int )random___0->quality == 0U)) {
    {
    {
#line 739
    __assert_fail("random->quality == RANDOM_GOOD", "/home/ysko/Works/test-src/lsh-2.0.4/src/client_x11.c",
                  739U, "make_forward_x11");
    }
    }
  }
  {
  {
#line 740
  fake = lsh_string_random(random___0, (uint32_t )16);
  }
  {
#line 742
  debug("Generated X11 fake cookie %xS\n", fake);
  }
  {
#line 745
  display = make_client_x11_display(display_string, fake);
  }
  }
#line 747
  if (display) {
    {
    {
#line 749
    tmp = lsh_object_alloc(& request_x11_forward_command_class);
    }
#line 749
    self = (struct request_x11_forward_command *)tmp;
#line 750
    self->super.super.call = & do_channel_request_command;
#line 751
    self->super.format_request = & do_format_request_x11_forward;
#line 753
    self->display = display;
    }
#line 754
    return (& self->super.super);
  } else {
#line 757
    return ((struct command *)((void *)0));
  }
}
}
#line 35 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.h"
struct lsh_string *format_userauth_password(struct lsh_string *name , int service ,
                                            struct lsh_string *passwd , int free___0 ) ;
#line 43
struct command *make_client_userauth(struct lsh_string *username , int service_name ,
                                     struct object_list *methods ) ;
#line 47
struct client_userauth_method *make_client_password_auth(struct interact *tty ) ;
#line 50
struct client_userauth_method *make_client_kbdinteract_auth(struct interact *tty ) ;
#line 53
struct client_userauth_method *make_client_publickey_auth(struct object_list *keys ) ;
#line 56
struct client_userauth_method *make_client_none_auth(void) ;
#line 56 "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.h"
struct lsh_string *local_to_utf8(struct lsh_string *s , int free___0 ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class client_userauth_failure_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class client_userauth_failure_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"client_userauth_failure",
    (size_t )sizeof(struct client_userauth_failure ), (void (*)(struct lsh_object *instance ,
                                                                void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 35
struct lsh_class client_userauth_method_class ;
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class client_userauth_method_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"client_userauth_method",
    (size_t )sizeof(struct client_userauth_method ), (void (*)(struct lsh_object *instance ,
                                                               void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 61
struct lsh_class client_userauth_class ;
#line 65 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_client_userauth_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_userauth *i ;

  {
  {
#line 69
  i = (struct client_userauth *)o;
  {
#line 70
  (*mark)((struct lsh_object *)i->methods);
  }
  }
#line 71
  return;
}
}
#line 72 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_client_userauth_free(struct lsh_object *o ) 
{ 
  struct client_userauth *i ;

  {
  {
#line 75
  i = (struct client_userauth *)o;
  {
#line 76
  lsh_string_free((struct lsh_string  const  *)i->username);
  }
  }
#line 77
  return;
}
}
#line 78 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class client_userauth_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"client_userauth", (size_t )sizeof(struct client_userauth ),
    & do_client_userauth_mark, & do_client_userauth_free};
#line 102
struct lsh_class client_userauth_state_class ;
#line 106 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_client_userauth_state_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_userauth_state *i ;

  {
  {
#line 110
  i = (struct client_userauth_state *)o;
  {
#line 111
  (*mark)((struct lsh_object *)i->userauth);
  }
  {
#line 112
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 113
  (*mark)((struct lsh_object *)i->failure);
  }
  }
#line 114
  return;
}
}
#line 115 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class client_userauth_state_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"client_userauth_state", (size_t )sizeof(struct client_userauth_state ),
    & do_client_userauth_state_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 135
struct lsh_class userauth_packet_handler_class ;
#line 139 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_userauth_packet_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct userauth_packet_handler *i ;

  {
  {
#line 143
  i = (struct userauth_packet_handler *)o;
  {
#line 144
  (*mark)((struct lsh_object *)i->state);
  }
  }
#line 145
  return;
}
}
#line 146 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class userauth_packet_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & packet_handler_class, (char *)"userauth_packet_handler", (size_t )sizeof(struct userauth_packet_handler ),
    & do_userauth_packet_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 166
struct lsh_class userauth_success_handler_class ;
#line 170 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_userauth_success_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct userauth_success_handler *i ;

  {
  {
#line 174
  i = (struct userauth_success_handler *)o;
  {
#line 175
  (*mark)((struct lsh_object *)i->c);
  }
  }
#line 176
  return;
}
}
#line 177 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class userauth_success_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & packet_handler_class, (char *)"userauth_success_handler", (size_t )sizeof(struct userauth_success_handler ),
    & do_userauth_success_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 197
struct lsh_class failure_handler_class ;
#line 201 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_failure_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct failure_handler *i ;

  {
  {
#line 205
  i = (struct failure_handler *)o;
  {
#line 206
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 207
  return;
}
}
#line 208 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class failure_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & userauth_packet_handler_class, (char *)"failure_handler", (size_t )sizeof(struct failure_handler ),
    & do_failure_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 228
struct lsh_class exc_client_userauth_class ;
#line 232 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_exc_client_userauth_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct exc_client_userauth *i ;

  {
  {
#line 236
  i = (struct exc_client_userauth *)o;
  {
#line 237
  (*mark)((struct lsh_object *)i->state);
  }
  }
#line 238
  return;
}
}
#line 239 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class exc_client_userauth_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"exc_client_userauth", (size_t )sizeof(struct exc_client_userauth ),
    & do_exc_client_userauth_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 259
struct lsh_class exc_userauth_disconnect_class ;
#line 263 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_exc_userauth_disconnect_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct exc_userauth_disconnect *i ;

  {
  {
#line 267
  i = (struct exc_userauth_disconnect *)o;
  {
#line 268
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 269
  return;
}
}
#line 270 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class exc_userauth_disconnect_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"exc_userauth_disconnect", (size_t )sizeof(struct exc_userauth_disconnect ),
    & do_exc_userauth_disconnect_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 290
struct lsh_class client_none_state_class ;
#line 294 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_client_none_state_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_none_state *i ;

  {
  {
#line 298
  i = (struct client_none_state *)o;
  {
#line 299
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 300
  return;
}
}
#line 301 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class client_none_state_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & client_userauth_failure_class, (char *)"client_none_state", (size_t )sizeof(struct client_none_state ),
    & do_client_none_state_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 325
struct lsh_class client_password_state_class ;
#line 329 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_client_password_state_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_password_state *i ;

  {
  {
#line 333
  i = (struct client_password_state *)o;
  {
#line 334
  (*mark)((struct lsh_object *)i->userauth);
  }
  {
#line 335
  (*mark)((struct lsh_object *)i->tty);
  }
  {
#line 336
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 337
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 338
  return;
}
}
#line 339 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class client_password_state_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & client_userauth_failure_class, (char *)"client_password_state", (size_t )sizeof(struct client_password_state ),
    & do_client_password_state_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 359
struct lsh_class client_userauth_interactive_method_class ;
#line 363 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_client_userauth_interactive_method_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_userauth_interactive_method *i ;

  {
  {
#line 367
  i = (struct client_userauth_interactive_method *)o;
  {
#line 368
  (*mark)((struct lsh_object *)i->tty);
  }
  }
#line 369
  return;
}
}
#line 370 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class client_userauth_interactive_method_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & client_userauth_method_class, (char *)"client_userauth_interactive_method",
    (size_t )sizeof(struct client_userauth_interactive_method ), & do_client_userauth_interactive_method_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 390
struct lsh_class client_publickey_method_class ;
#line 394 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_client_publickey_method_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_publickey_method *i ;

  {
  {
#line 398
  i = (struct client_publickey_method *)o;
  {
#line 399
  (*mark)((struct lsh_object *)i->keys);
  }
  }
#line 400
  return;
}
}
#line 401 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class client_publickey_method_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & client_userauth_method_class, (char *)"client_publickey_method",
    (size_t )sizeof(struct client_publickey_method ), & do_client_publickey_method_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 426
struct lsh_class client_publickey_state_class ;
#line 430 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_client_publickey_state_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_publickey_state *i ;

  {
  {
#line 434
  i = (struct client_publickey_state *)o;
  {
#line 435
  (*mark)((struct lsh_object *)i->userauth);
  }
  {
#line 436
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 437
  (*mark)((struct lsh_object *)i->keys);
  }
  {
#line 438
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 439
  return;
}
}
#line 440 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class client_publickey_state_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & client_userauth_failure_class, (char *)"client_publickey_state",
    (size_t )sizeof(struct client_publickey_state ), & do_client_publickey_state_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 460
struct lsh_class userauth_pk_ok_handler_class ;
#line 464 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_userauth_pk_ok_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct userauth_pk_ok_handler *i ;

  {
  {
#line 468
  i = (struct userauth_pk_ok_handler *)o;
  {
#line 469
  (*mark)((struct lsh_object *)i->state);
  }
  }
#line 470
  return;
}
}
#line 471 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class userauth_pk_ok_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & packet_handler_class, (char *)"userauth_pk_ok_handler", (size_t )sizeof(struct userauth_pk_ok_handler ),
    & do_userauth_pk_ok_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 493
struct lsh_class client_kbdinteract_state_class ;
#line 497 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_client_kbdinteract_state_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_kbdinteract_state *i ;

  {
  {
#line 501
  i = (struct client_kbdinteract_state *)o;
  {
#line 502
  (*mark)((struct lsh_object *)i->tty);
  }
  {
#line 503
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 504
  (*mark)((struct lsh_object *)i->e);
  }
  }
#line 505
  return;
}
}
#line 506 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class client_kbdinteract_state_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & client_userauth_failure_class, (char *)"client_kbdinteract_state",
    (size_t )sizeof(struct client_kbdinteract_state ), & do_client_kbdinteract_state_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 526
struct lsh_class userauth_info_request_handler_class ;
#line 530 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
static void do_userauth_info_request_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct userauth_info_request_handler *i ;

  {
  {
#line 534
  i = (struct userauth_info_request_handler *)o;
  {
#line 535
  (*mark)((struct lsh_object *)i->state);
  }
  }
#line 536
  return;
}
}
#line 537 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c.x"
struct lsh_class userauth_info_request_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & packet_handler_class, (char *)"userauth_info_request_handler", (size_t )sizeof(struct userauth_info_request_handler ),
    & do_userauth_info_request_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct lsh_string *format_userauth_none(struct lsh_string *name , int service ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 51
  tmp = ssh_format("%c%S%a%a", 50, name, service, 1);
  }
  }
#line 51
  return (tmp);
}
}
#line 59 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
struct lsh_string *format_userauth_password(struct lsh_string *name , int service ,
                                            struct lsh_string *passwd , int free___0 ) 
{ 
  char const   *tmp ;
  struct lsh_string *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 65
  if (free___0) {
#line 65
    tmp = "%c%S%a%a%c%fS";
  } else {
#line 65
    tmp = "%c%S%a%a%c%S";
  }
  {
  {
#line 65
  tmp___0 = ssh_format(tmp, 50, name, service, 48, 0, passwd);
  }
  }
#line 65
  return (tmp___0);
}
}
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct lsh_string *format_userauth_publickey_query(struct lsh_string *name ,
                                                          uint32_t service , uint32_t keytype ,
                                                          struct lsh_string *public ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 80
  tmp = ssh_format("%c%S%a%a%c%a%S", 50, name, service, 47, 0, keytype, public);
  }
  }
#line 80
  return (tmp);
}
}
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct lsh_string *format_userauth_publickey(struct lsh_string *name , uint32_t service ,
                                                    uint32_t keytype , struct lsh_string *public ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 96
  tmp = ssh_format("%c%S%a%a%c%a%S", 50, name, service, 47, 1, keytype, public);
  }
  }
#line 96
  return (tmp);
}
}
#line 106 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct lsh_string *format_userauth_kbdinteract(struct lsh_string *name , uint32_t service ) 
{ 
  struct lsh_string *s ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 110
  s = ssh_format("%c%S%a%a%i%i", 50, name, service, 50, 0, 0);
  }
  {
#line 115
  debug("format_userauth_kbdinteract %xS\n", s);
  }
  }
#line 116
  return (s);
}
}
#line 119 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct lsh_string *format_userauth_info_response(struct interact_dialog *dialog ) 
{ 
  uint32_t length ;
  unsigned int i ;
  struct lsh_string *msg ;
  uint32_t p ;
  uint32_t tmp ;
  struct lsh_string *r ;
  uint32_t rlength ;
  uint32_t tmp___0 ;
  uint8_t const   *tmp___1 ;
  uint32_t tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 131
  i = 0U;
  {
  {
#line 131
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 131
    if (! (i < dialog->nprompt)) {
#line 131
      goto while_break;
    }
    {
    {
#line 132
    *(dialog->response + i) = local_to_utf8(*(dialog->response + i), 1);
    }
#line 131
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 134
  length = (uint32_t )0;
#line 134
  i = length;
  {
  {
#line 134
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 134
    if (! (i < dialog->nprompt)) {
#line 134
      goto while_break___0;
    }
    {
    {
#line 135
    tmp = lsh_string_length((struct lsh_string  const  *)*(dialog->response + i));
    }
#line 135
    length += tmp;
#line 134
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
  {
#line 137
  msg = ssh_format("%c%i%lr", 61, dialog->nprompt, length + 4U * dialog->nprompt,
                   & p);
  }
#line 140
  i = 0U;
  }
  {
  {
#line 140
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;

#line 140
    if (! (i < dialog->nprompt)) {
#line 140
      goto while_break___1;
    }
    {
#line 142
    r = *(dialog->response + i);
    {
#line 143
    tmp___0 = lsh_string_length((struct lsh_string  const  *)r);
    }
#line 143
    rlength = tmp___0;
    {
#line 144
    lsh_string_write_uint32(msg, p, rlength);
    }
#line 145
    p += 4U;
    {
#line 146
    tmp___1 = lsh_string_data((struct lsh_string  const  *)r);
    }
    {
#line 146
    lsh_string_write(msg, p, rlength, tmp___1);
    }
#line 147
    p += rlength;
#line 140
    i ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
  {
  {
#line 149
  tmp___2 = lsh_string_length((struct lsh_string  const  *)msg);
  }
  }
#line 149
  if (! (p == tmp___2)) {
    {
    {
#line 149
    __assert_fail("p == lsh_string_length(msg)", "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c",
                  149U, "format_userauth_info_response");
    }
    }
  }
#line 151
  return (msg);
}
}
#line 216 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct client_userauth_state *make_client_userauth_state(struct client_userauth *userauth ,
                                                                struct ssh_connection *connection ) 
{ 
  struct client_userauth_state *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 220
  tmp = lsh_object_alloc(& client_userauth_state_class);
  }
#line 220
  self = (struct client_userauth_state *)tmp;
  {
#line 222
  trace("client_userauth.c: make_client_userauth_state\n");
  }
#line 223
  self->connection = connection;
#line 224
  self->userauth = userauth;
#line 225
  self->failure = (struct client_userauth_failure *)((void *)0);
#line 226
  self->current = 0U;
#line 227
  self->next = 1U;
  }
#line 229
  return (self);
}
}
#line 249 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void do_userauth_success(struct packet_handler *c , struct ssh_connection *connection ,
                                struct lsh_string *packet ) 
{ 
  struct userauth_success_handler *self ;
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  unsigned int i ;
  struct exception *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 254
  self = (struct userauth_success_handler *)c;
  {
#line 259
  trace("client_userauth.c: do_userauth_success\n");
  }
  {
#line 261
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 261
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 261
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 263
  tmp___2 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 263
  if (tmp___2) {
#line 263
    if (msg_number == 52U) {
      {
      {
#line 263
      tmp___3 = parse_eod(& buffer);
      }
      }
#line 263
      if (tmp___3) {
        {
        {
#line 269
        verbose("User authentication successful.\n");
        }
#line 271
        i = 50U;
        }
        {
        {
#line 271
        while (1) {
          while_continue___0: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;

#line 271
          if (! (i < 80U)) {
#line 271
            goto while_break;
          }
#line 272
          connection->dispatch[i] = & connection_fail_handler;
#line 271
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        while_break: 
        {
        {
#line 274
        (*((self->c)->c))(self->c, (struct lsh_object *)connection);
        }
        }
      } else {
        {
        {
#line 277
        tmp___1 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_SUCCESS message");
        }
        {
#line 277
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
        }
        }
      }
    } else {
      {
      {
#line 277
      tmp___1 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_SUCCESS message");
      }
      {
#line 277
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
      }
      }
    }
  } else {
    {
    {
#line 277
    tmp___1 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_SUCCESS message");
    }
    {
#line 277
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
    }
    }
  }
#line 278
  return;
}
}
#line 280 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct packet_handler *make_success_handler(struct command_continuation *c ) 
{ 
  struct userauth_success_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 283
  tmp = lsh_object_alloc(& userauth_success_handler_class);
  }
#line 283
  self = (struct userauth_success_handler *)tmp;
#line 285
  self->super.handler = & do_userauth_success;
#line 286
  self->c = c;
  }
#line 288
  return (& self->super);
}
}
#line 304 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static int userauth_method_is_useful(struct client_userauth *userauth , struct int_list *advertised ,
                                     unsigned int n ) 
{ 
  struct client_userauth_method *method ;
  unsigned int i ;

  {
#line 309
  method = (struct client_userauth_method *)(userauth->methods)->elements[n];
#line 322
  i = 0U;
  {
  {
#line 322
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 322
    if (! (i < advertised->super.length)) {
#line 322
      goto while_break;
    }
#line 323
    if (advertised->elements[i] == method->type) {
#line 324
      return (1);
    }
#line 322
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 326
  return (0);
}
}
#line 329 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void do_userauth_failure(struct packet_handler *c , struct ssh_connection *connection ,
                                struct lsh_string *packet ) 
{ 
  struct userauth_packet_handler *self ;
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  struct int_list *methods ;
  int partial_success ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct exception *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
#line 334
  self = (struct userauth_packet_handler *)c;
#line 338
  methods = (struct int_list *)((void *)0);
  {
#line 341
  trace("client_userauth.c: do_userauth_failure\n");
  }
  }
#line 342
  if (! ((self->state)->current < (self->state)->next)) {
    {
    {
#line 342
    __assert_fail("self->state->current < self->state->next", "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c",
                  342U, "do_userauth_failure");
    }
    }
  }
  {
  {
#line 344
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 344
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 344
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 346
  tmp___4 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 346
  if (tmp___4) {
#line 346
    if (msg_number == 51U) {
      {
      {
#line 346
      methods = parse_atom_list(& buffer, 47U);
      }
      }
#line 346
      if (methods) {
        {
        {
#line 346
        tmp___5 = parse_boolean(& buffer, & partial_success);
        }
        }
#line 346
        if (tmp___5) {
          {
          {
#line 346
          tmp___6 = parse_eod(& buffer);
          }
          }
#line 346
          if (tmp___6) {
#line 352
            if (partial_success) {
              {
              {
#line 354
              werror("Received SSH_MSH_USERAUTH_FAILURE indicating partial success.\n");
              }
              }
            }
            {
            {
#line 357
            while (1) {
              while_continue___0: /* CIL Label */ ;
              while_continue: /* CIL Label */ ;

#line 357
              if ((self->state)->next < (((self->state)->userauth)->methods)->super.length) {
                {
                {
#line 357
                tmp___1 = userauth_method_is_useful((self->state)->userauth, methods,
                                                    (self->state)->next);
                }
                }
#line 357
                if (tmp___1) {
#line 357
                  goto while_break;
                }
              } else {
#line 357
                goto while_break;
              }
#line 360
              ((self->state)->next) ++;
            }
            while_break___1: /* CIL Label */ ;
            }
            while_break___0: /* CIL Label */ ;
            }
            while_break: 
            {
            {
#line 362
            tmp___2 = userauth_method_is_useful((self->state)->userauth, methods,
                                                (self->state)->current);
            }
            {
#line 362
            (*(((self->state)->failure)->failure))((self->state)->failure, tmp___2);
            }
            }
          } else {
            {
            {
#line 367
            tmp___3 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_FAILURE message.");
            }
            {
#line 367
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
            }
            }
          }
        } else {
          {
          {
#line 367
          tmp___3 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_FAILURE message.");
          }
          {
#line 367
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
          }
          }
        }
      } else {
        {
        {
#line 367
        tmp___3 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_FAILURE message.");
        }
        {
#line 367
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
        }
        }
      }
    } else {
      {
      {
#line 367
      tmp___3 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_FAILURE message.");
      }
      {
#line 367
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
      }
      }
    }
  } else {
    {
    {
#line 367
    tmp___3 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_FAILURE message.");
    }
    {
#line 367
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
    }
    }
  }
  {
  {
#line 369
  gc_kill((struct lsh_object *)methods);
  }
  }
#line 370
  return;
}
}
#line 372 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct packet_handler *make_failure_handler(struct client_userauth_state *state ) 
{ 
  struct userauth_packet_handler *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 375
  tmp = lsh_object_alloc(& userauth_packet_handler_class);
  }
#line 375
  self = (struct userauth_packet_handler *)tmp;
  {
#line 377
  trace("client_userauth.c: make_failure_handler\n");
  }
#line 379
  self->super.handler = & do_userauth_failure;
#line 380
  self->state = state;
  }
#line 382
  return (& self->super);
}
}
#line 385 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void do_userauth_banner(struct packet_handler *self  __attribute__((__unused__)) ,
                               struct ssh_connection *connection  __attribute__((__unused__)) ,
                               struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t length ;
  uint8_t const   *msg ;
  uint32_t language_length ;
  uint8_t const   *language ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct exception *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
  {
#line 399
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 399
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 399
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 401
  tmp___2 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 401
  if (tmp___2) {
#line 401
    if (msg_number == 53U) {
      {
      {
#line 401
      tmp___3 = parse_string(& buffer, & length, & msg);
      }
      }
#line 401
      if (tmp___3) {
        {
        {
#line 401
        tmp___4 = parse_string(& buffer, & language_length, & language);
        }
        }
#line 401
        if (tmp___4) {
          {
          {
#line 401
          tmp___5 = parse_eod(& buffer);
          }
          }
#line 401
          if (tmp___5) {
            {
            {
#line 408
            werror("%ups", length, msg);
            }
            }
          } else {
            {
            {
#line 411
            tmp___1 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_SUCCESS message");
            }
            {
#line 411
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
            }
            }
          }
        } else {
          {
          {
#line 411
          tmp___1 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_SUCCESS message");
          }
          {
#line 411
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
          }
          }
        }
      } else {
        {
        {
#line 411
        tmp___1 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_SUCCESS message");
        }
        {
#line 411
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
        }
        }
      }
    } else {
      {
      {
#line 411
      tmp___1 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_SUCCESS message");
      }
      {
#line 411
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
      }
      }
    }
  } else {
    {
    {
#line 411
    tmp___1 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_SUCCESS message");
    }
    {
#line 411
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
    }
    }
  }
#line 412
  return;
}
}
#line 414 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct packet_handler userauth_banner_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_userauth_banner};
#line 429 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void do_exc_client_userauth(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct exc_client_userauth *self ;
  unsigned int tmp ;
  struct client_userauth_method *method ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 433
  self = (struct exc_client_userauth *)s;
  {
#line 435
  trace("client_userauth.c: do_exc_client_userauth\n");
  }
  }
#line 436
  if (! ((self->state)->current < (self->state)->next)) {
    {
    {
#line 436
    __assert_fail("self->state->current < self->state->next", "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c",
                  436U, "do_exc_client_userauth");
    }
    }
  }
#line 438
  if (e->type == 16385U) {
#line 438
    if ((self->state)->next < (((self->state)->userauth)->methods)->super.length) {
      {
#line 441
      tmp = (self->state)->next;
#line 441
      ((self->state)->next) ++;
#line 441
      (self->state)->current = tmp;
#line 443
      method = (struct client_userauth_method *)(((self->state)->userauth)->methods)->elements[(self->state)->current];
      {
#line 446
      (self->state)->failure = (*(method->login))(method, (self->state)->userauth,
                                                  (self->state)->connection, s);
      }
      }
    } else {
      {
      {
#line 452
      (*((s->parent)->raise))(s->parent, e);
      }
      }
    }
  } else {
    {
    {
#line 452
    (*((s->parent)->raise))(s->parent, e);
    }
    }
  }
#line 453
  return;
}
}
#line 455 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct exception_handler *make_exc_client_userauth(struct client_userauth_state *state ,
                                                          struct exception_handler *parent ,
                                                          char const   *context ) 
{ 
  struct exc_client_userauth *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 460
  tmp = lsh_object_alloc(& exc_client_userauth_class);
  }
#line 460
  self = (struct exc_client_userauth *)tmp;
  {
#line 462
  trace("client_userauth.c: make_exc_client_userauth\n");
  }
#line 464
  self->super.parent = parent;
#line 465
  self->super.raise = & do_exc_client_userauth;
#line 466
  self->super.context = context;
#line 468
  self->state = state;
  }
#line 470
  return (& self->super);
}
}
#line 482 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void do_exc_userauth_disconnect(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct exc_userauth_disconnect *self ;
  struct exception *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 486
  self = (struct exc_userauth_disconnect *)s;
#line 488
  if (e->type == 16385U) {
    {
    {
#line 490
    werror("User authentication failed.\n");
    }
    {
#line 491
    tmp = make_protocol_exception((uint32_t )14, (char const   *)((void *)0));
    }
    {
#line 491
    (*(((self->connection)->e)->raise))((self->connection)->e, (struct exception  const  *)tmp);
    }
    }
  }
  {
  {
#line 498
  (*((s->parent)->raise))(s->parent, e);
  }
  }
#line 499
  return;
}
}
#line 501 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct exception_handler *make_exc_userauth_disconnect(struct ssh_connection *connection ,
                                                              struct exception_handler *parent ,
                                                              char const   *context ) 
{ 
  struct exc_userauth_disconnect *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 506
  tmp = lsh_object_alloc(& exc_userauth_disconnect_class);
  }
#line 506
  self = (struct exc_userauth_disconnect *)tmp;
  {
#line 508
  trace("client_userauth.c: make_exc_userauth_disconnect\n");
  }
#line 510
  self->super.parent = parent;
#line 511
  self->super.raise = & do_exc_userauth_disconnect;
#line 512
  self->super.context = context;
#line 514
  self->connection = connection;
  }
#line 515
  return (& self->super);
}
}
#line 518 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void do_client_userauth(struct command *s , struct lsh_object *x , struct command_continuation *c ,
                               struct exception_handler *e ) 
{ 
  struct client_userauth *self ;
  struct ssh_connection *connection ;
  struct client_userauth_state *state ;
  struct client_userauth_state *tmp ;
  struct client_userauth_method *method ;
  struct exception_handler *tmp___0 ;
  struct exception_handler *tmp___1 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 524
  self = (struct client_userauth *)s;
#line 525
  connection = (struct ssh_connection *)x;
  {
#line 527
  tmp = make_client_userauth_state(self, connection);
  }
#line 527
  state = tmp;
  {
#line 530
  trace("client_userauth.c: do_client_userauth\n");
  }
  {
#line 532
  connection->dispatch[52] = make_success_handler(c);
  }
  {
#line 534
  connection->dispatch[51] = make_failure_handler(state);
  }
#line 536
  connection->dispatch[53] = & userauth_banner_handler;
  }
#line 539
  if (! (self->methods)->super.length) {
    {
    {
#line 539
    __assert_fail("((self->methods)->super.length)", "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c",
                  539U, "do_client_userauth");
    }
    }
  }
  {
#line 541
  method = (struct client_userauth_method *)(self->methods)->elements[0];
  {
#line 543
  tmp___0 = make_exc_userauth_disconnect(connection, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c:550");
  }
  {
#line 543
  tmp___1 = make_exc_client_userauth(state, tmp___0, "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c:550");
  }
  {
#line 543
  state->failure = (*(method->login))(method, self, connection, tmp___1);
  }
  }
#line 552
  return;
}
}
#line 555 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
struct command *make_client_userauth(struct lsh_string *username , int service_name ,
                                     struct object_list *methods ) 
{ 
  struct client_userauth *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 560
  tmp = lsh_object_alloc(& client_userauth_class);
  }
#line 560
  self = (struct client_userauth *)tmp;
#line 562
  self->super.call = & do_client_userauth;
  {
#line 563
  self->username = local_to_utf8(username, 1);
  }
#line 564
  self->service_name = service_name;
#line 565
  self->methods = methods;
  }
#line 567
  return (& self->super);
}
}
#line 585
static void do_none_failure(struct client_userauth_failure *s , int again___0 ) ;
#line 585 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct exception  const  need_auth  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "Need real authentication."};
#line 580 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void do_none_failure(struct client_userauth_failure *s , int again___0 ) 
{ 
  struct client_none_state *self ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 583
  self = (struct client_none_state *)s;
  {
#line 588
  trace("client_userauth.c: do_none_failure\n");
  }
  }
#line 590
  if (again___0) {
    {
    {
#line 591
    werror("Odd. Server says we should try the `none\'authentication method again.\n");
    }
    }
  }
  {
  {
#line 593
  (*((self->e)->raise))(self->e, & need_auth);
  }
  }
#line 594
  return;
}
}
#line 596 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct client_userauth_failure *make_client_none_state(struct exception_handler *e ) 
{ 
  struct client_none_state *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 599
  tmp = lsh_object_alloc(& client_none_state_class);
  }
#line 599
  self = (struct client_none_state *)tmp;
  {
#line 601
  trace("client_userauth.c: make_client_none_state\n");
  }
#line 603
  self->super.failure = & do_none_failure;
#line 604
  self->e = e;
  }
#line 606
  return (& self->super);
}
}
#line 609 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct client_userauth_failure *do_none_login(struct client_userauth_method *s  __attribute__((__unused__)) ,
                                                     struct client_userauth *userauth ,
                                                     struct ssh_connection *connection ,
                                                     struct exception_handler *e ) 
{ 
  struct lsh_string *tmp ;
  struct client_userauth_failure *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 615
  verbose("Requesting authentication using the `none\' method.\n");
  }
  {
#line 617
  tmp = format_userauth_none(userauth->username, userauth->service_name);
  }
  {
#line 617
  connection_send(connection, tmp);
  }
  {
#line 621
  tmp___0 = make_client_none_state(e);
  }
  }
#line 621
  return (tmp___0);
}
}
#line 624 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct client_userauth_method client_userauth_none  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, 1, & do_none_login};
#line 628 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
struct client_userauth_method *make_client_none_auth(void) 
{ 


  {
#line 631
  return (& client_userauth_none);
}
}
#line 688
static void send_password(struct client_password_state *state ) ;
#line 688 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct exception  const  no_passwd___0  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "No password supplied."};
#line 652 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void send_password(struct client_password_state *state ) 
{ 
  struct lsh_string *passwd ;
  struct lsh_string *tmp ;
  struct lsh_string *tmp___0 ;
  uint32_t tmp___1 ;
  struct lsh_string *tmp___2 ;
  struct lsh_string *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 655
  tmp = ssh_format("Password for %lS: ", (state->userauth)->username);
  }
  {
#line 655
  tmp___0 = (*((state->tty)->read_password))(state->tty, (uint32_t )100, (struct lsh_string  const  *)tmp);
  }
#line 655
  passwd = tmp___0;
  }
#line 660
  if (passwd) {
    {
    {
#line 663
    tmp___1 = lsh_string_length((struct lsh_string  const  *)passwd);
    }
    }
#line 663
    if (! tmp___1) {
#line 671
      (state->tried_empty_passwd) ++;
    }
    {
    {
#line 674
    verbose("Requesting authentication using the `password\' method.\n");
    }
    {
#line 676
    tmp___2 = local_to_utf8(passwd, 1);
    }
    {
#line 676
    tmp___3 = format_userauth_password((state->userauth)->username, (state->userauth)->service_name,
                                       tmp___2, 1);
    }
    {
#line 676
    connection_send(state->connection, tmp___3);
    }
    }
  } else {
    {
    {
#line 691
    (*((state->e)->raise))(state->e, & no_passwd___0);
    }
    }
  }
#line 693
  return;
}
}
#line 707
static void do_password_failure(struct client_userauth_failure *s , int again___0 ) ;
#line 707 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct exception  const  no_passwd___1  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "No password supplied."};
#line 717 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct exception  const  passwd_not_useful  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "password authentication not useful."};
#line 696 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void do_password_failure(struct client_userauth_failure *s , int again___0 ) 
{ 
  struct client_password_state *self ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 699
  self = (struct client_password_state *)s;
  {
#line 701
  trace("client_userauth.c: do_password_failure\n");
  }
  }
#line 703
  if (again___0) {
#line 705
    if (self->tried_empty_passwd >= 2) {
      {
      {
#line 710
      (*((self->e)->raise))(self->e, & no_passwd___1);
      }
      }
    } else {
      {
      {
#line 713
      send_password(self);
      }
      }
    }
  } else {
    {
    {
#line 720
    (*((self->e)->raise))(self->e, & passwd_not_useful);
    }
    }
  }
#line 722
  return;
}
}
#line 724 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct client_password_state *make_client_password_state(struct client_userauth *userauth ,
                                                                struct interact *tty ,
                                                                struct ssh_connection *connection ,
                                                                struct exception_handler *e ) 
{ 
  struct client_password_state *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 730
  tmp = lsh_object_alloc(& client_password_state_class);
  }
#line 730
  self = (struct client_password_state *)tmp;
  {
#line 732
  trace("client_userauth.c: make_client_password_state\n");
  }
#line 734
  self->super.failure = & do_password_failure;
#line 735
  self->userauth = userauth;
#line 736
  self->tty = tty;
#line 737
  self->tried_empty_passwd = 0;
#line 738
  self->connection = connection;
#line 739
  self->e = e;
  }
#line 741
  return (self);
}
}
#line 754 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct client_userauth_failure *do_password_login(struct client_userauth_method *s ,
                                                         struct client_userauth *userauth ,
                                                         struct ssh_connection *connection ,
                                                         struct exception_handler *e ) 
{ 
  struct client_userauth_interactive_method *self ;
  struct client_password_state *state ;
  struct client_password_state *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 760
  self = (struct client_userauth_interactive_method *)s;
  {
#line 762
  tmp = make_client_password_state(userauth, self->tty, connection, e);
  }
#line 762
  state = tmp;
  {
#line 766
  trace("client_userauth.c: do_password_login\n");
  }
  {
#line 768
  send_password(state);
  }
  }
#line 770
  return (& state->super);
}
}
#line 773 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
struct client_userauth_method *make_client_password_auth(struct interact *tty ) 
{ 
  struct client_userauth_interactive_method *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 776
  tmp = lsh_object_alloc(& client_userauth_interactive_method_class);
  }
#line 776
  self = (struct client_userauth_interactive_method *)tmp;
#line 778
  self->super.type = 48;
#line 779
  self->super.login = & do_password_login;
#line 780
  self->tty = tty;
  }
#line 782
  return (& self->super);
}
}
#line 829
static void client_publickey_next(struct client_publickey_state *state ) ;
#line 829 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct exception  const  publickey_auth_failed  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "Public key userauth failed."};
#line 826 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void client_publickey_next(struct client_publickey_state *state ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 832
  if (state->done < (state->keys)->super.length) {
#line 836
    (state->done) ++;
#line 837
    if (state->done < (state->keys)->super.length) {
#line 840
      return;
    }
#line 843
    (state->connection)->dispatch[60] = & connection_fail_handler;
  } else {
#line 850
    if (! state->pending) {
      {
      {
#line 850
      __assert_fail("state->pending", "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c",
                    850U, "client_publickey_next");
      }
      }
    }
#line 851
    (state->pending) --;
  }
#line 854
  if (! state->pending) {
    {
    {
#line 856
    (*((state->e)->raise))(state->e, & publickey_auth_failed);
    }
    }
  }
#line 857
  return;
}
}
#line 859 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void do_publickey_failure(struct client_userauth_failure *s , int again___0  __attribute__((__unused__)) ) 
{ 
  struct client_publickey_state *self ;

  {
  {
#line 862
  self = (struct client_publickey_state *)s;
  {
#line 867
  client_publickey_next(self);
  }
  }
#line 868
  return;
}
}
#line 870 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct client_publickey_state *make_client_publickey_state(struct client_userauth *userauth ,
                                                                  struct ssh_connection *connection ,
                                                                  struct object_list *keys ,
                                                                  struct exception_handler *e ) 
{ 
  struct client_publickey_state *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 876
  tmp = lsh_object_alloc(& client_publickey_state_class);
  }
#line 876
  self = (struct client_publickey_state *)tmp;
#line 877
  self->super.failure = & do_publickey_failure;
#line 878
  self->userauth = userauth;
#line 879
  self->connection = connection;
#line 880
  self->keys = keys;
#line 881
  self->done = (uint32_t )0;
#line 882
  self->pending = (uint32_t )0;
#line 883
  self->e = e;
  }
#line 885
  return (self);
}
}
#line 895 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void do_userauth_pk_ok(struct packet_handler *s , struct ssh_connection *connection ,
                              struct lsh_string *packet ) 
{ 
  struct userauth_pk_ok_handler *self ;
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  int algorithm ;
  uint32_t keyblob_length ;
  uint8_t const   *keyblob ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct keypair *key ;
  struct lsh_string *request ;
  struct lsh_string *signed_data ;
  uint8_t const   *tmp___1 ;
  uint32_t tmp___2 ;
  struct lsh_string *tmp___3 ;
  int tmp___4 ;
  struct exception *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
  {
#line 900
  self = (struct userauth_pk_ok_handler *)s;
  {
#line 909
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 909
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 909
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 911
  tmp___6 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 911
  if (tmp___6) {
#line 911
    if (msg_number == 60U) {
      {
      {
#line 911
      tmp___7 = parse_atom(& buffer, & algorithm);
      }
      }
#line 911
      if (tmp___7) {
        {
        {
#line 911
        tmp___8 = parse_string(& buffer, & keyblob_length, & keyblob);
        }
        }
#line 911
        if (tmp___8) {
          {
          {
#line 911
          tmp___9 = parse_eod(& buffer);
          }
          }
#line 911
          if (tmp___9) {
            {
#line 917
            key = (struct keypair *)((self->state)->keys)->elements[(self->state)->done];
            {
#line 918
            verbose("SSH_MSG_USERAUTH_PK_OK received\n");
            }
            }
#line 920
            if (key->type == algorithm) {
              {
              {
#line 920
              tmp___4 = lsh_string_eq_l((struct lsh_string  const  *)key->public,
                                        keyblob_length, keyblob);
              }
              }
#line 920
              if (tmp___4) {
                {
                {
#line 926
                verbose("Sending `publickey\' signature.\n");
                }
                {
#line 928
                request = format_userauth_publickey(((self->state)->userauth)->username,
                                                    (uint32_t )((self->state)->userauth)->service_name,
                                                    (uint32_t )key->type, key->public);
                }
                {
#line 933
                signed_data = ssh_format("%S%lS", connection->session_id, request);
                }
                {
#line 934
                tmp___1 = lsh_string_data((struct lsh_string  const  *)signed_data);
                }
                {
#line 934
                tmp___2 = lsh_string_length((struct lsh_string  const  *)signed_data);
                }
                {
#line 934
                tmp___3 = (*((key->private)->sign))(key->private, key->type, tmp___2,
                                                    tmp___1);
                }
                {
#line 934
                request = ssh_format("%flS%fS", request, tmp___3);
                }
                {
#line 939
                lsh_string_free((struct lsh_string  const  *)signed_data);
                }
                {
#line 940
                connection_send(connection, request);
                }
#line 941
                ((self->state)->pending) ++;
                }
              } else {
                {
                {
#line 944
                werror("client_userauth.c: Unexpected key in USERAUTH_PK_OK message.\n");
                }
                }
              }
            } else {
              {
              {
#line 944
              werror("client_userauth.c: Unexpected key in USERAUTH_PK_OK message.\n");
              }
              }
            }
            {
            {
#line 946
            client_publickey_next(self->state);
            }
            }
          } else {
            {
            {
#line 949
            tmp___5 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_PK_OK message");
            }
            {
#line 949
            (*(((self->state)->e)->raise))((self->state)->e, (struct exception  const  *)tmp___5);
            }
            }
          }
        } else {
          {
          {
#line 949
          tmp___5 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_PK_OK message");
          }
          {
#line 949
          (*(((self->state)->e)->raise))((self->state)->e, (struct exception  const  *)tmp___5);
          }
          }
        }
      } else {
        {
        {
#line 949
        tmp___5 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_PK_OK message");
        }
        {
#line 949
        (*(((self->state)->e)->raise))((self->state)->e, (struct exception  const  *)tmp___5);
        }
        }
      }
    } else {
      {
      {
#line 949
      tmp___5 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_PK_OK message");
      }
      {
#line 949
      (*(((self->state)->e)->raise))((self->state)->e, (struct exception  const  *)tmp___5);
      }
      }
    }
  } else {
    {
    {
#line 949
    tmp___5 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_PK_OK message");
    }
    {
#line 949
    (*(((self->state)->e)->raise))((self->state)->e, (struct exception  const  *)tmp___5);
    }
    }
  }
#line 950
  return;
}
}
#line 952 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct packet_handler *make_pk_ok_handler(struct client_publickey_state *state ) 
{ 
  struct userauth_pk_ok_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 955
  tmp = lsh_object_alloc(& userauth_pk_ok_handler_class);
  }
#line 955
  self = (struct userauth_pk_ok_handler *)tmp;
#line 957
  self->super.handler = & do_userauth_pk_ok;
#line 958
  self->state = state;
  }
#line 960
  return (& self->super);
}
}
#line 963 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct client_userauth_failure *do_publickey_login(struct client_userauth_method *s ,
                                                          struct client_userauth *userauth ,
                                                          struct ssh_connection *connection ,
                                                          struct exception_handler *e ) 
{ 
  struct client_publickey_method *self ;
  struct client_publickey_state *state ;
  struct client_publickey_state *tmp ;
  unsigned int i ;
  struct keypair *key ;
  struct lsh_string *tmp___0 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 969
  self = (struct client_publickey_method *)s;
#line 971
  if (! (self->keys)->super.length) {
    {
    {
#line 971
    __assert_fail("((self->keys)->super.length)", "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c",
                  971U, "do_publickey_login");
    }
    }
  }
  {
  {
#line 975
  tmp = make_client_publickey_state(userauth, connection, self->keys, e);
  }
#line 975
  state = tmp;
#line 982
  i = 0U;
  }
  {
  {
#line 982
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 982
    if (! (i < (self->keys)->super.length)) {
#line 982
      goto while_break;
    }
    {
#line 984
    key = (struct keypair *)(self->keys)->elements[i];
    {
#line 986
    verbose("Requesting authentication using the `publickey\' method.\n");
    }
    {
#line 988
    tmp___0 = format_userauth_publickey_query(userauth->username, (uint32_t )userauth->service_name,
                                              (uint32_t )key->type, key->public);
    }
    {
#line 988
    connection_send(connection, tmp___0);
    }
#line 982
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 994
  connection->dispatch[60] = make_pk_ok_handler(state);
  }
  }
#line 995
  return (& state->super);
}
}
#line 999 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
struct client_userauth_method *make_client_publickey_auth(struct object_list *keys ) 
{ 
  struct client_publickey_method *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 1002
  tmp = lsh_object_alloc(& client_publickey_method_class);
  }
#line 1002
  self = (struct client_publickey_method *)tmp;
#line 1004
  self->super.type = 47;
#line 1005
  self->super.login = & do_publickey_login;
#line 1006
  self->keys = keys;
  }
#line 1008
  return (& self->super);
}
}
#line 1087
static void do_userauth_info_request(struct packet_handler *s , struct ssh_connection *connection ,
                                     struct lsh_string *packet ) ;
#line 1087 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct exception  const  bad_info_request  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "Too large USERAUTH_INFO_RQUEST"};
#line 1148 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct exception  const  bad_info_request___0  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "No user response"};
#line 1050 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void do_userauth_info_request(struct packet_handler *s , struct ssh_connection *connection ,
                                     struct lsh_string *packet ) 
{ 
  struct userauth_info_request_handler *self ;
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint8_t const   *name ;
  uint32_t name_length ;
  uint8_t const   *instruction ;
  uint32_t instruction_length ;
  uint8_t const   *language ;
  uint32_t language_length ;
  uint32_t nprompt ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct interact_dialog *dialog ;
  unsigned int i ;
  uint8_t const   *prompt ;
  uint32_t prompt_length ;
  struct lsh_string *s___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct lsh_string *s___1 ;
  int tmp___3 ;
  struct lsh_string *tmp___4 ;
  struct exception *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  void *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 1055
  self = (struct userauth_info_request_handler *)s;
  {
#line 1072
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 1072
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 1072
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 1073
  tmp___6 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 1073
  if (tmp___6) {
#line 1073
    if (msg_number == 60U) {
      {
      {
#line 1073
      tmp___7 = parse_string(& buffer, & name_length, & name);
      }
      }
#line 1073
      if (tmp___7) {
        {
        {
#line 1073
        tmp___8 = parse_string(& buffer, & instruction_length, & instruction);
        }
        }
#line 1073
        if (tmp___8) {
          {
          {
#line 1073
          tmp___9 = parse_string(& buffer, & language_length, & language);
          }
          }
#line 1073
          if (tmp___9) {
            {
            {
#line 1073
            tmp___10 = parse_uint32(& buffer, & nprompt);
            }
            }
#line 1073
            if (tmp___10) {
#line 1083
              if (nprompt > 17U) {
#line 1083
                goto beyond_limit;
              } else
#line 1083
              if (name_length > 200U) {
#line 1083
                goto beyond_limit;
              } else
#line 1083
              if (instruction_length > 2000U) {
                beyond_limit: 
                {
                {
#line 1091
                (*(((self->state)->e)->raise))((self->state)->e, & bad_info_request);
                }
                }
#line 1092
                return;
              }
              {
              {
#line 1095
              dialog = make_interact_dialog(nprompt);
              }
#line 1097
              i = 0U;
              }
              {
              {
#line 1097
              while (1) {
                while_continue___0: /* CIL Label */ ;
                while_continue: /* CIL Label */ ;

#line 1097
                if (! (i < nprompt)) {
#line 1097
                  goto while_break;
                }
                {
                {
#line 1103
                tmp___1 = parse_string(& buffer, & prompt_length, & prompt);
                }
                }
#line 1103
                if (tmp___1) {
                  {
                  {
#line 1103
                  tmp___2 = parse_boolean(& buffer, dialog->echo + i);
                  }
                  }
#line 1103
                  if (! tmp___2) {
                    {
                    {
#line 1106
                    gc_kill((struct lsh_object *)dialog);
                    }
                    }
#line 1107
                    goto error;
                  }
                } else {
                  {
                  {
#line 1106
                  gc_kill((struct lsh_object *)dialog);
                  }
                  }
#line 1107
                  goto error;
                }
#line 1110
                if (prompt_length > 200U) {
                  {
                  {
#line 1112
                  gc_kill((struct lsh_object *)dialog);
                  }
                  }
#line 1113
                  goto beyond_limit;
                }
                {
                {
#line 1115
                s___0 = low_utf8_to_local(prompt_length, prompt, (enum utf8_flag )3);
                }
                }
#line 1117
                if (! s___0) {
#line 1118
                  goto error;
                }
#line 1120
                *(dialog->prompt + i) = s___0;
#line 1097
                i ++;
              }
              while_break___1: /* CIL Label */ ;
              }
              while_break___0: /* CIL Label */ ;
              }
              while_break: 
              {
              {
#line 1123
              dialog->instruction = low_utf8_to_local(instruction_length, instruction,
                                                      (enum utf8_flag )3);
              }
              }
#line 1127
              if (! dialog->instruction) {
#line 1128
                goto error;
              }
#line 1130
              if (name_length > 0U) {
                {
                {
#line 1135
                s___1 = low_utf8_to_local(name_length, name, (enum utf8_flag )3);
                }
                }
#line 1137
                if (! s___1) {
#line 1138
                  goto error;
                }
                {
                {
#line 1140
                dialog->instruction = ssh_format("%lfS\n\n%lfS\n", s___1, dialog->instruction);
                }
                }
              } else {
                {
                {
#line 1144
                dialog->instruction = ssh_format("%lfS\n", dialog->instruction);
                }
                }
              }
              {
              {
#line 1146
              tmp___3 = (*(((self->state)->tty)->dialog))((self->state)->tty, (struct interact_dialog  const  *)dialog);
              }
              }
#line 1146
              if (! tmp___3) {
                {
                {
#line 1151
                (*(((self->state)->e)->raise))((self->state)->e, & bad_info_request___0);
                }
                }
#line 1152
                return;
              }
              {
              {
#line 1155
              tmp___4 = format_userauth_info_response(dialog);
              }
              {
#line 1155
              connection_send(connection, tmp___4);
              }
              {
#line 1156
              gc_kill((struct lsh_object *)dialog);
              }
              }
#line 1157
              return;
            } else {
#line 1073
              goto error;
            }
          } else {
#line 1073
            goto error;
          }
        } else {
#line 1073
          goto error;
        }
      } else {
#line 1073
        goto error;
      }
    } else {
#line 1073
      goto error;
    }
  } else {
    error: 
    {
    {
#line 1162
    tmp___5 = make_protocol_exception((uint32_t )2, "Invalid USERAUTH_INFO_REQUEST message");
    }
    {
#line 1162
    (*(((self->state)->e)->raise))((self->state)->e, (struct exception  const  *)tmp___5);
    }
    }
  }
#line 1164
  return;
}
}
#line 1166 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct packet_handler *make_userauth_info_request_handler(struct client_kbdinteract_state *state ) 
{ 
  struct userauth_info_request_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 1169
  tmp = lsh_object_alloc(& userauth_info_request_handler_class);
  }
#line 1169
  self = (struct userauth_info_request_handler *)tmp;
#line 1170
  self->super.handler = & do_userauth_info_request;
#line 1171
  self->state = state;
  }
#line 1173
  return (& self->super);
}
}
#line 1183
static void do_kbdinteract_failure(struct client_userauth_failure *s , int again___0  __attribute__((__unused__)) ) ;
#line 1183 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct exception  const  kbdinteract_fail  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )16385, "keyboard-interact authentication failed."};
#line 1176 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static void do_kbdinteract_failure(struct client_userauth_failure *s , int again___0  __attribute__((__unused__)) ) 
{ 
  struct client_kbdinteract_state *self ;

  {
  {
#line 1179
  self = (struct client_kbdinteract_state *)s;
  {
#line 1186
  (*((self->e)->raise))(self->e, & kbdinteract_fail);
  }
  }
#line 1187
  return;
}
}
#line 1189 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct client_kbdinteract_state *make_client_kbdinteract_state(struct interact *tty ,
                                                                      struct ssh_connection *connection ,
                                                                      struct exception_handler *e ) 
{ 
  struct client_kbdinteract_state *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 1194
  tmp = lsh_object_alloc(& client_kbdinteract_state_class);
  }
#line 1194
  self = (struct client_kbdinteract_state *)tmp;
#line 1195
  self->super.failure = & do_kbdinteract_failure;
#line 1196
  self->tty = tty;
#line 1197
  self->connection = connection;
#line 1198
  self->e = e;
  }
#line 1200
  return (self);
}
}
#line 1203 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
static struct client_userauth_failure *do_kbdinteract_login(struct client_userauth_method *s ,
                                                            struct client_userauth *userauth ,
                                                            struct ssh_connection *connection ,
                                                            struct exception_handler *e ) 
{ 
  struct client_userauth_interactive_method *self ;
  struct client_kbdinteract_state *state ;
  struct client_kbdinteract_state *tmp ;
  struct lsh_string *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 1209
  self = (struct client_userauth_interactive_method *)s;
  {
#line 1210
  tmp = make_client_kbdinteract_state(self->tty, connection, e);
  }
#line 1210
  state = tmp;
  {
#line 1213
  verbose("Requesting authentication using the `keyboard-interactive\' method.\n");
  }
  {
#line 1215
  tmp___0 = format_userauth_kbdinteract(userauth->username, (uint32_t )userauth->service_name);
  }
  {
#line 1215
  connection_send(connection, tmp___0);
  }
  {
#line 1218
  connection->dispatch[60] = make_userauth_info_request_handler(state);
  }
  }
#line 1221
  return (& state->super);
}
}
#line 1224 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_userauth.c"
struct client_userauth_method *make_client_kbdinteract_auth(struct interact *tty ) 
{ 
  struct client_userauth_interactive_method *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 1227
  tmp = lsh_object_alloc(& client_userauth_interactive_method_class);
  }
#line 1227
  self = (struct client_userauth_interactive_method *)tmp;
#line 1229
  self->super.type = 50;
#line 1230
  self->super.login = & do_kbdinteract_login;
#line 1231
  self->tty = tty;
  }
#line 1233
  return (& self->super);
}
}
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.h"
struct alist *make_linear_alist(unsigned int n  , ...) ;
#line 359 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h"
struct abstract_write *make_channel_write(struct ssh_channel *channel ) ;
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h"
struct abstract_write *make_handle_escape(struct escape_info *info , struct abstract_write *next ) ;
#line 89
struct channel_request *make_handle_exit_status(int *exit_status ) ;
#line 90
struct channel_request *make_handle_exit_signal(int *exit_status ) ;
#line 98
struct command client_io ;
#line 101
struct ssh_channel *make_client_session_channel(struct lsh_fd *in , struct lsh_fd *out ,
                                                struct lsh_fd *err , struct escape_info *escape ,
                                                uint32_t initial_window , int *exit_status ) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c.x"
struct lsh_class client_session_channel_class ;
#line 18 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c.x"
static void do_client_session_channel_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_session_channel *i ;

  {
  {
#line 22
  i = (struct client_session_channel *)o;
  {
#line 23
  (*mark)((struct lsh_object *)i->in);
  }
  {
#line 24
  (*mark)((struct lsh_object *)i->out);
  }
  {
#line 25
  (*mark)((struct lsh_object *)i->err);
  }
  {
#line 26
  (*mark)((struct lsh_object *)i->escape);
  }
  }
#line 27
  return;
}
}
#line 28 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c.x"
struct lsh_class client_session_channel_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & ssh_channel_class, (char *)"client_session_channel", (size_t )sizeof(struct client_session_channel ),
    & do_client_session_channel_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 61 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c"
static void do_client_session_eof(struct ssh_channel *c ) 
{ 
  struct client_session_channel *session ;

  {
  {
#line 64
  session = (struct client_session_channel *)c;
  {
#line 66
  close_fd_nicely(session->out);
  }
  {
#line 67
  close_fd_nicely(session->err);
  }
  }
#line 68
  return;
}
}
#line 73
static void do_client_session_close(struct ssh_channel *c ) ;
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c"
static struct exception  const  finish_exception  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )65540, "Session closed."};
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c"
static void do_client_session_close(struct ssh_channel *c ) 
{ 


  {
  {
  {
#line 76
  (*((c->e)->raise))(c->e, & finish_exception);
  }
  }
#line 77
  return;
}
}
#line 81 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c"
static void do_receive___1(struct ssh_channel *c , int type , struct lsh_string *data ) 
{ 
  struct client_session_channel *closure ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 85
  closure = (struct client_session_channel *)c;
#line 89
  if (type == 0) {
#line 89
    goto case_0;
  }
#line 92
  if (type == 1) {
#line 92
    goto case_1;
  }
#line 95
  goto switch_default;
  case_0: 
  {
  {
#line 90
  (*(((closure->out)->write_buffer)->super.write))(& ((closure->out)->write_buffer)->super,
                                                   data);
  }
  }
#line 91
  goto switch_break;
  case_1: 
  {
  {
#line 93
  (*(((closure->err)->write_buffer)->super.write))(& ((closure->err)->write_buffer)->super,
                                                   data);
  }
  }
#line 94
  goto switch_break;
  switch_default: 
  {
  {
#line 96
  fatal("Internal error!\n");
  }
  }
  switch_break: ;
#line 98
  return;
}
}
#line 101 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c"
static void do_send_adjust___1(struct ssh_channel *s , uint32_t i  __attribute__((__unused__)) ) 
{ 
  struct client_session_channel *self ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 105
  self = (struct client_session_channel *)s;
#line 107
  if (! (self->in)->read) {
    {
    {
#line 107
    __assert_fail("self->in->read", "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c",
                  107U, "do_send_adjust");
    }
    }
  }
  {
  {
#line 109
  lsh_oop_register_read_fd(self->in);
  }
  }
#line 110
  return;
}
}
#line 114 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c"
static struct io_callback *client_read_stdin(struct client_session_channel *session ) 
{ 
  struct abstract_write *write___0 ;
  struct abstract_write *tmp ;
  struct io_callback *tmp___0 ;

  {
  {
  {
#line 117
  tmp = make_channel_write(& session->super);
  }
#line 117
  write___0 = tmp;
  }
#line 119
  if (session->escape) {
    {
    {
#line 120
    write___0 = make_handle_escape(session->escape, write___0);
    }
    }
  }
  {
  {
#line 122
  tmp___0 = make_read_data(& session->super, write___0);
  }
  }
#line 122
  return (tmp___0);
}
}
#line 126 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c"
static void do_client_io(struct command *s  __attribute__((__unused__)) , struct lsh_object *x ,
                         struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct client_session_channel *session ;
  struct ssh_channel *channel ;
  struct channel_request *tmp ;
  struct channel_request *tmp___0 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 133
  session = (struct client_session_channel *)x;
#line 134
  channel = & session->super;
#line 135
  if (! x) {
    {
    {
#line 135
    __assert_fail("x", "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c",
                  135U, "do_client_io");
    }
    }
  }
  {
#line 139
  channel->receive = & do_receive___1;
  {
#line 145
  (session->out)->e = make_channel_io_exception_handler(channel, "stdout: ", 0, (session->out)->e,
                                                        "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c:149");
  }
  {
#line 151
  (session->err)->e = make_channel_io_exception_handler(channel, "stderr: ", 0, (session->err)->e,
                                                        "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c:155");
  }
#line 158
  channel->send_adjust = & do_send_adjust___1;
  {
#line 161
  (session->in)->read = client_read_stdin(session);
  }
  }
#line 165
  if (session->super.send_window_size) {
    {
    {
#line 166
    lsh_oop_register_read_fd(session->in);
    }
    }
  }
  {
  {
#line 170
  (session->in)->close_callback = make_channel_read_close_callback(channel);
  }
  {
#line 174
  remember_resource(channel->resources, & (session->in)->super);
  }
  {
#line 175
  remember_resource(channel->resources, & (session->out)->super);
  }
  {
#line 176
  remember_resource(channel->resources, & (session->err)->super);
  }
  {
#line 178
  tmp = make_handle_exit_status(session->exit_status);
  }
  {
#line 178
  (*(((struct alist_meta *)(channel->request_types)->super.isa)->set))(channel->request_types,
                                                                       65, & tmp->super);
  }
  {
#line 180
  tmp___0 = make_handle_exit_signal(session->exit_status);
  }
  {
#line 180
  (*(((struct alist_meta *)(channel->request_types)->super.isa)->set))(channel->request_types,
                                                                       66, & tmp___0->super);
  }
#line 183
  channel->eof = & do_client_session_eof;
  {
#line 185
  (*(c->c))(c, (struct lsh_object *)channel);
  }
  }
#line 186
  return;
}
}
#line 188 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c"
struct command client_io  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_client_io};
#line 192 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_session.c"
struct ssh_channel *make_client_session_channel(struct lsh_fd *in , struct lsh_fd *out ,
                                                struct lsh_fd *err , struct escape_info *escape ,
                                                uint32_t initial_window , int *exit_status ) 
{ 
  struct client_session_channel *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 200
  tmp = lsh_object_alloc(& client_session_channel_class);
  }
#line 200
  self = (struct client_session_channel *)tmp;
  {
#line 202
  trace("make_client_session_channel\n");
  }
  {
#line 203
  init_channel(& self->super);
  }
#line 207
  self->super.close = & do_client_session_close;
#line 214
  self->super.flags &= -17;
#line 220
  self->super.rec_window_size = initial_window;
#line 223
  self->super.rec_max_packet = (uint32_t )32768;
  {
#line 225
  self->super.request_types = make_linear_alist(0U, -1);
  }
#line 228
  self->in = in;
#line 229
  self->out = out;
#line 230
  self->err = err;
#line 231
  self->escape = escape;
  {
#line 238
  remember_resource(self->super.resources, & in->super);
  }
  {
#line 239
  remember_resource(self->super.resources, & out->super);
  }
  {
#line 240
  remember_resource(self->super.resources, & err->super);
  }
#line 243
  (out->write_buffer)->report = & self->super.super;
#line 244
  (err->write_buffer)->report = & self->super.super;
#line 246
  self->exit_status = exit_status;
  }
#line 248
  return (& self->super);
}
}
#line 112 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h"
struct command *make_pty_request(struct interact *tty ) ;
#line 13 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
struct lsh_class pty_request_class ;
#line 17 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
static void do_pty_request_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct pty_request *i ;

  {
  {
#line 21
  i = (struct pty_request *)o;
  {
#line 22
  (*mark)((struct lsh_object *)i->tty);
  }
  {
#line 23
  (*mark)((struct lsh_object *)i->attr);
  }
  }
#line 24
  return;
}
}
#line 25 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
static void do_pty_request_free(struct lsh_object *o ) 
{ 
  struct pty_request *i ;

  {
  {
#line 28
  i = (struct pty_request *)o;
  {
#line 29
  lsh_string_free((struct lsh_string  const  *)i->term);
  }
  }
#line 30
  return;
}
}
#line 31 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
struct lsh_class pty_request_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_request_command_class, (char *)"pty_request", (size_t )sizeof(struct pty_request ),
    & do_pty_request_mark, & do_pty_request_free};
#line 52
struct lsh_class client_tty_resource_class ;
#line 56 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
static void do_client_tty_resource_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_tty_resource *i ;

  {
  {
#line 60
  i = (struct client_tty_resource *)o;
  {
#line 61
  (*mark)((struct lsh_object *)i->tty);
  }
  {
#line 62
  (*mark)((struct lsh_object *)i->attr);
  }
  }
#line 63
  return;
}
}
#line 64 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
struct lsh_class client_tty_resource_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & resource_class, (char *)"client_tty_resource", (size_t )sizeof(struct client_tty_resource ),
    & do_client_tty_resource_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 84
struct lsh_class client_winch_handler_class ;
#line 88 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
static void do_client_winch_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_winch_handler *i ;

  {
  {
#line 92
  i = (struct client_winch_handler *)o;
  {
#line 93
  (*mark)((struct lsh_object *)i->channel);
  }
  }
#line 94
  return;
}
}
#line 95 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
struct lsh_class client_winch_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & window_change_callback_class, (char *)"client_winch_handler", (size_t )sizeof(struct client_winch_handler ),
    & do_client_winch_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 115
struct lsh_class pty_request_continuation_class ;
#line 119 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
static void do_pty_request_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct pty_request_continuation *i ;

  {
  {
#line 123
  i = (struct pty_request_continuation *)o;
  {
#line 124
  (*mark)((struct lsh_object *)i->req);
  }
  }
#line 125
  return;
}
}
#line 126 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c.x"
struct lsh_class pty_request_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_frame_class, (char *)"pty_request_continuation", (size_t )sizeof(struct pty_request_continuation ),
    & do_pty_request_continuation_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c"
static void do_kill_client_tty_resource(struct resource *s ) 
{ 
  struct client_tty_resource *self ;

  {
  {
#line 65
  self = (struct client_tty_resource *)s;
#line 66
  self->super.alive = 0;
  {
#line 67
  (*((self->tty)->set_attributes))(self->tty, self->attr);
  }
  {
#line 69
  set_error_raw(0);
  }
  }
#line 70
  return;
}
}
#line 72 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c"
static struct resource *make_client_tty_resource(struct interact *tty , struct terminal_attributes *attr ) 
{ 
  struct client_tty_resource *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 76
  tmp = lsh_object_alloc(& client_tty_resource_class);
  }
#line 76
  self = (struct client_tty_resource *)tmp;
  {
#line 77
  init_resource(& self->super, & do_kill_client_tty_resource);
  }
#line 79
  self->tty = tty;
#line 80
  self->attr = attr;
  }
#line 82
  return (& self->super);
}
}
#line 93 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c"
static struct lsh_string *format_window_change(struct ssh_channel *channel , struct terminal_dimensions *dims ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 97
  tmp = format_channel_request(62, channel, 0, "%i%i%i%i", dims->char_width, dims->char_height,
                               dims->pixel_width, dims->pixel_height);
  }
  }
#line 97
  return (tmp);
}
}
#line 104 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c"
static void do_client_winch_handler(struct window_change_callback *s , struct interact *tty ) 
{ 
  struct client_winch_handler *self ;
  struct terminal_dimensions dims ;
  int tmp ;
  struct lsh_string *tmp___0 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 108
  self = (struct client_winch_handler *)s;
  {
#line 111
  tmp = (*(tty->window_size))(tty, & dims);
  }
  }
#line 111
  if (! tmp) {
#line 112
    return;
  }
  {
  {
#line 114
  tmp___0 = format_window_change(self->channel, & dims);
  }
  {
#line 114
  connection_send((self->channel)->connection, tmp___0);
  }
  }
#line 116
  return;
}
}
#line 118 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c"
static struct window_change_callback *make_client_winch_handler(struct ssh_channel *channel ) 
{ 
  struct client_winch_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 121
  tmp = lsh_object_alloc(& client_winch_handler_class);
  }
#line 121
  self = (struct client_winch_handler *)tmp;
#line 122
  self->super.f = & do_client_winch_handler;
#line 123
  self->channel = channel;
  }
#line 125
  return (& self->super);
}
}
#line 138 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c"
static void do_pty_continuation(struct command_continuation *s , struct lsh_object *x ) 
{ 
  struct pty_request_continuation *self ;
  struct ssh_channel *channel ;
  struct terminal_attributes *raw ;
  int tmp ;
  struct resource *tmp___0 ;
  struct window_change_callback *tmp___1 ;
  struct resource *tmp___2 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 142
  self = (struct pty_request_continuation *)s;
#line 143
  channel = (struct ssh_channel *)x;
#line 146
  if (! x) {
    {
    {
#line 146
    __assert_fail("x", "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c", 146U,
                  "do_pty_continuation");
    }
    }
  }
  {
  {
#line 147
  verbose("pty request succeeded\n");
  }
  {
#line 149
  raw = (*(((self->req)->attr)->make_raw))((self->req)->attr);
  }
  {
#line 150
  tmp = (*(((self->req)->tty)->set_attributes))((self->req)->tty, raw);
  }
  }
#line 150
  if (! tmp) {
    {
    {
#line 152
    werror("do_pty_continuation: Setting the attributes of the local terminal failed.\n");
    }
    }
  }
  {
  {
#line 157
  set_error_raw(1);
  }
  {
#line 159
  tmp___0 = make_client_tty_resource((self->req)->tty, (self->req)->attr);
  }
  {
#line 159
  remember_resource(channel->resources, tmp___0);
  }
  {
#line 163
  tmp___1 = make_client_winch_handler(channel);
  }
  {
#line 163
  tmp___2 = (*(((self->req)->tty)->window_change_subscribe))((self->req)->tty, tmp___1);
  }
  {
#line 163
  remember_resource(channel->resources, tmp___2);
  }
  {
#line 168
  (*((self->super.up)->c))(self->super.up, x);
  }
  }
#line 169
  return;
}
}
#line 171 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c"
static struct command_continuation *make_pty_continuation(struct pty_request *req ,
                                                          struct command_continuation *c ) 
{ 
  struct pty_request_continuation *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 175
  tmp = lsh_object_alloc(& pty_request_continuation_class);
  }
#line 175
  self = (struct pty_request_continuation *)tmp;
#line 176
  self->req = req;
#line 177
  self->super.up = c;
#line 178
  self->super.super.c = & do_pty_continuation;
  }
#line 180
  return (& self->super.super);
}
}
#line 183 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c"
static struct lsh_string *do_format_pty_request(struct channel_request_command *s ,
                                                struct ssh_channel *channel , struct command_continuation **c ) 
{ 
  struct pty_request *self ;
  struct lsh_string *tmp ;
  struct lsh_string *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 188
  self = (struct pty_request *)s;
  {
#line 190
  verbose("Requesting a remote pty.\n");
  }
  {
#line 192
  *c = make_pty_continuation(self, *c);
  }
  {
#line 194
  tmp = (*((self->attr)->encode))(self->attr);
  }
  {
#line 194
  tmp___0 = format_channel_request(53, channel, 1, "%S%i%i%i%i%fS", self->term, self->dims.char_width,
                                   self->dims.char_height, self->dims.pixel_width,
                                   self->dims.pixel_height, tmp);
  }
  }
#line 194
  return (tmp___0);
}
}
#line 203 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_pty.c"
struct command *make_pty_request(struct interact *tty ) 
{ 
  struct pty_request *req ;
  struct lsh_object *tmp ;
  char *term ;
  char *tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;
  struct lsh_string *tmp___5 ;
  struct lsh_string *tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
  {
#line 206
  tmp = lsh_object_alloc(& pty_request_class);
  }
#line 206
  req = (struct pty_request *)tmp;
  {
#line 207
  tmp___0 = getenv("TERM");
  }
#line 207
  term = tmp___0;
  {
#line 209
  req->attr = (*(tty->get_attributes))(tty);
  }
  }
#line 211
  if (! req->attr) {
    {
    {
#line 213
    gc_kill((struct lsh_object *)req);
    }
    }
#line 214
    return ((struct command *)((void *)0));
  }
  {
  {
#line 217
  tmp___4 = (*(tty->window_size))(tty, & req->dims);
  }
  }
#line 217
  if (! tmp___4) {
#line 218
    tmp___3 = (uint32_t )0;
#line 218
    req->dims.pixel_height = tmp___3;
#line 218
    tmp___2 = tmp___3;
#line 218
    req->dims.pixel_width = tmp___2;
#line 218
    tmp___1 = tmp___2;
#line 218
    req->dims.char_height = tmp___1;
#line 218
    req->dims.char_width = tmp___1;
  }
#line 221
  req->super.super.call = & do_channel_request_command;
#line 222
  req->super.format_request = & do_format_pty_request;
#line 224
  req->tty = tty;
#line 225
  if (term) {
    {
    {
#line 225
    tmp___5 = ssh_format("%lz", term);
    }
#line 225
    req->term = tmp___5;
    }
  } else {
    {
    {
#line 225
    tmp___6 = ssh_format("");
    }
#line 225
    req->term = tmp___6;
    }
  }
#line 227
  return (& req->super.super);
}
}
#line 33 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.h"
struct keyexchange_algorithm *make_dh_client(struct dh_method  const  *dh ) ;
#line 36
struct keyexchange_algorithm *make_srp_client(struct dh_method  const  *dh , struct interact *tty ,
                                              struct lsh_string *name ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
struct lsh_class dh_client_exchange_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
static void do_dh_client_exchange_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct dh_client_exchange *i ;

  {
  {
#line 18
  i = (struct dh_client_exchange *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->dh);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
struct lsh_class dh_client_exchange_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & keyexchange_algorithm_class, (char *)"dh_client_exchange", (size_t )sizeof(struct dh_client_exchange ),
    & do_dh_client_exchange_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 44
struct lsh_class dh_client_class ;
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
static void do_dh_client_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct dh_client *i ;

  {
  {
#line 52
  i = (struct dh_client *)o;
  {
#line 53
  dh_instance_mark(& i->dh, mark);
  }
  {
#line 55
  (*mark)((struct lsh_object *)i->verifier);
  }
  {
#line 56
  (*mark)((struct lsh_object *)i->algorithms);
  }
  }
#line 57
  return;
}
}
#line 58 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
static void do_dh_client_free(struct lsh_object *o ) 
{ 
  struct dh_client *i ;

  {
  {
#line 61
  i = (struct dh_client *)o;
  {
#line 62
  dh_instance_free(& i->dh);
  }
  }
#line 63
  return;
}
}
#line 64 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
struct lsh_class dh_client_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & packet_handler_class, (char *)"dh_client", (size_t )sizeof(struct dh_client ),
    & do_dh_client_mark, & do_dh_client_free};
#line 88
struct lsh_class srp_client_instance_class ;
#line 92 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
static void do_srp_client_instance_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct srp_client_instance *i ;

  {
  {
#line 96
  i = (struct srp_client_instance *)o;
  {
#line 97
  dh_instance_mark(& i->dh, mark);
  }
  {
#line 99
  (*mark)((struct lsh_object *)i->tty);
  }
  {
#line 100
  (*mark)((struct lsh_object *)i->algorithms);
  }
  }
#line 101
  return;
}
}
#line 102 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
static void do_srp_client_instance_free(struct lsh_object *o ) 
{ 
  struct srp_client_instance *i ;

  {
  {
#line 105
  i = (struct srp_client_instance *)o;
  {
#line 106
  dh_instance_free(& i->dh);
  }
  {
#line 107
  lsh_string_free((struct lsh_string  const  *)i->name);
  }
  {
#line 108
  lsh_string_free((struct lsh_string  const  *)i->m2);
  }
  }
#line 109
  return;
}
}
#line 110 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
struct lsh_class srp_client_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"srp_client_instance", (size_t )sizeof(struct srp_client_instance ),
    & do_srp_client_instance_mark, & do_srp_client_instance_free};
#line 130
struct lsh_class srp_client_handler_class ;
#line 134 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
static void do_srp_client_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct srp_client_handler *i ;

  {
  {
#line 138
  i = (struct srp_client_handler *)o;
  {
#line 139
  (*mark)((struct lsh_object *)i->srp);
  }
  }
#line 140
  return;
}
}
#line 141 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
struct lsh_class srp_client_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & packet_handler_class, (char *)"srp_client_handler", (size_t )sizeof(struct srp_client_handler ),
    & do_srp_client_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 163
struct lsh_class srp_client_exchange_class ;
#line 167 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
static void do_srp_client_exchange_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct srp_client_exchange *i ;

  {
  {
#line 171
  i = (struct srp_client_exchange *)o;
  {
#line 172
  (*mark)((struct lsh_object *)i->dh);
  }
  {
#line 173
  (*mark)((struct lsh_object *)i->tty);
  }
  }
#line 174
  return;
}
}
#line 175 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
static void do_srp_client_exchange_free(struct lsh_object *o ) 
{ 
  struct srp_client_exchange *i ;

  {
  {
#line 178
  i = (struct srp_client_exchange *)o;
  {
#line 179
  lsh_string_free((struct lsh_string  const  *)i->name);
  }
  }
#line 180
  return;
}
}
#line 181 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c.x"
struct lsh_class srp_client_exchange_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & keyexchange_algorithm_class, (char *)"srp_client_exchange", (size_t )sizeof(struct srp_client_exchange ),
    & do_srp_client_exchange_mark, & do_srp_client_exchange_free};
#line 64 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c"
static void do_handle_dh_reply(struct packet_handler *c , struct ssh_connection *connection ,
                               struct lsh_string *packet ) 
{ 
  struct dh_client *closure ;
  struct lsh_string *server_key ;
  struct lsh_string *signature ;
  struct verifier *v ;
  int res ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  uint8_t const   *tmp___1 ;
  uint32_t tmp___2 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 69
  closure = (struct dh_client *)c;
  {
#line 75
  trace("handle_dh_reply\n");
  }
  {
#line 77
  server_key = dh_process_server_msg(& closure->dh, & signature, packet);
  }
  }
#line 79
  if (! server_key) {
    {
    {
#line 81
    disconnect_kex_failed(connection, "Bad dh-reply\r\n");
    }
    }
#line 82
    return;
  }
  {
  {
#line 85
  v = (*((closure->verifier)->lookup))(closure->verifier, closure->hostkey_algorithm,
                                       (struct lsh_user *)((void *)0), server_key);
  }
  {
#line 87
  lsh_string_free((struct lsh_string  const  *)server_key);
  }
  }
#line 89
  if (! v) {
    {
    {
#line 92
    disconnect_kex_failed(connection, "Bad server host key\r\n");
    }
    {
#line 93
    lsh_string_free((struct lsh_string  const  *)signature);
    }
    }
#line 94
    return;
  }
  {
  {
#line 97
  tmp = lsh_string_data((struct lsh_string  const  *)signature);
  }
  {
#line 97
  tmp___0 = lsh_string_length((struct lsh_string  const  *)signature);
  }
  {
#line 97
  tmp___1 = lsh_string_data((struct lsh_string  const  *)closure->dh.exchange_hash);
  }
  {
#line 97
  tmp___2 = lsh_string_length((struct lsh_string  const  *)closure->dh.exchange_hash);
  }
  {
#line 97
  res = (*(v->verify))(v, closure->hostkey_algorithm, tmp___2, tmp___1, tmp___0, tmp);
  }
  {
#line 101
  lsh_string_free((struct lsh_string  const  *)signature);
  }
  }
#line 103
  if (! res) {
    {
    {
#line 105
    werror("Invalid server signature. Disconnecting.\n");
    }
    {
#line 107
    disconnect_kex_failed(connection, "Invalid server signature\r\n");
    }
    }
#line 108
    return;
  }
  {
#line 113
  connection->dispatch[31] = & connection_fail_handler;
  {
#line 115
  keyexchange_finish(connection, closure->algorithms, (struct hash_algorithm  const  *)(closure->dh.method)->H,
                     closure->dh.exchange_hash, closure->dh.K);
  }
#line 121
  closure->dh.K = (struct lsh_string *)((void *)0);
#line 122
  closure->dh.exchange_hash = (struct lsh_string *)((void *)0);
  }
#line 123
  return;
}
}
#line 125 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c"
static void do_init_client_dh(struct keyexchange_algorithm *c , struct ssh_connection *connection ,
                              int hostkey_algorithm_atom , struct lsh_object *extra ,
                              struct object_list *algorithms ) 
{ 
  struct dh_client_exchange *closure ;
  struct lookup_verifier *verifier ;
  struct dh_client *dh ;
  struct lsh_object *tmp ;
  struct lsh_string *tmp___0 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 132
  closure = (struct dh_client_exchange *)c;
#line 133
  verifier = (struct lookup_verifier *)extra;
  {
#line 135
  tmp = lsh_object_alloc(& dh_client_class);
  }
#line 135
  dh = (struct dh_client *)tmp;
  }
#line 137
  if (! verifier) {
    {
    {
#line 137
    __assert_fail("verifier", "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c",
                  137U, "do_init_client_dh");
    }
    }
  }
  {
#line 140
  dh->super.handler = & do_handle_dh_reply;
  {
#line 141
  init_dh_instance(closure->dh, & dh->dh, connection);
  }
#line 143
  dh->verifier = verifier;
#line 144
  dh->hostkey_algorithm = hostkey_algorithm_atom;
#line 146
  dh->algorithms = algorithms;
  {
#line 149
  tmp___0 = dh_make_client_msg(& dh->dh);
  }
  {
#line 149
  connection_send_kex(connection, tmp___0);
  }
#line 152
  connection->dispatch[31] = & dh->super;
  }
#line 153
  return;
}
}
#line 156 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c"
struct keyexchange_algorithm *make_dh_client(struct dh_method  const  *dh ) 
{ 
  struct dh_client_exchange *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 159
  tmp = lsh_object_alloc(& dh_client_exchange_class);
  }
#line 159
  self = (struct dh_client_exchange *)tmp;
#line 161
  self->super.init = & do_init_client_dh;
#line 162
  self->dh = dh;
  }
#line 164
  return (& self->super);
}
}
#line 190 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c"
static void do_srp_client_proof_handler(struct packet_handler *s , struct ssh_connection *connection ,
                                        struct lsh_string *packet ) 
{ 
  struct srp_client_handler *self ;
  int res ;
  int tmp ;
  struct exception *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 195
  self = (struct srp_client_handler *)s;
  {
#line 197
  tmp = srp_process_server_proof((self->srp)->m2, packet);
  }
#line 197
  res = tmp;
#line 200
  connection->dispatch[32] = & connection_fail_handler;
  }
#line 202
  if (res) {
    {
#line 204
    connection->flags = (enum connection_flag )((unsigned int )connection->flags | 2U);
    {
#line 206
    keyexchange_finish(connection, (self->srp)->algorithms, (struct hash_algorithm  const  *)((self->srp)->dh.method)->H,
                       (self->srp)->dh.exchange_hash, (self->srp)->dh.K);
    }
#line 212
    (self->srp)->dh.K = (struct lsh_string *)((void *)0);
#line 213
    (self->srp)->dh.exchange_hash = (struct lsh_string *)((void *)0);
    }
  } else {
    {
    {
#line 216
    tmp___0 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_KEXSRP_PROOF message");
    }
    {
#line 216
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___0);
    }
    }
  }
  {
  {
#line 219
  gc_kill((struct lsh_object *)self->srp);
  }
  {
#line 220
  gc_kill((struct lsh_object *)self);
  }
  }
#line 221
  return;
}
}
#line 223 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c"
static struct packet_handler *make_srp_client_proof_handler(struct srp_client_instance *srp ) 
{ 
  struct srp_client_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 226
  tmp = lsh_object_alloc(& srp_client_handler_class);
  }
#line 226
  self = (struct srp_client_handler *)tmp;
#line 227
  self->super.handler = & do_srp_client_proof_handler;
#line 228
  self->srp = srp;
  }
#line 230
  return (& self->super);
}
}
#line 235 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c"
static void do_handle_srp_reply(struct packet_handler *s , struct ssh_connection *connection ,
                                struct lsh_string *packet ) 
{ 
  struct srp_client_handler *self ;
  struct lsh_string *salt ;
  struct lsh_string *tmp ;
  struct lsh_string *passwd ;
  struct lsh_string *response ;
  mpz_t x ;
  struct exception *tmp___0 ;
  struct lsh_string *tmp___1 ;
  struct exception *tmp___2 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 240
  self = (struct srp_client_handler *)s;
  {
#line 241
  tmp = srp_process_reply_msg(& (self->srp)->dh, packet);
  }
#line 241
  salt = tmp;
#line 247
  connection->dispatch[31] = & connection_fail_handler;
  }
#line 249
  if (! salt) {
    {
    {
#line 251
    tmp___0 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_KEXSRP_REPLY message");
    }
    {
#line 251
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___0);
    }
    }
#line 252
    return;
  }
  {
  {
#line 256
  tmp___1 = ssh_format("SRP password for %lS: ", (self->srp)->name);
  }
  {
#line 256
  passwd = (*(((self->srp)->tty)->read_password))((self->srp)->tty, (uint32_t )100,
                                                  (struct lsh_string  const  *)tmp___1);
  }
  }
#line 259
  if (! passwd) {
    {
    {
#line 261
    lsh_string_free((struct lsh_string  const  *)salt);
    }
    {
#line 262
    disconnect_kex_failed(connection, "Bye");
    }
    }
#line 263
    return;
  }
  {
  {
#line 266
  __gmpz_init(x);
  }
  {
#line 267
  srp_hash_password(x, (struct hash_algorithm  const  *)((self->srp)->dh.method)->H,
                    salt, (self->srp)->name, passwd);
  }
  {
#line 271
  lsh_string_free((struct lsh_string  const  *)salt);
  }
  {
#line 272
  lsh_string_free((struct lsh_string  const  *)passwd);
  }
  {
#line 274
  response = srp_make_client_proof(& (self->srp)->dh, & (self->srp)->m2, x);
  }
  {
#line 275
  __gmpz_clear(x);
  }
  }
#line 277
  if (! response) {
    {
    {
#line 279
    tmp___2 = make_protocol_exception((uint32_t )2, "SRP failure: Invalid public value from server.");
    }
    {
#line 279
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___2);
    }
    }
#line 281
    return;
  }
  {
  {
#line 283
  connection_send_kex(connection, response);
  }
  {
#line 285
  connection->dispatch[32] = make_srp_client_proof_handler(self->srp);
  }
  }
#line 287
  return;
}
}
#line 289 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c"
static struct packet_handler *make_srp_reply_handler(struct srp_client_instance *srp ) 
{ 
  struct srp_client_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 292
  tmp = lsh_object_alloc(& srp_client_handler_class);
  }
#line 292
  self = (struct srp_client_handler *)tmp;
#line 293
  self->super.handler = & do_handle_srp_reply;
#line 294
  self->srp = srp;
  }
#line 296
  return (& self->super);
}
}
#line 309 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c"
static void do_init_client_srp(struct keyexchange_algorithm *s , struct ssh_connection *connection ,
                               int hostkey_algorithm_atom  __attribute__((__unused__)) ,
                               struct lsh_object *extra  __attribute__((__unused__)) ,
                               struct object_list *algorithms ) 
{ 
  struct srp_client_exchange *self ;
  struct srp_client_instance *srp ;
  struct lsh_object *tmp ;
  struct lsh_string *tmp___0 ;

  {
  {
#line 316
  self = (struct srp_client_exchange *)s;
  {
#line 318
  tmp = lsh_object_alloc(& srp_client_instance_class);
  }
#line 318
  srp = (struct srp_client_instance *)tmp;
  {
#line 321
  init_dh_instance(self->dh, & srp->dh, connection);
  }
#line 323
  srp->tty = self->tty;
#line 324
  srp->algorithms = algorithms;
#line 325
  srp->name = self->name;
#line 326
  srp->m2 = (struct lsh_string *)((void *)0);
  {
#line 329
  tmp___0 = srp_make_init_msg(& srp->dh, self->name);
  }
  {
#line 329
  connection_send_kex(connection, tmp___0);
  }
  {
#line 332
  connection->dispatch[31] = make_srp_reply_handler(srp);
  }
  }
#line 333
  return;
}
}
#line 335 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_keyexchange.c"
struct keyexchange_algorithm *make_srp_client(struct dh_method  const  *dh , struct interact *tty ,
                                              struct lsh_string *name ) 
{ 
  struct srp_client_exchange *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 339
  tmp = lsh_object_alloc(& srp_client_exchange_class);
  }
#line 339
  self = (struct srp_client_exchange *)tmp;
#line 341
  self->super.init = & do_init_client_srp;
#line 342
  self->dh = dh;
#line 343
  self->tty = tty;
#line 344
  self->name = name;
  }
#line 346
  return (& self->super);
}
}
#line 34 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h.x"
struct lsh_class escape_callback_class ;
#line 59
struct lsh_class escape_info_class ;
#line 85 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h"
struct escape_info *make_escape_info(uint8_t escape ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c.x"
struct lsh_class escape_help_class ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c.x"
static void do_escape_help_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct escape_help *i ;

  {
  {
#line 18
  i = (struct escape_help *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->info);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c.x"
struct lsh_class escape_help_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & escape_callback_class, (char *)"escape_help", (size_t )sizeof(struct escape_help ),
    & do_escape_help_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 42
struct lsh_class escape_handler_class ;
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c.x"
static void do_escape_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct escape_handler *i ;

  {
  {
#line 50
  i = (struct escape_handler *)o;
  {
#line 51
  (*mark)((struct lsh_object *)i->info);
  }
  }
#line 52
  return;
}
}
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c.x"
struct lsh_class escape_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & abstract_write_pipe_class, (char *)"escape_handler", (size_t )sizeof(struct escape_handler ),
    & do_escape_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c"
static void do_escape_help(struct lsh_callback *s ) 
{ 
  struct escape_help *self ;
  unsigned int i ;
  struct escape_callback *c ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 57
  self = (struct escape_help *)s;
  {
#line 60
  werror("The escape character is `%pc\'\n", (int )(self->info)->escape);
  }
  {
#line 63
  werror("Available commands:\n\n");
  }
#line 65
  i = 0U;
  }
  {
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 65
    if (! (i < 256U)) {
#line 65
      goto while_break;
    }
#line 67
    c = (self->info)->dispatch[i];
#line 69
    if (c) {
      {
      {
#line 70
      werror("`%pc\': %z\n", i, c->help);
      }
      }
    }
#line 65
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 72
  return;
}
}
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c"
static struct escape_callback *make_escape_help(struct escape_info *info ) 
{ 
  struct escape_help *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 77
  tmp = lsh_object_alloc(& escape_help_class);
  }
#line 77
  self = (struct escape_help *)tmp;
#line 78
  self->super.super.f = & do_escape_help;
#line 79
  self->super.help = "Display this help.";
#line 80
  self->info = info;
  }
#line 82
  return (& self->super);
}
}
#line 85 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c"
struct escape_info *make_escape_info(uint8_t escape ) 
{ 
  struct escape_info *self ;
  struct lsh_object *tmp ;
  unsigned int i ;

  {
  {
  {
#line 88
  tmp = lsh_object_alloc(& escape_info_class);
  }
#line 88
  self = (struct escape_info *)tmp;
#line 91
  self->escape = escape;
#line 93
  i = 0U;
  }
  {
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 93
    if (! (i < 256U)) {
#line 93
      goto while_break;
    }
#line 94
    self->dispatch[i] = (struct escape_callback *)((void *)0);
#line 93
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 96
  self->dispatch['?'] = make_escape_help(self);
  }
  }
#line 98
  return (self);
}
}
#line 112 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c"
__inline static int newlinep(uint8_t c ) 
{ 
  int tmp ;

  {
#line 115
  if ((int )c == 10) {
#line 115
    tmp = 1;
  } else
#line 115
  if ((int )c == 13) {
#line 115
    tmp = 1;
  } else {
#line 115
    tmp = 0;
  }
#line 115
  return (tmp);
}
}
#line 121 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c"
static uint32_t scan_escape(struct lsh_string *packet , uint32_t pos , uint8_t escape ) 
{ 
  uint32_t length ;
  uint32_t tmp ;
  uint8_t const   *data ;
  uint8_t const   *tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 124
  tmp = lsh_string_length((struct lsh_string  const  *)packet);
  }
#line 124
  length = tmp;
  {
#line 125
  tmp___0 = lsh_string_data((struct lsh_string  const  *)packet);
  }
#line 125
  data = tmp___0;
  }
  {
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 127
    if (! (pos + 2U <= length)) {
#line 127
      goto while_break;
    }
    {
    {
#line 129
    tmp___1 = newlinep((uint8_t )*(data + pos));
    }
    }
#line 129
    if (tmp___1) {
#line 129
      if ((int const   )*(data + (pos + 1U)) == (int const   )escape) {
#line 131
        return (pos + 1U);
      }
    }
#line 127
    pos ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 133
  return ((uint32_t )0);
}
}
#line 137 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c"
static int escape_dispatch(struct escape_info *info , uint8_t c ) 
{ 
  struct escape_callback *f ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 143
  if ((int )c == (int )info->escape) {
#line 144
    return (1);
  }
#line 146
  f = info->dispatch[c];
#line 147
  if (f) {
    {
    {
#line 148
    (*(f->super.f))(& f->super);
    }
    }
  } else {
    {
    {
#line 150
    werror("<escape> `%pc\' not defined.\n", (int )c);
    }
    }
  }
#line 152
  return (0);
}
}
#line 155 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c"
static void do_escape_handler(struct abstract_write *s , struct lsh_string *packet ) 
{ 
  struct escape_handler *self ;
  uint32_t pos ;
  uint32_t done ;
  uint32_t length ;
  uint8_t const   *data ;
  int tmp ;
  int tmp___0 ;
  struct lsh_string *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct lsh_string *tmp___4 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 158
  self = (struct escape_handler *)s;
#line 169
  if (! packet) {
    {
    {
#line 172
    (*((self->super.next)->write))(self->super.next, packet);
    }
    }
#line 173
    return;
  }
  {
  {
#line 176
  length = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 177
  data = lsh_string_data((struct lsh_string  const  *)packet);
  }
  }
#line 179
  if (! length) {
    {
    {
#line 179
    __assert_fail("length", "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c",
                  179U, "do_escape_handler");
    }
    }
  }
#line 184
  pos = (uint32_t )0;
#line 184
  done = pos;
#line 189
  if ((unsigned int )self->state == 1U) {
#line 189
    goto case_1;
  }
#line 210
  if ((unsigned int )self->state == 2U) {
#line 210
    goto case_2;
  }
#line 220
  if ((unsigned int )self->state == 0U) {
#line 220
    goto case_0;
  }
#line 187
  goto switch_break;
  case_1: 
#line 191
  if ((int const   )*(data + 0) == (int const   )(self->info)->escape) {
#line 193
    if (length == 1U) {
      {
#line 195
      self->state = (enum escape_state )2;
      {
#line 196
      lsh_string_free((struct lsh_string  const  *)packet);
      }
      }
#line 197
      return;
    } else {
      {
#line 201
      pos = (uint32_t )2;
      {
#line 202
      tmp = escape_dispatch(self->info, (uint8_t )*(data + 1));
      }
      }
#line 202
      if (tmp) {
#line 204
        done = (uint32_t )1;
      } else {
#line 206
        done = (uint32_t )2;
      }
    }
  }
#line 209
  goto switch_break;
  case_2: 
  {
#line 211
  pos = (uint32_t )1;
  {
#line 212
  tmp___0 = escape_dispatch(self->info, (uint8_t )*(data + 0));
  }
  }
#line 212
  if (tmp___0) {
#line 214
    done = (uint32_t )0;
  } else {
#line 216
    done = (uint32_t )1;
  }
#line 218
  goto switch_break;
  case_0: 
#line 222
  goto switch_break;
  switch_break: ;
  {
  {
#line 225
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 225
    pos = scan_escape(packet, pos, (self->info)->escape);
    }
    }
#line 225
    if (! pos) {
#line 225
      goto while_break;
    }
#line 230
    if (! (pos > done)) {
      {
      {
#line 230
      __assert_fail("pos > done", "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c",
                    230U, "do_escape_handler");
      }
      }
    }
    {
    {
#line 231
    tmp___1 = ssh_format("%ls", pos - done, data + done);
    }
    {
#line 231
    (*((self->super.next)->write))(self->super.next, tmp___1);
    }
#line 235
    pos ++;
    }
#line 236
    if (pos == length) {
      {
#line 239
      self->state = (enum escape_state )2;
      {
#line 240
      lsh_string_free((struct lsh_string  const  *)packet);
      }
      }
#line 241
      return;
    }
    {
    {
#line 243
    tmp___2 = escape_dispatch(self->info, (uint8_t )*(data + pos));
    }
    }
#line 243
    if (tmp___2) {
#line 245
      done = pos;
    } else {
#line 247
      done = pos + 1U;
    }
#line 248
    pos ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 252
  if (done < length) {
    {
    {
#line 255
    tmp___3 = newlinep((uint8_t )*(data + (length - 1U)));
    }
    }
#line 255
    if (tmp___3) {
#line 256
      self->state = (enum escape_state )1;
    } else {
#line 258
      self->state = (enum escape_state )0;
    }
#line 261
    if (done) {
      {
      {
#line 264
      tmp___4 = ssh_format("%ls", length - done, data + done);
      }
      {
#line 264
      (*((self->super.next)->write))(self->super.next, tmp___4);
      }
      {
#line 267
      lsh_string_free((struct lsh_string  const  *)packet);
      }
      }
    } else {
      {
      {
#line 270
      (*((self->super.next)->write))(self->super.next, packet);
      }
      }
    }
  } else {
    {
#line 274
    self->state = (enum escape_state )0;
    {
#line 275
    lsh_string_free((struct lsh_string  const  *)packet);
    }
    }
  }
#line 277
  return;
}
}
#line 279 "/home/ysko/Works/test-src/lsh-2.0.4/src/client_escape.c"
struct abstract_write *make_handle_escape(struct escape_info *info , struct abstract_write *next ) 
{ 
  struct escape_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 282
  tmp = lsh_object_alloc(& escape_handler_class);
  }
#line 282
  self = (struct escape_handler *)tmp;
#line 284
  self->super.super.write = & do_escape_handler;
#line 285
  self->super.next = next;
#line 286
  self->info = info;
#line 287
  self->state = (enum escape_state )0;
  }
#line 289
  return (& self->super.super);
}
}
#line 173 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 346
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 188 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 137 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h"
struct command *make_install_fix_channel_open_handler(uint32_t name , struct channel_open *handler ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h.x"
struct lsh_class request_service_class ;
#line 119
struct lsh_class client_options_class ;
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h"
struct packet_handler *make_accept_service_handler(uint32_t service , struct command_continuation *c ) ;
#line 51
void do_request_service(struct command *s , struct lsh_object *x , struct command_continuation *c ,
                        struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 60
struct command *make_request_service(int service ) ;
#line 92
struct command *make_open_session_command(struct ssh_channel *session ) ;
#line 95
struct channel_request_command request_shell ;
#line 109
struct command *make_exec_request(struct lsh_string *command ) ;
#line 115
struct command *make_subsystem_request(struct lsh_string *subsystem ) ;
#line 186
void init_client_options(struct client_options *self , struct randomness *random___0 ,
                         struct exception_handler *handler , int *exit_code ) ;
#line 192
struct command *client_add_action(struct client_options *options , struct command *action ) ;
#line 195
struct command *client_prepend_action(struct client_options *options , struct command *action ) ;
#line 199
int client_parse_forward_arg(char *arg , uint32_t *listen_port , struct address_info **target ) ;
#line 204
struct argp  const  client_argp ;
#line 207
void envp_parse(struct argp  const  *argp , char const   **envp , char const   *name ,
                unsigned int flags , void *input ) ;
#line 400 "/home/ysko/Works/test-src/lsh-2.0.4/src/argp/argp.h"
extern  __attribute__((__nothrow__)) error_t argp_parse(struct argp  const  *argp ,
                                                        int argc , char **argv , unsigned int flags ,
                                                        int *arg_index , void *input ) ;
#line 494
extern  __attribute__((__nothrow__)) void argp_usage(struct argp_state  const  *__state ) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h.x"
struct lsh_class request_service_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"request_service", (size_t )sizeof(struct request_service ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h.x"
struct lsh_class escape_callback_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & lsh_callback_class, (char *)"escape_callback", (size_t )sizeof(struct escape_callback ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h.x"
static void do_escape_info_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct escape_info *i ;
  unsigned int k1 ;

  {
#line 67
  i = (struct escape_info *)o;
#line 70
  k1 = 0U;
  {
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 70
    if (! (k1 < 256U)) {
#line 70
      goto while_break;
    }
    {
    {
#line 71
    (*mark)((struct lsh_object *)i->dispatch[k1]);
    }
#line 70
    k1 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 73
  return;
}
}
#line 74 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h.x"
struct lsh_class escape_info_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"escape_info", (size_t )sizeof(struct escape_info ),
    & do_escape_info_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 123 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h.x"
static void do_client_options_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct client_options *i ;

  {
  {
#line 127
  i = (struct client_options *)o;
  {
#line 128
  (*mark)((struct lsh_object *)i->random);
  }
  {
#line 129
  (*mark)((struct lsh_object *)i->tty);
  }
  {
#line 130
  (*mark)((struct lsh_object *)i->handler);
  }
  {
#line 131
  object_queue_mark(& i->actions, mark);
  }
  {
#line 133
  (*mark)((struct lsh_object *)i->resources);
  }
  }
#line 134
  return;
}
}
#line 135 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h.x"
static void do_client_options_free(struct lsh_object *o ) 
{ 
  struct client_options *i ;

  {
  {
#line 138
  i = (struct client_options *)o;
  {
#line 139
  object_queue_free(& i->actions);
  }
  }
#line 140
  return;
}
}
#line 141 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.h.x"
struct lsh_class client_options_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"client_options", (size_t )sizeof(struct client_options ),
    & do_client_options_mark, & do_client_options_free};
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct lsh_class accept_service_handler_class ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
static void do_accept_service_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct accept_service_handler *i ;

  {
  {
#line 19
  i = (struct accept_service_handler *)o;
  {
#line 20
  (*mark)((struct lsh_object *)i->c);
  }
  }
#line 21
  return;
}
}
#line 22 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct lsh_class accept_service_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & packet_handler_class, (char *)"accept_service_handler", (size_t )sizeof(struct accept_service_handler ),
    & do_accept_service_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 44
struct lsh_class detach_callback_class ;
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct lsh_class detach_callback_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & lsh_callback_class, (char *)"detach_callback", (size_t )sizeof(struct detach_callback ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 68
struct lsh_class detach_resource_class ;
#line 72 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
static void do_detach_resource_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct detach_resource *i ;

  {
  {
#line 76
  i = (struct detach_resource *)o;
  {
#line 77
  (*mark)((struct lsh_object *)i->c);
  }
  }
#line 78
  return;
}
}
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct lsh_class detach_resource_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & resource_class, (char *)"detach_resource", (size_t )sizeof(struct detach_resource ),
    & do_detach_resource_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 99
struct lsh_class exit_handler_class ;
#line 103 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct lsh_class exit_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_request_class, (char *)"exit_handler", (size_t )sizeof(struct exit_handler ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 123
struct lsh_class session_open_command_class ;
#line 127 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
static void do_session_open_command_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct session_open_command *i ;

  {
  {
#line 131
  i = (struct session_open_command *)o;
  {
#line 132
  (*mark)((struct lsh_object *)i->session);
  }
  }
#line 133
  return;
}
}
#line 134 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct lsh_class session_open_command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_open_command_class, (char *)"session_open_command", (size_t )sizeof(struct session_open_command ),
    & do_session_open_command_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 154
struct lsh_class exec_request_class ;
#line 158 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
static void do_exec_request_free(struct lsh_object *o ) 
{ 
  struct exec_request *i ;

  {
  {
#line 161
  i = (struct exec_request *)o;
  {
#line 162
  lsh_string_free((struct lsh_string  const  *)i->command);
  }
  }
#line 163
  return;
}
}
#line 164 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct lsh_class exec_request_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_request_command_class, (char *)"exec_request", (size_t )sizeof(struct exec_request ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_exec_request_free};
#line 184
struct lsh_class subsystem_request_class ;
#line 188 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
static void do_subsystem_request_free(struct lsh_object *o ) 
{ 
  struct subsystem_request___0 *i ;

  {
  {
#line 191
  i = (struct subsystem_request___0 *)o;
  {
#line 192
  lsh_string_free((struct lsh_string  const  *)i->subsystem);
  }
  }
#line 193
  return;
}
}
#line 194 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct lsh_class subsystem_request_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_request_command_class, (char *)"subsystem_request", (size_t )sizeof(struct subsystem_request___0 ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    & do_subsystem_request_free};
#line 205 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
static struct command *make_start_session(struct command *open_session , struct object_list *requests ) 
{ 
  struct command *res ;
  struct lsh_object *tmp ;
  struct command *tmp___0 ;

  {
  {
  {
#line 235
  tmp = gaba_apply(& progn_command.super, (struct lsh_object *)requests);
  }
  {
#line 235
  tmp___0 = make_command_3_invoke_2(& command_B, tmp, (struct lsh_object *)open_session);
  }
#line 235
  res = (struct command *)((struct lsh_object *)tmp___0);
  }
#line 240
  return (res);
}
}
#line 268 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
static struct command *client_start_session(struct command *request ) 
{ 
  struct command *res ;
  struct command *tmp ;

  {
  {
  {
#line 297
  tmp = make_command_3_invoke_2(& command_B, & client_io.super, (struct lsh_object *)request);
  }
#line 297
  res = (struct command *)((struct lsh_object *)tmp);
  }
#line 301
  return (res);
}
}
#line 338
struct lsh_class background_process_command_class ;
#line 342 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c.x"
struct lsh_class background_process_command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"background_process_command", (size_t )sizeof(struct background_process_command ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 72 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct lsh_string *format_service_request(int name ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 75
  tmp = ssh_format("%c%a", 5, name);
  }
  }
#line 75
  return (tmp);
}
}
#line 89 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static void do_accept_service(struct packet_handler *c , struct ssh_connection *connection ,
                              struct lsh_string *packet ) 
{ 
  struct accept_service_handler *closure ;
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  int name ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct exception *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 94
  closure = (struct accept_service_handler *)c;
  {
#line 100
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 100
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 100
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 102
  tmp___2 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 102
  if (tmp___2) {
#line 102
    if (msg_number == 6U) {
      {
      {
#line 102
      tmp___3 = parse_atom(& buffer, & name);
      }
      }
#line 102
      if (tmp___3) {
#line 102
        if (name == closure->service) {
          {
          {
#line 102
          tmp___4 = parse_eod(& buffer);
          }
          }
#line 102
          if (tmp___4) {
            {
#line 108
            connection->dispatch[6] = & connection_fail_handler;
            {
#line 110
            (*((closure->c)->c))(closure->c, (struct lsh_object *)connection);
            }
            }
          } else {
            {
            {
#line 113
            tmp___1 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_SERVICE_ACCEPT message");
            }
            {
#line 113
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
            }
            }
          }
        } else {
          {
          {
#line 113
          tmp___1 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_SERVICE_ACCEPT message");
          }
          {
#line 113
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
          }
          }
        }
      } else {
        {
        {
#line 113
        tmp___1 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_SERVICE_ACCEPT message");
        }
        {
#line 113
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
        }
        }
      }
    } else {
      {
      {
#line 113
      tmp___1 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_SERVICE_ACCEPT message");
      }
      {
#line 113
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
      }
      }
    }
  } else {
    {
    {
#line 113
    tmp___1 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_SERVICE_ACCEPT message");
    }
    {
#line 113
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___1);
    }
    }
  }
#line 114
  return;
}
}
#line 116 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct packet_handler *make_accept_service_handler(uint32_t service , struct command_continuation *c ) 
{ 
  struct accept_service_handler *closure ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 120
  tmp = lsh_object_alloc(& accept_service_handler_class);
  }
#line 120
  closure = (struct accept_service_handler *)tmp;
#line 122
  closure->super.handler = & do_accept_service;
#line 123
  closure->service = (int )service;
#line 124
  closure->c = c;
  }
#line 126
  return (& closure->super);
}
}
#line 129 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
void do_request_service(struct command *s , struct lsh_object *x , struct command_continuation *c ,
                        struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct request_service *self ;
  struct ssh_connection *connection ;
  struct lsh_string *tmp ;

  {
  {
#line 135
  self = (struct request_service *)s;
#line 136
  connection = (struct ssh_connection *)x;
  {
#line 140
  connection->dispatch[6] = make_accept_service_handler((uint32_t )self->service,
                                                        c);
  }
  {
#line 143
  tmp = format_service_request(self->service);
  }
  {
#line 143
  connection_send(connection, tmp);
  }
  }
#line 145
  return;
}
}
#line 147 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct command *make_request_service(int service ) 
{ 
  struct request_service *closure ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 150
  tmp = lsh_object_alloc(& request_service_class);
  }
#line 150
  closure = (struct request_service *)tmp;
#line 152
  closure->super.call = & do_request_service;
#line 153
  closure->service = service;
  }
#line 155
  return (& closure->super);
}
}
#line 177 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static void do_detach_res_kill(struct resource *r ) 
{ 
  struct detach_resource *self ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 180
  self = (struct detach_resource *)r;
  {
#line 182
  trace("client.c:do_detach_res\n");
  }
#line 183
  (self->c)->channel_flag = 1;
  }
#line 185
  if ((self->c)->channel_flag) {
#line 185
    if ((self->c)->fd_flag) {
      {
      {
#line 187
      io_callout(& (self->c)->super, 0U);
      }
      }
    }
  }
#line 188
  return;
}
}
#line 190 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct resource *make_detach_resource(struct lsh_callback *c ) 
{ 
  struct detach_resource *self ;
  struct lsh_object *tmp ;
  struct detach_callback *cb ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 193
  tmp = lsh_object_alloc(& detach_resource_class);
  }
#line 193
  self = (struct detach_resource *)tmp;
#line 194
  cb = (struct detach_callback *)c;
  {
#line 196
  trace("client.c:make_detach_resource\n");
  }
  {
#line 197
  init_resource(& self->super, & do_detach_res_kill);
  }
#line 199
  self->c = cb;
  }
#line 201
  return (& self->super);
}
}
#line 205 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static void do_detach_cb(struct lsh_callback *c ) 
{ 
  struct detach_callback *self ;
  int pid ;
  __pid_t tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 208
  self = (struct detach_callback *)c;
  {
#line 210
  trace("client.c: do_detach_cb\n");
  }
  }
#line 212
  if (! self->fd_flag) {
#line 214
    self->fd_flag = 1;
#line 216
    if (self->channel_flag) {
#line 216
      if (self->fd_flag) {
        {
        {
#line 218
        io_callout(c, 0U);
        }
        }
      }
    }
  } else {
    {
    {
#line 222
    tmp = fork();
    }
#line 222
    pid = tmp;
    }
#line 228
    if (pid == -1) {
#line 228
      goto case_neg_1;
    }
#line 232
    if (pid == 0) {
#line 232
      goto case_0;
    }
#line 245
    goto switch_default;
    case_neg_1: 
    {
    {
#line 229
    werror("Fork failed, not detaching.\n");
    }
    }
#line 230
    goto switch_break;
    case_0: 
    {
    {
#line 234
    close(0);
    }
    {
#line 235
    close(1);
    }
    {
#line 236
    close(2);
    }
    {
#line 240
    open("/dev/null", 0);
    }
    {
#line 241
    open("/dev/null", 0);
    }
    {
#line 242
    open("/dev/null", 0);
    }
    }
#line 243
    goto switch_break;
    switch_default: 
    {
    {
#line 246
    exit(*(self->exit_status));
    }
    }
    switch_break: ;
  }
#line 249
  return;
}
}
#line 251 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct lsh_callback *make_detach_callback(int *exit_status ) 
{ 
  struct detach_callback *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 254
  tmp = lsh_object_alloc(& detach_callback_class);
  }
#line 254
  self = (struct detach_callback *)tmp;
#line 256
  self->super.f = & do_detach_cb;
#line 257
  self->exit_status = exit_status;
#line 258
  self->fd_flag = 0;
#line 259
  self->channel_flag = 0;
  }
#line 261
  return (& self->super);
}
}
#line 272 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static void do_exit_status(struct channel_request *c , struct ssh_channel *channel ,
                           struct channel_request_info *info , struct simple_buffer *args ,
                           struct command_continuation *s , struct exception_handler *e ) 
{ 
  struct exit_handler *closure ;
  uint32_t status ;
  struct exception *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 280
  closure = (struct exit_handler *)c;
#line 283
  if (! info->want_reply) {
    {
    {
#line 283
    tmp___0 = parse_uint32(args, & status);
    }
    }
#line 283
    if (tmp___0) {
      {
      {
#line 283
      tmp___1 = parse_eod(args);
      }
      }
#line 283
      if (tmp___1) {
        {
        {
#line 287
        verbose("client.c: Receiving exit-status %i on channel %i\n", status, channel->channel_number);
        }
#line 290
        *(closure->exit_status) = (int )status;
        {
#line 291
        (*(((struct alist_meta *)(channel->request_types)->super.isa)->set))(channel->request_types,
                                                                             65, (struct lsh_object *)((void *)0));
        }
        {
#line 292
        (*(((struct alist_meta *)(channel->request_types)->super.isa)->set))(channel->request_types,
                                                                             66, (struct lsh_object *)((void *)0));
        }
        {
#line 294
        (*(s->c))(s, (struct lsh_object *)channel);
        }
        }
      } else {
        {
        {
#line 298
        tmp = make_protocol_exception((uint32_t )2, "Invalid exit-status message");
        }
        {
#line 298
        (*(e->raise))(e, (struct exception  const  *)tmp);
        }
        }
      }
    } else {
      {
      {
#line 298
      tmp = make_protocol_exception((uint32_t )2, "Invalid exit-status message");
      }
      {
#line 298
      (*(e->raise))(e, (struct exception  const  *)tmp);
      }
      }
    }
  } else {
    {
    {
#line 298
    tmp = make_protocol_exception((uint32_t )2, "Invalid exit-status message");
    }
    {
#line 298
    (*(e->raise))(e, (struct exception  const  *)tmp);
    }
    }
  }
#line 299
  return;
}
}
#line 301 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static void do_exit_signal(struct channel_request *c , struct ssh_channel *channel ,
                           struct channel_request_info *info , struct simple_buffer *args ,
                           struct command_continuation *s , struct exception_handler *e ) 
{ 
  struct exit_handler *closure ;
  uint32_t signal___0 ;
  int core ;
  uint8_t const   *msg ;
  uint32_t length ;
  uint8_t const   *language ;
  uint32_t language_length ;
  char const   *tmp ;
  struct exception *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 309
  closure = (struct exit_handler *)c;
#line 320
  if (! info->want_reply) {
    {
    {
#line 320
    tmp___1 = parse_atom(args, (int *)(& signal___0));
    }
    }
#line 320
    if (tmp___1) {
      {
      {
#line 320
      tmp___2 = parse_boolean(args, & core);
      }
      }
#line 320
      if (tmp___2) {
        {
        {
#line 320
        tmp___3 = parse_string(args, & length, & msg);
        }
        }
#line 320
        if (tmp___3) {
          {
          {
#line 320
          tmp___4 = parse_string(args, & language_length, & language);
          }
          }
#line 320
          if (tmp___4) {
            {
            {
#line 320
            tmp___5 = parse_eod(args);
            }
            }
#line 320
            if (tmp___5) {
#line 330
              *(closure->exit_status) = 7;
#line 332
              if (core) {
#line 332
                tmp = "(core dumped remotely)\n";
              } else {
#line 332
                tmp = "";
              }
              {
              {
#line 332
              werror("Remote process was killed by signal: %ups %z\n", length, msg,
                     tmp);
              }
              {
#line 336
              (*(((struct alist_meta *)(channel->request_types)->super.isa)->set))(channel->request_types,
                                                                                   65,
                                                                                   (struct lsh_object *)((void *)0));
              }
              {
#line 337
              (*(((struct alist_meta *)(channel->request_types)->super.isa)->set))(channel->request_types,
                                                                                   66,
                                                                                   (struct lsh_object *)((void *)0));
              }
              {
#line 339
              (*(s->c))(s, (struct lsh_object *)channel);
              }
              }
            } else {
              {
              {
#line 343
              tmp___0 = make_protocol_exception((uint32_t )2, "Invalid exit-signal message");
              }
              {
#line 343
              (*(e->raise))(e, (struct exception  const  *)tmp___0);
              }
              }
            }
          } else {
            {
            {
#line 343
            tmp___0 = make_protocol_exception((uint32_t )2, "Invalid exit-signal message");
            }
            {
#line 343
            (*(e->raise))(e, (struct exception  const  *)tmp___0);
            }
            }
          }
        } else {
          {
          {
#line 343
          tmp___0 = make_protocol_exception((uint32_t )2, "Invalid exit-signal message");
          }
          {
#line 343
          (*(e->raise))(e, (struct exception  const  *)tmp___0);
          }
          }
        }
      } else {
        {
        {
#line 343
        tmp___0 = make_protocol_exception((uint32_t )2, "Invalid exit-signal message");
        }
        {
#line 343
        (*(e->raise))(e, (struct exception  const  *)tmp___0);
        }
        }
      }
    } else {
      {
      {
#line 343
      tmp___0 = make_protocol_exception((uint32_t )2, "Invalid exit-signal message");
      }
      {
#line 343
      (*(e->raise))(e, (struct exception  const  *)tmp___0);
      }
      }
    }
  } else {
    {
    {
#line 343
    tmp___0 = make_protocol_exception((uint32_t )2, "Invalid exit-signal message");
    }
    {
#line 343
    (*(e->raise))(e, (struct exception  const  *)tmp___0);
    }
    }
  }
#line 344
  return;
}
}
#line 346 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct channel_request *make_handle_exit_status(int *exit_status ) 
{ 
  struct exit_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 349
  tmp = lsh_object_alloc(& exit_handler_class);
  }
#line 349
  self = (struct exit_handler *)tmp;
#line 351
  self->super.handler = & do_exit_status;
#line 353
  self->exit_status = exit_status;
  }
#line 355
  return (& self->super);
}
}
#line 358 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct channel_request *make_handle_exit_signal(int *exit_status ) 
{ 
  struct exit_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 361
  tmp = lsh_object_alloc(& exit_handler_class);
  }
#line 361
  self = (struct exit_handler *)tmp;
#line 363
  self->super.handler = & do_exit_signal;
#line 365
  self->exit_status = exit_status;
  }
#line 367
  return (& self->super);
}
}
#line 380 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct ssh_channel *new_session(struct channel_open_command *s , struct ssh_connection *connection ,
                                       uint32_t local_channel_number , struct lsh_string **request ) 
{ 
  struct session_open_command *self ;
  struct ssh_channel *res ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 386
  self = (struct session_open_command *)s;
#line 389
  (self->session)->connection = connection;
  {
#line 391
  *request = format_channel_open(52, local_channel_number, self->session, "");
  }
#line 395
  res = self->session;
#line 398
  self->session = (struct ssh_channel *)((void *)0);
  }
#line 400
  return (res);
}
}
#line 403 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct command *make_open_session_command(struct ssh_channel *session ) 
{ 
  struct session_open_command *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 406
  tmp = lsh_object_alloc(& session_open_command_class);
  }
#line 406
  self = (struct session_open_command *)tmp;
#line 407
  self->super.super.call = & do_channel_open_command;
#line 408
  self->super.new_channel = & new_session;
#line 409
  self->session = session;
  }
#line 411
  return (& self->super.super);
}
}
#line 415 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct lsh_string *do_format_shell_request(struct channel_request_command *s  __attribute__((__unused__)) ,
                                                  struct ssh_channel *channel , struct command_continuation **c ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 420
  tmp = format_channel_request(59, channel, ! (! *c), "");
  }
  }
#line 420
  return (tmp);
}
}
#line 423 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct channel_request_command request_shell  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_channel_request_command}, & do_format_shell_request};
#line 435 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct lsh_string *do_format_exec_request(struct channel_request_command *s ,
                                                 struct ssh_channel *channel , struct command_continuation **c ) 
{ 
  struct exec_request *self ;
  struct lsh_string *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 440
  self = (struct exec_request *)s;
  {
#line 442
  verbose("lsh: Requesting remote exec.\n");
  }
  {
#line 444
  tmp = format_channel_request(60, channel, ! (! *c), "%S", self->command);
  }
  }
#line 444
  return (tmp);
}
}
#line 448 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct command *make_exec_request(struct lsh_string *command ) 
{ 
  struct exec_request *req ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 451
  tmp = lsh_object_alloc(& exec_request_class);
  }
#line 451
  req = (struct exec_request *)tmp;
#line 453
  req->super.format_request = & do_format_exec_request;
#line 454
  req->super.super.call = & do_channel_request_command;
#line 455
  req->command = command;
  }
#line 457
  return (& req->super.super);
}
}
#line 469 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct lsh_string *do_format_subsystem_request(struct channel_request_command *s ,
                                                      struct ssh_channel *channel ,
                                                      struct command_continuation **c ) 
{ 
  struct subsystem_request___0 *self ;
  struct lsh_string *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 474
  self = (struct subsystem_request___0 *)s;
  {
#line 476
  verbose("lsh: Requesting remote subsystem.\n");
  }
  {
#line 478
  tmp = format_channel_request(61, channel, ! (! *c), "%S", self->subsystem);
  }
  }
#line 478
  return (tmp);
}
}
#line 482 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct command *make_subsystem_request(struct lsh_string *subsystem ) 
{ 
  struct subsystem_request___0 *req ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 485
  tmp = lsh_object_alloc(& subsystem_request_class);
  }
#line 485
  req = (struct subsystem_request___0 *)tmp;
#line 487
  req->super.format_request = & do_format_subsystem_request;
#line 488
  req->super.super.call = & do_channel_request_command;
#line 489
  req->subsystem = subsystem;
  }
#line 491
  return (& req->super.super);
}
}
#line 500
static struct ssh_channel *make_client_session(struct client_options *options ) ;
#line 524 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
void init_client_options(struct client_options *self , struct randomness *random___0 ,
                         struct exception_handler *handler , int *exit_code ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 530
  self->random = random___0;
  {
#line 532
  self->tty = make_unix_interact();
  }
#line 533
  self->escape = -1;
#line 535
  self->handler = handler;
#line 537
  self->exit_code = exit_code;
#line 539
  self->not = 0;
#line 540
  self->port = (char const   *)((void *)0);
#line 541
  self->target = (char const   *)((void *)0);
  }
  {
  {
#line 543
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 543
    self->user = getenv("LOGNAME");
    }
    }
#line 543
    if (! self->user) {
      {
      {
#line 543
      self->user = getenv("USER");
      }
      }
    }
#line 543
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 544
  self->local_user = self->user;
#line 546
  self->with_remote_peers = 0;
#line 547
  self->with_pty = -1;
#line 548
  self->with_x11 = 0;
#line 550
  self->stdin_file = (char const   *)((void *)0);
#line 551
  self->stdout_file = (char const   *)((void *)0);
#line 552
  self->stderr_file = (char const   *)((void *)0);
#line 554
  self->used_stdin = 0;
#line 555
  self->used_pty = 0;
#line 556
  self->used_x11 = 0;
#line 558
  self->detach_end = 0;
#line 559
  self->write_pid = 0;
#line 561
  self->start_shell = 1;
#line 562
  self->remote_forward = 0;
#line 564
  self->inhibit_actions = 0;
  {
#line 566
  lsh_queue_init(& self->actions.q);
  }
  {
#line 568
  self->resources = make_resource_list();
  }
  {
#line 569
  gc_global(& (self->resources)->super);
  }
  }
#line 570
  return;
}
}
#line 572 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct argp_option  const  client_options[31]  = 
#line 572
  {      {"port", 'p', "Port", 0, "Connect to this port.", 0}, 
        {"user", 'l', "User name", 0, "Login as this user.", 0}, 
        {"askpass", 534, "Program", 0, "Program to use for reading passwords. Should be an absolute filename.",
      0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Actions:",
      100}, 
        {"forward-local-port", 'L', "local-port:target-host:target-port", 0, "", 0}, 
        {"forward-socks", 'D', "port", 1, "Enable socks dynamic forwarding", 0}, 
        {"nop", 'N', (char const   *)((void *)0), 0, "No operation (suppresses the default action, which is to spawn a remote shell)",
      0}, 
        {"background", 'B', (char const   *)((void *)0), 0, "Put process into the background. Implies -N.",
      0}, 
        {"execute", 'E', "command", 0, "Execute a command on the remote machine", 0}, 
        {"shell",
      'S', "command", 0, "Spawn a remote shell", 0}, 
        {"subsystem", 532, "subsystem-name", 0, "Connect to given subsystem. Implies --no-pty.",
      0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Universal not:",
      0}, 
        {"no", 'n', (char const   *)((void *)0), 0, "Inverts the effect of the next modifier",
      0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Modifiers that apply to port forwarding:",
      190}, 
        {"remote-peers", 'g', (char const   *)((void *)0), 0, "Allow remote access to forwarded ports",
      0}, 
        {"no-remote-peers", 1127, (char const   *)((void *)0), 0, "Disallow remote access to forwarded ports (default).",
      0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Modifiers that apply to remote execution:",
      0}, 
        {"stdin", 528, "Filename", 0, "Redirect stdin", 0}, 
        {"no-stdin", 1552, (char const   *)((void *)0), 0, "Redirect stdin from /dev/null",
      0}, 
        {"stdout", 529, "Filename", 0, "Redirect stdout", 0}, 
        {"no-stdout", 1553, (char const   *)((void *)0), 0, "Redirect stdout to /dev/null",
      0}, 
        {"stderr", 530, "Filename", 0, "Redirect stderr", 0}, 
        {"no-stderr", 1554, (char const   *)((void *)0), 0, "Redirect stderr to /dev/null",
      0}, 
        {"detach", 533, (char const   *)((void *)0), 0, "Detach from terminal at session end.",
      0}, 
        {"no-detach", 1557, (char const   *)((void *)0), 0, "Do not detach session at end, wait for all open channels (default).",
      0}, 
        {"pty", 't', (char const   *)((void *)0), 0, "Request a remote pty (default).",
      0}, 
        {"no-pty", 1140, (char const   *)((void *)0), 0, "Don\'t request a remote pty.",
      0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Miscellaneous options:",
      0}, 
        {"escape-char", 'e', "Character", 0, "Escape char. `none\' means disable. Default is to use `~\' if we have a tty, otherwise none.",
      0}, 
        {"write-pid", 535, (char const   *)((void *)0), 0, "Make -B write the pid of the backgrounded process to stdout.",
      0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (char const   *)((void *)0),
      0}};
#line 657 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct command *make_client_start_session(struct command *request ) 
{ 
  struct command *r ;
  struct command *tmp ;

  {
  {
  {
#line 660
  tmp = client_start_session(request);
  }
#line 660
  r = tmp;
  }
#line 661
  return (r);
}
}
#line 664 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static void client_maybe_pty(struct client_options *options , int default_pty , struct object_queue *q ) 
{ 
  int with_pty ;
  struct command *get_pty ;
  struct command *tmp ;
  struct catch_handler_info *tmp___0 ;
  struct command *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 670
  with_pty = options->with_pty;
#line 671
  if (with_pty < 0) {
#line 672
    with_pty = default_pty;
  }
#line 674
  if (with_pty) {
#line 674
    if (! options->used_pty) {
#line 676
      options->used_pty = 1;
#line 678
      if (options->tty) {
        {
        {
#line 678
        tmp___2 = (*((options->tty)->is_tty))(options->tty);
        }
        }
#line 678
        if (tmp___2) {
          {
          {
#line 680
          tmp = make_pty_request(options->tty);
          }
#line 680
          get_pty = tmp;
          }
#line 682
          if (get_pty) {
            {
            {
#line 683
            tmp___0 = make_catch_handler_info((uint32_t )(~ 0), (uint32_t )32770,
                                              0, (struct command *)((void *)0));
            }
            {
#line 683
            tmp___1 = make_catch_apply(tmp___0, get_pty);
            }
            {
#line 683
            object_queue_add_tail(q, & tmp___1->super);
            }
            }
          } else {
            {
            {
#line 690
            werror("lsh: Can\'t use tty (probably getattr or atexit failed).\n");
            }
            }
          }
        } else {
          {
          {
#line 693
          werror("lsh: No tty available.\n");
          }
          }
        }
      } else {
        {
        {
#line 693
        werror("lsh: No tty available.\n");
        }
        }
      }
    }
  }
#line 696
  return;
}
}
#line 698 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static void client_maybe_x11(struct client_options *options , struct object_queue *q ) 
{ 
  char *display ;
  char *tmp ;
  struct command *request ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 702
  if (options->with_x11) {
    {
    {
#line 704
    tmp = getenv("DISPLAY");
    }
#line 704
    display = tmp;
#line 705
    request = (struct command *)((void *)0);
    }
#line 707
    if (! options->random) {
      {
      {
#line 707
      __assert_fail("options->random", "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c",
                    707U, "client_maybe_x11");
      }
      }
    }
#line 708
    if (display) {
      {
      {
#line 709
      request = make_forward_x11((char const   *)display, options->random);
      }
      }
    }
#line 711
    if (request) {
      {
      {
#line 713
      object_queue_add_tail(q, & request->super);
      }
#line 714
      options->used_x11 = 1;
      }
    } else {
      {
      {
#line 717
      werror("Can\'t find any local X11 display to forward.\n");
      }
      }
    }
  }
#line 719
  return;
}
}
#line 722 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct command *client_shell_session(struct client_options *options ) 
{ 
  struct ssh_channel *session ;
  struct ssh_channel *tmp ;
  struct object_queue session_requests ;
  struct command *tmp___0 ;
  struct command *r ;
  struct object_list *tmp___1 ;
  struct command *tmp___2 ;
  struct command *tmp___3 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;

  {
  {
  {
#line 725
  tmp = make_client_session(options);
  }
#line 725
  session = tmp;
  }
#line 727
  if (session) {
    {
    {
#line 731
    lsh_queue_init(& session_requests.q);
    }
    {
#line 733
    client_maybe_pty(options, 1, & session_requests);
    }
    {
#line 734
    client_maybe_x11(options, & session_requests);
    }
    {
#line 736
    tmp___0 = make_client_start_session(& request_shell.super);
    }
    {
#line 736
    object_queue_add_tail(& session_requests, & tmp___0->super);
    }
    {
#line 740
    tmp___1 = queue_to_list_and_kill(& session_requests);
    }
    {
#line 740
    tmp___2 = make_open_session_command(session);
    }
    {
#line 740
    tmp___3 = make_start_session(tmp___2, tmp___1);
    }
#line 740
    r = tmp___3;
    }
#line 744
    return (r);
  } else {
#line 748
    return ((struct command *)((void *)0));
  }
}
}
#line 752 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct command *client_subsystem_session(struct client_options *options , struct lsh_string *subsystem ) 
{ 
  struct ssh_channel *session ;
  struct ssh_channel *tmp ;
  struct command *r ;
  struct command *tmp___0 ;
  struct command *tmp___1 ;
  struct object_list *tmp___2 ;
  struct command *tmp___3 ;
  struct command *tmp___4 ;

  {
  {
  {
#line 756
  tmp = make_client_session(options);
  }
#line 756
  session = tmp;
  }
#line 758
  if (session) {
    {
    {
#line 760
    tmp___0 = make_subsystem_request(subsystem);
    }
    {
#line 760
    tmp___1 = make_client_start_session(tmp___0);
    }
    {
#line 760
    tmp___2 = make_object_list(1U, tmp___1, -1);
    }
    {
#line 760
    tmp___3 = make_open_session_command(session);
    }
    {
#line 760
    tmp___4 = make_start_session(tmp___3, tmp___2);
    }
#line 760
    r = tmp___4;
    }
#line 767
    return (r);
  }
#line 770
  return ((struct command *)((void *)0));
}
}
#line 774 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct command *client_command_session(struct client_options *options , struct lsh_string *command ) 
{ 
  struct ssh_channel *session ;
  struct ssh_channel *tmp ;
  struct object_queue session_requests ;
  struct command *tmp___0 ;
  struct command *tmp___1 ;
  struct command *r ;
  struct object_list *tmp___2 ;
  struct command *tmp___3 ;
  struct command *tmp___4 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
  {
#line 778
  tmp = make_client_session(options);
  }
#line 778
  session = tmp;
  }
#line 780
  if (session) {
    {
    {
#line 784
    lsh_queue_init(& session_requests.q);
    }
    {
#line 789
    client_maybe_pty(options, 0, & session_requests);
    }
    {
#line 790
    client_maybe_x11(options, & session_requests);
    }
    {
#line 792
    tmp___0 = make_exec_request(command);
    }
    {
#line 792
    tmp___1 = make_client_start_session(tmp___0);
    }
    {
#line 792
    object_queue_add_tail(& session_requests, & tmp___1->super);
    }
    {
#line 795
    tmp___2 = queue_to_list_and_kill(& session_requests);
    }
    {
#line 795
    tmp___3 = make_open_session_command(session);
    }
    {
#line 795
    tmp___4 = make_start_session(tmp___3, tmp___2);
    }
#line 795
    r = tmp___4;
    }
#line 799
    return (r);
  }
#line 803
  return ((struct command *)((void *)0));
}
}
#line 806 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct command *client_add_action(struct client_options *options , struct command *action ) 
{ 


  {
#line 810
  if (action) {
    {
    {
#line 811
    object_queue_add_tail(& options->actions, & action->super);
    }
    }
  }
#line 813
  return (action);
}
}
#line 816 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct command *client_prepend_action(struct client_options *options , struct command *action ) 
{ 


  {
#line 820
  if (action) {
    {
    {
#line 821
    object_queue_add_head(& options->actions, & action->super);
    }
    }
  }
#line 823
  return (action);
}
}
#line 827 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct lsh_string *rebuild_command_line(unsigned int argc , char **argv ) 
{ 
  unsigned int length ;
  unsigned int i ;
  unsigned int pos ;
  struct lsh_string *r ;
  unsigned int *alengths ;
  void *tmp ;
  unsigned int tmp___0 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
  {
#line 834
  tmp = __builtin_alloca(sizeof(unsigned int ) * (unsigned long )argc);
  }
#line 834
  alengths = (unsigned int *)tmp;
  }
#line 836
  if (! argc) {
    {
    {
#line 836
    __assert_fail("argc", "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c", 836U,
                  "rebuild_command_line");
    }
    }
  }
#line 837
  length = argc - 1U;
#line 839
  i = 0U;
  {
  {
#line 839
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 839
    if (! (i < argc)) {
#line 839
      goto while_break;
    }
    {
    {
#line 841
    *(alengths + i) = strlen((char const   *)*(argv + i));
    }
#line 842
    length += *(alengths + i);
#line 839
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 845
  r = lsh_string_alloc(length);
  }
  {
#line 846
  lsh_string_write(r, (uint32_t )0, *(alengths + 0), (uint8_t const   *)*(argv + 0));
  }
#line 847
  pos = *(alengths + 0);
#line 848
  i = 1U;
  }
  {
  {
#line 848
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 848
    if (! (i < argc)) {
#line 848
      goto while_break___0;
    }
    {
#line 850
    tmp___0 = pos;
#line 850
    pos ++;
    {
#line 850
    lsh_string_putc(r, tmp___0, (uint8_t )' ');
    }
    {
#line 851
    lsh_string_write(r, pos, *(alengths + i), (uint8_t const   *)*(argv + i));
    }
#line 852
    pos += *(alengths + i);
#line 848
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 855
  if (! (pos == length)) {
    {
    {
#line 855
    __assert_fail("pos == length", "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c",
                  855U, "rebuild_command_line");
    }
    }
  }
#line 857
  return (r);
}
}
#line 861
static void do_exit_callback(struct lsh_callback *self  __attribute__((__unused__)) ) ;
#line 861 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct escape_callback exit_callback  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_exit_callback}, "Exit."};
#line 861 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static void do_exit_callback(struct lsh_callback *self  __attribute__((__unused__)) ) 
{ 


  {
  {
  {
#line 863
  exit(0);
  }
  }
}
}
#line 866
static void do_verbose_callback(struct lsh_callback *self  __attribute__((__unused__)) ) ;
#line 866 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct escape_callback verbose_callback  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_verbose_callback}, "Toggle verbose messages."};
#line 866 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static void do_verbose_callback(struct lsh_callback *self  __attribute__((__unused__)) ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 868
  verbose_flag = ! verbose_flag;
#line 869
  if (verbose_flag) {
    {
    {
#line 870
    verbose("Enabling verbose messages\n");
    }
    }
  }
#line 871
  return;
}
}
#line 873
static void do_debug_callback(struct lsh_callback *self  __attribute__((__unused__)) ) ;
#line 873 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct escape_callback debug_callback  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_debug_callback}, "Toggle debug messages."};
#line 873 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static void do_debug_callback(struct lsh_callback *self  __attribute__((__unused__)) ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 875
  debug_flag = ! debug_flag;
#line 876
  if (debug_flag) {
    {
    {
#line 877
    debug("Enabling debug messages\n");
    }
    }
  }
#line 878
  return;
}
}
#line 880
static void do_quiet_callback(struct lsh_callback *self  __attribute__((__unused__)) ) ;
#line 880 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct escape_callback quiet_callback  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_quiet_callback}, "Toggle warning messages."};
#line 880 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static void do_quiet_callback(struct lsh_callback *self  __attribute__((__unused__)) ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 882
  quiet_flag = ! quiet_flag;
#line 883
  if (! quiet_flag) {
    {
    {
#line 884
    werror("Enabling warning messages\n");
    }
    }
  }
#line 885
  return;
}
}
#line 895 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static void do_background_process(struct command *s , struct lsh_object *a , struct command_continuation *c ,
                                  struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct background_process_command *self ;
  pid_t pid ;
  int *tmp ;
  struct lsh_string *msg ;
  struct lsh_string *tmp___0 ;
  struct exception  const  *e___0 ;
  uint8_t const   *tmp___1 ;
  uint32_t tmp___2 ;
  struct exception  const  *tmp___3 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 901
  self = (struct background_process_command *)s;
  {
#line 904
  trace("do_background_process\n");
  }
  {
#line 906
  pid = fork();
  }
  }
#line 910
  if (pid == 0) {
#line 910
    goto case_0;
  }
#line 916
  if (pid == -1) {
#line 916
    goto case_neg_1;
  }
#line 921
  goto switch_default;
  case_0: 
  {
  {
#line 914
  (*(c->c))(c, a);
  }
  }
#line 915
  goto switch_break;
  case_neg_1: 
  {
  {
#line 918
  tmp = __errno_location();
  }
  {
#line 918
  werror("background_process: fork failed %e\n", *tmp);
  }
  {
#line 919
  (*(c->c))(c, a);
  }
  }
#line 920
  goto switch_break;
  switch_default: 
#line 923
  if (self->write_pid) {
    {
    {
#line 925
    tmp___0 = ssh_format("%di\n", pid);
    }
#line 925
    msg = tmp___0;
    {
#line 926
    tmp___1 = lsh_string_data((struct lsh_string  const  *)msg);
    }
    {
#line 926
    tmp___2 = lsh_string_length((struct lsh_string  const  *)msg);
    }
    {
#line 926
    tmp___3 = write_raw(1, tmp___2, tmp___1);
    }
#line 926
    e___0 = tmp___3;
    }
#line 928
    if (e___0) {
      {
      {
#line 929
      werror("Write to stdout failed!?: %z\n", e___0->msg);
      }
      }
    }
  }
  {
  {
#line 931
  _exit(0);
  }
  }
  switch_break: ;
#line 933
  return;
}
}
#line 935 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct command *make_background_process(int write_pid ) 
{ 
  struct background_process_command *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 938
  tmp = lsh_object_alloc(& background_process_command_class);
  }
#line 938
  self = (struct background_process_command *)tmp;
#line 940
  self->super.call = & do_background_process;
#line 941
  self->write_pid = write_pid;
  }
#line 943
  return (& self->super);
}
}
#line 950 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static struct ssh_channel *make_client_session(struct client_options *options ) 
{ 
  int in ;
  int out ;
  int err ;
  enum io_type in_type ;
  enum io_type out_type ;
  enum io_type err_type ;
  int is_tty ;
  struct ssh_channel *session ;
  struct escape_info *escape ;
  struct lsh_callback *detach_cb ;
  int *tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  struct lsh_fd *tmp___3 ;
  struct lsh_fd *tmp___4 ;
  struct lsh_fd *tmp___5 ;
  struct lsh_fd *tmp___6 ;
  struct lsh_fd *tmp___7 ;
  struct lsh_fd *tmp___8 ;
  struct resource *tmp___9 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;

  {
  {
#line 956
  in_type = (enum io_type )0;
#line 957
  out_type = (enum io_type )0;
#line 958
  err_type = (enum io_type )0;
#line 960
  is_tty = 0;
#line 963
  escape = (struct escape_info *)((void *)0);
#line 964
  detach_cb = (struct lsh_callback *)((void *)0);
  {
#line 966
  debug("lsh.c: Setting up stdin\n");
  }
  }
#line 968
  if (options->stdin_file) {
    {
    {
#line 969
    in = open(options->stdin_file, 0);
    }
    }
  } else
#line 973
  if (options->used_stdin) {
    {
    {
#line 974
    in = open("/dev/null", 0);
    }
    }
  } else {
    {
#line 977
    in = 0;
#line 978
    in_type = (enum io_type )2;
    {
#line 979
    is_tty = isatty(0);
    }
#line 981
    options->used_stdin = 1;
    }
  }
#line 985
  if (in < 0) {
    {
    {
#line 987
    tmp = __errno_location();
    }
    {
#line 987
    werror("lsh: Can\'t open stdin %e\n", *tmp);
    }
    }
#line 988
    return ((struct ssh_channel *)((void *)0));
  }
#line 992
  if (options->escape > 0) {
    {
    {
#line 994
    verbose("Enabling explicit escape character `%pc\'\n", options->escape);
    }
    {
#line 996
    escape = make_escape_info((uint8_t )options->escape);
    }
    }
  } else
#line 998
  if (options->escape < 0) {
#line 998
    if (is_tty) {
      {
      {
#line 1000
      verbose("Enabling default escape character `%pc\'\n", '~');
      }
      {
#line 1002
      escape = make_escape_info((uint8_t )'~');
      }
      }
    }
  }
#line 1006
  if (escape) {
#line 1009
    escape->dispatch[26] = & suspend_callback;
#line 1010
    escape->dispatch['.'] = & exit_callback;
#line 1013
    escape->dispatch['d'] = & debug_callback;
#line 1014
    escape->dispatch['v'] = & verbose_callback;
#line 1015
    escape->dispatch['q'] = & quiet_callback;
  }
  {
  {
#line 1018
  debug("lsh.c: Setting up stdout\n");
  }
  }
#line 1020
  if (options->stdout_file) {
    {
    {
#line 1022
    out = open(options->stdout_file, 65, 438);
    }
    }
  } else {
#line 1025
    out_type = (enum io_type )2;
#line 1026
    out = 1;
  }
#line 1028
  if (out < 0) {
    {
    {
#line 1030
    tmp___0 = __errno_location();
    }
    {
#line 1030
    werror("lsh: Can\'t open stdout %e\n", *tmp___0);
    }
    {
#line 1031
    close(in);
    }
    }
#line 1032
    return ((struct ssh_channel *)((void *)0));
  }
  {
  {
#line 1035
  debug("lsh.c: Setting up stderr\n");
  }
  }
#line 1037
  if (options->stderr_file) {
    {
    {
#line 1039
    err = open(options->stderr_file, 65, 438);
    }
    }
  } else {
#line 1042
    err_type = (enum io_type )3;
#line 1043
    err = 2;
  }
#line 1045
  if (err < 0) {
    {
    {
#line 1047
    werror("lsh: Can\'t open stderr!\n");
    }
    {
#line 1048
    close(in);
    }
    {
#line 1049
    close(out);
    }
    }
#line 1050
    return ((struct ssh_channel *)((void *)0));
  }
#line 1053
  if (options->detach_end) {
    {
    {
#line 1054
    detach_cb = make_detach_callback(options->exit_code);
    }
    }
  }
  {
#line 1057
  tmp___2 = (char const   *)((void *)0);
#line 1057
  options->stderr_file = tmp___2;
#line 1057
  tmp___1 = tmp___2;
#line 1057
  options->stdout_file = tmp___1;
#line 1057
  options->stdin_file = tmp___1;
  {
#line 1059
  tmp___3 = make_lsh_fd(err, err_type, "client stderr", options->handler);
  }
  {
#line 1059
  tmp___4 = io_write(tmp___3, (uint32_t )32768, (struct lsh_callback *)((void *)0));
  }
  {
#line 1059
  tmp___5 = make_lsh_fd(out, out_type, "client stdout", options->handler);
  }
  {
#line 1059
  tmp___6 = io_write(tmp___5, (uint32_t )32768, detach_cb);
  }
  {
#line 1059
  tmp___7 = make_lsh_fd(in, in_type, "client stdin", options->handler);
  }
  {
#line 1059
  tmp___8 = io_read(tmp___7, (struct io_callback *)((void *)0), (struct lsh_callback *)((void *)0));
  }
  {
#line 1059
  session = make_client_session_channel(tmp___8, tmp___6, tmp___4, escape, (uint32_t )10000,
                                        options->exit_code);
  }
  }
#line 1071
  if (options->detach_end) {
    {
    {
#line 1073
    tmp___9 = make_detach_resource(detach_cb);
    }
    {
#line 1073
    remember_resource(session->resources, tmp___9);
    }
#line 1074
    options->detach_end = 0;
    }
  }
  {
  {
#line 1080
  remember_resource(options->resources, & (session->resources)->super);
  }
  }
#line 1082
  return (session);
}
}
#line 1088 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
void envp_parse(struct argp  const  *argp , char const   **envp , char const   *name ,
                unsigned int flags , void *input ) 
{ 
  struct client_options *options ;
  int nlen ;
  size_t tmp ;
  char **sim_argv ;
  char *entry ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int sim_argc ;
  char *token ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 1095
  options = (struct client_options *)input;
  {
#line 1096
  tmp = strlen(name);
  }
#line 1096
  nlen = (int )tmp;
  }
  {
  {
#line 1098
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 1098
    if (! *envp) {
#line 1098
      goto while_break;
    }
    {
    {
#line 1100
    tmp___4 = strncmp(*envp, name, (size_t )nlen);
    }
    }
#line 1100
    if (! tmp___4) {
      {
      {
#line 1107
      entry = strdup(*envp + nlen);
      }
      }
#line 1109
      if (entry) {
        {
        {
#line 1112
        tmp___0 = strlen((char const   *)entry);
        }
        {
#line 1112
        tmp___1 = malloc((size_t )(sizeof(char *) * (unsigned long )(tmp___0 + 2U)));
        }
#line 1112
        sim_argv = (char **)tmp___1;
        }
#line 1114
        if (sim_argv) {
          {
#line 1116
          sim_argc = 1;
          {
#line 1117
          tmp___2 = strtok((char */* __restrict  */)entry, (char const   */* __restrict  */)" \n\t");
          }
#line 1117
          token = tmp___2;
#line 1119
          *(sim_argv + 0) = (char *)"";
          }
          {
          {
#line 1121
          while (1) {
            while_continue___2: /* CIL Label */ ;
            while_continue___0: /* CIL Label */ ;

#line 1121
            if (! token) {
#line 1121
              goto while_break___0;
            }
            {
#line 1123
            tmp___3 = sim_argc;
#line 1123
            sim_argc ++;
#line 1123
            *(sim_argv + tmp___3) = token;
            {
#line 1124
            token = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \n\t");
            }
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
          while_break___0: 
          {
#line 1127
          *(sim_argv + sim_argc) = (char *)((void *)0);
#line 1129
          options->inhibit_actions = 1;
          {
#line 1130
          argp_parse(argp, sim_argc, sim_argv, (flags | 2U) | 32U, (int *)((void *)0),
                     input);
          }
#line 1131
          options->inhibit_actions = 0;
          }
        }
      }
    }
#line 1136
    envp ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1138
  return;
}
}
#line 1141 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
int client_parse_forward_arg(char *arg , uint32_t *listen_port , struct address_info **target ) 
{ 
  char *first ;
  char *second ;
  char *end ;
  long port ;
  char *tmp ;
  struct lsh_string *tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 1151
  first = strchr((char const   *)arg, ':');
  }
  }
#line 1152
  if (! first) {
#line 1153
    return (0);
  }
  {
  {
#line 1155
  second = strchr((char const   *)(first + 1), ':');
  }
  }
#line 1156
  if (! second) {
#line 1157
    return (0);
  } else
#line 1156
  if ((unsigned long )second == (unsigned long )(first + 1)) {
#line 1157
    return (0);
  }
  {
  {
#line 1159
  tmp = strchr((char const   *)(second + 1), ':');
  }
  }
#line 1159
  if (tmp) {
#line 1160
    return (0);
  }
  {
  {
#line 1162
  port = strtol((char const   */* __restrict  */)((char const   *)arg), (char **/* __restrict  */)(& end),
                0);
  }
  }
#line 1163
  if ((unsigned long )end == (unsigned long )arg) {
#line 1165
    return (0);
  } else
#line 1163
  if ((unsigned long )end != (unsigned long )first) {
#line 1165
    return (0);
  } else
#line 1163
  if (port < 0L) {
#line 1165
    return (0);
  } else
#line 1163
  if (port > 65535L) {
#line 1165
    return (0);
  }
  {
#line 1167
  *listen_port = (uint32_t )port;
  {
#line 1169
  port = strtol((char const   */* __restrict  */)((char const   *)(second + 1)), (char **/* __restrict  */)(& end),
                0);
  }
  }
#line 1170
  if ((unsigned long )end == (unsigned long )(second + 1)) {
#line 1172
    return (0);
  } else
#line 1170
  if ((int )*end != 0) {
#line 1172
    return (0);
  } else
#line 1170
  if (port < 0L) {
#line 1172
    return (0);
  } else
#line 1170
  if (port > 65535L) {
#line 1172
    return (0);
  }
  {
  {
#line 1174
  tmp___0 = ssh_format("%ls", (second - first) - 1L, first + 1);
  }
  {
#line 1174
  *target = make_address_info(tmp___0, (uint32_t )port);
  }
  }
#line 1176
  return (1);
}
}
#line 1179 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static int client_arg_unsigned(char const   *arg , unsigned long *n ) 
{ 
  char *end ;

  {
#line 1183
  if ((int const   )*arg == 0) {
#line 1184
    return (0);
  }
  {
  {
#line 1186
  *n = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& end),
               0);
  }
  }
#line 1187
  return ((int )*end == 0);
}
}
#line 1218 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
static error_t client_argp_parser(int key , char *arg , struct argp_state *state ) 
{ 
  struct client_options *options ;
  struct lsh_string *tmp ;
  struct command *tmp___0 ;
  struct command *tmp___1 ;
  struct command *tmp___2 ;
  struct command *tmp___3 ;
  int tmp___4 ;
  struct lsh_string *tmp___5 ;
  struct command *tmp___6 ;
  struct command *tmp___7 ;
  struct lsh_string *tmp___8 ;
  struct command *tmp___9 ;
  uint32_t listen_port ;
  struct address_info *target ;
  int tmp___10 ;
  struct lsh_string *tmp___11 ;
  struct lsh_string *tmp___12 ;
  struct address_info *tmp___13 ;
  struct command *tmp___14 ;
  unsigned long socks_port ;
  int tmp___15 ;
  struct lsh_string *tmp___16 ;
  struct lsh_string *tmp___17 ;
  struct address_info *tmp___18 ;
  struct command *tmp___19 ;
  struct command *tmp___20 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;

  {
#line 1221
  options = (struct client_options *)state->input;
#line 1227
  if (key == 16777218) {
#line 1227
    goto case_16777218;
  }
#line 1230
  if (key == 0) {
#line 1230
    goto case_0;
  }
#line 1239
  if (key == 16777222) {
#line 1239
    goto case_16777222;
  }
#line 1248
  if (key == 16777217) {
#line 1248
    goto case_16777217;
  }
#line 1279
  if (key == 112) {
#line 1279
    goto case_112;
  }
#line 1283
  if (key == 108) {
#line 1283
    goto case_108;
  }
#line 1287
  if (key == 534) {
#line 1287
    goto case_534;
  }
#line 1291
  if (key == 101) {
#line 1291
    goto case_101;
  }
#line 1301
  if (key == 69) {
#line 1301
    goto case_69;
  }
#line 1307
  if (key == 83) {
#line 1307
    goto case_83;
  }
#line 1311
  if (key == 532) {
#line 1311
    goto case_532;
  }
#line 1322
  if (key == 76) {
#line 1322
    goto case_76;
  }
#line 1339
  if (key == 68) {
#line 1339
    goto case_68;
  }
#line 1353
  if (key == 78) {
#line 1353
    goto case_78;
  }
#line 1357
  if (key == 66) {
#line 1357
    goto case_66;
  }
#line 1362
  if (key == 103) {
#line 1362
    goto case_103;
  }
#line 1362
  if (key == 1127) {
#line 1362
    goto case_1127;
  }
#line 1365
  if (key == 116) {
#line 1365
    goto case_116;
  }
#line 1365
  if (key == 1140) {
#line 1365
    goto case_1140;
  }
#line 1368
  if (key == 533) {
#line 1368
    goto case_533;
  }
#line 1368
  if (key == 1557) {
#line 1368
    goto case_1557;
  }
#line 1369
  if (key == 535) {
#line 1369
    goto case_535;
  }
#line 1369
  if (key == 1559) {
#line 1369
    goto case_1559;
  }
#line 1371
  if (key == 528) {
#line 1371
    goto case_528;
  }
#line 1371
  if (key == 1552) {
#line 1371
    goto case_1552;
  }
#line 1372
  if (key == 529) {
#line 1372
    goto case_529;
  }
#line 1372
  if (key == 1553) {
#line 1372
    goto case_1553;
  }
#line 1373
  if (key == 530) {
#line 1373
    goto case_530;
  }
#line 1373
  if (key == 1554) {
#line 1373
    goto case_1554;
  }
#line 1375
  if (key == 110) {
#line 1375
    goto case_110;
  }
#line 1225
  goto switch_default;
  switch_default: 
#line 1226
  return (7);
  case_16777218: 
  {
  {
#line 1228
  argp_usage((struct argp_state  const  *)state);
  }
  }
#line 1229
  goto switch_break;
  case_0: 
#line 1231
  if (! state->arg_num) {
#line 1232
    options->target = (char const   *)arg;
  } else {
#line 1236
    return (7);
  }
#line 1238
  goto switch_break;
  case_16777222: 
  {
  {
#line 1240
  tmp = rebuild_command_line((unsigned int )(state->argc - state->next), state->argv + state->next);
  }
  {
#line 1240
  tmp___0 = client_command_session(options, tmp);
  }
  {
#line 1240
  client_add_action(options, tmp___0);
  }
#line 1245
  options->start_shell = 0;
  }
#line 1246
  goto switch_break;
  case_16777217: 
#line 1249
  if (options->inhibit_actions) {
#line 1250
    goto switch_break;
  }
#line 1252
  if (! options->user) {
    {
    {
#line 1254
    argp_error((struct argp_state  const  *)state, "No user name given. Use the -l option, or set LOGNAME in the environment.");
    }
    }
#line 1255
    goto switch_break;
  }
#line 1259
  if (options->remote_forward) {
    {
    {
#line 1260
    tmp___1 = make_install_fix_channel_open_handler((uint32_t )69, & channel_open_forwarded_tcpip);
    }
    {
#line 1260
    client_add_action(options, tmp___1);
    }
    }
  }
#line 1266
  if (options->start_shell) {
    {
    {
#line 1267
    tmp___2 = client_shell_session(options);
    }
    {
#line 1267
    client_add_action(options, tmp___2);
    }
    }
  }
#line 1269
  if (options->used_x11) {
    {
    {
#line 1270
    tmp___3 = make_install_fix_channel_open_handler((uint32_t )55, & channel_open_x11);
    }
    {
#line 1270
    client_add_action(options, tmp___3);
    }
    }
  }
  {
  {
#line 1276
  suspend_install_handler();
  }
  }
#line 1277
  goto switch_break;
  case_112: 
#line 1280
  options->port = (char const   *)arg;
#line 1281
  goto switch_break;
  case_108: 
#line 1284
  options->user = arg;
#line 1285
  goto switch_break;
  case_534: 
  {
  {
#line 1288
  (*((options->tty)->set_askpass))(options->tty, (char const   *)arg);
  }
  }
#line 1289
  goto switch_break;
  case_101: 
#line 1292
  if (*(arg + 0)) {
#line 1292
    if (! *(arg + 1)) {
#line 1294
      options->escape = (int )*(arg + 0);
    } else {
#line 1292
      goto _L;
    }
  } else {
    _L: 
    {
    {
#line 1295
    tmp___4 = strcasecmp((char const   *)arg, "none");
    }
    }
#line 1295
    if (tmp___4) {
      {
      {
#line 1298
      argp_error((struct argp_state  const  *)state, "Invalid escape char: `%s\'. You must use a single character or `none\'.",
                 arg);
      }
      }
    } else {
#line 1296
      options->escape = 0;
    }
  }
#line 1300
  goto switch_break;
  case_69: 
  {
  {
#line 1302
  tmp___5 = ssh_format("%lz", arg);
  }
  {
#line 1302
  tmp___6 = client_command_session(options, tmp___5);
  }
  {
#line 1302
  client_add_action(options, tmp___6);
  }
  }
#line 1305
  goto switch_break;
  case_83: 
  {
  {
#line 1308
  tmp___7 = client_shell_session(options);
  }
  {
#line 1308
  client_add_action(options, tmp___7);
  }
  }
#line 1309
  goto switch_break;
  case_532: 
  {
  {
#line 1312
  tmp___8 = ssh_format("%lz", arg);
  }
  {
#line 1312
  tmp___9 = client_subsystem_session(options, tmp___8);
  }
  {
#line 1312
  client_add_action(options, tmp___9);
  }
#line 1316
  options->start_shell = 0;
#line 1318
  options->with_pty = 0;
  }
#line 1320
  goto switch_break;
  case_76: 
  {
  {
#line 1327
  tmp___10 = client_parse_forward_arg(arg, & listen_port, & target);
  }
  }
#line 1327
  if (! tmp___10) {
    {
    {
#line 1328
    argp_error((struct argp_state  const  *)state, "Invalid forward specification `%s\'.",
               arg);
    }
    }
  }
#line 1330
  if (options->with_remote_peers) {
#line 1330
    tmp___12 = (struct lsh_string *)((void *)0);
  } else {
    {
    {
#line 1330
    tmp___11 = ssh_format("%lz", "127.0.0.1");
    }
#line 1330
    tmp___12 = tmp___11;
    }
  }
  {
  {
#line 1330
  tmp___13 = make_address_info(tmp___12, listen_port);
  }
  {
#line 1330
  tmp___14 = make_forward_local_port(tmp___13, target);
  }
  {
#line 1330
  client_add_action(options, tmp___14);
  }
  }
#line 1336
  goto switch_break;
  case_68: 
#line 1341
  socks_port = 1080UL;
#line 1342
  if (arg) {
    {
    {
#line 1342
    tmp___15 = client_arg_unsigned((char const   *)arg, & socks_port);
    }
    }
#line 1342
    if (tmp___15 == 0) {
      {
      {
#line 1343
      argp_error((struct argp_state  const  *)state, "Invalid port number `%s\' for socks.",
                 arg);
      }
      }
    } else
#line 1342
    if (socks_port > 65535UL) {
      {
      {
#line 1343
      argp_error((struct argp_state  const  *)state, "Invalid port number `%s\' for socks.",
                 arg);
      }
      }
    }
  }
#line 1345
  if (options->with_remote_peers) {
#line 1345
    tmp___17 = (struct lsh_string *)((void *)0);
  } else {
    {
    {
#line 1345
    tmp___16 = ssh_format("%lz", "127.0.0.1");
    }
#line 1345
    tmp___17 = tmp___16;
    }
  }
  {
  {
#line 1345
  tmp___18 = make_address_info(tmp___17, (uint32_t )socks_port);
  }
  {
#line 1345
  tmp___19 = make_socks_server(tmp___18);
  }
  {
#line 1345
  client_add_action(options, tmp___19);
  }
  }
#line 1350
  goto switch_break;
  case_78: 
#line 1354
  options->start_shell = 0;
#line 1355
  goto switch_break;
  case_66: 
  {
#line 1358
  options->start_shell = 0;
  {
#line 1359
  tmp___20 = make_background_process(options->write_pid);
  }
  {
#line 1359
  client_add_action(options, tmp___20);
  }
  }
#line 1360
  goto switch_break;
  case_103: 
#line 1362
  if (options->not) {
#line 1362
    options->not = 0;
    case_1127: 
#line 1362
    options->with_remote_peers = 0;
#line 1362
    goto switch_break;
  }
#line 1362
  options->with_remote_peers = 1;
#line 1362
  goto switch_break;
  case_116: 
#line 1365
  if (options->not) {
#line 1365
    options->not = 0;
    case_1140: 
#line 1365
    options->with_pty = 0;
#line 1365
    goto switch_break;
  }
#line 1365
  options->with_pty = 1;
#line 1365
  goto switch_break;
  case_533: 
#line 1368
  if (options->not) {
#line 1368
    options->not = 0;
    case_1557: 
#line 1368
    options->detach_end = 0;
#line 1368
    goto switch_break;
  }
#line 1368
  options->detach_end = 1;
#line 1368
  goto switch_break;
  case_535: 
#line 1369
  if (options->not) {
#line 1369
    options->not = 0;
    case_1559: 
#line 1369
    options->write_pid = 0;
#line 1369
    goto switch_break;
  }
#line 1369
  options->write_pid = 1;
#line 1369
  goto switch_break;
  case_528: 
#line 1371
  if (options->not) {
#line 1371
    options->not = 0;
    case_1552: 
#line 1371
    options->stdin_file = "/dev/null";
#line 1371
    goto switch_break;
  }
#line 1371
  options->stdin_file = (char const   *)arg;
#line 1371
  goto switch_break;
  case_529: 
#line 1372
  if (options->not) {
#line 1372
    options->not = 0;
    case_1553: 
#line 1372
    options->stdout_file = "/dev/null";
#line 1372
    goto switch_break;
  }
#line 1372
  options->stdout_file = (char const   *)arg;
#line 1372
  goto switch_break;
  case_530: 
#line 1373
  if (options->not) {
#line 1373
    options->not = 0;
    case_1554: 
#line 1373
    options->stderr_file = "/dev/null";
#line 1373
    goto switch_break;
  }
#line 1373
  options->stderr_file = (char const   *)arg;
#line 1373
  goto switch_break;
  case_110: 
#line 1376
  options->not = ! options->not;
#line 1377
  goto switch_break;
  switch_break: ;
#line 1379
  return (0);
}
}
#line 1382 "/home/ysko/Works/test-src/lsh-2.0.4/src/client.c"
struct argp  const  client_argp  =    {client_options, & client_argp_parser, (char const   *)((void *)0), (char const   *)((void *)0),
    (struct argp_child  const  *)((void *)0), (char *(*)(int __key , char const   *__text ,
                                                         void *__input ))((void *)0),
    (char const   *)((void *)0)};
#line 37 "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.h"
void set_local_charset(int charset ) ;
#line 39
uint32_t local_to_ucs4(int c ) ;
#line 40
int ucs4_to_local(uint32_t c ) ;
#line 40 "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.c"
static int local_charset  ;
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.c"
void set_local_charset(int charset ) 
{ 


  {
#line 44
  local_charset = charset;
#line 45
  return;
}
}
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.c"
uint32_t local_to_ucs4(int c ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 52
  if (local_charset == 1) {
#line 52
    goto case_1;
  }
#line 52
  if (local_charset == 2) {
#line 52
    goto case_1;
  }
#line 54
  goto switch_default;
  case_1: 
#line 53
  return ((uint32_t )c);
  switch_default: 
  {
  {
#line 55
  fatal("Internal error");
  }
  }

#line 60
  return (0U);
}
}
#line 60 "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.c"
int ucs4_to_local(uint32_t c ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 64
  if (local_charset == 2) {
#line 64
    goto case_2;
  }
#line 66
  if (local_charset == 1) {
#line 66
    goto case_1;
  }
#line 68
  goto switch_default;
  case_2: 
#line 65
  if (c < 128U) {
#line 65
    tmp = (int )c;
  } else {
#line 65
    tmp = -1;
  }
#line 65
  return (tmp);
  case_1: 
#line 67
  if (c < 256U) {
#line 67
    tmp___0 = (int )c;
  } else {
#line 67
    tmp___0 = -1;
  }
#line 67
  return (tmp___0);
  switch_default: 
  {
  {
#line 69
  fatal("Internal error");
  }
  }

#line 74
  return (0);
}
}
#line 129 "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.c"
static uint8_t const   prefix[6]  = {      (uint8_t const   )0,      (uint8_t const   )192,      (uint8_t const   )224,      (uint8_t const   )240, 
        (uint8_t const   )248,      (uint8_t const   )252};
#line 86
extern int ( /* missing proto */  zoo_assume)() ;
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.c"
struct lsh_string *local_to_utf8(struct lsh_string *s , int free___0 ) 
{ 
  uint32_t length ;
  uint32_t tmp ;
  uint8_t const   *data ;
  uint8_t const   *tmp___0 ;
  uint32_t *chars ;
  void *tmp___1 ;
  unsigned char *lengths ;
  void *tmp___2 ;
  uint32_t total ;
  uint32_t i ;
  uint32_t c ;
  uint32_t tmp___3 ;
  unsigned char l ;
  struct lsh_string *res ;
  struct lsh_string *tmp___4 ;
  uint32_t i___0 ;
  uint32_t j ;
  uint32_t c___0 ;
  unsigned char l___0 ;
  int k ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 79
  if (local_charset == 2) {
#line 79
    goto case_2;
  }
#line 79
  if (local_charset == 0) {
#line 79
    goto case_2;
  }
#line 81
  goto switch_default;
  case_2: 
#line 80
  return (s);
  switch_default: 
  {
  {
#line 83
  tmp = lsh_string_length((struct lsh_string  const  *)s);
  }
#line 83
  length = tmp;
  {
#line 84
  tmp___0 = lsh_string_data((struct lsh_string  const  *)s);
  }
#line 84
  data = tmp___0;
  {
#line 86
  zoo_assume(length > 0U);
  }
  {
#line 87
  tmp___1 = __builtin_alloca((unsigned long )length * sizeof(uint32_t ));
  }
#line 86
  chars = (uint32_t *)tmp___1;
  {
#line 87
  tmp___2 = __builtin_alloca((unsigned long )length);
  }
#line 87
  lengths = (unsigned char *)tmp___2;
#line 89
  total = (uint32_t )0;
#line 95
  i = (uint32_t )0;
  }
  {
  {
#line 95
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 95
    if (! (i < length)) {
#line 95
      goto while_break;
    }
    {
    {
#line 97
    tmp___3 = local_to_ucs4((int )*(data + i));
    }
#line 97
    c = tmp___3;
#line 98
    l = (unsigned char)1;
    }
#line 100
    if ((unsigned long )c >= 1UL << 7) {
#line 102
      l = (unsigned char )((int )l + 1);
#line 103
      if ((unsigned long )c >= 1UL << 11) {
#line 105
        l = (unsigned char )((int )l + 1);
#line 106
        if ((unsigned long )c >= 1UL << 16) {
#line 108
          l = (unsigned char )((int )l + 1);
#line 109
          if ((unsigned long )c >= 1UL << 21) {
#line 111
            l = (unsigned char )((int )l + 1);
#line 112
            if ((unsigned long )c >= 1UL << 25) {
#line 114
              l = (unsigned char )((int )l + 1);
#line 115
              if ((unsigned long )c >= 1UL << 31) {
                {
                {
#line 116
                fatal("Internal error!\n");
                }
                }
              }
            }
          }
        }
      }
    }
#line 118
    *(chars + i) = c;
#line 119
    *(lengths + i) = l;
#line 120
    total += (uint32_t )l;
#line 95
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 124
  tmp___4 = lsh_string_alloc(total);
  }
#line 124
  res = tmp___4;
#line 127
  j = (uint32_t )0;
#line 127
  i___0 = j;
  }
  {
  {
#line 127
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 127
    if (! (i___0 < length)) {
#line 127
      goto while_break___0;
    }
#line 132
    c___0 = *(chars + i___0);
#line 133
    l___0 = (unsigned char )((int )*(lengths + i___0) - 1);
#line 136
    k = (int )l___0;
    {
    {
#line 136
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;

#line 136
      if (! k) {
#line 136
        goto while_break___1;
      }
      {
      {
#line 138
      lsh_string_putc(res, j + (uint32_t )k, (uint8_t )(128U | (c___0 & 63U)));
      }
#line 139
      c___0 >>= 6;
#line 136
      k --;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
#line 141
    if (! (! ((unsigned int )prefix[l___0] & c___0))) {
      {
      {
#line 141
      __assert_fail("!(prefix[l] & c)", "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.c",
                    141U, "local_to_utf8");
      }
      }
    }
    {
    {
#line 142
    lsh_string_putc(res, j, (uint8_t )((unsigned int )prefix[l___0] | c___0));
    }
#line 144
    j += (uint32_t )*(lengths + i___0);
#line 127
    i___0 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 146
  if (! (j == total)) {
    {
    {
#line 146
    __assert_fail("j == total", "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.c",
                  146U, "local_to_utf8");
    }
    }
  }
#line 148
  if (free___0) {
    {
    {
#line 149
    lsh_string_free((struct lsh_string  const  *)s);
    }
    }
  }
#line 151
  return (res);

#line 155
  return ((struct lsh_string *)0);
}
}
#line 157 "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.c"
static int ucs4_is_control(uint32_t c ) 
{ 
  int tmp ;

  {
#line 161
  if (c < 32U) {
#line 161
    if (c != 10U) {
#line 161
      tmp = 1;
    } else {
#line 161
      goto _L;
    }
  } else
  _L: 
#line 161
  if (c >= 127U) {
#line 161
    if (c < 160U) {
#line 161
      tmp = 1;
    } else {
#line 161
      tmp = 0;
    }
  } else {
#line 161
    tmp = 0;
  }
#line 161
  return (tmp);
}
}
#line 164 "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.c"
struct lsh_string *low_utf8_to_local(uint32_t length , uint8_t const   *s , enum utf8_flag flags ) 
{ 
  uint32_t i ;
  struct lsh_string *res ;
  struct simple_buffer buffer ;
  uint32_t ucs4 ;
  unsigned int utf8_length ;
  int tmp ;
  uint32_t tmp___0 ;
  int local ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  uint32_t tmp___4 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
  {
#line 172
  res = lsh_string_alloc(length);
  }
  {
#line 174
  simple_buffer_init(& buffer, length, s);
  }
#line 176
  i = (uint32_t )0;
  }
  {
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 183
    tmp = parse_utf8(& buffer, & ucs4, & utf8_length);
    }
    }
#line 185
    if (tmp == -1) {
#line 185
      goto case_neg_1;
    }
#line 192
    if (tmp == 1) {
#line 192
      goto case_1;
    }
#line 223
    if (tmp == 0) {
#line 223
      goto case_0;
    }
#line 234
    goto switch_default;
    case_neg_1: 
#line 186
    if (! (i <= length)) {
      {
      {
#line 186
      __assert_fail("i<=length", "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.c",
                    186U, "low_utf8_to_local");
      }
      }
    }
    {
    {
#line 188
    lsh_string_trunc(res, i);
    }
    }
#line 190
    return (res);
    case_1: 
#line 194
    if ((unsigned int )flags & 2U) {
      {
      {
#line 194
      tmp___3 = ucs4_is_control(ucs4);
      }
      }
#line 194
      if (tmp___3) {
#line 196
        if ((unsigned int )flags & 1U) {
          {
#line 197
          tmp___0 = i;
#line 197
          i ++;
          {
#line 197
          lsh_string_putc(res, tmp___0, (uint8_t )'?');
          }
          }
        } else {
#line 199
          goto fail;
        }
      } else {
#line 194
        goto _L;
      }
    } else
    _L: 
#line 201
    if (local_charset == 0) {
      {
      {
#line 203
      lsh_string_write(res, i, utf8_length, (buffer.data + buffer.pos) - utf8_length);
      }
#line 205
      i += utf8_length;
      }
    } else {
      {
      {
#line 209
      tmp___1 = ucs4_to_local(ucs4);
      }
#line 209
      local = tmp___1;
      }
#line 210
      if (local < 0) {
#line 212
        if ((unsigned int )flags & 1U) {
#line 214
          local = '?';
        } else {
#line 216
          goto fail;
        }
      }
      {
#line 219
      tmp___2 = i;
#line 219
      i ++;
      {
#line 219
      lsh_string_putc(res, tmp___2, (uint8_t )local);
      }
      }
    }
#line 221
    goto switch_break;
    case_0: 
#line 224
    if ((unsigned int )flags & 4U) {
      {
#line 225
      tmp___4 = i;
#line 225
      i ++;
      {
#line 225
      lsh_string_putc(res, tmp___4, (uint8_t )'?');
      }
      }
    } else {
      fail: 
      {
      {
#line 229
      lsh_string_free((struct lsh_string  const  *)res);
      }
      }
#line 231
      return ((struct lsh_string *)((void *)0));
    }
#line 233
    goto switch_break;
    switch_default: 
    {
    {
#line 236
    fatal("Internal error!\n");
    }
    }
    switch_break: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }

#line 244
  return ((struct lsh_string *)0);
}
}
#line 241 "/home/ysko/Works/test-src/lsh-2.0.4/src/charset.c"
struct lsh_string *utf8_to_local(struct lsh_string *s , enum utf8_flag flags , int free___0 ) 
{ 
  struct lsh_string *res ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;

  {
  {
  {
#line 247
  tmp = lsh_string_data((struct lsh_string  const  *)s);
  }
  {
#line 247
  tmp___0 = lsh_string_length((struct lsh_string  const  *)s);
  }
  {
#line 247
  res = low_utf8_to_local(tmp___0, tmp, flags);
  }
  }
#line 249
  if (free___0) {
    {
    {
#line 250
    lsh_string_free((struct lsh_string  const  *)s);
    }
    }
  }
#line 252
  return (res);
}
}
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.h.x"
static void do_channel_forward_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct channel_forward *i ;

  {
  {
#line 18
  i = (struct channel_forward *)o;
  {
#line 19
  (*mark)((struct lsh_object *)i->socket);
  }
  }
#line 20
  return;
}
}
#line 21 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.h.x"
struct lsh_class channel_forward_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & ssh_channel_class, (char *)"channel_forward", (size_t )sizeof(struct channel_forward ),
    & do_channel_forward_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.c"
void init_channel_forward(struct channel_forward *self , struct lsh_fd *socket___0 ,
                          uint32_t initial_window ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 50
  if (! socket___0) {
    {
    {
#line 50
    __assert_fail("socket", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.c",
                  50U, "init_channel_forward");
    }
    }
  }
  {
  {
#line 52
  init_channel(& self->super);
  }
#line 60
  self->super.rec_window_size = initial_window;
#line 63
  self->super.rec_max_packet = (uint32_t )32768;
#line 65
  self->socket = socket___0;
  {
#line 67
  remember_resource(self->super.resources, & socket___0->super);
  }
  }
#line 68
  return;
}
}
#line 70 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.c"
struct channel_forward *make_channel_forward(struct lsh_fd *socket___0 , uint32_t initial_window ) 
{ 
  struct channel_forward *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 73
  tmp = lsh_object_alloc(& channel_forward_class);
  }
#line 73
  self = (struct channel_forward *)tmp;
  {
#line 74
  init_channel_forward(self, socket___0, initial_window);
  }
  }
#line 76
  return (self);
}
}
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.c"
static void do_channel_forward_receive(struct ssh_channel *c , int type , struct lsh_string *data ) 
{ 
  struct channel_forward *closure ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 83
  closure = (struct channel_forward *)c;
#line 87
  if (type == 0) {
#line 87
    goto case_0;
  }
#line 90
  if (type == 1) {
#line 90
    goto case_1;
  }
#line 94
  goto switch_default;
  case_0: 
  {
  {
#line 88
  (*(((closure->socket)->write_buffer)->super.write))(& ((closure->socket)->write_buffer)->super,
                                                      data);
  }
  }
#line 89
  goto switch_break;
  case_1: 
  {
  {
#line 91
  werror("Ignoring unexpected stderr data.\n");
  }
  {
#line 92
  lsh_string_free((struct lsh_string  const  *)data);
  }
  }
#line 93
  goto switch_break;
  switch_default: 
  {
  {
#line 95
  fatal("Internal error. do_channel_forward_receive");
  }
  }
  switch_break: ;
#line 97
  return;
}
}
#line 99 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.c"
static void do_channel_forward_send_adjust(struct ssh_channel *s , uint32_t i  __attribute__((__unused__)) ) 
{ 
  struct channel_forward *self ;

  {
  {
#line 103
  self = (struct channel_forward *)s;
  {
#line 105
  lsh_oop_register_read_fd(self->socket);
  }
  }
#line 106
  return;
}
}
#line 108 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.c"
static void do_channel_forward_eof(struct ssh_channel *s ) 
{ 
  struct channel_forward *self ;

  {
  {
#line 111
  self = (struct channel_forward *)s;
  {
#line 115
  close_fd_write(self->socket);
  }
  }
#line 116
  return;
}
}
#line 124 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.c"
void channel_forward_start_io(struct channel_forward *channel ) 
{ 
  struct lsh_callback *tmp ;
  struct io_callback *tmp___0 ;

  {
  {
#line 127
  channel->super.receive = & do_channel_forward_receive;
#line 128
  channel->super.send_adjust = & do_channel_forward_send_adjust;
#line 129
  channel->super.eof = & do_channel_forward_eof;
  {
#line 133
  tmp = make_channel_read_close_callback(& channel->super);
  }
  {
#line 133
  tmp___0 = make_channel_read_data(& channel->super);
  }
  {
#line 133
  io_read_write(channel->socket, tmp___0, (uint32_t )327680, tmp);
  }
#line 140
  ((channel->socket)->write_buffer)->report = & channel->super.super;
  }
#line 141
  return;
}
}
#line 144 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.c"
void channel_forward_start_io_read(struct channel_forward *channel ) 
{ 
  struct lsh_callback *tmp ;
  struct io_callback *tmp___0 ;

  {
  {
#line 147
  channel->super.receive = & do_channel_forward_receive;
#line 148
  channel->super.send_adjust = & do_channel_forward_send_adjust;
#line 149
  channel->super.eof = & do_channel_forward_eof;
  {
#line 152
  tmp = make_channel_read_close_callback(& channel->super);
  }
  {
#line 152
  tmp___0 = make_channel_read_data(& channel->super);
  }
  {
#line 152
  io_read(channel->socket, tmp___0, tmp);
  }
#line 157
  ((channel->socket)->write_buffer)->report = & channel->super.super;
  }
#line 158
  return;
}
}
#line 165
static void do_start_io_command(struct command *s  __attribute__((__unused__)) , struct lsh_object *x ,
                                struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 165 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.c"
struct command start_io_command  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_start_io_command};
#line 165 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.c"
static void do_start_io_command(struct command *s  __attribute__((__unused__)) , struct lsh_object *x ,
                                struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct channel_forward *channel ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 171
  channel = (struct channel_forward *)x;
#line 173
  if (! channel) {
    {
    {
#line 173
    __assert_fail("channel", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.c",
                  173U, "do_start_io_command");
    }
    }
  }
  {
  {
#line 175
  channel_forward_start_io(channel);
  }
  {
#line 177
  (*(c->c))(c, (struct lsh_object *)channel);
  }
  }
#line 178
  return;
}
}
#line 182 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.c"
static struct report_exception_info  const  forward_open_report  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )(~ 0), (uint32_t )32771, "Forwarding failed, could not open channel"};
#line 186 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_forward.c"
struct catch_report_collect catch_channel_open  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_catch_report_collect}, & forward_open_report};
#line 342 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h"
int alloc_channel(struct channel_table *table ) ;
#line 343
void dealloc_channel(struct channel_table *table , int i ) ;
#line 349
void register_channel(uint32_t local_channel_number , struct ssh_channel *channel ,
                      int take_into_use ) ;
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h.x"
struct lsh_class install_info_class ;
#line 133 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h"
struct command *make_install_fix_global_request_handler(uint32_t name , struct global_request *handler ) ;
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h.x"
struct lsh_class channel_open_command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"channel_open_command", (size_t )sizeof(struct channel_open_command ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h.x"
struct lsh_class channel_request_command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"channel_request_command", (size_t )sizeof(struct channel_request_command ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h.x"
struct lsh_class global_request_command_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"global_request_command", (size_t )sizeof(struct global_request_command ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.h.x"
struct lsh_class install_info_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_2_class, (char *)"install_info", (size_t )sizeof(struct install_info ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 11 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c.x"
struct lsh_class install_global_request_handler_class ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c.x"
static void do_install_global_request_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct install_global_request_handler *i ;

  {
  {
#line 19
  i = (struct install_global_request_handler *)o;
  {
#line 20
  (*mark)((struct lsh_object *)i->handler);
  }
  }
#line 21
  return;
}
}
#line 22 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c.x"
struct lsh_class install_global_request_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"install_global_request_handler", (size_t )sizeof(struct install_global_request_handler ),
    & do_install_global_request_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 43
struct lsh_class install_channel_open_handler_class ;
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c.x"
static void do_install_channel_open_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct install_channel_open_handler *i ;

  {
  {
#line 51
  i = (struct install_channel_open_handler *)o;
  {
#line 52
  (*mark)((struct lsh_object *)i->handler);
  }
  }
#line 53
  return;
}
}
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c.x"
struct lsh_class install_channel_open_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_class, (char *)"install_channel_open_handler", (size_t )sizeof(struct install_channel_open_handler ),
    & do_install_channel_open_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c"
void do_channel_open_command(struct command *s , struct lsh_object *x , struct command_continuation *c ,
                             struct exception_handler *e ) 
{ 
  struct channel_open_command *self ;
  struct ssh_connection *connection ;
  struct lsh_string *request ;
  struct ssh_channel *channel ;
  int index ;
  int tmp ;
  struct exception *tmp___0 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 48
  self = (struct channel_open_command *)s;
#line 49
  connection = (struct ssh_connection *)x;
  {
#line 53
  tmp = alloc_channel(connection->table);
  }
#line 53
  index = tmp;
  }
#line 55
  if (index < 0) {
    {
    {
#line 58
    werror("do_channel_open_command: alloc_channel failed\n");
    }
    {
#line 59
    tmp___0 = make_channel_open_exception((uint32_t )4, "Allocating a local channel number failed.");
    }
    {
#line 59
    (*(e->raise))(e, (struct exception  const  *)tmp___0);
    }
    }
#line 64
    return;
  }
  {
  {
#line 67
  channel = (*(self->new_channel))(self, connection, (uint32_t )index, & request);
  }
  }
#line 69
  if (! channel) {
    {
    {
#line 71
    werror("do_channel_open_command: NEW_CHANNEL failed\n");
    }
    {
#line 72
    dealloc_channel(connection->table, index);
    }
    }
  } else {
    {
#line 78
    channel->open_continuation = c;
#line 79
    channel->e = e;
    {
#line 80
    register_channel((uint32_t )index, channel, 0);
    }
    {
#line 82
    connection_send(connection, request);
    }
    }
  }
#line 84
  return;
}
}
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c"
void do_channel_request_command(struct command *s , struct lsh_object *x , struct command_continuation *c ,
                                struct exception_handler *e ) 
{ 
  struct channel_request_command *self ;
  struct ssh_channel *channel ;
  struct lsh_string *request ;
  struct lsh_string *tmp ;
  struct command_context *tmp___0 ;

  {
  {
#line 92
  self = (struct channel_request_command *)s;
#line 93
  channel = (struct ssh_channel *)x;
  {
#line 95
  tmp = (*(self->format_request))(self, channel, & c);
  }
#line 95
  request = tmp;
  }
#line 98
  if ((unsigned long )c != (unsigned long )(& discard_continuation)) {
    {
    {
#line 99
    tmp___0 = make_command_context(c, e);
    }
    {
#line 99
    object_queue_add_tail(& channel->pending_requests, & tmp___0->super);
    }
    }
  }
  {
  {
#line 102
  connection_send(channel->connection, request);
  }
  }
#line 103
  return;
}
}
#line 105 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c"
void do_channel_global_command(struct command *s , struct lsh_object *x , struct command_continuation *c ,
                               struct exception_handler *e ) 
{ 
  struct global_request_command *self ;
  struct ssh_connection *connection ;
  struct lsh_string *request ;
  struct lsh_string *tmp ;
  struct command_context *tmp___0 ;

  {
  {
#line 111
  self = (struct global_request_command *)s;
#line 112
  connection = (struct ssh_connection *)x;
  {
#line 114
  tmp = (*(self->format_request))(self, connection, & c);
  }
#line 114
  request = tmp;
  }
#line 117
  if ((unsigned long )c != (unsigned long )(& discard_continuation)) {
    {
    {
#line 118
    tmp___0 = make_command_context(c, e);
    }
    {
#line 118
    object_queue_add_tail(& (connection->table)->pending_global_requests, & tmp___0->super);
    }
    }
  }
  {
  {
#line 121
  connection_send(connection, request);
  }
  }
#line 122
  return;
}
}
#line 124 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c"
void do_install_global_request_handler(struct command_2 *s , struct lsh_object *a1 ,
                                       struct lsh_object *a2 , struct command_continuation *c ,
                                       struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct install_info *self ;
  struct ssh_connection *connection ;
  struct global_request *handler ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 131
  self = (struct install_info *)s;
#line 132
  connection = (struct ssh_connection *)a1;
#line 133
  handler = (struct global_request *)a2;
#line 135
  if (! handler) {
    {
    {
#line 135
    __assert_fail("handler", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c",
                  135U, "do_install_global_request_handler");
    }
    }
  }
  {
  {
#line 137
  trace("Installing global request handler for \'%a\'\n", self->name);
  }
  {
#line 139
  (*(((struct alist_meta *)((connection->table)->global_requests)->super.isa)->set))((connection->table)->global_requests,
                                                                                     self->name,
                                                                                     & handler->super);
  }
  {
#line 143
  (*(c->c))(c, (struct lsh_object *)connection);
  }
  }
#line 144
  return;
}
}
#line 146 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c"
void do_install_channel_open_handler(struct command_2 *s , struct lsh_object *a1 ,
                                     struct lsh_object *a2 , struct command_continuation *c ,
                                     struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct install_info *self ;
  struct ssh_connection *connection ;
  struct channel_open *handler ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 153
  self = (struct install_info *)s;
#line 154
  connection = (struct ssh_connection *)a1;
#line 155
  handler = (struct channel_open *)a2;
#line 157
  if (! handler) {
    {
    {
#line 157
    __assert_fail("handler", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c",
                  157U, "do_install_channel_open_handler");
    }
    }
  }
  {
  {
#line 159
  trace("Installing channel open handler for \'%a\'\n", self->name);
  }
  {
#line 161
  (*(((struct alist_meta *)((connection->table)->channel_types)->super.isa)->set))((connection->table)->channel_types,
                                                                                   self->name,
                                                                                   & handler->super);
  }
  {
#line 165
  (*(c->c))(c, (struct lsh_object *)connection);
  }
  }
#line 166
  return;
}
}
#line 181 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c"
static void do_install_fix_global_request_handler(struct command *s , struct lsh_object *x ,
                                                  struct command_continuation *c ,
                                                  struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct install_global_request_handler *self ;
  struct ssh_connection *connection ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 187
  self = (struct install_global_request_handler *)s;
#line 188
  connection = (struct ssh_connection *)x;
  {
#line 190
  trace("Installing fix global request handler for \'%a\'\n", self->name);
  }
  {
#line 192
  (*(((struct alist_meta *)((connection->table)->global_requests)->super.isa)->set))((connection->table)->global_requests,
                                                                                     self->name,
                                                                                     & (self->handler)->super);
  }
  {
#line 196
  (*(c->c))(c, x);
  }
  }
#line 197
  return;
}
}
#line 199 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c"
struct command *make_install_fix_global_request_handler(uint32_t name , struct global_request *handler ) 
{ 
  struct install_global_request_handler *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 203
  tmp = lsh_object_alloc(& install_global_request_handler_class);
  }
#line 203
  self = (struct install_global_request_handler *)tmp;
  }
#line 205
  if (! handler) {
    {
    {
#line 205
    __assert_fail("handler", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c",
                  205U, "make_install_fix_global_request_handler");
    }
    }
  }
#line 207
  self->super.call = & do_install_fix_global_request_handler;
#line 208
  self->name = (int )name;
#line 209
  self->handler = handler;
#line 211
  return (& self->super);
}
}
#line 224 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c"
static void do_install_fix_channel_open_handler(struct command *s , struct lsh_object *x ,
                                                struct command_continuation *c , struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct install_channel_open_handler *self ;
  struct ssh_connection *connection ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 230
  self = (struct install_channel_open_handler *)s;
#line 231
  connection = (struct ssh_connection *)x;
  {
#line 233
  trace("Installing fix channel open handler for type \'%a\'\n", self->name);
  }
  {
#line 235
  (*(((struct alist_meta *)((connection->table)->channel_types)->super.isa)->set))((connection->table)->channel_types,
                                                                                   self->name,
                                                                                   & (self->handler)->super);
  }
  {
#line 240
  (*(c->c))(c, (struct lsh_object *)connection);
  }
  }
#line 241
  return;
}
}
#line 243 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c"
struct command *make_install_fix_channel_open_handler(uint32_t name , struct channel_open *handler ) 
{ 
  struct install_channel_open_handler *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 247
  tmp = lsh_object_alloc(& install_channel_open_handler_class);
  }
#line 247
  self = (struct install_channel_open_handler *)tmp;
  }
#line 249
  if (! handler) {
    {
    {
#line 249
    __assert_fail("handler", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel_commands.c",
                  249U, "make_install_fix_channel_open_handler");
    }
    }
  }
#line 251
  self->super.call = & do_install_fix_channel_open_handler;
#line 252
  self->name = (int )name;
#line 253
  self->handler = handler;
#line 255
  return (& self->super);
}
}
#line 90 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct lsh_class channel_table_class ;
#line 172
struct lsh_class channel_open_exception_class ;
#line 341 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h"
struct channel_table *make_channel_table(void) ;
#line 345
void use_channel(struct ssh_connection *connection , uint32_t local_channel_number ) ;
#line 354
struct ssh_channel *lookup_channel(struct channel_table *table , uint32_t i ) ;
#line 356
struct ssh_channel *lookup_channel_reserved(struct channel_table *table , uint32_t i ) ;
#line 360
struct abstract_write *make_channel_write_extended(struct ssh_channel *channel , uint32_t type ) ;
#line 366
struct lsh_string *format_global_failure(void) ;
#line 367
struct lsh_string *format_global_success(void) ;
#line 369
struct lsh_string *format_open_failure(uint32_t channel , uint32_t reason , char const   *msg ,
                                       char const   *language ) ;
#line 371
struct lsh_string *format_open_confirmation(struct ssh_channel *channel , uint32_t channel_number ,
                                            char const   *format  , ...) ;
#line 375
struct lsh_string *format_channel_success(uint32_t channel ) ;
#line 376
struct lsh_string *format_channel_failure(uint32_t channel ) ;
#line 378
struct lsh_string *prepare_window_adjust(struct ssh_channel *channel , uint32_t add ) ;
#line 411
struct lsh_string *format_channel_close(struct ssh_channel *channel ) ;
#line 412
struct lsh_string *format_channel_eof(struct ssh_channel *channel ) ;
#line 435
struct command connection_service_command ;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
static void do_ssh_channel_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct ssh_channel *i ;

  {
  {
#line 36
  i = (struct ssh_channel *)o;
  {
#line 37
  (*mark)((struct lsh_object *)i->e);
  }
  {
#line 38
  (*mark)((struct lsh_object *)i->resources);
  }
  {
#line 39
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 40
  (*mark)((struct lsh_object *)i->request_types);
  }
  {
#line 41
  (*mark)((struct lsh_object *)i->request_fallback);
  }
  {
#line 42
  (*mark)((struct lsh_object *)i->open_continuation);
  }
  {
#line 43
  object_queue_mark(& i->pending_requests, mark);
  }
  {
#line 45
  object_queue_mark(& i->active_requests, mark);
  }
  }
#line 47
  return;
}
}
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
static void do_ssh_channel_free(struct lsh_object *o ) 
{ 
  struct ssh_channel *i ;

  {
  {
#line 51
  i = (struct ssh_channel *)o;
  {
#line 52
  object_queue_free(& i->pending_requests);
  }
  {
#line 53
  object_queue_free(& i->active_requests);
  }
  }
#line 54
  return;
}
}
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct lsh_class ssh_channel_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & flow_controlled_class, (char *)"ssh_channel", (size_t )sizeof(struct ssh_channel ),
    & do_ssh_channel_mark, & do_ssh_channel_free};
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
static void do_channel_table_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct channel_table *i ;
  unsigned int k1 ;

  {
#line 98
  i = (struct channel_table *)o;
#line 101
  k1 = 0U;
  {
  {
#line 101
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 101
    if (! (k1 < i->used_channels)) {
#line 101
      goto while_break;
    }
    {
    {
#line 102
    (*mark)((struct lsh_object *)*(i->channels + k1));
    }
#line 101
    k1 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 104
  (*mark)((struct lsh_object *)i->global_requests);
  }
  {
#line 105
  (*mark)((struct lsh_object *)i->channel_types);
  }
  {
#line 106
  (*mark)((struct lsh_object *)i->open_fallback);
  }
  {
#line 107
  object_queue_mark(& i->local_ports, mark);
  }
  {
#line 109
  object_queue_mark(& i->remote_ports, mark);
  }
  {
#line 111
  (*mark)((struct lsh_object *)i->x11_display);
  }
  {
#line 112
  object_queue_mark(& i->active_global_requests, mark);
  }
  {
#line 114
  object_queue_mark(& i->pending_global_requests, mark);
  }
  }
#line 116
  return;
}
}
#line 117 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
static void do_channel_table_free(struct lsh_object *o ) 
{ 
  struct channel_table *i ;

  {
  {
#line 120
  i = (struct channel_table *)o;
  {
#line 121
  lsh_space_free((void const   *)i->channels);
  }
  {
#line 122
  lsh_space_free((void const   *)i->in_use);
  }
  {
#line 123
  object_queue_free(& i->local_ports);
  }
  {
#line 124
  object_queue_free(& i->remote_ports);
  }
  {
#line 125
  object_queue_free(& i->active_global_requests);
  }
  {
#line 126
  object_queue_free(& i->pending_global_requests);
  }
  }
#line 127
  return;
}
}
#line 128 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct lsh_class channel_table_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"channel_table", (size_t )sizeof(struct channel_table ),
    & do_channel_table_mark, & do_channel_table_free};
#line 152 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct lsh_class global_request_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"global_request", (size_t )sizeof(struct global_request ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 176 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct lsh_class channel_open_exception_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_class, (char *)"channel_open_exception", (size_t )sizeof(struct channel_open_exception ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 200 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct lsh_class channel_open_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"channel_open", (size_t )sizeof(struct channel_open ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 224 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.h.x"
struct lsh_class channel_request_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"channel_request", (size_t )sizeof(struct channel_request ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 12 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct lsh_class exc_finish_channel_handler_class ;
#line 16 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
static void do_exc_finish_channel_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct exc_finish_channel_handler *i ;

  {
  {
#line 20
  i = (struct exc_finish_channel_handler *)o;
  {
#line 21
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 22
  return;
}
}
#line 23 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct lsh_class exc_finish_channel_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"exc_finish_channel_handler", (size_t )sizeof(struct exc_finish_channel_handler ),
    & do_exc_finish_channel_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 43
struct lsh_class request_status_class ;
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct lsh_class request_status_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"request_status", (size_t )sizeof(struct request_status ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 68
struct lsh_class global_request_continuation_class ;
#line 72 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
static void do_global_request_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct global_request_continuation *i ;

  {
  {
#line 76
  i = (struct global_request_continuation *)o;
  {
#line 77
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 78
  (*mark)((struct lsh_object *)i->active);
  }
  }
#line 79
  return;
}
}
#line 80 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct lsh_class global_request_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"global_request_continuation",
    (size_t )sizeof(struct global_request_continuation ), & do_global_request_continuation_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 101
struct lsh_class global_request_exception_handler_class ;
#line 105 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
static void do_global_request_exception_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct global_request_exception_handler *i ;

  {
  {
#line 109
  i = (struct global_request_exception_handler *)o;
  {
#line 110
  (*mark)((struct lsh_object *)i->connection);
  }
  {
#line 111
  (*mark)((struct lsh_object *)i->active);
  }
  }
#line 112
  return;
}
}
#line 113 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct lsh_class global_request_exception_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"global_request_exception_handler",
    (size_t )sizeof(struct global_request_exception_handler ), & do_global_request_exception_handler_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 134
struct lsh_class channel_request_continuation_class ;
#line 138 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
static void do_channel_request_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct channel_request_continuation *i ;

  {
  {
#line 142
  i = (struct channel_request_continuation *)o;
  {
#line 143
  (*mark)((struct lsh_object *)i->channel);
  }
  {
#line 144
  (*mark)((struct lsh_object *)i->active);
  }
  }
#line 145
  return;
}
}
#line 146 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct lsh_class channel_request_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"channel_request_continuation",
    (size_t )sizeof(struct channel_request_continuation ), & do_channel_request_continuation_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 167
struct lsh_class channel_request_exception_handler_class ;
#line 171 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
static void do_channel_request_exception_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct channel_request_exception_handler *i ;

  {
  {
#line 175
  i = (struct channel_request_exception_handler *)o;
  {
#line 176
  (*mark)((struct lsh_object *)i->channel);
  }
  {
#line 177
  (*mark)((struct lsh_object *)i->active);
  }
  }
#line 178
  return;
}
}
#line 179 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct lsh_class channel_request_exception_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"channel_request_exception_handler",
    (size_t )sizeof(struct channel_request_exception_handler ), & do_channel_request_exception_handler_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 203
struct lsh_class channel_open_continuation_class ;
#line 207 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
static void do_channel_open_continuation_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct channel_open_continuation *i ;

  {
  {
#line 211
  i = (struct channel_open_continuation *)o;
  {
#line 212
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 213
  return;
}
}
#line 214 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct lsh_class channel_open_continuation_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & command_continuation_class, (char *)"channel_open_continuation",
    (size_t )sizeof(struct channel_open_continuation ), & do_channel_open_continuation_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 236
struct lsh_class exc_channel_open_handler_class ;
#line 240 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
static void do_exc_channel_open_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct exc_channel_open_handler *i ;

  {
  {
#line 244
  i = (struct exc_channel_open_handler *)o;
  {
#line 245
  (*mark)((struct lsh_object *)i->connection);
  }
  }
#line 246
  return;
}
}
#line 247 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct lsh_class exc_channel_open_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"exc_channel_open_handler", (size_t )sizeof(struct exc_channel_open_handler ),
    & do_exc_channel_open_handler_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 267
struct lsh_class channel_write_class ;
#line 271 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
static void do_channel_write_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct channel_write *i ;

  {
  {
#line 275
  i = (struct channel_write *)o;
  {
#line 276
  (*mark)((struct lsh_object *)i->channel);
  }
  }
#line 277
  return;
}
}
#line 278 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct lsh_class channel_write_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & abstract_write_class, (char *)"channel_write", (size_t )sizeof(struct channel_write ),
    & do_channel_write_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 298
struct lsh_class channel_write_extended_class ;
#line 302 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct lsh_class channel_write_extended_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & channel_write_class, (char *)"channel_write_extended", (size_t )sizeof(struct channel_write_extended ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 322
struct lsh_class channel_close_callback_class ;
#line 326 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
static void do_channel_close_callback_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct channel_close_callback *i ;

  {
  {
#line 330
  i = (struct channel_close_callback *)o;
  {
#line 331
  (*mark)((struct lsh_object *)i->channel);
  }
  }
#line 332
  return;
}
}
#line 333 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct lsh_class channel_close_callback_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & lsh_callback_class, (char *)"channel_close_callback", (size_t )sizeof(struct channel_close_callback ),
    & do_channel_close_callback_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 355
struct lsh_class channel_io_exception_handler_class ;
#line 359 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
static void do_channel_io_exception_handler_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct channel_io_exception_handler *i ;

  {
  {
#line 363
  i = (struct channel_io_exception_handler *)o;
  {
#line 364
  (*mark)((struct lsh_object *)i->channel);
  }
  }
#line 365
  return;
}
}
#line 366 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c.x"
struct lsh_class channel_io_exception_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"channel_io_exception_handler",
    (size_t )sizeof(struct channel_io_exception_handler ), & do_channel_io_exception_handler_mark,
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 53 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static char const   *msgs[5]  = {      "",      "Administratively prohibited",      "Connect failed",      "Unknown channel type", 
        "Resource shortage"};
#line 47 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct exception *make_channel_open_exception(uint32_t error_code , char const   *msg ) 
{ 
  struct channel_open_exception *self ;
  struct lsh_object *tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
  {
#line 50
  tmp = lsh_object_alloc(& channel_open_exception_class);
  }
#line 50
  self = (struct channel_open_exception *)tmp;
  }
#line 61
  if (! (error_code > 0U)) {
    {
    {
#line 61
    __assert_fail("error_code > 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  61U, "make_channel_open_exception");
    }
    }
  }
#line 62
  if (! (error_code <= 4U)) {
    {
    {
#line 62
    __assert_fail("error_code <= 4", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  62U, "make_channel_open_exception");
    }
    }
  }
#line 65
  self->super.type = (uint32_t )32771;
#line 66
  if (msg) {
#line 66
    self->super.msg = msg;
  } else {
#line 66
    self->super.msg = msgs[error_code];
  }
#line 67
  self->error_code = error_code;
#line 69
  return (& self->super);
}
}
#line 73 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *format_global_failure(void) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 76
  tmp = ssh_format("%c", 82);
  }
  }
#line 76
  return (tmp);
}
}
#line 79 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *format_global_success(void) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 82
  tmp = ssh_format("%c", 81);
  }
  }
#line 82
  return (tmp);
}
}
#line 94 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void check_rec_max_packet(struct ssh_channel *channel ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 100
  if (channel->rec_max_packet > 32668U) {
    {
    {
#line 102
    debug("check_rec_max_packet: Reduced rec_max_packet from %i to %i.\n", channel->rec_max_packet,
          32668);
    }
#line 104
    channel->rec_max_packet = (uint32_t )32668;
    }
  }
#line 106
  return;
}
}
#line 108 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *format_open_confirmation(struct ssh_channel *channel , uint32_t channel_number ,
                                            char const   *format  , ...) 
{ 
  va_list args ;
  uint32_t l1 ;
  uint32_t l2 ;
  struct lsh_string *packet ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 122
  check_rec_max_packet(channel);
  }
  {
#line 124
  debug("format_open_confirmation: rec_window_size = %i,\n                          rec_max_packet = %i,\n",
        channel->rec_window_size, channel->rec_max_packet);
  }
  {
#line 128
  l1 = ssh_format_length("%c%i%i%i%i", 91, channel->channel_number, channel_number,
                         channel->rec_window_size, channel->rec_max_packet);
  }
  {
#line 130
  __builtin_va_start(args, format);
  }
  {
#line 131
  l2 = ssh_vformat_length(format, args);
  }
  {
#line 132
  __builtin_va_end(args);
  }
  {
#line 134
  packet = lsh_string_alloc(l1 + l2);
  }
  {
#line 136
  ssh_format_write("%c%i%i%i%i", packet, (uint32_t )0, 91, channel->channel_number,
                   channel_number, channel->rec_window_size, channel->rec_max_packet);
  }
  {
#line 138
  __builtin_va_start(args, format);
  }
  {
#line 139
  ssh_vformat_write(format, packet, l1, args);
  }
  {
#line 140
  __builtin_va_end(args);
  }
  }
#line 142
  return (packet);
}
}
#line 147 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *format_open_failure(uint32_t channel , uint32_t reason , char const   *msg ,
                                       char const   *language ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 151
  tmp = ssh_format("%c%i%i%z%z", 92, channel, reason, msg, language);
  }
  }
#line 151
  return (tmp);
}
}
#line 155 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *format_channel_success(uint32_t channel ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 158
  tmp = ssh_format("%c%i", 99, channel);
  }
  }
#line 158
  return (tmp);
}
}
#line 161 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *format_channel_failure(uint32_t channel ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 164
  tmp = ssh_format("%c%i", 100, channel);
  }
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *prepare_window_adjust(struct ssh_channel *channel , uint32_t add ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 171
  channel->rec_window_size += add;
  {
#line 173
  tmp = ssh_format("%c%i%i", 93, channel->channel_number, add);
  }
  }
#line 173
  return (tmp);
}
}
#line 190 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_exc_finish_channel_handler(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct exc_finish_channel_handler *self ;
  struct ssh_channel *channel ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 194
  self = (struct exc_finish_channel_handler *)s;
#line 198
  if (e->type == 65540U) {
#line 198
    goto case_65540;
  }
#line 210
  if (e->type == 65537U) {
#line 210
    goto case_65537;
  }
#line 248
  goto switch_default;
  case_65540: 
#line 199
  if (self->dead) {
    {
    {
#line 200
    werror("channel.c: EXC_FINISH_PENDING on dead channel.\n");
    }
    }
  }
#line 202
  ((self->connection)->table)->pending_close = 1;
#line 208
  goto switch_break;
  case_65537: 
#line 222
  if (self->dead) {
    {
    {
#line 223
    debug("EXC_FINISH_CHANNEL on dead channel.\n");
    }
    }
  } else {
#line 226
    channel = *(((self->connection)->table)->channels + self->channel_number);
#line 229
    if (! channel) {
      {
      {
#line 229
      __assert_fail("channel", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                    229U, "do_exc_finish_channel_handler");
      }
      }
    }
#line 230
    if (! (channel->resources)->super.alive) {
      {
      {
#line 230
      __assert_fail("channel->resources->super.alive", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                    230U, "do_exc_finish_channel_handler");
      }
      }
    }
#line 232
    if (channel->close) {
      {
      {
#line 233
      (*(channel->close))(channel);
      }
      }
    }
    {
    {
#line 235
    (*((channel->resources)->super.kill))(& (channel->resources)->super);
    }
    {
#line 237
    dealloc_channel((self->connection)->table, (int )self->channel_number);
    }
#line 238
    self->dead = 1;
    }
#line 240
    if (((self->connection)->table)->pending_close) {
#line 240
      if (! ((self->connection)->table)->channel_count) {
        {
        {
#line 244
        (*(((self->connection)->e)->raise))((self->connection)->e, & finish_read_exception);
        }
        }
      }
    }
  }
#line 247
  goto switch_break;
  switch_default: 
  {
  {
#line 249
  (*((self->super.parent)->raise))(self->super.parent, e);
  }
  }
  switch_break: ;
#line 251
  return;
}
}
#line 253 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct exception_handler *make_exc_finish_channel_handler(struct ssh_connection *connection ,
                                                                 uint32_t channel_number ,
                                                                 struct exception_handler *e ,
                                                                 char const   *context ) 
{ 
  struct exc_finish_channel_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 259
  tmp = lsh_object_alloc(& exc_finish_channel_handler_class);
  }
#line 259
  self = (struct exc_finish_channel_handler *)tmp;
#line 260
  self->super.parent = e;
#line 261
  self->super.raise = & do_exc_finish_channel_handler;
#line 262
  self->super.context = context;
#line 264
  self->connection = connection;
#line 265
  self->channel_number = channel_number;
#line 266
  self->dead = 0;
  }
#line 268
  return (& self->super);
}
}
#line 278 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct channel_table *make_channel_table(void) 
{ 
  struct channel_table *table ;
  struct lsh_object *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t size5 ;
  void *tmp6 ;
  void *ret_lsh_space_alloc7 ;
  size_t size8 ;
  void *tmp9 ;
  void *ret_lsh_space_alloc10 ;

  {
  {
  {
#line 281
  tmp = lsh_object_alloc(& channel_table_class);
  }
#line 281
  table = (struct channel_table *)tmp;
  {
#line 283
  size5 = (size_t )(sizeof(struct ssh_channel *) * 32UL);
  {
  {
  {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
  tmp6 = malloc(size5);
  }
  }
  {
#line 262
  ret_lsh_space_alloc7 = tmp6;
#line 262
  goto Lret_lsh_space_alloc;
  }
  }
  Lret_lsh_space_alloc: /* CIL Label */ 
#line 283 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
  tmp___0 = ret_lsh_space_alloc7;
  }
#line 283
  table->channels = (struct ssh_channel **)tmp___0;
  {
#line 285
  size8 = (size_t )32;
  {
  {
  {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
  tmp9 = malloc(size8);
  }
  }
  {
#line 262
  ret_lsh_space_alloc10 = tmp9;
#line 262
  goto Lret_lsh_space_alloc___0;
  }
  }
  Lret_lsh_space_alloc___0: /* CIL Label */ 
#line 285 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
  tmp___1 = ret_lsh_space_alloc10;
  }
#line 285
  table->in_use = (uint8_t *)tmp___1;
#line 287
  table->allocated_channels = (uint32_t )32;
#line 288
  table->used_channels = (uint32_t )0;
#line 289
  table->next_channel = (uint32_t )0;
#line 290
  table->channel_count = (uint32_t )0;
#line 292
  table->max_channels = (uint32_t )(1L << 17);
#line 294
  table->pending_close = 0;
  {
#line 296
  table->global_requests = make_linear_alist(0U, -1);
  }
  {
#line 297
  table->channel_types = make_linear_alist(0U, -1);
  }
#line 298
  table->open_fallback = (struct channel_open *)((void *)0);
  {
#line 300
  lsh_queue_init(& table->local_ports.q);
  }
  {
#line 301
  lsh_queue_init(& table->remote_ports.q);
  }
#line 302
  table->x11_display = (struct client_x11_display *)((void *)0);
  {
#line 304
  lsh_queue_init(& table->active_global_requests.q);
  }
  {
#line 305
  lsh_queue_init(& table->pending_global_requests.q);
  }
  }
#line 307
  return (table);
}
}
#line 314 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
int alloc_channel(struct channel_table *table ) 
{ 
  uint32_t i ;
  uint32_t new_size ;
  struct ssh_channel **new_channels ;
  uint8_t *new_in_use ;
  void *tmp ;
  void *tmp___0 ;
  uint32_t tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  size_t size17 ;
  void *tmp18 ;
  void *ret_lsh_space_alloc19 ;
  size_t size20 ;
  void *tmp21 ;
  void *ret_lsh_space_alloc22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 319
  i = table->next_channel;
  {
  {
#line 319
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 319
    if (! (i < table->used_channels)) {
#line 319
      goto while_break;
    }
#line 321
    if ((int )*(table->in_use + i) == 0) {
#line 323
      if (! (! *(table->channels + i))) {
        {
        {
#line 323
        __assert_fail("!table->channels[i]", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                      323U, "alloc_channel");
        }
        }
      }
#line 324
      *(table->in_use + i) = (uint8_t )1;
#line 325
      table->next_channel = i + 1U;
#line 327
      goto success;
    }
#line 319
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 330
  if (i == table->max_channels) {
#line 331
    return (-1);
  }
#line 333
  if (i == table->allocated_channels) {
    {
#line 335
    new_size = table->allocated_channels * 2U;
    {
#line 339
    size17 = (size_t )(sizeof(struct ssh_channel *) * (unsigned long )new_size);
    {
    {
    {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
    tmp18 = malloc(size17);
    }
    }
    {
#line 262
    ret_lsh_space_alloc19 = tmp18;
#line 262
    goto Lret_lsh_space_alloc;
    }
    }
    Lret_lsh_space_alloc: /* CIL Label */ 
#line 339 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
    tmp = ret_lsh_space_alloc19;
    }
#line 339
    new_channels = (struct ssh_channel **)tmp;
    {
#line 341
    memcpy((void */* __restrict  */)((void *)new_channels), (void const   */* __restrict  */)((void const   *)table->channels),
           (size_t )(sizeof(struct ssh_channel *) * (unsigned long )table->used_channels));
    }
    {
#line 343
    lsh_space_free((void const   *)table->channels);
    }
#line 344
    table->channels = new_channels;
    {
#line 347
    size20 = new_size;
    {
    {
    {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
    tmp21 = malloc(size20);
    }
    }
    {
#line 262
    ret_lsh_space_alloc22 = tmp21;
#line 262
    goto Lret_lsh_space_alloc___0;
    }
    }
    Lret_lsh_space_alloc___0: /* CIL Label */ 
#line 347 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
    tmp___0 = ret_lsh_space_alloc22;
    }
#line 347
    new_in_use = (uint8_t *)tmp___0;
    {
#line 348
    memcpy((void */* __restrict  */)((void *)new_in_use), (void const   */* __restrict  */)((void const   *)table->in_use),
           table->used_channels);
    }
    {
#line 349
    lsh_space_free((void const   *)table->in_use);
    }
#line 350
    table->in_use = new_in_use;
#line 352
    table->allocated_channels = new_size;
    }
  }
#line 355
  tmp___1 = i + 1U;
#line 355
  table->used_channels = tmp___1;
#line 355
  table->next_channel = tmp___1;
#line 357
  *(table->in_use + i) = (uint8_t )1;
#line 358
  *(table->channels + i) = (struct ssh_channel *)((void *)0);
  success: 
  {
#line 361
  (table->channel_count) ++;
  {
#line 362
  verbose("Allocated local channel number %i\n", i);
  }
  }
#line 364
  return ((int )i);
}
}
#line 367 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
void dealloc_channel(struct channel_table *table , int i ) 
{ 
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 370
  if (! (i >= 0)) {
    {
    {
#line 370
    __assert_fail("i >= 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c", 370U,
                  "dealloc_channel");
    }
    }
  }
#line 371
  if (! ((unsigned int )i < table->used_channels)) {
    {
    {
#line 371
    __assert_fail("(unsigned) i < table->used_channels", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  371U, "dealloc_channel");
    }
    }
  }
#line 372
  if (! table->channel_count) {
    {
    {
#line 372
    __assert_fail("table->channel_count", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  372U, "dealloc_channel");
    }
    }
  }
  {
  {
#line 374
  verbose("Deallocating local channel %i\n", i);
  }
#line 375
  *(table->channels + i) = (struct ssh_channel *)((void *)0);
#line 376
  *(table->in_use + i) = (uint8_t )0;
#line 378
  (table->channel_count) --;
  }
#line 380
  if ((unsigned int )i < table->next_channel) {
#line 381
    table->next_channel = (uint32_t )i;
  }
#line 382
  return;
}
}
#line 384 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
void use_channel(struct ssh_connection *connection , uint32_t local_channel_number ) 
{ 
  struct channel_table *table ;
  struct ssh_channel *channel ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 388
  table = connection->table;
#line 389
  channel = *(table->channels + local_channel_number);
#line 391
  if (! channel) {
    {
    {
#line 391
    __assert_fail("channel", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  391U, "use_channel");
    }
    }
  }
#line 392
  if (! ((int )*(table->in_use + local_channel_number) == 1)) {
    {
    {
#line 392
    __assert_fail("table->in_use[local_channel_number] == 1", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  392U, "use_channel");
    }
    }
  }
  {
#line 394
  *(table->in_use + local_channel_number) = (uint8_t )2;
  {
#line 395
  verbose("Taking channel %i in use, (local %i).\n", channel->channel_number, local_channel_number);
  }
  }
#line 397
  return;
}
}
#line 399 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
void register_channel(uint32_t local_channel_number , struct ssh_channel *channel ,
                      int take_into_use ) 
{ 
  struct channel_table *table ;
  struct exception_handler *tmp ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 404
  table = (channel->connection)->table;
#line 406
  if (! ((int )*(table->in_use + local_channel_number) == 1)) {
    {
    {
#line 406
    __assert_fail("table->in_use[local_channel_number] == 1", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  406U, "register_channel");
    }
    }
  }
#line 407
  if (! (! *(table->channels + local_channel_number))) {
    {
    {
#line 407
    __assert_fail("!table->channels[local_channel_number]", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  407U, "register_channel");
    }
    }
  }
  {
  {
#line 409
  verbose("Registering local channel %i.\n", local_channel_number);
  }
  }
#line 413
  if (channel->e) {
#line 413
    tmp = channel->e;
  } else {
#line 413
    tmp = (channel->connection)->e;
  }
  {
  {
#line 413
  channel->e = make_exc_finish_channel_handler(channel->connection, local_channel_number,
                                               tmp, "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c:418");
  }
#line 420
  *(table->channels + local_channel_number) = channel;
  }
#line 422
  if (take_into_use) {
    {
    {
#line 423
    use_channel(channel->connection, local_channel_number);
    }
    }
  }
  {
  {
#line 425
  remember_resource((channel->connection)->resources, & (channel->resources)->super);
  }
  }
#line 427
  return;
}
}
#line 429 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct ssh_channel *lookup_channel(struct channel_table *table , uint32_t i ) 
{ 
  struct ssh_channel *tmp ;

  {
#line 432
  if (i < table->used_channels) {
#line 432
    if ((int )*(table->in_use + i) == 2) {
#line 432
      tmp = *(table->channels + i);
    } else {
#line 432
      tmp = (struct ssh_channel *)((void *)0);
    }
  } else {
#line 432
    tmp = (struct ssh_channel *)((void *)0);
  }
#line 432
  return (tmp);
}
}
#line 437 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct ssh_channel *lookup_channel_reserved(struct channel_table *table , uint32_t i ) 
{ 
  struct ssh_channel *tmp ;

  {
#line 440
  if (i < table->used_channels) {
#line 440
    if ((int )*(table->in_use + i) == 1) {
#line 440
      tmp = *(table->channels + i);
    } else {
#line 440
      tmp = (struct ssh_channel *)((void *)0);
    }
  } else {
#line 440
    tmp = (struct ssh_channel *)((void *)0);
  }
#line 440
  return (tmp);
}
}
#line 455 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void adjust_rec_window(struct flow_controlled *f , uint32_t written ) 
{ 
  struct ssh_channel *channel ;
  struct lsh_string *tmp ;

  {
#line 458
  channel = (struct ssh_channel *)f;
#line 462
  if (! (channel->flags & 11)) {
    {
    {
#line 464
    tmp = prepare_window_adjust(channel, written);
    }
    {
#line 464
    connection_send(channel->connection, tmp);
    }
    }
  }
#line 466
  return;
}
}
#line 468 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
void channel_start_receive(struct ssh_channel *channel , uint32_t initial_window_size ) 
{ 
  struct lsh_string *tmp ;

  {
#line 472
  if (channel->rec_window_size < initial_window_size) {
    {
    {
#line 473
    tmp = prepare_window_adjust(channel, initial_window_size - channel->rec_window_size);
    }
    {
#line 473
    connection_send(channel->connection, tmp);
    }
    }
  }
#line 476
  return;
}
}
#line 490 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct request_status *make_request_status(void) 
{ 
  struct request_status *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 493
  tmp = lsh_object_alloc(& request_status_class);
  }
#line 493
  self = (struct request_status *)tmp;
#line 494
  self->status = -1;
  }
#line 496
  return (self);
}
}
#line 508 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void send_global_request_responses(struct ssh_connection *connection , struct object_queue *q ) 
{ 
  struct request_status *n ;
  struct lsh_object *tmp ;
  struct lsh_string *tmp___0 ;
  struct lsh_string *tmp___1 ;
  struct lsh_string *tmp___2 ;

  {
  {
  {
#line 512
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 514
    tmp = object_queue_peek_head(q);
    }
#line 514
    n = (struct request_status *)tmp;
    }
#line 515
    if (! n) {
#line 516
      goto while_break;
    } else
#line 515
    if (n->status < 0) {
#line 516
      goto while_break;
    }
    {
    {
#line 518
    object_queue_remove_head(q);
    }
    }
#line 520
    if (n->status) {
      {
      {
#line 520
      tmp___0 = format_global_success();
      }
#line 520
      tmp___2 = tmp___0;
      }
    } else {
      {
      {
#line 520
      tmp___1 = format_global_failure();
      }
#line 520
      tmp___2 = tmp___1;
      }
    }
    {
    {
#line 520
    connection_send(connection, tmp___2);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 525
  return;
}
}
#line 527 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_global_request_response(struct command_continuation *s , struct lsh_object *x  __attribute__((__unused__)) ) 
{ 
  struct global_request_continuation *self ;
  struct object_queue *q ;
  int tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 531
  self = (struct global_request_continuation *)s;
#line 532
  q = & ((self->connection)->table)->active_global_requests;
#line 534
  if (! ((self->active)->status == -1)) {
    {
    {
#line 534
    __assert_fail("self->active->status == -1", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  534U, "do_global_request_response");
    }
    }
  }
  {
  {
#line 535
  tmp = lsh_queue_is_empty(& q->q);
  }
  }
#line 535
  if (tmp) {
    {
    {
#line 535
    __assert_fail("!lsh_queue_is_empty(&(q)->q)", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  535U, "do_global_request_response");
    }
    }
  }
  {
#line 537
  (self->active)->status = 1;
  {
#line 539
  send_global_request_responses(self->connection, q);
  }
  }
#line 540
  return;
}
}
#line 542 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct command_continuation *make_global_request_response(struct ssh_connection *connection ,
                                                                 struct request_status *active ) 
{ 
  struct global_request_continuation *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 546
  tmp = lsh_object_alloc(& global_request_continuation_class);
  }
#line 546
  self = (struct global_request_continuation *)tmp;
#line 548
  self->super.c = & do_global_request_response;
#line 549
  self->connection = connection;
#line 550
  self->active = active;
  }
#line 552
  return (& self->super);
}
}
#line 566 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_exc_global_request_handler(struct exception_handler *c , struct exception  const  *e ) 
{ 
  struct global_request_exception_handler *self ;
  struct object_queue *q ;
  int tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 570
  self = (struct global_request_exception_handler *)c;
#line 571
  if (e->type == 32769U) {
#line 573
    q = & ((self->connection)->table)->active_global_requests;
#line 575
    if (! ((self->active)->status == -1)) {
      {
      {
#line 575
      __assert_fail("self->active->status == -1", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                    575U, "do_exc_global_request_handler");
      }
      }
    }
    {
    {
#line 576
    tmp = lsh_queue_is_empty(& q->q);
    }
    }
#line 576
    if (tmp) {
      {
      {
#line 576
      __assert_fail("!lsh_queue_is_empty(&(q)->q)", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                    576U, "do_exc_global_request_handler");
      }
      }
    }
    {
#line 578
    (self->active)->status = 0;
    {
#line 580
    send_global_request_responses(self->connection, q);
    }
    }
  } else {
    {
    {
#line 583
    (*((c->parent)->raise))(c->parent, e);
    }
    }
  }
#line 584
  return;
}
}
#line 586 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct exception_handler *make_global_request_exception_handler(struct ssh_connection *connection ,
                                                                       struct request_status *active ,
                                                                       struct exception_handler *h___0 ,
                                                                       char const   *context ) 
{ 
  struct global_request_exception_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 592
  tmp = lsh_object_alloc(& global_request_exception_handler_class);
  }
#line 592
  self = (struct global_request_exception_handler *)tmp;
#line 594
  self->super.raise = & do_exc_global_request_handler;
#line 595
  self->super.context = context;
#line 596
  self->super.parent = h___0;
#line 597
  self->active = active;
#line 598
  self->connection = connection;
  }
#line 599
  return (& self->super);
}
}
#line 602
static void do_global_request_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                      struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 602 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler global_request_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_global_request_handler};
#line 647 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct report_exception_info  const  global_req_ignore  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )(~ 0), (uint32_t )32769, "Ignored:"};
#line 602 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_global_request_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                      struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  int name ;
  int want_reply ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct global_request *req ;
  struct command_continuation *c ;
  struct exception_handler *e ;
  struct global_request *r ;
  struct lsh_object *tmp___1 ;
  struct lsh_string *tmp___2 ;
  struct request_status *a ;
  struct request_status *tmp___3 ;
  struct exception *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
  {
#line 609
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 609
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 609
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 611
  tmp___5 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 611
  if (tmp___5) {
#line 611
    if (msg_number == 80U) {
      {
      {
#line 611
      tmp___6 = parse_atom(& buffer, & name);
      }
      }
#line 611
      if (tmp___6) {
        {
        {
#line 611
        tmp___7 = parse_boolean(& buffer, & want_reply);
        }
        }
#line 611
        if (tmp___7) {
#line 616
          req = (struct global_request *)((void *)0);
#line 617
          c = & discard_continuation;
#line 618
          e = connection->e;
#line 620
          if (name) {
#line 620
            if ((connection->table)->global_requests) {
              {
              {
#line 622
              tmp___1 = (*(((struct alist_meta *)((connection->table)->global_requests)->super.isa)->get))((connection->table)->global_requests,
                                                                                                           name);
              }
#line 622
              r = (struct global_request *)tmp___1;
#line 625
              req = r;
              }
            }
          }
#line 627
          if (! req) {
            {
            {
#line 629
            tmp___2 = format_global_failure();
            }
            {
#line 629
            connection_send(connection, tmp___2);
            }
            }
#line 630
            return;
          } else {
#line 634
            if (want_reply) {
              {
              {
#line 636
              tmp___3 = make_request_status();
              }
#line 636
              a = tmp___3;
              {
#line 638
              object_queue_add_tail(& (connection->table)->active_global_requests,
                                    & a->super);
              }
              {
#line 641
              c = make_global_request_response(connection, a);
              }
              {
#line 642
              e = make_global_request_exception_handler(connection, a, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c:642");
              }
              }
            } else {
              {
              {
#line 651
              e = make_report_exception_handler(& global_req_ignore, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c:652");
              }
              }
            }
            {
            {
#line 654
            (*(req->handler))(req, connection, (uint32_t )name, want_reply, & buffer,
                              c, e);
            }
            }
          }
        } else {
          {
          {
#line 658
          tmp___4 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_GLOBAL_REQUEST message.");
          }
          {
#line 658
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
          }
          }
        }
      } else {
        {
        {
#line 658
        tmp___4 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_GLOBAL_REQUEST message.");
        }
        {
#line 658
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
        }
        }
      }
    } else {
      {
      {
#line 658
      tmp___4 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_GLOBAL_REQUEST message.");
      }
      {
#line 658
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
      }
      }
    }
  } else {
    {
    {
#line 658
    tmp___4 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_GLOBAL_REQUEST message.");
    }
    {
#line 658
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
    }
    }
  }
#line 659
  return;
}
}
#line 661
static void do_global_success_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                      struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 661 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler global_success_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_global_success_handler};
#line 661 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_global_success_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                      struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct exception *tmp ;
  uint32_t tmp___0 ;
  uint8_t const   *tmp___1 ;
  int tmp___2 ;
  struct command_context *ctx ;
  struct lsh_object *tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
  {
#line 664
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  }
#line 664
  if (tmp___0 != 1U) {
    {
    {
#line 666
    tmp = make_protocol_exception((uint32_t )2, "Invalid GLOBAL_REQUEST_SUCCESS message.");
    }
    {
#line 666
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp);
    }
    }
#line 667
    return;
  }
  {
  {
#line 670
  tmp___1 = lsh_string_data((struct lsh_string  const  *)packet);
  }
  }
#line 670
  if (! ((int const   )*(tmp___1 + 0) == 81)) {
    {
    {
#line 670
    __assert_fail("lsh_string_data(packet)[0] == 81", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  670U, "do_global_success_handler");
    }
    }
  }
  {
  {
#line 672
  tmp___2 = lsh_queue_is_empty(& (connection->table)->pending_global_requests.q);
  }
  }
#line 672
  if (tmp___2) {
    {
    {
#line 674
    werror("do_global_request_success: Unexpected message, ignoring.\n");
    }
    }
#line 675
    return;
  }
  {
  {
#line 678
  tmp___3 = object_queue_remove_head(& (connection->table)->pending_global_requests);
  }
#line 678
  ctx = (struct command_context *)tmp___3;
  {
#line 680
  (*((ctx->c)->c))(ctx->c, (struct lsh_object *)connection);
  }
  }
#line 682
  return;
}
}
#line 684 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct exception global_request_exception  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )32769, "Global request failed"};
#line 687
static void do_global_failure_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                      struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 687 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler global_failure_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_global_failure_handler};
#line 687 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_global_failure_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                      struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct exception *tmp ;
  uint32_t tmp___0 ;
  uint8_t const   *tmp___1 ;
  struct command_context *ctx ;
  struct lsh_object *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
  {
#line 690
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  }
#line 690
  if (tmp___0 != 1U) {
    {
    {
#line 692
    tmp = make_protocol_exception((uint32_t )2, "Invalid GLOBAL_REQUEST_FAILURE message.");
    }
    {
#line 692
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp);
    }
    }
#line 693
    return;
  }
  {
  {
#line 696
  tmp___1 = lsh_string_data((struct lsh_string  const  *)packet);
  }
  }
#line 696
  if (! ((int const   )*(tmp___1 + 0) == 82)) {
    {
    {
#line 696
    __assert_fail("lsh_string_data(packet)[0] == 82", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  696U, "do_global_failure_handler");
    }
    }
  }
  {
  {
#line 698
  tmp___3 = lsh_queue_is_empty(& (connection->table)->pending_global_requests.q);
  }
  }
#line 698
  if (tmp___3) {
    {
    {
#line 700
    werror("do_global_request_failure: Unexpected message, ignoring.\n");
    }
    }
  } else {
    {
    {
#line 704
    tmp___2 = object_queue_remove_head(& (connection->table)->pending_global_requests);
    }
#line 704
    ctx = (struct command_context *)tmp___2;
    {
#line 706
    (*((ctx->e)->raise))(ctx->e, (struct exception  const  *)(& global_request_exception));
    }
    }
  }
#line 708
  return;
}
}
#line 727 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void send_channel_request_responses(struct ssh_channel *channel , struct object_queue *q ) 
{ 
  struct request_status *n ;
  struct lsh_object *tmp ;
  struct lsh_string *tmp___0 ;
  struct lsh_string *tmp___1 ;
  struct lsh_string *tmp___2 ;

  {
  {
  {
#line 731
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 733
    tmp = object_queue_peek_head(q);
    }
#line 733
    n = (struct request_status *)tmp;
    }
#line 734
    if (! n) {
#line 735
      goto while_break;
    } else
#line 734
    if (n->status < 0) {
#line 735
      goto while_break;
    }
    {
    {
#line 737
    object_queue_remove_head(q);
    }
    }
#line 739
    if (n->status) {
      {
      {
#line 739
      tmp___0 = format_channel_success(channel->channel_number);
      }
#line 739
      tmp___2 = tmp___0;
      }
    } else {
      {
      {
#line 739
      tmp___1 = format_channel_failure(channel->channel_number);
      }
#line 739
      tmp___2 = tmp___1;
      }
    }
    {
    {
#line 739
    connection_send(channel->connection, tmp___2);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 744
  return;
}
}
#line 746 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_request_response(struct command_continuation *s , struct lsh_object *x  __attribute__((__unused__)) ) 
{ 
  struct channel_request_continuation *self ;
  struct object_queue *q ;
  int tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 750
  self = (struct channel_request_continuation *)s;
#line 751
  q = & (self->channel)->active_requests;
#line 753
  if (! ((self->active)->status == -1)) {
    {
    {
#line 753
    __assert_fail("self->active->status == -1", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  753U, "do_channel_request_response");
    }
    }
  }
  {
  {
#line 754
  tmp = lsh_queue_is_empty(& q->q);
  }
  }
#line 754
  if (tmp) {
    {
    {
#line 754
    __assert_fail("!lsh_queue_is_empty(&(q)->q)", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  754U, "do_channel_request_response");
    }
    }
  }
  {
#line 756
  (self->active)->status = 1;
  {
#line 758
  send_channel_request_responses(self->channel, q);
  }
  }
#line 759
  return;
}
}
#line 761 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct command_continuation *make_channel_request_response(struct ssh_channel *channel ,
                                                                  struct request_status *active ) 
{ 
  struct channel_request_continuation *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 765
  tmp = lsh_object_alloc(& channel_request_continuation_class);
  }
#line 765
  self = (struct channel_request_continuation *)tmp;
#line 767
  self->super.c = & do_channel_request_response;
#line 768
  self->channel = channel;
#line 769
  self->active = active;
  }
#line 771
  return (& self->super);
}
}
#line 784 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_exc_channel_request_handler(struct exception_handler *c , struct exception  const  *e ) 
{ 
  struct channel_request_exception_handler *self ;
  struct object_queue *q ;
  int tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 788
  self = (struct channel_request_exception_handler *)c;
#line 789
  if (e->type == 32770U) {
#line 791
    q = & (self->channel)->active_requests;
#line 793
    if (! ((self->active)->status == -1)) {
      {
      {
#line 793
      __assert_fail("self->active->status == -1", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                    793U, "do_exc_channel_request_handler");
      }
      }
    }
    {
    {
#line 794
    tmp = lsh_queue_is_empty(& q->q);
    }
    }
#line 794
    if (tmp) {
      {
      {
#line 794
      __assert_fail("!lsh_queue_is_empty(&(q)->q)", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                    794U, "do_exc_channel_request_handler");
      }
      }
    }
    {
#line 796
    (self->active)->status = 0;
    {
#line 798
    send_channel_request_responses(self->channel, q);
    }
    }
  } else {
    {
    {
#line 801
    (*((c->parent)->raise))(c->parent, e);
    }
    }
  }
#line 802
  return;
}
}
#line 804 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct exception_handler *make_channel_request_exception_handler(struct ssh_channel *channel ,
                                                                        struct request_status *active ,
                                                                        struct exception_handler *h___0 ,
                                                                        char const   *context ) 
{ 
  struct channel_request_exception_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 810
  tmp = lsh_object_alloc(& channel_request_exception_handler_class);
  }
#line 810
  self = (struct channel_request_exception_handler *)tmp;
#line 812
  self->super.raise = & do_exc_channel_request_handler;
#line 813
  self->super.parent = h___0;
#line 814
  self->super.context = context;
#line 816
  self->channel = channel;
#line 817
  self->active = active;
  }
#line 819
  return (& self->super);
}
}
#line 822 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static int parse_channel_request(struct simple_buffer *buffer , uint32_t *channel_number ,
                                 struct channel_request_info *info ) 
{ 
  unsigned int msg_number ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 829
  tmp = parse_uint8(buffer, & msg_number);
  }
  }
#line 829
  if (tmp) {
#line 829
    if (msg_number == 98U) {
      {
      {
#line 829
      tmp___0 = parse_uint32(buffer, channel_number);
      }
      }
#line 829
      if (tmp___0) {
        {
        {
#line 829
        tmp___1 = parse_string(buffer, & info->type_length, & info->type_data);
        }
        }
#line 829
        if (tmp___1) {
          {
          {
#line 829
          tmp___2 = parse_boolean(buffer, & info->want_reply);
          }
          }
#line 829
          if (tmp___2) {
            {
            {
#line 836
            info->type = lookup_atom(info->type_length, info->type_data);
            }
            }
#line 837
            return (1);
          } else {
#line 840
            return (0);
          }
        } else {
#line 840
          return (0);
        }
      } else {
#line 840
        return (0);
      }
    } else {
#line 840
      return (0);
    }
  } else {
#line 840
    return (0);
  }
}
}
#line 843
static void do_channel_request_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                       struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 843 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler channel_request_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channel_request_handler};
#line 891 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct report_exception_info  const  channel_req_ignore  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )(~ 0), (uint32_t )32770, "Ignored:"};
#line 843 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_request_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                       struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  struct channel_request_info info ;
  uint32_t channel_number ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct ssh_channel *channel ;
  struct ssh_channel *tmp___1 ;
  struct channel_request *req ;
  struct command_continuation *c ;
  struct exception_handler *e ;
  struct channel_request *r ;
  struct lsh_object *tmp___2 ;
  struct request_status *a ;
  struct request_status *tmp___3 ;
  struct lsh_string *tmp___4 ;
  struct exception *tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
  {
#line 850
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 850
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 850
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 852
  tmp___6 = parse_channel_request(& buffer, & channel_number, & info);
  }
  }
#line 852
  if (tmp___6) {
    {
    {
#line 854
    tmp___1 = lookup_channel(connection->table, channel_number);
    }
#line 854
    channel = tmp___1;
    }
#line 861
    if (channel) {
#line 863
      req = (struct channel_request *)((void *)0);
#line 864
      c = & discard_continuation;
#line 865
      e = channel->e;
#line 867
      if (info.type) {
#line 867
        if (channel->request_types) {
          {
          {
#line 869
          tmp___2 = (*(((struct alist_meta *)(channel->request_types)->super.isa)->get))(channel->request_types,
                                                                                         info.type);
          }
#line 869
          r = (struct channel_request *)tmp___2;
#line 871
          req = r;
          }
        }
      }
#line 873
      if (! req) {
#line 874
        req = channel->request_fallback;
      }
#line 876
      if (req) {
#line 878
        if (info.want_reply) {
          {
          {
#line 880
          tmp___3 = make_request_status();
          }
#line 880
          a = tmp___3;
          {
#line 882
          object_queue_add_tail(& channel->active_requests, & a->super);
          }
          {
#line 885
          c = make_channel_request_response(channel, a);
          }
          {
#line 886
          e = make_channel_request_exception_handler(channel, a, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c:886");
          }
          }
        } else {
          {
          {
#line 896
          e = make_report_exception_handler(& channel_req_ignore, e, "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c:897");
          }
          }
        }
        {
        {
#line 900
        (*(req->handler))(req, channel, & info, & buffer, c, e);
        }
        }
      } else
#line 904
      if (info.want_reply) {
        {
        {
#line 905
        tmp___4 = format_channel_failure(channel->channel_number);
        }
        {
#line 905
        connection_send(connection, tmp___4);
        }
        }
      }
    } else {
      {
      {
#line 911
      werror("SSH_MSG_CHANNEL_REQUEST on nonexistant channel %i: %xS\n", channel_number,
             packet);
      }
      }
    }
  } else {
    {
    {
#line 916
    tmp___5 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_CHANNEL_REQUEST message.");
    }
    {
#line 916
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___5);
    }
    }
  }
#line 917
  return;
}
}
#line 932 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_open_continue(struct command_continuation *c , struct lsh_object *value ) 
{ 
  struct channel_open_continuation *self ;
  struct ssh_channel *channel ;
  struct lsh_string *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 936
  self = (struct channel_open_continuation *)c;
#line 937
  channel = (struct ssh_channel *)value;
#line 939
  if (! channel) {
    {
    {
#line 939
    __assert_fail("channel", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  939U, "do_channel_open_continue");
    }
    }
  }
  {
#line 944
  channel->send_window_size = self->send_window_size;
#line 945
  channel->send_max_packet = self->send_max_packet;
#line 946
  channel->channel_number = self->remote_channel_number;
#line 948
  channel->connection = self->connection;
  {
#line 950
  register_channel(self->local_channel_number, channel, 1);
  }
  {
#line 957
  tmp = format_open_confirmation(channel, self->local_channel_number, "");
  }
  {
#line 957
  connection_send(self->connection, tmp);
  }
  }
#line 960
  return;
}
}
#line 962 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct command_continuation *make_channel_open_continuation(struct ssh_connection *connection ,
                                                                   uint32_t local_channel_number ,
                                                                   uint32_t remote_channel_number ,
                                                                   uint32_t send_window_size ,
                                                                   uint32_t send_max_packet ) 
{ 
  struct channel_open_continuation *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 969
  tmp = lsh_object_alloc(& channel_open_continuation_class);
  }
#line 969
  self = (struct channel_open_continuation *)tmp;
#line 971
  self->super.c = & do_channel_open_continue;
#line 972
  self->connection = connection;
#line 973
  self->local_channel_number = local_channel_number;
#line 974
  self->remote_channel_number = remote_channel_number;
#line 975
  self->send_window_size = send_window_size;
#line 976
  self->send_max_packet = send_max_packet;
  }
#line 978
  return (& self->super);
}
}
#line 991 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_exc_channel_open_handler(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct exc_channel_open_handler *self ;
  struct channel_open_exception *exc ;
  struct channel_table *table ;
  struct lsh_string *tmp ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 995
  self = (struct exc_channel_open_handler *)s;
#line 999
  if (e->type == 32771U) {
#line 999
    goto case_32771;
  }
#line 1014
  goto switch_default;
  case_32771: 
#line 1001
  exc = (struct channel_open_exception *)e;
#line 1002
  table = (self->connection)->table;
#line 1004
  if (! *(table->in_use + self->local_channel_number)) {
    {
    {
#line 1004
    __assert_fail("table->in_use[self->local_channel_number]", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  1004U, "do_exc_channel_open_handler");
    }
    }
  }
#line 1005
  if (! (! *(table->channels + self->local_channel_number))) {
    {
    {
#line 1005
    __assert_fail("!table->channels[self->local_channel_number]", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  1005U, "do_exc_channel_open_handler");
    }
    }
  }
  {
  {
#line 1007
  dealloc_channel(table, (int )self->local_channel_number);
  }
  {
#line 1009
  tmp = format_open_failure(self->remote_channel_number, exc->error_code, (char const   *)e->msg,
                            "");
  }
  {
#line 1009
  connection_send(self->connection, tmp);
  }
  }
#line 1012
  goto switch_break;
  switch_default: 
  {
  {
#line 1015
  (*((self->super.parent)->raise))(self->super.parent, e);
  }
  }
  switch_break: ;
#line 1017
  return;
}
}
#line 1019 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct exception_handler *make_exc_channel_open_handler(struct ssh_connection *connection ,
                                                               uint32_t local_channel_number ,
                                                               uint32_t remote_channel_number ,
                                                               struct exception_handler *parent ,
                                                               char const   *context ) 
{ 
  struct exc_channel_open_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 1026
  tmp = lsh_object_alloc(& exc_channel_open_handler_class);
  }
#line 1026
  self = (struct exc_channel_open_handler *)tmp;
#line 1027
  self->super.parent = parent;
#line 1028
  self->super.raise = & do_exc_channel_open_handler;
#line 1029
  self->super.context = context;
#line 1031
  self->connection = connection;
#line 1032
  self->local_channel_number = local_channel_number;
#line 1033
  self->remote_channel_number = remote_channel_number;
  }
#line 1035
  return (& self->super);
}
}
#line 1038 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static int parse_channel_open(struct simple_buffer *buffer , struct channel_open_info *info ) 
{ 
  unsigned int msg_number ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 1044
  tmp = parse_uint8(buffer, & msg_number);
  }
  }
#line 1044
  if (tmp) {
#line 1044
    if (msg_number == 90U) {
      {
      {
#line 1044
      tmp___0 = parse_string(buffer, & info->type_length, & info->type_data);
      }
      }
#line 1044
      if (tmp___0) {
        {
        {
#line 1044
        tmp___1 = parse_uint32(buffer, & info->remote_channel_number);
        }
        }
#line 1044
        if (tmp___1) {
          {
          {
#line 1044
          tmp___2 = parse_uint32(buffer, & info->send_window_size);
          }
          }
#line 1044
          if (tmp___2) {
            {
            {
#line 1044
            tmp___3 = parse_uint32(buffer, & info->send_max_packet);
            }
            }
#line 1044
            if (tmp___3) {
              {
              {
#line 1051
              info->type = lookup_atom(info->type_length, info->type_data);
              }
              }
#line 1055
              if (info->send_max_packet > 32768U) {
                {
                {
#line 1057
                werror("do_channel_open: The remote end asked for really large packets.\n");
                }
#line 1058
                info->send_max_packet = (uint32_t )32768;
                }
              }
#line 1061
              return (1);
            } else {
#line 1064
              return (0);
            }
          } else {
#line 1064
            return (0);
          }
        } else {
#line 1064
          return (0);
        }
      } else {
#line 1064
        return (0);
      }
    } else {
#line 1064
      return (0);
    }
  } else {
#line 1064
    return (0);
  }
}
}
#line 1068
static void do_channel_open_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                    struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 1068 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler channel_open_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channel_open_handler};
#line 1068 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_open_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                    struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  struct channel_open_info info ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct channel_open *open___0 ;
  struct lsh_string *tmp___1 ;
  struct channel_open *o ;
  struct lsh_object *tmp___2 ;
  struct lsh_string *tmp___3 ;
  int local_number ;
  int tmp___4 ;
  struct lsh_string *tmp___5 ;
  struct exception_handler *tmp___6 ;
  struct command_continuation *tmp___7 ;
  struct exception *tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
  {
#line 1074
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 1074
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 1074
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 1076
  tmp___9 = parse_channel_open(& buffer, & info);
  }
  }
#line 1076
  if (tmp___9) {
#line 1078
    open___0 = (struct channel_open *)((void *)0);
#line 1083
    if ((connection->table)->pending_close) {
      {
      {
#line 1087
      tmp___1 = format_open_failure(info.remote_channel_number, (uint32_t )1, "Waiting for channels to close.",
                                    "");
      }
      {
#line 1087
      connection_send(connection, tmp___1);
      }
      }
    } else {
#line 1095
      if (info.type) {
        {
        {
#line 1097
        tmp___2 = (*(((struct alist_meta *)((connection->table)->channel_types)->super.isa)->get))((connection->table)->channel_types,
                                                                                                   info.type);
        }
#line 1097
        o = (struct channel_open *)tmp___2;
#line 1100
        open___0 = o;
        }
      }
#line 1103
      if (! open___0) {
#line 1104
        open___0 = (connection->table)->open_fallback;
      }
#line 1106
      if (! open___0) {
        {
        {
#line 1108
        tmp___3 = format_open_failure(info.remote_channel_number, (uint32_t )3, "Unknown channel type",
                                      "");
        }
        {
#line 1108
        connection_send(connection, tmp___3);
        }
        }
      } else {
        {
        {
#line 1116
        tmp___4 = alloc_channel(connection->table);
        }
#line 1116
        local_number = tmp___4;
        }
#line 1118
        if (local_number < 0) {
          {
          {
#line 1120
          tmp___5 = format_open_failure(info.remote_channel_number, (uint32_t )4,
                                        "Channel limit exceeded.", "");
          }
          {
#line 1120
          connection_send(connection, tmp___5);
          }
          }
#line 1125
          return;
        }
        {
        {
#line 1128
        tmp___6 = make_exc_channel_open_handler(connection, (uint32_t )local_number,
                                                info.remote_channel_number, connection->e,
                                                "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c:1140");
        }
        {
#line 1128
        tmp___7 = make_channel_open_continuation(connection, (uint32_t )local_number,
                                                 info.remote_channel_number, info.send_window_size,
                                                 info.send_max_packet);
        }
        {
#line 1128
        (*(open___0->handler))(open___0, connection, & info, & buffer, tmp___7, tmp___6);
        }
        }
      }
    }
  } else {
    {
    {
#line 1146
    tmp___8 = make_protocol_exception((uint32_t )2, "Invalid SSH_MSG_CHANNEL_OPEN message.");
    }
    {
#line 1146
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___8);
    }
    }
  }
#line 1147
  return;
}
}
#line 1149
static void do_window_adjust_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                     struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 1149 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler window_adjust_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_window_adjust_handler};
#line 1149 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_window_adjust_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                     struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t channel_number ;
  uint32_t size ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct ssh_channel *channel ;
  struct ssh_channel *tmp___1 ;
  struct exception *tmp___2 ;
  struct exception *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
  {
  {
#line 1157
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 1157
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 1157
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 1159
  tmp___4 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 1159
  if (tmp___4) {
#line 1159
    if (msg_number == 93U) {
      {
      {
#line 1159
      tmp___5 = parse_uint32(& buffer, & channel_number);
      }
      }
#line 1159
      if (tmp___5) {
        {
        {
#line 1159
        tmp___6 = parse_uint32(& buffer, & size);
        }
        }
#line 1159
        if (tmp___6) {
          {
          {
#line 1159
          tmp___7 = parse_eod(& buffer);
          }
          }
#line 1159
          if (tmp___7) {
            {
            {
#line 1165
            tmp___1 = lookup_channel(connection->table, channel_number);
            }
#line 1165
            channel = tmp___1;
            }
#line 1168
            if (channel) {
#line 1168
              if (! (channel->flags & 2)) {
#line 1171
                if (! (channel->flags & 5)) {
#line 1173
                  channel->send_window_size += size;
#line 1175
                  if (channel->send_window_size) {
#line 1175
                    if (channel->send_adjust) {
                      {
                      {
#line 1176
                      (*(channel->send_adjust))(channel, size);
                      }
                      }
                    }
                  }
                }
              } else {
                {
                {
#line 1181
                werror("SSH_MSG_CHANNEL_WINDOW_ADJUST on nonexistant or closed channel %i\n",
                       channel_number);
                }
                {
#line 1183
                tmp___2 = make_protocol_exception((uint32_t )2, "Unexpected CHANNEL_WINDOW_ADJUST");
                }
                {
#line 1183
                (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___2);
                }
                }
              }
            } else {
              {
              {
#line 1181
              werror("SSH_MSG_CHANNEL_WINDOW_ADJUST on nonexistant or closed channel %i\n",
                     channel_number);
              }
              {
#line 1183
              tmp___2 = make_protocol_exception((uint32_t )2, "Unexpected CHANNEL_WINDOW_ADJUST");
              }
              {
#line 1183
              (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___2);
              }
              }
            }
          } else {
            {
            {
#line 1187
            tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_WINDOW_ADJUST message.");
            }
            {
#line 1187
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
            }
            }
          }
        } else {
          {
          {
#line 1187
          tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_WINDOW_ADJUST message.");
          }
          {
#line 1187
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
          }
          }
        }
      } else {
        {
        {
#line 1187
        tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_WINDOW_ADJUST message.");
        }
        {
#line 1187
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
        }
        }
      }
    } else {
      {
      {
#line 1187
      tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_WINDOW_ADJUST message.");
      }
      {
#line 1187
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
      }
      }
    }
  } else {
    {
    {
#line 1187
    tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_WINDOW_ADJUST message.");
    }
    {
#line 1187
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
    }
    }
  }
#line 1188
  return;
}
}
#line 1190
static void do_channel_data_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                    struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 1190 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler channel_data_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channel_data_handler};
#line 1190 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_data_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                    struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t channel_number ;
  struct lsh_string *data ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct ssh_channel *channel ;
  struct ssh_channel *tmp___1 ;
  uint32_t length ;
  uint32_t tmp___2 ;
  struct exception *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
  {
#line 1198
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 1198
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 1198
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 1200
  tmp___4 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 1200
  if (tmp___4) {
#line 1200
    if (msg_number == 94U) {
      {
      {
#line 1200
      tmp___5 = parse_uint32(& buffer, & channel_number);
      }
      }
#line 1200
      if (tmp___5) {
        {
        {
#line 1200
        data = parse_string_copy(& buffer);
        }
        }
#line 1200
        if (data) {
          {
          {
#line 1200
          tmp___6 = parse_eod(& buffer);
          }
          }
#line 1200
          if (tmp___6) {
            {
            {
#line 1206
            tmp___1 = lookup_channel(connection->table, channel_number);
            }
#line 1206
            channel = tmp___1;
            }
#line 1209
            if (channel) {
#line 1209
              if (channel->receive) {
#line 1209
                if (! (channel->flags & 10)) {
#line 1213
                  if (channel->flags & 1) {
                    {
                    {
#line 1215
                    lsh_string_free((struct lsh_string  const  *)data);
                    }
                    {
#line 1216
                    werror("Ignoring data on channel which is closing\n");
                    }
                    }
#line 1217
                    return;
                  } else {
                    {
                    {
#line 1221
                    tmp___2 = lsh_string_length((struct lsh_string  const  *)data);
                    }
#line 1221
                    length = tmp___2;
                    }
#line 1222
                    if (length > channel->rec_max_packet) {
                      {
                      {
#line 1224
                      werror("Channel data larger than rec_max_packet. Extra data ignored.\n");
                      }
                      {
#line 1225
                      lsh_string_trunc(data, channel->rec_max_packet);
                      }
                      }
                    }
#line 1228
                    if (length > channel->rec_window_size) {
                      {
                      {
#line 1231
                      werror("Channel data overflow. Extra data ignored.\n");
                      }
                      {
#line 1232
                      debug("   (data->length=%i, rec_window_size=%i).\n", length,
                            channel->rec_window_size);
                      }
                      {
#line 1235
                      lsh_string_trunc(data, channel->rec_window_size);
                      }
                      }
                    }
#line 1238
                    if (! length) {
                      {
                      {
#line 1241
                      lsh_string_free((struct lsh_string  const  *)data);
                      }
                      }
#line 1242
                      return;
                    }
                    {
#line 1244
                    channel->rec_window_size -= length;
                    {
#line 1246
                    (*(channel->receive))(channel, 0, data);
                    }
                    }
                  }
                } else {
                  {
                  {
#line 1251
                  werror("Data on closed or non-existant channel %i\n", channel_number);
                  }
                  {
#line 1253
                  lsh_string_free((struct lsh_string  const  *)data);
                  }
                  }
                }
              } else {
                {
                {
#line 1251
                werror("Data on closed or non-existant channel %i\n", channel_number);
                }
                {
#line 1253
                lsh_string_free((struct lsh_string  const  *)data);
                }
                }
              }
            } else {
              {
              {
#line 1251
              werror("Data on closed or non-existant channel %i\n", channel_number);
              }
              {
#line 1253
              lsh_string_free((struct lsh_string  const  *)data);
              }
              }
            }
          } else {
            {
            {
#line 1257
            tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_DATA message.");
            }
            {
#line 1257
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
            }
            }
          }
        } else {
          {
          {
#line 1257
          tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_DATA message.");
          }
          {
#line 1257
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
          }
          }
        }
      } else {
        {
        {
#line 1257
        tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_DATA message.");
        }
        {
#line 1257
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
        }
        }
      }
    } else {
      {
      {
#line 1257
      tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_DATA message.");
      }
      {
#line 1257
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
      }
      }
    }
  } else {
    {
    {
#line 1257
    tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_DATA message.");
    }
    {
#line 1257
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
    }
    }
  }
#line 1258
  return;
}
}
#line 1260
static void do_channel_extended_data_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                             struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 1260 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler channel_extended_data_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channel_extended_data_handler};
#line 1260 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_extended_data_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                             struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t channel_number ;
  uint32_t type ;
  struct lsh_string *data ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct ssh_channel *channel ;
  struct ssh_channel *tmp___1 ;
  uint32_t length ;
  uint32_t tmp___2 ;
  struct exception *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  void *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
  {
  {
#line 1269
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 1269
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 1269
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 1271
  tmp___4 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 1271
  if (tmp___4) {
#line 1271
    if (msg_number == 95U) {
      {
      {
#line 1271
      tmp___5 = parse_uint32(& buffer, & channel_number);
      }
      }
#line 1271
      if (tmp___5) {
        {
        {
#line 1271
        tmp___6 = parse_uint32(& buffer, & type);
        }
        }
#line 1271
        if (tmp___6) {
          {
          {
#line 1271
          data = parse_string_copy(& buffer);
          }
          }
#line 1271
          if (data) {
            {
            {
#line 1271
            tmp___7 = parse_eod(& buffer);
            }
            }
#line 1271
            if (tmp___7) {
              {
              {
#line 1278
              tmp___1 = lookup_channel(connection->table, channel_number);
              }
#line 1278
              channel = tmp___1;
              }
#line 1281
              if (channel) {
#line 1281
                if (channel->receive) {
#line 1281
                  if (! (channel->flags & 10)) {
#line 1285
                    if (channel->flags & 1) {
                      {
                      {
#line 1287
                      lsh_string_free((struct lsh_string  const  *)data);
                      }
                      {
#line 1288
                      werror("Ignoring extended data on channel which is closing\n");
                      }
                      }
#line 1289
                      return;
                    } else {
                      {
                      {
#line 1293
                      tmp___2 = lsh_string_length((struct lsh_string  const  *)data);
                      }
#line 1293
                      length = tmp___2;
                      }
#line 1294
                      if (length > channel->rec_max_packet) {
                        {
                        {
#line 1296
                        werror("Channel data larger than rec_max_packet. Extra data ignored.\n");
                        }
                        {
#line 1297
                        lsh_string_trunc(data, channel->rec_max_packet);
                        }
                        }
                      }
#line 1300
                      if (length > channel->rec_window_size) {
                        {
                        {
#line 1303
                        werror("Channel extended data overflow. Extra data ignored.\n");
                        }
                        {
#line 1305
                        debug("   (data->length=%i, rec_window_size=%i).\n", length,
                              channel->rec_window_size);
                        }
                        {
#line 1308
                        lsh_string_trunc(data, channel->rec_window_size);
                        }
                        }
                      }
#line 1311
                      if (! length) {
                        {
                        {
#line 1314
                        lsh_string_free((struct lsh_string  const  *)data);
                        }
                        }
#line 1315
                        return;
                      }
#line 1318
                      channel->rec_window_size -= length;
#line 1322
                      if (type == 1U) {
#line 1322
                        goto case_1;
                      }
#line 1325
                      goto switch_default;
                      case_1: 
                      {
                      {
#line 1323
                      (*(channel->receive))(channel, 1, data);
                      }
                      }
#line 1324
                      goto switch_break;
                      switch_default: 
                      {
                      {
#line 1326
                      werror("Unknown type %i of extended data.\n", type);
                      }
                      {
#line 1328
                      lsh_string_free((struct lsh_string  const  *)data);
                      }
                      }
                      switch_break: ;
                    }
                  } else {
                    {
                    {
#line 1334
                    werror("Extended data on closed or non-existant channel %i\n",
                           channel_number);
                    }
                    {
#line 1336
                    lsh_string_free((struct lsh_string  const  *)data);
                    }
                    }
                  }
                } else {
                  {
                  {
#line 1334
                  werror("Extended data on closed or non-existant channel %i\n", channel_number);
                  }
                  {
#line 1336
                  lsh_string_free((struct lsh_string  const  *)data);
                  }
                  }
                }
              } else {
                {
                {
#line 1334
                werror("Extended data on closed or non-existant channel %i\n", channel_number);
                }
                {
#line 1336
                lsh_string_free((struct lsh_string  const  *)data);
                }
                }
              }
            } else {
              {
              {
#line 1340
              tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_EXTENDED_DATA message.");
              }
              {
#line 1340
              (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
              }
              }
            }
          } else {
            {
            {
#line 1340
            tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_EXTENDED_DATA message.");
            }
            {
#line 1340
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
            }
            }
          }
        } else {
          {
          {
#line 1340
          tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_EXTENDED_DATA message.");
          }
          {
#line 1340
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
          }
          }
        }
      } else {
        {
        {
#line 1340
        tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_EXTENDED_DATA message.");
        }
        {
#line 1340
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
        }
        }
      }
    } else {
      {
      {
#line 1340
      tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_EXTENDED_DATA message.");
      }
      {
#line 1340
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
      }
      }
    }
  } else {
    {
    {
#line 1340
    tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_EXTENDED_DATA message.");
    }
    {
#line 1340
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
    }
    }
  }
#line 1341
  return;
}
}
#line 1343
static void do_channel_eof_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                   struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 1343 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler channel_eof_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channel_eof_handler};
#line 1343 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_eof_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                   struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t channel_number ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct ssh_channel *channel ;
  struct ssh_channel *tmp___1 ;
  struct exception *tmp___2 ;
  struct exception *tmp___3 ;
  struct exception *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
  {
#line 1350
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 1350
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 1350
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 1352
  tmp___5 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 1352
  if (tmp___5) {
#line 1352
    if (msg_number == 96U) {
      {
      {
#line 1352
      tmp___6 = parse_uint32(& buffer, & channel_number);
      }
      }
#line 1352
      if (tmp___6) {
        {
        {
#line 1352
        tmp___7 = parse_eod(& buffer);
        }
        }
#line 1352
        if (tmp___7) {
          {
          {
#line 1357
          tmp___1 = lookup_channel(connection->table, channel_number);
          }
#line 1357
          channel = tmp___1;
          }
#line 1360
          if (channel) {
#line 1362
            if (channel->flags & 10) {
              {
              {
#line 1364
              werror("Receiving EOF on channel on closed channel.\n");
              }
              {
#line 1365
              tmp___2 = make_protocol_exception((uint32_t )2, "Received EOF on channel on closed channel.");
              }
              {
#line 1365
              (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___2);
              }
              }
            } else {
              {
              {
#line 1370
              verbose("Receiving EOF on channel %i (local %i)\n", channel->channel_number,
                      channel_number);
              }
#line 1373
              channel->flags |= 8;
              }
#line 1375
              if (channel->eof) {
                {
                {
#line 1377
                (*(channel->eof))(channel);
                }
                }
#line 1380
                if (channel->flags & 4) {
#line 1380
                  if (channel->flags & 16) {
                    {
                    {
#line 1382
                    channel_close(channel);
                    }
                    }
                  }
                }
              } else {
                {
                {
#line 1387
                debug("No CHANNEL_EOF handler. Closing.\n");
                }
                {
#line 1388
                channel_close(channel);
                }
                }
              }
            }
          } else {
            {
            {
#line 1395
            werror("EOF on non-existant channel %i\n", channel_number);
            }
            {
#line 1397
            tmp___3 = make_protocol_exception((uint32_t )2, "EOF on non-existant channel");
            }
            {
#line 1397
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
            }
            }
          }
        } else {
          {
          {
#line 1401
          tmp___4 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_EOF message");
          }
          {
#line 1401
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
          }
          }
        }
      } else {
        {
        {
#line 1401
        tmp___4 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_EOF message");
        }
        {
#line 1401
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
        }
        }
      }
    } else {
      {
      {
#line 1401
      tmp___4 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_EOF message");
      }
      {
#line 1401
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
      }
      }
    }
  } else {
    {
    {
#line 1401
    tmp___4 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_EOF message");
    }
    {
#line 1401
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
    }
    }
  }
#line 1402
  return;
}
}
#line 1404
static void do_channel_close_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                     struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 1404 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler channel_close_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channel_close_handler};
#line 1443 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct exception  const  finish_exception___0  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )65537, "Received CLOSE message."};
#line 1404 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_close_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                     struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t channel_number ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct ssh_channel *channel ;
  struct ssh_channel *tmp___1 ;
  struct exception *tmp___2 ;
  struct exception *tmp___3 ;
  struct exception *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
  {
#line 1411
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 1411
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 1411
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 1413
  tmp___5 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 1413
  if (tmp___5) {
#line 1413
    if (msg_number == 97U) {
      {
      {
#line 1413
      tmp___6 = parse_uint32(& buffer, & channel_number);
      }
      }
#line 1413
      if (tmp___6) {
        {
        {
#line 1413
        tmp___7 = parse_eod(& buffer);
        }
        }
#line 1413
        if (tmp___7) {
          {
          {
#line 1418
          tmp___1 = lookup_channel(connection->table, channel_number);
          }
#line 1418
          channel = tmp___1;
          }
#line 1421
          if (channel) {
            {
            {
#line 1423
            verbose("Receiving CLOSE on channel %i (local %i)\n", channel->channel_number,
                    channel_number);
            }
            }
#line 1426
            if (channel->flags & 2) {
              {
              {
#line 1428
              werror("Receiving multiple CLOSE on channel.\n");
              }
              {
#line 1429
              tmp___2 = make_protocol_exception((uint32_t )2, "Receiving multiple CLOSE on channel.");
              }
              {
#line 1429
              (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___2);
              }
              }
            } else {
#line 1433
              channel->flags |= 2;
#line 1435
              if (! (channel->flags & 41)) {
                {
                {
#line 1438
                werror("Unexpected channel CLOSE.\n");
                }
                }
              }
#line 1441
              if (channel->flags & 1) {
                {
                {
#line 1446
                (*((channel->e)->raise))(channel->e, & finish_exception___0);
                }
                }
              } else {
                {
                {
#line 1450
                channel_close(channel);
                }
                }
              }
            }
          } else {
            {
            {
#line 1455
            werror("CLOSE on non-existant channel %i\n", channel_number);
            }
            {
#line 1457
            tmp___3 = make_protocol_exception((uint32_t )2, "CLOSE on non-existant channel");
            }
            {
#line 1457
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
            }
            }
          }
        } else {
          {
          {
#line 1461
          tmp___4 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_CLOSE message");
          }
          {
#line 1461
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
          }
          }
        }
      } else {
        {
        {
#line 1461
        tmp___4 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_CLOSE message");
        }
        {
#line 1461
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
        }
        }
      }
    } else {
      {
      {
#line 1461
      tmp___4 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_CLOSE message");
      }
      {
#line 1461
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
      }
      }
    }
  } else {
    {
    {
#line 1461
    tmp___4 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_CLOSE message");
    }
    {
#line 1461
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___4);
    }
    }
  }
#line 1462
  return;
}
}
#line 1464
static void do_channel_open_confirm_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                            struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 1464 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler channel_open_confirm_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channel_open_confirm_handler};
#line 1464 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_open_confirm_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                            struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t local_channel_number ;
  uint32_t remote_channel_number ;
  uint32_t window_size ;
  uint32_t max_packet ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct ssh_channel *channel ;
  struct ssh_channel *tmp___1 ;
  struct command_continuation *c ;
  struct exception *tmp___2 ;
  struct exception *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  void *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
  {
  {
#line 1474
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 1474
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 1474
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 1476
  tmp___4 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 1476
  if (tmp___4) {
#line 1476
    if (msg_number == 91U) {
      {
      {
#line 1476
      tmp___5 = parse_uint32(& buffer, & local_channel_number);
      }
      }
#line 1476
      if (tmp___5) {
        {
        {
#line 1476
        tmp___6 = parse_uint32(& buffer, & remote_channel_number);
        }
        }
#line 1476
        if (tmp___6) {
          {
          {
#line 1476
          tmp___7 = parse_uint32(& buffer, & window_size);
          }
          }
#line 1476
          if (tmp___7) {
            {
            {
#line 1476
            tmp___8 = parse_uint32(& buffer, & max_packet);
            }
            }
#line 1476
            if (tmp___8) {
              {
              {
#line 1476
              tmp___9 = parse_eod(& buffer);
              }
              }
#line 1476
              if (tmp___9) {
                {
                {
#line 1484
                tmp___1 = lookup_channel_reserved(connection->table, local_channel_number);
                }
#line 1484
                channel = tmp___1;
                }
#line 1488
                if (channel) {
#line 1490
                  c = channel->open_continuation;
#line 1491
                  if (! c) {
                    {
                    {
#line 1491
                    __assert_fail("c", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                                  1491U, "do_channel_open_confirm_handler");
                    }
                    }
                  }
                  {
#line 1493
                  channel->open_continuation = (struct command_continuation *)((void *)0);
#line 1495
                  channel->channel_number = remote_channel_number;
#line 1496
                  channel->send_window_size = window_size;
#line 1497
                  channel->send_max_packet = max_packet;
                  {
#line 1499
                  use_channel(connection, local_channel_number);
                  }
                  {
#line 1501
                  (*(c->c))(c, (struct lsh_object *)channel);
                  }
                  }
                } else {
                  {
                  {
#line 1505
                  werror("Unexpected SSH_MSG_CHANNEL_OPEN_CONFIRMATION on channel %i\n",
                         local_channel_number);
                  }
                  {
#line 1507
                  tmp___2 = make_protocol_exception((uint32_t )2, "Unexpected CHANNEL_OPEN_CONFIRMATION.");
                  }
                  {
#line 1507
                  (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___2);
                  }
                  }
                }
              } else {
                {
                {
#line 1511
                tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_CONFIRMATION message.");
                }
                {
#line 1511
                (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
                }
                }
              }
            } else {
              {
              {
#line 1511
              tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_CONFIRMATION message.");
              }
              {
#line 1511
              (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
              }
              }
            }
          } else {
            {
            {
#line 1511
            tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_CONFIRMATION message.");
            }
            {
#line 1511
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
            }
            }
          }
        } else {
          {
          {
#line 1511
          tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_CONFIRMATION message.");
          }
          {
#line 1511
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
          }
          }
        }
      } else {
        {
        {
#line 1511
        tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_CONFIRMATION message.");
        }
        {
#line 1511
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
        }
        }
      }
    } else {
      {
      {
#line 1511
      tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_CONFIRMATION message.");
      }
      {
#line 1511
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
      }
      }
    }
  } else {
    {
    {
#line 1511
    tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_CONFIRMATION message.");
    }
    {
#line 1511
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
    }
    }
  }
#line 1512
  return;
}
}
#line 1514
static void do_channel_open_failure_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                            struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 1514 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler channel_open_failure_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channel_open_failure_handler};
#line 1544 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct exception  const  finish_exception___1  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )65537, "CHANNEL_OPEN failed."};
#line 1514 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_open_failure_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                            struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t channel_number ;
  uint32_t reason ;
  uint8_t const   *msg ;
  uint32_t length ;
  uint8_t const   *language ;
  uint32_t language_length ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct ssh_channel *channel ;
  struct ssh_channel *tmp___1 ;
  struct exception *tmp___2 ;
  struct exception *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  void *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
  {
  {
#line 1528
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 1528
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 1528
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 1530
  tmp___4 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 1530
  if (tmp___4) {
#line 1530
    if (msg_number == 92U) {
      {
      {
#line 1530
      tmp___5 = parse_uint32(& buffer, & channel_number);
      }
      }
#line 1530
      if (tmp___5) {
        {
        {
#line 1530
        tmp___6 = parse_uint32(& buffer, & reason);
        }
        }
#line 1530
        if (tmp___6) {
          {
          {
#line 1530
          tmp___7 = parse_string(& buffer, & length, & msg);
          }
          }
#line 1530
          if (tmp___7) {
            {
            {
#line 1530
            tmp___8 = parse_string(& buffer, & language_length, & language);
            }
            }
#line 1530
            if (tmp___8) {
              {
              {
#line 1530
              tmp___9 = parse_eod(& buffer);
              }
              }
#line 1530
              if (tmp___9) {
                {
                {
#line 1538
                tmp___1 = lookup_channel_reserved(connection->table, channel_number);
                }
#line 1538
                channel = tmp___1;
                }
#line 1542
                if (channel) {
#line 1547
                  if (! channel->open_continuation) {
                    {
                    {
#line 1547
                    __assert_fail("channel->open_continuation", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                                  1547U, "do_channel_open_failure_handler");
                    }
                    }
                  }
                  {
                  {
#line 1550
                  tmp___2 = make_channel_open_exception(reason, "Refused by peer");
                  }
                  {
#line 1550
                  (*((channel->e)->raise))(channel->e, (struct exception  const  *)tmp___2);
                  }
                  {
#line 1552
                  (*((channel->e)->raise))(channel->e, & finish_exception___1);
                  }
                  }
                } else {
                  {
                  {
#line 1555
                  werror("Unexpected SSH_MSG_CHANNEL_OPEN_FAILURE on channel %i\n",
                         channel_number);
                  }
                  }
                }
              } else {
                {
                {
#line 1559
                tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_FAILURE message.");
                }
                {
#line 1559
                (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
                }
                }
              }
            } else {
              {
              {
#line 1559
              tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_FAILURE message.");
              }
              {
#line 1559
              (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
              }
              }
            }
          } else {
            {
            {
#line 1559
            tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_FAILURE message.");
            }
            {
#line 1559
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
            }
            }
          }
        } else {
          {
          {
#line 1559
          tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_FAILURE message.");
          }
          {
#line 1559
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
          }
          }
        }
      } else {
        {
        {
#line 1559
        tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_FAILURE message.");
        }
        {
#line 1559
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
        }
        }
      }
    } else {
      {
      {
#line 1559
      tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_FAILURE message.");
      }
      {
#line 1559
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
      }
      }
    }
  } else {
    {
    {
#line 1559
    tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_OPEN_FAILURE message.");
    }
    {
#line 1559
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
    }
    }
  }
#line 1560
  return;
}
}
#line 1562
static void do_channel_success_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                       struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 1562 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler channel_success_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channel_success_handler};
#line 1562 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_success_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                       struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t channel_number ;
  struct ssh_channel *channel ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct command_context *ctx ;
  struct lsh_object *tmp___1 ;
  int tmp___2 ;
  struct exception *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
  {
#line 1570
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 1570
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 1570
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 1572
  tmp___4 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 1572
  if (tmp___4) {
#line 1572
    if (msg_number == 99U) {
      {
      {
#line 1572
      tmp___5 = parse_uint32(& buffer, & channel_number);
      }
      }
#line 1572
      if (tmp___5) {
        {
        {
#line 1572
        tmp___6 = parse_eod(& buffer);
        }
        }
#line 1572
        if (tmp___6) {
          {
          {
#line 1572
          channel = lookup_channel(connection->table, channel_number);
          }
          }
#line 1572
          if (channel) {
            {
            {
#line 1578
            tmp___2 = lsh_queue_is_empty(& channel->pending_requests.q);
            }
            }
#line 1578
            if (tmp___2) {
              {
              {
#line 1580
              werror("do_channel_success: Unexpected message. Ignoring.\n");
              }
              }
            } else {
              {
              {
#line 1584
              tmp___1 = object_queue_remove_head(& channel->pending_requests);
              }
#line 1584
              ctx = (struct command_context *)tmp___1;
              {
#line 1587
              (*((ctx->c)->c))(ctx->c, (struct lsh_object *)channel);
              }
              }
            }
          } else {
            {
            {
#line 1591
            tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_SUCCESS message");
            }
            {
#line 1591
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
            }
            }
          }
        } else {
          {
          {
#line 1591
          tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_SUCCESS message");
          }
          {
#line 1591
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
          }
          }
        }
      } else {
        {
        {
#line 1591
        tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_SUCCESS message");
        }
        {
#line 1591
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
        }
        }
      }
    } else {
      {
      {
#line 1591
      tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_SUCCESS message");
      }
      {
#line 1591
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
      }
      }
    }
  } else {
    {
    {
#line 1591
    tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_SUCCESS message");
    }
    {
#line 1591
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
    }
    }
  }
#line 1592
  return;
}
}
#line 1594
static void do_channel_failure_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                       struct ssh_connection *connection , struct lsh_string *packet ) ;
#line 1594 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct packet_handler channel_failure_handler  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channel_failure_handler};
#line 1616 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct exception  const  channel_request_exception  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )32770, "Channel request failed"};
#line 1594 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_failure_handler(struct packet_handler *s  __attribute__((__unused__)) ,
                                       struct ssh_connection *connection , struct lsh_string *packet ) 
{ 
  struct simple_buffer buffer ;
  unsigned int msg_number ;
  uint32_t channel_number ;
  struct ssh_channel *channel ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct command_context *ctx ;
  struct lsh_object *tmp___1 ;
  int tmp___2 ;
  struct exception *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
  {
#line 1602
  tmp = lsh_string_data((struct lsh_string  const  *)packet);
  }
  {
#line 1602
  tmp___0 = lsh_string_length((struct lsh_string  const  *)packet);
  }
  {
#line 1602
  simple_buffer_init(& buffer, tmp___0, tmp);
  }
  {
#line 1604
  tmp___4 = parse_uint8(& buffer, & msg_number);
  }
  }
#line 1604
  if (tmp___4) {
#line 1604
    if (msg_number == 100U) {
      {
      {
#line 1604
      tmp___5 = parse_uint32(& buffer, & channel_number);
      }
      }
#line 1604
      if (tmp___5) {
        {
        {
#line 1604
        tmp___6 = parse_eod(& buffer);
        }
        }
#line 1604
        if (tmp___6) {
          {
          {
#line 1604
          channel = lookup_channel(connection->table, channel_number);
          }
          }
#line 1604
          if (channel) {
            {
            {
#line 1610
            tmp___2 = lsh_queue_is_empty(& channel->pending_requests.q);
            }
            }
#line 1610
            if (tmp___2) {
              {
              {
#line 1612
              werror("do_channel_failure: No handler. Ignoring.\n");
              }
              }
            } else {
              {
              {
#line 1619
              tmp___1 = object_queue_remove_head(& channel->pending_requests);
              }
#line 1619
              ctx = (struct command_context *)tmp___1;
              {
#line 1622
              (*((ctx->e)->raise))(ctx->e, & channel_request_exception);
              }
              }
            }
          } else {
            {
            {
#line 1626
            tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_FAILURE message.");
            }
            {
#line 1626
            (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
            }
            }
          }
        } else {
          {
          {
#line 1626
          tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_FAILURE message.");
          }
          {
#line 1626
          (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
          }
          }
        }
      } else {
        {
        {
#line 1626
        tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_FAILURE message.");
        }
        {
#line 1626
        (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
        }
        }
      }
    } else {
      {
      {
#line 1626
      tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_FAILURE message.");
      }
      {
#line 1626
      (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
      }
      }
    }
  } else {
    {
    {
#line 1626
    tmp___3 = make_protocol_exception((uint32_t )2, "Invalid CHANNEL_FAILURE message.");
    }
    {
#line 1626
    (*((connection->e)->raise))(connection->e, (struct exception  const  *)tmp___3);
    }
    }
  }
#line 1627
  return;
}
}
#line 1632 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channels_wakeup(struct command_continuation *s  __attribute__((__unused__)) ,
                               struct lsh_object *x ) 
{ 
  struct ssh_connection *connection ;
  struct channel_table *table ;
  uint32_t i ;
  struct ssh_channel *channel ;
  struct ssh_channel *tmp ;

  {
#line 1636
  connection = (struct ssh_connection *)x;
#line 1637
  table = connection->table;
#line 1643
  i = (uint32_t )0;
  {
  {
#line 1643
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 1643
    if (! (i < table->used_channels)) {
#line 1643
      goto while_break;
    }
    {
    {
#line 1645
    tmp = lookup_channel(table, i);
    }
#line 1645
    channel = tmp;
    }
#line 1646
    if (channel) {
#line 1646
      if (! (channel->flags & 5)) {
#line 1646
        if (channel->send_adjust) {
          {
          {
#line 1649
          (*(channel->send_adjust))(channel, (uint32_t )0);
          }
          }
        }
      }
    }
#line 1643
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1651
  return;
}
}
#line 1653 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct command_continuation channels_wakeup  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_channels_wakeup};
#line 1657 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
void init_connection_service(struct ssh_connection *connection ) 
{ 
  struct channel_table *table ;
  struct channel_table *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 1660
  tmp = make_channel_table();
  }
#line 1660
  table = tmp;
  {
#line 1662
  debug("channel.c: do_connection_service\n");
  }
#line 1664
  connection->table = table;
  {
#line 1667
  connection_clear_timeout(connection);
  }
  {
#line 1670
  connection_wakeup(connection, & channels_wakeup);
  }
#line 1672
  connection->dispatch[80] = & global_request_handler;
#line 1674
  connection->dispatch[90] = & channel_open_handler;
#line 1676
  connection->dispatch[98] = & channel_request_handler;
#line 1679
  connection->dispatch[93] = & window_adjust_handler;
#line 1681
  connection->dispatch[94] = & channel_data_handler;
#line 1683
  connection->dispatch[95] = & channel_extended_data_handler;
#line 1686
  connection->dispatch[96] = & channel_eof_handler;
#line 1688
  connection->dispatch[97] = & channel_close_handler;
#line 1691
  connection->dispatch[91] = & channel_open_confirm_handler;
#line 1693
  connection->dispatch[92] = & channel_open_failure_handler;
#line 1696
  connection->dispatch[99] = & channel_success_handler;
#line 1698
  connection->dispatch[100] = & channel_failure_handler;
#line 1701
  connection->dispatch[81] = & global_success_handler;
#line 1703
  connection->dispatch[82] = & global_failure_handler;
  }
#line 1705
  return;
}
}
#line 1707
static void do_connection_service_command(struct command *s  __attribute__((__unused__)) ,
                                          struct lsh_object *a , struct command_continuation *c ,
                                          struct exception_handler *e  __attribute__((__unused__)) ) ;
#line 1707 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct command connection_service_command  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & do_connection_service_command};
#line 1707 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_connection_service_command(struct command *s  __attribute__((__unused__)) ,
                                          struct lsh_object *a , struct command_continuation *c ,
                                          struct exception_handler *e  __attribute__((__unused__)) ) 
{ 
  struct ssh_connection *connection ;

  {
  {
#line 1713
  connection = (struct ssh_connection *)a;
  {
#line 1715
  init_connection_service(connection);
  }
  {
#line 1717
  (*(c->c))(c, (struct lsh_object *)connection);
  }
  }
#line 1718
  return;
}
}
#line 1720 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *format_channel_close(struct ssh_channel *channel ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 1723
  tmp = ssh_format("%c%i", 97, channel->channel_number);
  }
  }
#line 1723
  return (tmp);
}
}
#line 1731 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static struct exception  const  finish_exception___2  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )65537, "Closing channel"};
#line 1728 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
void channel_close(struct ssh_channel *channel ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1734
  if (! (channel->flags & 1)) {
    {
    {
#line 1736
    verbose("Sending CLOSE on channel %i\n", channel->channel_number);
    }
#line 1738
    channel->flags |= 1;
    {
#line 1740
    tmp = format_channel_close(channel);
    }
    {
#line 1740
    connection_send(channel->connection, tmp);
    }
    }
#line 1742
    if (channel->flags & 2) {
      {
      {
#line 1743
      (*((channel->e)->raise))(channel->e, & finish_exception___2);
      }
      }
    }
  }
#line 1745
  return;
}
}
#line 1747 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *format_channel_eof(struct ssh_channel *channel ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 1750
  tmp = ssh_format("%c%i", 96, channel->channel_number);
  }
  }
#line 1750
  return (tmp);
}
}
#line 1755 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
void channel_eof(struct ssh_channel *channel ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1758
  if (! (channel->flags & 7)) {
    {
    {
#line 1761
    verbose("Sending EOF on channel %i\n", channel->channel_number);
    }
#line 1763
    channel->flags |= 4;
    {
#line 1764
    tmp = format_channel_eof(channel);
    }
    {
#line 1764
    connection_send(channel->connection, tmp);
    }
    }
#line 1766
    if (channel->flags & 16) {
#line 1766
      if (channel->flags & 40) {
        {
        {
#line 1770
        channel_close(channel);
        }
        }
      }
    }
  }
#line 1773
  return;
}
}
#line 1775 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
void init_channel(struct ssh_channel *channel ) 
{ 


  {
  {
#line 1778
  channel->connection = (struct ssh_connection *)((void *)0);
#line 1780
  channel->super.report = & adjust_rec_window;
#line 1782
  channel->flags = 16;
#line 1783
  channel->sources = 0;
#line 1785
  channel->request_types = (struct alist *)((void *)0);
#line 1786
  channel->request_fallback = (struct channel_request *)((void *)0);
#line 1788
  channel->receive = (void (*)(struct ssh_channel *self , int type , struct lsh_string *data ))((void *)0);
#line 1789
  channel->send_adjust = (void (*)(struct ssh_channel *self , uint32_t increment ))((void *)0);
#line 1791
  channel->close = (void (*)(struct ssh_channel *self ))((void *)0);
#line 1792
  channel->eof = (void (*)(struct ssh_channel *self ))((void *)0);
#line 1794
  channel->open_continuation = (struct command_continuation *)((void *)0);
  {
#line 1796
  channel->resources = make_resource_list();
  }
  {
#line 1798
  lsh_queue_init(& channel->pending_requests.q);
  }
  {
#line 1799
  lsh_queue_init(& channel->active_requests.q);
  }
  }
#line 1800
  return;
}
}
#line 1802 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *channel_transmit_data(struct ssh_channel *channel , struct lsh_string *data ) 
{ 
  uint32_t length ;
  uint32_t tmp ;
  struct lsh_string *tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
  {
#line 1806
  tmp = lsh_string_length((struct lsh_string  const  *)data);
  }
#line 1806
  length = tmp;
  }
#line 1807
  if (! (length <= channel->send_window_size)) {
    {
    {
#line 1807
    __assert_fail("length <= channel->send_window_size", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  1807U, "channel_transmit_data");
    }
    }
  }
#line 1808
  if (! (length <= channel->send_max_packet)) {
    {
    {
#line 1808
    __assert_fail("length <= channel->send_max_packet", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  1808U, "channel_transmit_data");
    }
    }
  }
  {
#line 1809
  channel->send_window_size -= length;
  {
#line 1811
  tmp___0 = ssh_format("%c%i%fS", 94, channel->channel_number, data);
  }
  }
#line 1811
  return (tmp___0);
}
}
#line 1817 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *channel_transmit_extended(struct ssh_channel *channel , uint32_t type ,
                                             struct lsh_string *data ) 
{ 
  uint32_t length ;
  uint32_t tmp ;
  struct lsh_string *tmp___0 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
  {
#line 1822
  tmp = lsh_string_length((struct lsh_string  const  *)data);
  }
#line 1822
  length = tmp;
  }
#line 1823
  if (! (length <= channel->send_window_size)) {
    {
    {
#line 1823
    __assert_fail("length <= channel->send_window_size", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  1823U, "channel_transmit_extended");
    }
    }
  }
#line 1824
  if (! (length <= channel->send_max_packet)) {
    {
    {
#line 1824
    __assert_fail("length <= channel->send_max_packet", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  1824U, "channel_transmit_extended");
    }
    }
  }
  {
#line 1825
  channel->send_window_size -= length;
  {
#line 1827
  tmp___0 = ssh_format("%c%i%i%fS", 95, channel->channel_number, type, data);
  }
  }
#line 1827
  return (tmp___0);
}
}
#line 1869 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_write(struct abstract_write *w , struct lsh_string *packet ) 
{ 
  struct channel_write *closure ;
  struct lsh_string *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1873
  closure = (struct channel_write *)w;
#line 1875
  if (! packet) {
#line 1878
    if (! (closure->channel)->sources) {
      {
      {
#line 1878
      __assert_fail("closure->channel->sources", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                    1878U, "do_channel_write");
      }
      }
    }
#line 1879
    if ((closure->channel)->sources == 1) {
      {
      {
#line 1880
      channel_eof(closure->channel);
      }
      }
    }
  } else {
    {
    {
#line 1883
    tmp = channel_transmit_data(closure->channel, packet);
    }
    {
#line 1883
    connection_send((closure->channel)->connection, tmp);
    }
    }
  }
#line 1885
  return;
}
}
#line 1887 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_write_extended(struct abstract_write *w , struct lsh_string *packet ) 
{ 
  struct channel_write_extended *closure ;
  struct lsh_string *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1891
  closure = (struct channel_write_extended *)w;
#line 1893
  if (! packet) {
#line 1896
    if (! (closure->super.channel)->sources) {
      {
      {
#line 1896
      __assert_fail("closure->super.channel->sources", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                    1896U, "do_channel_write_extended");
      }
      }
    }
#line 1897
    if ((closure->super.channel)->sources == 1) {
      {
      {
#line 1898
      channel_eof(closure->super.channel);
      }
      }
    }
  } else {
    {
    {
#line 1901
    tmp = channel_transmit_extended(closure->super.channel, closure->type, packet);
    }
    {
#line 1901
    connection_send((closure->super.channel)->connection, tmp);
    }
    }
  }
#line 1905
  return;
}
}
#line 1907 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct abstract_write *make_channel_write(struct ssh_channel *channel ) 
{ 
  struct channel_write *closure ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 1910
  tmp = lsh_object_alloc(& channel_write_class);
  }
#line 1910
  closure = (struct channel_write *)tmp;
#line 1912
  closure->super.write = & do_channel_write;
#line 1913
  closure->channel = channel;
  }
#line 1915
  return (& closure->super);
}
}
#line 1918 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct abstract_write *make_channel_write_extended(struct ssh_channel *channel , uint32_t type ) 
{ 
  struct channel_write_extended *closure ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 1922
  tmp = lsh_object_alloc(& channel_write_extended_class);
  }
#line 1922
  closure = (struct channel_write_extended *)tmp;
#line 1924
  closure->super.super.write = & do_channel_write_extended;
#line 1925
  closure->super.channel = channel;
#line 1926
  closure->type = type;
  }
#line 1928
  return (& closure->super.super);
}
}
#line 1931 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct io_callback *make_channel_read_data(struct ssh_channel *channel ) 
{ 
  struct abstract_write *tmp ;
  struct io_callback *tmp___0 ;

  {
  {
  {
#line 1940
  tmp = make_channel_write(channel);
  }
  {
#line 1940
  tmp___0 = make_read_data(channel, tmp);
  }
  }
#line 1940
  return (tmp___0);
}
}
#line 1943 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct io_callback *make_channel_read_stderr(struct ssh_channel *channel ) 
{ 
  struct abstract_write *tmp ;
  struct io_callback *tmp___0 ;

  {
  {
  {
#line 1953
  tmp = make_channel_write_extended(channel, (uint32_t )1);
  }
  {
#line 1953
  tmp___0 = make_read_data(channel, tmp);
  }
  }
#line 1953
  return (tmp___0);
}
}
#line 1974 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void channel_read_close_callback(struct lsh_callback *c ) 
{ 
  struct channel_close_callback *closure ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1977
  closure = (struct channel_close_callback *)c;
  {
#line 1979
  trace("channel_read_close_callback: File closed.\n");
  }
  }
#line 1981
  if (! (closure->channel)->sources) {
    {
    {
#line 1981
    __assert_fail("closure->channel->sources", "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c",
                  1981U, "channel_read_close_callback");
    }
    }
  }
#line 1983
  ((closure->channel)->sources) --;
#line 1984
  if (! (closure->channel)->sources) {
    {
    {
#line 1987
    channel_eof(closure->channel);
    }
    }
  }
#line 1989
  return;
}
}
#line 1991 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_callback *make_channel_read_close_callback(struct ssh_channel *channel ) 
{ 
  struct channel_close_callback *closure ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 1994
  tmp = lsh_object_alloc(& channel_close_callback_class);
  }
#line 1994
  closure = (struct channel_close_callback *)tmp;
#line 1996
  closure->super.f = & channel_read_close_callback;
#line 1997
  closure->channel = channel;
  }
#line 1999
  return (& closure->super);
}
}
#line 2023 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
static void do_channel_io_exception_handler(struct exception_handler *s , struct exception  const  *x ) 
{ 
  struct channel_io_exception_handler *self ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 2027
  self = (struct channel_io_exception_handler *)s;
#line 2028
  if (x->type & 8192U) {
#line 2030
    if (! self->silent) {
      {
      {
#line 2031
      werror("channel.c: %zI/O error, %z\n", self->prefix, x->msg);
      }
      }
    }
    {
    {
#line 2038
    channel_close(self->channel);
    }
    }
  } else {
    {
    {
#line 2041
    (*((s->parent)->raise))(s->parent, x);
    }
    }
  }
#line 2042
  return;
}
}
#line 2044 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct exception_handler *make_channel_io_exception_handler(struct ssh_channel *channel ,
                                                            char const   *prefix___0 ,
                                                            int silent , struct exception_handler *parent ,
                                                            char const   *context ) 
{ 
  struct channel_io_exception_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 2051
  tmp = lsh_object_alloc(& channel_io_exception_handler_class);
  }
#line 2051
  self = (struct channel_io_exception_handler *)tmp;
#line 2052
  self->super.raise = & do_channel_io_exception_handler;
#line 2053
  self->super.parent = parent;
#line 2054
  self->super.context = context;
#line 2056
  self->channel = channel;
#line 2057
  self->prefix = prefix___0;
#line 2058
  self->silent = silent;
  }
#line 2059
  return (& self->super);
}
}
#line 2063 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *format_channel_open_s(struct lsh_string *type , uint32_t local_channel_number ,
                                         struct ssh_channel *channel , struct lsh_string *args ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 2069
  check_rec_max_packet(channel);
  }
  {
#line 2071
  tmp = ssh_format("%c%S%i%i%i%lS", 90, type, local_channel_number, channel->rec_window_size,
                   channel->rec_max_packet, args);
  }
  }
#line 2071
  return (tmp);
}
}
#line 2077 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *format_channel_open(int type , uint32_t local_channel_number ,
                                       struct ssh_channel *channel , char const   *format 
                                       , ...) 
{ 
  va_list args ;
  uint32_t l1 ;
  uint32_t l2 ;
  struct lsh_string *packet ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 2090
  check_rec_max_packet(channel);
  }
  {
#line 2092
  debug("format_channel_open: rec_window_size = %i,\n                     rec_max_packet = %i,\n",
        channel->rec_window_size, channel->rec_max_packet);
  }
  {
#line 2097
  l1 = ssh_format_length("%c%a%i%i%i", 90, type, local_channel_number, channel->rec_window_size,
                         channel->rec_max_packet);
  }
  {
#line 2099
  __builtin_va_start(args, format);
  }
  {
#line 2100
  l2 = ssh_vformat_length(format, args);
  }
  {
#line 2101
  __builtin_va_end(args);
  }
  {
#line 2103
  packet = lsh_string_alloc(l1 + l2);
  }
  {
#line 2105
  ssh_format_write("%c%a%i%i%i", packet, (uint32_t )0, 90, type, local_channel_number,
                   channel->rec_window_size, channel->rec_max_packet);
  }
  {
#line 2107
  __builtin_va_start(args, format);
  }
  {
#line 2108
  ssh_vformat_write(format, packet, l1, args);
  }
  {
#line 2109
  __builtin_va_end(args);
  }
  }
#line 2111
  return (packet);
}
}
#line 2116 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *format_channel_request_i(struct channel_request_info *info , struct ssh_channel *channel ,
                                            uint32_t args_length , uint8_t const   *args_data ) 
{ 
  struct lsh_string *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 2121
  tmp = ssh_format("%c%i%s%c%ls", 98, channel->channel_number, info->type_length,
                   info->type_data, info->want_reply, args_length, args_data);
  }
  }
#line 2121
  return (tmp);
}
}
#line 2128 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *format_channel_request(int type , struct ssh_channel *channel ,
                                          int want_reply , char const   *format  , ...) 
{ 
  va_list args ;
  uint32_t l1 ;
  uint32_t l2 ;
  struct lsh_string *packet ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 2141
  l1 = ssh_format_length("%c%i%a%c", 98, channel->channel_number, type, want_reply);
  }
  {
#line 2143
  __builtin_va_start(args, format);
  }
  {
#line 2144
  l2 = ssh_vformat_length(format, args);
  }
  {
#line 2145
  __builtin_va_end(args);
  }
  {
#line 2147
  packet = lsh_string_alloc(l1 + l2);
  }
  {
#line 2149
  ssh_format_write("%c%i%a%c", packet, (uint32_t )0, 98, channel->channel_number,
                   type, want_reply);
  }
  {
#line 2151
  __builtin_va_start(args, format);
  }
  {
#line 2152
  ssh_vformat_write(format, packet, l1, args);
  }
  {
#line 2153
  __builtin_va_end(args);
  }
  }
#line 2155
  return (packet);
}
}
#line 2160 "/home/ysko/Works/test-src/lsh-2.0.4/src/channel.c"
struct lsh_string *format_global_request(int type , int want_reply , char const   *format 
                                         , ...) 
{ 
  va_list args ;
  uint32_t l1 ;
  uint32_t l2 ;
  struct lsh_string *packet ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 2171
  l1 = ssh_format_length("%c%a%c", 80, type, want_reply);
  }
  {
#line 2173
  __builtin_va_start(args, format);
  }
  {
#line 2174
  l2 = ssh_vformat_length(format, args);
  }
  {
#line 2175
  __builtin_va_end(args);
  }
  {
#line 2177
  packet = lsh_string_alloc(l1 + l2);
  }
  {
#line 2179
  ssh_format_write("%c%a%c", packet, (uint32_t )0, 80, type, want_reply);
  }
  {
#line 2181
  __builtin_va_start(args, format);
  }
  {
#line 2182
  ssh_vformat_write(format, packet, l1, args);
  }
  {
#line 2183
  __builtin_va_end(args);
  }
  }
#line 2185
  return (packet);
}
}
#line 39 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms.c"
__inline struct atom_assoc  const  *gperf_atom(char const   *str , unsigned int len ) ;
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms_gperf.c"
__inline static unsigned int hash___1(char const   *str , unsigned int len ) ;
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms_gperf.c"
static unsigned short const   asso_values___0[256]  = 
#line 55
  {      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )5,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )0,      (unsigned short const   )100,      (unsigned short const   )10,      (unsigned short const   )10, 
        (unsigned short const   )348,      (unsigned short const   )0,      (unsigned short const   )60,      (unsigned short const   )348, 
        (unsigned short const   )35,      (unsigned short const   )15,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )10,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )15,      (unsigned short const   )0,      (unsigned short const   )5, 
        (unsigned short const   )5,      (unsigned short const   )0,      (unsigned short const   )348,      (unsigned short const   )0, 
        (unsigned short const   )5,      (unsigned short const   )5,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )20,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )20,      (unsigned short const   )0,      (unsigned short const   )348, 
        (unsigned short const   )0,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )15,      (unsigned short const   )25,      (unsigned short const   )0, 
        (unsigned short const   )30,      (unsigned short const   )80,      (unsigned short const   )5,      (unsigned short const   )55, 
        (unsigned short const   )80,      (unsigned short const   )0,      (unsigned short const   )348,      (unsigned short const   )0, 
        (unsigned short const   )5,      (unsigned short const   )5,      (unsigned short const   )10,      (unsigned short const   )0, 
        (unsigned short const   )35,      (unsigned short const   )90,      (unsigned short const   )5,      (unsigned short const   )20, 
        (unsigned short const   )0,      (unsigned short const   )5,      (unsigned short const   )15,      (unsigned short const   )5, 
        (unsigned short const   )60,      (unsigned short const   )50,      (unsigned short const   )120,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348, 
        (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348,      (unsigned short const   )348};
#line 46 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms_gperf.c"
__inline static unsigned int hash___1(char const   *str , unsigned int len ) 
{ 
  register int hval ;

  {
#line 84
  hval = (int )len;
#line 101
  if (hval == 10) {
#line 101
    goto case_10;
  }
#line 101
  if (hval == 11) {
#line 101
    goto case_10;
  }
#line 101
  if (hval == 12) {
#line 101
    goto case_10;
  }
#line 101
  if (hval == 13) {
#line 101
    goto case_10;
  }
#line 101
  if (hval == 14) {
#line 101
    goto case_10;
  }
#line 101
  if (hval == 15) {
#line 101
    goto case_10;
  }
#line 101
  if (hval == 16) {
#line 101
    goto case_10;
  }
#line 101
  if (hval == 17) {
#line 101
    goto case_10;
  }
#line 101
  if (hval == 18) {
#line 101
    goto case_10;
  }
#line 101
  if (hval == 19) {
#line 101
    goto case_10;
  }
#line 101
  if (hval == 20) {
#line 101
    goto case_10;
  }
#line 107
  if (hval == 6) {
#line 107
    goto case_6;
  }
#line 107
  if (hval == 7) {
#line 107
    goto case_6;
  }
#line 107
  if (hval == 8) {
#line 107
    goto case_6;
  }
#line 107
  if (hval == 9) {
#line 107
    goto case_6;
  }
#line 112
  if (hval == 3) {
#line 112
    goto case_3;
  }
#line 112
  if (hval == 4) {
#line 112
    goto case_3;
  }
#line 112
  if (hval == 5) {
#line 112
    goto case_3;
  }
#line 116
  if (hval == 1) {
#line 116
    goto case_1;
  }
#line 116
  if (hval == 2) {
#line 116
    goto case_1;
  }
#line 88
  goto switch_default;
  switch_default: 
#line 89
  hval += (int )asso_values___0[(unsigned char )*(str + 20)];
  case_10: 
#line 102
  hval += (int )asso_values___0[(unsigned char )*(str + 9)];
  case_6: 
#line 108
  hval += (int )asso_values___0[(unsigned char )*(str + 5)];
  case_3: 
#line 113
  hval += (int )asso_values___0[(unsigned char )*(str + 2)];
  case_1: 
#line 117
  hval += (int )asso_values___0[(unsigned char )*(str + 0)];
#line 118
  goto switch_break;
  switch_break: ;
#line 120
  return ((unsigned int )(hval + (int )asso_values___0[(unsigned char )*(str + (len - 1U))]));
}
}
#line 129 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms_gperf.c"
static unsigned char const   lengthtable___0[348]  = 
#line 129
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )8,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )7,      (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )4, 
        (unsigned char const   )10,      (unsigned char const   )1,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )14,      (unsigned char const   )0,      (unsigned char const   )11,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )14,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )10, 
        (unsigned char const   )11,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )14,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )13,      (unsigned char const   )9, 
        (unsigned char const   )10,      (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )8, 
        (unsigned char const   )14,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )10,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )8,      (unsigned char const   )14,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )8,      (unsigned char const   )14, 
        (unsigned char const   )20,      (unsigned char const   )1,      (unsigned char const   )12,      (unsigned char const   )8, 
        (unsigned char const   )4,      (unsigned char const   )10,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )14,      (unsigned char const   )5,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )14,      (unsigned char const   )10, 
        (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )9, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )14,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )13,      (unsigned char const   )9,      (unsigned char const   )0,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )14,      (unsigned char const   )0, 
        (unsigned char const   )11,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )7,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )9,      (unsigned char const   )15, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )20,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )29,      (unsigned char const   )10,      (unsigned char const   )26, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )11,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )11,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )29,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )9,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )9,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )7,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )26,      (unsigned char const   )27};
#line 157 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms_gperf.c"
static struct atom_assoc  const  wordlist___0[348]  = 
#line 157
  {      {"", 0}, 
        {"c", 103}, 
        {"", 0}, 
        {"INT", 76}, 
        {"QUIT", 79}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"HUP", 74}, 
        {"SEGV", 80}, 
        {"", 0}, 
        {"r", 93}, 
        {"", 0}, 
        {"ILL", 75}, 
        {"KILL", 77}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"Xpkcs5v2", 104}, 
        {"PIPE", 78}, 
        {"", 0}, 
        {"n", 98}, 
        {"", 0}, 
        {"", 0}, 
        {"spki", 44}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"TERM", 81}, 
        {"", 0}, 
        {"a", 101}, 
        {"arcfour", 26}, 
        {"FPE", 73}, 
        {"ABRT", 71}, 
        {"", 0}, 
        {"", 0}, 
        {"blowfish-cbc", 5}, 
        {"rsa-pkcs1-md5", 97}, 
        {"ALRM", 72}, 
        {"auth-agent", 57}, 
        {"s", 94}, 
        {"blowfish-ctr", 6}, 
        {"", 0}, 
        {"twofish192-cbc", 10}, 
        {"", 0}, 
        {"cast128-ctr", 28}, 
        {"", 0}, 
        {"", 0}, 
        {"twofish192-ctr", 12}, 
        {"", 0}, 
        {"b", 102}, 
        {"", 0}, 
        {"", 0}, 
        {"USR2", 83}, 
        {"aes192-cbc", 15}, 
        {"twofish-cbc", 8}, 
        {"session", 52}, 
        {"", 0}, 
        {"serpent192-cbc", 21}, 
        {"", 0}, 
        {"d", 100}, 
        {"", 0}, 
        {"dsa", 87}, 
        {"serpent192-ctr", 24}, 
        {"aes192-ctr", 18}, 
        {"cast128-cbc", 27}, 
        {"", 0}, 
        {"", 0}, 
        {"twofish128-cbc", 9}, 
        {"forwarded-tcpip", 69}, 
        {"p", 88}, 
        {"", 0}, 
        {"spki-sign-rsa", 40}, 
        {"twofish128-ctr", 11}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"spki-sign-dss", 41}, 
        {"subsystem", 61}, 
        {"aes128-cbc", 16}, 
        {"gssapi", 51}, 
        {"", 0}, 
        {"xon-xoff", 63}, 
        {"serpent128-cbc", 22}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"tcpip-forward", 67}, 
        {"serpent128-ctr", 23}, 
        {"aes128-ctr", 17}, 
        {"signal", 64}, 
        {"", 0}, 
        {"password", 48}, 
        {"twofish256-cbc", 7}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"3des-cbc", 3}, 
        {"twofish256-ctr", 13}, 
        {"cancel-tcpip-forward", 68}, 
        {"y", 91}, 
        {"pgp-sign-rsa", 42}, 
        {"3des-ctr", 4}, 
        {"none", 1}, 
        {"aes256-cbc", 14}, 
        {"", 0}, 
        {"", 0}, 
        {"hmac-md5", 32}, 
        {"serpent256-cbc", 20}, 
        {"shell", 59}, 
        {"g", 90}, 
        {"", 0}, 
        {"env", 58}, 
        {"serpent256-ctr", 25}, 
        {"aes256-ctr", 19}, 
        {"", 0}, 
        {"direct-tcpip", 70}, 
        {"", 0}, 
        {"publickey", 47}, 
        {"", 0}, 
        {"x", 92}, 
        {"", 0}, 
        {"", 0}, 
        {"ssh-connection", 46}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"window-change", 62}, 
        {"rsa-pkcs1", 95}, 
        {"", 0}, 
        {"exit-signal", 66}, 
        {"pgp-sign-dss", 43}, 
        {"", 0}, 
        {"auth-agent-req", 56}, 
        {"", 0}, 
        {"exit-status", 65}, 
        {"", 0}, 
        {"", 0}, 
        {"rsa-pkcs1-sha1", 96}, 
        {"", 0}, 
        {"", 0}, 
        {"ssh-rsa", 37}, 
        {"", 0}, 
        {"USR1", 82}, 
        {"", 0}, 
        {"", 0}, 
        {"ssh-dss", 36}, 
        {"", 0}, 
        {"zlib", 2}, 
        {"", 0}, 
        {"", 0}, 
        {"srp-verifier", 106}, 
        {"", 0}, 
        {"hostbased", 49}, 
        {"x509v3-sign-rsa", 38}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"x509v3-sign-dss", 39}, 
        {"e", 99}, 
        {"", 0}, 
        {"", 0}, 
        {"exec", 60}, 
        {"keyboard-interactive", 50}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"srp-ring1-sha1@lysator.liu.se", 105}, 
        {"public-key", 86}, 
        {"serpent-cbc@lysator.liu.se", 29}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"private-key", 85}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"q", 89}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"hmac-md5-96", 33}, 
        {"", 0}, 
        {"", 0}, 
        {"signal-unknown@lysator.liu.se", 84}, 
        {"", 0}, 
        {"", 0}, 
        {"hmac-sha1-96", 31}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"ssh-ring1", 107}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"ssh-userauth", 45}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"hmac-sha1", 30}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"pty-req", 53}, 
        {"x11", 55}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"x11-req", 54}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"", 0}, 
        {"diffie-hellman-group1-sha1", 34}, 
        {"diffie-hellman-group14-sha1", 35}};
#line 124 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms_gperf.c"
__inline struct atom_assoc  const  *gperf_atom(char const   *str , unsigned int len ) 
{ 
  register int key ;
  unsigned int tmp ;
  register char const   *s ;
  int tmp___0 ;

  {
#line 338
  if (len <= 29U) {
#line 338
    if (len >= 1U) {
      {
      {
#line 340
      tmp = hash___1(str, len);
      }
#line 340
      key = (int )tmp;
      }
#line 342
      if (key <= 347) {
#line 342
        if (key >= 0) {
#line 343
          if (len == (unsigned int )lengthtable___0[key]) {
#line 345
            s = (char const   *)wordlist___0[key].name;
#line 347
            if ((int const   )*str == (int const   )*s) {
              {
              {
#line 347
              tmp___0 = memcmp((void const   *)(str + 1), (void const   *)(s + 1),
                               len - 1U);
              }
              }
#line 347
              if (! tmp___0) {
#line 348
                return (& wordlist___0[key]);
              }
            }
          }
        }
      }
    }
  }
#line 351
  return ((struct atom_assoc  const  *)0);
}
}
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms.c"
struct atom_rassoc atom_table[108]  = 
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms.c"
  {      {(uint8_t const   *)"UNKNOWN", (uint32_t )7}, 
        {(uint8_t const   *)"none", (uint32_t )4}, 
        {(uint8_t const   *)"zlib", (uint32_t )4}, 
        {(uint8_t const   *)"3des-cbc", (uint32_t )8}, 
        {(uint8_t const   *)"3des-ctr", (uint32_t )8}, 
        {(uint8_t const   *)"blowfish-cbc", (uint32_t )12}, 
        {(uint8_t const   *)"blowfish-ctr", (uint32_t )12}, 
        {(uint8_t const   *)"twofish256-cbc", (uint32_t )14}, 
        {(uint8_t const   *)"twofish-cbc", (uint32_t )11}, 
        {(uint8_t const   *)"twofish128-cbc", (uint32_t )14}, 
        {(uint8_t const   *)"twofish192-cbc", (uint32_t )14}, 
        {(uint8_t const   *)"twofish128-ctr", (uint32_t )14}, 
        {(uint8_t const   *)"twofish192-ctr", (uint32_t )14}, 
        {(uint8_t const   *)"twofish256-ctr", (uint32_t )14}, 
        {(uint8_t const   *)"aes256-cbc", (uint32_t )10}, 
        {(uint8_t const   *)"aes192-cbc", (uint32_t )10}, 
        {(uint8_t const   *)"aes128-cbc", (uint32_t )10}, 
        {(uint8_t const   *)"aes128-ctr", (uint32_t )10}, 
        {(uint8_t const   *)"aes192-ctr", (uint32_t )10}, 
        {(uint8_t const   *)"aes256-ctr", (uint32_t )10}, 
        {(uint8_t const   *)"serpent256-cbc", (uint32_t )14}, 
        {(uint8_t const   *)"serpent192-cbc", (uint32_t )14}, 
        {(uint8_t const   *)"serpent128-cbc", (uint32_t )14}, 
        {(uint8_t const   *)"serpent128-ctr", (uint32_t )14}, 
        {(uint8_t const   *)"serpent192-ctr", (uint32_t )14}, 
        {(uint8_t const   *)"serpent256-ctr", (uint32_t )14}, 
        {(uint8_t const   *)"arcfour", (uint32_t )7}, 
        {(uint8_t const   *)"cast128-cbc", (uint32_t )11}, 
        {(uint8_t const   *)"cast128-ctr", (uint32_t )11}, 
        {(uint8_t const   *)"serpent-cbc@lysator.liu.se", (uint32_t )26}, 
        {(uint8_t const   *)"hmac-sha1", (uint32_t )9}, 
        {(uint8_t const   *)"hmac-sha1-96", (uint32_t )12}, 
        {(uint8_t const   *)"hmac-md5", (uint32_t )8}, 
        {(uint8_t const   *)"hmac-md5-96", (uint32_t )11}, 
        {(uint8_t const   *)"diffie-hellman-group1-sha1", (uint32_t )26}, 
        {(uint8_t const   *)"diffie-hellman-group14-sha1", (uint32_t )27}, 
        {(uint8_t const   *)"ssh-dss", (uint32_t )7}, 
        {(uint8_t const   *)"ssh-rsa", (uint32_t )7}, 
        {(uint8_t const   *)"x509v3-sign-rsa", (uint32_t )15}, 
        {(uint8_t const   *)"x509v3-sign-dss", (uint32_t )15}, 
        {(uint8_t const   *)"spki-sign-rsa", (uint32_t )13}, 
        {(uint8_t const   *)"spki-sign-dss", (uint32_t )13}, 
        {(uint8_t const   *)"pgp-sign-rsa", (uint32_t )12}, 
        {(uint8_t const   *)"pgp-sign-dss", (uint32_t )12}, 
        {(uint8_t const   *)"spki", (uint32_t )4}, 
        {(uint8_t const   *)"ssh-userauth", (uint32_t )12}, 
        {(uint8_t const   *)"ssh-connection", (uint32_t )14}, 
        {(uint8_t const   *)"publickey", (uint32_t )9}, 
        {(uint8_t const   *)"password", (uint32_t )8}, 
        {(uint8_t const   *)"hostbased", (uint32_t )9}, 
        {(uint8_t const   *)"keyboard-interactive", (uint32_t )20}, 
        {(uint8_t const   *)"gssapi", (uint32_t )6}, 
        {(uint8_t const   *)"session", (uint32_t )7}, 
        {(uint8_t const   *)"pty-req", (uint32_t )7}, 
        {(uint8_t const   *)"x11-req", (uint32_t )7}, 
        {(uint8_t const   *)"x11", (uint32_t )3}, 
        {(uint8_t const   *)"auth-agent-req", (uint32_t )14}, 
        {(uint8_t const   *)"auth-agent", (uint32_t )10}, 
        {(uint8_t const   *)"env", (uint32_t )3}, 
        {(uint8_t const   *)"shell", (uint32_t )5}, 
        {(uint8_t const   *)"exec", (uint32_t )4}, 
        {(uint8_t const   *)"subsystem", (uint32_t )9}, 
        {(uint8_t const   *)"window-change", (uint32_t )13}, 
        {(uint8_t const   *)"xon-xoff", (uint32_t )8}, 
        {(uint8_t const   *)"signal", (uint32_t )6}, 
        {(uint8_t const   *)"exit-status", (uint32_t )11}, 
        {(uint8_t const   *)"exit-signal", (uint32_t )11}, 
        {(uint8_t const   *)"tcpip-forward", (uint32_t )13}, 
        {(uint8_t const   *)"cancel-tcpip-forward", (uint32_t )20}, 
        {(uint8_t const   *)"forwarded-tcpip", (uint32_t )15}, 
        {(uint8_t const   *)"direct-tcpip", (uint32_t )12}, 
        {(uint8_t const   *)"ABRT", (uint32_t )4}, 
        {(uint8_t const   *)"ALRM", (uint32_t )4}, 
        {(uint8_t const   *)"FPE", (uint32_t )3}, 
        {(uint8_t const   *)"HUP", (uint32_t )3}, 
        {(uint8_t const   *)"ILL", (uint32_t )3}, 
        {(uint8_t const   *)"INT", (uint32_t )3}, 
        {(uint8_t const   *)"KILL", (uint32_t )4}, 
        {(uint8_t const   *)"PIPE", (uint32_t )4}, 
        {(uint8_t const   *)"QUIT", (uint32_t )4}, 
        {(uint8_t const   *)"SEGV", (uint32_t )4}, 
        {(uint8_t const   *)"TERM", (uint32_t )4}, 
        {(uint8_t const   *)"USR1", (uint32_t )4}, 
        {(uint8_t const   *)"USR2", (uint32_t )4}, 
        {(uint8_t const   *)"signal-unknown@lysator.liu.se", (uint32_t )29}, 
        {(uint8_t const   *)"private-key", (uint32_t )11}, 
        {(uint8_t const   *)"public-key", (uint32_t )10}, 
        {(uint8_t const   *)"dsa", (uint32_t )3}, 
        {(uint8_t const   *)"p", (uint32_t )1}, 
        {(uint8_t const   *)"q", (uint32_t )1}, 
        {(uint8_t const   *)"g", (uint32_t )1}, 
        {(uint8_t const   *)"y", (uint32_t )1}, 
        {(uint8_t const   *)"x", (uint32_t )1}, 
        {(uint8_t const   *)"r", (uint32_t )1}, 
        {(uint8_t const   *)"s", (uint32_t )1}, 
        {(uint8_t const   *)"rsa-pkcs1", (uint32_t )9}, 
        {(uint8_t const   *)"rsa-pkcs1-sha1", (uint32_t )14}, 
        {(uint8_t const   *)"rsa-pkcs1-md5", (uint32_t )13}, 
        {(uint8_t const   *)"n", (uint32_t )1}, 
        {(uint8_t const   *)"e", (uint32_t )1}, 
        {(uint8_t const   *)"d", (uint32_t )1}, 
        {(uint8_t const   *)"a", (uint32_t )1}, 
        {(uint8_t const   *)"b", (uint32_t )1}, 
        {(uint8_t const   *)"c", (uint32_t )1}, 
        {(uint8_t const   *)"Xpkcs5v2", (uint32_t )8}, 
        {(uint8_t const   *)"srp-ring1-sha1@lysator.liu.se", (uint32_t )29}, 
        {(uint8_t const   *)"srp-verifier", (uint32_t )12}, 
        {(uint8_t const   *)"ssh-ring1", (uint32_t )9}};
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms.c"
uint32_t get_atom_length(int atom ) 
{ 


  {
#line 49
  return (atom_table[atom].length);
}
}
#line 51 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms.c"
uint8_t const   *get_atom_name(int atom ) 
{ 


  {
#line 52
  return (atom_table[atom].name);
}
}
#line 54 "/home/ysko/Works/test-src/lsh-2.0.4/src/atoms.c"
int lookup_atom(uint32_t length , uint8_t const   *name ) 
{ 
  struct atom_assoc  const  *pair ;
  struct atom_assoc  const  *tmp ;
  int tmp___0 ;

  {
  {
  {
#line 60
  tmp = gperf_atom((char const   *)name, length);
  }
#line 60
  pair = tmp;
  }
#line 62
  if (pair) {
#line 62
    tmp___0 = (int )pair->id;
  } else {
#line 62
    tmp___0 = (int )((int const   )0);
  }
#line 62
  return (tmp___0);
}
}
#line 18 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.h.x"
struct alist_meta alist_class_extended ;
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.h"
struct alist *alist_addv(struct alist *a , unsigned int n , va_list args ) ;
#line 79
unsigned int alist_select(struct alist *dst , struct alist *src , struct int_list *names___3 ) ;
#line 83
unsigned int alist_select_l(struct alist *dst , struct alist *src , unsigned int n 
                            , ...) ;
#line 23 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.h.x"
struct alist_meta alist_class_extended  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, (struct lsh_class *)((void *)0), (char *)"alist", (size_t )sizeof(struct alist ),
     (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
     (void (*)(struct lsh_object *instance ))((void *)0)}, (struct lsh_object *(*)(struct alist *self ,
                                                                                   int atom ))((void *)0),
    (void (*)(struct alist *self , int atom , struct lsh_object *value ))((void *)0)};
#line 43 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c"
struct alist *alist_addv(struct alist *a , unsigned int n , va_list args ) 
{ 
  unsigned int i ;
  int atom ;
  int tmp___0 ;
  struct lsh_object *value ;
  struct lsh_object *tmp___2 ;
  int tmp___4 ;
  int tmp ;
  struct lsh_object *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 48
  i = 0U;
  {
  {
#line 48
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 48
    if (! (i < n)) {
#line 48
      goto while_break;
    }
    {
    {
#line 50
    tmp = __builtin_va_arg(args, int );
    }
#line 50
    tmp___0 = tmp;
#line 50
    atom = tmp___0;
    {
#line 51
    tmp___5 = __builtin_va_arg(args, struct lsh_object *);
    }
#line 51
    tmp___2 = tmp___5;
#line 51
    value = tmp___2;
    }
#line 53
    if (atom < 0) {
      {
      {
#line 54
      fatal("Internal error!\n");
      }
      }
    }
    {
    {
#line 55
    (*(((struct alist_meta *)a->super.isa)->set))(a, atom, value);
    }
#line 48
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 58
  tmp___6 = __builtin_va_arg(args, int );
  }
#line 58
  tmp___4 = tmp___6;
  }
#line 58
  if (! (tmp___4 == -1)) {
    {
    {
#line 58
    __assert_fail("__builtin_va_arg(args,int) == -1", "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c",
                  58U, "alist_addv");
    }
    }
  }
#line 60
  return (a);
}
}
#line 72
static struct lsh_object *do_linear_get(struct alist *c , int atom ) ;
#line 74
static void do_linear_set(struct alist *c , int atom , struct lsh_object *value ) ;
#line 77
static void do_mark_list(struct alist_node *n , void (*mark)(struct lsh_object *o ) ) ;
#line 80
static void do_free_list(struct alist_node *n ) ;
#line 83
static struct lsh_object *do_linked_get(struct alist *c , int atom ) ;
#line 85
static void do_linked_set(struct alist *c , int atom , struct lsh_object *value ) ;
#line 10 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c.x"
struct alist_meta alist_linear_class_extended ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c.x"
static void do_alist_linear_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct alist_linear *i ;
  unsigned int k1 ;

  {
#line 19
  i = (struct alist_linear *)o;
#line 22
  k1 = 0U;
  {
  {
#line 22
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 22
    if (! (k1 < 108U)) {
#line 22
      goto while_break;
    }
    {
    {
#line 23
    (*mark)(i->table[k1]);
    }
#line 22
    k1 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 25
  return;
}
}
#line 26 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c.x"
struct alist_meta alist_linear_class_extended  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & alist_class_extended.super, (char *)"alist_linear", (size_t )sizeof(struct alist_linear ),
     & do_alist_linear_mark, (void (*)(struct lsh_object *instance ))((void *)0)},
    & do_linear_get, & do_linear_set};
#line 50
struct alist_meta alist_linked_class_extended ;
#line 55 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c.x"
static void do_alist_linked_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct alist_linked *i ;

  {
  {
#line 59
  i = (struct alist_linked *)o;
  {
#line 60
  do_mark_list(i->head, mark);
  }
  }
#line 62
  return;
}
}
#line 63 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c.x"
static void do_alist_linked_free(struct lsh_object *o ) 
{ 
  struct alist_linked *i ;

  {
  {
#line 66
  i = (struct alist_linked *)o;
  {
#line 67
  do_free_list(i->head);
  }
  }
#line 68
  return;
}
}
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c.x"
struct alist_meta alist_linked_class_extended  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & alist_class_extended.super, (char *)"alist_linked", (size_t )sizeof(struct alist_linked ),
     & do_alist_linked_mark, & do_alist_linked_free}, & do_linked_get, & do_linked_set};
#line 103 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c"
static struct lsh_object *do_linear_get(struct alist *c , int atom ) 
{ 
  struct alist_linear *self ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 106
  self = (struct alist_linear *)c;
#line 108
  if (! (atom >= 0)) {
    {
    {
#line 108
    __assert_fail("atom >= 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c",
                  108U, "do_linear_get");
    }
    }
  }
#line 109
  if (! (atom < 108)) {
    {
    {
#line 109
    __assert_fail("atom < 108", "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c",
                  109U, "do_linear_get");
    }
    }
  }
#line 111
  return (self->table[atom]);
}
}
#line 114 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c"
static void do_linear_set(struct alist *c , int atom , struct lsh_object *value ) 
{ 
  struct alist_linear *self ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 117
  self = (struct alist_linear *)c;
#line 119
  if (! (atom >= 0)) {
    {
    {
#line 119
    __assert_fail("atom >= 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c",
                  119U, "do_linear_set");
    }
    }
  }
#line 120
  if (! (atom < 108)) {
    {
    {
#line 120
    __assert_fail("atom < 108", "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c",
                  120U, "do_linear_set");
    }
    }
  }
#line 122
  self->super.size += (unsigned int )(! self->table[atom] - ! value);
#line 124
  self->table[atom] = value;
#line 125
  return;
}
}
#line 127 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c"
struct alist *make_linear_alist(unsigned int n  , ...) 
{ 
  int i ;
  va_list args ;
  struct alist_linear *res ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 133
  tmp = lsh_object_alloc(& alist_linear_class_extended.super);
  }
#line 133
  res = (struct alist_linear *)tmp;
#line 135
  res->super.size = 0U;
#line 137
  i = 0;
  }
  {
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 137
    if (! (i < 108)) {
#line 137
      goto while_break;
    }
#line 138
    res->table[i] = (struct lsh_object *)((void *)0);
#line 137
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 140
  __builtin_va_start(args, n);
  }
  {
#line 142
  alist_addv(& res->super, n, args);
  }
  {
#line 143
  __builtin_va_end(args);
  }
  }
#line 145
  return (& res->super);
}
}
#line 161 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c"
static void do_mark_list(struct alist_node *n , void (*mark)(struct lsh_object *o ) ) 
{ 


  {
  {
  {
#line 165
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 165
    if (! n) {
#line 165
      goto while_break;
    }
    {
    {
#line 167
    (*mark)(n->value);
    }
#line 168
    n = n->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 170
  return;
}
}
#line 172 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c"
static void do_free_list(struct alist_node *n ) 
{ 
  struct alist_node *old ;

  {
  {
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 175
    if (! n) {
#line 175
      goto while_break;
    }
    {
#line 177
    old = n;
#line 178
    n = n->next;
    {
#line 179
    lsh_space_free((void const   *)old);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 181
  return;
}
}
#line 183 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c"
static struct lsh_object *do_linked_get(struct alist *c , int atom ) 
{ 
  struct alist_linked *self ;
  struct alist_node *p ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 186
  self = (struct alist_linked *)c;
#line 189
  if (! (atom >= 0)) {
    {
    {
#line 189
    __assert_fail("atom >= 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c",
                  189U, "do_linked_get");
    }
    }
  }
#line 191
  p = self->head;
  {
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 191
    if (! p) {
#line 191
      goto while_break;
    }
#line 192
    if (p->atom == atom) {
#line 193
      return (p->value);
    }
#line 191
    p = p->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 195
  return ((struct lsh_object *)((void *)0));
}
}
#line 198 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c"
static void do_linked_set(struct alist *c , int atom , struct lsh_object *value ) 
{ 
  struct alist_linked *self ;
  struct alist_node *p ;
  void *tmp ;
  struct alist_node **p___0 ;
  struct alist_node *o ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  size_t size15 ;
  void *tmp16 ;
  void *ret_lsh_space_alloc17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 201
  self = (struct alist_linked *)c;
#line 203
  if (! (atom >= 0)) {
    {
    {
#line 203
    __assert_fail("atom >= 0", "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c",
                  203U, "do_linked_set");
    }
    }
  }
#line 205
  if (value) {
#line 209
    p = self->head;
    {
    {
#line 209
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 209
      if (! p) {
#line 209
        goto while_break;
      }
#line 210
      if (p->atom == atom) {
#line 212
        p->value = value;
#line 213
        return;
      }
#line 209
      p = p->next;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
    {
#line 216
    size15 = (size_t )sizeof(*p);
    {
    {
    {
#line 262 "/home/ysko/Works/test-src/lsh-2.0.4/src/xalloc.c"
    tmp16 = malloc(size15);
    }
    }
    {
#line 262
    ret_lsh_space_alloc17 = tmp16;
#line 262
    goto Lret_lsh_space_alloc;
    }
    }
    Lret_lsh_space_alloc: /* CIL Label */ 
#line 216 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c"
    tmp = ret_lsh_space_alloc17;
    }
#line 216
    p = (struct alist_node *)tmp;
#line 217
    p->next = self->head;
#line 218
    p->atom = atom;
#line 219
    p->value = value;
#line 221
    self->head = p;
#line 223
    (self->super.size) ++;
    }
  } else {
#line 229
    p___0 = & self->head;
    {
    {
#line 229
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;

#line 229
      if (! *p___0) {
#line 229
        goto while_break___0;
      }
#line 231
      o = *p___0;
#line 232
      if (o->atom == atom) {
        {
#line 234
        *p___0 = o->next;
        {
#line 235
        lsh_space_free((void const   *)o);
        }
#line 237
        (self->super.size) --;
        }
#line 238
        return;
      }
#line 240
      p___0 = & o->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 244
  return;
}
}
#line 246 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c"
struct alist *make_linked_alist(unsigned int n  , ...) 
{ 
  va_list args ;
  struct alist *res ;
  struct alist_linked *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 253
  tmp = lsh_object_alloc(& alist_linked_class_extended.super);
  }
#line 253
  self = (struct alist_linked *)tmp;
#line 254
  res = & self->super;
#line 256
  res->size = 0U;
#line 258
  self->head = (struct alist_node *)((void *)0);
  {
#line 260
  __builtin_va_start(args, n);
  }
  {
#line 262
  alist_addv(res, n, args);
  }
  {
#line 263
  __builtin_va_end(args);
  }
  }
#line 265
  return (res);
}
}
#line 270 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c"
unsigned int alist_select(struct alist *dst , struct alist *src , struct int_list *names___3 ) 
{ 
  unsigned int selected ;
  unsigned int i ;
  int atom ;
  struct lsh_object *o ;
  struct lsh_object *tmp ;

  {
#line 276
  i = 0U;
#line 276
  selected = 0U;
  {
  {
#line 276
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 276
    if (! (i < names___3->super.length)) {
#line 276
      goto while_break;
    }
    {
#line 278
    atom = names___3->elements[i];
    {
#line 279
    tmp = (*(((struct alist_meta *)src->super.isa)->get))(src, atom);
    }
#line 279
    o = tmp;
    }
#line 280
    if (o) {
      {
      {
#line 282
      (*(((struct alist_meta *)dst->super.isa)->set))(dst, atom, o);
      }
#line 283
      selected ++;
      }
    }
#line 276
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 286
  return (selected);
}
}
#line 289 "/home/ysko/Works/test-src/lsh-2.0.4/src/alist.c"
unsigned int alist_select_l(struct alist *dst , struct alist *src , unsigned int n 
                            , ...) 
{ 
  va_list args ;
  struct int_list *names___3 ;
  unsigned int selected ;

  {
  {
  {
#line 297
  __builtin_va_start(args, n);
  }
  {
#line 298
  names___3 = make_int_listv(n, args);
  }
  {
#line 299
  __builtin_va_end(args);
  }
  {
#line 301
  selected = alist_select(dst, src, names___3);
  }
  {
#line 303
  gc_kill((struct lsh_object *)names___3);
  }
  }
#line 305
  return (selected);
}
}
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.h.x"
struct lsh_class algorithms_options_class ;
#line 32 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.h"
struct alist *all_symmetric_algorithms(void) ;
#line 33
struct alist *all_signature_algorithms(struct randomness *r ) ;
#line 35
struct int_list *filter_algorithms(struct alist *algorithms , struct int_list  const  *candidates ) ;
#line 39
int lookup_crypto(struct alist *algorithms , char const   *name , struct crypto_algorithm **ap ) ;
#line 42
int lookup_mac(struct alist *algorithms , char const   *name , struct mac_algorithm **ap ) ;
#line 45
int lookup_compression(struct alist *algorithms , char const   *name , struct compress_algorithm **ap ) ;
#line 49
int lookup_hostkey_algorithm(char const   *name ) ;
#line 52
void list_crypto_algorithms(struct argp_state  const  *state , struct alist *algorithms ) ;
#line 55
void list_mac_algorithms(struct argp_state  const  *state , struct alist *algorithms ) ;
#line 58
void list_compression_algorithms(struct argp_state  const  *state , struct alist *algorithms ) ;
#line 62
void list_hostkey_algorithms(struct argp_state  const  *state ) ;
#line 65
void init_algorithms_options(struct algorithms_options *self , struct alist *algorithms ) ;
#line 68
struct algorithms_options *make_algorithms_options(struct alist *algorithms ) ;
#line 71
struct argp  const  algorithms_argp ;
#line 18 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.h.x"
static void do_algorithms_options_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct algorithms_options *i ;

  {
  {
#line 22
  i = (struct algorithms_options *)o;
  {
#line 23
  (*mark)((struct lsh_object *)i->algorithms);
  }
  {
#line 24
  (*mark)((struct lsh_object *)i->crypto_algorithms);
  }
  {
#line 25
  (*mark)((struct lsh_object *)i->mac_algorithms);
  }
  {
#line 26
  (*mark)((struct lsh_object *)i->compression_algorithms);
  }
  {
#line 27
  (*mark)((struct lsh_object *)i->hostkey_algorithms);
  }
  }
#line 28
  return;
}
}
#line 29 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.h.x"
struct lsh_class algorithms_options_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"algorithms_options", (size_t )sizeof(struct algorithms_options ),
    & do_algorithms_options_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 48 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
struct alist *all_symmetric_algorithms(void) 
{ 
  struct compress_algorithm *tmp ;
  struct mac_algorithm *tmp___0 ;
  struct mac_algorithm *tmp___1 ;
  struct alist *tmp___2 ;

  {
  {
  {
#line 51
  tmp = make_zlib();
  }
  {
#line 51
  tmp___0 = make_hmac_algorithm(& crypto_md5_algorithm);
  }
  {
#line 51
  tmp___1 = make_hmac_algorithm(& crypto_sha1_algorithm);
  }
  {
#line 51
  tmp___2 = make_linear_alist(12U, 26, & crypto_arcfour_algorithm, 5, & crypto_blowfish_cbc_algorithm,
                              8, & crypto_twofish256_cbc_algorithm, 14, & crypto_aes256_cbc_algorithm,
                              19, & crypto_aes256_ctr_algorithm, 20, & crypto_serpent256_cbc_algorithm,
                              29, & crypto_serpent256_cbc_algorithm, 3, & crypto_des3_cbc_algorithm,
                              27, & crypto_cast128_cbc_algorithm, 30, tmp___1, 32,
                              tmp___0, 2, tmp, -1);
  }
  }
#line 51
  return (tmp___2);
}
}
#line 77 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
struct alist *all_signature_algorithms(struct randomness *r ) 
{ 
  struct signature_algorithm *tmp ;
  struct alist *tmp___0 ;

  {
  {
  {
#line 80
  tmp = make_dsa_algorithm(r);
  }
  {
#line 80
  tmp___0 = make_linear_alist(3U, 87, tmp, 95, & rsa_sha1_algorithm.super, 96, & rsa_sha1_algorithm.super,
                              -1);
  }
  }
#line 80
  return (tmp___0);
}
}
#line 88
struct int_list *filter_algorithms_l(struct alist *algorithms , unsigned int n  , ...) ;
#line 93 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
static struct int_list *default_crypto_algorithms(struct alist *algorithms ) 
{ 
  struct int_list *tmp ;

  {
  {
  {
#line 96
  tmp = filter_algorithms_l(algorithms, 4U, 14, 3, 5, 26, -1);
  }
  }
#line 96
  return (tmp);
}
}
#line 105 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
static struct int_list *all_crypto_algorithms(struct alist *algorithms ) 
{ 
  struct int_list *tmp ;

  {
  {
  {
#line 108
  tmp = filter_algorithms_l(algorithms, 9U, 14, 19, 3, 8, 27, 20, 29, 5, 26, -1);
  }
  }
#line 108
  return (tmp);
}
}
#line 120 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
static struct int_list *default_mac_algorithms(struct alist *algorithms ) 
{ 
  struct int_list *tmp ;

  {
  {
  {
#line 123
  tmp = filter_algorithms_l(algorithms, 2U, 30, 32, -1);
  }
  }
#line 123
  return (tmp);
}
}
#line 126 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
static struct int_list *default_compression_algorithms(struct alist *algorithms ) 
{ 
  struct int_list *tmp ;

  {
  {
  {
#line 129
  tmp = filter_algorithms_l(algorithms, 2U, 1, 2, -1);
  }
  }
#line 129
  return (tmp);
}
}
#line 132 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
static struct int_list *prefer_compression_algorithms(struct alist *algorithms ) 
{ 
  struct int_list *tmp ;

  {
  {
  {
#line 135
  tmp = filter_algorithms_l(algorithms, 2U, 2, 1, -1);
  }
  }
#line 135
  return (tmp);
}
}
#line 140 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
static int strcasecmp_list(char const   *name  , ...) 
{ 
  va_list args ;
  char *s ;
  int res ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 144
  res = 0;
  {
#line 146
  __builtin_va_start(args, name);
  }
  }
  {
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 147
    tmp___1 = __builtin_va_arg(args, char *);
    }
#line 147
    tmp___0 = tmp___1;
#line 147
    s = tmp___0;
    }
#line 147
    if (! s) {
#line 147
      goto while_break;
    }
    {
    {
#line 149
    tmp = strcasecmp(name, (char const   *)s);
    }
    }
#line 149
    if (! tmp) {
#line 151
      res = 1;
#line 152
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  {
#line 155
  __builtin_va_end(args);
  }
  }
#line 157
  return (res);
}
}
#line 160 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
int lookup_crypto(struct alist *algorithms , char const   *name , struct crypto_algorithm **ap ) 
{ 
  int atom ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct crypto_algorithm *a ;
  struct lsh_object *tmp___8 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;

  {
  {
  {
#line 165
  tmp___7 = strcasecmp(name, "none");
  }
  }
#line 165
  if (tmp___7) {
    {
    {
#line 172
    tmp___6 = strcasecmp_list(name, "arcfour", (void *)0);
    }
    }
#line 172
    if (tmp___6) {
#line 173
      atom = 26;
    } else {
      {
      {
#line 174
      tmp___5 = strcasecmp_list(name, "twofish-cbc", "twofish", (void *)0);
      }
      }
#line 174
      if (tmp___5) {
#line 175
        atom = 8;
      } else {
        {
        {
#line 176
        tmp___4 = strcasecmp_list(name, "blowfish-cbc", "blowfish", (void *)0);
        }
        }
#line 176
        if (tmp___4) {
#line 177
          atom = 5;
        } else {
          {
          {
#line 178
          tmp___3 = strcasecmp_list(name, "3des-cbc", "3des", (void *)0);
          }
          }
#line 178
          if (tmp___3) {
#line 179
            atom = 3;
          } else {
            {
            {
#line 180
            tmp___2 = strcasecmp_list(name, "aes256-cbc", "aes-cbc", "aes", "rijndael",
                                      (void *)0);
            }
            }
#line 180
            if (tmp___2) {
#line 181
              atom = 14;
            } else {
              {
              {
#line 182
              tmp___1 = strcasecmp_list(name, "aes256-ctr", "aes-ctr", (void *)0);
              }
              }
#line 182
              if (tmp___1) {
#line 183
                atom = 19;
              } else {
                {
                {
#line 184
                tmp___0 = strcasecmp_list(name, "serpent256-cbc", "serpent-cbc", "serpent",
                                          (void *)0);
                }
                }
#line 184
                if (tmp___0) {
#line 186
                  atom = 20;
                } else {
                  {
                  {
#line 187
                  tmp = strcasecmp_list(name, "cast128-cbc", "cast", "cast-cbc", "cast128",
                                        (void *)0);
                  }
                  }
#line 187
                  if (tmp) {
#line 189
                    atom = 27;
                  } else {
#line 191
                    return (0);
                  }
                }
              }
            }
          }
        }
      }
    }
  } else {
#line 167
    if (ap) {
#line 168
      *ap = (struct crypto_algorithm *)((void *)0);
    }
#line 170
    return (1);
  }
  {
  {
#line 195
  tmp___8 = (*(((struct alist_meta *)algorithms->super.isa)->get))(algorithms, atom);
  }
#line 195
  a = (struct crypto_algorithm *)tmp___8;
  }
#line 196
  if (a) {
#line 198
    if (ap) {
#line 199
      *ap = a;
    }
#line 201
    return (atom);
  } else {
#line 204
    return (0);
  }
}
}
#line 208 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
int lookup_mac(struct alist *algorithms , char const   *name , struct mac_algorithm **ap ) 
{ 
  int atom ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct mac_algorithm *a ;
  struct lsh_object *tmp___2 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
  {
#line 213
  tmp = strcasecmp(name, "none");
  }
  }
#line 213
  if (! tmp) {
#line 215
    if (ap) {
#line 216
      *ap = (struct mac_algorithm *)((void *)0);
    }
#line 218
    return (1);
  }
  {
  {
#line 220
  tmp___1 = strcasecmp_list(name, "hmac-sha1", "sha", "hmac-sha", "sha1", (void *)0);
  }
  }
#line 220
  if (tmp___1) {
#line 221
    atom = 30;
  } else {
    {
    {
#line 222
    tmp___0 = strcasecmp_list(name, "hmac-md5", "md5", (void *)0);
    }
    }
#line 222
    if (tmp___0) {
#line 223
      atom = 32;
    } else {
#line 225
      return (0);
    }
  }
  {
  {
#line 229
  tmp___2 = (*(((struct alist_meta *)algorithms->super.isa)->get))(algorithms, atom);
  }
#line 229
  a = (struct mac_algorithm *)tmp___2;
  }
#line 230
  if (a) {
#line 232
    if (ap) {
#line 233
      *ap = a;
    }
#line 235
    return (atom);
  } else {
#line 238
    return (0);
  }
}
}
#line 242 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
int lookup_compression(struct alist *algorithms , char const   *name , struct compress_algorithm **ap ) 
{ 
  int atom ;
  int tmp ;
  int tmp___0 ;
  struct compress_algorithm *a ;
  struct lsh_object *tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 247
  tmp = strcasecmp(name, "none");
  }
  }
#line 247
  if (! tmp) {
#line 249
    if (ap) {
#line 250
      *ap = (struct compress_algorithm *)((void *)0);
    }
#line 252
    return (1);
  }
  {
  {
#line 254
  tmp___0 = strcasecmp_list(name, "zlib", "z", (void *)0);
  }
  }
#line 254
  if (tmp___0) {
#line 255
    atom = 2;
  } else {
#line 257
    return (0);
  }
  {
  {
#line 261
  tmp___1 = (*(((struct alist_meta *)algorithms->super.isa)->get))(algorithms, atom);
  }
#line 261
  a = (struct compress_algorithm *)tmp___1;
  }
#line 262
  if (a) {
#line 264
    if (ap) {
#line 265
      *ap = a;
    }
#line 267
    return (atom);
  } else {
#line 270
    return (0);
  }
}
}
#line 274 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
int lookup_hostkey_algorithm(char const   *name ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
  {
#line 277
  tmp___2 = strcasecmp(name, "none");
  }
  }
#line 277
  if (tmp___2) {
    {
    {
#line 279
    tmp___1 = strcasecmp_list(name, "ssh-dss", "dsa", "dss", (void *)0);
    }
    }
#line 279
    if (tmp___1) {
#line 280
      return (36);
    } else {
      {
      {
#line 281
      tmp___0 = strcasecmp_list(name, "spki-sign-rsa", "spki-rsa", (void *)0);
      }
      }
#line 281
      if (tmp___0) {
#line 282
        return (40);
      } else {
        {
        {
#line 283
        tmp = strcasecmp_list(name, "spki-sign-dss", "spki-dss", "spki-sign-dsa",
                              "spki-dsa", (void *)0);
        }
        }
#line 283
        if (tmp) {
#line 285
          return (41);
        } else {
#line 287
          return (0);
        }
      }
    }
  } else {
#line 278
    return (1);
  }
}
}
#line 296 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
struct int_list *filter_algorithms(struct alist *algorithms , struct int_list  const  *candidates ) 
{ 
  struct int_list *l ;
  unsigned int i ;
  unsigned int j ;
  unsigned int supported ;
  int atom ;
  struct lsh_object *tmp ;
  struct list_header *tmp___0 ;
  int atom___0 ;
  unsigned int tmp___1 ;
  struct lsh_object *tmp___2 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  struct lsh_class *class25 ;
  unsigned int length26 ;
  size_t element_size27 ;
  struct list_header *list28 ;
  struct lsh_object *tmp29 ;
  char *__cil_tmp930 ;
  char *__cil_tmp1031 ;
  char *__cil_tmp1132 ;
  struct list_header *ret_lsh_list_alloc33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 304
  i = 0U;
#line 304
  supported = 0U;
  {
  {
#line 304
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 304
    if (! (i < (unsigned int )candidates->super.length)) {
#line 304
      goto while_break;
    }
    {
#line 306
    atom = candidates->elements[i];
    {
#line 307
    tmp = (*(((struct alist_meta *)algorithms->super.isa)->get))(algorithms, atom);
    }
    }
#line 307
    if (tmp) {
#line 309
      supported ++;
    } else
#line 307
    if (atom == 1) {
#line 309
      supported ++;
    }
#line 304
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 312
  if (! supported) {
#line 313
    return ((struct int_list *)((void *)0));
  }
  {
  {
#line 315
  class25 = & int_list_class;
#line 315
  length26 = supported;
#line 315
  element_size27 = (size_t )sizeof(int );
  {
#line 49
  if (! (element_size27 < 1024U)) {
    {
    {
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c"
    __assert_fail("element_size < 1024", "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c",
                  49U, "lsh_list_alloc");
    }
    }
  }
  {
  {
#line 51
  tmp29 = lsh_var_alloc(class25, (class25->size + element_size27 * length26) - element_size27);
  }
#line 51
  list28 = (struct list_header *)tmp29;
#line 57
  list28->length = length26;
  }
  {
#line 59
  ret_lsh_list_alloc33 = list28;
#line 59
  goto Lret_lsh_list_alloc;
  }
  }
  Lret_lsh_list_alloc: /* CIL Label */ 
#line 315 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
  tmp___0 = ret_lsh_list_alloc33;
  }
#line 315
  l = (struct int_list *)tmp___0;
#line 317
  j = 0U;
#line 317
  i = j;
  }
  {
  {
#line 317
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;

#line 317
    if (! (i < (unsigned int )candidates->super.length)) {
#line 317
      goto while_break___0;
    }
    {
#line 319
    atom___0 = candidates->elements[i];
    {
#line 320
    tmp___2 = (*(((struct alist_meta *)algorithms->super.isa)->get))(algorithms, atom___0);
    }
    }
#line 320
    if (tmp___2) {
#line 320
      goto _L;
    } else
#line 320
    if (atom___0 == 1) {
      _L: 
#line 323
      if (! (j < supported)) {
        {
        {
#line 323
        __assert_fail("j < supported", "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c",
                      323U, "filter_algorithms");
        }
        }
      }
#line 324
      tmp___1 = j;
#line 324
      j ++;
#line 324
      l->elements[tmp___1] = atom___0;
    }
#line 317
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 327
  if (! (j == supported)) {
    {
    {
#line 327
    __assert_fail("j == supported", "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c",
                  327U, "filter_algorithms");
    }
    }
  }
#line 329
  return (l);
}
}
#line 333 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
struct int_list *filter_algorithms_l(struct alist *algorithms , unsigned int n  , ...) 
{ 
  va_list args ;
  struct int_list *l ;
  struct int_list *candidates ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 340
  __builtin_va_start(args, n);
  }
  {
#line 341
  candidates = make_int_listv(n, args);
  }
  {
#line 342
  __builtin_va_end(args);
  }
  {
#line 344
  l = filter_algorithms(algorithms, (struct int_list  const  *)candidates);
  }
  }
#line 346
  if (! l->super.length) {
    {
    {
#line 346
    __assert_fail("((l)->super.length)", "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c",
                  346U, "filter_algorithms_l");
    }
    }
  }
  {
  {
#line 348
  gc_kill((struct lsh_object *)candidates);
  }
  }
#line 349
  return (l);
}
}
#line 353 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
static void list_algorithms(struct argp_state  const  *state , char *prefix___0 ,
                            struct int_list *algorithms , int none ) 
{ 
  unsigned int i ;
  int separate ;
  uint8_t const   *tmp ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
  {
#line 362
  fprintf((FILE */* __restrict  */)((FILE *)state->out_stream), (char const   */* __restrict  */)"%s",
          prefix___0);
  }
#line 364
  i = 0U;
#line 364
  separate = 0;
  }
  {
  {
#line 364
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;

#line 364
    if (! (i < algorithms->super.length)) {
#line 364
      goto while_break;
    }
#line 366
    if (separate) {
      {
      {
#line 367
      fprintf((FILE */* __restrict  */)((FILE *)state->out_stream), (char const   */* __restrict  */)", ");
      }
      }
    }
    {
    {
#line 369
    tmp = get_atom_name(algorithms->elements[i]);
    }
    {
#line 369
    fprintf((FILE */* __restrict  */)((FILE *)state->out_stream), (char const   */* __restrict  */)"%s",
            tmp);
    }
#line 373
    separate = 1;
#line 364
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 376
  if (none) {
#line 378
    if (separate) {
      {
      {
#line 379
      fprintf((FILE */* __restrict  */)((FILE *)state->out_stream), (char const   */* __restrict  */)", ");
      }
      }
    }
    {
    {
#line 380
    fprintf((FILE */* __restrict  */)((FILE *)state->out_stream), (char const   */* __restrict  */)"none");
    }
    }
  }
  {
  {
#line 383
  fprintf((FILE */* __restrict  */)((FILE *)state->out_stream), (char const   */* __restrict  */)"\n");
  }
  }
#line 384
  return;
}
}
#line 386 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
void list_crypto_algorithms(struct argp_state  const  *state , struct alist *algorithms ) 
{ 
  struct int_list *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 390
  tmp = all_crypto_algorithms(algorithms);
  }
  {
#line 390
  list_algorithms(state, (char *)"Supported crypto algorithms: ", tmp, 1);
  }
  }
#line 394
  return;
}
}
#line 396 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
void list_mac_algorithms(struct argp_state  const  *state , struct alist *algorithms ) 
{ 
  struct int_list *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 400
  tmp = default_mac_algorithms(algorithms);
  }
  {
#line 400
  list_algorithms(state, (char *)"Supported MAC algorithms: ", tmp, 1);
  }
  }
#line 404
  return;
}
}
#line 406 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
void list_compression_algorithms(struct argp_state  const  *state , struct alist *algorithms ) 
{ 
  struct int_list *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 410
  tmp = default_compression_algorithms(algorithms);
  }
  {
#line 410
  list_algorithms(state, (char *)"Supported compression algorithms: ", tmp, 0);
  }
  }
#line 414
  return;
}
}
#line 416 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
void list_hostkey_algorithms(struct argp_state  const  *state ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 419
  fprintf((FILE */* __restrict  */)((FILE *)state->out_stream), (char const   */* __restrict  */)"%s",
          "Supported hostkey algorithms: ssh-dss, spki, none\n");
  }
  }
#line 420
  return;
}
}
#line 426 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
static struct argp_option  const  algorithms_options[7]  = {      {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Algorithm selection:",
      0}, 
        {"crypto", 'c', "Algorithm", 0, "", 0}, 
        {"compression", 'z', "Algorithm", 1, "Default is zlib.", 0}, 
        {"mac", 'm', "Algorithm", 0, "", 0}, 
        {"hostkey-algorithm", 257, "Algorithm", 0, "", 0}, 
        {"list-algorithms", 256, (char const   *)((void *)0), 0, "List supported algorithms.",
      0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (char const   *)((void *)0),
      0}};
#line 441 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
void init_algorithms_options(struct algorithms_options *self , struct alist *algorithms ) 
{ 


  {
#line 445
  self->algorithms = algorithms;
#line 447
  self->crypto_algorithms = (struct int_list *)((void *)0);
#line 448
  self->mac_algorithms = (struct int_list *)((void *)0);
#line 449
  self->compression_algorithms = (struct int_list *)((void *)0);
#line 450
  self->hostkey_algorithms = (struct int_list *)((void *)0);
#line 451
  return;
}
}
#line 453 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
struct algorithms_options *make_algorithms_options(struct alist *algorithms ) 
{ 
  struct algorithms_options *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 456
  tmp = lsh_object_alloc(& algorithms_options_class);
  }
#line 456
  self = (struct algorithms_options *)tmp;
  {
#line 457
  init_algorithms_options(self, algorithms);
  }
  }
#line 459
  return (self);
}
}
#line 462 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
static error_t algorithms_argp_parser(int key , char *arg , struct argp_state *state ) 
{ 
  struct algorithms_options *self ;
  int crypto ;
  int tmp ;
  int tmp___0 ;
  int mac ;
  int tmp___1 ;
  int compression ;
  int tmp___2 ;
  int algorithm ;
  int tmp___3 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 465
  self = (struct algorithms_options *)state->input;
#line 471
  if (key == 16777217) {
#line 471
    goto case_16777217;
  }
#line 482
  if (key == 99) {
#line 482
    goto case_99;
  }
#line 498
  if (key == 109) {
#line 498
    goto case_109;
  }
#line 510
  if (key == 122) {
#line 510
    goto case_122;
  }
#line 527
  if (key == 257) {
#line 527
    goto case_257;
  }
#line 541
  if (key == 256) {
#line 541
    goto case_256;
  }
#line 469
  goto switch_default;
  switch_default: 
#line 470
  return (7);
  case_16777217: 
#line 472
  if (! self->crypto_algorithms) {
    {
    {
#line 473
    self->crypto_algorithms = default_crypto_algorithms(self->algorithms);
    }
    }
  }
#line 474
  if (! self->mac_algorithms) {
    {
    {
#line 475
    self->mac_algorithms = default_mac_algorithms(self->algorithms);
    }
    }
  }
#line 476
  if (! self->compression_algorithms) {
    {
    {
#line 477
    self->compression_algorithms = default_compression_algorithms(self->algorithms);
    }
    }
  }
#line 478
  if (! self->hostkey_algorithms) {
    {
    {
#line 479
    self->hostkey_algorithms = make_int_list(4U, 37, 36, 40, 41, -1);
    }
    }
  }
#line 481
  goto switch_break;
  case_99: 
  {
  {
#line 484
  tmp = lookup_crypto(self->algorithms, (char const   *)arg, (struct crypto_algorithm **)((void *)0));
  }
#line 484
  crypto = tmp;
  }
#line 486
  if (crypto) {
    {
    {
#line 487
    self->crypto_algorithms = make_int_list(1U, crypto, -1);
    }
    }
  } else {
    {
    {
#line 488
    tmp___0 = strcasecmp_list((char const   *)arg, "all", "any", (void *)0);
    }
    }
#line 488
    if (tmp___0) {
      {
      {
#line 489
      self->crypto_algorithms = all_crypto_algorithms(self->algorithms);
      }
      }
    } else {
      {
      {
#line 493
      list_crypto_algorithms((struct argp_state  const  *)state, self->algorithms);
      }
      {
#line 494
      argp_error((struct argp_state  const  *)state, "Unknown crypto algorithm \'%s\'.",
                 arg);
      }
      }
    }
  }
#line 496
  goto switch_break;
  case_109: 
  {
  {
#line 500
  tmp___1 = lookup_mac(self->algorithms, (char const   *)arg, (struct mac_algorithm **)((void *)0));
  }
#line 500
  mac = tmp___1;
  }
#line 501
  if (mac) {
    {
    {
#line 502
    self->mac_algorithms = make_int_list(1U, mac, -1);
    }
    }
  } else {
    {
    {
#line 505
    list_mac_algorithms((struct argp_state  const  *)state, self->algorithms);
    }
    {
#line 506
    argp_error((struct argp_state  const  *)state, "Unknown message authentication algorithm \'%s\'.",
               arg);
    }
    }
  }
#line 508
  goto switch_break;
  case_122: 
#line 512
  if (! arg) {
    {
    {
#line 513
    self->compression_algorithms = prefer_compression_algorithms(self->algorithms);
    }
    }
  } else {
    {
    {
#line 516
    tmp___2 = lookup_compression(self->algorithms, (char const   *)arg, (struct compress_algorithm **)((void *)0));
    }
#line 516
    compression = tmp___2;
    }
#line 517
    if (compression) {
      {
      {
#line 518
      self->compression_algorithms = make_int_list(1U, compression, -1);
      }
      }
    } else {
      {
      {
#line 521
      list_compression_algorithms((struct argp_state  const  *)state, self->algorithms);
      }
      {
#line 522
      argp_error((struct argp_state  const  *)state, "Unknown compression algorithm \'%s\'.",
                 arg);
      }
      }
    }
  }
#line 525
  goto switch_break;
  case_257: 
  {
  {
#line 529
  tmp___3 = lookup_hostkey_algorithm((char const   *)arg);
  }
#line 529
  algorithm = tmp___3;
  }
#line 530
  if (algorithm) {
    {
    {
#line 531
    self->hostkey_algorithms = make_int_list(1U, algorithm, -1);
    }
    }
  } else {
    {
    {
#line 534
    list_hostkey_algorithms((struct argp_state  const  *)state);
    }
    {
#line 535
    argp_error((struct argp_state  const  *)state, "Unknown hostkey algorithm \'%s\'.",
               arg);
    }
    }
  }
#line 537
  goto switch_break;
  case_256: 
  {
  {
#line 542
  list_crypto_algorithms((struct argp_state  const  *)state, self->algorithms);
  }
  {
#line 543
  list_compression_algorithms((struct argp_state  const  *)state, self->algorithms);
  }
  {
#line 544
  list_mac_algorithms((struct argp_state  const  *)state, self->algorithms);
  }
  {
#line 545
  list_hostkey_algorithms((struct argp_state  const  *)state);
  }
  }
#line 547
  if (! (state->flags & 32U)) {
    {
    {
#line 548
    exit(0);
    }
    }
  }
  switch_break: ;
#line 550
  return (0);
}
}
#line 553 "/home/ysko/Works/test-src/lsh-2.0.4/src/algorithms.c"
struct argp  const  algorithms_argp  =    {algorithms_options, & algorithms_argp_parser, (char const   *)((void *)0), (char const   *)((void *)0),
    (struct argp_child  const  *)((void *)0), (char *(*)(int __key , char const   *__text ,
                                                         void *__input ))((void *)0),
    (char const   *)((void *)0)};
#line 14 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_io.h.x"
struct lsh_class abstract_write_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"abstract_write", (size_t )sizeof(struct abstract_write ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_io.h.x"
static void do_abstract_write_pipe_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct abstract_write_pipe *i ;

  {
  {
#line 42
  i = (struct abstract_write_pipe *)o;
  {
#line 43
  (*mark)((struct lsh_object *)i->next);
  }
  }
#line 44
  return;
}
}
#line 45 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_io.h.x"
struct lsh_class abstract_write_pipe_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & abstract_write_class, (char *)"abstract_write_pipe", (size_t )sizeof(struct abstract_write_pipe ),
    & do_abstract_write_pipe_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 69 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_io.h.x"
struct lsh_class read_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"read_handler", (size_t )sizeof(struct read_handler ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 38 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct lsh_class crypto_algorithm_class ;
#line 87
struct lsh_class hash_algorithm_class ;
#line 217 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h"
struct lsh_string *mac_string(struct mac_algorithm *a , struct lsh_string  const  *key ,
                              int kfree , struct lsh_string  const  *in , int ifree ) ;
#line 224
struct lsh_string *crypt_string(struct crypto_instance *c , struct lsh_string  const  *in ,
                                int free___0 ) ;
#line 15 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct lsh_class crypto_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"crypto_instance", (size_t )sizeof(struct crypto_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 42 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct lsh_class crypto_algorithm_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"crypto_algorithm", (size_t )sizeof(struct crypto_algorithm ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 67 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct lsh_class hash_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"hash_instance", (size_t )sizeof(struct hash_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 91 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct lsh_class hash_algorithm_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"hash_algorithm", (size_t )sizeof(struct hash_algorithm ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 117 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct lsh_class mac_instance_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"mac_instance", (size_t )sizeof(struct mac_instance ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 143 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct lsh_class mac_algorithm_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"mac_algorithm", (size_t )sizeof(struct mac_algorithm ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 169 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct lsh_class verifier_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"verifier", (size_t )sizeof(struct verifier ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 194 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct lsh_class signer_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"signer", (size_t )sizeof(struct signer ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 219 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.h.x"
struct lsh_class signature_algorithm_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (struct lsh_class *)((void *)0), (char *)"signature_algorithm", (size_t )sizeof(struct signature_algorithm ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 44 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.c"
struct lsh_string *hash_string(struct hash_algorithm  const  *a , struct lsh_string  const  *in ,
                               int free___0 ) 
{ 
  struct hash_instance *hash___2 ;
  struct hash_instance *tmp ;
  struct lsh_string *out ;
  uint8_t const   *tmp___0 ;
  uint32_t tmp___1 ;

  {
  {
  {
#line 49
  tmp = make_hash(a);
  }
#line 49
  hash___2 = tmp;
  {
#line 52
  tmp___0 = lsh_string_data(in);
  }
  {
#line 52
  tmp___1 = lsh_string_length(in);
  }
  {
#line 52
  hash_update(hash___2, tmp___1, tmp___0);
  }
  {
#line 53
  out = hash_digest_string(hash___2);
  }
  {
#line 55
  gc_kill((struct lsh_object *)hash___2);
  }
  }
#line 56
  if (free___0) {
    {
    {
#line 57
    lsh_string_free(in);
    }
    }
  }
#line 59
  return (out);
}
}
#line 62 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.c"
struct lsh_string *mac_string(struct mac_algorithm *a , struct lsh_string  const  *key ,
                              int kfree , struct lsh_string  const  *in , int ifree ) 
{ 
  struct lsh_string *out ;
  struct mac_instance *mac ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  struct mac_instance *tmp___1 ;
  uint8_t const   *tmp___2 ;
  uint32_t tmp___3 ;
  struct lsh_string *tmp___4 ;

  {
  {
  {
#line 70
  tmp = lsh_string_data(key);
  }
  {
#line 70
  tmp___0 = lsh_string_length(key);
  }
  {
#line 70
  tmp___1 = (*(a->make_mac))(a, tmp___0, tmp);
  }
#line 70
  mac = tmp___1;
  {
#line 73
  tmp___2 = lsh_string_data(in);
  }
  {
#line 73
  tmp___3 = lsh_string_length(in);
  }
  {
#line 73
  (*(mac->update))(mac, tmp___3, tmp___2);
  }
  {
#line 74
  tmp___4 = lsh_string_alloc(mac->mac_size);
  }
  {
#line 74
  out = (*(mac->digest))(mac, tmp___4, (uint32_t )0);
  }
  {
#line 76
  gc_kill((struct lsh_object *)mac);
  }
  }
#line 78
  if (kfree) {
    {
    {
#line 79
    lsh_string_free(key);
    }
    }
  }
#line 80
  if (ifree) {
    {
    {
#line 81
    lsh_string_free(in);
    }
    }
  }
#line 83
  return (out);
}
}
#line 86 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.c"
struct lsh_string *crypt_string(struct crypto_instance *c , struct lsh_string  const  *in ,
                                int free___0 ) 
{ 
  struct lsh_string *out ;
  uint32_t length ;
  uint32_t tmp ;

  {
  {
  {
#line 92
  tmp = lsh_string_length(in);
  }
#line 92
  length = tmp;
  }
#line 94
  if (c->block_size) {
#line 94
    if (length % c->block_size) {
#line 95
      return ((struct lsh_string *)((void *)0));
    }
  }
#line 97
  if (free___0) {
#line 102
    out = (struct lsh_string *)in;
  } else {
    {
    {
#line 106
    out = lsh_string_alloc(length);
    }
    }
  }
  {
  {
#line 108
  (*(c->crypt))(c, length, out, (uint32_t )0, in, (uint32_t )0);
  }
  }
#line 110
  return (out);
}
}
#line 115 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.c"
struct lsh_string *crypt_string_pad(struct crypto_instance *c , struct lsh_string  const  *in ,
                                    int free___0 ) 
{ 
  struct lsh_string *s ;
  uint32_t length ;
  uint32_t tmp ;
  uint32_t pos ;
  uint32_t pad___0 ;
  char const   *tmp___0 ;
  struct lsh_string *tmp___1 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
  {
#line 121
  tmp = lsh_string_length(in);
  }
#line 121
  length = tmp;
#line 123
  pad___0 = c->block_size - length % c->block_size;
  }
#line 125
  if (! pad___0) {
    {
    {
#line 125
    __assert_fail("pad", "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.c",
                  125U, "crypt_string_pad");
    }
    }
  }
#line 127
  if (free___0) {
#line 127
    tmp___0 = "%lfS%lr";
  } else {
#line 127
    tmp___0 = "%lS%lr";
  }
  {
  {
#line 127
  s = ssh_format(tmp___0, in, pad___0, & pos);
  }
  {
#line 130
  lsh_string_set(s, pos, pad___0, (uint8_t )pad___0);
  }
  {
#line 132
  tmp___1 = crypt_string(c, (struct lsh_string  const  *)s, 1);
  }
  }
#line 132
  return (tmp___1);
}
}
#line 135 "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.c"
struct lsh_string *crypt_string_unpad(struct crypto_instance *c , struct lsh_string  const  *in ,
                                      int free___0 ) 
{ 
  struct lsh_string *out ;
  uint32_t pad___0 ;
  uint32_t length ;
  uint32_t tmp ;
  uint8_t const   *tmp___0 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
  {
#line 142
  tmp = lsh_string_length(in);
  }
#line 142
  length = tmp;
  }
#line 143
  if (! length) {
    {
    {
#line 143
    __assert_fail("length", "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.c",
                  143U, "crypt_string_unpad");
    }
    }
  }
  {
  {
#line 145
  out = crypt_string(c, in, free___0);
  }
  }
#line 146
  if (! out) {
#line 147
    return ((struct lsh_string *)((void *)0));
  }
  {
  {
#line 149
  length = lsh_string_length((struct lsh_string  const  *)out);
  }
  {
#line 150
  tmp___0 = lsh_string_data((struct lsh_string  const  *)out);
  }
#line 150
  pad___0 = (uint32_t )*(tmp___0 + (length - 1U));
  }
#line 152
  if (pad___0 > 0U) {
#line 152
    if (pad___0 <= c->block_size) {
#line 156
      if (! (pad___0 <= length)) {
        {
        {
#line 156
        __assert_fail("pad <= length", "/home/ysko/Works/test-src/lsh-2.0.4/src/abstract_crypto.c",
                      156U, "crypt_string_unpad");
        }
        }
      }
      {
      {
#line 158
      lsh_string_trunc(out, length - pad___0);
      }
      }
#line 159
      return (out);
    } else {
      {
      {
#line 163
      lsh_string_free((struct lsh_string  const  *)out);
      }
      }
#line 164
      return ((struct lsh_string *)((void *)0));
    }
  } else {
    {
    {
#line 163
    lsh_string_free((struct lsh_string  const  *)out);
    }
    }
#line 164
    return ((struct lsh_string *)((void *)0));
  }
}
}
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 415 "/home/ysko/Works/test-src/lsh-2.0.4/src/argp/argp.h"
char const   *argp_program_version ;
#line 431
char const   *argp_program_bug_address ;
#line 515
extern  __attribute__((__nothrow__)) void argp_failure(struct argp_state  const  *__state ,
                                                       int __status , int __errnum ,
                                                       char const   *__fmt  , ...) ;
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static struct request_service request_userauth_service  =    {{{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1,
      (char)0, (char)0}, & do_request_service}, 45};
#line 22 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c.x"
struct lsh_class lsh_options_class ;
#line 26 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c.x"
static void do_lsh_options_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct lsh_options *i ;

  {
  {
#line 30
  i = (struct lsh_options *)o;
  {
#line 31
  (*mark)((struct lsh_object *)i->algorithms);
  }
  {
#line 32
  (*mark)((struct lsh_object *)i->signature_algorithms);
  }
  {
#line 33
  (*mark)((struct lsh_object *)i->kex_algorithms);
  }
  {
#line 34
  (*mark)((struct lsh_object *)i->capture_file);
  }
  }
#line 35
  return;
}
}
#line 36 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c.x"
struct lsh_class lsh_options_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & client_options_class, (char *)"lsh_options", (size_t )sizeof(struct lsh_options ),
    & do_lsh_options_mark, (void (*)(struct lsh_object *instance ))((void *)0)};
#line 62
struct lsh_class lsh_host_db_class ;
#line 66 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c.x"
static void do_lsh_host_db_mark(struct lsh_object *o , void (*mark)(struct lsh_object *o ) ) 
{ 
  struct lsh_host_db *i ;

  {
  {
#line 70
  i = (struct lsh_host_db *)o;
  {
#line 71
  (*mark)((struct lsh_object *)i->db);
  }
  {
#line 72
  (*mark)((struct lsh_object *)i->tty);
  }
  {
#line 73
  (*mark)((struct lsh_object *)i->file);
  }
  {
#line 74
  (*mark)((struct lsh_object *)i->hash);
  }
  }
#line 75
  return;
}
}
#line 76 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c.x"
static void do_lsh_host_db_free(struct lsh_object *o ) 
{ 
  struct lsh_host_db *i ;

  {
  {
#line 79
  i = (struct lsh_host_db *)o;
  {
#line 80
  lsh_string_free((struct lsh_string  const  *)i->access);
  }
  }
#line 81
  return;
}
}
#line 82 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c.x"
struct lsh_class lsh_host_db_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & lookup_verifier_class, (char *)"lsh_host_db", (size_t )sizeof(struct lsh_host_db ),
    & do_lsh_host_db_mark, & do_lsh_host_db_free};
#line 93 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c.x"
static struct command *make_lsh_connect(struct resource *resource , struct handshake_info *handshake ,
                                        struct lookup_verifier *db , struct object_list *actions ,
                                        struct command *login ) 
{ 
  struct command *res ;
  struct lsh_object *tmp ;
  struct lsh_object *tmp___0 ;
  struct lsh_object *tmp___1 ;
  struct lsh_object *tmp___2 ;
  struct command *tmp___3 ;
  struct command *tmp___4 ;
  struct lsh_object *tmp___5 ;
  struct command *tmp___6 ;

  {
  {
  {
#line 126
  tmp = gaba_apply(& protect_command.super.super, (struct lsh_object *)resource);
  }
  {
#line 126
  tmp___0 = gaba_apply(tmp, & handshake_command.super.super);
  }
  {
#line 126
  tmp___1 = gaba_apply(tmp___0, (struct lsh_object *)handshake);
  }
  {
#line 126
  tmp___2 = gaba_apply(tmp___1, (struct lsh_object *)db);
  }
  {
#line 126
  tmp___3 = make_command_4_invoke_3(& command_Bp, & request_userauth_service.super.super,
                                    tmp___2, & connect_list_command.super);
  }
  {
#line 126
  tmp___4 = make_command_4_invoke_3(& command_Bp, & connection_service_command.super,
                                    (struct lsh_object *)login, (struct lsh_object *)tmp___3);
  }
  {
#line 126
  tmp___5 = gaba_apply(& progn_command.super, (struct lsh_object *)actions);
  }
  {
#line 126
  tmp___6 = make_command_3_invoke_2(& command_B, tmp___5, (struct lsh_object *)tmp___4);
  }
#line 126
  res = (struct command *)((struct lsh_object *)tmp___6);
  }
#line 139
  return (res);
}
}
#line 176
struct lsh_class lsh_default_handler_class ;
#line 180 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c.x"
struct lsh_class lsh_default_handler_class  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, & exception_handler_class, (char *)"lsh_default_handler", (size_t )sizeof(struct lsh_default_handler ),
    (void (*)(struct lsh_object *instance , void (*mark)(struct lsh_object *o ) ))((void *)0),
    (void (*)(struct lsh_object *instance ))((void *)0)};
#line 124 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static struct lsh_options *make_options(struct exception_handler *handler , int *exit_code ) 
{ 
  struct lsh_options *self ;
  struct lsh_object *tmp ;
  char const   *home ;
  char *tmp___0 ;
  struct randomness *r ;
  struct randomness *tmp___1 ;
  struct alist *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 128
  tmp = lsh_object_alloc(& lsh_options_class);
  }
#line 128
  self = (struct lsh_options *)tmp;
  {
#line 129
  tmp___0 = getenv("HOME");
  }
#line 129
  home = (char const   *)tmp___0;
  {
#line 130
  tmp___1 = make_user_random(home);
  }
#line 130
  r = tmp___1;
  {
#line 132
  init_client_options(& self->super, r, handler, exit_code);
  }
  {
#line 135
  tmp___2 = all_symmetric_algorithms();
  }
  {
#line 135
  self->algorithms = make_algorithms_options(tmp___2);
  }
#line 136
  self->home = home;
  {
#line 139
  self->signature_algorithms = all_signature_algorithms(r);
  }
#line 141
  self->sloppy = 0;
#line 142
  self->capture = (char const   *)((void *)0);
#line 143
  self->capture_file = (struct abstract_write *)((void *)0);
#line 145
  self->known_hosts = (char const   *)((void *)0);
#line 147
  self->start_gateway = 0;
#line 149
  self->with_publickey = 1;
#line 151
  self->with_srp_keyexchange = 0;
#line 154
  self->with_dh_keyexchange = -1;
#line 156
  self->kex_algorithms = (struct int_list *)((void *)0);
  }
#line 158
  return (self);
}
}
#line 164 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static struct spki_context *read_known_hosts(struct lsh_options *options ) 
{ 
  struct lsh_string *tmp ;
  char const   *s ;
  struct lsh_string *contents ;
  int fd ;
  struct spki_iterator i ;
  struct spki_context *context ;
  char const   *sexp_conv ;
  char *tmp___0 ;
  char const   *args[4] ;
  struct stat sbuf ;
  struct lsh_string *known_hosts ;
  struct lsh_string *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  uint8_t const   *tmp___7 ;
  uint32_t tmp___8 ;
  enum spki_type tmp___9 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;

  {
  {
#line 167
  tmp = (struct lsh_string *)((void *)0);
  {
#line 173
  tmp___0 = getenv("SEXP_CONV");
  }
#line 173
  sexp_conv = (char const   *)tmp___0;
#line 174
  args[0] = "sexp-conv";
#line 174
  args[1] = "-s";
#line 174
  args[2] = "canonical";
#line 174
  args[3] = (char const   *)((void *)0);
  {
#line 176
  context = make_spki_context(options->signature_algorithms);
  }
  }
#line 178
  if (options->known_hosts) {
    {
#line 180
    s = options->known_hosts;
    {
#line 181
    fd = open(s, 0);
    }
    }
  } else {
    {
    {
#line 185
    tmp = ssh_format("%lz/.lsh/host-acls", options->home);
    }
    {
#line 186
    s = lsh_get_cstring((struct lsh_string  const  *)tmp);
    }
    {
#line 187
    fd = open(s, 0);
    }
    }
#line 189
    if (fd < 0) {
      {
      {
#line 192
      tmp___1 = ssh_format("%lz/.lsh/known_hosts", options->home);
      }
#line 192
      known_hosts = tmp___1;
      {
#line 195
      tmp___2 = lsh_get_cstring((struct lsh_string  const  *)known_hosts);
      }
      {
#line 195
      tmp___3 = stat((char const   */* __restrict  */)tmp___2, (struct stat */* __restrict  */)(& sbuf));
      }
      }
#line 195
      if (tmp___3 == 0) {
        {
        {
#line 197
        werror("You have an old known-hosts file `%S\'.\nTo work with lsh-2.0, run the lsh-upgrade script,\nwhich will convert that to a new host-acls file.\n",
               tmp);
        }
        }
      }
      {
      {
#line 202
      lsh_string_free((struct lsh_string  const  *)known_hosts);
      }
      }
    }
  }
#line 206
  if (fd < 0) {
    {
    {
#line 208
    tmp___4 = __errno_location();
    }
    {
#line 208
    werror("Failed to open `%z\' for reading %e\n", s, *tmp___4);
    }
    {
#line 209
    lsh_string_free((struct lsh_string  const  *)tmp);
    }
    }
#line 211
    return (context);
  }
  {
  {
#line 214
  lsh_string_free((struct lsh_string  const  *)tmp);
  }
  }
#line 216
  if (! sexp_conv) {
#line 217
    sexp_conv = "/usr/local/bin/sexp-conv";
  }
  {
  {
#line 219
  contents = lsh_popen_read(sexp_conv, args, fd, 5000U);
  }
  }
#line 221
  if (! contents) {
    {
    {
#line 223
    tmp___5 = __errno_location();
    }
    {
#line 223
    werror("Failed to read host-acls file %e\n", *tmp___5);
    }
    {
#line 224
    close(fd);
    }
    }
#line 225
    return (context);
  }
  {
  {
#line 228
  close(fd);
  }
  {
#line 232
  tmp___7 = lsh_string_data((struct lsh_string  const  *)contents);
  }
  {
#line 232
  tmp___8 = lsh_string_length((struct lsh_string  const  *)contents);
  }
  {
#line 232
  tmp___9 = spki_iterator_first(& i, tmp___8, tmp___7);
  }
  }
#line 232
  if (tmp___9) {
    {
    {
#line 236
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;

#line 236
      if (! ((unsigned int )i.type != 28U)) {
#line 236
        goto while_break;
      }
      {
      {
#line 238
      tmp___6 = spki_add_acl(context, & i);
      }
      }
#line 238
      if (! tmp___6) {
        {
        {
#line 240
        werror("read_known_hosts: Invalid ACL.\n");
        }
        }
#line 241
        goto while_break;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
    {
#line 233
    werror("read_known_hosts: S-expression syntax error.\n");
    }
    }
  }
  {
  {
#line 244
  lsh_string_free((struct lsh_string  const  *)contents);
  }
  }
#line 245
  return (context);
}
}
#line 249 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static struct object_list *read_user_keys(struct lsh_options *options ) 
{ 
  struct lsh_string *tmp ;
  struct lsh_string *contents ;
  char const   *name ;
  int fd ;
  int algorithm_name ;
  struct signer *s ;
  struct verifier *v ;
  struct lsh_string *spki_public ;
  struct object_list *tmp___0 ;
  int *tmp___1 ;
  struct object_list *tmp___2 ;
  int *tmp___3 ;
  struct object_list *tmp___4 ;
  struct alist *mac ;
  struct alist *tmp___5 ;
  struct alist *crypto ;
  struct alist *tmp___6 ;
  struct object_list *tmp___7 ;
  struct object_list *tmp___8 ;
  struct keypair *tmp___9 ;
  struct lsh_string *tmp___10 ;
  struct keypair *tmp___11 ;
  struct object_list *tmp___12 ;
  struct keypair *tmp___13 ;
  struct lsh_string *tmp___14 ;
  struct keypair *tmp___15 ;
  struct object_list *tmp___16 ;
  struct keypair *tmp___17 ;
  struct object_list *tmp___18 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
  {
#line 252
  tmp = (struct lsh_string *)((void *)0);
#line 254
  name = (char const   *)((void *)0);
  {
#line 262
  trace("read_user_keys\n");
  }
  }
#line 264
  if (! options->with_publickey) {
    {
    {
#line 265
    tmp___0 = make_object_list(0U, -1);
    }
    }
#line 265
    return (tmp___0);
  }
#line 267
  if (options->identity) {
#line 268
    name = (char const   *)options->identity;
  } else {
    {
    {
#line 271
    tmp = ssh_format("%lz/.lsh/identity", options->home);
    }
    {
#line 272
    name = lsh_get_cstring((struct lsh_string  const  *)tmp);
    }
    }
  }
  {
  {
#line 275
  fd = open(name, 0);
  }
  }
#line 276
  if (fd < 0) {
    {
    {
#line 278
    tmp___1 = __errno_location();
    }
    {
#line 278
    verbose("Failed to open `%z\' for reading %e\n", name, *tmp___1);
    }
    {
#line 279
    lsh_string_free((struct lsh_string  const  *)tmp);
    }
    {
#line 281
    tmp___2 = make_object_list(0U, -1);
    }
    }
#line 281
    return (tmp___2);
  }
  {
  {
#line 284
  lsh_string_free((struct lsh_string  const  *)tmp);
  }
  {
#line 286
  contents = io_read_file_raw(fd, (uint32_t )2000);
  }
  }
#line 288
  if (! contents) {
    {
    {
#line 290
    tmp___3 = __errno_location();
    }
    {
#line 290
    werror("Failed to read private key file %e\n", *tmp___3);
    }
    {
#line 291
    close(fd);
    }
    {
#line 293
    tmp___4 = make_object_list(0U, -1);
    }
    }
#line 293
    return (tmp___4);
  }
  {
  {
#line 296
  close(fd);
  }
  }
#line 298
  if (options->super.tty) {
    {
    {
#line 300
    tmp___5 = make_linear_alist(0U, -1);
    }
#line 300
    mac = tmp___5;
    {
#line 301
    tmp___6 = make_linear_alist(0U, -1);
    }
#line 301
    crypto = tmp___6;
    {
#line 303
    alist_select_l(mac, (options->algorithms)->algorithms, 2U, 30, 32, -1);
    }
    {
#line 305
    alist_select_l(crypto, (options->algorithms)->algorithms, 4U, 3, 5, 8, 14, -1);
    }
    {
#line 309
    contents = spki_pkcs5_decrypt(mac, crypto, options->super.tty, contents);
    }
    }
#line 312
    if (! contents) {
      {
      {
#line 314
      werror("Decrypting private key failed.\n");
      }
      {
#line 315
      tmp___7 = make_object_list(0U, -1);
      }
      }
#line 315
      return (tmp___7);
    }
  }
  {
  {
#line 319
  s = spki_make_signer(options->signature_algorithms, (struct lsh_string  const  *)contents,
                       & algorithm_name);
  }
  {
#line 322
  lsh_string_free((struct lsh_string  const  *)contents);
  }
  }
#line 324
  if (! s) {
    {
    {
#line 326
    werror("Invalid private key.\n");
    }
    {
#line 327
    tmp___8 = make_object_list(0U, -1);
    }
    }
#line 327
    return (tmp___8);
  }
  {
  {
#line 330
  v = (*(s->get_verifier))(s);
  }
  }
#line 331
  if (! v) {
    {
    {
#line 331
    __assert_fail("v", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c", 331U, "read_user_keys");
    }
    }
  }
  {
  {
#line 333
  spki_public = (*(v->public_spki_key))(v, 0);
  }
  }
#line 338
  if (algorithm_name == 87) {
#line 338
    goto case_87;
  }
#line 349
  if (algorithm_name == 96) {
#line 349
    goto case_96;
  }
#line 349
  if (algorithm_name == 95) {
#line 349
    goto case_96;
  }
#line 358
  if (algorithm_name == 97) {
#line 358
    goto case_97;
  }
#line 364
  goto switch_default;
  case_87: 
  {
  {
#line 339
  tmp___9 = make_keypair((uint32_t )41, spki_public, s);
  }
  {
#line 339
  tmp___10 = (*(v->public_key))(v);
  }
  {
#line 339
  tmp___11 = make_keypair((uint32_t )36, tmp___10, s);
  }
  {
#line 339
  tmp___12 = make_object_list(2U, tmp___11, tmp___9, -1);
  }
  }
#line 339
  return (tmp___12);
#line 346
  goto switch_break;
  case_96: 
  {
  {
#line 350
  tmp___13 = make_keypair((uint32_t )40, spki_public, s);
  }
  {
#line 350
  tmp___14 = (*(v->public_key))(v);
  }
  {
#line 350
  tmp___15 = make_keypair((uint32_t )37, tmp___14, s);
  }
  {
#line 350
  tmp___16 = make_object_list(2U, tmp___15, tmp___13, -1);
  }
  }
#line 350
  return (tmp___16);
  case_97: 
  {
  {
#line 359
  tmp___17 = make_keypair((uint32_t )40, spki_public, s);
  }
  {
#line 359
  tmp___18 = make_object_list(1U, tmp___17, -1);
  }
  }
#line 359
  return (tmp___18);
  switch_default: 
  {
  {
#line 365
  fatal("Internal error!\n");
  }
  }
  switch_break: ;
#line 367
  return ((struct object_list *)0);
}
}
#line 389 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static struct verifier *do_lsh_lookup(struct lookup_verifier *c , int method , struct lsh_user *keyholder  __attribute__((__unused__)) ,
                                      struct lsh_string *key ) 
{ 
  struct lsh_host_db *self ;
  struct spki_principal *subject ;
  struct lsh_string *spki_key ;
  struct verifier *v ;
  struct verifier *tmp ;
  uint8_t const   *tmp___0 ;
  uint32_t tmp___1 ;
  struct lsh_string *spki_key___0 ;
  struct verifier *v___0 ;
  struct verifier *tmp___2 ;
  uint8_t const   *tmp___3 ;
  uint32_t tmp___4 ;
  uint8_t const   *tmp___5 ;
  uint32_t tmp___6 ;
  struct lsh_string *acl ;
  struct spki_iterator i ;
  struct lsh_string *fingerprint ;
  struct lsh_string *tmp___7 ;
  struct lsh_string *tmp___8 ;
  struct lsh_string *tmp___9 ;
  struct lsh_string *babble ;
  struct lsh_string *tmp___10 ;
  struct lsh_string *tmp___11 ;
  struct lsh_string *tmp___12 ;
  int tmp___13 ;
  uint8_t const   *tmp___14 ;
  uint32_t tmp___15 ;
  uint8_t const   *tmp___16 ;
  uint32_t tmp___17 ;
  enum spki_type tmp___18 ;
  uint8_t const   *tmp___19 ;
  uint32_t tmp___20 ;
  struct lsh_string *tmp___21 ;
  struct lsh_string *tmp___22 ;
  time_t tmp___23 ;
  int tmp___24 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  void *__cil_tmp103 ;
  void *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;

  {
#line 395
  self = (struct lsh_host_db *)c;
#line 400
  if (method == 36) {
#line 400
    goto case_36;
  }
#line 421
  if (method == 37) {
#line 421
    goto case_37;
  }
#line 444
  if (method == 41) {
#line 444
    goto case_41;
  }
#line 444
  if (method == 40) {
#line 444
    goto case_41;
  }
#line 459
  goto switch_default;
  case_36: 
  {
  {
#line 403
  tmp = make_ssh_dss_verifier((struct lsh_string  const  *)key);
  }
#line 403
  v = tmp;
  }
#line 405
  if (! v) {
    {
    {
#line 407
    werror("do_lsh_lookup: Invalid ssh-dss key.\n");
    }
    }
#line 408
    return ((struct verifier *)((void *)0));
  }
  {
  {
#line 412
  spki_key = (*(v->public_spki_key))(v, 0);
  }
  {
#line 414
  tmp___0 = lsh_string_data((struct lsh_string  const  *)spki_key);
  }
  {
#line 414
  tmp___1 = lsh_string_length((struct lsh_string  const  *)spki_key);
  }
  {
#line 414
  subject = spki_lookup(self->db, tmp___1, tmp___0, v);
  }
  }
#line 415
  if (! subject) {
    {
    {
#line 415
    __assert_fail("subject", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c", 415U,
                  "do_lsh_lookup");
    }
    }
  }
#line 416
  if (! subject->verifier) {
    {
    {
#line 416
    __assert_fail("subject->verifier", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c",
                  416U, "do_lsh_lookup");
    }
    }
  }
  {
  {
#line 418
  lsh_string_free((struct lsh_string  const  *)spki_key);
  }
  }
#line 419
  goto switch_break;
  case_37: 
  {
  {
#line 424
  tmp___2 = make_ssh_rsa_verifier((struct lsh_string  const  *)key);
  }
#line 424
  v___0 = tmp___2;
  }
#line 426
  if (! v___0) {
    {
    {
#line 428
    werror("do_lsh_lookup: Invalid ssh-rsa key.\n");
    }
    }
#line 429
    return ((struct verifier *)((void *)0));
  }
  {
  {
#line 433
  spki_key___0 = (*(v___0->public_spki_key))(v___0, 0);
  }
  {
#line 434
  tmp___3 = lsh_string_data((struct lsh_string  const  *)spki_key___0);
  }
  {
#line 434
  tmp___4 = lsh_string_length((struct lsh_string  const  *)spki_key___0);
  }
  {
#line 434
  subject = spki_lookup(self->db, tmp___4, tmp___3, v___0);
  }
  }
#line 435
  if (! subject) {
    {
    {
#line 435
    __assert_fail("subject", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c", 435U,
                  "do_lsh_lookup");
    }
    }
  }
#line 436
  if (! subject->verifier) {
    {
    {
#line 436
    __assert_fail("subject->verifier", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c",
                  436U, "do_lsh_lookup");
    }
    }
  }
  {
  {
#line 438
  lsh_string_free((struct lsh_string  const  *)spki_key___0);
  }
  }
#line 439
  goto switch_break;
  case_41: 
  {
  {
#line 446
  tmp___5 = lsh_string_data((struct lsh_string  const  *)key);
  }
  {
#line 446
  tmp___6 = lsh_string_length((struct lsh_string  const  *)key);
  }
  {
#line 446
  subject = spki_lookup(self->db, tmp___6, tmp___5, (struct verifier *)((void *)0));
  }
  }
#line 447
  if (! subject) {
    {
    {
#line 449
    werror("do_lsh_lookup: Invalid spki key.\n");
    }
    }
#line 450
    return ((struct verifier *)((void *)0));
  }
#line 452
  if (! subject->verifier) {
    {
    {
#line 454
    werror("do_lsh_lookup: Valid SPKI subject, but no key available.\n");
    }
    }
#line 455
    return ((struct verifier *)((void *)0));
  }
#line 457
  goto switch_break;
  switch_default: 
  {
  {
#line 460
  werror("do_lsh_lookup: Unknown key type. Should not happen!\n");
  }
  }
#line 461
  return ((struct verifier *)((void *)0));
  switch_break: ;
#line 464
  if (! subject->key) {
    {
    {
#line 464
    __assert_fail("subject->key", "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c",
                  464U, "do_lsh_lookup");
    }
    }
  }
  {
  {
#line 468
  tmp___23 = time((time_t *)((void *)0));
  }
  {
#line 468
  tmp___24 = spki_authorize(self->db, (struct spki_principal  const  *)subject, tmp___23,
                            (struct lsh_string  const  *)self->access);
  }
  }
#line 468
  if (tmp___24) {
    {
    {
#line 470
    verbose("SPKI host authorization successful!\n");
    }
    }
  } else {
    {
    {
#line 477
    verbose("SPKI authorization failed.\n");
    }
    }
#line 478
    if (! self->sloppy) {
      {
      {
#line 480
      werror("Server\'s hostkey is not trusted. Disconnecting.\n");
      }
      }
#line 481
      return ((struct verifier *)((void *)0));
    }
#line 485
    if (! quiet_flag) {
      {
      {
#line 494
      tmp___7 = hash_string(& crypto_md5_algorithm, (struct lsh_string  const  *)key,
                            0);
      }
      {
#line 494
      tmp___8 = ssh_format("%lfxS", tmp___7);
      }
      {
#line 494
      tmp___9 = lsh_string_colonize((struct lsh_string  const  *)tmp___8, 2, 1);
      }
#line 494
      fingerprint = tmp___9;
      {
#line 505
      tmp___10 = hash_string(& crypto_sha1_algorithm, (struct lsh_string  const  *)key,
                             0);
      }
      {
#line 505
      tmp___11 = lsh_string_bubblebabble((struct lsh_string  const  *)tmp___10, 1);
      }
#line 505
      babble = tmp___11;
      {
#line 513
      tmp___12 = ssh_format("Received unauthenticated key for host %lz\nKey details:\nBubble Babble: %lfS\nFingerprint:   %lfS\nDo you trust this key? (y/n) ",
                            self->host, babble, fingerprint);
      }
      {
#line 513
      tmp___13 = (*((self->tty)->yes_or_no))(self->tty, (struct lsh_string  const  *)tmp___12,
                                             0, 1);
      }
      }
#line 513
      if (! tmp___13) {
#line 522
        return ((struct verifier *)((void *)0));
      }
    }
    {
    {
#line 525
    tmp___14 = lsh_string_data((struct lsh_string  const  *)self->access);
    }
    {
#line 525
    tmp___15 = lsh_string_length((struct lsh_string  const  *)self->access);
    }
    {
#line 525
    acl = lsh_string_format_sexp(0, "(acl(entry(subject%l)%l))", subject->key_length,
                                 subject->key, tmp___15, tmp___14);
    }
    {
#line 530
    tmp___16 = lsh_string_data((struct lsh_string  const  *)acl);
    }
    {
#line 530
    tmp___17 = lsh_string_length((struct lsh_string  const  *)acl);
    }
    {
#line 530
    tmp___18 = spki_iterator_first(& i, tmp___17, tmp___16);
    }
    }
#line 530
    if (! tmp___18) {
      {
      {
#line 531
      fatal("Internal error.\n");
      }
      }
    }
    {
    {
#line 534
    spki_add_acl(self->db, & i);
    }
    }
#line 537
    if (self->file) {
      {
      {
#line 539
      tmp___19 = lsh_string_data((struct lsh_string  const  *)acl);
      }
      {
#line 539
      tmp___20 = lsh_string_length((struct lsh_string  const  *)acl);
      }
      {
#line 539
      tmp___21 = lsh_string_format_sexp(1, "%l", tmp___20, tmp___19);
      }
      {
#line 539
      tmp___22 = ssh_format("\n; ACL for host %lz\n%lfS\n", self->host, tmp___21);
      }
      {
#line 539
      (*((self->file)->write))(self->file, tmp___22);
      }
      {
#line 544
      lsh_string_free((struct lsh_string  const  *)acl);
      }
      }
    }
  }
#line 548
  return ((struct verifier *)subject->verifier);
}
}
#line 551 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static struct lookup_verifier *make_lsh_host_db(struct spki_context *db , struct interact *tty ,
                                                char const   *host , int sloppy ,
                                                struct abstract_write *file ) 
{ 
  struct lsh_host_db *res ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 558
  tmp = lsh_object_alloc(& lsh_host_db_class);
  }
#line 558
  res = (struct lsh_host_db *)tmp;
#line 560
  res->super.lookup = & do_lsh_lookup;
#line 561
  res->db = db;
#line 562
  res->tty = tty;
  {
#line 563
  res->access = make_ssh_hostkey_tag(host);
  }
#line 564
  res->host = host;
#line 565
  res->sloppy = sloppy;
#line 566
  res->file = file;
#line 567
  res->hash = & crypto_sha1_algorithm;
  }
#line 569
  return (& res->super);
}
}
#line 572 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static struct command *make_lsh_login(struct lsh_options *options , struct object_list *keys ) 
{ 
  struct client_userauth_method *password ;
  struct client_userauth_method *tmp ;
  struct client_userauth_method *kbdinteract ;
  struct client_userauth_method *tmp___0 ;
  struct client_userauth_method *none ;
  struct client_userauth_method *tmp___1 ;
  struct object_list *methods ;
  struct client_userauth_method *tmp___2 ;
  struct lsh_string *tmp___3 ;
  struct command *tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 576
  tmp = make_client_password_auth(options->super.tty);
  }
#line 576
  password = tmp;
  {
#line 579
  tmp___0 = make_client_kbdinteract_auth(options->super.tty);
  }
#line 579
  kbdinteract = tmp___0;
  {
#line 583
  tmp___1 = make_client_none_auth();
  }
#line 583
  none = tmp___1;
  }
#line 587
  if (keys->super.length) {
    {
    {
#line 588
    tmp___2 = make_client_publickey_auth(keys);
    }
    {
#line 588
    methods = make_object_list(4U, none, tmp___2, password, kbdinteract, -1);
    }
    }
  } else {
    {
    {
#line 595
    methods = make_object_list(3U, none, password, kbdinteract, -1);
    }
    }
  }
  {
  {
#line 597
  tmp___3 = ssh_format("%lz", options->super.user);
  }
  {
#line 597
  tmp___4 = make_client_userauth(tmp___3, 46, methods);
  }
  }
#line 597
  return (tmp___4);
}
}
#line 628 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
char const   *argp_program_version  =    "lsh-2.0.4, secsh protocol version 2.0";
#line 631 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
char const   *argp_program_bug_address  =    "<bug-lsh@gnu.org>";
#line 652 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static struct argp_option  const  main_options[16]  = 
#line 652
  {      {"identity", 'i', "Identity key", 0, "Use this key to authenticate.", 0}, 
        {"publickey", 513, (char const   *)((void *)0), 0, "Try publickey user authentication (default).",
      0}, 
        {"no-publickey", 1537, (char const   *)((void *)0), 0, "Don\'t try publickey user authentication.",
      0}, 
        {"host-db", 517, "Filename", 0, "By default, ~/.lsh/host-acls", 0}, 
        {"sloppy-host-authentication", 514, (char const   *)((void *)0), 0, "Allow untrusted hostkeys.",
      0}, 
        {"strict-host-authentication", 515, (char const   *)((void *)0), 0, "Never, never, ever trust an unknown hostkey. (default)",
      0}, 
        {"capture-to", 516, "File", 0, "When a new hostkey is received, append an ACL expressing trust in the key. In sloppy mode, the default is ~/.lsh/captured_keys.",
      0}, 
        {"srp-keyexchange", 519, (char const   *)((void *)0), 0, "Enable experimental SRP support.",
      0}, 
        {"no-srp-keyexchange", 1543, (char const   *)((void *)0), 0, "Disable experimental SRP support (default).",
      0}, 
        {"dh-keyexchange", 518, (char const   *)((void *)0), 0, "Enable DH support (default, unless SRP is being used).",
      0}, 
        {"no-dh-keyexchange", 1542, (char const   *)((void *)0), 0, "Disable DH support.",
      0}, 
        {"forward-remote-port", 'R', "remote-port:target-host:target-port", 0, "", 100}, 
        {"gateway",
      'G', (char const   *)((void *)0), 0, "Setup a local gateway", 0}, 
        {"x11-forward", 'x', (char const   *)((void *)0), 0, "Enable X11 forwarding.",
      200}, 
        {"no-x11-forward", 1144, (char const   *)((void *)0), 0, "Disable X11 forwarding (default).",
      0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (char const   *)((void *)0),
      0}};
#line 698 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static struct argp_child  const  main_argp_children[4]  = {      {& client_argp, 0, "", 0}, 
        {& algorithms_argp, 0, "", 0}, 
        {& werror_argp, 0, "", 0}, 
        {(struct argp  const  *)((void *)0), 0, (char const   *)((void *)0), 0}};
#line 815
static error_t main_argp_parser(int key , char *arg , struct argp_state *state ) ;
#line 815 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static struct report_exception_info  const  report___0  =    {{(struct lsh_object *)((void *)0), (struct lsh_class *)((void *)0), (char)1, (char)0,
     (char)0}, (uint32_t )8192, (uint32_t )8192, "Writing new ACL: "};
#line 735 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static error_t main_argp_parser(int key , char *arg , struct argp_state *state ) 
{ 
  struct lsh_options *self ;
  int i ;
  struct list_header *tmp ;
  int tmp___0 ;
  struct lsh_string *tmp___1 ;
  struct dh_method *tmp___2 ;
  struct keyexchange_algorithm *tmp___3 ;
  int tmp___4 ;
  struct dh_method *tmp___5 ;
  struct keyexchange_algorithm *tmp___6 ;
  int tmp___7 ;
  struct dh_method *tmp___8 ;
  struct keyexchange_algorithm *tmp___9 ;
  struct lsh_string *tmp___10 ;
  char const   *s ;
  struct exception_handler *tmp___11 ;
  int *tmp___12 ;
  struct local_info *gateway ;
  struct command *tmp___13 ;
  int tmp___14 ;
  uint32_t listen_port ;
  struct address_info *target ;
  int tmp___15 ;
  struct lsh_string *tmp___16 ;
  struct lsh_string *tmp___17 ;
  struct lsh_string *tmp___18 ;
  struct address_info *tmp___19 ;
  struct command *tmp___20 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  struct lsh_class *class62 ;
  unsigned int length63 ;
  size_t element_size64 ;
  struct list_header *list65 ;
  struct lsh_object *tmp66 ;
  char *__cil_tmp967 ;
  char *__cil_tmp1068 ;
  char *__cil_tmp1169 ;
  struct list_header *ret_lsh_list_alloc70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;

  {
#line 738
  self = (struct lsh_options *)state->input;
#line 744
  if (key == 16777219) {
#line 744
    goto case_16777219;
  }
#line 750
  if (key == 16777217) {
#line 750
    goto case_16777217;
  }
#line 875
  if (key == 105) {
#line 875
    goto case_105;
  }
#line 879
  if (key == 513) {
#line 879
    goto case_513;
  }
#line 879
  if (key == 1537) {
#line 879
    goto case_1537;
  }
#line 881
  if (key == 517) {
#line 881
    goto case_517;
  }
#line 885
  if (key == 514) {
#line 885
    goto case_514;
  }
#line 889
  if (key == 515) {
#line 889
    goto case_515;
  }
#line 893
  if (key == 516) {
#line 893
    goto case_516;
  }
#line 897
  if (key == 518) {
#line 897
    goto case_518;
  }
#line 897
  if (key == 1542) {
#line 897
    goto case_1542;
  }
#line 898
  if (key == 519) {
#line 898
    goto case_519;
  }
#line 898
  if (key == 1543) {
#line 898
    goto case_1543;
  }
#line 900
  if (key == 82) {
#line 900
    goto case_82;
  }
#line 919
  if (key == 71) {
#line 919
    goto case_71;
  }
#line 919
  if (key == 1095) {
#line 919
    goto case_1095;
  }
#line 921
  if (key == 120) {
#line 921
    goto case_120;
  }
#line 921
  if (key == 1144) {
#line 921
    goto case_1144;
  }
#line 742
  goto switch_default;
  switch_default: 
#line 743
  return (7);
  case_16777219: 
#line 745
  *(state->child_inputs + 0) = (void *)(& self->super);
#line 746
  *(state->child_inputs + 1) = (void *)self->algorithms;
#line 747
  *(state->child_inputs + 2) = (void *)0;
#line 748
  goto switch_break;
  case_16777217: 
#line 751
  if (self->super.inhibit_actions) {
#line 752
    goto switch_break;
  }
#line 754
  if (! self->home) {
    {
    {
#line 756
    argp_error((struct argp_state  const  *)state, "No home directory. Please set HOME in the environment.");
    }
    }
#line 757
    goto switch_break;
  }
#line 760
  if (! self->super.random) {
    {
    {
#line 761
    argp_failure((struct argp_state  const  *)state, 1, 0, "No randomness generator available.");
    }
    }
  }
#line 763
  if (self->with_dh_keyexchange < 0) {
#line 764
    self->with_dh_keyexchange = ! self->with_srp_keyexchange;
  }
#line 766
  if (self->with_dh_keyexchange) {
#line 766
    goto _L;
  } else
#line 766
  if (self->with_srp_keyexchange) {
    _L: 
    {
#line 768
    i = 0;
    {
#line 769
    class62 = & int_list_class;
#line 769
    length63 = (unsigned int )(2 * self->with_dh_keyexchange + self->with_srp_keyexchange);
#line 769
    element_size64 = (size_t )sizeof(int );
    {
#line 49
    if (! (element_size64 < 1024U)) {
      {
      {
#line 49 "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c"
      __assert_fail("element_size < 1024", "/home/ysko/Works/test-src/lsh-2.0.4/src/list.c",
                    49U, "lsh_list_alloc");
      }
      }
    }
    {
    {
#line 51
    tmp66 = lsh_var_alloc(class62, (class62->size + element_size64 * length63) - element_size64);
    }
#line 51
    list65 = (struct list_header *)tmp66;
#line 57
    list65->length = length63;
    }
    {
#line 59
    ret_lsh_list_alloc70 = list65;
#line 59
    goto Lret_lsh_list_alloc;
    }
    }
    Lret_lsh_list_alloc: /* CIL Label */ 
#line 769 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
    tmp = ret_lsh_list_alloc70;
    }
#line 769
    self->kex_algorithms = (struct int_list *)tmp;
    }
#line 773
    if (self->with_srp_keyexchange) {
      {
#line 775
      tmp___0 = i;
#line 775
      i ++;
#line 775
      (self->kex_algorithms)->elements[tmp___0] = 105;
      {
#line 776
      tmp___1 = ssh_format("%lz", self->super.user);
      }
      {
#line 776
      tmp___2 = make_srp1(self->super.random);
      }
      {
#line 776
      tmp___3 = make_srp_client((struct dh_method  const  *)tmp___2, self->super.tty,
                                tmp___1);
      }
      {
#line 776
      (*(((struct alist_meta *)((self->algorithms)->algorithms)->super.isa)->set))((self->algorithms)->algorithms,
                                                                                   105,
                                                                                   & tmp___3->super);
      }
      }
    }
#line 784
    if (self->with_dh_keyexchange) {
      {
#line 786
      tmp___4 = i;
#line 786
      i ++;
#line 786
      (self->kex_algorithms)->elements[tmp___4] = 35;
      {
#line 787
      tmp___5 = make_dh14(self->super.random);
      }
      {
#line 787
      tmp___6 = make_dh_client((struct dh_method  const  *)tmp___5);
      }
      {
#line 787
      (*(((struct alist_meta *)((self->algorithms)->algorithms)->super.isa)->set))((self->algorithms)->algorithms,
                                                                                   35,
                                                                                   & tmp___6->super);
      }
#line 792
      tmp___7 = i;
#line 792
      i ++;
#line 792
      (self->kex_algorithms)->elements[tmp___7] = 34;
      {
#line 793
      tmp___8 = make_dh1(self->super.random);
      }
      {
#line 793
      tmp___9 = make_dh_client((struct dh_method  const  *)tmp___8);
      }
      {
#line 793
      (*(((struct alist_meta *)((self->algorithms)->algorithms)->super.isa)->set))((self->algorithms)->algorithms,
                                                                                   34,
                                                                                   & tmp___9->super);
      }
      }
    }
  } else {
    {
    {
#line 800
    argp_error((struct argp_state  const  *)state, "All keyexchange algorithms disabled.");
    }
    }
  }
#line 803
  tmp___10 = (struct lsh_string *)((void *)0);
#line 804
  s = (char const   *)((void *)0);
#line 806
  if (self->capture) {
#line 807
    s = self->capture;
  } else
#line 808
  if (self->sloppy) {
    {
    {
#line 810
    tmp___10 = ssh_format("%lz/.lsh/captured_keys", self->home);
    }
    {
#line 811
    s = lsh_get_cstring((struct lsh_string  const  *)tmp___10);
    }
    }
  }
#line 813
  if (s) {
    {
    {
#line 819
    tmp___11 = make_report_exception_handler(& report___0, & default_exception_handler,
                                             "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c:826");
    }
    {
#line 819
    self->capture_file = io_write_file(s, 1089, 384, tmp___11);
    }
    }
#line 827
    if (! self->capture_file) {
      {
      {
#line 828
      tmp___12 = __errno_location();
      }
      {
#line 828
      werror("Failed to open \'%z\' %e.\n", s, *tmp___12);
      }
      }
    }
  }
  {
  {
#line 830
  lsh_string_free((struct lsh_string  const  *)tmp___10);
  }
  }
#line 843
  if (self->start_gateway) {
#line 846
    if (! self->super.local_user) {
      {
      {
#line 848
      argp_error((struct argp_state  const  *)state, "You have to set LOGNAME in the environment,  if you want to use the gateway feature.");
      }
      }
#line 850
      goto switch_break;
    }
    {
    {
#line 852
    gateway = make_gateway_address((char const   *)self->super.local_user, (char const   *)self->super.user,
                                   self->super.target);
    }
    }
#line 856
    if (! gateway) {
      {
      {
#line 858
      argp_error((struct argp_state  const  *)state, "Local or remote user name, or the target host name, are too strange for the gateway socket name construction.");
      }
      }
#line 860
      goto switch_break;
    }
    {
    {
#line 863
    tmp___13 = make_gateway_setup(gateway);
    }
    {
#line 863
    client_prepend_action(& self->super, tmp___13);
    }
    }
  }
  {
  {
#line 867
  tmp___14 = lsh_queue_is_empty(& self->super.actions.q);
  }
  }
#line 867
  if (tmp___14) {
    {
    {
#line 869
    argp_error((struct argp_state  const  *)state, "No actions given.");
    }
    }
#line 870
    goto switch_break;
  }
#line 873
  goto switch_break;
  case_105: 
#line 876
  self->identity = arg;
#line 877
  goto switch_break;
  case_513: 
#line 879
  if (self->super.not) {
#line 879
    self->super.not = 0;
    case_1537: 
#line 879
    self->with_publickey = 0;
#line 879
    goto switch_break;
  }
#line 879
  self->with_publickey = 1;
#line 879
  goto switch_break;
  case_517: 
#line 882
  self->known_hosts = (char const   *)arg;
#line 883
  goto switch_break;
  case_514: 
#line 886
  self->sloppy = 1;
#line 887
  goto switch_break;
  case_515: 
#line 890
  self->sloppy = 0;
#line 891
  goto switch_break;
  case_516: 
#line 894
  self->capture = (char const   *)arg;
#line 895
  goto switch_break;
  case_518: 
#line 897
  if (self->super.not) {
#line 897
    self->super.not = 0;
    case_1542: 
#line 897
    self->with_dh_keyexchange = 0;
#line 897
    goto switch_break;
  }
#line 897
  self->with_dh_keyexchange = 1;
#line 897
  goto switch_break;
  case_519: 
#line 898
  if (self->super.not) {
#line 898
    self->super.not = 0;
    case_1543: 
#line 898
    self->with_srp_keyexchange = 0;
#line 898
    goto switch_break;
  }
#line 898
  self->with_srp_keyexchange = 1;
#line 898
  goto switch_break;
  case_82: 
  {
  {
#line 905
  tmp___15 = client_parse_forward_arg(arg, & listen_port, & target);
  }
  }
#line 905
  if (! tmp___15) {
    {
    {
#line 906
    argp_error((struct argp_state  const  *)state, "Invalid forward specification \'%s\'.",
               arg);
    }
    }
  }
#line 908
  if (self->super.with_remote_peers) {
    {
    {
#line 908
    tmp___16 = ssh_format("%lz", "0.0.0.0");
    }
#line 908
    tmp___18 = tmp___16;
    }
  } else {
    {
    {
#line 908
    tmp___17 = ssh_format("%lz", "127.0.0.1");
    }
#line 908
    tmp___18 = tmp___17;
    }
  }
  {
  {
#line 908
  tmp___19 = make_address_info(tmp___18, listen_port);
  }
  {
#line 908
  tmp___20 = make_forward_remote_port(tmp___19, target);
  }
  {
#line 908
  client_add_action(& self->super, tmp___20);
  }
#line 915
  self->super.remote_forward = 1;
  }
#line 916
  goto switch_break;
  case_71: 
#line 919
  if (self->super.not) {
#line 919
    self->super.not = 0;
    case_1095: 
#line 919
    self->start_gateway = 0;
#line 919
    goto switch_break;
  }
#line 919
  self->start_gateway = 1;
#line 919
  goto switch_break;
  case_120: 
#line 921
  if (self->super.not) {
#line 921
    self->super.not = 0;
    case_1144: 
#line 921
    self->super.with_x11 = 0;
#line 921
    goto switch_break;
  }
#line 921
  self->super.with_x11 = 1;
#line 921
  goto switch_break;
  switch_break: ;
#line 925
  return (0);
}
}
#line 928 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static struct argp  const  main_argp  =    {main_options, & main_argp_parser, "host\nhost command ...", "Connects to a remote machine\vConnects to the remote machine, and then performs one or more actions, i.e. command execution, various forwarding services. The default action is to start a remote interactive shell or execute a given command on the remote machine.",
    main_argp_children, (char *(*)(int __key , char const   *__text , void *__input ))((void *)0),
    (char const   *)((void *)0)};
#line 950 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static void do_lsh_default_handler(struct exception_handler *s , struct exception  const  *e ) 
{ 
  struct lsh_default_handler *self ;
  struct io_exception *exc ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 954
  self = (struct lsh_default_handler *)s;
#line 956
  if (e->type & 8192U) {
    {
#line 958
    exc = (struct io_exception *)e;
#line 959
    *(self->status) = 1;
    {
#line 961
    werror("%z, (errno = %i)\n", e->msg, exc->error);
    }
    }
  } else {
#line 970
    if (e->type == 32771U) {
#line 970
      goto case_32771;
    }
#line 970
    if (e->type == 32770U) {
#line 970
      goto case_32771;
    }
#line 970
    if (e->type == 32769U) {
#line 970
      goto case_32771;
    }
#line 970
    if (e->type == 16385U) {
#line 970
      goto case_32771;
    }
#line 970
    if (e->type == 131073U) {
#line 970
      goto case_32771;
    }
#line 975
    goto switch_default;
    case_32771: 
    {
    {
#line 972
    werror("%z\n", e->msg);
    }
#line 973
    *(self->status) = 1;
    }
#line 974
    goto switch_break;
    switch_default: 
    {
#line 976
    *(self->status) = 1;
    {
#line 977
    (*((self->super.parent)->raise))(self->super.parent, e);
    }
    }
    switch_break: ;
  }
#line 979
  return;
}
}
#line 981 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
static struct exception_handler *make_lsh_default_handler(int *status , struct exception_handler *parent ,
                                                          char const   *context ) 
{ 
  struct lsh_default_handler *self ;
  struct lsh_object *tmp ;

  {
  {
  {
#line 985
  tmp = lsh_object_alloc(& lsh_default_handler_class);
  }
#line 985
  self = (struct lsh_default_handler *)tmp;
#line 986
  self->super.parent = parent;
#line 987
  self->super.raise = & do_lsh_default_handler;
#line 988
  self->super.context = context;
#line 990
  self->status = status;
  }
#line 992
  return (& self->super);
}
}
#line 996 "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c"
int main(int argc , char **argv , char const   **envp ) 
{ 
  struct lsh_options *options ;
  struct spki_context *spki ;
  struct object_list *keys ;
  struct connect_list_state *remote ;
  struct command *lsh_connect ;
  int lsh_exit_code ;
  struct exception_handler *handler ;
  struct exception_handler *tmp ;
  unsigned int tmp___0 ;
  struct command *tmp___1 ;
  struct object_list *tmp___2 ;
  struct lookup_verifier *tmp___3 ;
  struct int_list *tmp___4 ;
  struct make_kexinit *tmp___5 ;
  struct handshake_info *tmp___6 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 1005
  lsh_exit_code = 17;
  {
#line 1007
  tmp = make_lsh_default_handler(& lsh_exit_code, & default_exception_handler, "/home/ysko/Works/test-src/lsh-2.0.4/src/lsh.c:1009");
  }
#line 1007
  handler = tmp;
  {
#line 1011
  io_init();
  }
  {
#line 1015
  setlocale(0, "");
  }
  {
#line 1018
  set_local_charset(1);
  }
  {
#line 1020
  options = make_options(handler, & lsh_exit_code);
  }
  }
#line 1022
  if (! options) {
#line 1023
    return (1);
  }
  {
  {
#line 1025
  envp_parse(& main_argp, envp, "LSHFLAGS=", 8U, (void *)options);
  }
  {
#line 1026
  argp_parse(& main_argp, argc, argv, 8U, (int *)((void *)0), (void *)options);
  }
  }
#line 1028
  if (! options->super.random) {
    {
    {
#line 1030
    werror("Failed to initialize randomness generator.\n");
    }
    }
#line 1031
    return (1);
  }
  {
  {
#line 1034
  remote = make_connect_list_state();
  }
  {
#line 1036
  tmp___0 = io_resolv_address(options->super.target, options->super.port, 22U, & remote->q);
  }
  }
#line 1036
  if (! tmp___0) {
    {
    {
#line 1040
    werror("Could not resolv address `%z\'\n", options->super.target);
    }
    }
#line 1041
    return (1);
  }
  {
  {
#line 1044
  spki = read_known_hosts(options);
  }
  {
#line 1045
  keys = read_user_keys(options);
  }
  {
#line 1047
  tmp___1 = make_lsh_login(options, keys);
  }
  {
#line 1047
  tmp___2 = queue_to_list(& options->super.actions);
  }
  {
#line 1047
  tmp___3 = make_lsh_host_db(spki, options->super.tty, options->super.target, options->sloppy,
                             options->capture_file);
  }
  {
#line 1047
  tmp___4 = make_int_list(0U, -1);
  }
  {
#line 1047
  tmp___5 = make_simple_kexinit(options->super.random, options->kex_algorithms, (options->algorithms)->hostkey_algorithms,
                                (options->algorithms)->crypto_algorithms, (options->algorithms)->mac_algorithms,
                                (options->algorithms)->compression_algorithms, tmp___4);
  }
  {
#line 1047
  tmp___6 = make_handshake_info((enum connection_flag )0, "lsh - a GNU ssh", (char const   *)((void *)0),
                                (uint32_t )32768, options->super.random, (options->algorithms)->algorithms,
                                tmp___5, (struct lsh_string *)((void *)0));
  }
  {
#line 1047
  lsh_connect = make_lsh_connect(& (options->super.resources)->super, tmp___6, tmp___3,
                                 tmp___2, tmp___1);
  }
  {
#line 1072
  (*(lsh_connect->call))(lsh_connect, (struct lsh_object *)remote, & discard_continuation,
                         handler);
  }
  {
#line 1075
  io_run();
  }
  {
#line 1078
  io_final();
  }
  }
#line 1082
  return (lsh_exit_code);
}
}
