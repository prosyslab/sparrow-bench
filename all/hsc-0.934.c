/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/utypes.h"
typedef unsigned long ULONG;
#line 52 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/utypes.h"
typedef char *STRPTR;
#line 57 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/utypes.h"
typedef short BOOL;
#line 85 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/utypes.h"
typedef char const   *CONSTRPTR;
#line 47 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.h"
struct __anonstruct_EXPSTR_26 {
   STRPTR es_data ;
   size_t es_len ;
   size_t es_size ;
   size_t es_step ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.h"
typedef struct __anonstruct_EXPSTR_26 EXPSTR;
#line 41 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/utypes.h"
typedef long LONG;
#line 55 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/utypes.h"
typedef void VOID;
#line 86 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/utypes.h"
typedef char STRARR;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 40 "./ugly/utypes.h"
typedef void *APTR;
#line 41 "./ugly/dllist.h"
struct dlnode {
   struct dlnode *prev ;
   struct dlnode *next ;
   APTR data ;
};
#line 48 "./ugly/dllist.h"
struct dllist {
   struct dlnode *first ;
   struct dlnode *last ;
   LONG entry_num ;
   void (*del_data)(APTR data ) ;
   APTR user_data ;
};
#line 59 "./ugly/dllist.h"
typedef struct dllist DLLIST;
#line 60 "./ugly/dllist.h"
typedef struct dlnode DLNODE;
#line 43 "./ugly/infile.h"
struct infile {
   STRPTR filename ;
   FILE *infile ;
   EXPSTR *lnbuf ;
   EXPSTR *wordbuf ;
   EXPSTR *wspcbuf ;
   ULONG filepos ;
   ULONG pos_y ;
   ULONG pos_x ;
   ULONG wpos_y ;
   ULONG wpos_x ;
   ULONG base_x ;
   ULONG base_y ;
   DLLIST *pos_list ;
   ULONG pos_count ;
   BOOL (*is_ws)(int ch ) ;
   BOOL (*is_nc)(int ch ) ;
   BOOL eof_reached ;
   BOOL out_of_mem ;
   BOOL skipped_ws ;
   BOOL closed ;
};
#line 43 "./ugly/infile.h"
typedef struct infile INFILE;
#line 96 "./ugly/uargs.h"
union __anonunion_ai_misc1_26 {
   STRPTR ai_enum ;
   LONG ai_lolim ;
};
#line 96 "./ugly/uargs.h"
union __anonunion_ai_misc2_27 {
   LONG ai_uplim ;
};
#line 96 "./ugly/uargs.h"
struct arginfo {
   STRPTR ai_id ;
   LONG ai_type ;
   LONG ai_flags ;
   union __anonunion_ai_misc1_26 ai_misc1 ;
   union __anonunion_ai_misc2_27 ai_misc2 ;
   APTR ai_dest ;
   STRPTR (*ai_func)(STRPTR  ) ;
   STRPTR ai_help ;
   BOOL ai_set ;
};
#line 148 "./ugly/uargs.h"
struct arglist {
   STRPTR al_name ;
   struct dllist *al_list ;
   struct arginfo *al_multiple ;
   struct arginfo *al_nokeywd ;
};
#line 148 "./ugly/uargs.h"
typedef struct arglist ARGLIST;
#line 40 "./hscprj/document.h"
struct document_node {
   STRPTR docname ;
   STRPTR sourcename ;
   EXPSTR *title ;
   DLLIST *iddefs ;
   DLLIST *includes ;
   DLLIST *references ;
   ULONG flags ;
};
#line 40 "./hscprj/document.h"
typedef struct document_node HSCDOC;
#line 60 "./hscprj/document.h"
struct caller_node {
   STRPTR name ;
   ULONG posx ;
   ULONG posy ;
};
#line 60 "./hscprj/document.h"
typedef struct caller_node CALLER;
#line 73 "./hscprj/document.h"
struct include_node {
   STRPTR name ;
   CALLER *caller ;
};
#line 73 "./hscprj/document.h"
typedef struct include_node HSCINC;
#line 34 "./hscprj/project.h"
struct hscproject {
   HSCDOC *document ;
   DLLIST *documents ;
   INFILE *inpf ;
   BOOL debug ;
   BOOL fatal ;
   APTR user_data ;
   VOID (*CB_msg_unknown_id)(struct hscproject *hp , STRPTR document , STRPTR id ) ;
   VOID (*CB_msg_corrupt_pf)(struct hscproject *hp , STRPTR reason ) ;
};
#line 34 "./hscprj/project.h"
typedef struct hscproject HSCPRJ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/utypes.h"
typedef signed char BYTE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 50 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/utypes.h"
typedef unsigned char UBYTE;
#line 96 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/uargs.h"
typedef struct arginfo ARGINFO;
#line 114 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/uargs.h"
struct argfile {
   int argc ;
   char **argv ;
};
#line 114 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/uargs.h"
typedef struct argfile ARGFILE;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.h"
enum fcopy_e {
    FC_OK = 0,
    FC_ERR_NoMemory = 1,
    FC_ERR_OpenInput = 2,
    FC_ERR_OpenOutput = 3,
    FC_ERR_Read = 4,
    FC_ERR_Write = 5
} ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.h"
typedef enum fcopy_e fcopy_t;
#line 48
enum __anonenum_fentrytype_t_29 {
    FE_NONE = 0,
    FE_FILE = 1,
    FE_DIR = 2
} ;
#line 48 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.h"
typedef enum __anonenum_fentrytype_t_29 fentrytype_t;
#line 27 "./ugly/unikot.h"
typedef long ucs4_t;
#line 29 "./ugly/unikot.h"
typedef unsigned char utf8_t;
#line 75 "./ugly/infile.h"
struct infile_pos {
   INFILE *inpf ;
   STRPTR fname ;
   ULONG x ;
   ULONG y ;
   ULONG fpos ;
};
#line 75 "./ugly/infile.h"
typedef struct infile_pos INFILEPOS;
#line 79 "./hscprj/document.h"
struct iddef_node {
   STRPTR name ;
   CALLER *caller ;
   INFILEPOS *fpos ;
};
#line 79 "./hscprj/document.h"
typedef struct iddef_node HSCIDD;
#line 40 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.h"
struct uglymem {
   struct uglymem *next ;
   void *ptr ;
   UBYTE *lower ;
   UBYTE *upper ;
   size_t size ;
   STRPTR file ;
   ULONG line ;
   UBYTE fillchar ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.h"
typedef struct uglymem UGLYMEM;
#line 67 "./hscprj/document.h"
struct reference_node {
   STRPTR name ;
   CALLER *caller ;
};
#line 67 "./hscprj/document.h"
typedef struct reference_node HSCREF;
#line 114 "./hsclib/attrib.h"
struct hscattr {
   STRPTR name ;
   STRPTR deftext ;
   STRPTR text ;
   STRPTR enumstr ;
   ULONG macro_id ;
   ULONG varflag ;
   int quote ;
   BYTE vartype ;
};
#line 114 "./hsclib/attrib.h"
typedef struct hscattr HSCATTR;
#line 73 "./hsclib/tag.h"
struct hsc_process;
#line 78 "./hsclib/tag.h"
struct hsctag {
   STRPTR name ;
   ULONG option ;
   BOOL (*o_handle)(struct hsc_process *hp , struct hsctag *tag ) ;
   BOOL (*c_handle)(struct hsc_process *hp , struct hsctag *tag ) ;
   DLLIST *attr ;
   EXPSTR *op_text ;
   EXPSTR *cl_text ;
   STRPTR mbi ;
   STRPTR naw ;
   HSCATTR *uri_stripext ;
   HSCATTR *uri_size ;
   INFILEPOS *start_fpos ;
   INFILEPOS *end_fpos ;
   BOOL occured ;
};
#line 78 "./hsclib/tag.h"
typedef struct hsctag HSCTAG;
#line 173 "./hsclib/hscprc.h"
typedef LONG HSCMSG_ID;
#line 174 "./hsclib/hscprc.h"
typedef LONG HSCMSG_CLASS;
#line 177
enum hsc_ignore_status {
    make_my_day = 0,
    ignore = 1,
    enable = 2
} ;
#line 184 "./hsclib/hscprc.h"
typedef enum hsc_ignore_status HSCIGN;
#line 189 "./hsclib/hscprc.h"
struct hsc_process {
   INFILE *inpf ;
   DLLIST *inpf_stack ;
   DLLIST *deftag ;
   DLLIST *defattr ;
   DLLIST *defent ;
   DLLIST *deflazy ;
   DLLIST *defstyle ;
   DLLIST *container_stack ;
   DLLIST *content_stack ;
   DLLIST *include_dirs ;
   DLLIST *tag_styles ;
   HSCPRJ *project ;
   DLLIST *idrefs ;
   EXPSTR *destdir ;
   EXPSTR *reldir ;
   EXPSTR *tmpstr ;
   EXPSTR *curr_msg ;
   EXPSTR *curr_ref ;
   EXPSTR *iconbase ;
   EXPSTR *server_dir ;
   time_t start_time ;
   DLLIST *select_stack ;
   EXPSTR *if_stack ;
   EXPSTR *tag_name_str ;
   EXPSTR *tag_attr_str ;
   EXPSTR *tag_close_str ;
   STRPTR filename_document ;
   HSCIGN *msg_ignore ;
   BOOL msg_ignore_notes ;
   BOOL msg_ignore_style ;
   BOOL msg_ignore_port ;
   HSCMSG_CLASS *msg_class ;
   ULONG msg_count ;
   ULONG max_messages ;
   ULONG max_errors ;
   unsigned char *image_buffer ;
   BOOL chkid ;
   BOOL chkuri ;
   BOOL compact ;
   BOOL debug ;
   BOOL getsize ;
   BOOL htmlonly ;
   BOOL jerkvalues ;
   BOOL rplc_ent ;
   BOOL rplc_quote ;
   BOOL smart_ent ;
   BOOL strip_cmt ;
   BOOL strip_ext ;
   BOOL strip_badws ;
   BOOL weenix ;
   BOOL xhtml_emptytag ;
   BOOL suppress_output ;
   BOOL docbase_set ;
   BOOL inside_pre ;
   BOOL inside_anchor ;
   BOOL inside_title ;
   BOOL prostitute ;
   BOOL nested_errors ;
   BOOL lctags ;
   BOOL checkext ;
   BOOL xhtml ;
   BOOL validate_css ;
   BOOL fatal ;
   LONG tag_call_id ;
   ULONG prev_status_line ;
   LONG prev_heading_num ;
   LONG entitymode ;
   LONG quotemode ;
   STRPTR click_here_str ;
   STRPTR color_names ;
   STRPTR strip_tags ;
   EXPSTR *whtspc ;
   HSCTAG *tag_next_whtspc ;
   BOOL strip_next_whtspc ;
   BOOL strip_next2_whtspc ;
   VOID (*CB_status_misc)(struct hsc_process *hp , STRPTR s ) ;
   VOID (*CB_status_line)(struct hsc_process *hp ) ;
   VOID (*CB_status_file_begin)(struct hsc_process *hp , STRPTR filename ) ;
   VOID (*CB_status_file_end)(struct hsc_process *hp ) ;
   VOID (*CB_message)(struct hsc_process *hp , HSCMSG_CLASS msg_class , HSCMSG_ID msg_id ,
                      STRPTR fname , ULONG x , ULONG y , STRPTR msg_text ) ;
   VOID (*CB_message_ref)(struct hsc_process *hp , HSCMSG_CLASS msg_class , HSCMSG_ID msg_id ,
                          STRPTR fname , ULONG x , ULONG y , STRPTR msg_text ) ;
   VOID (*CB_start_tag)(struct hsc_process *hp , HSCTAG *tag , STRPTR tag_name , STRPTR tag_attr ,
                        STRPTR tag_close ) ;
   VOID (*CB_end_tag)(struct hsc_process *hp , HSCTAG *tag , STRPTR tag_name , STRPTR tag_attr ,
                      STRPTR tag_close ) ;
   VOID (*CB_text)(struct hsc_process *hp , STRPTR white_spaces , STRPTR text ) ;
   VOID (*CB_id)(struct hsc_process *hp , HSCATTR *attr , STRPTR id ) ;
};
#line 307 "./hsclib/hscprc.h"
typedef struct hsc_process HSCPRC;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 55 "./hsclib/entity.h"
struct hscent {
   STRPTR name ;
   int numeric ;
   char replace[2] ;
   char flags ;
};
#line 55 "./hsclib/entity.h"
typedef struct hscent HSCENT;
#line 130 "./hsclib/attrib.h"
struct hscstyle {
   STRPTR name ;
   STRPTR value ;
};
#line 130 "./hsclib/attrib.h"
typedef struct hscstyle HSCSTYLE;
#line 41 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
typedef BYTE if_t;
#line 33 "./hsclib/uri.h"
enum __anonenum_URIKIND_28 {
    URI_abs = 0,
    URI_ext = 1,
    URI_rel = 2,
    URI_relserv = 3
} ;
#line 33 "./hsclib/uri.h"
typedef enum __anonenum_URIKIND_28 URIKIND;
#line 3 "./hsclib/entities.c"
struct HSCENTITY {
   STRPTR name ;
   unsigned short numeric ;
   BOOL prefnum ;
};
#line 82 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
enum __anonenum_op_t_29 {
    OP_NONE = 0,
    OP_EQ = 1,
    OP_NEQ = 2,
    OP_CEQ = 3,
    OP_GT = 4,
    OP_LT = 5,
    OP_GE = 6,
    OP_LE = 7,
    OP_NUMGT = 8,
    OP_NUMLT = 9,
    OP_NUMGE = 10,
    OP_NUMLE = 11,
    OP_INSIDE = 12,
    OP_AND = 13,
    OP_NOT = 14,
    OP_OR = 15,
    OP_XOR = 16,
    OP_CAT = 17,
    OP_ADD = 18,
    OP_SUB = 19,
    OP_MUL = 20,
    OP_DIV = 21,
    OP_MOD = 22,
    OP_CL_BRACKET = 23,
    OP_CL_BRACE = 24
} ;
#line 82 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
typedef enum __anonenum_op_t_29 op_t;
#line 30 "./hsclib/idref.h"
struct idref_node {
   STRPTR name ;
   INFILEPOS *fpos ;
};
#line 30 "./hsclib/idref.h"
typedef struct idref_node IDREF;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.h"
void ugly_freestr(STRPTR s___2 , STRPTR file , ULONG line ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.h"
void *ugly_malloc_tracking(size_t size , STRPTR file , ULONG line ) ;
#line 90
void *ugly_malloc_notracking(size_t size ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.h"
EXPSTR *ugly_dbg_init_estr(size_t step_size , STRPTR file , ULONG line ) ;
#line 63
EXPSTR *ugly_init_estr(size_t step_size ) ;
#line 64
void del_estr(EXPSTR *es ) ;
#line 66
BOOL ugly_clr_estr(EXPSTR *es ) ;
#line 67
BOOL ugly_dbg_clr_estr(EXPSTR *es , STRPTR file , ULONG line ) ;
#line 68
BOOL set_estrn(EXPSTR *es , CONSTRPTR s___2 , size_t n ) ;
#line 70
BOOL ugly_set_estr(EXPSTR *es , CONSTRPTR s___2 ) ;
#line 71
BOOL ugly_app_estrch(EXPSTR *es , int ch ) ;
#line 72
BOOL ugly_app_estr(EXPSTR *es , CONSTRPTR s___2 ) ;
#line 74
BOOL ugly_dbg_set_estr(EXPSTR *es , CONSTRPTR s___2 , STRPTR file , ULONG line ) ;
#line 75
BOOL ugly_dbg_app_estrch(EXPSTR *es , int ch , STRPTR file , ULONG line ) ;
#line 76
BOOL ugly_dbg_app_estr(EXPSTR *es , CONSTRPTR s___2 , STRPTR file , ULONG line ) ;
#line 77
STRPTR ugly_estr2str(EXPSTR *es ) ;
#line 78
size_t ugly_estrlen(EXPSTR *es ) ;
#line 80
BOOL estrcpy(EXPSTR *dest , EXPSTR *src ) ;
#line 81
BOOL estrcat(EXPSTR *dest , EXPSTR *src ) ;
#line 83
BOOL get_mid_estr(EXPSTR *dest , EXPSTR *src , size_t from , size_t num ) ;
#line 84
BOOL get_right_estr(EXPSTR *dest , EXPSTR *src , size_t num ) ;
#line 85
BOOL get_left_estr(EXPSTR *dest , EXPSTR *src , size_t num ) ;
#line 122 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
static void es_null(STRPTR func , STRPTR file , ULONG line ) 
{ 


  {
  {
#line 124
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n##\n## panic: es=NULL in %s()\n##   called from %s (%lu)\n##\n",
          func, file, line);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
static void s_null(STRPTR func , STRPTR file , ULONG line ) 
{ 


  {
  {
#line 130
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n##\n## panic: string=NULL in %s()\n##   called from %s (%lu)\n##\n",
          func, file, line);
  }
#line 132
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
static BOOL do_set_estr_mem(EXPSTR *es , STRPTR new_data , size_t new_size ) 
{ 
  BOOL ok ;

  {
#line 153
  ok = (BOOL )1;
#line 155
  if (new_data) {
#line 162
    es->es_size = new_size;
#line 163
    es->es_data = new_data;
  } else {
#line 167
    ok = (BOOL )0;
  }
#line 169
  return (ok);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL ugly_set_estr_mem(EXPSTR *es , size_t new_size ) 
{ 
  void *tmp ;
  BOOL tmp___0 ;

  {
  {
#line 174
  tmp = ugly_malloc_notracking(new_size);
#line 174
  tmp___0 = do_set_estr_mem(es, (STRPTR )tmp, new_size);
  }
#line 174
  return (tmp___0);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL ugly_dbg_set_estr_mem(EXPSTR *es , size_t new_size , STRPTR file , ULONG line ) 
{ 
  BOOL ok ;
  void *tmp ;

  {
#line 179
  ok = (BOOL )0;
#line 181
  if (! es) {
    {
#line 182
    es_null((STRPTR )"set_estr_mem", file, line);
    }
  } else {
    {
#line 185
    tmp = ugly_malloc_tracking(new_size, file, line);
#line 185
    ok = do_set_estr_mem(es, (STRPTR )tmp, new_size);
    }
  }
#line 190
  return (ok);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL ugly_set_estr(EXPSTR *es , CONSTRPTR s___2 ) 
{ 
  BOOL ok ;
  size_t new_len ;
  size_t tmp ;
  STRPTR old_data ;
  BOOL tmp___0 ;

  {
  {
#line 228
  ok = (BOOL )0;
#line 229
  tmp = strlen(s___2);
#line 229
  new_len = tmp + 1UL;
#line 230
  old_data = es->es_data;
  }
#line 232
  if (es->es_size == es->es_step) {
#line 232
    if (es->es_size > new_len) {
      {
#line 235
      strcpy((char */* __restrict  */)es->es_data, (char const   */* __restrict  */)s___2);
#line 236
      es->es_len = new_len;
#line 237
      ok = (BOOL )1;
      }
    } else {
#line 232
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 239
    tmp___0 = ugly_set_estr_mem(es, es->es_step * ((new_len + es->es_step) / es->es_step));
    }
#line 239
    if (tmp___0) {
      {
#line 242
      strcpy((char */* __restrict  */)es->es_data, (char const   */* __restrict  */)s___2);
#line 243
      ugly_freestr(old_data, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c",
                   (ULONG )243);
#line 243
      old_data = (STRPTR )((void *)0);
#line 245
      es->es_len = new_len;
#line 246
      ok = (BOOL )1;
      }
    }
  }
#line 248
  return (ok);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL ugly_dbg_set_estr(EXPSTR *es , CONSTRPTR s___2 , STRPTR file , ULONG line ) 
{ 
  BOOL ok ;
  size_t new_len ;
  size_t tmp ;
  STRPTR old_data ;
  BOOL tmp___0 ;

  {
#line 253
  ok = (BOOL )0;
#line 255
  if (! es) {
    {
#line 256
    es_null((STRPTR )"set_estr_mem", file, line);
    }
  } else
#line 257
  if (! s___2) {
    {
#line 258
    s_null((STRPTR )"set_estr_mem", file, line);
    }
  } else {
    {
#line 261
    tmp = strlen(s___2);
#line 261
    new_len = tmp + 1UL;
#line 262
    old_data = es->es_data;
    }
#line 268
    if (es->es_size == es->es_step) {
#line 268
      if (es->es_size > new_len) {
        {
#line 272
        strcpy((char */* __restrict  */)es->es_data, (char const   */* __restrict  */)s___2);
#line 273
        es->es_len = new_len;
#line 274
        ok = (BOOL )1;
        }
      } else {
#line 268
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 277
      tmp___0 = ugly_dbg_set_estr_mem(es, es->es_step * ((new_len + es->es_step) / es->es_step),
                                      file, line);
      }
#line 277
      if (tmp___0) {
        {
#line 280
        strcpy((char */* __restrict  */)es->es_data, (char const   */* __restrict  */)s___2);
        }
#line 281
        if (old_data) {
          {
#line 281
          free((void *)old_data);
#line 281
          old_data = (STRPTR )((void *)0);
          }
        }
#line 283
        es->es_len = new_len;
#line 284
        ok = (BOOL )1;
      }
    }
  }
#line 292
  return (ok);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL ugly_clr_estr(EXPSTR *es ) 
{ 
  BOOL tmp ;

  {
  {
#line 330
  tmp = ugly_set_estr(es, "");
  }
#line 330
  return (tmp);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL ugly_dbg_clr_estr(EXPSTR *es , STRPTR file , ULONG line ) 
{ 
  BOOL tmp ;

  {
  {
#line 342
  tmp = ugly_dbg_set_estr(es, "", file, line);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL set_estrn(EXPSTR *es , CONSTRPTR s___2 , size_t n ) 
{ 
  BOOL ok ;
  STRPTR s1 ;
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 352
  ok = (BOOL )0;
#line 353
  s1 = (STRPTR )((void *)0);
#line 354
  tmp = strlen(s___2);
#line 354
  len = tmp;
  }
#line 356
  if (n > len) {
#line 357
    n = len;
  }
  {
#line 359
  tmp___0 = ugly_malloc_notracking(n + 1UL);
#line 359
  s1 = (STRPTR )tmp___0;
  }
#line 360
  if (s1) {
    {
#line 363
    memcpy((void */* __restrict  */)s1, (void const   */* __restrict  */)s___2, n);
#line 364
    *(s1 + n) = (char)0;
#line 365
    ok = ugly_set_estr(es, (CONSTRPTR )s1);
    }
#line 366
    if (s1) {
      {
#line 366
      free((void *)s1);
#line 366
      s1 = (STRPTR )((void *)0);
      }
    }
  }
#line 369
  return (ok);
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
EXPSTR *ugly_dbg_init_estr(size_t step_size , STRPTR file , ULONG line ) 
{ 
  EXPSTR *es ;
  void *tmp ;
  BOOL tmp___0 ;

  {
  {
#line 419
  tmp = ugly_malloc_tracking(sizeof(EXPSTR ), file, line);
#line 419
  es = (EXPSTR *)tmp;
  }
#line 421
  if (es) {
#line 424
    if (step_size < 8UL) {
#line 425
      step_size = (size_t )8;
    }
    {
#line 426
    es->es_data = (STRPTR )((void *)0);
#line 427
    es->es_size = (size_t )0;
#line 428
    es->es_step = step_size;
#line 429
    tmp___0 = ugly_clr_estr(es);
    }
#line 429
    if (! tmp___0) {
#line 432
      if (es) {
        {
#line 432
        free((void *)es);
#line 432
        es = (EXPSTR *)((void *)0);
        }
      }
#line 433
      es = (EXPSTR *)((void *)0);
    }
  }
#line 437
  return (es);
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
EXPSTR *ugly_init_estr(size_t step_size ) 
{ 
  EXPSTR *es ;
  void *tmp ;
  BOOL tmp___0 ;

  {
  {
#line 443
  tmp = ugly_malloc_notracking(sizeof(EXPSTR ));
#line 443
  es = (EXPSTR *)tmp;
  }
#line 445
  if (es) {
#line 448
    if (step_size < 8UL) {
#line 449
      step_size = (size_t )8;
    }
    {
#line 450
    es->es_data = (STRPTR )((void *)0);
#line 451
    es->es_size = (size_t )0;
#line 452
    es->es_step = step_size;
#line 453
    tmp___0 = ugly_clr_estr(es);
    }
#line 453
    if (! tmp___0) {
#line 455
      if (es) {
        {
#line 455
        free((void *)es);
#line 455
        es = (EXPSTR *)((void *)0);
        }
      }
#line 456
      es = (EXPSTR *)((void *)0);
    }
  }
#line 459
  return (es);
}
}
#line 489 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
void del_estr(EXPSTR *es ) 
{ 


  {
#line 517
  if (es) {
#line 520
    if (es->es_data) {
      {
#line 520
      free((void *)es->es_data);
#line 520
      es->es_data = (STRPTR )((void *)0);
      }
    }
#line 521
    es->es_len = (size_t )0;
#line 522
    es->es_size = (size_t )0;
#line 523
    es->es_step = (size_t )0;
#line 524
    if (es) {
      {
#line 524
      free((void *)es);
#line 524
      es = (EXPSTR *)((void *)0);
      }
    }
  }
#line 527
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL ugly_app_estrch(EXPSTR *es , int ch ) 
{ 
  BOOL ok ;
  STRPTR old_data ;
  BOOL tmp ;
  STRPTR s___2 ;

  {
#line 564
  ok = (BOOL )1;
#line 566
  if (es->es_len >= es->es_size) {
    {
#line 568
    old_data = es->es_data;
#line 570
    tmp = ugly_set_estr_mem(es, es->es_size + es->es_step);
    }
#line 570
    if (tmp) {
      {
#line 573
      strcpy((char */* __restrict  */)es->es_data, (char const   */* __restrict  */)old_data);
      }
#line 575
      if (old_data) {
        {
#line 575
        free((void *)old_data);
#line 575
        old_data = (STRPTR )((void *)0);
        }
      }
    } else {
#line 579
      ok = (BOOL )0;
    }
  }
#line 582
  if (ok) {
#line 585
    s___2 = es->es_data;
#line 586
    *(s___2 + (es->es_len - 1UL)) = (char )ch;
#line 587
    *(s___2 + es->es_len) = (char)0;
#line 588
    (es->es_len) ++;
  }
#line 591
  return (ok);
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL ugly_dbg_app_estrch(EXPSTR *es , int ch , STRPTR file , ULONG line ) 
{ 
  BOOL ok ;
  STRPTR old_data ;
  BOOL tmp ;
  STRPTR s___2 ;

  {
#line 595
  ok = (BOOL )1;
#line 597
  if (! es) {
    {
#line 598
    es_null((STRPTR )"app_estrch", file, line);
#line 599
    ok = (BOOL )0;
    }
  } else
#line 600
  if (es->es_len >= es->es_size) {
    {
#line 602
    old_data = es->es_data;
#line 604
    tmp = ugly_dbg_set_estr_mem(es, es->es_size + es->es_step, file, line);
    }
#line 604
    if (tmp) {
      {
#line 607
      strcpy((char */* __restrict  */)es->es_data, (char const   */* __restrict  */)old_data);
      }
#line 609
      if (old_data) {
        {
#line 609
        free((void *)old_data);
#line 609
        old_data = (STRPTR )((void *)0);
        }
      }
    } else {
#line 611
      ok = (BOOL )0;
    }
  }
#line 614
  if (ok) {
#line 616
    s___2 = es->es_data;
#line 617
    *(s___2 + (es->es_len - 1UL)) = (char )ch;
#line 618
    *(s___2 + es->es_len) = (char)0;
#line 619
    (es->es_len) ++;
  }
#line 621
  return (ok);
}
}
#line 656 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL ugly_app_estr(EXPSTR *es , CONSTRPTR s___2 ) 
{ 
  BOOL ok ;
  size_t slen ;
  size_t tmp ;
  STRPTR old_data ;
  BOOL tmp___0 ;
  STRPTR ds ;

  {
  {
#line 658
  ok = (BOOL )1;
#line 659
  tmp = strlen(s___2);
#line 659
  slen = tmp;
#line 661
  ok = (BOOL )1;
  }
#line 662
  if ((es->es_len + slen) - 1UL >= es->es_size) {
    {
#line 665
    old_data = es->es_data;
#line 667
    tmp___0 = ugly_set_estr_mem(es, es->es_step * ((((es->es_len + slen) + 1UL) + es->es_step) / es->es_step));
    }
#line 667
    if (tmp___0) {
      {
#line 671
      strcpy((char */* __restrict  */)es->es_data, (char const   */* __restrict  */)old_data);
      }
#line 673
      if (old_data) {
        {
#line 673
        free((void *)old_data);
#line 673
        old_data = (STRPTR )((void *)0);
        }
      }
    } else {
#line 677
      ok = (BOOL )0;
    }
  }
#line 680
  if (ok) {
    {
#line 684
    ds = es->es_data + (es->es_len - 1UL);
#line 685
    strcat((char */* __restrict  */)ds, (char const   */* __restrict  */)s___2);
#line 687
    es->es_len += slen;
#line 688
    *(es->es_data + (es->es_len - 1UL)) = (char)0;
    }
  }
#line 691
  return (ok);
}
}
#line 694 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL ugly_dbg_app_estr(EXPSTR *es , CONSTRPTR s___2 , STRPTR file , ULONG line ) 
{ 
  BOOL ok ;
  size_t slen ;
  size_t tmp ;
  STRPTR old_data ;
  BOOL tmp___0 ;
  STRPTR ds ;

  {
#line 696
  ok = (BOOL )0;
#line 698
  if (! es) {
    {
#line 699
    es_null((STRPTR )"app_estr", file, line);
    }
  } else
#line 700
  if (! s___2) {
    {
#line 701
    s_null((STRPTR )"app_estr", file, line);
    }
  } else {
    {
#line 705
    tmp = strlen(s___2);
#line 705
    slen = tmp;
#line 707
    ok = (BOOL )1;
    }
#line 708
    if ((es->es_len + slen) - 1UL >= es->es_size) {
      {
#line 711
      old_data = es->es_data;
#line 713
      tmp___0 = ugly_dbg_set_estr_mem(es, es->es_step * ((((es->es_len + slen) + 1UL) + es->es_step) / es->es_step),
                                      file, line);
      }
#line 713
      if (tmp___0) {
        {
#line 717
        strcpy((char */* __restrict  */)es->es_data, (char const   */* __restrict  */)old_data);
        }
#line 719
        if (old_data) {
          {
#line 719
          free((void *)old_data);
#line 719
          old_data = (STRPTR )((void *)0);
          }
        }
      } else {
#line 723
        ok = (BOOL )0;
      }
    }
#line 726
    if (ok) {
      {
#line 730
      ds = es->es_data + (es->es_len - 1UL);
#line 731
      strcat((char */* __restrict  */)ds, (char const   */* __restrict  */)s___2);
#line 733
      es->es_len += slen;
#line 734
      *(es->es_data + (es->es_len - 1UL)) = (char)0;
      }
    }
  }
#line 739
  return (ok);
}
}
#line 769 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL get_mid_estr(EXPSTR *dest , EXPSTR *src , size_t from , size_t num ) 
{ 
  BOOL ok ;
  EXPSTR *tmp ;
  EXPSTR *tmp___0 ;
  STRPTR old_data ;

  {
  {
#line 771
  ok = (BOOL )0;
#line 772
  tmp___0 = ugly_init_estr(dest->es_step);
#line 772
  tmp = tmp___0;
  }
#line 774
  if (tmp) {
#line 777
    old_data = tmp->es_data;
#line 780
    if (from >= src->es_len) {
#line 781
      from = src->es_len - 1UL;
    }
#line 782
    if (from + num >= src->es_len) {
#line 783
      num = (src->es_len - from) - 1UL;
    }
    {
#line 786
    ok = ugly_set_estr_mem(tmp, tmp->es_step * (((num + 1UL) + tmp->es_step) / tmp->es_step));
    }
#line 788
    if (ok) {
      {
#line 792
      strncpy((char */* __restrict  */)tmp->es_data, (char const   */* __restrict  */)(src->es_data + from),
              num);
#line 793
      *(tmp->es_data + num) = (char)0;
#line 794
      tmp->es_len = num + 1UL;
      }
#line 795
      if (old_data) {
        {
#line 795
        free((void *)old_data);
#line 795
        old_data = (STRPTR )((void *)0);
        }
      }
      {
#line 797
      ok = estrcpy(dest, tmp);
      }
    }
    {
#line 800
    del_estr(tmp);
    }
  }
#line 803
  return (ok);
}
}
#line 811 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL get_right_estr(EXPSTR *dest , EXPSTR *src , size_t num ) 
{ 
  BOOL tmp ;

  {
#line 813
  if (num >= src->es_len) {
#line 814
    num = src->es_len - 1UL;
  }
  {
#line 816
  tmp = get_mid_estr(dest, src, (src->es_len - num) - 1UL, num);
  }
#line 816
  return (tmp);
}
}
#line 824 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL get_left_estr(EXPSTR *dest , EXPSTR *src , size_t num ) 
{ 
  BOOL tmp ;

  {
  {
#line 826
  tmp = get_mid_estr(dest, src, (size_t )0, num);
  }
#line 826
  return (tmp);
}
}
#line 868 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
STRPTR ugly_estr2str(EXPSTR *es ) 
{ 


  {
#line 870
  return (es->es_data);
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
size_t ugly_estrlen(EXPSTR *es ) 
{ 


  {
#line 914
  return (es->es_len - 1UL);
}
}
#line 952 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL estrcpy(EXPSTR *dest , EXPSTR *src ) 
{ 
  BOOL tmp ;

  {
  {
#line 954
  tmp = ugly_set_estr(dest, (CONSTRPTR )src->es_data);
  }
#line 954
  return (tmp);
}
}
#line 992 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
BOOL estrcat(EXPSTR *dest , EXPSTR *src ) 
{ 
  BOOL tmp ;

  {
  {
#line 994
  tmp = ugly_app_estr(dest, (CONSTRPTR )src->es_data);
  }
#line 994
  return (tmp);
}
}
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.h"
VOID display_panic_message(char *msg , char *file , size_t line ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.h"
int upstrcmp(CONSTRPTR s1 , CONSTRPTR s2 ) ;
#line 58
STRPTR ugly_strclone(CONSTRPTR oldstr , STRPTR file , ULONG line ) ;
#line 61
STRPTR ustrrpbrk(CONSTRPTR str , CONSTRPTR set ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
BOOL get_fext(EXPSTR *dest , CONSTRPTR fn ) 
{ 
  CONSTRPTR fn_ext ;
  CONSTRPTR tmp ;
  char *tmp___0 ;

  {
#line 53
  fn_ext = fn;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! *(fn_ext + 0)) {
#line 56
      goto while_break;
    }
#line 57
    fn_ext ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 60
    if ((unsigned long )fn_ext != (unsigned long )fn) {
#line 60
      tmp = fn_ext;
#line 60
      fn_ext --;
#line 60
      if (tmp) {
#line 60
        if ((int const   )*(fn_ext + 0) != 46) {
          {
#line 60
          tmp___0 = strchr("/", (int )*(fn_ext + 0));
          }
#line 60
          if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 60
            goto while_break___0;
          }
        } else {
#line 60
          goto while_break___0;
        }
      } else {
#line 60
        goto while_break___0;
      }
    } else {
#line 60
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 70
  if ((int const   )*(fn_ext + 0) == 46) {
    {
#line 71
    fn_ext ++;
#line 71
    ugly_set_estr(dest, fn_ext);
    }
  } else {
    {
#line 73
    ugly_clr_estr(dest);
    }
  }
#line 75
  return ((BOOL )(dest->es_len - 1UL <= 253UL));
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
BOOL get_fname(EXPSTR *dest , CONSTRPTR fn ) 
{ 
  CONSTRPTR fn_name ;
  STRPTR tmp ;

  {
  {
#line 85
  fn_name = fn;
#line 87
  tmp = ustrrpbrk(fn_name, "/");
#line 87
  fn_name = (CONSTRPTR )tmp;
  }
#line 90
  if (fn_name) {
    {
#line 91
    fn_name ++;
#line 91
    ugly_set_estr(dest, fn_name);
    }
  } else {
    {
#line 93
    ugly_set_estr(dest, fn);
    }
  }
#line 95
  return ((BOOL )(dest->es_len - 1UL <= 254UL));
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
BOOL get_fpath(EXPSTR *dest , CONSTRPTR fn ) 
{ 
  STRPTR pa_name ;
  STRPTR tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 105
  tmp = ustrrpbrk(fn, "/");
#line 105
  pa_name = tmp;
  }
#line 107
  if (pa_name) {
    {
#line 108
    tmp___0 = strlen(fn);
#line 108
    tmp___1 = strlen((char const   *)pa_name);
#line 108
    set_estrn(dest, fn, (tmp___0 - tmp___1) + 1UL);
    }
  } else {
    {
#line 110
    ugly_clr_estr(dest);
    }
  }
#line 112
  return ((BOOL )(dest->es_len - 1UL <= 254UL));
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
BOOL get_fsdir(EXPSTR *dest , CONSTRPTR fn ) 
{ 
  STRPTR fn_name ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 121
  tmp = strpbrk(fn, "/");
#line 121
  fn_name = tmp;
  }
#line 123
  if (fn_name) {
    {
#line 124
    tmp___0 = strlen(fn);
#line 124
    tmp___1 = strlen((char const   *)fn_name);
#line 124
    set_estrn(dest, fn, (tmp___0 - tmp___1) + 1UL);
    }
  } else {
    {
#line 126
    ugly_clr_estr(dest);
    }
  }
#line 128
  return ((BOOL )(dest->es_len - 1UL <= 254UL));
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
BOOL get_fdrive(EXPSTR *dest , CONSTRPTR fn ) 
{ 


  {
  {
#line 138
  ugly_set_estr(dest, fn);
#line 139
  ugly_clr_estr(dest);
  }
#line 140
  return ((BOOL )(dest->es_len - 1UL <= 254UL));
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
static size_t fextidx(CONSTRPTR fn ) 
{ 
  size_t i ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 160
  tmp = strlen(fn);
#line 160
  i = tmp - 1UL;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (i) {
#line 161
      if ((int const   )*(fn + i) != 46) {
        {
#line 161
        tmp___0 = strchr("/", (int )*(fn + i));
        }
#line 161
        if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 161
          goto while_break;
        }
      } else {
#line 161
        goto while_break;
      }
    } else {
#line 161
      goto while_break;
    }
#line 163
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if ((int const   )*(fn + i) != 46) {
    {
#line 165
    i = strlen(fn);
    }
  }
#line 167
  return (i);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
BOOL clr_fext(EXPSTR *dest ) 
{ 
  BOOL ok ;
  size_t extidx ;
  size_t tmp ;

  {
  {
#line 181
  tmp = fextidx((CONSTRPTR )dest->es_data);
#line 181
  extidx = tmp;
#line 183
  ok = set_estrn(dest, (CONSTRPTR )dest->es_data, extidx);
#line 184
  ok = (BOOL )((int )ok & (int )((BOOL )(dest->es_len - 1UL <= 254UL)));
  }
#line 186
  return (ok);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
BOOL set_fext(EXPSTR *dest , CONSTRPTR newext ) 
{ 
  BOOL ok ;
  BOOL tmp ;
  BOOL tmp___0 ;

  {
  {
#line 202
  ok = clr_fext(dest);
#line 203
  tmp = ugly_app_estrch(dest, '.');
#line 203
  ok = (BOOL )((int )ok & (int )tmp);
#line 204
  tmp___0 = ugly_app_estr(dest, newext);
#line 204
  ok = (BOOL )((int )ok & (int )tmp___0);
#line 206
  ok = (BOOL )((int )ok & (int )((BOOL )(dest->es_len - 1UL <= 254UL)));
  }
#line 208
  return (ok);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
BOOL app_fext(EXPSTR *dest , CONSTRPTR newext ) 
{ 
  BOOL ok ;
  BOOL tmp ;
  BOOL tmp___0 ;

  {
  {
#line 219
  tmp = ugly_app_estrch(dest, '.');
#line 219
  ok = tmp;
#line 221
  tmp___0 = ugly_app_estr(dest, newext);
#line 221
  ok = (BOOL )((int )ok & (int )tmp___0);
#line 222
  ok = (BOOL )((int )ok & (int )((BOOL )(dest->es_len - 1UL <= 254UL)));
  }
#line 224
  return (ok);
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
BOOL set_fnameIdx(EXPSTR *dest , int idx ) 
{ 
  char fn_ext[12] ;
  BOOL tmp ;

  {
  {
#line 237
  sprintf((char */* __restrict  */)(fn_ext), (char const   */* __restrict  */)"%03d",
          idx);
#line 239
  tmp = set_fext(dest, (CONSTRPTR )(fn_ext));
  }
#line 239
  return (tmp);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
BOOL link_fname(EXPSTR *dest , STRPTR dir , STRPTR fn ) 
{ 
  BOOL anydir ;
  BOOL ok ;
  size_t tmp ;
  int tmp___0 ;
  STRPTR dir_clone ;
  STRPTR tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 254
  ok = (BOOL )1;
#line 257
  if ((unsigned long )dir != (unsigned long )((void *)0)) {
    {
#line 257
    tmp = strlen((char const   *)dir);
    }
#line 257
    if (tmp != 0UL) {
#line 257
      tmp___0 = 1;
    } else {
#line 257
      tmp___0 = 0;
    }
  } else {
#line 257
    tmp___0 = 0;
  }
#line 257
  anydir = (BOOL )tmp___0;
#line 259
  if (anydir) {
    {
#line 266
    tmp___1 = ugly_strclone((CONSTRPTR )dir, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c",
                            (ULONG )266);
#line 266
    dir_clone = tmp___1;
#line 268
    ugly_set_estr(dest, (CONSTRPTR )dir_clone);
#line 271
    tmp___2 = strlen((char const   *)dir_clone);
#line 271
    tmp___3 = strchr("/", (int )*(dir_clone + (tmp___2 - 1UL)));
    }
#line 271
    if (! tmp___3) {
      {
#line 272
      ugly_app_estrch(dest, '/');
      }
    }
    {
#line 275
    ugly_freestr(dir_clone, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c",
                 (ULONG )275);
#line 275
    dir_clone = (STRPTR )((void *)0);
    }
  } else {
    {
#line 278
    ugly_clr_estr(dest);
    }
  }
#line 281
  if (fn) {
    {
#line 282
    ugly_app_estr(dest, (CONSTRPTR )fn);
    }
  }
#line 284
  ok = (BOOL )((int )ok & (int )((BOOL )(dest->es_len - 1UL <= 254UL)));
#line 286
  return (ok);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
BOOL link_envfname(EXPSTR *dest , STRPTR envname , STRPTR dir , STRPTR fn ) 
{ 
  BOOL ok ;
  STRPTR env ;
  char *tmp ;
  STRPTR env1 ;
  STRPTR tmp___0 ;
  EXPSTR *tmpstr ;
  EXPSTR *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 303
  ok = (BOOL )0;
#line 304
  tmp = getenv((char const   *)envname);
#line 304
  env = tmp;
  }
#line 306
  if (env) {
    {
#line 308
    tmp___0 = ugly_strclone((CONSTRPTR )env, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c",
                            (ULONG )308);
#line 308
    env1 = tmp___0;
#line 309
    tmp___1 = ugly_init_estr((size_t )32);
#line 309
    tmpstr = tmp___1;
    }
    {
#line 312
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 312
      tmp___3 = strlen((char const   *)env1);
      }
#line 312
      if (tmp___3) {
        {
#line 312
        tmp___4 = strlen((char const   *)env1);
        }
#line 312
        if (! ((int )*(env1 + tmp___4) == 10)) {
#line 312
          goto while_break;
        }
      } else {
#line 312
        goto while_break;
      }
      {
#line 313
      tmp___2 = strlen((char const   *)env1);
#line 313
      *(env1 + tmp___2) = (char )'\000';
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 315
    if (dir) {
      {
#line 317
      link_fname(tmpstr, env1, dir);
      }
    } else {
      {
#line 321
      ugly_set_estr(tmpstr, (CONSTRPTR )env1);
      }
    }
    {
#line 324
    ok = link_fname(dest, tmpstr->es_data, fn);
#line 326
    del_estr(tmpstr);
#line 327
    ugly_freestr(env1, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c",
                 (ULONG )327);
#line 327
    env1 = (STRPTR )((void *)0);
    }
  } else {
    {
#line 331
    ugly_clr_estr(dest);
    }
  }
#line 334
  return (ok);
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
static size_t adjust_prefix_length(size_t prefix_length ) 
{ 


  {
#line 350
  if (prefix_length > 246UL) {
#line 352
    prefix_length = (size_t )246;
  }
#line 355
  return (prefix_length);
}
}
#line 360
STRPTR tmpnamstr(STRPTR suggested_prefix ) ;
#line 360 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
static LONG fileidx  =    (LONG )0;
#line 361 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
static STRARR buf[288]  ;
#line 358 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
STRPTR tmpnamstr(STRPTR suggested_prefix ) 
{ 
  STRPTR s___2 ;
  STRPTR prefix ;
  FILE *file ;
  size_t prefix_length ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 362
  s___2 = (STRPTR )((void *)0);
#line 363
  prefix = suggested_prefix;
#line 364
  file = (FILE *)((void *)0);
#line 365
  prefix_length = (size_t )0;
#line 367
  if ((unsigned long )prefix == (unsigned long )((void *)0)) {
#line 369
    prefix = (STRPTR )"";
  }
  {
#line 373
  tmp = strlen((char const   *)prefix);
#line 373
  prefix_length = adjust_prefix_length(tmp);
#line 374
  strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)prefix,
          prefix_length);
#line 375
  buf[prefix_length] = (STRARR )'\000';
#line 380
  tmp___0 = strlen((char const   *)(buf));
#line 380
  sprintf((char */* __restrict  */)(& buf[tmp___0]), (char const   */* __restrict  */)"%p",
          (void *)(& tmpnamstr));
#line 383
  prefix_length = strlen((char const   *)(buf));
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 393
    fileidx ++;
#line 397
    sprintf((char */* __restrict  */)(& buf[prefix_length]), (char const   */* __restrict  */)"%04lx.tmp",
            fileidx);
#line 399
    file = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
    }
#line 400
    if (file) {
      {
#line 402
      fclose(file);
      }
#line 403
      if (fileidx == 65535L) {
#line 405
        fileidx = (LONG )0;
      }
    }
#line 391
    if (fileidx) {
#line 391
      if (! file) {
#line 391
        goto while_break;
      }
    } else {
#line 391
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  if (fileidx != 0L) {
#line 413
    s___2 = buf;
  }
#line 416
  return (s___2);
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
BOOL get_relfname(EXPSTR *dest , STRPTR absn , STRPTR curp ) 
{ 
  EXPSTR *fname ;
  EXPSTR *tmp ;
  EXPSTR *abspa ;
  EXPSTR *tmp___0 ;
  EXPSTR *tmpp1 ;
  EXPSTR *tmp___1 ;
  EXPSTR *tmpp2 ;
  EXPSTR *tmp___2 ;
  STRPTR rest_absp ;
  STRPTR absp ;
  int cmp_result ;
  size_t tmp___3 ;

  {
  {
#line 432
  tmp = ugly_init_estr((size_t )32);
#line 432
  fname = tmp;
#line 433
  tmp___0 = ugly_init_estr((size_t )32);
#line 433
  abspa = tmp___0;
#line 434
  tmp___1 = ugly_init_estr((size_t )32);
#line 434
  tmpp1 = tmp___1;
#line 435
  tmp___2 = ugly_init_estr((size_t )32);
#line 435
  tmpp2 = tmp___2;
#line 436
  rest_absp = (STRPTR )((void *)0);
#line 437
  absp = (STRPTR )((void *)0);
#line 441
  ugly_clr_estr(dest);
#line 442
  get_fname(fname, (CONSTRPTR )absn);
#line 443
  get_fpath(abspa, (CONSTRPTR )absn);
#line 444
  absp = abspa->es_data;
  }
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 450
    get_fsdir(tmpp1, (CONSTRPTR )absp);
#line 451
    get_fsdir(tmpp2, (CONSTRPTR )curp);
#line 452
    cmp_result = upstrcmp((CONSTRPTR )tmpp1->es_data, (CONSTRPTR )tmpp2->es_data);
    }
#line 454
    if (! cmp_result) {
#line 455
      absp += tmpp1->es_len - 1UL;
#line 456
      curp += tmpp2->es_len - 1UL;
    }
#line 449
    if (tmpp1->es_len - 1UL) {
#line 449
      if (tmpp2->es_len - 1UL) {
#line 449
        if (! (! cmp_result)) {
#line 449
          goto while_break;
        }
      } else {
#line 449
        goto while_break;
      }
    } else {
#line 449
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  rest_absp = absp;
#line 469
  if (*(curp + 0)) {
    {
#line 470
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 471
      get_fsdir(tmpp1, (CONSTRPTR )absp);
#line 472
      get_fsdir(tmpp2, (CONSTRPTR )curp);
#line 473
      cmp_result = upstrcmp((CONSTRPTR )tmpp1->es_data, (CONSTRPTR )tmpp2->es_data);
      }
#line 475
      if (cmp_result) {
        {
#line 476
        absp += tmpp1->es_len - 1UL;
#line 477
        curp += tmpp2->es_len - 1UL;
#line 478
        ugly_app_estr(dest, "../");
        }
      }
      {
#line 470
      tmp___3 = strlen((char const   *)curp);
      }
#line 470
      if (tmp___3) {
#line 470
        if (! cmp_result) {
#line 470
          goto while_break___0;
        }
      } else {
#line 470
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 483
  ugly_app_estr(dest, (CONSTRPTR )rest_absp);
#line 486
  ugly_app_estr(dest, (CONSTRPTR )fname->es_data);
#line 489
  del_estr(fname);
#line 490
  del_estr(abspa);
#line 491
  del_estr(tmpp1);
#line 492
  del_estr(tmpp2);
  }
#line 494
  return ((BOOL )(dest->es_len - 1UL <= 254UL));
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
BOOL optimize_fname(STRPTR *target_name , STRPTR source_name ) 
{ 
  STRPTR filename ;
  STRPTR tmp ;
  STRPTR filename_fun_start ;
  STRPTR filename_scan ;
  STRPTR next_parent_inside ;
  STRPTR previous_directory ;
  size_t filename_length ;
  size_t tmp___0 ;
  size_t parent_begin_length ;
  size_t tmp___1 ;
  size_t parent_inside_length ;
  size_t tmp___2 ;
  size_t parent_inside_index ;
  STRPTR next_directory ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char fun_start_character ;
  STRPTR what2 ;
  STRPTR what2___0 ;
  STRPTR what2___1 ;
  STRPTR target ;
  void *tmp___6 ;
  size_t target_index ;

  {
  {
#line 523
  tmp = ugly_strclone((CONSTRPTR )source_name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c",
                      (ULONG )523);
#line 523
  filename = tmp;
#line 524
  filename_fun_start = filename;
#line 525
  filename_scan = (STRPTR )((void *)0);
#line 526
  next_parent_inside = (STRPTR )((void *)0);
#line 527
  previous_directory = (STRPTR )((void *)0);
#line 528
  tmp___0 = strlen((char const   *)filename);
#line 528
  filename_length = tmp___0;
#line 529
  tmp___1 = strlen("../");
#line 529
  parent_begin_length = tmp___1;
#line 530
  tmp___2 = strlen("../");
#line 530
  parent_inside_length = tmp___2;
#line 531
  parent_inside_index = (size_t )0;
  }
#line 544
  if ((int )*(filename_fun_start + 0) == 47) {
    {
#line 546
    tmp___3 = strchr((char const   *)(filename_fun_start + 1), '/');
#line 546
    next_directory = tmp___3;
    }
#line 547
    if ((unsigned long )next_directory != (unsigned long )((void *)0)) {
#line 549
      filename_fun_start = next_directory + 1;
    } else {
      {
#line 554
      tmp___4 = strlen((char const   *)filename_fun_start);
#line 554
      filename_fun_start += tmp___4;
      }
    }
  }
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 563
    tmp___5 = strncmp((char const   *)filename_fun_start, "../", parent_begin_length);
    }
#line 563
    if (tmp___5) {
#line 563
      goto while_break;
    }
#line 565
    filename_fun_start += parent_begin_length;
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  filename_scan = filename_fun_start;
  {
#line 573
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 577
    next_parent_inside = strstr((char const   *)filename_scan, "/../");
    }
#line 578
    if ((unsigned long )next_parent_inside != (unsigned long )((void *)0)) {
#line 591
      fun_start_character = *(filename_fun_start + 0);
#line 593
      previous_directory = next_parent_inside - 1;
      {
#line 595
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 595
        if ((unsigned long )previous_directory > (unsigned long )filename_fun_start) {
#line 595
          if (! ((int )*(previous_directory + 0) != (int )*("/" + 0))) {
#line 595
            goto while_break___1;
          }
        } else {
#line 595
          goto while_break___1;
        }
#line 598
        previous_directory --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 604
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 606
        what2 = previous_directory;
#line 606
        if ((int )*(what2 + 0) != 7) {
#line 606
          *(what2 + 0) = (char )'\a';
#line 606
          filename_length --;
        }
#line 607
        previous_directory ++;
#line 604
        if (! ((int )*(previous_directory + 0) != (int )*("/" + 0))) {
#line 604
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 615
      parent_inside_index = (size_t )0;
      {
#line 615
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 615
        if (! (parent_inside_index < parent_inside_length)) {
#line 615
          goto while_break___3;
        }
#line 619
        what2___0 = next_parent_inside + parent_inside_index;
#line 619
        if ((int )*(what2___0 + 0) != 7) {
#line 619
          *(what2___0 + 0) = (char )'\a';
#line 619
          filename_length --;
        }
#line 615
        parent_inside_index ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 621
      filename_scan = next_parent_inside + parent_inside_length;
#line 627
      if ((int )*(filename_fun_start + 0) != (int )fun_start_character) {
#line 629
        what2___1 = filename_scan;
#line 629
        if ((int )*(what2___1 + 0) != 7) {
#line 629
          *(what2___1 + 0) = (char )'\a';
#line 629
          filename_length --;
        }
#line 630
        filename_scan ++;
      }
    } else {
      {
#line 639
      tmp___6 = ugly_malloc_notracking(filename_length + 1UL);
#line 639
      target = (STRPTR )tmp___6;
#line 640
      target_index = (size_t )0;
#line 641
      *target_name = target;
#line 645
      filename_scan = filename;
      }
      {
#line 646
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 646
        if (! ((int )*(filename_scan + 0) != 0)) {
#line 646
          goto while_break___4;
        }
#line 648
        if ((int )*(filename_scan + 0) != 7) {
#line 650
          *(target + target_index) = *(filename_scan + 0);
#line 651
          target_index ++;
        }
#line 653
        filename_scan ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 657
      *(target + target_index) = (char )'\000';
#line 659
      if (target_index != filename_length) {
        {
#line 661
        display_panic_message((char *)"bad target_index", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c",
                              (size_t )661);
        }
      }
    }
#line 573
    if (! ((unsigned long )next_parent_inside != (unsigned long )((void *)0))) {
#line 573
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 669
  if (filename) {
    {
#line 669
    free((void *)filename);
#line 669
    filename = (STRPTR )((void *)0);
    }
  }
#line 671
  return ((BOOL )1);
}
}
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 102 "./ugly/infile.h"
INFILE *infopen(CONSTRPTR name , size_t step_size ) ;
#line 104
int infclose1(INFILE *inpf ) ;
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 98 "./ugly/umemory.h"
void atexit_uglymemory_dummy(void) ;
#line 100
BOOL (*ugly_nomem_handler)(size_t size ) ;
#line 171 "./ugly/uargs.h"
LONG prep_error_num ;
#line 175
struct arglist *prepare_args(STRPTR arglist_name  , ...) ;
#line 176
BOOL set_args(int argc , char **argv , ARGLIST *al ) ;
#line 179
void free_args(struct arglist *al ) ;
#line 187
int fprintf_arghelp(FILE *stream , struct arglist *al ) ;
#line 192
void pargerr(void) ;
#line 89 "./ugly/prginfo.h"
void call_set_prginfo2(STRPTR name , STRPTR auth , int ver , int rel , int rev , STRPTR rel_date ,
                       STRPTR rel_time , STRPTR infostr , STRPTR copystatus ) ;
#line 93
int fprintf_prginfo(FILE *stream ) ;
#line 58 "./hscprj/project.h"
HSCPRJ *new_project(void) ;
#line 59
VOID del_project(HSCPRJ *hp___0 ) ;
#line 61
BOOL hsc_project_read_data(HSCPRJ *hp___0 , INFILE *inpf ) ;
#line 31 "./hscprj/license.h"
VOID show_license(void) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static int return_code___0  =    2;
#line 101 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static STRPTR makefile  =    (STRPTR )((void *)0);
#line 102 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static STRPTR prjfile  =    (STRPTR )((void *)0);
#line 103 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static STRPTR nameall  =    (STRPTR )((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static BOOL verbose  =    (BOOL )0;
#line 105 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static BOOL nobackup  =    (BOOL )0;
#line 106 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static BOOL notaglines  =    (BOOL )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static BOOL debug  =    (BOOL )0;
#line 109 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static EXPSTR *lines_precede  =    (EXPSTR *)((void *)0);
#line 110 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static EXPSTR *lines_follow  =    (EXPSTR *)((void *)0);
#line 111 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static EXPSTR *lines_depend  =    (EXPSTR *)((void *)0);
#line 113 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static HSCPRJ *project  =    (HSCPRJ *)((void *)0);
#line 119 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static VOID cleanup(void) 
{ 


  {
#line 121
  if (debug) {
    {
#line 121
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(cleanup)\r");
    }
  }
  {
#line 122
  del_project(project);
#line 123
  del_estr(lines_precede);
#line 124
  del_estr(lines_follow);
#line 125
  del_estr(lines_depend);
  }
#line 126
  if (debug) {
    {
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         ");
    }
  }
#line 127
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static VOID set_return_code___0(int new_code ) 
{ 


  {
#line 131
  if (new_code > return_code___0) {
#line 132
    return_code___0 = new_code;
  }
#line 133
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static BOOL hscdepp_nomem_handler(size_t size ) 
{ 


  {
  {
#line 142
  fputs((char const   */* __restrict  */)"*** out of memory\n", (FILE */* __restrict  */)stderr);
#line 144
  return_code___0 = 2;
#line 146
  exit(return_code___0);
  }
#line 148
  return ((BOOL )0);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
VOID msg_corrupt_pf(HSCPRJ *hp___0 , STRPTR reason ) 
{ 


  {
  {
#line 153
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"project-file corrupt: %s\n",
          reason);
  }
#line 154
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static BOOL args_ok___0(int argc , char **argv ) 
{ 
  struct arglist *hscdepp_args ;
  BOOL arg_help___0 ;
  BOOL arg_license___0 ;
  BOOL ok ;

  {
  {
#line 168
  arg_help___0 = (BOOL )0;
#line 169
  arg_license___0 = (BOOL )0;
#line 170
  ok = (BOOL )0;
#line 173
  hscdepp_args = prepare_args((STRPTR )"HSCDEPP_ARGS", "FILE/T", & makefile, "makefile to update",
                              "PRJFILE/T/K", & prjfile, "project file", "NAMEALL/T/K",
                              & nameall, "name for `all_hsc\' rule", "VERBOSE/S",
                              & verbose, "verbose output", "NOBACKUP/S", & nobackup,
                              "do not backup makefile", "NOTAGLINES/S", & notaglines,
                              "do not write taglines", "-DEBUG/S", & debug, "enable debugging output",
                              "HELP=?=-h=--help/S", & arg_help___0, "display this text",
                              "LICENSE/S", & arg_license___0, "display license", (void *)0);
#line 186
  ok = (BOOL )((unsigned long )hscdepp_args != (unsigned long )((void *)0));
  }
#line 189
  if (ok) {
    {
#line 191
    ok = set_args(argc, argv, hscdepp_args);
    }
#line 194
    if (! ok) {
      {
#line 196
      pargerr();
#line 197
      set_return_code___0(1);
      }
    } else
#line 199
    if (arg_help___0) {
#line 199
      goto _L;
    } else
#line 199
    if (arg_license___0) {
      _L: /* CIL Label */ 
      {
#line 204
      fprintf_prginfo(stderr);
      }
#line 205
      if (arg_help___0) {
        {
#line 206
        fprintf_arghelp(stderr, hscdepp_args);
        }
      } else {
        {
#line 208
        show_license();
        }
      }
      {
#line 209
      set_return_code___0(0);
#line 210
      ok = (BOOL )0;
      }
    } else {
#line 215
      if (debug) {
#line 216
        verbose = (BOOL )1;
      }
#line 219
      if (verbose) {
        {
#line 220
        fprintf_prginfo(stderr);
        }
      }
#line 223
      if (! prjfile) {
#line 225
        prjfile = (STRPTR )"hsc.project";
#line 226
        if (verbose) {
          {
#line 227
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: using default project-file\n",
                  prjfile);
          }
        }
      }
#line 230
      if (! nameall) {
#line 232
        nameall = (STRPTR )"all_hsc";
      }
#line 237
      if (debug) {
#line 237
        if (makefile) {
          {
#line 237
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscdep* makefile=`%s\'\n",
                  makefile);
#line 237
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscdep* makefile=DEFAULT\n");
#line 237
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscdep* prjfile =`%s\'\n",
                  prjfile);
#line 237
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscdep* nameall =`%s\'\n",
                  nameall);
          }
        }
      }
    }
    {
#line 249
    free_args(hscdepp_args);
    }
  } else
#line 254
  if (debug) {
    {
#line 254
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** ArgDef error: %lu\n",
            prep_error_num);
    }
  }
#line 258
  return (ok);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static STRARR buf___0[1024]  ;
#line 270 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static BOOL read_makefile(void) 
{ 
  STRPTR scanfile[4] ;
  FILE *file ;
  BOOL ok ;
  int *tmp ;
  int i ;
  BOOL found ;
  STRPTR line ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;

  {
  {
#line 272
  scanfile[0] = (STRPTR )"GNUmakefile";
#line 272
  scanfile[1] = (STRPTR )"Makefile";
#line 272
  scanfile[2] = (STRPTR )"makefile";
#line 272
  scanfile[3] = (STRPTR )((void *)0);
#line 274
  file = (FILE *)((void *)0);
#line 275
  ok = (BOOL )0;
#line 277
  lines_precede = ugly_init_estr((size_t )1024);
#line 278
  lines_follow = ugly_init_estr((size_t )1024);
#line 283
  tmp = __errno_location();
#line 283
  *tmp = 0;
  }
#line 284
  if (! makefile) {
#line 287
    i = 0;
#line 289
    if (debug) {
      {
#line 289
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscdep* scanning makefile\n");
      }
    }
#line 290
    makefile = scanfile[0];
    {
#line 291
    while (1) {
      while_continue: /* CIL Label */ ;
#line 291
      if (! file) {
#line 291
        if (! makefile) {
#line 291
          goto while_break;
        }
      } else {
#line 291
        goto while_break;
      }
#line 293
      if (debug) {
        {
#line 293
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscdep*   try `%s\'\n",
                makefile);
        }
      }
      {
#line 294
      file = fopen((char const   */* __restrict  */)makefile, (char const   */* __restrict  */)"r");
      }
#line 295
      if (! file) {
#line 297
        i ++;
#line 298
        makefile = scanfile[i];
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 306
    if (debug) {
      {
#line 306
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscdep* makefile `%s\' specified by user\n",
              makefile);
      }
    }
    {
#line 307
    file = fopen((char const   */* __restrict  */)makefile, (char const   */* __restrict  */)"r");
    }
  }
#line 310
  if (! file) {
#line 312
    if (! makefile) {
#line 313
      makefile = (STRPTR )"Makefile";
    }
    {
#line 314
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: creating new makefile\n",
            makefile);
#line 315
    ok = (BOOL )1;
    }
  } else {
    {
#line 320
    found = (BOOL )0;
#line 321
    line = (STRPTR )((void *)0);
#line 328
    tmp___0 = __errno_location();
#line 328
    *tmp___0 = 0;
    }
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 335
      line = fgets((char */* __restrict  */)(buf___0), 1024, (FILE */* __restrict  */)file);
      }
#line 336
      if (line) {
        {
#line 337
        tmp___1 = strcmp((char const   *)line, "# --- DO NOT MODIFY THIS LINE -- hsc-dependencies follow ---\n");
        }
#line 337
        if (tmp___1) {
          {
#line 340
          ugly_app_estr(lines_precede, (CONSTRPTR )line);
          }
        } else {
#line 338
          found = (BOOL )1;
        }
      }
#line 333
      if (! found) {
        {
#line 333
        tmp___2 = __errno_location();
        }
#line 333
        if (*tmp___2) {
#line 333
          goto while_break___0;
        } else
#line 333
        if (! line) {
#line 333
          goto while_break___0;
        }
      } else {
#line 333
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 345
    tmp___14 = __errno_location();
    }
#line 345
    if (*tmp___14) {
      {
#line 347
      tmp___3 = __errno_location();
#line 347
      tmp___4 = strerror(*tmp___3);
#line 347
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error reading `%s\': %s\n",
              makefile, tmp___4);
#line 348
      set_return_code___0(1);
      }
    } else
#line 350
    if (! line) {
#line 353
      if (verbose) {
        {
#line 354
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no starting tag-line; appending dependencies\n",
                makefile);
        }
      }
    } else {
#line 362
      if (debug) {
        {
#line 362
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscdep* starting tagline found\n");
        }
      }
#line 364
      found = (BOOL )0;
      {
#line 365
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 367
        line = fgets((char */* __restrict  */)(buf___0), 1024, (FILE */* __restrict  */)file);
        }
#line 368
        if (line) {
          {
#line 369
          tmp___5 = strcmp((char const   *)line, "# --- DO NOT MODIFY THIS LINE -- hsc-dependencies precede ---\n");
          }
#line 369
          if (! tmp___5) {
#line 370
            found = (BOOL )1;
          }
        }
#line 365
        if (! found) {
          {
#line 365
          tmp___6 = __errno_location();
          }
#line 365
          if (*tmp___6) {
#line 365
            goto while_break___1;
          } else
#line 365
          if (! line) {
#line 365
            goto while_break___1;
          }
        } else {
#line 365
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 374
      tmp___13 = __errno_location();
      }
#line 374
      if (*tmp___13) {
        {
#line 376
        tmp___7 = __errno_location();
#line 376
        tmp___8 = strerror(*tmp___7);
#line 376
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error reading `%s\': %s\n",
                makefile, tmp___8);
#line 377
        set_return_code___0(1);
        }
      } else
#line 379
      if (! line) {
#line 382
        if (verbose) {
          {
#line 383
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no ending tag-line; appending dependencies\n",
                  makefile);
          }
        }
      } else {
#line 391
        if (debug) {
          {
#line 391
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscdep* ending tagline found\n");
          }
        }
        {
#line 392
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 394
          line = fgets((char */* __restrict  */)(buf___0), 1024, (FILE */* __restrict  */)file);
          }
#line 395
          if (line) {
            {
#line 396
            ugly_app_estr(lines_follow, (CONSTRPTR )line);
            }
          }
          {
#line 392
          tmp___9 = __errno_location();
          }
#line 392
          if (*tmp___9) {
#line 392
            goto while_break___2;
          } else
#line 392
          if (! line) {
#line 392
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 400
        tmp___12 = __errno_location();
        }
#line 400
        if (*tmp___12) {
          {
#line 402
          tmp___10 = __errno_location();
#line 402
          tmp___11 = strerror(*tmp___10);
#line 402
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error reading `%s\': %s\n",
                  makefile, tmp___11);
#line 403
          set_return_code___0(1);
          }
        }
      }
    }
    {
#line 408
    tmp___15 = __errno_location();
    }
#line 408
    if (! *tmp___15) {
#line 410
      if (verbose) {
        {
#line 411
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: makefile read\n",
                makefile);
        }
      }
#line 412
      ok = (BOOL )1;
    }
    {
#line 415
    fclose(file);
    }
  }
#line 418
  return (ok);
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static BOOL read_project(void) 
{ 
  BOOL ok ;
  INFILE *inpf ;
  int *tmp ;
  BOOL tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 428
  ok = (BOOL )0;
#line 429
  inpf = (INFILE *)((void *)0);
#line 431
  if (verbose) {
    {
#line 433
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: reading..\r",
            prjfile);
#line 434
    fflush(stderr);
    }
  }
  {
#line 438
  project->CB_msg_corrupt_pf = & msg_corrupt_pf;
#line 441
  tmp = __errno_location();
#line 441
  *tmp = 0;
#line 442
  inpf = infopen((CONSTRPTR )prjfile, (size_t )65536);
  }
#line 443
  if (inpf) {
    {
#line 445
    tmp___0 = hsc_project_read_data(project, inpf);
    }
#line 445
    if (tmp___0) {
#line 447
      if (verbose) {
        {
#line 448
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: project-file read\n",
                prjfile);
        }
      }
#line 449
      ok = (BOOL )1;
    }
#line 451
    if (inpf) {
      {
#line 451
      infclose1(inpf);
#line 451
      inpf = (INFILE *)((void *)0);
      }
    }
  }
#line 454
  if (! ok) {
    {
#line 456
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error reading `%s\'",
            prjfile);
#line 457
    tmp___3 = __errno_location();
    }
#line 457
    if (*tmp___3) {
      {
#line 458
      tmp___1 = __errno_location();
#line 458
      tmp___2 = strerror(*tmp___1);
#line 458
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
              tmp___2);
      }
    }
    {
#line 459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 462
  return (ok);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static VOID depline_appstr(STRPTR s___2 , ULONG *linelen ) 
{ 
  size_t slen ;
  size_t tmp ;

  {
  {
#line 476
  tmp = strlen((char const   *)s___2);
#line 476
  slen = tmp;
  }
#line 480
  if (*linelen + slen >= 75UL) {
#line 482
    if (debug) {
      {
#line 482
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscdep* break line after %lu chars to avoid %lu\n",
              *linelen, *linelen + slen);
      }
    }
    {
#line 485
    ugly_app_estr(lines_depend, " \\\n");
#line 486
    ugly_app_estr(lines_depend, "   ");
#line 487
    *linelen = strlen("   ");
    }
  }
  {
#line 490
  ugly_app_estrch(lines_depend, ' ');
#line 491
  ugly_app_estr(lines_depend, (CONSTRPTR )s___2);
#line 492
  *linelen = (*linelen + slen) + 1UL;
  }
#line 493
  return;
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
static BOOL update_makefile(void) 
{ 
  BOOL ok ;
  ULONG linelen ;
  DLNODE *docnode ;
  BOOL bak_ok ;
  time_t now ;
  time_t tmp ;
  STRARR timebuf___2[40] ;
  struct tm *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  HSCDOC *document ;
  HSCDOC *document___0 ;
  DLNODE *incnode ;
  size_t tmp___3 ;
  HSCINC *include ;
  EXPSTR *makefile_bak ;
  EXPSTR *tmp___4 ;
  int tmp___5 ;
  FILE *outf ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 500
  ok = (BOOL )0;
#line 501
  linelen = (ULONG )0;
#line 502
  docnode = (project->documents)->first;
#line 503
  bak_ok = (BOOL )1;
#line 505
  lines_depend = ugly_init_estr((size_t )16384);
  }
#line 508
  if (! notaglines) {
    {
#line 510
    ugly_app_estr(lines_depend, "# --- DO NOT MODIFY THIS LINE -- hsc-dependencies follow ---\n");
    }
  }
#line 514
  if (! notaglines) {
    {
#line 517
    tmp = time((time_t *)((void *)0));
#line 517
    now = tmp;
#line 520
    tmp___0 = localtime((time_t const   *)(& now));
#line 520
    tmp___1 = strftime((char */* __restrict  */)(timebuf___2), (size_t )40, (char const   */* __restrict  */)"%A %d-%b-%Y %H:%M:%S",
                       (struct tm  const  */* __restrict  */)tmp___0);
    }
#line 520
    if (tmp___1) {
      {
#line 523
      ugly_app_estr(lines_depend, "\n# dependencies updated: ");
#line 524
      ugly_app_estr(lines_depend, (CONSTRPTR )(timebuf___2));
#line 525
      ugly_app_estr(lines_depend, "\n\n");
      }
    }
  }
  {
#line 532
  ugly_app_estr(lines_depend, (CONSTRPTR )nameall);
#line 533
  ugly_app_estr(lines_depend, " :");
#line 534
  tmp___2 = strlen((char const   *)nameall);
#line 534
  linelen = tmp___2 + 2UL;
  }
  {
#line 536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 536
    if (! docnode) {
#line 536
      goto while_break;
    }
    {
#line 538
    document = (HSCDOC *)docnode->data;
#line 539
    depline_appstr(document->docname, & linelen);
#line 541
    docnode = docnode->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 543
  ugly_app_estr(lines_depend, "\n\n");
#line 548
  docnode = (project->documents)->first;
  }
  {
#line 549
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 549
    if (! docnode) {
#line 549
      goto while_break___0;
    }
#line 551
    document___0 = (HSCDOC *)docnode->data;
#line 552
    incnode = (document___0->includes)->first;
#line 554
    if (debug) {
      {
#line 554
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscdep* document `%s\'\n",
              document___0->docname);
      }
    }
    {
#line 556
    ugly_app_estr(lines_depend, (CONSTRPTR )document___0->docname);
#line 557
    ugly_app_estr(lines_depend, " :");
#line 559
    tmp___3 = strlen((char const   *)document___0->docname);
#line 559
    linelen = tmp___3 + 2UL;
#line 562
    depline_appstr(document___0->sourcename, & linelen);
    }
    {
#line 565
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 565
      if (! incnode) {
#line 565
        goto while_break___1;
      }
      {
#line 567
      include = (HSCINC *)incnode->data;
#line 568
      depline_appstr(include->name, & linelen);
#line 570
      incnode = incnode->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 574
    ugly_app_estr(lines_depend, "\n\n");
#line 576
    docnode = docnode->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 580
  if (! notaglines) {
    {
#line 581
    ugly_app_estr(lines_depend, "# --- DO NOT MODIFY THIS LINE -- hsc-dependencies precede ---\n");
    }
  }
#line 586
  if (! nobackup) {
    {
#line 588
    tmp___4 = ugly_init_estr((size_t )32);
#line 588
    makefile_bak = tmp___4;
#line 590
    ugly_set_estr(makefile_bak, (CONSTRPTR )makefile);
#line 591
    ugly_app_estr(makefile_bak, ".bak");
#line 594
    remove((char const   *)makefile_bak->es_data);
#line 601
    tmp___5 = rename((char const   *)makefile, (char const   *)makefile_bak->es_data);
    }
#line 601
    if (! tmp___5) {
#line 603
      if (verbose) {
        {
#line 604
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: backup created\n",
                makefile_bak->es_data);
        }
      }
    }
    {
#line 608
    del_estr(makefile_bak);
    }
  }
#line 614
  if (bak_ok) {
    {
#line 616
    outf = (FILE *)((void *)0);
#line 619
    tmp___6 = __errno_location();
#line 619
    *tmp___6 = 0;
#line 620
    outf = fopen((char const   */* __restrict  */)makefile, (char const   */* __restrict  */)"w");
    }
#line 621
    if (outf) {
      {
#line 624
      tmp___7 = __errno_location();
#line 624
      *tmp___7 = 0;
#line 625
      fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s%s%s",
              lines_precede->es_data, lines_depend->es_data, lines_follow->es_data);
#line 629
      tmp___10 = __errno_location();
      }
#line 629
      if (*tmp___10) {
        {
#line 632
        tmp___8 = __errno_location();
#line 632
        tmp___9 = strerror(*tmp___8);
#line 632
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error writing to `%s\': %s\n",
                makefile, tmp___9);
        }
      } else {
#line 636
        ok = (BOOL )1;
      }
      {
#line 639
      fclose(outf);
      }
    } else {
      {
#line 644
      tmp___11 = __errno_location();
#line 644
      tmp___12 = strerror(*tmp___11);
#line 644
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error opening `%s\' for output: %s\n",
              makefile, tmp___12);
      }
    }
  }
#line 649
  return (ok);
}
}
#line 657 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscdepp.c"
int main(int argc , char **argv ) 
{ 
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;
  int tmp___3 ;

  {
  {
#line 663
  call_set_prginfo2((STRPTR )"hscdepp", (STRPTR )"T.Aglassinger/Tommy-Saftw\366rx, Matthias Bethke",
                    1, 4, 0, (STRPTR )"17.11.01", (STRPTR )"20:22:17", (STRPTR )"hsc dependency procreator",
                    (STRPTR )"Freeware, type `hscdepp LICENSE\' for details.");
#line 670
  atexit(& atexit_uglymemory_dummy);
#line 674
  ugly_nomem_handler = & hscdepp_nomem_handler;
#line 677
  tmp___3 = atexit(& cleanup);
  }
#line 677
  if (tmp___3) {
    {
#line 701
    fputs((char const   */* __restrict  */)"*** atexit() failed ", (FILE */* __restrict  */)stderr);
    }
  } else {
    {
#line 682
    return_code___0 = 0;
#line 683
    project = new_project();
    }
#line 684
    if (project) {
      {
#line 684
      tmp = args_ok___0(argc, argv);
      }
#line 684
      if (tmp) {
        {
#line 684
        tmp___0 = read_makefile();
        }
#line 684
        if (tmp___0) {
          {
#line 684
          tmp___1 = read_project();
          }
#line 684
          if (tmp___1) {
            {
#line 684
            tmp___2 = update_makefile();
            }
#line 684
            if (tmp___2) {
#line 691
              if (verbose) {
                {
#line 693
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: updated using `%s\'\n",
                        makefile, prjfile);
                }
              }
#line 696
              return_code___0 = 0;
            }
          }
        }
      }
    }
  }
#line 703
  return (return_code___0);
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
int last_ch(STRPTR s___2 ) 
{ 
  size_t len ;
  size_t tmp ;
  int ch ;

  {
  {
#line 45
  tmp = strlen((char const   *)s___2);
#line 45
  len = tmp;
#line 46
  ch = 0;
  }
#line 48
  if (len) {
#line 50
    ch = (int )*(s___2 + (len - 1UL));
  } else {
#line 54
    ch = 0;
  }
#line 57
  return (ch);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
STRPTR ugly_strclone(CONSTRPTR oldstr , STRPTR file , ULONG line ) 
{ 
  STRPTR newstr ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 72
  newstr = (STRPTR )((void *)0);
#line 74
  if (oldstr) {
    {
#line 79
    tmp = strlen(oldstr);
#line 79
    tmp___0 = ugly_malloc_notracking(tmp + 1UL);
#line 79
    newstr = (STRPTR )tmp___0;
    }
#line 82
    if (newstr) {
      {
#line 83
      strcpy((char */* __restrict  */)newstr, (char const   */* __restrict  */)oldstr);
      }
    } else {
      {
#line 85
      display_panic_message((char *)"out of memory while trying to clone string",
                            (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c",
                            (size_t )85);
      }
    }
  }
#line 87
  return (newstr);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
STRPTR lowstr(STRPTR s___2 ) 
{ 
  STRPTR s_old ;
  int tmp ;

  {
#line 97
  s_old = s___2;
#line 99
  if (s___2) {
    {
#line 100
    while (1) {
      while_continue: /* CIL Label */ ;
#line 100
      if (! ((int )*s___2 != 0)) {
#line 100
        goto while_break;
      }
      {
#line 101
      tmp = tolower((int )*s___2);
#line 101
      *s___2 = (char )tmp;
#line 100
      s___2 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 103
  return (s_old);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
STRPTR upstr(STRPTR s___2 ) 
{ 
  STRPTR s_old ;
  int tmp ;

  {
#line 112
  s_old = s___2;
#line 114
  if (s___2) {
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;
#line 115
      if (! ((int )*s___2 != 0)) {
#line 115
        goto while_break;
      }
      {
#line 116
      tmp = toupper((int )*s___2);
#line 116
      *s___2 = (char )tmp;
#line 115
      s___2 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 118
  return (s_old);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
int upstrcmp(CONSTRPTR s1 , CONSTRPTR s2 ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  size_t i ;
  int tmp ;
  int tmp___0 ;

  {
#line 134
  i = (size_t )0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 137
    tmp = toupper((int )*(s1 + i));
#line 137
    c1 = (unsigned char )tmp;
#line 138
    tmp___0 = toupper((int )*(s2 + i));
#line 138
    c2 = (unsigned char )tmp___0;
#line 139
    i ++;
    }
#line 136
    if (c1) {
#line 136
      if (c2) {
#line 136
        if (! ((int )c1 == (int )c2)) {
#line 136
          goto while_break;
        }
      } else {
#line 136
        goto while_break;
      }
    } else {
#line 136
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return ((int )c2 - (int )c1);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
int upstrncmp(CONSTRPTR s1 , CONSTRPTR s2 , size_t n ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  size_t i ;
  int tmp ;
  int tmp___0 ;

  {
#line 158
  i = (size_t )0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 161
    tmp = toupper((int )*(s1 + i));
#line 161
    c1 = (unsigned char )tmp;
#line 162
    tmp___0 = toupper((int )*(s2 + i));
#line 162
    c2 = (unsigned char )tmp___0;
#line 163
    i ++;
    }
#line 160
    if (c1) {
#line 160
      if (c2) {
#line 160
        if ((int )c1 == (int )c2) {
#line 160
          if (! (i < n)) {
#line 160
            goto while_break;
          }
        } else {
#line 160
          goto while_break;
        }
      } else {
#line 160
        goto while_break;
      }
    } else {
#line 160
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return ((int )c2 - (int )c1);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
STRPTR upstrstr(CONSTRPTR s1 , CONSTRPTR s2 ) 
{ 
  char const   *c1 ;
  char const   *c2 ;
  int tmp ;
  int tmp___0 ;
  CONSTRPTR tmp___1 ;

  {
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    c1 = s1;
#line 180
    c2 = s2;
    {
#line 182
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 182
      if ((int const   )*c1 != 0) {
        {
#line 182
        tmp = toupper((int )*(c1 + 0));
#line 182
        tmp___0 = toupper((int )*(c2 + 0));
        }
#line 182
        if (! (tmp == tmp___0)) {
#line 182
          goto while_break___0;
        }
      } else {
#line 182
        goto while_break___0;
      }
#line 183
      c1 ++;
#line 184
      c2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 187
    if ((int const   )*c2 == 0) {
#line 188
      return ((char *)s1);
    }
#line 178
    tmp___1 = s1;
#line 178
    s1 ++;
#line 178
    if (! ((int const   )*tmp___1 != 0)) {
#line 178
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return ((STRPTR )((void *)0));
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
void ugly_freestr(STRPTR s___2 , STRPTR file , ULONG line ) 
{ 


  {
#line 209
  if (s___2) {
    {
#line 209
    free((void *)s___2);
#line 209
    s___2 = (STRPTR )((void *)0);
    }
  }
#line 211
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
void ugly_reallocstr(STRPTR *oldstr , CONSTRPTR newstr , STRPTR file , ULONG line ) 
{ 


  {
#line 230
  if (*oldstr) {
    {
#line 230
    free((void *)*oldstr);
#line 230
    *oldstr = (STRPTR )((void *)0);
    }
  }
  {
#line 231
  *oldstr = ugly_strclone(newstr, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c",
                          (ULONG )231);
  }
#line 233
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
static char ch2str_buffer[2]  ;
#line 251 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
STRPTR ch2str(char const   ch ) 
{ 


  {
#line 254
  ch2str_buffer[0] = (char )ch;
#line 255
  ch2str_buffer[1] = (char )'\000';
#line 257
  return (ch2str_buffer);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
STRPTR ustrrpbrk(CONSTRPTR str , CONSTRPTR set ) 
{ 
  size_t i ;
  STRPTR result ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 275
  result = (STRPTR )((void *)0);
#line 277
  if (str) {
#line 277
    if (0 != (int )*(str + 0)) {
      {
#line 279
      tmp = strlen(str);
#line 279
      i = tmp - 1UL;
      }
      {
#line 281
      while (1) {
        while_continue: /* CIL Label */ ;
#line 281
        if (i) {
          {
#line 281
          tmp___0 = strchr(set, (int )*(str + i));
          }
#line 281
          if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 281
            goto while_break;
          }
        } else {
#line 281
          goto while_break;
        }
#line 282
        i --;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 284
      tmp___1 = strchr(set, (int )*(str + i));
      }
#line 284
      if (tmp___1) {
#line 285
        result = (STRPTR )(str + i);
      }
    }
  }
#line 287
  return (result);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
BOOL str2long(STRPTR s___2 , LONG *num ) 
{ 
  BOOL conv_ok ;
  int tmp ;

  {
  {
#line 302
  conv_ok = (BOOL )0;
#line 304
  tmp = sscanf((char const   */* __restrict  */)s___2, (char const   */* __restrict  */)"%d",
               (int *)num);
  }
#line 304
  if (tmp) {
#line 305
    conv_ok = (BOOL )1;
  }
#line 306
  return (conv_ok);
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
static char num2str_buffer[10]  ;
#line 319 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
STRPTR long2str(LONG num ) 
{ 
  STRPTR result_str ;
  int tmp ;

  {
  {
#line 322
  result_str = (STRPTR )((void *)0);
#line 324
  tmp = sprintf((char */* __restrict  */)(num2str_buffer), (char const   */* __restrict  */)"%d",
                (int )num);
  }
#line 324
  if (tmp) {
#line 325
    result_str = num2str_buffer;
  }
#line 326
  return (result_str);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
LONG strenum(CONSTRPTR str , CONSTRPTR set , char sep , BYTE options ) 
{ 
  STRPTR s___2 ;
  STRPTR tmp ;
  LONG found ;
  STRPTR nxtstr ;
  STRPTR tmp___0 ;
  char *tmp___1 ;
  LONG count ;
  int tmp___2 ;
  int tmp___3 ;
  STRPTR tmp___4 ;

  {
  {
#line 348
  tmp = ugly_strclone(set, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c",
                      (ULONG )348);
#line 348
  s___2 = tmp;
#line 349
  found = (LONG )0;
  }
#line 351
  if (s___2) {
    {
#line 353
    tmp___0 = ch2str((char const   )sep);
#line 353
    tmp___1 = strtok((char */* __restrict  */)s___2, (char const   */* __restrict  */)tmp___0);
#line 353
    nxtstr = tmp___1;
#line 354
    count = (LONG )1;
    }
    {
#line 356
    while (1) {
      while_continue: /* CIL Label */ ;
#line 356
      if (! found) {
#line 356
        if (! nxtstr) {
#line 356
          goto while_break;
        }
      } else {
#line 356
        goto while_break;
      }
#line 358
      if ((int )options & 1) {
        {
#line 359
        tmp___2 = upstrcmp(str, (CONSTRPTR )nxtstr);
        }
#line 359
        if (! tmp___2) {
#line 360
          found = count;
        }
      } else {
        {
#line 361
        tmp___3 = strcmp(str, (char const   *)nxtstr);
        }
#line 361
        if (! tmp___3) {
#line 362
          found = count;
        }
      }
      {
#line 364
      count ++;
#line 365
      tmp___4 = ch2str((char const   )sep);
#line 365
      nxtstr = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)tmp___4);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 367
    ugly_freestr(s___2, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c",
                 (ULONG )367);
#line 367
    s___2 = (STRPTR )((void *)0);
    }
  } else {
#line 369
    found = (LONG )-1;
  }
#line 370
  return (found);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.h"
DLLIST *init_dllist(void (*fn_del_data)(APTR data ) ) ;
#line 93
DLNODE *app_dlnode(DLLIST *list , APTR data ) ;
#line 100
void del_dllist(DLLIST *list ) ;
#line 108
DLNODE *find_dlnode(DLNODE *start , APTR data , int (*compare)(APTR cmp_data , APTR list_data ) ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_fre.c"
void del_arginfo(APTR data ) 
{ 
  struct arginfo *arg ;

  {
#line 55
  arg = (struct arginfo *)data;
#line 57
  if (arg) {
#line 61
    if (arg->ai_type == 5L) {
      {
#line 62
      ugly_freestr(arg->ai_misc1.ai_enum, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_fre.c",
                   (ULONG )62);
#line 62
      arg->ai_misc1.ai_enum = (STRPTR )((void *)0);
      }
    }
    {
#line 65
    ugly_freestr(arg->ai_id, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_fre.c",
                 (ULONG )65);
#line 65
    arg->ai_id = (STRPTR )((void *)0);
#line 66
    ugly_freestr(arg->ai_help, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_fre.c",
                 (ULONG )66);
#line 66
    arg->ai_help = (STRPTR )((void *)0);
#line 67
    arg->ai_type = (LONG )0;
#line 68
    arg->ai_dest = (void *)0;
#line 69
    arg->ai_func = (STRPTR (*)(STRPTR  ))((void *)0);
    }
#line 72
    if (arg) {
      {
#line 72
      free((void *)arg);
#line 72
      arg = (struct arginfo *)((void *)0);
      }
    }
  }
#line 76
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_fre.c"
void free_args(struct arglist *al ) 
{ 


  {
#line 88
  if (al) {
    {
#line 90
    del_dllist(al->al_list);
    }
#line 91
    if (al) {
      {
#line 91
      free((void *)al);
#line 91
      al = (struct arglist *)((void *)0);
      }
    }
  }
#line 93
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.h"
BOOL fexists(STRPTR filename ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static int arg_error_num  =    -1;
#line 65 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static STRPTR arg_error_arg  =    (STRPTR )((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static STRPTR arg_error_hfs  =    (STRPTR )((void *)0);
#line 72 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static STRARR argerrstr[60]  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static BOOL no_argerr  =    (BOOL )1;
#line 78 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static BOOL any_argerr  =    (BOOL )0;
#line 79 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static int argidx  =    -1;
#line 86 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static int compare_arginfo(APTR cmp_data , APTR list_data ) 
{ 
  struct arginfo *ai ;
  STRPTR lst_arg ;
  STRPTR tmp ;
  STRPTR cmp_arg ;
  BOOL eq ;
  char lastch ;
  STRPTR nxt_arg ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 88
  ai = (struct arginfo *)list_data;
#line 89
  tmp = ugly_strclone((CONSTRPTR )ai->ai_id, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c",
                      (ULONG )89);
#line 89
  lst_arg = tmp;
#line 90
  cmp_arg = ((struct arginfo *)cmp_data)->ai_id;
#line 91
  eq = (BOOL )0;
  }
#line 94
  if (lst_arg) {
#line 94
    if (cmp_arg) {
      {
#line 96
      tmp___0 = strtok((char */* __restrict  */)lst_arg, (char const   */* __restrict  */)"=");
#line 96
      nxt_arg = tmp___0;
      }
      {
#line 98
      while (1) {
        while_continue: /* CIL Label */ ;
#line 98
        if (nxt_arg) {
#line 98
          if (! ((int )eq == 0)) {
#line 98
            goto while_break;
          }
        } else {
#line 98
          goto while_break;
        }
#line 100
        if (ai->ai_flags & (long )(1 << 3)) {
          {
#line 102
          tmp___1 = strlen((char const   *)nxt_arg);
#line 102
          tmp___2 = strncmp((char const   *)nxt_arg, (char const   *)cmp_arg, tmp___1);
#line 102
          eq = (BOOL )(tmp___2 == 0);
          }
        } else {
          {
#line 106
          tmp___3 = strlen((char const   *)nxt_arg);
#line 106
          tmp___4 = upstrncmp((CONSTRPTR )nxt_arg, (CONSTRPTR )cmp_arg, tmp___3);
#line 106
          eq = (BOOL )(tmp___4 == 0);
          }
        }
        {
#line 116
        tmp___5 = strlen((char const   *)nxt_arg);
#line 116
        lastch = *(cmp_arg + tmp___5);
        }
#line 117
        if ((int )lastch == 0) {
#line 117
          tmp___6 = 1;
        } else
#line 117
        if ((int )lastch == 61) {
#line 117
          tmp___6 = 1;
        } else {
#line 117
          tmp___6 = 0;
        }
        {
#line 117
        eq = (BOOL )((int )eq & tmp___6);
#line 119
        nxt_arg = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"=");
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 125
      eq = (BOOL )0;
    }
  } else {
#line 125
    eq = (BOOL )0;
  }
  {
#line 128
  ugly_freestr(lst_arg, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c",
               (ULONG )128);
#line 128
  lst_arg = (STRPTR )((void *)0);
  }
#line 130
  return ((int )eq);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID clr_ai_set(ARGLIST *al ) 
{ 
  struct dlnode *nd ;
  struct arginfo *ai ;

  {
#line 157
  if (al) {
#line 157
    if (al->al_list) {
#line 159
      nd = (al->al_list)->first;
      {
#line 161
      while (1) {
        while_continue: /* CIL Label */ ;
#line 161
        if (! nd) {
#line 161
          goto while_break;
        }
#line 163
        ai = (struct arginfo *)nd->data;
#line 165
        if (ai) {
#line 166
          ai->ai_set = (BOOL )0;
        }
#line 167
        nd = nd->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 170
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID reset_nokeywd(ARGLIST *al ) 
{ 
  struct dlnode *nd ;
  struct arginfo *ai ;

  {
#line 186
  nd = (al->al_list)->first;
#line 187
  ai = (struct arginfo *)nd->data;
#line 189
  if (ai->ai_flags & 1L) {
#line 189
    goto _L___0;
  } else
#line 189
  if (ai->ai_type == 1L) {
    _L___0: /* CIL Label */ 
#line 191
    al->al_nokeywd = (struct arginfo *)((void *)0);
    {
#line 193
    while (1) {
      while_continue: /* CIL Label */ ;
#line 195
      if (ai->ai_flags & 1L) {
#line 195
        goto _L;
      } else
#line 195
      if (ai->ai_type == 1L) {
        _L: /* CIL Label */ 
#line 198
        nd = nd->next;
#line 199
        if (nd) {
#line 200
          ai = (struct arginfo *)nd->data;
        }
      } else {
#line 203
        al->al_nokeywd = ai;
      }
#line 193
      if (nd) {
#line 193
        if (! (! al->al_nokeywd)) {
#line 193
          goto while_break;
        }
      } else {
#line 193
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 209
    al->al_nokeywd = ai;
  }
#line 211
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID find_nxt_nokeywd(ARGLIST *al ) 
{ 
  struct dlnode *nd ;
  struct arginfo *ai ;
  BOOL is_keywd ;
  BOOL multiple_nokeywd ;
  int tmp ;

  {
#line 221
  if (al->al_nokeywd) {
#line 253
    nd = (al->al_list)->first;
#line 259
    al->al_nokeywd = (struct arginfo *)((void *)0);
    {
#line 260
    while (1) {
      while_continue: /* CIL Label */ ;
#line 260
      if (nd) {
#line 260
        if (! ((unsigned long )al->al_nokeywd == (unsigned long )((void *)0))) {
#line 260
          goto while_break;
        }
      } else {
#line 260
        goto while_break;
      }
#line 262
      is_keywd = (BOOL )0;
#line 263
      multiple_nokeywd = (BOOL )0;
#line 265
      ai = (struct arginfo *)nd->data;
#line 267
      is_keywd = (BOOL )(ai->ai_flags & 1L);
#line 268
      if (ai->ai_flags & (long )(1 << 2)) {
#line 268
        if (! is_keywd) {
#line 268
          tmp = 1;
        } else {
#line 268
          tmp = 0;
        }
      } else {
#line 268
        tmp = 0;
      }
#line 268
      multiple_nokeywd = (BOOL )tmp;
#line 272
      if (ai->ai_flags & 1L) {
#line 272
        goto _L;
      } else
#line 272
      if (ai->ai_type == 1L) {
#line 272
        goto _L;
      } else
#line 272
      if (ai->ai_set) {
        _L: /* CIL Label */ 
#line 272
        if (! multiple_nokeywd) {
#line 277
          nd = nd->next;
        } else {
#line 281
          al->al_nokeywd = ai;
        }
      } else {
#line 281
        al->al_nokeywd = ai;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 285
  return;
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID set_argerr(int num , STRPTR arg ) 
{ 


  {
#line 294
  if (no_argerr) {
#line 296
    no_argerr = (BOOL )0;
#line 297
    any_argerr = (BOOL )1;
#line 299
    arg_error_num = num;
#line 300
    arg_error_arg = arg;
  }
#line 302
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID clr_argerr(void) 
{ 


  {
#line 306
  no_argerr = (BOOL )1;
#line 307
  any_argerr = (BOOL )0;
#line 308
  arg_error_num = 0;
#line 309
  arg_error_arg = (STRPTR )((void *)0);
#line 310
  return;
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
STRPTR strargerr(void) 
{ 
  STRPTR str ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 321
  str = (STRPTR )"unknown error";
  {
#line 325
  if (arg_error_num == 1) {
#line 325
    goto case_1;
  }
#line 329
  if (arg_error_num == 8) {
#line 329
    goto case_8;
  }
#line 333
  if (arg_error_num == 7) {
#line 333
    goto case_7;
  }
#line 337
  if (arg_error_num == 2) {
#line 337
    goto case_2;
  }
#line 341
  if (arg_error_num == 5) {
#line 341
    goto case_5;
  }
#line 345
  if (arg_error_num == 3) {
#line 345
    goto case_3;
  }
#line 349
  if (arg_error_num == 6) {
#line 349
    goto case_6;
  }
#line 353
  if (arg_error_num == 4) {
#line 353
    goto case_4;
  }
#line 356
  if (arg_error_num == 9) {
#line 356
    goto case_9;
  }
#line 360
  if (arg_error_num == 127) {
#line 360
    goto case_127;
  }
#line 323
  goto switch_break;
  case_1: /* CIL Label */ 
#line 326
  str = (STRPTR )"out of memory";
#line 327
  goto switch_break;
  case_8: /* CIL Label */ 
#line 330
  str = (STRPTR )"argument occured twice";
#line 331
  goto switch_break;
  case_7: /* CIL Label */ 
#line 334
  str = (STRPTR )"unknown keyword";
#line 335
  goto switch_break;
  case_2: /* CIL Label */ 
#line 338
  str = (STRPTR )"invalid numeric argument";
#line 339
  goto switch_break;
  case_5: /* CIL Label */ 
#line 342
  str = (STRPTR )"invalid enumerator value";
#line 343
  goto switch_break;
  case_3: /* CIL Label */ 
#line 346
  str = (STRPTR )"required argument missing";
#line 347
  goto switch_break;
  case_6: /* CIL Label */ 
#line 350
  str = (STRPTR )"empty template";
#line 351
  goto switch_break;
  case_4: /* CIL Label */ 
#line 354
  str = (STRPTR )"numeric argument out of range";
#line 355
  goto switch_break;
  case_9: /* CIL Label */ 
#line 357
  str = (STRPTR )"value after keyword missing";
#line 358
  goto switch_break;
  case_127: /* CIL Label */ 
#line 361
  str = arg_error_hfs;
#line 362
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 365
  strcpy((char */* __restrict  */)(argerrstr), (char const   */* __restrict  */)str);
  }
#line 366
  if (arg_error_arg) {
    {
#line 368
    tmp = strlen((char const   *)str);
#line 368
    strncat((char */* __restrict  */)(argerrstr), (char const   */* __restrict  */)": ",
            (60UL - tmp) - 1UL);
#line 369
    tmp___0 = strlen((char const   *)str);
#line 369
    strncat((char */* __restrict  */)(argerrstr), (char const   */* __restrict  */)arg_error_arg,
            (60UL - tmp___0) - 3UL);
    }
  }
#line 372
  if (arg_error_num) {
#line 374
    return (argerrstr);
  } else {
#line 378
    return ((STRPTR )((void *)0));
  }
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
void pargerr(void) 
{ 
  STRPTR tmp ;

  {
#line 390
  if (arg_error_num) {
    {
#line 392
    tmp = strargerr();
#line 392
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            tmp);
    }
  }
#line 394
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static UBYTE set_arg_value(struct arginfo *ai , STRPTR arg , STRPTR arg2 , BOOL keywd ) 
{ 
  APTR dest ;
  STRPTR param ;
  UBYTE arg_incr ;
  BOOL arg2used ;
  APTR aparam ;
  DLLIST **dest_list ;
  LONG along ;
  BOOL tmp ;
  LONG aenum ;
  LONG tmp___0 ;
  DLNODE *tmp___1 ;

  {
#line 404
  dest = ai->ai_dest;
#line 406
  arg_incr = (UBYTE )0;
#line 407
  arg2used = (BOOL )0;
#line 414
  if (keywd) {
#line 414
    if (! (ai->ai_type == 1L)) {
#line 416
      param = arg;
      {
#line 417
      while (1) {
        while_continue: /* CIL Label */ ;
#line 417
        if (*(param + 0)) {
#line 417
          if (! ((int )*(param + 0) != 61)) {
#line 417
            goto while_break;
          }
        } else {
#line 417
          goto while_break;
        }
#line 418
        param ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 419
      if (*(param + 0)) {
#line 420
        param ++;
      } else {
#line 423
        param = arg2;
#line 424
        arg2used = (BOOL )1;
#line 425
        if (! param) {
          {
#line 426
          set_argerr(3, arg);
          }
        }
      }
    } else {
#line 430
      param = arg;
    }
  } else {
#line 430
    param = arg;
  }
#line 435
  if (no_argerr) {
#line 437
    if (ai->ai_func) {
      {
#line 440
      arg_error_hfs = (*(ai->ai_func))(param);
      }
#line 441
      if (arg_error_hfs) {
        {
#line 442
        set_argerr(127, param);
        }
      }
    } else
#line 444
    if (ai->ai_type == 1L) {
#line 446
      *((BOOL *)dest) = (BOOL )1;
    } else {
#line 453
      if ((int )ai->ai_set == 2) {
#line 453
        if (ai->ai_flags & (long )(1 << 4)) {
#line 461
          ai->ai_set = (BOOL )2;
        } else
#line 453
        if (ai->ai_flags & (long )(1 << 2)) {
#line 461
          ai->ai_set = (BOOL )2;
        } else {
          {
#line 457
          set_argerr(8, arg);
          }
        }
      } else {
#line 461
        ai->ai_set = (BOOL )2;
      }
#line 464
      if (no_argerr) {
#line 466
        aparam = (void *)0;
#line 467
        dest_list = (DLLIST **)dest;
#line 473
        if (! param) {
          {
#line 476
          set_argerr(9, arg);
          }
        }
#line 478
        if (ai->ai_type == 2L) {
#line 480
          aparam = (APTR )param;
        } else
#line 482
        if (ai->ai_type == 3L) {
          {
#line 484
          tmp = str2long(param, & along);
          }
#line 484
          if (tmp) {
#line 487
            aparam = (APTR )along;
          } else {
            {
#line 485
            set_argerr(2, arg);
            }
          }
        } else
#line 489
        if (ai->ai_type == 5L) {
          {
#line 491
          tmp___0 = strenum((CONSTRPTR )param, (CONSTRPTR )ai->ai_misc1.ai_enum, (char )'|',
                            (BYTE )1);
#line 491
          aenum = tmp___0;
          }
#line 494
          if (! aenum) {
            {
#line 495
            set_argerr(5, arg);
            }
          } else {
#line 497
            aparam = (APTR )aenum;
          }
        }
#line 514
        if (no_argerr) {
#line 516
          if (ai->ai_flags & (long )(1 << 2)) {
#line 518
            if (! *dest_list) {
              {
#line 519
              *dest_list = init_dllist((void (*)(APTR data ))((void *)0));
              }
            }
#line 520
            if (*dest_list) {
              {
#line 522
              tmp___1 = app_dlnode(*dest_list, aparam);
              }
#line 522
              if (! tmp___1) {
                {
#line 523
                set_argerr(1, arg);
                }
              }
            } else {
              {
#line 526
              set_argerr(1, arg);
              }
            }
          } else
#line 530
          if (ai->ai_type == 3L) {
#line 531
            *((LONG *)dest) = (LONG )aparam;
          } else
#line 532
          if (ai->ai_type == 5L) {
#line 533
            *((LONG *)dest) = (LONG )aparam;
          } else
#line 534
          if (ai->ai_type == 2L) {
#line 535
            *((STRPTR *)dest) = (STRPTR )aparam;
          }
        }
      }
    }
#line 542
    if (arg2used) {
#line 543
      arg_incr = (UBYTE )1;
    }
  }
#line 546
  return (arg_incr);
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID check_required_set(ARGLIST *al ) 
{ 
  DLNODE *nd ;
  ARGINFO *ai ;

  {
#line 557
  nd = (al->al_list)->first;
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    ai = (struct arginfo *)nd->data;
#line 564
    if (ai->ai_flags & (long )(1 << 1)) {
#line 564
      if ((int )ai->ai_set == 0) {
        {
#line 565
        set_argerr(3, ai->ai_id);
        }
      } else {
#line 567
        nd = nd->next;
      }
    } else {
#line 567
      nd = nd->next;
    }
#line 560
    if (nd) {
#line 560
      if (! no_argerr) {
#line 560
        goto while_break;
      }
    } else {
#line 560
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return;
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
ARGFILE *new_argfile(char *argfname ) 
{ 
  ARGFILE *argf___0 ;
  void *tmp ;
  BOOL no_argerr___2 ;
  FILE *file ;
  void *tmp___0 ;
  STRPTR fgetsbuf ;
  void *tmp___1 ;
  STRPTR argline ;
  int i ;
  char **old_argv ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 580
  tmp = ugly_malloc_notracking(sizeof(ARGFILE ));
#line 580
  argf___0 = (ARGFILE *)tmp;
#line 582
  no_argerr___2 = (BOOL )1;
  }
#line 583
  if (argf___0) {
    {
#line 585
    file = (FILE *)((void *)0);
#line 587
    argf___0->argc = 0;
#line 588
    tmp___0 = ugly_malloc_notracking(2UL * sizeof(char *));
#line 588
    argf___0->argv = (char **)tmp___0;
#line 589
    *(argf___0->argv + 0) = (char *)((void *)0);
#line 590
    *(argf___0->argv + 1) = (char *)((void *)0);
    }
#line 592
    if (argfname) {
      {
#line 594
      *(argf___0->argv + 0) = ugly_strclone((CONSTRPTR )argfname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c",
                                            (ULONG )594);
#line 595
      file = fopen((char const   */* __restrict  */)argfname, (char const   */* __restrict  */)"r");
      }
    }
#line 597
    if (file) {
      {
#line 599
      tmp___1 = ugly_malloc_notracking((size_t )1024);
#line 599
      fgetsbuf = (STRPTR )tmp___1;
      }
#line 601
      if (fgetsbuf) {
#line 603
        argline = (STRPTR )((void *)0);
#line 604
        no_argerr___2 = (BOOL )0;
        {
#line 606
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 608
          argline = fgets((char */* __restrict  */)fgetsbuf, 1024, (FILE */* __restrict  */)file);
          }
#line 609
          if (argline) {
            {
#line 611
            i = 0;
#line 614
            old_argv = argf___0->argv;
#line 615
            (argf___0->argc) ++;
#line 616
            tmp___2 = ugly_malloc_notracking((unsigned long )(argf___0->argc + 2) * sizeof(char *));
#line 616
            argf___0->argv = (char **)tmp___2;
#line 619
            i = 0;
            }
            {
#line 619
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 619
              if (! (i <= argf___0->argc)) {
#line 619
                goto while_break___0;
              }
#line 621
              *(argf___0->argv + i) = *(old_argv + i);
#line 619
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 625
            if (old_argv) {
              {
#line 625
              free((void *)old_argv);
#line 625
              old_argv = (char **)((void *)0);
              }
            }
            {
#line 628
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 628
              if (*(fgetsbuf + 0)) {
                {
#line 628
                tmp___4 = strlen((char const   *)fgetsbuf);
#line 628
                tmp___5 = strchr("\r\n", (int )*(fgetsbuf + (tmp___4 - 1UL)));
                }
#line 628
                if (! tmp___5) {
#line 628
                  goto while_break___1;
                }
              } else {
#line 628
                goto while_break___1;
              }
              {
#line 631
              tmp___3 = strlen((char const   *)fgetsbuf);
#line 631
              *(fgetsbuf + (tmp___3 - 1UL)) = (char )'\000';
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 635
            *(argf___0->argv + argf___0->argc) = ugly_strclone((CONSTRPTR )fgetsbuf,
                                                               (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c",
                                                               (ULONG )635);
#line 636
            *(argf___0->argv + (argf___0->argc + 1)) = (char *)((void *)0);
            }
          }
#line 606
          if (! argline) {
#line 606
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 640
        (argf___0->argc) ++;
      }
#line 643
      if (fgetsbuf) {
        {
#line 643
        free((void *)fgetsbuf);
#line 643
        fgetsbuf = (STRPTR )((void *)0);
        }
      }
      {
#line 644
      fclose(file);
      }
    }
  }
#line 648
  return (argf___0);
}
}
#line 651 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
ARGFILE *new_argfilev(STRPTR *fname ) 
{ 
  int i ;
  BOOL tmp ;
  ARGFILE *tmp___0 ;

  {
#line 653
  i = 0;
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 655
    if (*(fname + i)) {
      {
#line 655
      tmp = fexists(*(fname + i));
      }
#line 655
      if (tmp) {
#line 655
        goto while_break;
      }
    } else {
#line 655
      goto while_break;
    }
#line 657
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 660
  tmp___0 = new_argfile(*(fname + i));
  }
#line 660
  return (tmp___0);
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
VOID del_argfile(ARGFILE *argf___0 ) 
{ 


  {
#line 668
  if (argf___0) {
    {
#line 670
    while (1) {
      while_continue: /* CIL Label */ ;
#line 670
      if (! (argf___0->argc + 1)) {
#line 670
        goto while_break;
      }
      {
#line 672
      ugly_freestr(*(argf___0->argv + argf___0->argc), (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c",
                   (ULONG )672);
#line 672
      *(argf___0->argv + argf___0->argc) = (char *)((void *)0);
#line 673
      (argf___0->argc) --;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 675
    if (argf___0->argv) {
      {
#line 675
      free((void *)argf___0->argv);
#line 675
      argf___0->argv = (char **)((void *)0);
      }
    }
#line 676
    if (argf___0) {
      {
#line 676
      free((void *)argf___0);
#line 676
      argf___0 = (ARGFILE *)((void *)0);
      }
    }
  }
#line 678
  return;
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
BOOL set_args_argv(int argc , char **argv , ARGLIST *al ) 
{ 
  struct arginfo search_ai ;
  struct arginfo *found_ai ;
  struct dlnode *ainode ;
  STRPTR arg2 ;
  UBYTE tmp ;
  UBYTE tmp___0 ;
  DLNODE *nd ;
  ARGINFO *ai ;

  {
  {
#line 696
  clr_argerr();
#line 697
  clr_ai_set(al);
#line 698
  reset_nokeywd(al);
#line 700
  argidx = 1;
  }
#line 702
  if ((unsigned long )al == (unsigned long )((void *)0)) {
    {
#line 703
    set_argerr(6, *(argv + argidx));
    }
  } else
#line 704
  if ((unsigned long )al->al_list == (unsigned long )((void *)0)) {
    {
#line 705
    set_argerr(6, *(argv + argidx));
    }
  }
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (argidx < argc) {
#line 707
      if (! no_argerr) {
#line 707
        goto while_break;
      }
    } else {
#line 707
      goto while_break;
    }
    {
#line 712
    arg2 = (STRPTR )((void *)0);
#line 720
    search_ai.ai_id = *(argv + argidx);
#line 721
    ainode = find_dlnode((al->al_list)->first, (APTR )(& search_ai), & compare_arginfo);
    }
#line 725
    if (argidx < argc - 1) {
#line 726
      arg2 = *(argv + (argidx + 1));
    }
#line 730
    if (ainode) {
      {
#line 732
      found_ai = (struct arginfo *)ainode->data;
#line 733
      tmp = set_arg_value(found_ai, *(argv + argidx), arg2, (BOOL )1);
#line 733
      argidx += (int )tmp;
      }
    } else {
      {
#line 737
      find_nxt_nokeywd(al);
      }
#line 738
      if (al->al_nokeywd) {
        {
#line 739
        tmp___0 = set_arg_value(al->al_nokeywd, *(argv + argidx), arg2, (BOOL )0);
#line 739
        argidx += (int )tmp___0;
        }
      } else {
        {
#line 741
        set_argerr(7, *(argv + argidx));
        }
      }
    }
#line 744
    argidx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 749
  if (no_argerr) {
#line 751
    nd = (al->al_list)->first;
    {
#line 752
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 752
      if (! nd) {
#line 752
        goto while_break___0;
      }
#line 754
      ai = (struct arginfo *)nd->data;
#line 755
      if ((int )ai->ai_set == 2) {
#line 756
        ai->ai_set = (BOOL )1;
      }
#line 757
      nd = nd->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 761
  return (no_argerr);
}
}
#line 769 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
BOOL check_args(ARGLIST *al ) 
{ 


  {
#line 772
  if (no_argerr) {
    {
#line 774
    check_required_set(al);
    }
  }
#line 777
  return (no_argerr);
}
}
#line 785 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
BOOL set_args(int argc , char **argv , ARGLIST *al ) 
{ 
  BOOL tmp ;
  BOOL tmp___0 ;
  int tmp___1 ;

  {
  {
#line 787
  tmp = set_args_argv(argc, argv, al);
  }
#line 787
  if (tmp) {
    {
#line 787
    tmp___0 = check_args(al);
    }
#line 787
    if (tmp___0) {
#line 787
      tmp___1 = 1;
    } else {
#line 787
      tmp___1 = 0;
    }
  } else {
#line 787
    tmp___1 = 0;
  }
#line 787
  return ((BOOL )tmp___1);
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
BOOL set_args_file(ARGFILE *argf___0 , ARGLIST *argl ) 
{ 
  BOOL tmp ;

  {
  {
#line 797
  tmp = set_args_argv(argf___0->argc, argf___0->argv, argl);
  }
#line 797
  return (tmp);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c"
LONG prep_error_num  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c"
int prep_error_idx  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c"
size_t prep_error_pos  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c"
BOOL no_preperr  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c"
BOOL any_preperr  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c"
void set_preperr(LONG num , size_t pos ) 
{ 


  {
#line 65
  if (no_preperr) {
#line 68
    no_preperr = (BOOL )0;
#line 69
    any_preperr = (BOOL )1;
#line 70
    prep_error_num = num;
#line 71
    prep_error_pos = pos;
  }
#line 74
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c"
void clr_preperr(void) 
{ 


  {
#line 78
  no_preperr = (BOOL )1;
#line 79
  any_preperr = (BOOL )0;
#line 80
  prep_error_num = (LONG )0;
#line 81
  prep_error_pos = (size_t )0;
#line 82
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c"
void fprintf_arginfo(FILE *stream , APTR data ) 
{ 
  struct arginfo *arg ;

  {
  {
#line 89
  arg = (struct arginfo *)data;
#line 91
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"  %-15s %2lx %2lx",
          arg->ai_id, arg->ai_type, arg->ai_flags);
  }
#line 93
  if (arg->ai_help) {
    {
#line 94
    printf((char const   */* __restrict  */)"  \"%s\"", arg->ai_help);
    }
  }
  {
#line 95
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n");
  }
#line 96
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c"
struct arglist *prepare_args(STRPTR arglist_name  , ...) 
{ 
  va_list ap ;
  struct dllist *newlist ;
  struct arginfo *newarg ;
  struct arglist *new_arglist ;
  void *tmp ;
  STRPTR nxtdef ;
  STRPTR tmp___0 ;
  void *tmp___1 ;
  STRPTR new_id ;
  STRPTR typestr ;
  STRPTR flagstr ;
  STRPTR enumstr ;
  LONG new_type ;
  LONG new_flags ;
  LONG rnlolim ;
  LONG rnhilim ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  APTR func_tmp ;
  STRPTR tmp___6 ;
  LONG tmp___7 ;
  LONG tmp___8 ;
  STRPTR tmp___9 ;
  APTR tmp___10 ;
  STRPTR tmp___12 ;
  DLNODE *tmp___13 ;

  {
  {
#line 108
  new_arglist = (struct arglist *)((void *)0);
#line 112
  clr_preperr();
#line 117
  tmp = ugly_malloc_notracking(sizeof(struct arglist ));
#line 117
  new_arglist = (struct arglist *)tmp;
  }
#line 120
  if (new_arglist) {
#line 121
    new_arglist->al_name = arglist_name;
#line 122
    new_arglist->al_list = (struct dllist *)((void *)0);
#line 123
    new_arglist->al_multiple = (struct arginfo *)((void *)0);
#line 124
    new_arglist->al_nokeywd = (struct arginfo *)((void *)0);
  } else {
    {
#line 126
    set_preperr((LONG )1, (size_t )0);
    }
  }
  {
#line 131
  newlist = init_dllist(& del_arginfo);
  }
#line 133
  if (new_arglist) {
#line 133
    if (newlist) {
      {
#line 135
      nxtdef = (STRPTR )((void *)0);
#line 137
      __builtin_va_start(ap, arglist_name);
      }
      {
#line 139
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 141
        ugly_freestr(nxtdef, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c",
                     (ULONG )141);
#line 141
        nxtdef = (STRPTR )((void *)0);
#line 142
        tmp___0 = __builtin_va_arg(ap, STRPTR );
#line 142
        nxtdef = tmp___0;
#line 147
        nxtdef = ugly_strclone((CONSTRPTR )nxtdef, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c",
                               (ULONG )147);
#line 148
        prep_error_idx ++;
        }
#line 150
        if (nxtdef) {
          {
#line 154
          tmp___1 = ugly_malloc_notracking(sizeof(struct arginfo ));
#line 154
          newarg = (struct arginfo *)tmp___1;
          }
#line 156
          if (newarg) {
            {
#line 159
            flagstr = (STRPTR )((void *)0);
#line 160
            enumstr = (STRPTR )((void *)0);
#line 161
            new_type = (LONG )0;
#line 162
            new_flags = (LONG )0;
#line 163
            rnlolim = (LONG )0;
#line 164
            rnhilim = (LONG )0;
#line 167
            newarg->ai_id = (STRPTR )((void *)0);
#line 168
            newarg->ai_type = (LONG )0;
#line 169
            newarg->ai_flags = (LONG )0;
#line 170
            newarg->ai_misc1.ai_lolim = (LONG )0;
#line 171
            newarg->ai_misc2.ai_uplim = (LONG )0;
#line 172
            newarg->ai_dest = (void *)0;
#line 173
            newarg->ai_func = (STRPTR (*)(STRPTR  ))((void *)0);
#line 174
            newarg->ai_help = (STRPTR )((void *)0);
#line 176
            new_id = strtok((char */* __restrict  */)nxtdef, (char const   */* __restrict  */)"/");
#line 178
            typestr = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"/");
            }
#line 183
            if (typestr) {
              {
#line 185
              tmp___3 = strlen((char const   *)typestr);
              }
#line 185
              if (tmp___3 == 1UL) {
                {
#line 187
                tmp___2 = toupper((int )*(typestr + 0));
                }
                {
#line 189
                if (tmp___2 == 84) {
#line 189
                  goto case_84;
                }
#line 193
                if (tmp___2 == 83) {
#line 193
                  goto case_83;
                }
#line 197
                if (tmp___2 == 78) {
#line 197
                  goto case_78;
                }
#line 201
                if (tmp___2 == 82) {
#line 201
                  goto case_82;
                }
#line 205
                if (tmp___2 == 69) {
#line 205
                  goto case_69;
                }
#line 187
                goto switch_break;
                case_84: /* CIL Label */ 
#line 190
                new_type = (LONG )2;
#line 191
                goto switch_break;
                case_83: /* CIL Label */ 
#line 194
                new_type = (LONG )1;
#line 195
                goto switch_break;
                case_78: /* CIL Label */ 
#line 198
                new_type = (LONG )3;
#line 199
                goto switch_break;
                case_82: /* CIL Label */ 
#line 202
                new_type = (LONG )4;
#line 203
                goto switch_break;
                case_69: /* CIL Label */ 
#line 206
                new_type = (LONG )5;
#line 207
                goto switch_break;
                switch_break: /* CIL Label */ ;
                }
#line 211
                if (new_type) {
                  {
#line 212
                  flagstr = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"/");
                  }
                } else {
#line 216
                  flagstr = typestr;
#line 217
                  new_type = (LONG )2;
                }
              } else {
                {
#line 221
                set_preperr((LONG )2, (size_t )0);
                }
              }
            } else {
#line 224
              flagstr = (STRPTR )((void *)0);
#line 225
              new_type = (LONG )2;
            }
            {
#line 231
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 231
              if (flagstr) {
#line 231
                if (*(flagstr + 0)) {
#line 231
                  if (! no_preperr) {
#line 231
                    goto while_break___0;
                  }
                } else {
#line 231
                  goto while_break___0;
                }
              } else {
#line 231
                goto while_break___0;
              }
              {
#line 233
              tmp___4 = toupper((int )*(flagstr + 0));
              }
              {
#line 235
              if (tmp___4 == 77) {
#line 235
                goto case_77;
              }
#line 239
              if (tmp___4 == 65) {
#line 239
                goto case_65;
              }
#line 243
              if (tmp___4 == 75) {
#line 243
                goto case_75;
              }
#line 247
              if (tmp___4 == 79) {
#line 247
                goto case_79;
              }
#line 251
              if (tmp___4 == 36) {
#line 251
                goto case_36;
              }
#line 255
              goto switch_default;
              case_77: /* CIL Label */ 
#line 236
              new_flags |= (long )(1 << 2);
#line 237
              goto switch_break___0;
              case_65: /* CIL Label */ 
#line 240
              new_flags |= (long )(1 << 1);
#line 241
              goto switch_break___0;
              case_75: /* CIL Label */ 
#line 244
              new_flags |= 1L;
#line 245
              goto switch_break___0;
              case_79: /* CIL Label */ 
#line 248
              new_flags |= (long )(1 << 4);
#line 249
              goto switch_break___0;
              case_36: /* CIL Label */ 
#line 252
              new_flags |= (long )(1 << 5);
#line 253
              goto switch_break___0;
              switch_default: /* CIL Label */ 
              {
#line 256
              set_preperr((LONG )6, (size_t )0);
              }
#line 257
              goto switch_break___0;
              switch_break___0: /* CIL Label */ ;
              }
              {
#line 261
              flagstr = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"/");
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 264
            if (no_preperr) {
#line 269
              if (new_flags & (long )(1 << 5)) {
                {
#line 273
                tmp___6 = __builtin_va_arg(ap, STRPTR );
#line 273
                func_tmp = (APTR )tmp___6;
#line 274
                newarg->ai_func = (STRPTR (*)(STRPTR  ))func_tmp;
                }
              }
#line 283
              if (new_type == 4L) {
                {
#line 288
                tmp___7 = __builtin_va_arg(ap, LONG );
#line 288
                rnlolim = tmp___7;
#line 289
                tmp___8 = __builtin_va_arg(ap, LONG );
#line 289
                rnhilim = tmp___8;
                }
              } else
#line 291
              if (new_type == 5L) {
                {
#line 296
                tmp___9 = __builtin_va_arg(ap, STRPTR );
#line 296
                enumstr = tmp___9;
                }
              }
#line 300
              if (no_preperr) {
                {
#line 302
                newarg->ai_id = ugly_strclone((CONSTRPTR )new_id, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c",
                                              (ULONG )302);
#line 303
                newarg->ai_type = new_type;
#line 304
                newarg->ai_flags = new_flags;
#line 305
                tmp___10 = __builtin_va_arg(ap, APTR );
#line 305
                newarg->ai_dest = tmp___10;
#line 306
                tmp___12 = __builtin_va_arg(ap, STRPTR );
#line 306
                newarg->ai_help = ugly_strclone((CONSTRPTR )tmp___12, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c",
                                                (ULONG )307);
                }
                {
#line 315
                if (new_type == 5L) {
#line 315
                  goto case_5;
                }
#line 321
                if (new_type == 4L) {
#line 321
                  goto case_4;
                }
#line 313
                goto switch_break___1;
                case_5: /* CIL Label */ 
                {
#line 316
                newarg->ai_misc1.ai_enum = ugly_strclone((CONSTRPTR )enumstr, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c",
                                                         (ULONG )316);
                }
#line 317
                if (! newarg->ai_misc1.ai_enum) {
                  {
#line 318
                  set_preperr((LONG )1, (size_t )0);
                  }
                }
#line 319
                goto switch_break___1;
                case_4: /* CIL Label */ 
#line 322
                newarg->ai_misc1.ai_lolim = rnlolim;
#line 323
                newarg->ai_misc2.ai_uplim = rnhilim;
#line 324
                goto switch_break___1;
                switch_break___1: /* CIL Label */ ;
                }
#line 331
                if ((unsigned long )newarg->ai_dest == (unsigned long )((void *)0)) {
                  {
#line 332
                  set_preperr((LONG )7, (size_t )0);
                  }
                }
              }
#line 338
              if (new_flags & (long )(1 << 2)) {
#line 339
                if (! (new_flags & 1L)) {
#line 340
                  if (new_arglist->al_multiple) {
                    {
#line 341
                    set_preperr((LONG )8, (size_t )0);
                    }
                  } else {
#line 343
                    new_arglist->al_multiple = newarg;
                  }
                }
              }
#line 349
              if (no_preperr) {
                {
#line 350
                tmp___13 = app_dlnode(newlist, (APTR )newarg);
                }
#line 350
                if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
                  {
#line 351
                  set_preperr((LONG )1, (size_t )0);
                  }
                }
              }
#line 354
              if (any_preperr) {
                {
#line 355
                del_arginfo((APTR )newarg);
                }
              }
            }
          } else {
            {
#line 358
            set_preperr((LONG )1, (size_t )0);
            }
          }
        }
#line 139
        if (nxtdef) {
#line 139
          if (! no_preperr) {
#line 139
            goto while_break;
          }
        } else {
#line 139
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 366
      ugly_freestr(nxtdef, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_prp.c",
                   (ULONG )366);
#line 366
      nxtdef = (STRPTR )((void *)0);
#line 367
      __builtin_va_end(ap);
      }
    } else {
      {
#line 369
      set_preperr((LONG )1, (size_t )0);
      }
    }
  } else {
    {
#line 369
    set_preperr((LONG )1, (size_t )0);
    }
  }
#line 374
  if (no_preperr) {
#line 375
    if ((unsigned long )newlist->first == (unsigned long )((void *)0)) {
      {
#line 376
      set_preperr((LONG )4, (size_t )0);
      }
    }
  }
#line 381
  if (any_preperr) {
    {
#line 383
    del_dllist(newlist);
    }
#line 384
    if (new_arglist) {
      {
#line 384
      free((void *)new_arglist);
#line 384
      new_arglist = (struct arglist *)((void *)0);
      }
    }
#line 385
    newlist = (struct dllist *)((void *)0);
#line 386
    new_arglist = (struct arglist *)((void *)0);
  } else {
#line 388
    new_arglist->al_list = newlist;
  }
#line 390
  return (new_arglist);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_hlp.c"
static VOID strcat_flag(STRPTR s___2 , struct arginfo *ai , ULONG chk_flag , char ch ) 
{ 
  char flag[3] ;

  {
#line 54
  flag[0] = (char )'/';
#line 54
  flag[1] = (char )'x';
#line 54
  flag[2] = (char )'\000';
#line 56
  if ((unsigned long )ai->ai_flags & chk_flag) {
    {
#line 58
    flag[1] = ch;
#line 59
    strcat((char */* __restrict  */)s___2, (char const   */* __restrict  */)(flag));
    }
  }
#line 61
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_hlp.c"
static STRARR s[100]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_hlp.c"
static STRPTR ai2str(struct arginfo *ai ) 
{ 


  {
  {
#line 67
  strncpy((char */* __restrict  */)(s), (char const   */* __restrict  */)ai->ai_id,
          (size_t )80);
  }
  {
#line 71
  if (ai->ai_type == 1L) {
#line 71
    goto case_1;
  }
#line 75
  if (ai->ai_type == 3L) {
#line 75
    goto case_3;
  }
#line 75
  if (ai->ai_type == 4L) {
#line 75
    goto case_3;
  }
#line 80
  if (ai->ai_type == (LONG )(1 << 5)) {
#line 80
    goto case_exp;
  }
#line 80
  if (ai->ai_type == 5L) {
#line 80
    goto case_exp;
  }
#line 80
  if (ai->ai_type == 2L) {
#line 80
    goto case_exp;
  }
#line 82
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 72
  strcat((char */* __restrict  */)(s), (char const   */* __restrict  */)"/S");
  }
#line 73
  goto switch_break;
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 76
  strcat((char */* __restrict  */)(s), (char const   */* __restrict  */)"/N");
  }
#line 77
  goto switch_break;
  case_exp: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 81
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 83
  strcat((char */* __restrict  */)(s), (char const   */* __restrict  */)"/?");
  }
#line 84
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 87
  strcat_flag(s, ai, (ULONG )1, (char )'K');
#line 88
  strcat_flag(s, ai, (ULONG )(1 << 1), (char )'A');
#line 89
  strcat_flag(s, ai, (ULONG )(1 << 2), (char )'M');
#line 90
  strcat_flag(s, ai, (ULONG )(1 << 3), (char )'C');
  }
#line 92
  return (s);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_hlp.c"
int fprintf_arghelp(FILE *stream , struct arglist *al ) 
{ 
  int err ;
  struct dlnode *nd ;
  struct arginfo *ai ;
  size_t maxidlen ;
  STRPTR s___2 ;
  STRPTR tmp ;
  size_t tmp___0 ;
  STRPTR s___3 ;
  STRPTR tmp___1 ;

  {
#line 100
  err = 0;
#line 102
  if (al) {
#line 106
    maxidlen = (size_t )0;
#line 109
    nd = (al->al_list)->first;
    {
#line 110
    while (1) {
      while_continue: /* CIL Label */ ;
#line 110
      if (! nd) {
#line 110
        goto while_break;
      }
#line 112
      ai = (struct arginfo *)nd->data;
#line 114
      if (ai) {
#line 116
        if (ai->ai_help) {
          {
#line 118
          tmp = ai2str(ai);
#line 118
          s___2 = tmp;
#line 119
          tmp___0 = strlen((char const   *)s___2);
          }
#line 119
          if (tmp___0 > maxidlen) {
            {
#line 120
            maxidlen = strlen((char const   *)s___2);
            }
          }
        }
      }
#line 123
      nd = nd->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 125
    maxidlen += 2UL;
#line 127
    nd = (al->al_list)->first;
    {
#line 128
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 128
      if (! nd) {
#line 128
        goto while_break___0;
      }
#line 130
      ai = (struct arginfo *)nd->data;
#line 132
      if (ai) {
#line 134
        if (ai->ai_help) {
          {
#line 136
          tmp___1 = ai2str(ai);
#line 136
          s___3 = tmp___1;
          }
#line 138
          if (ai->ai_help) {
            {
#line 139
            fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" %-*s  %s",
                    (int )maxidlen, s___3, ai->ai_help);
            }
          } else {
            {
#line 142
            fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                    s___3);
            }
          }
          {
#line 144
          fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n");
          }
        }
      }
#line 148
      nd = nd->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 152
  return (err);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_hlp.c"
int fprintf_arghelp_short(FILE *stream , struct arglist *al ) 
{ 
  int err ;
  struct dlnode *no ;
  struct arginfo *ai ;
  STRPTR tmp ;

  {
#line 162
  err = 0;
#line 164
  if (al) {
#line 169
    no = (al->al_list)->first;
#line 171
    if (no) {
      {
#line 172
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Usage: ");
      }
    }
    {
#line 174
    while (1) {
      while_continue: /* CIL Label */ ;
#line 174
      if (! no) {
#line 174
        goto while_break;
      }
#line 176
      ai = (struct arginfo *)no->data;
#line 178
      if (ai) {
        {
#line 179
        tmp = ai2str(ai);
#line 179
        fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                tmp);
        }
      }
#line 181
      no = no->next;
#line 182
      if (no) {
        {
#line 183
        fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)",");
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 186
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n");
    }
  }
#line 189
  return (err);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
DLLIST *init_dllist(void (*fn_del_data)(APTR data ) ) 
{ 
  DLLIST *newlist ;
  void *tmp ;

  {
  {
#line 53
  tmp = ugly_malloc_notracking(sizeof(DLLIST ));
#line 53
  newlist = (DLLIST *)tmp;
  }
#line 56
  if (newlist) {
#line 58
    newlist->first = (struct dlnode *)((void *)0);
#line 59
    newlist->last = (struct dlnode *)((void *)0);
#line 60
    newlist->entry_num = (LONG )0;
#line 61
    newlist->user_data = (void *)0;
#line 62
    newlist->del_data = fn_del_data;
  }
#line 65
  return (newlist);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
DLNODE *new_dlnode(void) 
{ 
  DLNODE *newnode ;
  void *tmp ;

  {
  {
#line 81
  tmp = ugly_malloc_notracking(sizeof(DLNODE ));
#line 81
  newnode = (DLNODE *)tmp;
  }
#line 83
  if (newnode) {
#line 84
    newnode->prev = (struct dlnode *)((void *)0);
#line 85
    newnode->next = (struct dlnode *)((void *)0);
#line 86
    newnode->data = (void *)0;
  }
#line 88
  return (newnode);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
APTR detach_dlnode(DLLIST *list , DLNODE *node ) 
{ 
  APTR nd_data ;

  {
#line 99
  nd_data = (void *)0;
#line 101
  if (list) {
#line 101
    if (node) {
#line 102
      nd_data = node->data;
#line 103
      if (node->prev) {
#line 104
        (node->prev)->next = node->next;
      } else {
#line 106
        list->first = node->next;
      }
#line 107
      (list->entry_num) --;
#line 109
      if (node->next) {
#line 110
        (node->next)->prev = node->prev;
      } else {
#line 112
        list->last = node->prev;
      }
#line 114
      if (node) {
        {
#line 114
        free((void *)node);
#line 114
        node = (DLNODE *)((void *)0);
        }
      }
    }
  }
#line 117
  return (nd_data);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
void del_dlnode(DLLIST *list , DLNODE *node ) 
{ 
  void (*dd)(APTR  ) ;

  {
#line 127
  if (list) {
#line 127
    if (node) {
#line 128
      dd = list->del_data;
#line 130
      if (node->data) {
#line 130
        if (dd) {
          {
#line 131
          (*dd)(node->data);
          }
        }
      }
#line 133
      if ((unsigned long )((void *)0) != (unsigned long )node->prev) {
#line 133
        (node->prev)->next = node->next;
      } else {
#line 133
        list->first = node->next;
      }
#line 133
      if ((unsigned long )((void *)0) != (unsigned long )node->next) {
#line 133
        (node->next)->prev = node->prev;
      } else {
#line 133
        list->last = node->prev;
      }
#line 133
      (list->entry_num) --;
#line 134
      node->prev = (struct dlnode *)((void *)0);
#line 135
      node->next = (struct dlnode *)((void *)0);
#line 136
      node->data = (void *)0;
#line 138
      if (node) {
        {
#line 138
        free((void *)node);
#line 138
        node = (DLNODE *)((void *)0);
        }
      }
    }
  }
#line 140
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
void move_dlnode(DLLIST *dest , DLLIST *src , DLNODE *node ) 
{ 
  struct dlnode *tmp ;

  {
#line 149
  if ((unsigned long )((void *)0) != (unsigned long )node->prev) {
#line 149
    (node->prev)->next = node->next;
  } else {
#line 149
    src->first = node->next;
  }
#line 149
  if ((unsigned long )((void *)0) != (unsigned long )node->next) {
#line 149
    (node->next)->prev = node->prev;
  } else {
#line 149
    src->last = node->prev;
  }
#line 149
  (src->entry_num) --;
#line 150
  node->next = (struct dlnode *)((void *)0);
#line 150
  tmp = dest->last;
#line 150
  node->prev = tmp;
#line 150
  if ((unsigned long )((void *)0) != (unsigned long )tmp) {
#line 150
    (node->prev)->next = node;
  }
#line 150
  dest->last = node;
#line 150
  if ((unsigned long )((void *)0) == (unsigned long )dest->first) {
#line 150
    dest->first = node;
  }
#line 151
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
VOID del_all_dlnodes(DLLIST *list ) 
{ 


  {
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! list->first) {
#line 159
      goto while_break;
    }
    {
#line 160
    del_dlnode(list, list->first);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
static DLNODE *ins_dlnode(DLLIST *list , DLNODE *node , APTR data ) 
{ 
  DLNODE *newnode ;

  {
#line 170
  newnode = (DLNODE *)((void *)0);
#line 172
  if (list) {
    {
#line 173
    newnode = new_dlnode();
    }
#line 175
    if (newnode) {
#line 176
      newnode->data = data;
#line 177
      (list->entry_num) ++;
#line 179
      if (node) {
#line 180
        if ((unsigned long )list->first == (unsigned long )node) {
#line 182
          list->first = newnode;
        } else {
#line 185
          (node->prev)->next = newnode;
#line 186
          newnode->prev = node->prev;
        }
#line 188
        node->prev = newnode;
#line 189
        newnode->next = node;
      } else {
#line 191
        if (list->last) {
#line 192
          (list->last)->next = newnode;
        }
#line 193
        newnode->prev = list->last;
#line 194
        list->last = newnode;
      }
#line 197
      if ((unsigned long )list->first == (unsigned long )((void *)0)) {
#line 198
        list->first = newnode;
      }
#line 199
      if ((unsigned long )list->last == (unsigned long )((void *)0)) {
#line 200
        list->last = newnode;
      }
    }
  }
#line 203
  return (newnode);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
DLNODE *app_dlnode(DLLIST *list , APTR data ) 
{ 
  DLNODE *tmp ;

  {
  {
#line 217
  tmp = ins_dlnode(list, (DLNODE *)((void *)0), data);
  }
#line 217
  return (tmp);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
DLNODE *add_dlnode(DLLIST *list , APTR data ) 
{ 
  DLNODE *tmp ;

  {
  {
#line 231
  tmp = ins_dlnode(list, list->first, data);
  }
#line 231
  return (tmp);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
void del_dllist(DLLIST *list ) 
{ 


  {
#line 242
  if (list) {
    {
#line 244
    while (1) {
      while_continue: /* CIL Label */ ;
#line 244
      if (! list->first) {
#line 244
        goto while_break;
      }
      {
#line 245
      del_dlnode(list, list->first);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 248
    list->first = (struct dlnode *)((void *)0);
#line 249
    list->last = (struct dlnode *)((void *)0);
#line 250
    list->entry_num = (LONG )0;
#line 251
    list->user_data = (void *)0;
#line 252
    list->del_data = (void (*)(APTR data ))((void *)0);
#line 253
    if (list) {
      {
#line 253
      free((void *)list);
#line 253
      list = (DLLIST *)((void *)0);
      }
    }
  }
#line 255
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
void do_dllist(DLLIST *list , void (*func)(APTR data ) ) 
{ 
  DLNODE *nd ;

  {
#line 264
  if (list) {
#line 265
    nd = list->first;
    {
#line 267
    while (1) {
      while_continue: /* CIL Label */ ;
#line 267
      if (! nd) {
#line 267
        goto while_break;
      }
      {
#line 268
      (*func)(nd->data);
#line 269
      nd = nd->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 272
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
void fprintf_dllist(FILE *stream , DLLIST *list , void (*fprintf_data)(FILE *stream ,
                                                                       APTR data ) ) 
{ 
  DLNODE *node ;
  ULONG i ;
  ULONG tmp ;

  {
#line 283
  if (list) {
#line 285
    i = (ULONG )1;
#line 287
    node = list->first;
#line 288
    if (node) {
      {
#line 289
      while (1) {
        while_continue: /* CIL Label */ ;
#line 289
        if (! node) {
#line 289
          goto while_break;
        }
        {
#line 290
        tmp = i;
#line 290
        i ++;
#line 290
        fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%4lu: ",
                tmp);
        }
#line 291
        if (fprintf_data) {
          {
#line 292
          (*fprintf_data)(stream, node->data);
          }
        } else {
          {
#line 294
          fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s\n",
                  (STRPTR )node->data);
          }
        }
#line 295
        node = node->next;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 298
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"  [empty list]\n");
      }
    }
  } else {
    {
#line 300
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"  [no list]\n");
    }
  }
#line 301
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
DLNODE *find_dlnode(DLNODE *start , APTR data , int (*compare)(APTR cmp_data , APTR list_data ) ) 
{ 
  DLNODE *search ;
  int found ;

  {
#line 318
  search = start;
#line 319
  found = 0;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (search) {
#line 321
      if (! (! found)) {
#line 321
        goto while_break;
      }
    } else {
#line 321
      goto while_break;
    }
    {
#line 323
    found = (*compare)(data, search->data);
    }
#line 324
    if (! found) {
#line 325
      search = search->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  return (search);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
DLNODE *find_dlnode_bw(DLNODE *start , APTR data , int (*compare)(APTR cmp_data ,
                                                                  APTR list_data ) ) 
{ 
  DLNODE *search ;
  int found ;

  {
#line 347
  search = start;
#line 348
  found = 0;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (search) {
#line 350
      if (! (! found)) {
#line 350
        goto while_break;
      }
    } else {
#line 350
      goto while_break;
    }
    {
#line 352
    found = (*compare)(data, search->data);
    }
#line 353
    if (! found) {
#line 354
      search = search->prev;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return (search);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
BOOL empty_dllist(DLLIST *list ) 
{ 


  {
#line 370
  if (list->first) {
#line 371
    return ((BOOL )0);
  } else {
#line 373
    return ((BOOL )1);
  }
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.c"
BOOL fexists(STRPTR filename ) 
{ 
  FILE *file ;
  FILE *tmp ;

  {
  {
#line 63
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
#line 63
  file = tmp;
  }
#line 64
  if (file) {
    {
#line 66
    fclose(file);
    }
  }
#line 68
  return ((BOOL )((unsigned long )file != (unsigned long )((void *)0)));
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.c"
fentrytype_t fgetentrytype(STRPTR const   name ) 
{ 
  fentrytype_t type ;
  struct stat sbuf ;
  int tmp ;

  {
  {
#line 80
  type = (fentrytype_t )0;
#line 100
  tmp = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& sbuf));
  }
#line 100
  if (-1 != tmp) {
#line 101
    if ((sbuf.st_mode & 61440U) == 16384U) {
#line 102
      type = (fentrytype_t )2;
    } else
#line 103
    if ((sbuf.st_mode & 61440U) == 32768U) {
#line 104
      type = (fentrytype_t )1;
    } else
#line 103
    if ((sbuf.st_mode & 61440U) == 40960U) {
#line 104
      type = (fentrytype_t )1;
    }
  }
#line 107
  return (type);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.c"
struct tm  const  *fgetmtime(STRPTR const   name ) 
{ 
  struct tm *time___0 ;
  struct stat sbuf ;
  int tmp ;

  {
  {
#line 118
  time___0 = (struct tm *)((void *)0);
#line 144
  tmp = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& sbuf));
  }
#line 144
  if (-1 != tmp) {
    {
#line 145
    time___0 = localtime((time_t const   *)(& sbuf.st_mtim.tv_sec));
    }
  }
#line 148
  return ((struct tm  const  *)time___0);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.c"
STRPTR getcurrentdir(void) 
{ 
  STRPTR s___2 ;
  int ss ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 161
  ss = 32;
#line 162
  tmp = __errno_location();
#line 162
  *tmp = 0;
  }
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 164
    tmp___0 = ugly_malloc_notracking((size_t )ss);
#line 164
    s___2 = (STRPTR )tmp___0;
    }
#line 164
    if ((unsigned long )((void *)0) == (unsigned long )s___2) {
      {
#line 165
      display_panic_message((char *)"out of memory", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.c",
                            (size_t )165);
      }
    }
    {
#line 166
    tmp___4 = getcwd(s___2, (size_t )ss);
    }
#line 166
    if ((unsigned long )((void *)0) == (unsigned long )tmp___4) {
      {
#line 167
      tmp___3 = __errno_location();
      }
#line 167
      if (34 != *tmp___3) {
        {
#line 168
        tmp___1 = __errno_location();
#line 168
        tmp___2 = strerror(*tmp___1);
#line 168
        display_panic_message(tmp___2, (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.c",
                              (size_t )168);
        }
      }
#line 169
      if (s___2) {
        {
#line 169
        free((void *)s___2);
#line 169
        s___2 = (STRPTR )((void *)0);
        }
      }
#line 170
      ss *= 2;
    } else {
#line 171
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (s___2);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.c"
void setcurrentdir(STRPTR const   dir ) 
{ 


  {
  {
#line 186
  chdir((char const   *)dir);
  }
#line 187
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.c"
LONG getfsize(CONSTRPTR filename ) 
{ 
  FILE *file ;
  FILE *tmp ;
  LONG filesize ;

  {
  {
#line 200
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
#line 200
  file = tmp;
#line 201
  filesize = (LONG )0;
  }
#line 202
  if (file) {
    {
#line 205
    fseek(file, 0L, 2);
#line 206
    filesize = ftell(file);
#line 207
    fclose(file);
    }
  }
#line 209
  return (filesize);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.c"
fcopy_t fcopy(CONSTRPTR oldname , CONSTRPTR newname ) 
{ 
  fcopy_t err ;
  FILE *inpf ;
  FILE *tmp ;
  FILE *outf ;
  FILE *tmp___0 ;
  char *buf___3 ;
  void *tmp___1 ;
  int nowErrno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  BOOL quit ;
  size_t byteRead ;
  size_t tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 226
  err = (fcopy_t )0;
#line 227
  tmp = fopen((char const   */* __restrict  */)oldname, (char const   */* __restrict  */)"rb");
#line 227
  inpf = tmp;
#line 228
  tmp___0 = fopen((char const   */* __restrict  */)newname, (char const   */* __restrict  */)"wb");
#line 228
  outf = tmp___0;
#line 229
  tmp___1 = ugly_malloc_notracking(sizeof(char ) * 16384UL);
#line 229
  buf___3 = (char *)tmp___1;
#line 230
  nowErrno = 0;
  }
#line 233
  if (! buf___3) {
    {
#line 235
    err = (fcopy_t )1;
#line 235
    tmp___2 = __errno_location();
#line 235
    nowErrno = *tmp___2;
    }
  } else
#line 237
  if (! inpf) {
    {
#line 239
    err = (fcopy_t )2;
#line 239
    tmp___3 = __errno_location();
#line 239
    nowErrno = *tmp___3;
    }
  } else
#line 241
  if (! outf) {
    {
#line 243
    err = (fcopy_t )3;
#line 243
    tmp___4 = __errno_location();
#line 243
    nowErrno = *tmp___4;
    }
  } else {
#line 248
    quit = (BOOL )0;
    {
#line 249
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 251
      tmp___5 = fread((void */* __restrict  */)buf___3, sizeof(char ), (size_t )16384,
                      (FILE */* __restrict  */)inpf);
#line 251
      byteRead = tmp___5;
#line 253
      tmp___9 = ferror(inpf);
      }
#line 253
      if (tmp___9) {
        {
#line 255
        err = (fcopy_t )4;
#line 255
        tmp___6 = __errno_location();
#line 255
        nowErrno = *tmp___6;
        }
      } else
#line 257
      if (byteRead == 0UL) {
#line 259
        quit = (BOOL )1;
      } else {
        {
#line 263
        fwrite((void const   */* __restrict  */)buf___3, sizeof(char ), byteRead,
               (FILE */* __restrict  */)outf);
#line 264
        tmp___8 = ferror(outf);
        }
#line 264
        if (tmp___8) {
          {
#line 266
          err = (fcopy_t )5;
#line 266
          tmp___7 = __errno_location();
#line 266
          nowErrno = *tmp___7;
          }
        }
      }
#line 249
      if (! quit) {
#line 249
        if (! ((unsigned int )err == 0U)) {
#line 249
          goto while_break;
        }
      } else {
#line 249
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 274
  if (inpf) {
    {
#line 275
    fclose(outf);
    }
  }
#line 276
  if (inpf) {
    {
#line 277
    fclose(inpf);
    }
  }
#line 278
  if (buf___3) {
#line 279
    if (buf___3) {
      {
#line 279
      free((void *)buf___3);
#line 279
      buf___3 = (char *)((void *)0);
      }
    }
  }
#line 282
  if (nowErrno) {
    {
#line 283
    tmp___10 = __errno_location();
#line 283
    *tmp___10 = nowErrno;
    }
  }
#line 285
  return (err);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.c"
fcopy_t fmove(CONSTRPTR oldname , CONSTRPTR newname ) 
{ 
  fcopy_t ferr ;
  int nowErrno ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 300
  ferr = (fcopy_t )0;
#line 302
  tmp___1 = rename(oldname, newname);
  }
#line 302
  if (tmp___1) {
    {
#line 304
    nowErrno = 0;
#line 307
    ferr = fcopy(oldname, newname);
#line 308
    tmp = __errno_location();
#line 308
    nowErrno = *tmp;
    }
    {
#line 312
    if ((unsigned int )ferr == 0U) {
#line 312
      goto case_0;
    }
#line 316
    if ((unsigned int )ferr == 5U) {
#line 316
      goto case_5;
    }
#line 324
    if ((unsigned int )ferr == 4U) {
#line 324
      goto case_4;
    }
#line 324
    if ((unsigned int )ferr == 3U) {
#line 324
      goto case_4;
    }
#line 324
    if ((unsigned int )ferr == 2U) {
#line 324
      goto case_4;
    }
#line 324
    if ((unsigned int )ferr == 1U) {
#line 324
      goto case_4;
    }
#line 328
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 313
    remove(oldname);
    }
#line 314
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 317
    remove(newname);
#line 318
    tmp___0 = __errno_location();
#line 318
    *tmp___0 = nowErrno;
    }
#line 319
    goto switch_break;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 326
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 329
    display_panic_message((char *)"unhandled return value", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ufile.c",
                          (size_t )329);
    }
#line 330
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 334
  return (ferr);
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
STRPTR pi_progname  =    (STRPTR )((void *)0);
#line 52 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
STRPTR pi_authname  =    (STRPTR )((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
int pi_version  =    0;
#line 54 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
int pi_release  =    0;
#line 55 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
int pi_revision  =    0;
#line 56 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
char pi_rel_date[24]  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
STRPTR pi_rel_time  =    (STRPTR )((void *)0);
#line 58 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
STRPTR pi_descript  =    (STRPTR )((void *)0);
#line 59 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
STRPTR pi_copystat  =    (STRPTR )((void *)0);
#line 61 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
STRPTR pi_dt_day  =    (STRPTR )((void *)0);
#line 62 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
STRPTR pi_dt_month  =    (STRPTR )((void *)0);
#line 63 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
STRPTR pi_dt_year  =    (STRPTR )((void *)0);
#line 71 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
void call_set_prginfo(STRPTR name , STRPTR auth , int ver , int rel , int rev , STRPTR rel_date ,
                      STRPTR rel_time , STRPTR infostr , STRPTR copystatus ) 
{ 


  {
  {
#line 74
  pi_progname = name;
#line 75
  pi_authname = auth;
#line 76
  pi_version = ver;
#line 77
  pi_release = rel;
#line 78
  pi_revision = rev;
#line 79
  pi_rel_time = rel_time;
#line 80
  pi_descript = infostr;
#line 81
  pi_copystat = copystatus;
#line 83
  strncpy((char */* __restrict  */)(pi_rel_date), (char const   */* __restrict  */)rel_date,
          (size_t )24);
#line 84
  pi_rel_date[3] = (char )'\000';
#line 85
  pi_rel_date[6] = (char )'\000';
#line 86
  pi_dt_month = pi_rel_date;
#line 87
  pi_dt_day = & pi_rel_date[4];
  }
#line 88
  if ((int )*(pi_dt_day + 0) == 32) {
#line 89
    pi_dt_day ++;
  }
#line 90
  pi_dt_year = & pi_rel_date[7];
#line 91
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
void call_set_prginfo2(STRPTR name , STRPTR auth , int ver , int rel , int rev , STRPTR rel_date ,
                       STRPTR rel_time , STRPTR infostr , STRPTR copystatus ) 
{ 
  STRPTR monthName[13] ;
  long tmp ;

  {
  {
#line 103
  monthName[0] = (STRPTR )"XXX";
#line 103
  monthName[1] = (STRPTR )"Jan";
#line 103
  monthName[2] = (STRPTR )"Feb";
#line 103
  monthName[3] = (STRPTR )"Mar";
#line 103
  monthName[4] = (STRPTR )"Apr";
#line 103
  monthName[5] = (STRPTR )"May";
#line 103
  monthName[6] = (STRPTR )"Jun";
#line 103
  monthName[7] = (STRPTR )"Jul";
#line 103
  monthName[8] = (STRPTR )"Aug";
#line 103
  monthName[9] = (STRPTR )"Sep";
#line 103
  monthName[10] = (STRPTR )"Oct";
#line 103
  monthName[11] = (STRPTR )"Nov";
#line 103
  monthName[12] = (STRPTR )"Dec";
#line 107
  pi_progname = name;
#line 108
  pi_authname = auth;
#line 109
  pi_version = ver;
#line 110
  pi_release = rel;
#line 111
  pi_revision = rev;
#line 112
  pi_rel_time = rel_time;
#line 113
  pi_descript = infostr;
#line 114
  pi_copystat = copystatus;
#line 116
  strncpy((char */* __restrict  */)(pi_rel_date), (char const   */* __restrict  */)rel_date,
          (size_t )24);
#line 119
  pi_dt_day = pi_rel_date;
#line 122
  pi_dt_month = strchr((char const   *)(pi_rel_date), '.');
#line 123
  *(pi_dt_month + 0) = (char )'\000';
#line 124
  pi_dt_month ++;
#line 127
  pi_dt_year = strchr((char const   *)pi_dt_month, '.');
#line 128
  *(pi_dt_year + 0) = (char )'\000';
#line 129
  pi_dt_year ++;
#line 132
  tmp = strtol((char const   */* __restrict  */)pi_dt_month, (char **/* __restrict  */)((void *)0),
               10);
#line 132
  pi_dt_month = monthName[tmp];
  }
#line 133
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/prginfo.c"
int fprintf_prginfo(FILE *stream ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 143
  err = 0;
#line 145
  err = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s - %s, v%d.%d",
                pi_progname, pi_descript, pi_version, pi_release);
  }
#line 148
  if (pi_revision) {
    {
#line 149
    tmp = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)".%d",
                  pi_revision);
#line 149
    err += tmp;
    }
  }
  {
#line 151
  tmp___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" (%s-%s-%s)\n",
                    pi_dt_day, pi_dt_month, pi_dt_year);
#line 151
  err += tmp___0;
#line 153
  tmp___1 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"(C) %s.\n%s\n",
                    pi_authname, pi_copystat);
#line 153
  err += tmp___1;
  }
#line 156
  return (err);
}
}
#line 47 "./ugly/unikot.h"
int utf8_to_ucs4(ucs4_t *ucs4 , utf8_t const   *utf8str ) ;
#line 48
int ucs4_to_utf8(utf8_t *utf8str , ucs4_t ucs4 ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/unikot.c"
int utf8_to_ucs4(ucs4_t *ucs4 , utf8_t const   *utf8str ) 
{ 
  int skip ;
  char ch_to_read ;
  utf8_t i ;
  ucs4_t first_ch_mask ;
  utf8_t ch ;

  {
#line 78
  skip = 1;
#line 80
  if ((int const   )*(utf8str + 0) >= 192) {
#line 82
    ch_to_read = (char)0;
#line 83
    i = (utf8_t )*(utf8str + 0);
#line 84
    first_ch_mask = (ucs4_t )63;
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
#line 86
      if (! ((int )i & 64)) {
#line 86
        goto while_break;
      }
#line 87
      ch_to_read = (char )((int )ch_to_read + 1);
#line 88
      i = (utf8_t )(((int )i << 1) & 127);
#line 89
      first_ch_mask >>= 1;
    }
    while_break: /* CIL Label */ ;
    }
#line 92
    *ucs4 = (long )*(utf8str + 0) & first_ch_mask;
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      ch = (utf8_t )0;
#line 101
      ch = (utf8_t )*(utf8str + skip);
#line 103
      if (((int )ch & 192) == 128) {
#line 105
        *ucs4 = (*ucs4 << 6) + (ucs4_t )((int )ch & 63);
#line 106
        ch_to_read = (char )((int )ch_to_read - 1);
#line 107
        skip ++;
      } else {
#line 111
        skip = -2;
      }
#line 97
      if (ch_to_read) {
#line 97
        if (! (skip > 0)) {
#line 97
          goto while_break___0;
        }
      } else {
#line 97
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 115
  if ((int const   )*(utf8str + 0) >= 128) {
#line 118
    skip = -1;
  } else {
#line 121
    *ucs4 = (ucs4_t )*(utf8str + 0);
#line 122
    skip = 1;
  }
#line 124
  return (skip);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/unikot.c"
static utf8_t const   first_char_mask[5]  = {      (utf8_t const   )192,      (utf8_t const   )224,      (utf8_t const   )240,      (utf8_t const   )248, 
        (utf8_t const   )252};
#line 146 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/unikot.c"
int ucs4_to_utf8(utf8_t *utf8str , ucs4_t ucs4 ) 
{ 
  int skip ;
  int i ;
  utf8_t first_char ;
  utf8_t ch ;

  {
#line 147
  skip = 0;
#line 148
  if (ucs4 < 128L) {
#line 150
    *(utf8str + 0) = (utf8_t )ucs4;
#line 151
    skip = 1;
  } else {
#line 162
    i = 0;
#line 163
    first_char = (utf8_t )0;
#line 164
    ch = (utf8_t )0;
#line 177
    if (ucs4 <= 65535L) {
#line 178
      if (ucs4 <= 2047L) {
#line 178
        skip = 2;
      } else {
#line 178
        skip = 3;
      }
    } else
#line 179
    if (ucs4 < 67108863L) {
#line 180
      if (ucs4 <= 2097151L) {
#line 180
        skip = 4;
      } else {
#line 180
        skip = 5;
      }
    } else {
#line 182
      skip = 6;
    }
#line 184
    first_char = (utf8_t )first_char_mask[skip - 2];
#line 190
    i = skip - 1;
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 191
      if (! (i > 0)) {
#line 191
        goto while_break;
      }
#line 192
      ch = (utf8_t )(128L + (ucs4 & 63L));
#line 193
      ucs4 >>= 6;
#line 194
      *(utf8str + i) = ch;
#line 196
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 202
    first_char = (utf8_t )((long )first_char | ucs4);
#line 203
    *(utf8str + 0) = first_char;
  }
#line 205
  return (skip);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 89 "./hscprj/document.h"
HSCDOC *new_document(STRPTR docname ) ;
#line 90
VOID del_document(APTR data ) ;
#line 92
DLNODE *find_document_node(DLLIST *list , STRPTR name ) ;
#line 93
HSCDOC *find_document(DLLIST *list , STRPTR name ) ;
#line 103
HSCINC *app_include(HSCDOC *document , STRPTR inc_name ) ;
#line 110
HSCIDD *find_iddef(HSCDOC *document , STRPTR name ) ;
#line 56 "./hscprj/project.h"
int check_document_id(HSCPRJ *hp___0 , STRPTR docname , STRPTR id ) ;
#line 64
BOOL hsc_project_add_document(HSCPRJ *hp___0 ) ;
#line 65
BOOL hsc_project_del_document(HSCPRJ *hp___0 , STRPTR docname ) ;
#line 67
BOOL hsc_project_set_filename(HSCPRJ *hp___0 , STRPTR new_prjname ) ;
#line 68
BOOL hsc_project_set_document(HSCPRJ *hp___0 , STRPTR new_docname ) ;
#line 69
BOOL hsc_project_set_source(HSCPRJ *hp___0 , STRPTR new_sourcename ) ;
#line 70
BOOL hsc_project_add_include(HSCPRJ *hp___0 , STRPTR new_includename ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c"
HSCPRJ *new_project(void) 
{ 
  HSCPRJ *hp___0 ;
  void *tmp ;

  {
  {
#line 53
  tmp = ugly_malloc_notracking(sizeof(HSCPRJ ));
#line 53
  hp___0 = (HSCPRJ *)tmp;
  }
#line 55
  if (hp___0) {
    {
#line 57
    memset((void *)hp___0, 0, sizeof(HSCPRJ ));
#line 58
    hp___0->documents = init_dllist(& del_document);
    }
  }
#line 61
  return (hp___0);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c"
VOID del_project(HSCPRJ *hp___0 ) 
{ 


  {
#line 70
  if (hp___0) {
    {
#line 72
    del_dllist(hp___0->documents);
#line 73
    del_document((APTR )hp___0->document);
    }
#line 74
    if (hp___0) {
      {
#line 74
      free((void *)hp___0);
#line 74
      hp___0 = (HSCPRJ *)((void *)0);
      }
    }
  }
#line 76
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c"
int check_document_id(HSCPRJ *hp___0 , STRPTR docname , STRPTR id ) 
{ 
  int err ;
  HSCDOC *document ;
  HSCDOC *tmp ;
  HSCIDD *iddef ;

  {
  {
#line 87
  err = 0;
#line 88
  tmp = find_document(hp___0->documents, docname);
#line 88
  document = tmp;
  }
#line 92
  if (document) {
    {
#line 94
    iddef = (HSCIDD *)((void *)0);
#line 96
    iddef = find_iddef(document, id);
    }
#line 97
    if (! iddef) {
#line 100
      err = 1;
    } else {
#line 105
      err = 0;
    }
  } else {
#line 111
    err = 2;
  }
#line 114
  return (err);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c"
BOOL hsc_project_set_filename(HSCPRJ *hp___0 , STRPTR new_prjname ) 
{ 
  BOOL ok ;

  {
#line 124
  ok = (BOOL )1;
#line 127
  if ((hp___0->document)->sourcename) {
    {
#line 129
    display_panic_message((char *)"project-name already set", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c",
                          (size_t )129);
    }
  }
  {
#line 132
  (hp___0->document)->sourcename = ugly_strclone((CONSTRPTR )new_prjname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c",
                                                 (ULONG )132);
  }
#line 134
  return (ok);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c"
BOOL hsc_project_add_document(HSCPRJ *hp___0 ) 
{ 
  BOOL ok ;

  {
#line 144
  ok = (BOOL )1;
#line 146
  if (hp___0->document) {
#line 148
    if ((hp___0->document)->docname) {
      {
#line 152
      app_dlnode(hp___0->documents, (APTR )hp___0->document);
      }
    } else {
      {
#line 157
      del_document((APTR )hp___0->document);
      }
    }
#line 160
    hp___0->document = (HSCDOC *)((void *)0);
  } else {
    {
#line 164
    display_panic_message((char *)"no document to replace", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c",
                          (size_t )164);
    }
  }
#line 167
  return (ok);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c"
BOOL hsc_project_del_document(HSCPRJ *hp___0 , STRPTR docname ) 
{ 
  BOOL deleted ;
  DLNODE *docnd ;
  DLNODE *tmp ;

  {
  {
#line 177
  deleted = (BOOL )0;
#line 178
  tmp = find_document_node(hp___0->documents, docname);
#line 178
  docnd = tmp;
  }
#line 180
  if (docnd) {
    {
#line 183
    del_dlnode(hp___0->documents, docnd);
#line 184
    deleted = (BOOL )1;
    }
  }
#line 191
  return (deleted);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c"
BOOL hsc_project_set_document(HSCPRJ *hp___0 , STRPTR new_docname ) 
{ 
  BOOL ok ;
  DLNODE *nd ;

  {
#line 205
  ok = (BOOL )1;
#line 206
  nd = (DLNODE *)((void *)0);
#line 207
  if (new_docname) {
    {
#line 212
    nd = find_document_node(hp___0->documents, new_docname);
    }
#line 213
    if (nd) {
      {
#line 217
      del_dlnode(hp___0->documents, nd);
      }
    }
  }
#line 230
  if (hp___0->document) {
    {
#line 234
    del_document((APTR )hp___0->document);
    }
  }
  {
#line 237
  hp___0->document = new_document(new_docname);
  }
#line 239
  return (ok);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c"
BOOL hsc_project_set_source(HSCPRJ *hp___0 , STRPTR new_sourcename ) 
{ 
  BOOL ok ;

  {
#line 249
  ok = (BOOL )1;
#line 252
  if (! (hp___0->document)->sourcename) {
    {
#line 253
    (hp___0->document)->sourcename = ugly_strclone((CONSTRPTR )new_sourcename, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c",
                                                   (ULONG )253);
    }
  } else {
    {
#line 256
    display_panic_message((char *)"sourcename already set", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c",
                          (size_t )256);
#line 257
    ok = (BOOL )0;
    }
  }
#line 260
  return (ok);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/project.c"
BOOL hsc_project_add_include(HSCPRJ *hp___0 , STRPTR new_includename ) 
{ 
  BOOL ok ;

  {
  {
#line 270
  ok = (BOOL )1;
#line 272
  app_include(hp___0->document, new_includename);
  }
#line 273
  return (ok);
}
}
#line 62 "./hscprj/project.h"
BOOL hsc_project_write_data(HSCPRJ *hp___0 , STRPTR project_fname , BOOL force___0 ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static STRARR timebuf[40]  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_ulong(EXPSTR *dest , ULONG num ) 
{ 
  STRARR lenbuf[20] ;

  {
  {
#line 68
  sprintf((char */* __restrict  */)(lenbuf), (char const   */* __restrict  */)"%lx ",
          num);
#line 69
  ugly_app_estr(dest, (CONSTRPTR )(lenbuf));
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_string(EXPSTR *dest , STRPTR s___2 ) 
{ 


  {
  {
#line 75
  ugly_app_estr(dest, (CONSTRPTR )s___2);
  }
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_caller(EXPSTR *dest , CALLER *caller ) 
{ 


  {
#line 89
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_docname(EXPSTR *prjstr , STRPTR docname ) 
{ 


  {
  {
#line 93
  ugly_app_estr(prjstr, "DOCUMENT");
#line 94
  ugly_app_estr(prjstr, " ");
#line 95
  append_string(prjstr, docname);
#line 96
  ugly_app_estr(prjstr, "\n");
  }
#line 97
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_sourcename(EXPSTR *prjstr , STRPTR sourcename ) 
{ 


  {
#line 101
  if (sourcename) {
    {
#line 103
    ugly_app_estr(prjstr, "SOURCE");
#line 104
    ugly_app_estr(prjstr, " ");
#line 105
    append_string(prjstr, sourcename);
#line 106
    ugly_app_estr(prjstr, "\n");
    }
  }
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_title(EXPSTR *prjstr , STRPTR title ) 
{ 


  {
#line 112
  if (title) {
    {
#line 114
    ugly_app_estr(prjstr, "TITLE");
#line 115
    ugly_app_estr(prjstr, " ");
#line 116
    append_string(prjstr, title);
#line 117
    ugly_app_estr(prjstr, "\n");
    }
  }
#line 119
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_include(EXPSTR *prjstr , HSCINC *include ) 
{ 


  {
  {
#line 133
  ugly_app_estr(prjstr, "INCLUDE");
#line 134
  ugly_app_estr(prjstr, " ");
#line 135
  append_string(prjstr, include->name);
#line 136
  append_caller(prjstr, include->caller);
#line 137
  ugly_app_estr(prjstr, "\n");
  }
#line 141
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_iddef(EXPSTR *prjstr , HSCIDD *iddef ) 
{ 


  {
  {
#line 160
  ugly_app_estr(prjstr, "ID");
#line 161
  ugly_app_estr(prjstr, " ");
#line 162
  append_string(prjstr, iddef->name);
#line 163
  append_caller(prjstr, iddef->caller);
#line 164
  ugly_app_estr(prjstr, "\n");
  }
#line 165
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_header(EXPSTR *prjstr ) 
{ 
  time_t now ;
  time_t tmp ;
  struct tm *tmp___0 ;

  {
  {
#line 172
  tmp = time((time_t *)((void *)0));
#line 172
  now = tmp;
#line 175
  tmp___0 = localtime((time_t const   *)(& now));
#line 175
  strftime((char */* __restrict  */)(timebuf), (size_t )40, (char const   */* __restrict  */)"%d-%b-%Y %H:%M:%S",
           (struct tm  const  */* __restrict  */)tmp___0);
#line 179
  ugly_app_estr(prjstr, "HSC_PROJECT\nVERSION ");
#line 181
  append_ulong(prjstr, (ULONG )3);
#line 182
  ugly_app_estr(prjstr, "\n");
#line 183
  ugly_app_estr(prjstr, "# Contains all data relevant for project.\n# Maintained by hsc, DO NOT MODIFY!\n");
#line 186
  ugly_app_estr(prjstr, "# updated: ");
#line 188
  ugly_app_estr(prjstr, (CONSTRPTR )(timebuf));
#line 189
  ugly_app_estrch(prjstr, '\n');
  }
#line 190
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_doc_includes(EXPSTR *prjstr , DLLIST *inclist ) 
{ 
  DLNODE *nd ;

  {
#line 195
  nd = inclist->first;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! nd) {
#line 196
      goto while_break;
    }
    {
#line 198
    append_include(prjstr, (HSCINC *)nd->data);
#line 199
    nd = nd->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_doc_iddefs(EXPSTR *prjstr , DLLIST *iddefs ) 
{ 
  DLNODE *nd ;

  {
#line 219
  nd = iddefs->first;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! nd) {
#line 220
      goto while_break;
    }
    {
#line 222
    append_iddef(prjstr, (HSCIDD *)nd->data);
#line 223
    nd = nd->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_document(EXPSTR *prjstr , HSCDOC *document ) 
{ 
  STRPTR docname ;

  {
  {
#line 230
  docname = document->docname;
#line 232
  append_docname(prjstr, docname);
#line 233
  append_sourcename(prjstr, document->sourcename);
#line 234
  append_title(prjstr, (document->title)->es_data);
#line 236
  append_doc_iddefs(prjstr, document->iddefs);
#line 237
  append_doc_includes(prjstr, document->includes);
  }
#line 241
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
BOOL hsc_project_write_data(HSCPRJ *hp___0 , STRPTR project_fname , BOOL force___0 ) 
{ 
  BOOL written ;
  EXPSTR *prjstr ;
  EXPSTR *tmp ;
  DLNODE *nd ;
  FILE *outfile ;
  BOOL write_it ;
  HSCDOC *document ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 277
  written = (BOOL )0;
#line 279
  if (hp___0) {
#line 279
    if (! hp___0->fatal) {
#line 279
      if (project_fname) {
        {
#line 281
        tmp = ugly_init_estr((size_t )256);
#line 281
        prjstr = tmp;
#line 282
        nd = (DLNODE *)((void *)0);
#line 283
        outfile = (FILE *)((void *)0);
#line 284
        write_it = force___0;
#line 290
        append_header(prjstr);
        }
#line 292
        if (hp___0->document) {
#line 292
          if ((hp___0->document)->docname) {
            {
#line 295
            hsc_project_add_document(hp___0);
#line 298
            write_it = (BOOL )1;
            }
          }
        }
#line 301
        if (write_it) {
#line 306
          nd = (hp___0->documents)->first;
          {
#line 307
          while (1) {
            while_continue: /* CIL Label */ ;
#line 307
            if (! nd) {
#line 307
              goto while_break;
            }
            {
#line 309
            document = (HSCDOC *)nd->data;
#line 311
            append_document(prjstr, document);
#line 313
            nd = nd->next;
            }
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 319
          tmp___0 = __errno_location();
#line 319
          *tmp___0 = 0;
#line 320
          outfile = fopen((char const   */* __restrict  */)project_fname, (char const   */* __restrict  */)"w");
          }
#line 321
          if (outfile) {
            {
#line 323
            tmp___1 = __errno_location();
#line 323
            *tmp___1 = 0;
#line 324
            fwrite((void const   */* __restrict  */)prjstr->es_data, sizeof(char ),
                   prjstr->es_len - 1UL, (FILE */* __restrict  */)outfile);
#line 327
            tmp___2 = __errno_location();
            }
#line 327
            if (! *tmp___2) {
#line 333
              written = (BOOL )1;
            }
          }
        } else {
          {
#line 344
          del_document((APTR )hp___0->document);
#line 345
          hp___0->document = (HSCDOC *)((void *)0);
          }
        }
        {
#line 348
        del_estr(prjstr);
        }
      }
    }
  }
#line 355
  return (written);
}
}
#line 106 "./ugly/infile.h"
int infgetc(INFILE *inpf ) ;
#line 107
STRPTR infgetw(INFILE *inpf ) ;
#line 113
int inungetc(int ch , INFILE *inpf ) ;
#line 116
size_t inungetcw(INFILE *inpf ) ;
#line 126
size_t infskip_ws(INFILE *inpf ) ;
#line 129
STRPTR infreadtoeol(INFILE *inpf ) ;
#line 85 "./hscprj/document.h"
CALLER *new_caller(STRPTR name , ULONG posx , ULONG posy ) ;
#line 109
HSCIDD *app_iddef(HSCDOC *document , STRPTR iddef_name ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static VOID hsc_msg_project_corrupt(HSCPRJ *hp___0 , STRPTR descr ) 
{ 


  {
#line 55
  hp___0->fatal = (BOOL )1;
#line 56
  if (hp___0->CB_msg_corrupt_pf) {
    {
#line 57
    (*(hp___0->CB_msg_corrupt_pf))(hp___0, descr);
    }
  }
#line 58
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static int x2int(char c ) 
{ 


  {
#line 63
  if ((int )c >= 48) {
#line 63
    if ((int )c <= 57) {
#line 64
      return ((int )c - 48);
    }
  }
#line 65
  if ((int )c >= 65) {
#line 65
    if ((int )c <= 70) {
#line 66
      return (((int )c - 65) + 10);
    }
  }
#line 67
  if ((int )c >= 97) {
#line 67
    if ((int )c <= 102) {
#line 68
      return (((int )c - 97) + 10);
    }
  }
#line 69
  return (-1);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static ULONG read_ulong(HSCPRJ *hp___0 ) 
{ 
  INFILE *inpf ;
  ULONG num ;
  int ch ;
  int digit ;

  {
#line 77
  inpf = hp___0->inpf;
#line 78
  num = (ULONG )0;
#line 80
  digit = -1;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 84
    ch = infgetc(inpf);
    }
#line 85
    if (ch != 32) {
      {
#line 87
      digit = x2int((char )ch);
      }
#line 88
      if (digit == -1) {
#line 89
        num = (ULONG )0;
      } else {
#line 91
        num = (num << 4) + (ULONG )digit;
      }
    }
#line 93
    if (digit == -1) {
      {
#line 94
      hsc_msg_project_corrupt(hp___0, (STRPTR )"hex digit expected");
      }
    }
#line 82
    if (digit != -1) {
#line 82
      if (! (ch != 32)) {
#line 82
        goto while_break;
      }
    } else {
#line 82
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (digit == -1) {
#line 99
    num = (ULONG )0;
  }
#line 101
  return (num);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static STRPTR read_string(HSCPRJ *hp___0 , BOOL len_format ) 
{ 
  STRPTR dest ;
  ULONG len ;
  STRPTR s___2 ;
  ULONG i ;
  int ch ;
  void *tmp ;

  {
#line 110
  dest = (STRPTR )((void *)0);
#line 113
  if (! len_format) {
    {
#line 115
    s___2 = infreadtoeol(hp___0->inpf);
#line 116
    inungetc(10, hp___0->inpf);
    }
#line 117
    return (s___2);
  }
  {
#line 120
  len = read_ulong(hp___0);
  }
#line 121
  if (len) {
    {
#line 123
    ch = 'x';
#line 126
    tmp = ugly_malloc_notracking(len + 1UL);
#line 126
    dest = (STRPTR )tmp;
#line 127
    *(dest + len) = (char )'\000';
#line 129
    i = (ULONG )0;
    }
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (i < len) {
#line 129
        if (! (ch != -1)) {
#line 129
          goto while_break;
        }
      } else {
#line 129
        goto while_break;
      }
      {
#line 130
      ch = infgetc(hp___0->inpf);
      }
#line 131
      if (ch != -1) {
#line 132
        *(dest + i) = (char )ch;
      } else {
        {
#line 134
        hsc_msg_project_corrupt(hp___0, (STRPTR )"string expected");
        }
      }
#line 129
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 136
    if (ch != -1) {
#line 137
      *(dest + len) = (char)0;
    } else {
#line 139
      if (dest) {
        {
#line 139
        free((void *)dest);
#line 139
        dest = (STRPTR )((void *)0);
        }
      }
#line 140
      dest = (STRPTR )((void *)0);
    }
  }
#line 143
  return (dest);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static CALLER *read_caller(HSCPRJ *hp___0 , BOOL v2format ) 
{ 
  CALLER *caller ;
  STRPTR callerid ;
  STRPTR tmp ;
  int ch ;
  int tmp___0 ;
  STRPTR fname ;
  STRPTR tmp___1 ;
  ULONG tmp___2 ;
  ULONG tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 150
  caller = (CALLER *)((void *)0);
#line 151
  tmp = infgetw(hp___0->inpf);
#line 151
  callerid = tmp;
  }
#line 153
  if (callerid) {
    {
#line 153
    tmp___5 = upstrcmp((CONSTRPTR )callerid, "FROM");
    }
#line 153
    if (tmp___5) {
#line 153
      goto _L;
    } else {
      {
#line 154
      tmp___0 = infgetc(hp___0->inpf);
#line 154
      ch = tmp___0;
      }
#line 156
      if (ch == 32) {
        {
#line 157
        tmp___1 = read_string(hp___0, v2format);
#line 157
        fname = tmp___1;
#line 158
        tmp___2 = read_ulong(hp___0);
#line 158
        tmp___3 = read_ulong(hp___0);
#line 158
        caller = new_caller(fname, tmp___3, tmp___2);
#line 159
        ugly_freestr(fname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c",
                     (ULONG )159);
#line 159
        fname = (STRPTR )((void *)0);
        }
      } else {
        {
#line 161
        hsc_msg_project_corrupt(hp___0, (STRPTR )"blank expected");
        }
      }
    }
  } else
  _L: /* CIL Label */ 
#line 162
  if (callerid) {
    {
#line 162
    tmp___4 = strcmp((char const   *)callerid, "\n");
    }
#line 162
    if (! tmp___4) {
      {
#line 164
      inungetcw(hp___0->inpf);
      }
    }
  }
#line 167
  return (caller);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static BOOL read_lf(HSCPRJ *hp___0 ) 
{ 
  int ch ;
  int tmp ;
  BOOL ok ;

  {
  {
#line 174
  tmp = infgetc(hp___0->inpf);
#line 174
  ch = tmp;
#line 175
  ok = (BOOL )1;
  }
#line 177
  if (ch != 10) {
    {
#line 178
    hsc_msg_project_corrupt(hp___0, (STRPTR )"linefeed expected");
#line 179
    ok = (BOOL )0;
    }
  }
#line 181
  return (ok);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static STRPTR read_command(HSCPRJ *hp___0 ) 
{ 
  STRPTR command___0 ;
  int tmp ;

  {
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    command___0 = infgetw(hp___0->inpf);
    }
#line 192
    if (command___0) {
      {
#line 192
      tmp = strcmp((char const   *)command___0, "\n");
      }
#line 192
      if (tmp) {
#line 192
        goto while_break;
      }
    } else {
#line 192
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (command___0) {
    {
#line 198
    infskip_ws(hp___0->inpf);
    }
  }
#line 203
  return (command___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static int read_header(HSCPRJ *hp___0 ) 
{ 
  STRARR fileid[1UL + sizeof("HSC_PROJECT")] ;
  BOOL ok ;
  STRPTR cmd ;
  ULONG version ;
  size_t i ;
  int ch ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ULONG tmp___3 ;

  {
#line 211
  ok = (BOOL )0;
#line 212
  cmd = (STRPTR )((void *)0);
#line 213
  version = (ULONG )0;
#line 217
  i = (size_t )0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 217
    tmp___0 = strlen("HSC_PROJECT");
    }
#line 217
    if (! (i < tmp___0)) {
#line 217
      goto while_break;
    }
    {
#line 218
    tmp = infgetc(hp___0->inpf);
#line 218
    ch = tmp;
#line 220
    fileid[i] = (STRARR )((UBYTE )ch);
#line 217
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  fileid[i] = (STRARR )'\000';
#line 227
  tmp___1 = strcmp((char const   *)(fileid), "HSC_PROJECT");
  }
#line 227
  if (tmp___1) {
    {
#line 231
    hsc_msg_project_corrupt(hp___0, (STRPTR )"wrong file-id");
    }
  } else {
    {
#line 229
    ok = read_lf(hp___0);
    }
  }
#line 233
  if (ok) {
    {
#line 235
    ok = (BOOL )0;
#line 238
    cmd = read_command(hp___0);
    }
#line 241
    if (cmd) {
      {
#line 241
      tmp___2 = strcmp((char const   *)cmd, "VERSION");
      }
#line 241
      if (tmp___2) {
        {
#line 251
        hsc_msg_project_corrupt(hp___0, (STRPTR )"unknown version");
        }
      } else {
        {
#line 242
        version = read_ulong(hp___0);
        }
#line 246
        if (version) {
#line 246
          if (version <= 3UL) {
            {
#line 247
            ok = read_lf(hp___0);
            }
          } else {
            {
#line 249
            hsc_msg_project_corrupt(hp___0, (STRPTR )"wrong version");
            }
          }
        } else {
          {
#line 249
          hsc_msg_project_corrupt(hp___0, (STRPTR )"wrong version");
          }
        }
      }
    } else {
      {
#line 251
      hsc_msg_project_corrupt(hp___0, (STRPTR )"unknown version");
      }
    }
  }
#line 253
  if (ok) {
#line 253
    tmp___3 = version;
  } else {
#line 253
    tmp___3 = 0UL;
  }
#line 253
  return ((int )tmp___3);
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
BOOL hsc_project_read_data(HSCPRJ *hp___0 , INFILE *inpf ) 
{ 
  BOOL ok ;
  BOOL v2format ;
  int version ;
  HSCDOC *document ;
  STRPTR cmd ;
  int ch ;
  STRPTR docname ;
  STRPTR tmp ;
  STRPTR sourcename ;
  STRPTR tmp___0 ;
  STRPTR titlename ;
  STRPTR tmp___1 ;
  STRPTR idname ;
  STRPTR tmp___2 ;
  HSCIDD *iddef ;
  HSCIDD *tmp___3 ;
  STRPTR incname ;
  STRPTR tmp___4 ;
  HSCINC *inc ;
  HSCINC *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 268
  ok = (BOOL )0;
#line 271
  if (inpf) {
    {
#line 274
    hp___0->inpf = inpf;
#line 279
    version = read_header(hp___0);
    }
#line 279
    if (0 != version) {
#line 280
      document = (HSCDOC *)((void *)0);
#line 281
      cmd = (STRPTR )((void *)0);
#line 283
      v2format = (BOOL )(version <= 2);
      {
#line 284
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 285
        cmd = read_command(hp___0);
        }
#line 287
        if (cmd) {
          {
#line 288
          tmp___11 = strcmp((char const   *)cmd, "#");
          }
#line 288
          if (tmp___11) {
            {
#line 302
            tmp___10 = strcmp((char const   *)cmd, "DOCUMENT");
            }
#line 302
            if (tmp___10) {
              {
#line 311
              tmp___9 = strcmp((char const   *)cmd, "SOURCE");
              }
#line 311
              if (tmp___9) {
                {
#line 325
                tmp___8 = strcmp((char const   *)cmd, "TITLE");
                }
#line 325
                if (tmp___8) {
                  {
#line 338
                  tmp___7 = strcmp((char const   *)cmd, "ID");
                  }
#line 338
                  if (tmp___7) {
                    {
#line 354
                    tmp___6 = strcmp((char const   *)cmd, "INCLUDE");
                    }
#line 354
                    if (tmp___6) {
                      {
#line 371
                      hsc_msg_project_corrupt(hp___0, (STRPTR )"unknown tag");
                      }
                    } else
#line 356
                    if (document) {
                      {
#line 357
                      tmp___4 = read_string(hp___0, v2format);
#line 357
                      incname = tmp___4;
                      }
#line 358
                      if (incname) {
                        {
#line 359
                        tmp___5 = app_include(document, incname);
#line 359
                        inc = tmp___5;
#line 361
                        inc->caller = read_caller(hp___0, v2format);
                        }
#line 363
                        if (incname) {
                          {
#line 363
                          free((void *)incname);
#line 363
                          incname = (STRPTR )((void *)0);
                          }
                        }
                      }
                    } else {
                      {
#line 366
                      hsc_msg_project_corrupt(hp___0, (STRPTR )"INCLUDE without DOCUMENT");
                      }
                    }
                  } else
#line 340
                  if (document) {
                    {
#line 341
                    tmp___2 = read_string(hp___0, v2format);
#line 341
                    idname = tmp___2;
                    }
#line 342
                    if (idname) {
                      {
#line 343
                      tmp___3 = app_iddef(document, idname);
#line 343
                      iddef = tmp___3;
#line 345
                      iddef->caller = read_caller(hp___0, v2format);
                      }
#line 347
                      if (idname) {
                        {
#line 347
                        free((void *)idname);
#line 347
                        idname = (STRPTR )((void *)0);
                        }
                      }
                    }
                  } else {
                    {
#line 350
                    hsc_msg_project_corrupt(hp___0, (STRPTR )"ID without DOCUMENT");
                    }
                  }
                } else
#line 327
                if (document) {
                  {
#line 328
                  tmp___1 = read_string(hp___0, v2format);
#line 328
                  titlename = tmp___1;
                  }
#line 329
                  if (titlename) {
                    {
#line 330
                    ugly_set_estr(document->title, (CONSTRPTR )titlename);
                    }
#line 332
                    if (titlename) {
                      {
#line 332
                      free((void *)titlename);
#line 332
                      titlename = (STRPTR )((void *)0);
                      }
                    }
                  }
                } else {
                  {
#line 335
                  hsc_msg_project_corrupt(hp___0, (STRPTR )"TITLE without DOCUMENT");
                  }
                }
              } else
#line 313
              if (document) {
                {
#line 314
                tmp___0 = read_string(hp___0, v2format);
#line 314
                sourcename = tmp___0;
                }
#line 315
                if (sourcename) {
                  {
#line 316
                  ugly_reallocstr(& document->sourcename, (CONSTRPTR )sourcename,
                                  (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c",
                                  (ULONG )317);
                  }
#line 319
                  if (sourcename) {
                    {
#line 319
                    free((void *)sourcename);
#line 319
                    sourcename = (STRPTR )((void *)0);
                    }
                  }
                }
              } else {
                {
#line 322
                hsc_msg_project_corrupt(hp___0, (STRPTR )"SOURCE without DOCUMENT");
                }
              }
            } else {
              {
#line 304
              tmp = read_string(hp___0, v2format);
#line 304
              docname = tmp;
              }
#line 305
              if (docname) {
                {
#line 306
                document = new_document(docname);
#line 307
                app_dlnode(hp___0->documents, (APTR )document);
                }
#line 309
                if (docname) {
                  {
#line 309
                  free((void *)docname);
#line 309
                  docname = (STRPTR )((void *)0);
                  }
                }
              }
            }
          } else {
            {
#line 292
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 293
              ch = infgetc(inpf);
              }
#line 292
              if (ch != -1) {
#line 292
                if (! (ch != 10)) {
#line 292
                  goto while_break___0;
                }
              } else {
#line 292
                goto while_break___0;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
#line 284
        if (cmd) {
#line 284
          if (! (! hp___0->fatal)) {
#line 284
            goto while_break;
          }
        } else {
#line 284
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 375
      ok = (BOOL )(! hp___0->fatal);
    }
#line 377
    hp___0->inpf = (INFILE *)((void *)0);
  }
#line 380
  return (ok);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UGLYMEM *first  =    (UGLYMEM *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UBYTE deadbeef[4]  = {      (UBYTE )222,      (UBYTE )173,      (UBYTE )190,      (UBYTE )239};
#line 83 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UBYTE deadfood[4]  = {      (UBYTE )222,      (UBYTE )173,      (UBYTE )240,      (UBYTE )13};
#line 86 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UBYTE ugly_fillchar  =    (UBYTE )129;
#line 88 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_umalloc_count  =    (ULONG )0;
#line 89 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_ufree_count  =    (ULONG )0;
#line 90 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_umalloc_count_fail  =    (ULONG )0;
#line 91 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_ufree_count_fail  =    (ULONG )0;
#line 92 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_maxmem_usage  =    (ULONG )0;
#line 93 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_curmem_usage  =    (ULONG )0;
#line 94 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_real_maxmem_usage  =    (ULONG )0;
#line 95 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_real_curmem_usage  =    (ULONG )0;
#line 96 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_maxnod_usage  =    (ULONG )0;
#line 97 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_curnod_usage  =    (ULONG )0;
#line 101
static BOOL ugly_walldamaged(UGLYMEM *umem ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
BOOL (*ugly_nomem_handler)(size_t size )  =    (BOOL (*)(size_t size ))((void *)0);
#line 109 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
VOID display_panic_message(char *msg , char *file , size_t line ) 
{ 


  {
  {
#line 111
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n");
#line 112
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  I won\'t be a monkey in anyone\'s zoo\n");
#line 113
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  I won\'t get fazed whatever you do\n");
#line 114
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                   (Ride, \"Not Fazed\")\n\n");
#line 115
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** internal error: \"%s\" (%lu): %s\n",
          file, line, msg);
#line 117
  exit(255);
  }
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UGLYMEM *find_umem(void *mem ) 
{ 
  UGLYMEM *nxtum ;
  UGLYMEM *found ;

  {
#line 125
  nxtum = first;
#line 126
  found = (UGLYMEM *)((void *)0);
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (nxtum) {
#line 128
      if (! (! found)) {
#line 128
        goto while_break;
      }
    } else {
#line 128
      goto while_break;
    }
#line 130
    if ((unsigned long )nxtum->ptr == (unsigned long )mem) {
#line 132
      found = nxtum;
    }
#line 134
    nxtum = nxtum->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return (found);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UGLYMEM *find_prev(UGLYMEM *umem ) 
{ 
  UGLYMEM *prev ;
  UGLYMEM *pprev ;
  BOOL found ;

  {
#line 152
  prev = first;
#line 153
  pprev = (UGLYMEM *)((void *)0);
#line 154
  found = (BOOL )0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (prev) {
#line 156
      if (! (! found)) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 158
    found = (BOOL )((unsigned long )prev == (unsigned long )umem);
#line 159
    if (! found) {
#line 161
      pprev = prev;
#line 162
      prev = prev->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return (pprev);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void fill_mem4(void *mem , size_t size , UBYTE *value ) 
{ 
  size_t i ;

  {
#line 178
  i = (size_t )0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < size)) {
#line 178
      goto while_break;
    }
#line 180
    *((UBYTE *)mem + i) = *(value + i % 4UL);
#line 178
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void fill_mem(void *mem , size_t size , UBYTE value ) 
{ 
  size_t i ;

  {
#line 188
  i = (size_t )0;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (i < size)) {
#line 188
      goto while_break;
    }
#line 190
    *((UBYTE *)mem + i) = value;
#line 188
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void del_uglymem(UGLYMEM *umem ) 
{ 
  UGLYMEM *prev ;
  UGLYMEM *tmp ;
  BOOL tmp___0 ;

  {
  {
#line 201
  tmp = find_prev(umem);
#line 201
  prev = tmp;
  }
#line 204
  if (prev) {
#line 205
    prev->next = umem->next;
  } else {
#line 207
    first = umem->next;
  }
  {
#line 210
  tmp___0 = ugly_walldamaged(umem);
  }
#line 210
  if (! tmp___0) {
    {
#line 216
    fill_mem4((void *)umem->lower, umem->size + 32UL, (UBYTE *)(deadbeef));
#line 217
    free((void *)umem->lower);
    }
  }
  {
#line 221
  umem->lower = (UBYTE *)((void *)0);
#line 222
  umem->upper = (UBYTE *)((void *)0);
#line 223
  umem->size = (size_t )0;
#line 224
  umem->file = (STRPTR )((void *)0);
#line 225
  umem->line = (ULONG )0;
#line 226
  free((void *)umem);
  }
#line 227
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UGLYMEM *new_uglymem(size_t memsize , STRPTR memfile , ULONG memline ) 
{ 
  UGLYMEM *newmem ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 236
  tmp = malloc(sizeof(UGLYMEM ));
#line 236
  newmem = (UGLYMEM *)tmp;
  }
#line 238
  if (newmem) {
    {
#line 240
    tmp___0 = ugly_malloc_notracking(memsize + 32UL);
#line 240
    newmem->lower = (UBYTE *)tmp___0;
    }
#line 242
    if (newmem->lower) {
      {
#line 245
      newmem->ptr = (void *)(newmem->lower + 16);
#line 246
      newmem->upper = (newmem->lower + 16) + memsize;
#line 249
      newmem->next = first;
#line 250
      first = newmem;
#line 253
      newmem->size = memsize;
#line 254
      newmem->file = memfile;
#line 255
      newmem->line = memline;
#line 256
      newmem->fillchar = ugly_fillchar;
#line 259
      fill_mem4(newmem->ptr, memsize, (UBYTE *)(deadfood));
#line 262
      fill_mem((void *)newmem->lower, (size_t )16, ugly_fillchar);
#line 263
      fill_mem((void *)newmem->upper, (size_t )16, ugly_fillchar);
      }
#line 266
      if ((int )ugly_fillchar == 255) {
#line 268
        ugly_fillchar = (UBYTE )129;
      } else {
#line 272
        ugly_fillchar = (UBYTE )((int )ugly_fillchar + 1);
      }
    } else {
      {
#line 276
      free((void *)newmem);
      }
    }
  }
#line 278
  return (newmem);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void uglymem_message(STRPTR msg ) 
{ 


  {
  {
#line 283
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
  }
#line 284
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void ugly_memdump(void *ptr , size_t size ) 
{ 
  STRPTR data ;
  size_t i ;

  {
#line 288
  data = (STRPTR )ptr;
#line 291
  if (size > 16UL) {
#line 293
    size = (size_t )16;
  }
  {
#line 296
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %p:",
          ptr);
  }
#line 297
  if (data) {
#line 302
    i = (size_t )0;
    {
#line 302
    while (1) {
      while_continue: /* CIL Label */ ;
#line 302
      if (! (i < size)) {
#line 302
        goto while_break;
      }
#line 304
      if (! (i % 4UL)) {
        {
#line 306
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
        }
      }
      {
#line 308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x",
              (int )*(data + i));
#line 302
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 313
      if (! (i < 16UL)) {
#line 313
        goto while_break___0;
      }
#line 315
      if (! (i % 4UL)) {
        {
#line 317
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
        }
      }
      {
#line 319
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  ");
#line 320
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 323
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  \"");
#line 325
    i = (size_t )0;
    }
    {
#line 325
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 325
      if (! (i < size)) {
#line 325
        goto while_break___1;
      }
#line 327
      if ((int )*(data + i) < 32) {
        {
#line 329
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
        }
      } else {
        {
#line 333
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c",
                (int )*(data + i));
        }
      }
#line 325
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 336
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"\n");
    }
  } else {
    {
#line 340
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL\n");
    }
  }
#line 342
  return;
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void uglymem_meminfo(void *ptr , STRPTR file , ULONG line ) 
{ 


  {
  {
#line 346
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %p: from \"%s\" (%lu)\n",
          ptr, file, line);
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void umem_info(UGLYMEM *umem ) 
{ 


  {
  {
#line 351
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %p: %lu (0x%lx) bytes from \"%s\" (%lu)\n",
          umem->ptr, umem->size, umem->size, umem->file, umem->line);
  }
#line 354
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static STRARR strbuf[30]  ;
#line 368 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static STRPTR str_ubyte(UBYTE val ) 
{ 
  UBYTE ch ;

  {
#line 371
  ch = val;
#line 373
  if ((int )ch < 32) {
#line 374
    ch = (UBYTE )'.';
  }
  {
#line 376
  sprintf((char */* __restrict  */)(strbuf), (char const   */* __restrict  */)"(0x%02x/#%d/`%c\')",
          (int )val, (int )val, (int )ch);
  }
#line 378
  return (strbuf);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static BOOL ugly_walldamaged(UGLYMEM *umem ) 
{ 
  size_t i ;
  BOOL damaged ;
  BOOL lower_damaged ;
  BOOL upper_damaged ;
  int tmp ;
  STRPTR wall ;
  UBYTE value ;
  STRPTR tmp___0 ;

  {
#line 389
  i = (size_t )0;
#line 390
  damaged = (BOOL )0;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! damaged) {
#line 392
      if (! (i < 16UL)) {
#line 392
        goto while_break;
      }
    } else {
#line 392
      goto while_break;
    }
#line 394
    lower_damaged = (BOOL )((int )*(umem->lower + i) != (int )umem->fillchar);
#line 395
    upper_damaged = (BOOL )((int )*(umem->upper + i) != (int )umem->fillchar);
#line 397
    if (lower_damaged) {
#line 397
      tmp = 1;
    } else
#line 397
    if (upper_damaged) {
#line 397
      tmp = 1;
    } else {
#line 397
      tmp = 0;
    }
#line 397
    damaged = (BOOL )tmp;
#line 398
    if (damaged) {
#line 403
      if (lower_damaged) {
#line 405
        wall = (STRPTR )"LOWER";
#line 406
        value = *(umem->lower + i);
      } else {
#line 410
        wall = (STRPTR )"UPPER";
#line 411
        value = *(umem->upper + i);
      }
      {
#line 414
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** MEMORY WALL DAMAGED!!!\n");
#line 415
      tmp___0 = str_ubyte(value);
#line 415
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** %s wall, byte#%lu is %s instead of 0x%02x\n",
              wall, i, tmp___0, (int )umem->fillchar);
#line 417
      umem_info(umem);
#line 418
      ugly_memdump(umem->ptr, umem->size);
#line 419
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  * lower wall:\n");
#line 420
      ugly_memdump((void *)umem->lower, (size_t )16);
#line 421
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  * upper wall:\n");
#line 422
      ugly_memdump((void *)umem->upper, (size_t )16);
      }
    } else {
#line 427
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  return (damaged);
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
void uglymem_wallcheck(STRPTR msg , STRPTR file , ULONG line ) 
{ 
  UGLYMEM *umem ;

  {
#line 441
  umem = first;
#line 443
  if (umem) {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MEMORY WALL-CHECK (%s)",
            msg);
    }
#line 447
    if (file) {
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" from `%s\' (%lu)",
              file, line);
      }
    }
    {
#line 449
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
    {
#line 452
    while (1) {
      while_continue: /* CIL Label */ ;
#line 452
      if (! umem) {
#line 452
        goto while_break;
      }
#line 454
      if (umem->ptr) {
        {
#line 456
        ugly_walldamaged(umem);
#line 457
        umem = umem->next;
        }
      } else {
        {
#line 461
        umem = (UGLYMEM *)((void *)0);
#line 462
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n** PANIC: memory list trashed\n");
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 466
  return;
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
void uglymem_report(STRPTR msg , STRPTR file , ULONG line , STRPTR date , STRPTR time___0 ) 
{ 
  UGLYMEM *umem ;

  {
#line 481
  umem = first;
#line 483
  if (umem) {
    {
#line 486
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MEMORY REPORT (%s)\n",
            msg);
    }
#line 487
    if (file) {
      {
#line 489
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(\"%s\" (%lu), at %s, %s)\n",
              file, line, date, time___0);
      }
    }
    {
#line 494
    while (1) {
      while_continue: /* CIL Label */ ;
#line 494
      if (! umem) {
#line 494
        goto while_break;
      }
#line 496
      if (umem->ptr) {
        {
#line 498
        umem_info(umem);
#line 499
        ugly_memdump(umem->ptr, umem->size);
#line 500
        umem = umem->next;
        }
      } else {
        {
#line 504
        umem = (UGLYMEM *)((void *)0);
#line 505
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"##\n## panic: memory list trashed\n##\n");
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 509
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
void uglymem_stats(STRPTR msg , STRPTR file , ULONG line , STRPTR date , STRPTR time___0 ) 
{ 


  {
  {
#line 519
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MEMORY STATISTICS (%s)\n",
          msg);
  }
#line 520
  if (file) {
    {
#line 522
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(\"%s\" (%lu), at %s, %s)\n",
            file, line, date, time___0);
    }
  }
  {
#line 527
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  bytes used: %lu max: %lu/%lu  ",
          ugly_curmem_usage, ugly_real_maxmem_usage, ugly_maxmem_usage);
  }
#line 530
  if (ugly_maxmem_usage) {
    {
#line 532
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"slack: %lu%%\n",
            (100UL * (ugly_real_maxmem_usage - ugly_maxmem_usage)) / ugly_maxmem_usage);
    }
  } else {
    {
#line 538
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no slack\n");
    }
  }
  {
#line 541
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  nodes used: %lu (max: %lu)\n",
          ugly_curnod_usage, ugly_maxnod_usage);
#line 543
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  calls to: umalloc(%lu)   ufree(%lu)\n",
          ugly_umalloc_count, ugly_ufree_count);
  }
#line 545
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
void atexit_uglymemory_real(void) 
{ 
  ULONG mem_lost ;

  {
  {
#line 558
  mem_lost = ugly_curmem_usage;
#line 559
  uglymem_report((STRPTR )"at exit:  MEMORY LEAK detected!", (STRPTR )((void *)0),
                 (ULONG )0, (STRPTR )((void *)0), (STRPTR )((void *)0));
#line 561
  uglymem_stats((STRPTR )"[exit]", (STRPTR )((void *)0), (ULONG )0, (STRPTR )((void *)0),
                (STRPTR )((void *)0));
  }
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! first) {
#line 564
      goto while_break;
    }
    {
#line 566
    del_uglymem(first);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 569
  if (mem_lost) {
    {
#line 571
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%lu bytes of memory lost!\n",
            mem_lost);
    }
  }
#line 573
  return;
}
}
#line 578 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
void atexit_uglymemory_dummy(void) 
{ 


  {
#line 580
  return;
}
}
#line 591 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
void *ugly_malloc_notracking(size_t size ) 
{ 
  void *mem ;
  BOOL retry ;

  {
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 597
    mem = malloc(size);
    }
#line 598
    if (! mem) {
#line 598
      if (ugly_nomem_handler) {
        {
#line 600
        retry = (*ugly_nomem_handler)(size);
        }
#line 601
        if (! retry) {
          {
#line 602
          exit(1);
          }
        }
      } else {
#line 603
        retry = (BOOL )0;
      }
    } else {
#line 603
      retry = (BOOL )0;
    }
#line 595
    if (! retry) {
#line 595
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 606
  return (mem);
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
void *ugly_malloc_tracking(size_t size , STRPTR file , ULONG line ) 
{ 
  void *mem ;
  UGLYMEM *umem ;

  {
#line 613
  mem = (void *)0;
#line 614
  umem = (UGLYMEM *)((void *)0);
#line 619
  if (size) {
    {
#line 621
    ugly_umalloc_count ++;
#line 624
    umem = new_uglymem(size, file, line);
    }
#line 625
    if (umem) {
#line 626
      mem = umem->ptr;
#line 629
      ugly_curmem_usage += size;
#line 630
      ugly_real_curmem_usage += 8UL * ((size + 7UL) / 8UL);
#line 631
      if (ugly_curmem_usage > ugly_maxmem_usage) {
#line 632
        ugly_maxmem_usage = ugly_curmem_usage;
      }
#line 633
      if (ugly_real_curmem_usage > ugly_real_maxmem_usage) {
#line 634
        ugly_real_maxmem_usage = ugly_real_curmem_usage;
      }
#line 635
      ugly_curnod_usage ++;
#line 636
      if (ugly_curnod_usage > ugly_maxnod_usage) {
#line 637
        ugly_maxnod_usage = ugly_curnod_usage;
      }
    }
  } else {
    {
#line 643
    ugly_umalloc_count_fail ++;
#line 645
    uglymem_message((STRPTR )"MALLOC: zero-sized allocation");
#line 646
    uglymem_meminfo((void *)0, file, line);
    }
  }
#line 649
  return (mem);
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
void ugly_free(void *ptr , STRPTR file , ULONG line ) 
{ 
  UGLYMEM *umem ;
  UGLYMEM *tmp ;

  {
#line 662
  if (ptr) {
    {
#line 663
    tmp = find_umem(ptr);
#line 663
    umem = tmp;
    }
#line 665
    if (umem) {
      {
#line 667
      ugly_ufree_count ++;
#line 670
      ugly_curmem_usage -= umem->size;
#line 671
      ugly_real_curmem_usage -= 8UL * ((umem->size + 7UL) / 8UL);
#line 674
      del_uglymem(umem);
#line 675
      ugly_curnod_usage --;
      }
    } else {
      {
#line 680
      ugly_ufree_count_fail ++;
#line 683
      uglymem_message((STRPTR )"*** FREE: memory never allocated  or released twice");
#line 685
      uglymem_meminfo(ptr, file, line);
      }
    }
  }
#line 688
  return;
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
void *ugly_realloc(void *ptr , size_t size , STRPTR file , ULONG line ) 
{ 
  void *newptr ;
  void *tmp ;
  UGLYMEM *umem ;
  UGLYMEM *tmp___0 ;

  {
  {
#line 696
  tmp = ugly_malloc_tracking(size, file, line);
#line 696
  newptr = tmp;
#line 697
  tmp___0 = find_umem(ptr);
#line 697
  umem = tmp___0;
  }
#line 699
  if (newptr) {
#line 699
    if (umem) {
      {
#line 701
      memcpy((void */* __restrict  */)newptr, (void const   */* __restrict  */)umem->ptr,
             umem->size);
#line 703
      ugly_free(ptr, file, line);
      }
    }
  }
#line 705
  return (newptr);
}
}
#line 713 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
void *ugly_calloc(size_t count , size_t size , STRPTR file , ULONG line ) 
{ 
  void *mem ;
  void *tmp ;

  {
  {
#line 715
  tmp = ugly_malloc_tracking(count * size, file, line);
#line 715
  mem = tmp;
  }
#line 718
  if (mem) {
    {
#line 719
    memset(mem, 0, size * count);
    }
  }
#line 721
  return (mem);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.h"
STRPTR FNAME_STDIN ;
#line 103
INFILE *infopen_str(CONSTRPTR name , CONSTRPTR s___2 , size_t step_size ) ;
#line 108
STRPTR infgetall(INFILE *inpf ) ;
#line 110
STRPTR infgetcws(INFILE *inpf ) ;
#line 111
STRPTR infgetcw(INFILE *inpf ) ;
#line 114
size_t inungets(STRPTR s___2 , INFILE *inpf ) ;
#line 115
size_t inungetcwws(INFILE *inpf ) ;
#line 118
ULONG infget_x(INFILE *inpf ) ;
#line 119
ULONG infget_y(INFILE *inpf ) ;
#line 120
ULONG infget_wx(INFILE *inpf ) ;
#line 121
ULONG infget_wy(INFILE *inpf ) ;
#line 122
STRPTR infget_fname(INFILE *inpf ) ;
#line 123
BOOL infget_skws(INFILE *inpf ) ;
#line 125
BOOL inf_isws(char ch , INFILE *inpf ) ;
#line 128
int infeof(INFILE *inpf ) ;
#line 130
int infgotoeol(INFILE *inpf ) ;
#line 132
VOID del_infilepos(INFILEPOS *pos ) ;
#line 133
INFILEPOS *new_infilepos(INFILE *inpfile ) ;
#line 134
INFILEPOS *new_winfilepos(INFILE *inpfile ) ;
#line 135
INFILEPOS *clone_infilepos(INFILEPOS *ipos ) ;
#line 137
STRPTR ifp_get_fname(INFILEPOS *pos ) ;
#line 138
ULONG ifp_get_x(INFILEPOS *pos ) ;
#line 139
ULONG ifp_get_y(INFILEPOS *pos ) ;
#line 140
BOOL set_infilepos(INFILE *inpf , INFILEPOS *pos ) ;
#line 141
BOOL set_infile_base(INFILE *inpf , INFILEPOS *pos ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
STRPTR FNAME_STDIN  =    (STRPTR )"STDIN";
#line 82
static VOID del_infilepos_nddata(APTR data ) ;
#line 96 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static BOOL default_whtspc(int ch ) 
{ 
  char *tmp ;

  {
  {
#line 98
  tmp = strchr(" \t", ch);
  }
#line 98
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 100
    return ((BOOL )1);
  } else {
#line 104
    return ((BOOL )0);
  }
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static BOOL default_normch(int ch ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 110
  tmp = __ctype_b_loc();
  }
#line 110
  if ((int const   )*(*tmp + ch) & 8) {
#line 112
    return ((BOOL )1);
  } else
#line 110
  if (ch == 95) {
#line 112
    return ((BOOL )1);
  } else {
#line 116
    return ((BOOL )0);
  }
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID update_wpos(INFILE *inpf ) 
{ 


  {
#line 129
  inpf->wpos_x = inpf->pos_x;
#line 130
  inpf->wpos_y = inpf->pos_y;
#line 131
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID reset_infile(INFILE *inpf ) 
{ 


  {
  {
#line 147
  inpf->infile = (FILE *)((void *)0);
#line 148
  inpf->filename = (STRPTR )((void *)0);
#line 149
  inpf->lnbuf = (EXPSTR *)((void *)0);
#line 150
  inpf->wordbuf = (EXPSTR *)((void *)0);
#line 151
  inpf->wspcbuf = (EXPSTR *)((void *)0);
#line 153
  inpf->filepos = (ULONG )0;
#line 154
  inpf->pos_x = (ULONG )0;
#line 155
  inpf->pos_y = (ULONG )0;
#line 156
  update_wpos(inpf);
#line 158
  inpf->base_x = (ULONG )0;
#line 159
  inpf->base_y = (ULONG )0;
#line 160
  inpf->pos_list = (DLLIST *)((void *)0);
#line 161
  inpf->pos_count = (ULONG )0;
#line 162
  inpf->eof_reached = (BOOL )0;
#line 163
  inpf->out_of_mem = (BOOL )0;
#line 164
  inpf->skipped_ws = (BOOL )0;
#line 165
  inpf->closed = (BOOL )0;
#line 166
  inpf->is_nc = (BOOL (*)(int ch ))((void *)0);
#line 167
  inpf->is_ws = (BOOL (*)(int ch ))((void *)0);
  }
#line 168
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID del_infile(INFILE *inpf ) 
{ 


  {
#line 175
  if (inpf) {
#line 186
    if (inpf->pos_count) {
#line 188
      inpf->closed = (BOOL )1;
    } else {
#line 195
      if (inpf->infile) {
        {
#line 196
        fclose(inpf->infile);
        }
      }
      {
#line 199
      del_dllist(inpf->pos_list);
#line 202
      ugly_freestr(inpf->filename, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c",
                   (ULONG )202);
#line 202
      inpf->filename = (STRPTR )((void *)0);
#line 203
      del_estr(inpf->lnbuf);
#line 204
      del_estr(inpf->wordbuf);
#line 205
      del_estr(inpf->wspcbuf);
#line 208
      reset_infile(inpf);
      }
#line 211
      if (inpf) {
        {
#line 211
        free((void *)inpf);
#line 211
        inpf = (INFILE *)((void *)0);
        }
      }
    }
  }
#line 214
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static INFILE *init_infile(CONSTRPTR name , size_t buf_step , size_t word_step ) 
{ 
  INFILE *inpf ;
  void *tmp ;

  {
  {
#line 221
  tmp = ugly_malloc_notracking(sizeof(INFILE ));
#line 221
  inpf = (INFILE *)tmp;
  }
#line 223
  if (inpf) {
#line 226
    if (! buf_step) {
#line 227
      buf_step = (size_t )128;
    }
#line 228
    if (! word_step) {
#line 229
      word_step = (size_t )128;
    }
    {
#line 232
    reset_infile(inpf);
    }
#line 235
    if (name) {
      {
#line 236
      inpf->filename = ugly_strclone(name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c",
                                     (ULONG )236);
      }
    }
    {
#line 239
    inpf->lnbuf = ugly_init_estr(buf_step);
#line 240
    inpf->wordbuf = ugly_init_estr(word_step);
#line 241
    inpf->wspcbuf = ugly_init_estr(word_step);
#line 242
    inpf->pos_list = init_dllist(& del_infilepos_nddata);
#line 243
    inpf->pos_count = (ULONG )0;
    }
#line 246
    if (inpf->filename) {
#line 246
      goto _L;
    } else
#line 246
    if (! name) {
      _L: /* CIL Label */ 
#line 246
      if (inpf->lnbuf) {
#line 246
        if (inpf->wordbuf) {
#line 246
          if (! inpf->wspcbuf) {
            {
#line 253
            del_infile(inpf);
#line 254
            inpf = (INFILE *)((void *)0);
            }
          }
        } else {
          {
#line 253
          del_infile(inpf);
#line 254
          inpf = (INFILE *)((void *)0);
          }
        }
      } else {
        {
#line 253
        del_infile(inpf);
#line 254
        inpf = (INFILE *)((void *)0);
        }
      }
    } else {
      {
#line 253
      del_infile(inpf);
#line 254
      inpf = (INFILE *)((void *)0);
      }
    }
  }
#line 258
  return (inpf);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
ULONG infget_x(INFILE *inpf ) 
{ 


  {
#line 282
  if (inpf->wpos_y) {
#line 284
    return (inpf->pos_x);
  } else {
#line 288
    return (inpf->pos_x + inpf->base_x);
  }
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
ULONG infget_y(INFILE *inpf ) 
{ 


  {
#line 299
  return (inpf->pos_y + inpf->base_y);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
ULONG infget_wx(INFILE *inpf ) 
{ 


  {
#line 309
  if (inpf->wpos_y) {
#line 311
    return (inpf->wpos_x);
  } else {
#line 315
    return (inpf->wpos_x + inpf->base_x);
  }
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
ULONG infget_wy(INFILE *inpf ) 
{ 


  {
#line 326
  return (inpf->wpos_y + inpf->base_y);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
BOOL infget_skws(INFILE *inpf ) 
{ 


  {
#line 336
  return (inpf->skipped_ws);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
STRPTR infget_fname(INFILE *inpf ) 
{ 


  {
#line 346
  if (inpf->filename) {
#line 348
    return (inpf->filename);
  } else {
#line 352
    return (FNAME_STDIN);
  }
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
int infeof(INFILE *inpf ) 
{ 


  {
#line 368
  if ((int )inpf->eof_reached == 1) {
#line 370
    return (-1);
  } else {
#line 374
    return (0);
  }
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
STRPTR infgetcws(INFILE *inpf ) 
{ 


  {
#line 386
  return ((inpf->wspcbuf)->es_data);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
STRPTR infgetcw(INFILE *inpf ) 
{ 


  {
#line 397
  return ((inpf->wordbuf)->es_data);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
void set_whtspc(INFILE *inpf , BOOL (*iswsfn)(int ch ) ) 
{ 


  {
#line 415
  if (inpf) {
#line 417
    inpf->is_ws = iswsfn;
  }
#line 419
  return;
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
void set_normch(INFILE *inpf , BOOL (*isncfn)(int ch ) ) 
{ 


  {
#line 430
  if (inpf) {
#line 432
    inpf->is_nc = isncfn;
  }
#line 434
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
int infclose1(INFILE *inpf ) 
{ 


  {
  {
#line 452
  del_infile(inpf);
  }
#line 454
  return (0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
INFILE *infopen(CONSTRPTR name , size_t step_size ) 
{ 
  INFILE *inpf ;
  FILE *file ;
  long filesize ;
  size_t buf_size ;
  size_t tmp ;
  STRPTR buf___3 ;
  void *tmp___0 ;
  STRPTR restr ;
  BOOL ok ;
  int tmp___1 ;

  {
#line 475
  inpf = (INFILE *)((void *)0);
#line 476
  file = (FILE *)((void *)0);
#line 477
  filesize = 0L;
#line 478
  buf_size = (size_t )4096;
#line 481
  if (name) {
    {
#line 483
    file = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"rb");
    }
#line 484
    if (file) {
      {
#line 489
      fseek(file, 0L, 2);
#line 490
      filesize = ftell(file);
      }
#line 491
      if (filesize == -1L) {
#line 492
        buf_size = (size_t )32768;
      } else {
#line 494
        buf_size = (size_t )((filesize + filesize / 16L) + 1L);
      }
      {
#line 495
      rewind(file);
      }
    }
  } else {
#line 502
    file = stdin;
#line 503
    buf_size = (size_t )32768;
  }
#line 507
  if (file) {
    {
#line 509
    inpf = init_infile(name, buf_size, step_size);
    }
#line 510
    if (inpf) {
#line 511
      inpf->infile = file;
    }
  }
#line 515
  if (inpf) {
#line 517
    if ((unsigned long )file != (unsigned long )stdin) {
      {
#line 522
      tmp = fread((void */* __restrict  */)(inpf->lnbuf)->es_data, (size_t )1, (size_t )filesize,
                  (FILE */* __restrict  */)file);
#line 522
      filesize = (long )tmp;
#line 523
      (inpf->lnbuf)->es_len = (size_t )filesize;
#line 524
      *((inpf->lnbuf)->es_data + filesize) = (char)0;
      }
    } else {
      {
#line 529
      tmp___0 = ugly_malloc_notracking((size_t )1024);
#line 529
      buf___3 = (STRPTR )tmp___0;
#line 530
      restr = buf___3;
#line 531
      ok = (BOOL )((unsigned long )buf___3 != (unsigned long )((void *)0));
      }
      {
#line 534
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 534
        tmp___1 = feof(inpf->infile);
        }
#line 534
        if (tmp___1) {
#line 534
          goto while_break;
        } else
#line 534
        if (! ok) {
#line 534
          goto while_break;
        }
        {
#line 536
        restr = fgets((char */* __restrict  */)buf___3, 1024, (FILE */* __restrict  */)inpf->infile);
        }
#line 537
        if (restr) {
          {
#line 539
          ok = ugly_app_estr(inpf->lnbuf, (CONSTRPTR )restr);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 549
      if (buf___3) {
        {
#line 549
        free((void *)buf___3);
#line 549
        buf___3 = (STRPTR )((void *)0);
        }
      }
    }
  }
#line 554
  return (inpf);
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
INFILE *infopen_str(CONSTRPTR name , CONSTRPTR s___2 , size_t step_size ) 
{ 
  INFILE *inpf ;
  size_t tmp ;
  INFILE *tmp___0 ;
  BOOL ok ;
  BOOL tmp___1 ;

  {
  {
#line 573
  tmp = strlen(s___2);
#line 573
  tmp___0 = init_infile(name, tmp + 1UL, step_size);
#line 573
  inpf = tmp___0;
  }
#line 575
  if (inpf) {
    {
#line 578
    tmp___1 = ugly_set_estr(inpf->lnbuf, s___2);
#line 578
    ok = tmp___1;
    }
#line 580
    if (! ok) {
      {
#line 582
      del_infile(inpf);
#line 583
      inpf = (INFILE *)((void *)0);
      }
    }
  }
#line 587
  return (inpf);
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
int ugly_infgetc(INFILE *inpf ) 
{ 
  int result ;
  STRPTR lnbuf_str ;

  {
#line 603
  result = -1;
#line 608
  if (inpf) {
#line 608
    if (! inpf->eof_reached) {
#line 610
      lnbuf_str = (inpf->lnbuf)->es_data;
#line 616
      if ((int )*(lnbuf_str + inpf->filepos) == 0) {
#line 618
        inpf->eof_reached = (BOOL )1;
      }
#line 625
      if ((int )inpf->eof_reached == 0) {
#line 628
        lnbuf_str = (inpf->lnbuf)->es_data;
#line 629
        result = (int )((UBYTE )*(lnbuf_str + inpf->filepos));
#line 630
        if (result) {
#line 632
          (inpf->pos_x) ++;
#line 633
          (inpf->filepos) ++;
        }
      }
#line 638
      if (result == 10) {
#line 640
        (inpf->pos_y) ++;
#line 641
        inpf->pos_x = (ULONG )0;
      }
    }
  }
#line 645
  return (result);
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
int infgetc(INFILE *inpf ) 
{ 
  int ch ;
  int tmp ;

  {
  {
#line 656
  tmp = ugly_infgetc(inpf);
#line 656
  ch = tmp;
#line 659
  update_wpos(inpf);
  }
#line 669
  return (ch);
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static int ugly_inungetc(int ch , INFILE *inpf ) 
{ 
  int result ;
  STRPTR lnbuf_str ;

  {
#line 689
  result = -1;
#line 691
  if (inpf) {
#line 691
    if (inpf->filepos) {
#line 693
      lnbuf_str = (inpf->lnbuf)->es_data;
#line 696
      (inpf->filepos) --;
#line 699
      *(lnbuf_str + inpf->filepos) = (char )ch;
#line 700
      result = ch;
#line 703
      if (ch == 10) {
#line 705
        result = ch;
#line 706
        (inpf->pos_y) --;
#line 707
        inpf->pos_x = (ULONG )0;
      } else
#line 709
      if (inpf->pos_x) {
#line 710
        (inpf->pos_x) --;
      }
    }
  }
#line 713
  return (result);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
int inungetc(int ch , INFILE *inpf ) 
{ 
  int result ;
  int tmp ;

  {
  {
#line 729
  tmp = ugly_inungetc(ch, inpf);
#line 729
  result = tmp;
  }
#line 731
  if (inpf) {
#line 731
    if (inpf->filepos) {
      {
#line 733
      update_wpos(inpf);
      }
    }
  }
#line 736
  return (result);
}
}
#line 747 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
size_t inungets(STRPTR s___2 , INFILE *inpf ) 
{ 
  size_t ctr ;
  size_t slen ;
  size_t tmp ;
  STRPTR p ;
  size_t tmp___0 ;
  int ch ;

  {
  {
#line 749
  ctr = (size_t )0;
#line 750
  tmp = strlen((char const   *)s___2);
#line 750
  slen = tmp;
#line 751
  tmp___0 = strlen((char const   *)s___2);
#line 751
  p = s___2 + (tmp___0 - 1UL);
#line 752
  ch = 0;
  }
#line 754
  if (slen > 0UL) {
    {
#line 756
    ctr = (size_t )1;
#line 757
    ch = ugly_inungetc((int )*(p + 0), inpf);
    }
    {
#line 759
    while (1) {
      while_continue: /* CIL Label */ ;
#line 759
      if ((unsigned long )p != (unsigned long )s___2) {
#line 759
        if (! (ch != -1)) {
#line 759
          goto while_break;
        }
      } else {
#line 759
        goto while_break;
      }
      {
#line 761
      ctr ++;
#line 762
      p --;
#line 763
      ch = ugly_inungetc((int )*(p + 0), inpf);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 767
  return (ctr);
}
}
#line 777 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
size_t inungetcw(INFILE *inpf ) 
{ 
  size_t ctr ;
  STRPTR tmp ;

  {
  {
#line 782
  tmp = infgetcw(inpf);
#line 782
  ctr = inungets(tmp, inpf);
  }
#line 784
  return (ctr);
}
}
#line 794 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
size_t inungetcwws(INFILE *inpf ) 
{ 
  size_t ctr ;
  STRPTR tmp ;
  STRPTR tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 799
  tmp = infgetcw(inpf);
#line 799
  ctr = inungets(tmp, inpf);
#line 800
  tmp___0 = infgetcws(inpf);
#line 800
  tmp___1 = inungets(tmp___0, inpf);
#line 800
  ctr += tmp___1;
  }
#line 802
  return (ctr);
}
}
#line 813 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
BOOL inf_isws(char ch , INFILE *inpf ) 
{ 
  BOOL (*isws)(int ch ) ;
  BOOL tmp ;

  {
#line 815
  isws = inpf->is_ws;
#line 817
  if ((unsigned long )isws == (unsigned long )((void *)0)) {
#line 818
    isws = & default_whtspc;
  }
  {
#line 820
  tmp = (*isws)((int )ch);
  }
#line 820
  return (tmp);
}
}
#line 830 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
size_t infskip_ws(INFILE *inpf ) 
{ 
  char nxtch ;
  size_t ctr ;
  BOOL ok ;
  int tmp ;
  BOOL tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  BOOL tmp___3 ;

  {
  {
#line 833
  ctr = (size_t )0;
#line 840
  inpf->skipped_ws = (BOOL )0;
#line 843
  ok = ugly_clr_estr(inpf->wspcbuf);
#line 848
  tmp = ugly_infgetc(inpf);
#line 848
  nxtch = (char )tmp;
  }
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 849
    tmp___2 = infeof(inpf);
    }
#line 849
    if (tmp___2) {
#line 849
      goto while_break;
    } else
#line 849
    if (ok) {
      {
#line 849
      tmp___3 = inf_isws(nxtch, inpf);
      }
#line 849
      if (! tmp___3) {
#line 849
        goto while_break;
      }
    } else {
#line 849
      goto while_break;
    }
    {
#line 853
    tmp___0 = ugly_app_estrch(inpf->wspcbuf, (int )nxtch);
#line 853
    ok = (BOOL )((int )ok & (int )tmp___0);
#line 854
    ctr ++;
#line 855
    tmp___1 = ugly_infgetc(inpf);
#line 855
    nxtch = (char )tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 858
  if (ctr) {
#line 859
    inpf->skipped_ws = (BOOL )1;
  }
  {
#line 872
  inungetc((int )nxtch, inpf);
  }
#line 874
  return (ctr);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
STRPTR infgetall(INFILE *inpf ) 
{ 


  {
#line 884
  return ((inpf->lnbuf)->es_data);
}
}
#line 892 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
STRPTR infgetw(INFILE *inpf ) 
{ 
  int ch ;
  BOOL wordread ;
  STRPTR thisword ;
  BOOL ok ;
  BOOL (*isnc)(int ch ) ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;
  int tmp___3 ;

  {
#line 895
  ch = -1;
#line 896
  wordread = (BOOL )0;
#line 897
  thisword = (STRPTR )((void *)0);
#line 898
  ok = (BOOL )1;
#line 901
  isnc = inpf->is_nc;
#line 902
  if ((unsigned long )isnc == (unsigned long )((void *)0)) {
#line 903
    isnc = & default_normch;
  }
  {
#line 906
  infskip_ws(inpf);
#line 908
  ok = ugly_clr_estr(inpf->wordbuf);
#line 913
  tmp___3 = infeof(inpf);
  }
#line 913
  if (! tmp___3) {
    {
#line 914
    ch = infgetc(inpf);
#line 916
    tmp___2 = (*isnc)(ch);
    }
#line 916
    if (tmp___2) {
      {
#line 917
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 918
        tmp = ugly_app_estrch(inpf->wordbuf, ch);
#line 918
        ok = (BOOL )((int )ok & (int )tmp);
#line 919
        ch = ugly_infgetc(inpf);
        }
#line 917
        if (ch != -1) {
#line 917
          if (ok) {
            {
#line 917
            tmp___0 = (*isnc)(ch);
            }
#line 917
            if (! tmp___0) {
#line 917
              goto while_break;
            }
          } else {
#line 917
            goto while_break;
          }
        } else {
#line 917
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 922
      wordread = (BOOL )1;
#line 923
      if (ch != -1) {
        {
#line 924
        inungetc(ch, inpf);
        }
      }
    } else {
      {
#line 926
      tmp___1 = ugly_app_estrch(inpf->wordbuf, ch);
#line 926
      ok = (BOOL )((int )ok & (int )tmp___1);
      }
    }
#line 928
    thisword = (inpf->wordbuf)->es_data;
  }
#line 930
  return (thisword);
}
}
#line 938 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
STRPTR infreadtoeol(INFILE *inpf ) 
{ 
  int ch ;
  BOOL ok ;
  BOOL tmp ;
  int tmp___0 ;
  STRPTR tmp___1 ;

  {
  {
#line 940
  ch = -1;
#line 943
  ok = ugly_clr_estr(inpf->wordbuf);
#line 944
  tmp___0 = infeof(inpf);
  }
#line 944
  if (! tmp___0) {
    {
#line 947
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 949
      ch = ugly_infgetc(inpf);
      }
#line 950
      if (ch != 13) {
#line 950
        if (ch != 10) {
          {
#line 951
          tmp = ugly_app_estrch(inpf->wordbuf, ch);
#line 951
          ok = (BOOL )((int )ok & (int )tmp);
          }
        }
      }
#line 947
      if (ok) {
#line 947
        if (ch > 0) {
#line 947
          if (! (ch != 10)) {
#line 947
            goto while_break;
          }
        } else {
#line 947
          goto while_break;
        }
      } else {
#line 947
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 955
    if (ch == 10) {
      {
#line 957
      ch = ugly_infgetc(inpf);
      }
#line 958
      if (ch != 13) {
        {
#line 959
        inungetc(ch, inpf);
        }
      }
    }
  }
  {
#line 962
  tmp___1 = ugly_strclone((CONSTRPTR )(inpf->wordbuf)->es_data, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c",
                          (ULONG )962);
  }
#line 962
  return (tmp___1);
}
}
#line 970 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
int infgotoeol(INFILE *inpf ) 
{ 
  int ch ;
  int tmp ;

  {
  {
#line 972
  ch = -1;
#line 974
  tmp = infeof(inpf);
  }
#line 974
  if (! tmp) {
    {
#line 979
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 981
      ch = ugly_infgetc(inpf);
      }
#line 979
      if (ch > 0) {
#line 979
        if (! (ch != 10)) {
#line 979
          goto while_break;
        }
      } else {
#line 979
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 988
    if (ch == 10) {
      {
#line 990
      ch = ugly_infgetc(inpf);
      }
#line 991
      if (ch != 13) {
        {
#line 992
        inungetc(ch, inpf);
        }
      }
#line 993
      ch = 10;
    }
  }
#line 998
  return (ch);
}
}
#line 1010 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID del_infilepos_nddata(APTR data ) 
{ 
  INFILEPOS *pos ;

  {
#line 1012
  pos = (INFILEPOS *)data;
#line 1014
  if (pos) {
#line 1017
    ((pos->inpf)->pos_count) --;
#line 1024
    if (pos) {
      {
#line 1024
      free((void *)pos);
#line 1024
      pos = (INFILEPOS *)((void *)0);
      }
    }
  }
#line 1026
  return;
}
}
#line 1031 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static int cmp_posdata(APTR data1 , APTR data2 ) 
{ 


  {
#line 1033
  if ((unsigned long )data1 == (unsigned long )data2) {
#line 1035
    return (-1);
  } else {
#line 1039
    return (0);
  }
}
}
#line 1046 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
VOID del_infilepos(INFILEPOS *pos ) 
{ 
  INFILE *inpf ;
  DLNODE *nd ;
  DLNODE *tmp ;

  {
#line 1048
  if (pos) {
    {
#line 1050
    inpf = pos->inpf;
#line 1053
    ugly_freestr(pos->fname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c",
                 (ULONG )1053);
#line 1053
    pos->fname = (STRPTR )((void *)0);
    }
#line 1060
    if (inpf->closed) {
#line 1060
      if (inpf->pos_count == 1UL) {
        {
#line 1065
        ((pos->inpf)->pos_count) --;
#line 1066
        infclose1(inpf);
        }
      } else {
        {
#line 1070
        tmp = find_dlnode(((pos->inpf)->pos_list)->first, (APTR )pos, & cmp_posdata);
#line 1070
        nd = tmp;
#line 1072
        del_dlnode((pos->inpf)->pos_list, nd);
        }
      }
    } else {
      {
#line 1070
      tmp = find_dlnode(((pos->inpf)->pos_list)->first, (APTR )pos, & cmp_posdata);
#line 1070
      nd = tmp;
#line 1072
      del_dlnode((pos->inpf)->pos_list, nd);
      }
    }
  }
#line 1075
  return;
}
}
#line 1080 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
VOID del_all_infilepos(INFILE *inpf ) 
{ 


  {
  {
#line 1082
  del_all_dlnodes(inpf->pos_list);
  }
#line 1083
  return;
}
}
#line 1088 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static INFILEPOS *new_infilepos_node(INFILE *inpfile , ULONG x , ULONG y ) 
{ 
  INFILEPOS *pos ;
  void *tmp ;
  DLNODE *nd ;
  DLNODE *tmp___0 ;

  {
  {
#line 1090
  tmp = ugly_malloc_notracking(sizeof(INFILEPOS ));
#line 1090
  pos = (INFILEPOS *)tmp;
  }
#line 1092
  if (pos) {
    {
#line 1094
    tmp___0 = app_dlnode(inpfile->pos_list, (APTR )pos);
#line 1094
    nd = tmp___0;
#line 1096
    pos->inpf = inpfile;
#line 1097
    pos->fname = ugly_strclone((CONSTRPTR )inpfile->filename, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c",
                               (ULONG )1097);
#line 1098
    pos->x = x;
#line 1099
    pos->y = y;
#line 1100
    pos->fpos = inpfile->filepos;
    }
#line 1102
    if (! nd) {
      {
#line 1104
      del_infilepos_nddata((APTR )pos);
#line 1105
      pos = (INFILEPOS *)((void *)0);
      }
    } else {
#line 1109
      (inpfile->pos_count) ++;
    }
  }
#line 1128
  return (pos);
}
}
#line 1132 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
INFILEPOS *new_infilepos(INFILE *inpfile ) 
{ 
  INFILEPOS *pos ;
  ULONG tmp ;
  ULONG tmp___0 ;
  INFILEPOS *tmp___1 ;

  {
  {
#line 1134
  tmp = infget_y(inpfile);
#line 1134
  tmp___0 = infget_x(inpfile);
#line 1134
  tmp___1 = new_infilepos_node(inpfile, tmp___0, tmp);
#line 1134
  pos = tmp___1;
  }
#line 1136
  return (pos);
}
}
#line 1139 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
INFILEPOS *new_winfilepos(INFILE *inpfile ) 
{ 
  INFILEPOS *pos ;
  ULONG tmp ;
  ULONG tmp___0 ;
  INFILEPOS *tmp___1 ;

  {
  {
#line 1141
  tmp = infget_wy(inpfile);
#line 1141
  tmp___0 = infget_wx(inpfile);
#line 1141
  tmp___1 = new_infilepos_node(inpfile, tmp___0, tmp);
#line 1141
  pos = tmp___1;
  }
#line 1143
  return (pos);
}
}
#line 1161 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
INFILEPOS *clone_infilepos(INFILEPOS *ipos ) 
{ 
  INFILEPOS *pos ;
  INFILEPOS *tmp ;

  {
  {
#line 1163
  tmp = new_infilepos_node(ipos->inpf, ipos->x, ipos->y);
#line 1163
  pos = tmp;
  }
#line 1164
  return (pos);
}
}
#line 1170 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
STRPTR ifp_get_fname(INFILEPOS *pos ) 
{ 
  STRPTR tmp ;

  {
  {
#line 1172
  tmp = infget_fname(pos->inpf);
  }
#line 1172
  return (tmp);
}
}
#line 1175 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
ULONG ifp_get_x(INFILEPOS *pos ) 
{ 


  {
#line 1177
  return (pos->x);
}
}
#line 1180 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
ULONG ifp_get_y(INFILEPOS *pos ) 
{ 


  {
#line 1182
  return (pos->y);
}
}
#line 1185 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
BOOL set_infile_base(INFILE *inpf , INFILEPOS *pos ) 
{ 


  {
  {
#line 1191
  ugly_reallocstr(& inpf->filename, (CONSTRPTR )pos->fname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c",
                  (ULONG )1191);
#line 1192
  inpf->base_x = pos->x;
#line 1193
  inpf->base_y = pos->y;
  }
#line 1194
  return ((BOOL )1);
}
}
#line 1197 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
BOOL set_infilepos(INFILE *inpf , INFILEPOS *pos ) 
{ 


  {
  {
#line 1203
  ugly_reallocstr(& inpf->filename, (CONSTRPTR )pos->fname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c",
                  (ULONG )1203);
#line 1205
  inpf->pos_x = pos->x;
#line 1206
  inpf->pos_y = pos->y;
#line 1207
  update_wpos(inpf);
  }
#line 1209
  return ((BOOL )1);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustrlist.c"
VOID del_string_node(APTR data ) 
{ 
  STRPTR s___2 ;

  {
  {
#line 41
  s___2 = (STRPTR )data;
#line 42
  ugly_freestr(s___2, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustrlist.c",
               (ULONG )42);
#line 42
  s___2 = (STRPTR )((void *)0);
  }
#line 43
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustrlist.c"
STRPTR new_string_node(STRPTR data ) 
{ 
  STRPTR tmp ;

  {
  {
#line 53
  tmp = ugly_strclone((CONSTRPTR )data, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustrlist.c",
                      (ULONG )53);
  }
#line 53
  return (tmp);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustrlist.c"
int cmp_string_node(APTR cmp_data , APTR lst_data ) 
{ 
  STRPTR s1 ;
  STRPTR s2 ;
  int tmp ;

  {
  {
#line 61
  s1 = (STRPTR )cmp_data;
#line 62
  s2 = (STRPTR )lst_data;
#line 71
  tmp = strcmp((char const   *)s1, (char const   *)s2);
  }
#line 71
  if (tmp) {
#line 74
    return (0);
  } else {
#line 72
    return (-1);
  }
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustrlist.c"
VOID del_strlist(DLLIST *list ) 
{ 


  {
  {
#line 82
  del_dllist(list);
  }
#line 83
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustrlist.c"
VOID clr_strlist(DLLIST *list ) 
{ 


  {
  {
#line 90
  del_all_dlnodes(list);
  }
#line 91
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustrlist.c"
DLLIST *init_strlist(void) 
{ 
  DLLIST *tmp ;

  {
  {
#line 98
  tmp = init_dllist(& del_string_node);
  }
#line 98
  return (tmp);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustrlist.c"
DLNODE *app_strnode(DLLIST *list , STRPTR str ) 
{ 
  STRPTR scp ;
  STRPTR tmp ;
  DLNODE *nd ;

  {
  {
#line 108
  tmp = new_string_node(str);
#line 108
  scp = tmp;
#line 109
  nd = (DLNODE *)((void *)0);
  }
#line 111
  if (scp) {
    {
#line 113
    nd = app_dlnode(list, (APTR )scp);
    }
  }
#line 116
  return (nd);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustrlist.c"
DLNODE *add_strnode(DLLIST *list , STRPTR str ) 
{ 
  STRPTR scp ;
  STRPTR tmp ;
  DLNODE *nd ;

  {
  {
#line 126
  tmp = new_string_node(str);
#line 126
  scp = tmp;
#line 127
  nd = (DLNODE *)((void *)0);
  }
#line 129
  if (scp) {
    {
#line 131
    nd = add_dlnode(list, (APTR )scp);
    }
  }
#line 134
  return (nd);
}
}
#line 86 "./hscprj/document.h"
VOID del_caller(APTR data ) ;
#line 87
CALLER *fpos2caller(INFILEPOS *fpos ) ;
#line 91
int cmp_document(APTR cmp_data , APTR list_data ) ;
#line 95
VOID del_reference(APTR data ) ;
#line 96
HSCREF *new_reference(STRPTR newname ) ;
#line 97
int cmp_reference(APTR cmp_data , APTR list_data ) ;
#line 98
HSCREF *app_reference(HSCDOC *document , STRPTR ref_name ) ;
#line 100
VOID del_include(APTR data ) ;
#line 101
HSCINC *new_include(STRPTR newname ) ;
#line 102
int cmp_include(APTR cmp_data , APTR list_data ) ;
#line 105
VOID del_iddef(APTR data ) ;
#line 106
HSCIDD *new_iddef(STRPTR newname ) ;
#line 107
VOID prt_iddef(FILE *stream , APTR data ) ;
#line 108
int cmp_iddef(APTR cmp_data , APTR list_data ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
VOID del_document(APTR data ) 
{ 
  HSCDOC *document ;

  {
#line 55
  if (data) {
    {
#line 57
    document = (HSCDOC *)data;
#line 59
    ugly_freestr(document->docname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c",
                 (ULONG )59);
#line 59
    document->docname = (STRPTR )((void *)0);
#line 60
    ugly_freestr(document->sourcename, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c",
                 (ULONG )60);
#line 60
    document->sourcename = (STRPTR )((void *)0);
#line 61
    del_estr(document->title);
#line 62
    del_dllist(document->iddefs);
#line 63
    del_dllist(document->includes);
#line 64
    del_dllist(document->references);
    }
#line 65
    if (document) {
      {
#line 65
      free((void *)document);
#line 65
      document = (HSCDOC *)((void *)0);
      }
    }
  }
#line 67
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
HSCDOC *new_document(STRPTR docname ) 
{ 
  HSCDOC *newdoc ;
  void *tmp ;

  {
  {
#line 72
  tmp = ugly_malloc_notracking(sizeof(HSCDOC ));
#line 72
  newdoc = (HSCDOC *)tmp;
#line 77
  newdoc->docname = ugly_strclone((CONSTRPTR )docname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c",
                                  (ULONG )77);
#line 78
  newdoc->sourcename = (STRPTR )((void *)0);
#line 79
  newdoc->title = ugly_init_estr((size_t )0);
#line 80
  newdoc->iddefs = init_dllist(& del_iddef);
#line 81
  newdoc->includes = init_dllist(& del_include);
#line 82
  newdoc->references = init_dllist(& del_reference);
  }
#line 84
  return (newdoc);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
int cmp_document(APTR cmp_data , APTR list_data ) 
{ 
  HSCDOC *document ;
  STRPTR fname1 ;
  STRPTR fname2 ;
  int tmp ;

  {
  {
#line 92
  document = (HSCDOC *)list_data;
#line 93
  fname1 = (STRPTR )((void *)0);
#line 94
  fname2 = (STRPTR )cmp_data;
#line 110
  fname1 = document->docname;
#line 112
  tmp = strcmp((char const   *)fname1, (char const   *)fname2);
  }
#line 112
  if (tmp) {
#line 118
    return (0);
  } else {
#line 114
    return (-1);
  }
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
DLNODE *find_document_node(DLLIST *list , STRPTR name ) 
{ 
  DLNODE *tmp ;

  {
  {
#line 125
  tmp = find_dlnode(list->first, (APTR )name, & cmp_document);
  }
#line 125
  return (tmp);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
HSCDOC *find_document(DLLIST *list , STRPTR name ) 
{ 
  DLNODE *nd ;
  DLNODE *tmp ;
  HSCDOC *document ;

  {
  {
#line 131
  tmp = find_document_node(list, name);
#line 131
  nd = tmp;
#line 132
  document = (HSCDOC *)((void *)0);
  }
#line 134
  if (nd) {
#line 135
    document = (HSCDOC *)nd->data;
  }
#line 137
  return (document);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
CALLER *new_caller(STRPTR name , ULONG posx , ULONG posy ) 
{ 
  CALLER *caller ;
  void *tmp ;

  {
  {
#line 145
  tmp = ugly_malloc_notracking(sizeof(CALLER ));
#line 145
  caller = (CALLER *)tmp;
#line 147
  caller->name = ugly_strclone((CONSTRPTR )name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c",
                               (ULONG )147);
#line 148
  caller->posx = posx;
#line 149
  caller->posy = posy;
  }
#line 151
  return (caller);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
VOID del_caller(APTR data ) 
{ 
  CALLER *caller ;

  {
#line 156
  if (data) {
    {
#line 158
    caller = (CALLER *)data;
#line 159
    ugly_freestr(caller->name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c",
                 (ULONG )159);
#line 159
    caller->name = (STRPTR )((void *)0);
    }
#line 160
    if (caller) {
      {
#line 160
      free((void *)caller);
#line 160
      caller = (CALLER *)((void *)0);
      }
    }
  }
#line 162
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
CALLER *fpos2caller(INFILEPOS *fpos ) 
{ 
  CALLER *cal ;
  ULONG tmp ;
  ULONG tmp___0 ;
  STRPTR tmp___1 ;

  {
#line 166
  cal = (CALLER *)((void *)0);
#line 168
  if (fpos) {
    {
#line 170
    tmp = ifp_get_y(fpos);
#line 170
    tmp___0 = ifp_get_x(fpos);
#line 170
    tmp___1 = ifp_get_fname(fpos);
#line 170
    cal = new_caller(tmp___1, tmp___0, tmp);
    }
  } else {
    {
#line 174
    cal = new_caller((STRPTR )"", (ULONG )0, (ULONG )0);
    }
  }
#line 176
  return (cal);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
VOID del_reference(APTR data ) 
{ 
  HSCREF *ref ;

  {
  {
#line 186
  ref = (HSCREF *)data;
#line 188
  ugly_freestr(ref->name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c",
               (ULONG )188);
#line 188
  ref->name = (STRPTR )((void *)0);
#line 189
  del_caller((APTR )ref->caller);
  }
#line 190
  if (ref) {
    {
#line 190
    free((void *)ref);
#line 190
    ref = (HSCREF *)((void *)0);
    }
  }
#line 193
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
HSCREF *new_reference(STRPTR newname ) 
{ 
  HSCREF *ref ;
  void *tmp ;

  {
  {
#line 198
  tmp = ugly_malloc_notracking(sizeof(HSCREF ));
#line 198
  ref = (HSCREF *)tmp;
  }
#line 200
  if (ref) {
    {
#line 202
    ref->name = ugly_strclone((CONSTRPTR )newname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c",
                              (ULONG )202);
#line 203
    ref->caller = (CALLER *)((void *)0);
    }
  }
#line 205
  return (ref);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
int cmp_reference(APTR cmp_data , APTR list_data ) 
{ 
  HSCREF *reference ;
  STRPTR fname1 ;
  STRPTR fname2 ;
  int tmp ;

  {
  {
#line 213
  reference = (HSCREF *)list_data;
#line 214
  fname1 = (STRPTR )((void *)0);
#line 215
  fname2 = (STRPTR )cmp_data;
#line 231
  fname1 = reference->name;
#line 233
  tmp = strcmp((char const   *)fname1, (char const   *)fname2);
  }
#line 233
  if (tmp) {
#line 239
    return (0);
  } else {
#line 235
    return (-1);
  }
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
HSCREF *app_reference(HSCDOC *document , STRPTR ref_name ) 
{ 
  HSCREF *ref ;

  {
  {
#line 249
  ref = (HSCREF *)((void *)0);
#line 252
  ref = new_reference(ref_name);
#line 253
  app_dlnode(document->references, (APTR )ref);
  }
#line 258
  return (ref);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
VOID del_include(APTR data ) 
{ 
  HSCINC *inc ;

  {
  {
#line 268
  inc = (HSCINC *)data;
#line 270
  ugly_freestr(inc->name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c",
               (ULONG )270);
#line 270
  inc->name = (STRPTR )((void *)0);
#line 271
  del_caller((APTR )inc->caller);
  }
#line 272
  if (inc) {
    {
#line 272
    free((void *)inc);
#line 272
    inc = (HSCINC *)((void *)0);
    }
  }
#line 273
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
HSCINC *new_include(STRPTR newname ) 
{ 
  HSCINC *inc ;
  void *tmp ;

  {
  {
#line 278
  tmp = ugly_malloc_notracking(sizeof(HSCINC ));
#line 278
  inc = (HSCINC *)tmp;
  }
#line 280
  if (inc) {
    {
#line 282
    inc->name = ugly_strclone((CONSTRPTR )newname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c",
                              (ULONG )282);
#line 283
    inc->caller = (CALLER *)((void *)0);
    }
  }
#line 285
  return (inc);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
int cmp_include(APTR cmp_data , APTR list_data ) 
{ 
  HSCINC *include ;
  STRPTR fname1 ;
  STRPTR fname2 ;
  int tmp ;

  {
  {
#line 293
  include = (HSCINC *)list_data;
#line 294
  fname1 = (STRPTR )((void *)0);
#line 295
  fname2 = (STRPTR )cmp_data;
#line 311
  fname1 = include->name;
#line 313
  tmp = strcmp((char const   *)fname1, (char const   *)fname2);
  }
#line 313
  if (tmp) {
#line 316
    return (0);
  } else {
#line 314
    return (-1);
  }
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
HSCINC *app_include(HSCDOC *document , STRPTR inc_name ) 
{ 
  DLNODE *nd ;
  HSCINC *inc ;
  HSCINC *tmp ;

  {
  {
#line 325
  nd = (DLNODE *)((void *)0);
#line 327
  tmp = new_include(inc_name);
#line 327
  inc = tmp;
#line 328
  nd = app_dlnode(document->includes, (APTR )inc);
  }
#line 330
  return (inc);
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
VOID del_iddef(APTR data ) 
{ 
  HSCIDD *iddef ;

  {
  {
#line 340
  iddef = (HSCIDD *)data;
#line 342
  ugly_freestr(iddef->name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c",
               (ULONG )342);
#line 342
  iddef->name = (STRPTR )((void *)0);
#line 343
  del_caller((APTR )iddef->caller);
  }
#line 344
  if (iddef->fpos) {
    {
#line 345
    del_infilepos(iddef->fpos);
    }
  }
#line 346
  if (iddef) {
    {
#line 346
    free((void *)iddef);
#line 346
    iddef = (HSCIDD *)((void *)0);
    }
  }
#line 347
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
HSCIDD *new_iddef(STRPTR newname ) 
{ 
  HSCIDD *iddef ;
  void *tmp ;

  {
  {
#line 352
  tmp = ugly_malloc_notracking(sizeof(HSCIDD ));
#line 352
  iddef = (HSCIDD *)tmp;
  }
#line 354
  if (iddef) {
    {
#line 356
    iddef->name = ugly_strclone((CONSTRPTR )newname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c",
                                (ULONG )356);
#line 357
    iddef->caller = (CALLER *)((void *)0);
#line 358
    iddef->fpos = (INFILEPOS *)((void *)0);
    }
  }
#line 360
  return (iddef);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
VOID prt_iddef(FILE *stream , APTR data ) 
{ 
  HSCIDD *iddef ;
  INFILEPOS *fpos ;
  ULONG tmp ;
  ULONG tmp___0 ;

  {
  {
#line 368
  iddef = (HSCIDD *)data;
#line 369
  fpos = iddef->fpos;
#line 371
  tmp = ifp_get_x(fpos);
#line 371
  tmp___0 = ifp_get_y(fpos);
#line 371
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"`%s\' at (%lu,%lu)\n",
          iddef->name, tmp___0, tmp);
  }
#line 373
  return;
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
int cmp_iddef(APTR cmp_data , APTR list_data ) 
{ 
  HSCIDD *iddef ;
  STRPTR fname1 ;
  STRPTR fname2 ;
  int tmp ;

  {
  {
#line 380
  iddef = (HSCIDD *)list_data;
#line 381
  fname1 = (STRPTR )((void *)0);
#line 382
  fname2 = (STRPTR )cmp_data;
#line 398
  fname1 = iddef->name;
#line 400
  tmp = strcmp((char const   *)fname1, (char const   *)fname2);
  }
#line 400
  if (tmp) {
#line 406
    return (0);
  } else {
#line 402
    return (-1);
  }
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
HSCIDD *find_iddef(HSCDOC *document , STRPTR name ) 
{ 
  DLNODE *nd ;
  DLNODE *tmp ;
  HSCIDD *iddef ;

  {
  {
#line 413
  tmp = find_dlnode((document->iddefs)->first, (APTR )name, & cmp_iddef);
#line 413
  nd = tmp;
#line 415
  iddef = (HSCIDD *)((void *)0);
  }
#line 417
  if (nd) {
#line 419
    iddef = (HSCIDD *)nd->data;
  }
#line 422
  return (iddef);
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/document.c"
HSCIDD *app_iddef(HSCDOC *document , STRPTR iddef_name ) 
{ 
  HSCIDD *iddef ;

  {
  {
#line 430
  iddef = (HSCIDD *)((void *)0);
#line 433
  iddef = new_iddef(iddef_name);
#line 434
  app_dlnode(document->iddefs, (APTR )iddef);
  }
#line 439
  return (iddef);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/license.c"
STRPTR hsc_license  =    (STRPTR )"\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\nFor support, visit `http://www.linguistik.uni-erlangen.de/~msbethke/software.html\'.\n\n";
#line 59 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/license.c"
VOID show_license(void) 
{ 


  {
  {
#line 61
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)hsc_license);
  }
#line 62
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
static void es_null___0(STRPTR func , STRPTR file , ULONG line ) 
{ 


  {
  {
#line 124
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n##\n## panic: es=NULL in %s()\n##   called from %s (%lu)\n##\n",
          func, file, line);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
static void s_null___0(STRPTR func , STRPTR file , ULONG line ) 
{ 


  {
  {
#line 130
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n##\n## panic: string=NULL in %s()\n##   called from %s (%lu)\n##\n",
          func, file, line);
  }
#line 132
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
static BOOL do_set_estr_mem___0(EXPSTR *es , STRPTR new_data , size_t new_size ) 
{ 
  BOOL ok ;

  {
#line 153
  ok = (BOOL )1;
#line 155
  if (new_data) {
#line 162
    es->es_size = new_size;
#line 163
    es->es_data = new_data;
  } else {
#line 167
    ok = (BOOL )0;
  }
#line 169
  return (ok);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
static size_t fextidx___0(CONSTRPTR fn ) 
{ 
  size_t i ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 160
  tmp = strlen(fn);
#line 160
  i = tmp - 1UL;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (i) {
#line 161
      if ((int const   )*(fn + i) != 46) {
        {
#line 161
        tmp___0 = strchr("/", (int )*(fn + i));
        }
#line 161
        if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 161
          goto while_break;
        }
      } else {
#line 161
        goto while_break;
      }
    } else {
#line 161
      goto while_break;
    }
#line 163
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if ((int const   )*(fn + i) != 46) {
    {
#line 165
    i = strlen(fn);
    }
  }
#line 167
  return (i);
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
static size_t adjust_prefix_length___0(size_t prefix_length ) 
{ 


  {
#line 350
  if (prefix_length > 246UL) {
#line 352
    prefix_length = (size_t )246;
  }
#line 355
  return (prefix_length);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
static LONG fileidx___0  =    (LONG )0;
#line 361 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
static STRARR buf___1[288]  ;
#line 252 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
static char ch2str_buffer___0[2]  ;
#line 320 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
static char num2str_buffer___0[10]  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static int arg_error_num___0  =    -1;
#line 65 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static STRPTR arg_error_arg___0  =    (STRPTR )((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static STRPTR arg_error_hfs___0  =    (STRPTR )((void *)0);
#line 72 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static STRARR argerrstr___0[60]  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static BOOL no_argerr___0  =    (BOOL )1;
#line 78 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static BOOL any_argerr___0  =    (BOOL )0;
#line 79 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static int argidx___0  =    -1;
#line 86 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static int compare_arginfo___0(APTR cmp_data , APTR list_data ) 
{ 
  struct arginfo *ai ;
  STRPTR lst_arg ;
  STRPTR tmp ;
  STRPTR cmp_arg ;
  BOOL eq ;
  char lastch ;
  STRPTR nxt_arg ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 88
  ai = (struct arginfo *)list_data;
#line 89
  tmp = ugly_strclone((CONSTRPTR )ai->ai_id, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c",
                      (ULONG )89);
#line 89
  lst_arg = tmp;
#line 90
  cmp_arg = ((struct arginfo *)cmp_data)->ai_id;
#line 91
  eq = (BOOL )0;
  }
#line 94
  if (lst_arg) {
#line 94
    if (cmp_arg) {
      {
#line 96
      tmp___0 = strtok((char */* __restrict  */)lst_arg, (char const   */* __restrict  */)"=");
#line 96
      nxt_arg = tmp___0;
      }
      {
#line 98
      while (1) {
        while_continue: /* CIL Label */ ;
#line 98
        if (nxt_arg) {
#line 98
          if (! ((int )eq == 0)) {
#line 98
            goto while_break;
          }
        } else {
#line 98
          goto while_break;
        }
#line 100
        if (ai->ai_flags & (long )(1 << 3)) {
          {
#line 102
          tmp___1 = strlen((char const   *)nxt_arg);
#line 102
          tmp___2 = strncmp((char const   *)nxt_arg, (char const   *)cmp_arg, tmp___1);
#line 102
          eq = (BOOL )(tmp___2 == 0);
          }
        } else {
          {
#line 106
          tmp___3 = strlen((char const   *)nxt_arg);
#line 106
          tmp___4 = upstrncmp((CONSTRPTR )nxt_arg, (CONSTRPTR )cmp_arg, tmp___3);
#line 106
          eq = (BOOL )(tmp___4 == 0);
          }
        }
        {
#line 116
        tmp___5 = strlen((char const   *)nxt_arg);
#line 116
        lastch = *(cmp_arg + tmp___5);
        }
#line 117
        if ((int )lastch == 0) {
#line 117
          tmp___6 = 1;
        } else
#line 117
        if ((int )lastch == 61) {
#line 117
          tmp___6 = 1;
        } else {
#line 117
          tmp___6 = 0;
        }
        {
#line 117
        eq = (BOOL )((int )eq & tmp___6);
#line 119
        nxt_arg = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"=");
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 125
      eq = (BOOL )0;
    }
  } else {
#line 125
    eq = (BOOL )0;
  }
  {
#line 128
  ugly_freestr(lst_arg, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c",
               (ULONG )128);
#line 128
  lst_arg = (STRPTR )((void *)0);
  }
#line 130
  return ((int )eq);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID clr_ai_set___0(ARGLIST *al ) 
{ 
  struct dlnode *nd ;
  struct arginfo *ai ;

  {
#line 157
  if (al) {
#line 157
    if (al->al_list) {
#line 159
      nd = (al->al_list)->first;
      {
#line 161
      while (1) {
        while_continue: /* CIL Label */ ;
#line 161
        if (! nd) {
#line 161
          goto while_break;
        }
#line 163
        ai = (struct arginfo *)nd->data;
#line 165
        if (ai) {
#line 166
          ai->ai_set = (BOOL )0;
        }
#line 167
        nd = nd->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 170
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID reset_nokeywd___0(ARGLIST *al ) 
{ 
  struct dlnode *nd ;
  struct arginfo *ai ;

  {
#line 186
  nd = (al->al_list)->first;
#line 187
  ai = (struct arginfo *)nd->data;
#line 189
  if (ai->ai_flags & 1L) {
#line 189
    goto _L___0;
  } else
#line 189
  if (ai->ai_type == 1L) {
    _L___0: /* CIL Label */ 
#line 191
    al->al_nokeywd = (struct arginfo *)((void *)0);
    {
#line 193
    while (1) {
      while_continue: /* CIL Label */ ;
#line 195
      if (ai->ai_flags & 1L) {
#line 195
        goto _L;
      } else
#line 195
      if (ai->ai_type == 1L) {
        _L: /* CIL Label */ 
#line 198
        nd = nd->next;
#line 199
        if (nd) {
#line 200
          ai = (struct arginfo *)nd->data;
        }
      } else {
#line 203
        al->al_nokeywd = ai;
      }
#line 193
      if (nd) {
#line 193
        if (! (! al->al_nokeywd)) {
#line 193
          goto while_break;
        }
      } else {
#line 193
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 209
    al->al_nokeywd = ai;
  }
#line 211
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID find_nxt_nokeywd___0(ARGLIST *al ) 
{ 
  struct dlnode *nd ;
  struct arginfo *ai ;
  BOOL is_keywd ;
  BOOL multiple_nokeywd ;
  int tmp ;

  {
#line 221
  if (al->al_nokeywd) {
#line 253
    nd = (al->al_list)->first;
#line 259
    al->al_nokeywd = (struct arginfo *)((void *)0);
    {
#line 260
    while (1) {
      while_continue: /* CIL Label */ ;
#line 260
      if (nd) {
#line 260
        if (! ((unsigned long )al->al_nokeywd == (unsigned long )((void *)0))) {
#line 260
          goto while_break;
        }
      } else {
#line 260
        goto while_break;
      }
#line 262
      is_keywd = (BOOL )0;
#line 263
      multiple_nokeywd = (BOOL )0;
#line 265
      ai = (struct arginfo *)nd->data;
#line 267
      is_keywd = (BOOL )(ai->ai_flags & 1L);
#line 268
      if (ai->ai_flags & (long )(1 << 2)) {
#line 268
        if (! is_keywd) {
#line 268
          tmp = 1;
        } else {
#line 268
          tmp = 0;
        }
      } else {
#line 268
        tmp = 0;
      }
#line 268
      multiple_nokeywd = (BOOL )tmp;
#line 272
      if (ai->ai_flags & 1L) {
#line 272
        goto _L;
      } else
#line 272
      if (ai->ai_type == 1L) {
#line 272
        goto _L;
      } else
#line 272
      if (ai->ai_set) {
        _L: /* CIL Label */ 
#line 272
        if (! multiple_nokeywd) {
#line 277
          nd = nd->next;
        } else {
#line 281
          al->al_nokeywd = ai;
        }
      } else {
#line 281
        al->al_nokeywd = ai;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 285
  return;
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID set_argerr___0(int num , STRPTR arg ) 
{ 


  {
#line 294
  if (no_argerr___0) {
#line 296
    no_argerr___0 = (BOOL )0;
#line 297
    any_argerr___0 = (BOOL )1;
#line 299
    arg_error_num___0 = num;
#line 300
    arg_error_arg___0 = arg;
  }
#line 302
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID clr_argerr___0(void) 
{ 


  {
#line 306
  no_argerr___0 = (BOOL )1;
#line 307
  any_argerr___0 = (BOOL )0;
#line 308
  arg_error_num___0 = 0;
#line 309
  arg_error_arg___0 = (STRPTR )((void *)0);
#line 310
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static UBYTE set_arg_value___0(struct arginfo *ai , STRPTR arg , STRPTR arg2 , BOOL keywd ) 
{ 
  APTR dest ;
  STRPTR param ;
  UBYTE arg_incr ;
  BOOL arg2used ;
  APTR aparam ;
  DLLIST **dest_list ;
  LONG along ;
  BOOL tmp ;
  LONG aenum ;
  LONG tmp___0 ;
  DLNODE *tmp___1 ;

  {
#line 404
  dest = ai->ai_dest;
#line 406
  arg_incr = (UBYTE )0;
#line 407
  arg2used = (BOOL )0;
#line 414
  if (keywd) {
#line 414
    if (! (ai->ai_type == 1L)) {
#line 416
      param = arg;
      {
#line 417
      while (1) {
        while_continue: /* CIL Label */ ;
#line 417
        if (*(param + 0)) {
#line 417
          if (! ((int )*(param + 0) != 61)) {
#line 417
            goto while_break;
          }
        } else {
#line 417
          goto while_break;
        }
#line 418
        param ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 419
      if (*(param + 0)) {
#line 420
        param ++;
      } else {
#line 423
        param = arg2;
#line 424
        arg2used = (BOOL )1;
#line 425
        if (! param) {
          {
#line 426
          set_argerr___0(3, arg);
          }
        }
      }
    } else {
#line 430
      param = arg;
    }
  } else {
#line 430
    param = arg;
  }
#line 435
  if (no_argerr___0) {
#line 437
    if (ai->ai_func) {
      {
#line 440
      arg_error_hfs___0 = (*(ai->ai_func))(param);
      }
#line 441
      if (arg_error_hfs___0) {
        {
#line 442
        set_argerr___0(127, param);
        }
      }
    } else
#line 444
    if (ai->ai_type == 1L) {
#line 446
      *((BOOL *)dest) = (BOOL )1;
    } else {
#line 453
      if ((int )ai->ai_set == 2) {
#line 453
        if (ai->ai_flags & (long )(1 << 4)) {
#line 461
          ai->ai_set = (BOOL )2;
        } else
#line 453
        if (ai->ai_flags & (long )(1 << 2)) {
#line 461
          ai->ai_set = (BOOL )2;
        } else {
          {
#line 457
          set_argerr___0(8, arg);
          }
        }
      } else {
#line 461
        ai->ai_set = (BOOL )2;
      }
#line 464
      if (no_argerr___0) {
#line 466
        aparam = (void *)0;
#line 467
        dest_list = (DLLIST **)dest;
#line 473
        if (! param) {
          {
#line 476
          set_argerr___0(9, arg);
          }
        }
#line 478
        if (ai->ai_type == 2L) {
#line 480
          aparam = (APTR )param;
        } else
#line 482
        if (ai->ai_type == 3L) {
          {
#line 484
          tmp = str2long(param, & along);
          }
#line 484
          if (tmp) {
#line 487
            aparam = (APTR )along;
          } else {
            {
#line 485
            set_argerr___0(2, arg);
            }
          }
        } else
#line 489
        if (ai->ai_type == 5L) {
          {
#line 491
          tmp___0 = strenum((CONSTRPTR )param, (CONSTRPTR )ai->ai_misc1.ai_enum, (char )'|',
                            (BYTE )1);
#line 491
          aenum = tmp___0;
          }
#line 494
          if (! aenum) {
            {
#line 495
            set_argerr___0(5, arg);
            }
          } else {
#line 497
            aparam = (APTR )aenum;
          }
        }
#line 514
        if (no_argerr___0) {
#line 516
          if (ai->ai_flags & (long )(1 << 2)) {
#line 518
            if (! *dest_list) {
              {
#line 519
              *dest_list = init_dllist((void (*)(APTR data ))((void *)0));
              }
            }
#line 520
            if (*dest_list) {
              {
#line 522
              tmp___1 = app_dlnode(*dest_list, aparam);
              }
#line 522
              if (! tmp___1) {
                {
#line 523
                set_argerr___0(1, arg);
                }
              }
            } else {
              {
#line 526
              set_argerr___0(1, arg);
              }
            }
          } else
#line 530
          if (ai->ai_type == 3L) {
#line 531
            *((LONG *)dest) = (LONG )aparam;
          } else
#line 532
          if (ai->ai_type == 5L) {
#line 533
            *((LONG *)dest) = (LONG )aparam;
          } else
#line 534
          if (ai->ai_type == 2L) {
#line 535
            *((STRPTR *)dest) = (STRPTR )aparam;
          }
        }
      }
    }
#line 542
    if (arg2used) {
#line 543
      arg_incr = (UBYTE )1;
    }
  }
#line 546
  return (arg_incr);
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID check_required_set___0(ARGLIST *al ) 
{ 
  DLNODE *nd ;
  ARGINFO *ai ;

  {
#line 557
  nd = (al->al_list)->first;
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    ai = (struct arginfo *)nd->data;
#line 564
    if (ai->ai_flags & (long )(1 << 1)) {
#line 564
      if ((int )ai->ai_set == 0) {
        {
#line 565
        set_argerr___0(3, ai->ai_id);
        }
      } else {
#line 567
        nd = nd->next;
      }
    } else {
#line 567
      nd = nd->next;
    }
#line 560
    if (nd) {
#line 560
      if (! no_argerr___0) {
#line 560
        goto while_break;
      }
    } else {
#line 560
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_hlp.c"
static VOID strcat_flag___0(STRPTR s___2 , struct arginfo *ai , ULONG chk_flag , char ch ) 
{ 
  char flag[3] ;

  {
#line 54
  flag[0] = (char )'/';
#line 54
  flag[1] = (char )'x';
#line 54
  flag[2] = (char )'\000';
#line 56
  if ((unsigned long )ai->ai_flags & chk_flag) {
    {
#line 58
    flag[1] = ch;
#line 59
    strcat((char */* __restrict  */)s___2, (char const   */* __restrict  */)(flag));
    }
  }
#line 61
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_hlp.c"
static STRARR s___0[100]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_hlp.c"
static STRPTR ai2str___0(struct arginfo *ai ) 
{ 


  {
  {
#line 67
  strncpy((char */* __restrict  */)(s___0), (char const   */* __restrict  */)ai->ai_id,
          (size_t )80);
  }
  {
#line 71
  if (ai->ai_type == 1L) {
#line 71
    goto case_1;
  }
#line 75
  if (ai->ai_type == 3L) {
#line 75
    goto case_3;
  }
#line 75
  if (ai->ai_type == 4L) {
#line 75
    goto case_3;
  }
#line 80
  if (ai->ai_type == (LONG )(1 << 5)) {
#line 80
    goto case_exp;
  }
#line 80
  if (ai->ai_type == 5L) {
#line 80
    goto case_exp;
  }
#line 80
  if (ai->ai_type == 2L) {
#line 80
    goto case_exp;
  }
#line 82
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 72
  strcat((char */* __restrict  */)(s___0), (char const   */* __restrict  */)"/S");
  }
#line 73
  goto switch_break;
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 76
  strcat((char */* __restrict  */)(s___0), (char const   */* __restrict  */)"/N");
  }
#line 77
  goto switch_break;
  case_exp: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 81
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 83
  strcat((char */* __restrict  */)(s___0), (char const   */* __restrict  */)"/?");
  }
#line 84
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 87
  strcat_flag___0(s___0, ai, (ULONG )1, (char )'K');
#line 88
  strcat_flag___0(s___0, ai, (ULONG )(1 << 1), (char )'A');
#line 89
  strcat_flag___0(s___0, ai, (ULONG )(1 << 2), (char )'M');
#line 90
  strcat_flag___0(s___0, ai, (ULONG )(1 << 3), (char )'C');
  }
#line 92
  return (s___0);
}
}
#line 695 "/usr/include/stdio.h"
extern int puts(char const   *__s ) ;
#line 125 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static STRPTR command_name[9]  = 
#line 125 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
  {      (STRPTR )"***NONE***",      (STRPTR )"count",      (STRPTR )"list",      (STRPTR )"extract", 
        (STRPTR )"delete",      (STRPTR )"erase",      (STRPTR )"add",      (STRPTR )"new", 
        (STRPTR )((void *)0)};
#line 138 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static int return_code___1  =    2;
#line 140 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static STRPTR prjfile___0  =    (STRPTR )((void *)0);
#line 141 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static LONG command  =    (LONG )2;
#line 142 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static LONG cmdArgNum  =    (LONG )0;
#line 143 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static DLLIST *command_arglist  =    (DLLIST *)((void *)0);
#line 144 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static BOOL force  =    (BOOL )0;
#line 145 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static BOOL quiet  =    (BOOL )0;
#line 146 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static BOOL debug___0  =    (BOOL )0;
#line 148 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static HSCPRJ *project___0  =    (HSCPRJ *)((void *)0);
#line 154 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static VOID cleanup___0(void) 
{ 


  {
#line 156
  if (debug___0) {
    {
#line 156
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(cleanup)\r");
    }
  }
  {
#line 157
  del_dllist(command_arglist);
#line 158
  del_project(project___0);
  }
#line 159
  if (debug___0) {
    {
#line 159
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         \r");
    }
  }
#line 160
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static VOID set_return_code___1(int new_code ) 
{ 


  {
#line 164
  if (new_code > return_code___1) {
#line 165
    return_code___1 = new_code;
  }
#line 166
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static BOOL hscpitt_nomem_handler(size_t size ) 
{ 


  {
  {
#line 175
  fputs((char const   */* __restrict  */)"*** out of memory\n", (FILE */* __restrict  */)stderr);
#line 177
  return_code___1 = 2;
#line 178
  exit(return_code___1);
  }
#line 180
  return ((BOOL )0);
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
BOOL update_project_file(HSCPRJ *project___1 ) 
{ 
  BOOL ok ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
#line 196
  ok = (BOOL )0;
#line 198
  if (debug___0) {
    {
#line 198
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscpit* update_project_file()\n");
    }
  }
  {
#line 201
  tmp = __errno_location();
#line 201
  *tmp = 0;
#line 202
  ok = hsc_project_write_data(project___1, prjfile___0, (BOOL )1);
  }
#line 204
  if (! ok) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error writing `%s\'",
            prjfile___0);
#line 207
    tmp___2 = __errno_location();
    }
#line 207
    if (*tmp___2) {
      {
#line 208
      tmp___0 = __errno_location();
#line 208
      tmp___1 = strerror(*tmp___0);
#line 208
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
              tmp___1);
      }
    }
    {
#line 209
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 210
    set_return_code___1(1);
    }
  }
#line 213
  return (ok);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
BOOL check_min_cmd_args(LONG minArgNum , DLLIST *list ) 
{ 
  BOOL ok ;
  DLNODE *nd ;
  LONG argNum ;

  {
#line 230
  ok = (BOOL )1;
#line 231
  nd = list->first;
#line 232
  argNum = (LONG )0;
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    if (! nd) {
#line 235
      goto while_break;
    }
#line 237
    argNum ++;
#line 238
    nd = nd->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  if (argNum < minArgNum) {
    {
#line 243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"command %s requires at least %ld arguments\n",
            command_name[command], minArgNum);
#line 245
    ok = (BOOL )0;
    }
  }
#line 248
  return (ok);
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static BOOL args_ok___1(int argc , char **argv ) 
{ 
  struct arglist *hscpitt_args ;
  BOOL arg_help___0 ;
  BOOL arg_license___0 ;
  BOOL ok ;

  {
  {
#line 263
  arg_help___0 = (BOOL )0;
#line 264
  arg_license___0 = (BOOL )0;
#line 265
  ok = (BOOL )0;
#line 268
  hscpitt_args = prepare_args((STRPTR )"HSCPITT_ARGS", "COMMAND/E", "count|list|extract|delete|erase|add|new",
                              & command, "command to perform (count|list|extract|delete|erase|add|new)",
                              "ARG/T/M", & command_arglist, "command argument(s)",
                              "PRJFILE/T/K", & prjfile___0, "project file", "FORCE/S",
                              & force, "disable certain checks", "QUIET/S", & quiet,
                              "act quietly", "-DEBUG/S", & debug___0, "enable debugging output",
                              "HELP=?=-h=--help/S", & arg_help___0, "display this text",
                              "LICENSE/S", & arg_license___0, "display license", (void *)0);
#line 281
  ok = (BOOL )((unsigned long )hscpitt_args != (unsigned long )((void *)0));
  }
#line 284
  if (ok) {
    {
#line 286
    ok = set_args(argc, argv, hscpitt_args);
    }
#line 289
    if (! ok) {
      {
#line 291
      pargerr();
#line 292
      set_return_code___1(1);
      }
    } else
#line 294
    if (arg_help___0) {
#line 294
      goto _L;
    } else
#line 294
    if (arg_license___0) {
      _L: /* CIL Label */ 
      {
#line 299
      fprintf_prginfo(stderr);
      }
#line 300
      if (arg_help___0) {
        {
#line 301
        fprintf_arghelp(stderr, hscpitt_args);
        }
      } else {
        {
#line 303
        show_license();
        }
      }
      {
#line 304
      set_return_code___1(0);
#line 305
      ok = (BOOL )0;
      }
    } else {
#line 310
      if (! quiet) {
        {
#line 311
        fprintf_prginfo(stderr);
        }
      }
#line 314
      if (! prjfile___0) {
#line 316
        prjfile___0 = (STRPTR )"hsc.project";
#line 317
        if (! quiet) {
          {
#line 319
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: using default project-file\n",
                  prjfile___0);
          }
        }
      }
#line 324
      if (command) {
#line 327
        if (debug___0) {
          {
#line 327
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscpit* prjfile =`%s\'\n",
                  prjfile___0);
#line 327
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscpit* command =`%ld\'\n",
                  command);
          }
        }
      } else {
        {
#line 336
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no command specified\n");
#line 337
        ok = (BOOL )0;
        }
      }
    }
#line 342
    if (! ok) {
      {
#line 344
      set_return_code___1(1);
      }
    }
    {
#line 348
    free_args(hscpitt_args);
    }
  } else
#line 353
  if (debug___0) {
    {
#line 353
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** ArgDef error: %lu\n",
            prep_error_num);
    }
  }
#line 357
  return (ok);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static BOOL read_project___0(void) 
{ 
  BOOL ok ;
  INFILE *inpf ;
  int *tmp ;
  BOOL tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 370
  ok = (BOOL )0;
#line 371
  inpf = (INFILE *)((void *)0);
#line 373
  if (! quiet) {
    {
#line 375
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: reading..\r",
            prjfile___0);
#line 376
    fflush(stderr);
    }
  }
  {
#line 380
  project___0->CB_msg_corrupt_pf = & msg_corrupt_pf;
#line 383
  tmp = __errno_location();
#line 383
  *tmp = 0;
#line 384
  inpf = infopen((CONSTRPTR )prjfile___0, (size_t )1024);
  }
#line 385
  if (inpf) {
    {
#line 387
    tmp___0 = hsc_project_read_data(project___0, inpf);
    }
#line 387
    if (tmp___0) {
#line 389
      if (! quiet) {
        {
#line 391
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: project-file read\n",
                prjfile___0);
        }
      }
#line 393
      ok = (BOOL )1;
    }
#line 395
    if (inpf) {
      {
#line 395
      infclose1(inpf);
#line 395
      inpf = (INFILE *)((void *)0);
      }
    }
  }
#line 398
  if (! ok) {
    {
#line 400
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error reading `%s\'",
            prjfile___0);
#line 401
    tmp___3 = __errno_location();
    }
#line 401
    if (*tmp___3) {
      {
#line 402
      tmp___1 = __errno_location();
#line 402
      tmp___2 = strerror(*tmp___1);
#line 402
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
              tmp___2);
      }
    }
    {
#line 403
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 407
  if (! ok) {
    {
#line 409
    set_return_code___1(1);
    }
  }
#line 412
  return (ok);
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static BOOL chkArg0(STRPTR command___0 ) 
{ 
  BOOL ok ;

  {
#line 424
  ok = (BOOL )1;
#line 425
  if (cmdArgNum) {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no arguments allowed for command `%s\'\n",
            command___0);
#line 428
    set_return_code___1(1);
#line 429
    ok = (BOOL )0;
    }
  }
#line 431
  return (ok);
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static BOOL chkArg2(STRPTR command___0 , STRPTR arg1 , STRPTR arg2 ) 
{ 
  BOOL ok ;

  {
#line 437
  ok = (BOOL )1;
#line 438
  if (cmdArgNum != 2L) {
    {
#line 440
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"two arguments required for command `%s\': %s and %s\n",
            command___0, arg1, arg2);
#line 442
    set_return_code___1(1);
#line 443
    ok = (BOOL )0;
    }
  }
#line 445
  return (ok);
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static BOOL chkArgAny(STRPTR command___0 ) 
{ 
  BOOL ok ;

  {
#line 451
  ok = (BOOL )1;
#line 452
  if (! cmdArgNum) {
    {
#line 454
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"arguments required for command `%s\'\n",
            command___0);
#line 455
    set_return_code___1(1);
#line 456
    ok = (BOOL )0;
    }
  }
#line 458
  return (ok);
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
BOOL command_new(HSCPRJ *project___1 , DLLIST *arglist ) 
{ 
  BOOL ok ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;

  {
  {
#line 476
  ok = (BOOL )1;
#line 478
  tmp___1 = chkArg0((STRPTR )"new");
  }
#line 478
  if (tmp___1) {
    {
#line 480
    tmp___0 = fexists(prjfile___0);
    }
#line 480
    if (tmp___0) {
#line 480
      if (! force) {
        {
#line 482
        printf((char const   */* __restrict  */)"project file `%s\' already exists\n",
               prjfile___0);
#line 483
        set_return_code___1(1);
#line 484
        ok = (BOOL )0;
        }
      } else {
#line 480
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 489
      tmp = update_project_file(project___1);
      }
#line 489
      if (tmp) {
#line 491
        if (! quiet) {
          {
#line 493
          printf((char const   */* __restrict  */)"Created new project file `%s\'\n",
                 prjfile___0);
          }
        }
      }
    }
  }
#line 499
  return (ok);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
VOID command_add(HSCPRJ *project___1 , DLLIST *arglist ) 
{ 
  BOOL deleted ;
  DLNODE *docNameNd ;
  DLNODE *docSourceNd ;
  STRPTR docName ;
  STRPTR docSource ;
  STRPTR operation ;
  BOOL tmp ;
  BOOL tmp___0 ;

  {
  {
#line 511
  tmp___0 = chkArg2((STRPTR )"add", (STRPTR )"DOCUMENT", (STRPTR )"SOURCE");
  }
#line 511
  if (tmp___0) {
    {
#line 513
    deleted = (BOOL )0;
#line 514
    docNameNd = arglist->first;
#line 515
    docSourceNd = docNameNd->next;
#line 516
    docName = (STRPTR )docNameNd->data;
#line 517
    docSource = (STRPTR )docSourceNd->data;
#line 520
    deleted = hsc_project_del_document(project___1, docName);
    }
#line 522
    if (! deleted) {
#line 522
      goto _L;
    } else
#line 522
    if (force) {
      _L: /* CIL Label */ 
#line 524
      if (debug___0) {
        {
#line 524
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscpit*  add doc=`%s\'\n    src=`%s\'\n",
                docName, docSource);
        }
      }
      {
#line 528
      hsc_project_set_document(project___1, docName);
#line 529
      hsc_project_set_source(project___1, docSource);
#line 530
      hsc_project_add_document(project___1);
#line 533
      tmp = update_project_file(project___1);
      }
#line 533
      if (tmp) {
#line 535
        if (! quiet) {
#line 537
          operation = (STRPTR )"Added";
#line 538
          if (deleted) {
#line 540
            operation = (STRPTR )"Replaced";
          }
          {
#line 542
          printf((char const   */* __restrict  */)"%s document `%s\'\n", operation,
                 docName);
          }
        }
      }
    } else {
      {
#line 548
      printf((char const   */* __restrict  */)"Document `%s\' already in project\n",
             docName);
#line 549
      set_return_code___1(0);
      }
    }
  }
#line 552
  return;
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
VOID command_delete(HSCPRJ *project___1 , DLLIST *arglist ) 
{ 
  DLNODE *docNode ;
  STRPTR docName ;
  BOOL deleted ;
  BOOL tmp ;

  {
  {
#line 563
  tmp = chkArgAny((STRPTR )"delete");
  }
#line 563
  if (tmp) {
#line 565
    docNode = arglist->first;
    {
#line 567
    while (1) {
      while_continue: /* CIL Label */ ;
#line 567
      if (! docNode) {
#line 567
        goto while_break;
      }
      {
#line 569
      docName = (STRPTR )docNode->data;
#line 570
      deleted = (BOOL )0;
#line 573
      deleted = hsc_project_del_document(project___1, docName);
      }
#line 576
      if (deleted) {
#line 578
        if (! quiet) {
          {
#line 580
          printf((char const   */* __restrict  */)"Delete `%s\'\n", docName);
          }
        }
      } else {
        {
#line 585
        printf((char const   */* __restrict  */)"Delete `%s\': no such document\n",
               docName);
#line 586
        set_return_code___1(0);
        }
      }
#line 588
      docNode = docNode->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 592
    update_project_file(project___1);
    }
  }
#line 594
  return;
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static BOOL uremove(STRPTR fname ) 
{ 
  BOOL erased ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 605
  erased = (BOOL )0;
#line 608
  tmp = __errno_location();
#line 608
  *tmp = 0;
#line 609
  tmp___0 = remove((char const   *)fname);
  }
#line 609
  if (tmp___0) {
#line 609
    tmp___1 = 0;
  } else {
#line 609
    tmp___1 = 1;
  }
#line 609
  erased = (BOOL )tmp___1;
#line 610
  if (erased) {
#line 612
    if (! quiet) {
      {
#line 614
      printf((char const   */* __restrict  */)"Delete `%s\'\n", fname);
      }
    }
  } else {
    {
#line 619
    tmp___2 = __errno_location();
#line 619
    tmp___3 = strerror(*tmp___2);
#line 619
    printf((char const   */* __restrict  */)"Error deleting `%s\': %s\n", fname, tmp___3);
    }
  }
#line 622
  return (erased);
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
VOID command_erase(HSCPRJ *project___1 , DLLIST *arglist ) 
{ 
  DLNODE *argNode ;
  BOOL erasedAny ;
  STRPTR docName ;
  HSCDOC *document ;
  HSCDOC *tmp ;
  BOOL erased ;
  BOOL tmp___0 ;

  {
  {
#line 627
  tmp___0 = chkArgAny((STRPTR )"erase");
  }
#line 627
  if (tmp___0) {
#line 629
    argNode = arglist->first;
#line 630
    erasedAny = (BOOL )0;
    {
#line 632
    while (1) {
      while_continue: /* CIL Label */ ;
#line 632
      if (! argNode) {
#line 632
        goto while_break;
      }
      {
#line 634
      docName = (STRPTR )argNode->data;
#line 635
      tmp = find_document(project___1->documents, docName);
#line 635
      document = tmp;
#line 636
      erased = (BOOL )0;
      }
#line 639
      if (document) {
        {
#line 641
        uremove(document->docname);
#line 642
        uremove(document->sourcename);
#line 643
        erased = hsc_project_del_document(project___1, docName);
        }
#line 644
        if (! erased) {
          {
#line 645
          display_panic_message((char *)"no document entry", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c",
                                (size_t )645);
          }
        }
      }
#line 649
      if (! erased) {
        {
#line 651
        printf((char const   */* __restrict  */)"Delete `%s\': no such document\n",
               docName);
#line 652
        set_return_code___1(0);
        }
      } else {
#line 657
        erasedAny = (BOOL )1;
      }
#line 660
      argNode = argNode->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 664
    if (erasedAny) {
      {
#line 666
      update_project_file(project___1);
      }
    }
  }
#line 669
  return;
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static VOID printfVar(STRPTR var , STRPTR value ) 
{ 


  {
#line 680
  if (! value) {
#line 681
    value = (STRPTR )"";
  }
  {
#line 682
  printf((char const   */* __restrict  */)"%s=\"%s\"\n", var, value);
  }
#line 683
  return;
}
}
#line 685 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
static VOID extract_document(HSCPRJ *project___1 , HSCDOC *document , BOOL emptyLine ) 
{ 
  DLNODE *nd ;
  HSCINC *include ;

  {
#line 688
  if (emptyLine) {
    {
#line 690
    puts("");
    }
  }
  {
#line 694
  printfVar((STRPTR )"DOCUMENT", document->docname);
#line 695
  printfVar((STRPTR )"SOURCE", document->sourcename);
  }
#line 699
  if (document->includes) {
#line 701
    nd = (document->includes)->first;
    {
#line 702
    while (1) {
      while_continue: /* CIL Label */ ;
#line 702
      if (! nd) {
#line 702
        goto while_break;
      }
      {
#line 704
      include = (HSCINC *)nd->data;
#line 705
      printfVar((STRPTR )"INCLUDE", include->name);
#line 706
      nd = nd->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 710
  return;
}
}
#line 712 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
VOID command_extract(HSCPRJ *project___1 , DLLIST *arglist ) 
{ 
  DLNODE *argNode ;
  BOOL emptyLine ;
  STRPTR docName ;
  HSCDOC *document ;
  HSCDOC *tmp ;
  DLNODE *docNode ;
  BOOL emptyLine___0 ;
  HSCDOC *document___0 ;

  {
#line 714
  if (cmdArgNum) {
#line 717
    argNode = arglist->first;
#line 718
    emptyLine = (BOOL )0;
    {
#line 720
    while (1) {
      while_continue: /* CIL Label */ ;
#line 720
      if (! argNode) {
#line 720
        goto while_break;
      }
      {
#line 722
      docName = (STRPTR )argNode->data;
#line 723
      tmp = find_document(project___1->documents, docName);
#line 723
      document = tmp;
      }
#line 726
      if (document) {
        {
#line 728
        extract_document(project___1, document, emptyLine);
#line 729
        emptyLine = (BOOL )1;
        }
      } else {
        {
#line 733
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Extract `%s\': no such document\n",
                docName);
#line 734
        set_return_code___1(0);
        }
      }
#line 737
      argNode = argNode->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 743
    docNode = (project___1->documents)->first;
#line 744
    emptyLine___0 = (BOOL )0;
    {
#line 746
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 746
      if (! docNode) {
#line 746
        goto while_break___0;
      }
      {
#line 748
      document___0 = (HSCDOC *)docNode->data;
#line 750
      extract_document(project___1, document___0, emptyLine___0);
#line 751
      emptyLine___0 = (BOOL )1;
#line 755
      docNode = docNode->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 758
  return;
}
}
#line 767 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
VOID command_count(HSCPRJ *project___1 , DLLIST *arglist ) 
{ 
  DLNODE *docNode ;
  ULONG docNum ;
  BOOL tmp ;

  {
  {
#line 769
  docNode = (project___1->documents)->first;
#line 770
  docNum = (ULONG )0;
#line 772
  tmp = chkArg0((STRPTR )"count");
  }
#line 772
  if (tmp) {
    {
#line 774
    while (1) {
      while_continue: /* CIL Label */ ;
#line 774
      if (! docNode) {
#line 774
        goto while_break;
      }
#line 776
      docNum ++;
#line 777
      docNode = docNode->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 781
    printf((char const   */* __restrict  */)"%lu\n", docNum);
    }
  }
#line 783
  return;
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
VOID command_list(HSCPRJ *project___1 , DLLIST *arglist ) 
{ 
  DLNODE *docNode ;
  HSCDOC *document ;
  BOOL tmp ;

  {
  {
#line 794
  tmp = chkArg0((STRPTR )"count");
  }
#line 794
  if (tmp) {
#line 796
    docNode = (project___1->documents)->first;
    {
#line 798
    while (1) {
      while_continue: /* CIL Label */ ;
#line 798
      if (! docNode) {
#line 798
        goto while_break;
      }
      {
#line 800
      document = (HSCDOC *)docNode->data;
#line 802
      printf((char const   */* __restrict  */)"%s\n", document->docname);
#line 803
      docNode = docNode->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 806
  return;
}
}
#line 814 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsctools/hscpitt.c"
BOOL process_command(HSCPRJ *project___1 , LONG command___0 , DLLIST *arglist ) 
{ 
  BOOL ok ;
  DLNODE *nd ;

  {
#line 816
  ok = (BOOL )1;
#line 817
  nd = (DLNODE *)((void *)0);
#line 819
  if (debug___0) {
    {
#line 819
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscpit* process_command()\n");
    }
  }
#line 820
  if (debug___0) {
    {
#line 820
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscpit* command: %s\n",
            command_name[command___0]);
    }
  }
#line 823
  if (arglist) {
#line 824
    nd = arglist->first;
  }
#line 825
  if (nd) {
#line 827
    if (debug___0) {
      {
#line 827
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscpit* command args:\n");
      }
    }
    {
#line 828
    while (1) {
      while_continue: /* CIL Label */ ;
#line 828
      if (! nd) {
#line 828
        goto while_break;
      }
#line 830
      if (debug___0) {
        {
#line 830
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscpit*   `%s\'\n",
                (STRPTR )nd->data);
        }
      }
#line 831
      cmdArgNum ++;
#line 832
      nd = nd->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 837
  if (debug___0) {
    {
#line 837
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscpit* command args: NONE\n");
    }
  }
#line 839
  if (debug___0) {
    {
#line 839
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscpit* cmdarg#: %ld\n",
            cmdArgNum);
    }
  }
  {
#line 843
  if (command___0 == 1L) {
#line 843
    goto case_1;
  }
#line 846
  if (command___0 == 2L) {
#line 846
    goto case_2;
  }
#line 849
  if (command___0 == 3L) {
#line 849
    goto case_3;
  }
#line 852
  if (command___0 == 4L) {
#line 852
    goto case_4;
  }
#line 855
  if (command___0 == 5L) {
#line 855
    goto case_5;
  }
#line 858
  if (command___0 == 6L) {
#line 858
    goto case_6;
  }
#line 861
  if (command___0 == 7L) {
#line 861
    goto case_7;
  }
#line 864
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 844
  command_count(project___1, arglist);
  }
#line 845
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 847
  command_list(project___1, arglist);
  }
#line 848
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 850
  command_extract(project___1, arglist);
  }
#line 851
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 853
  command_delete(project___1, arglist);
  }
#line 854
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 856
  command_erase(project___1, arglist);
  }
#line 857
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 859
  command_add(project___1, arglist);
  }
#line 860
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 862
  ok = command_new(project___1, arglist);
  }
#line 863
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 866
  if (debug___0) {
    {
#line 866
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hscpit* unknown command\n");
    }
  }
#line 867
  ok = (BOOL )0;
#line 868
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 872
  return (ok);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
static DLNODE *ins_dlnode___0(DLLIST *list , DLNODE *node , APTR data ) 
{ 
  DLNODE *newnode ;

  {
#line 170
  newnode = (DLNODE *)((void *)0);
#line 172
  if (list) {
    {
#line 173
    newnode = new_dlnode();
    }
#line 175
    if (newnode) {
#line 176
      newnode->data = data;
#line 177
      (list->entry_num) ++;
#line 179
      if (node) {
#line 180
        if ((unsigned long )list->first == (unsigned long )node) {
#line 182
          list->first = newnode;
        } else {
#line 185
          (node->prev)->next = newnode;
#line 186
          newnode->prev = node->prev;
        }
#line 188
        node->prev = newnode;
#line 189
        newnode->next = node;
      } else {
#line 191
        if (list->last) {
#line 192
          (list->last)->next = newnode;
        }
#line 193
        newnode->prev = list->last;
#line 194
        list->last = newnode;
      }
#line 197
      if ((unsigned long )list->first == (unsigned long )((void *)0)) {
#line 198
        list->first = newnode;
      }
#line 199
      if ((unsigned long )list->last == (unsigned long )((void *)0)) {
#line 200
        list->last = newnode;
      }
    }
  }
#line 203
  return (newnode);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/unikot.c"
static utf8_t const   first_char_mask___0[5]  = {      (utf8_t const   )192,      (utf8_t const   )224,      (utf8_t const   )240,      (utf8_t const   )248, 
        (utf8_t const   )252};
#line 51 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static STRARR timebuf___0[40]  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_ulong___0(EXPSTR *dest , ULONG num ) 
{ 
  STRARR lenbuf[20] ;

  {
  {
#line 68
  sprintf((char */* __restrict  */)(lenbuf), (char const   */* __restrict  */)"%lx ",
          num);
#line 69
  ugly_app_estr(dest, (CONSTRPTR )(lenbuf));
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_string___0(EXPSTR *dest , STRPTR s___2 ) 
{ 


  {
  {
#line 75
  ugly_app_estr(dest, (CONSTRPTR )s___2);
  }
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_caller___0(EXPSTR *dest , CALLER *caller ) 
{ 


  {
#line 89
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_docname___0(EXPSTR *prjstr , STRPTR docname ) 
{ 


  {
  {
#line 93
  ugly_app_estr(prjstr, "DOCUMENT");
#line 94
  ugly_app_estr(prjstr, " ");
#line 95
  append_string___0(prjstr, docname);
#line 96
  ugly_app_estr(prjstr, "\n");
  }
#line 97
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_sourcename___0(EXPSTR *prjstr , STRPTR sourcename ) 
{ 


  {
#line 101
  if (sourcename) {
    {
#line 103
    ugly_app_estr(prjstr, "SOURCE");
#line 104
    ugly_app_estr(prjstr, " ");
#line 105
    append_string___0(prjstr, sourcename);
#line 106
    ugly_app_estr(prjstr, "\n");
    }
  }
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_title___0(EXPSTR *prjstr , STRPTR title ) 
{ 


  {
#line 112
  if (title) {
    {
#line 114
    ugly_app_estr(prjstr, "TITLE");
#line 115
    ugly_app_estr(prjstr, " ");
#line 116
    append_string___0(prjstr, title);
#line 117
    ugly_app_estr(prjstr, "\n");
    }
  }
#line 119
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_include___0(EXPSTR *prjstr , HSCINC *include ) 
{ 


  {
  {
#line 133
  ugly_app_estr(prjstr, "INCLUDE");
#line 134
  ugly_app_estr(prjstr, " ");
#line 135
  append_string___0(prjstr, include->name);
#line 136
  append_caller___0(prjstr, include->caller);
#line 137
  ugly_app_estr(prjstr, "\n");
  }
#line 141
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_iddef___0(EXPSTR *prjstr , HSCIDD *iddef ) 
{ 


  {
  {
#line 160
  ugly_app_estr(prjstr, "ID");
#line 161
  ugly_app_estr(prjstr, " ");
#line 162
  append_string___0(prjstr, iddef->name);
#line 163
  append_caller___0(prjstr, iddef->caller);
#line 164
  ugly_app_estr(prjstr, "\n");
  }
#line 165
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_header___0(EXPSTR *prjstr ) 
{ 
  time_t now ;
  time_t tmp ;
  struct tm *tmp___0 ;

  {
  {
#line 172
  tmp = time((time_t *)((void *)0));
#line 172
  now = tmp;
#line 175
  tmp___0 = localtime((time_t const   *)(& now));
#line 175
  strftime((char */* __restrict  */)(timebuf___0), (size_t )40, (char const   */* __restrict  */)"%d-%b-%Y %H:%M:%S",
           (struct tm  const  */* __restrict  */)tmp___0);
#line 179
  ugly_app_estr(prjstr, "HSC_PROJECT\nVERSION ");
#line 181
  append_ulong___0(prjstr, (ULONG )3);
#line 182
  ugly_app_estr(prjstr, "\n");
#line 183
  ugly_app_estr(prjstr, "# Contains all data relevant for project.\n# Maintained by hsc, DO NOT MODIFY!\n");
#line 186
  ugly_app_estr(prjstr, "# updated: ");
#line 188
  ugly_app_estr(prjstr, (CONSTRPTR )(timebuf___0));
#line 189
  ugly_app_estrch(prjstr, '\n');
  }
#line 190
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_doc_includes___0(EXPSTR *prjstr , DLLIST *inclist ) 
{ 
  DLNODE *nd ;

  {
#line 195
  nd = inclist->first;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! nd) {
#line 196
      goto while_break;
    }
    {
#line 198
    append_include___0(prjstr, (HSCINC *)nd->data);
#line 199
    nd = nd->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_doc_iddefs___0(EXPSTR *prjstr , DLLIST *iddefs ) 
{ 
  DLNODE *nd ;

  {
#line 219
  nd = iddefs->first;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! nd) {
#line 220
      goto while_break;
    }
    {
#line 222
    append_iddef___0(prjstr, (HSCIDD *)nd->data);
#line 223
    nd = nd->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_document___0(EXPSTR *prjstr , HSCDOC *document ) 
{ 
  STRPTR docname ;

  {
  {
#line 230
  docname = document->docname;
#line 232
  append_docname___0(prjstr, docname);
#line 233
  append_sourcename___0(prjstr, document->sourcename);
#line 234
  append_title___0(prjstr, (document->title)->es_data);
#line 236
  append_doc_iddefs___0(prjstr, document->iddefs);
#line 237
  append_doc_includes___0(prjstr, document->includes);
  }
#line 241
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static VOID hsc_msg_project_corrupt___0(HSCPRJ *hp___0 , STRPTR descr ) 
{ 


  {
#line 55
  hp___0->fatal = (BOOL )1;
#line 56
  if (hp___0->CB_msg_corrupt_pf) {
    {
#line 57
    (*(hp___0->CB_msg_corrupt_pf))(hp___0, descr);
    }
  }
#line 58
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static int x2int___0(char c ) 
{ 


  {
#line 63
  if ((int )c >= 48) {
#line 63
    if ((int )c <= 57) {
#line 64
      return ((int )c - 48);
    }
  }
#line 65
  if ((int )c >= 65) {
#line 65
    if ((int )c <= 70) {
#line 66
      return (((int )c - 65) + 10);
    }
  }
#line 67
  if ((int )c >= 97) {
#line 67
    if ((int )c <= 102) {
#line 68
      return (((int )c - 97) + 10);
    }
  }
#line 69
  return (-1);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static ULONG read_ulong___0(HSCPRJ *hp___0 ) 
{ 
  INFILE *inpf ;
  ULONG num ;
  int ch ;
  int digit ;

  {
#line 77
  inpf = hp___0->inpf;
#line 78
  num = (ULONG )0;
#line 80
  digit = -1;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 84
    ch = infgetc(inpf);
    }
#line 85
    if (ch != 32) {
      {
#line 87
      digit = x2int___0((char )ch);
      }
#line 88
      if (digit == -1) {
#line 89
        num = (ULONG )0;
      } else {
#line 91
        num = (num << 4) + (ULONG )digit;
      }
    }
#line 93
    if (digit == -1) {
      {
#line 94
      hsc_msg_project_corrupt___0(hp___0, (STRPTR )"hex digit expected");
      }
    }
#line 82
    if (digit != -1) {
#line 82
      if (! (ch != 32)) {
#line 82
        goto while_break;
      }
    } else {
#line 82
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (digit == -1) {
#line 99
    num = (ULONG )0;
  }
#line 101
  return (num);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static STRPTR read_string___0(HSCPRJ *hp___0 , BOOL len_format ) 
{ 
  STRPTR dest ;
  ULONG len ;
  STRPTR s___2 ;
  ULONG i ;
  int ch ;
  void *tmp ;

  {
#line 110
  dest = (STRPTR )((void *)0);
#line 113
  if (! len_format) {
    {
#line 115
    s___2 = infreadtoeol(hp___0->inpf);
#line 116
    inungetc(10, hp___0->inpf);
    }
#line 117
    return (s___2);
  }
  {
#line 120
  len = read_ulong___0(hp___0);
  }
#line 121
  if (len) {
    {
#line 123
    ch = 'x';
#line 126
    tmp = ugly_malloc_notracking(len + 1UL);
#line 126
    dest = (STRPTR )tmp;
#line 127
    *(dest + len) = (char )'\000';
#line 129
    i = (ULONG )0;
    }
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (i < len) {
#line 129
        if (! (ch != -1)) {
#line 129
          goto while_break;
        }
      } else {
#line 129
        goto while_break;
      }
      {
#line 130
      ch = infgetc(hp___0->inpf);
      }
#line 131
      if (ch != -1) {
#line 132
        *(dest + i) = (char )ch;
      } else {
        {
#line 134
        hsc_msg_project_corrupt___0(hp___0, (STRPTR )"string expected");
        }
      }
#line 129
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 136
    if (ch != -1) {
#line 137
      *(dest + len) = (char)0;
    } else {
#line 139
      if (dest) {
        {
#line 139
        free((void *)dest);
#line 139
        dest = (STRPTR )((void *)0);
        }
      }
#line 140
      dest = (STRPTR )((void *)0);
    }
  }
#line 143
  return (dest);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static CALLER *read_caller___0(HSCPRJ *hp___0 , BOOL v2format ) 
{ 
  CALLER *caller ;
  STRPTR callerid ;
  STRPTR tmp ;
  int ch ;
  int tmp___0 ;
  STRPTR fname ;
  STRPTR tmp___1 ;
  ULONG tmp___2 ;
  ULONG tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 150
  caller = (CALLER *)((void *)0);
#line 151
  tmp = infgetw(hp___0->inpf);
#line 151
  callerid = tmp;
  }
#line 153
  if (callerid) {
    {
#line 153
    tmp___5 = upstrcmp((CONSTRPTR )callerid, "FROM");
    }
#line 153
    if (tmp___5) {
#line 153
      goto _L;
    } else {
      {
#line 154
      tmp___0 = infgetc(hp___0->inpf);
#line 154
      ch = tmp___0;
      }
#line 156
      if (ch == 32) {
        {
#line 157
        tmp___1 = read_string___0(hp___0, v2format);
#line 157
        fname = tmp___1;
#line 158
        tmp___2 = read_ulong___0(hp___0);
#line 158
        tmp___3 = read_ulong___0(hp___0);
#line 158
        caller = new_caller(fname, tmp___3, tmp___2);
#line 159
        ugly_freestr(fname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c",
                     (ULONG )159);
#line 159
        fname = (STRPTR )((void *)0);
        }
      } else {
        {
#line 161
        hsc_msg_project_corrupt___0(hp___0, (STRPTR )"blank expected");
        }
      }
    }
  } else
  _L: /* CIL Label */ 
#line 162
  if (callerid) {
    {
#line 162
    tmp___4 = strcmp((char const   *)callerid, "\n");
    }
#line 162
    if (! tmp___4) {
      {
#line 164
      inungetcw(hp___0->inpf);
      }
    }
  }
#line 167
  return (caller);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static BOOL read_lf___0(HSCPRJ *hp___0 ) 
{ 
  int ch ;
  int tmp ;
  BOOL ok ;

  {
  {
#line 174
  tmp = infgetc(hp___0->inpf);
#line 174
  ch = tmp;
#line 175
  ok = (BOOL )1;
  }
#line 177
  if (ch != 10) {
    {
#line 178
    hsc_msg_project_corrupt___0(hp___0, (STRPTR )"linefeed expected");
#line 179
    ok = (BOOL )0;
    }
  }
#line 181
  return (ok);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static STRPTR read_command___0(HSCPRJ *hp___0 ) 
{ 
  STRPTR command___0 ;
  int tmp ;

  {
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    command___0 = infgetw(hp___0->inpf);
    }
#line 192
    if (command___0) {
      {
#line 192
      tmp = strcmp((char const   *)command___0, "\n");
      }
#line 192
      if (tmp) {
#line 192
        goto while_break;
      }
    } else {
#line 192
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (command___0) {
    {
#line 198
    infskip_ws(hp___0->inpf);
    }
  }
#line 203
  return (command___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static int read_header___0(HSCPRJ *hp___0 ) 
{ 
  STRARR fileid[1UL + sizeof("HSC_PROJECT")] ;
  BOOL ok ;
  STRPTR cmd ;
  ULONG version ;
  size_t i ;
  int ch ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ULONG tmp___3 ;

  {
#line 211
  ok = (BOOL )0;
#line 212
  cmd = (STRPTR )((void *)0);
#line 213
  version = (ULONG )0;
#line 217
  i = (size_t )0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 217
    tmp___0 = strlen("HSC_PROJECT");
    }
#line 217
    if (! (i < tmp___0)) {
#line 217
      goto while_break;
    }
    {
#line 218
    tmp = infgetc(hp___0->inpf);
#line 218
    ch = tmp;
#line 220
    fileid[i] = (STRARR )((UBYTE )ch);
#line 217
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  fileid[i] = (STRARR )'\000';
#line 227
  tmp___1 = strcmp((char const   *)(fileid), "HSC_PROJECT");
  }
#line 227
  if (tmp___1) {
    {
#line 231
    hsc_msg_project_corrupt___0(hp___0, (STRPTR )"wrong file-id");
    }
  } else {
    {
#line 229
    ok = read_lf___0(hp___0);
    }
  }
#line 233
  if (ok) {
    {
#line 235
    ok = (BOOL )0;
#line 238
    cmd = read_command___0(hp___0);
    }
#line 241
    if (cmd) {
      {
#line 241
      tmp___2 = strcmp((char const   *)cmd, "VERSION");
      }
#line 241
      if (tmp___2) {
        {
#line 251
        hsc_msg_project_corrupt___0(hp___0, (STRPTR )"unknown version");
        }
      } else {
        {
#line 242
        version = read_ulong___0(hp___0);
        }
#line 246
        if (version) {
#line 246
          if (version <= 3UL) {
            {
#line 247
            ok = read_lf___0(hp___0);
            }
          } else {
            {
#line 249
            hsc_msg_project_corrupt___0(hp___0, (STRPTR )"wrong version");
            }
          }
        } else {
          {
#line 249
          hsc_msg_project_corrupt___0(hp___0, (STRPTR )"wrong version");
          }
        }
      }
    } else {
      {
#line 251
      hsc_msg_project_corrupt___0(hp___0, (STRPTR )"unknown version");
      }
    }
  }
#line 253
  if (ok) {
#line 253
    tmp___3 = version;
  } else {
#line 253
    tmp___3 = 0UL;
  }
#line 253
  return ((int )tmp___3);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UGLYMEM *first___0  =    (UGLYMEM *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UBYTE deadbeef___0[4]  = {      (UBYTE )222,      (UBYTE )173,      (UBYTE )190,      (UBYTE )239};
#line 83 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UBYTE deadfood___0[4]  = {      (UBYTE )222,      (UBYTE )173,      (UBYTE )240,      (UBYTE )13};
#line 86 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UBYTE ugly_fillchar___0  =    (UBYTE )129;
#line 88 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_umalloc_count___0  =    (ULONG )0;
#line 89 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_ufree_count___0  =    (ULONG )0;
#line 90 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_umalloc_count_fail___0  =    (ULONG )0;
#line 91 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_ufree_count_fail___0  =    (ULONG )0;
#line 92 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_maxmem_usage___0  =    (ULONG )0;
#line 93 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_curmem_usage___0  =    (ULONG )0;
#line 94 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_real_maxmem_usage___0  =    (ULONG )0;
#line 95 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_real_curmem_usage___0  =    (ULONG )0;
#line 96 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_maxnod_usage___0  =    (ULONG )0;
#line 97 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_curnod_usage___0  =    (ULONG )0;
#line 101
static BOOL ugly_walldamaged___0(UGLYMEM *umem ) ;
#line 123 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UGLYMEM *find_umem___0(void *mem ) 
{ 
  UGLYMEM *nxtum ;
  UGLYMEM *found ;

  {
#line 125
  nxtum = first___0;
#line 126
  found = (UGLYMEM *)((void *)0);
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (nxtum) {
#line 128
      if (! (! found)) {
#line 128
        goto while_break;
      }
    } else {
#line 128
      goto while_break;
    }
#line 130
    if ((unsigned long )nxtum->ptr == (unsigned long )mem) {
#line 132
      found = nxtum;
    }
#line 134
    nxtum = nxtum->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return (found);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UGLYMEM *find_prev___0(UGLYMEM *umem ) 
{ 
  UGLYMEM *prev ;
  UGLYMEM *pprev ;
  BOOL found ;

  {
#line 152
  prev = first___0;
#line 153
  pprev = (UGLYMEM *)((void *)0);
#line 154
  found = (BOOL )0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (prev) {
#line 156
      if (! (! found)) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 158
    found = (BOOL )((unsigned long )prev == (unsigned long )umem);
#line 159
    if (! found) {
#line 161
      pprev = prev;
#line 162
      prev = prev->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return (pprev);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void fill_mem4___0(void *mem , size_t size , UBYTE *value ) 
{ 
  size_t i ;

  {
#line 178
  i = (size_t )0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < size)) {
#line 178
      goto while_break;
    }
#line 180
    *((UBYTE *)mem + i) = *(value + i % 4UL);
#line 178
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void fill_mem___0(void *mem , size_t size , UBYTE value ) 
{ 
  size_t i ;

  {
#line 188
  i = (size_t )0;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (i < size)) {
#line 188
      goto while_break;
    }
#line 190
    *((UBYTE *)mem + i) = value;
#line 188
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void del_uglymem___0(UGLYMEM *umem ) 
{ 
  UGLYMEM *prev ;
  UGLYMEM *tmp ;
  BOOL tmp___0 ;

  {
  {
#line 201
  tmp = find_prev___0(umem);
#line 201
  prev = tmp;
  }
#line 204
  if (prev) {
#line 205
    prev->next = umem->next;
  } else {
#line 207
    first___0 = umem->next;
  }
  {
#line 210
  tmp___0 = ugly_walldamaged___0(umem);
  }
#line 210
  if (! tmp___0) {
    {
#line 216
    fill_mem4___0((void *)umem->lower, umem->size + 32UL, (UBYTE *)(deadbeef___0));
#line 217
    free((void *)umem->lower);
    }
  }
  {
#line 221
  umem->lower = (UBYTE *)((void *)0);
#line 222
  umem->upper = (UBYTE *)((void *)0);
#line 223
  umem->size = (size_t )0;
#line 224
  umem->file = (STRPTR )((void *)0);
#line 225
  umem->line = (ULONG )0;
#line 226
  free((void *)umem);
  }
#line 227
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UGLYMEM *new_uglymem___0(size_t memsize , STRPTR memfile , ULONG memline ) 
{ 
  UGLYMEM *newmem ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 236
  tmp = malloc(sizeof(UGLYMEM ));
#line 236
  newmem = (UGLYMEM *)tmp;
  }
#line 238
  if (newmem) {
    {
#line 240
    tmp___0 = ugly_malloc_notracking(memsize + 32UL);
#line 240
    newmem->lower = (UBYTE *)tmp___0;
    }
#line 242
    if (newmem->lower) {
      {
#line 245
      newmem->ptr = (void *)(newmem->lower + 16);
#line 246
      newmem->upper = (newmem->lower + 16) + memsize;
#line 249
      newmem->next = first___0;
#line 250
      first___0 = newmem;
#line 253
      newmem->size = memsize;
#line 254
      newmem->file = memfile;
#line 255
      newmem->line = memline;
#line 256
      newmem->fillchar = ugly_fillchar___0;
#line 259
      fill_mem4___0(newmem->ptr, memsize, (UBYTE *)(deadfood___0));
#line 262
      fill_mem___0((void *)newmem->lower, (size_t )16, ugly_fillchar___0);
#line 263
      fill_mem___0((void *)newmem->upper, (size_t )16, ugly_fillchar___0);
      }
#line 266
      if ((int )ugly_fillchar___0 == 255) {
#line 268
        ugly_fillchar___0 = (UBYTE )129;
      } else {
#line 272
        ugly_fillchar___0 = (UBYTE )((int )ugly_fillchar___0 + 1);
      }
    } else {
      {
#line 276
      free((void *)newmem);
      }
    }
  }
#line 278
  return (newmem);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void uglymem_message___0(STRPTR msg ) 
{ 


  {
  {
#line 283
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
  }
#line 284
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void ugly_memdump___0(void *ptr , size_t size ) 
{ 
  STRPTR data ;
  size_t i ;

  {
#line 288
  data = (STRPTR )ptr;
#line 291
  if (size > 16UL) {
#line 293
    size = (size_t )16;
  }
  {
#line 296
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %p:",
          ptr);
  }
#line 297
  if (data) {
#line 302
    i = (size_t )0;
    {
#line 302
    while (1) {
      while_continue: /* CIL Label */ ;
#line 302
      if (! (i < size)) {
#line 302
        goto while_break;
      }
#line 304
      if (! (i % 4UL)) {
        {
#line 306
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
        }
      }
      {
#line 308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x",
              (int )*(data + i));
#line 302
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 313
      if (! (i < 16UL)) {
#line 313
        goto while_break___0;
      }
#line 315
      if (! (i % 4UL)) {
        {
#line 317
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
        }
      }
      {
#line 319
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  ");
#line 320
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 323
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  \"");
#line 325
    i = (size_t )0;
    }
    {
#line 325
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 325
      if (! (i < size)) {
#line 325
        goto while_break___1;
      }
#line 327
      if ((int )*(data + i) < 32) {
        {
#line 329
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
        }
      } else {
        {
#line 333
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c",
                (int )*(data + i));
        }
      }
#line 325
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 336
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"\n");
    }
  } else {
    {
#line 340
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL\n");
    }
  }
#line 342
  return;
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void uglymem_meminfo___0(void *ptr , STRPTR file , ULONG line ) 
{ 


  {
  {
#line 346
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %p: from \"%s\" (%lu)\n",
          ptr, file, line);
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void umem_info___0(UGLYMEM *umem ) 
{ 


  {
  {
#line 351
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %p: %lu (0x%lx) bytes from \"%s\" (%lu)\n",
          umem->ptr, umem->size, umem->size, umem->file, umem->line);
  }
#line 354
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static STRARR strbuf___0[30]  ;
#line 368 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static STRPTR str_ubyte___0(UBYTE val ) 
{ 
  UBYTE ch ;

  {
#line 371
  ch = val;
#line 373
  if ((int )ch < 32) {
#line 374
    ch = (UBYTE )'.';
  }
  {
#line 376
  sprintf((char */* __restrict  */)(strbuf___0), (char const   */* __restrict  */)"(0x%02x/#%d/`%c\')",
          (int )val, (int )val, (int )ch);
  }
#line 378
  return (strbuf___0);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static BOOL ugly_walldamaged___0(UGLYMEM *umem ) 
{ 
  size_t i ;
  BOOL damaged ;
  BOOL lower_damaged ;
  BOOL upper_damaged ;
  int tmp ;
  STRPTR wall ;
  UBYTE value ;
  STRPTR tmp___0 ;

  {
#line 389
  i = (size_t )0;
#line 390
  damaged = (BOOL )0;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! damaged) {
#line 392
      if (! (i < 16UL)) {
#line 392
        goto while_break;
      }
    } else {
#line 392
      goto while_break;
    }
#line 394
    lower_damaged = (BOOL )((int )*(umem->lower + i) != (int )umem->fillchar);
#line 395
    upper_damaged = (BOOL )((int )*(umem->upper + i) != (int )umem->fillchar);
#line 397
    if (lower_damaged) {
#line 397
      tmp = 1;
    } else
#line 397
    if (upper_damaged) {
#line 397
      tmp = 1;
    } else {
#line 397
      tmp = 0;
    }
#line 397
    damaged = (BOOL )tmp;
#line 398
    if (damaged) {
#line 403
      if (lower_damaged) {
#line 405
        wall = (STRPTR )"LOWER";
#line 406
        value = *(umem->lower + i);
      } else {
#line 410
        wall = (STRPTR )"UPPER";
#line 411
        value = *(umem->upper + i);
      }
      {
#line 414
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** MEMORY WALL DAMAGED!!!\n");
#line 415
      tmp___0 = str_ubyte___0(value);
#line 415
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** %s wall, byte#%lu is %s instead of 0x%02x\n",
              wall, i, tmp___0, (int )umem->fillchar);
#line 417
      umem_info___0(umem);
#line 418
      ugly_memdump___0(umem->ptr, umem->size);
#line 419
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  * lower wall:\n");
#line 420
      ugly_memdump___0((void *)umem->lower, (size_t )16);
#line 421
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  * upper wall:\n");
#line 422
      ugly_memdump___0((void *)umem->upper, (size_t )16);
      }
    } else {
#line 427
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  return (damaged);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID del_infilepos_nddata___0(APTR data ) ;
#line 96 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static BOOL default_whtspc___0(int ch ) 
{ 
  char *tmp ;

  {
  {
#line 98
  tmp = strchr(" \t", ch);
  }
#line 98
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 100
    return ((BOOL )1);
  } else {
#line 104
    return ((BOOL )0);
  }
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static BOOL default_normch___0(int ch ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 110
  tmp = __ctype_b_loc();
  }
#line 110
  if ((int const   )*(*tmp + ch) & 8) {
#line 112
    return ((BOOL )1);
  } else
#line 110
  if (ch == 95) {
#line 112
    return ((BOOL )1);
  } else {
#line 116
    return ((BOOL )0);
  }
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID update_wpos___0(INFILE *inpf ) 
{ 


  {
#line 129
  inpf->wpos_x = inpf->pos_x;
#line 130
  inpf->wpos_y = inpf->pos_y;
#line 131
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID reset_infile___0(INFILE *inpf ) 
{ 


  {
  {
#line 147
  inpf->infile = (FILE *)((void *)0);
#line 148
  inpf->filename = (STRPTR )((void *)0);
#line 149
  inpf->lnbuf = (EXPSTR *)((void *)0);
#line 150
  inpf->wordbuf = (EXPSTR *)((void *)0);
#line 151
  inpf->wspcbuf = (EXPSTR *)((void *)0);
#line 153
  inpf->filepos = (ULONG )0;
#line 154
  inpf->pos_x = (ULONG )0;
#line 155
  inpf->pos_y = (ULONG )0;
#line 156
  update_wpos___0(inpf);
#line 158
  inpf->base_x = (ULONG )0;
#line 159
  inpf->base_y = (ULONG )0;
#line 160
  inpf->pos_list = (DLLIST *)((void *)0);
#line 161
  inpf->pos_count = (ULONG )0;
#line 162
  inpf->eof_reached = (BOOL )0;
#line 163
  inpf->out_of_mem = (BOOL )0;
#line 164
  inpf->skipped_ws = (BOOL )0;
#line 165
  inpf->closed = (BOOL )0;
#line 166
  inpf->is_nc = (BOOL (*)(int ch ))((void *)0);
#line 167
  inpf->is_ws = (BOOL (*)(int ch ))((void *)0);
  }
#line 168
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID del_infile___0(INFILE *inpf ) 
{ 


  {
#line 175
  if (inpf) {
#line 186
    if (inpf->pos_count) {
#line 188
      inpf->closed = (BOOL )1;
    } else {
#line 195
      if (inpf->infile) {
        {
#line 196
        fclose(inpf->infile);
        }
      }
      {
#line 199
      del_dllist(inpf->pos_list);
#line 202
      ugly_freestr(inpf->filename, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c",
                   (ULONG )202);
#line 202
      inpf->filename = (STRPTR )((void *)0);
#line 203
      del_estr(inpf->lnbuf);
#line 204
      del_estr(inpf->wordbuf);
#line 205
      del_estr(inpf->wspcbuf);
#line 208
      reset_infile___0(inpf);
      }
#line 211
      if (inpf) {
        {
#line 211
        free((void *)inpf);
#line 211
        inpf = (INFILE *)((void *)0);
        }
      }
    }
  }
#line 214
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static INFILE *init_infile___0(CONSTRPTR name , size_t buf_step , size_t word_step ) 
{ 
  INFILE *inpf ;
  void *tmp ;

  {
  {
#line 221
  tmp = ugly_malloc_notracking(sizeof(INFILE ));
#line 221
  inpf = (INFILE *)tmp;
  }
#line 223
  if (inpf) {
#line 226
    if (! buf_step) {
#line 227
      buf_step = (size_t )128;
    }
#line 228
    if (! word_step) {
#line 229
      word_step = (size_t )128;
    }
    {
#line 232
    reset_infile___0(inpf);
    }
#line 235
    if (name) {
      {
#line 236
      inpf->filename = ugly_strclone(name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c",
                                     (ULONG )236);
      }
    }
    {
#line 239
    inpf->lnbuf = ugly_init_estr(buf_step);
#line 240
    inpf->wordbuf = ugly_init_estr(word_step);
#line 241
    inpf->wspcbuf = ugly_init_estr(word_step);
#line 242
    inpf->pos_list = init_dllist(& del_infilepos_nddata___0);
#line 243
    inpf->pos_count = (ULONG )0;
    }
#line 246
    if (inpf->filename) {
#line 246
      goto _L;
    } else
#line 246
    if (! name) {
      _L: /* CIL Label */ 
#line 246
      if (inpf->lnbuf) {
#line 246
        if (inpf->wordbuf) {
#line 246
          if (! inpf->wspcbuf) {
            {
#line 253
            del_infile___0(inpf);
#line 254
            inpf = (INFILE *)((void *)0);
            }
          }
        } else {
          {
#line 253
          del_infile___0(inpf);
#line 254
          inpf = (INFILE *)((void *)0);
          }
        }
      } else {
        {
#line 253
        del_infile___0(inpf);
#line 254
        inpf = (INFILE *)((void *)0);
        }
      }
    } else {
      {
#line 253
      del_infile___0(inpf);
#line 254
      inpf = (INFILE *)((void *)0);
      }
    }
  }
#line 258
  return (inpf);
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static int ugly_inungetc___0(int ch , INFILE *inpf ) 
{ 
  int result ;
  STRPTR lnbuf_str ;

  {
#line 689
  result = -1;
#line 691
  if (inpf) {
#line 691
    if (inpf->filepos) {
#line 693
      lnbuf_str = (inpf->lnbuf)->es_data;
#line 696
      (inpf->filepos) --;
#line 699
      *(lnbuf_str + inpf->filepos) = (char )ch;
#line 700
      result = ch;
#line 703
      if (ch == 10) {
#line 705
        result = ch;
#line 706
        (inpf->pos_y) --;
#line 707
        inpf->pos_x = (ULONG )0;
      } else
#line 709
      if (inpf->pos_x) {
#line 710
        (inpf->pos_x) --;
      }
    }
  }
#line 713
  return (result);
}
}
#line 1010 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID del_infilepos_nddata___0(APTR data ) 
{ 
  INFILEPOS *pos ;

  {
#line 1012
  pos = (INFILEPOS *)data;
#line 1014
  if (pos) {
#line 1017
    ((pos->inpf)->pos_count) --;
#line 1024
    if (pos) {
      {
#line 1024
      free((void *)pos);
#line 1024
      pos = (INFILEPOS *)((void *)0);
      }
    }
  }
#line 1026
  return;
}
}
#line 1031 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static int cmp_posdata___0(APTR data1 , APTR data2 ) 
{ 


  {
#line 1033
  if ((unsigned long )data1 == (unsigned long )data2) {
#line 1035
    return (-1);
  } else {
#line 1039
    return (0);
  }
}
}
#line 1088 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static INFILEPOS *new_infilepos_node___0(INFILE *inpfile , ULONG x , ULONG y ) 
{ 
  INFILEPOS *pos ;
  void *tmp ;
  DLNODE *nd ;
  DLNODE *tmp___0 ;

  {
  {
#line 1090
  tmp = ugly_malloc_notracking(sizeof(INFILEPOS ));
#line 1090
  pos = (INFILEPOS *)tmp;
  }
#line 1092
  if (pos) {
    {
#line 1094
    tmp___0 = app_dlnode(inpfile->pos_list, (APTR )pos);
#line 1094
    nd = tmp___0;
#line 1096
    pos->inpf = inpfile;
#line 1097
    pos->fname = ugly_strclone((CONSTRPTR )inpfile->filename, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c",
                               (ULONG )1097);
#line 1098
    pos->x = x;
#line 1099
    pos->y = y;
#line 1100
    pos->fpos = inpfile->filepos;
    }
#line 1102
    if (! nd) {
      {
#line 1104
      del_infilepos_nddata___0((APTR )pos);
#line 1105
      pos = (INFILEPOS *)((void *)0);
      }
    } else {
#line 1109
      (inpfile->pos_count) ++;
    }
  }
#line 1128
  return (pos);
}
}
#line 142 "./hsclib/attrib.h"
HSCATTR *new_hscattr(CONSTRPTR newname ) ;
#line 143
VOID del_hscattr(APTR data ) ;
#line 146
DLNODE *find_attrnode(DLLIST *varlist , STRPTR name ) ;
#line 147
HSCATTR *find_varname(DLLIST *varlist , STRPTR name ) ;
#line 148
HSCATTR *app_var(DLLIST *varlist , STRPTR newname ) ;
#line 152
STRPTR set_vartext(HSCATTR *var , STRPTR newtext ) ;
#line 153
BOOL set_varbool(HSCATTR *attr , BOOL value ) ;
#line 154
BOOL clr_vartext(HSCATTR *var ) ;
#line 155
VOID clr_attrdef(HSCATTR *attr ) ;
#line 160
STRPTR get_vartext(HSCATTR *var ) ;
#line 166
STRPTR get_vardeftext(HSCATTR *var ) ;
#line 33 "./hsclib/lmessage.h"
VOID hsc_message(HSCPRC *hp___0 , HSCMSG_ID msg_id , char const   *format  , ...) ;
#line 36
VOID hsc_msg_eof(HSCPRC *hp___0 , STRPTR descr ) ;
#line 43 "./hsclib/eval.h"
STRPTR eval_expression(HSCPRC *hp___0 , HSCATTR *dest , STRPTR endstr ) ;
#line 41 "./hsclib/input.h"
STRPTR infget_attrid(HSCPRC *hp___0 ) ;
#line 43
BOOL parse_wd(HSCPRC *hp___0 , STRPTR expstr ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
static BYTE str2vartype(STRPTR s___2 ) 
{ 
  BYTE vartype ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 44
  vartype = (BYTE )0;
#line 46
  tmp___5 = upstrcmp("URI", (CONSTRPTR )s___2);
  }
#line 46
  if (tmp___5) {
    {
#line 48
    tmp___4 = upstrcmp("STRING", (CONSTRPTR )s___2);
    }
#line 48
    if (tmp___4) {
      {
#line 50
      tmp___3 = upstrcmp("BOOL", (CONSTRPTR )s___2);
      }
#line 50
      if (tmp___3) {
        {
#line 52
        tmp___2 = upstrcmp("NUM", (CONSTRPTR )s___2);
        }
#line 52
        if (tmp___2) {
          {
#line 54
          tmp___1 = upstrcmp("ENUM", (CONSTRPTR )s___2);
          }
#line 54
          if (tmp___1) {
            {
#line 56
            tmp___0 = upstrcmp("ID", (CONSTRPTR )s___2);
            }
#line 56
            if (tmp___0) {
              {
#line 58
              tmp = upstrcmp("COLOR", (CONSTRPTR )s___2);
              }
#line 58
              if (! tmp) {
#line 59
                vartype = (BYTE )7;
              }
            } else {
#line 57
              vartype = (BYTE )6;
            }
          } else {
#line 55
            vartype = (BYTE )5;
          }
        } else {
#line 53
          vartype = (BYTE )4;
        }
      } else {
#line 51
        vartype = (BYTE )3;
      }
    } else {
#line 49
      vartype = (BYTE )2;
    }
  } else {
#line 47
    vartype = (BYTE )1;
  }
#line 61
  return (vartype);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
static BOOL check_reqvar(HSCPRC *hp___0 , HSCATTR *var ) 
{ 
  BOOL ok ;

  {
#line 71
  ok = (BOOL )1;
#line 73
  if (var->varflag & (unsigned long )(1 << 6)) {
#line 73
    if (! var->text) {
      {
#line 74
      hsc_message(hp___0, (HSCMSG_ID )4186, "recommended %A missing", var);
      }
    }
  }
#line 76
  if (var->varflag & (unsigned long )(1 << 1)) {
#line 76
    if (! var->text) {
      {
#line 78
      hsc_message(hp___0, (HSCMSG_ID )16428, "required %A missing", var);
#line 80
      ok = (BOOL )0;
      }
    }
  }
#line 83
  return (ok);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
BOOL check_varlist(HSCPRC *hp___0 , DLLIST *varlist ) 
{ 
  DLNODE *nd ;
  BOOL ok ;
  BOOL tmp ;

  {
#line 88
  nd = varlist->first;
#line 89
  ok = (BOOL )1;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! nd) {
#line 91
      goto while_break;
    }
    {
#line 93
    tmp = check_reqvar(hp___0, (HSCATTR *)nd->data);
#line 93
    ok = (BOOL )((int )ok & (int )tmp);
#line 94
    nd = nd->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return (ok);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
LONG get_mci(HSCPRC *hp___0 ) 
{ 


  {
#line 112
  (hp___0->tag_call_id) ++;
#line 114
  return (hp___0->tag_call_id);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
VOID unget_mci(HSCPRC *hp___0 ) 
{ 


  {
#line 123
  (hp___0->tag_call_id) --;
#line 124
  if (hp___0->tag_call_id < 0L) {
    {
#line 126
    display_panic_message((char *)"MCI underflow", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c",
                          (size_t )126);
    }
  }
#line 128
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
LONG get_current_mci(HSCPRC *hp___0 ) 
{ 


  {
#line 136
  return (hp___0->tag_call_id);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
static BOOL read_enum_str(HSCPRC *hp___0 , HSCATTR *var ) 
{ 
  HSCATTR *attr ;
  HSCATTR *tmp ;
  STRPTR tmp___0 ;
  STRPTR tmp___1 ;

  {
  {
#line 152
  tmp = new_hscattr("HSC.TMP.enumerator");
#line 152
  attr = tmp;
#line 153
  attr->vartype = (BYTE )2;
#line 156
  tmp___1 = eval_expression(hp___0, attr, (STRPTR )((void *)0));
  }
#line 156
  if (tmp___1) {
    {
#line 159
    tmp___0 = get_vartext(attr);
#line 159
    var->enumstr = ugly_strclone((CONSTRPTR )tmp___0, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c",
                                 (ULONG )159);
    }
  }
  {
#line 163
  del_hscattr((APTR )attr);
  }
#line 165
  return ((BOOL )(! hp___0->fatal));
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
static BOOL check_attr_option(HSCPRC *hp___0 , STRPTR option , HSCATTR *attr , STRPTR id ,
                              STRPTR sid , ULONG value , ULONG unmasked_flags ) 
{ 
  BOOL found ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 183
  found = (BOOL )0;
#line 185
  tmp = upstrcmp((CONSTRPTR )option, (CONSTRPTR )id);
  }
#line 185
  if (tmp) {
    {
#line 185
    tmp___0 = upstrcmp((CONSTRPTR )option, (CONSTRPTR )sid);
    }
#line 185
    if (! tmp___0) {
#line 185
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 189
    if (value & unmasked_flags) {
      {
#line 191
      hsc_message(hp___0, (HSCMSG_ID )12312, "attribute option %q not allowed in this context",
                  id);
      }
    } else {
#line 196
      attr->varflag |= value;
    }
#line 198
    found = (BOOL )1;
  }
#line 201
  return (found);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
HSCATTR *define_var(HSCPRC *hp___0 , DLLIST *varlist , ULONG unmasked_flags ) 
{ 
  HSCATTR *var ;
  BOOL ok ;
  BYTE val_vartype ;
  BOOL newattr ;
  STRPTR nw ;
  STRPTR varname ;
  BOOL eof_called ;
  INFILE *inpf ;
  BOOL tmp ;
  DLNODE *nd ;
  DLNODE *tmp___0 ;
  BOOL ok___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;
  BOOL tmp___5 ;
  BOOL tmp___6 ;
  BOOL tmp___7 ;
  BOOL tmp___8 ;
  BOOL tmp___9 ;
  int tmp___10 ;
  STRPTR new_deftext ;
  LONG old_attrflag ;
  STRPTR dummy ;
  int tmp___11 ;
  DLNODE *nd___0 ;
  DLNODE *tmp___12 ;

  {
  {
#line 223
  var = (HSCATTR *)((void *)0);
#line 224
  ok = (BOOL )0;
#line 225
  val_vartype = (BYTE )0;
#line 226
  newattr = (BOOL )0;
#line 227
  nw = (STRPTR )((void *)0);
#line 228
  varname = (STRPTR )((void *)0);
#line 229
  eof_called = (BOOL )0;
#line 230
  inpf = hp___0->inpf;
#line 233
  nw = infget_attrid(hp___0);
  }
#line 234
  if (nw) {
    {
#line 235
    varname = ugly_strclone((CONSTRPTR )nw, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c",
                            (ULONG )235);
    }
  } else {
#line 237
    eof_called = (BOOL )1;
  }
#line 240
  if (nw) {
    {
#line 241
    tmp = parse_wd(hp___0, (STRPTR )":");
    }
#line 241
    if (tmp) {
      {
#line 242
      nw = infgetw(inpf);
      }
#line 243
      if (nw) {
        {
#line 244
        val_vartype = str2vartype(nw);
        }
      }
    } else {
      {
#line 246
      inungetcw(inpf);
      }
    }
  }
#line 249
  if (nw) {
    {
#line 255
    var = find_varname(varlist, varname);
    }
#line 256
    if (var) {
      {
#line 257
      tmp___0 = find_attrnode(varlist, varname);
#line 257
      nd = tmp___0;
      }
#line 260
      if (nd) {
        {
#line 261
        del_dlnode(varlist, nd);
        }
      } else {
        {
#line 263
        display_panic_message((char *)"no node for redefined attribute", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c",
                              (size_t )263);
        }
      }
      {
#line 265
      hsc_message(hp___0, (HSCMSG_ID )12351, "redefined %a", varname);
      }
    }
    {
#line 273
    var = app_var(varlist, varname);
#line 276
    var->vartype = val_vartype;
    }
#line 277
    if ((int )var->vartype == 5) {
      {
#line 279
      read_enum_str(hp___0, var);
      }
    } else
#line 280
    if ((int )var->vartype == 3) {
      {
#line 282
      set_varbool(var, (BOOL )0);
      }
    }
#line 285
    newattr = (BOOL )1;
  }
#line 289
  if (nw) {
#line 290
    if ((int )var->vartype != 1) {
#line 291
      unmasked_flags |= (unsigned long )((1 << 5) | (1 << 4));
    }
    {
#line 293
    nw = infgetw(inpf);
    }
  }
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (nw) {
      {
#line 299
      tmp___10 = strcmp((char const   *)nw, "/");
      }
#line 299
      if (tmp___10) {
#line 299
        goto while_break;
      }
    } else {
#line 299
      goto while_break;
    }
    {
#line 300
    nw = infgetw(inpf);
    }
#line 301
    if (nw) {
      {
#line 302
      ok___0 = (BOOL )0;
#line 304
      tmp___1 = check_attr_option(hp___0, nw, var, (STRPTR )"CONST", (STRPTR )"C",
                                  (ULONG )(1 << 2), unmasked_flags);
#line 304
      ok___0 = (BOOL )((int )ok___0 | (int )tmp___1);
#line 307
      tmp___2 = check_attr_option(hp___0, nw, var, (STRPTR )"GLOBAL", (STRPTR )"G",
                                  (ULONG )(1 << 29), unmasked_flags);
#line 307
      ok___0 = (BOOL )((int )ok___0 | (int )tmp___2);
#line 310
      tmp___3 = check_attr_option(hp___0, nw, var, (STRPTR )"JERK", (STRPTR )"J",
                                  (ULONG )(1 << 3), unmasked_flags);
#line 310
      ok___0 = (BOOL )((int )ok___0 | (int )tmp___3);
#line 313
      tmp___4 = check_attr_option(hp___0, nw, var, (STRPTR )"ONLYONCE", (STRPTR )"1",
                                  (ULONG )1, unmasked_flags);
#line 313
      ok___0 = (BOOL )((int )ok___0 | (int )tmp___4);
#line 316
      tmp___5 = check_attr_option(hp___0, nw, var, (STRPTR )"REQUIRED", (STRPTR )"R",
                                  (ULONG )(1 << 1), unmasked_flags);
#line 316
      ok___0 = (BOOL )((int )ok___0 | (int )tmp___5);
#line 319
      tmp___6 = check_attr_option(hp___0, nw, var, (STRPTR )"GETSIZE", (STRPTR )"Z",
                                  (ULONG )(1 << 5), unmasked_flags);
#line 319
      ok___0 = (BOOL )((int )ok___0 | (int )tmp___6);
#line 322
      tmp___7 = check_attr_option(hp___0, nw, var, (STRPTR )"STRIPEXT", (STRPTR )"X",
                                  (ULONG )(1 << 4), unmasked_flags);
#line 322
      ok___0 = (BOOL )((int )ok___0 | (int )tmp___7);
#line 325
      tmp___8 = check_attr_option(hp___0, nw, var, (STRPTR )"OBSOLETE", (STRPTR )"O",
                                  (ULONG )(1 << 7), unmasked_flags);
#line 325
      ok___0 = (BOOL )((int )ok___0 | (int )tmp___8);
#line 328
      tmp___9 = check_attr_option(hp___0, nw, var, (STRPTR )"RECOMMENDED", (STRPTR )"RCMD",
                                  (ULONG )(1 << 6), unmasked_flags);
#line 328
      ok___0 = (BOOL )((int )ok___0 | (int )tmp___9);
      }
#line 331
      if (! ok___0) {
        {
#line 332
        hsc_message(hp___0, (HSCMSG_ID )16427, "unknown attribute flag %q", nw);
        }
      }
      {
#line 337
      nw = infgetw(inpf);
      }
    } else {
      {
#line 339
      hsc_msg_eof(hp___0, (STRPTR )"defining attribute");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  if (nw) {
    {
#line 346
    tmp___11 = strcmp((char const   *)nw, "=");
    }
#line 346
    if (! tmp___11) {
#line 348
      new_deftext = (STRPTR )((void *)0);
#line 349
      old_attrflag = (LONG )var->varflag;
#line 352
      var->varflag |= (unsigned long )(1 << 28);
#line 354
      if (! var->deftext) {
        {
#line 355
        new_deftext = eval_expression(hp___0, var, (STRPTR )((void *)0));
        }
      } else {
        {
#line 359
        hsc_message(hp___0, (HSCMSG_ID )16410, "default value for %A already set",
                    var);
#line 363
        dummy = eval_expression(hp___0, var, (STRPTR )((void *)0));
        }
      }
#line 367
      var->varflag = (ULONG )old_attrflag;
#line 370
      if (new_deftext) {
        {
#line 371
        var->deftext = ugly_strclone((CONSTRPTR )new_deftext, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c",
                                     (ULONG )371);
        }
      }
      {
#line 374
      nw = infgetw(inpf);
      }
    }
  }
#line 378
  if (! nw) {
#line 379
    if (! eof_called) {
      {
#line 380
      hsc_msg_eof(hp___0, (STRPTR )"defining attribute");
      }
    }
  } else {
    {
#line 383
    inungetcw(inpf);
#line 384
    ok = (BOOL )1;
    }
  }
#line 388
  if (! ok) {
#line 388
    if (var) {
      {
#line 389
      tmp___12 = find_attrnode(varlist, varname);
#line 389
      nd___0 = tmp___12;
      }
#line 390
      if (nd___0) {
        {
#line 391
        del_dlnode(varlist, (DLNODE *)((APTR )nd___0));
        }
      } else {
        {
#line 393
        del_hscattr((APTR )var);
        }
      }
#line 394
      var = (HSCATTR *)((void *)0);
    }
  }
  {
#line 396
  ugly_freestr(varname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c",
               (ULONG )396);
#line 396
  varname = (STRPTR )((void *)0);
  }
#line 398
  return (var);
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
HSCATTR *define_attr_by_hp(HSCPRC *hp___0 , STRPTR default_value , ULONG unmasked_flags ) 
{ 
  HSCATTR *attr ;
  HSCATTR *tmp ;
  LONG tmp___0 ;
  STRPTR tmp___1 ;

  {
  {
#line 411
  tmp = define_var(hp___0, hp___0->defattr, (ULONG )0);
#line 411
  attr = tmp;
  }
#line 412
  if (attr) {
#line 415
    if (attr->varflag & (unsigned long )(1 << 29)) {
#line 415
      attr->macro_id = (ULONG )0;
    } else {
      {
#line 415
      tmp___0 = get_current_mci(hp___0);
#line 415
      attr->macro_id = (ULONG )tmp___0;
      }
    }
    {
#line 419
    attr->varflag |= (unsigned long )(1 << 30);
#line 422
    tmp___1 = get_vardeftext(attr);
    }
#line 422
    if (tmp___1) {
#line 423
      if (default_value) {
        {
#line 424
        display_panic_message((char *)"default value already set", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c",
                              (size_t )424);
        }
      } else {
        {
#line 426
        clr_vartext(attr);
        }
      }
    }
#line 430
    if (default_value) {
      {
#line 431
      set_vartext(attr, default_value);
      }
    }
    {
#line 434
    clr_attrdef(attr);
    }
  }
#line 436
  return (attr);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
HSCATTR *define_attr_by_text(HSCPRC *hp___0 , STRPTR attr_text , STRPTR default_value ,
                             ULONG unmasked_flags ) 
{ 
  EXPSTR *define_text ;
  EXPSTR *tmp ;
  INFILE *old_inpf ;
  HSCATTR *attr ;

  {
  {
#line 472
  tmp = ugly_init_estr((size_t )0);
#line 472
  define_text = tmp;
#line 473
  old_inpf = hp___0->inpf;
#line 474
  attr = (HSCATTR *)((void *)0);
#line 477
  ugly_set_estr(define_text, (CONSTRPTR )attr_text);
#line 478
  ugly_app_estr(define_text, ">");
#line 480
  hp___0->inpf = infopen_str("::p::define_attr_by_text", (CONSTRPTR )define_text->es_data,
                             (size_t )0);
  }
#line 484
  if (hp___0->inpf) {
    {
#line 486
    attr = define_attr_by_hp(hp___0, default_value, unmasked_flags);
    }
#line 487
    if (hp___0->inpf) {
      {
#line 487
      infclose1(hp___0->inpf);
#line 487
      hp___0->inpf = (INFILE *)((void *)0);
      }
    }
  }
  {
#line 491
  hp___0->inpf = old_inpf;
#line 492
  del_estr(define_text);
  }
#line 494
  return (attr);
}
}
#line 511 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
static HSCATTR *copy_local_var(DLLIST *destlist , HSCATTR *locvar , ULONG mci ) 
{ 
  HSCATTR *var ;
  HSCATTR *tmp ;

  {
  {
#line 513
  tmp = app_var(destlist, locvar->name);
#line 513
  var = tmp;
#line 515
  var->macro_id = mci;
#line 516
  var->vartype = locvar->vartype;
#line 517
  var->varflag = locvar->varflag & (unsigned long )(~ (1 << 30));
#line 518
  set_vartext(var, locvar->text);
#line 519
  var->quote = locvar->quote;
  }
#line 521
  return (var);
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
BOOL copy_local_varlist(DLLIST *destlist , DLLIST *varlist , ULONG mci ) 
{ 
  BOOL ok ;
  DLNODE *nd ;
  HSCATTR *var ;

  {
#line 536
  ok = (BOOL )1;
#line 538
  if (4294967295UL != mci) {
#line 539
    nd = varlist->first;
    {
#line 542
    while (1) {
      while_continue: /* CIL Label */ ;
#line 542
      if (nd) {
#line 542
        if (! ok) {
#line 542
          goto while_break;
        }
      } else {
#line 542
        goto while_break;
      }
      {
#line 543
      var = copy_local_var(destlist, (HSCATTR *)nd->data, mci);
#line 544
      ok = (BOOL )((int )ok & (int )((BOOL )((unsigned long )var != (unsigned long )((void *)0))));
#line 545
      nd = nd->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 547
    display_panic_message((char *)"mci=MCI_ERROR", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c",
                          (size_t )547);
    }
  }
#line 549
  return (ok);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
static HSCATTR *set_local_var(DLLIST *destlist , HSCATTR *locvar , ULONG mci ) 
{ 
  HSCATTR *var ;
  HSCATTR *tmp ;

  {
  {
#line 561
  tmp = find_varname(destlist, locvar->name);
#line 561
  var = tmp;
  }
#line 563
  if (var) {
    {
#line 564
    var->macro_id = mci;
#line 565
    var->vartype = locvar->vartype;
#line 566
    set_vartext(var, locvar->text);
    }
  } else {
    {
#line 568
    display_panic_message((char *)"set_local_var to UNKNOWN ATTR", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c",
                          (size_t )568);
    }
  }
#line 570
  return (var);
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
BOOL set_local_varlist(DLLIST *destlist , DLLIST *varlist , ULONG mci ) 
{ 
  BOOL ok ;
  DLNODE *nd ;
  HSCATTR *var ;

  {
#line 582
  ok = (BOOL )1;
#line 584
  if (4294967295UL != mci) {
#line 585
    nd = varlist->first;
    {
#line 588
    while (1) {
      while_continue: /* CIL Label */ ;
#line 588
      if (nd) {
#line 588
        if (! ok) {
#line 588
          goto while_break;
        }
      } else {
#line 588
        goto while_break;
      }
      {
#line 589
      var = set_local_var(destlist, (HSCATTR *)nd->data, mci);
#line 590
      ok = (BOOL )((int )ok & (int )((BOOL )((unsigned long )var != (unsigned long )((void *)0))));
#line 591
      nd = nd->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 593
    display_panic_message((char *)"mci=MCI_ERROR", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c",
                          (size_t )593);
    }
  }
#line 595
  return (ok);
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
VOID remove_local_varlist(DLLIST *varlist , ULONG mci ) 
{ 
  DLNODE *nd ;
  HSCATTR *var ;
  DLNODE *nd_nxt ;

  {
#line 603
  nd = varlist->first;
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! nd) {
#line 605
      goto while_break;
    }
#line 606
    var = (HSCATTR *)nd->data;
#line 607
    nd_nxt = nd->next;
#line 609
    if (var->macro_id == mci) {
      {
#line 610
      del_dlnode(varlist, nd);
      }
    }
#line 612
    nd = nd_nxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 614
  return;
}
}
#line 620 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c"
void move_local_varlist(DLLIST *destlist , DLLIST *varlist , ULONG mci ) 
{ 
  DLNODE *nd ;

  {
#line 622
  if (4294967295UL != mci) {
#line 623
    nd = varlist->first;
    {
#line 625
    while (1) {
      while_continue: /* CIL Label */ ;
#line 625
      if (! ((unsigned long )((void *)0) != (unsigned long )nd)) {
#line 625
        goto while_break;
      }
#line 626
      if (((HSCATTR *)nd->data)->macro_id == mci) {
        {
#line 627
        move_dlnode(destlist, varlist, nd);
        }
      }
#line 629
      nd = nd->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 631
    display_panic_message((char *)"mci=MCI_ERROR", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/defattr.c",
                          (size_t )631);
    }
  }
#line 632
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 33 "./hsclib/tcpip.h"
BOOL check_ext_uri(HSCPRC *hp___0 , char *uri ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tcpip.c"
static BOOL get_http_hdr(HSCPRC *hp___0 , CONSTRPTR fulluri , CONSTRPTR host , CONSTRPTR proxy ,
                         CONSTRPTR res , unsigned short port ) 
{ 
  EXPSTR *message___0 ;
  EXPSTR *request ;
  BOOL reading ;
  BOOL ret ;
  int sock ;
  int nread ;
  int n ;
  struct sockaddr_in saddr ;
  struct hostent *he ;
  char *rcvbuf ;
  char *cr ;
  void *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  CONSTRPTR tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;

  {
#line 93
  ret = (BOOL )0;
#line 97
  cr = (char *)((void *)0);
#line 111
  if (0 == (int )*res) {
#line 111
    res = "/";
  }
  {
#line 114
  tmp = calloc((size_t )256, (size_t )1);
#line 114
  rcvbuf = (char *)tmp;
#line 117
  sock = socket(2, 1, 0);
  }
#line 117
  if (-1 != sock) {
    {
#line 119
    request = ugly_init_estr((size_t )64);
#line 120
    ugly_set_estr(request, "HEAD ");
#line 121
    ugly_app_estr(request, res);
#line 122
    ugly_app_estr(request, " HTTP/1.0");
#line 123
    ugly_app_estr(request, "\r\n");
    }
#line 126
    if ((unsigned long )((void *)0) == (unsigned long )proxy) {
      {
#line 127
      ugly_app_estr(request, "Host: ");
#line 128
      ugly_app_estr(request, host);
#line 129
      ugly_app_estr(request, "\r\n");
      }
    }
    {
#line 131
    ugly_app_estr(request, "\r\n");
    }
#line 134
    if ((unsigned long )proxy != (unsigned long )((void *)0)) {
#line 134
      tmp___7 = proxy;
    } else {
#line 134
      tmp___7 = host;
    }
    {
#line 134
    he = gethostbyname(tmp___7);
    }
#line 134
    if ((unsigned long )((void *)0) != (unsigned long )he) {
      {
#line 135
      saddr.sin_family = (sa_family_t )2;
#line 136
      saddr.sin_port = htons(port);
#line 137
      saddr.sin_addr.s_addr = (in_addr_t )*((unsigned long *)*(he->h_addr_list + 0));
#line 140
      tmp___6 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& saddr)),
                        (socklen_t )sizeof(saddr));
      }
#line 140
      if (-1 != tmp___6) {
        {
#line 144
        tmp___0 = strlen((char const   *)request->es_data);
#line 144
        write(sock, (void const   *)request->es_data, tmp___0);
#line 145
        shutdown(sock, 1);
#line 148
        nread = 0;
#line 148
        reading = (BOOL )1;
        }
        {
#line 148
        while (1) {
          while_continue: /* CIL Label */ ;
#line 148
          if (reading) {
#line 148
            if (! (12 - nread)) {
#line 148
              goto while_break;
            }
          } else {
#line 148
            goto while_break;
          }
          {
#line 149
          tmp___1 = read(sock, (void *)rcvbuf, (size_t )(12 - nread));
#line 149
          n = (int )tmp___1;
          }
          {
#line 150
          if (n == -1) {
#line 150
            goto case_neg_1;
          }
#line 156
          if (n == 0) {
#line 156
            goto case_0;
          }
#line 162
          goto switch_default;
          case_neg_1: /* CIL Label */ 
          {
#line 151
          tmp___2 = __errno_location();
#line 151
          tmp___3 = strerror(*tmp___2);
#line 151
          hsc_message(hp___0, (HSCMSG_ID )12382, "dubious external URI \"%s\": error reading from server: %s",
                      fulluri, tmp___3);
#line 154
          reading = (BOOL )0;
          }
#line 155
          goto switch_break;
          case_0: /* CIL Label */ 
          {
#line 157
          hsc_message(hp___0, (HSCMSG_ID )12382, "dubious external URI \"%s\": short read from server",
                      fulluri);
#line 160
          reading = (BOOL )0;
          }
#line 161
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 163
          nread += n;
#line 164
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 167
        if (12 == nread) {
          {
#line 169
          tmp___5 = strncmp((char const   *)rcvbuf, "HTTP/", (size_t )5);
          }
#line 169
          if (0 == tmp___5) {
            {
#line 171
            if ((int )*(rcvbuf + 9) == 50) {
#line 171
              goto case_50;
            }
#line 175
            if ((int )*(rcvbuf + 9) == 53) {
#line 175
              goto case_53;
            }
#line 175
            if ((int )*(rcvbuf + 9) == 52) {
#line 175
              goto case_53;
            }
#line 179
            if ((int )*(rcvbuf + 9) == 51) {
#line 179
              goto case_51;
            }
#line 186
            goto switch_default___0;
            case_50: /* CIL Label */ 
#line 172
            ret = (BOOL )1;
#line 173
            goto switch_break___0;
            case_53: /* CIL Label */ 
            case_52: /* CIL Label */ 
            {
#line 176
            hsc_message(hp___0, (HSCMSG_ID )12381, "external URI \"%s\" does not exist (error code %s)",
                        fulluri, rcvbuf + 9);
            }
#line 178
            goto switch_break___0;
            case_51: /* CIL Label */ 
#line 181
            if (48 == (int )*(rcvbuf + 10)) {
#line 181
              if (50 == (int )*(rcvbuf + 11)) {
#line 182
                ret = (BOOL )1;
#line 183
                goto switch_break___0;
              }
            }
            switch_default___0: /* CIL Label */ 
            {
#line 187
            message___0 = ugly_init_estr((size_t )32);
#line 188
            ugly_set_estr(message___0, (CONSTRPTR )(rcvbuf + 9));
            }
            {
#line 190
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 190
              tmp___4 = read(sock, (void *)rcvbuf, (size_t )255);
#line 190
              nread = (int )tmp___4;
              }
#line 190
              if (! (nread > 0)) {
#line 190
                goto while_break___0;
              }
#line 191
              if (-1 == nread) {
#line 191
                goto while_break___0;
              }
#line 192
              if ((unsigned long )((void *)0) == (unsigned long )cr) {
                {
#line 193
                cr = strchr((char const   *)rcvbuf, '\r');
                }
#line 194
                if ((unsigned long )((void *)0) != (unsigned long )cr) {
#line 195
                  *cr = (char )'\000';
                }
                {
#line 196
                ugly_app_estr(message___0, (CONSTRPTR )rcvbuf);
                }
              }
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 199
            hsc_message(hp___0, (HSCMSG_ID )12382, "dubious external URI \"%s\": server said \"%s\"",
                        fulluri, message___0->es_data);
#line 201
            del_estr(message___0);
#line 202
            ret = (BOOL )1;
            }
#line 203
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          } else {
#line 208
            ret = (BOOL )1;
          }
        }
      } else
#line 212
      if ((unsigned long )((void *)0) == (unsigned long )proxy) {
        {
#line 213
        hsc_message(hp___0, (HSCMSG_ID )12381, "external URI \"%s\" does not exist (no connection to server)",
                    fulluri);
        }
      } else {
        {
#line 216
        hsc_message(hp___0, (HSCMSG_ID )12382, "dubious external URI \"%s\": proxy \"%s\" is down",
                    fulluri, proxy);
        }
      }
    } else
#line 220
    if ((unsigned long )((void *)0) == (unsigned long )proxy) {
      {
#line 221
      hsc_message(hp___0, (HSCMSG_ID )12381, "external URI \"%s\" does not exist: host address not found",
                  fulluri, proxy);
      }
    } else {
      {
#line 224
      hsc_message(hp___0, (HSCMSG_ID )12382, "dubious external URI \"%s\": no address for proxy \"%s\"",
                  fulluri, proxy);
      }
    }
    {
#line 228
    del_estr(request);
#line 229
    close(sock);
    }
  } else {
    {
#line 230
    tmp___8 = __errno_location();
#line 230
    tmp___9 = strerror(*tmp___8);
#line 230
    hsc_message(hp___0, (HSCMSG_ID )16479, "socket() failed: %s)", tmp___9);
    }
  }
#line 231
  if (rcvbuf) {
    {
#line 231
    free((void *)rcvbuf);
#line 231
    rcvbuf = (char *)((void *)0);
    }
  }
#line 235
  return (ret);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tcpip.c"
static BOOL parse_proxy_addr(CONSTRPTR proxy , EXPSTR *host , unsigned short *port ) 
{ 
  BOOL done ;
  CONSTRPTR p ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 248
  if ((unsigned long )((void *)0) == (unsigned long )proxy) {
#line 249
    return ((BOOL )0);
  } else {
    {
#line 248
    tmp = strncmp(proxy, "http://", (size_t )7);
    }
#line 248
    if (0 != tmp) {
#line 249
      return ((BOOL )0);
    }
  }
#line 250
  *port = (unsigned short)3128;
#line 251
  p = proxy + 7;
#line 251
  done = (BOOL )0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (! done)) {
#line 251
      goto while_break;
    }
    {
#line 254
    if ((int const   )*p == 47) {
#line 254
      goto case_47;
    }
#line 254
    if ((int const   )*p == 0) {
#line 254
      goto case_47;
    }
#line 257
    if ((int const   )*p == 58) {
#line 257
      goto case_58;
    }
#line 261
    goto switch_default;
    case_47: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 255
    done = (BOOL )1;
#line 256
    goto switch_break;
    case_58: /* CIL Label */ 
    {
#line 258
    p ++;
#line 258
    tmp___0 = atoi(p);
#line 258
    *port = (unsigned short )tmp___0;
    }
    {
#line 259
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 259
      tmp___1 = __ctype_b_loc();
      }
#line 259
      if (! ((int const   )*(*tmp___1 + (int )*p) & 2048)) {
#line 259
        goto while_break___0;
      }
#line 259
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 262
    ugly_app_estrch(host, (int )*p);
    }
#line 263
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 251
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  return ((BOOL )1);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tcpip.c"
static BOOL check_http_uri(HSCPRC *hp___0 , CONSTRPTR uri , CONSTRPTR proxyvar ) 
{ 
  EXPSTR *host ;
  EXPSTR *tmp ;
  EXPSTR *proxy ;
  EXPSTR *tmp___0 ;
  EXPSTR *res ;
  EXPSTR *tmp___1 ;
  unsigned short port ;
  BOOL ret ;
  BOOL done ;
  BOOL use_proxy ;
  CONSTRPTR p ;
  CONSTRPTR fulluri ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  BOOL tmp___4 ;
  STRPTR tmp___5 ;

  {
  {
#line 270
  tmp = ugly_init_estr((size_t )32);
#line 270
  host = tmp;
#line 271
  tmp___0 = ugly_init_estr((size_t )32);
#line 271
  proxy = tmp___0;
#line 272
  tmp___1 = ugly_init_estr((size_t )32);
#line 272
  res = tmp___1;
#line 273
  port = (unsigned short)80;
#line 274
  use_proxy = (BOOL )1;
#line 275
  fulluri = uri;
#line 277
  tmp___4 = parse_proxy_addr(proxyvar, proxy, & port);
  }
#line 277
  if (! tmp___4) {
#line 278
    use_proxy = (BOOL )0;
#line 280
    p = uri + 7;
#line 280
    done = (BOOL )0;
    {
#line 280
    while (1) {
      while_continue: /* CIL Label */ ;
#line 280
      if (! (! done)) {
#line 280
        goto while_break;
      }
      {
#line 282
      if ((int const   )*p == 0) {
#line 282
        goto case_0;
      }
#line 285
      if ((int const   )*p == 47) {
#line 285
        goto case_47;
      }
#line 289
      if ((int const   )*p == 58) {
#line 289
        goto case_58;
      }
#line 293
      goto switch_default;
      case_0: /* CIL Label */ 
#line 283
      done = (BOOL )1;
#line 284
      goto switch_break;
      case_47: /* CIL Label */ 
      {
#line 286
      ugly_set_estr(res, p);
#line 287
      done = (BOOL )1;
      }
#line 288
      goto switch_break;
      case_58: /* CIL Label */ 
      {
#line 290
      p ++;
#line 290
      tmp___2 = atoi(p);
#line 290
      port = (unsigned short )tmp___2;
      }
      {
#line 291
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 291
        tmp___3 = __ctype_b_loc();
        }
#line 291
        if (! ((int const   )*(*tmp___3 + (int )*p) & 2048)) {
#line 291
          goto while_break___0;
        }
#line 291
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 292
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 294
      ugly_app_estrch(host, (int )*p);
      }
#line 295
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 280
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 300
    uri = (CONSTRPTR )res->es_data;
  }
#line 302
  if (use_proxy) {
#line 302
    tmp___5 = proxy->es_data;
  } else {
#line 302
    tmp___5 = (STRPTR )((void *)0);
  }
  {
#line 302
  ret = get_http_hdr(hp___0, fulluri, (CONSTRPTR )host->es_data, (CONSTRPTR )tmp___5,
                     uri, port);
#line 305
  del_estr(host);
#line 306
  del_estr(proxy);
#line 307
  del_estr(res);
  }
#line 308
  return (ret);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tcpip.c"
static BOOL check_proxyonly_uri(HSCPRC *hp___0 , CONSTRPTR uri , CONSTRPTR proxy ) 
{ 
  EXPSTR *host ;
  EXPSTR *tmp ;
  unsigned short port ;
  BOOL ret ;
  BOOL tmp___0 ;

  {
  {
#line 312
  tmp = ugly_init_estr((size_t )32);
#line 312
  host = tmp;
#line 313
  port = (unsigned short)80;
#line 316
  tmp___0 = parse_proxy_addr(proxy, host, & port);
  }
#line 316
  if (tmp___0) {
    {
#line 320
    ret = get_http_hdr(hp___0, uri, uri, (CONSTRPTR )host->es_data, uri, port);
    }
  } else {
#line 318
    ret = (BOOL )1;
  }
  {
#line 323
  del_estr(host);
  }
#line 324
  return (ret);
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tcpip.c"
BOOL check_ext_uri(HSCPRC *hp___0 , char *uri ) 
{ 
  unsigned short const   **tmp ;
  char *tmp___0 ;
  BOOL tmp___1 ;
  char *tmp___2 ;
  BOOL tmp___3 ;
  char *tmp___4 ;
  BOOL tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 328
    tmp = __ctype_b_loc();
    }
#line 328
    if (! ((int const   )*(*tmp + (int )*uri) & 8192)) {
#line 328
      goto while_break;
    }
#line 328
    uri ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 329
  tmp___8 = strncmp((char const   *)uri, "http://", (size_t )7);
  }
#line 329
  if (0 == tmp___8) {
    {
#line 330
    tmp___0 = getenv("http_proxy");
#line 330
    tmp___1 = check_http_uri(hp___0, (CONSTRPTR )uri, (CONSTRPTR )tmp___0);
    }
#line 330
    return (tmp___1);
  } else {
    {
#line 331
    tmp___7 = strncmp((char const   *)uri, "ftp://", (size_t )6);
    }
#line 331
    if (0 == tmp___7) {
      {
#line 332
      tmp___2 = getenv("ftp_proxy");
#line 332
      tmp___3 = check_proxyonly_uri(hp___0, (CONSTRPTR )uri, (CONSTRPTR )tmp___2);
      }
#line 332
      return (tmp___3);
    } else {
      {
#line 333
      tmp___6 = strncmp((char const   *)uri, "gopher://", (size_t )9);
      }
#line 333
      if (0 == tmp___6) {
        {
#line 334
        tmp___4 = getenv("gopher_proxy");
#line 334
        tmp___5 = check_proxyonly_uri(hp___0, (CONSTRPTR )uri, (CONSTRPTR )tmp___4);
        }
#line 334
        return (tmp___5);
      }
    }
  }
#line 337
  return ((BOOL )1);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
EXPSTR *inpfilename  =    (EXPSTR *)((void *)0);
#line 41 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
EXPSTR *outfilename  =    (EXPSTR *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
STRPTR msgfilename  =    (STRPTR )((void *)0);
#line 44 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
STRPTR prjfilename  =    (STRPTR )((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
STRPTR prefsfilename  =    (STRPTR )((void *)0);
#line 47 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
DLLIST *define_list  =    (DLLIST *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
DLLIST *incfile  =    (DLLIST *)((void *)0);
#line 50 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
int return_code  =    2;
#line 52 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
BOOL msg_ansi  =    (BOOL )0;
#line 53 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
STRPTR msg_format  =    (STRPTR )((void *)0);
#line 54 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
STRPTR msg_browser  =    (STRPTR )((void *)0);
#line 55 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
EXPSTR *msgbuf  =    (EXPSTR *)((void *)0);
#line 57 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
STRARR misc_buffer[6000]  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
BOOL init_global(void) 
{ 
  BOOL ok ;
  int tmp ;

  {
  {
#line 66
  ok = (BOOL )1;
#line 68
  return_code = 0;
#line 71
  inpfilename = ugly_init_estr((size_t )32);
#line 72
  msgbuf = ugly_init_estr((size_t )64);
  }
#line 74
  if (inpfilename) {
#line 74
    if (msgbuf) {
#line 74
      tmp = 1;
    } else {
#line 74
      tmp = 0;
    }
  } else {
#line 74
    tmp = 0;
  }
#line 74
  ok = (BOOL )tmp;
#line 76
  return (ok);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
VOID cleanup_global(void) 
{ 


  {
  {
#line 86
  del_estr(inpfilename);
#line 87
  del_estr(outfilename);
#line 88
  del_dllist(define_list);
#line 89
  del_dllist(incfile);
#line 90
  del_estr(msgbuf);
  }
#line 91
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/global.c"
STRPTR get_outfilename(void) 
{ 


  {
#line 100
  if (outfilename) {
#line 101
    return (outfilename->es_data);
  } else {
#line 103
    return ((STRPTR )"<stdout>");
  }
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/dllist.c"
static DLNODE *ins_dlnode___1(DLLIST *list , DLNODE *node , APTR data ) 
{ 
  DLNODE *newnode ;

  {
#line 170
  newnode = (DLNODE *)((void *)0);
#line 172
  if (list) {
    {
#line 173
    newnode = new_dlnode();
    }
#line 175
    if (newnode) {
#line 176
      newnode->data = data;
#line 177
      (list->entry_num) ++;
#line 179
      if (node) {
#line 180
        if ((unsigned long )list->first == (unsigned long )node) {
#line 182
          list->first = newnode;
        } else {
#line 185
          (node->prev)->next = newnode;
#line 186
          newnode->prev = node->prev;
        }
#line 188
        node->prev = newnode;
#line 189
        newnode->next = node;
      } else {
#line 191
        if (list->last) {
#line 192
          (list->last)->next = newnode;
        }
#line 193
        newnode->prev = list->last;
#line 194
        list->last = newnode;
      }
#line 197
      if ((unsigned long )list->first == (unsigned long )((void *)0)) {
#line 198
        list->first = newnode;
      }
#line 199
      if ((unsigned long )list->last == (unsigned long )((void *)0)) {
#line 200
        list->last = newnode;
      }
    }
  }
#line 203
  return (newnode);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
static char ch2str_buffer___1[2]  ;
#line 320 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/ustring.c"
static char num2str_buffer___1[10]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/entity.c"
HSCENT *new_hscent(STRPTR newid ) 
{ 
  HSCENT *newent ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 44
  tmp = ugly_malloc_notracking(sizeof(HSCENT ));
#line 44
  newent = (HSCENT *)tmp;
  }
#line 50
  if (newent) {
    {
#line 52
    newent->name = ugly_strclone((CONSTRPTR )newid, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/entity.c",
                                 (ULONG )52);
#line 53
    tmp___0 = (char )'\000';
#line 53
    newent->replace[1] = tmp___0;
#line 53
    newent->replace[0] = tmp___0;
#line 54
    newent->numeric = 0;
#line 55
    newent->flags = (char)0;
    }
  }
#line 57
  return (newent);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/entity.c"
VOID del_entity(APTR data ) 
{ 
  HSCENT *ent ;

  {
#line 64
  ent = (HSCENT *)data;
#line 70
  if ((unsigned long )((void *)0) != (unsigned long )ent->name) {
    {
#line 71
    ugly_freestr(ent->name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/entity.c",
                 (ULONG )71);
#line 71
    ent->name = (STRPTR )((void *)0);
    }
  }
#line 72
  ent->replace[0] = (char )'\000';
#line 73
  ent->numeric = 0;
#line 74
  if (ent) {
    {
#line 74
    free((void *)ent);
#line 74
    ent = (HSCENT *)((void *)0);
    }
  }
#line 75
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/entity.c"
HSCENT *cpy_hscent(HSCENT *oldent ) 
{ 
  HSCENT *newent ;
  HSCENT *tmp ;

  {
  {
#line 83
  tmp = new_hscent(oldent->name);
#line 83
  newent = tmp;
  }
#line 85
  if (newent) {
#line 86
    newent->replace[0] = oldent->replace[0];
#line 87
    newent->numeric = oldent->numeric;
  }
#line 89
  return (newent);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/entity.c"
int cmp_strent(APTR cmpstr , APTR entdata ) 
{ 
  STRPTR entstr ;
  int tmp ;

  {
#line 105
  entstr = (STRPTR )((void *)0);
#line 107
  if (entdata) {
#line 108
    entstr = ((HSCENT *)entdata)->name;
  }
#line 110
  if ((unsigned long )((void *)0) != (unsigned long )entstr) {
    {
#line 111
    tmp = strcmp((char const   *)cmpstr, (char const   *)entstr);
    }
#line 111
    if (tmp) {
#line 114
      return (0);
    } else {
#line 112
      return (-1);
    }
  }
#line 116
  return (0);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/entity.c"
int cmp_nument(APTR cmpstr , APTR entdata ) 
{ 
  LONG num ;
  LONG cmpnum ;
  int tmp ;

  {
#line 126
  num = (LONG )-1;
#line 127
  cmpnum = (LONG )cmpstr;
#line 129
  if (entdata) {
#line 130
    num = (LONG )((HSCENT *)entdata)->numeric;
  }
#line 132
  if (num != -1L) {
#line 132
    if (num == cmpnum) {
#line 132
      tmp = 1;
    } else {
#line 132
      tmp = 0;
    }
  } else {
#line 132
    tmp = 0;
  }
#line 132
  return (tmp);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/entity.c"
int cmp_rplcent(APTR cmpstr , APTR entdata ) 
{ 
  STRPTR entstr ;
  int tmp ;

  {
#line 142
  entstr = (STRPTR )((void *)0);
#line 144
  if (entdata) {
#line 145
    entstr = ((HSCENT *)entdata)->replace;
  }
#line 147
  if (entstr) {
    {
#line 148
    tmp = strcmp((char const   *)cmpstr, (char const   *)entstr);
    }
#line 148
    if (tmp) {
#line 151
      return (0);
    } else {
#line 149
      return (-1);
    }
  }
#line 153
  return (0);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/entity.c"
HSCENT *app_entnode(DLLIST *entlist , STRPTR entid ) 
{ 
  HSCENT *newent ;
  DLNODE *tmp ;

  {
  {
#line 173
  newent = new_hscent(entid);
  }
#line 174
  if ((unsigned long )((void *)0) != (unsigned long )newent) {
    {
#line 175
    tmp = app_dlnode(entlist, (APTR )newent);
    }
#line 175
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 176
      del_entity((APTR )newent);
#line 177
      newent = (HSCENT *)((void *)0);
      }
    }
  }
#line 180
  return (newent);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/entity.c"
void add_ent(DLLIST *entlist , STRPTR entid , char entreplace , short num , char flags ) 
{ 
  HSCENT *newent ;
  HSCENT *tmp ;

  {
  {
#line 187
  tmp = app_entnode(entlist, entid);
#line 187
  newent = tmp;
  }
#line 189
  if ((unsigned long )((void *)0) != (unsigned long )newent) {
#line 190
    newent->replace[0] = entreplace;
#line 191
    newent->numeric = (int )num;
#line 192
    newent->flags = flags;
  }
#line 194
  return;
}
}
#line 144 "./hsclib/attrib.h"
HSCATTR *cpy_hscattr(HSCATTR *oldvar ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c"
void del_hsctag(APTR data ) 
{ 
  HSCTAG *tag ;

  {
  {
#line 45
  tag = (HSCTAG *)data;
#line 48
  ugly_freestr(tag->name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c",
               (ULONG )48);
#line 48
  tag->name = (STRPTR )((void *)0);
#line 49
  ugly_freestr(tag->name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c",
               (ULONG )49);
#line 49
  tag->name = (STRPTR )((void *)0);
#line 50
  del_estr(tag->op_text);
#line 51
  del_estr(tag->cl_text);
#line 52
  ugly_freestr(tag->mbi, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c",
               (ULONG )52);
#line 52
  tag->mbi = (STRPTR )((void *)0);
#line 53
  ugly_freestr(tag->naw, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c",
               (ULONG )53);
#line 53
  tag->naw = (STRPTR )((void *)0);
#line 54
  del_dllist(tag->attr);
#line 55
  del_infilepos(tag->start_fpos);
#line 56
  del_infilepos(tag->end_fpos);
#line 59
  tag->option = (ULONG )0;
#line 60
  tag->op_text = (EXPSTR *)((void *)0);
#line 61
  tag->cl_text = (EXPSTR *)((void *)0);
#line 62
  tag->attr = (DLLIST *)((void *)0);
#line 63
  tag->uri_size = (HSCATTR *)((void *)0);
#line 64
  tag->uri_stripext = (HSCATTR *)((void *)0);
  }
#line 66
  if (tag) {
    {
#line 66
    free((void *)tag);
#line 66
    tag = (HSCTAG *)((void *)0);
    }
  }
#line 67
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c"
HSCTAG *new_hsctag(STRPTR newid ) 
{ 
  HSCTAG *newtag ;
  void *tmp ;
  STRPTR tmp___0 ;

  {
  {
#line 77
  tmp = ugly_malloc_notracking(sizeof(HSCTAG ));
#line 77
  newtag = (HSCTAG *)tmp;
  }
#line 79
  if (newtag) {
    {
#line 82
    tmp___0 = ugly_strclone((CONSTRPTR )newid, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c",
                            (ULONG )82);
#line 82
    newtag->name = upstr(tmp___0);
#line 83
    newtag->option = (ULONG )0;
#line 84
    newtag->o_handle = (BOOL (*)(struct hsc_process *hp , struct hsctag *tag ))((void *)0);
#line 85
    newtag->c_handle = (BOOL (*)(struct hsc_process *hp , struct hsctag *tag ))((void *)0);
#line 86
    newtag->occured = (BOOL )0;
#line 87
    newtag->op_text = (EXPSTR *)((void *)0);
#line 88
    newtag->cl_text = (EXPSTR *)((void *)0);
#line 89
    newtag->attr = init_dllist(& del_hscattr);
#line 90
    newtag->mbi = (STRPTR )((void *)0);
#line 91
    newtag->naw = (STRPTR )((void *)0);
#line 92
    newtag->uri_size = (HSCATTR *)((void *)0);
#line 93
    newtag->uri_stripext = (HSCATTR *)((void *)0);
#line 94
    newtag->start_fpos = (INFILEPOS *)((void *)0);
#line 95
    newtag->end_fpos = (INFILEPOS *)((void *)0);
    }
#line 97
    if (newtag->name) {
#line 97
      if (! newtag->attr) {
        {
#line 99
        del_hsctag((APTR )newtag);
#line 100
        newtag = (HSCTAG *)((void *)0);
        }
      }
    } else {
      {
#line 99
      del_hsctag((APTR )newtag);
#line 100
      newtag = (HSCTAG *)((void *)0);
      }
    }
  }
#line 104
  return (newtag);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c"
HSCTAG *cpy_hsctag(HSCTAG *oldtag ) 
{ 
  HSCTAG *newtag ;
  HSCTAG *tmp ;
  DLNODE *nd ;
  HSCATTR *attr ;
  HSCATTR *nattr ;
  HSCATTR *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 118
  tmp = new_hsctag(oldtag->name);
#line 118
  newtag = tmp;
  }
#line 120
  if (newtag) {
    {
#line 122
    nd = (DLNODE *)((void *)0);
#line 125
    newtag->option = oldtag->option;
#line 126
    newtag->o_handle = (BOOL (*)(struct hsc_process *hp , struct hsctag *tag ))((void *)0);
#line 127
    newtag->c_handle = (BOOL (*)(struct hsc_process *hp , struct hsctag *tag ))((void *)0);
#line 128
    newtag->occured = (BOOL )0;
#line 129
    newtag->op_text = (EXPSTR *)((void *)0);
#line 130
    newtag->cl_text = (EXPSTR *)((void *)0);
#line 131
    newtag->attr = init_dllist(& del_hscattr);
#line 132
    newtag->mbi = ugly_strclone((CONSTRPTR )oldtag->mbi, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c",
                                (ULONG )132);
#line 133
    newtag->naw = ugly_strclone((CONSTRPTR )oldtag->naw, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c",
                                (ULONG )133);
#line 134
    newtag->uri_size = (HSCATTR *)((void *)0);
#line 135
    newtag->uri_stripext = (HSCATTR *)((void *)0);
    }
#line 138
    if (oldtag->op_text) {
      {
#line 140
      newtag->op_text = ugly_init_estr((size_t )0);
#line 141
      estrcpy(newtag->op_text, oldtag->op_text);
      }
    }
#line 143
    if (oldtag->cl_text) {
      {
#line 145
      newtag->cl_text = ugly_init_estr((size_t )0);
#line 146
      estrcpy(newtag->cl_text, oldtag->cl_text);
      }
    }
#line 150
    nd = (oldtag->attr)->first;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! nd) {
#line 151
        goto while_break;
      }
      {
#line 153
      attr = (HSCATTR *)nd->data;
#line 156
      tmp___0 = cpy_hscattr(attr);
#line 156
      nattr = tmp___0;
#line 159
      app_dlnode(newtag->attr, (APTR )nattr);
#line 162
      tmp___1 = upstrcmp((CONSTRPTR )nattr->name, (CONSTRPTR )(oldtag->uri_size)->name);
      }
#line 162
      if (! tmp___1) {
#line 163
        newtag->uri_size = nattr;
      }
      {
#line 164
      tmp___2 = upstrcmp((CONSTRPTR )nattr->name, (CONSTRPTR )(oldtag->uri_stripext)->name);
      }
#line 164
      if (! tmp___2) {
#line 165
        newtag->uri_size = nattr;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 169
  return (newtag);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c"
int cmp_strtag(APTR cmpstr , APTR tagdata ) 
{ 
  STRPTR tagstr ;
  int tmp ;

  {
#line 186
  tagstr = (STRPTR )((void *)0);
#line 188
  if (tagdata) {
#line 189
    tagstr = ((HSCTAG *)tagdata)->name;
  }
#line 191
  if (tagstr) {
    {
#line 192
    tmp = upstrcmp((CONSTRPTR )cmpstr, (CONSTRPTR )tagstr);
    }
#line 192
    if (tmp) {
#line 195
      return (0);
    } else {
#line 193
      return (-1);
    }
  } else {
#line 196
    return (0);
  }
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c"
HSCTAG *find_strtag(DLLIST *taglist , STRPTR name ) 
{ 
  DLNODE *nd ;
  DLNODE *tmp ;
  HSCTAG *tag ;

  {
  {
#line 204
  tmp = find_dlnode(taglist->first, (APTR )name, & cmp_strtag);
#line 204
  nd = tmp;
#line 205
  tag = (HSCTAG *)((void *)0);
  }
#line 207
  if (nd) {
#line 208
    tag = (HSCTAG *)nd->data;
  }
#line 210
  return (tag);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c"
HSCTAG *app_tag(DLLIST *taglist , STRPTR tagid ) 
{ 
  HSCTAG *newtag ;
  DLNODE *tmp ;

  {
  {
#line 231
  newtag = new_hsctag(tagid);
#line 232
  tmp = app_dlnode(taglist, (APTR )newtag);
  }
#line 232
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 234
    del_hsctag((APTR )newtag);
#line 235
    newtag = (HSCTAG *)((void *)0);
    }
  }
#line 238
  return (newtag);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c"
BOOL is_hsc_tag(HSCTAG *tag ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 244
  tmp = strlen("$");
#line 244
  tmp___0 = upstrncmp((CONSTRPTR )tag->name, "$", tmp);
  }
#line 244
  if (tmp___0) {
    {
#line 244
    tmp___1 = upstrcmp((CONSTRPTR )tag->name, "*");
    }
#line 244
    if (tmp___1) {
      {
#line 244
      tmp___2 = upstrcmp((CONSTRPTR )tag->name, "|");
      }
#line 244
      if (tmp___2) {
        {
#line 244
        tmp___3 = upstrcmp((CONSTRPTR )tag->name, "(");
        }
#line 244
        if (tmp___3) {
#line 244
          tmp___4 = 0;
        } else {
#line 244
          tmp___4 = 1;
        }
      } else {
#line 244
        tmp___4 = 1;
      }
    } else {
#line 244
      tmp___4 = 1;
    }
  } else {
#line 244
    tmp___4 = 1;
  }
#line 244
  return ((BOOL )tmp___4);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag.c"
BOOL is_macro_tag(HSCTAG *tag ) 
{ 


  {
#line 253
  return ((BOOL )((tag->option & (unsigned long )(1 << 10)) > 0UL));
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 156 "./hsclib/attrib.h"
BOOL clr_varlist(DLLIST *varlist ) ;
#line 442 "./hsclib/hscprc.h"
BOOL hsc_output_text(HSCPRC *hp___0 , STRPTR wspc , STRPTR text ) ;
#line 37 "./hsclib/lmessage.h"
VOID hsc_msg_illg_whtspc(HSCPRC *hp___0 ) ;
#line 38
VOID hsc_msg_stripped_tag(HSCPRC *hp___0 , HSCTAG *tag , STRPTR why ) ;
#line 29 "./hsclib/deftag.h"
ULONG set_tag_args(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 49 "./hsclib/idref.h"
BOOL check_all_local_idref(HSCPRC *hp___0 ) ;
#line 48 "./hsclib/include.h"
BOOL hsc_include_string(HSCPRC *hp___0 , STRPTR filename , STRPTR s___2 , ULONG optn ) ;
#line 36 "./hsclib/input.h"
BOOL hsc_whtspc(int ch ) ;
#line 40
STRPTR infget_tagid(HSCPRC *hp___0 ) ;
#line 45
BOOL parse_gt(HSCPRC *hp___0 ) ;
#line 37 "./hsclib/posteval.h"
BOOL postprocess_tagattr(HSCPRC *hp___0 , HSCTAG *tag , BOOL open_tag ) ;
#line 61 "./hsclib/skip.h"
BOOL skip_next_lf(HSCPRC *hp___0 ) ;
#line 65
BOOL skip_until_eot(HSCPRC *hp___0 , EXPSTR *logstr ) ;
#line 30 "./hsclib/size.h"
BOOL get_attr_size(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
static VOID message_rplc(HSCPRC *hp___0 , STRPTR what , STRPTR by ) 
{ 


  {
  {
#line 60
  hsc_message(hp___0, (HSCMSG_ID )46, "replaced %q by %q", what, by);
  }
#line 62
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
static BOOL check_mbinaw(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL ok ;
  BOOL xhtml_strictmbi ;
  BOOL tmp ;
  int tmp___0 ;
  DLNODE *nd ;
  LONG found ;
  HSCTAG *ctag ;
  BOOL tmp___1 ;
  DLNODE *nd___0 ;
  LONG found___0 ;
  HSCTAG *ctag___0 ;

  {
#line 70
  ok = (BOOL )1;
#line 71
  if (hp___0->xhtml) {
#line 71
    if (tag->option & (unsigned long )(1 << 10)) {
#line 71
      tmp___0 = 0;
    } else {
      {
#line 71
      tmp = is_hsc_tag(tag);
      }
#line 71
      if (tmp) {
#line 71
        tmp___0 = 0;
      } else {
#line 71
        tmp___0 = 1;
      }
    }
  } else {
#line 71
    tmp___0 = 0;
  }
#line 71
  xhtml_strictmbi = (BOOL )tmp___0;
#line 74
  if (tag->mbi) {
#line 75
    nd = (hp___0->container_stack)->last;
#line 76
    found = (LONG )0;
    {
#line 79
    while (1) {
      while_continue: /* CIL Label */ ;
#line 79
      if (nd) {
#line 79
        if (! (! found)) {
#line 79
          goto while_break;
        }
      } else {
#line 79
        goto while_break;
      }
      {
#line 80
      ctag = (HSCTAG *)nd->data;
#line 82
      nd = nd->prev;
#line 83
      found = strenum((CONSTRPTR )ctag->name, (CONSTRPTR )tag->mbi, (char )'|', (BYTE )1);
      }
#line 85
      if (xhtml_strictmbi) {
#line 85
        if (ctag->option & (unsigned long )((1 << 4) | (1 << 10))) {
#line 87
          goto while_continue;
        }
      }
#line 90
      if (xhtml_strictmbi) {
        {
#line 90
        tmp___1 = is_hsc_tag(ctag);
        }
#line 90
        if (! tmp___1) {
#line 90
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 94
    if (! found) {
      {
#line 95
      hsc_message(hp___0, (HSCMSG_ID )16444, "%T must be inside %t", tag, tag->mbi);
#line 97
      ok = (BOOL )0;
      }
    }
  }
#line 102
  if (tag->naw) {
#line 103
    nd___0 = (hp___0->container_stack)->last;
#line 104
    found___0 = (LONG )0;
    {
#line 106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 106
      if (! nd___0) {
#line 106
        goto while_break___0;
      }
      {
#line 107
      ctag___0 = (HSCTAG *)nd___0->data;
#line 109
      found___0 = strenum((CONSTRPTR )ctag___0->name, (CONSTRPTR )tag->naw, (char )'|',
                          (BYTE )1);
      }
#line 110
      if (found___0) {
        {
#line 111
        hsc_message(hp___0, (HSCMSG_ID )16445, "%T not allowed within %T", tag, ctag___0);
#line 114
        ok = (BOOL )0;
        }
      }
#line 116
      nd___0 = nd___0->prev;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 119
  return (ok);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
static BOOL check_autoclose_anyway(HSCPRC *hp___0 , DLNODE *nd ) 
{ 
  DLNODE *cnd ;
  DLNODE *tnd ;
  BOOL anyway ;

  {
#line 129
  anyway = (BOOL )1;
#line 131
  cnd = (hp___0->container_stack)->last;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if ((unsigned long )cnd != (unsigned long )nd) {
#line 131
      if (! anyway) {
#line 131
        goto while_break;
      }
    } else {
#line 131
      goto while_break;
    }
#line 134
    anyway = (BOOL )(((HSCTAG *)cnd->data)->option & (unsigned long )(1 << 7));
#line 131
    cnd = cnd->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (anyway) {
#line 145
    cnd = (hp___0->container_stack)->last;
    {
#line 145
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 145
      if (! ((unsigned long )cnd != (unsigned long )nd)) {
#line 145
        goto while_break___0;
      }
      {
#line 151
      tnd = cnd->prev;
#line 152
      del_dlnode(hp___0->container_stack, cnd);
#line 145
      cnd = tnd;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 154
    return ((BOOL )1);
  }
#line 156
  return ((BOOL )0);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
void hp_enable_output(HSCPRC *hp___0 , STRPTR cause ) 
{ 


  {
#line 162
  if (hp___0->suppress_output) {
    {
#line 164
    ugly_clr_estr(hp___0->whtspc);
    }
  }
#line 167
  hp___0->suppress_output = (BOOL )0;
#line 168
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
DLNODE *find_end_tag_node(HSCPRC *hp___0 , STRPTR tagname ) 
{ 
  DLNODE *tmp ;

  {
  {
#line 184
  tmp = find_dlnode_bw((hp___0->container_stack)->last, (APTR )tagname, & cmp_strtag);
  }
#line 184
  return (tmp);
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
HSCTAG *find_end_tag(HSCPRC *hp___0 , STRPTR tagname ) 
{ 
  DLNODE *nd ;
  DLNODE *tmp ;
  APTR tmp___0 ;

  {
  {
#line 195
  tmp = find_dlnode_bw((hp___0->container_stack)->last, (APTR )tagname, & cmp_strtag);
#line 195
  nd = tmp;
  }
#line 198
  if ((unsigned long )((void *)0) != (unsigned long )nd) {
#line 198
    tmp___0 = nd->data;
  } else {
#line 198
    tmp___0 = (void *)0;
  }
#line 198
  return ((HSCTAG *)tmp___0);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
HSCTAG *find_end_container_macro(HSCPRC *hp___0 ) 
{ 
  HSCTAG *tag ;
  DLNODE *nd ;
  HSCTAG *nd_tag ;

  {
#line 208
  tag = (HSCTAG *)((void *)0);
#line 209
  nd = (hp___0->container_stack)->last;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! nd) {
#line 211
      goto while_break;
    }
#line 212
    nd_tag = (HSCTAG *)nd->data;
#line 214
    if (nd_tag->option & (unsigned long )(1 << 16)) {
#line 215
      tag = nd_tag;
#line 216
      nd = (DLNODE *)((void *)0);
    } else {
#line 218
      nd = nd->prev;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return (tag);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
HSCTAG *append_end_tag(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  HSCTAG *end_tag ;
  DLLIST *taglist ;
  BOOL ok ;
  DLNODE *nd ;

  {
  {
#line 237
  taglist = hp___0->container_stack;
#line 239
  end_tag = new_hsctag(tag->name);
  }
#line 240
  if (end_tag) {
#line 241
    ok = (BOOL )1;
#line 242
    nd = (DLNODE *)((void *)0);
#line 245
    end_tag->option = tag->option;
#line 250
    if (tag->option & (unsigned long )(1 << 10)) {
#line 250
      if (tag->option & (unsigned long )(1 << 1)) {
        {
#line 251
        ok = copy_local_varlist(end_tag->attr, tag->attr, (ULONG )4294967294U);
        }
      }
    }
    {
#line 255
    end_tag->start_fpos = new_infilepos(hp___0->inpf);
    }
#line 258
    if (ok) {
      {
#line 259
      nd = app_dlnode(taglist, (APTR )end_tag);
      }
#line 260
      if (! nd) {
        {
#line 261
        del_hsctag((APTR )end_tag);
#line 262
        end_tag = (HSCTAG *)((void *)0);
        }
      }
    }
  }
#line 266
  return (end_tag);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
VOID remove_end_tag(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  DLNODE *nd ;
  DLNODE *tmp ;
  HSCTAG *end_tag ;
  HSCTAG *last_tag ;
  STRPTR foundnm ;
  STRPTR lastnm ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  int tmp___2 ;
  BOOL tmp___3 ;

  {
  {
#line 280
  tmp = find_dlnode_bw((hp___0->container_stack)->last, (APTR )tag->name, & cmp_strtag);
#line 280
  nd = tmp;
  }
#line 283
  if ((unsigned long )nd == (unsigned long )((void *)0)) {
    {
#line 286
    hsc_message(hp___0, (HSCMSG_ID )16397, "unmatched %C", tag);
    }
  } else {
    {
#line 293
    tmp___0 = is_hsc_tag(tag);
    }
#line 293
    if (! tmp___0) {
      {
#line 294
      check_autoclose_anyway(hp___0, nd);
      }
    }
    {
#line 296
    end_tag = (HSCTAG *)nd->data;
#line 297
    foundnm = end_tag->name;
#line 298
    lastnm = ((HSCTAG *)((hp___0->container_stack)->last)->data)->name;
#line 304
    tmp___2 = upstrcmp((CONSTRPTR )lastnm, (CONSTRPTR )foundnm);
    }
#line 304
    if (tmp___2) {
#line 304
      if (! (tag->option & (unsigned long )(1 << 10))) {
        {
#line 304
        tmp___3 = is_hsc_tag(tag);
        }
#line 304
        if (! tmp___3) {
          {
#line 306
          last_tag = find_strtag(hp___0->deftag, lastnm);
          }
#line 306
          if ((unsigned long )((void *)0) != (unsigned long )last_tag) {
            {
#line 307
            tmp___1 = is_hsc_tag(last_tag);
            }
#line 307
            if (! tmp___1) {
              {
#line 308
              hsc_message(hp___0, (HSCMSG_ID )12302, "illegal end tag nesting (expected %c, found %C)",
                          lastnm, tag);
              }
            }
          }
        }
      }
    }
#line 319
    if (end_tag->attr) {
      {
#line 319
      set_local_varlist(tag->attr, end_tag->attr, (ULONG )4294967294U);
      }
    }
    {
#line 323
    del_dlnode(hp___0->container_stack, nd);
    }
  }
#line 325
  return;
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
BOOL hsc_parse_tag(HSCPRC *hp___0 ) 
{ 
  INFILE *inpf ;
  STRPTR nxtwd ;
  DLNODE *nd ;
  HSCTAG *tag ;
  HSCTAG *now_tag_strip_whtspc ;
  ULONG tci ;
  BOOL (*hnd)(HSCPRC *hp , HSCTAG *tag ) ;
  BOOL open_tag ;
  DLLIST *taglist ;
  BOOL rplc_lt ;
  BOOL hnd_result ;
  BOOL unknown_tag ;
  BOOL preceeding_whtspc ;
  STRPTR tmp ;
  int ch ;
  int tmp___0 ;
  BOOL tmp___1 ;
  STRPTR tmp___2 ;
  STRPTR tmp___3 ;
  BOOL write_tag ;
  int tmp___4 ;
  BOOL tmp___5 ;
  STRPTR tmp___6 ;
  STRPTR tmp___7 ;
  int ch___0 ;
  int tmp___8 ;
  BOOL tmp___9 ;
  int tmp___10 ;
  DLNODE *nd___0 ;
  DLNODE *tmp___11 ;
  BOOL tmp___12 ;
  STRPTR tmp___13 ;
  STRPTR tmp___14 ;
  STRPTR tmp___15 ;
  STRPTR tmp___16 ;
  BOOL tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  STRPTR tmp___20 ;
  LONG tmp___21 ;
  BOOL tmp___22 ;
  BOOL semicolon ;
  STRPTR quote ;
  char const   *tmp___23 ;
  HSCSTYLE *stylend ;
  DLNODE *nd___1 ;
  char const   *tmp___24 ;
  VOID (*tag_callback)(HSCPRC *hp , HSCTAG *tag , STRPTR tag_name , STRPTR tag_attr ,
                       STRPTR tag_close ) ;

  {
  {
#line 339
  inpf = hp___0->inpf;
#line 340
  nxtwd = (STRPTR )((void *)0);
#line 341
  nd = (DLNODE *)((void *)0);
#line 342
  tag = (HSCTAG *)((void *)0);
#line 343
  now_tag_strip_whtspc = (HSCTAG *)((void *)0);
#line 344
  tci = (ULONG )0;
#line 345
  hnd = (BOOL (*)(HSCPRC *hp , HSCTAG *tag ))((void *)0);
#line 347
  taglist = hp___0->deftag;
#line 348
  rplc_lt = (BOOL )0;
#line 349
  hnd_result = (BOOL )1;
#line 350
  unknown_tag = (BOOL )0;
#line 351
  preceeding_whtspc = (BOOL )((hp___0->whtspc)->es_len - 1UL);
#line 354
  tmp = infgetcw(inpf);
#line 354
  ugly_set_estr(hp___0->tag_name_str, (CONSTRPTR )tmp);
#line 355
  ugly_clr_estr(hp___0->tag_attr_str);
#line 356
  ugly_clr_estr(hp___0->tag_close_str);
#line 359
  hp___0->xhtml_emptytag = (BOOL )0;
  }
#line 361
  if (hp___0->smart_ent) {
#line 361
    if (preceeding_whtspc) {
      {
#line 365
      tmp___0 = infgetc(inpf);
#line 365
      ch = tmp___0;
#line 368
      tmp___1 = hsc_whtspc(ch);
      }
#line 368
      if (tmp___1) {
        {
#line 369
        rplc_lt = (BOOL )1;
#line 372
        message_rplc(hp___0, (STRPTR )"<", (STRPTR )"&lt;");
#line 373
        hsc_output_text(hp___0, (STRPTR )"", (STRPTR )"&lt;");
        }
      }
      {
#line 375
      inungetc(ch, inpf);
      }
    }
  }
#line 378
  if (! rplc_lt) {
    {
#line 380
    nxtwd = infget_tagid(hp___0);
    }
#line 381
    if (! hp___0->fatal) {
#line 383
      if (! hp___0->compact) {
        {
#line 384
        tmp___2 = infgetcws(inpf);
#line 384
        ugly_app_estr(hp___0->tag_name_str, (CONSTRPTR )tmp___2);
        }
      }
      {
#line 385
      tmp___3 = infgetcw(inpf);
#line 385
      ugly_app_estr(hp___0->tag_name_str, (CONSTRPTR )tmp___3);
      }
    }
  }
#line 396
  if (! hp___0->fatal) {
#line 396
    if (! rplc_lt) {
      {
#line 397
      write_tag = (BOOL )0;
#line 399
      tmp___18 = strcmp("/", (char const   *)nxtwd);
      }
#line 399
      if (tmp___18) {
        {
#line 405
        open_tag = (BOOL )1;
#line 410
        nd = find_dlnode(taglist->first, (APTR )nxtwd, & cmp_strtag);
        }
#line 411
        if ((unsigned long )((void *)0) == (unsigned long )nd) {
          {
#line 413
          hsc_message(hp___0, (HSCMSG_ID )12299, "unknown %t", nxtwd);
#line 414
          tag = new_hsctag(nxtwd);
#line 415
          tag->option |= (unsigned long )(1 << 14);
#line 416
          unknown_tag = (BOOL )1;
          }
        } else {
#line 418
          tag = (HSCTAG *)nd->data;
        }
#line 422
        hnd = tag->o_handle;
#line 429
        if (tag->option & (unsigned long )(1 << 5)) {
          {
#line 430
          hsc_message(hp___0, (HSCMSG_ID )12325, "%T is obsolete", tag);
          }
        }
#line 435
        if (tag->option & (unsigned long )(1 << 17)) {
#line 435
          if (hp___0->xhtml) {
#line 435
            tmp___4 = 1;
          } else {
#line 435
            tmp___4 = 0;
          }
        } else {
#line 435
          tmp___4 = 0;
        }
#line 435
        hp___0->xhtml_emptytag = (BOOL )tmp___4;
#line 439
        if (tag->option & (unsigned long )(1 << 6)) {
          {
#line 440
          hsc_message(hp___0, (HSCMSG_ID )12326, "%T is only used by %j", tag);
          }
        }
#line 445
        if (tag->option & (unsigned long )(1 << 3)) {
#line 445
          if (tag->occured) {
            {
#line 446
            hsc_message(hp___0, (HSCMSG_ID )16396, "%T occured too often", tag);
            }
          }
        }
#line 451
        if (tag->option & (unsigned long )((1 << 3) | (1 << 2))) {
#line 452
          tag->occured = (BOOL )1;
        }
        {
#line 455
        tmp___5 = check_mbinaw(hp___0, tag);
        }
#line 455
        if (! tmp___5) {
#line 456
          hnd = (BOOL (*)(HSCPRC *hp , HSCTAG *tag ))((void *)0);
        }
        {
#line 459
        clr_varlist(tag->attr);
        }
#line 462
        if (! (tag->option & (unsigned long )(1 << 4))) {
          {
#line 463
          tci = set_tag_args(hp___0, tag);
          }
#line 464
          if (tci == 4294967295UL) {
            {
#line 465
            skip_until_eot(hp___0, (EXPSTR *)((void *)0));
#line 466
            hnd = (BOOL (*)(HSCPRC *hp , HSCTAG *tag ))((void *)0);
            }
          }
#line 469
          if (! hp___0->fatal) {
#line 471
            if (! hp___0->compact) {
              {
#line 472
              tmp___6 = infgetcws(inpf);
#line 472
              ugly_set_estr(hp___0->tag_close_str, (CONSTRPTR )tmp___6);
              }
            } else {
              {
#line 474
              ugly_clr_estr(hp___0->tag_close_str);
              }
            }
            {
#line 475
            tmp___7 = infgetcw(inpf);
#line 475
            ugly_app_estr(hp___0->tag_close_str, (CONSTRPTR )tmp___7);
            }
#line 478
            if (tag->option & (unsigned long )(1 << 12)) {
              {
#line 478
              tmp___10 = infeof(inpf);
              }
#line 478
              if (! tmp___10) {
                {
#line 479
                tmp___8 = infgetc(inpf);
#line 479
                ch___0 = tmp___8;
#line 481
                tmp___9 = hsc_whtspc(ch___0);
                }
#line 481
                if (tmp___9) {
#line 482
                  if (hp___0->strip_badws) {
#line 483
                    hp___0->strip_next2_whtspc = (BOOL )1;
                  } else
#line 484
                  if (! hp___0->strip_next2_whtspc) {
#line 485
                    now_tag_strip_whtspc = tag;
                  }
                }
                {
#line 487
                inungetc(ch___0, inpf);
                }
              }
            }
          }
        }
#line 493
        if (tag->option & (unsigned long )(1 << 7)) {
          {
#line 494
          tmp___11 = find_end_tag_node(hp___0, tag->name);
#line 494
          nd___0 = tmp___11;
          }
#line 496
          if (nd___0) {
#line 497
            if ((unsigned long )nd___0 == (unsigned long )(hp___0->container_stack)->last) {
              {
#line 502
              remove_end_tag(hp___0, tag);
              }
            } else {
              {
#line 497
              tmp___12 = check_autoclose_anyway(hp___0, nd___0);
              }
#line 497
              if (tmp___12) {
                {
#line 502
                remove_end_tag(hp___0, tag);
                }
              }
            }
          }
        }
#line 515
        if (tag->option & (unsigned long )(1 << 1)) {
          {
#line 519
          append_end_tag(hp___0, tag);
          }
        } else
#line 515
        if (tag->option & (unsigned long )(1 << 7)) {
          {
#line 519
          append_end_tag(hp___0, tag);
          }
        }
      } else {
        {
#line 529
        nxtwd = infget_tagid(hp___0);
#line 530
        open_tag = (BOOL )0;
        }
#line 533
        if (! hp___0->compact) {
          {
#line 534
          tmp___13 = infgetcws(inpf);
#line 534
          ugly_app_estr(hp___0->tag_name_str, (CONSTRPTR )tmp___13);
          }
        }
        {
#line 535
        tmp___14 = infgetcw(inpf);
#line 535
        ugly_app_estr(hp___0->tag_name_str, (CONSTRPTR )tmp___14);
#line 542
        nd = find_dlnode(taglist->first, (APTR )nxtwd, & cmp_strtag);
        }
#line 543
        if ((unsigned long )nd == (unsigned long )((void *)0)) {
          {
#line 545
          hsc_message(hp___0, (HSCMSG_ID )12299, "unknown %c", nxtwd);
#line 547
          skip_until_eot(hp___0, hp___0->tag_attr_str);
          }
        } else {
#line 549
          tag = (HSCTAG *)nd->data;
#line 552
          if (tag->option & (unsigned long )(1 << 12)) {
#line 552
            if ((hp___0->whtspc)->es_len - 1UL) {
#line 553
              if (hp___0->strip_badws) {
#line 554
                hp___0->strip_next_whtspc = (BOOL )1;
              } else
#line 555
              if (! hp___0->strip_next_whtspc) {
                {
#line 556
                hsc_message(hp___0, (HSCMSG_ID )8271, "preceding white space for %C",
                            tag);
                }
              }
            }
          }
#line 560
          if (tag->option & (unsigned long )((1 << 1) | (1 << 7))) {
            {
#line 562
            hnd = tag->c_handle;
#line 565
            tmp___17 = parse_wd(hp___0, (STRPTR )">");
            }
#line 565
            if (tmp___17) {
#line 570
              if (! hp___0->compact) {
                {
#line 571
                tmp___15 = infgetcws(inpf);
#line 571
                ugly_set_estr(hp___0->tag_close_str, (CONSTRPTR )tmp___15);
                }
              }
              {
#line 572
              tmp___16 = infgetcw(inpf);
#line 572
              ugly_app_estr(hp___0->tag_close_str, (CONSTRPTR )tmp___16);
              }
            } else {
              {
#line 566
              hsc_message(hp___0, (HSCMSG_ID )16446, "no attributes allowed for end-tags");
              }
            }
            {
#line 579
            remove_end_tag(hp___0, tag);
            }
          } else {
            {
#line 582
            hsc_message(hp___0, (HSCMSG_ID )16450, "illegal %c", nxtwd);
#line 584
            parse_gt(hp___0);
#line 585
            tag = (HSCTAG *)((void *)0);
            }
          }
        }
      }
#line 593
      if (! tag) {
#line 593
        tmp___19 = 1;
      } else
#line 593
      if (! (tag->option & 1UL)) {
#line 593
        tmp___19 = 1;
      } else {
#line 593
        tmp___19 = 0;
      }
#line 593
      write_tag = (BOOL )tmp___19;
#line 595
      if (tag) {
        {
#line 599
        tmp___22 = postprocess_tagattr(hp___0, tag, open_tag);
        }
#line 599
        if (tmp___22) {
#line 605
          if (hp___0->strip_tags) {
            {
#line 605
            tmp___21 = strenum((CONSTRPTR )tag->name, (CONSTRPTR )hp___0->strip_tags,
                               (char )'|', (BYTE )1);
            }
#line 605
            if (tmp___21) {
#line 608
              if (! (tag->option & (unsigned long )(1 << 4))) {
#line 609
                if (open_tag) {
                  {
#line 610
                  hsc_msg_stripped_tag(hp___0, tag, (STRPTR )"as requested");
                  }
                }
#line 611
                hnd = (BOOL (*)(HSCPRC *hp , HSCTAG *tag ))((void *)0);
#line 612
                write_tag = (BOOL )0;
              } else {
                {
#line 614
                hsc_message(hp___0, (HSCMSG_ID )12358, "can not strip special tag %T",
                            tag);
                }
              }
            } else {
#line 605
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 620
          if (tag->uri_size) {
            {
#line 620
            tmp___20 = get_vartext(tag->uri_size);
            }
#line 620
            if (tmp___20) {
              {
#line 621
              get_attr_size(hp___0, tag);
              }
            }
          }
        } else {
#line 601
          if (open_tag) {
            {
#line 602
            hsc_msg_stripped_tag(hp___0, tag, (STRPTR )"external reference");
            }
          }
#line 603
          hnd = (BOOL (*)(HSCPRC *hp , HSCTAG *tag ))((void *)0);
#line 604
          write_tag = (BOOL )0;
        }
#line 624
        if ((unsigned long )((void *)0) != (unsigned long )(hp___0->tag_styles)->first) {
#line 625
          semicolon = (BOOL )0;
#line 626
          if (3L == hp___0->quotemode) {
#line 626
            tmp___23 = "\'";
          } else {
#line 626
            tmp___23 = "\"";
          }
#line 626
          quote = (STRPTR )tmp___23;
#line 631
          if (hp___0->lctags) {
#line 631
            tmp___24 = " style=";
          } else {
#line 631
            tmp___24 = " STYLE=";
          }
          {
#line 631
          ugly_app_estr(hp___0->tag_attr_str, tmp___24);
#line 632
          ugly_app_estr(hp___0->tag_attr_str, (CONSTRPTR )quote);
          }
          {
#line 634
          while (1) {
            while_continue: /* CIL Label */ ;
#line 634
            nd___1 = (hp___0->tag_styles)->first;
#line 634
            if (! ((unsigned long )((void *)0) != (unsigned long )nd___1)) {
#line 634
              goto while_break;
            }
#line 635
            stylend = (HSCSTYLE *)nd___1->data;
#line 638
            if (semicolon) {
              {
#line 638
              ugly_app_estr(hp___0->tag_attr_str, "; ");
              }
            }
            {
#line 640
            ugly_app_estr(hp___0->tag_attr_str, (CONSTRPTR )stylend->name);
#line 641
            ugly_app_estr(hp___0->tag_attr_str, ":");
#line 642
            ugly_app_estr(hp___0->tag_attr_str, (CONSTRPTR )stylend->value);
#line 644
            del_dlnode(hp___0->tag_styles, nd___1);
#line 645
            semicolon = (BOOL )1;
            }
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 648
          ugly_app_estr(hp___0->tag_attr_str, (CONSTRPTR )quote);
          }
        }
      }
#line 653
      if (hnd) {
#line 653
        if (! hp___0->fatal) {
          {
#line 654
          hnd_result = (*hnd)(hp___0, tag);
          }
        }
      }
#line 657
      if (write_tag) {
#line 657
        if (hnd_result) {
#line 658
          tag_callback = (VOID (*)(HSCPRC *hp , HSCTAG *tag , STRPTR tag_name , STRPTR tag_attr ,
                                   STRPTR tag_close ))((void *)0);
#line 661
          if (open_tag) {
#line 662
            tag_callback = hp___0->CB_start_tag;
          } else {
#line 664
            tag_callback = hp___0->CB_end_tag;
          }
#line 667
          if (hp___0->suppress_output) {
            {
#line 668
            hp_enable_output(hp___0, (STRPTR )"non-internal tag occured");
            }
          }
          {
#line 671
          hsc_output_text(hp___0, (STRPTR )"", (STRPTR )"");
          }
#line 673
          if (tag_callback) {
            {
#line 674
            (*tag_callback)(hp___0, tag, (hp___0->tag_name_str)->es_data, (hp___0->tag_attr_str)->es_data,
                            (hp___0->tag_close_str)->es_data);
            }
          }
        }
      }
#line 682
      if (tag) {
#line 682
        if (tag->option & (unsigned long )(1 << 13)) {
          {
#line 683
          skip_next_lf(hp___0);
          }
        }
      }
#line 687
      if (now_tag_strip_whtspc) {
#line 689
        hp___0->tag_next_whtspc = now_tag_strip_whtspc;
      }
#line 693
      if (unknown_tag) {
        {
#line 694
        del_hsctag((APTR )tag);
        }
      }
    }
  }
#line 697
  return ((BOOL )(! hp___0->fatal));
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
static VOID replace_icon(HSCPRC *hp___0 , STRPTR icon ) 
{ 
  INFILEPOS *base ;
  INFILEPOS *tmp ;
  EXPSTR *image ;
  EXPSTR *tmp___0 ;
  STRPTR s___2 ;

  {
  {
#line 708
  tmp = new_infilepos(hp___0->inpf);
#line 708
  base = tmp;
#line 709
  tmp___0 = ugly_init_estr((size_t )0);
#line 709
  image = tmp___0;
#line 710
  s___2 = (hp___0->iconbase)->es_data;
#line 713
  ugly_set_estr(image, "<IMG SRC=\"");
  }
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! *(s___2 + 0)) {
#line 716
      goto while_break;
    }
#line 717
    if ((int )*(s___2 + 0) == 42) {
      {
#line 718
      ugly_app_estr(image, (CONSTRPTR )icon);
      }
    } else {
      {
#line 720
      ugly_app_estrch(image, (int )*(s___2 + 0));
      }
    }
#line 721
    s___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 725
  ugly_app_estr(image, "\" ALT=\"");
#line 726
  ugly_app_estr(image, (CONSTRPTR )icon);
#line 727
  ugly_app_estr(image, "\">");
#line 729
  hsc_message(hp___0, (HSCMSG_ID )77, "replacing icon-%e", icon);
#line 731
  hsc_include_string(hp___0, (STRPTR )"::s::include icon", image->es_data, (ULONG )(((1 << 3) | (1 << 5)) | (1 << 7)));
#line 734
  del_estr(image);
#line 735
  del_infilepos(base);
  }
#line 736
  return;
}
}
#line 744 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
BOOL hsc_parse_amp(HSCPRC *hp___0 ) 
{ 
  unsigned long numeric_ent ;
  BOOL invalid_ent ;
  INFILE *inpf ;
  EXPSTR *amp_str ;
  EXPSTR *tmp ;
  DLNODE *nd ;
  HSCENT *entity ;
  char *nxtwd ;
  BOOL app_entity ;
  STRPTR tmp___0 ;
  STRPTR tmp___1 ;
  size_t tmp___2 ;
  STRPTR tmp___3 ;
  int base ;
  STRPTR digit_start ;
  STRPTR tmp___4 ;
  STRPTR tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  STRPTR tmp___11 ;
  size_t tmp___12 ;
  STRPTR tmp___13 ;
  STRPTR tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char tbuf[8] ;
  char *ent_out ;
  int tmp___18 ;

  {
#line 745
  if (! hp___0->fatal) {
    {
#line 746
    numeric_ent = 0xffffffffffffffffUL;
#line 747
    invalid_ent = (BOOL )1;
#line 748
    inpf = hp___0->inpf;
#line 749
    tmp = ugly_init_estr((size_t )0);
#line 749
    amp_str = tmp;
#line 750
    nd = (DLNODE *)((void *)0);
#line 751
    entity = (HSCENT *)((void *)0);
#line 757
    app_entity = (BOOL )1;
#line 760
    tmp___0 = infgetcw(inpf);
#line 760
    ugly_set_estr(amp_str, (CONSTRPTR )tmp___0);
#line 763
    nxtwd = infgetw(inpf);
#line 766
    tmp___1 = infgetcws(inpf);
#line 766
    tmp___2 = strlen((char const   *)tmp___1);
    }
#line 766
    if (tmp___2) {
      {
#line 767
      hsc_msg_illg_whtspc(hp___0);
      }
    }
#line 769
    if ((unsigned long )nxtwd == (unsigned long )((void *)0)) {
      {
#line 770
      hsc_msg_eof(hp___0, (STRPTR )"missing entity");
      }
    } else {
      {
#line 771
      tmp___17 = strcmp((char const   *)nxtwd, "\\");
      }
#line 771
      if (tmp___17) {
        {
#line 776
        tmp___16 = strcmp((char const   *)nxtwd, "/");
        }
#line 776
        if (tmp___16) {
          {
#line 782
          hp_enable_output(hp___0, (STRPTR )"entity");
#line 785
          tmp___3 = infgetcws(inpf);
#line 785
          ugly_app_estr(amp_str, (CONSTRPTR )tmp___3);
#line 787
          tmp___10 = strcmp((char const   *)nxtwd, "#");
          }
#line 787
          if (tmp___10) {
            {
#line 836
            nd = find_dlnode((hp___0->defent)->first, (APTR )nxtwd, & cmp_strent);
            }
#line 836
            if ((unsigned long )((void *)0) != (unsigned long )nd) {
#line 840
              invalid_ent = (BOOL )0;
#line 841
              entity = (HSCENT *)nd->data;
#line 842
              if (entity->numeric == -1) {
#line 843
                if ((hp___0->iconbase)->es_len - 1UL) {
                  {
#line 844
                  replace_icon(hp___0, nxtwd);
#line 845
                  ugly_set_estr(amp_str, "");
#line 846
                  app_entity = (BOOL )0;
                  }
                } else {
                  {
#line 848
                  hsc_message(hp___0, (HSCMSG_ID )8250, "icon %e found", nxtwd);
                  }
                }
              } else {
#line 852
                numeric_ent = (unsigned long )entity->numeric;
              }
            } else {
              {
#line 854
              hsc_message(hp___0, (HSCMSG_ID )12306, "unknown %e", nxtwd);
              }
            }
#line 856
            if (app_entity) {
              {
#line 858
              ugly_app_estr(amp_str, (CONSTRPTR )nxtwd);
              }
            }
          } else {
            {
#line 791
            base = 10;
#line 792
            digit_start = (STRPTR )((void *)0);
#line 795
            tmp___4 = infgetcw(inpf);
#line 795
            ugly_app_estr(amp_str, (CONSTRPTR )tmp___4);
#line 798
            nxtwd = infgetw(inpf);
#line 801
            tmp___5 = infgetcws(inpf);
#line 801
            tmp___6 = strlen((char const   *)tmp___5);
            }
#line 801
            if (tmp___6) {
              {
#line 802
              hsc_msg_illg_whtspc(hp___0);
              }
            }
            {
#line 806
            tmp___7 = toupper((int )*(nxtwd + 0));
            }
#line 806
            if (tmp___7 == 88) {
#line 807
              base = 16;
#line 808
              digit_start = nxtwd + 1;
            } else {
#line 810
              base = 10;
#line 811
              digit_start = nxtwd;
            }
            {
#line 815
            tmp___8 = __errno_location();
#line 815
            *tmp___8 = 0;
#line 816
            numeric_ent = strtoul((char const   */* __restrict  */)digit_start, (char **/* __restrict  */)((void *)0),
                                  base);
#line 817
            tmp___9 = __errno_location();
            }
#line 817
            if (*tmp___9) {
              {
#line 818
              hsc_message(hp___0, (HSCMSG_ID )12359, "illegal numeric value %q for entity",
                          nxtwd);
              }
            } else
#line 817
            if (65535UL < numeric_ent) {
              {
#line 818
              hsc_message(hp___0, (HSCMSG_ID )12359, "illegal numeric value %q for entity",
                          nxtwd);
              }
            } else {
#line 821
              invalid_ent = (BOOL )0;
            }
#line 824
            if (1L != hp___0->entitymode) {
#line 824
              if (3L != hp___0->entitymode) {
                {
#line 825
                nd = find_dlnode((hp___0->defent)->first, (APTR )numeric_ent, & cmp_nument);
                }
#line 825
                if ((unsigned long )((void *)0) != (unsigned long )nd) {
#line 826
                  entity = (HSCENT *)nd->data;
                }
              }
            }
            {
#line 829
            ugly_app_estr(amp_str, (CONSTRPTR )nxtwd);
            }
          }
          {
#line 863
          nxtwd = infgetw(inpf);
          }
#line 864
          if (nxtwd) {
            {
#line 865
            tmp___15 = strcmp((char const   *)nxtwd, ";");
            }
#line 865
            if (tmp___15) {
              {
#line 874
              hsc_message(hp___0, (HSCMSG_ID )12307, "%q expected after entity", ";");
#line 875
              inungetcwws(inpf);
              }
            } else {
              {
#line 866
              tmp___11 = infgetcws(inpf);
#line 866
              tmp___12 = strlen((char const   *)tmp___11);
              }
#line 866
              if (tmp___12) {
                {
#line 867
                hsc_msg_illg_whtspc(hp___0);
                }
              }
#line 869
              if (app_entity) {
                {
#line 870
                tmp___13 = infgetcws(inpf);
#line 870
                ugly_app_estr(amp_str, (CONSTRPTR )tmp___13);
#line 871
                tmp___14 = infgetcw(inpf);
#line 871
                ugly_app_estr(amp_str, (CONSTRPTR )tmp___14);
                }
              }
            }
          } else {
            {
#line 878
            hsc_msg_eof(hp___0, (STRPTR )"expected \";\") for entity");
            }
          }
        } else {
          {
#line 778
          ugly_set_estr(hp___0->whtspc, " ");
#line 779
          ugly_clr_estr(amp_str);
#line 780
          infskip_ws(inpf);
          }
        }
      } else {
        {
#line 773
        ugly_clr_estr(hp___0->whtspc);
#line 774
        ugly_clr_estr(amp_str);
#line 775
        infskip_ws(inpf);
        }
      }
    }
#line 883
    if (amp_str->es_len - 1UL) {
#line 884
      if (invalid_ent) {
        {
#line 886
        hsc_output_text(hp___0, (STRPTR )"", amp_str->es_data);
        }
      } else {
#line 889
        ent_out = tbuf;
        {
#line 892
        if (hp___0->entitymode == 1L) {
#line 892
          goto case_1;
        }
#line 901
        if (hp___0->entitymode == 2L) {
#line 901
          goto case_2;
        }
#line 918
        if (hp___0->entitymode == 3L) {
#line 918
          goto case_3;
        }
#line 923
        if (hp___0->entitymode == 4L) {
#line 923
          goto case_4;
        }
#line 934
        if (hp___0->entitymode == 5L) {
#line 934
          goto case_5;
        }
#line 944
        goto switch_default;
        case_1: /* CIL Label */ 
#line 893
        if ((unsigned long )((void *)0) != (unsigned long )entity) {
#line 893
          if ((int )entity->flags & 2) {
            {
#line 896
            snprintf((char */* __restrict  */)(tbuf), sizeof(tbuf), (char const   */* __restrict  */)"&%d;",
                     (int )((unsigned short )numeric_ent));
            }
          } else {
#line 898
            ent_out = amp_str->es_data;
          }
        } else {
#line 898
          ent_out = amp_str->es_data;
        }
#line 899
        goto switch_break;
        case_2: /* CIL Label */ 
#line 902
        if ((unsigned long )((void *)0) != (unsigned long )entity) {
#line 903
          if ((int )entity->flags & 3) {
            {
#line 905
            snprintf((char */* __restrict  */)(tbuf), sizeof(tbuf), (char const   */* __restrict  */)"&%d;",
                     (int )((unsigned short )numeric_ent));
            }
          } else {
            {
#line 909
            ugly_set_estr(amp_str, "&");
#line 910
            ugly_app_estr(amp_str, (CONSTRPTR )entity->name);
#line 911
            ugly_app_estr(amp_str, ";");
#line 912
            ent_out = amp_str->es_data;
            }
          }
        } else {
#line 915
          ent_out = amp_str->es_data;
        }
#line 916
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 920
        snprintf((char */* __restrict  */)(tbuf), sizeof(tbuf), (char const   */* __restrict  */)"&%d;",
                 (int )((unsigned short )numeric_ent));
        }
#line 921
        goto switch_break;
        case_4: /* CIL Label */ 
#line 926
        if ((unsigned long )((void *)0) != (unsigned long )entity) {
          {
#line 927
          ugly_set_estr(amp_str, "&");
#line 928
          ugly_app_estr(amp_str, (CONSTRPTR )entity->name);
#line 929
          ugly_app_estr(amp_str, ";");
          }
        }
#line 931
        ent_out = amp_str->es_data;
#line 932
        goto switch_break;
        case_5: /* CIL Label */ 
#line 938
        if (numeric_ent) {
          {
#line 939
          tmp___18 = ucs4_to_utf8((utf8_t *)(tbuf), (ucs4_t )numeric_ent);
#line 939
          *((utf8_t *)(tbuf) + tmp___18) = (utf8_t )'\000';
          }
        } else {
#line 941
          ent_out = amp_str->es_data;
        }
#line 942
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 945
        ent_out = amp_str->es_data;
#line 946
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 948
        hsc_output_text(hp___0, (STRPTR )"", ent_out);
        }
      }
    }
    {
#line 951
    del_estr(amp_str);
    }
  }
#line 953
  return ((BOOL )(! hp___0->fatal));
}
}
#line 959 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
BOOL hsc_parse_text(HSCPRC *hp___0 ) 
{ 
  INFILE *inpf ;
  STRPTR nw ;
  STRPTR tmp ;
  BOOL rplc ;
  int ch ;
  int tmp___0 ;
  BOOL tmp___1 ;
  DLNODE *nd ;
  char tbuf[8] ;
  BOOL ok ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;
  int tmp___5 ;
  BOOL tmp___6 ;
  int tmp___7 ;
  BOOL tmp___8 ;
  size_t tmp___9 ;
  ULONG found ;
  LONG tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 960
  inpf = hp___0->inpf;
#line 961
  tmp = infgetcw(inpf);
#line 961
  nw = tmp;
  }
#line 963
  if (nw) {
#line 963
    if (hp___0->suppress_output) {
      {
#line 964
      hp_enable_output(hp___0, (STRPTR )"some text");
      }
    }
  }
#line 966
  if (nw) {
    {
#line 970
    tmp___12 = strcmp((char const   *)nw, ">");
    }
#line 970
    if (tmp___12) {
      {
#line 991
      tmp___11 = strcmp((char const   *)nw, "\"");
      }
#line 991
      if (tmp___11) {
#line 998
        nd = (DLNODE *)((void *)0);
#line 1000
        if (hp___0->rplc_ent) {
          {
#line 1000
          tmp___9 = strlen((char const   *)nw);
          }
#line 1000
          if (tmp___9 == 1UL) {
#line 1000
            if ((int )((UBYTE )*(nw + 0)) >= 127) {
              {
#line 1001
              nd = find_dlnode((hp___0->defent)->first, (APTR )nw, & cmp_rplcent);
              }
#line 1003
              if (nd) {
#line 1005
                ok = (BOOL )1;
                {
#line 1011
                if (hp___0->entitymode == 4L) {
#line 1011
                  goto case_4;
                }
#line 1011
                if (hp___0->entitymode == 2L) {
#line 1011
                  goto case_4;
                }
#line 1011
                if (hp___0->entitymode == 1L) {
#line 1011
                  goto case_4;
                }
#line 1016
                if (hp___0->entitymode == 3L) {
#line 1016
                  goto case_3;
                }
#line 1021
                if (hp___0->entitymode == 5L) {
#line 1021
                  goto case_5;
                }
#line 1025
                goto switch_default;
                case_4: /* CIL Label */ 
                case_2: /* CIL Label */ 
                case_1: /* CIL Label */ 
                {
#line 1012
                tmp___2 = ugly_set_estr(hp___0->tmpstr, "&");
#line 1012
                ok = (BOOL )((int )ok & (int )tmp___2);
#line 1013
                tmp___3 = ugly_app_estr(hp___0->tmpstr, (CONSTRPTR )((HSCENT *)nd->data)->name);
#line 1013
                ok = (BOOL )((int )ok & (int )tmp___3);
#line 1014
                tmp___4 = ugly_app_estr(hp___0->tmpstr, ";");
#line 1014
                ok = (BOOL )((int )ok & (int )tmp___4);
                }
#line 1015
                goto switch_break;
                case_3: /* CIL Label */ 
                {
#line 1017
                tmp___5 = snprintf((char */* __restrict  */)(tbuf), sizeof(tbuf),
                                   (char const   */* __restrict  */)"&%d;", (int )((unsigned short )((HSCENT *)nd->data)->numeric));
#line 1017
                ok = (BOOL )((int )ok & (sizeof(tbuf) >= (unsigned long )((unsigned int )tmp___5)));
#line 1019
                tmp___6 = ugly_set_estr(hp___0->tmpstr, (CONSTRPTR )(tbuf));
#line 1019
                ok = (BOOL )((int )ok & (int )tmp___6);
                }
#line 1020
                goto switch_break;
                case_5: /* CIL Label */ 
                {
#line 1022
                tmp___7 = ucs4_to_utf8((utf8_t *)(tbuf), (ucs4_t )((HSCENT *)nd->data)->numeric);
#line 1022
                *((utf8_t *)(tbuf) + tmp___7) = (utf8_t )'\000';
#line 1023
                tmp___8 = ugly_set_estr(hp___0->tmpstr, (CONSTRPTR )(tbuf));
#line 1023
                ok = (BOOL )((int )ok & (int )tmp___8);
                }
#line 1024
                goto switch_break;
                switch_default: /* CIL Label */ 
#line 1026
                ok = (BOOL )0;
#line 1027
                goto switch_break;
                switch_break: /* CIL Label */ ;
                }
#line 1029
                if (ok) {
                  {
#line 1031
                  message_rplc(hp___0, nw, (hp___0->tmpstr)->es_data);
#line 1032
                  nw = (hp___0->tmpstr)->es_data;
                  }
                }
              }
            }
          }
        }
#line 1039
        if (hp___0->inside_anchor) {
#line 1039
          if (hp___0->click_here_str) {
            {
#line 1040
            tmp___10 = strenum((CONSTRPTR )nw, (CONSTRPTR )hp___0->click_here_str,
                               (char )'|', (BYTE )1);
#line 1040
            found = (ULONG )tmp___10;
            }
#line 1041
            if (found) {
              {
#line 1042
              hsc_message(hp___0, (HSCMSG_ID )4106, "%q-syndrome detected", "click here");
              }
            }
          }
        }
      } else
#line 992
      if (hp___0->rplc_quote) {
        {
#line 994
        message_rplc(hp___0, nw, (STRPTR )"&quot;");
#line 995
        nw = (STRPTR )"&quot;";
        }
      }
    } else {
#line 971
      rplc = hp___0->smart_ent;
#line 973
      if (rplc) {
        {
#line 978
        tmp___0 = infgetc(inpf);
#line 978
        ch = tmp___0;
#line 980
        inungetc(ch, inpf);
#line 982
        tmp___1 = hsc_whtspc(ch);
        }
#line 982
        if (tmp___1) {
#line 982
          if (! ((hp___0->whtspc)->es_len - 1UL)) {
#line 983
            rplc = (BOOL )0;
          }
        } else {
#line 983
          rplc = (BOOL )0;
        }
      }
#line 985
      if (rplc) {
        {
#line 987
        message_rplc(hp___0, nw, (STRPTR )"&gt;");
#line 988
        nw = (STRPTR )"&gt;";
        }
      } else {
        {
#line 990
        hsc_message(hp___0, (HSCMSG_ID )16414, "unmatched %q", ">");
        }
      }
    }
  }
#line 1048
  if (nw) {
    {
#line 1049
    hsc_output_text(hp___0, (STRPTR )"", nw);
    }
  }
#line 1051
  return ((BOOL )(! hp___0->fatal));
}
}
#line 1063 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
BOOL hsc_parse(HSCPRC *hp___0 ) 
{ 
  STRPTR nxtwd ;
  STRPTR tmp ;
  STRPTR cws ;
  STRPTR tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1065
  if (! hp___0->fatal) {
    {
#line 1067
    tmp = infgetw(hp___0->inpf);
#line 1067
    nxtwd = tmp;
#line 1068
    tmp___0 = infgetcws(hp___0->inpf);
#line 1068
    cws = tmp___0;
    }
#line 1071
    if (cws) {
      {
#line 1072
      ugly_app_estr(hp___0->whtspc, (CONSTRPTR )cws);
      }
    }
#line 1075
    if (nxtwd) {
      {
#line 1077
      tmp___2 = strcmp((char const   *)nxtwd, "<");
      }
#line 1077
      if (tmp___2) {
        {
#line 1080
        tmp___1 = strcmp((char const   *)nxtwd, "&");
        }
#line 1080
        if (tmp___1) {
          {
#line 1085
          hsc_parse_text(hp___0);
          }
        } else {
          {
#line 1082
          hsc_parse_amp(hp___0);
          }
        }
      } else {
        {
#line 1079
        hsc_parse_tag(hp___0);
        }
      }
    }
  }
#line 1089
  return ((BOOL )(! hp___0->fatal));
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
BOOL hsc_parse_source(HSCPRC *hp___0 ) 
{ 
  STRPTR nxtwd ;
  STRPTR tmp ;
  STRPTR cws ;
  STRPTR tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1103
  if (! hp___0->fatal) {
    {
#line 1105
    tmp = infgetw(hp___0->inpf);
#line 1105
    nxtwd = tmp;
#line 1106
    tmp___0 = infgetcws(hp___0->inpf);
#line 1106
    cws = tmp___0;
    }
#line 1109
    if (cws) {
      {
#line 1110
      ugly_app_estr(hp___0->whtspc, (CONSTRPTR )cws);
      }
    }
#line 1112
    if (nxtwd) {
      {
#line 1115
      tmp___3 = strcmp((char const   *)nxtwd, "<");
      }
#line 1115
      if (tmp___3) {
        {
#line 1117
        tmp___2 = strcmp((char const   *)nxtwd, ">");
        }
#line 1117
        if (tmp___2) {
          {
#line 1119
          tmp___1 = strcmp((char const   *)nxtwd, "&");
          }
#line 1119
          if (tmp___1) {
            {
#line 1122
            hsc_parse_text(hp___0);
            }
          } else {
            {
#line 1120
            hsc_output_text(hp___0, (STRPTR )"", (STRPTR )"&amp;");
            }
          }
        } else {
          {
#line 1118
          hsc_output_text(hp___0, (STRPTR )"", (STRPTR )"&gt;");
          }
        }
      } else {
        {
#line 1116
        hsc_output_text(hp___0, (STRPTR )"", (STRPTR )"&lt;");
        }
      }
    }
  }
#line 1125
  return ((BOOL )(! hp___0->fatal));
}
}
#line 1140 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
BOOL hsc_parse_end(HSCPRC *hp___0 ) 
{ 
  INFILEPOS *infpos ;
  INFILEPOS *tmp ;
  DLNODE *nd ;
  HSCTAG *endtag ;
  HSCTAG *tag ;

  {
#line 1142
  if (! hp___0->fatal) {
    {
#line 1145
    tmp = new_infilepos(hp___0->inpf);
#line 1145
    infpos = tmp;
#line 1146
    nd = (DLNODE *)((void *)0);
#line 1151
    nd = (hp___0->container_stack)->last;
    }
    {
#line 1152
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1152
      if (! nd) {
#line 1152
        goto while_break;
      }
#line 1154
      endtag = (HSCTAG *)nd->data;
#line 1156
      if (! (endtag->option & (unsigned long )(1 << 7))) {
        {
#line 1158
        set_infilepos(hp___0->inpf, endtag->start_fpos);
#line 1159
        hsc_message(hp___0, (HSCMSG_ID )12304, "%c missing", endtag->name);
        }
      }
#line 1163
      nd = nd->prev;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1167
    set_infilepos(hp___0->inpf, infpos);
#line 1168
    del_infilepos(infpos);
#line 1171
    nd = (hp___0->deftag)->first;
    }
    {
#line 1172
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1172
      if (! nd) {
#line 1172
        goto while_break___0;
      }
#line 1174
      tag = (HSCTAG *)nd->data;
#line 1176
      if (tag->option & (unsigned long )(1 << 2)) {
#line 1176
        if ((int )tag->occured == 0) {
          {
#line 1179
          hsc_message(hp___0, (HSCMSG_ID )16399, "required %T missing", tag);
          }
        } else {
#line 1176
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1182
      if (tag->option & (unsigned long )(1 << 15)) {
#line 1182
        if ((int )tag->occured == 0) {
          {
#line 1185
          hsc_message(hp___0, (HSCMSG_ID )4163, "recommended %T missing", tag);
          }
        }
      }
#line 1188
      nd = nd->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1192
    hsc_output_text(hp___0, (STRPTR )"", (STRPTR )"");
    }
  }
#line 1194
  return ((BOOL )(! hp___0->fatal));
}
}
#line 1210 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/parse.c"
BOOL hsc_parse_end_id(HSCPRC *hp___0 ) 
{ 


  {
#line 1212
  if (! hp___0->fatal) {
    {
#line 1213
    check_all_local_idref(hp___0);
    }
  }
#line 1215
  return ((BOOL )(! hp___0->fatal));
}
}
#line 161 "./hsclib/attrib.h"
BOOL get_varbool_byname(DLLIST *varlist , STRPTR name ) ;
#line 66 "./hsclib/skip.h"
BOOL skip_until_tag(HSCPRC *hp___0 , EXPSTR *content , EXPSTR *tagfound , STRPTR tagstoplist ,
                    STRPTR tagnest , ULONG option ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
static VOID message_unma_else(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 


  {
  {
#line 46
  hsc_message(hp___0, (HSCMSG_ID )16437, "unmatched conditional %T", tag);
  }
#line 48
  return;
}
}
#line 51
BOOL handle_hsc_else(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 52
BOOL handle_hsc_elseif(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 53
BOOL handle_hsc_cif(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
static if_t bool2ift(BOOL bval ) 
{ 


  {
#line 58
  if (bval) {
#line 59
    return ((if_t )'1');
  } else {
#line 61
    return ((if_t )'0');
  }
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
static VOID is_push(HSCPRC *hp___0 , if_t value ) 
{ 


  {
  {
#line 73
  ugly_app_estrch(hp___0->if_stack, (int )((char )value));
  }
#line 76
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
static if_t is_get(HSCPRC *hp___0 ) 
{ 
  if_t value ;
  STRPTR stkstr ;
  char lastch ;
  size_t tmp ;

  {
#line 81
  value = (if_t )'0';
#line 83
  if (hp___0->if_stack) {
#line 85
    stkstr = (hp___0->if_stack)->es_data;
#line 89
    if (stkstr) {
#line 89
      if (*(stkstr + 0)) {
        {
#line 91
        tmp = strlen((char const   *)stkstr);
#line 91
        lastch = *(stkstr + (tmp - 1UL));
        }
#line 92
        if ((int )lastch != 49) {
#line 92
          if ((int )lastch != 48) {
#line 92
            if (! ((int )lastch != 101)) {
#line 99
              value = (if_t )lastch;
            }
          } else {
#line 99
            value = (if_t )lastch;
          }
        } else {
#line 99
          value = (if_t )lastch;
        }
      }
    }
  }
#line 113
  return (value);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
static if_t is_pop(HSCPRC *hp___0 ) 
{ 
  if_t value ;
  if_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 120
  tmp = is_get(hp___0);
#line 120
  value = tmp;
#line 122
  tmp___0 = strlen((char const   *)(hp___0->if_stack)->es_data);
  }
#line 122
  if (tmp___0) {
#line 122
    tmp___1 = 0;
  } else {
#line 122
    tmp___1 = 1;
  }
  {
#line 127
  tmp___2 = strlen((char const   *)(hp___0->if_stack)->es_data);
#line 127
  get_left_estr(hp___0->if_stack, hp___0->if_stack, tmp___2 - 1UL);
  }
#line 131
  return (value);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
static BOOL is_empty(HSCPRC *hp___0 ) 
{ 
  BOOL result ;
  size_t tmp ;

  {
  {
#line 137
  result = (BOOL )0;
#line 139
  tmp = strlen((char const   *)(hp___0->if_stack)->es_data);
  }
#line 139
  if (! tmp) {
#line 140
    result = (BOOL )1;
  }
#line 142
  return (result);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
VOID del_select_stack_node(APTR data ) 
{ 
  STRPTR s___2 ;

  {
  {
#line 156
  s___2 = (STRPTR )data;
#line 157
  ugly_freestr(s___2, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c",
               (ULONG )157);
#line 157
  s___2 = (STRPTR )((void *)0);
  }
#line 158
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
STRPTR new_select_stack_node(STRPTR data ) 
{ 
  STRPTR tmp ;

  {
  {
#line 165
  tmp = ugly_strclone((CONSTRPTR )data, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c",
                      (ULONG )165);
  }
#line 165
  return (tmp);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
int cmp_select_stack_node(APTR cmp_data , APTR lst_data ) 
{ 
  STRPTR s1 ;
  STRPTR s2 ;
  int tmp ;

  {
  {
#line 173
  s1 = (STRPTR )cmp_data;
#line 174
  s2 = (STRPTR )lst_data;
#line 183
  tmp = strcmp((char const   *)s1, (char const   *)s2);
  }
#line 183
  if (tmp) {
#line 186
    return (0);
  } else {
#line 184
    return (-1);
  }
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
static VOID skip_until_conditional(HSCPRC *hp___0 ) 
{ 
  EXPSTR *s___2 ;
  EXPSTR *tmp ;

  {
  {
#line 328
  tmp = ugly_init_estr((size_t )32);
#line 328
  s___2 = tmp;
#line 331
  skip_until_tag(hp___0, (EXPSTR *)((void *)0), s___2, (STRPTR )"$else|$elseif", (STRPTR )"$if",
                 (ULONG )1);
#line 334
  del_estr(s___2);
  }
#line 335
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
BOOL handle_hsc_if(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL new_condbool ;
  BOOL tmp ;
  if_t new_cond ;
  if_t tmp___0 ;

  {
  {
#line 350
  tmp = get_varbool_byname(tag->attr, (STRPTR )"COND");
#line 350
  new_condbool = tmp;
#line 351
  tmp___0 = bool2ift(new_condbool);
#line 351
  new_cond = tmp___0;
#line 354
  is_push(hp___0, new_cond);
  }
#line 357
  if ((int )new_cond != 49) {
    {
#line 360
    skip_until_conditional(hp___0);
    }
  }
#line 367
  return ((BOOL )0);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
BOOL handle_hsc_cif(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL tmp ;

  {
  {
#line 379
  tmp = is_empty(hp___0);
  }
#line 379
  if (! tmp) {
    {
#line 388
    is_pop(hp___0);
    }
  }
#line 391
  return ((BOOL )0);
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
BOOL handle_hsc_else(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  if_t value ;
  if_t tmp ;
  BOOL tmp___0 ;

  {
  {
#line 401
  tmp___0 = is_empty(hp___0);
  }
#line 401
  if (! tmp___0) {
    {
#line 408
    tmp = is_pop(hp___0);
#line 408
    value = tmp;
    }
#line 410
    if ((int )value == 101) {
      {
#line 412
      message_unma_else(hp___0, tag);
      }
    } else
#line 414
    if (! ((int )value == 48)) {
      {
#line 421
      skip_until_conditional(hp___0);
      }
    }
    {
#line 425
    is_push(hp___0, (if_t )'e');
    }
  }
#line 428
  return ((BOOL )0);
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_if.c"
BOOL handle_hsc_elseif(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL new_condbool ;
  BOOL tmp ;
  if_t new_cond ;
  if_t tmp___0 ;
  if_t old_cond ;
  if_t tmp___1 ;
  if_t push_cond ;
  BOOL tmp___2 ;

  {
  {
#line 438
  tmp = get_varbool_byname(tag->attr, (STRPTR )"COND");
#line 438
  new_condbool = tmp;
#line 439
  tmp___0 = bool2ift(new_condbool);
#line 439
  new_cond = tmp___0;
#line 441
  tmp___2 = is_empty(hp___0);
  }
#line 441
  if (! tmp___2) {
    {
#line 448
    tmp___1 = is_pop(hp___0);
#line 448
    old_cond = tmp___1;
#line 449
    push_cond = old_cond;
    }
#line 451
    if ((int )old_cond == 101) {
      {
#line 453
      message_unma_else(hp___0, tag);
      }
    } else
#line 455
    if ((int )old_cond == 49) {
      {
#line 458
      skip_until_conditional(hp___0);
      }
    } else
#line 460
    if ((int )new_cond == 49) {
#line 463
      push_cond = new_cond;
    } else {
      {
#line 468
      skip_until_conditional(hp___0);
      }
    }
    {
#line 472
    is_push(hp___0, push_cond);
    }
  }
#line 475
  return ((BOOL )0);
}
}
#line 434 "./hsclib/hscprc.h"
HSCIGN hsc_get_msg_ignore(HSCPRC *hp___0 , HSCMSG_ID msg_id ) ;
#line 49 "./hsclib/lmessage.h"
VOID hsc_msg_nouri(HSCPRC *hp___0 , STRPTR filename , STRPTR uriname , STRPTR note ) ;
#line 42 "./hsclib/idref.h"
VOID hsc_msg_unknown_id(HSCPRC *hp___0 , STRPTR filename , STRPTR id ) ;
#line 47
VOID add_local_idref(HSCPRC *hp___0 , STRPTR id ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/uri.c"
VOID conv_path2uri(EXPSTR *dest , STRPTR path ) 
{ 


  {
  {
#line 50
  ugly_clr_estr(dest);
#line 72
  ugly_set_estr(dest, (CONSTRPTR )path);
  }
#line 76
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/uri.c"
VOID conv_uri2path(EXPSTR *dest , STRPTR uri , BOOL weenix ) 
{ 


  {
  {
#line 86
  ugly_clr_estr(dest);
#line 117
  ugly_set_estr(dest, (CONSTRPTR )uri);
  }
#line 121
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/uri.c"
URIKIND uri_kind(STRPTR uri ) 
{ 
  URIKIND kind ;
  STRPTR colon_pos ;
  char *tmp ;
  STRPTR slash_pos ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 130
  kind = (URIKIND )0;
#line 132
  tmp___1 = strlen(":");
#line 132
  tmp___2 = upstrncmp((CONSTRPTR )uri, ":", tmp___1);
  }
#line 132
  if (tmp___2) {
#line 133
    if ((int )*(uri + 0) == 47) {
#line 134
      kind = (URIKIND )3;
    } else {
      {
#line 136
      tmp = strchr((char const   *)uri, ':');
#line 136
      colon_pos = tmp;
#line 137
      tmp___0 = strchr((char const   *)uri, '/');
#line 137
      slash_pos = tmp___0;
      }
#line 139
      if (colon_pos) {
#line 140
        if (slash_pos) {
#line 141
          if ((unsigned long )colon_pos < (unsigned long )slash_pos) {
#line 142
            kind = (URIKIND )1;
          } else {
#line 144
            kind = (URIKIND )2;
          }
        } else {
#line 145
          kind = (URIKIND )1;
        }
      } else {
#line 146
        kind = (URIKIND )2;
      }
    }
  }
#line 149
  return (kind);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/uri.c"
VOID conv_hscuri2fileNuri(HSCPRC *hp___0 , EXPSTR *dest_uri , EXPSTR *dest_fname ,
                          STRPTR uri ) 
{ 
  EXPSTR *rel_path ;
  EXPSTR *tmp ;
  EXPSTR *turi ;
  EXPSTR *tmp___0 ;
  URIKIND kind ;
  URIKIND tmp___1 ;
  STRPTR uri2 ;
  size_t tmp___2 ;
  EXPSTR *dest_relfname ;
  EXPSTR *tmp___3 ;
  size_t tmp___4 ;
  fentrytype_t tmp___5 ;
  EXPSTR *uri_path ;
  EXPSTR *tmp___6 ;
  EXPSTR *docdir ;
  EXPSTR *tmp___7 ;
  STRPTR optimized_name ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  fentrytype_t tmp___11 ;
  STRPTR optimized_name___0 ;
  size_t tmp___12 ;
  fentrytype_t tmp___13 ;
  size_t tmp___14 ;

  {
  {
#line 159
  tmp = ugly_init_estr((size_t )32);
#line 159
  rel_path = tmp;
#line 160
  tmp___0 = ugly_init_estr((size_t )32);
#line 160
  turi = tmp___0;
#line 161
  tmp___1 = uri_kind(uri);
#line 161
  kind = tmp___1;
#line 163
  ugly_clr_estr(dest_uri);
#line 164
  ugly_clr_estr(dest_fname);
#line 168
  tmp___14 = strlen((char const   *)uri);
  }
#line 168
  if (0UL == tmp___14) {
    {
#line 169
    ugly_set_estr(dest_uri, (CONSTRPTR )uri);
    }
  } else {
#line 171
    if ((unsigned int )kind == 3U) {
      {
#line 173
      uri2 = uri + 1;
#line 180
      conv_uri2path(rel_path, uri2, hp___0->weenix);
#line 181
      estrcpy(dest_fname, hp___0->server_dir);
#line 182
      estrcat(dest_fname, rel_path);
#line 189
      ugly_set_estr(dest_uri, (CONSTRPTR )uri);
      }
    } else {
#line 196
      if (hp___0->docbase_set) {
#line 197
        kind = (URIKIND )1;
      }
#line 199
      if ((unsigned int )kind == 0U) {
        {
#line 200
        tmp___2 = strlen(":");
#line 200
        uri += tmp___2;
#line 207
        estrcpy(dest_fname, hp___0->destdir);
        }
#line 208
        if (0 != (int )*(uri + 0)) {
          {
#line 209
          tmp___3 = ugly_init_estr((size_t )32);
#line 209
          dest_relfname = tmp___3;
#line 211
          conv_uri2path(dest_relfname, uri, hp___0->weenix);
#line 212
          estrcat(dest_fname, dest_relfname);
#line 213
          del_estr(dest_relfname);
          }
        }
        {
#line 220
        estrcpy(dest_uri, hp___0->reldir);
#line 221
        ugly_app_estr(dest_uri, (CONSTRPTR )uri);
#line 224
        ugly_set_estr(turi, (CONSTRPTR )uri);
#line 225
        tmp___5 = fgetentrytype((STRPTR const   )uri);
        }
#line 225
        if (2U == (unsigned int )tmp___5) {
          {
#line 227
          tmp___4 = strlen((char const   *)uri);
          }
#line 227
          if (47 != (int )*(uri + (tmp___4 - 1UL))) {
            {
#line 228
            ugly_app_estr(turi, "/");
            }
          }
        }
        {
#line 230
        get_relfname(rel_path, turi->es_data, (hp___0->reldir)->es_data);
        }
#line 237
        if (0 == (int )*(rel_path->es_data + 0)) {
          {
#line 238
          ugly_set_estr(rel_path, ".");
#line 239
          ugly_set_estr(dest_fname, ".");
          }
        }
        {
#line 246
        conv_path2uri(dest_uri, rel_path->es_data);
        }
      } else
#line 247
      if ((unsigned int )kind == 2U) {
        {
#line 251
        tmp___6 = ugly_init_estr((size_t )32);
#line 251
        uri_path = tmp___6;
#line 252
        tmp___7 = ugly_init_estr((size_t )32);
#line 252
        docdir = tmp___7;
#line 253
        optimized_name = (STRPTR )((void *)0);
#line 259
        conv_uri2path(uri_path, uri, hp___0->weenix);
#line 260
        estrcat(dest_fname, hp___0->destdir);
#line 261
        estrcat(dest_fname, hp___0->reldir);
#line 262
        estrcat(dest_fname, uri_path);
#line 265
        tmp___11 = fgetentrytype((STRPTR const   )dest_fname->es_data);
        }
#line 265
        if (2U == (unsigned int )tmp___11) {
          {
#line 267
          tmp___8 = strlen((char const   *)dest_fname->es_data);
#line 267
          tmp___9 = strlen("/");
#line 267
          tmp___10 = strcmp("/", (char const   *)((dest_fname->es_data + tmp___8) - tmp___9));
          }
#line 267
          if (0 != tmp___10) {
            {
#line 270
            ugly_app_estr(dest_fname, "/");
            }
          }
        }
        {
#line 273
        estrcpy(docdir, hp___0->destdir);
#line 274
        estrcat(docdir, hp___0->reldir);
#line 277
        optimize_fname(& optimized_name, dest_fname->es_data);
        }
#line 278
        if (optimized_name) {
          {
#line 280
          get_relfname(dest_uri, optimized_name, docdir->es_data);
          }
#line 281
          if (0UL == dest_uri->es_len - 1UL) {
            {
#line 282
            ugly_set_estr(dest_uri, ".");
            }
          }
#line 283
          if (optimized_name) {
            {
#line 283
            free((void *)optimized_name);
#line 283
            optimized_name = (STRPTR )((void *)0);
            }
          }
        } else {
          {
#line 286
          ugly_set_estr(dest_uri, (CONSTRPTR )uri);
          }
        }
        {
#line 289
        del_estr(docdir);
#line 290
        del_estr(uri_path);
        }
      } else {
        {
#line 292
        ugly_set_estr(dest_uri, (CONSTRPTR )uri);
#line 293
        ugly_set_estr(dest_fname, "");
        }
      }
    }
#line 298
    if (dest_fname->es_len - 1UL > 0UL) {
      {
#line 299
      optimized_name___0 = (STRPTR )((void *)0);
#line 300
      optimize_fname(& optimized_name___0, dest_fname->es_data);
#line 301
      ugly_set_estr(dest_fname, (CONSTRPTR )optimized_name___0);
      }
#line 302
      if (optimized_name___0) {
#line 303
        if (optimized_name___0) {
          {
#line 303
          free((void *)optimized_name___0);
#line 303
          optimized_name___0 = (STRPTR )((void *)0);
          }
        }
      }
      {
#line 305
      tmp___13 = fgetentrytype((STRPTR const   )dest_fname->es_data);
      }
#line 305
      if (2U == (unsigned int )tmp___13) {
        {
#line 307
        tmp___12 = strlen((char const   *)dest_uri->es_data);
        }
#line 307
        if (47 != (int )*(dest_uri->es_data + (tmp___12 - 1UL))) {
          {
#line 308
          ugly_app_estr(dest_uri, "/");
          }
        }
      }
    }
  }
  {
#line 323
  del_estr(turi);
#line 324
  del_estr(rel_path);
  }
#line 325
  return;
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/uri.c"
VOID conv_hscuri2file(HSCPRC *hp___0 , EXPSTR *dest_fname , STRPTR uri ) 
{ 
  EXPSTR *dest_uri ;
  EXPSTR *tmp ;

  {
  {
#line 329
  tmp = ugly_init_estr((size_t )64);
#line 329
  dest_uri = tmp;
#line 330
  conv_hscuri2fileNuri(hp___0, dest_uri, dest_fname, uri);
#line 331
  del_estr(dest_uri);
  }
#line 332
  return;
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/uri.c"
VOID parse_uri(HSCPRC *hp___0 , EXPSTR *dest_uri , STRPTR uri ) 
{ 
  STRPTR protocol ;
  STRPTR host ;
  STRPTR port ;
  STRPTR path ;
  STRPTR name ;
  STRPTR cgiargs ;
  URIKIND kind ;
  URIKIND tmp ;
  EXPSTR *dest_fname ;
  EXPSTR *tmp___0 ;
  STRPTR noabsuri ;
  size_t tmp___1 ;
  FILE *exist ;
  int tmp___2 ;
  STRPTR doc_fname ;
  int tmp___3 ;
  int tmp___4 ;
  HSCIGN tmp___5 ;

  {
  {
#line 348
  protocol = (STRPTR )((void *)0);
#line 349
  host = (STRPTR )((void *)0);
#line 350
  port = (STRPTR )((void *)0);
#line 351
  path = (STRPTR )((void *)0);
#line 352
  name = (STRPTR )((void *)0);
#line 353
  cgiargs = (STRPTR )((void *)0);
#line 357
  ugly_clr_estr(dest_uri);
  }
#line 359
  if (uri) {
    {
#line 361
    tmp = uri_kind(uri);
#line 361
    kind = tmp;
    }
#line 362
    if ((unsigned int )kind == 1U) {
#line 362
      goto _L;
    } else
#line 362
    if ((unsigned int )kind == 3U) {
#line 362
      if (! ((hp___0->server_dir)->es_len - 1UL)) {
        _L: /* CIL Label */ 
#line 364
        if ((unsigned int )kind == 1U) {
#line 368
          if (! protocol) {
#line 368
            protocol = (STRPTR )"";
          }
#line 369
          if (! host) {
#line 369
            host = (STRPTR )"";
          }
#line 370
          if (! port) {
#line 370
            port = (STRPTR )"";
          }
#line 386
          if (hp___0->checkext) {
            {
#line 386
            check_ext_uri(hp___0, uri);
            }
          }
        } else
#line 388
        if ((unsigned int )kind == 3U) {
          {
#line 389
          hsc_message(hp___0, (HSCMSG_ID )12324, "server relative URI to %q", uri);
          }
        } else {
          {
#line 391
          display_panic_message((char *)"what kind of uri now?", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/uri.c",
                                (size_t )391);
          }
        }
        {
#line 393
        ugly_set_estr(dest_uri, (CONSTRPTR )uri);
        }
      } else {
#line 362
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 401
      tmp___0 = ugly_init_estr((size_t )32);
#line 401
      dest_fname = tmp___0;
#line 402
      noabsuri = uri;
      }
#line 405
      if ((unsigned int )kind == 0U) {
        {
#line 406
        tmp___1 = strlen(":");
#line 406
        noabsuri += tmp___1;
        }
      }
#line 409
      if ((int )*(noabsuri + 0) == 35) {
#line 410
        path = (STRPTR )((void *)0);
#line 411
        name = noabsuri + 1;
      } else {
        {
#line 413
        path = uri;
#line 414
        name = strchr((char const   *)uri, '#');
        }
#line 415
        if (name) {
#line 417
          *(name + 0) = (char )'\000';
#line 418
          name ++;
        } else {
#line 421
          cgiargs = (STRPTR )((void *)0);
#line 425
          if (cgiargs) {
#line 427
            *(cgiargs + 0) = (char )'\000';
#line 428
            cgiargs ++;
          }
        }
      }
#line 433
      if (path) {
        {
#line 434
        exist = (FILE *)((void *)0);
#line 439
        conv_hscuri2fileNuri(hp___0, dest_uri, dest_fname, path);
        }
#line 441
        if (hp___0->chkuri) {
          {
#line 441
          tmp___5 = hsc_get_msg_ignore(hp___0, (HSCMSG_ID )12309);
          }
#line 441
          if (! tmp___5) {
            {
#line 443
            exist = fopen((char const   */* __restrict  */)dest_fname->es_data, (char const   */* __restrict  */)"r");
            }
#line 444
            if (! exist) {
#line 446
              if (0 != (int )*(uri + 0)) {
                {
#line 446
                tmp___2 = strcmp(":", (char const   *)uri);
                }
#line 446
                if (0 != tmp___2) {
                  {
#line 447
                  hsc_msg_nouri(hp___0, dest_fname->es_data, uri, (STRPTR )((void *)0));
                  }
                }
              }
            } else {
              {
#line 449
              fclose(exist);
              }
#line 452
              if (hp___0->chkid) {
#line 452
                if (name) {
                  {
#line 453
                  doc_fname = dest_fname->es_data;
#line 455
                  tmp___4 = upstrcmp((CONSTRPTR )((hp___0->project)->document)->docname,
                                     (CONSTRPTR )doc_fname);
                  }
#line 455
                  if (tmp___4) {
                    {
#line 461
                    tmp___3 = check_document_id(hp___0->project, doc_fname, name);
                    }
                    {
#line 464
                    if (tmp___3 == 0) {
#line 464
                      goto case_0;
                    }
#line 467
                    if (tmp___3 == 1) {
#line 467
                      goto case_1;
                    }
#line 470
                    if (tmp___3 == 2) {
#line 470
                      goto case_2;
                    }
#line 477
                    goto switch_default;
                    case_0: /* CIL Label */ ;
#line 466
                    goto switch_break;
                    case_1: /* CIL Label */ 
                    {
#line 468
                    hsc_msg_unknown_id(hp___0, (STRPTR )((void *)0), name);
                    }
#line 469
                    goto switch_break;
                    case_2: /* CIL Label */ 
                    {
#line 471
                    hsc_message(hp___0, (HSCMSG_ID )12339, "no entry for document %q in project data to check %i",
                                dest_fname->es_data, name);
                    }
#line 476
                    goto switch_break;
                    switch_default: /* CIL Label */ 
                    {
#line 478
                    display_panic_message((char *)"unknown returncode", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/uri.c",
                                          (size_t )478);
                    }
#line 479
                    goto switch_break;
                    switch_break: /* CIL Label */ ;
                    }
                  } else {
                    {
#line 457
                    add_local_idref(hp___0, name);
                    }
                  }
                }
              }
            }
          }
        }
      } else
#line 487
      if (hp___0->chkid) {
#line 487
        if (name) {
          {
#line 488
          add_local_idref(hp___0, name);
          }
        }
      }
#line 492
      if (name) {
        {
#line 493
        ugly_app_estrch(dest_uri, '#');
#line 494
        ugly_app_estr(dest_uri, (CONSTRPTR )name);
        }
      } else
#line 495
      if (cgiargs) {
        {
#line 496
        ugly_app_estrch(dest_uri, '?');
#line 497
        ugly_app_estr(dest_uri, (CONSTRPTR )cgiargs);
        }
      }
      {
#line 501
      del_estr(dest_fname);
      }
    }
  }
#line 504
  return;
}
}
#line 358 "./hsclib/hscprc.h"
VOID hsc_set_chkid(HSCPRC *hp___0 , BOOL new_chkid ) ;
#line 359
VOID hsc_set_chkuri(HSCPRC *hp___0 , BOOL new_chkuri ) ;
#line 360
VOID hsc_set_compact(HSCPRC *hp___0 , BOOL new_compact ) ;
#line 361
VOID hsc_set_debug(HSCPRC *hp___0 , BOOL new_debug ) ;
#line 362
VOID hsc_set_getsize(HSCPRC *hp___0 , BOOL new_getsize ) ;
#line 364
VOID hsc_set_rplc_ent(HSCPRC *hp___0 , BOOL new_rplc_ent ) ;
#line 365
VOID hsc_set_rplc_quote(HSCPRC *hp___0 , BOOL new_rplc_quote ) ;
#line 366
BOOL hsc_set_server_dir(HSCPRC *hp___0 , STRPTR dir ) ;
#line 367
VOID hsc_set_smart_ent(HSCPRC *hp___0 , BOOL new_smart_ent ) ;
#line 368
VOID hsc_set_strip_badws(HSCPRC *hp___0 , BOOL new_strip_badws ) ;
#line 369
VOID hsc_set_strip_cmt(HSCPRC *hp___0 , BOOL new_strip_cmt ) ;
#line 370
VOID hsc_set_strip_ext(HSCPRC *hp___0 , BOOL new_strip_ext ) ;
#line 371
VOID hsc_set_nested_errors(HSCPRC *hp___0 , BOOL new_nested_errors ) ;
#line 372
VOID hsc_set_lctags(HSCPRC *hp___0 , BOOL new_lctags ) ;
#line 373
VOID hsc_set_checkext(HSCPRC *hp___0 , BOOL new_checkext ) ;
#line 374
VOID hsc_set_xhtml(HSCPRC *hp___0 , BOOL new_xhtml ) ;
#line 375
VOID hsc_set_vcss(HSCPRC *hp___0 , BOOL new_vcss ) ;
#line 378
BOOL hsc_set_destdir(HSCPRC *hp___0 , STRPTR dir ) ;
#line 379
BOOL hsc_set_reldir(HSCPRC *hp___0 , STRPTR dir ) ;
#line 380
BOOL hsc_set_iconbase(HSCPRC *hp___0 , STRPTR uri ) ;
#line 381
BOOL hsc_set_strip_tags(HSCPRC *hp___0 , STRPTR taglist ) ;
#line 382
BOOL hsc_set_filename_document(HSCPRC *hp___0 , STRPTR filename ) ;
#line 383
VOID hsc_set_quote_mode(HSCPRC *hp___0 , LONG new_mode ) ;
#line 384
VOID hsc_set_entity_mode(HSCPRC *hp___0 , LONG new_mode ) ;
#line 385
VOID hsc_set_maximum_messages(HSCPRC *hp___0 , LONG messages ) ;
#line 386
VOID hsc_set_maximum_errors(HSCPRC *hp___0 , LONG errors ) ;
#line 389
BOOL hsc_add_include_directory(HSCPRC *hp___0 , STRPTR dir ) ;
#line 396
BOOL hsc_get_debug(HSCPRC *hp___0 ) ;
#line 430
BOOL hsc_set_msg_ignore_notes(HSCPRC *hp___0 , BOOL value ) ;
#line 431
BOOL hsc_set_msg_ignore_style(HSCPRC *hp___0 , BOOL value ) ;
#line 432
BOOL hsc_set_msg_ignore_port(HSCPRC *hp___0 , BOOL value ) ;
#line 433
BOOL hsc_set_msg_ignore(HSCPRC *hp___0 , HSCMSG_ID msg_id , HSCIGN value ) ;
#line 62 "./hsc/status.h"
LONG disp_status ;
#line 64
VOID set_return_code(int newrc ) ;
#line 71
VOID status_error(STRPTR s___2 ) ;
#line 42 "./hsc/callback.h"
BOOL init_msg_browser(HSCPRC *hp___0 , STRPTR filename ) ;
#line 43
VOID del_msg_browser(HSCPRC *hp___0 ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static STRPTR arg_inpfname  =    (STRPTR )((void *)0);
#line 50 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static STRPTR arg_outfname  =    (STRPTR )((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static STRPTR arg_extension  =    (STRPTR )((void *)0);
#line 52 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static STRPTR arg_server_dir  =    (STRPTR )((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_mode  =    (BOOL )0;
#line 54 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_compact  =    (BOOL )0;
#line 55 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_getsize  =    (BOOL )0;
#line 56 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_rplc_ent  =    (BOOL )0;
#line 57 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_rplc_quote  =    (BOOL )0;
#line 58 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_smart_ent  =    (BOOL )0;
#line 59 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_strip_cmt  =    (BOOL )0;
#line 60 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_strip_badws  =    (BOOL )0;
#line 61 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_strip_ext  =    (BOOL )0;
#line 62 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_license  =    (BOOL )0;
#line 63 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_help  =    (BOOL )0;
#line 64 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_debug  =    (BOOL )0;
#line 65 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_nonesterr  =    (BOOL )0;
#line 66 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_lctags  =    (BOOL )0;
#line 67 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_xhtml  =    (BOOL )0;
#line 68 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_nvcss  =    (BOOL )0;
#line 69 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static BOOL arg_checkext  =    (BOOL )0;
#line 70 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static STRPTR arg_iconbase  =    (STRPTR )((void *)0);
#line 71 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static STRPTR arg_striptags  =    (STRPTR )((void *)0);
#line 72 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static LONG arg_entitymode  =    (LONG )-1;
#line 73 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static LONG arg_quotemode  =    (LONG )2;
#line 75 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static HSCPRC *arg_hp  =    (HSCPRC *)((void *)0);
#line 78 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static EXPSTR *fileattr_str  =    (EXPSTR *)((void *)0);
#line 80 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static ARGFILE *argf  =    (ARGFILE *)((void *)0);
#line 85 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
VOID cleanup_hsc_args(void) 
{ 


  {
  {
#line 87
  del_argfile(argf);
#line 88
  del_estr(fileattr_str);
  }
#line 89
  if ((unsigned long )msg_browser != (unsigned long )((void *)0)) {
    {
#line 91
    del_msg_browser(arg_hp);
    }
  }
#line 93
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static STRPTR arg_ignore_CB(STRPTR arg ) 
{ 
  STRPTR errmsg ;
  STRPTR arg_clone ;
  STRPTR tmp ;
  HSCPRC *hp___0 ;
  STRPTR nxt_arg ;
  char *tmp___0 ;
  HSCMSG_ID i ;
  LONG ignnum ;
  BOOL tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 104
  errmsg = (STRPTR )((void *)0);
#line 105
  tmp = ugly_strclone((CONSTRPTR )arg, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c",
                      (ULONG )105);
#line 105
  arg_clone = tmp;
#line 106
  hp___0 = arg_hp;
#line 107
  tmp___0 = strtok((char */* __restrict  */)arg_clone, (char const   */* __restrict  */)"|");
#line 107
  nxt_arg = tmp___0;
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! nxt_arg) {
#line 109
      goto while_break;
    }
    {
#line 111
    tmp___5 = upstrcmp((CONSTRPTR )nxt_arg, "all");
    }
#line 111
    if (tmp___5) {
      {
#line 117
      tmp___4 = upstrcmp((CONSTRPTR )nxt_arg, "note");
      }
#line 117
      if (tmp___4) {
        {
#line 120
        tmp___3 = upstrcmp((CONSTRPTR )nxt_arg, "style");
        }
#line 120
        if (tmp___3) {
          {
#line 123
          tmp___2 = upstrcmp((CONSTRPTR )nxt_arg, "portability");
          }
#line 123
          if (tmp___2) {
            {
#line 130
            tmp___1 = str2long(nxt_arg, & ignnum);
            }
#line 130
            if (tmp___1) {
              {
#line 133
              hsc_set_msg_ignore(hp___0, ignnum, (HSCIGN )1);
              }
            } else {
#line 131
              errmsg = (STRPTR )"unknown `ignore\'";
            }
          } else {
            {
#line 125
            hsc_set_msg_ignore_port(hp___0, (BOOL )1);
            }
          }
        } else {
          {
#line 122
          hsc_set_msg_ignore_style(hp___0, (BOOL )1);
          }
        }
      } else {
        {
#line 119
        hsc_set_msg_ignore_notes(hp___0, (BOOL )1);
        }
      }
    } else {
#line 115
      i = (HSCMSG_ID )0;
      {
#line 115
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 115
        if (! (i < 95L)) {
#line 115
          goto while_break___0;
        }
        {
#line 116
        hsc_set_msg_ignore(hp___0, i, (HSCIGN )1);
#line 115
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 137
    nxt_arg = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"|");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  ugly_freestr(arg_clone, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c",
               (ULONG )141);
#line 141
  arg_clone = (STRPTR )((void *)0);
  }
#line 143
  return (errmsg);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static STRPTR arg_enable_CB(STRPTR arg ) 
{ 
  STRPTR errmsg ;
  STRPTR arg_clone ;
  STRPTR tmp ;
  HSCPRC *hp___0 ;
  STRPTR nxt_arg ;
  char *tmp___0 ;
  HSCMSG_ID i ;
  LONG ignnum ;
  BOOL tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 154
  errmsg = (STRPTR )((void *)0);
#line 155
  tmp = ugly_strclone((CONSTRPTR )arg, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c",
                      (ULONG )155);
#line 155
  arg_clone = tmp;
#line 156
  hp___0 = arg_hp;
#line 157
  tmp___0 = strtok((char */* __restrict  */)arg_clone, (char const   */* __restrict  */)"|");
#line 157
  nxt_arg = tmp___0;
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! nxt_arg) {
#line 159
      goto while_break;
    }
    {
#line 161
    tmp___5 = upstrcmp((CONSTRPTR )nxt_arg, "all");
    }
#line 161
    if (tmp___5) {
      {
#line 167
      tmp___4 = upstrcmp((CONSTRPTR )nxt_arg, "note");
      }
#line 167
      if (tmp___4) {
        {
#line 170
        tmp___3 = upstrcmp((CONSTRPTR )nxt_arg, "style");
        }
#line 170
        if (tmp___3) {
          {
#line 173
          tmp___2 = upstrcmp((CONSTRPTR )nxt_arg, "portability");
          }
#line 173
          if (tmp___2) {
            {
#line 180
            tmp___1 = str2long(nxt_arg, & ignnum);
            }
#line 180
            if (tmp___1) {
              {
#line 183
              hsc_set_msg_ignore(hp___0, ignnum, (HSCIGN )2);
              }
            } else {
#line 181
              errmsg = (STRPTR )"unknown `enable\'";
            }
          } else {
            {
#line 175
            hsc_set_msg_ignore_port(hp___0, (BOOL )0);
            }
          }
        } else {
          {
#line 172
          hsc_set_msg_ignore_style(hp___0, (BOOL )0);
          }
        }
      } else {
        {
#line 169
        hsc_set_msg_ignore_notes(hp___0, (BOOL )0);
        }
      }
    } else {
#line 165
      i = (HSCMSG_ID )0;
      {
#line 165
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 165
        if (! (i < 95L)) {
#line 165
          goto while_break___0;
        }
        {
#line 166
        hsc_set_msg_ignore(hp___0, i, (HSCIGN )2);
#line 165
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 187
    nxt_arg = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"|");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  ugly_freestr(arg_clone, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c",
               (ULONG )191);
#line 191
  arg_clone = (STRPTR )((void *)0);
  }
#line 193
  return (errmsg);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static STRPTR arg_incdir_CB(STRPTR arg ) 
{ 
  HSCPRC *hp___0 ;

  {
  {
#line 203
  hp___0 = arg_hp;
#line 204
  hsc_add_include_directory(hp___0, arg);
  }
#line 205
  return ((STRPTR )((void *)0));
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static STRPTR arg_mode_CB(STRPTR arg ) 
{ 
  STRPTR errmsg ;
  size_t mode ;
  LONG tmp ;
  HSCPRC *hp___0 ;
  HSCMSG_ID i ;
  LONG ignnum ;
  BOOL tmp___0 ;

  {
  {
#line 217
  errmsg = (STRPTR )((void *)0);
#line 218
  tmp = strenum((CONSTRPTR )arg, "pedantic|normal|relaxed", (char )'|', (BYTE )1);
#line 218
  mode = (size_t )tmp;
#line 219
  hp___0 = arg_hp;
  }
#line 223
  if (! mode) {
#line 224
    errmsg = (STRPTR )"unknown mode";
  } else
#line 225
  if (mode == 1UL) {
#line 230
    i = (HSCMSG_ID )0;
    {
#line 230
    while (1) {
      while_continue: /* CIL Label */ ;
#line 230
      if (! (i < 95L)) {
#line 230
        goto while_break;
      }
      {
#line 231
      hsc_set_msg_ignore(hp___0, i, (HSCIGN )0);
#line 230
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 234
    hsc_set_msg_ignore_notes(hp___0, (BOOL )0);
#line 235
    hsc_set_msg_ignore_style(hp___0, (BOOL )0);
#line 236
    hsc_set_msg_ignore_port(hp___0, (BOOL )0);
    }
  } else
#line 237
  if (mode == 2UL) {
    {
#line 240
    arg_mode_CB((STRPTR )"pedantic");
#line 241
    arg_ignore_CB((STRPTR )"note");
#line 242
    hsc_set_msg_ignore(hp___0, (HSCMSG_ID )4105, (HSCIGN )1);
#line 243
    hsc_set_msg_ignore(hp___0, (HSCMSG_ID )8240, (HSCIGN )1);
    }
  } else
#line 244
  if (mode == 3UL) {
    {
#line 246
    arg_mode_CB((STRPTR )"normal");
#line 247
    arg_ignore_CB((STRPTR )"style");
#line 248
    arg_ignore_CB((STRPTR )"portability");
#line 249
    arg_ignore_CB((STRPTR )"jerk");
#line 250
    hsc_set_msg_ignore(hp___0, (HSCMSG_ID )16399, (HSCIGN )1);
#line 251
    hsc_set_msg_ignore(hp___0, (HSCMSG_ID )12325, (HSCIGN )1);
#line 252
    hsc_set_msg_ignore(hp___0, (HSCMSG_ID )16396, (HSCIGN )1);
#line 253
    hsc_set_msg_ignore(hp___0, (HSCMSG_ID )12302, (HSCIGN )1);
    }
  } else {
    {
#line 258
    tmp___0 = str2long(arg, & ignnum);
    }
#line 258
    if (tmp___0) {
      {
#line 261
      hsc_set_msg_ignore(hp___0, ignnum, (HSCIGN )1);
      }
    } else {
#line 259
      errmsg = (STRPTR )"illegal argument";
    }
  }
#line 264
  return (errmsg);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static STRPTR arg_status_CB(STRPTR arg ) 
{ 
  STRPTR errmsg ;
  STRPTR argstr ;
  STRPTR tmp ;
  STRPTR argold ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 275
  errmsg = (STRPTR )((void *)0);
#line 276
  tmp = ugly_strclone((CONSTRPTR )arg, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c",
                      (ULONG )276);
#line 276
  argstr = tmp;
#line 277
  argold = argstr;
#line 283
  arg = strtok((char */* __restrict  */)argstr, (char const   */* __restrict  */)"|");
  }
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! arg) {
#line 284
      goto while_break;
    }
    {
#line 285
    tmp___4 = upstrcmp((CONSTRPTR )arg, "quiet");
    }
#line 285
    if (tmp___4) {
      {
#line 287
      tmp___3 = upstrcmp((CONSTRPTR )arg, "line");
      }
#line 287
      if (tmp___3) {
        {
#line 289
        tmp___2 = upstrcmp((CONSTRPTR )arg, "version");
        }
#line 289
        if (tmp___2) {
          {
#line 291
          tmp___1 = upstrcmp((CONSTRPTR )arg, "verbose");
          }
#line 291
          if (tmp___1) {
            {
#line 293
            tmp___0 = upstrcmp((CONSTRPTR )arg, "full");
            }
#line 293
            if (tmp___0) {
#line 296
              errmsg = (STRPTR )"illegal argument";
            } else {
#line 294
              disp_status = (LONG )-1;
            }
          } else {
#line 292
            disp_status |= (long )(1 << 2);
          }
        } else {
#line 290
          disp_status |= (long )(1 << 1);
        }
      } else {
#line 288
        disp_status |= 1L;
      }
    } else {
#line 286
      disp_status = (LONG )0;
    }
    {
#line 298
    arg = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"|");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 300
  ugly_freestr(argold, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c",
               (ULONG )300);
#line 300
  argold = (STRPTR )((void *)0);
  }
#line 302
  return (errmsg);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static VOID set_dest_attribs(HSCPRC *hp___0 , STRPTR destpath , STRPTR reldestpath ,
                             STRPTR destname ) 
{ 


  {
  {
#line 313
  ugly_set_estr(fileattr_str, "<$define HSC.DOCUMENT.NAME:string/c=\"");
  }
#line 314
  if (destname) {
    {
#line 315
    ugly_app_estr(fileattr_str, (CONSTRPTR )destname);
    }
  }
  {
#line 316
  ugly_app_estr(fileattr_str, "\">\n<$define HSC.DOCUMENT.PATH:string/c=\"");
  }
#line 317
  if (reldestpath) {
    {
#line 318
    ugly_app_estr(fileattr_str, (CONSTRPTR )reldestpath);
    }
  }
  {
#line 319
  ugly_app_estr(fileattr_str, "\">\n<$define HSC.DESTPATH:string/c=\"");
  }
#line 320
  if (destpath) {
    {
#line 321
    ugly_app_estr(fileattr_str, (CONSTRPTR )destpath);
    }
  }
  {
#line 322
  ugly_app_estr(fileattr_str, "\">\n<$define HSC.DOCUMENT.URI:string/c=\"");
  }
#line 323
  if (destname) {
    {
#line 324
    ugly_app_estr(fileattr_str, (CONSTRPTR )reldestpath);
    }
  }
#line 325
  if (destname) {
    {
#line 326
    ugly_app_estr(fileattr_str, (CONSTRPTR )destname);
    }
  }
  {
#line 327
  ugly_app_estr(fileattr_str, "\">\n");
  }
#line 328
  return;
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static VOID set_source_attribs(HSCPRC *hp___0 , STRPTR sourcepath , STRPTR sourcename ) 
{ 


  {
  {
#line 333
  ugly_app_estr(fileattr_str, "<$define HSC.SOURCE.NAME:string/c=\"");
  }
#line 334
  if (sourcename) {
    {
#line 335
    ugly_app_estr(fileattr_str, (CONSTRPTR )sourcename);
    }
  }
  {
#line 336
  ugly_app_estr(fileattr_str, "\">\n<$define HSC.SOURCE.PATH:string/c=\"");
  }
#line 337
  if (sourcename) {
    {
#line 338
    ugly_app_estr(fileattr_str, (CONSTRPTR )sourcepath);
    }
  }
  {
#line 339
  ugly_app_estr(fileattr_str, "\">\n<$define HSC.SOURCE.FILE:string/c=\"");
  }
#line 340
  if (sourcename) {
    {
#line 341
    ugly_app_estr(fileattr_str, (CONSTRPTR )sourcepath);
    }
  }
#line 342
  if (sourcename) {
    {
#line 343
    ugly_app_estr(fileattr_str, (CONSTRPTR )sourcename);
    }
  }
  {
#line 344
  ugly_app_estr(fileattr_str, "\">\n");
  }
#line 345
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static VOID set_global_attribs(HSCPRC *hp___0 ) 
{ 
  STRPTR emode ;

  {
#line 352
  if (hp___0->xhtml) {
    {
#line 353
    ugly_app_estr(fileattr_str, "<$define HSC.OPTS.XHTML:bool/c=\"1\">\n");
    }
  }
  {
#line 354
  ugly_app_estr(fileattr_str, "<$define HSC.OPTS.ENTITYMODE:string/c=\"");
  }
  {
#line 356
  if (hp___0->entitymode == 2L) {
#line 356
    goto case_2;
  }
#line 359
  if (hp___0->entitymode == 3L) {
#line 359
    goto case_3;
  }
#line 362
  if (hp___0->entitymode == 4L) {
#line 362
    goto case_4;
  }
#line 365
  if (hp___0->entitymode == 5L) {
#line 365
    goto case_5;
  }
#line 369
  goto switch_default;
  case_2: /* CIL Label */ 
#line 357
  emode = (STRPTR )"replace";
#line 358
  goto switch_break;
  case_3: /* CIL Label */ 
#line 360
  emode = (STRPTR )"numeric";
#line 361
  goto switch_break;
  case_4: /* CIL Label */ 
#line 363
  emode = (STRPTR )"symbolic";
#line 364
  goto switch_break;
  case_5: /* CIL Label */ 
#line 366
  emode = (STRPTR )"utf-8";
#line 367
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 370
  emode = (STRPTR )"keep";
#line 371
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 373
  ugly_app_estr(fileattr_str, (CONSTRPTR )emode);
#line 374
  ugly_app_estr(fileattr_str, "\">\n");
  }
#line 375
  return;
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
static VOID define_file_attribs(HSCPRC *hp___0 ) 
{ 


  {
  {
#line 381
  hsc_include_string(hp___0, (STRPTR )"[define destattr]", fileattr_str->es_data,
                     (ULONG )((1 << 3) | (1 << 5)));
  }
#line 387
  return;
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
BOOL user_defines_ok(HSCPRC *hp___0 ) 
{ 
  DLNODE *nd ;
  EXPSTR *defbuf ;
  EXPSTR *tmp ;
  STRPTR defarg ;
  char quote_needed ;
  BOOL single_quote ;
  BOOL double_quote ;
  STRPTR scanarg ;

  {
  {
#line 399
  define_file_attribs(hp___0);
  }
#line 401
  if (define_list) {
#line 401
    if (define_list->first) {
      {
#line 402
      nd = define_list->first;
#line 403
      tmp = ugly_init_estr((size_t )64);
#line 403
      defbuf = tmp;
      }
      {
#line 405
      while (1) {
        while_continue: /* CIL Label */ ;
#line 405
        if (! nd) {
#line 405
          goto while_break;
        }
        {
#line 406
        defarg = (STRPTR )nd->data;
#line 410
        ugly_set_estr(defbuf, "<$define ");
        }
        {
#line 413
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 414
          ugly_app_estrch(defbuf, (int )*(defarg + 0));
#line 415
          defarg ++;
          }
#line 413
          if (*(defarg + 0)) {
#line 413
            if ((int )*(defarg + 0) != 61) {
#line 413
              if ((int )*(defarg + 0) != 47) {
#line 413
                if (! ((int )*(defarg + 0) != 58)) {
#line 413
                  goto while_break___0;
                }
              } else {
#line 413
                goto while_break___0;
              }
            } else {
#line 413
              goto while_break___0;
            }
          } else {
#line 413
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 420
        if ((int )*(defarg + 0) != 58) {
          {
#line 421
          ugly_app_estr(defbuf, ":string");
          }
        }
        {
#line 424
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 424
          if (*(defarg + 0)) {
#line 424
            if (! ((int )*(defarg + 0) != 61)) {
#line 424
              goto while_break___1;
            }
          } else {
#line 424
            goto while_break___1;
          }
          {
#line 425
          ugly_app_estrch(defbuf, (int )*(defarg + 0));
#line 426
          defarg ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 430
        if ((int )*(defarg + 0) == 61) {
          {
#line 431
          quote_needed = (char)0;
#line 434
          ugly_app_estrch(defbuf, (int )*(defarg + 0));
#line 435
          defarg ++;
          }
#line 438
          if ((int )*(defarg + 0) != 34) {
#line 438
            if ((int )*(defarg + 0) != 39) {
#line 439
              single_quote = (BOOL )0;
#line 440
              double_quote = (BOOL )0;
#line 441
              scanarg = defarg;
              {
#line 444
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 444
                if (! *(scanarg + 0)) {
#line 444
                  goto while_break___2;
                }
#line 445
                if ((int )*(scanarg + 0) == 34) {
#line 446
                  double_quote = (BOOL )1;
                } else
#line 447
                if ((int )*(scanarg + 0) == 39) {
#line 448
                  single_quote = (BOOL )1;
                }
#line 449
                scanarg ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 453
              if (! double_quote) {
#line 454
                quote_needed = (char )'\"';
              } else
#line 455
              if (! single_quote) {
#line 456
                quote_needed = (char )'\'';
              } else {
                {
#line 458
                display_panic_message((char *)"both quotes in value", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c",
                                      (size_t )458);
                }
              }
            }
          }
#line 462
          if (quote_needed) {
            {
#line 463
            ugly_app_estrch(defbuf, (int )quote_needed);
            }
          }
          {
#line 466
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 466
            if (! *(defarg + 0)) {
#line 466
              goto while_break___3;
            }
            {
#line 467
            ugly_app_estrch(defbuf, (int )*(defarg + 0));
#line 468
            defarg ++;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 472
          if (quote_needed) {
            {
#line 473
            ugly_app_estrch(defbuf, (int )quote_needed);
            }
          }
        }
        {
#line 478
        ugly_app_estrch(defbuf, '>');
#line 482
        hsc_include_string(hp___0, (STRPTR )"DEFINE", defbuf->es_data, (ULONG )((1 << 3) | (1 << 5)));
#line 484
        nd = nd->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 487
      del_estr(defbuf);
      }
    }
  }
#line 494
  return ((BOOL )(return_code < 1));
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c"
BOOL args_ok(HSCPRC *hp___0 , int argc , char **argv ) 
{ 
  BOOL ok ;
  DLLIST *ignore_list ;
  EXPSTR *destdir ;
  EXPSTR *tmp ;
  EXPSTR *rel_destdir ;
  EXPSTR *tmp___0 ;
  EXPSTR *kack_name ;
  EXPSTR *tmp___1 ;
  struct arglist *hsc_args ;
  LONG maximum_number_of_errors ;
  long tmp___2 ;
  LONG maximum_number_of_messages ;
  long tmp___3 ;
  BOOL use_stdout ;
  BOOL any_input_passed ;
  STRPTR argfiles[2] ;
  BOOL tmp___4 ;
  BOOL tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  BOOL fnsux ;
  BOOL tmp___9 ;
  UBYTE lastch ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  EXPSTR *kack_destdir ;
  EXPSTR *tmp___12 ;
  EXPSTR *kack_reldir ;
  EXPSTR *tmp___13 ;
  STRPTR inp_reldir ;
  STRPTR out_reldir ;
  STRPTR ou2_reldir ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  STRPTR tmp_name ;
  size_t tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  EXPSTR *tmp_fname ;
  EXPSTR *tmp___21 ;
  STRPTR compilation_unit ;

  {
  {
#line 508
  ignore_list = (DLLIST *)((void *)0);
#line 509
  tmp = ugly_init_estr((size_t )32);
#line 509
  destdir = tmp;
#line 510
  tmp___0 = ugly_init_estr((size_t )32);
#line 510
  rel_destdir = tmp___0;
#line 511
  tmp___1 = ugly_init_estr((size_t )0);
#line 511
  kack_name = tmp___1;
#line 513
  tmp___2 = strtol((char const   */* __restrict  */)"20", (char **/* __restrict  */)((char **)((void *)0)),
                   10);
#line 513
  maximum_number_of_errors = tmp___2;
#line 514
  tmp___3 = strtol((char const   */* __restrict  */)"40", (char **/* __restrict  */)((char **)((void *)0)),
                   10);
#line 514
  maximum_number_of_messages = tmp___3;
#line 516
  arg_hp = hp___0;
#line 517
  arg_mode_CB((STRPTR )"normal");
#line 520
  hsc_args = prepare_args((STRPTR )"HSC_ARGS", "FROM/M", & incfile, "include- and input file(s)",
                          "TO/K", & arg_outfname, "output file (default: stdout)",
                          "PRJFILE/T/K", & prjfilename, "project file (default: none)",
                          "PREFSFILE/T/K", & prefsfilename, "syntax definition file",
                          "MSGFILE=MF/T/K", & msgfilename, "message file (default: stderr)",
                          "MSGFORMAT/T/K", & msg_format, "how to display messages",
                          "MSGBROWSER/T/K", & msg_browser, "message browser to use (default:none)",
                          "MAXERR/N/K", & maximum_number_of_errors, "max. number of errors (default: 20)",
                          "MAXMSG/N/K", & maximum_number_of_messages, "max. number of messages (default: 40)",
                          "EXTENSION/T/K", & arg_extension, "output file extension (default: html)",
                          "DEFINE=DEF/T/K/M", & define_list, "define global attribute",
                          "IGNORE=IGN/K/M/$", & arg_ignore_CB, & ignore_list, "ignore message number or class",
                          "ENABLE=ENA/K/M/$", & arg_enable_CB, & ignore_list, "enable message number or class",
                          "MSGMODE/E/K/$", & arg_mode_CB, "pedantic|normal|relaxed",
                          & arg_mode, "mode for syntax check (pedantic|normal|relaxed)",
                          "QUOTESTYLE=QS/E/K", "keep|double|single|none", & arg_quotemode,
                          "defines how quotes appear (keep|double|single|none)", "ENTITYSTYLE=ES/E/K",
                          "keep|replace|numeric|symbolic|utf-8", & arg_entitymode,
                          "set character entity rendering (keep|replace|numeric|symbolic|utf-8)",
                          "INCLUDEDIR=IDIR/K/M/$", & arg_incdir_CB, & ignore_list,
                          "add include directory", "COMPACT=CO/S", & arg_compact,
                          "strip useless white spaces", "GETSIZE/S", & arg_getsize,
                          "get width and height of images", "RPLCENT=RE/S", & arg_rplc_ent,
                          "replace special characters", "RPLCQUOTE=RQ/S", & arg_rplc_quote,
                          "replace quotes in text with `&quot;\'", "STRIPBADWS/S",
                          & arg_strip_badws, "strip bad whitespace", "STRIPCOMMENT=SC/S",
                          & arg_strip_cmt, "strip SGML comments", "STRIPEXTERNAL=SX/S",
                          & arg_strip_ext, "strip tags with external URIs", "STRIPTAGS=ST/K",
                          & arg_striptags, "tags to be stripped", "ICONBASE/T/K",
                          & arg_iconbase, "base URI for icon entities", "SERVERDIR/T/K",
                          & arg_server_dir, "base directory for server relative URIs",
                          "STATUS/E/K/$", & arg_status_CB, "quiet|line|version|verbose|full",
                          & disp_status, "status message (quiet|line|version|verbose|full)",
                          "NONESTERR=NNE/S", & arg_nonesterr, "don\'t show \"previous call\" tracebacks on error",
                          "LOWERCASETAGS=LCT/S", & arg_lctags, "force all tags and attributes to lowercase",
                          "XHTML/S", & arg_xhtml, "use XHTML mode (implies: LCT QS=double)",
                          "NOVALIDATECSS=NVCS/S", & arg_nvcss, "don\'t validate CSS in STYLE attributes",
                          "CHECKEXTERNAL=CKX/S", & arg_checkext, "check external HTTP links",
                          "-DEBUG/S", & arg_debug, "enable debugging output if enabled at compile-time",
                          "HELP=?=-h=--help/S", & arg_help, "display this text", "LICENSE/S",
                          & arg_license, "display license", (void *)0);
#line 638
  del_dllist(ignore_list);
#line 640
  ok = (BOOL )((unsigned long )hsc_args != (unsigned long )((void *)0));
  }
#line 643
  if (ok) {
    {
#line 644
    use_stdout = (BOOL )0;
#line 645
    any_input_passed = (BOOL )0;
#line 646
    argfiles[0] = (STRPTR )"hsc.options";
#line 646
    argfiles[1] = (STRPTR )((void *)0);
#line 649
    argf = new_argfilev(argfiles);
#line 651
    tmp___4 = set_args_file(argf, hsc_args);
    }
#line 651
    if (tmp___4) {
      {
#line 651
      tmp___5 = set_args(argc, argv, hsc_args);
      }
#line 651
      if (tmp___5) {
#line 651
        tmp___6 = 1;
      } else {
#line 651
        tmp___6 = 0;
      }
    } else {
#line 651
      tmp___6 = 0;
    }
#line 651
    ok = (BOOL )tmp___6;
#line 656
    if (incfile) {
#line 656
      if (incfile->first) {
#line 656
        tmp___7 = 1;
      } else {
#line 656
        tmp___7 = 0;
      }
    } else {
#line 656
      tmp___7 = 0;
    }
#line 656
    any_input_passed = (BOOL )tmp___7;
#line 657
    if (! arg_help) {
#line 657
      if (any_input_passed) {
#line 657
        tmp___8 = 1;
      } else {
#line 657
        tmp___8 = 0;
      }
    } else {
#line 657
      tmp___8 = 0;
    }
#line 657
    ok = (BOOL )((int )ok & tmp___8);
#line 659
    if (arg_license) {
      {
#line 661
      fprintf_prginfo(stderr);
#line 662
      show_license();
#line 663
      set_return_code(0);
      }
    } else
#line 664
    if (! ok) {
#line 665
      if (arg_help) {
        {
#line 667
        fprintf_prginfo(stderr);
#line 668
        fprintf_arghelp(stderr, hsc_args);
        }
      } else
#line 665
      if (! any_input_passed) {
        {
#line 667
        fprintf_prginfo(stderr);
#line 668
        fprintf_arghelp(stderr, hsc_args);
        }
      }
      {
#line 670
      set_return_code(0);
      }
    } else {
      {
#line 672
      fnsux = (BOOL )0;
#line 675
      hsc_set_debug(hp___0, arg_debug);
#line 678
      tmp___9 = hsc_get_debug(hp___0);
      }
#line 678
      if (tmp___9) {
#line 679
        disp_status = (LONG )(1 << 2);
      }
#line 682
      if (! arg_extension) {
#line 683
        arg_extension = (STRPTR )"html";
      }
#line 686
      if (! prjfilename) {
        {
#line 687
        hsc_set_msg_ignore(hp___0, (HSCMSG_ID )12339, (HSCIGN )1);
        }
      }
#line 690
      arg_inpfname = (STRPTR )((void *)0);
#line 691
      if (incfile->first) {
        {
#line 693
        arg_inpfname = (STRPTR )(incfile->last)->data;
#line 695
        ugly_set_estr(inpfilename, (CONSTRPTR )arg_inpfname);
#line 699
        get_fpath(rel_destdir, (CONSTRPTR )arg_inpfname);
#line 705
        del_dlnode(incfile, incfile->last);
        }
      }
#line 731
      if (arg_outfname) {
#line 736
        if (arg_outfname) {
          {
#line 737
          lastch = (UBYTE )0;
#line 751
          tmp___11 = strlen((char const   *)arg_outfname);
          }
#line 751
          if (tmp___11) {
            {
#line 752
            tmp___10 = strlen((char const   *)arg_outfname);
#line 752
            lastch = (UBYTE )*(arg_outfname + (tmp___10 - 1UL));
            }
          }
          {
#line 762
          tmp___19 = strchr("/", (int )lastch);
          }
#line 762
          if (tmp___19) {
            {
#line 764
            ugly_set_estr(destdir, (CONSTRPTR )arg_outfname);
#line 765
            arg_outfname = (STRPTR )((void *)0);
            }
          } else
#line 768
          if (arg_inpfname) {
            {
#line 771
            tmp___12 = ugly_init_estr((size_t )0);
#line 771
            kack_destdir = tmp___12;
#line 772
            tmp___13 = ugly_init_estr((size_t )0);
#line 772
            kack_reldir = tmp___13;
#line 773
            inp_reldir = rel_destdir->es_data;
#line 774
            out_reldir = (STRPTR )((void *)0);
#line 775
            ou2_reldir = (STRPTR )((void *)0);
#line 777
            get_fname(kack_name, (CONSTRPTR )arg_outfname);
#line 778
            get_fpath(kack_destdir, (CONSTRPTR )arg_outfname);
#line 783
            out_reldir = kack_destdir->es_data;
#line 784
            ou2_reldir = out_reldir;
#line 785
            tmp___14 = strlen((char const   *)out_reldir);
#line 785
            tmp___15 = strlen((char const   *)inp_reldir);
#line 785
            out_reldir += tmp___14 - tmp___15;
            }
#line 788
            if (*(out_reldir + 0)) {
              {
#line 791
              while (1) {
                while_continue: /* CIL Label */ ;
#line 791
                if ((unsigned long )out_reldir != (unsigned long )ou2_reldir) {
                  {
#line 791
                  tmp___16 = strchr("/", (int )*(out_reldir + 0));
                  }
#line 791
                  if (tmp___16) {
#line 791
                    goto while_break;
                  }
                } else {
#line 791
                  goto while_break;
                }
#line 793
                out_reldir --;
              }
              while_break: /* CIL Label */ ;
              }
#line 796
              if ((unsigned long )out_reldir != (unsigned long )ou2_reldir) {
#line 797
                out_reldir ++;
              }
            }
            {
#line 805
            tmp___18 = upstrcmp((CONSTRPTR )inp_reldir, (CONSTRPTR )out_reldir);
            }
#line 805
            if (tmp___18) {
              {
#line 839
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unmatched corresponding relative directories:\n  input  `%s\'\n  output `%s\'\n",
                      inp_reldir, out_reldir);
#line 842
              ok = (BOOL )0;
              }
            } else {
              {
#line 807
              tmp_name = (STRPTR )((void *)0);
#line 810
              tmp___17 = strlen((char const   *)out_reldir);
#line 810
              get_left_estr(kack_destdir, kack_destdir, (kack_destdir->es_len - 1UL) - tmp___17);
#line 814
              ugly_set_estr(kack_reldir, (CONSTRPTR )inp_reldir);
#line 826
              estrcpy(destdir, kack_destdir);
#line 827
              estrcpy(rel_destdir, kack_reldir);
#line 830
              tmp_name = ugly_strclone((CONSTRPTR )kack_name->es_data, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c",
                                       (ULONG )830);
#line 831
              estrcpy(kack_name, kack_destdir);
#line 832
              estrcat(kack_name, kack_reldir);
#line 833
              ugly_app_estr(kack_name, (CONSTRPTR )tmp_name);
#line 834
              ugly_freestr(tmp_name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/args.c",
                           (ULONG )834);
#line 834
              tmp_name = (STRPTR )((void *)0);
#line 836
              arg_outfname = kack_name->es_data;
              }
            }
            {
#line 846
            del_estr(kack_reldir);
#line 847
            del_estr(kack_destdir);
            }
          }
        }
#line 850
        if (arg_outfname) {
          {
#line 852
          outfilename = ugly_init_estr((size_t )32);
#line 853
          ugly_set_estr(outfilename, (CONSTRPTR )arg_outfname);
          }
        } else {
          {
#line 861
          outfilename = ugly_init_estr((size_t )32);
#line 862
          link_fname(outfilename, destdir->es_data, arg_inpfname);
#line 864
          tmp___20 = strcmp((char const   *)arg_extension, ".");
          }
#line 864
          if (tmp___20) {
            {
#line 865
            set_fext(outfilename, (CONSTRPTR )arg_extension);
            }
          }
        }
#line 872
        if (fnsux) {
          {
#line 874
          status_error((STRPTR )"unable to evaluate output filename\n");
#line 875
          arg_outfname = (STRPTR )((void *)0);
#line 876
          ok = (BOOL )0;
          }
        }
      } else {
#line 880
        use_stdout = (BOOL )1;
      }
#line 883
      if (! ok) {
        {
#line 884
        set_return_code(1);
        }
      }
    }
#line 887
    if (ok) {
#line 889
      if (arg_server_dir) {
        {
#line 890
        hsc_set_server_dir(hp___0, arg_server_dir);
        }
      }
#line 893
      if (arg_iconbase) {
        {
#line 894
        hsc_set_iconbase(hp___0, arg_iconbase);
        }
      }
#line 897
      if (! use_stdout) {
        {
#line 898
        hsc_set_filename_document(hp___0, outfilename->es_data);
        }
      }
    }
#line 902
    if (! ok) {
      {
#line 906
      pargerr();
#line 907
      arg_outfname = (STRPTR )((void *)0);
#line 908
      set_return_code(1);
      }
    } else {
      {
#line 910
      tmp___21 = ugly_init_estr((size_t )32);
#line 910
      tmp_fname = tmp___21;
#line 912
      fileattr_str = ugly_init_estr((size_t )64);
      }
#line 915
      if (outfilename) {
        {
#line 916
        get_fname(tmp_fname, (CONSTRPTR )outfilename->es_data);
        }
      }
      {
#line 917
      set_dest_attribs(hp___0, destdir->es_data, rel_destdir->es_data, tmp_fname->es_data);
      }
#line 922
      if (inpfilename) {
        {
#line 923
        get_fname(tmp_fname, (CONSTRPTR )inpfilename->es_data);
        }
      } else {
        {
#line 925
        ugly_clr_estr(tmp_fname);
        }
      }
      {
#line 927
      set_source_attribs(hp___0, rel_destdir->es_data, tmp_fname->es_data);
#line 973
      del_estr(tmp_fname);
      }
    }
#line 979
    if (ok) {
      {
#line 980
      hsc_set_chkid(hp___0, (BOOL )1);
#line 981
      hsc_set_chkuri(hp___0, (BOOL )1);
#line 982
      hsc_set_compact(hp___0, arg_compact);
#line 983
      hsc_set_debug(hp___0, arg_debug);
#line 984
      hsc_set_getsize(hp___0, arg_getsize);
#line 985
      hsc_set_rplc_ent(hp___0, arg_rplc_ent);
#line 986
      hsc_set_rplc_quote(hp___0, arg_rplc_quote);
#line 987
      hsc_set_smart_ent(hp___0, arg_smart_ent);
#line 988
      hsc_set_strip_badws(hp___0, arg_strip_badws);
#line 989
      hsc_set_strip_cmt(hp___0, arg_strip_cmt);
#line 990
      hsc_set_strip_ext(hp___0, arg_strip_ext);
#line 991
      hsc_set_nested_errors(hp___0, (BOOL )(! arg_nonesterr));
#line 992
      hsc_set_strip_tags(hp___0, arg_striptags);
#line 993
      hsc_set_lctags(hp___0, arg_lctags);
#line 994
      hsc_set_checkext(hp___0, arg_checkext);
      }
#line 995
      if (arg_xhtml) {
#line 995
        if (arg_nvcss) {
          {
#line 996
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: cannot disable CSS checking in XHTML mode!\n");
          }
        } else {
          {
#line 998
          hsc_set_vcss(hp___0, (BOOL )(! arg_nvcss));
          }
        }
      } else {
        {
#line 998
        hsc_set_vcss(hp___0, (BOOL )(! arg_nvcss));
        }
      }
#line 999
      if (arg_xhtml) {
#line 999
        if (2L != arg_quotemode) {
          {
#line 1000
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: XHTML only allows double quotes, ignoring QUOTESTYLE option!\n");
          }
        } else {
          {
#line 1002
          hsc_set_quote_mode(hp___0, arg_quotemode);
          }
        }
      } else {
        {
#line 1002
        hsc_set_quote_mode(hp___0, arg_quotemode);
        }
      }
      {
#line 1003
      hsc_set_xhtml(hp___0, arg_xhtml);
#line 1004
      hsc_set_entity_mode(hp___0, arg_entitymode);
      }
#line 1008
      if (maximum_number_of_messages) {
        {
#line 1009
        hsc_set_maximum_messages(hp___0, maximum_number_of_messages);
        }
      }
#line 1010
      if (maximum_number_of_errors) {
        {
#line 1011
        hsc_set_maximum_errors(hp___0, maximum_number_of_errors);
        }
      }
      {
#line 1014
      hsc_set_destdir(hp___0, destdir->es_data);
#line 1015
      hsc_set_reldir(hp___0, rel_destdir->es_data);
      }
#line 1017
      if ((unsigned long )msg_browser != (unsigned long )((void *)0)) {
#line 1018
        compilation_unit = inpfilename->es_data;
#line 1020
        if ((unsigned long )compilation_unit == (unsigned long )((void *)0)) {
#line 1021
          compilation_unit = (STRPTR )"<stdin>";
        }
        {
#line 1023
        init_msg_browser(hp___0, compilation_unit);
        }
      }
      {
#line 1027
      set_global_attribs(hp___0);
      }
    }
    {
#line 1030
    free_args(hsc_args);
    }
  }
  {
#line 1038
  del_estr(destdir);
#line 1039
  del_estr(rel_destdir);
#line 1040
  del_estr(kack_name);
  }
#line 1042
  return (ok);
}
}
#line 159 "./hsclib/attrib.h"
STRPTR get_vartext_byname(DLLIST *varlist , STRPTR name ) ;
#line 30 "./hsclib/lstatus.h"
VOID hsc_status_misc(HSCPRC *hp___0 , STRPTR s___2 ) ;
#line 31
VOID hsc_status_file_begin(HSCPRC *hp___0 , STRPTR filename ) ;
#line 30 "./hsclib/deftag.h"
BOOL def_tag_args(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 31
HSCTAG *def_tag_name(HSCPRC *hp___0 , BOOL *start_tag ) ;
#line 47 "./hsclib/include.h"
BOOL hsc_include_file(HSCPRC *hp___0 , STRPTR filename , ULONG optn ) ;
#line 30 "./hsclib/tag_a.h"
BOOL handle_anchor(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 31
BOOL handle_canchor(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 36 "./hsclib/tag_hsc.h"
BOOL handle_hsc_comment(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 38
BOOL handle_hsc_defent(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 39
BOOL handle_hsc_defstyle(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 40
BOOL handle_hsc_deficon(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 41
BOOL handle_hsc_define(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 42
BOOL handle_hsc_deftag(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 43
BOOL handle_hsc_depend(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 44
BOOL handle_hsc_exec(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 45
BOOL handle_hsc_export(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 46
BOOL handle_hsc_insert(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 47
BOOL handle_hsc_include(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 48
BOOL handle_hsc_lazy(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 49
BOOL handle_hsc_let(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 50
BOOL handle_hsc_message(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 51
BOOL handle_hsc_verbatim(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 52
BOOL handle_hsc_source(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 53
BOOL handle_hsc_stripws(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 54
BOOL handle_hsc_insert_expression(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 33 "./hsclib/tag_macro.h"
BOOL handle_hsc_macro(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 34
BOOL handle_hsc_content(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 35 "./hsclib/tag_misc.h"
BOOL handle_sgml_comment(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 37
BOOL handle_base(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 38
BOOL handle_blink(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 40
BOOL handle_heading(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 41
BOOL handle_img(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 42
BOOL handle_pre(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 43
BOOL handle_end_pre(HSCPRC *hp___0 , HSCTAG *tag ) ;
#line 3 "./hsclib/entities.c"
static struct HSCENTITY HSCInternalEntities[156]  = 
#line 3 "./hsclib/entities.c"
  {      {(STRPTR )"amp", (unsigned short)0, (BOOL )0}, 
        {(STRPTR )"lt", (unsigned short)0, (BOOL )0}, 
        {(STRPTR )"gt", (unsigned short)0, (BOOL )0}, 
        {(STRPTR )"quot", (unsigned short)0, (BOOL )0}, 
        {(STRPTR )"apos", (unsigned short)0, (BOOL )0}, 
        {(STRPTR )"OElig", (unsigned short)338, (BOOL )0}, 
        {(STRPTR )"oelig", (unsigned short)339, (BOOL )0}, 
        {(STRPTR )"Scaron", (unsigned short)352, (BOOL )0}, 
        {(STRPTR )"scaron", (unsigned short)353, (BOOL )0}, 
        {(STRPTR )"Yuml", (unsigned short)376, (BOOL )0}, 
        {(STRPTR )"circ", (unsigned short)710, (BOOL )0}, 
        {(STRPTR )"tilde", (unsigned short)732, (BOOL )0}, 
        {(STRPTR )"ensp", (unsigned short)8194, (BOOL )0}, 
        {(STRPTR )"emsp", (unsigned short)8195, (BOOL )0}, 
        {(STRPTR )"thinsp", (unsigned short)8201, (BOOL )0}, 
        {(STRPTR )"zwnj", (unsigned short)8204, (BOOL )0}, 
        {(STRPTR )"zwj", (unsigned short)8205, (BOOL )0}, 
        {(STRPTR )"lrm", (unsigned short)8206, (BOOL )0}, 
        {(STRPTR )"rlm", (unsigned short)8207, (BOOL )0}, 
        {(STRPTR )"ndash", (unsigned short)8211, (BOOL )0}, 
        {(STRPTR )"mdash", (unsigned short)8212, (BOOL )0}, 
        {(STRPTR )"lsquo", (unsigned short)8216, (BOOL )0}, 
        {(STRPTR )"rsquo", (unsigned short)8217, (BOOL )0}, 
        {(STRPTR )"sbquo", (unsigned short)8218, (BOOL )0}, 
        {(STRPTR )"ldquo", (unsigned short)8220, (BOOL )0}, 
        {(STRPTR )"rdquo", (unsigned short)8221, (BOOL )0}, 
        {(STRPTR )"bdquo", (unsigned short)8222, (BOOL )0}, 
        {(STRPTR )"dagger", (unsigned short)8224, (BOOL )0}, 
        {(STRPTR )"Dagger", (unsigned short)8225, (BOOL )0}, 
        {(STRPTR )"permil", (unsigned short)8240, (BOOL )0}, 
        {(STRPTR )"lsaquo", (unsigned short)8249, (BOOL )0}, 
        {(STRPTR )"rsaquo", (unsigned short)8250, (BOOL )0}, 
        {(STRPTR )"euro", (unsigned short)8364, (BOOL )0}, 
        {(STRPTR )"fnof", (unsigned short)402, (BOOL )0}, 
        {(STRPTR )"Alpha", (unsigned short)913, (BOOL )0}, 
        {(STRPTR )"Beta", (unsigned short)914, (BOOL )0}, 
        {(STRPTR )"Gamma", (unsigned short)915, (BOOL )0}, 
        {(STRPTR )"Delta", (unsigned short)916, (BOOL )0}, 
        {(STRPTR )"Epsilon", (unsigned short)917, (BOOL )0}, 
        {(STRPTR )"Zeta", (unsigned short)918, (BOOL )0}, 
        {(STRPTR )"Eta", (unsigned short)919, (BOOL )0}, 
        {(STRPTR )"Theta", (unsigned short)920, (BOOL )0}, 
        {(STRPTR )"Iota", (unsigned short)921, (BOOL )0}, 
        {(STRPTR )"Kappa", (unsigned short)922, (BOOL )0}, 
        {(STRPTR )"Lambda", (unsigned short)923, (BOOL )0}, 
        {(STRPTR )"Mu", (unsigned short)924, (BOOL )0}, 
        {(STRPTR )"Nu", (unsigned short)925, (BOOL )0}, 
        {(STRPTR )"Xi", (unsigned short)926, (BOOL )0}, 
        {(STRPTR )"Omicron", (unsigned short)927, (BOOL )0}, 
        {(STRPTR )"Pi", (unsigned short)928, (BOOL )0}, 
        {(STRPTR )"Rho", (unsigned short)929, (BOOL )0}, 
        {(STRPTR )"Sigma", (unsigned short)931, (BOOL )0}, 
        {(STRPTR )"Tau", (unsigned short)932, (BOOL )0}, 
        {(STRPTR )"Upsilon", (unsigned short)933, (BOOL )0}, 
        {(STRPTR )"Phi", (unsigned short)934, (BOOL )0}, 
        {(STRPTR )"Chi", (unsigned short)935, (BOOL )0}, 
        {(STRPTR )"Psi", (unsigned short)936, (BOOL )0}, 
        {(STRPTR )"Omega", (unsigned short)937, (BOOL )0}, 
        {(STRPTR )"alpha", (unsigned short)945, (BOOL )0}, 
        {(STRPTR )"beta", (unsigned short)946, (BOOL )0}, 
        {(STRPTR )"gamma", (unsigned short)947, (BOOL )0}, 
        {(STRPTR )"delta", (unsigned short)948, (BOOL )0}, 
        {(STRPTR )"epsilon", (unsigned short)949, (BOOL )0}, 
        {(STRPTR )"zeta", (unsigned short)950, (BOOL )0}, 
        {(STRPTR )"eta", (unsigned short)951, (BOOL )0}, 
        {(STRPTR )"theta", (unsigned short)952, (BOOL )0}, 
        {(STRPTR )"iota", (unsigned short)953, (BOOL )0}, 
        {(STRPTR )"kappa", (unsigned short)954, (BOOL )0}, 
        {(STRPTR )"lambda", (unsigned short)955, (BOOL )0}, 
        {(STRPTR )"mu", (unsigned short)956, (BOOL )0}, 
        {(STRPTR )"nu", (unsigned short)957, (BOOL )0}, 
        {(STRPTR )"xi", (unsigned short)958, (BOOL )0}, 
        {(STRPTR )"omicron", (unsigned short)959, (BOOL )0}, 
        {(STRPTR )"pi", (unsigned short)960, (BOOL )0}, 
        {(STRPTR )"rho", (unsigned short)961, (BOOL )0}, 
        {(STRPTR )"sigmaf", (unsigned short)962, (BOOL )0}, 
        {(STRPTR )"sigma", (unsigned short)963, (BOOL )0}, 
        {(STRPTR )"tau", (unsigned short)964, (BOOL )0}, 
        {(STRPTR )"upsilon", (unsigned short)965, (BOOL )0}, 
        {(STRPTR )"phi", (unsigned short)966, (BOOL )0}, 
        {(STRPTR )"chi", (unsigned short)967, (BOOL )0}, 
        {(STRPTR )"psi", (unsigned short)968, (BOOL )0}, 
        {(STRPTR )"omega", (unsigned short)969, (BOOL )0}, 
        {(STRPTR )"thetasym", (unsigned short)977, (BOOL )0}, 
        {(STRPTR )"upsih", (unsigned short)978, (BOOL )0}, 
        {(STRPTR )"piv", (unsigned short)982, (BOOL )0}, 
        {(STRPTR )"bull", (unsigned short)8226, (BOOL )0}, 
        {(STRPTR )"hellip", (unsigned short)8230, (BOOL )0}, 
        {(STRPTR )"prime", (unsigned short)8242, (BOOL )0}, 
        {(STRPTR )"Prime", (unsigned short)8243, (BOOL )0}, 
        {(STRPTR )"oline", (unsigned short)8254, (BOOL )0}, 
        {(STRPTR )"frasl", (unsigned short)8260, (BOOL )0}, 
        {(STRPTR )"weierp", (unsigned short)8472, (BOOL )0}, 
        {(STRPTR )"image", (unsigned short)8465, (BOOL )0}, 
        {(STRPTR )"real", (unsigned short)8476, (BOOL )0}, 
        {(STRPTR )"trade", (unsigned short)8482, (BOOL )0}, 
        {(STRPTR )"alefsym", (unsigned short)8501, (BOOL )0}, 
        {(STRPTR )"larr", (unsigned short)8592, (BOOL )0}, 
        {(STRPTR )"uarr", (unsigned short)8593, (BOOL )0}, 
        {(STRPTR )"darr", (unsigned short)8595, (BOOL )0}, 
        {(STRPTR )"harr", (unsigned short)8596, (BOOL )0}, 
        {(STRPTR )"crarr", (unsigned short)8629, (BOOL )0}, 
        {(STRPTR )"lArr", (unsigned short)8656, (BOOL )0}, 
        {(STRPTR )"uArr", (unsigned short)8657, (BOOL )0}, 
        {(STRPTR )"rArr", (unsigned short)8658, (BOOL )0}, 
        {(STRPTR )"dArr", (unsigned short)8659, (BOOL )0}, 
        {(STRPTR )"hArr", (unsigned short)8660, (BOOL )0}, 
        {(STRPTR )"forall", (unsigned short)8704, (BOOL )0}, 
        {(STRPTR )"part", (unsigned short)8706, (BOOL )0}, 
        {(STRPTR )"exist", (unsigned short)8707, (BOOL )0}, 
        {(STRPTR )"empty", (unsigned short)8709, (BOOL )0}, 
        {(STRPTR )"nabla", (unsigned short)8711, (BOOL )0}, 
        {(STRPTR )"isin", (unsigned short)8712, (BOOL )0}, 
        {(STRPTR )"notin", (unsigned short)8713, (BOOL )0}, 
        {(STRPTR )"ni", (unsigned short)8715, (BOOL )0}, 
        {(STRPTR )"prod", (unsigned short)8719, (BOOL )0}, 
        {(STRPTR )"sum", (unsigned short)8721, (BOOL )0}, 
        {(STRPTR )"minus", (unsigned short)8722, (BOOL )0}, 
        {(STRPTR )"lowast", (unsigned short)8727, (BOOL )0}, 
        {(STRPTR )"radic", (unsigned short)8730, (BOOL )0}, 
        {(STRPTR )"prop", (unsigned short)8733, (BOOL )0}, 
        {(STRPTR )"infin", (unsigned short)8734, (BOOL )0}, 
        {(STRPTR )"ang", (unsigned short)8736, (BOOL )0}, 
        {(STRPTR )"and", (unsigned short)8743, (BOOL )0}, 
        {(STRPTR )"or", (unsigned short)8744, (BOOL )0}, 
        {(STRPTR )"cap", (unsigned short)8745, (BOOL )0}, 
        {(STRPTR )"cup", (unsigned short)8746, (BOOL )0}, 
        {(STRPTR )"int", (unsigned short)8747, (BOOL )0}, 
        {(STRPTR )"there4", (unsigned short)8756, (BOOL )0}, 
        {(STRPTR )"sim", (unsigned short)8764, (BOOL )0}, 
        {(STRPTR )"cong", (unsigned short)8773, (BOOL )0}, 
        {(STRPTR )"asymp", (unsigned short)8776, (BOOL )0}, 
        {(STRPTR )"ne", (unsigned short)8800, (BOOL )0}, 
        {(STRPTR )"equiv", (unsigned short)8801, (BOOL )0}, 
        {(STRPTR )"le", (unsigned short)8804, (BOOL )0}, 
        {(STRPTR )"ge", (unsigned short)8805, (BOOL )0}, 
        {(STRPTR )"sub", (unsigned short)8834, (BOOL )0}, 
        {(STRPTR )"sup", (unsigned short)8835, (BOOL )0}, 
        {(STRPTR )"nsub", (unsigned short)8836, (BOOL )0}, 
        {(STRPTR )"sube", (unsigned short)8838, (BOOL )0}, 
        {(STRPTR )"supe", (unsigned short)8839, (BOOL )0}, 
        {(STRPTR )"oplus", (unsigned short)8853, (BOOL )0}, 
        {(STRPTR )"otimes", (unsigned short)8855, (BOOL )0}, 
        {(STRPTR )"perp", (unsigned short)8869, (BOOL )0}, 
        {(STRPTR )"sdot", (unsigned short)8901, (BOOL )0}, 
        {(STRPTR )"lceil", (unsigned short)8968, (BOOL )0}, 
        {(STRPTR )"rceil", (unsigned short)8969, (BOOL )0}, 
        {(STRPTR )"lfloor", (unsigned short)8970, (BOOL )0}, 
        {(STRPTR )"rfloor", (unsigned short)8971, (BOOL )0}, 
        {(STRPTR )"lang", (unsigned short)9001, (BOOL )0}, 
        {(STRPTR )"rang", (unsigned short)9002, (BOOL )0}, 
        {(STRPTR )"loz", (unsigned short)9674, (BOOL )0}, 
        {(STRPTR )"spades", (unsigned short)9824, (BOOL )0}, 
        {(STRPTR )"clubs", (unsigned short)9827, (BOOL )0}, 
        {(STRPTR )"hearts", (unsigned short)9829, (BOOL )0}, 
        {(STRPTR )"diams", (unsigned short)9830, (BOOL )0}};
#line 122 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/linit.c"
static STRPTR find_prefs_fname(HSCPRC *hp___0 , EXPSTR *cfgfn ) 
{ 
  STRPTR prefs_fname ;
  STRPTR paths[7] ;
  STRPTR path ;
  UBYTE path_ctr ;
  FILE *cfgf ;
  EXPSTR *hscpathstr ;
  EXPSTR *tmp ;
  EXPSTR *homepathstr ;
  EXPSTR *tmp___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;

  {
  {
#line 124
  prefs_fname = (STRPTR )((void *)0);
#line 125
  paths[0] = (STRPTR )"";
#line 125
  paths[1] = (STRPTR )"";
#line 125
  paths[2] = (STRPTR )"";
#line 125
  paths[3] = (STRPTR )"/usr/local/lib/";
#line 125
  paths[4] = (STRPTR )"/usr/lib/";
#line 125
  paths[5] = (STRPTR )((void *)0);
#line 125
  paths[6] = (STRPTR )((void *)0);
#line 128
  path = (STRPTR )((void *)0);
#line 129
  path_ctr = (UBYTE )0;
#line 130
  cfgf = (FILE *)((void *)0);
#line 131
  tmp = ugly_init_estr((size_t )32);
#line 131
  hscpathstr = tmp;
#line 132
  tmp___0 = ugly_init_estr((size_t )32);
#line 132
  homepathstr = tmp___0;
#line 135
  tmp___1 = link_envfname(hscpathstr, (STRPTR )"HSCPATH", (STRPTR )((void *)0), (STRPTR )((void *)0));
  }
#line 135
  if (tmp___1) {
#line 137
    paths[1] = hscpathstr->es_data;
  }
  {
#line 141
  tmp___2 = link_envfname(homepathstr, (STRPTR )"HOME", (STRPTR )"lib", (STRPTR )((void *)0));
  }
#line 141
  if (tmp___2) {
#line 143
    paths[2] = homepathstr->es_data;
  }
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    path = paths[path_ctr];
#line 149
    if (path) {
      {
#line 150
      ugly_set_estr(cfgfn, (CONSTRPTR )path);
#line 151
      ugly_app_estr(cfgfn, "hsc.prefs");
#line 155
      cfgf = fopen((char const   */* __restrict  */)cfgfn->es_data, (char const   */* __restrict  */)"r");
      }
    }
#line 157
    path_ctr = (UBYTE )((int )path_ctr + 1);
#line 147
    if (path) {
#line 147
      if (! (! cfgf)) {
#line 147
        goto while_break;
      }
    } else {
#line 147
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if (cfgf) {
    {
#line 161
    prefs_fname = cfgfn->es_data;
#line 162
    fclose(cfgf);
    }
  }
  {
#line 165
  del_estr(homepathstr);
#line 166
  del_estr(hscpathstr);
  }
#line 168
  return (prefs_fname);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/linit.c"
BOOL hsc_read_prefs(HSCPRC *hp___0 , STRPTR prefs_fname ) 
{ 
  BOOL ok ;
  EXPSTR *prefs_name_buffer ;
  EXPSTR *tmp ;
  EXPSTR *msg ;
  EXPSTR *tmp___0 ;

  {
  {
#line 178
  ok = (BOOL )0;
#line 179
  tmp = ugly_init_estr((size_t )32);
#line 179
  prefs_name_buffer = tmp;
  }
#line 182
  if (! prefs_fname) {
    {
#line 183
    prefs_fname = find_prefs_fname(hp___0, prefs_name_buffer);
    }
  }
#line 186
  if (prefs_fname) {
    {
#line 189
    hsc_status_file_begin(hp___0, prefs_fname);
#line 190
    ok = hsc_include_file(hp___0, prefs_fname, (ULONG )((1 << 3) | (1 << 5)));
    }
#line 194
    if (ok) {
      {
#line 195
      tmp___0 = ugly_init_estr((size_t )32);
#line 195
      msg = tmp___0;
#line 196
      ugly_set_estr(msg, (CONSTRPTR )prefs_fname);
#line 197
      ugly_app_estr(msg, ": preferences read");
#line 198
      hsc_status_misc(hp___0, msg->es_data);
#line 199
      del_estr(msg);
      }
    }
  } else {
    {
#line 201
    hsc_message(hp___0, (HSCMSG_ID )61480, "can not open preferences file");
    }
  }
  {
#line 204
  del_estr(prefs_name_buffer);
  }
#line 206
  return (ok);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/linit.c"
VOID hsc_set_tagCB(HSCPRC *hp___0 , STRPTR name , BOOL (*op_hnd)(HSCPRC *inpf , HSCTAG *tag ) ,
                   BOOL (*cl_hnd)(HSCPRC *inpf , HSCTAG *tag ) ) 
{ 
  HSCTAG *tag ;
  HSCTAG *tmp ;

  {
  {
#line 217
  tmp = find_strtag(hp___0->deftag, name);
#line 217
  tag = tmp;
  }
#line 219
  if (tag) {
#line 219
    if (! (tag->option & (unsigned long )(1 << 11))) {
#line 223
      tag->o_handle = op_hnd;
#line 224
      tag->c_handle = cl_hnd;
    }
  }
#line 226
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/linit.c"
BOOL hsc_init_tagsNattr(HSCPRC *hp___0 ) 
{ 
  BYTE i ;
  BOOL ok ;
  BOOL open_tag ;
  HSCTAG *tag ;
  STRPTR hsc_prefs[24] ;
  STRPTR hsc_attribs[20] ;
  STRARR infname[20] ;
  BOOL tmp ;
  int tmp___0 ;
  HSCATTR *tmp___1 ;

  {
#line 238
  i = (BYTE )0;
#line 239
  ok = (BOOL )1;
#line 244
  hsc_prefs[0] = (STRPTR )"* /SKIPLF /SPECIAL>";
#line 244
  hsc_prefs[1] = (STRPTR )"| /SPECIAL>";
#line 244
  hsc_prefs[2] = (STRPTR )"( /SPECIAL>";
#line 244
  hsc_prefs[3] = (STRPTR )"$content /SKIPLF>";
#line 244
  hsc_prefs[4] = (STRPTR )"$defent /SKIPLF NAME:string RPLC:string NUM:num PREFNUM:bool NONSTD:bool>";
#line 244
  hsc_prefs[5] = (STRPTR )"$defstyle /SKIPLF NAME:string/r VAL:string>";
#line 244
  hsc_prefs[6] = (STRPTR )"$deficon /SKIPLF NAME:string/r>";
#line 244
  hsc_prefs[7] = (STRPTR )"$define /SKIPLF /SPECIAL>";
#line 244
  hsc_prefs[8] = (STRPTR )"$deftag /SKIPLF /SPECIAL>";
#line 244
  hsc_prefs[9] = (STRPTR )"$depend /SKIPLF ON:string/r FILE:bool>";
#line 244
  hsc_prefs[10] = (STRPTR )"$else /SKIPLF /MBI=\"$if\">";
#line 244
  hsc_prefs[11] = (STRPTR )"$elseif /SKIPLF /MBI=\"$if\"COND:bool>";
#line 244
  hsc_prefs[12] = (STRPTR )"$message /SKIPLF TEXT:string/r CLASS:enum(\"note|warning|error|fatal\")=\'note\'>";
#line 244
  hsc_prefs[13] = (STRPTR )"$exec /SKIPLF COMMAND:string/r REMOVE:enum(\"on|off|auto\")=\"auto\" ATTRIBUTE:string INCLUDE:bool FILE:string  PRE:bool SOURCE:bool TEMPORARY:bool INDENT:num TABSIZE:num=\"4\" >";
#line 244
  hsc_prefs[14] = (STRPTR )"$export /SKIPLF FILE:string/r DATA:string/r APPEND:bool>";
#line 244
  hsc_prefs[15] = (STRPTR )"$if /SKIPLF /CLOSE COND:bool>";
#line 244
  hsc_prefs[16] = (STRPTR )"$insert /OBSOLETE TEXT:string TIME:bool FORMAT:string>";
#line 244
  hsc_prefs[17] = (STRPTR )"$include /SKIPLF FILE:string/r  PRE:bool SOURCE:bool TEMPORARY:bool INDENT:num TABSIZE:num=\"4\" >";
#line 244
  hsc_prefs[18] = (STRPTR )"$varlist /SKIPLF /SPECIAL>";
#line 244
  hsc_prefs[19] = (STRPTR )"$let /SKIPLF /SPECIAL>";
#line 244
  hsc_prefs[20] = (STRPTR )"$macro /SKIPLF /SPECIAL>";
#line 244
  hsc_prefs[21] = (STRPTR )"$source /SKIPLF PRE:bool>";
#line 244
  hsc_prefs[22] = (STRPTR )"$StripWS TYPE:enum(\"both|prev|succ|none\")=\"both\">";
#line 244
  hsc_prefs[23] = (STRPTR )((void *)0);
#line 278
  hsc_attribs[0] = (STRPTR )"hsc.System:string/c";
#line 278
  hsc_attribs[1] = (STRPTR )"Unix";
#line 278
  hsc_attribs[2] = (STRPTR )"HSC.ANCHOR:string";
#line 278
  hsc_attribs[3] = (STRPTR )"this is a feature, not a bug";
#line 278
  hsc_attribs[4] = (STRPTR )"HSC.CONTENT:string/c";
#line 278
  hsc_attribs[5] = (STRPTR )((void *)0);
#line 278
  hsc_attribs[6] = (STRPTR )"HSC.EXEC.RESULT:num=\"0\"";
#line 278
  hsc_attribs[7] = (STRPTR )((void *)0);
#line 278
  hsc_attribs[8] = (STRPTR )"HSC.FORMAT.FILESIZE:string";
#line 278
  hsc_attribs[9] = (STRPTR )"%a%u";
#line 278
  hsc_attribs[10] = (STRPTR )"HSC.FORMAT.TIME:string";
#line 278
  hsc_attribs[11] = (STRPTR )"%d-%b-%Y, %H:%M";
#line 278
  hsc_attribs[12] = (STRPTR )"HSC.LF:string>";
#line 278
  hsc_attribs[13] = (STRPTR )((void *)0);
#line 278
  hsc_attribs[14] = (STRPTR )"HSC.VERSION:num/c=0";
#line 278
  hsc_attribs[15] = (STRPTR )((void *)0);
#line 278
  hsc_attribs[16] = (STRPTR )"HSC.REVISION:num/c=934";
#line 278
  hsc_attribs[17] = (STRPTR )((void *)0);
#line 278
  hsc_attribs[18] = (STRPTR )((void *)0);
#line 278
  hsc_attribs[19] = (STRPTR )((void *)0);
#line 299
  i = (BYTE )0;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! hp___0->fatal) {
#line 300
      if (! hsc_prefs[i]) {
#line 300
        goto while_break;
      }
    } else {
#line 300
      goto while_break;
    }
    {
#line 303
    sprintf((char */* __restrict  */)(infname), (char const   */* __restrict  */)"::s::init%3d",
            (int )i);
#line 304
    hp___0->inpf = infopen_str((CONSTRPTR )(infname), (CONSTRPTR )hsc_prefs[i], (size_t )60);
    }
#line 306
    if (hp___0->inpf) {
      {
#line 307
      tag = def_tag_name(hp___0, & open_tag);
      }
#line 308
      if (tag) {
        {
#line 308
        tmp = def_tag_args(hp___0, tag);
        }
#line 308
        if (tmp) {
#line 308
          tmp___0 = 1;
        } else {
#line 308
          tmp___0 = 0;
        }
      } else {
#line 308
        tmp___0 = 0;
      }
#line 308
      ok = (BOOL )tmp___0;
#line 309
      if (hp___0->inpf) {
        {
#line 309
        infclose1(hp___0->inpf);
#line 309
        hp___0->inpf = (INFILE *)((void *)0);
        }
      }
    }
#line 311
    i = (BYTE )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  i = (BYTE )0;
  {
#line 316
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 316
    if (! hp___0->fatal) {
#line 316
      if (! hsc_attribs[i]) {
#line 316
        goto while_break___0;
      }
    } else {
#line 316
      goto while_break___0;
    }
    {
#line 317
    define_attr_by_text(hp___0, hsc_attribs[i], hsc_attribs[(int )i + 1], (ULONG )0);
#line 318
    i = (BYTE )((int )i + 2);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 322
  tmp___1 = find_varname(hp___0->defattr, (STRPTR )"HSC.LF");
#line 322
  set_vartext(tmp___1, (STRPTR )"\n");
  }
#line 325
  if (ok) {
    {
#line 326
    hsc_set_tagCB(hp___0, (STRPTR )"*", & handle_hsc_comment, (BOOL (*)(HSCPRC *inpf ,
                                                                        HSCTAG *tag ))((void *)0));
#line 327
    hsc_set_tagCB(hp___0, (STRPTR )"$content", & handle_hsc_content, (BOOL (*)(HSCPRC *inpf ,
                                                                               HSCTAG *tag ))((void *)0));
#line 328
    hsc_set_tagCB(hp___0, (STRPTR )"$defstyle", & handle_hsc_defstyle, (BOOL (*)(HSCPRC *inpf ,
                                                                                 HSCTAG *tag ))((void *)0));
#line 329
    hsc_set_tagCB(hp___0, (STRPTR )"$defent", & handle_hsc_defent, (BOOL (*)(HSCPRC *inpf ,
                                                                             HSCTAG *tag ))((void *)0));
#line 330
    hsc_set_tagCB(hp___0, (STRPTR )"$deficon", & handle_hsc_deficon, (BOOL (*)(HSCPRC *inpf ,
                                                                               HSCTAG *tag ))((void *)0));
#line 331
    hsc_set_tagCB(hp___0, (STRPTR )"$define", & handle_hsc_define, (BOOL (*)(HSCPRC *inpf ,
                                                                             HSCTAG *tag ))((void *)0));
#line 332
    hsc_set_tagCB(hp___0, (STRPTR )"$deftag", & handle_hsc_deftag, (BOOL (*)(HSCPRC *inpf ,
                                                                             HSCTAG *tag ))((void *)0));
#line 333
    hsc_set_tagCB(hp___0, (STRPTR )"$depend", & handle_hsc_depend, (BOOL (*)(HSCPRC *inpf ,
                                                                             HSCTAG *tag ))((void *)0));
#line 334
    hsc_set_tagCB(hp___0, (STRPTR )"$else", & handle_hsc_else, (BOOL (*)(HSCPRC *inpf ,
                                                                         HSCTAG *tag ))((void *)0));
#line 335
    hsc_set_tagCB(hp___0, (STRPTR )"$elseif", & handle_hsc_elseif, (BOOL (*)(HSCPRC *inpf ,
                                                                             HSCTAG *tag ))((void *)0));
#line 336
    hsc_set_tagCB(hp___0, (STRPTR )"$exec", & handle_hsc_exec, (BOOL (*)(HSCPRC *inpf ,
                                                                         HSCTAG *tag ))((void *)0));
#line 337
    hsc_set_tagCB(hp___0, (STRPTR )"$export", & handle_hsc_export, (BOOL (*)(HSCPRC *inpf ,
                                                                             HSCTAG *tag ))((void *)0));
#line 338
    hsc_set_tagCB(hp___0, (STRPTR )"$if", & handle_hsc_if, & handle_hsc_cif);
#line 339
    hsc_set_tagCB(hp___0, (STRPTR )"$include", & handle_hsc_include, (BOOL (*)(HSCPRC *inpf ,
                                                                               HSCTAG *tag ))((void *)0));
#line 340
    hsc_set_tagCB(hp___0, (STRPTR )"$insert", & handle_hsc_insert, (BOOL (*)(HSCPRC *inpf ,
                                                                             HSCTAG *tag ))((void *)0));
#line 341
    hsc_set_tagCB(hp___0, (STRPTR )"(", & handle_hsc_insert_expression, (BOOL (*)(HSCPRC *inpf ,
                                                                                  HSCTAG *tag ))((void *)0));
#line 342
    hsc_set_tagCB(hp___0, (STRPTR )"*", & handle_hsc_comment, (BOOL (*)(HSCPRC *inpf ,
                                                                        HSCTAG *tag ))((void *)0));
#line 343
    hsc_set_tagCB(hp___0, (STRPTR )"$varlist", & handle_hsc_lazy, (BOOL (*)(HSCPRC *inpf ,
                                                                            HSCTAG *tag ))((void *)0));
#line 344
    hsc_set_tagCB(hp___0, (STRPTR )"$let", & handle_hsc_let, (BOOL (*)(HSCPRC *inpf ,
                                                                       HSCTAG *tag ))((void *)0));
#line 345
    hsc_set_tagCB(hp___0, (STRPTR )"$macro", & handle_hsc_macro, (BOOL (*)(HSCPRC *inpf ,
                                                                           HSCTAG *tag ))((void *)0));
#line 346
    hsc_set_tagCB(hp___0, (STRPTR )"$message", & handle_hsc_message, (BOOL (*)(HSCPRC *inpf ,
                                                                               HSCTAG *tag ))((void *)0));
#line 347
    hsc_set_tagCB(hp___0, (STRPTR )"|", & handle_hsc_verbatim, (BOOL (*)(HSCPRC *inpf ,
                                                                         HSCTAG *tag ))((void *)0));
#line 348
    hsc_set_tagCB(hp___0, (STRPTR )"$source", & handle_hsc_source, (BOOL (*)(HSCPRC *inpf ,
                                                                             HSCTAG *tag ))((void *)0));
#line 349
    hsc_set_tagCB(hp___0, (STRPTR )"$StripWS", & handle_hsc_stripws, (BOOL (*)(HSCPRC *inpf ,
                                                                               HSCTAG *tag ))((void *)0));
    }
  }
#line 355
  return (ok);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/linit.c"
BOOL hsc_init_basicEntities(HSCPRC *hp___0 ) 
{ 
  unsigned int i ;

  {
#line 367
  i = 0U;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! ((unsigned long )i < sizeof(HSCInternalEntities) / sizeof(HSCInternalEntities[0]))) {
#line 367
      goto while_break;
    }
    {
#line 368
    add_ent(hp___0->defent, HSCInternalEntities[i].name, (char )'\000', (short )HSCInternalEntities[i].numeric,
            (char )HSCInternalEntities[i].prefnum);
#line 367
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((BOOL )1);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/linit.c"
BOOL hsc_assign_tagCBs(HSCPRC *hp___0 ) 
{ 


  {
  {
#line 385
  hsc_set_tagCB(hp___0, (STRPTR )"!", & handle_sgml_comment, (BOOL (*)(HSCPRC *inpf ,
                                                                       HSCTAG *tag ))((void *)0));
#line 386
  hsc_set_tagCB(hp___0, (STRPTR )"A", & handle_anchor, & handle_canchor);
#line 387
  hsc_set_tagCB(hp___0, (STRPTR )"BASE", & handle_base, (BOOL (*)(HSCPRC *inpf , HSCTAG *tag ))((void *)0));
#line 388
  hsc_set_tagCB(hp___0, (STRPTR )"BLINK", & handle_blink, (BOOL (*)(HSCPRC *inpf ,
                                                                    HSCTAG *tag ))((void *)0));
#line 389
  hsc_set_tagCB(hp___0, (STRPTR )"H1", & handle_heading, (BOOL (*)(HSCPRC *inpf ,
                                                                   HSCTAG *tag ))((void *)0));
#line 390
  hsc_set_tagCB(hp___0, (STRPTR )"H2", & handle_heading, (BOOL (*)(HSCPRC *inpf ,
                                                                   HSCTAG *tag ))((void *)0));
#line 391
  hsc_set_tagCB(hp___0, (STRPTR )"H3", & handle_heading, (BOOL (*)(HSCPRC *inpf ,
                                                                   HSCTAG *tag ))((void *)0));
#line 392
  hsc_set_tagCB(hp___0, (STRPTR )"H4", & handle_heading, (BOOL (*)(HSCPRC *inpf ,
                                                                   HSCTAG *tag ))((void *)0));
#line 393
  hsc_set_tagCB(hp___0, (STRPTR )"H5", & handle_heading, (BOOL (*)(HSCPRC *inpf ,
                                                                   HSCTAG *tag ))((void *)0));
#line 394
  hsc_set_tagCB(hp___0, (STRPTR )"H6", & handle_heading, (BOOL (*)(HSCPRC *inpf ,
                                                                   HSCTAG *tag ))((void *)0));
#line 395
  hsc_set_tagCB(hp___0, (STRPTR )"IMG", & handle_img, (BOOL (*)(HSCPRC *inpf , HSCTAG *tag ))((void *)0));
#line 396
  hsc_set_tagCB(hp___0, (STRPTR )"PRE", & handle_pre, & handle_end_pre);
  }
#line 398
  return ((BOOL )1);
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/linit.c"
BOOL hsc_init_hscprc(HSCPRC *hp___0 , STRPTR prefs_fname ) 
{ 
  BOOL ok ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;

  {
  {
#line 411
  ok = (BOOL )0;
#line 413
  tmp = hsc_init_basicEntities(hp___0);
  }
#line 413
  if (tmp) {
    {
#line 413
    tmp___0 = hsc_read_prefs(hp___0, prefs_fname);
    }
#line 413
    if (tmp___0) {
      {
#line 413
      tmp___1 = hsc_assign_tagCBs(hp___0);
      }
#line 413
      if (tmp___1) {
#line 419
        ok = (BOOL )1;
      }
    }
  }
  {
#line 457
  hp___0->click_here_str = get_vartext_byname(hp___0->defattr, (STRPTR )"HSC.CLICK-HERE");
#line 459
  hp___0->color_names = get_vartext_byname(hp___0->defattr, (STRPTR )"HSC.COLOR-NAMES");
  }
#line 462
  return (ok);
}
}
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 162 "./hsclib/attrib.h"
BOOL get_varbool(HSCATTR *attr ) ;
#line 39 "./hsclib/lmessage.h"
VOID hsc_msg_unkn_attr_ref(HSCPRC *hp___0 , STRPTR attr ) ;
#line 37 "./hsclib/input.h"
BOOL hsc_normch(int ch ) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static VOID check_integer(HSCPRC *hp___0 , HSCATTR *dest , STRPTR value ) ;
#line 105 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static VOID err_op(HSCPRC *hp___0 , STRPTR opstr ) 
{ 


  {
  {
#line 106
  hsc_message(hp___0, (HSCMSG_ID )16449, "unknown binary operator %q", opstr);
  }
#line 107
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static BOOL eval_boolstr(STRPTR s___2 ) 
{ 


  {
#line 113
  if (*(s___2 + 0)) {
#line 114
    return ((BOOL )1);
  } else {
#line 116
    return ((BOOL )0);
  }
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static VOID check_brackets(HSCPRC *hp___0 ) 
{ 
  BOOL tmp ;

  {
  {
#line 121
  tmp = parse_wd(hp___0, (STRPTR )"(");
  }
#line 121
  if (tmp) {
    {
#line 122
    parse_wd(hp___0, (STRPTR )")");
    }
  }
#line 123
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static EXPSTR *gettimestr(HSCPRC *hp___0 , struct tm  const  *time___0 ) 
{ 
  STRPTR timefmt ;
  STRPTR tmp ;
  EXPSTR *timebuf___2 ;
  EXPSTR *tmp___0 ;
  BOOL strftrc ;
  size_t i ;
  size_t tmp___1 ;

  {
  {
#line 130
  tmp = get_vartext_byname(hp___0->defattr, (STRPTR )"HSC.FORMAT.TIME");
#line 130
  timefmt = tmp;
#line 131
  tmp___0 = ugly_init_estr((size_t )20);
#line 131
  timebuf___2 = tmp___0;
#line 132
  strftrc = (BOOL )0;
  }
#line 136
  if (! timefmt) {
#line 137
    timefmt = (STRPTR )"%d-%b-%Y, %H:%M";
  }
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! hp___0->fatal) {
#line 139
      if (! (! strftrc)) {
#line 139
        goto while_break;
      }
    } else {
#line 139
      goto while_break;
    }
#line 141
    i = (size_t )0;
    {
#line 141
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 141
      if (! (i < 20UL)) {
#line 141
        goto while_break___0;
      }
      {
#line 142
      ugly_app_estrch(timebuf___2, '.');
#line 141
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 147
    tmp___1 = strftime((char */* __restrict  */)timebuf___2->es_data, timebuf___2->es_len - 1UL,
                       (char const   */* __restrict  */)timefmt, (struct tm  const  */* __restrict  */)time___0);
#line 147
    strftrc = (BOOL )tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  if (! strftrc) {
    {
#line 152
    del_estr(timebuf___2);
#line 153
    timebuf___2 = (EXPSTR *)((void *)0);
    }
  }
#line 156
  return (timebuf___2);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static STRPTR getfilesize(HSCPRC *hp___0 , EXPSTR *dest , STRPTR uri ) 
{ 
  STRPTR filesizestr ;
  FILE *file ;
  LONG filesize ;
  LONG filesize_k ;
  LONG filesize_m ;
  LONG filesize_g ;
  LONG filesize_auto ;
  EXPSTR *efilename ;
  EXPSTR *tmp ;
  STRPTR filename ;
  STRPTR sizeunit ;
  STRPTR s___2 ;
  STRPTR tmp___0 ;
  int *tmp___1 ;
  STRPTR tmp___2 ;
  STRPTR tmp___3 ;
  STRPTR tmp___4 ;
  STRPTR tmp___5 ;
  STRPTR tmp___6 ;

  {
  {
#line 173
  filesizestr = (STRPTR )((void *)0);
#line 174
  file = (FILE *)((void *)0);
#line 175
  filesize = (LONG )0;
#line 176
  filesize_k = (LONG )0;
#line 177
  filesize_m = (LONG )0;
#line 178
  filesize_g = (LONG )0;
#line 179
  filesize_auto = (LONG )0;
#line 180
  tmp = ugly_init_estr((size_t )32);
#line 180
  efilename = tmp;
#line 181
  filename = (STRPTR )((void *)0);
#line 182
  sizeunit = (STRPTR )"";
#line 183
  tmp___0 = get_vartext_byname(hp___0->defattr, (STRPTR )"HSC.FORMAT.FILESIZE");
#line 183
  s___2 = tmp___0;
#line 186
  conv_hscuri2file(hp___0, efilename, uri);
#line 187
  filename = efilename->es_data;
#line 190
  tmp___1 = __errno_location();
#line 190
  *tmp___1 = 0;
#line 191
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 192
  if (file) {
    {
#line 194
    fseek(file, 0L, 2);
#line 195
    filesize = ftell(file);
#line 196
    fclose(file);
#line 199
    filesize_k = (filesize + 512L) >> 10;
#line 200
    filesize_m = (filesize_k + 512L) >> 10;
#line 201
    filesize_g = (filesize_m + 512L) >> 10;
    }
#line 204
    if (filesize_g > 10L) {
#line 205
      filesize_auto = filesize_g;
#line 206
      sizeunit = (STRPTR )"G";
    } else
#line 207
    if (filesize_m > 10L) {
#line 208
      filesize_auto = filesize_m;
#line 209
      sizeunit = (STRPTR )"M";
    } else
#line 210
    if (filesize_k > 10L) {
#line 211
      filesize_auto = filesize_k;
#line 212
      sizeunit = (STRPTR )"K";
    } else {
#line 214
      filesize_auto = filesize;
#line 215
      sizeunit = (STRPTR )"";
    }
  } else {
    {
#line 219
    filesize = (LONG )0;
#line 220
    filesize_k = (LONG )0;
#line 221
    filesize_m = (LONG )0;
#line 222
    filesize_g = (LONG )0;
#line 223
    filesize_auto = (LONG )0;
#line 224
    sizeunit = (STRPTR )"";
#line 225
    hsc_msg_nouri(hp___0, filename, uri, (STRPTR )"get filesize");
    }
  }
  {
#line 229
  ugly_clr_estr(dest);
  }
#line 230
  if (s___2) {
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 231
      if (! *(s___2 + 0)) {
#line 231
        goto while_break;
      }
#line 232
      if ((int )*(s___2 + 0) == 37) {
#line 233
        if (*(s___2 + 1)) {
#line 234
          s___2 ++;
        }
        {
#line 236
        if ((int )*(s___2 + 0) == 98) {
#line 236
          goto case_98;
        }
#line 240
        if ((int )*(s___2 + 0) == 107) {
#line 240
          goto case_107;
        }
#line 244
        if ((int )*(s___2 + 0) == 109) {
#line 244
          goto case_109;
        }
#line 248
        if ((int )*(s___2 + 0) == 103) {
#line 248
          goto case_103;
        }
#line 252
        if ((int )*(s___2 + 0) == 97) {
#line 252
          goto case_97;
        }
#line 256
        if ((int )*(s___2 + 0) == 117) {
#line 256
          goto case_117;
        }
#line 260
        goto switch_default;
        case_98: /* CIL Label */ 
        {
#line 237
        tmp___2 = long2str(filesize);
#line 237
        ugly_app_estr(dest, (CONSTRPTR )tmp___2);
        }
#line 238
        goto switch_break;
        case_107: /* CIL Label */ 
        {
#line 241
        tmp___3 = long2str(filesize_k);
#line 241
        ugly_app_estr(dest, (CONSTRPTR )tmp___3);
        }
#line 242
        goto switch_break;
        case_109: /* CIL Label */ 
        {
#line 245
        tmp___4 = long2str(filesize_m);
#line 245
        ugly_app_estr(dest, (CONSTRPTR )tmp___4);
        }
#line 246
        goto switch_break;
        case_103: /* CIL Label */ 
        {
#line 249
        tmp___5 = long2str(filesize_g);
#line 249
        ugly_app_estr(dest, (CONSTRPTR )tmp___5);
        }
#line 250
        goto switch_break;
        case_97: /* CIL Label */ 
        {
#line 253
        tmp___6 = long2str(filesize_auto);
#line 253
        ugly_app_estr(dest, (CONSTRPTR )tmp___6);
        }
#line 254
        goto switch_break;
        case_117: /* CIL Label */ 
        {
#line 257
        ugly_app_estr(dest, (CONSTRPTR )sizeunit);
        }
#line 258
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 261
        ugly_app_estrch(dest, '%');
#line 262
        ugly_app_estrch(dest, (int )*(s___2 + 0));
        }
#line 263
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
        {
#line 266
        ugly_app_estrch(dest, (int )*(s___2 + 0));
        }
      }
#line 267
      s___2 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 274
  filesizestr = dest->es_data;
#line 277
  del_estr(efilename);
  }
#line 279
  return (filesizestr);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static STRPTR const   set_var_basename_ext(STRPTR src , HSCATTR *dest , BOOL ext ) 
{ 
  STRPTR end ;
  EXPSTR *tmp ;
  EXPSTR *tmp___0 ;
  BOOL ok ;
  size_t tmp___1 ;
  STRPTR tmp___2 ;
  STRPTR tmp___3 ;

  {
  {
#line 291
  tmp___0 = ugly_init_estr((size_t )0);
#line 291
  tmp = tmp___0;
#line 292
  ok = (BOOL )0;
  }
#line 294
  if (tmp) {
    {
#line 295
    tmp___1 = strlen((char const   *)src);
#line 295
    end = (src + tmp___1) - 1;
    }
    {
#line 296
    while (1) {
      while_continue: /* CIL Label */ ;
#line 296
      if ((int )*end != 46) {
#line 296
        if (! ((unsigned long )end > (unsigned long )src)) {
#line 296
          goto while_break;
        }
      } else {
#line 296
        goto while_break;
      }
#line 296
      end --;
    }
    while_break: /* CIL Label */ ;
    }
#line 297
    if ((unsigned long )end == (unsigned long )src) {
#line 297
      if ((int )*end != 46) {
#line 299
        if (ext) {
          {
#line 299
          set_vartext(dest, (STRPTR )"");
          }
        } else {
          {
#line 300
          set_vartext(dest, src);
          }
        }
      } else {
#line 297
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 302
      if (ext) {
        {
#line 302
        ok = ugly_set_estr(tmp, (CONSTRPTR )(end + 1));
        }
      } else {
        {
#line 303
        ok = set_estrn(tmp, (CONSTRPTR )src, (size_t )(end - src));
        }
      }
#line 304
      if (ok) {
        {
#line 304
        set_vartext(dest, tmp->es_data);
        }
      }
      {
#line 305
      del_estr(tmp);
      }
    }
  }
#line 308
  if (ok) {
    {
#line 308
    tmp___2 = get_vartext(dest);
#line 308
    tmp___3 = tmp___2;
    }
  } else {
#line 308
    tmp___3 = (STRPTR )((void *)0);
  }
#line 308
  return ((STRPTR const   )tmp___3);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
STRPTR check_attrname(HSCPRC *hp___0 , HSCATTR *dest , STRPTR name , BOOL allow_expr ) 
{ 
  STRPTR res ;
  char const   *tmp___0 ;
  int tmp___1 ;
  BOOL tmp___2 ;

  {
  {
#line 319
  res = (STRPTR )((void *)0);
#line 321
  tmp___2 = hsc_normch((int )*(name + 0));
  }
#line 321
  if (tmp___2) {
#line 322
    res = name;
  } else
#line 323
  if (47 == (int )*(name + 0)) {
#line 323
    if (0 == (int )*(name + 1)) {
#line 323
      if (hp___0->xhtml_emptytag) {
#line 324
        hp___0->xhtml_emptytag = (BOOL )0;
#line 325
        res = name;
      } else {
#line 323
        goto _L___1;
      }
    } else {
#line 323
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 326
  if (123 == (int )*(name + 0)) {
#line 326
    if (allow_expr) {
      {
#line 327
      dest->vartype = (BYTE )2;
#line 328
      res = eval_expression(hp___0, dest, (STRPTR )"}");
      }
    } else {
#line 326
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 330
    tmp___1 = strcmp((char const   *)name, "/");
    }
#line 330
    if (tmp___1) {
#line 330
      tmp___0 = "";
    } else {
#line 330
      tmp___0 = " (XHTML mode?)";
    }
    {
#line 330
    hsc_message(hp___0, (HSCMSG_ID )16448, "illegal attribute identifier %q%s", name,
                tmp___0);
    }
  }
#line 334
  return (res);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static STRPTR eval_attrname(HSCPRC *hp___0 , HSCATTR *tmpdest ) 
{ 
  STRPTR result ;
  STRPTR nw ;
  STRPTR tmp ;

  {
  {
#line 344
  result = (STRPTR )((void *)0);
#line 345
  tmp = infgetw(hp___0->inpf);
#line 345
  nw = tmp;
  }
#line 346
  if (nw) {
    {
#line 347
    nw = check_attrname(hp___0, tmpdest, nw, (BOOL )1);
    }
#line 347
    if ((unsigned long )((void *)0) != (unsigned long )nw) {
#line 348
      result = nw;
    }
  } else {
    {
#line 351
    hsc_msg_eof(hp___0, (STRPTR )"attribute identifier expected");
    }
  }
#line 353
  return (result);
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
STRPTR quotestr(int quote ) 
{ 
  STRPTR s___2 ;
  STRARR tmp[60] ;

  {
#line 362
  s___2 = (STRPTR )"UNKNOWN";
#line 364
  if (quote == 34) {
#line 366
    s___2 = (STRPTR )"[double]";
  } else
#line 368
  if (quote == 39) {
#line 370
    s___2 = (STRPTR )"[single]";
  } else
#line 372
  if (quote == 96) {
#line 374
    s___2 = (STRPTR )"[back]";
  } else
#line 376
  if (quote == 0) {
#line 378
    s___2 = (STRPTR )"[none]";
  } else {
    {
#line 383
    sprintf((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"unknown quote-kind: $%02x #%03d",
            quote, quote);
#line 384
    display_panic_message(tmp, (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c",
                          (size_t )384);
    }
  }
#line 387
  return (s___2);
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
VOID choose_quote(HSCPRC *hp___0 , HSCATTR *attr ) 
{ 
  int quote ;
  LONG qm ;
  BOOL single_quote ;
  BOOL double_quote ;
  BOOL nasty_char ;
  STRPTR value ;
  STRPTR tmp ;
  BOOL tmp___0 ;
  EXPSTR *newval ;
  EXPSTR *tmp___1 ;
  STRPTR tmp___2 ;
  STRPTR tmp___3 ;

  {
  {
#line 397
  quote = attr->quote;
#line 398
  qm = hp___0->quotemode;
#line 399
  single_quote = (BOOL )0;
#line 400
  double_quote = (BOOL )0;
#line 401
  nasty_char = (BOOL )0;
#line 403
  tmp = get_vartext(attr);
#line 403
  value = tmp;
  }
#line 407
  if (! ((int )attr->vartype == 3)) {
#line 409
    if (*(value + 0)) {
      {
#line 411
      while (1) {
        while_continue: /* CIL Label */ ;
#line 411
        if (! *(value + 0)) {
#line 411
          goto while_break;
        }
#line 412
        if ((int )*(value + 0) == 39) {
#line 414
          single_quote = (BOOL )1;
#line 415
          nasty_char = (BOOL )1;
        } else
#line 416
        if ((int )*(value + 0) == 34) {
#line 418
          double_quote = (BOOL )1;
#line 419
          nasty_char = (BOOL )1;
        } else {
          {
#line 420
          tmp___0 = hsc_normch((int )*(value + 0));
          }
#line 420
          if (tmp___0) {
#line 420
            if ((int )*(value + 0) == 95) {
              _L: /* CIL Label */ 
#line 420
              if (! nasty_char) {
#line 422
                nasty_char = (BOOL )1;
              }
            }
          } else {
#line 420
            goto _L;
          }
        }
#line 424
        value ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 428
      nasty_char = (BOOL )1;
    }
  }
#line 431
  if (qm == 1L) {
#line 433
    if (attr->quote == 0) {
#line 433
      if (nasty_char) {
        {
#line 434
        hsc_message(hp___0, (HSCMSG_ID )12369, "value for %A requires quotes", attr);
        }
      }
    }
  } else {
#line 439
    if (single_quote) {
#line 439
      if (double_quote) {
        {
#line 442
        tmp___1 = ugly_init_estr((size_t )32);
#line 442
        newval = tmp___1;
#line 446
        value = get_vartext(attr);
        }
        {
#line 447
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 447
          if (! *(value + 0)) {
#line 447
            goto while_break___0;
          }
#line 448
          if ((int )*(value + 0) == 34) {
            {
#line 451
            ugly_app_estr(newval, "&quot;");
            }
          } else {
            {
#line 453
            ugly_app_estrch(newval, (int )*(value + 0));
            }
          }
#line 454
          value ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 458
        set_vartext(attr, newval->es_data);
#line 459
        quote = '\"';
#line 460
        del_estr(newval);
        }
      } else {
#line 439
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 462
    if (single_quote) {
#line 464
      quote = '\"';
    } else
#line 465
    if (double_quote) {
#line 467
      quote = '\'';
    } else
#line 470
    if (qm == 3L) {
#line 472
      quote = '\'';
    } else
#line 473
    if (qm == 2L) {
#line 475
      quote = '\"';
    } else
#line 476
    if (qm == 4L) {
#line 477
      if (nasty_char) {
#line 479
        quote = '\"';
      } else {
#line 482
        quote = 0;
      }
    } else {
      {
#line 485
      display_panic_message((char *)"illegal quote-mode", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c",
                            (size_t )485);
      }
    }
#line 490
    if (attr->quote != quote) {
      {
#line 491
      tmp___2 = quotestr(quote);
#line 491
      tmp___3 = quotestr(attr->quote);
#line 491
      hsc_message(hp___0, (HSCMSG_ID )82, "changed quotes for %A from %s to %s", attr,
                  tmp___3, tmp___2);
      }
    }
  }
#line 496
  attr->quote = quote;
#line 497
  return;
}
}
#line 727
static STRPTR try_eval_unary_op(HSCPRC *hp___0 , HSCATTR *dest , BOOL *err ) ;
#line 727 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static STRPTR const   kinds[4]  = {      (STRPTR const   )"abs",      (STRPTR const   )"ext",      (STRPTR const   )"rel",      (STRPTR const   )"rsv"};
#line 507 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static STRPTR try_eval_unary_op(HSCPRC *hp___0 , HSCATTR *dest , BOOL *err ) 
{ 
  STRPTR eval_result ;
  INFILE *inpf ;
  HSCATTR *eadest ;
  HSCATTR *tmp ;
  STRPTR nw ;
  STRPTR tmp___0 ;
  HSCATTR *tmpdest ;
  HSCATTR *tmp___1 ;
  STRPTR nw___0 ;
  STRPTR tmp___2 ;
  BOOL err_rec ;
  STRPTR endstr ;
  int tmp___3 ;
  BOOL tmp___4 ;
  int tmp___5 ;
  HSCATTR *attr ;
  HSCATTR *tmp___6 ;
  char ts[4] ;
  char ts___0[2] ;
  int tmp___7 ;
  FILE *file ;
  EXPSTR *dest_fname ;
  EXPSTR *tmp___8 ;
  FILE *file___0 ;
  EXPSTR *dest_fname___0 ;
  EXPSTR *tmp___9 ;
  STRPTR env_value ;
  STRPTR tmp___10 ;
  char *tmp___11 ;
  STRPTR tmp___12 ;
  EXPSTR *filesizestr ;
  EXPSTR *tmp___13 ;
  HSCATTR *filedestattr ;
  HSCATTR *tmp___14 ;
  STRPTR filename ;
  EXPSTR *filedatestr ;
  HSCATTR *filedestattr___0 ;
  HSCATTR *tmp___15 ;
  STRPTR filename___0 ;
  struct tm  const  *time___0 ;
  EXPSTR *timestr ;
  struct tm *tmp___16 ;
  EXPSTR *tmp___17 ;
  EXPSTR *timestr___0 ;
  struct tm *tmp___18 ;
  EXPSTR *tmp___19 ;
  HSCATTR *attr___0 ;
  HSCATTR *tmp___20 ;
  BOOL tmp___21 ;
  STRPTR tmp___22 ;
  URIKIND tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;

  {
  {
#line 508
  eval_result = (STRPTR )((void *)0);
#line 509
  inpf = hp___0->inpf;
#line 510
  tmp = new_hscattr("HSC.TMP.eval_attrname");
#line 510
  eadest = tmp;
#line 511
  tmp___0 = eval_attrname(hp___0, eadest);
#line 511
  nw = tmp___0;
#line 512
  tmp___1 = new_hscattr("HSC.TMP.unary.operator");
#line 512
  tmpdest = tmp___1;
#line 514
  tmpdest->vartype = (BYTE )2;
#line 516
  *err = (BOOL )0;
  }
#line 517
  if (nw) {
    {
#line 518
    tmp___38 = upstrcmp((CONSTRPTR )nw, "NOT");
    }
#line 518
    if (tmp___38) {
      {
#line 545
      tmp___37 = upstrcmp((CONSTRPTR )nw, "DEFINED");
      }
#line 545
      if (tmp___37) {
        {
#line 556
        tmp___36 = upstrcmp((CONSTRPTR )nw, "ORD");
        }
#line 556
        if (tmp___36) {
          {
#line 566
          tmp___35 = upstrcmp((CONSTRPTR )nw, "CHR");
          }
#line 566
          if (tmp___35) {
            {
#line 578
            tmp___34 = upstrcmp((CONSTRPTR )nw, "EXISTS");
            }
#line 578
            if (tmp___34) {
              {
#line 598
              tmp___33 = upstrcmp((CONSTRPTR )nw, "FEXISTS");
              }
#line 598
              if (tmp___33) {
                {
#line 617
                tmp___32 = upstrcmp((CONSTRPTR )nw, "GETENV");
                }
#line 617
                if (tmp___32) {
                  {
#line 635
                  tmp___31 = upstrcmp((CONSTRPTR )nw, "GETFILESIZE");
                  }
#line 635
                  if (tmp___31) {
                    {
#line 652
                    tmp___30 = upstrcmp((CONSTRPTR )nw, "GETFILEDATE");
                    }
#line 652
                    if (tmp___30) {
                      {
#line 668
                      tmp___29 = upstrcmp((CONSTRPTR )nw, "GETTIME");
                      }
#line 668
                      if (tmp___29) {
                        {
#line 679
                        tmp___28 = upstrcmp((CONSTRPTR )nw, "GETGMTIME");
                        }
#line 679
                        if (tmp___28) {
                          {
#line 690
                          tmp___27 = upstrcmp((CONSTRPTR )nw, "SET");
                          }
#line 690
                          if (tmp___27) {
                            {
#line 708
                            tmp___26 = upstrcmp((CONSTRPTR )nw, "BASENAME");
                            }
#line 708
                            if (tmp___26) {
                              {
#line 716
                              tmp___25 = upstrcmp((CONSTRPTR )nw, "EXTENSION");
                              }
#line 716
                              if (tmp___25) {
                                {
#line 724
                                tmp___24 = upstrcmp((CONSTRPTR )nw, "URIKIND");
                                }
#line 724
                                if (tmp___24) {
                                  {
#line 735
                                  inungetcw(inpf);
                                  }
                                } else {
                                  {
#line 725
                                  eval_result = eval_expression(hp___0, tmpdest, (STRPTR )((void *)0));
                                  }
#line 726
                                  if (eval_result) {
                                    {
#line 730
                                    tmp___23 = uri_kind(eval_result);
#line 730
                                    set_vartext(dest, (STRPTR )kinds[tmp___23]);
#line 731
                                    eval_result = get_vartext(dest);
                                    }
                                  }
                                }
                              } else {
                                {
#line 717
                                eval_result = eval_expression(hp___0, tmpdest, (STRPTR )((void *)0));
                                }
#line 718
                                if (eval_result) {
                                  {
#line 720
                                  set_var_basename_ext(eval_result, dest, (BOOL )1);
#line 721
                                  eval_result = get_vartext(dest);
                                  }
                                }
                              }
                            } else {
                              {
#line 709
                              eval_result = eval_expression(hp___0, tmpdest, (STRPTR )((void *)0));
                              }
#line 710
                              if (eval_result) {
                                {
#line 712
                                set_var_basename_ext(eval_result, dest, (BOOL )0);
#line 713
                                eval_result = get_vartext(dest);
                                }
                              }
                            }
                          } else {
                            {
#line 691
                            nw = eval_attrname(hp___0, eadest);
                            }
#line 692
                            if (nw) {
                              {
#line 693
                              tmp___20 = find_varname(hp___0->defattr, nw);
#line 693
                              attr___0 = tmp___20;
                              }
#line 695
                              if (attr___0) {
#line 696
                                if ((int )attr___0->vartype == 3) {
                                  {
#line 697
                                  tmp___21 = get_varbool(attr___0);
#line 697
                                  set_varbool(dest, tmp___21);
                                  }
                                } else {
                                  {
#line 698
                                  tmp___22 = get_vartext(attr___0);
                                  }
#line 698
                                  if (tmp___22) {
                                    {
#line 699
                                    set_varbool(dest, (BOOL )1);
                                    }
                                  } else {
                                    {
#line 701
                                    set_varbool(dest, (BOOL )0);
                                    }
                                  }
                                }
                                {
#line 702
                                eval_result = get_vartext(dest);
                                }
                              } else {
                                {
#line 704
                                hsc_msg_unkn_attr_ref(hp___0, nw);
#line 705
                                *err = (BOOL )1;
                                }
                              }
                            }
                          }
                        } else {
                          {
#line 681
                          tmp___18 = gmtime((time_t const   *)(& hp___0->start_time));
#line 681
                          tmp___19 = gettimestr(hp___0, (struct tm  const  *)tmp___18);
#line 681
                          timestr___0 = tmp___19;
                          }
#line 684
                          if (timestr___0) {
                            {
#line 685
                            set_vartext(dest, timestr___0->es_data);
#line 686
                            del_estr(timestr___0);
#line 687
                            eval_result = get_vartext(dest);
                            }
                          }
                          {
#line 689
                          check_brackets(hp___0);
                          }
                        }
                      } else {
                        {
#line 670
                        tmp___16 = localtime((time_t const   *)(& hp___0->start_time));
#line 670
                        tmp___17 = gettimestr(hp___0, (struct tm  const  *)tmp___16);
#line 670
                        timestr = tmp___17;
                        }
#line 673
                        if (timestr) {
                          {
#line 674
                          set_vartext(dest, timestr->es_data);
#line 675
                          del_estr(timestr);
#line 676
                          eval_result = get_vartext(dest);
                          }
                        }
                        {
#line 678
                        check_brackets(hp___0);
                        }
                      }
                    } else {
                      {
#line 653
                      filedatestr = (EXPSTR *)((void *)0);
#line 654
                      tmp___15 = new_hscattr("HSC.TMP.get.filedate");
#line 654
                      filedestattr___0 = tmp___15;
#line 655
                      filename___0 = (STRPTR )((void *)0);
#line 658
                      eval_result = (STRPTR )((void *)0);
#line 659
                      filedestattr___0->vartype = (BYTE )2;
#line 660
                      filename___0 = eval_expression(hp___0, filedestattr___0, (STRPTR )((void *)0));
                      }
#line 660
                      if ((unsigned long )((void *)0) != (unsigned long )filename___0) {
                        {
#line 660
                        time___0 = fgetmtime((STRPTR const   )filename___0);
                        }
#line 660
                        if ((unsigned long )((void *)0) != (unsigned long )time___0) {
                          {
#line 660
                          filedatestr = gettimestr(hp___0, time___0);
                          }
#line 660
                          if ((unsigned long )((void *)0) != (unsigned long )filedatestr) {
                            {
#line 663
                            set_vartext(dest, filedatestr->es_data);
#line 664
                            eval_result = get_vartext(dest);
                            }
                          }
                        }
                      }
                      {
#line 666
                      del_hscattr((APTR )filedestattr___0);
#line 667
                      del_estr(filedatestr);
                      }
                    }
                  } else {
                    {
#line 637
                    tmp___13 = ugly_init_estr((size_t )0);
#line 637
                    filesizestr = tmp___13;
#line 638
                    tmp___14 = new_hscattr("HSC.TMP.get.filesize");
#line 638
                    filedestattr = tmp___14;
#line 639
                    filename = (STRPTR )((void *)0);
#line 641
                    eval_result = (STRPTR )((void *)0);
#line 642
                    filedestattr->vartype = (BYTE )2;
#line 643
                    filename = eval_expression(hp___0, filedestattr, (STRPTR )((void *)0));
                    }
#line 644
                    if (filename) {
                      {
#line 645
                      eval_result = getfilesize(hp___0, filesizestr, filename);
                      }
                    }
#line 646
                    if (eval_result) {
                      {
#line 647
                      set_vartext(dest, eval_result);
#line 648
                      eval_result = get_vartext(dest);
                      }
                    }
                    {
#line 650
                    del_hscattr((APTR )filedestattr);
#line 651
                    del_estr(filesizestr);
                    }
                  }
                } else {
                  {
#line 619
                  eval_result = eval_expression(hp___0, dest, (STRPTR )((void *)0));
                  }
#line 620
                  if (eval_result) {
                    {
#line 621
                    tmp___10 = get_vartext(dest);
#line 621
                    tmp___11 = getenv((char const   *)tmp___10);
#line 621
                    env_value = tmp___11;
                    }
#line 624
                    if (! env_value) {
                      {
#line 625
                      tmp___12 = get_vartext(dest);
#line 625
                      hsc_message(hp___0, (HSCMSG_ID )12329, "unknown environment variable %q",
                                  tmp___12);
#line 629
                      env_value = (STRPTR )"";
                      }
                    }
                    {
#line 631
                    set_vartext(dest, env_value);
#line 632
                    eval_result = get_vartext(dest);
                    }
                  }
                }
              } else {
                {
#line 600
                eval_result = eval_expression(hp___0, tmpdest, (STRPTR )((void *)0));
                }
#line 601
                if (eval_result) {
                  {
#line 602
                  file___0 = (FILE *)((void *)0);
#line 603
                  tmp___9 = ugly_init_estr((size_t )64);
#line 603
                  dest_fname___0 = tmp___9;
#line 607
                  file___0 = fopen((char const   */* __restrict  */)eval_result, (char const   */* __restrict  */)"r");
                  }
#line 608
                  if (file___0) {
                    {
#line 609
                    fclose(file___0);
#line 610
                    set_varbool(dest, (BOOL )1);
                    }
                  } else {
                    {
#line 612
                    set_varbool(dest, (BOOL )0);
                    }
                  }
                  {
#line 614
                  del_estr(dest_fname___0);
#line 615
                  eval_result = get_vartext(dest);
                  }
                }
              }
            } else {
              {
#line 580
              eval_result = eval_expression(hp___0, tmpdest, (STRPTR )((void *)0));
              }
#line 581
              if (eval_result) {
                {
#line 582
                file = (FILE *)((void *)0);
#line 583
                tmp___8 = ugly_init_estr((size_t )64);
#line 583
                dest_fname = tmp___8;
#line 587
                conv_hscuri2file(hp___0, dest_fname, eval_result);
#line 588
                file = fopen((char const   */* __restrict  */)dest_fname->es_data,
                             (char const   */* __restrict  */)"r");
                }
#line 589
                if (file) {
                  {
#line 590
                  fclose(file);
#line 591
                  set_varbool(dest, (BOOL )1);
                  }
                } else {
                  {
#line 593
                  set_varbool(dest, (BOOL )0);
                  }
                }
                {
#line 595
                del_estr(dest_fname);
#line 596
                eval_result = get_vartext(dest);
                }
              }
            }
          } else {
            {
#line 567
            eval_result = eval_expression(hp___0, tmpdest, (STRPTR )((void *)0));
            }
#line 568
            if (eval_result) {
              {
#line 571
              check_integer(hp___0, tmpdest, eval_result);
#line 572
              tmp___7 = atoi((char const   *)eval_result);
#line 572
              ts___0[0] = (char )tmp___7;
#line 573
              ts___0[1] = (char )'\000';
#line 574
              set_vartext(dest, ts___0);
#line 575
              eval_result = get_vartext(dest);
              }
            }
          }
        } else {
          {
#line 557
          eval_result = eval_expression(hp___0, tmpdest, (STRPTR )((void *)0));
          }
#line 558
          if (eval_result) {
            {
#line 561
            sprintf((char */* __restrict  */)(ts), (char const   */* __restrict  */)"%d",
                    (int )*(eval_result + 0));
#line 562
            set_vartext(dest, ts);
#line 563
            eval_result = get_vartext(dest);
            }
          }
        }
      } else {
        {
#line 546
        nw = eval_attrname(hp___0, eadest);
        }
#line 547
        if (nw) {
          {
#line 548
          tmp___6 = find_varname(hp___0->defattr, nw);
#line 548
          attr = tmp___6;
          }
#line 550
          if (attr) {
            {
#line 551
            set_varbool(dest, (BOOL )1);
            }
          } else {
            {
#line 553
            set_varbool(dest, (BOOL )0);
            }
          }
          {
#line 554
          eval_result = get_vartext(dest);
          }
        }
      }
    } else {
      {
#line 520
      tmp___2 = infgetw(inpf);
#line 520
      nw___0 = tmp___2;
      }
#line 522
      if (nw___0) {
        {
#line 523
        err_rec = (BOOL )0;
#line 524
        endstr = (STRPTR )((void *)0);
#line 526
        tmp___3 = strcmp((char const   *)nw___0, "(");
        }
#line 526
        if (tmp___3) {
          {
#line 528
          inungetcw(inpf);
#line 529
          eval_result = try_eval_unary_op(hp___0, dest, & err_rec);
          }
        } else {
#line 531
          endstr = (STRPTR )")";
        }
#line 534
        if (! eval_result) {
#line 534
          if (! err_rec) {
            {
#line 535
            eval_result = eval_expression(hp___0, dest, endstr);
            }
          }
        }
      } else {
        {
#line 537
        hsc_msg_eof(hp___0, (STRPTR )"after NOT");
        }
      }
#line 540
      if (eval_result) {
        {
#line 541
        tmp___4 = get_varbool(dest);
        }
#line 541
        if (tmp___4) {
#line 541
          tmp___5 = 0;
        } else {
#line 541
          tmp___5 = 1;
        }
        {
#line 541
        set_varbool(dest, (BOOL )tmp___5);
#line 542
        eval_result = get_vartext(dest);
        }
      } else {
#line 544
        *err = (BOOL )1;
      }
    }
  }
  {
#line 738
  del_hscattr((APTR )tmpdest);
#line 739
  del_hscattr((APTR )eadest);
  }
#line 741
  if (! nw) {
#line 742
    *err = (BOOL )1;
  }
#line 744
  return (eval_result);
}
}
#line 752 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static BYTE eval_op(HSCPRC *hp___0 ) 
{ 
  op_t op ;
  BOOL op_eof ;
  INFILE *inpf ;
  STRPTR nw ;
  STRPTR tmp ;
  STRARR opstr[3] ;
  int ch ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  LONG tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
  {
#line 753
  op = (op_t )0;
#line 754
  op_eof = (BOOL )0;
#line 755
  inpf = hp___0->inpf;
#line 756
  tmp = infgetw(inpf);
#line 756
  nw = tmp;
  }
#line 760
  if (nw) {
    {
#line 762
    tmp___24 = upstrcmp((CONSTRPTR )nw, "AND");
    }
#line 762
    if (tmp___24) {
      {
#line 763
      tmp___23 = upstrcmp((CONSTRPTR )nw, "OR");
      }
#line 763
      if (tmp___23) {
        {
#line 764
        tmp___22 = upstrcmp((CONSTRPTR )nw, "XOR");
        }
#line 764
        if (tmp___22) {
          {
#line 765
          tmp___21 = strcmp((char const   *)nw, "+");
          }
#line 765
          if (tmp___21) {
            {
#line 766
            tmp___20 = strcmp((char const   *)nw, "&");
            }
#line 766
            if (tmp___20) {
              {
#line 767
              tmp___19 = strcmp((char const   *)nw, "-");
              }
#line 767
              if (tmp___19) {
                {
#line 768
                tmp___18 = strcmp((char const   *)nw, "*");
                }
#line 768
                if (tmp___18) {
                  {
#line 769
                  tmp___17 = strcmp((char const   *)nw, "/");
                  }
#line 769
                  if (tmp___17) {
                    {
#line 770
                    tmp___16 = upstrcmp((CONSTRPTR )nw, "MOD");
                    }
#line 770
                    if (tmp___16) {
                      {
#line 771
                      tmp___15 = upstrcmp((CONSTRPTR )nw, "GT");
                      }
#line 771
                      if (tmp___15) {
                        {
#line 772
                        tmp___14 = upstrcmp((CONSTRPTR )nw, "LT");
                        }
#line 772
                        if (tmp___14) {
                          {
#line 773
                          tmp___13 = upstrcmp((CONSTRPTR )nw, "LE");
                          }
#line 773
                          if (tmp___13) {
                            {
#line 774
                            tmp___12 = upstrcmp((CONSTRPTR )nw, "GE");
                            }
#line 774
                            if (tmp___12) {
                              {
#line 775
                              tmp___11 = upstrcmp((CONSTRPTR )nw, "IN");
                              }
#line 775
                              if (tmp___11) {
                                {
#line 776
                                tmp___10 = strcmp((char const   *)nw, ")");
                                }
#line 776
                                if (tmp___10) {
                                  {
#line 777
                                  tmp___9 = strcmp((char const   *)nw, "}");
                                  }
#line 777
                                  if (tmp___9) {
                                    {
#line 778
                                    tmp___8 = strenum((CONSTRPTR )nw, "<|=|>", (char )'|',
                                                      (BYTE )0);
                                    }
#line 778
                                    if (tmp___8) {
                                      {
#line 790
                                      strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)nw);
#line 791
                                      ch = infgetc(inpf);
                                      }
#line 792
                                      if (ch != -1) {
                                        {
#line 795
                                        tmp___0 = strchr("<=>", ch);
                                        }
#line 795
                                        if (tmp___0) {
#line 796
                                          opstr[1] = (STRARR )ch;
#line 797
                                          opstr[2] = (STRARR )0;
                                        } else {
                                          {
#line 799
                                          inungetc(ch, inpf);
                                          }
                                        }
                                      } else {
#line 802
                                        op_eof = (BOOL )1;
                                      }
                                      {
#line 805
                                      tmp___7 = strcmp((char const   *)(opstr), "=");
                                      }
#line 805
                                      if (tmp___7) {
                                        {
#line 807
                                        tmp___6 = strcmp((char const   *)(opstr),
                                                         "<>");
                                        }
#line 807
                                        if (tmp___6) {
                                          {
#line 809
                                          tmp___5 = strcmp((char const   *)(opstr),
                                                           ">");
                                          }
#line 809
                                          if (tmp___5) {
                                            {
#line 811
                                            tmp___4 = strcmp((char const   *)(opstr),
                                                             "<");
                                            }
#line 811
                                            if (tmp___4) {
                                              {
#line 813
                                              tmp___3 = strcmp((char const   *)(opstr),
                                                               "<=");
                                              }
#line 813
                                              if (tmp___3) {
                                                {
#line 815
                                                tmp___2 = strcmp((char const   *)(opstr),
                                                                 ">=");
                                                }
#line 815
                                                if (tmp___2) {
                                                  {
#line 817
                                                  tmp___1 = strcmp((char const   *)(opstr),
                                                                   "==");
                                                  }
#line 817
                                                  if (tmp___1) {
                                                    {
#line 820
                                                    err_op(hp___0, opstr);
                                                    }
                                                  } else {
#line 818
                                                    op = (op_t )3;
                                                  }
                                                } else {
#line 816
                                                  op = (op_t )10;
                                                }
                                              } else {
#line 814
                                                op = (op_t )11;
                                              }
                                            } else {
#line 812
                                              op = (op_t )9;
                                            }
                                          } else {
#line 810
                                            op = (op_t )8;
                                          }
                                        } else {
#line 808
                                          op = (op_t )2;
                                        }
                                      } else {
#line 806
                                        op = (op_t )1;
                                      }
                                    } else {
                                      {
#line 822
                                      err_op(hp___0, nw);
                                      }
                                    }
                                  } else {
#line 777
                                    op = (op_t )24;
                                  }
                                } else {
#line 776
                                  op = (op_t )23;
                                }
                              } else {
#line 775
                                op = (op_t )12;
                              }
                            } else {
#line 774
                              op = (op_t )6;
                            }
                          } else {
#line 773
                            op = (op_t )7;
                          }
                        } else {
#line 772
                          op = (op_t )5;
                        }
                      } else {
#line 771
                        op = (op_t )4;
                      }
                    } else {
#line 770
                      op = (op_t )22;
                    }
                  } else {
#line 769
                    op = (op_t )21;
                  }
                } else {
#line 768
                  op = (op_t )20;
                }
              } else {
#line 767
                op = (op_t )19;
              }
            } else {
#line 766
              op = (op_t )18;
            }
          } else {
#line 765
            op = (op_t )17;
          }
        } else {
#line 764
          op = (op_t )16;
        }
      } else {
#line 763
        op = (op_t )15;
      }
    } else {
#line 762
      op = (op_t )13;
    }
  } else {
#line 825
    op_eof = (BOOL )1;
  }
#line 830
  if (op_eof) {
    {
#line 831
    hsc_msg_eof(hp___0, (STRPTR )"operator expected");
    }
  }
#line 833
  return ((BYTE )op);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static BOOL stroptol(HSCPRC *hp___0 , LONG *dest , STRPTR str ) 
{ 
  BOOL ok ;
  STRPTR last_char ;

  {
#line 847
  ok = (BOOL )1;
#line 849
  *dest = (LONG )0;
#line 851
  if (*(str + 0)) {
    {
#line 852
    last_char = (STRPTR )((void *)0);
#line 853
    *dest = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)(& last_char),
                   0);
    }
#line 854
    if (! last_char) {
#line 855
      *dest = (LONG )1;
    } else
#line 854
    if (*(last_char + 0)) {
#line 855
      *dest = (LONG )1;
    }
  }
#line 859
  return (ok);
}
}
#line 865 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static BOOL process_arithmetic_op(HSCPRC *hp___0 , EXPSTR *result , BYTE op , STRPTR str1 ,
                                  STRPTR str2 ) 
{ 
  BOOL result_set ;
  LONG int1 ;
  LONG int2 ;
  LONG intr ;
  BOOL tmp ;
  STRARR buf___3[20] ;

  {
  {
#line 866
  result_set = (BOOL )1;
#line 867
  int1 = (LONG )0;
#line 868
  int2 = (LONG )0;
#line 869
  intr = (LONG )0;
#line 872
  result_set = stroptol(hp___0, & int1, str1);
#line 873
  tmp = stroptol(hp___0, & int2, str2);
#line 873
  result_set = (BOOL )((int )result_set & (int )tmp);
  }
#line 875
  if (int2 == 0L) {
#line 875
    if ((int )op == 21) {
      {
#line 877
      hsc_message(hp___0, (HSCMSG_ID )61448, "arithmetic error: division by zero");
#line 879
      result_set = (BOOL )0;
      }
    } else
#line 875
    if ((int )op == 22) {
      {
#line 877
      hsc_message(hp___0, (HSCMSG_ID )61448, "arithmetic error: division by zero");
#line 879
      result_set = (BOOL )0;
      }
    } else {
#line 875
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 883
    if ((int )op == 18) {
#line 883
      goto case_18;
    }
#line 886
    if ((int )op == 19) {
#line 886
      goto case_19;
    }
#line 889
    if ((int )op == 20) {
#line 889
      goto case_20;
    }
#line 892
    if ((int )op == 21) {
#line 892
      goto case_21;
    }
#line 895
    if ((int )op == 22) {
#line 895
      goto case_22;
    }
#line 898
    goto switch_default;
    case_18: /* CIL Label */ 
#line 884
    intr = int1 + int2;
#line 885
    goto switch_break;
    case_19: /* CIL Label */ 
#line 887
    intr = int1 - int2;
#line 888
    goto switch_break;
    case_20: /* CIL Label */ 
#line 890
    intr = int1 * int2;
#line 891
    goto switch_break;
    case_21: /* CIL Label */ 
#line 893
    intr = int1 / int2;
#line 894
    goto switch_break;
    case_22: /* CIL Label */ 
#line 896
    intr = int1 % int2;
#line 897
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 899
    display_panic_message((char *)"unknown arithmetic operator", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c",
                          (size_t )899);
    }
#line 900
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 905
  if (result_set) {
    {
#line 907
    sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%ld",
            intr);
#line 908
    ugly_set_estr(result, (CONSTRPTR )(buf___3));
    }
  }
#line 910
  return (result_set);
}
}
#line 916 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static BOOL process_boolean_op(HSCPRC *hp___0 , HSCATTR *dest , BYTE op , STRPTR str1 ,
                               STRPTR str2 ) 
{ 
  BOOL bool_val1 ;
  BOOL tmp ;
  BOOL bool_val2 ;
  BOOL tmp___0 ;
  BOOL bool_valr ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 918
  tmp = eval_boolstr(str1);
#line 918
  bool_val1 = tmp;
#line 919
  tmp___0 = eval_boolstr(str2);
#line 919
  bool_val2 = tmp___0;
  }
  {
#line 923
  if ((int )op == 13) {
#line 923
    goto case_13;
  }
#line 926
  if ((int )op == 15) {
#line 926
    goto case_15;
  }
#line 930
  if ((int )op == 16) {
#line 930
    goto case_16;
  }
#line 934
  goto switch_default;
  case_13: /* CIL Label */ 
#line 923
  if (bool_val1) {
#line 923
    if (bool_val2) {
#line 923
      tmp___1 = 1;
    } else {
#line 923
      tmp___1 = 0;
    }
  } else {
#line 923
    tmp___1 = 0;
  }
#line 923
  bool_valr = (BOOL )tmp___1;
#line 924
  goto switch_break;
  case_15: /* CIL Label */ 
#line 927
  if (bool_val1) {
#line 927
    tmp___2 = 1;
  } else
#line 927
  if (bool_val2) {
#line 927
    tmp___2 = 1;
  } else {
#line 927
    tmp___2 = 0;
  }
#line 927
  bool_valr = (BOOL )tmp___2;
#line 928
  goto switch_break;
  case_16: /* CIL Label */ 
#line 931
  bool_valr = (BOOL )((int )bool_val1 ^ (int )bool_val2);
#line 932
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 935
  bool_valr = (BOOL )0;
#line 936
  display_panic_message((char *)"unknown boolean operator", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c",
                        (size_t )936);
  }
#line 937
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 939
  set_varbool(dest, bool_valr);
  }
#line 941
  return ((BOOL )0);
}
}
#line 948 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static BOOL process_comparison_op(HSCPRC *hp___0 , HSCATTR *dest , BYTE op , STRPTR str1 ,
                                  STRPTR str2 ) 
{ 
  BOOL comparison_matches ;
  EXPSTR *uri1 ;
  EXPSTR *uri2 ;
  EXPSTR *fname ;
  LONG int1 ;
  LONG int2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 950
  comparison_matches = (BOOL )0;
#line 951
  uri1 = (EXPSTR *)((void *)0);
#line 952
  uri2 = (EXPSTR *)((void *)0);
#line 953
  fname = (EXPSTR *)((void *)0);
#line 957
  if ((int )dest->vartype == 1) {
    {
#line 958
    uri1 = ugly_init_estr((size_t )0);
#line 959
    uri2 = ugly_init_estr((size_t )0);
#line 960
    fname = ugly_init_estr((size_t )64);
#line 965
    ugly_set_estr(uri1, (CONSTRPTR )str1);
#line 966
    ugly_set_estr(uri2, (CONSTRPTR )str2);
#line 969
    conv_hscuri2fileNuri(hp___0, uri1, fname, str1);
#line 970
    conv_hscuri2fileNuri(hp___0, uri2, fname, str2);
#line 973
    str1 = uri1->es_data;
#line 974
    str2 = uri2->es_data;
    }
  }
#line 981
  if ((int )op == 8) {
    {
#line 985
    stroptol(hp___0, & int1, str1);
#line 986
    stroptol(hp___0, & int2, str2);
    }
  } else
#line 981
  if ((int )op == 9) {
    {
#line 985
    stroptol(hp___0, & int1, str1);
#line 986
    stroptol(hp___0, & int2, str2);
    }
  } else
#line 981
  if ((int )op == 10) {
    {
#line 985
    stroptol(hp___0, & int1, str1);
#line 986
    stroptol(hp___0, & int2, str2);
    }
  } else
#line 981
  if ((int )op == 11) {
    {
#line 985
    stroptol(hp___0, & int1, str1);
#line 986
    stroptol(hp___0, & int2, str2);
    }
  }
  {
#line 991
  if ((int )op == 1) {
#line 991
    goto case_1;
  }
#line 996
  if ((int )op == 2) {
#line 996
    goto case_2;
  }
#line 1001
  if ((int )op == 8) {
#line 1001
    goto case_8;
  }
#line 1006
  if ((int )op == 9) {
#line 1006
    goto case_9;
  }
#line 1011
  if ((int )op == 10) {
#line 1011
    goto case_10;
  }
#line 1016
  if ((int )op == 11) {
#line 1016
    goto case_11;
  }
#line 1021
  if ((int )op == 4) {
#line 1021
    goto case_4;
  }
#line 1026
  if ((int )op == 5) {
#line 1026
    goto case_5;
  }
#line 1031
  if ((int )op == 6) {
#line 1031
    goto case_6;
  }
#line 1036
  if ((int )op == 7) {
#line 1036
    goto case_7;
  }
#line 1041
  if ((int )op == 3) {
#line 1041
    goto case_3;
  }
#line 1046
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 993
  tmp = upstrcmp((CONSTRPTR )str1, (CONSTRPTR )str2);
  }
#line 993
  if (tmp) {
#line 993
    tmp___0 = 0;
  } else {
#line 993
    tmp___0 = 1;
  }
#line 993
  comparison_matches = (BOOL )tmp___0;
#line 994
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 998
  tmp___1 = upstrcmp((CONSTRPTR )str1, (CONSTRPTR )str2);
#line 998
  comparison_matches = (BOOL )tmp___1;
  }
#line 999
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1003
  comparison_matches = (BOOL )(int1 > int2);
#line 1004
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1008
  comparison_matches = (BOOL )(int1 < int2);
#line 1009
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1013
  comparison_matches = (BOOL )(int1 >= int2);
#line 1014
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1018
  comparison_matches = (BOOL )(int1 <= int2);
#line 1019
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1023
  tmp___2 = upstrcmp((CONSTRPTR )str2, (CONSTRPTR )str1);
#line 1023
  comparison_matches = (BOOL )(tmp___2 > 0);
  }
#line 1024
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1028
  tmp___3 = upstrcmp((CONSTRPTR )str2, (CONSTRPTR )str1);
#line 1028
  comparison_matches = (BOOL )(tmp___3 < 0);
  }
#line 1029
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1033
  tmp___4 = upstrcmp((CONSTRPTR )str2, (CONSTRPTR )str1);
#line 1033
  comparison_matches = (BOOL )(tmp___4 >= 0);
  }
#line 1034
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1038
  tmp___5 = upstrcmp((CONSTRPTR )str2, (CONSTRPTR )str1);
#line 1038
  comparison_matches = (BOOL )(tmp___5 <= 0);
  }
#line 1039
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1043
  tmp___6 = strcmp((char const   *)str1, (char const   *)str2);
  }
#line 1043
  if (tmp___6) {
#line 1043
    tmp___7 = 0;
  } else {
#line 1043
    tmp___7 = 1;
  }
#line 1043
  comparison_matches = (BOOL )tmp___7;
#line 1044
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1047
  display_panic_message((char *)"unknown comparison operator", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c",
                        (size_t )1047);
  }
#line 1048
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1052
  set_varbool(dest, comparison_matches);
#line 1055
  del_estr(uri1);
#line 1056
  del_estr(uri2);
#line 1057
  del_estr(fname);
  }
#line 1059
  return ((BOOL )0);
}
}
#line 1065 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static VOID process_op(HSCPRC *hp___0 , HSCATTR *dest , BYTE op , STRPTR str1 , STRPTR str2 ) 
{ 
  EXPSTR *result ;
  EXPSTR *tmp ;
  BOOL result_set ;
  int tmp___1 ;
  STRPTR tmp___2 ;

  {
  {
#line 1066
  tmp = ugly_init_estr((size_t )40);
#line 1066
  result = tmp;
#line 1067
  result_set = (BOOL )0;
  }
#line 1070
  if (str2) {
#line 1070
    if ((int )op != 0) {
      {
#line 1072
      if ((int )op == 17) {
#line 1072
        goto case_17;
      }
#line 1081
      if ((int )op == 16) {
#line 1081
        goto case_16;
      }
#line 1081
      if ((int )op == 15) {
#line 1081
        goto case_16;
      }
#line 1081
      if ((int )op == 13) {
#line 1081
        goto case_16;
      }
#line 1085
      if ((int )op == 12) {
#line 1085
        goto case_12;
      }
#line 1094
      if ((int )op == 22) {
#line 1094
        goto case_22;
      }
#line 1094
      if ((int )op == 21) {
#line 1094
        goto case_22;
      }
#line 1094
      if ((int )op == 20) {
#line 1094
        goto case_22;
      }
#line 1094
      if ((int )op == 19) {
#line 1094
        goto case_22;
      }
#line 1094
      if ((int )op == 18) {
#line 1094
        goto case_22;
      }
#line 1108
      if ((int )op == 3) {
#line 1108
        goto case_3;
      }
#line 1108
      if ((int )op == 7) {
#line 1108
        goto case_3;
      }
#line 1108
      if ((int )op == 6) {
#line 1108
        goto case_3;
      }
#line 1108
      if ((int )op == 5) {
#line 1108
        goto case_3;
      }
#line 1108
      if ((int )op == 4) {
#line 1108
        goto case_3;
      }
#line 1108
      if ((int )op == 11) {
#line 1108
        goto case_3;
      }
#line 1108
      if ((int )op == 10) {
#line 1108
        goto case_3;
      }
#line 1108
      if ((int )op == 9) {
#line 1108
        goto case_3;
      }
#line 1108
      if ((int )op == 8) {
#line 1108
        goto case_3;
      }
#line 1108
      if ((int )op == 2) {
#line 1108
        goto case_3;
      }
#line 1108
      if ((int )op == 1) {
#line 1108
        goto case_3;
      }
#line 1112
      goto switch_default;
      case_17: /* CIL Label */ 
      {
#line 1074
      ugly_set_estr(result, (CONSTRPTR )str1);
#line 1075
      ugly_app_estr(result, (CONSTRPTR )str2);
#line 1076
      result_set = (BOOL )1;
      }
#line 1077
      goto switch_break;
      case_16: /* CIL Label */ 
      case_15: /* CIL Label */ 
      case_13: /* CIL Label */ 
      {
#line 1082
      result_set = process_boolean_op(hp___0, dest, op, str1, str2);
      }
#line 1083
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 1087
      tmp___2 = upstrstr((CONSTRPTR )str2, (CONSTRPTR )str1);
      }
#line 1087
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 1087
        tmp___1 = 0;
      } else {
#line 1087
        tmp___1 = 1;
      }
      {
#line 1087
      set_varbool(dest, (BOOL )tmp___1);
      }
#line 1088
      goto switch_break;
      case_22: /* CIL Label */ 
      case_21: /* CIL Label */ 
      case_20: /* CIL Label */ 
      case_19: /* CIL Label */ 
      case_18: /* CIL Label */ 
      {
#line 1095
      result_set = process_arithmetic_op(hp___0, result, op, str1, str2);
      }
#line 1096
      goto switch_break;
      case_3: /* CIL Label */ 
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
      case_11: /* CIL Label */ 
      case_10: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_8: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
      {
#line 1109
      result_set = process_comparison_op(hp___0, dest, op, str1, str2);
      }
#line 1110
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1113
      display_panic_message((char *)"empty operator", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c",
                            (size_t )1113);
      }
#line 1114
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1120
  if (result_set) {
    {
#line 1121
    set_vartext(dest, result->es_data);
    }
  }
  {
#line 1124
  del_estr(result);
  }
#line 1125
  return;
}
}
#line 1138 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static STRPTR eval_string_expr(HSCPRC *hp___0 , HSCATTR *dest ) 
{ 
  INFILE *inpf ;
  STRPTR eval_result ;
  EXPSTR *tmpstr ;
  EXPSTR *tmp ;
  int quote ;
  BOOL end ;
  int ch ;
  int tmp___0 ;

  {
  {
#line 1139
  inpf = hp___0->inpf;
#line 1140
  eval_result = (STRPTR )((void *)0);
#line 1141
  tmp = ugly_init_estr((size_t )128);
#line 1141
  tmpstr = tmp;
#line 1145
  quote = infgetc(inpf);
  }
#line 1146
  if (quote != -1) {
#line 1147
    end = (BOOL )0;
    {
#line 1149
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1149
      if (! (! end)) {
#line 1149
        goto while_break;
      }
      {
#line 1150
      tmp___0 = infgetc(inpf);
#line 1150
      ch = tmp___0;
      }
#line 1151
      if (ch == -1) {
        {
#line 1152
        hsc_msg_eof(hp___0, (STRPTR )"reading string constant");
#line 1153
        eval_result = (STRPTR )((void *)0);
#line 1154
        end = (BOOL )1;
        }
      } else
#line 1155
      if (ch != quote) {
#line 1157
        if (ch == 10) {
          {
#line 1158
          hsc_message(hp___0, (HSCMSG_ID )12321, "linefeed found inside string");
          }
        }
        {
#line 1162
        ugly_app_estrch(tmpstr, ch);
        }
      } else {
#line 1165
        eval_result = tmpstr->es_data;
#line 1166
        end = (BOOL )1;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1170
    hsc_msg_eof(hp___0, (STRPTR )"reading string constant");
    }
  }
#line 1173
  if (eval_result) {
    {
#line 1175
    dest->quote = quote;
#line 1177
    set_vartext(dest, eval_result);
#line 1178
    eval_result = get_vartext(dest);
    }
  }
  {
#line 1181
  del_estr(tmpstr);
  }
#line 1183
  return (eval_result);
}
}
#line 1191 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static STRPTR eval_string_expr_noquote(HSCPRC *hp___0 , HSCATTR *dest ) 
{ 
  INFILE *inpf ;
  STRPTR eval_result ;
  EXPSTR *tmpstr ;
  EXPSTR *tmp ;
  BOOL end ;
  int ch ;
  int tmp___0 ;
  BOOL tmp___1 ;

  {
  {
#line 1192
  inpf = hp___0->inpf;
#line 1193
  eval_result = (STRPTR )((void *)0);
#line 1194
  tmp = ugly_init_estr((size_t )128);
#line 1194
  tmpstr = tmp;
#line 1195
  end = (BOOL )0;
  }
  {
#line 1204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1204
    if (! (! end)) {
#line 1204
      goto while_break;
    }
    {
#line 1205
    tmp___0 = infgetc(inpf);
#line 1205
    ch = tmp___0;
    }
#line 1206
    if (ch == -1) {
      {
#line 1207
      hsc_msg_eof(hp___0, (STRPTR )"reading attribute");
#line 1209
      end = (BOOL )1;
      }
    } else
#line 1210
    if (ch == 10) {
      {
#line 1212
      inungetc(ch, inpf);
#line 1213
      eval_result = tmpstr->es_data;
#line 1214
      end = (BOOL )1;
      }
    } else {
      {
#line 1210
      tmp___1 = inf_isws((char )ch, inpf);
      }
#line 1210
      if (tmp___1) {
        {
#line 1212
        inungetc(ch, inpf);
#line 1213
        eval_result = tmpstr->es_data;
#line 1214
        end = (BOOL )1;
        }
      } else
#line 1210
      if (ch == 62) {
        {
#line 1212
        inungetc(ch, inpf);
#line 1213
        eval_result = tmpstr->es_data;
#line 1214
        end = (BOOL )1;
        }
      } else {
        {
#line 1217
        ugly_app_estrch(tmpstr, ch);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1222
  if (eval_result) {
    {
#line 1223
    set_vartext(dest, eval_result);
#line 1224
    eval_result = get_vartext(dest);
    }
  }
  {
#line 1227
  del_estr(tmpstr);
  }
#line 1229
  return (eval_result);
}
}
#line 1238 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
STRPTR eval_attrref(HSCPRC *hp___0 , HSCATTR *destattr ) 
{ 
  STRPTR eval_result ;
  HSCATTR *eadest ;
  HSCATTR *tmp ;
  STRPTR nw ;
  STRPTR tmp___0 ;
  HSCATTR *refvar ;
  HSCATTR *tmp___1 ;

  {
  {
#line 1239
  eval_result = (STRPTR )((void *)0);
#line 1240
  tmp = new_hscattr("HSC.TMP.eval_attrname");
#line 1240
  eadest = tmp;
#line 1241
  tmp___0 = eval_attrname(hp___0, eadest);
#line 1241
  nw = tmp___0;
  }
#line 1243
  if (nw) {
    {
#line 1244
    tmp___1 = find_varname(hp___0->defattr, nw);
#line 1244
    refvar = tmp___1;
    }
#line 1246
    if (refvar) {
#line 1247
      destattr->quote = refvar->quote;
#line 1248
      destattr->vartype = refvar->vartype;
#line 1250
      eval_result = refvar->text;
#line 1253
      if (! eval_result) {
        {
#line 1254
        hsc_message(hp___0, (HSCMSG_ID )16407, "empty reference to %A", destattr);
        }
      }
    } else {
      {
#line 1262
      hsc_msg_unkn_attr_ref(hp___0, nw);
      }
    }
#line 1266
    if (! refvar) {
#line 1268
      destattr->quote = '\"';
#line 1269
      eval_result = (STRPTR )"";
    } else
#line 1266
    if (! eval_result) {
#line 1268
      destattr->quote = '\"';
#line 1269
      eval_result = (STRPTR )"";
    }
  }
#line 1274
  if (eval_result) {
    {
#line 1275
    set_vartext(destattr, eval_result);
    }
  }
  {
#line 1277
  del_hscattr((APTR )eadest);
  }
#line 1278
  return (eval_result);
}
}
#line 1284 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static VOID check_color(HSCPRC *hp___0 , HSCATTR *dest , STRPTR value ) 
{ 
  BOOL ok ;
  size_t color_len ;
  size_t tmp ;
  size_t i ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  LONG tmp___2 ;

  {
  {
#line 1285
  ok = (BOOL )0;
#line 1286
  tmp = strlen("#rrggbb");
#line 1286
  color_len = tmp;
  }
#line 1288
  if ((int )*(value + 0) == 35) {
    {
#line 1290
    tmp___1 = strlen((char const   *)value);
    }
#line 1290
    if (tmp___1 == color_len) {
#line 1291
      i = (size_t )1;
#line 1293
      ok = (BOOL )1;
      {
#line 1294
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1294
        if (! (i < color_len)) {
#line 1294
          goto while_break;
        }
        {
#line 1295
        tmp___0 = __ctype_b_loc();
        }
#line 1295
        if (! ((int const   )*(*tmp___0 + (int )*(value + i)) & 4096)) {
#line 1296
          ok = (BOOL )0;
        }
#line 1294
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else
#line 1301
  if (hp___0->color_names) {
    {
#line 1302
    tmp___2 = strenum((CONSTRPTR )value, (CONSTRPTR )hp___0->color_names, (char )'|',
                      (BYTE )1);
    }
#line 1302
    if (tmp___2) {
#line 1303
      ok = (BOOL )1;
    }
  } else {
#line 1305
    ok = (BOOL )1;
  }
#line 1308
  if (! ok) {
    {
#line 1310
    hsc_message(hp___0, (HSCMSG_ID )12360, "illegal color value %q for %A", value,
                dest);
    }
  }
#line 1314
  return;
}
}
#line 1319 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static VOID check_integer(HSCPRC *hp___0 , HSCATTR *dest , STRPTR value ) 
{ 
  BOOL ok ;
  int i ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;

  {
#line 1320
  ok = (BOOL )0;
#line 1321
  i = 0;
#line 1323
  if ((int )*(value + 0) == 43) {
#line 1324
    i = 1;
  } else
#line 1323
  if ((int )*(value + 0) == 45) {
#line 1324
    i = 1;
  }
  {
#line 1326
  tmp___0 = strlen((char const   *)value);
  }
#line 1326
  if (tmp___0 - (size_t )i) {
#line 1327
    ok = (BOOL )1;
    {
#line 1328
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1328
      if (*(value + i)) {
#line 1328
        if (! ok) {
#line 1328
          goto while_break;
        }
      } else {
#line 1328
        goto while_break;
      }
      {
#line 1329
      tmp = __ctype_b_loc();
      }
#line 1329
      if ((int const   )*(*tmp + (int )*(value + i)) & 2048) {
#line 1332
        i ++;
      } else {
#line 1330
        ok = (BOOL )0;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1336
  if (! ok) {
    {
#line 1338
    hsc_message(hp___0, (HSCMSG_ID )12359, "illegal numeric value %q for %A", value,
                dest);
    }
  }
#line 1342
  return;
}
}
#line 1354 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static HSCATTR *new_cloned_attr(STRPTR debug_name , HSCATTR *attr ) 
{ 
  STRPTR cloned_name ;
  HSCATTR *cloned_attr ;
  HSCATTR *tmp ;

  {
  {
#line 1359
  cloned_name = attr->name;
#line 1361
  tmp = new_hscattr((CONSTRPTR )cloned_name);
#line 1361
  cloned_attr = tmp;
#line 1364
  cloned_attr->vartype = attr->vartype;
#line 1365
  cloned_attr->varflag = attr->varflag;
#line 1366
  cloned_attr->quote = attr->quote;
  }
#line 1368
  return (cloned_attr);
}
}
#line 1371 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
void do_tag_checks(HSCPRC *hp___0 , HSCATTR *dest , STRPTR str ) 
{ 
  EXPSTR *dest_uri ;
  EXPSTR *tmp ;

  {
#line 1376
  if (! (dest->varflag & (unsigned long )(1 << 30))) {
#line 1380
    if ((int )dest->vartype == 1) {
      {
#line 1381
      tmp = ugly_init_estr((size_t )32);
#line 1381
      dest_uri = tmp;
#line 1383
      parse_uri(hp___0, dest_uri, str);
#line 1384
      set_vartext(dest, dest_uri->es_data);
#line 1386
      del_estr(dest_uri);
      }
    }
  }
#line 1389
  return;
}
}
#line 1407 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
STRPTR eval_expression(HSCPRC *hp___0 , HSCATTR *dest , STRPTR endstr ) 
{ 
  INFILE *inpf ;
  EXPSTR *vararg ;
  EXPSTR *tmp ;
  HSCATTR *dest1 ;
  HSCATTR *tmp___0 ;
  STRPTR exprstr ;
  int ch ;
  char *tmp___1 ;
  BOOL err ;
  BYTE op ;
  HSCATTR *dest2 ;
  HSCATTR *tmp___2 ;
  STRPTR str1 ;
  STRPTR tmp___3 ;
  STRPTR str2 ;
  LONG tmp___4 ;
  BOOL tmp___5 ;

  {
  {
#line 1408
  inpf = hp___0->inpf;
#line 1411
  tmp = ugly_init_estr((size_t )128);
#line 1411
  vararg = tmp;
#line 1414
  tmp___0 = new_cloned_attr((STRPTR )"HSC.TMP.1st.operand", dest);
#line 1414
  dest1 = tmp___0;
#line 1416
  exprstr = (STRPTR )((void *)0);
#line 1420
  infskip_ws(inpf);
#line 1423
  ch = infgetc(inpf);
#line 1424
  tmp___1 = strchr("\"\'", ch);
  }
#line 1424
  if (tmp___1) {
#line 1431
    dest1->quote = ch;
  } else
#line 1425
  if (ch != -1) {
#line 1426
    dest1->quote = 0;
  } else {
    {
#line 1428
    hsc_msg_eof(hp___0, (STRPTR )"reading attribute");
    }
  }
#line 1434
  if (ch == 40) {
    {
#line 1436
    exprstr = eval_expression(hp___0, dest1, (STRPTR )")");
    }
#line 1439
    if (! endstr) {
#line 1440
      dest1->quote = '\"';
    }
  } else
#line 1442
  if (ch == 123) {
    {
#line 1445
    exprstr = eval_expression(hp___0, dest1, (STRPTR )"}");
#line 1446
    inungets(exprstr, inpf);
#line 1447
    exprstr = eval_attrref(hp___0, dest1);
    }
  } else
#line 1449
  if (ch != -1) {
    {
#line 1451
    inungetc(ch, inpf);
    }
#line 1453
    if (dest1->quote != 0) {
      {
#line 1455
      exprstr = eval_string_expr(hp___0, dest1);
      }
    } else
#line 1456
    if (endstr) {
      {
#line 1457
      err = (BOOL )0;
#line 1460
      exprstr = try_eval_unary_op(hp___0, dest1, & err);
      }
#line 1463
      if (! exprstr) {
#line 1463
        if (! err) {
          {
#line 1464
          exprstr = eval_attrref(hp___0, dest1);
          }
        }
      }
    } else {
      {
#line 1467
      exprstr = eval_string_expr_noquote(hp___0, dest1);
      }
    }
  }
#line 1471
  if (exprstr) {
#line 1471
    if (endstr) {
      {
#line 1475
      op = eval_op(hp___0);
      }
      {
#line 1479
      if ((int )op == 24) {
#line 1479
        goto case_24;
      }
#line 1479
      if ((int )op == 23) {
#line 1479
        goto case_24;
      }
#line 1482
      if ((int )op == 0) {
#line 1482
        goto case_0;
      }
#line 1485
      goto switch_default;
      case_24: /* CIL Label */ 
      case_23: /* CIL Label */ ;
#line 1481
      goto switch_break;
      case_0: /* CIL Label */ ;
#line 1484
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1487
      if ((int )op != 0) {
        {
#line 1488
        tmp___2 = new_cloned_attr((STRPTR )"HSC.TMP.2nd.operand", dest1);
#line 1488
        dest2 = tmp___2;
#line 1489
        tmp___3 = get_vartext(dest1);
#line 1489
        str1 = tmp___3;
#line 1490
        str2 = (STRPTR )((void *)0);
#line 1492
        str2 = eval_expression(hp___0, dest2, endstr);
        }
#line 1492
        if ((unsigned long )((void *)0) != (unsigned long )str2) {
          {
#line 1493
          process_op(hp___0, dest1, op, str1, str2);
          }
        } else {
#line 1495
          exprstr = (STRPTR )((void *)0);
        }
        {
#line 1498
        del_hscattr((APTR )dest2);
        }
      } else {
#line 1500
        exprstr = (STRPTR )((void *)0);
      }
#line 1502
      if (exprstr) {
        {
#line 1504
        exprstr = get_vartext(dest1);
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1509
  if (! endstr) {
#line 1511
    if (exprstr) {
#line 1513
      if ((int )dest1->vartype != 3) {
#line 1513
        if (! (dest1->varflag & (unsigned long )((1 << 30) | (1 << 28)))) {
          {
#line 1514
          choose_quote(hp___0, dest1);
          }
        }
      }
#line 1517
      if ((int )dest1->vartype == 5) {
        {
#line 1520
        tmp___4 = strenum((CONSTRPTR )exprstr, (CONSTRPTR )dest->enumstr, (char )'|',
                          (BYTE )1);
        }
#line 1520
        if (! tmp___4) {
          {
#line 1522
          hsc_message(hp___0, (HSCMSG_ID )12323, "unknown value %q for enumerator %A",
                      exprstr, dest);
          }
        }
      } else
#line 1526
      if ((int )dest1->vartype == 7) {
        {
#line 1528
        check_color(hp___0, dest1, exprstr);
        }
      } else
#line 1529
      if ((int )dest1->vartype == 4) {
        {
#line 1531
        check_integer(hp___0, dest1, exprstr);
        }
      } else
#line 1532
      if ((int )dest1->vartype == 3) {
        {
#line 1538
        tmp___5 = eval_boolstr(exprstr);
        }
#line 1538
        if (tmp___5) {
          {
#line 1539
          set_vartext(dest1, dest1->name);
          }
        } else {
          {
#line 1541
          set_vartext(dest1, (STRPTR )"");
          }
        }
      }
      {
#line 1543
      do_tag_checks(hp___0, dest1, exprstr);
#line 1544
      exprstr = get_vartext(dest1);
      }
    } else {
      {
#line 1549
      skip_until_eot(hp___0, (EXPSTR *)((void *)0));
      }
#line 1550
      if (! hp___0->fatal) {
        {
#line 1551
        inungetcw(inpf);
        }
      }
    }
  }
#line 1556
  if (exprstr) {
    {
#line 1557
    set_vartext(dest, exprstr);
#line 1558
    dest->quote = dest1->quote;
#line 1559
    exprstr = get_vartext(dest);
    }
  }
  {
#line 1563
  del_hscattr((APTR )dest1);
#line 1564
  del_estr(vararg);
  }
#line 1566
  return (exprstr);
}
}
#line 1582 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
static STRPTR assign_conditional_attr(HSCPRC *hp___0 , HSCATTR *dest , STRPTR source_name ) 
{ 
  STRPTR attrval ;
  HSCATTR *tmpdest ;
  HSCATTR *tmp ;
  HSCATTR *attr ;
  HSCATTR *tmp___0 ;

  {
#line 1583
  attrval = (STRPTR )((void *)0);
#line 1585
  if (source_name) {
    {
#line 1586
    tmp = new_hscattr("HSC.TMP.check.attrname");
#line 1586
    tmpdest = tmp;
#line 1588
    source_name = check_attrname(hp___0, tmpdest, source_name, (BOOL )1);
    }
#line 1588
    if ((unsigned long )((void *)0) != (unsigned long )source_name) {
      {
#line 1589
      tmp___0 = find_varname(hp___0->defattr, source_name);
#line 1589
      attr = tmp___0;
      }
#line 1591
      if (attr) {
        {
#line 1592
        attrval = get_vartext(attr);
#line 1593
        dest->quote = attr->quote;
        }
      } else {
        {
#line 1595
        hsc_msg_unkn_attr_ref(hp___0, source_name);
        }
      }
    }
    {
#line 1598
    del_hscattr((APTR )tmpdest);
    }
  } else {
    {
#line 1600
    display_panic_message((char *)"no source attribute", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c",
                          (size_t )1600);
    }
  }
#line 1604
  if (attrval) {
    {
#line 1605
    set_vartext(dest, attrval);
#line 1606
    attrval = get_vartext(dest);
#line 1607
    do_tag_checks(hp___0, dest, attrval);
    }
#line 1608
    if (! (dest->varflag & (unsigned long )(1 << 30))) {
      {
#line 1608
      choose_quote(hp___0, dest);
      }
    }
  }
#line 1611
  return (attrval);
}
}
#line 1626 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/eval.c"
STRPTR eval_conditional_assignment(HSCPRC *hp___0 , HSCATTR *dest ) 
{ 
  STRPTR nw ;
  STRPTR tmp ;
  STRPTR attr_val ;
  HSCATTR *tmp_attr ;
  STRPTR source_name ;
  int tmp___0 ;

  {
  {
#line 1627
  tmp = infgetw(hp___0->inpf);
#line 1627
  nw = tmp;
#line 1628
  attr_val = (STRPTR )((void *)0);
  }
#line 1632
  if (nw) {
    {
#line 1635
    tmp_attr = (HSCATTR *)((void *)0);
#line 1636
    source_name = (STRPTR )((void *)0);
#line 1638
    tmp___0 = strcmp((char const   *)nw, "(");
    }
#line 1638
    if (tmp___0) {
#line 1644
      source_name = nw;
    } else {
      {
#line 1640
      tmp_attr = new_hscattr("HSC.TMP.conditional.assignment");
#line 1641
      source_name = eval_expression(hp___0, tmp_attr, (STRPTR )")");
      }
    }
#line 1647
    if (source_name) {
      {
#line 1649
      attr_val = assign_conditional_attr(hp___0, dest, source_name);
      }
    }
#line 1653
    if (tmp_attr) {
      {
#line 1654
      del_hscattr((APTR )tmp_attr);
      }
    }
  } else {
    {
#line 1658
    hsc_msg_eof(hp___0, (STRPTR )"conditional attribute identifier expected");
    }
  }
#line 1661
  return (attr_val);
}
}
#line 157 "./hsclib/attrib.h"
VOID clr_varlist_bool(DLLIST *varlist ) ;
#line 40 "./hsclib/lmessage.h"
VOID hsc_msg_unkn_attr_tag(HSCPRC *hp___0 , STRPTR attr , STRPTR tag ) ;
#line 41
VOID hsc_msg_unkn_attr_macro(HSCPRC *hp___0 , STRPTR attr , STRPTR macro ) ;
#line 44 "./hsclib/input.h"
BOOL parse_eq(HSCPRC *hp___0 ) ;
#line 32 "./hsclib/css.h"
BOOL add_styleattr(HSCPRC *hp___0 , CONSTRPTR property , CONSTRPTR value ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c"
HSCTAG *def_tag_name(HSCPRC *hp___0 , BOOL *start_tag ) 
{ 
  STRPTR nw ;
  HSCTAG *tag ;
  DLLIST *taglist ;
  int tmp ;
  DLNODE *nd ;
  DLNODE *tmp___0 ;

  {
  {
#line 48
  nw = (STRPTR )((void *)0);
#line 49
  tag = (HSCTAG *)((void *)0);
#line 50
  taglist = hp___0->deftag;
#line 53
  nw = infget_tagid(hp___0);
  }
#line 56
  if (nw) {
    {
#line 58
    tmp = strcmp((char const   *)nw, "/");
#line 58
    *start_tag = (BOOL )tmp;
    }
#line 59
    if (! *start_tag) {
      {
#line 62
      nw = infget_tagid(hp___0);
      }
#line 63
      if (nw) {
        {
#line 65
        tag = find_strtag(taglist, nw);
        }
#line 66
        if (tag) {
#line 68
          if (tag->option & (unsigned long )(1 << 1)) {
            {
#line 73
            tag = (HSCTAG *)((void *)0);
#line 74
            hsc_message(hp___0, (HSCMSG_ID )16436, "redefined %c", nw);
            }
          } else
#line 68
          if (tag->option & (unsigned long )(1 << 16)) {
            {
#line 73
            tag = (HSCTAG *)((void *)0);
#line 74
            hsc_message(hp___0, (HSCMSG_ID )16436, "redefined %c", nw);
            }
          } else {
#line 80
            tag->option |= (unsigned long )(1 << 1);
          }
        } else {
          {
#line 86
          tag = (HSCTAG *)((void *)0);
#line 87
          hsc_message(hp___0, (HSCMSG_ID )61497, "no start tag for %c", nw);
          }
        }
      }
    } else {
      {
#line 94
      tag = find_strtag(taglist, nw);
      }
#line 95
      if (tag) {
        {
#line 100
        tmp___0 = find_dlnode((hp___0->deftag)->first, (APTR )nw, & cmp_strtag);
#line 100
        nd = tmp___0;
#line 104
        tag->occured = (BOOL )0;
#line 106
        hsc_message(hp___0, (HSCMSG_ID )12347, "redefined %T", tag);
#line 108
        del_dlnode(hp___0->deftag, nd);
        }
      }
      {
#line 113
      tag = app_tag(taglist, nw);
      }
    }
  }
#line 117
  return (tag);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c"
static BOOL check_tag_option(HSCPRC *hp___0 , STRPTR option , HSCTAG *tag , STRPTR id ,
                             STRPTR sid , ULONG value ) 
{ 
  BOOL found ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 136
  found = (BOOL )0;
#line 138
  tmp = upstrcmp((CONSTRPTR )option, (CONSTRPTR )id);
  }
#line 138
  if (tmp) {
    {
#line 138
    tmp___0 = upstrcmp((CONSTRPTR )option, (CONSTRPTR )sid);
    }
#line 138
    if (! tmp___0) {
#line 141
      tag->option |= value;
#line 142
      found = (BOOL )1;
    }
  } else {
#line 141
    tag->option |= value;
#line 142
    found = (BOOL )1;
  }
#line 145
  return (found);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c"
static HSCATTR *def_lazy_attr(HSCPRC *hp___0 , HSCTAG *tag , STRPTR attrname , BYTE attrtype ,
                              ULONG flags ) 
{ 
  HSCATTR *newattr ;
  HSCATTR *tmp ;

  {
  {
#line 168
  tmp = app_var(tag->attr, attrname);
#line 168
  newattr = tmp;
#line 170
  newattr->vartype = attrtype;
#line 171
  newattr->varflag = flags;
  }
#line 172
  return (newattr);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c"
static BOOL parse_lazy_option(HSCPRC *hp___0 , HSCTAG *tag , STRPTR lazy ) 
{ 
  BOOL ok ;
  HSCATTR *attr ;
  STRPTR tmp ;

  {
#line 177
  ok = (BOOL )1;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! *(lazy + 0)) {
#line 180
      goto while_break;
    }
    {
#line 184
    if ((int )*(lazy + 0) == 99) {
#line 184
      goto case_99;
    }
#line 187
    if ((int )*(lazy + 0) == 100) {
#line 187
      goto case_100;
    }
#line 191
    if ((int )*(lazy + 0) == 104) {
#line 191
      goto case_104;
    }
#line 194
    if ((int )*(lazy + 0) == 105) {
#line 194
      goto case_105;
    }
#line 197
    if ((int )*(lazy + 0) == 107) {
#line 197
      goto case_107;
    }
#line 201
    if ((int )*(lazy + 0) == 108) {
#line 201
      goto case_108;
    }
#line 204
    if ((int )*(lazy + 0) == 109) {
#line 204
      goto case_109;
    }
#line 208
    if ((int )*(lazy + 0) == 115) {
#line 208
      goto case_115;
    }
#line 211
    if ((int )*(lazy + 0) == 116) {
#line 211
      goto case_116;
    }
#line 214
    if ((int )*(lazy + 0) == 118) {
#line 214
      goto case_118;
    }
#line 226
    if ((int )*(lazy + 0) == 121) {
#line 226
      goto case_121;
    }
#line 229
    goto switch_default;
    case_99: /* CIL Label */ 
    {
#line 185
    def_lazy_attr(hp___0, tag, (STRPTR )"CLASS", (BYTE )2, (ULONG )0);
    }
#line 186
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 188
    attr = def_lazy_attr(hp___0, tag, (STRPTR )"DIR", (BYTE )5, (ULONG )0);
#line 189
    attr->enumstr = ugly_strclone("ltr|rtl", (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c",
                                  (ULONG )189);
    }
#line 190
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 192
    def_lazy_attr(hp___0, tag, (STRPTR )"HREF", (BYTE )1, (ULONG )0);
    }
#line 193
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 195
    def_lazy_attr(hp___0, tag, (STRPTR )"ID", (BYTE )6, (ULONG )0);
    }
#line 196
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 198
    attr = def_lazy_attr(hp___0, tag, (STRPTR )"CLEAR", (BYTE )5, (ULONG )0);
#line 199
    attr->enumstr = ugly_strclone("left|right|all|none", (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c",
                                  (ULONG )199);
    }
#line 200
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 202
    def_lazy_attr(hp___0, tag, (STRPTR )"LANG", (BYTE )2, (ULONG )0);
    }
#line 203
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 206
    def_lazy_attr(hp___0, tag, (STRPTR )"MD", (BYTE )2, (ULONG )0);
    }
#line 207
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 209
    def_lazy_attr(hp___0, tag, (STRPTR )"SRC", (BYTE )1, (ULONG )0);
    }
#line 210
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 212
    def_lazy_attr(hp___0, tag, (STRPTR )"TITLE", (BYTE )2, (ULONG )0);
    }
#line 213
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 216
    def_lazy_attr(hp___0, tag, (STRPTR )"ONCLICK", (BYTE )2, (ULONG )0);
#line 217
    def_lazy_attr(hp___0, tag, (STRPTR )"ONDBLCLICK", (BYTE )2, (ULONG )0);
#line 218
    def_lazy_attr(hp___0, tag, (STRPTR )"ONMOUSEDOWN", (BYTE )2, (ULONG )0);
#line 219
    def_lazy_attr(hp___0, tag, (STRPTR )"ONMOUSEUP", (BYTE )2, (ULONG )0);
#line 220
    def_lazy_attr(hp___0, tag, (STRPTR )"ONMOUSEOVER", (BYTE )2, (ULONG )0);
#line 221
    def_lazy_attr(hp___0, tag, (STRPTR )"ONMOUSEMOVE", (BYTE )2, (ULONG )0);
#line 222
    def_lazy_attr(hp___0, tag, (STRPTR )"ONMOUSEOUT", (BYTE )2, (ULONG )0);
#line 223
    def_lazy_attr(hp___0, tag, (STRPTR )"ONKEYDOWN", (BYTE )2, (ULONG )0);
#line 224
    def_lazy_attr(hp___0, tag, (STRPTR )"ONKEYUP", (BYTE )2, (ULONG )0);
    }
#line 225
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 227
    def_lazy_attr(hp___0, tag, (STRPTR )"STYLE", (BYTE )2, (ULONG )0);
    }
#line 228
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 230
    tmp = ch2str((char const   )*(lazy + 0));
#line 230
    hsc_message(hp___0, (HSCMSG_ID )16401, "unknown tag modifier %q (arg %q)", "LAZY",
                tmp);
    }
#line 233
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 235
    lazy ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return (ok);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c"
static BOOL parse_tag_option(HSCPRC *hp___0 , STRPTR option , HSCTAG *tag ) 
{ 
  BOOL ok ;
  HSCATTR *attr ;
  HSCATTR *tmp ;
  STRPTR strmbi ;
  STRPTR tmp___0 ;
  BOOL tmp___1 ;
  STRPTR strnaw ;
  STRPTR tmp___2 ;
  BOOL tmp___3 ;
  STRPTR strlazy ;
  STRPTR tmp___4 ;
  BOOL tmp___5 ;
  BOOL tmp___6 ;
  BOOL tmp___7 ;
  BOOL tmp___8 ;
  int tmp___9 ;
  BOOL tmp___10 ;
  BOOL tmp___11 ;
  BOOL tmp___12 ;
  BOOL tmp___13 ;
  BOOL tmp___14 ;
  BOOL tmp___15 ;
  BOOL tmp___16 ;
  BOOL tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  {
#line 254
  ok = (BOOL )0;
#line 255
  tmp = new_hscattr("HSC.TMP.mbi.naw");
#line 255
  attr = tmp;
#line 257
  attr->vartype = (BYTE )2;
#line 259
  tmp___22 = upstrcmp((CONSTRPTR )option, "MUST_BE_INSIDE");
  }
#line 259
  if (tmp___22) {
    {
#line 259
    tmp___23 = upstrcmp((CONSTRPTR )option, "MBI");
    }
#line 259
    if (tmp___23) {
      {
#line 271
      tmp___20 = upstrcmp((CONSTRPTR )option, "NOT_ALLOWED_WITHIN");
      }
#line 271
      if (tmp___20) {
        {
#line 271
        tmp___21 = upstrcmp((CONSTRPTR )option, "NAW");
        }
#line 271
        if (tmp___21) {
          {
#line 283
          tmp___18 = upstrcmp((CONSTRPTR )option, "LAZY");
          }
#line 283
          if (tmp___18) {
            {
#line 283
            tmp___19 = upstrcmp((CONSTRPTR )option, "L");
            }
#line 283
            if (tmp___19) {
              {
#line 295
              tmp___6 = check_tag_option(hp___0, option, tag, (STRPTR )"CLOSE", (STRPTR )"C",
                                         (ULONG )(1 << 1));
#line 295
              ok = (BOOL )((int )ok | (int )tmp___6);
#line 299
              tmp___7 = check_tag_option(hp___0, option, tag, (STRPTR )"SPECIAL",
                                         (STRPTR )"SPC", (ULONG )(1 << 4));
#line 299
              ok = (BOOL )((int )ok | (int )tmp___7);
#line 301
              tmp___8 = check_tag_option(hp___0, option, tag, (STRPTR )"JERK", (STRPTR )"J",
                                         (ULONG )(1 << 6));
#line 301
              ok = (BOOL )((int )ok | (int )tmp___8);
              }
#line 303
              if (hp___0->xhtml) {
#line 303
                tmp___9 = 1 << 1;
              } else {
#line 303
                tmp___9 = 1 << 7;
              }
              {
#line 303
              tmp___10 = check_tag_option(hp___0, option, tag, (STRPTR )"AUTOCLOSE",
                                          (STRPTR )"AC", (ULONG )tmp___9);
#line 303
              ok = (BOOL )((int )ok | (int )tmp___10);
#line 306
              tmp___11 = check_tag_option(hp___0, option, tag, (STRPTR )"EMPTY", (STRPTR )"E",
                                          (ULONG )(1 << 17));
#line 306
              ok = (BOOL )((int )ok | (int )tmp___11);
#line 308
              tmp___12 = check_tag_option(hp___0, option, tag, (STRPTR )"OBSOLETE",
                                          (STRPTR )"O", (ULONG )(1 << 5));
#line 308
              ok = (BOOL )((int )ok | (int )tmp___12);
#line 310
              tmp___13 = check_tag_option(hp___0, option, tag, (STRPTR )"ONLYONCE",
                                          (STRPTR )"1", (ULONG )(1 << 3));
#line 310
              ok = (BOOL )((int )ok | (int )tmp___13);
#line 312
              tmp___14 = check_tag_option(hp___0, option, tag, (STRPTR )"REQUIRED",
                                          (STRPTR )"R", (ULONG )(1 << 2));
#line 312
              ok = (BOOL )((int )ok | (int )tmp___14);
#line 314
              tmp___15 = check_tag_option(hp___0, option, tag, (STRPTR )"RECOMMENDED",
                                          (STRPTR )"RCMD", (ULONG )(1 << 15));
#line 314
              ok = (BOOL )((int )ok | (int )tmp___15);
#line 316
              tmp___16 = check_tag_option(hp___0, option, tag, (STRPTR )"SKIPLF",
                                          (STRPTR )"S", (ULONG )(1 << 13));
#line 316
              ok = (BOOL )((int )ok | (int )tmp___16);
#line 318
              tmp___17 = check_tag_option(hp___0, option, tag, (STRPTR )"WHTSPC",
                                          (STRPTR )"W", (ULONG )(1 << 12));
#line 318
              ok = (BOOL )((int )ok | (int )tmp___17);
              }
#line 322
              if (tag->option & (unsigned long )(1 << 17)) {
#line 322
                if (hp___0->xhtml) {
#line 325
                  tag->option &= (unsigned long )(~ (1 << 1));
                }
              }
#line 328
              if (! ok) {
                {
#line 329
                hsc_message(hp___0, (HSCMSG_ID )16401, "unknown tag modifer %q", option);
                }
              }
            } else {
#line 283
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 286
            tmp___5 = parse_eq(hp___0);
            }
#line 286
            if (tmp___5) {
              {
#line 287
              tmp___4 = eval_expression(hp___0, attr, (STRPTR )((void *)0));
#line 287
              strlazy = tmp___4;
              }
#line 289
              if (strlazy) {
                {
#line 291
                ok = parse_lazy_option(hp___0, tag, strlazy);
                }
              }
            }
          }
        } else {
#line 271
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 274
        tmp___3 = parse_eq(hp___0);
        }
#line 274
        if (tmp___3) {
          {
#line 275
          tmp___2 = eval_expression(hp___0, attr, (STRPTR )((void *)0));
#line 275
          strnaw = tmp___2;
          }
#line 277
          if (strnaw) {
            {
#line 278
            tag->naw = ugly_strclone((CONSTRPTR )strnaw, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c",
                                     (ULONG )278);
#line 280
            ok = (BOOL )1;
            }
          }
        }
      }
    } else {
#line 259
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 262
    tmp___1 = parse_eq(hp___0);
    }
#line 262
    if (tmp___1) {
      {
#line 263
      tmp___0 = eval_expression(hp___0, attr, (STRPTR )((void *)0));
#line 263
      strmbi = tmp___0;
      }
#line 265
      if (strmbi) {
        {
#line 266
        tag->mbi = ugly_strclone((CONSTRPTR )strmbi, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c",
                                 (ULONG )266);
#line 268
        ok = (BOOL )1;
        }
      }
    }
  }
  {
#line 334
  del_hscattr((APTR )attr);
  }
#line 336
  return (ok);
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c"
static BOOL parse_tag_var(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL ok ;
  HSCATTR *var ;

  {
  {
#line 343
  ok = (BOOL )0;
#line 344
  var = (HSCATTR *)((void *)0);
#line 347
  var = define_var(hp___0, tag->attr, (ULONG )((1 << 2) | (1 << 29)));
  }
#line 352
  if (var) {
#line 354
    if (var->varflag & (unsigned long )(1 << 5)) {
#line 355
      tag->uri_size = var;
    }
#line 358
    if (var->varflag & (unsigned long )(1 << 4)) {
#line 359
      tag->uri_stripext = var;
    }
#line 362
    if (tag->option & (unsigned long )(1 << 30)) {
#line 363
      var->varflag |= (unsigned long )(1 << 28);
    }
#line 366
    if (tag->option & (unsigned long )(1 << 10)) {
#line 367
      var->varflag |= (unsigned long )(1 << 30);
    }
#line 369
    ok = (BOOL )1;
  }
#line 372
  return (ok);
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c"
BOOL def_tag_args(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL ok ;
  STRPTR nw ;
  INFILE *inpf ;
  BOOL tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  BOOL tmp___3 ;
  STRPTR name ;
  STRPTR tmp___4 ;
  HSCTAG *lazy ;
  HSCTAG *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 380
  ok = (BOOL )0;
#line 382
  inpf = hp___0->inpf;
#line 384
  if (tag) {
    {
#line 385
    ok = (BOOL )1;
#line 388
    nw = infgetw(inpf);
    }
    {
#line 393
    while (1) {
      while_continue: /* CIL Label */ ;
#line 393
      if (nw) {
        {
#line 393
        tmp___0 = strcmp((char const   *)nw, "/");
        }
#line 393
        if (tmp___0) {
#line 393
          goto while_break;
        }
      } else {
#line 393
        goto while_break;
      }
      {
#line 394
      nw = infgetw(inpf);
      }
#line 395
      if (nw) {
        {
#line 396
        tmp = parse_tag_option(hp___0, nw, tag);
#line 396
        ok = (BOOL )((int )ok & (int )tmp);
#line 397
        nw = infgetw(inpf);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 402
    tmp___1 = strlen("$");
#line 402
    tmp___2 = strncmp((char const   *)tag->name, "$", tmp___1);
    }
#line 402
    if (! tmp___2) {
#line 403
      tag->option |= (unsigned long )(1 << 30);
    }
    {
#line 408
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 408
      if (nw) {
        {
#line 408
        tmp___7 = strcmp((char const   *)nw, ">");
        }
#line 408
        if (! tmp___7) {
#line 408
          goto while_break___0;
        }
      } else {
#line 408
        goto while_break___0;
      }
      {
#line 409
      tmp___6 = strcmp((char const   *)nw, "[");
      }
#line 409
      if (tmp___6) {
        {
#line 411
        inungetcw(inpf);
#line 412
        tmp___3 = parse_tag_var(hp___0, tag);
#line 412
        ok = (BOOL )((int )ok & (int )tmp___3);
        }
      } else {
        {
#line 415
        tmp___4 = infget_tagid(hp___0);
#line 415
        name = tmp___4;
        }
#line 416
        if (nw) {
          {
#line 417
          tmp___5 = find_strtag(hp___0->deflazy, name);
#line 417
          lazy = tmp___5;
          }
#line 418
          if (lazy) {
            {
#line 419
            copy_local_varlist(tag->attr, lazy->attr, (ULONG )0);
            }
          } else {
            {
#line 421
            hsc_message(hp___0, (HSCMSG_ID )16416, "unknown %l", name);
            }
          }
        }
        {
#line 423
        parse_wd(hp___0, (STRPTR )"]");
        }
      }
      {
#line 425
      nw = infgetw(inpf);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 430
    if (nw) {
      {
#line 431
      inungetcw(inpf);
#line 432
      ok = parse_gt(hp___0);
      }
    }
  }
#line 436
  return (ok);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c"
static BOOL set_tag_arg(HSCPRC *hp___0 , DLLIST *varlist , STRPTR varname , STRPTR tagname ,
                        BOOL tag_unknown , BOOL is_macro_tag___0 ) 
{ 
  HSCATTR *attr ;
  HSCATTR *tmp ;
  INFILE *inpf ;
  STRPTR arg ;
  BOOL ok ;
  BOOL inheritage_failed ;
  STRPTR nw ;
  HSCATTR skipvar ;
  EXPSTR *attr_str ;
  EXPSTR *tmp___0 ;
  EXPSTR *val_str ;
  EXPSTR *tmp___1 ;
  BOOL is_styleattr ;
  int tmp___2 ;
  int tmp___3 ;
  STRPTR tmp___4 ;
  STRPTR tmp___5 ;
  STRPTR tmp___6 ;
  STRPTR tmp___7 ;
  STRPTR tmp___8 ;
  STRPTR tmp___9 ;
  STRPTR tmp___10 ;
  STRPTR tmp___11 ;
  BOOL tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  BOOL tmp___15 ;
  BOOL tmp___16 ;
  char *s___2 ;
  char *t ;
  char *q ;
  unsigned short const   **tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  BOOL done ;
  STRPTR cstyle ;
  STRPTR nstyle ;
  STRPTR value ;
  STRPTR tmp___20 ;
  unsigned short const   **tmp___21 ;
  STRPTR tmp___22 ;
  unsigned short const   **tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;

  {
  {
#line 446
  tmp = find_varname(varlist, varname);
#line 446
  attr = tmp;
#line 447
  inpf = hp___0->inpf;
#line 448
  arg = (STRPTR )((void *)0);
#line 449
  ok = (BOOL )0;
#line 450
  inheritage_failed = (BOOL )0;
#line 453
  tmp___0 = ugly_init_estr((size_t )40);
#line 453
  attr_str = tmp___0;
#line 454
  tmp___1 = ugly_init_estr((size_t )40);
#line 454
  val_str = tmp___1;
#line 455
  tmp___2 = upstrcmp((CONSTRPTR )varname, "STYLE");
#line 455
  is_styleattr = (BOOL )(0 == tmp___2);
#line 460
  tmp___3 = strcmp((char const   *)varname, "/");
  }
#line 460
  if (! tmp___3) {
#line 460
    return ((BOOL )1);
  }
#line 463
  if (hp___0->compact) {
    {
#line 464
    ugly_app_estr(attr_str, " ");
    }
  } else {
    {
#line 466
    tmp___4 = infgetcws(inpf);
#line 466
    ugly_app_estr(attr_str, (CONSTRPTR )tmp___4);
    }
  }
  {
#line 468
  tmp___5 = infgetcw(inpf);
#line 468
  ugly_app_estr(attr_str, (CONSTRPTR )tmp___5);
  }
#line 471
  if (hp___0->lctags) {
    {
#line 472
    lowstr(attr_str->es_data);
    }
  }
#line 474
  if (! attr) {
#line 476
    attr = & skipvar;
#line 477
    attr->name = varname;
#line 478
    attr->deftext = (STRPTR )((void *)0);
#line 479
    attr->text = (STRPTR )((void *)0);
#line 480
    attr->enumstr = (STRPTR )((void *)0);
#line 481
    attr->vartype = (BYTE )2;
#line 482
    attr->varflag = (ULONG )0;
#line 489
    if (! tag_unknown) {
#line 490
      if (is_macro_tag___0) {
        {
#line 491
        hsc_msg_unkn_attr_macro(hp___0, varname, tagname);
        }
      } else {
        {
#line 493
        hsc_msg_unkn_attr_tag(hp___0, varname, tagname);
        }
      }
    }
  }
  {
#line 498
  nw = infgetw(inpf);
  }
#line 499
  if (nw) {
    {
#line 500
    tmp___14 = strcmp((char const   *)nw, "=");
    }
#line 500
    if (tmp___14) {
      {
#line 520
      tmp___13 = strcmp((char const   *)nw, "?");
      }
#line 520
      if (tmp___13) {
        {
#line 548
        arg = (STRPTR )((void *)0);
#line 549
        inungetcwws(inpf);
        }
#line 550
        if ((unsigned long )attr == (unsigned long )(& skipvar)) {
#line 551
          attr->vartype = (BYTE )3;
        }
#line 552
        ok = (BOOL )1;
      } else {
#line 522
        if (! hp___0->compact) {
          {
#line 523
          tmp___9 = infgetcws(inpf);
#line 523
          ugly_app_estr(val_str, (CONSTRPTR )tmp___9);
          }
        }
        {
#line 524
        tmp___12 = parse_eq(hp___0);
        }
#line 524
        if (tmp___12) {
#line 525
          if (! is_styleattr) {
            {
#line 526
            ugly_app_estr(val_str, "=");
            }
          }
          {
#line 528
          arg = eval_conditional_assignment(hp___0, attr);
          }
#line 531
          if (! is_styleattr) {
#line 531
            if (attr->quote != 0) {
              {
#line 532
              ugly_app_estrch(val_str, attr->quote);
              }
            }
          }
          {
#line 533
          tmp___11 = get_vartext(attr);
          }
#line 533
          if (tmp___11) {
            {
#line 534
            tmp___10 = get_vartext(attr);
#line 534
            ugly_app_estr(val_str, (CONSTRPTR )tmp___10);
            }
          }
#line 535
          if (! is_styleattr) {
#line 535
            if (attr->quote != 0) {
              {
#line 536
              ugly_app_estrch(val_str, attr->quote);
              }
            }
          }
#line 538
          if (! arg) {
#line 542
            inheritage_failed = (BOOL )1;
          }
#line 544
          ok = (BOOL )1;
        }
      }
    } else {
#line 502
      if (! is_styleattr) {
        {
#line 502
        tmp___6 = infgetcw(inpf);
#line 502
        ugly_app_estr(val_str, (CONSTRPTR )tmp___6);
        }
      }
      {
#line 505
      arg = eval_expression(hp___0, attr, (STRPTR )((void *)0));
      }
#line 508
      if (! is_styleattr) {
#line 508
        if (attr->quote != 0) {
          {
#line 509
          ugly_app_estrch(val_str, attr->quote);
          }
        }
      }
      {
#line 510
      tmp___8 = get_vartext(attr);
      }
#line 510
      if (tmp___8) {
        {
#line 511
        tmp___7 = get_vartext(attr);
#line 511
        ugly_app_estr(val_str, (CONSTRPTR )tmp___7);
        }
      }
#line 512
      if (! is_styleattr) {
#line 512
        if (attr->quote != 0) {
          {
#line 513
          ugly_app_estrch(val_str, attr->quote);
          }
        }
      }
#line 516
      if (arg) {
#line 518
        ok = (BOOL )1;
      }
    }
  } else {
    {
#line 554
    hsc_msg_eof(hp___0, (STRPTR )"read attribute value");
    }
  }
#line 556
  if (ok) {
#line 557
    if (arg) {
#line 558
      if ((int )attr->vartype == 3) {
        {
#line 560
        tmp___15 = get_varbool(attr);
#line 560
        set_varbool(attr, tmp___15);
#line 565
        tmp___16 = get_varbool(attr);
        }
#line 565
        if (! tmp___16) {
          {
#line 566
          ugly_clr_estr(attr_str);
          }
        }
      } else
#line 567
      if (! inheritage_failed) {
        {
#line 569
        estrcat(attr_str, val_str);
        }
      }
    } else
#line 571
    if (inheritage_failed) {
      {
#line 575
      ugly_clr_estr(attr_str);
      }
    } else
#line 578
    if ((int )attr->vartype == 3) {
      {
#line 583
      set_varbool(attr, (BOOL )1);
      }
    } else
#line 584
    if (! tag_unknown) {
      {
#line 588
      hsc_message(hp___0, (HSCMSG_ID )16426, "missing value for %A", attr);
      }
    }
  }
#line 595
  if (hp___0->xhtml) {
#line 595
    if (3 == (int )attr->vartype) {
#line 598
      if (3L == hp___0->quotemode) {
#line 598
        q = (char *)"\'";
      } else {
#line 598
        q = (char *)"\"";
      }
      {
#line 600
      t = ugly_strclone((CONSTRPTR )attr_str->es_data, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c",
                        (ULONG )600);
#line 600
      s___2 = t;
      }
      {
#line 602
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 602
        tmp___17 = __ctype_b_loc();
        }
#line 602
        if (! ((int const   )*(*tmp___17 + (int )*t) & 8192)) {
#line 602
          goto while_break;
        }
#line 602
        t ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 604
      ugly_app_estr(attr_str, "=");
#line 605
      ugly_app_estr(attr_str, (CONSTRPTR )q);
#line 606
      ugly_app_estr(attr_str, (CONSTRPTR )t);
#line 607
      ugly_app_estr(attr_str, (CONSTRPTR )q);
#line 608
      ugly_freestr(s___2, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c",
                   (ULONG )608);
#line 608
      s___2 = (char *)((void *)0);
      }
    } else {
#line 595
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 609
  if (hp___0->lctags) {
#line 609
    if (5 == (int )attr->vartype) {
      {
#line 611
      lowstr(attr_str->es_data);
      }
    }
  }
#line 615
  if (attr->varflag & (unsigned long )(1 << 7)) {
    {
#line 615
    tmp___18 = strlen((char const   *)val_str->es_data);
    }
#line 615
    if (tmp___18) {
      {
#line 615
      tmp___19 = strlen((char const   *)attr_str->es_data);
      }
#line 615
      if (tmp___19) {
        {
#line 618
        hsc_message(hp___0, (HSCMSG_ID )12375, "%A is obsolete", attr);
        }
      }
    }
  }
#line 622
  if ((unsigned long )attr == (unsigned long )(& skipvar)) {
    {
#line 623
    clr_vartext(attr);
    }
  }
#line 625
  if (is_styleattr) {
    {
#line 625
    tmp___26 = strlen((char const   *)val_str->es_data);
    }
#line 625
    if (tmp___26) {
      {
#line 625
      tmp___27 = strlen((char const   *)attr_str->es_data);
      }
#line 625
      if (tmp___27) {
#line 627
        done = (BOOL )0;
#line 630
        cstyle = val_str->es_data;
        {
#line 632
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 636
          nstyle = strchr((char const   *)cstyle, ';');
          }
#line 636
          if ((unsigned long )((void *)0) != (unsigned long )nstyle) {
#line 638
            tmp___20 = nstyle;
#line 638
            nstyle ++;
#line 638
            *tmp___20 = (char )'\000';
            {
#line 640
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 640
              tmp___21 = __ctype_b_loc();
              }
#line 640
              if (! ((int const   )*(*tmp___21 + (int )*nstyle) & 8192)) {
#line 640
                goto while_break___1;
              }
#line 640
              nstyle ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 642
            if (0 == (int )*nstyle) {
#line 643
              done = (BOOL )1;
            }
          } else {
#line 645
            done = (BOOL )1;
          }
          {
#line 647
          value = strchr((char const   *)cstyle, ':');
          }
#line 648
          if ((unsigned long )((void *)0) != (unsigned long )value) {
#line 650
            tmp___22 = value;
#line 650
            value ++;
#line 650
            *tmp___22 = (char )'\000';
            {
#line 652
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 652
              tmp___23 = __ctype_b_loc();
              }
#line 652
              if (! ((int const   )*(*tmp___23 + (int )*value) & 8192)) {
#line 652
                goto while_break___2;
              }
#line 652
              value ++;
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 654
            tmp___24 = strlen((char const   *)cstyle);
            }
#line 654
            if (tmp___24) {
              {
#line 654
              tmp___25 = strlen((char const   *)value);
              }
#line 654
              if (tmp___25) {
                {
#line 655
                add_styleattr(hp___0, (CONSTRPTR )cstyle, (CONSTRPTR )value);
                }
              } else {
                {
#line 657
                hsc_message(hp___0, (HSCMSG_ID )12378, "invalid CSS style definition `%s:%s\'",
                            cstyle, value);
                }
              }
            } else {
              {
#line 657
              hsc_message(hp___0, (HSCMSG_ID )12378, "invalid CSS style definition `%s:%s\'",
                          cstyle, value);
              }
            }
          } else {
            {
#line 661
            hsc_message(hp___0, (HSCMSG_ID )12378, "invalid CSS style definition %q",
                        cstyle);
            }
          }
#line 665
          cstyle = nstyle;
#line 632
          if (! (! done)) {
#line 632
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 669
        ugly_app_estr(hp___0->tag_attr_str, (CONSTRPTR )attr_str->es_data);
        }
      }
    } else {
      {
#line 669
      ugly_app_estr(hp___0->tag_attr_str, (CONSTRPTR )attr_str->es_data);
      }
    }
  } else {
    {
#line 669
    ugly_app_estr(hp___0->tag_attr_str, (CONSTRPTR )attr_str->es_data);
    }
  }
  {
#line 671
  del_estr(attr_str);
#line 672
  del_estr(val_str);
  }
#line 673
  return (ok);
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c"
static VOID set_tag_defaults(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  DLNODE *nd ;
  HSCATTR *attr ;
  STRPTR value ;
  STRPTR tmp ;
  STRPTR defval ;
  STRPTR tmp___0 ;

  {
#line 684
  nd = (tag->attr)->first;
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 686
    if (! nd) {
#line 686
      goto while_break;
    }
    {
#line 688
    attr = (HSCATTR *)nd->data;
#line 689
    tmp = get_vartext(attr);
#line 689
    value = tmp;
#line 690
    tmp___0 = get_vardeftext(attr);
#line 690
    defval = tmp___0;
    }
#line 692
    if (! value) {
#line 692
      if (defval) {
        {
#line 696
        set_vartext(attr, defval);
#line 699
        ugly_app_estr(hp___0->tag_attr_str, " ");
#line 700
        ugly_app_estr(hp___0->tag_attr_str, (CONSTRPTR )attr->name);
        }
#line 706
        if ((int )attr->vartype != 3) {
          {
#line 708
          ugly_app_estr(hp___0->tag_attr_str, "=");
#line 711
          attr->quote = '\"';
#line 712
          choose_quote(hp___0, attr);
          }
#line 715
          if (attr->quote != 0) {
            {
#line 717
            ugly_app_estrch(hp___0->tag_attr_str, attr->quote);
            }
          }
          {
#line 720
          ugly_app_estr(hp___0->tag_attr_str, (CONSTRPTR )attr->name);
          }
#line 722
          if (attr->quote != 0) {
            {
#line 724
            ugly_app_estrch(hp___0->tag_attr_str, attr->quote);
            }
          }
        }
      }
    }
#line 729
    nd = nd->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 732
  return;
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/deftag.c"
ULONG set_tag_args(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  INFILE *inpf ;
  BOOL ok ;
  DLLIST *varlist ;
  ULONG result_tci ;
  LONG tmp ;
  STRPTR nw ;
  STRPTR tmp___0 ;
  int tmp___1 ;

  {
  {
#line 740
  inpf = hp___0->inpf;
#line 741
  ok = (BOOL )0;
#line 743
  tmp = get_mci(hp___0);
#line 743
  result_tci = (ULONG )tmp;
#line 744
  tmp___0 = infgetw(inpf);
#line 744
  nw = tmp___0;
#line 747
  varlist = tag->attr;
#line 750
  ugly_clr_estr(hp___0->tag_attr_str);
  }
  {
#line 753
  while (1) {
    while_continue: /* CIL Label */ ;
#line 754
    if (! nw) {
      {
#line 755
      hsc_msg_eof(hp___0, (STRPTR )"read attributes");
      }
    } else {
      {
#line 760
      tmp___1 = strcmp((char const   *)nw, ">");
      }
#line 760
      if (tmp___1) {
#line 766
        if (hp___0->xhtml) {
#line 766
          if (tag->option & (unsigned long )(1 << 17)) {
#line 766
            if (! hp___0->xhtml_emptytag) {
              {
#line 767
              hsc_message(hp___0, (HSCMSG_ID )16473, "%a after closing slash in empty tag",
                          nw);
              }
            }
          }
        }
        {
#line 771
        nw = check_attrname(hp___0, (HSCATTR *)((void *)0), nw, (BOOL )0);
        }
#line 771
        if ((unsigned long )((void *)0) != (unsigned long )nw) {
          {
#line 772
          set_tag_arg(hp___0, varlist, nw, tag->name, (BOOL )(tag->option & (unsigned long )(1 << 14)),
                      (BOOL )(tag->option & (unsigned long )(1 << 10)));
          }
        }
#line 785
        if (nw) {
          {
#line 786
          nw = infgetw(inpf);
          }
        }
      } else {
#line 761
        nw = (STRPTR )((void *)0);
#line 762
        ok = (BOOL )1;
      }
    }
#line 753
    if (! nw) {
#line 753
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 793
  set_tag_defaults(hp___0, tag);
#line 796
  unget_mci(hp___0);
#line 799
  clr_varlist_bool(varlist);
  }
#line 802
  if (ok) {
    {
#line 803
    ok = check_varlist(hp___0, varlist);
    }
#line 803
    if (! ok) {
      {
#line 804
      inungetcw(inpf);
      }
    }
  }
#line 806
  if (! ok) {
#line 807
    result_tci = (ULONG )4294967295U;
  }
#line 809
  return (result_tci);
}
}
#line 321 "./hsclib/hscprc.h"
VOID hsc_set_status_file_begin(HSCPRC *hp___0 , VOID (*status_file)(HSCPRC *hp , STRPTR filename ) ) ;
#line 322
VOID hsc_set_status_file_end(HSCPRC *hp___0 , VOID (*status_file)(HSCPRC *hp ) ) ;
#line 323
VOID hsc_set_status_line(HSCPRC *hp___0 , VOID (*status_line___0)(HSCPRC *hp ) ) ;
#line 324
VOID hsc_set_status_misc(HSCPRC *hp___0 , VOID (*status_misc___0)(HSCPRC *hp , STRPTR s ) ) ;
#line 325
VOID hsc_set_message(HSCPRC *hp___0 , VOID (*message___0)(struct hsc_process *hp ,
                                                          HSCMSG_CLASS msg_class ,
                                                          HSCMSG_ID msg_id , STRPTR fname ,
                                                          ULONG x , ULONG y , STRPTR msg_text ) ) ;
#line 331
VOID hsc_set_message_ref(HSCPRC *hp___0 , VOID (*message_ref___0)(struct hsc_process *hp ,
                                                                  HSCMSG_CLASS msg_class ,
                                                                  HSCMSG_ID msg_id ,
                                                                  STRPTR fname , ULONG x ,
                                                                  ULONG y , STRPTR msg_text ) ) ;
#line 338
VOID hsc_set_start_tag(HSCPRC *hp___0 , VOID (*start_tag)(struct hsc_process *hp ,
                                                          HSCTAG *tag , STRPTR tag_name ,
                                                          STRPTR tag_attr , STRPTR tag_close ) ) ;
#line 344
VOID hsc_set_end_tag(HSCPRC *hp___0 , VOID (*end_tag)(struct hsc_process *hp , HSCTAG *tag ,
                                                      STRPTR tag_name , STRPTR tag_attr ,
                                                      STRPTR tag_close ) ) ;
#line 350
VOID hsc_set_text(HSCPRC *hp___0 , VOID (*text)(struct hsc_process *hp , STRPTR white_spaces ,
                                                STRPTR text ) ) ;
#line 353
VOID hsc_set_id(HSCPRC *hp___0 , VOID (*id)(struct hsc_process *hp , HSCATTR *attr ,
                                            STRPTR id ) ) ;
#line 33 "./hsc/output.h"
VOID append_output(STRPTR text ) ;
#line 67 "./hsc/status.h"
VOID status_file_begin(HSCPRC *hp___0 , STRPTR filename ) ;
#line 68
VOID status_file_end(HSCPRC *hp___0 ) ;
#line 69
VOID status_line(HSCPRC *hp___0 ) ;
#line 70
VOID status_misc(HSCPRC *hp___0 , STRPTR s___2 ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
static FILE *msgfile  =    (FILE *)((void *)0);
#line 68 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
BOOL init_msg_browser(HSCPRC *hp___0 , STRPTR filename ) 
{ 


  {
#line 70
  return ((BOOL )1);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
VOID del_msg_browser(HSCPRC *hp___0 ) 
{ 


  {
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
VOID send_msg_browser(HSCPRC *hp___0 , HSCMSG_CLASS msg_class , HSCMSG_ID msg_id ,
                      STRPTR fname , ULONG x , ULONG y , STRPTR msg_text ) 
{ 


  {
#line 84
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
BOOL hsc_nomem_handler(size_t size ) 
{ 


  {
  {
#line 95
  status_error((STRPTR )"out of memory");
#line 97
  return_code = 2;
#line 99
  exit(return_code);
  }
#line 101
  return ((BOOL )0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
static VOID message(HSCPRC *hp___0 , HSCMSG_CLASS msg_class , HSCMSG_ID msg_id , STRPTR fname ,
                    ULONG x , ULONG y , STRPTR msg_text ) 
{ 
  STRPTR msg_class_str ;
  STRPTR msg_class_seq ;
  STRPTR msgfmt ;
  BOOL msg_ansi___0 ;
  int tmp ;
  STRPTR tmp___0 ;
  STRPTR tmp___1 ;
  STRPTR tmp___2 ;

  {
#line 114
  msg_class_str = (STRPTR )"*UNKNOWN*";
#line 115
  msg_class_seq = (STRPTR )"\033[1m";
#line 116
  msgfmt = msg_format;
#line 117
  msg_ansi___0 = (BOOL )0;
#line 119
  if ((unsigned long )msg_browser != (unsigned long )((void *)0)) {
    {
#line 119
    tmp = upstrcmp((CONSTRPTR )msg_browser, "ANSI");
    }
#line 119
    if (! tmp) {
#line 121
      msg_ansi___0 = (BOOL )1;
    }
  }
#line 124
  if (! msgfmt) {
#line 126
    msgfmt = (STRPTR )"%f (%y,%x): %c %i: %m";
  }
  {
#line 132
  if (msg_class == 0L) {
#line 132
    goto case_0;
  }
#line 135
  if (msg_class == 4096L) {
#line 135
    goto case_4096;
  }
#line 138
  if (msg_class == 8192L) {
#line 138
    goto case_8192;
  }
#line 141
  if (msg_class == 12288L) {
#line 141
    goto case_12288;
  }
#line 144
  if (msg_class == 16384L) {
#line 144
    goto case_16384;
  }
#line 148
  if (msg_class == 61440L) {
#line 148
    goto case_61440;
  }
#line 129
  goto switch_break;
  case_0: /* CIL Label */ 
#line 133
  msg_class_str = (STRPTR )"Note";
#line 134
  goto switch_break;
  case_4096: /* CIL Label */ 
#line 136
  msg_class_str = (STRPTR )"Bad style";
#line 137
  goto switch_break;
  case_8192: /* CIL Label */ 
#line 139
  msg_class_str = (STRPTR )"Portability problem";
#line 140
  goto switch_break;
  case_12288: /* CIL Label */ 
#line 142
  msg_class_str = (STRPTR )"Warning";
#line 143
  goto switch_break;
  case_16384: /* CIL Label */ 
#line 145
  msg_class_str = (STRPTR )"Error";
#line 146
  msg_class_seq = (STRPTR )"\033[1m\033[32m";
#line 147
  goto switch_break;
  case_61440: /* CIL Label */ 
#line 149
  msg_class_str = (STRPTR )"Fatal error";
#line 150
  msg_class_seq = (STRPTR )"\033[1m\033[32m";
#line 151
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 156
  if (msg_class == 12288L) {
    {
#line 157
    set_return_code(0);
    }
  } else
#line 158
  if (msg_class == 16384L) {
    {
#line 159
    set_return_code(1);
    }
  } else
#line 160
  if (msg_class == 61440L) {
    {
#line 161
    set_return_code(2);
    }
  }
#line 164
  if (! fname) {
#line 166
    fname = inpfilename->es_data;
#line 167
    x = (ULONG )1;
#line 168
    y = (ULONG )1;
  }
  {
#line 171
  ugly_clr_estr(msgbuf);
  }
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! *(msgfmt + 0)) {
#line 172
      goto while_break;
    }
#line 174
    if ((int )*(msgfmt + 0) == 37) {
#line 176
      msgfmt ++;
      {
#line 179
      if ((int )*(msgfmt + 0) == 99) {
#line 179
        goto case_99;
      }
#line 186
      if ((int )*(msgfmt + 0) == 102) {
#line 186
        goto case_102;
      }
#line 189
      if ((int )*(msgfmt + 0) == 105) {
#line 189
        goto case_105;
      }
#line 196
      if ((int )*(msgfmt + 0) == 109) {
#line 196
        goto case_109;
      }
#line 199
      if ((int )*(msgfmt + 0) == 110) {
#line 199
        goto case_110;
      }
#line 202
      if ((int )*(msgfmt + 0) == 120) {
#line 202
        goto case_120;
      }
#line 205
      if ((int )*(msgfmt + 0) == 121) {
#line 205
        goto case_121;
      }
#line 208
      if ((int )*(msgfmt + 0) == 37) {
#line 208
        goto case_37;
      }
#line 211
      goto switch_default;
      case_99: /* CIL Label */ 
#line 180
      if (msg_ansi___0) {
        {
#line 181
        ugly_app_estr(msgbuf, (CONSTRPTR )msg_class_seq);
        }
      }
      {
#line 182
      ugly_app_estr(msgbuf, (CONSTRPTR )msg_class_str);
      }
#line 183
      if (msg_ansi___0) {
        {
#line 184
        ugly_app_estr(msgbuf, "\033[0m");
        }
      }
#line 185
      goto switch_break___0;
      case_102: /* CIL Label */ 
      {
#line 187
      ugly_app_estr(msgbuf, (CONSTRPTR )fname);
      }
#line 188
      goto switch_break___0;
      case_105: /* CIL Label */ 
#line 190
      if (msg_ansi___0) {
        {
#line 191
        ugly_app_estr(msgbuf, (CONSTRPTR )msg_class_seq);
        }
      }
      {
#line 192
      tmp___0 = long2str(msg_id);
#line 192
      ugly_app_estr(msgbuf, (CONSTRPTR )tmp___0);
      }
#line 193
      if (msg_ansi___0) {
        {
#line 194
        ugly_app_estr(msgbuf, "\033[0m");
        }
      }
#line 195
      goto switch_break___0;
      case_109: /* CIL Label */ 
      {
#line 197
      ugly_app_estr(msgbuf, (CONSTRPTR )msg_text);
      }
#line 198
      goto switch_break___0;
      case_110: /* CIL Label */ 
      {
#line 200
      ugly_app_estrch(msgbuf, '\n');
      }
#line 201
      goto switch_break___0;
      case_120: /* CIL Label */ 
      {
#line 203
      tmp___1 = long2str((LONG )x);
#line 203
      ugly_app_estr(msgbuf, (CONSTRPTR )tmp___1);
      }
#line 204
      goto switch_break___0;
      case_121: /* CIL Label */ 
      {
#line 206
      tmp___2 = long2str((LONG )y);
#line 206
      ugly_app_estr(msgbuf, (CONSTRPTR )tmp___2);
      }
#line 207
      goto switch_break___0;
      case_37: /* CIL Label */ 
      {
#line 209
      ugly_app_estrch(msgbuf, '%');
      }
#line 210
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 212
      ugly_app_estrch(msgbuf, '%');
#line 213
      ugly_app_estrch(msgbuf, (int )*(msgfmt + 0));
      }
#line 214
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 219
      ugly_app_estrch(msgbuf, (int )*(msgfmt + 0));
      }
    }
#line 221
    msgfmt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  ugly_app_estrch(msgbuf, '\n');
  }
#line 225
  if ((unsigned long )msg_format == (unsigned long )((void *)0)) {
    {
#line 227
    fputs((char const   */* __restrict  */)msgbuf->es_data, (FILE */* __restrict  */)msgfile);
    }
  } else
#line 225
  if ((int )*(msg_format + 0) != 0) {
    {
#line 227
    fputs((char const   */* __restrict  */)msgbuf->es_data, (FILE */* __restrict  */)msgfile);
    }
  }
#line 231
  if ((unsigned long )msg_browser != (unsigned long )((void *)0)) {
    {
#line 233
    send_msg_browser(hp___0, msg_class, msg_id, fname, x, y, msg_text);
    }
  }
#line 246
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
static VOID message_ref(HSCPRC *hp___0 , HSCMSG_CLASS msg_class , HSCMSG_ID msg_id ,
                        STRPTR fname , ULONG x , ULONG y , STRPTR msg_text ) 
{ 


  {
#line 258
  if (msg_text) {
#line 258
    if (*(msg_text + 0)) {
      {
#line 259
      message(hp___0, msg_class, msg_id, fname, x, y, msg_text);
      }
    } else {
      {
#line 261
      message(hp___0, msg_class, msg_id, fname, x, y, (STRPTR )"(location of previous call)");
      }
    }
  } else {
    {
#line 261
    message(hp___0, msg_class, msg_id, fname, x, y, (STRPTR )"(location of previous call)");
    }
  }
#line 263
  return;
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
static VOID do_hsc_id(HSCPRC *hp___0 , HSCATTR *attr , STRPTR id ) 
{ 


  {
#line 271
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
static VOID do_hsc_start_tag(HSCPRC *hp___0 , HSCTAG *tag , STRPTR tag_name , STRPTR tag_attr ,
                             STRPTR tag_close ) 
{ 


  {
  {
#line 286
  append_output(tag_name);
#line 287
  append_output(tag_attr);
  }
#line 288
  if (hp___0->xhtml) {
#line 288
    if (tag->option & (unsigned long )(1 << 17)) {
#line 289
      if (hp___0->xhtml_emptytag) {
        {
#line 290
        hsc_message(hp___0, (HSCMSG_ID )12376, "EMPTY content model tag %T not closed in XHTML mode",
                    tag);
        }
      }
      {
#line 293
      append_output((STRPTR )" /");
      }
    }
  }
  {
#line 295
  append_output(tag_close);
  }
#line 296
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
static VOID do_hsc_end_tag(HSCPRC *hp___0 , HSCTAG *tag , STRPTR tag_name , STRPTR tag_attr ,
                           STRPTR tag_close ) 
{ 


  {
  {
#line 306
  append_output(tag_name);
#line 307
  append_output(tag_attr);
#line 308
  append_output(tag_close);
  }
#line 309
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
static VOID do_hsc_text(HSCPRC *hp___0 , STRPTR whtspc , STRPTR text ) 
{ 


  {
  {
#line 316
  append_output(whtspc);
#line 317
  append_output(text);
  }
#line 318
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
BOOL init_callback(HSCPRC *hp___0 ) 
{ 


  {
  {
#line 328
  hsc_set_status_file_begin(hp___0, & status_file_begin);
#line 329
  hsc_set_status_file_end(hp___0, & status_file_end);
#line 330
  hsc_set_status_line(hp___0, & status_line);
#line 331
  hsc_set_status_misc(hp___0, & status_misc);
#line 334
  hsc_set_message(hp___0, & message);
#line 335
  hsc_set_message_ref(hp___0, & message_ref);
#line 338
  hsc_set_start_tag(hp___0, & do_hsc_start_tag);
#line 339
  hsc_set_end_tag(hp___0, & do_hsc_end_tag);
#line 340
  hsc_set_id(hp___0, & do_hsc_id);
#line 341
  hsc_set_text(hp___0, & do_hsc_text);
  }
#line 343
  return ((BOOL )1);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
BOOL init_msgfile(HSCPRC *hp___0 , STRPTR fname ) 
{ 
  BOOL ok ;
  int *tmp ;
  STRARR msgbuf___0[80] ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
#line 357
  ok = (BOOL )1;
#line 359
  if (fname) {
    {
#line 363
    tmp = __errno_location();
#line 363
    *tmp = 0;
#line 364
    msgfile = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
    }
#line 365
    if (! msgfile) {
      {
#line 370
      strncpy((char */* __restrict  */)(msgbuf___0), (char const   */* __restrict  */)"unable to open message file `",
              (size_t )79);
#line 371
      tmp___0 = strlen((char const   *)(msgbuf___0));
#line 371
      strncat((char */* __restrict  */)(msgbuf___0), (char const   */* __restrict  */)fname,
              79UL - tmp___0);
#line 372
      tmp___1 = strlen((char const   *)(msgbuf___0));
#line 372
      strncat((char */* __restrict  */)(msgbuf___0), (char const   */* __restrict  */)"\': ",
              79UL - tmp___1);
#line 373
      tmp___2 = strlen((char const   *)(msgbuf___0));
#line 373
      tmp___3 = __errno_location();
#line 373
      tmp___4 = strerror(*tmp___3);
#line 373
      strncat((char */* __restrict  */)(msgbuf___0), (char const   */* __restrict  */)tmp___4,
              79UL - tmp___2);
#line 374
      status_error(msgbuf___0);
#line 375
      ok = (BOOL )0;
      }
    }
  } else {
#line 380
    msgfile = stderr;
  }
#line 384
  return (ok);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/callback.c"
VOID cleanup_msgfile(void) 
{ 


  {
#line 394
  if (msgfile) {
#line 394
    if ((unsigned long )msgfile != (unsigned long )stderr) {
      {
#line 395
      fclose(msgfile);
      }
    }
  }
#line 396
  return;
}
}
#line 64 "./hsclib/skip.h"
BOOL skip_sgml_special(HSCPRC *hp___0 , EXPSTR *content , BOOL *stripped ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_misc.c"
BOOL handle_base(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  STRPTR href_arg ;
  STRPTR tmp ;

  {
  {
#line 45
  tmp = get_vartext_byname(tag->attr, (STRPTR )"HREF");
#line 45
  href_arg = tmp;
  }
#line 47
  if (href_arg) {
#line 50
    hp___0->docbase_set = (BOOL )1;
  }
#line 53
  return ((BOOL )1);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_misc.c"
BOOL handle_blink(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 


  {
  {
#line 63
  hsc_message(hp___0, (HSCMSG_ID )4121, "%t sucks", "BLINK");
  }
#line 65
  return ((BOOL )1);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_misc.c"
BOOL handle_heading(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BYTE num ;
  HSCTAG *tmp ;
  char hstr[4] ;

  {
  {
#line 78
  num = (BYTE )((int )*(tag->name + 1) - 48);
#line 83
  tmp = find_strtag(hp___0->container_stack, (STRPTR )"A");
  }
#line 83
  if (tmp) {
    {
#line 85
    hsc_message(hp___0, (HSCMSG_ID )4124, "heading inside anchor");
    }
  }
#line 88
  if (hp___0->prev_heading_num - (LONG )num < -1L) {
    {
#line 92
    sprintf((char */* __restrict  */)(hstr), (char const   */* __restrict  */)"H%ld",
            hp___0->prev_heading_num + 1L);
#line 93
    hsc_message(hp___0, (HSCMSG_ID )4105, "expected heading %t", hstr);
    }
  }
#line 97
  hp___0->prev_heading_num = (LONG )num;
#line 98
  return ((BOOL )1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_misc.c"
BOOL handle_img(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 


  {
#line 109
  return ((BOOL )1);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_misc.c"
BOOL handle_pre(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 


  {
#line 120
  hp___0->inside_pre = (BOOL )1;
#line 121
  return ((BOOL )1);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_misc.c"
BOOL handle_end_pre(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 


  {
#line 131
  hp___0->inside_pre = (BOOL )0;
#line 132
  return ((BOOL )1);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_misc.c"
BOOL handle_sgml_comment(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL stripped ;
  EXPSTR *content ;

  {
  {
#line 141
  stripped = (BOOL )0;
#line 142
  content = hp___0->tag_attr_str;
#line 145
  skip_sgml_special(hp___0, content, & stripped);
  }
#line 147
  return ((BOOL )(! stripped));
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/input.c"
BOOL hsc_whtspc(int ch ) 
{ 


  {
#line 50
  if (ch == 32) {
#line 56
    return ((BOOL )1);
  } else
#line 50
  if (ch == 10) {
#line 56
    return ((BOOL )1);
  } else
#line 50
  if (ch == 13) {
#line 56
    return ((BOOL )1);
  } else
#line 50
  if (ch == 9) {
#line 56
    return ((BOOL )1);
  } else {
#line 59
    return ((BOOL )0);
  }
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/input.c"
BOOL hsc_normch(int ch ) 
{ 


  {
#line 75
  if (ch >= 48) {
#line 75
    if (ch <= 57) {
#line 81
      return ((BOOL )1);
    } else {
#line 75
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 75
  if (ch >= 97) {
#line 75
    if (ch <= 122) {
#line 81
      return ((BOOL )1);
    } else {
#line 75
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 75
  if (ch >= 65) {
#line 75
    if (ch <= 90) {
#line 81
      return ((BOOL )1);
    } else {
#line 75
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 75
  if (ch == 95) {
#line 81
    return ((BOOL )1);
  } else
#line 75
  if (ch == 45) {
#line 81
    return ((BOOL )1);
  } else
#line 75
  if (ch == 46) {
#line 81
    return ((BOOL )1);
  } else {
#line 84
    return ((BOOL )0);
  }
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/input.c"
BOOL hsc_normch_tagid(int ch ) 
{ 
  BOOL found ;
  BOOL tmp ;
  char *tmp___0 ;

  {
  {
#line 100
  tmp = hsc_normch(ch);
#line 100
  found = tmp;
  }
#line 102
  if (! found) {
    {
#line 103
    tmp___0 = strchr("$", ch);
    }
#line 103
    if (tmp___0) {
#line 104
      found = (BOOL )1;
    }
  }
#line 106
  return (found);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/input.c"
STRPTR infget_tagid(HSCPRC *hp___0 ) 
{ 
  INFILE *inpf ;
  STRPTR tagid ;
  BOOL (*old_is_nc)(int ch ) ;

  {
  {
#line 124
  inpf = hp___0->inpf;
#line 125
  tagid = (STRPTR )((void *)0);
#line 129
  old_is_nc = inpf->is_nc;
#line 130
  inpf->is_nc = & hsc_normch_tagid;
#line 131
  tagid = infgetw(inpf);
  }
#line 132
  if (! tagid) {
    {
#line 133
    hsc_msg_eof(hp___0, (STRPTR )"reading tag name");
    }
  }
#line 134
  inpf->is_nc = old_is_nc;
#line 137
  if (hp___0->lctags) {
#line 137
    if ((unsigned long )((void *)0) != (unsigned long )tagid) {
      {
#line 138
      lowstr(tagid);
      }
    }
  }
#line 140
  return (tagid);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/input.c"
STRPTR infget_attrid(HSCPRC *hp___0 ) 
{ 
  INFILE *inpf ;
  STRPTR attrid ;
  BOOL (*old_is_nc)(int ch ) ;

  {
  {
#line 152
  inpf = hp___0->inpf;
#line 153
  attrid = (STRPTR )((void *)0);
#line 157
  old_is_nc = inpf->is_nc;
#line 158
  inpf->is_nc = & hsc_normch_tagid;
#line 159
  attrid = infgetw(inpf);
  }
#line 160
  if (! attrid) {
    {
#line 161
    hsc_msg_eof(hp___0, (STRPTR )"reading attribute name");
    }
  }
#line 162
  inpf->is_nc = old_is_nc;
#line 164
  return (attrid);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/input.c"
BOOL parse_wd(HSCPRC *hp___0 , STRPTR expstr ) 
{ 
  INFILE *inpf ;
  BOOL value ;
  STRPTR nw ;
  STRPTR tmp ;
  int tmp___0 ;

  {
#line 185
  inpf = hp___0->inpf;
#line 186
  value = (BOOL )1;
#line 188
  if (expstr) {
    {
#line 190
    tmp = infgetw(inpf);
#line 190
    nw = tmp;
    }
#line 193
    if (! nw) {
#line 193
      goto _L;
    } else {
      {
#line 193
      tmp___0 = upstrcmp((CONSTRPTR )nw, (CONSTRPTR )expstr);
      }
#line 193
      if (tmp___0) {
        _L: /* CIL Label */ 
#line 195
        if (! nw) {
#line 196
          nw = (STRPTR )"<EOF>";
        }
        {
#line 198
        hsc_message(hp___0, (HSCMSG_ID )16415, "expected %q, found %q", expstr, nw);
#line 200
        value = (BOOL )0;
        }
      }
    }
  } else {
    {
#line 205
    display_panic_message((char *)"no data to expect", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/input.c",
                          (size_t )205);
    }
  }
#line 208
  return (value);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/input.c"
BOOL parse_eq(HSCPRC *hp___0 ) 
{ 
  BOOL tmp ;

  {
  {
#line 221
  tmp = parse_wd(hp___0, (STRPTR )"=");
  }
#line 221
  return (tmp);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/input.c"
BOOL parse_gt(HSCPRC *hp___0 ) 
{ 
  BOOL tmp ;

  {
  {
#line 234
  tmp = parse_wd(hp___0, (STRPTR )">");
  }
#line 234
  return (tmp);
}
}
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 164 "./hsclib/attrib.h"
LONG get_varnum_byname(DLLIST *varlist , STRPTR name ) ;
#line 48 "./hsclib/lmessage.h"
VOID hsc_msg_noinput(HSCPRC *hp___0 , STRPTR filename ) ;
#line 62 "./hsclib/skip.h"
BOOL skip_hsc_comment(HSCPRC *hp___0 , EXPSTR *content ) ;
#line 63
BOOL skip_hsc_verbatim(HSCPRC *hp___0 , EXPSTR *content ) ;
#line 50 "./hsclib/include.h"
BOOL hsc_base_include_string(HSCPRC *hp___0 , STRPTR filename , STRPTR s___2 , ULONG optn ,
                             INFILEPOS *base_pos ) ;
#line 31 "./hsclib/css.h"
HSCSTYLE *new_styleattr(CONSTRPTR name , CONSTRPTR value ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_comment(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 


  {
  {
#line 72
  skip_hsc_comment(hp___0, (EXPSTR *)((void *)0));
  }
#line 73
  return ((BOOL )0);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_verbatim(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  EXPSTR *content ;
  EXPSTR *tmp ;
  STRPTR strend ;
  BOOL tmp___0 ;

  {
  {
#line 84
  tmp = ugly_init_estr((size_t )256);
#line 84
  content = tmp;
#line 85
  tmp___0 = skip_hsc_verbatim(hp___0, content);
  }
#line 85
  if (tmp___0) {
#line 87
    strend = content->es_data + (content->es_len - 1UL);
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
#line 88
      if (! ((int )*(strend + 0) != 124)) {
#line 88
        goto while_break;
      }
#line 89
      strend --;
    }
    while_break: /* CIL Label */ ;
    }
#line 90
    *(strend + 0) = (char)0;
#line 93
    if (content) {
#line 93
      if (content->es_data) {
#line 93
        if (hp___0->suppress_output) {
          {
#line 94
          hp_enable_output(hp___0, (STRPTR )"some text");
          }
        }
      }
    }
    {
#line 96
    hsc_output_text(hp___0, (STRPTR )"", content->es_data);
    }
  }
  {
#line 98
  del_estr(content);
  }
#line 100
  return ((BOOL )0);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_insert_expression(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  HSCATTR *dest ;
  HSCATTR *tmp ;
  STRPTR value ;

  {
  {
#line 111
  tmp = new_hscattr("HSC.TMP.insert.expression");
#line 111
  dest = tmp;
#line 112
  value = (STRPTR )((void *)0);
#line 115
  dest->vartype = (BYTE )2;
#line 118
  value = eval_expression(hp___0, dest, (STRPTR )")");
  }
#line 119
  if (value) {
    {
#line 120
    parse_gt(hp___0);
#line 121
    hsc_include_string(hp___0, (STRPTR )"::s::insert expression", value, (ULONG )(((1 << 3) | (1 << 5)) | (1 << 7)));
    }
  }
  {
#line 124
  del_hscattr((APTR )dest);
  }
#line 126
  return ((BOOL )0);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
static VOID do_include(HSCPRC *hp___0 , STRPTR filename , BOOL nostatus , BOOL temporary ,
                       BOOL source , BOOL pre , LONG indent , LONG tabsize ) 
{ 
  EXPSTR *fname ;
  EXPSTR *tmp ;
  ULONG optn ;

  {
  {
#line 139
  tmp = ugly_init_estr((size_t )0);
#line 139
  fname = tmp;
#line 140
  optn = (ULONG )0;
  }
#line 143
  if (! temporary) {
#line 144
    optn |= (unsigned long )(1 << 8);
  }
#line 146
  if (! nostatus) {
#line 147
    optn |= (unsigned long )(1 << 5);
  }
#line 149
  if (source) {
#line 150
    optn |= (unsigned long )(1 << 4);
  }
  {
#line 153
  conv_uri2path(fname, filename, hp___0->weenix);
  }
#line 156
  if (pre) {
    {
#line 157
    hsc_include_string(hp___0, (STRPTR )"::s::include <PRE>", (STRPTR )"<PRE>", (ULONG )(((1 << 3) | (1 << 5)) | (1 << 7)));
    }
  }
#line 161
  if (fname) {
    {
#line 162
    hsc_include_file(hp___0, fname->es_data, optn);
    }
  }
#line 165
  if (pre) {
    {
#line 166
    hsc_include_string(hp___0, (STRPTR )"::s::include </PRE>", (STRPTR )"</PRE>\n",
                       (ULONG )(((1 << 3) | (1 << 5)) | (1 << 7)));
    }
  }
  {
#line 170
  del_estr(fname);
  }
#line 171
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_include(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  STRPTR fname_arg ;
  STRPTR tmp ;
  LONG indent ;
  LONG tmp___0 ;
  LONG tabsize ;
  LONG tmp___1 ;
  BOOL source ;
  BOOL tmp___2 ;
  BOOL pre ;
  BOOL tmp___3 ;
  BOOL temporary ;
  BOOL tmp___4 ;

  {
  {
#line 179
  tmp = get_vartext_byname(tag->attr, (STRPTR )"FILE");
#line 179
  fname_arg = tmp;
#line 180
  tmp___0 = get_varnum_byname(tag->attr, (STRPTR )"INDENT");
#line 180
  indent = tmp___0;
#line 181
  tmp___1 = get_varnum_byname(tag->attr, (STRPTR )"TABSIZE");
#line 181
  tabsize = tmp___1;
#line 182
  tmp___2 = get_varbool_byname(tag->attr, (STRPTR )"SOURCE");
#line 182
  source = tmp___2;
#line 183
  tmp___3 = get_varbool_byname(tag->attr, (STRPTR )"PRE");
#line 183
  pre = tmp___3;
#line 184
  tmp___4 = get_varbool_byname(tag->attr, (STRPTR )"TEMPORARY");
#line 184
  temporary = tmp___4;
#line 186
  do_include(hp___0, fname_arg, (BOOL )0, temporary, source, pre, indent, tabsize);
  }
#line 189
  return ((BOOL )0);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_message(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  STRPTR msg_text ;
  STRPTR tmp ;
  STRPTR msg_class ;
  STRPTR tmp___0 ;
  ULONG msgid ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 204
  tmp = get_vartext_byname(tag->attr, (STRPTR )"TEXT");
#line 204
  msg_text = tmp;
#line 205
  tmp___0 = get_vartext_byname(tag->attr, (STRPTR )"CLASS");
#line 205
  msg_class = tmp___0;
  }
#line 207
  if (msg_text) {
    {
#line 209
    msgid = (ULONG )39;
#line 212
    tmp___3 = upstrcmp((CONSTRPTR )msg_class, "WARNING");
    }
#line 212
    if (tmp___3) {
      {
#line 214
      tmp___2 = upstrcmp((CONSTRPTR )msg_class, "ERROR");
      }
#line 214
      if (tmp___2) {
        {
#line 216
        tmp___1 = upstrcmp((CONSTRPTR )msg_class, "FATAL");
        }
#line 216
        if (! tmp___1) {
#line 217
          msgid |= 61440UL;
        }
      } else {
#line 215
        msgid |= 16384UL;
      }
    } else {
#line 213
      msgid |= 12288UL;
    }
    {
#line 225
    hsc_message(hp___0, (HSCMSG_ID )msgid, "user message: %s", msg_text);
    }
  }
#line 227
  return ((BOOL )0);
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_exec(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  STRPTR cmd ;
  STRPTR tmp ;
  HSCATTR *file_attr ;
  HSCATTR *tmp___0 ;
  HSCATTR *remove_attr ;
  HSCATTR *tmp___1 ;
  HSCATTR *result_attr ;
  HSCATTR *tmp___2 ;
  int result ;
  BOOL remove_file ;
  BOOL read_file ;
  STRPTR remove_str ;
  STRPTR tmp___3 ;
  EXPSTR *msg ;
  EXPSTR *tmp___4 ;
  EXPSTR *cmdstr ;
  EXPSTR *tmp___5 ;
  HSCATTR *temp_attr ;
  HSCATTR *tmp___6 ;
  HSCATTR *include_attr ;
  HSCATTR *tmp___7 ;
  HSCATTR *attribute_attr ;
  HSCATTR *tmp___8 ;
  STRPTR attribute_name ;
  BOOL temporary ;
  BOOL tmp___9 ;
  BOOL include ;
  BOOL tmp___10 ;
  BOOL pre ;
  BOOL tmp___11 ;
  BOOL source ;
  BOOL tmp___12 ;
  LONG indent ;
  LONG tmp___13 ;
  LONG tabsize ;
  LONG tmp___14 ;
  INFILE *outfile ;
  STRPTR filename ;
  STRPTR tmp___15 ;
  BOOL usetmpfile ;
  ULONG old_msg_count ;
  STRPTR tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  HSCATTR *output_attr ;
  HSCATTR *tmp___20 ;
  STRPTR tmp___21 ;
  BOOL nostatus ;
  STRPTR tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int *tmp___28 ;
  int *tmp___29 ;
  STRPTR tmp___30 ;

  {
  {
#line 248
  tmp = get_vartext_byname(tag->attr, (STRPTR )"COMMAND");
#line 248
  cmd = tmp;
#line 249
  tmp___0 = find_varname(tag->attr, (STRPTR )"FILE");
#line 249
  file_attr = tmp___0;
#line 250
  tmp___1 = find_varname(tag->attr, (STRPTR )"REMOVE");
#line 250
  remove_attr = tmp___1;
#line 251
  tmp___2 = find_varname(hp___0->defattr, (STRPTR )"HSC.EXEC.RESULT");
#line 251
  result_attr = tmp___2;
  }
#line 253
  if (cmd) {
#line 253
    if (file_attr) {
#line 253
      if (result_attr) {
#line 253
        if (remove_attr) {
          {
#line 255
          result = 0;
#line 256
          remove_file = (BOOL )0;
#line 257
          read_file = (BOOL )0;
#line 258
          tmp___3 = get_vartext(remove_attr);
#line 258
          remove_str = tmp___3;
#line 259
          tmp___4 = ugly_init_estr((size_t )0);
#line 259
          msg = tmp___4;
#line 260
          tmp___5 = ugly_init_estr((size_t )32);
#line 260
          cmdstr = tmp___5;
#line 263
          tmp___6 = find_varname(tag->attr, (STRPTR )"TEMPORARY");
#line 263
          temp_attr = tmp___6;
#line 264
          tmp___7 = find_varname(tag->attr, (STRPTR )"INCLUDE");
#line 264
          include_attr = tmp___7;
#line 265
          tmp___8 = find_varname(tag->attr, (STRPTR )"ATTRIBUTE");
#line 265
          attribute_attr = tmp___8;
#line 266
          attribute_name = (STRPTR )((void *)0);
#line 267
          tmp___9 = get_varbool(temp_attr);
#line 267
          temporary = tmp___9;
#line 268
          tmp___10 = get_varbool(include_attr);
#line 268
          include = tmp___10;
#line 269
          tmp___11 = get_varbool_byname(tag->attr, (STRPTR )"PRE");
#line 269
          pre = tmp___11;
#line 270
          tmp___12 = get_varbool_byname(tag->attr, (STRPTR )"SOURCE");
#line 270
          source = tmp___12;
#line 271
          tmp___13 = get_varnum_byname(tag->attr, (STRPTR )"INDENT");
#line 271
          indent = tmp___13;
#line 272
          tmp___14 = get_varnum_byname(tag->attr, (STRPTR )"TABSIZE");
#line 272
          tabsize = tmp___14;
#line 274
          outfile = (INFILE *)((void *)0);
#line 275
          tmp___15 = get_vartext(file_attr);
#line 275
          filename = tmp___15;
#line 276
          usetmpfile = (BOOL )0;
#line 277
          old_msg_count = hp___0->msg_count;
          }
#line 280
          if (attribute_attr) {
            {
#line 281
            attribute_name = get_vartext(attribute_attr);
            }
          }
#line 282
          if (attribute_name) {
#line 283
            read_file = (BOOL )1;
          } else
#line 282
          if (include) {
#line 283
            read_file = (BOOL )1;
          }
#line 286
          if (! filename) {
#line 286
            if (read_file) {
              {
#line 287
              usetmpfile = (BOOL )1;
#line 288
              tmp___16 = tmpnamstr((STRPTR )"hsc");
#line 288
              set_vartext(file_attr, tmp___16);
#line 289
              set_varbool(temp_attr, (BOOL )1);
#line 290
              filename = get_vartext(file_attr);
              }
            }
          }
#line 297
          if (remove_str) {
            {
#line 298
            tmp___18 = upstrcmp((CONSTRPTR )remove_str, "ON");
            }
#line 298
            if (tmp___18) {
              {
#line 303
              tmp___17 = upstrcmp((CONSTRPTR )remove_str, "AUTO");
              }
#line 303
              if (! tmp___17) {
#line 304
                if (hp___0->msg_count == old_msg_count) {
#line 305
                  remove_file = temporary;
                }
              }
            } else {
#line 299
              remove_file = (BOOL )1;
#line 300
              temporary = (BOOL )1;
            }
          }
          {
#line 316
          ugly_app_estr(msg, "execute: ");
#line 317
          ugly_app_estr(msg, (CONSTRPTR )cmd);
#line 318
          hsc_status_misc(hp___0, msg->es_data);
#line 321
          ugly_set_estr(cmdstr, (CONSTRPTR )cmd);
          }
#line 322
          if (usetmpfile) {
            {
#line 326
            ugly_app_estr(cmdstr, " >");
#line 327
            ugly_app_estr(cmdstr, (CONSTRPTR )filename);
            }
          }
          {
#line 336
          result = system((char const   *)cmdstr->es_data);
          }
#line 339
          if (result) {
            {
#line 340
            hsc_message(hp___0, (HSCMSG_ID )12342, "shell-command returned %d", result);
            }
          }
#line 345
          if (read_file) {
            {
#line 346
            tmp___19 = __errno_location();
#line 346
            *tmp___19 = 0;
#line 347
            outfile = infopen((CONSTRPTR )filename, (size_t )512);
            }
#line 348
            if (outfile) {
#line 350
              if (attribute_name) {
                {
#line 351
                tmp___20 = find_varname(hp___0->defattr, attribute_name);
#line 351
                output_attr = tmp___20;
                }
#line 357
                if (output_attr) {
                  {
#line 358
                  tmp___21 = infgetall(outfile);
#line 358
                  set_vartext(output_attr, tmp___21);
                  }
                } else {
                  {
#line 360
                  hsc_msg_unkn_attr_ref(hp___0, attribute_name);
                  }
                }
              }
#line 362
              if (outfile) {
                {
#line 362
                infclose1(outfile);
#line 362
                outfile = (INFILE *)((void *)0);
                }
              }
#line 365
              if (include) {
                {
#line 367
                nostatus = usetmpfile;
#line 369
                tmp___22 = get_vartext(file_attr);
#line 369
                do_include(hp___0, tmp___22, nostatus, temporary, source, pre, indent,
                           tabsize);
                }
              }
            } else {
              {
#line 374
              hsc_msg_noinput(hp___0, filename);
              }
            }
#line 378
            remove_file = (BOOL )0;
#line 379
            if (remove_str) {
              {
#line 380
              tmp___23 = upstrcmp((CONSTRPTR )remove_str, "ON");
              }
#line 380
              if (! tmp___23) {
#line 381
                remove_file = (BOOL )1;
              }
              {
#line 382
              tmp___24 = upstrcmp((CONSTRPTR )remove_str, "AUTO");
              }
#line 382
              if (! tmp___24) {
#line 383
                if (hp___0->msg_count == old_msg_count) {
#line 384
                  remove_file = temporary;
                }
              }
            }
#line 394
            if (remove_file) {
              {
#line 396
              tmp___25 = __errno_location();
#line 396
              *tmp___25 = 0;
#line 397
              remove((char const   *)filename);
#line 398
              tmp___29 = __errno_location();
              }
#line 398
              if (*tmp___29) {
                {
#line 399
                tmp___26 = __errno_location();
#line 399
                tmp___27 = strerror(*tmp___26);
#line 399
                hsc_message(hp___0, (HSCMSG_ID )12374, "error removing file `%s\': %s",
                            filename, tmp___27);
#line 402
                tmp___28 = __errno_location();
#line 402
                *tmp___28 = 0;
                }
              }
            }
          }
#line 410
          if (result_attr) {
            {
#line 411
            tmp___30 = long2str((LONG )result);
#line 411
            set_vartext(result_attr, tmp___30);
            }
          }
          {
#line 416
          del_estr(cmdstr);
#line 417
          del_estr(msg);
          }
        } else {
          {
#line 419
          display_panic_message((char *)"attribute missing", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c",
                                (size_t )419);
          }
        }
      } else {
        {
#line 419
        display_panic_message((char *)"attribute missing", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c",
                              (size_t )419);
        }
      }
    } else {
      {
#line 419
      display_panic_message((char *)"attribute missing", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c",
                            (size_t )419);
      }
    }
  } else {
    {
#line 419
    display_panic_message((char *)"attribute missing", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c",
                          (size_t )419);
    }
  }
#line 421
  return ((BOOL )0);
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_export(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  STRPTR filename ;
  STRPTR tmp ;
  STRPTR data ;
  STRPTR tmp___0 ;
  BOOL append ;
  BOOL tmp___1 ;
  BOOL relsrc ;
  BOOL tmp___2 ;
  EXPSTR *real_filename ;
  EXPSTR *tmp___3 ;
  FILE *outfile ;
  STRPTR writemode ;
  HSCATTR *tmp___4 ;
  STRPTR tmp___5 ;
  int *tmp___6 ;
  size_t tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 436
  tmp = get_vartext_byname(tag->attr, (STRPTR )"FILE");
#line 436
  filename = tmp;
#line 437
  tmp___0 = get_vartext_byname(tag->attr, (STRPTR )"DATA");
#line 437
  data = tmp___0;
#line 438
  tmp___1 = get_varbool_byname(tag->attr, (STRPTR )"APPEND");
#line 438
  append = tmp___1;
#line 439
  tmp___2 = get_varbool_byname(tag->attr, (STRPTR )"RELSRC");
#line 439
  relsrc = tmp___2;
#line 440
  tmp___3 = ugly_init_estr((size_t )1);
#line 440
  real_filename = tmp___3;
  }
#line 442
  if (filename) {
#line 442
    if (data) {
#line 443
      outfile = (FILE *)((void *)0);
#line 444
      writemode = (STRPTR )"w";
#line 446
      if (append) {
#line 447
        writemode = (STRPTR )"a";
      }
#line 449
      if (relsrc) {
        {
#line 450
        tmp___4 = find_varname(hp___0->defattr, (STRPTR )"HSC.SOURCE.PATH");
#line 450
        tmp___5 = get_vartext(tmp___4);
#line 450
        ugly_set_estr(real_filename, (CONSTRPTR )tmp___5);
        }
      } else {
        {
#line 452
        ugly_clr_estr(real_filename);
        }
      }
      {
#line 453
      ugly_app_estr(real_filename, (CONSTRPTR )filename);
#line 454
      tmp___6 = __errno_location();
#line 454
      *tmp___6 = 0;
#line 455
      outfile = fopen((char const   */* __restrict  */)real_filename->es_data, (char const   */* __restrict  */)writemode);
      }
#line 456
      if (outfile) {
        {
#line 457
        tmp___7 = strlen((char const   *)data);
#line 457
        fwrite((void const   */* __restrict  */)data, sizeof(char ), tmp___7, (FILE */* __restrict  */)outfile);
#line 458
        fclose(outfile);
        }
      }
      {
#line 461
      tmp___10 = __errno_location();
      }
#line 461
      if (*tmp___10) {
        {
#line 462
        tmp___8 = __errno_location();
#line 462
        tmp___9 = strerror(*tmp___8);
#line 462
        hsc_message(hp___0, (HSCMSG_ID )16467, "error opening/writing %q: %s", real_filename->es_data,
                    tmp___9);
        }
      }
    } else {
      {
#line 466
      display_panic_message((char *)"attribute missing", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c",
                            (size_t )466);
      }
    }
  } else {
    {
#line 466
    display_panic_message((char *)"attribute missing", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c",
                          (size_t )466);
    }
  }
  {
#line 468
  del_estr(real_filename);
  }
#line 469
  return ((BOOL )0);
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_time(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  STRPTR timefmt ;
  STRPTR tmp ;
  EXPSTR *timebuf___2 ;
  EXPSTR *tmp___0 ;
  BOOL strftrc ;
  size_t i ;
  struct tm *tmp___1 ;
  size_t tmp___2 ;
  INFILEPOS *base ;
  INFILEPOS *tmp___3 ;

  {
  {
#line 484
  tmp = get_vartext_byname(tag->attr, (STRPTR )"FORMAT");
#line 484
  timefmt = tmp;
#line 485
  tmp___0 = ugly_init_estr((size_t )20);
#line 485
  timebuf___2 = tmp___0;
#line 486
  strftrc = (BOOL )0;
  }
#line 490
  if (! timefmt) {
#line 491
    timefmt = (STRPTR )"%d-%b-%Y, %H:%M";
  }
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! hp___0->fatal) {
#line 493
      if (! (! strftrc)) {
#line 493
        goto while_break;
      }
    } else {
#line 493
      goto while_break;
    }
#line 495
    i = (size_t )0;
    {
#line 495
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 495
      if (! (i < 20UL)) {
#line 495
        goto while_break___0;
      }
      {
#line 496
      ugly_app_estrch(timebuf___2, '.');
#line 495
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 501
    tmp___1 = localtime((time_t const   *)(& hp___0->start_time));
#line 501
    tmp___2 = strftime((char */* __restrict  */)timebuf___2->es_data, timebuf___2->es_len - 1UL,
                       (char const   */* __restrict  */)timefmt, (struct tm  const  */* __restrict  */)tmp___1);
#line 501
    strftrc = (BOOL )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  if (strftrc) {
    {
#line 505
    tmp___3 = new_infilepos(hp___0->inpf);
#line 505
    base = tmp___3;
#line 506
    hsc_base_include_string(hp___0, (STRPTR )"::s::insert time", timebuf___2->es_data,
                            (ULONG )((1 << 3) | (1 << 5)), base);
#line 509
    del_infilepos(base);
    }
  }
  {
#line 511
  del_estr(timebuf___2);
  }
#line 513
  return ((BOOL )0);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_text(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  STRPTR text ;
  STRPTR tmp ;
  INFILEPOS *base ;
  INFILEPOS *tmp___0 ;

  {
  {
#line 522
  tmp = get_vartext_byname(tag->attr, (STRPTR )"TEXT");
#line 522
  text = tmp;
#line 525
  tmp___0 = new_infilepos(hp___0->inpf);
#line 525
  base = tmp___0;
#line 526
  hsc_base_include_string(hp___0, (STRPTR )"::s::insert TEXT", text, (ULONG )((1 << 3) | (1 << 5)),
                          base);
#line 528
  del_infilepos(base);
  }
#line 530
  return ((BOOL )0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_insert(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL insert_text ;
  BOOL insert_time ;
  BOOL tmp ;
  STRPTR tmp___0 ;

  {
  {
#line 539
  insert_text = (BOOL )0;
#line 540
  tmp = get_varbool_byname(tag->attr, (STRPTR )"TIME");
#line 540
  insert_time = tmp;
#line 542
  tmp___0 = get_vartext_byname(tag->attr, (STRPTR )"TEXT");
  }
#line 542
  if (tmp___0) {
#line 543
    insert_text = (BOOL )1;
  }
#line 545
  if (insert_text) {
    {
#line 546
    handle_hsc_text(hp___0, tag);
    }
  } else
#line 547
  if (insert_time) {
    {
#line 548
    handle_hsc_time(hp___0, tag);
    }
  } else {
    {
#line 552
    hsc_message(hp___0, (HSCMSG_ID )16428, "required attribute for %t missing", "$insert");
    }
  }
  {
#line 555
  clr_varlist(tag->attr);
  }
#line 557
  return ((BOOL )0);
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_deftag(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL ok ;
  BOOL open_tag ;
  BOOL tmp ;
  int tmp___0 ;

  {
  {
#line 566
  ok = (BOOL )0;
#line 567
  open_tag = (BOOL )0;
#line 569
  tag = def_tag_name(hp___0, & open_tag);
  }
#line 570
  if (tag) {
    {
#line 570
    tmp = def_tag_args(hp___0, tag);
    }
#line 570
    if (tmp) {
#line 570
      tmp___0 = 1;
    } else {
#line 570
      tmp___0 = 0;
    }
  } else {
#line 570
    tmp___0 = 0;
  }
#line 570
  ok = (BOOL )tmp___0;
#line 572
  return ((BOOL )0);
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
static VOID msg_illegal_defent(HSCPRC *hp___0 , STRPTR msg ) 
{ 


  {
  {
#line 581
  hsc_message(hp___0, (HSCMSG_ID )16453, "illegal entity definition (%s)", msg);
  }
#line 582
  return;
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
static VOID msg_dubious_defent(HSCPRC *hp___0 , STRPTR msg ) 
{ 


  {
  {
#line 585
  hsc_message(hp___0, (HSCMSG_ID )12380, "dubious entity definition (%s)", msg);
  }
#line 586
  return;
}
}
#line 588 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_defent(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  STRPTR name ;
  STRPTR tmp ;
  STRPTR rplc ;
  STRPTR tmp___0 ;
  STRPTR nums ;
  STRPTR tmp___1 ;
  BOOL prefnum ;
  BOOL tmp___2 ;
  BOOL nonstd ;
  BOOL tmp___3 ;
  LONG num ;
  char flags ;
  int tmp___4 ;
  int tmp___5 ;
  BOOL tmp___6 ;
  DLNODE *nd ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;

  {
  {
#line 589
  tmp = get_vartext_byname(tag->attr, (STRPTR )"NAME");
#line 589
  name = tmp;
#line 590
  tmp___0 = get_vartext_byname(tag->attr, (STRPTR )"RPLC");
#line 590
  rplc = tmp___0;
#line 591
  tmp___1 = get_vartext_byname(tag->attr, (STRPTR )"NUM");
#line 591
  nums = tmp___1;
#line 592
  tmp___2 = get_varbool_byname(tag->attr, (STRPTR )"PREFNUM");
#line 592
  prefnum = tmp___2;
#line 593
  tmp___3 = get_varbool_byname(tag->attr, (STRPTR )"NONSTD");
#line 593
  nonstd = tmp___3;
#line 594
  num = (LONG )0;
  }
#line 595
  if (prefnum) {
#line 595
    tmp___4 = 1;
  } else {
#line 595
    tmp___4 = 0;
  }
#line 595
  if (nonstd) {
#line 595
    tmp___5 = 2;
  } else {
#line 595
    tmp___5 = 0;
  }
#line 595
  flags = (char )(tmp___4 | tmp___5);
#line 597
  if ((unsigned long )((void *)0) == (unsigned long )nums) {
#line 597
    if ((unsigned long )((void *)0) == (unsigned long )name) {
      {
#line 598
      msg_illegal_defent(hp___0, (STRPTR )"specify at least one of NAME and NUM");
      }
#line 599
      return ((BOOL )0);
    }
  }
#line 601
  if ((unsigned long )((void *)0) != (unsigned long )nums) {
    {
#line 601
    tmp___6 = str2long(nums, & num);
    }
#line 601
    if (! tmp___6) {
      {
#line 602
      msg_illegal_defent(hp___0, (STRPTR )"illegal value for NUM");
      }
#line 603
      return ((BOOL )0);
    }
  }
#line 605
  if ((unsigned long )((void *)0) == (unsigned long )rplc) {
#line 605
    goto _L___1;
  } else {
    {
#line 605
    tmp___10 = strlen((char const   *)rplc);
    }
#line 605
    if (tmp___10 == 1UL) {
      _L___1: /* CIL Label */ 
#line 606
      if (num >= 160L) {
#line 606
        if (num <= 65535L) {
#line 607
          nd = (DLNODE *)((void *)0);
#line 609
          if (num > 255L) {
#line 609
            if ((unsigned long )((void *)0) != (unsigned long )rplc) {
              {
#line 609
              tmp___7 = strlen((char const   *)rplc);
              }
#line 609
              if (tmp___7) {
                {
#line 610
                msg_dubious_defent(hp___0, (STRPTR )"RPLC specified for NUM > 255");
                }
              }
            }
          }
#line 612
          if ((unsigned long )((void *)0) != (unsigned long )name) {
            {
#line 612
            nd = find_dlnode((hp___0->defent)->first, (APTR )name, & cmp_strent);
            }
#line 612
            if ((unsigned long )((void *)0) != (unsigned long )nd) {
#line 615
              if (num == (LONG )((HSCENT *)nd->data)->numeric) {
                {
#line 616
                msg_dubious_defent(hp___0, (STRPTR )"duplicate entity - updating flags");
#line 617
                ((HSCENT *)nd->data)->flags = flags;
#line 618
                ((HSCENT *)nd->data)->replace[0] = *rplc;
                }
              } else {
                {
#line 620
                msg_illegal_defent(hp___0, (STRPTR )"NAME defined with different NUM");
                }
              }
            } else {
#line 612
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 621
          if ((unsigned long )((void *)0) != (unsigned long )nums) {
            {
#line 621
            nd = find_dlnode((hp___0->defent)->first, (APTR )num, & cmp_nument);
            }
#line 621
            if ((unsigned long )((void *)0) != (unsigned long )nd) {
              {
#line 624
              tmp___8 = strcmp((char const   *)name, (char const   *)((HSCENT *)nd->data)->name);
              }
#line 624
              if (0 == tmp___8) {
                {
#line 625
                msg_dubious_defent(hp___0, (STRPTR )"duplicate NUM - updating flags");
#line 626
                ((HSCENT *)nd->data)->flags = flags;
#line 627
                ((HSCENT *)nd->data)->replace[0] = *rplc;
                }
              } else {
                {
#line 629
                msg_illegal_defent(hp___0, (STRPTR )"NUM defined with different NAME");
                }
              }
            } else {
#line 621
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 631
            if ((unsigned long )((void *)0) == (unsigned long )rplc) {
#line 631
              tmp___9 = '\000';
            } else {
#line 631
              tmp___9 = (int )*(rplc + 0);
            }
            {
#line 631
            add_ent(hp___0->defent, name, (char )tmp___9, (short )num, flags);
            }
          }
        } else {
          {
#line 633
          msg_illegal_defent(hp___0, (STRPTR )"illegal range for NUM (must be 160<=NUM<=65535)");
          }
        }
      } else {
        {
#line 633
        msg_illegal_defent(hp___0, (STRPTR )"illegal range for NUM (must be 160<=NUM<=65535)");
        }
      }
    } else {
      {
#line 635
      msg_illegal_defent(hp___0, (STRPTR )"RPLC not a single character");
      }
    }
  }
#line 637
  return ((BOOL )0);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_defstyle(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  STRPTR tmp ;
  STRPTR tmp___0 ;
  HSCSTYLE *tmp___1 ;

  {
  {
#line 646
  tmp = get_vartext_byname(tag->attr, (STRPTR )"VAL");
#line 646
  tmp___0 = get_vartext_byname(tag->attr, (STRPTR )"NAME");
#line 646
  tmp___1 = new_styleattr((CONSTRPTR )tmp___0, (CONSTRPTR )tmp);
#line 646
  app_dlnode(hp___0->defstyle, (APTR )tmp___1);
  }
#line 650
  return ((BOOL )0);
}
}
#line 658 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_deficon(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  STRPTR name ;
  STRPTR tmp ;
  DLNODE *nd ;

  {
  {
#line 659
  tmp = get_vartext_byname(tag->attr, (STRPTR )"NAME");
#line 659
  name = tmp;
#line 660
  nd = (DLNODE *)((void *)0);
#line 662
  nd = find_dlnode((hp___0->defent)->first, (APTR )name, & cmp_strent);
  }
#line 663
  if (nd) {
    {
#line 664
    msg_illegal_defent(hp___0, (STRPTR )"duplicate entity");
    }
  } else {
    {
#line 666
    add_ent(hp___0->defent, name, (char )'\000', (short)-1, (char)0);
    }
  }
#line 668
  return ((BOOL )0);
}
}
#line 675 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_define(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  HSCATTR *attr ;
  HSCATTR *tmp ;

  {
  {
#line 676
  tmp = define_attr_by_hp(hp___0, (STRPTR )((void *)0), (ULONG )0);
#line 676
  attr = tmp;
  }
#line 677
  if (attr) {
    {
#line 681
    parse_gt(hp___0);
    }
  }
#line 684
  return ((BOOL )0);
}
}
#line 692 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
static HSCTAG *def_lazy_name(HSCPRC *hp___0 ) 
{ 
  STRPTR nw ;
  HSCTAG *lazy ;
  DLLIST *lazy_list ;

  {
  {
#line 693
  nw = (STRPTR )((void *)0);
#line 694
  lazy = (HSCTAG *)((void *)0);
#line 695
  lazy_list = hp___0->deflazy;
#line 698
  nw = infget_tagid(hp___0);
  }
#line 701
  if (nw) {
    {
#line 702
    lazy = find_strtag(lazy_list, nw);
    }
#line 703
    if (lazy) {
      {
#line 704
      hsc_message(hp___0, (HSCMSG_ID )16440, "redefined lazy ", lazy);
      }
    } else {
      {
#line 707
      lazy = app_tag(lazy_list, nw);
      }
    }
  }
#line 709
  return (lazy);
}
}
#line 713 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_lazy(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL ok ;
  HSCTAG *lazy ;
  HSCTAG *tmp ;

  {
  {
#line 714
  ok = (BOOL )0;
#line 715
  tmp = def_lazy_name(hp___0);
#line 715
  lazy = tmp;
  }
#line 716
  if (lazy) {
    {
#line 717
    ok = def_tag_args(hp___0, lazy);
    }
  }
#line 718
  return ((BOOL )0);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_depend(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  STRPTR filename ;
  STRPTR tmp ;
  BOOL file ;
  BOOL tmp___0 ;
  EXPSTR *dest_fname ;
  EXPSTR *tmp___1 ;

  {
  {
#line 728
  tmp = get_vartext_byname(tag->attr, (STRPTR )"ON");
#line 728
  filename = tmp;
#line 729
  tmp___0 = get_varbool_byname(tag->attr, (STRPTR )"FILE");
#line 729
  file = tmp___0;
  }
#line 731
  if (filename) {
    {
#line 732
    tmp___1 = ugly_init_estr((size_t )64);
#line 732
    dest_fname = tmp___1;
    }
#line 735
    if (! file) {
      {
#line 736
      conv_hscuri2file(hp___0, dest_fname, filename);
#line 737
      filename = dest_fname->es_data;
      }
    }
    {
#line 742
    app_include((hp___0->project)->document, filename);
#line 744
    del_estr(dest_fname);
    }
  } else {
    {
#line 746
    display_panic_message((char *)"attribute missing", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c",
                          (size_t )746);
    }
  }
#line 748
  return ((BOOL )0);
}
}
#line 760 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_let(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  INFILE *inpf ;
  STRPTR varname ;
  STRPTR tmp ;
  HSCATTR *attr ;
  BOOL ok ;
  HSCATTR *dummy ;
  HSCATTR *tmp___0 ;
  STRPTR eq_sign ;
  STRPTR tmp___1 ;
  STRPTR brace ;
  STRPTR tmp___2 ;
  int tmp___3 ;
  BOOL tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 761
  inpf = hp___0->inpf;
#line 762
  tmp = infgetw(inpf);
#line 762
  varname = tmp;
#line 763
  attr = (HSCATTR *)((void *)0);
#line 764
  ok = (BOOL )0;
  }
#line 766
  if (varname) {
    {
#line 771
    tmp___0 = new_hscattr("HSC.TMP.let");
#line 771
    dummy = tmp___0;
    }
#line 773
    if (123 == (int )*(varname + 0)) {
      {
#line 774
      varname = eval_expression(hp___0, dummy, (STRPTR )"}");
      }
    }
    {
#line 777
    attr = find_varname(hp___0->defattr, varname);
    }
#line 778
    if (attr) {
      {
#line 779
      tmp___1 = infgetw(inpf);
#line 779
      eq_sign = tmp___1;
      }
#line 781
      if (attr->varflag & (unsigned long )(1 << 2)) {
        {
#line 783
        hsc_message(hp___0, (HSCMSG_ID )16411, "attempt to modify constant %A", attr);
#line 787
        attr = dummy;
#line 788
        dummy->vartype = attr->vartype;
#line 789
        dummy->varflag = attr->varflag;
        }
      }
#line 793
      if (eq_sign) {
        {
#line 794
        tmp___6 = strcmp((char const   *)eq_sign, "=");
        }
#line 794
        if (tmp___6) {
          {
#line 806
          tmp___5 = strcmp((char const   *)eq_sign, "?");
          }
#line 806
          if (tmp___5) {
            {
#line 812
            clr_vartext(attr);
#line 814
            inungetcw(inpf);
            }
          } else {
            {
#line 808
            tmp___4 = parse_eq(hp___0);
            }
#line 808
            if (tmp___4) {
              {
#line 809
              eval_conditional_assignment(hp___0, attr);
              }
            }
          }
        } else {
          {
#line 795
          tmp___2 = infgetw(inpf);
#line 795
          brace = tmp___2;
#line 796
          tmp___3 = strcmp((char const   *)brace, "{");
          }
#line 796
          if (tmp___3) {
            {
#line 803
            inungets(brace, inpf);
#line 804
            eval_expression(hp___0, attr, (STRPTR )((void *)0));
            }
          } else {
            {
#line 798
            brace = eval_expression(hp___0, attr, (STRPTR )"}");
#line 799
            inungets(brace, inpf);
#line 800
            eval_attrref(hp___0, attr);
            }
          }
        }
      }
      {
#line 820
      ok = parse_gt(hp___0);
      }
    } else {
      {
#line 822
      hsc_msg_unkn_attr_ref(hp___0, varname);
      }
    }
    {
#line 826
    del_hscattr((APTR )dummy);
    }
  }
#line 829
  return ((BOOL )0);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_source(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL pre ;
  BOOL tmp ;
  BOOL ok ;
  EXPSTR *source_content ;
  EXPSTR *tmp___0 ;
  INFILEPOS *base ;
  INFILEPOS *tmp___1 ;

  {
  {
#line 838
  tmp = get_varbool_byname(tag->attr, (STRPTR )"PRE");
#line 838
  pre = tmp;
#line 839
  ok = (BOOL )1;
#line 840
  tmp___0 = ugly_init_estr((size_t )1024);
#line 840
  source_content = tmp___0;
#line 841
  tmp___1 = new_infilepos(hp___0->inpf);
#line 841
  base = tmp___1;
  }
#line 844
  if (hp___0->inside_pre) {
#line 845
    pre = (BOOL )0;
  }
#line 848
  if (pre) {
    {
#line 849
    hsc_include_string(hp___0, (STRPTR )"::s::insert <PRE>", (STRPTR )"<PRE>", (ULONG )(((1 << 3) | (1 << 5)) | (1 << 7)));
    }
  }
  {
#line 854
  ok = skip_until_tag(hp___0, source_content, (EXPSTR *)((void *)0), (STRPTR )((void *)0),
                      (STRPTR )"$source", (ULONG )((1 << 1) | (1 << 3)));
  }
#line 858
  if (ok) {
    {
#line 860
    hsc_base_include_string(hp___0, (STRPTR )"::s::source", source_content->es_data,
                            (ULONG )((1 << 4) | (1 << 5)), base);
    }
#line 865
    if (pre) {
      {
#line 866
      hsc_include_string(hp___0, (STRPTR )"::s::insert </PRE>", (STRPTR )"</PRE>\n",
                         (ULONG )(((1 << 3) | (1 << 5)) | (1 << 7)));
      }
    }
  }
  {
#line 871
  del_infilepos(base);
#line 872
  del_estr(source_content);
  }
#line 874
  return ((BOOL )0);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_hsc.c"
BOOL handle_hsc_stripws(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  STRPTR strip_type ;
  STRPTR tmp ;
  BOOL strip_prev ;
  BOOL strip_succ ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 883
  tmp = get_vartext_byname(tag->attr, (STRPTR )"TYPE");
#line 883
  strip_type = tmp;
#line 884
  strip_prev = (BOOL )0;
#line 885
  strip_succ = (BOOL )0;
#line 888
  tmp___4 = upstrcmp((CONSTRPTR )strip_type, "both");
  }
#line 888
  if (tmp___4) {
    {
#line 891
    tmp___3 = upstrcmp((CONSTRPTR )strip_type, "prev");
    }
#line 891
    if (tmp___3) {
      {
#line 893
      tmp___2 = upstrcmp((CONSTRPTR )strip_type, "succ");
      }
#line 893
      if (tmp___2) {
        {
#line 895
        tmp___0 = upstrcmp((CONSTRPTR )strip_type, "none");
        }
#line 895
        if (tmp___0) {
#line 895
          tmp___1 = 0;
        } else {
#line 895
          tmp___1 = 1;
        }
      } else {
#line 894
        strip_succ = (BOOL )1;
      }
    } else {
#line 892
      strip_prev = (BOOL )1;
    }
  } else {
#line 889
    strip_prev = (BOOL )1;
#line 890
    strip_succ = (BOOL )1;
  }
#line 900
  if (strip_prev) {
    {
#line 901
    ugly_clr_estr(hp___0->whtspc);
    }
  }
#line 904
  if (strip_succ) {
    {
#line 905
    hsc_output_text(hp___0, (STRPTR )((void *)0), (STRPTR )((void *)0));
#line 906
    hp___0->strip_next_whtspc = (BOOL )1;
    }
  }
#line 909
  return ((BOOL )0);
}
}
#line 436 "./hsclib/hscprc.h"
HSCMSG_CLASS hsc_get_msg_class(HSCPRC *hp___0 , HSCMSG_ID msg_id ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
static VOID handle_too_many_messages(HSCPRC *hp___0 ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
static VOID msg_tag(EXPSTR *msgstr , CONSTRPTR tagname ) 
{ 


  {
  {
#line 44
  ugly_app_estr(msgstr, "tag <");
#line 45
  ugly_app_estr(msgstr, tagname);
#line 46
  ugly_app_estr(msgstr, ">");
  }
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
static VOID msg_endtag(EXPSTR *msgstr , CONSTRPTR tagname ) 
{ 


  {
  {
#line 51
  ugly_app_estr(msgstr, "end tag </");
#line 52
  ugly_app_estr(msgstr, tagname);
#line 53
  ugly_app_estr(msgstr, ">");
  }
#line 54
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
static VOID msg_attr(EXPSTR *msgstr , CONSTRPTR attrname ) 
{ 


  {
  {
#line 58
  ugly_app_estr(msgstr, "attribute ");
#line 59
  ugly_app_estr(msgstr, attrname);
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
static VOID msg_lazy(EXPSTR *msgstr , CONSTRPTR lazy_name ) 
{ 


  {
  {
#line 64
  ugly_app_estr(msgstr, "var-list ");
#line 65
  ugly_app_estr(msgstr, lazy_name);
  }
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
static VOID msg_entity(EXPSTR *msgstr , CONSTRPTR entname ) 
{ 


  {
  {
#line 70
  ugly_app_estr(msgstr, "entity `");
#line 71
  ugly_app_estr(msgstr, entname);
#line 72
  ugly_app_estr(msgstr, "\'");
  }
#line 73
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
static VOID msg_idname(EXPSTR *msgstr , CONSTRPTR idname ) 
{ 


  {
  {
#line 77
  ugly_app_estr(msgstr, "id ");
#line 78
  ugly_app_estr(msgstr, "\"#");
#line 79
  ugly_app_estr(msgstr, idname);
#line 80
  ugly_app_estrch(msgstr, '\"');
  }
#line 81
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
static BOOL is_child_file(STRPTR filename ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 119
  tmp = strlen("::p::");
#line 119
  tmp___0 = strncmp((char const   *)filename, "::p::", tmp);
  }
#line 119
  if (tmp___0) {
#line 119
    tmp___1 = 0;
  } else {
#line 119
    tmp___1 = 1;
  }
#line 119
  return ((BOOL )tmp___1);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
static BOOL really_display_message(HSCPRC *hp___0 , HSCMSG_ID msg_id ) 
{ 
  HSCMSG_CLASS msg_class ;
  HSCMSG_CLASS tmp ;
  BOOL disp_msg ;
  HSCIGN tmp___0 ;
  HSCIGN tmp___1 ;

  {
  {
#line 126
  tmp = hsc_get_msg_class(hp___0, msg_id);
#line 126
  msg_class = tmp;
#line 127
  disp_msg = (BOOL )1;
  }
#line 132
  if (hp___0->fatal) {
#line 135
    disp_msg = (BOOL )0;
  } else {
    {
#line 136
    tmp___1 = hsc_get_msg_ignore(hp___0, msg_id);
    }
#line 136
    if ((unsigned int )tmp___1 == 1U) {
#line 136
      if (msg_class <= 12288L) {
#line 141
        disp_msg = (BOOL )0;
      } else {
#line 136
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 142
    if (msg_class == 0L) {
#line 142
      if (hp___0->msg_ignore_notes) {
#line 142
        goto _L;
      } else {
#line 142
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 142
    if (msg_class == 4096L) {
#line 142
      if (hp___0->msg_ignore_style) {
#line 142
        goto _L;
      } else {
#line 142
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 142
    if (msg_class == 8192L) {
#line 142
      if (hp___0->msg_ignore_port) {
        _L: /* CIL Label */ 
        {
#line 147
        tmp___0 = hsc_get_msg_ignore(hp___0, msg_id);
        }
#line 147
        if ((unsigned int )tmp___0 != 2U) {
#line 152
          disp_msg = (BOOL )0;
        }
      }
    }
  }
#line 159
  return (disp_msg);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
VOID hsc_message(HSCPRC *hp___0 , HSCMSG_ID msg_id , char const   *format  , ...) 
{ 
  HSCMSG_CLASS msg_class ;
  HSCMSG_CLASS tmp ;
  HSCMSG_ID msg_id_unmasked ;
  INFILE *msg_inpf ;
  STRPTR msg_fname ;
  ULONG msg_x ;
  ULONG msg_y ;
  BOOL disp_msg ;
  BOOL tmp___0 ;
  va_list ap ;
  STRPTR s___2 ;
  HSCTAG *tag ;
  HSCTAG *lazy ;
  HSCATTR *attr ;
  HSCENT *ent ;
  LONG tmp___2 ;
  STRPTR tmp___3 ;
  STRPTR tmp___4 ;
  STRPTR tmp___5 ;
  STRPTR tmp___7 ;
  HSCTAG *tmp___8 ;
  STRPTR tmp___10 ;
  HSCTAG *tmp___11 ;
  STRPTR tmp___13 ;
  HSCATTR *tmp___14 ;
  STRPTR tmp___16 ;
  HSCENT *tmp___17 ;
  STRPTR tmp___19 ;
  STRPTR tmp___21 ;
  HSCTAG *tmp___22 ;
  STRPTR tmp___24 ;
  DLNODE *nd ;
  BOOL tmp___25 ;
  BOOL tmp___26 ;
  ULONG tmp___27 ;
  ULONG tmp___28 ;
  DLNODE *nd___0 ;
  ULONG tmp___29 ;
  ULONG tmp___30 ;

  {
  {
#line 163
  tmp = hsc_get_msg_class(hp___0, msg_id);
#line 163
  msg_class = tmp;
#line 164
  msg_id_unmasked = msg_id & 4095L;
#line 165
  msg_inpf = (INFILE *)((void *)0);
#line 166
  msg_fname = (STRPTR )"unknown";
#line 167
  msg_x = (ULONG )0;
#line 168
  msg_y = (ULONG )0;
#line 169
  tmp___0 = really_display_message(hp___0, msg_id);
#line 169
  disp_msg = tmp___0;
  }
#line 171
  if (disp_msg) {
#line 175
    (hp___0->msg_count) ++;
#line 178
    if (msg_id > 61440L) {
#line 179
      hp___0->fatal = (BOOL )1;
    }
    {
#line 182
    ugly_clr_estr(hp___0->curr_msg);
#line 185
    __builtin_va_start(ap, format);
    }
    {
#line 186
    while (1) {
      while_continue: /* CIL Label */ ;
#line 186
      if (! *(format + 0)) {
#line 186
        goto while_break;
      }
#line 187
      if ((int const   )*(format + 0) == 37) {
#line 188
        s___2 = (STRPTR )((void *)0);
#line 189
        tag = (HSCTAG *)((void *)0);
#line 190
        lazy = (HSCTAG *)((void *)0);
#line 191
        attr = (HSCATTR *)((void *)0);
#line 192
        ent = (HSCENT *)((void *)0);
#line 194
        format ++;
        {
#line 197
        if ((int const   )*(format + 0) == 100) {
#line 197
          goto case_100;
        }
#line 205
        if ((int const   )*(format + 0) == 113) {
#line 205
          goto case_113;
        }
#line 236
        if ((int const   )*(format + 0) == 115) {
#line 236
          goto case_115;
        }
#line 243
        if ((int const   )*(format + 0) == 84) {
#line 243
          goto case_84;
        }
#line 249
        if ((int const   )*(format + 0) == 116) {
#line 249
          goto case_116;
        }
#line 254
        if ((int const   )*(format + 0) == 67) {
#line 254
          goto case_67;
        }
#line 260
        if ((int const   )*(format + 0) == 99) {
#line 260
          goto case_99;
        }
#line 265
        if ((int const   )*(format + 0) == 65) {
#line 265
          goto case_65;
        }
#line 271
        if ((int const   )*(format + 0) == 97) {
#line 271
          goto case_97;
        }
#line 276
        if ((int const   )*(format + 0) == 69) {
#line 276
          goto case_69;
        }
#line 282
        if ((int const   )*(format + 0) == 101) {
#line 282
          goto case_101;
        }
#line 287
        if ((int const   )*(format + 0) == 105) {
#line 287
          goto case_105;
        }
#line 292
        if ((int const   )*(format + 0) == 106) {
#line 292
          goto case_106;
        }
#line 300
        if ((int const   )*(format + 0) == 76) {
#line 300
          goto case_76;
        }
#line 306
        if ((int const   )*(format + 0) == 108) {
#line 306
          goto case_108;
        }
#line 311
        goto switch_default___0;
        case_100: /* CIL Label */ 
        {
#line 201
        tmp___2 = __builtin_va_arg(ap, LONG );
#line 201
        tmp___3 = long2str(tmp___2);
#line 201
        ugly_app_estr(hp___0->curr_msg, (CONSTRPTR )tmp___3);
        }
#line 203
        goto switch_break;
        case_113: /* CIL Label */ 
        {
#line 209
        tmp___4 = __builtin_va_arg(ap, STRPTR );
#line 209
        s___2 = tmp___4;
#line 211
        ugly_app_estrch(hp___0->curr_msg, '`');
        }
        {
#line 212
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 212
          if (! *(s___2 + 0)) {
#line 212
            goto while_break___0;
          }
          {
#line 215
          if ((int )*(s___2 + 0) == 10) {
#line 215
            goto case_10;
          }
#line 218
          if ((int )*(s___2 + 0) == 34) {
#line 218
            goto case_34;
          }
#line 221
          goto switch_default;
          case_10: /* CIL Label */ 
          {
#line 216
          ugly_app_estr(hp___0->curr_msg, "\\n");
          }
#line 217
          goto switch_break___0;
          case_34: /* CIL Label */ 
          {
#line 219
          ugly_app_estr(hp___0->curr_msg, "\\\"");
          }
#line 220
          goto switch_break___0;
          switch_default: /* CIL Label */ 
#line 222
          if ((int )((unsigned char )*(s___2 + 0)) < 32) {
            {
#line 223
            ugly_app_estrch(hp___0->curr_msg, '\\');
#line 224
            tmp___5 = long2str((LONG )*(s___2 + 0));
#line 224
            ugly_app_estr(hp___0->curr_msg, (CONSTRPTR )tmp___5);
#line 226
            ugly_app_estrch(hp___0->curr_msg, ';');
            }
          } else {
            {
#line 228
            ugly_app_estrch(hp___0->curr_msg, (int )*(s___2 + 0));
            }
          }
          switch_break___0: /* CIL Label */ ;
          }
#line 230
          s___2 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 232
        ugly_app_estrch(hp___0->curr_msg, '\'');
        }
#line 234
        goto switch_break;
        case_115: /* CIL Label */ 
        {
#line 240
        tmp___7 = __builtin_va_arg(ap, STRPTR );
#line 240
        ugly_app_estr(hp___0->curr_msg, (CONSTRPTR )tmp___7);
        }
#line 241
        goto switch_break;
        case_84: /* CIL Label */ 
        {
#line 245
        tmp___8 = __builtin_va_arg(ap, HSCTAG *);
#line 245
        tag = tmp___8;
#line 246
        msg_tag(hp___0->curr_msg, (CONSTRPTR )tag->name);
        }
#line 247
        goto switch_break;
        case_116: /* CIL Label */ 
        {
#line 251
        tmp___10 = __builtin_va_arg(ap, STRPTR );
#line 251
        msg_tag(hp___0->curr_msg, (CONSTRPTR )tmp___10);
        }
#line 252
        goto switch_break;
        case_67: /* CIL Label */ 
        {
#line 256
        tmp___11 = __builtin_va_arg(ap, HSCTAG *);
#line 256
        tag = tmp___11;
#line 257
        msg_endtag(hp___0->curr_msg, (CONSTRPTR )tag->name);
        }
#line 258
        goto switch_break;
        case_99: /* CIL Label */ 
        {
#line 262
        tmp___13 = __builtin_va_arg(ap, STRPTR );
#line 262
        msg_endtag(hp___0->curr_msg, (CONSTRPTR )tmp___13);
        }
#line 263
        goto switch_break;
        case_65: /* CIL Label */ 
        {
#line 267
        tmp___14 = __builtin_va_arg(ap, HSCATTR *);
#line 267
        attr = tmp___14;
#line 268
        msg_attr(hp___0->curr_msg, (CONSTRPTR )attr->name);
        }
#line 269
        goto switch_break;
        case_97: /* CIL Label */ 
        {
#line 273
        tmp___16 = __builtin_va_arg(ap, STRPTR );
#line 273
        msg_attr(hp___0->curr_msg, (CONSTRPTR )tmp___16);
        }
#line 274
        goto switch_break;
        case_69: /* CIL Label */ 
        {
#line 278
        tmp___17 = __builtin_va_arg(ap, HSCENT *);
#line 278
        ent = tmp___17;
#line 279
        msg_entity(hp___0->curr_msg, (CONSTRPTR )ent->name);
        }
#line 280
        goto switch_break;
        case_101: /* CIL Label */ 
        {
#line 284
        tmp___19 = __builtin_va_arg(ap, STRPTR );
#line 284
        msg_entity(hp___0->curr_msg, (CONSTRPTR )tmp___19);
        }
#line 285
        goto switch_break;
        case_105: /* CIL Label */ 
        {
#line 289
        tmp___21 = __builtin_va_arg(ap, STRPTR );
#line 289
        msg_idname(hp___0->curr_msg, (CONSTRPTR )tmp___21);
        }
#line 290
        goto switch_break;
        case_106: /* CIL Label */ 
#line 294
        if (hp___0->prostitute) {
          {
#line 295
          ugly_app_estr(hp___0->curr_msg, "prostitutes");
          }
        } else {
          {
#line 297
          ugly_app_estr(hp___0->curr_msg, "jerks");
          }
        }
#line 298
        goto switch_break;
        case_76: /* CIL Label */ 
        {
#line 302
        tmp___22 = __builtin_va_arg(ap, HSCTAG *);
#line 302
        lazy = tmp___22;
#line 303
        msg_lazy(hp___0->curr_msg, (CONSTRPTR )lazy->name);
        }
#line 304
        goto switch_break;
        case_108: /* CIL Label */ 
        {
#line 308
        tmp___24 = __builtin_va_arg(ap, STRPTR );
#line 308
        msg_lazy(hp___0->curr_msg, (CONSTRPTR )tmp___24);
        }
#line 309
        goto switch_break;
        switch_default___0: /* CIL Label */ 
        {
#line 315
        ugly_app_estrch(hp___0->curr_msg, '%');
        }
#line 316
        if (*(format + 0)) {
#line 316
          if ((int const   )*(format + 0) != 37) {
            {
#line 317
            ugly_app_estrch(hp___0->curr_msg, '%');
#line 318
            format --;
            }
          }
        }
#line 320
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
        {
#line 324
        ugly_app_estrch(hp___0->curr_msg, (int )*(format + 0));
        }
      }
#line 326
      if (*(format + 0)) {
#line 327
        format ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 329
    __builtin_va_end(ap);
    }
#line 332
    if (hp___0->inpf) {
      {
#line 333
      msg_inpf = hp___0->inpf;
#line 335
      msg_fname = infget_fname(msg_inpf);
#line 338
      tmp___26 = is_child_file(msg_fname);
      }
#line 338
      if (tmp___26) {
#line 339
        nd = (hp___0->inpf_stack)->first;
#line 341
        msg_inpf = (INFILE *)((void *)0);
#line 342
        msg_fname = (STRPTR )((void *)0);
#line 344
        if (nd) {
          {
#line 345
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 349
            msg_inpf = (INFILE *)nd->data;
#line 350
            msg_fname = infget_fname(msg_inpf);
#line 351
            nd = nd->next;
            }
#line 345
            if (nd) {
              {
#line 345
              tmp___25 = is_child_file(msg_fname);
              }
#line 345
              if (! tmp___25) {
#line 345
                goto while_break___1;
              }
            } else {
#line 345
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
#line 355
      if (msg_inpf) {
        {
#line 356
        tmp___27 = infget_wx(msg_inpf);
#line 356
        msg_x = tmp___27 + 1UL;
#line 357
        tmp___28 = infget_wy(msg_inpf);
#line 357
        msg_y = tmp___28 + 1UL;
        }
      } else {
#line 359
        msg_fname = (STRPTR )"hsc-internal.hsc";
#line 360
        msg_x = (ULONG )0;
#line 361
        msg_y = (ULONG )0;
      }
    } else {
#line 364
      msg_fname = (STRPTR )((void *)0);
#line 365
      msg_x = (ULONG )0;
#line 366
      msg_y = (ULONG )0;
    }
#line 370
    if (hp___0->CB_message) {
      {
#line 371
      (*(hp___0->CB_message))(hp___0, msg_class, msg_id_unmasked, msg_fname, msg_x,
                              msg_y, (hp___0->curr_msg)->es_data);
      }
    }
#line 379
    if (hp___0->CB_message_ref) {
#line 379
      if (hp___0->nested_errors) {
#line 380
        nd___0 = (hp___0->inpf_stack)->first;
        {
#line 382
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 382
          if (! nd___0) {
#line 382
            goto while_break___2;
          }
          {
#line 383
          msg_inpf = (INFILE *)nd___0->data;
#line 384
          msg_fname = infget_fname(msg_inpf);
#line 385
          tmp___29 = infget_wx(msg_inpf);
#line 385
          msg_x = tmp___29 + 1UL;
#line 386
          tmp___30 = infget_wy(msg_inpf);
#line 386
          msg_y = tmp___30 + 1UL;
#line 388
          (*(hp___0->CB_message_ref))(hp___0, msg_class, msg_id_unmasked, msg_fname,
                                      msg_x, msg_y, (STRPTR )"");
#line 395
          nd___0 = nd___0->next;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    {
#line 401
    handle_too_many_messages(hp___0);
    }
  }
#line 404
  return;
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
static VOID handle_too_many_messages(HSCPRC *hp___0 ) 
{ 


  {
#line 410
  if (hp___0->max_errors != 0xffffffffffffffffUL) {
#line 411
    (hp___0->max_errors) --;
  }
#line 412
  if (hp___0->max_messages != 0xffffffffffffffffUL) {
#line 413
    (hp___0->max_messages) --;
  }
#line 415
  if (hp___0->max_messages == 0UL) {
    {
#line 416
    hsc_message(hp___0, (HSCMSG_ID )61445, "too many errors or messages");
    }
  } else
#line 415
  if (hp___0->max_errors == 0UL) {
    {
#line 416
    hsc_message(hp___0, (HSCMSG_ID )61445, "too many errors or messages");
    }
  }
#line 417
  return;
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
VOID hsc_msg_eof(HSCPRC *hp___0 , STRPTR descr ) 
{ 
  STRPTR eoftxt ;

  {
#line 427
  eoftxt = (STRPTR )"unexpected end of context";
#line 429
  if (descr) {
    {
#line 430
    hsc_message(hp___0, (HSCMSG_ID )61443, "%s (%s)", eoftxt, descr);
    }
  } else {
    {
#line 432
    hsc_message(hp___0, (HSCMSG_ID )61443, "%s", eoftxt);
    }
  }
#line 433
  return;
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
VOID hsc_msg_illg_whtspc(HSCPRC *hp___0 ) 
{ 


  {
  {
#line 437
  hsc_message(hp___0, (HSCMSG_ID )16431, "illegal white space");
  }
#line 438
  return;
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
VOID hsc_msg_stripped_tag(HSCPRC *hp___0 , HSCTAG *tag , STRPTR why ) 
{ 


  {
#line 442
  if (why) {
    {
#line 443
    hsc_message(hp___0, (HSCMSG_ID )7, "stripped %T (%s)", tag, why);
    }
  } else {
    {
#line 446
    hsc_message(hp___0, (HSCMSG_ID )7, "stripped %T", tag);
    }
  }
#line 448
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
VOID hsc_msg_unkn_attr_ref(HSCPRC *hp___0 , STRPTR attr ) 
{ 


  {
  {
#line 452
  hsc_message(hp___0, (HSCMSG_ID )16404, "unknown %a", attr);
  }
#line 454
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
VOID hsc_msg_unkn_attr_tag(HSCPRC *hp___0 , STRPTR attr , STRPTR tag ) 
{ 


  {
  {
#line 458
  hsc_message(hp___0, (HSCMSG_ID )12372, "unknown %a for %t", attr, tag);
  }
#line 460
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
VOID hsc_msg_unkn_attr_macro(HSCPRC *hp___0 , STRPTR attr , STRPTR macro ) 
{ 


  {
  {
#line 464
  hsc_message(hp___0, (HSCMSG_ID )16469, "unknown %a for %t", attr, macro);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
VOID hsc_msg_noinput(HSCPRC *hp___0 , STRPTR filename ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 470
  tmp = __errno_location();
#line 470
  tmp___0 = strerror(*tmp);
#line 470
  hsc_message(hp___0, (HSCMSG_ID )61446, "can not open %q for input: %s", filename,
              tmp___0);
  }
#line 473
  return;
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
VOID hsc_msg_read_error(HSCPRC *hp___0 , STRPTR filename ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 477
  tmp = __errno_location();
#line 477
  tmp___0 = strerror(*tmp);
#line 477
  hsc_message(hp___0, (HSCMSG_ID )61444, "error reading %s: %s", filename, tmp___0);
  }
#line 480
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lmessage.c"
VOID hsc_msg_nouri(HSCPRC *hp___0 , STRPTR filename , STRPTR uriname , STRPTR note ) 
{ 


  {
#line 484
  if (note) {
    {
#line 485
    hsc_message(hp___0, (HSCMSG_ID )12309, "file %q for URI %q not found (%s)", filename,
                uriname, note);
    }
  } else {
    {
#line 489
    hsc_message(hp___0, (HSCMSG_ID )12309, "file %q for URI %q not found", filename,
                uriname);
    }
  }
#line 493
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID del_infilepos_nddata___1(APTR data ) ;
#line 96 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static BOOL default_whtspc___1(int ch ) 
{ 
  char *tmp ;

  {
  {
#line 98
  tmp = strchr(" \t", ch);
  }
#line 98
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 100
    return ((BOOL )1);
  } else {
#line 104
    return ((BOOL )0);
  }
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static BOOL default_normch___1(int ch ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 110
  tmp = __ctype_b_loc();
  }
#line 110
  if ((int const   )*(*tmp + ch) & 8) {
#line 112
    return ((BOOL )1);
  } else
#line 110
  if (ch == 95) {
#line 112
    return ((BOOL )1);
  } else {
#line 116
    return ((BOOL )0);
  }
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID update_wpos___1(INFILE *inpf ) 
{ 


  {
#line 129
  inpf->wpos_x = inpf->pos_x;
#line 130
  inpf->wpos_y = inpf->pos_y;
#line 131
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID reset_infile___1(INFILE *inpf ) 
{ 


  {
  {
#line 147
  inpf->infile = (FILE *)((void *)0);
#line 148
  inpf->filename = (STRPTR )((void *)0);
#line 149
  inpf->lnbuf = (EXPSTR *)((void *)0);
#line 150
  inpf->wordbuf = (EXPSTR *)((void *)0);
#line 151
  inpf->wspcbuf = (EXPSTR *)((void *)0);
#line 153
  inpf->filepos = (ULONG )0;
#line 154
  inpf->pos_x = (ULONG )0;
#line 155
  inpf->pos_y = (ULONG )0;
#line 156
  update_wpos___1(inpf);
#line 158
  inpf->base_x = (ULONG )0;
#line 159
  inpf->base_y = (ULONG )0;
#line 160
  inpf->pos_list = (DLLIST *)((void *)0);
#line 161
  inpf->pos_count = (ULONG )0;
#line 162
  inpf->eof_reached = (BOOL )0;
#line 163
  inpf->out_of_mem = (BOOL )0;
#line 164
  inpf->skipped_ws = (BOOL )0;
#line 165
  inpf->closed = (BOOL )0;
#line 166
  inpf->is_nc = (BOOL (*)(int ch ))((void *)0);
#line 167
  inpf->is_ws = (BOOL (*)(int ch ))((void *)0);
  }
#line 168
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID del_infile___1(INFILE *inpf ) 
{ 


  {
#line 175
  if (inpf) {
#line 186
    if (inpf->pos_count) {
#line 188
      inpf->closed = (BOOL )1;
    } else {
#line 195
      if (inpf->infile) {
        {
#line 196
        fclose(inpf->infile);
        }
      }
      {
#line 199
      del_dllist(inpf->pos_list);
#line 202
      ugly_freestr(inpf->filename, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c",
                   (ULONG )202);
#line 202
      inpf->filename = (STRPTR )((void *)0);
#line 203
      del_estr(inpf->lnbuf);
#line 204
      del_estr(inpf->wordbuf);
#line 205
      del_estr(inpf->wspcbuf);
#line 208
      reset_infile___1(inpf);
      }
#line 211
      if (inpf) {
        {
#line 211
        free((void *)inpf);
#line 211
        inpf = (INFILE *)((void *)0);
        }
      }
    }
  }
#line 214
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static INFILE *init_infile___1(CONSTRPTR name , size_t buf_step , size_t word_step ) 
{ 
  INFILE *inpf ;
  void *tmp ;

  {
  {
#line 221
  tmp = ugly_malloc_notracking(sizeof(INFILE ));
#line 221
  inpf = (INFILE *)tmp;
  }
#line 223
  if (inpf) {
#line 226
    if (! buf_step) {
#line 227
      buf_step = (size_t )128;
    }
#line 228
    if (! word_step) {
#line 229
      word_step = (size_t )128;
    }
    {
#line 232
    reset_infile___1(inpf);
    }
#line 235
    if (name) {
      {
#line 236
      inpf->filename = ugly_strclone(name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c",
                                     (ULONG )236);
      }
    }
    {
#line 239
    inpf->lnbuf = ugly_init_estr(buf_step);
#line 240
    inpf->wordbuf = ugly_init_estr(word_step);
#line 241
    inpf->wspcbuf = ugly_init_estr(word_step);
#line 242
    inpf->pos_list = init_dllist(& del_infilepos_nddata___1);
#line 243
    inpf->pos_count = (ULONG )0;
    }
#line 246
    if (inpf->filename) {
#line 246
      goto _L;
    } else
#line 246
    if (! name) {
      _L: /* CIL Label */ 
#line 246
      if (inpf->lnbuf) {
#line 246
        if (inpf->wordbuf) {
#line 246
          if (! inpf->wspcbuf) {
            {
#line 253
            del_infile___1(inpf);
#line 254
            inpf = (INFILE *)((void *)0);
            }
          }
        } else {
          {
#line 253
          del_infile___1(inpf);
#line 254
          inpf = (INFILE *)((void *)0);
          }
        }
      } else {
        {
#line 253
        del_infile___1(inpf);
#line 254
        inpf = (INFILE *)((void *)0);
        }
      }
    } else {
      {
#line 253
      del_infile___1(inpf);
#line 254
      inpf = (INFILE *)((void *)0);
      }
    }
  }
#line 258
  return (inpf);
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static int ugly_inungetc___1(int ch , INFILE *inpf ) 
{ 
  int result ;
  STRPTR lnbuf_str ;

  {
#line 689
  result = -1;
#line 691
  if (inpf) {
#line 691
    if (inpf->filepos) {
#line 693
      lnbuf_str = (inpf->lnbuf)->es_data;
#line 696
      (inpf->filepos) --;
#line 699
      *(lnbuf_str + inpf->filepos) = (char )ch;
#line 700
      result = ch;
#line 703
      if (ch == 10) {
#line 705
        result = ch;
#line 706
        (inpf->pos_y) --;
#line 707
        inpf->pos_x = (ULONG )0;
      } else
#line 709
      if (inpf->pos_x) {
#line 710
        (inpf->pos_x) --;
      }
    }
  }
#line 713
  return (result);
}
}
#line 1010 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static VOID del_infilepos_nddata___1(APTR data ) 
{ 
  INFILEPOS *pos ;

  {
#line 1012
  pos = (INFILEPOS *)data;
#line 1014
  if (pos) {
#line 1017
    ((pos->inpf)->pos_count) --;
#line 1024
    if (pos) {
      {
#line 1024
      free((void *)pos);
#line 1024
      pos = (INFILEPOS *)((void *)0);
      }
    }
  }
#line 1026
  return;
}
}
#line 1031 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static int cmp_posdata___1(APTR data1 , APTR data2 ) 
{ 


  {
#line 1033
  if ((unsigned long )data1 == (unsigned long )data2) {
#line 1035
    return (-1);
  } else {
#line 1039
    return (0);
  }
}
}
#line 1088 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c"
static INFILEPOS *new_infilepos_node___1(INFILE *inpfile , ULONG x , ULONG y ) 
{ 
  INFILEPOS *pos ;
  void *tmp ;
  DLNODE *nd ;
  DLNODE *tmp___0 ;

  {
  {
#line 1090
  tmp = ugly_malloc_notracking(sizeof(INFILEPOS ));
#line 1090
  pos = (INFILEPOS *)tmp;
  }
#line 1092
  if (pos) {
    {
#line 1094
    tmp___0 = app_dlnode(inpfile->pos_list, (APTR )pos);
#line 1094
    nd = tmp___0;
#line 1096
    pos->inpf = inpfile;
#line 1097
    pos->fname = ugly_strclone((CONSTRPTR )inpfile->filename, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/infile.c",
                               (ULONG )1097);
#line 1098
    pos->x = x;
#line 1099
    pos->y = y;
#line 1100
    pos->fpos = inpfile->filepos;
    }
#line 1102
    if (! nd) {
      {
#line 1104
      del_infilepos_nddata___1((APTR )pos);
#line 1105
      pos = (INFILEPOS *)((void *)0);
      }
    } else {
#line 1109
      (inpfile->pos_count) ++;
    }
  }
#line 1128
  return (pos);
}
}
#line 316 "./hsclib/hscprc.h"
VOID del_hscprc(HSCPRC *hp___0 ) ;
#line 317
HSCPRC *new_hscprc(void) ;
#line 318
VOID reset_hscprc(HSCPRC *hp___0 ) ;
#line 363
VOID hsc_set_jerkvalues(HSCPRC *hp___0 , BOOL new_jerkvalues ) ;
#line 390
VOID hsc_clr_include_directory(HSCPRC *hp___0 ) ;
#line 393
BOOL hsc_get_chkid(HSCPRC *hp___0 ) ;
#line 394
BOOL hsc_get_chkuri(HSCPRC *hp___0 ) ;
#line 395
BOOL hsc_get_compact(HSCPRC *hp___0 ) ;
#line 397
BOOL hsc_get_getsize(HSCPRC *hp___0 ) ;
#line 398
BOOL hsc_get_htmlonly(HSCPRC *hp___0 ) ;
#line 399
BOOL hsc_get_jerkvalues(HSCPRC *hp___0 ) ;
#line 400
BOOL hsc_get_rplc_ent(HSCPRC *hp___0 ) ;
#line 401
BOOL hsc_get_rplc_quote(HSCPRC *hp___0 ) ;
#line 402
BOOL hsc_get_smart_ent(HSCPRC *hp___0 ) ;
#line 403
BOOL hsc_get_strip_badws(HSCPRC *hp___0 ) ;
#line 404
BOOL hsc_get_strip_cmt(HSCPRC *hp___0 ) ;
#line 405
BOOL hsc_get_strip_ext(HSCPRC *hp___0 ) ;
#line 408
BOOL hsc_get_fatal(HSCPRC *hp___0 ) ;
#line 409
BOOL hsc_get_inside_anchor(HSCPRC *hp___0 ) ;
#line 410
BOOL hsc_get_inside_pre(HSCPRC *hp___0 ) ;
#line 411
BOOL hsc_get_suppress_output(HSCPRC *hp___0 ) ;
#line 414
STRPTR hsc_get_destdir(HSCPRC *hp___0 ) ;
#line 415
STRPTR hsc_get_reldir(HSCPRC *hp___0 ) ;
#line 416
STRPTR hsc_get_iconbase(HSCPRC *hp___0 ) ;
#line 417
STRPTR hsc_get_server_dir(HSCPRC *hp___0 ) ;
#line 420
STRPTR hsc_get_click_here_str(HSCPRC *hp___0 ) ;
#line 421
STRPTR hsc_get_file_name(HSCPRC *hp___0 ) ;
#line 422
ULONG hsc_get_file_line(HSCPRC *hp___0 ) ;
#line 423
ULONG hsc_get_file_column(HSCPRC *hp___0 ) ;
#line 424
ULONG hsc_get_msg_count(HSCPRC *hp___0 ) ;
#line 427
BOOL hsc_get_msg_ignore_notes(HSCPRC *hp___0 ) ;
#line 428
BOOL hsc_get_msg_ignore_style(HSCPRC *hp___0 ) ;
#line 429
BOOL hsc_get_msg_ignore_port(HSCPRC *hp___0 ) ;
#line 435
BOOL hsc_set_msg_class(HSCPRC *hp___0 , HSCMSG_ID msg_id , HSCMSG_CLASS msg_class ) ;
#line 437
VOID hsc_clear_msg_ignore(HSCPRC *hp___0 ) ;
#line 438
VOID hsc_reset_msg_class(HSCPRC *hp___0 ) ;
#line 441
STRPTR compactWs(HSCPRC *hp___0 , STRPTR ws ) ;
#line 445
BOOL hsc_standard_nomem_handler(size_t size ) ;
#line 46 "./hsclib/idref.h"
VOID del_idref(APTR data ) ;
#line 33 "./hsclib/css.h"
VOID del_styleattr(APTR data ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
static VOID del_inpf_stack_node(APTR data ) 
{ 


  {
#line 50
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID del_hscprc(HSCPRC *hp___0 ) 
{ 


  {
#line 59
  if (hp___0) {
    {
#line 62
    del_dllist(hp___0->defstyle);
#line 63
    del_dllist(hp___0->defent);
#line 64
    del_dllist(hp___0->deftag);
#line 65
    del_dllist(hp___0->defattr);
#line 66
    del_dllist(hp___0->deflazy);
#line 67
    del_dllist(hp___0->container_stack);
#line 68
    del_dllist(hp___0->content_stack);
#line 69
    del_dllist(hp___0->inpf_stack);
#line 70
    del_dllist(hp___0->idrefs);
#line 71
    del_dllist(hp___0->select_stack);
#line 72
    del_dllist(hp___0->tag_styles);
#line 73
    del_strlist(hp___0->include_dirs);
#line 76
    del_estr(hp___0->destdir);
#line 77
    del_estr(hp___0->reldir);
#line 78
    del_estr(hp___0->iconbase);
#line 79
    del_estr(hp___0->server_dir);
#line 80
    del_estr(hp___0->if_stack);
#line 81
    del_estr(hp___0->tag_name_str);
#line 82
    del_estr(hp___0->tag_attr_str);
#line 83
    del_estr(hp___0->tag_close_str);
#line 84
    del_estr(hp___0->tmpstr);
#line 85
    del_estr(hp___0->curr_msg);
#line 86
    del_estr(hp___0->curr_ref);
#line 87
    del_estr(hp___0->whtspc);
#line 89
    ugly_freestr(hp___0->filename_document, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c",
                 (ULONG )89);
#line 89
    hp___0->filename_document = (STRPTR )((void *)0);
#line 90
    ugly_freestr(hp___0->strip_tags, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c",
                 (ULONG )90);
#line 90
    hp___0->strip_tags = (STRPTR )((void *)0);
    }
#line 92
    if (hp___0->image_buffer) {
      {
#line 92
      free((void *)hp___0->image_buffer);
#line 92
      hp___0->image_buffer = (unsigned char *)((void *)0);
      }
    }
    {
#line 95
    del_project(hp___0->project);
    }
#line 98
    if (hp___0->inpf) {
      {
#line 98
      infclose1(hp___0->inpf);
#line 98
      hp___0->inpf = (INFILE *)((void *)0);
      }
    }
#line 101
    if (hp___0->msg_ignore) {
      {
#line 101
      free((void *)hp___0->msg_ignore);
#line 101
      hp___0->msg_ignore = (HSCIGN *)((void *)0);
      }
    }
#line 102
    if (hp___0->msg_class) {
      {
#line 102
      free((void *)hp___0->msg_class);
#line 102
      hp___0->msg_class = (HSCMSG_CLASS *)((void *)0);
      }
    }
#line 104
    if (hp___0) {
      {
#line 104
      free((void *)hp___0);
#line 104
      hp___0 = (HSCPRC *)((void *)0);
      }
    }
  }
#line 106
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID reset_hscprc(HSCPRC *hp___0 ) 
{ 
  int i ;
  char *tmp ;

  {
  {
#line 118
  hp___0->start_time = time((time_t *)((void *)0));
#line 121
  ugly_clr_estr(hp___0->destdir);
#line 122
  ugly_clr_estr(hp___0->reldir);
#line 123
  ugly_clr_estr(hp___0->if_stack);
#line 124
  ugly_clr_estr(hp___0->whtspc);
#line 126
  hp___0->suppress_output = (BOOL )1;
#line 127
  hp___0->fatal = (BOOL )0;
#line 128
  hp___0->prev_heading_num = (LONG )0;
#line 129
  hp___0->prev_status_line = (ULONG )-1;
#line 130
  hp___0->msg_count = (ULONG )0;
#line 132
  hp___0->inside_pre = (BOOL )0;
#line 133
  hp___0->inside_anchor = (BOOL )0;
#line 134
  hp___0->inside_title = (BOOL )0;
#line 136
  hp___0->tag_next_whtspc = (HSCTAG *)((void *)0);
#line 137
  hp___0->strip_badws = (BOOL )0;
#line 138
  hp___0->strip_next_whtspc = (BOOL )0;
#line 139
  hp___0->strip_next2_whtspc = (BOOL )0;
#line 141
  ugly_freestr(hp___0->strip_tags, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c",
               (ULONG )141);
#line 141
  hp___0->strip_tags = (STRPTR )((void *)0);
#line 144
  tmp = getenv("HSCSALARY");
#line 144
  hp___0->prostitute = (BOOL )((unsigned long )tmp != (unsigned long )((void *)0));
#line 146
  hp___0->nested_errors = (BOOL )1;
#line 147
  hp___0->lctags = (BOOL )0;
#line 148
  hp___0->xhtml = (BOOL )0;
#line 151
  hp___0->max_messages = (ULONG )-1;
#line 152
  hp___0->max_errors = (ULONG )-1;
#line 155
  hp___0->msg_ignore_notes = (BOOL )0;
#line 156
  hp___0->msg_ignore_style = (BOOL )0;
#line 157
  hp___0->msg_ignore_port = (BOOL )0;
#line 158
  i = 0;
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i <= 95)) {
#line 158
      goto while_break;
    }
#line 160
    *(hp___0->msg_ignore + i) = (HSCIGN )0;
#line 161
    *(hp___0->msg_class + i) = (HSCMSG_CLASS )0;
#line 158
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
HSCPRC *new_hscprc(void) 
{ 
  HSCPRC *hp___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 172
  hp___0 = (HSCPRC *)((void *)0);
#line 174
  tmp = ugly_malloc_notracking(sizeof(HSCPRC ));
#line 174
  hp___0 = (HSCPRC *)tmp;
  }
#line 175
  if (hp___0) {
    {
#line 177
    memset((void *)hp___0, 0, sizeof(HSCPRC ));
#line 180
    hp___0->defent = init_dllist(& del_entity);
#line 181
    hp___0->deftag = init_dllist(& del_hsctag);
#line 182
    hp___0->defattr = init_dllist(& del_hscattr);
#line 183
    hp___0->deflazy = init_dllist(& del_hsctag);
#line 184
    hp___0->defstyle = init_dllist(& del_styleattr);
#line 185
    hp___0->container_stack = init_dllist(& del_hsctag);
#line 186
    hp___0->content_stack = init_dllist(& del_string_node);
#line 187
    hp___0->inpf_stack = init_dllist(& del_inpf_stack_node);
#line 188
    hp___0->project = (HSCPRJ *)((void *)0);
#line 189
    hp___0->idrefs = init_dllist(& del_idref);
#line 190
    hp___0->select_stack = init_dllist(& del_select_stack_node);
#line 191
    hp___0->tag_styles = init_dllist(& del_styleattr);
#line 192
    hp___0->include_dirs = init_strlist();
#line 195
    hp___0->destdir = ugly_init_estr((size_t )0);
#line 196
    hp___0->reldir = ugly_init_estr((size_t )0);
#line 197
    hp___0->iconbase = ugly_init_estr((size_t )0);
#line 198
    hp___0->server_dir = ugly_init_estr((size_t )0);
#line 199
    hp___0->if_stack = ugly_init_estr((size_t )0);
#line 200
    hp___0->tag_name_str = ugly_init_estr((size_t )128);
#line 201
    hp___0->tag_attr_str = ugly_init_estr((size_t )128);
#line 202
    hp___0->tag_close_str = ugly_init_estr((size_t )0);
#line 203
    hp___0->tmpstr = ugly_init_estr((size_t )0);
#line 204
    hp___0->curr_msg = ugly_init_estr((size_t )64);
#line 205
    hp___0->curr_ref = ugly_init_estr((size_t )64);
#line 206
    hp___0->whtspc = ugly_init_estr((size_t )0);
#line 209
    tmp___0 = ugly_malloc_notracking(96UL * sizeof(HSCIGN ));
#line 209
    hp___0->msg_ignore = (HSCIGN *)tmp___0;
#line 211
    tmp___1 = ugly_malloc_notracking(96UL * sizeof(HSCMSG_CLASS ));
#line 211
    hp___0->msg_class = (HSCMSG_CLASS *)tmp___1;
#line 215
    tmp___2 = ugly_malloc_notracking((size_t )2048);
#line 215
    hp___0->image_buffer = (unsigned char *)tmp___2;
#line 217
    reset_hscprc(hp___0);
    }
  }
#line 219
  return (hp___0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_chkid(HSCPRC *hp___0 ) 
{ 


  {
#line 232
  return (hp___0->chkid);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_chkuri(HSCPRC *hp___0 ) 
{ 


  {
#line 236
  return (hp___0->chkuri);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_compact(HSCPRC *hp___0 ) 
{ 


  {
#line 240
  return (hp___0->compact);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_debug(HSCPRC *hp___0 ) 
{ 


  {
#line 244
  return (hp___0->debug);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_getsize(HSCPRC *hp___0 ) 
{ 


  {
#line 248
  return (hp___0->getsize);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_htmlonly(HSCPRC *hp___0 ) 
{ 


  {
#line 252
  return (hp___0->htmlonly);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_jerkvalues(HSCPRC *hp___0 ) 
{ 


  {
#line 256
  return (hp___0->jerkvalues);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_rplc_ent(HSCPRC *hp___0 ) 
{ 


  {
#line 260
  return (hp___0->rplc_ent);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_rplc_quote(HSCPRC *hp___0 ) 
{ 


  {
#line 264
  return (hp___0->rplc_quote);
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_smart_ent(HSCPRC *hp___0 ) 
{ 


  {
#line 268
  return (hp___0->smart_ent);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_strip_badws(HSCPRC *hp___0 ) 
{ 


  {
#line 272
  return (hp___0->strip_badws);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_strip_cmt(HSCPRC *hp___0 ) 
{ 


  {
#line 276
  return (hp___0->strip_cmt);
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_strip_ext(HSCPRC *hp___0 ) 
{ 


  {
#line 280
  return (hp___0->strip_ext);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_nested_errors(HSCPRC *hp___0 ) 
{ 


  {
#line 284
  return (hp___0->nested_errors);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_lctags(HSCPRC *hp___0 ) 
{ 


  {
#line 288
  return (hp___0->lctags);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_xhtml(HSCPRC *hp___0 ) 
{ 


  {
#line 292
  return (hp___0->xhtml);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_suppress_output(HSCPRC *hp___0 ) 
{ 


  {
#line 299
  return (hp___0->suppress_output);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_inside_pre(HSCPRC *hp___0 ) 
{ 


  {
#line 303
  return (hp___0->inside_pre);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_inside_anchor(HSCPRC *hp___0 ) 
{ 


  {
#line 307
  return (hp___0->inside_anchor);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_fatal(HSCPRC *hp___0 ) 
{ 


  {
#line 311
  return (hp___0->fatal);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
STRPTR hsc_get_destdir(HSCPRC *hp___0 ) 
{ 


  {
#line 318
  return ((hp___0->destdir)->es_data);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
STRPTR hsc_get_reldir(HSCPRC *hp___0 ) 
{ 


  {
#line 322
  return ((hp___0->reldir)->es_data);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
STRPTR hsc_get_iconbase(HSCPRC *hp___0 ) 
{ 


  {
#line 326
  return ((hp___0->iconbase)->es_data);
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
STRPTR hsc_get_server_dir(HSCPRC *hp___0 ) 
{ 


  {
#line 330
  return ((hp___0->server_dir)->es_data);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
STRPTR hsc_get_click_here_str(HSCPRC *hp___0 ) 
{ 


  {
#line 338
  return (hp___0->click_here_str);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
STRPTR hsc_get_file_name(HSCPRC *hp___0 ) 
{ 
  STRPTR tmp ;

  {
#line 342
  if (hp___0->inpf) {
    {
#line 343
    tmp = infget_fname(hp___0->inpf);
    }
#line 343
    return (tmp);
  } else {
#line 345
    return ((STRPTR )((void *)0));
  }
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
ULONG hsc_get_file_line(HSCPRC *hp___0 ) 
{ 
  ULONG tmp ;

  {
#line 349
  if (hp___0->inpf) {
    {
#line 350
    tmp = infget_y(hp___0->inpf);
    }
#line 350
    return (tmp);
  } else {
#line 352
    return ((ULONG )0);
  }
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
ULONG hsc_get_file_column(HSCPRC *hp___0 ) 
{ 
  ULONG tmp ;

  {
#line 356
  if (hp___0->inpf) {
    {
#line 357
    tmp = infget_x(hp___0->inpf);
    }
#line 357
    return (tmp);
  } else {
#line 359
    return ((ULONG )0);
  }
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
ULONG hsc_get_msg_count(HSCPRC *hp___0 ) 
{ 


  {
#line 363
  return (hp___0->msg_count);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_set_destdir(HSCPRC *hp___0 , STRPTR dir ) 
{ 


  {
  {
#line 376
  ugly_set_estr(hp___0->destdir, (CONSTRPTR )dir);
#line 378
  link_fname(hp___0->destdir, (hp___0->destdir)->es_data, (STRPTR )"");
  }
#line 381
  return ((BOOL )1);
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_set_reldir(HSCPRC *hp___0 , STRPTR dir ) 
{ 


  {
  {
#line 386
  link_fname(hp___0->reldir, dir, (STRPTR )"");
  }
#line 388
  return ((BOOL )1);
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_set_iconbase(HSCPRC *hp___0 , STRPTR uri ) 
{ 


  {
  {
#line 392
  ugly_set_estr(hp___0->iconbase, (CONSTRPTR )uri);
  }
#line 394
  return ((BOOL )1);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_set_server_dir(HSCPRC *hp___0 , STRPTR dir ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 398
  ugly_set_estr(hp___0->server_dir, (CONSTRPTR )dir);
#line 402
  tmp = last_ch(dir);
#line 402
  tmp___0 = strchr("/", tmp);
  }
#line 402
  if (! tmp___0) {
    {
#line 403
    ugly_app_estrch(hp___0->server_dir, (int )*("/" + 0));
    }
  }
#line 406
  return ((BOOL )1);
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_set_strip_tags(HSCPRC *hp___0 , STRPTR taglist ) 
{ 


  {
  {
#line 410
  ugly_reallocstr(& hp___0->strip_tags, (CONSTRPTR )taglist, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c",
                  (ULONG )410);
  }
#line 411
  return ((BOOL )1);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_set_filename_document(HSCPRC *hp___0 , STRPTR filename ) 
{ 
  BOOL ok ;

  {
  {
#line 415
  ok = (BOOL )0;
#line 418
  hp___0->filename_document = ugly_strclone((CONSTRPTR )filename, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c",
                                            (ULONG )418);
  }
#line 419
  return (ok);
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_chkid(HSCPRC *hp___0 , BOOL new_chkid ) 
{ 


  {
#line 426
  hp___0->chkid = new_chkid;
#line 428
  return;
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_chkuri(HSCPRC *hp___0 , BOOL new_chkuri ) 
{ 


  {
#line 431
  hp___0->chkuri = new_chkuri;
#line 433
  return;
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_compact(HSCPRC *hp___0 , BOOL new_compact ) 
{ 


  {
#line 436
  hp___0->compact = new_compact;
#line 438
  return;
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_debug(HSCPRC *hp___0 , BOOL new_debug ) 
{ 


  {
#line 441
  hp___0->debug = new_debug;
#line 443
  return;
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_getsize(HSCPRC *hp___0 , BOOL new_getsize ) 
{ 


  {
#line 446
  hp___0->getsize = new_getsize;
#line 448
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_jerkvalues(HSCPRC *hp___0 , BOOL new_jerkvalues ) 
{ 


  {
#line 451
  hp___0->jerkvalues = new_jerkvalues;
#line 453
  return;
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_rplc_ent(HSCPRC *hp___0 , BOOL new_rplc_ent ) 
{ 


  {
#line 456
  hp___0->rplc_ent = new_rplc_ent;
#line 458
  return;
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_rplc_quote(HSCPRC *hp___0 , BOOL new_rplc_quote ) 
{ 


  {
#line 461
  hp___0->rplc_quote = new_rplc_quote;
#line 463
  return;
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_smart_ent(HSCPRC *hp___0 , BOOL new_smart_ent ) 
{ 


  {
#line 466
  hp___0->smart_ent = new_smart_ent;
#line 468
  return;
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_strip_badws(HSCPRC *hp___0 , BOOL new_strip_badws ) 
{ 


  {
#line 471
  hp___0->strip_badws = new_strip_badws;
#line 473
  return;
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_strip_cmt(HSCPRC *hp___0 , BOOL new_strip_cmt ) 
{ 


  {
#line 476
  hp___0->strip_cmt = new_strip_cmt;
#line 478
  return;
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_strip_ext(HSCPRC *hp___0 , BOOL new_strip_ext ) 
{ 


  {
#line 481
  hp___0->strip_ext = new_strip_ext;
#line 483
  return;
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_nested_errors(HSCPRC *hp___0 , BOOL new_nested_errors ) 
{ 


  {
#line 486
  hp___0->nested_errors = new_nested_errors;
#line 488
  return;
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_lctags(HSCPRC *hp___0 , BOOL new_lctags ) 
{ 


  {
#line 491
  hp___0->lctags = new_lctags;
#line 493
  return;
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_checkext(HSCPRC *hp___0 , BOOL new_checkext ) 
{ 


  {
#line 496
  hp___0->checkext = new_checkext;
#line 498
  return;
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_xhtml(HSCPRC *hp___0 , BOOL new_xhtml ) 
{ 
  BOOL tmp ;

  {
#line 501
  tmp = new_xhtml;
#line 501
  hp___0->xhtml = tmp;
#line 501
  if (tmp) {
#line 502
    hp___0->lctags = (BOOL )1;
#line 503
    hp___0->quotemode = (LONG )2;
#line 504
    hp___0->validate_css = (BOOL )1;
#line 505
    hp___0->entitymode = (LONG )5;
  }
#line 508
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_vcss(HSCPRC *hp___0 , BOOL new_vcss ) 
{ 


  {
#line 511
  hp___0->validate_css = new_vcss;
#line 513
  return;
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_quote_mode(HSCPRC *hp___0 , LONG new_mode ) 
{ 


  {
#line 519
  hp___0->quotemode = new_mode;
#line 521
  return;
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_entity_mode(HSCPRC *hp___0 , LONG new_mode ) 
{ 


  {
#line 524
  if (-1L == new_mode) {
#line 525
    new_mode = (LONG )1;
  }
#line 526
  hp___0->entitymode = new_mode;
#line 528
  return;
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_maximum_messages(HSCPRC *hp___0 , LONG messages ) 
{ 


  {
#line 531
  hp___0->max_messages = (ULONG )messages;
#line 532
  return;
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_maximum_errors(HSCPRC *hp___0 , LONG errors ) 
{ 


  {
#line 535
  hp___0->max_errors = (ULONG )errors;
#line 536
  return;
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_status_file_begin(HSCPRC *hp___0 , VOID (*status_file)(HSCPRC *hp , STRPTR filename ) ) 
{ 


  {
#line 542
  hp___0->CB_status_file_begin = status_file;
#line 543
  return;
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_status_file_end(HSCPRC *hp___0 , VOID (*status_file)(HSCPRC *hp ) ) 
{ 


  {
#line 546
  hp___0->CB_status_file_end = status_file;
#line 547
  return;
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_status_line(HSCPRC *hp___0 , VOID (*status_line___0)(HSCPRC *hp ) ) 
{ 


  {
#line 550
  hp___0->CB_status_line = status_line___0;
#line 551
  return;
}
}
#line 553 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_status_misc(HSCPRC *hp___0 , VOID (*status_misc___0)(HSCPRC *hp , STRPTR s ) ) 
{ 


  {
#line 554
  hp___0->CB_status_misc = status_misc___0;
#line 555
  return;
}
}
#line 557 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_message(HSCPRC *hp___0 , VOID (*message___0)(struct hsc_process *hp ,
                                                          HSCMSG_CLASS msg_class ,
                                                          HSCMSG_ID msg_id , STRPTR fname ,
                                                          ULONG x , ULONG y , STRPTR msg_text ) ) 
{ 


  {
#line 564
  hp___0->CB_message = message___0;
#line 565
  return;
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_message_ref(HSCPRC *hp___0 , VOID (*message_ref___0)(struct hsc_process *hp ,
                                                                  HSCMSG_CLASS msg_class ,
                                                                  HSCMSG_ID msg_id ,
                                                                  STRPTR fname , ULONG x ,
                                                                  ULONG y , STRPTR msg_text ) ) 
{ 


  {
#line 574
  hp___0->CB_message_ref = message_ref___0;
#line 575
  return;
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_start_tag(HSCPRC *hp___0 , VOID (*start_tag)(struct hsc_process *hp ,
                                                          HSCTAG *tag , STRPTR tag_name ,
                                                          STRPTR tag_attr , STRPTR tag_close ) ) 
{ 


  {
#line 581
  hp___0->CB_start_tag = start_tag;
#line 582
  return;
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_end_tag(HSCPRC *hp___0 , VOID (*end_tag)(struct hsc_process *hp , HSCTAG *tag ,
                                                      STRPTR tag_name , STRPTR tag_attr ,
                                                      STRPTR tag_close ) ) 
{ 


  {
#line 588
  hp___0->CB_end_tag = end_tag;
#line 589
  return;
}
}
#line 591 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_text(HSCPRC *hp___0 , VOID (*text)(struct hsc_process *hp , STRPTR white_spaces ,
                                                STRPTR text ) ) 
{ 


  {
#line 595
  hp___0->CB_text = text;
#line 596
  return;
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_set_id(HSCPRC *hp___0 , VOID (*id)(struct hsc_process *hp , HSCATTR *attr ,
                                            STRPTR id ) ) 
{ 


  {
#line 602
  hp___0->CB_id = id;
#line 603
  return;
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_set_msg_ignore(HSCPRC *hp___0 , HSCMSG_ID msg_id , HSCIGN value ) 
{ 
  BOOL set ;

  {
#line 609
  set = (BOOL )0;
#line 611
  if ((msg_id & 4095L) <= 95L) {
#line 612
    *(hp___0->msg_ignore + (msg_id & 4095L)) = value;
  }
#line 613
  return (set);
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
HSCIGN hsc_get_msg_ignore(HSCPRC *hp___0 , HSCMSG_ID msg_id ) 
{ 
  unsigned int tmp ;

  {
#line 618
  if ((msg_id & 4095L) <= 95L) {
#line 618
    tmp = (unsigned int )*(hp___0->msg_ignore + (msg_id & 4095L));
  } else {
#line 618
    tmp = 0U;
  }
#line 618
  return ((HSCIGN )tmp);
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_set_msg_class(HSCPRC *hp___0 , HSCMSG_ID msg_id , HSCMSG_CLASS msg_class ) 
{ 
  BOOL set ;

  {
#line 623
  set = (BOOL )0;
#line 625
  if ((msg_id & 4095L) <= 95L) {
#line 626
    *(hp___0->msg_class + (msg_id & 4095L)) = msg_class;
  }
#line 627
  return (set);
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
HSCMSG_CLASS hsc_get_msg_class(HSCPRC *hp___0 , HSCMSG_ID msg_id ) 
{ 
  HSCMSG_ID msg_id_unmasked ;
  HSCMSG_CLASS mchp ;
  HSCMSG_CLASS mcid ;
  HSCMSG_CLASS tmp ;

  {
#line 631
  msg_id_unmasked = msg_id & 4095L;
#line 632
  if (msg_id_unmasked <= 95L) {
#line 633
    mchp = *(hp___0->msg_class + msg_id_unmasked);
#line 634
    mcid = msg_id & 61440L;
#line 635
    if (mcid > mchp) {
#line 635
      tmp = mcid;
    } else {
#line 635
      tmp = mchp;
    }
#line 635
    return (tmp);
  }
#line 637
  return ((HSCMSG_CLASS )1044480);
}
}
#line 643 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_msg_ignore_notes(HSCPRC *hp___0 ) 
{ 


  {
#line 644
  return (hp___0->msg_ignore_notes);
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_msg_ignore_style(HSCPRC *hp___0 ) 
{ 


  {
#line 648
  return (hp___0->msg_ignore_style);
}
}
#line 651 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_get_msg_ignore_port(HSCPRC *hp___0 ) 
{ 


  {
#line 652
  return (hp___0->msg_ignore_port);
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_set_msg_ignore_notes(HSCPRC *hp___0 , BOOL value ) 
{ 


  {
#line 656
  hp___0->msg_ignore_notes = value;
#line 657
  return (value);
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_set_msg_ignore_style(HSCPRC *hp___0 , BOOL value ) 
{ 


  {
#line 661
  hp___0->msg_ignore_style = value;
#line 662
  return (value);
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_set_msg_ignore_port(HSCPRC *hp___0 , BOOL value ) 
{ 


  {
#line 666
  hp___0->msg_ignore_port = value;
#line 667
  return (value);
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_clear_msg_ignore(HSCPRC *hp___0 ) 
{ 
  size_t i ;

  {
#line 676
  i = (size_t )0;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! (i <= 95UL)) {
#line 676
      goto while_break;
    }
#line 677
    *(hp___0->msg_ignore + i) = (HSCIGN )0;
#line 676
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  return;
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_reset_msg_class(HSCPRC *hp___0 ) 
{ 
  size_t i ;

  {
#line 682
  i = (size_t )0;
  {
#line 682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 682
    if (! (i <= 95UL)) {
#line 682
      goto while_break;
    }
#line 683
    *(hp___0->msg_class + i) = (HSCMSG_CLASS )1044480;
#line 682
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 684
  return;
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_add_include_directory(HSCPRC *hp___0 , STRPTR dir ) 
{ 
  DLNODE *tmp ;

  {
  {
#line 690
  tmp = app_strnode(hp___0->include_dirs, dir);
  }
#line 690
  return ((BOOL )((unsigned long )tmp != (unsigned long )((void *)0)));
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
VOID hsc_clr_include_directory(HSCPRC *hp___0 ) 
{ 


  {
  {
#line 694
  clr_strlist(hp___0->include_dirs);
  }
#line 695
  return;
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
STRPTR compactWs(HSCPRC *hp___0 , STRPTR ws ) 
{ 
  STRPTR newWs ;
  STRPTR containsLF ;
  char *tmp ;
  STRPTR containsCR ;
  char *tmp___0 ;

  {
#line 708
  newWs = (STRPTR )"";
#line 710
  if (*(ws + 0)) {
    {
#line 712
    tmp = strchr((char const   *)ws, '\n');
#line 712
    containsLF = tmp;
#line 713
    tmp___0 = strchr((char const   *)ws, '\r');
#line 713
    containsCR = tmp___0;
    }
#line 715
    if (containsLF) {
#line 716
      if (containsCR) {
#line 717
        newWs = (STRPTR )"\r\n";
      } else {
#line 719
        newWs = (STRPTR )"\n";
      }
    } else
#line 721
    if (containsCR) {
#line 722
      newWs = (STRPTR )"\r";
    } else {
#line 724
      newWs = (STRPTR )" ";
    }
  }
#line 727
  return (newWs);
}
}
#line 740 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_output_text(HSCPRC *hp___0 , STRPTR wspc , STRPTR text ) 
{ 
  BOOL written ;
  size_t tmp ;

  {
#line 741
  written = (BOOL )0;
#line 742
  if (hp___0->CB_text) {
#line 742
    if (! hp___0->suppress_output) {
#line 746
      if (wspc) {
        {
#line 747
        ugly_app_estr(hp___0->whtspc, (CONSTRPTR )wspc);
        }
      }
#line 748
      if (hp___0->compact) {
#line 748
        if (! hp___0->inside_pre) {
          {
#line 750
          wspc = compactWs(hp___0, (hp___0->whtspc)->es_data);
          }
        } else {
#line 752
          wspc = (hp___0->whtspc)->es_data;
        }
      } else {
#line 752
        wspc = (hp___0->whtspc)->es_data;
      }
#line 755
      if (hp___0->strip_next_whtspc) {
#line 757
        hp___0->strip_next_whtspc = (BOOL )0;
#line 758
        wspc = (STRPTR )"";
      } else
#line 759
      if (hp___0->strip_next2_whtspc) {
#line 760
        hp___0->strip_next2_whtspc = (BOOL )0;
#line 761
        hp___0->strip_next_whtspc = (BOOL )1;
      } else
#line 762
      if (hp___0->tag_next_whtspc) {
        {
#line 762
        tmp = strlen((char const   *)wspc);
        }
#line 762
        if (tmp) {
          {
#line 763
          hsc_message(hp___0, (HSCMSG_ID )8270, "succeeding white-space for %T", hp___0->tag_next_whtspc);
          }
        }
      }
#line 767
      hp___0->tag_next_whtspc = (HSCTAG *)((void *)0);
#line 777
      if (wspc) {
#line 777
        if (*(wspc + 0)) {
#line 777
          goto _L;
        } else {
#line 777
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 777
      if (text) {
#line 777
        if (*(text + 0)) {
          _L: /* CIL Label */ 
#line 779
          if (! wspc) {
#line 780
            wspc = (STRPTR )"";
          }
#line 781
          if (! text) {
#line 782
            text = (STRPTR )"";
          }
          {
#line 785
          (*(hp___0->CB_text))(hp___0, wspc, text);
#line 786
          written = (BOOL )1;
          }
        }
      }
      {
#line 789
      ugly_clr_estr(hp___0->whtspc);
      }
    }
  }
#line 791
  return (written);
}
}
#line 797 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/hscprc.c"
BOOL hsc_standard_nomem_handler(size_t size ) 
{ 


  {
  {
#line 798
  fputs((char const   */* __restrict  */)"\n*** out of memory\n\n", (FILE */* __restrict  */)stderr);
#line 799
  exit(2);
  }
#line 800
  return ((BOOL )0);
}
}
#line 44 "./hsclib/idref.h"
BOOL add_local_iddef(HSCPRC *hp___0 , STRPTR id ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/posteval.c"
BOOL postprocess_tagattr(HSCPRC *hp___0 , HSCTAG *tag , BOOL open_tag ) 
{ 
  BOOL dontstrip ;
  DLNODE *nd ;
  HSCATTR *attrib ;
  STRPTR value ;
  STRPTR tmp ;
  INFILEPOS *fpos ;
  INFILEPOS *tmp___0 ;
  CALLER *newcaller ;
  CALLER *tmp___1 ;
  HSCREF *newref ;
  HSCREF *tmp___2 ;
  STRPTR tmp___3 ;
  STRPTR tmp___4 ;
  URIKIND tmp___5 ;

  {
#line 57
  dontstrip = (BOOL )1;
#line 59
  if (tag->attr) {
#line 64
    if (hp___0->strip_ext) {
#line 64
      if (tag->uri_stripext) {
        {
#line 64
        tmp___3 = get_vartext(tag->uri_stripext);
        }
#line 64
        if (tmp___3) {
          {
#line 64
          tmp___4 = get_vartext(tag->uri_stripext);
#line 64
          tmp___5 = uri_kind(tmp___4);
          }
#line 64
          if ((unsigned int )tmp___5 == 1U) {
#line 71
            dontstrip = (BOOL )0;
          } else {
#line 64
            goto _L___1;
          }
        } else {
#line 64
          goto _L___1;
        }
      } else {
#line 64
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 72
    if (open_tag) {
#line 76
      nd = (tag->attr)->first;
      {
#line 77
      while (1) {
        while_continue: /* CIL Label */ ;
#line 77
        if (! nd) {
#line 77
          goto while_break;
        }
        {
#line 78
        attrib = (HSCATTR *)nd->data;
#line 79
        tmp = get_vartext(attrib);
#line 79
        value = tmp;
        }
#line 81
        if (value) {
#line 82
          if ((int )attrib->vartype == 1) {
            {
#line 84
            tmp___0 = new_infilepos(hp___0->inpf);
#line 84
            fpos = tmp___0;
#line 85
            tmp___1 = fpos2caller(fpos);
#line 85
            newcaller = tmp___1;
#line 86
            tmp___2 = app_reference((hp___0->project)->document, value);
#line 86
            newref = tmp___2;
#line 89
            newref->caller = newcaller;
#line 91
            del_infilepos(fpos);
            }
          } else
#line 94
          if ((int )attrib->vartype == 6) {
            {
#line 97
            add_local_iddef(hp___0, value);
            }
          }
        }
#line 100
        nd = nd->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 104
  return (dontstrip);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
LONG disp_status  =    (LONG )1;
#line 42 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
static size_t prev_stmsg_len  =    (size_t )0;
#line 43 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
static ULONG prev_status_line  =    (ULONG )0;
#line 49 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
static STRARR status_buf[162]  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
VOID set_return_code(int newrc ) 
{ 


  {
#line 59
  if (newrc > return_code) {
#line 64
    return_code = newrc;
  }
#line 73
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
VOID status_msg(STRPTR s___2 ) 
{ 
  size_t new_stmsg_len ;
  size_t tmp ;
  size_t i ;

  {
  {
#line 84
  tmp = strlen((char const   *)s___2);
#line 84
  new_stmsg_len = tmp;
  }
#line 87
  if (disp_status) {
#line 90
    if (*(s___2 + 0)) {
      {
#line 91
      fputs((char const   */* __restrict  */)s___2, (FILE */* __restrict  */)stderr);
      }
    }
#line 94
    i = new_stmsg_len;
    {
#line 94
    while (1) {
      while_continue: /* CIL Label */ ;
#line 94
      if (! (i < prev_stmsg_len)) {
#line 94
        goto while_break;
      }
      {
#line 95
      fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)stderr);
#line 94
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 98
    fputs((char const   */* __restrict  */)"\r", (FILE */* __restrict  */)stderr);
#line 99
    fflush(stderr);
#line 101
    prev_stmsg_len = new_stmsg_len;
    }
  }
#line 103
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
VOID status_clear(void) 
{ 


  {
  {
#line 112
  status_msg((STRPTR )"");
  }
#line 113
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
static VOID status_file_and_line(HSCPRC *hp___0 ) 
{ 
  STRPTR filename ;
  STRPTR tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  ULONG tmp___2 ;
  STRPTR tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 125
  tmp = hsc_get_file_name(hp___0);
#line 125
  filename = tmp;
  }
#line 127
  if (filename) {
    {
#line 132
    strncpy((char */* __restrict  */)(status_buf), (char const   */* __restrict  */)filename,
            (size_t )160);
#line 133
    tmp___0 = strlen((char const   *)(status_buf));
#line 133
    strncat((char */* __restrict  */)(status_buf), (char const   */* __restrict  */)" (",
            160UL - tmp___0);
#line 134
    tmp___1 = strlen((char const   *)(status_buf));
#line 134
    tmp___2 = hsc_get_file_line(hp___0);
#line 134
    tmp___3 = long2str((LONG )tmp___2);
#line 134
    strncat((char */* __restrict  */)(status_buf), (char const   */* __restrict  */)tmp___3,
            160UL - tmp___1);
#line 136
    tmp___4 = strlen((char const   *)(status_buf));
#line 136
    strncat((char */* __restrict  */)(status_buf), (char const   */* __restrict  */)")",
            160UL - tmp___4);
    }
  } else {
    {
#line 140
    strcpy((char */* __restrict  */)(status_buf), (char const   */* __restrict  */)"");
    }
  }
  {
#line 143
  status_msg(status_buf);
  }
#line 144
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
VOID status_lf(void) 
{ 


  {
#line 154
  if (disp_status) {
    {
#line 156
    fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stderr);
#line 157
    prev_status_line = (ULONG )0;
    }
  }
#line 159
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
VOID status_file_begin(HSCPRC *hp___0 , STRPTR filename ) 
{ 
  size_t tmp ;

  {
#line 169
  if (filename) {
    {
#line 174
    strncpy((char */* __restrict  */)(status_buf), (char const   */* __restrict  */)filename,
            (size_t )160);
#line 175
    tmp = strlen((char const   *)(status_buf));
#line 175
    strncat((char */* __restrict  */)(status_buf), (char const   */* __restrict  */)" (reading)",
            160UL - tmp);
#line 176
    status_msg(status_buf);
    }
  }
#line 178
  return;
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
VOID status_file_end(HSCPRC *hp___0 ) 
{ 


  {
  {
#line 188
  status_file_and_line(hp___0);
#line 189
  status_msg(status_buf);
#line 190
  status_lf();
  }
#line 191
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
VOID status_line(HSCPRC *hp___0 ) 
{ 
  ULONG tmp ;

  {
#line 198
  if (disp_status & 1L) {
    {
#line 198
    tmp = hsc_get_file_line(hp___0);
    }
#line 198
    if (tmp - prev_status_line > 25UL) {
      {
#line 205
      status_file_and_line(hp___0);
#line 206
      status_msg(status_buf);
#line 207
      prev_status_line = hsc_get_file_line(hp___0);
      }
    }
  }
#line 209
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
VOID status_misc(HSCPRC *hp___0 , STRPTR s___2 ) 
{ 
  size_t tmp ;

  {
#line 218
  if (disp_status & (long )(1 << 2)) {
    {
#line 220
    strcpy((char */* __restrict  */)(status_buf), (char const   */* __restrict  */)"");
#line 224
    tmp = strlen((char const   *)(status_buf));
#line 224
    strncat((char */* __restrict  */)(status_buf), (char const   */* __restrict  */)s___2,
            160UL - tmp);
#line 225
    status_msg(status_buf);
#line 226
    status_lf();
    }
  }
#line 228
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/status.c"
VOID status_error(STRPTR s___2 ) 
{ 
  LONG old_disp_status ;

  {
  {
#line 238
  old_disp_status = disp_status;
#line 239
  disp_status = (LONG )1;
#line 242
  strncpy((char */* __restrict  */)(status_buf), (char const   */* __restrict  */)"*** ",
          (size_t )160);
#line 243
  strncat((char */* __restrict  */)(status_buf), (char const   */* __restrict  */)s___2,
          (size_t )160);
#line 244
  status_msg(status_buf);
#line 245
  status_lf();
#line 248
  disp_status = old_disp_status;
#line 250
  set_return_code(1);
  }
#line 251
  return;
}
}
#line 34 "./hsclib/css.h"
BOOL add_width_height_attrs(HSCPRC *hp___0 , ULONG width , ULONG height ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/size.c"
static UBYTE const   msof[14]  = 
#line 35 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/size.c"
  {      (UBYTE const   )192,      (UBYTE const   )193,      (UBYTE const   )194,      (UBYTE const   )195, 
        (UBYTE const   )197,      (UBYTE const   )198,      (UBYTE const   )199,      (UBYTE const   )201, 
        (UBYTE const   )202,      (UBYTE const   )203,      (UBYTE const   )205,      (UBYTE const   )206, 
        (UBYTE const   )207,      (UBYTE const   )0};
#line 54 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/size.c"
static unsigned char const   id_PNG[8]  = 
#line 54
  {      (unsigned char const   )137,      (unsigned char const   )80,      (unsigned char const   )78,      (unsigned char const   )71, 
        (unsigned char const   )13,      (unsigned char const   )10,      (unsigned char const   )26,      (unsigned char const   )10};
#line 84 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/size.c"
static VOID hsc_msg_img_corrupt(HSCPRC *hp___0 , STRPTR name , STRPTR cause ) 
{ 


  {
  {
#line 86
  hsc_message(hp___0, (HSCMSG_ID )16392, "image %q is corrupt (%s)", name, cause);
  }
#line 87
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/size.c"
static VOID try_setattr(HSCPRC *hp___0 , HSCATTR *attr , ULONG value ) 
{ 
  STRPTR old_value ;
  STRPTR tmp ;
  STRPTR new_value ;
  STRPTR tmp___0 ;
  STRPTR tmp___1 ;
  STRPTR tmp___2 ;
  STRPTR tmp___3 ;
  int tmp___4 ;

  {
#line 99
  if (attr) {
    {
#line 101
    tmp = get_vartext(attr);
#line 101
    old_value = tmp;
#line 102
    tmp___0 = long2str((LONG )value);
#line 102
    new_value = tmp___0;
    }
#line 103
    if (! old_value) {
      {
#line 106
      set_vartext(attr, new_value);
#line 109
      ugly_app_estr(hp___0->tag_attr_str, " ");
      }
#line 110
      if (hp___0->lctags) {
        {
#line 111
        tmp___2 = ugly_strclone((CONSTRPTR )attr->name, (hp___0->inpf)->filename,
                                (hp___0->inpf)->pos_y);
#line 111
        tmp___1 = tmp___2;
#line 113
        lowstr(tmp___1);
#line 114
        ugly_app_estr(hp___0->tag_attr_str, (CONSTRPTR )tmp___1);
#line 115
        ugly_freestr(tmp___1, (hp___0->inpf)->filename, (hp___0->inpf)->pos_y);
        }
      } else {
        {
#line 117
        ugly_app_estr(hp___0->tag_attr_str, (CONSTRPTR )attr->name);
        }
      }
      {
#line 119
      ugly_app_estr(hp___0->tag_attr_str, "=");
      }
#line 122
      if (hp___0->quotemode == 1L) {
        {
#line 124
        ugly_app_estrch(hp___0->tag_attr_str, '\"');
        }
      } else
#line 122
      if (hp___0->quotemode == 2L) {
        {
#line 124
        ugly_app_estrch(hp___0->tag_attr_str, '\"');
        }
      } else
#line 125
      if (hp___0->quotemode == 3L) {
        {
#line 126
        ugly_app_estrch(hp___0->tag_attr_str, '\'');
        }
      }
      {
#line 127
      tmp___3 = long2str((LONG )value);
#line 127
      ugly_app_estr(hp___0->tag_attr_str, (CONSTRPTR )tmp___3);
      }
#line 128
      if (hp___0->quotemode == 1L) {
        {
#line 130
        ugly_app_estrch(hp___0->tag_attr_str, '\"');
        }
      } else
#line 128
      if (hp___0->quotemode == 2L) {
        {
#line 130
        ugly_app_estrch(hp___0->tag_attr_str, '\"');
        }
      } else
#line 131
      if (hp___0->quotemode == 3L) {
        {
#line 132
        ugly_app_estrch(hp___0->tag_attr_str, '\'');
        }
      }
    } else {
      {
#line 138
      tmp___4 = strcmp((char const   *)old_value, (char const   *)new_value);
      }
#line 138
      if (tmp___4) {
        {
#line 140
        hsc_message(hp___0, (HSCMSG_ID )12333, "unexpected value for %A: expected %q, found %q",
                    attr, new_value, old_value);
        }
      }
    }
  }
#line 146
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/size.c"
BOOL get_attr_size(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  STRPTR srcuri ;
  unsigned char *buf___3 ;
  EXPSTR *srcpath ;
  EXPSTR *tmp ;
  EXPSTR *imgpath ;
  EXPSTR *tmp___0 ;
  ULONG width ;
  ULONG height ;
  BOOL transparent ;
  BOOL progressive ;
  STRPTR filetype ;
  STRPTR filename ;
  FILE *fref ;
  size_t bytes_read ;
  int *tmp___1 ;
  BOOL found ;
  long offset ;
  char *tmp___2 ;
  int tmp___3 ;
  ULONG use_global_colormap ;
  ULONG pixeldepth ;
  ULONG startimg ;
  BOOL fucked_up ;
  UBYTE blksize ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  HSCATTR *awidth ;
  HSCATTR *aheight ;
  STRPTR tmp___8 ;
  STRPTR tmp___9 ;
  URIKIND tmp___10 ;

  {
#line 160
  srcuri = (STRPTR )((void *)0);
#line 162
  if (tag->uri_size) {
    {
#line 163
    srcuri = get_vartext(tag->uri_size);
    }
  } else {
    {
#line 165
    display_panic_message((char *)"no uri_size", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/size.c",
                          (size_t )165);
    }
  }
#line 167
  if (hp___0->getsize) {
#line 167
    if (srcuri) {
      {
#line 167
      tmp___10 = uri_kind(srcuri);
      }
#line 167
      if ((unsigned int )tmp___10 != 1U) {
        {
#line 168
        buf___3 = hp___0->image_buffer;
#line 169
        tmp = ugly_init_estr((size_t )64);
#line 169
        srcpath = tmp;
#line 170
        tmp___0 = ugly_init_estr((size_t )64);
#line 170
        imgpath = tmp___0;
#line 171
        width = (ULONG )0;
#line 172
        height = (ULONG )0;
#line 173
        transparent = (BOOL )0;
#line 174
        progressive = (BOOL )0;
#line 175
        filetype = (STRPTR )((void *)0);
#line 176
        filename = (STRPTR )((void *)0);
#line 177
        fref = (FILE *)((void *)0);
#line 180
        conv_hscuri2file(hp___0, srcpath, srcuri);
#line 181
        filename = srcpath->es_data;
#line 186
        fref = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
        }
#line 188
        if (fref) {
          {
#line 189
          bytes_read = (size_t )0;
#line 192
          memset((void *)buf___3, 0, (size_t )2048);
#line 195
          tmp___1 = __errno_location();
#line 195
          *tmp___1 = 0;
#line 196
          bytes_read = fread((void */* __restrict  */)buf___3, (size_t )1, (size_t )2048,
                             (FILE */* __restrict  */)fref);
#line 197
          tmp___7 = __errno_location();
          }
#line 197
          if (*tmp___7) {
            {
#line 199
            hsc_msg_read_error(hp___0, filename);
            }
          } else
#line 200
          if (255 == (int )*(buf___3 + 0)) {
#line 200
            if (216 == (int )*(buf___3 + 1)) {
#line 204
              found = (BOOL )0;
#line 205
              offset = 2L;
              {
#line 207
              while (1) {
                while_continue: /* CIL Label */ ;
                {
#line 208
                fseek(fref, offset, 0);
#line 209
                fread((void */* __restrict  */)buf___3, (size_t )1, (size_t )16, (FILE */* __restrict  */)fref);
                }
#line 210
                if (255 != (int )*(buf___3 + 0)) {
#line 211
                  goto while_break;
                }
                {
#line 212
                tmp___2 = strchr((char const   *)((char *)(msof)), (int )*(buf___3 + 1));
                }
#line 212
                if ((unsigned long )((void *)0) == (unsigned long )tmp___2) {
#line 214
                  offset += (long )((((int )*(buf___3 + 2) << 8) + (int )*(buf___3 + 3)) + 2);
                } else {
#line 218
                  filetype = (STRPTR )"JFIF/JPEG";
#line 219
                  width = (ULONG )((int )*(buf___3 + 8) + ((int )*(buf___3 + 7) << 8));
#line 220
                  height = (ULONG )((int )*(buf___3 + 6) + ((int )*(buf___3 + 5) << 8));
#line 221
                  found = (BOOL )1;
                }
#line 207
                if (found) {
#line 207
                  goto while_break;
                } else {
                  {
#line 207
                  tmp___3 = feof(fref);
                  }
#line 207
                  if (tmp___3) {
#line 207
                    goto while_break;
                  }
                }
              }
              while_break: /* CIL Label */ ;
              }
#line 225
              if (! found) {
                {
#line 226
                hsc_msg_img_corrupt(hp___0, filename, (STRPTR )"no size info or illegal marker");
                }
              }
            } else {
#line 200
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 227
            tmp___5 = strncmp((char const   *)((char *)"GIF87a"), (char const   *)((STRPTR )buf___3),
                              (size_t )6);
            }
#line 227
            if (tmp___5) {
              {
#line 227
              tmp___6 = strncmp((char const   *)((char *)"GIF89a"), (char const   *)((STRPTR )buf___3),
                                (size_t )6);
              }
#line 227
              if (tmp___6) {
                {
#line 296
                tmp___4 = strncmp((char const   *)((char *)(id_PNG)), (char const   *)((char *)buf___3),
                                  (size_t )8);
                }
#line 296
                if (tmp___4) {
                  {
#line 331
                  hsc_message(hp___0, (HSCMSG_ID )12356, "filetype of %q not recognised",
                              srcpath->es_data);
                  }
                } else {
#line 300
                  filetype = (STRPTR )"PNG";
#line 301
                  width = (ULONG )(((8388608 * (int )*(buf___3 + 16) + 65536 * (int )*(buf___3 + 17)) + 256 * (int )*(buf___3 + 18)) + (int )*(buf___3 + 19));
#line 305
                  height = (ULONG )(((8388608 * (int )*(buf___3 + 20) + 65536 * (int )*(buf___3 + 21)) + 256 * (int )*(buf___3 + 22)) + (int )*(buf___3 + 23));
#line 310
                  progressive = (BOOL )*(buf___3 + 29);
                }
              } else {
                _L: /* CIL Label */ 
#line 232
                use_global_colormap = (ULONG )(((int )*(buf___3 + 10) & 128) >> 7);
#line 233
                pixeldepth = (ULONG )(((int )*(buf___3 + 10) & 7) + 1);
#line 234
                startimg = 13UL + (use_global_colormap * 3UL) * (ULONG )(1 << pixeldepth);
#line 235
                fucked_up = (BOOL )0;
                {
#line 240
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 240
                  if (! fucked_up) {
#line 240
                    if (! ((int )*(buf___3 + startimg) != 44)) {
#line 240
                      goto while_break___0;
                    }
                  } else {
#line 240
                    goto while_break___0;
                  }
#line 244
                  if ((int )*(buf___3 + startimg) == 33) {
#line 245
                    blksize = (UBYTE )0;
#line 247
                    if ((int )*(buf___3 + (startimg + 1UL)) == 249) {
#line 250
                      transparent = (BOOL )((int )*(buf___3 + (startimg + 3UL)) & 1);
                    }
#line 257
                    startimg += 2UL;
                    {
#line 258
                    while (1) {
                      while_continue___1: /* CIL Label */ ;
#line 259
                      blksize = *(buf___3 + startimg);
#line 261
                      startimg += (ULONG )(1L + (long )blksize);
#line 258
                      if (! fucked_up) {
#line 258
                        if (! blksize) {
#line 258
                          goto while_break___1;
                        }
                      } else {
#line 258
                        goto while_break___1;
                      }
                    }
                    while_break___1: /* CIL Label */ ;
                    }
#line 265
                    if (startimg > bytes_read - 9UL) {
                      {
#line 266
                      hsc_msg_img_corrupt(hp___0, filename, (STRPTR )"image buffer exeeds");
#line 267
                      fucked_up = (BOOL )1;
                      }
                    }
                  } else {
                    {
#line 271
                    hsc_msg_img_corrupt(hp___0, filename, (STRPTR )"unknown GIF-block");
#line 274
                    fucked_up = (BOOL )1;
                    }
                  }
                }
                while_break___0: /* CIL Label */ ;
                }
#line 278
                if ((int )*(buf___3 + startimg) != 44) {
#line 278
                  if (! fucked_up) {
                    {
#line 281
                    hsc_msg_img_corrupt(hp___0, filename, (STRPTR )"image separator expected");
                    }
                  } else {
#line 287
                    filetype = (STRPTR )"GIF";
#line 288
                    width = (ULONG )((int )*(buf___3 + (startimg + 5UL)) + 256 * (int )*(buf___3 + (startimg + 6UL)));
#line 289
                    height = (ULONG )((int )*(buf___3 + (startimg + 7UL)) + 256 * (int )*(buf___3 + (startimg + 8UL)));
#line 290
                    progressive = (BOOL )(0 != ((int )*(buf___3 + (startimg + 9UL)) & (1 << 6)));
                  }
                } else {
#line 287
                  filetype = (STRPTR )"GIF";
#line 288
                  width = (ULONG )((int )*(buf___3 + (startimg + 5UL)) + 256 * (int )*(buf___3 + (startimg + 6UL)));
#line 289
                  height = (ULONG )((int )*(buf___3 + (startimg + 7UL)) + 256 * (int )*(buf___3 + (startimg + 8UL)));
#line 290
                  progressive = (BOOL )(0 != ((int )*(buf___3 + (startimg + 9UL)) & (1 << 6)));
                }
              }
            } else {
#line 227
              goto _L;
            }
          }
          {
#line 341
          fclose(fref);
          }
        } else {
          {
#line 345
          hsc_msg_nouri(hp___0, srcpath->es_data, srcuri, (STRPTR )"image dimension");
          }
        }
#line 349
        if (height) {
#line 349
          if (width) {
            {
#line 350
            awidth = (HSCATTR *)((void *)0);
#line 350
            aheight = (HSCATTR *)((void *)0);
#line 352
            awidth = find_varname(tag->attr, (STRPTR )"WIDTH");
#line 353
            aheight = find_varname(tag->attr, (STRPTR )"HEIGHT");
#line 356
            ugly_app_estr(srcpath, ": ");
#line 357
            ugly_app_estr(srcpath, (CONSTRPTR )filetype);
#line 358
            ugly_app_estr(srcpath, ", ");
#line 359
            tmp___8 = long2str((LONG )width);
#line 359
            ugly_app_estr(srcpath, (CONSTRPTR )tmp___8);
#line 360
            ugly_app_estr(srcpath, "x");
#line 361
            tmp___9 = long2str((LONG )height);
#line 361
            ugly_app_estr(srcpath, (CONSTRPTR )tmp___9);
            }
#line 362
            if (progressive) {
              {
#line 363
              ugly_app_estr(srcpath, ", progressive");
              }
            }
#line 364
            if (transparent) {
              {
#line 365
              ugly_app_estr(srcpath, ", transparent");
              }
            }
            {
#line 366
            hsc_status_misc(hp___0, srcpath->es_data);
            }
#line 368
            if (hp___0->xhtml) {
              {
#line 370
              add_width_height_attrs(hp___0, width, height);
              }
            } else {
              {
#line 373
              try_setattr(hp___0, awidth, width);
#line 374
              try_setattr(hp___0, aheight, height);
              }
            }
          }
        }
        {
#line 379
        del_estr(srcpath);
#line 380
        del_estr(imgpath);
        }
      }
    }
  }
#line 382
  return ((BOOL )1);
}
}
#line 32 "./hsclib/lstatus.h"
VOID hsc_status_file_end(HSCPRC *hp___0 ) ;
#line 33
VOID hsc_status_line(HSCPRC *hp___0 ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lstatus.c"
VOID hsc_status_misc(HSCPRC *hp___0 , STRPTR s___2 ) 
{ 


  {
#line 31
  if (hp___0->CB_status_misc) {
    {
#line 32
    (*(hp___0->CB_status_misc))(hp___0, s___2);
    }
  }
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lstatus.c"
VOID hsc_status_file_begin(HSCPRC *hp___0 , STRPTR filename ) 
{ 


  {
#line 37
  if (hp___0->CB_status_file_begin) {
    {
#line 38
    (*(hp___0->CB_status_file_begin))(hp___0, filename);
    }
  }
#line 39
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lstatus.c"
VOID hsc_status_file_end(HSCPRC *hp___0 ) 
{ 


  {
#line 43
  if (hp___0->CB_status_file_end) {
    {
#line 44
    (*(hp___0->CB_status_file_end))(hp___0);
    }
  }
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/lstatus.c"
VOID hsc_status_line(HSCPRC *hp___0 ) 
{ 


  {
#line 49
  if (hp___0->CB_status_line) {
    {
#line 50
    (*(hp___0->CB_status_line))(hp___0);
    }
  }
#line 51
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_a.c"
BOOL handle_anchor(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  HSCATTR *vhref ;
  HSCATTR *tmp ;
  HSCATTR *vname ;
  HSCATTR *tmp___0 ;
  HSCATTR *vid ;
  HSCATTR *tmp___1 ;
  STRPTR href ;
  STRPTR name ;
  STRPTR id ;
  HSCATTR *anchor_attr ;
  HSCATTR *tmp___2 ;

  {
  {
#line 38
  tmp = find_varname(tag->attr, (STRPTR )"HREF");
#line 38
  vhref = tmp;
#line 39
  tmp___0 = find_varname(tag->attr, (STRPTR )"NAME");
#line 39
  vname = tmp___0;
#line 40
  tmp___1 = find_varname(tag->attr, (STRPTR )"ID");
#line 40
  vid = tmp___1;
#line 41
  href = (STRPTR )((void *)0);
#line 42
  name = (STRPTR )((void *)0);
#line 43
  id = (STRPTR )((void *)0);
  }
#line 46
  if (vhref) {
#line 48
    href = vhref->text;
  }
#line 50
  if (vname) {
#line 52
    name = vname->text;
  }
#line 54
  if (vid) {
#line 56
    id = vid->text;
  }
#line 60
  if (href) {
    {
#line 62
    tmp___2 = find_varname(hp___0->defattr, (STRPTR )"HSC.ANCHOR");
#line 62
    anchor_attr = tmp___2;
    }
#line 64
    if (anchor_attr) {
      {
#line 66
      set_vartext(anchor_attr, href);
      }
    } else {
      {
#line 70
      display_panic_message((char *)"no anchor-attribute", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_a.c",
                            (size_t )70);
      }
    }
#line 73
    hp___0->inside_anchor = (BOOL )1;
  }
#line 77
  if (! href) {
#line 77
    if (! name) {
#line 77
      if (! id) {
        {
#line 79
        hsc_message(hp___0, (HSCMSG_ID )16413, "%T without HREF, NAME or ID", tag);
        }
      }
    }
  }
#line 83
  return ((BOOL )1);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_a.c"
BOOL handle_canchor(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 


  {
#line 93
  hp___0->inside_anchor = (BOOL )0;
#line 97
  return ((BOOL )1);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
static void es_null___1(STRPTR func , STRPTR file , ULONG line ) 
{ 


  {
  {
#line 124
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n##\n## panic: es=NULL in %s()\n##   called from %s (%lu)\n##\n",
          func, file, line);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
static void s_null___1(STRPTR func , STRPTR file , ULONG line ) 
{ 


  {
  {
#line 130
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n##\n## panic: string=NULL in %s()\n##   called from %s (%lu)\n##\n",
          func, file, line);
  }
#line 132
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/expstr.c"
static BOOL do_set_estr_mem___1(EXPSTR *es , STRPTR new_data , size_t new_size ) 
{ 
  BOOL ok ;

  {
#line 153
  ok = (BOOL )1;
#line 155
  if (new_data) {
#line 162
    es->es_size = new_size;
#line 163
    es->es_data = new_data;
  } else {
#line 167
    ok = (BOOL )0;
  }
#line 169
  return (ok);
}
}
#line 29 "./hsc/output.h"
BOOL init_output(HSCPRC *hp___0 ) ;
#line 30
VOID cleanup_output(void) ;
#line 32
BOOL write_output(HSCPRC *hp___0 ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/hsc.c"
static HSCPRC *hp  =    (HSCPRC *)((void *)0);
#line 77 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/hsc.c"
static BOOL attempt_atexit(VOID (*func)(void) ) 
{ 
  BOOL ok ;
  int *tmp ;
  char errmsg[300] ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 80
  ok = (BOOL )0;
#line 82
  tmp = __errno_location();
#line 82
  *tmp = 0;
#line 83
  tmp___2 = atexit(func);
  }
#line 83
  if (tmp___2) {
    {
#line 87
    strncpy((char */* __restrict  */)(errmsg), (char const   */* __restrict  */)"atexit() failed: ",
            (size_t )300);
#line 88
    tmp___0 = __errno_location();
#line 88
    tmp___1 = strerror(*tmp___0);
#line 88
    strncat((char */* __restrict  */)(errmsg), (char const   */* __restrict  */)tmp___1,
            (size_t )300);
#line 89
    status_error(errmsg);
    }
  } else {
#line 93
    ok = (BOOL )1;
  }
#line 96
  return (ok);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/hsc.c"
static BOOL include_ok(HSCPRC *hp___0 ) 
{ 
  BOOL ok ;
  DLNODE *nd ;
  STRPTR filename ;

  {
#line 106
  ok = (BOOL )1;
#line 108
  if (incfile) {
#line 110
    nd = incfile->first;
    {
#line 112
    while (1) {
      while_continue: /* CIL Label */ ;
#line 112
      if (nd) {
#line 112
        if (! ok) {
#line 112
          goto while_break;
        }
      } else {
#line 112
        goto while_break;
      }
      {
#line 114
      filename = (STRPTR )nd->data;
#line 115
      ok = hsc_include_file(hp___0, filename, (ULONG )(1 << 8));
#line 116
      nd = nd->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return (ok);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/hsc.c"
static VOID cleanup___1(void) 
{ 


  {
  {
#line 135
  del_hscprc(hp);
#line 136
  cleanup_global();
#line 137
  cleanup_output();
#line 138
  cleanup_msgfile();
#line 139
  cleanup_hsc_args();
  }
#line 146
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/hsc.c"
static VOID msg_corrupt_pf___0(HSCPRJ *project___1 , STRPTR reason ) 
{ 
  EXPSTR *msg ;
  EXPSTR *tmp ;
  STRPTR tmp___0 ;

  {
  {
#line 153
  tmp = ugly_init_estr((size_t )32);
#line 153
  msg = tmp;
#line 154
  tmp___0 = infget_fname(project___1->inpf);
#line 154
  ugly_set_estr(msg, (CONSTRPTR )tmp___0);
#line 155
  ugly_app_estr(msg, ": project file corrupt");
  }
#line 156
  if (reason) {
    {
#line 158
    ugly_app_estr(msg, " (");
#line 159
    ugly_app_estr(msg, (CONSTRPTR )reason);
#line 160
    ugly_app_estr(msg, ")");
    }
  }
  {
#line 162
  status_error(msg->es_data);
#line 163
  del_estr(msg);
  }
#line 164
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/hsc.c"
static BOOL hsc_init_project(HSCPRC *hp___0 , STRPTR project_fname ) 
{ 
  BOOL ok ;
  EXPSTR *msg ;
  EXPSTR *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 174
  ok = (BOOL )0;
#line 177
  hp___0->project = new_project();
#line 178
  (hp___0->project)->user_data = (APTR )hp___0;
#line 179
  (hp___0->project)->debug = hp___0->debug;
#line 180
  (hp___0->project)->CB_msg_corrupt_pf = & msg_corrupt_pf___0;
  }
#line 182
  if (project_fname) {
    {
#line 189
    hsc_status_file_begin(hp___0, project_fname);
#line 192
    hp___0->inpf = infopen((CONSTRPTR )project_fname, (size_t )0);
    }
#line 194
    if (hp___0->inpf) {
      {
#line 196
      ok = hsc_project_read_data(hp___0->project, hp___0->inpf);
      }
#line 197
      if (hp___0->inpf) {
        {
#line 197
        infclose1(hp___0->inpf);
#line 197
        hp___0->inpf = (INFILE *)((void *)0);
        }
      }
#line 198
      if (ok) {
        {
#line 201
        tmp = ugly_init_estr((size_t )32);
#line 201
        msg = tmp;
#line 202
        ugly_set_estr(msg, (CONSTRPTR )project_fname);
#line 203
        ugly_app_estr(msg, ": project read");
#line 204
        hsc_status_misc(hp___0, msg->es_data);
#line 205
        del_estr(msg);
        }
      }
#line 208
      hp___0->inpf = (INFILE *)((void *)0);
    } else {
      {
#line 212
      tmp___0 = __errno_location();
#line 212
      tmp___1 = strerror(*tmp___0);
#line 212
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error reading project file: %s\n",
              project_fname, tmp___1);
#line 214
      ok = (BOOL )0;
      }
    }
  } else {
#line 220
    ok = (BOOL )1;
  }
#line 223
  if (ok) {
    {
#line 226
    hsc_project_set_document(hp___0->project, hp___0->filename_document);
    }
  }
#line 229
  return (ok);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/hsc.c"
int hsc_main(HSCPRC **hpVar , int argc , char **argv ) 
{ 
  BOOL init_hp ;
  STRPTR inpfname ;
  BOOL ok ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  int tmp___4 ;
  BOOL tmp___5 ;
  BOOL tmp___6 ;
  BOOL tmp___7 ;
  BOOL tmp___8 ;
  BOOL tmp___9 ;
  BOOL tmp___10 ;
  BOOL tmp___11 ;

  {
#line 237
  init_hp = (BOOL )0;
#line 239
  if (! *hpVar) {
    {
#line 241
    hp = new_hscprc();
#line 242
    init_hp = (BOOL )1;
#line 243
    *hpVar = hp;
    }
  } else {
    {
#line 247
    hp = *hpVar;
#line 248
    reset_hscprc(hp);
    }
  }
#line 251
  if (hp) {
    {
#line 251
    tmp___10 = init_global();
    }
#line 251
    if (tmp___10) {
      {
#line 251
      tmp___11 = args_ok(hp, argc, argv);
      }
#line 251
      if (tmp___11) {
#line 256
        inpfname = (STRPTR )((void *)0);
#line 257
        ok = (BOOL )1;
#line 260
        if (disp_status & (long )((1 << 1) | (1 << 2))) {
          {
#line 262
          fprintf_prginfo(stderr);
          }
        }
        {
#line 265
        tmp___8 = init_msgfile(hp, msgfilename);
        }
#line 265
        if (tmp___8) {
          {
#line 265
          tmp___9 = init_output(hp);
          }
#line 265
          if (tmp___9) {
#line 269
            return_code = 0;
#line 272
            inpfname = inpfilename->es_data;
#line 273
            if (! *(inpfname + 0)) {
#line 274
              inpfname = (STRPTR )((void *)0);
            }
#line 279
            if (ok) {
#line 279
              if (init_hp) {
                {
#line 281
                tmp = init_callback(hp);
                }
#line 281
                if (tmp) {
                  {
#line 281
                  tmp___0 = hsc_init_tagsNattr(hp);
                  }
#line 281
                  if (tmp___0) {
                    {
#line 281
                    tmp___1 = user_defines_ok(hp);
                    }
#line 281
                    if (tmp___1) {
                      {
#line 281
                      tmp___2 = hsc_init_hscprc(hp, prefsfilename);
                      }
#line 281
                      if (tmp___2) {
                        {
#line 281
                        tmp___3 = hsc_init_project(hp, prjfilename);
                        }
#line 281
                        if (tmp___3) {
#line 281
                          tmp___4 = 1;
                        } else {
#line 281
                          tmp___4 = 0;
                        }
                      } else {
#line 281
                        tmp___4 = 0;
                      }
                    } else {
#line 281
                      tmp___4 = 0;
                    }
                  } else {
#line 281
                    tmp___4 = 0;
                  }
                } else {
#line 281
                  tmp___4 = 0;
                }
#line 281
                ok = (BOOL )tmp___4;
              }
            }
#line 291
            if (ok) {
              {
#line 291
              tmp___6 = include_ok(hp);
              }
#line 291
              if (tmp___6) {
                {
#line 291
                tmp___7 = hsc_include_file(hp, inpfname, (ULONG )((1 | (1 << 9)) | (1 << 6)));
                }
#line 291
                if (tmp___7) {
                  {
#line 298
                  tmp___5 = write_output(hp);
                  }
#line 298
                  if (tmp___5) {
                    {
#line 301
                    hsc_project_write_data(hp->project, prjfilename, (BOOL )0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 307
  return (return_code);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/include.c"
static BOOL hsc_include(HSCPRC *hp___0 , INFILE *inpf , ULONG optn , INFILEPOS *base_pos ) 
{ 
  BOOL ok ;
  STRPTR tmp ;
  int tmp___0 ;
  ULONG tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  int tmp___4 ;

  {
#line 54
  ok = (BOOL )((unsigned long )inpf != (unsigned long )((void *)0));
#line 56
  if (optn & (unsigned long )(1 << 7)) {
    {
#line 57
    display_panic_message((char *)"IH_POS_PARENT set", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/include.c",
                          (size_t )57);
    }
  }
#line 59
  if (inpf) {
#line 62
    if (hp___0->inpf) {
      {
#line 63
      add_dlnode(hp___0->inpf_stack, (APTR )hp___0->inpf);
      }
    }
#line 67
    if (base_pos) {
      {
#line 68
      set_infile_base(inpf, base_pos);
      }
    }
#line 71
    hp___0->inpf = inpf;
#line 74
    if (optn & (unsigned long )(1 << 2)) {
#line 75
      optn |= (unsigned long )(1 << 5);
    }
#line 78
    inpf->is_nc = & hsc_normch;
#line 79
    inpf->is_ws = & hsc_whtspc;
#line 82
    if (! (optn & (unsigned long )(1 << 5))) {
      {
#line 82
      tmp___0 = infeof(inpf);
      }
#line 82
      if (! tmp___0) {
        {
#line 83
        tmp = infget_fname(hp___0->inpf);
#line 83
        hsc_status_file_begin(hp___0, tmp);
        }
      }
    }
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 86
      tmp___4 = infeof(inpf);
      }
#line 86
      if (tmp___4) {
#line 86
        goto while_break;
      } else
#line 86
      if (! ok) {
#line 86
        goto while_break;
      }
#line 88
      if (! (optn & (unsigned long )(1 << 5))) {
        {
#line 88
        tmp___1 = infget_y(hp___0->inpf);
        }
#line 88
        if (hp___0->prev_status_line != tmp___1) {
          {
#line 92
          hsc_status_line(hp___0);
#line 93
          hp___0->prev_status_line = infget_y(hp___0->inpf);
          }
        }
      }
#line 97
      if (optn & (unsigned long )(1 << 4)) {
        {
#line 97
        tmp___2 = hsc_parse_source(hp___0);
#line 97
        ok = tmp___2;
        }
      } else {
        {
#line 97
        tmp___3 = hsc_parse(hp___0);
#line 97
        ok = tmp___3;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 101
    if (ok) {
#line 101
      if (optn & 1UL) {
        {
#line 103
        ok = hsc_parse_end(hp___0);
        }
#line 105
        if (ok) {
#line 105
          if (optn & (unsigned long )(1 << 6)) {
            {
#line 108
            ok = hsc_parse_end_id(hp___0);
            }
          }
        }
      }
    }
#line 113
    if (! (optn & (unsigned long )(1 << 5))) {
      {
#line 116
      hsc_status_file_end(hp___0);
      }
    }
#line 120
    if (hp___0->inpf) {
      {
#line 120
      infclose1(hp___0->inpf);
#line 120
      hp___0->inpf = (INFILE *)((void *)0);
      }
    }
#line 124
    if ((hp___0->inpf_stack)->first) {
      {
#line 127
      hp___0->inpf = (INFILE *)((hp___0->inpf_stack)->first)->data;
#line 128
      ((hp___0->inpf_stack)->first)->data = (void *)0;
#line 130
      del_dlnode(hp___0->inpf_stack, (hp___0->inpf_stack)->first);
      }
    } else {
#line 134
      hp___0->inpf = (INFILE *)((void *)0);
    }
  } else {
    {
#line 139
    display_panic_message((char *)"no input file", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/include.c",
                          (size_t )139);
    }
  }
#line 142
  return (ok);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/include.c"
BOOL hsc_base_include_file(HSCPRC *hp___0 , STRPTR filename , ULONG optn , INFILEPOS *base_pos ) 
{ 
  BOOL ok ;
  INFILE *inpf ;
  EXPSTR *fpath ;
  EXPSTR *tmp ;
  STRPTR newpath ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 152
  ok = (BOOL )0;
#line 153
  inpf = (INFILE *)((void *)0);
#line 154
  tmp = ugly_init_estr((size_t )32);
#line 154
  fpath = tmp;
  }
#line 157
  if (! (optn & (unsigned long )((1 << 2) | (1 << 3)))) {
    {
#line 158
    hsc_status_file_begin(hp___0, filename);
    }
  }
  {
#line 161
  tmp___1 = strcmp((char const   *)filename, "STDIN");
  }
#line 161
  if (tmp___1) {
    {
#line 161
    tmp___2 = strcmp((char const   *)filename, "-");
    }
#line 161
    if (tmp___2) {
      {
#line 167
      get_fpath(fpath, (CONSTRPTR )filename);
      }
#line 169
      if (0UL != fpath->es_len - 1UL) {
        {
#line 170
        tmp___0 = ugly_malloc_notracking((fpath->es_len - 1UL) + 1UL);
#line 170
        newpath = (STRPTR )tmp___0;
#line 171
        strcpy((char */* __restrict  */)newpath, (char const   */* __restrict  */)fpath->es_data);
#line 172
        add_dlnode(hp___0->include_dirs, (APTR )newpath);
        }
      }
    } else {
#line 163
      filename = (STRPTR )((void *)0);
    }
  } else {
#line 163
    filename = (STRPTR )((void *)0);
  }
  {
#line 177
  tmp___3 = __errno_location();
#line 177
  *tmp___3 = 0;
#line 178
  inpf = infopen((CONSTRPTR )filename, (size_t )4096);
  }
#line 180
  if (inpf) {
    {
#line 182
    ok = hsc_include(hp___0, inpf, optn, base_pos);
    }
#line 188
    if (ok) {
#line 188
      if (hp___0->project) {
#line 189
        if (optn & (unsigned long )(1 << 9)) {
#line 190
          if (! filename) {
#line 191
            filename = (STRPTR )"STDIN";
          }
          {
#line 193
          hsc_project_set_source(hp___0->project, filename);
          }
        }
#line 199
        if (filename) {
#line 199
          if (optn & (unsigned long )(1 << 8)) {
            {
#line 201
            hsc_project_add_include(hp___0->project, filename);
            }
          }
        }
      }
    }
  } else {
    {
#line 205
    hsc_msg_noinput(hp___0, filename);
    }
  }
#line 208
  if (0UL != fpath->es_len - 1UL) {
    {
#line 209
    del_dlnode(hp___0->include_dirs, (hp___0->include_dirs)->first);
    }
  }
  {
#line 211
  del_estr(fpath);
  }
#line 212
  return (ok);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/include.c"
BOOL hsc_base_include_string(HSCPRC *hp___0 , STRPTR filename , STRPTR s___2 , ULONG optn ,
                             INFILEPOS *base_pos ) 
{ 
  BOOL ok ;
  INFILE *inpf ;

  {
#line 223
  inpf = (INFILE *)((void *)0);
#line 225
  if (optn & (unsigned long )(1 << 7)) {
#line 226
    filename = (STRPTR )"::p::";
#line 227
    optn &= (unsigned long )(~ (1 << 7));
  }
  {
#line 229
  inpf = infopen_str((CONSTRPTR )filename, (CONSTRPTR )s___2, (size_t )0);
#line 231
  ok = hsc_include(hp___0, inpf, optn, base_pos);
  }
#line 233
  return (ok);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/include.c"
static BOOL find_includefile(HSCPRC *hp___0 , EXPSTR *dest , STRPTR filename ) 
{ 
  BOOL found ;
  DLNODE *nd ;
  BOOL tmp ;
  BOOL tmp___0 ;

  {
  {
#line 253
  found = (BOOL )0;
#line 256
  ugly_set_estr(dest, (CONSTRPTR )filename);
#line 258
  tmp___0 = fexists(filename);
  }
#line 258
  if (tmp___0) {
#line 274
    found = (BOOL )1;
  } else {
#line 259
    nd = (hp___0->include_dirs)->first;
    {
#line 262
    while (1) {
      while_continue: /* CIL Label */ ;
#line 262
      if (nd) {
#line 262
        if (! (! found)) {
#line 262
          goto while_break;
        }
      } else {
#line 262
        goto while_break;
      }
      {
#line 265
      link_fname(dest, (STRPTR )nd->data, filename);
#line 267
      tmp = fexists(dest->es_data);
      }
#line 267
      if (tmp) {
#line 268
        found = (BOOL )1;
      } else {
#line 270
        nd = nd->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 282
  return (found);
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/include.c"
BOOL hsc_include_file(HSCPRC *hp___0 , STRPTR filename , ULONG optn ) 
{ 
  BOOL ok ;
  EXPSTR *real_filename ;
  EXPSTR *tmp ;

  {
  {
#line 288
  ok = (BOOL )0;
#line 289
  tmp = ugly_init_estr((size_t )64);
#line 289
  real_filename = tmp;
  }
#line 291
  if ((unsigned long )((void *)0) == (unsigned long )filename) {
    {
#line 292
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"hsc_include_file(): NULL/empty filename!\n");
    }
#line 293
    return (ok);
  }
  {
#line 297
  find_includefile(hp___0, real_filename, filename);
#line 300
  ok = hsc_base_include_file(hp___0, real_filename->es_data, optn, (INFILEPOS *)((void *)0));
#line 303
  del_estr(real_filename);
  }
#line 305
  return (ok);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/include.c"
BOOL hsc_include_string(HSCPRC *hp___0 , STRPTR filename , STRPTR s___2 , ULONG optn ) 
{ 
  BOOL tmp ;

  {
  {
#line 311
  tmp = hsc_base_include_string(hp___0, filename, s___2, optn, (INFILEPOS *)((void *)0));
  }
#line 311
  return (tmp);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static STRARR timebuf___1[40]  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_ulong___1(EXPSTR *dest , ULONG num ) 
{ 
  STRARR lenbuf[20] ;

  {
  {
#line 68
  sprintf((char */* __restrict  */)(lenbuf), (char const   */* __restrict  */)"%lx ",
          num);
#line 69
  ugly_app_estr(dest, (CONSTRPTR )(lenbuf));
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_string___1(EXPSTR *dest , STRPTR s___2 ) 
{ 


  {
  {
#line 75
  ugly_app_estr(dest, (CONSTRPTR )s___2);
  }
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_caller___1(EXPSTR *dest , CALLER *caller ) 
{ 


  {
#line 89
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_docname___1(EXPSTR *prjstr , STRPTR docname ) 
{ 


  {
  {
#line 93
  ugly_app_estr(prjstr, "DOCUMENT");
#line 94
  ugly_app_estr(prjstr, " ");
#line 95
  append_string___1(prjstr, docname);
#line 96
  ugly_app_estr(prjstr, "\n");
  }
#line 97
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_sourcename___1(EXPSTR *prjstr , STRPTR sourcename ) 
{ 


  {
#line 101
  if (sourcename) {
    {
#line 103
    ugly_app_estr(prjstr, "SOURCE");
#line 104
    ugly_app_estr(prjstr, " ");
#line 105
    append_string___1(prjstr, sourcename);
#line 106
    ugly_app_estr(prjstr, "\n");
    }
  }
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_title___1(EXPSTR *prjstr , STRPTR title ) 
{ 


  {
#line 112
  if (title) {
    {
#line 114
    ugly_app_estr(prjstr, "TITLE");
#line 115
    ugly_app_estr(prjstr, " ");
#line 116
    append_string___1(prjstr, title);
#line 117
    ugly_app_estr(prjstr, "\n");
    }
  }
#line 119
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_include___1(EXPSTR *prjstr , HSCINC *include ) 
{ 


  {
  {
#line 133
  ugly_app_estr(prjstr, "INCLUDE");
#line 134
  ugly_app_estr(prjstr, " ");
#line 135
  append_string___1(prjstr, include->name);
#line 136
  append_caller___1(prjstr, include->caller);
#line 137
  ugly_app_estr(prjstr, "\n");
  }
#line 141
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_iddef___1(EXPSTR *prjstr , HSCIDD *iddef ) 
{ 


  {
  {
#line 160
  ugly_app_estr(prjstr, "ID");
#line 161
  ugly_app_estr(prjstr, " ");
#line 162
  append_string___1(prjstr, iddef->name);
#line 163
  append_caller___1(prjstr, iddef->caller);
#line 164
  ugly_app_estr(prjstr, "\n");
  }
#line 165
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_header___1(EXPSTR *prjstr ) 
{ 
  time_t now ;
  time_t tmp ;
  struct tm *tmp___0 ;

  {
  {
#line 172
  tmp = time((time_t *)((void *)0));
#line 172
  now = tmp;
#line 175
  tmp___0 = localtime((time_t const   *)(& now));
#line 175
  strftime((char */* __restrict  */)(timebuf___1), (size_t )40, (char const   */* __restrict  */)"%d-%b-%Y %H:%M:%S",
           (struct tm  const  */* __restrict  */)tmp___0);
#line 179
  ugly_app_estr(prjstr, "HSC_PROJECT\nVERSION ");
#line 181
  append_ulong___1(prjstr, (ULONG )3);
#line 182
  ugly_app_estr(prjstr, "\n");
#line 183
  ugly_app_estr(prjstr, "# Contains all data relevant for project.\n# Maintained by hsc, DO NOT MODIFY!\n");
#line 186
  ugly_app_estr(prjstr, "# updated: ");
#line 188
  ugly_app_estr(prjstr, (CONSTRPTR )(timebuf___1));
#line 189
  ugly_app_estrch(prjstr, '\n');
  }
#line 190
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_doc_includes___1(EXPSTR *prjstr , DLLIST *inclist ) 
{ 
  DLNODE *nd ;

  {
#line 195
  nd = inclist->first;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! nd) {
#line 196
      goto while_break;
    }
    {
#line 198
    append_include___1(prjstr, (HSCINC *)nd->data);
#line 199
    nd = nd->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_doc_iddefs___1(EXPSTR *prjstr , DLLIST *iddefs ) 
{ 
  DLNODE *nd ;

  {
#line 219
  nd = iddefs->first;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! nd) {
#line 220
      goto while_break;
    }
    {
#line 222
    append_iddef___1(prjstr, (HSCIDD *)nd->data);
#line 223
    nd = nd->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/writeprj.c"
static VOID append_document___1(EXPSTR *prjstr , HSCDOC *document ) 
{ 
  STRPTR docname ;

  {
  {
#line 230
  docname = document->docname;
#line 232
  append_docname___1(prjstr, docname);
#line 233
  append_sourcename___1(prjstr, document->sourcename);
#line 234
  append_title___1(prjstr, (document->title)->es_data);
#line 236
  append_doc_iddefs___1(prjstr, document->iddefs);
#line 237
  append_doc_includes___1(prjstr, document->includes);
  }
#line 241
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static VOID hsc_msg_project_corrupt___1(HSCPRJ *hp___0 , STRPTR descr ) 
{ 


  {
#line 55
  hp___0->fatal = (BOOL )1;
#line 56
  if (hp___0->CB_msg_corrupt_pf) {
    {
#line 57
    (*(hp___0->CB_msg_corrupt_pf))(hp___0, descr);
    }
  }
#line 58
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static int x2int___1(char c ) 
{ 


  {
#line 63
  if ((int )c >= 48) {
#line 63
    if ((int )c <= 57) {
#line 64
      return ((int )c - 48);
    }
  }
#line 65
  if ((int )c >= 65) {
#line 65
    if ((int )c <= 70) {
#line 66
      return (((int )c - 65) + 10);
    }
  }
#line 67
  if ((int )c >= 97) {
#line 67
    if ((int )c <= 102) {
#line 68
      return (((int )c - 97) + 10);
    }
  }
#line 69
  return (-1);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static ULONG read_ulong___1(HSCPRJ *hp___0 ) 
{ 
  INFILE *inpf ;
  ULONG num ;
  int ch ;
  int digit ;

  {
#line 77
  inpf = hp___0->inpf;
#line 78
  num = (ULONG )0;
#line 80
  digit = -1;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 84
    ch = infgetc(inpf);
    }
#line 85
    if (ch != 32) {
      {
#line 87
      digit = x2int___1((char )ch);
      }
#line 88
      if (digit == -1) {
#line 89
        num = (ULONG )0;
      } else {
#line 91
        num = (num << 4) + (ULONG )digit;
      }
    }
#line 93
    if (digit == -1) {
      {
#line 94
      hsc_msg_project_corrupt___1(hp___0, (STRPTR )"hex digit expected");
      }
    }
#line 82
    if (digit != -1) {
#line 82
      if (! (ch != 32)) {
#line 82
        goto while_break;
      }
    } else {
#line 82
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (digit == -1) {
#line 99
    num = (ULONG )0;
  }
#line 101
  return (num);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static STRPTR read_string___1(HSCPRJ *hp___0 , BOOL len_format ) 
{ 
  STRPTR dest ;
  ULONG len ;
  STRPTR s___2 ;
  ULONG i ;
  int ch ;
  void *tmp ;

  {
#line 110
  dest = (STRPTR )((void *)0);
#line 113
  if (! len_format) {
    {
#line 115
    s___2 = infreadtoeol(hp___0->inpf);
#line 116
    inungetc(10, hp___0->inpf);
    }
#line 117
    return (s___2);
  }
  {
#line 120
  len = read_ulong___1(hp___0);
  }
#line 121
  if (len) {
    {
#line 123
    ch = 'x';
#line 126
    tmp = ugly_malloc_notracking(len + 1UL);
#line 126
    dest = (STRPTR )tmp;
#line 127
    *(dest + len) = (char )'\000';
#line 129
    i = (ULONG )0;
    }
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (i < len) {
#line 129
        if (! (ch != -1)) {
#line 129
          goto while_break;
        }
      } else {
#line 129
        goto while_break;
      }
      {
#line 130
      ch = infgetc(hp___0->inpf);
      }
#line 131
      if (ch != -1) {
#line 132
        *(dest + i) = (char )ch;
      } else {
        {
#line 134
        hsc_msg_project_corrupt___1(hp___0, (STRPTR )"string expected");
        }
      }
#line 129
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 136
    if (ch != -1) {
#line 137
      *(dest + len) = (char)0;
    } else {
#line 139
      if (dest) {
        {
#line 139
        free((void *)dest);
#line 139
        dest = (STRPTR )((void *)0);
        }
      }
#line 140
      dest = (STRPTR )((void *)0);
    }
  }
#line 143
  return (dest);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static CALLER *read_caller___1(HSCPRJ *hp___0 , BOOL v2format ) 
{ 
  CALLER *caller ;
  STRPTR callerid ;
  STRPTR tmp ;
  int ch ;
  int tmp___0 ;
  STRPTR fname ;
  STRPTR tmp___1 ;
  ULONG tmp___2 ;
  ULONG tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 150
  caller = (CALLER *)((void *)0);
#line 151
  tmp = infgetw(hp___0->inpf);
#line 151
  callerid = tmp;
  }
#line 153
  if (callerid) {
    {
#line 153
    tmp___5 = upstrcmp((CONSTRPTR )callerid, "FROM");
    }
#line 153
    if (tmp___5) {
#line 153
      goto _L;
    } else {
      {
#line 154
      tmp___0 = infgetc(hp___0->inpf);
#line 154
      ch = tmp___0;
      }
#line 156
      if (ch == 32) {
        {
#line 157
        tmp___1 = read_string___1(hp___0, v2format);
#line 157
        fname = tmp___1;
#line 158
        tmp___2 = read_ulong___1(hp___0);
#line 158
        tmp___3 = read_ulong___1(hp___0);
#line 158
        caller = new_caller(fname, tmp___3, tmp___2);
#line 159
        ugly_freestr(fname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c",
                     (ULONG )159);
#line 159
        fname = (STRPTR )((void *)0);
        }
      } else {
        {
#line 161
        hsc_msg_project_corrupt___1(hp___0, (STRPTR )"blank expected");
        }
      }
    }
  } else
  _L: /* CIL Label */ 
#line 162
  if (callerid) {
    {
#line 162
    tmp___4 = strcmp((char const   *)callerid, "\n");
    }
#line 162
    if (! tmp___4) {
      {
#line 164
      inungetcw(hp___0->inpf);
      }
    }
  }
#line 167
  return (caller);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static BOOL read_lf___1(HSCPRJ *hp___0 ) 
{ 
  int ch ;
  int tmp ;
  BOOL ok ;

  {
  {
#line 174
  tmp = infgetc(hp___0->inpf);
#line 174
  ch = tmp;
#line 175
  ok = (BOOL )1;
  }
#line 177
  if (ch != 10) {
    {
#line 178
    hsc_msg_project_corrupt___1(hp___0, (STRPTR )"linefeed expected");
#line 179
    ok = (BOOL )0;
    }
  }
#line 181
  return (ok);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static STRPTR read_command___1(HSCPRJ *hp___0 ) 
{ 
  STRPTR command___0 ;
  int tmp ;

  {
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    command___0 = infgetw(hp___0->inpf);
    }
#line 192
    if (command___0) {
      {
#line 192
      tmp = strcmp((char const   *)command___0, "\n");
      }
#line 192
      if (tmp) {
#line 192
        goto while_break;
      }
    } else {
#line 192
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (command___0) {
    {
#line 198
    infskip_ws(hp___0->inpf);
    }
  }
#line 203
  return (command___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hscprj/readprj.c"
static int read_header___1(HSCPRJ *hp___0 ) 
{ 
  STRARR fileid[1UL + sizeof("HSC_PROJECT")] ;
  BOOL ok ;
  STRPTR cmd ;
  ULONG version ;
  size_t i ;
  int ch ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ULONG tmp___3 ;

  {
#line 211
  ok = (BOOL )0;
#line 212
  cmd = (STRPTR )((void *)0);
#line 213
  version = (ULONG )0;
#line 217
  i = (size_t )0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 217
    tmp___0 = strlen("HSC_PROJECT");
    }
#line 217
    if (! (i < tmp___0)) {
#line 217
      goto while_break;
    }
    {
#line 218
    tmp = infgetc(hp___0->inpf);
#line 218
    ch = tmp;
#line 220
    fileid[i] = (STRARR )((UBYTE )ch);
#line 217
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  fileid[i] = (STRARR )'\000';
#line 227
  tmp___1 = strcmp((char const   *)(fileid), "HSC_PROJECT");
  }
#line 227
  if (tmp___1) {
    {
#line 231
    hsc_msg_project_corrupt___1(hp___0, (STRPTR )"wrong file-id");
    }
  } else {
    {
#line 229
    ok = read_lf___1(hp___0);
    }
  }
#line 233
  if (ok) {
    {
#line 235
    ok = (BOOL )0;
#line 238
    cmd = read_command___1(hp___0);
    }
#line 241
    if (cmd) {
      {
#line 241
      tmp___2 = strcmp((char const   *)cmd, "VERSION");
      }
#line 241
      if (tmp___2) {
        {
#line 251
        hsc_msg_project_corrupt___1(hp___0, (STRPTR )"unknown version");
        }
      } else {
        {
#line 242
        version = read_ulong___1(hp___0);
        }
#line 246
        if (version) {
#line 246
          if (version <= 3UL) {
            {
#line 247
            ok = read_lf___1(hp___0);
            }
          } else {
            {
#line 249
            hsc_msg_project_corrupt___1(hp___0, (STRPTR )"wrong version");
            }
          }
        } else {
          {
#line 249
          hsc_msg_project_corrupt___1(hp___0, (STRPTR )"wrong version");
          }
        }
      }
    } else {
      {
#line 251
      hsc_msg_project_corrupt___1(hp___0, (STRPTR )"unknown version");
      }
    }
  }
#line 253
  if (ok) {
#line 253
    tmp___3 = version;
  } else {
#line 253
    tmp___3 = 0UL;
  }
#line 253
  return ((int )tmp___3);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
static size_t fextidx___1(CONSTRPTR fn ) 
{ 
  size_t i ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 160
  tmp = strlen(fn);
#line 160
  i = tmp - 1UL;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (i) {
#line 161
      if ((int const   )*(fn + i) != 46) {
        {
#line 161
        tmp___0 = strchr("/", (int )*(fn + i));
        }
#line 161
        if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 161
          goto while_break;
        }
      } else {
#line 161
        goto while_break;
      }
    } else {
#line 161
      goto while_break;
    }
#line 163
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if ((int const   )*(fn + i) != 46) {
    {
#line 165
    i = strlen(fn);
    }
  }
#line 167
  return (i);
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
static size_t adjust_prefix_length___1(size_t prefix_length ) 
{ 


  {
#line 350
  if (prefix_length > 246UL) {
#line 352
    prefix_length = (size_t )246;
  }
#line 355
  return (prefix_length);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
static LONG fileidx___1  =    (LONG )0;
#line 361 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/fname.c"
static STRARR buf___2[288]  ;
#line 140 "./hsclib/attrib.h"
VOID prt_varlist(DLLIST *varlist , STRPTR title ) ;
#line 163
LONG get_varnum(HSCATTR *attr ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
static VOID prt_var(FILE *stream , APTR data ) 
{ 
  HSCATTR *var ;
  int varquote ;

  {
#line 47
  var = (HSCATTR *)data;
#line 49
  if ((unsigned long )((void *)0) != (unsigned long )var) {
#line 51
    varquote = var->quote;
#line 52
    if (varquote == 0) {
#line 53
      varquote = '.';
    }
    {
#line 56
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (type:%u,mci:%lu) ",
            var->name, (int )var->vartype, var->macro_id);
    }
#line 59
    if (var->text) {
      {
#line 60
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"cur:%c%s%c",
              var->quote, var->text, varquote);
      }
    } else {
      {
#line 63
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"<NULL>");
      }
    }
    {
#line 64
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" ");
    }
#line 66
    if (var->deftext) {
      {
#line 67
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"def:%c%s%c",
              var->quote, var->deftext, varquote);
      }
    } else {
      {
#line 70
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"<NULL>");
      }
    }
    {
#line 71
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 74
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"<NULL>\n");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
VOID prt_varlist(DLLIST *varlist , STRPTR title ) 
{ 


  {
  {
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*hsclib* %s\n",
          title);
#line 80
  fprintf_dllist(stderr, varlist, & prt_var);
  }
#line 81
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
VOID del_hscattr(APTR data ) 
{ 
  HSCATTR *var ;

  {
  {
#line 97
  var = (HSCATTR *)data;
#line 105
  ugly_freestr(var->name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c",
               (ULONG )105);
#line 105
  var->name = (STRPTR )((void *)0);
#line 106
  ugly_freestr(var->deftext, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c",
               (ULONG )106);
#line 106
  var->deftext = (STRPTR )((void *)0);
#line 107
  ugly_freestr(var->text, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c",
               (ULONG )107);
#line 107
  var->text = (STRPTR )((void *)0);
#line 108
  ugly_freestr(var->enumstr, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c",
               (ULONG )108);
#line 108
  var->enumstr = (STRPTR )((void *)0);
#line 110
  var->macro_id = (ULONG )0;
#line 111
  var->varflag = (ULONG )0;
#line 112
  var->vartype = (BYTE )0;
#line 113
  var->quote = -1;
  }
#line 115
  if (var) {
    {
#line 115
    free((void *)var);
#line 115
    var = (HSCATTR *)((void *)0);
    }
  }
#line 117
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
HSCATTR *new_hscattr(CONSTRPTR newname ) 
{ 
  HSCATTR *newvar ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 126
  tmp = ugly_malloc_notracking(sizeof(HSCATTR ));
#line 126
  newvar = (HSCATTR *)tmp;
  }
#line 132
  if (newvar) {
    {
#line 135
    newvar->vartype = (BYTE )0;
#line 136
    newvar->name = ugly_strclone(newname, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c",
                                 (ULONG )136);
#line 137
    newvar->deftext = (STRPTR )((void *)0);
#line 138
    newvar->text = (STRPTR )((void *)0);
#line 139
    newvar->enumstr = (STRPTR )((void *)0);
#line 140
    newvar->macro_id = (ULONG )0;
#line 141
    tmp___0 = strlen("HSC.");
#line 141
    tmp___1 = upstrncmp(newname, "HSC.", tmp___0);
    }
#line 141
    if (tmp___1) {
#line 142
      newvar->varflag = (ULONG )0;
    } else {
#line 144
      newvar->varflag = (ULONG )(1 << 28);
    }
#line 145
    newvar->quote = 0;
  }
#line 148
  if (! newvar->name) {
    {
#line 150
    del_hscattr((APTR )newvar);
#line 151
    newvar = (HSCATTR *)((void *)0);
    }
  }
#line 154
  return (newvar);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
HSCATTR *cpy_hscattr(HSCATTR *oldvar ) 
{ 
  HSCATTR *newvar ;
  HSCATTR *tmp ;

  {
  {
#line 164
  tmp = new_hscattr((CONSTRPTR )oldvar->name);
#line 164
  newvar = tmp;
  }
#line 166
  if (newvar) {
#line 168
    newvar->vartype = oldvar->vartype;
#line 169
    if (oldvar->deftext) {
      {
#line 170
      newvar->deftext = ugly_strclone((CONSTRPTR )oldvar->deftext, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c",
                                      (ULONG )170);
      }
    }
#line 171
    if (oldvar->text) {
      {
#line 172
      newvar->text = ugly_strclone((CONSTRPTR )oldvar->text, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c",
                                   (ULONG )172);
      }
    }
#line 173
    if (oldvar->enumstr) {
      {
#line 174
      newvar->enumstr = ugly_strclone((CONSTRPTR )oldvar->enumstr, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c",
                                      (ULONG )174);
      }
    }
#line 175
    newvar->macro_id = oldvar->macro_id;
#line 176
    newvar->varflag = oldvar->varflag;
#line 177
    newvar->quote = oldvar->quote;
  }
#line 180
  if (! newvar->name) {
    {
#line 182
    del_hscattr((APTR )newvar);
#line 183
    newvar = (HSCATTR *)((void *)0);
    }
  }
#line 186
  return (newvar);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
HSCATTR *app_var(DLLIST *varlist , STRPTR newname ) 
{ 
  HSCATTR *var ;
  HSCATTR *tmp ;
  BOOL ok ;
  DLNODE *tmp___0 ;

  {
  {
#line 197
  tmp = new_hscattr((CONSTRPTR )newname);
#line 197
  var = tmp;
#line 198
  ok = (BOOL )0;
  }
#line 200
  if (var) {
    {
#line 201
    tmp___0 = add_dlnode(varlist, (APTR )var);
#line 201
    ok = (BOOL )((unsigned long )tmp___0 != (unsigned long )((void *)0));
    }
  }
#line 203
  if (! ok) {
    {
#line 204
    del_hscattr((APTR )var);
#line 205
    var = (HSCATTR *)((void *)0);
    }
  }
#line 208
  return (var);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
static int cmp_varname(APTR const   cmpstr , APTR const   vardata ) 
{ 
  STRPTR varstr ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 223
  varstr = (STRPTR )((void *)0);
#line 225
  if (vardata) {
#line 225
    varstr = ((HSCATTR *)vardata)->name;
  }
#line 226
  if (varstr) {
    {
#line 227
    tmp___1 = upstrcmp((CONSTRPTR )((STRPTR )cmpstr), (CONSTRPTR )((HSCATTR *)vardata)->name);
    }
#line 227
    if (tmp___1) {
#line 227
      tmp___0 = 0;
    } else {
#line 227
      tmp___0 = -1;
    }
#line 227
    return (tmp___0);
  }
#line 228
  return (0);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
DLNODE *find_attrnode(DLLIST *varlist , STRPTR name ) 
{ 
  DLNODE *tmp ;

  {
  {
#line 236
  tmp = find_dlnode(varlist->first, (APTR )name, (int (*)(APTR cmp_data , APTR list_data ))(& cmp_varname));
  }
#line 236
  return (tmp);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
HSCATTR *find_varname(DLLIST *varlist , STRPTR name ) 
{ 
  DLNODE *nd ;
  DLNODE *tmp ;

  {
  {
#line 243
  tmp = find_dlnode(varlist->first, (APTR )name, (int (*)(APTR cmp_data , APTR list_data ))(& cmp_varname));
#line 243
  nd = tmp;
  }
#line 245
  if (nd) {
#line 245
    return ((HSCATTR *)nd->data);
  }
#line 246
  return ((HSCATTR *)((void *)0));
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
STRPTR set_vartext(HSCATTR *var , STRPTR newtext ) 
{ 


  {
#line 267
  if (! var) {
    {
#line 267
    display_panic_message((char *)"NULL attribute detected", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c",
                          (size_t )267);
    }
  }
#line 269
  if ((unsigned long )newtext != (unsigned long )var->text) {
    {
#line 271
    ugly_freestr(var->text, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c",
                 (ULONG )271);
#line 271
    var->text = (STRPTR )((void *)0);
    }
#line 272
    if (newtext) {
      {
#line 273
      var->text = ugly_strclone((CONSTRPTR )newtext, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c",
                                (ULONG )273);
      }
    } else {
#line 275
      var->text = (STRPTR )((void *)0);
    }
  }
#line 277
  return (var->text);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
BOOL set_varbool(HSCATTR *attr , BOOL value ) 
{ 


  {
#line 292
  if (value) {
    {
#line 293
    set_vartext(attr, attr->name);
    }
  } else {
    {
#line 295
    set_vartext(attr, (STRPTR )"");
    }
  }
#line 297
  return (value);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
BOOL clr_vartext(HSCATTR *var ) 
{ 
  BOOL ok ;
  STRPTR tmp ;

  {
#line 310
  ok = (BOOL )1;
#line 312
  if (var->deftext) {
    {
#line 314
    tmp = set_vartext(var, var->deftext);
    }
#line 314
    if (! tmp) {
#line 315
      ok = (BOOL )0;
    }
  } else {
    {
#line 319
    ugly_freestr(var->text, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c",
                 (ULONG )319);
#line 319
    var->text = (STRPTR )((void *)0);
#line 320
    var->text = (STRPTR )((void *)0);
    }
  }
#line 323
  return (ok);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
VOID clr_attrdef(HSCATTR *attr ) 
{ 


  {
  {
#line 335
  ugly_freestr(attr->deftext, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c",
               (ULONG )335);
#line 335
  attr->deftext = (STRPTR )((void *)0);
#line 336
  attr->deftext = (STRPTR )((void *)0);
  }
#line 337
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
BOOL clr_varlist(DLLIST *varlist ) 
{ 
  DLNODE *nd ;
  BOOL ok ;
  BOOL tmp ;

  {
#line 348
  nd = varlist->first;
#line 349
  ok = (BOOL )1;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (nd) {
#line 351
      if (! ok) {
#line 351
        goto while_break;
      }
    } else {
#line 351
      goto while_break;
    }
    {
#line 353
    tmp = clr_vartext((HSCATTR *)nd->data);
#line 353
    ok = (BOOL )((int )ok & (int )tmp);
#line 354
    nd = nd->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return (ok);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
VOID clr_varlist_bool(DLLIST *varlist ) 
{ 
  DLNODE *nd ;
  BOOL ok ;
  HSCATTR *attr ;

  {
#line 370
  nd = varlist->first;
#line 371
  ok = (BOOL )1;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (nd) {
#line 373
      if (! ok) {
#line 373
        goto while_break;
      }
    } else {
#line 373
      goto while_break;
    }
#line 375
    attr = (HSCATTR *)nd->data;
#line 377
    if ((int )attr->vartype == 3) {
#line 377
      if (! attr->text) {
        {
#line 378
        set_varbool(attr, (BOOL )0);
        }
      }
    }
#line 380
    nd = nd->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
STRPTR get_vartext_byname(DLLIST *varlist , STRPTR name ) 
{ 
  HSCATTR *var ;
  HSCATTR *tmp ;
  STRPTR vartext ;

  {
  {
#line 391
  tmp = find_varname(varlist, name);
#line 391
  var = tmp;
#line 392
  vartext = (STRPTR )((void *)0);
  }
#line 394
  if (var) {
#line 395
    vartext = var->text;
  }
#line 397
  return (vartext);
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
STRPTR get_vartext(HSCATTR *var ) 
{ 
  STRPTR tmp ;

  {
#line 406
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 406
    tmp = (STRPTR )((void *)0);
  } else {
#line 406
    tmp = var->text;
  }
#line 406
  return (tmp);
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
BOOL get_varbool(HSCATTR *attr ) 
{ 
  BOOL set ;

  {
#line 414
  set = (BOOL )0;
#line 415
  if (attr) {
#line 415
    if (*(attr->text + 0)) {
#line 416
      set = (BOOL )1;
    }
  }
#line 418
  return (set);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
BOOL get_varbool_byname(DLLIST *varlist , STRPTR name ) 
{ 
  HSCATTR *var ;
  HSCATTR *tmp ;
  BOOL tmp___0 ;

  {
  {
#line 426
  tmp = find_varname(varlist, name);
#line 426
  var = tmp;
#line 428
  tmp___0 = get_varbool(var);
  }
#line 428
  return (tmp___0);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
LONG get_varnum(HSCATTR *attr ) 
{ 
  LONG num ;

  {
#line 436
  num = (LONG )0;
#line 437
  if (attr) {
#line 437
    if (attr->text) {
#line 437
      if (*(attr->text + 0)) {
        {
#line 438
        str2long(attr->text, & num);
        }
      }
    }
  }
#line 440
  return (num);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
LONG get_varnum_byname(DLLIST *varlist , STRPTR name ) 
{ 
  HSCATTR *var ;
  HSCATTR *tmp ;
  LONG tmp___0 ;

  {
  {
#line 448
  tmp = find_varname(varlist, name);
#line 448
  var = tmp;
#line 450
  tmp___0 = get_varnum(var);
  }
#line 450
  return (tmp___0);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/attrib.c"
STRPTR get_vardeftext(HSCATTR *var ) 
{ 
  STRPTR deftext ;

  {
#line 459
  deftext = (STRPTR )((void *)0);
#line 461
  if (var) {
#line 462
    deftext = var->deftext;
  }
#line 464
  return (deftext);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/unikot.c"
static utf8_t const   first_char_mask___1[5]  = {      (utf8_t const   )192,      (utf8_t const   )224,      (utf8_t const   )240,      (utf8_t const   )248, 
        (utf8_t const   )252};
#line 79 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UGLYMEM *first___1  =    (UGLYMEM *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UBYTE deadbeef___1[4]  = {      (UBYTE )222,      (UBYTE )173,      (UBYTE )190,      (UBYTE )239};
#line 83 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UBYTE deadfood___1[4]  = {      (UBYTE )222,      (UBYTE )173,      (UBYTE )240,      (UBYTE )13};
#line 86 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UBYTE ugly_fillchar___1  =    (UBYTE )129;
#line 88 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_umalloc_count___1  =    (ULONG )0;
#line 89 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_ufree_count___1  =    (ULONG )0;
#line 90 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_umalloc_count_fail___1  =    (ULONG )0;
#line 91 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_ufree_count_fail___1  =    (ULONG )0;
#line 92 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_maxmem_usage___1  =    (ULONG )0;
#line 93 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_curmem_usage___1  =    (ULONG )0;
#line 94 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_real_maxmem_usage___1  =    (ULONG )0;
#line 95 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_real_curmem_usage___1  =    (ULONG )0;
#line 96 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_maxnod_usage___1  =    (ULONG )0;
#line 97 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static ULONG ugly_curnod_usage___1  =    (ULONG )0;
#line 101
static BOOL ugly_walldamaged___1(UGLYMEM *umem ) ;
#line 123 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UGLYMEM *find_umem___1(void *mem ) 
{ 
  UGLYMEM *nxtum ;
  UGLYMEM *found ;

  {
#line 125
  nxtum = first___1;
#line 126
  found = (UGLYMEM *)((void *)0);
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (nxtum) {
#line 128
      if (! (! found)) {
#line 128
        goto while_break;
      }
    } else {
#line 128
      goto while_break;
    }
#line 130
    if ((unsigned long )nxtum->ptr == (unsigned long )mem) {
#line 132
      found = nxtum;
    }
#line 134
    nxtum = nxtum->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return (found);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UGLYMEM *find_prev___1(UGLYMEM *umem ) 
{ 
  UGLYMEM *prev ;
  UGLYMEM *pprev ;
  BOOL found ;

  {
#line 152
  prev = first___1;
#line 153
  pprev = (UGLYMEM *)((void *)0);
#line 154
  found = (BOOL )0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (prev) {
#line 156
      if (! (! found)) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 158
    found = (BOOL )((unsigned long )prev == (unsigned long )umem);
#line 159
    if (! found) {
#line 161
      pprev = prev;
#line 162
      prev = prev->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return (pprev);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void fill_mem4___1(void *mem , size_t size , UBYTE *value ) 
{ 
  size_t i ;

  {
#line 178
  i = (size_t )0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < size)) {
#line 178
      goto while_break;
    }
#line 180
    *((UBYTE *)mem + i) = *(value + i % 4UL);
#line 178
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void fill_mem___1(void *mem , size_t size , UBYTE value ) 
{ 
  size_t i ;

  {
#line 188
  i = (size_t )0;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (i < size)) {
#line 188
      goto while_break;
    }
#line 190
    *((UBYTE *)mem + i) = value;
#line 188
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void del_uglymem___1(UGLYMEM *umem ) 
{ 
  UGLYMEM *prev ;
  UGLYMEM *tmp ;
  BOOL tmp___0 ;

  {
  {
#line 201
  tmp = find_prev___1(umem);
#line 201
  prev = tmp;
  }
#line 204
  if (prev) {
#line 205
    prev->next = umem->next;
  } else {
#line 207
    first___1 = umem->next;
  }
  {
#line 210
  tmp___0 = ugly_walldamaged___1(umem);
  }
#line 210
  if (! tmp___0) {
    {
#line 216
    fill_mem4___1((void *)umem->lower, umem->size + 32UL, (UBYTE *)(deadbeef___1));
#line 217
    free((void *)umem->lower);
    }
  }
  {
#line 221
  umem->lower = (UBYTE *)((void *)0);
#line 222
  umem->upper = (UBYTE *)((void *)0);
#line 223
  umem->size = (size_t )0;
#line 224
  umem->file = (STRPTR )((void *)0);
#line 225
  umem->line = (ULONG )0;
#line 226
  free((void *)umem);
  }
#line 227
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static UGLYMEM *new_uglymem___1(size_t memsize , STRPTR memfile , ULONG memline ) 
{ 
  UGLYMEM *newmem ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 236
  tmp = malloc(sizeof(UGLYMEM ));
#line 236
  newmem = (UGLYMEM *)tmp;
  }
#line 238
  if (newmem) {
    {
#line 240
    tmp___0 = ugly_malloc_notracking(memsize + 32UL);
#line 240
    newmem->lower = (UBYTE *)tmp___0;
    }
#line 242
    if (newmem->lower) {
      {
#line 245
      newmem->ptr = (void *)(newmem->lower + 16);
#line 246
      newmem->upper = (newmem->lower + 16) + memsize;
#line 249
      newmem->next = first___1;
#line 250
      first___1 = newmem;
#line 253
      newmem->size = memsize;
#line 254
      newmem->file = memfile;
#line 255
      newmem->line = memline;
#line 256
      newmem->fillchar = ugly_fillchar___1;
#line 259
      fill_mem4___1(newmem->ptr, memsize, (UBYTE *)(deadfood___1));
#line 262
      fill_mem___1((void *)newmem->lower, (size_t )16, ugly_fillchar___1);
#line 263
      fill_mem___1((void *)newmem->upper, (size_t )16, ugly_fillchar___1);
      }
#line 266
      if ((int )ugly_fillchar___1 == 255) {
#line 268
        ugly_fillchar___1 = (UBYTE )129;
      } else {
#line 272
        ugly_fillchar___1 = (UBYTE )((int )ugly_fillchar___1 + 1);
      }
    } else {
      {
#line 276
      free((void *)newmem);
      }
    }
  }
#line 278
  return (newmem);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void uglymem_message___1(STRPTR msg ) 
{ 


  {
  {
#line 283
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
  }
#line 284
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void ugly_memdump___1(void *ptr , size_t size ) 
{ 
  STRPTR data ;
  size_t i ;

  {
#line 288
  data = (STRPTR )ptr;
#line 291
  if (size > 16UL) {
#line 293
    size = (size_t )16;
  }
  {
#line 296
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %p:",
          ptr);
  }
#line 297
  if (data) {
#line 302
    i = (size_t )0;
    {
#line 302
    while (1) {
      while_continue: /* CIL Label */ ;
#line 302
      if (! (i < size)) {
#line 302
        goto while_break;
      }
#line 304
      if (! (i % 4UL)) {
        {
#line 306
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
        }
      }
      {
#line 308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x",
              (int )*(data + i));
#line 302
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 313
      if (! (i < 16UL)) {
#line 313
        goto while_break___0;
      }
#line 315
      if (! (i % 4UL)) {
        {
#line 317
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
        }
      }
      {
#line 319
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  ");
#line 320
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 323
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  \"");
#line 325
    i = (size_t )0;
    }
    {
#line 325
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 325
      if (! (i < size)) {
#line 325
        goto while_break___1;
      }
#line 327
      if ((int )*(data + i) < 32) {
        {
#line 329
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
        }
      } else {
        {
#line 333
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c",
                (int )*(data + i));
        }
      }
#line 325
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 336
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"\n");
    }
  } else {
    {
#line 340
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL\n");
    }
  }
#line 342
  return;
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void uglymem_meminfo___1(void *ptr , STRPTR file , ULONG line ) 
{ 


  {
  {
#line 346
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %p: from \"%s\" (%lu)\n",
          ptr, file, line);
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static void umem_info___1(UGLYMEM *umem ) 
{ 


  {
  {
#line 351
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %p: %lu (0x%lx) bytes from \"%s\" (%lu)\n",
          umem->ptr, umem->size, umem->size, umem->file, umem->line);
  }
#line 354
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static STRARR strbuf___1[30]  ;
#line 368 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static STRPTR str_ubyte___1(UBYTE val ) 
{ 
  UBYTE ch ;

  {
#line 371
  ch = val;
#line 373
  if ((int )ch < 32) {
#line 374
    ch = (UBYTE )'.';
  }
  {
#line 376
  sprintf((char */* __restrict  */)(strbuf___1), (char const   */* __restrict  */)"(0x%02x/#%d/`%c\')",
          (int )val, (int )val, (int )ch);
  }
#line 378
  return (strbuf___1);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/umemory.c"
static BOOL ugly_walldamaged___1(UGLYMEM *umem ) 
{ 
  size_t i ;
  BOOL damaged ;
  BOOL lower_damaged ;
  BOOL upper_damaged ;
  int tmp ;
  STRPTR wall ;
  UBYTE value ;
  STRPTR tmp___0 ;

  {
#line 389
  i = (size_t )0;
#line 390
  damaged = (BOOL )0;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! damaged) {
#line 392
      if (! (i < 16UL)) {
#line 392
        goto while_break;
      }
    } else {
#line 392
      goto while_break;
    }
#line 394
    lower_damaged = (BOOL )((int )*(umem->lower + i) != (int )umem->fillchar);
#line 395
    upper_damaged = (BOOL )((int )*(umem->upper + i) != (int )umem->fillchar);
#line 397
    if (lower_damaged) {
#line 397
      tmp = 1;
    } else
#line 397
    if (upper_damaged) {
#line 397
      tmp = 1;
    } else {
#line 397
      tmp = 0;
    }
#line 397
    damaged = (BOOL )tmp;
#line 398
    if (damaged) {
#line 403
      if (lower_damaged) {
#line 405
        wall = (STRPTR )"LOWER";
#line 406
        value = *(umem->lower + i);
      } else {
#line 410
        wall = (STRPTR )"UPPER";
#line 411
        value = *(umem->upper + i);
      }
      {
#line 414
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** MEMORY WALL DAMAGED!!!\n");
#line 415
      tmp___0 = str_ubyte___1(value);
#line 415
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** %s wall, byte#%lu is %s instead of 0x%02x\n",
              wall, i, tmp___0, (int )umem->fillchar);
#line 417
      umem_info___1(umem);
#line 418
      ugly_memdump___1(umem->ptr, umem->size);
#line 419
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  * lower wall:\n");
#line 420
      ugly_memdump___1((void *)umem->lower, (size_t )16);
#line 421
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  * upper wall:\n");
#line 422
      ugly_memdump___1((void *)umem->upper, (size_t )16);
      }
    } else {
#line 427
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  return (damaged);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/css.c"
static int cmp_stylename(APTR const   cmpstr , APTR const   vardata ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 36
  tmp___1 = upstrcmp((CONSTRPTR )((STRPTR )cmpstr), (CONSTRPTR )((HSCSTYLE *)vardata)->name);
  }
#line 36
  if (tmp___1) {
#line 36
    tmp___0 = 0;
  } else {
#line 36
    tmp___0 = -1;
  }
#line 36
  return (tmp___0);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/css.c"
static HSCSTYLE *find_stylename(DLLIST *stylelist , CONSTRPTR name ) 
{ 
  DLNODE *nd ;
  DLNODE *tmp ;

  {
  {
#line 43
  tmp = find_dlnode(stylelist->first, (APTR )name, (int (*)(APTR cmp_data , APTR list_data ))(& cmp_stylename));
#line 43
  nd = tmp;
  }
#line 45
  if (nd) {
#line 45
    return ((HSCSTYLE *)nd->data);
  }
#line 46
  return ((HSCSTYLE *)((void *)0));
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/css.c"
HSCSTYLE *new_styleattr(CONSTRPTR name , CONSTRPTR value ) 
{ 
  HSCSTYLE *newvar ;
  void *tmp ;

  {
  {
#line 56
  tmp = ugly_malloc_notracking(sizeof(HSCSTYLE ));
#line 56
  newvar = (HSCSTYLE *)tmp;
  }
#line 62
  if (newvar) {
    {
#line 63
    newvar->name = ugly_strclone(name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/css.c",
                                 (ULONG )63);
#line 64
    newvar->value = ugly_strclone(value, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/css.c",
                                  (ULONG )64);
    }
  }
#line 66
  return (newvar);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/css.c"
VOID del_styleattr(APTR data ) 
{ 


  {
  {
#line 80
  ugly_freestr(((HSCSTYLE *)data)->name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/css.c",
               (ULONG )80);
#line 80
  ((HSCSTYLE *)data)->name = (STRPTR )((void *)0);
#line 81
  ugly_freestr(((HSCSTYLE *)data)->value, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/css.c",
               (ULONG )81);
#line 81
  ((HSCSTYLE *)data)->value = (STRPTR )((void *)0);
  }
#line 82
  if (data) {
    {
#line 82
    free(data);
#line 82
    data = (void *)0;
    }
  }
#line 83
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/css.c"
BOOL add_styleattr(HSCPRC *hp___0 , CONSTRPTR property , CONSTRPTR value ) 
{ 
  HSCSTYLE *styledef ;
  LONG tmp ;

  {
  {
#line 96
  styledef = find_stylename(hp___0->tag_styles, property);
  }
#line 96
  if ((unsigned long )((void *)0) != (unsigned long )styledef) {
    {
#line 97
    hsc_message(hp___0, (HSCMSG_ID )12379, "CSS property %q redefined, previous value was %q",
                property, styledef->value);
#line 100
    ugly_freestr(styledef->value, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/css.c",
                 (ULONG )100);
#line 100
    styledef->value = (STRPTR )((void *)0);
#line 101
    styledef->value = ugly_strclone(value, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/css.c",
                                    (ULONG )101);
    }
#line 102
    return ((BOOL )0);
  } else {
#line 105
    if (hp___0->validate_css) {
      {
#line 106
      styledef = find_stylename(hp___0->defstyle, property);
      }
#line 106
      if ((unsigned long )((void *)0) == (unsigned long )styledef) {
        {
#line 108
        hsc_message(hp___0, (HSCMSG_ID )12378, "unknown CSS property %q", property);
        }
      } else
#line 112
      if ((unsigned long )((void *)0) != (unsigned long )styledef->value) {
        {
#line 112
        tmp = strenum(value, (CONSTRPTR )styledef->value, (char )'|', (BYTE )0);
        }
#line 112
        if (! tmp) {
          {
#line 116
          hsc_message(hp___0, (HSCMSG_ID )12378, "value %q invalid for CSS property %q",
                      value, property);
          }
        }
      }
    }
    {
#line 122
    styledef = new_styleattr(property, value);
#line 123
    app_dlnode(hp___0->tag_styles, (APTR )styledef);
    }
#line 124
    return ((BOOL )0);
  }
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/css.c"
BOOL add_width_height_attrs(HSCPRC *hp___0 , ULONG width , ULONG height ) 
{ 
  char buf___3[13] ;
  BOOL rw ;
  BOOL rh ;
  int tmp ;

  {
  {
#line 138
  sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%ldpx",
          width);
#line 139
  rw = add_styleattr(hp___0, "width", (CONSTRPTR )(buf___3));
#line 140
  sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%ldpx",
          height);
#line 141
  rh = add_styleattr(hp___0, "height", (CONSTRPTR )(buf___3));
  }
#line 142
  if (rw) {
#line 142
    if (rh) {
#line 142
      tmp = 1;
    } else {
#line 142
      tmp = 0;
    }
  } else {
#line 142
    tmp = 0;
  }
#line 142
  return ((BOOL )tmp);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c"
static BOOL include_macro(HSCPRC *hp___0 , HSCTAG *macro , STRPTR macro_text , STRPTR filename ,
                          INFILEPOS *fpos ) 
{ 
  BOOL ok ;
  ULONG mci ;
  LONG tmp ;

  {
  {
#line 51
  ok = (BOOL )1;
#line 52
  tmp = get_mci(hp___0);
#line 52
  mci = (ULONG )tmp;
#line 55
  ok = copy_local_varlist(hp___0->defattr, macro->attr, mci);
  }
#line 58
  if (ok) {
    {
#line 61
    ok = hsc_base_include_string(hp___0, filename, macro_text, (ULONG )(1 << 2), fpos);
    }
  }
#line 66
  if (mci != 4294967295UL) {
    {
#line 69
    remove_local_varlist(hp___0->defattr, mci);
    }
  }
  {
#line 71
  unget_mci(hp___0);
  }
#line 73
  return (ok);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c"
static VOID dbg_print_macro(HSCPRC *hp___0 , HSCTAG *macro , BOOL open_mac , STRPTR prefix ) 
{ 


  {
#line 107
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c"
static BOOL handle_macro(HSCPRC *hp___0 , HSCTAG *macro , BOOL open_mac ) 
{ 
  BOOL ok ;
  EXPSTR *text ;
  INFILEPOS *fpos ;

  {
  {
#line 111
  ok = (BOOL )1;
#line 112
  text = (EXPSTR *)((void *)0);
#line 113
  fpos = (INFILEPOS *)((void *)0);
#line 116
  dbg_print_macro(hp___0, macro, open_mac, (STRPTR )"BEGIN");
  }
#line 119
  if (open_mac) {
#line 121
    text = macro->op_text;
#line 122
    fpos = macro->start_fpos;
  } else {
#line 126
    text = macro->cl_text;
#line 127
    fpos = macro->end_fpos;
  }
  {
#line 131
  ok = include_macro(hp___0, macro, text->es_data, (STRPTR )"::s::macro", fpos);
#line 135
  dbg_print_macro(hp___0, macro, open_mac, (STRPTR )"END");
  }
#line 137
  return ((BOOL )0);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c"
static BOOL handle_op_macro(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL tmp ;

  {
  {
#line 147
  tmp = handle_macro(hp___0, tag, (BOOL )1);
  }
#line 147
  return (tmp);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c"
static BOOL handle_cl_macro(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL tmp ;

  {
  {
#line 157
  tmp = handle_macro(hp___0, tag, (BOOL )0);
  }
#line 157
  return (tmp);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c"
static BOOL handle_content_macro(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  EXPSTR *macro_content ;
  EXPSTR *tmp ;
  HSCATTR *macro_content_attr ;
  HSCATTR *tmp___0 ;
  HSCTAG *end_macro ;
  STRPTR old_content ;
  INFILEPOS *start_content_fpos ;
  INFILEPOS *tmp___1 ;
  STRPTR old ;
  STRPTR tmp___2 ;

  {
  {
#line 182
  tmp = ugly_init_estr((size_t )2048);
#line 182
  macro_content = tmp;
#line 184
  tmp___0 = find_varname(hp___0->defattr, (STRPTR )"HSC.CONTENT");
#line 184
  macro_content_attr = tmp___0;
#line 185
  end_macro = (HSCTAG *)((void *)0);
#line 186
  old_content = (STRPTR )((void *)0);
#line 189
  tmp___1 = new_infilepos(hp___0->inpf);
#line 189
  start_content_fpos = tmp___1;
  }
#line 193
  if (! macro_content_attr) {
    {
#line 194
    display_panic_message((char *)"no content attribute", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c",
                          (size_t )194);
    }
  }
  {
#line 198
  skip_until_tag(hp___0, macro_content, (EXPSTR *)((void *)0), (STRPTR )((void *)0),
                 tag->name, (ULONG )(1 << 1));
#line 203
  tmp___2 = get_vartext(macro_content_attr);
#line 203
  old = tmp___2;
  }
#line 204
  if (old) {
    {
#line 205
    old_content = ugly_strclone((CONSTRPTR )old, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c",
                                (ULONG )205);
    }
  }
  {
#line 209
  set_vartext(macro_content_attr, macro_content->es_data);
#line 212
  add_strnode(hp___0->content_stack, macro_content->es_data);
#line 221
  end_macro = append_end_tag(hp___0, tag);
#line 224
  end_macro->end_fpos = start_content_fpos;
#line 227
  include_macro(hp___0, tag, (tag->op_text)->es_data, (STRPTR )"::s::content-macro",
                tag->start_fpos);
#line 231
  end_macro->end_fpos = (INFILEPOS *)((void *)0);
#line 232
  remove_end_tag(hp___0, tag);
#line 235
  set_vartext(macro_content_attr, old_content);
#line 238
  del_dlnode(hp___0->content_stack, (hp___0->content_stack)->first);
#line 241
  ugly_freestr(old_content, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c",
               (ULONG )241);
#line 241
  old_content = (STRPTR )((void *)0);
#line 242
  del_estr(macro_content);
#line 243
  del_infilepos(start_content_fpos);
  }
#line 247
  return ((BOOL )0);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c"
static VOID hsc_msg_no_content(HSCPRC *hp___0 ) 
{ 


  {
  {
#line 257
  hsc_message(hp___0, (HSCMSG_ID )61468, "no content within current context");
  }
#line 259
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c"
BOOL handle_hsc_content(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  HSCATTR *content_attr ;
  HSCATTR *tmp ;
  HSCTAG *macro ;
  HSCTAG *tmp___0 ;
  INFILEPOS *fpos ;
  INFILEPOS *tmp___1 ;
  INFILEPOS *start_content_fpos ;
  DLNODE *first_content_text_node ;
  STRPTR content ;
  APTR tmp___2 ;
  STRPTR old_content ;
  STRPTR tmp___3 ;
  STRPTR tmp___4 ;
  DLLIST *old_attribs ;
  DLLIST *tmp___5 ;
  ULONG scope_id ;
  LONG tmp___6 ;

  {
  {
#line 262
  tmp = find_varname(hp___0->defattr, (STRPTR )"HSC.CONTENT");
#line 262
  content_attr = tmp;
#line 263
  tmp___0 = find_end_container_macro(hp___0);
#line 263
  macro = tmp___0;
#line 266
  tmp___1 = new_infilepos(hp___0->inpf);
#line 266
  fpos = tmp___1;
  }
#line 268
  if (! macro) {
    {
#line 270
    hsc_msg_no_content(hp___0);
    }
  } else
#line 271
  if (content_attr) {
#line 273
    start_content_fpos = macro->end_fpos;
#line 276
    first_content_text_node = (hp___0->content_stack)->first;
#line 278
    if (first_content_text_node) {
      {
#line 280
      tmp___2 = detach_dlnode(hp___0->content_stack, first_content_text_node);
#line 280
      content = (STRPTR )tmp___2;
#line 282
      tmp___3 = get_vartext(content_attr);
#line 282
      tmp___4 = ugly_strclone((CONSTRPTR )tmp___3, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c",
                              (ULONG )282);
#line 282
      old_content = tmp___4;
#line 283
      tmp___5 = init_dllist(& del_hscattr);
#line 283
      old_attribs = tmp___5;
#line 284
      tmp___6 = get_current_mci(hp___0);
#line 284
      scope_id = (ULONG )tmp___6;
#line 289
      set_vartext(content_attr, content);
#line 293
      move_local_varlist(old_attribs, hp___0->defattr, scope_id);
#line 299
      unget_mci(hp___0);
#line 303
      hsc_base_include_string(hp___0, (STRPTR )"::s::macro-content", content, (ULONG )((1 << 5) | (1 << 2)),
                              start_content_fpos);
#line 310
      add_dlnode(hp___0->content_stack, (APTR )content);
#line 314
      move_local_varlist(hp___0->defattr, old_attribs, scope_id);
#line 315
      get_mci(hp___0);
#line 321
      set_vartext(content_attr, old_content);
#line 324
      del_dllist(old_attribs);
#line 325
      ugly_freestr(old_content, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c",
                   (ULONG )325);
#line 325
      old_content = (STRPTR )((void *)0);
      }
    } else {
      {
#line 328
      hsc_msg_no_content(hp___0);
      }
    }
  } else {
    {
#line 331
    display_panic_message((char *)"no content attribute", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c",
                          (size_t )331);
    }
  }
  {
#line 335
  del_infilepos(fpos);
  }
#line 337
  return ((BOOL )0);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c"
static BOOL read_macro_text(HSCPRC *hp___0 , HSCTAG *macro , BOOL is_start_macro ) 
{ 
  BOOL ok ;
  EXPSTR *macstr ;
  STRPTR ms ;
  size_t len ;
  size_t tmp ;
  size_t oldlen ;

  {
  {
#line 351
  ok = (BOOL )0;
#line 352
  macstr = (EXPSTR *)((void *)0);
#line 355
  skip_next_lf(hp___0);
  }
#line 359
  if (is_start_macro) {
    {
#line 361
    macro->op_text = ugly_init_estr((size_t )1024);
#line 362
    macstr = macro->op_text;
#line 363
    macro->start_fpos = new_winfilepos(hp___0->inpf);
    }
  } else {
    {
#line 367
    macro->cl_text = ugly_init_estr((size_t )1024);
#line 368
    macstr = macro->cl_text;
#line 369
    macro->end_fpos = new_winfilepos(hp___0->inpf);
    }
  }
  {
#line 373
  ok = skip_until_tag(hp___0, macstr, (EXPSTR *)((void *)0), (STRPTR )((void *)0),
                      (STRPTR )"$macro", (ULONG )(1 << 1));
  }
#line 377
  if (ok) {
    {
#line 379
    ms = macstr->es_data;
#line 380
    tmp = strlen((char const   *)ms);
#line 380
    len = tmp;
#line 381
    oldlen = len;
    }
#line 386
    if (len) {
#line 386
      if ((int )*(ms + (len - 1UL)) == 10) {
        {
#line 388
        *(ms + (len - 1UL)) = (char )'\000';
#line 389
        len = strlen((char const   *)ms);
        }
      }
    }
#line 392
    if (len) {
#line 392
      if ((int )*(ms + (len - 1UL)) == 13) {
        {
#line 394
        *(ms + (len - 1UL)) = (char )'\000';
#line 395
        len = strlen((char const   *)ms);
        }
      }
    }
  }
#line 406
  return (ok);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/tag_macro.c"
BOOL handle_hsc_macro(HSCPRC *hp___0 , HSCTAG *tag ) 
{ 
  BOOL ok ;
  BOOL is_start_macro ;
  BOOL tmp ;
  int tmp___0 ;

  {
  {
#line 422
  ok = (BOOL )0;
#line 423
  is_start_macro = (BOOL )0;
#line 426
  tag = def_tag_name(hp___0, & is_start_macro);
  }
#line 427
  if (tag) {
#line 429
    tag->option |= (unsigned long )(1 << 10);
  }
#line 433
  if (tag) {
    {
#line 433
    tmp = def_tag_args(hp___0, tag);
    }
#line 433
    if (tmp) {
#line 433
      tmp___0 = 1;
    } else {
#line 433
      tmp___0 = 0;
    }
  } else {
#line 433
    tmp___0 = 0;
  }
#line 433
  ok = (BOOL )tmp___0;
#line 435
  if (ok) {
    {
#line 437
    ok = read_macro_text(hp___0, tag, is_start_macro);
    }
#line 438
    if (ok) {
#line 440
      tag->option |= 1UL;
#line 442
      if (is_start_macro) {
#line 443
        if (tag->option & (unsigned long )(1 << 1)) {
#line 447
          tag->o_handle = & handle_content_macro;
#line 452
          tag->option &= (unsigned long )(~ (1 << 1));
#line 453
          tag->option |= (unsigned long )(1 << 16);
        } else {
#line 460
          tag->o_handle = & handle_op_macro;
        }
      } else {
#line 466
        tag->c_handle = & handle_cl_macro;
      }
    }
  }
#line 472
  return ((BOOL )0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c"
BOOL skip_expression(HSCPRC *hp___0 , EXPSTR *content , int endmark ) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c"
BOOL skip_next_lf(HSCPRC *hp___0 ) 
{ 
  INFILE *inpf ;
  int nc ;
  int tmp ;

  {
  {
#line 88
  inpf = hp___0->inpf;
#line 89
  tmp = infgetc(inpf);
#line 89
  nc = tmp;
  }
#line 92
  if (nc == 13) {
    {
#line 94
    nc = infgetc(inpf);
    }
  }
#line 96
  if (nc != 10) {
    {
#line 98
    inungetc(nc, inpf);
    }
  }
#line 101
  return ((BOOL )(nc == -1));
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c"
BOOL skip_until_eot(HSCPRC *hp___0 , EXPSTR *logstr ) 
{ 
  INFILE *inpf ;
  STRPTR nw ;
  STRPTR tmp ;
  STRPTR tmp___0 ;
  int tmp___1 ;

  {
#line 115
  inpf = hp___0->inpf;
#line 116
  nw = (STRPTR )((void *)0);
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    nw = infgetw(inpf);
    }
#line 121
    if (nw) {
#line 121
      if (logstr) {
        {
#line 123
        tmp = infgetcws(inpf);
#line 123
        ugly_app_estr(logstr, (CONSTRPTR )tmp);
#line 124
        tmp___0 = infgetcw(inpf);
#line 124
        ugly_app_estr(logstr, (CONSTRPTR )tmp___0);
        }
      }
    }
#line 118
    if (nw) {
      {
#line 118
      tmp___1 = strcmp((char const   *)nw, ">");
      }
#line 118
      if (! tmp___1) {
#line 118
        goto while_break;
      }
    } else {
#line 118
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return ((BOOL )(! hp___0->fatal));
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c"
BOOL eoc_reached(HSCPRC *hp___0 , BYTE *state , LONG *nest ) 
{ 
  INFILE *inpf ;
  STRPTR nw ;
  STRPTR tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 153
  inpf = hp___0->inpf;
#line 154
  tmp = infgetw(inpf);
#line 154
  nw = tmp;
  }
#line 156
  if (nw) {
    {
#line 160
    if ((int )*state == 0) {
#line 160
      goto case_0;
    }
#line 167
    if ((int )*state == 1) {
#line 167
      goto case_1;
    }
#line 182
    if ((int )*state == 2) {
#line 182
      goto case_2;
    }
#line 158
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 161
    tmp___1 = strcmp((char const   *)nw, "*");
    }
#line 161
    if (tmp___1) {
      {
#line 163
      tmp___0 = strcmp((char const   *)nw, "<");
      }
#line 163
      if (! tmp___0) {
#line 164
        *state = (BYTE )2;
      }
    } else {
#line 162
      *state = (BYTE )1;
    }
#line 165
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 168
    tmp___4 = strcmp((char const   *)nw, "*");
    }
#line 168
    if (tmp___4) {
      {
#line 170
      tmp___3 = strcmp((char const   *)nw, "<");
      }
#line 170
      if (tmp___3) {
        {
#line 172
        tmp___2 = strcmp((char const   *)nw, ">");
        }
#line 172
        if (! tmp___2) {
#line 173
          if (*nest) {
#line 175
            (*nest) --;
#line 176
            *state = (BYTE )0;
          } else {
#line 178
            *state = (BYTE )10;
          }
        }
      } else {
#line 171
        *state = (BYTE )2;
      }
    } else {
#line 169
      *state = (BYTE )1;
    }
#line 180
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 183
    tmp___6 = strcmp((char const   *)nw, "<");
    }
#line 183
    if (tmp___6) {
      {
#line 187
      tmp___5 = strcmp((char const   *)nw, "*");
      }
#line 187
      if (! tmp___5) {
#line 188
        (*nest) ++;
      }
#line 189
      *state = (BYTE )0;
    } else {
#line 184
      *state = (BYTE )2;
    }
#line 191
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 196
    hsc_msg_eof(hp___0, (STRPTR )"missing end of comment (\"*>\")");
#line 197
    *state = (BYTE )99;
    }
  }
#line 200
  if ((int )*state == 10) {
#line 200
    tmp___7 = 1;
  } else
#line 200
  if ((int )*state == 99) {
#line 200
    tmp___7 = 1;
  } else {
#line 200
    tmp___7 = 0;
  }
#line 200
  return ((BOOL )tmp___7);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c"
BOOL skip_hsc_comment(HSCPRC *hp___0 , EXPSTR *content ) 
{ 
  INFILE *inpf ;
  int ch ;
  int tmp ;
  BYTE state ;
  LONG nesting ;
  BOOL end ;

  {
  {
#line 218
  inpf = hp___0->inpf;
#line 219
  tmp = infgetc(inpf);
#line 219
  ch = tmp;
#line 220
  state = (BYTE )0;
#line 221
  nesting = (LONG )0;
#line 222
  end = (BOOL )0;
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (ch != -1) {
#line 225
      if (! (! end)) {
#line 225
        goto while_break;
      }
    } else {
#line 225
      goto while_break;
    }
#line 252
    if (content) {
      {
#line 252
      ugly_app_estrch(content, ch);
      }
    }
    {
#line 257
    if ((int )state == 0) {
#line 257
      goto case_0;
    }
#line 268
    if ((int )state == 1) {
#line 268
      goto case_1;
    }
#line 298
    if ((int )state == 2) {
#line 298
      goto case_2;
    }
#line 255
    goto switch_break;
    case_0: /* CIL Label */ 
#line 258
    if (ch == 42) {
#line 260
      state = (BYTE )1;
    } else
#line 262
    if (ch == 60) {
#line 264
      state = (BYTE )2;
    }
#line 266
    goto switch_break;
    case_1: /* CIL Label */ 
#line 269
    if (ch == 42) {
#line 271
      state = (BYTE )1;
    } else
#line 273
    if (ch == 60) {
#line 275
      state = (BYTE )2;
    } else
#line 277
    if (ch == 62) {
#line 279
      if (nesting) {
#line 283
        nesting --;
#line 284
        state = (BYTE )0;
      } else {
#line 288
        end = (BOOL )1;
      }
    } else {
#line 293
      state = (BYTE )0;
    }
#line 296
    goto switch_break;
    case_2: /* CIL Label */ 
#line 299
    if (ch == 60) {
#line 300
      state = (BYTE )2;
    } else {
#line 303
      if (ch == 42) {
#line 305
        nesting ++;
      }
#line 309
      state = (BYTE )0;
    }
#line 311
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 315
    if (! end) {
      {
#line 317
      ch = infgetc(inpf);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if (ch == -1) {
    {
#line 324
    hsc_msg_eof(hp___0, (STRPTR )"missing end of comment (\"*>\")");
    }
  }
#line 327
  return ((BOOL )(! hp___0->fatal));
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c"
BOOL skip_hsc_verbatim(HSCPRC *hp___0 , EXPSTR *content ) 
{ 
  INFILE *inpf ;
  int ch ;
  int tmp ;
  BYTE state ;

  {
  {
#line 348
  inpf = hp___0->inpf;
#line 349
  tmp = infgetc(inpf);
#line 349
  ch = tmp;
#line 350
  state = (BYTE )1;
  }
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (ch != -1) {
#line 352
      if (! ((int )state != 3)) {
#line 352
        goto while_break;
      }
    } else {
#line 352
      goto while_break;
    }
#line 355
    if (content) {
      {
#line 355
      ugly_app_estrch(content, ch);
      }
    }
    {
#line 360
    if ((int )state == 1) {
#line 360
      goto case_1;
    }
#line 366
    if ((int )state == 2) {
#line 366
      goto case_2;
    }
#line 380
    goto switch_default;
    case_1: /* CIL Label */ 
#line 361
    if (ch == (int )*("|" + 0)) {
#line 363
      state = (BYTE )2;
    }
#line 365
    goto switch_break;
    case_2: /* CIL Label */ 
#line 367
    if (ch == 62) {
#line 369
      state = (BYTE )3;
    } else
#line 371
    if (ch == (int )*("|" + 0)) {
#line 373
      state = (BYTE )2;
    } else {
#line 377
      state = (BYTE )1;
    }
#line 379
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 381
    display_panic_message((char *)"unhandled state", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c",
                          (size_t )381);
#line 382
    state = (BYTE )3;
    }
#line 383
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 387
    if ((int )state != 3) {
      {
#line 389
      ch = infgetc(inpf);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  if (ch == -1) {
    {
#line 396
    hsc_msg_eof(hp___0, (STRPTR )"missing end verbatim section \"<|..|>\"");
    }
  }
#line 399
  return ((BOOL )(! hp___0->fatal));
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c"
static VOID msg_lf_in_comment(HSCPRC *hp___0 ) 
{ 


  {
  {
#line 421
  hsc_message(hp___0, (HSCMSG_ID )8240, "line feed inside sgml-comment");
  }
#line 423
  return;
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c"
BOOL skip_sgml_special(HSCPRC *hp___0 , EXPSTR *content , BOOL *stripped ) 
{ 
  INFILE *inpf ;
  int ch ;
  int tmp ;
  int ch_prev ;
  BOOL end ;
  BOOL inside_comment ;
  BOOL warned_text ;
  HSCTAG dummytag ;

  {
  {
#line 427
  inpf = hp___0->inpf;
#line 428
  tmp = infgetc(inpf);
#line 428
  ch = tmp;
#line 429
  ch_prev = -1;
#line 430
  end = (BOOL )0;
  }
#line 432
  if (ch == 62) {
    {
#line 433
    hsc_message(hp___0, (HSCMSG_ID )8242, "empty sgml comment");
#line 434
    end = (BOOL )1;
    }
  } else
#line 435
  if (ch == 45) {
    {
#line 436
    ch_prev = ch;
#line 437
    ch = infgetc(inpf);
    }
#line 438
    if (ch == 45) {
#line 439
      inside_comment = (BOOL )1;
#line 440
      warned_text = (BOOL )0;
#line 444
      if (hp___0->strip_cmt) {
        {
#line 446
        dummytag.name = (STRPTR )"!-- ... --";
#line 447
        content = (EXPSTR *)((void *)0);
#line 448
        *stripped = (BOOL )1;
#line 449
        hsc_msg_stripped_tag(hp___0, & dummytag, (STRPTR )"sgml-comment");
        }
      }
#line 453
      if (content) {
        {
#line 453
        ugly_app_estrch(content, ch_prev);
        }
      }
#line 454
      if (content) {
        {
#line 454
        ugly_app_estrch(content, ch);
        }
      }
      {
#line 456
      ch_prev = -1;
#line 457
      ch = infgetc(inpf);
      }
      {
#line 459
      while (1) {
        while_continue: /* CIL Label */ ;
#line 459
        if (! end) {
#line 459
          if (! (ch != -1)) {
#line 459
            goto while_break;
          }
        } else {
#line 459
          goto while_break;
        }
#line 461
        if (content) {
          {
#line 461
          ugly_app_estrch(content, ch);
          }
        }
#line 463
        if (ch == 45) {
#line 463
          if (ch_prev == 45) {
#line 464
            inside_comment = (BOOL )(! inside_comment);
#line 465
            warned_text = (BOOL )0;
#line 466
            ch_prev = -1;
          } else {
#line 463
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 467
        if (ch == 45) {
#line 468
          ch_prev = '-';
        } else
#line 469
        if (ch == 13) {
          {
#line 470
          ch_prev = '\r';
#line 471
          msg_lf_in_comment(hp___0);
          }
        } else {
#line 473
          if (ch == 10) {
#line 474
            if (ch_prev != 13) {
              {
#line 475
              msg_lf_in_comment(hp___0);
              }
            }
          }
#line 478
          ch_prev = -1;
#line 479
          if (ch == 62) {
#line 480
            if (inside_comment) {
              {
#line 481
              hsc_message(hp___0, (HSCMSG_ID )8241, "%q inside sgml-comment", ">");
              }
            } else {
#line 484
              end = (BOOL )1;
            }
          } else {
#line 486
            if (! inside_comment) {
#line 486
              if (! warned_text) {
                {
#line 487
                hsc_message(hp___0, (HSCMSG_ID )12343, "text outside sgml-comment context");
                }
              }
            }
#line 489
            warned_text = (BOOL )1;
          }
        }
#line 493
        if (! end) {
          {
#line 495
          ch = infgetc(inpf);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 500
      if (! end) {
#line 500
        if (ch != -1) {
          {
#line 501
          inungetc(ch, inpf);
          }
        }
      }
    } else {
      {
#line 504
      inungetc(ch, inpf);
#line 505
      inungetc(ch_prev, inpf);
#line 507
      ch_prev = -1;
      }
    }
  }
#line 512
  if (! end) {
#line 515
    if (content) {
      {
#line 515
      ugly_app_estrch(content, ch);
      }
    }
    {
#line 516
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 517
      ch = infgetc(inpf);
      }
#line 518
      if (ch != -1) {
#line 519
        if (content) {
          {
#line 519
          ugly_app_estrch(content, ch);
          }
        }
#line 528
        if (ch == 62) {
#line 529
          end = (BOOL )1;
        } else {
          {
#line 531
          skip_expression(hp___0, content, ch);
          }
        }
      }
#line 516
      if (ch != -1) {
#line 516
        if (! (! end)) {
#line 516
          goto while_break___0;
        }
      } else {
#line 516
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 537
  if (ch == -1) {
    {
#line 538
    hsc_msg_eof(hp___0, (STRPTR )"missing end of sgml special tag \"<!..>\"");
    }
  }
#line 540
  return ((BOOL )(! hp___0->fatal));
}
}
#line 569 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c"
static BOOL is_endmark(int ch ) 
{ 
  BOOL it_is ;
  char *tmp ;

  {
  {
#line 571
  it_is = (BOOL )0;
#line 572
  tmp = strchr("(`\'\"", ch);
  }
#line 572
  if (tmp) {
#line 574
    it_is = (BOOL )1;
  }
#line 576
  return (it_is);
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c"
BOOL skip_expression(HSCPRC *hp___0 , EXPSTR *content , int endmark ) 
{ 
  BOOL quit ;
  BOOL usual_endmark ;
  BOOL tmp ;
  int ch ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  EXPSTR *expected ;
  EXPSTR *tmp___2 ;

  {
  {
#line 595
  quit = (BOOL )0;
#line 596
  tmp = is_endmark(endmark);
#line 596
  usual_endmark = tmp;
#line 597
  ch = -1;
  }
#line 601
  if (endmark == 40) {
#line 603
    endmark = ')';
  }
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 608
    ch = infgetc(hp___0->inpf);
    }
#line 610
    if (! usual_endmark) {
      {
#line 613
      tmp___0 = hsc_whtspc(ch);
      }
#line 613
      if (tmp___0) {
        {
#line 615
        inungetc(ch, hp___0->inpf);
#line 616
        quit = (BOOL )1;
        }
      } else
#line 613
      if (ch == 62) {
        {
#line 615
        inungetc(ch, hp___0->inpf);
#line 616
        quit = (BOOL )1;
        }
      } else
#line 620
      if (content) {
        {
#line 620
        ugly_app_estrch(content, ch);
        }
      }
    } else
#line 624
    if (endmark == 41) {
#line 626
      if (content) {
        {
#line 626
        ugly_app_estrch(content, ch);
        }
      }
      {
#line 627
      tmp___1 = is_endmark(ch);
      }
#line 627
      if (tmp___1) {
        {
#line 630
        skip_expression(hp___0, content, ch);
        }
      } else
#line 632
      if (ch == endmark) {
#line 634
        quit = (BOOL )1;
      }
    } else {
#line 643
      if (content) {
        {
#line 643
        ugly_app_estrch(content, ch);
        }
      }
#line 644
      if (ch == endmark) {
#line 646
        quit = (BOOL )1;
      }
    }
#line 606
    if (! quit) {
#line 606
      if (! (ch == -1)) {
#line 606
        if (! (! hp___0->fatal)) {
#line 606
          goto while_break;
        }
      } else {
#line 606
        goto while_break;
      }
    } else {
#line 606
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 658
  if (ch == -1) {
    {
#line 660
    tmp___2 = ugly_init_estr((size_t )0);
#line 660
    expected = tmp___2;
    }
#line 661
    if (usual_endmark) {
      {
#line 663
      ugly_app_estrch(expected, '`');
#line 664
      ugly_app_estrch(expected, endmark);
#line 665
      ugly_app_estrch(expected, '\'');
      }
    } else {
      {
#line 669
      ugly_app_estr(expected, "white space or `>\'");
      }
    }
    {
#line 671
    ugly_app_estr(expected, " expected");
#line 672
    hsc_msg_eof(hp___0, expected->es_data);
#line 673
    del_estr(expected);
    }
  }
#line 676
  return ((BOOL )(! hp___0->fatal));
}
}
#line 694 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c"
BOOL skip_tag_attribs(HSCPRC *hp___0 , EXPSTR *content ) 
{ 
  UBYTE state ;
  INFILE *inpf ;
  STRPTR nw ;
  BOOL quit ;
  STRPTR tmp ;
  STRPTR tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 699
  state = (UBYTE )10;
#line 700
  inpf = hp___0->inpf;
#line 701
  nw = (STRPTR )((void *)0);
#line 702
  quit = (BOOL )0;
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if ((int )state == 10) {
      {
#line 709
      nw = infget_attrid(hp___0);
      }
    } else {
      {
#line 713
      nw = infgetw(inpf);
      }
    }
#line 716
    if (nw) {
      {
#line 718
      tmp = infgetcws(inpf);
#line 718
      ugly_app_estr(content, (CONSTRPTR )tmp);
#line 719
      tmp___0 = infgetcw(inpf);
#line 719
      ugly_app_estr(content, (CONSTRPTR )tmp___0);
      }
      {
#line 723
      if ((int )state == 10) {
#line 723
        goto case_10;
      }
#line 751
      if ((int )state == 11) {
#line 751
        goto case_11;
      }
#line 758
      goto switch_default;
      case_10: /* CIL Label */ 
      {
#line 725
      tmp___3 = strcmp((char const   *)nw, "=");
      }
#line 725
      if (tmp___3) {
        {
#line 730
        tmp___2 = strcmp((char const   *)nw, "?");
        }
#line 730
        if (tmp___2) {
          {
#line 738
          tmp___1 = strcmp((char const   *)nw, ">");
          }
#line 738
          if (! tmp___1) {
#line 741
            quit = (BOOL )1;
          }
        } else {
          {
#line 735
          parse_eq(hp___0);
#line 736
          inungetcw(inpf);
          }
        }
      } else {
#line 728
        state = (UBYTE )11;
      }
#line 748
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 752
      skip_expression(hp___0, content, (int )*(nw + 0));
#line 754
      state = (UBYTE )10;
      }
#line 755
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 759
      display_panic_message((char *)"unhandled state", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c",
                            (size_t )759);
      }
#line 760
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 704
    if (nw) {
#line 704
      if (! quit) {
#line 704
        if (! (! hp___0->fatal)) {
#line 704
          goto while_break;
        }
      } else {
#line 704
        goto while_break;
      }
    } else {
#line 704
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 766
  return ((BOOL )(! hp___0->fatal));
}
}
#line 814 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c"
BOOL skip_until_tag(HSCPRC *hp___0 , EXPSTR *content , EXPSTR *tagfound , STRPTR tagstoplist ,
                    STRPTR tagnest , ULONG option ) 
{ 
  UBYTE state ;
  INFILE *inpf ;
  LONG nesting ;
  STRPTR nw ;
  BOOL quit ;
  EXPSTR *tagstr ;
  EXPSTR *tmp ;
  STRPTR tmp___0 ;
  STRPTR tmp___1 ;
  STRPTR tmp___2 ;
  int tmp___3 ;
  BOOL skip_attribs ;
  BOOL append_tag ;
  STRPTR tmp___4 ;
  STRPTR tmp___5 ;
  BOOL dummy_stripped ;
  HSCTAG *tag ;
  HSCTAG *tmp___6 ;
  LONG tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  STRPTR tmp___15 ;
  STRPTR tmp___16 ;
  int tmp___17 ;
  STRPTR tmp___18 ;
  STRPTR tmp___19 ;

  {
  {
#line 817
  state = (UBYTE )1;
#line 818
  inpf = hp___0->inpf;
#line 819
  nesting = (LONG )0;
#line 820
  nw = (STRPTR )((void *)0);
#line 821
  quit = (BOOL )0;
#line 822
  tmp = ugly_init_estr((size_t )128);
#line 822
  tagstr = tmp;
  }
#line 825
  if (tagfound) {
    {
#line 826
    ugly_clr_estr(tagfound);
    }
  }
#line 829
  if (content) {
#line 829
    if (option & (unsigned long )(1 << 2)) {
      {
#line 830
      ugly_clr_estr(content);
      }
    }
  }
  {
#line 832
  while (1) {
    while_continue: /* CIL Label */ ;
#line 834
    if ((int )state != 2) {
#line 834
      if ((int )state != 8) {
        {
#line 835
        nw = infgetw(inpf);
        }
      } else {
        {
#line 837
        nw = infget_tagid(hp___0);
        }
      }
    } else {
      {
#line 837
      nw = infget_tagid(hp___0);
      }
    }
#line 839
    if (nw) {
      {
#line 852
      if ((int )state == 1) {
#line 852
        goto case_1;
      }
#line 868
      if ((int )state == 2) {
#line 868
        goto case_2;
      }
#line 972
      if ((int )state == 8) {
#line 972
        goto case_8;
      }
#line 1006
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 853
      tmp___3 = strcmp((char const   *)nw, "<");
      }
#line 853
      if (tmp___3) {
#line 861
        if (content) {
          {
#line 861
          tmp___1 = infgetcws(inpf);
#line 861
          ugly_app_estr(content, (CONSTRPTR )tmp___1);
          }
        }
#line 861
        if (content) {
          {
#line 861
          tmp___2 = infgetcw(inpf);
#line 861
          ugly_app_estr(content, (CONSTRPTR )tmp___2);
          }
        }
#line 862
        if (tagstr->es_len - 1UL) {
          {
#line 863
          ugly_clr_estr(tagstr);
          }
        }
      } else {
#line 855
        if (content) {
          {
#line 855
          tmp___0 = infgetcws(inpf);
#line 855
          ugly_app_estr(content, (CONSTRPTR )tmp___0);
          }
        }
        {
#line 857
        ugly_set_estr(tagstr, (CONSTRPTR )nw);
#line 859
        state = (UBYTE )2;
        }
      }
#line 865
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 869
      tmp___14 = strcmp((char const   *)nw, "<");
      }
#line 869
      if (tmp___14) {
        {
#line 882
        skip_attribs = (BOOL )0;
#line 884
        append_tag = (BOOL )0;
#line 886
        tmp___4 = infgetcws(inpf);
#line 886
        ugly_app_estr(tagstr, (CONSTRPTR )tmp___4);
#line 887
        tmp___5 = infgetcw(inpf);
#line 887
        ugly_app_estr(tagstr, (CONSTRPTR )tmp___5);
#line 890
        tmp___13 = strcmp((char const   *)nw, "/");
        }
#line 890
        if (tmp___13) {
#line 892
          if (option & (unsigned long )(1 << 3)) {
#line 894
            append_tag = (BOOL )1;
          } else {
            {
#line 896
            tmp___12 = upstrcmp((CONSTRPTR )nw, "*");
            }
#line 896
            if (tmp___12) {
              {
#line 901
              tmp___11 = upstrcmp((CONSTRPTR )nw, "|");
              }
#line 901
              if (tmp___11) {
                {
#line 907
                tmp___10 = upstrcmp((CONSTRPTR )nw, "$source");
                }
#line 907
                if (tmp___10) {
                  {
#line 916
                  tmp___9 = strcmp((char const   *)nw, "!");
                  }
#line 916
                  if (tmp___9) {
                    {
#line 924
                    tmp___6 = find_strtag(hp___0->deftag, nw);
#line 924
                    tag = tmp___6;
#line 928
                    tmp___8 = upstrcmp((CONSTRPTR )nw, (CONSTRPTR )tagnest);
                    }
#line 928
                    if (tmp___8) {
#line 933
                      if (! nesting) {
#line 933
                        if (tagstoplist) {
                          {
#line 933
                          tmp___7 = strenum((CONSTRPTR )nw, (CONSTRPTR )tagstoplist,
                                            (char )'|', (BYTE )1);
                          }
#line 933
                          if (tmp___7) {
#line 937
                            if (tagfound) {
                              {
#line 938
                              ugly_set_estr(tagfound, (CONSTRPTR )nw);
                              }
                            }
#line 939
                            skip_attribs = (BOOL )1;
#line 940
                            quit = (BOOL )1;
                          } else {
#line 933
                            goto _L___0;
                          }
                        } else {
#line 933
                          goto _L___0;
                        }
                      } else
                      _L___0: /* CIL Label */ 
#line 941
                      if (tag) {
#line 941
                        if (tag->option & (unsigned long )(1 << 4)) {
#line 947
                          state = (UBYTE )1;
#line 948
                          append_tag = (BOOL )1;
                        } else {
#line 951
                          append_tag = (BOOL )1;
#line 952
                          skip_attribs = (BOOL )1;
                        }
                      } else {
#line 951
                        append_tag = (BOOL )1;
#line 952
                        skip_attribs = (BOOL )1;
                      }
                    } else {
#line 930
                      nesting ++;
#line 931
                      skip_attribs = (BOOL )1;
#line 932
                      append_tag = (BOOL )1;
                    }
#line 956
                    if (skip_attribs) {
                      {
#line 957
                      skip_tag_attribs(hp___0, tagstr);
#line 958
                      state = (UBYTE )1;
                      }
                    }
                  } else {
#line 920
                    if (content) {
                      {
#line 920
                      ugly_app_estr(content, (CONSTRPTR )tagstr->es_data);
                      }
                    }
                    {
#line 921
                    skip_sgml_special(hp___0, content, & dummy_stripped);
#line 922
                    state = (UBYTE )1;
                    }
                  }
                } else {
#line 910
                  if (content) {
                    {
#line 910
                    ugly_app_estr(content, (CONSTRPTR )tagstr->es_data);
                    }
                  }
                  {
#line 911
                  skip_tag_attribs(hp___0, content);
#line 912
                  skip_until_tag(hp___0, content, (EXPSTR *)((void *)0), (STRPTR )((void *)0),
                                 (STRPTR )"$source", (ULONG )(1 << 3));
#line 915
                  state = (UBYTE )1;
                  }
                }
              } else {
#line 904
                if (content) {
                  {
#line 904
                  ugly_app_estr(content, (CONSTRPTR )tagstr->es_data);
                  }
                }
                {
#line 905
                skip_hsc_verbatim(hp___0, content);
#line 906
                state = (UBYTE )1;
                }
              }
            } else {
#line 898
              if (content) {
                {
#line 898
                ugly_app_estr(content, (CONSTRPTR )tagstr->es_data);
                }
              }
              {
#line 899
              skip_hsc_comment(hp___0, content);
#line 900
              state = (UBYTE )1;
              }
            }
          }
        } else {
#line 891
          state = (UBYTE )8;
        }
#line 963
        if (append_tag) {
#line 966
          if (content) {
            {
#line 966
            ugly_app_estr(content, (CONSTRPTR )tagstr->es_data);
            }
          }
#line 967
          state = (UBYTE )1;
        }
      } else {
#line 872
        if (content) {
          {
#line 872
          estrcat(content, tagstr);
          }
        }
        {
#line 875
        inungetcwws(inpf);
#line 878
        state = (UBYTE )1;
        }
      }
#line 970
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 974
      tmp___15 = infgetcws(inpf);
#line 974
      ugly_app_estr(tagstr, (CONSTRPTR )tmp___15);
#line 975
      tmp___16 = infgetcw(inpf);
#line 975
      ugly_app_estr(tagstr, (CONSTRPTR )tmp___16);
#line 976
      tmp___17 = upstrcmp((CONSTRPTR )nw, (CONSTRPTR )tagnest);
      }
#line 976
      if (! tmp___17) {
#line 977
        if (nesting) {
#line 978
          nesting --;
        } else {
#line 982
          quit = (BOOL )1;
        }
      }
#line 987
      if (quit) {
#line 987
        goto _L___1;
      } else
#line 987
      if (! (option & (unsigned long )(1 << 3))) {
        _L___1: /* CIL Label */ 
        {
#line 988
        nw = infgetw(inpf);
        }
#line 989
        if (nw) {
          {
#line 990
          tmp___18 = infgetcws(inpf);
#line 990
          ugly_app_estr(tagstr, (CONSTRPTR )tmp___18);
#line 991
          tmp___19 = infgetcw(inpf);
#line 991
          ugly_app_estr(tagstr, (CONSTRPTR )tmp___19);
#line 992
          inungetcw(inpf);
          }
        }
        {
#line 994
        parse_gt(hp___0);
        }
      }
#line 998
      if (! quit) {
#line 999
        if (content) {
          {
#line 999
          ugly_app_estr(content, (CONSTRPTR )tagstr->es_data);
          }
        }
      }
#line 1002
      state = (UBYTE )1;
#line 1004
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1007
      display_panic_message((char *)"unhandled state in skip_until_tag()", (char *)"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/skip.c",
                            (size_t )1007);
      }
#line 1008
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 832
    if (nw) {
#line 832
      if (! quit) {
#line 832
        if (! (! hp___0->fatal)) {
#line 832
          goto while_break;
        }
      } else {
#line 832
        goto while_break;
      }
    } else {
#line 832
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  if (nw) {
#line 1015
    if (option & 1UL) {
      {
#line 1016
      inungets(tagstr->es_data, inpf);
      }
    }
#line 1019
    if (! (option & (unsigned long )(1 << 1))) {
#line 1020
      if (content) {
        {
#line 1020
        ugly_app_estr(content, (CONSTRPTR )tagstr->es_data);
        }
      }
    }
  } else {
    {
#line 1023
    ugly_set_estr(tagstr, "</");
#line 1024
    ugly_app_estr(tagstr, (CONSTRPTR )tagnest);
#line 1025
    ugly_app_estr(tagstr, "> expected");
#line 1026
    hsc_msg_eof(hp___0, tagstr->es_data);
    }
  }
  {
#line 1030
  del_estr(tagstr);
  }
#line 1032
  return ((BOOL )((unsigned long )nw != (unsigned long )((void *)0)));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/idref.c"
VOID hsc_msg_unknown_id(HSCPRC *hp___0 , STRPTR filename , STRPTR id ) 
{ 


  {
#line 47
  if (filename) {
    {
#line 48
    hsc_message(hp___0, (HSCMSG_ID )12362, "unknown id `%s#%s\'", filename, id);
    }
  } else {
    {
#line 51
    hsc_message(hp___0, (HSCMSG_ID )12362, "unknown id %q", id);
    }
  }
#line 52
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/idref.c"
VOID del_idref(APTR data ) 
{ 
  IDREF *idref ;

  {
  {
#line 72
  idref = (IDREF *)data;
#line 74
  ugly_freestr(idref->name, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/idref.c",
               (ULONG )74);
#line 74
  idref->name = (STRPTR )((void *)0);
#line 75
  del_infilepos(idref->fpos);
  }
#line 76
  if (idref) {
    {
#line 76
    free((void *)idref);
#line 76
    idref = (IDREF *)((void *)0);
    }
  }
#line 77
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/idref.c"
static IDREF *new_idref(STRPTR id , INFILEPOS *fpos ) 
{ 
  IDREF *newid ;
  void *tmp ;

  {
  {
#line 82
  tmp = ugly_malloc_notracking(sizeof(IDREF ));
#line 82
  newid = (IDREF *)tmp;
#line 84
  newid->name = ugly_strclone((CONSTRPTR )id, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/idref.c",
                              (ULONG )84);
#line 85
  newid->fpos = fpos;
  }
#line 87
  return (newid);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/idref.c"
VOID prt_idref(FILE *stream , APTR data ) 
{ 
  IDREF *idref ;
  INFILEPOS *fpos ;
  ULONG tmp ;
  ULONG tmp___0 ;

  {
  {
#line 92
  idref = (IDREF *)data;
#line 93
  fpos = idref->fpos;
#line 95
  tmp = ifp_get_x(fpos);
#line 95
  tmp___0 = ifp_get_y(fpos);
#line 95
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"`%s\' at (%lu,%lu)\n",
          idref->name, tmp___0, tmp);
  }
#line 97
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/idref.c"
BOOL add_local_iddef(HSCPRC *hp___0 , STRPTR id ) 
{ 
  INFILEPOS *fpos ;
  INFILEPOS *tmp ;
  HSCIDD *iddef ;
  HSCIDD *tmp___0 ;

  {
  {
#line 106
  tmp = new_infilepos(hp___0->inpf);
#line 106
  fpos = tmp;
#line 107
  tmp___0 = find_iddef((hp___0->project)->document, id);
#line 107
  iddef = tmp___0;
  }
#line 115
  if (iddef) {
    {
#line 120
    hsc_message(hp___0, (HSCMSG_ID )12363, "local id %q already declared", id);
#line 123
    set_infilepos(hp___0->inpf, iddef->fpos);
#line 124
    hsc_message(hp___0, (HSCMSG_ID )12363, "(location of previous declaration)");
#line 127
    set_infilepos(hp___0->inpf, fpos);
#line 128
    del_infilepos(fpos);
    }
  } else {
    {
#line 133
    iddef = app_iddef((hp___0->project)->document, id);
#line 134
    iddef->caller = fpos2caller(fpos);
#line 135
    iddef->fpos = fpos;
    }
  }
#line 140
  return ((BOOL )1);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/idref.c"
VOID add_local_idref(HSCPRC *hp___0 , STRPTR id ) 
{ 
  INFILEPOS *fpos ;
  INFILEPOS *tmp ;
  IDREF *tmp___0 ;

  {
  {
#line 151
  tmp = new_infilepos(hp___0->inpf);
#line 151
  fpos = tmp;
#line 155
  tmp___0 = new_idref(id, fpos);
#line 155
  app_dlnode(hp___0->idrefs, (APTR )tmp___0);
  }
#line 156
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/idref.c"
static BOOL check_local_idref(HSCPRC *hp___0 , IDREF *idref ) 
{ 
  HSCIDD *iddef ;
  HSCIDD *tmp ;
  BOOL found ;

  {
  {
#line 163
  tmp = find_iddef((hp___0->project)->document, idref->name);
#line 163
  iddef = tmp;
#line 164
  found = (BOOL )0;
  }
#line 166
  if (iddef) {
#line 168
    found = (BOOL )1;
  } else {
    {
#line 181
    set_infilepos(hp___0->inpf, idref->fpos);
#line 182
    hsc_msg_unknown_id(hp___0, (STRPTR )((void *)0), idref->name);
    }
  }
#line 185
  return (found);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsclib/idref.c"
BOOL check_all_local_idref(HSCPRC *hp___0 ) 
{ 
  BOOL ok ;
  DLNODE *nd ;
  INFILEPOS *infpos ;
  INFILEPOS *tmp ;

  {
  {
#line 193
  ok = (BOOL )1;
#line 194
  nd = (DLNODE *)((void *)0);
#line 195
  tmp = new_infilepos(hp___0->inpf);
#line 195
  infpos = tmp;
#line 210
  nd = (hp___0->idrefs)->first;
  }
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! nd) {
#line 211
      goto while_break;
    }
    {
#line 213
    check_local_idref(hp___0, (IDREF *)nd->data);
#line 214
    nd = nd->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 217
  set_infilepos(hp___0->inpf, infpos);
#line 218
  del_infilepos(infpos);
  }
#line 220
  return (ok);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 43 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/output.c"
static DLLIST *outlist  =    (DLLIST *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/output.c"
static VOID del_outstr(APTR data ) 
{ 


  {
  {
#line 50
  del_estr((EXPSTR *)data);
  }
#line 51
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/output.c"
BOOL init_output(HSCPRC *hp___0 ) 
{ 
  BOOL ok ;
  EXPSTR *outstring ;
  EXPSTR *tmp ;

  {
  {
#line 62
  ok = (BOOL )1;
#line 63
  tmp = ugly_init_estr((size_t )8192);
#line 63
  outstring = tmp;
#line 65
  outlist = init_dllist(& del_outstr);
#line 66
  app_dlnode(outlist, (APTR )outstring);
  }
#line 68
  return (ok);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/output.c"
VOID cleanup_output(void) 
{ 


  {
  {
#line 79
  del_dllist(outlist);
  }
#line 80
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/output.c"
BOOL write_output(HSCPRC *hp___0 ) 
{ 
  STRPTR outfilenm ;
  BOOL written ;
  FILE *outfile ;
  char buf___3[502] ;
  int *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  DLNODE *nd ;
  int *tmp___5 ;
  EXPSTR *outstring ;
  int *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;

  {
#line 90
  outfilenm = (STRPTR )((void *)0);
#line 91
  written = (BOOL )0;
#line 93
  if (outfilename) {
#line 94
    outfilenm = outfilename->es_data;
  }
#line 96
  if (return_code == 0) {
#line 96
    goto _L;
  } else
#line 96
  if (return_code == 0) {
#line 96
    goto _L;
  } else
#line 96
  if (hp___0->debug) {
    _L: /* CIL Label */ 
#line 99
    outfile = (FILE *)((void *)0);
#line 105
    if (outfilenm) {
      {
#line 106
      tmp = __errno_location();
#line 106
      *tmp = 0;
#line 107
      outfile = fopen((char const   */* __restrict  */)outfilenm, (char const   */* __restrict  */)"w");
      }
#line 108
      if (! outfile) {
        {
#line 109
        strncpy((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"unable to open `",
                (size_t )500);
#line 110
        tmp___0 = strlen((char const   *)(buf___3));
#line 110
        strncat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)outfilename->es_data,
                500UL - tmp___0);
#line 112
        tmp___1 = strlen((char const   *)(buf___3));
#line 112
        strncat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"\' for output: ",
                500UL - tmp___1);
#line 113
        tmp___2 = strlen((char const   *)(buf___3));
#line 113
        tmp___3 = __errno_location();
#line 113
        tmp___4 = strerror(*tmp___3);
#line 113
        strncat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)tmp___4,
                500UL - tmp___2);
#line 114
        status_error(buf___3);
        }
      }
    } else {
#line 117
      outfile = stdout;
#line 118
      outfilenm = (STRPTR )"<stdout>";
    }
#line 124
    if (outfile) {
      {
#line 126
      nd = outlist->first;
#line 128
      status_msg((STRPTR )"writing output..");
#line 129
      tmp___5 = __errno_location();
#line 129
      *tmp___5 = 0;
      }
      {
#line 132
      while (1) {
        while_continue: /* CIL Label */ ;
#line 132
        if (nd) {
          {
#line 132
          tmp___6 = __errno_location();
          }
#line 132
          if (*tmp___6) {
#line 132
            goto while_break;
          }
        } else {
#line 132
          goto while_break;
        }
        {
#line 134
        outstring = (EXPSTR *)nd->data;
#line 136
        nd = nd->next;
#line 138
        fwrite((void const   */* __restrict  */)outstring->es_data, sizeof(char ),
               outstring->es_len - 1UL, (FILE */* __restrict  */)outfile);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 144
      tmp___12 = __errno_location();
      }
#line 144
      if (*tmp___12) {
        {
#line 146
        strncpy((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"error writing `",
                (size_t )500);
#line 147
        tmp___7 = strlen((char const   *)(buf___3));
#line 147
        strncat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)outfilename->es_data,
                500UL - tmp___7);
#line 149
        tmp___8 = strlen((char const   *)(buf___3));
#line 149
        strncat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"\': ",
                500UL - tmp___8);
#line 150
        tmp___9 = strlen((char const   *)(buf___3));
#line 150
        tmp___10 = __errno_location();
#line 150
        tmp___11 = strerror(*tmp___10);
#line 150
        strncat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)tmp___11,
                500UL - tmp___9);
#line 151
        status_error(buf___3);
        }
      } else {
#line 154
        written = (BOOL )1;
      }
      {
#line 156
      status_clear();
      }
#line 159
      if ((unsigned long )outfile != (unsigned long )stdout) {
        {
#line 161
        fclose(outfile);
        }
      }
    }
  } else {
    {
#line 175
    status_msg((STRPTR )"no output written");
#line 176
    status_lf();
    }
  }
#line 180
  return (written);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/hsc/output.c"
VOID append_output(STRPTR text ) 
{ 
  EXPSTR *outstr ;
  size_t tmp ;

  {
  {
#line 190
  outstr = (EXPSTR *)(outlist->last)->data;
#line 193
  tmp = strlen((char const   *)text);
  }
#line 193
  if (((outstr->es_len - 1UL) + tmp) + 1UL > 8192UL) {
    {
#line 201
    outstr = ugly_init_estr((size_t )8192);
#line 202
    app_dlnode(outlist, (APTR )outstr);
    }
  }
  {
#line 206
  ugly_app_estr(outstr, (CONSTRPTR )text);
  }
#line 207
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static int arg_error_num___1  =    -1;
#line 65 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static STRPTR arg_error_arg___1  =    (STRPTR )((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static STRPTR arg_error_hfs___1  =    (STRPTR )((void *)0);
#line 72 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static STRARR argerrstr___1[60]  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static BOOL no_argerr___1  =    (BOOL )1;
#line 78 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static BOOL any_argerr___1  =    (BOOL )0;
#line 79 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static int argidx___1  =    -1;
#line 86 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static int compare_arginfo___1(APTR cmp_data , APTR list_data ) 
{ 
  struct arginfo *ai ;
  STRPTR lst_arg ;
  STRPTR tmp ;
  STRPTR cmp_arg ;
  BOOL eq ;
  char lastch ;
  STRPTR nxt_arg ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 88
  ai = (struct arginfo *)list_data;
#line 89
  tmp = ugly_strclone((CONSTRPTR )ai->ai_id, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c",
                      (ULONG )89);
#line 89
  lst_arg = tmp;
#line 90
  cmp_arg = ((struct arginfo *)cmp_data)->ai_id;
#line 91
  eq = (BOOL )0;
  }
#line 94
  if (lst_arg) {
#line 94
    if (cmp_arg) {
      {
#line 96
      tmp___0 = strtok((char */* __restrict  */)lst_arg, (char const   */* __restrict  */)"=");
#line 96
      nxt_arg = tmp___0;
      }
      {
#line 98
      while (1) {
        while_continue: /* CIL Label */ ;
#line 98
        if (nxt_arg) {
#line 98
          if (! ((int )eq == 0)) {
#line 98
            goto while_break;
          }
        } else {
#line 98
          goto while_break;
        }
#line 100
        if (ai->ai_flags & (long )(1 << 3)) {
          {
#line 102
          tmp___1 = strlen((char const   *)nxt_arg);
#line 102
          tmp___2 = strncmp((char const   *)nxt_arg, (char const   *)cmp_arg, tmp___1);
#line 102
          eq = (BOOL )(tmp___2 == 0);
          }
        } else {
          {
#line 106
          tmp___3 = strlen((char const   *)nxt_arg);
#line 106
          tmp___4 = upstrncmp((CONSTRPTR )nxt_arg, (CONSTRPTR )cmp_arg, tmp___3);
#line 106
          eq = (BOOL )(tmp___4 == 0);
          }
        }
        {
#line 116
        tmp___5 = strlen((char const   *)nxt_arg);
#line 116
        lastch = *(cmp_arg + tmp___5);
        }
#line 117
        if ((int )lastch == 0) {
#line 117
          tmp___6 = 1;
        } else
#line 117
        if ((int )lastch == 61) {
#line 117
          tmp___6 = 1;
        } else {
#line 117
          tmp___6 = 0;
        }
        {
#line 117
        eq = (BOOL )((int )eq & tmp___6);
#line 119
        nxt_arg = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"=");
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 125
      eq = (BOOL )0;
    }
  } else {
#line 125
    eq = (BOOL )0;
  }
  {
#line 128
  ugly_freestr(lst_arg, (STRPTR )"/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c",
               (ULONG )128);
#line 128
  lst_arg = (STRPTR )((void *)0);
  }
#line 130
  return ((int )eq);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID clr_ai_set___1(ARGLIST *al ) 
{ 
  struct dlnode *nd ;
  struct arginfo *ai ;

  {
#line 157
  if (al) {
#line 157
    if (al->al_list) {
#line 159
      nd = (al->al_list)->first;
      {
#line 161
      while (1) {
        while_continue: /* CIL Label */ ;
#line 161
        if (! nd) {
#line 161
          goto while_break;
        }
#line 163
        ai = (struct arginfo *)nd->data;
#line 165
        if (ai) {
#line 166
          ai->ai_set = (BOOL )0;
        }
#line 167
        nd = nd->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 170
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID reset_nokeywd___1(ARGLIST *al ) 
{ 
  struct dlnode *nd ;
  struct arginfo *ai ;

  {
#line 186
  nd = (al->al_list)->first;
#line 187
  ai = (struct arginfo *)nd->data;
#line 189
  if (ai->ai_flags & 1L) {
#line 189
    goto _L___0;
  } else
#line 189
  if (ai->ai_type == 1L) {
    _L___0: /* CIL Label */ 
#line 191
    al->al_nokeywd = (struct arginfo *)((void *)0);
    {
#line 193
    while (1) {
      while_continue: /* CIL Label */ ;
#line 195
      if (ai->ai_flags & 1L) {
#line 195
        goto _L;
      } else
#line 195
      if (ai->ai_type == 1L) {
        _L: /* CIL Label */ 
#line 198
        nd = nd->next;
#line 199
        if (nd) {
#line 200
          ai = (struct arginfo *)nd->data;
        }
      } else {
#line 203
        al->al_nokeywd = ai;
      }
#line 193
      if (nd) {
#line 193
        if (! (! al->al_nokeywd)) {
#line 193
          goto while_break;
        }
      } else {
#line 193
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 209
    al->al_nokeywd = ai;
  }
#line 211
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID find_nxt_nokeywd___1(ARGLIST *al ) 
{ 
  struct dlnode *nd ;
  struct arginfo *ai ;
  BOOL is_keywd ;
  BOOL multiple_nokeywd ;
  int tmp ;

  {
#line 221
  if (al->al_nokeywd) {
#line 253
    nd = (al->al_list)->first;
#line 259
    al->al_nokeywd = (struct arginfo *)((void *)0);
    {
#line 260
    while (1) {
      while_continue: /* CIL Label */ ;
#line 260
      if (nd) {
#line 260
        if (! ((unsigned long )al->al_nokeywd == (unsigned long )((void *)0))) {
#line 260
          goto while_break;
        }
      } else {
#line 260
        goto while_break;
      }
#line 262
      is_keywd = (BOOL )0;
#line 263
      multiple_nokeywd = (BOOL )0;
#line 265
      ai = (struct arginfo *)nd->data;
#line 267
      is_keywd = (BOOL )(ai->ai_flags & 1L);
#line 268
      if (ai->ai_flags & (long )(1 << 2)) {
#line 268
        if (! is_keywd) {
#line 268
          tmp = 1;
        } else {
#line 268
          tmp = 0;
        }
      } else {
#line 268
        tmp = 0;
      }
#line 268
      multiple_nokeywd = (BOOL )tmp;
#line 272
      if (ai->ai_flags & 1L) {
#line 272
        goto _L;
      } else
#line 272
      if (ai->ai_type == 1L) {
#line 272
        goto _L;
      } else
#line 272
      if (ai->ai_set) {
        _L: /* CIL Label */ 
#line 272
        if (! multiple_nokeywd) {
#line 277
          nd = nd->next;
        } else {
#line 281
          al->al_nokeywd = ai;
        }
      } else {
#line 281
        al->al_nokeywd = ai;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 285
  return;
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID set_argerr___1(int num , STRPTR arg ) 
{ 


  {
#line 294
  if (no_argerr___1) {
#line 296
    no_argerr___1 = (BOOL )0;
#line 297
    any_argerr___1 = (BOOL )1;
#line 299
    arg_error_num___1 = num;
#line 300
    arg_error_arg___1 = arg;
  }
#line 302
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID clr_argerr___1(void) 
{ 


  {
#line 306
  no_argerr___1 = (BOOL )1;
#line 307
  any_argerr___1 = (BOOL )0;
#line 308
  arg_error_num___1 = 0;
#line 309
  arg_error_arg___1 = (STRPTR )((void *)0);
#line 310
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static UBYTE set_arg_value___1(struct arginfo *ai , STRPTR arg , STRPTR arg2 , BOOL keywd ) 
{ 
  APTR dest ;
  STRPTR param ;
  UBYTE arg_incr ;
  BOOL arg2used ;
  APTR aparam ;
  DLLIST **dest_list ;
  LONG along ;
  BOOL tmp ;
  LONG aenum ;
  LONG tmp___0 ;
  DLNODE *tmp___1 ;

  {
#line 404
  dest = ai->ai_dest;
#line 406
  arg_incr = (UBYTE )0;
#line 407
  arg2used = (BOOL )0;
#line 414
  if (keywd) {
#line 414
    if (! (ai->ai_type == 1L)) {
#line 416
      param = arg;
      {
#line 417
      while (1) {
        while_continue: /* CIL Label */ ;
#line 417
        if (*(param + 0)) {
#line 417
          if (! ((int )*(param + 0) != 61)) {
#line 417
            goto while_break;
          }
        } else {
#line 417
          goto while_break;
        }
#line 418
        param ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 419
      if (*(param + 0)) {
#line 420
        param ++;
      } else {
#line 423
        param = arg2;
#line 424
        arg2used = (BOOL )1;
#line 425
        if (! param) {
          {
#line 426
          set_argerr___1(3, arg);
          }
        }
      }
    } else {
#line 430
      param = arg;
    }
  } else {
#line 430
    param = arg;
  }
#line 435
  if (no_argerr___1) {
#line 437
    if (ai->ai_func) {
      {
#line 440
      arg_error_hfs___1 = (*(ai->ai_func))(param);
      }
#line 441
      if (arg_error_hfs___1) {
        {
#line 442
        set_argerr___1(127, param);
        }
      }
    } else
#line 444
    if (ai->ai_type == 1L) {
#line 446
      *((BOOL *)dest) = (BOOL )1;
    } else {
#line 453
      if ((int )ai->ai_set == 2) {
#line 453
        if (ai->ai_flags & (long )(1 << 4)) {
#line 461
          ai->ai_set = (BOOL )2;
        } else
#line 453
        if (ai->ai_flags & (long )(1 << 2)) {
#line 461
          ai->ai_set = (BOOL )2;
        } else {
          {
#line 457
          set_argerr___1(8, arg);
          }
        }
      } else {
#line 461
        ai->ai_set = (BOOL )2;
      }
#line 464
      if (no_argerr___1) {
#line 466
        aparam = (void *)0;
#line 467
        dest_list = (DLLIST **)dest;
#line 473
        if (! param) {
          {
#line 476
          set_argerr___1(9, arg);
          }
        }
#line 478
        if (ai->ai_type == 2L) {
#line 480
          aparam = (APTR )param;
        } else
#line 482
        if (ai->ai_type == 3L) {
          {
#line 484
          tmp = str2long(param, & along);
          }
#line 484
          if (tmp) {
#line 487
            aparam = (APTR )along;
          } else {
            {
#line 485
            set_argerr___1(2, arg);
            }
          }
        } else
#line 489
        if (ai->ai_type == 5L) {
          {
#line 491
          tmp___0 = strenum((CONSTRPTR )param, (CONSTRPTR )ai->ai_misc1.ai_enum, (char )'|',
                            (BYTE )1);
#line 491
          aenum = tmp___0;
          }
#line 494
          if (! aenum) {
            {
#line 495
            set_argerr___1(5, arg);
            }
          } else {
#line 497
            aparam = (APTR )aenum;
          }
        }
#line 514
        if (no_argerr___1) {
#line 516
          if (ai->ai_flags & (long )(1 << 2)) {
#line 518
            if (! *dest_list) {
              {
#line 519
              *dest_list = init_dllist((void (*)(APTR data ))((void *)0));
              }
            }
#line 520
            if (*dest_list) {
              {
#line 522
              tmp___1 = app_dlnode(*dest_list, aparam);
              }
#line 522
              if (! tmp___1) {
                {
#line 523
                set_argerr___1(1, arg);
                }
              }
            } else {
              {
#line 526
              set_argerr___1(1, arg);
              }
            }
          } else
#line 530
          if (ai->ai_type == 3L) {
#line 531
            *((LONG *)dest) = (LONG )aparam;
          } else
#line 532
          if (ai->ai_type == 5L) {
#line 533
            *((LONG *)dest) = (LONG )aparam;
          } else
#line 534
          if (ai->ai_type == 2L) {
#line 535
            *((STRPTR *)dest) = (STRPTR )aparam;
          }
        }
      }
    }
#line 542
    if (arg2used) {
#line 543
      arg_incr = (UBYTE )1;
    }
  }
#line 546
  return (arg_incr);
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_set.c"
static VOID check_required_set___1(ARGLIST *al ) 
{ 
  DLNODE *nd ;
  ARGINFO *ai ;

  {
#line 557
  nd = (al->al_list)->first;
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    ai = (struct arginfo *)nd->data;
#line 564
    if (ai->ai_flags & (long )(1 << 1)) {
#line 564
      if ((int )ai->ai_set == 0) {
        {
#line 565
        set_argerr___1(3, ai->ai_id);
        }
      } else {
#line 567
        nd = nd->next;
      }
    } else {
#line 567
      nd = nd->next;
    }
#line 560
    if (nd) {
#line 560
      if (! no_argerr___1) {
#line 560
        goto while_break;
      }
    } else {
#line 560
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_hlp.c"
static VOID strcat_flag___1(STRPTR s___2 , struct arginfo *ai , ULONG chk_flag , char ch ) 
{ 
  char flag[3] ;

  {
#line 54
  flag[0] = (char )'/';
#line 54
  flag[1] = (char )'x';
#line 54
  flag[2] = (char )'\000';
#line 56
  if ((unsigned long )ai->ai_flags & chk_flag) {
    {
#line 58
    flag[1] = ch;
#line 59
    strcat((char */* __restrict  */)s___2, (char const   */* __restrict  */)(flag));
    }
  }
#line 61
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_hlp.c"
static STRARR s___1[100]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/hsc-0.934/ugly/args_hlp.c"
static STRPTR ai2str___1(struct arginfo *ai ) 
{ 


  {
  {
#line 67
  strncpy((char */* __restrict  */)(s___1), (char const   */* __restrict  */)ai->ai_id,
          (size_t )80);
  }
  {
#line 71
  if (ai->ai_type == 1L) {
#line 71
    goto case_1;
  }
#line 75
  if (ai->ai_type == 3L) {
#line 75
    goto case_3;
  }
#line 75
  if (ai->ai_type == 4L) {
#line 75
    goto case_3;
  }
#line 80
  if (ai->ai_type == (LONG )(1 << 5)) {
#line 80
    goto case_exp;
  }
#line 80
  if (ai->ai_type == 5L) {
#line 80
    goto case_exp;
  }
#line 80
  if (ai->ai_type == 2L) {
#line 80
    goto case_exp;
  }
#line 82
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 72
  strcat((char */* __restrict  */)(s___1), (char const   */* __restrict  */)"/S");
  }
#line 73
  goto switch_break;
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 76
  strcat((char */* __restrict  */)(s___1), (char const   */* __restrict  */)"/N");
  }
#line 77
  goto switch_break;
  case_exp: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 81
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 83
  strcat((char */* __restrict  */)(s___1), (char const   */* __restrict  */)"/?");
  }
#line 84
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 87
  strcat_flag___1(s___1, ai, (ULONG )1, (char )'K');
#line 88
  strcat_flag___1(s___1, ai, (ULONG )(1 << 1), (char )'A');
#line 89
  strcat_flag___1(s___1, ai, (ULONG )(1 << 2), (char )'M');
#line 90
  strcat_flag___1(s___1, ai, (ULONG )(1 << 3), (char )'C');
  }
#line 92
  return (s___1);
}
}
