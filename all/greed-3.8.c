/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 358 "/usr/include/curses.h"
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
struct score {
   char user[9] ;
   int score ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static char *version  =    (char *)"Greed v3.8";
#line 393 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) lrand48)(void) ;
#line 403
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand48)(long __seedval ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 267 "/usr/include/curses.h"
extern chtype acs_map[] ;
#line 587
extern int cbreak(void) ;
#line 611
extern int endwin(void) ;
#line 622
extern _Bool has_colors(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 634
extern int init_pair(short  , short  , short  ) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 674
extern int mvprintw(int  , int  , char const   *  , ...) ;
#line 699
extern int mvwprintw(WINDOW * , int  , int  , char const   *  , ...) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 711
extern int noecho(void) ;
#line 764
extern int start_color(void) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 799
extern int wborder(WINDOW * , chtype  , chtype  , chtype  , chtype  , chtype  , chtype  ,
                   chtype  , chtype  ) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 839
extern int wtouchln(WINDOW * , int  , int  , int  ) ;
#line 1384
extern WINDOW *curscr ;
#line 1386
extern WINDOW *stdscr ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static int grid[22][79]  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static int y  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static int x  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static _Bool allmoves  =    (_Bool)0;
#line 84 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static _Bool havebotmsg  =    (_Bool)0;
#line 85 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static int score  =    0;
#line 86 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static char *cmdname  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static WINDOW *helpwin  =    (WINDOW *)((void *)0);
#line 89
static void topscores(int newscore ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static void botmsg(char *msg , _Bool backcur ) 
{ 
  int tmp ;

  {
  {
#line 98
  tmp = wmove(stdscr, 23, 40);
  }
#line 98
  if (! (tmp == -1)) {
    {
#line 98
    waddnstr(stdscr, (char const   *)msg, -1);
    }
  }
  {
#line 99
  wclrtoeol(stdscr);
  }
#line 100
  if (backcur) {
    {
#line 101
    wmove(stdscr, y, x);
    }
  }
  {
#line 102
  wrefresh(stdscr);
#line 103
  havebotmsg = (_Bool)1;
  }
#line 104
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static void quit(int sig ) 
{ 
  int ch ;
  void (*osig)() ;
  __sighandler_t tmp ;

  {
  {
#line 115
  tmp = signal(2, (void (*)(int  ))1);
#line 115
  osig = (void (*)())tmp;
#line 116
  signal(3, (void (*)(int  ))1);
  }
#line 118
  if (stdscr) {
    {
#line 119
    botmsg((char *)"Really quit? ", (_Bool)0);
#line 120
    ch = wgetch(stdscr);
    }
#line 120
    if (ch != 121) {
#line 120
      if (ch != 89) {
        {
#line 121
        wmove(stdscr, y, x);
#line 122
        signal(2, (void (*)(int  ))osig);
#line 123
        signal(3, (void (*)(int  ))osig);
#line 124
        wrefresh(stdscr);
        }
#line 125
        return;
      }
    }
    {
#line 127
    wmove(stdscr, 23, 0);
#line 128
    wrefresh(stdscr);
#line 129
    endwin();
#line 130
    puts("\n");
#line 131
    topscores(score);
    }
  }
  {
#line 133
  exit(0);
  }
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static void out(int onsig ) 
{ 


  {
#line 142
  if (stdscr) {
    {
#line 142
    endwin();
    }
  }
  {
#line 143
  exit(0);
  }
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static void usage(void) 
{ 


  {
  {
#line 150
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-p] [-s]\n",
          cmdname);
#line 151
  exit(1);
  }
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static void showscore(void) 
{ 


  {
  {
#line 161
  mvprintw(23, 7, "%d  %.2f%%", score, (double )((float )score) / 17.38);
#line 162
  wmove(stdscr, y, x);
#line 163
  wrefresh(stdscr);
  }
#line 164
  return;
}
}
#line 166
void showmoves(_Bool on , int *attribs ) ;
#line 171
extern long time() ;
#line 199
extern int ( /* missing proto */  getpid)() ;
#line 222
int main(int argc , char **argv ) ;
#line 222 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static char *cnames  =    (char *)" bgcrmywBGCRMYW";
#line 269
int tunnel(chtype cmd , int *attribs ) ;
#line 168 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
int main(int argc , char **argv ) 
{ 
  int val ;
  int attribs[9] ;
  char *colors ;
  size_t tmp ;
  long tmp___0 ;
  int tmp___1 ;
  char *cp ;
  int tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  int newval ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 170
  val = 1;
#line 177
  cmdname = *(argv + 0);
#line 178
  if (argc == 2) {
    {
#line 179
    tmp = strlen((char const   *)*(argv + 1));
    }
#line 179
    if (tmp != 2UL) {
      {
#line 179
      usage();
      }
    } else
#line 179
    if ((int )*(*(argv + 1) + 0) != 45) {
      {
#line 179
      usage();
      }
    }
#line 180
    if ((int )*(*(argv + 1) + 1) == 115) {
      {
#line 181
      topscores(0);
#line 182
      exit(0);
      }
    }
  } else
#line 185
  if (argc > 2) {
    {
#line 186
    usage();
    }
  }
  {
#line 188
  signal(2, & quit);
#line 189
  signal(3, & quit);
#line 190
  signal(15, & out);
#line 192
  initscr();
#line 194
  keypad(stdscr, (_Bool)1);
#line 196
  cbreak();
#line 197
  noecho();
#line 199
  tmp___0 = time(0);
#line 199
  tmp___1 = getpid();
#line 199
  srand48(tmp___0 ^ (long )(tmp___1 << 16));
#line 203
  tmp___6 = has_colors();
  }
#line 203
  if (tmp___6) {
    {
#line 204
    start_color();
#line 205
    init_pair((short)1, (short)3, (short)0);
#line 206
    init_pair((short)2, (short)1, (short)0);
#line 207
    init_pair((short)3, (short)2, (short)0);
#line 208
    init_pair((short)4, (short)6, (short)0);
#line 209
    init_pair((short)5, (short)5, (short)0);
#line 211
    attribs[0] = (int )(1UL << 8);
#line 212
    attribs[1] = (int )(2UL << 8);
#line 213
    attribs[2] = (int )(3UL << 8);
#line 214
    attribs[3] = (int )(4UL << 8);
#line 215
    attribs[4] = (int )(5UL << 8);
#line 216
    attribs[5] = (int )((1UL << 8) | (1UL << 21));
#line 217
    attribs[6] = (int )((2UL << 8) | (1UL << 21));
#line 218
    attribs[7] = (int )((3UL << 8) | (1UL << 21));
#line 219
    attribs[8] = (int )((4UL << 8) | (1UL << 21));
#line 221
    colors = getenv("GREEDOPTS");
    }
#line 221
    if ((unsigned long )colors != (unsigned long )((char *)((void *)0))) {
#line 225
      cp = colors;
      {
#line 225
      while (1) {
        while_continue: /* CIL Label */ ;
#line 225
        if (*cp) {
#line 225
          if (! ((int )*cp != 58)) {
#line 225
            goto while_break;
          }
        } else {
#line 225
          goto while_break;
        }
        {
#line 226
        tmp___5 = strchr((char const   *)cnames, (int )*cp);
        }
#line 226
        if ((unsigned long )tmp___5 != (unsigned long )((char *)((void *)0))) {
#line 227
          if ((int )*cp != 32) {
            {
#line 228
            tmp___2 = tolower((int )*cp);
#line 228
            tmp___3 = strchr((char const   *)cnames, tmp___2);
#line 228
            init_pair((short )((cp - colors) + 1L), (short )(tmp___3 - cnames), (short)0);
#line 231
            attribs[cp - colors] = (int )((chtype )((cp - colors) + 1L) << 8);
#line 232
            tmp___4 = __ctype_b_loc();
            }
#line 232
            if ((int const   )*(*tmp___4 + (int )*cp) & 256) {
#line 233
              attribs[cp - colors] = (int )((unsigned long )attribs[cp - colors] | (1UL << 21));
            }
          }
        }
#line 225
        cp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 235
      if ((int )*cp == 58) {
        {
#line 236
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 236
          cp ++;
#line 236
          if (! *cp) {
#line 236
            goto while_break___0;
          }
#line 237
          if ((int )*cp == 112) {
#line 238
            allmoves = (_Bool)1;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 243
  y = 0;
  {
#line 243
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 243
    if (! (y < 22)) {
#line 243
      goto while_break___1;
    }
#line 244
    x = 0;
    {
#line 244
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 244
      if (! (x < 79)) {
#line 244
        goto while_break___2;
      }
      {
#line 246
      tmp___13 = has_colors();
      }
#line 246
      if (tmp___13) {
        {
#line 247
        tmp___7 = lrand48();
#line 247
        newval = (int )(tmp___7 % 9L + 1L);
#line 249
        wattr_on(stdscr, (attr_t )attribs[newval - 1], (void *)0);
#line 250
        tmp___9 = wmove(stdscr, y, x);
        }
#line 250
        if (! (tmp___9 == -1)) {
          {
#line 250
          tmp___8 = newval;
#line 250
          grid[y][x] = tmp___8;
#line 250
          waddch(stdscr, (chtype const   )(tmp___8 + 48));
          }
        }
        {
#line 251
        wattr_off(stdscr, (attr_t )attribs[newval - 1], (void *)0);
        }
      } else {
        {
#line 254
        tmp___12 = wmove(stdscr, y, x);
        }
#line 254
        if (! (tmp___12 == -1)) {
          {
#line 254
          tmp___11 = lrand48();
#line 254
          tmp___10 = (int )(tmp___11 % 9L + 1L);
#line 254
          grid[y][x] = tmp___10;
#line 254
          waddch(stdscr, (chtype const   )(tmp___10 + 48));
          }
        }
      }
#line 244
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 243
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 256
  tmp___14 = wmove(stdscr, 23, 0);
  }
#line 256
  if (! (tmp___14 == -1)) {
    {
#line 256
    waddnstr(stdscr, "Score: ", -1);
    }
  }
  {
#line 257
  mvprintw(23, 40, "%s - Hit \'?\' for help.", version);
#line 258
  tmp___15 = lrand48();
#line 258
  y = (int )(tmp___15 % 22L + 1L) - 1;
#line 258
  tmp___16 = lrand48();
#line 258
  x = (int )(tmp___16 % 79L + 1L) - 1;
  }
#line 259
  if (stdscr) {
#line 259
    stdscr->_attrs = 1UL << 16;
  }
  {
#line 260
  tmp___17 = wmove(stdscr, y, x);
  }
#line 260
  if (! (tmp___17 == -1)) {
    {
#line 260
    waddch(stdscr, (chtype const   )'@');
    }
  }
#line 261
  if (stdscr) {
#line 261
    stdscr->_attrs = 0UL;
  }
#line 262
  grid[y][x] = 0;
#line 264
  if (allmoves) {
    {
#line 265
    showmoves((_Bool)1, attribs);
    }
  }
  {
#line 266
  showscore();
  }
  {
#line 269
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 269
    tmp___18 = wgetch(stdscr);
#line 269
    val = tunnel(tmp___18, attribs);
    }
#line 269
    if (! (val > 0)) {
#line 269
      goto while_break___3;
    }
#line 270
    goto while_continue___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 272
  if (! val) {
    {
#line 273
    botmsg((char *)"Hit any key..", (_Bool)0);
#line 274
    wgetch(stdscr);
    }
  }
  {
#line 277
  wmove(stdscr, 23, 0);
#line 278
  wrefresh(stdscr);
#line 279
  endwin();
#line 280
  puts("\n");
#line 281
  topscores(score);
#line 282
  exit(0);
  }
}
}
#line 293
void help(void) ;
#line 360
int othermove(int bady , int badx ) ;
#line 286 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
int tunnel(chtype cmd , int *attribs ) 
{ 
  int dy ;
  int dx ;
  int distance ;
  int j ;
  int i ;
  int d ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 298
  if (cmd == 260UL) {
#line 298
    goto case_260;
  }
#line 298
  if (cmd == 52UL) {
#line 298
    goto case_260;
  }
#line 298
  if (cmd == 72UL) {
#line 298
    goto case_260;
  }
#line 298
  if (cmd == 104UL) {
#line 298
    goto case_260;
  }
#line 304
  if (cmd == 258UL) {
#line 304
    goto case_258;
  }
#line 304
  if (cmd == 50UL) {
#line 304
    goto case_258;
  }
#line 304
  if (cmd == 74UL) {
#line 304
    goto case_258;
  }
#line 304
  if (cmd == 106UL) {
#line 304
    goto case_258;
  }
#line 310
  if (cmd == 259UL) {
#line 310
    goto case_259;
  }
#line 310
  if (cmd == 56UL) {
#line 310
    goto case_259;
  }
#line 310
  if (cmd == 75UL) {
#line 310
    goto case_259;
  }
#line 310
  if (cmd == 107UL) {
#line 310
    goto case_259;
  }
#line 316
  if (cmd == 261UL) {
#line 316
    goto case_261;
  }
#line 316
  if (cmd == 54UL) {
#line 316
    goto case_261;
  }
#line 316
  if (cmd == 76UL) {
#line 316
    goto case_261;
  }
#line 316
  if (cmd == 108UL) {
#line 316
    goto case_261;
  }
#line 320
  if (cmd == 49UL) {
#line 320
    goto case_49;
  }
#line 320
  if (cmd == 66UL) {
#line 320
    goto case_49;
  }
#line 320
  if (cmd == 98UL) {
#line 320
    goto case_49;
  }
#line 323
  if (cmd == 51UL) {
#line 323
    goto case_51;
  }
#line 323
  if (cmd == 78UL) {
#line 323
    goto case_51;
  }
#line 323
  if (cmd == 110UL) {
#line 323
    goto case_51;
  }
#line 326
  if (cmd == 55UL) {
#line 326
    goto case_55;
  }
#line 326
  if (cmd == 89UL) {
#line 326
    goto case_55;
  }
#line 326
  if (cmd == 121UL) {
#line 326
    goto case_55;
  }
#line 329
  if (cmd == 57UL) {
#line 329
    goto case_57;
  }
#line 329
  if (cmd == 85UL) {
#line 329
    goto case_57;
  }
#line 329
  if (cmd == 117UL) {
#line 329
    goto case_57;
  }
#line 332
  if (cmd == 80UL) {
#line 332
    goto case_80;
  }
#line 332
  if (cmd == 112UL) {
#line 332
    goto case_80;
  }
#line 338
  if (cmd == 81UL) {
#line 338
    goto case_81;
  }
#line 338
  if (cmd == 113UL) {
#line 338
    goto case_81;
  }
#line 341
  if (cmd == 63UL) {
#line 341
    goto case_63;
  }
#line 344
  if (cmd == 18UL) {
#line 344
    goto case_18;
  }
#line 344
  if (cmd == 12UL) {
#line 344
    goto case_18;
  }
#line 346
  goto switch_default;
  case_260: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_104: /* CIL Label */ 
#line 300
  dy = 0;
#line 300
  dx = -1;
#line 301
  goto switch_break;
  case_258: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_106: /* CIL Label */ 
#line 306
  dy = 1;
#line 306
  dx = 0;
#line 307
  goto switch_break;
  case_259: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_107: /* CIL Label */ 
#line 312
  dy = -1;
#line 312
  dx = 0;
#line 313
  goto switch_break;
  case_261: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_108: /* CIL Label */ 
#line 318
  dy = 0;
#line 318
  dx = 1;
#line 319
  goto switch_break;
  case_49: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_98: /* CIL Label */ 
#line 321
  dy = 1;
#line 321
  dx = -1;
#line 322
  goto switch_break;
  case_51: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
#line 324
  dx = 1;
#line 324
  dy = dx;
#line 325
  goto switch_break;
  case_55: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
#line 327
  dx = -1;
#line 327
  dy = dx;
#line 328
  goto switch_break;
  case_57: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_117: /* CIL Label */ 
#line 330
  dy = -1;
#line 330
  dx = 1;
#line 331
  goto switch_break;
  case_80: /* CIL Label */ 
  case_112: /* CIL Label */ 
  {
#line 333
  allmoves = (_Bool )(! allmoves);
#line 334
  showmoves(allmoves, attribs);
#line 335
  wmove(stdscr, y, x);
#line 336
  wrefresh(stdscr);
  }
#line 337
  return (1);
  case_81: /* CIL Label */ 
  case_113: /* CIL Label */ 
  {
#line 339
  quit(0);
  }
#line 340
  return (1);
  case_63: /* CIL Label */ 
  {
#line 342
  help();
  }
#line 343
  return (1);
  case_18: /* CIL Label */ 
  case_12: /* CIL Label */ 
  {
#line 345
  wrefresh(curscr);
  }
  switch_default: /* CIL Label */ 
#line 347
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 349
  if (y + dy >= 0) {
#line 349
    if (x + dx >= 0) {
#line 349
      if (y + dy < 22) {
#line 349
        if (x + dx < 79) {
#line 349
          distance = grid[y + dy][x + dx];
        } else {
#line 349
          distance = 0;
        }
      } else {
#line 349
        distance = 0;
      }
    } else {
#line 349
      distance = 0;
    }
  } else {
#line 349
    distance = 0;
  }
#line 353
  j = y;
#line 353
  i = x;
#line 353
  d = distance;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    j += dy;
#line 357
    i += dx;
#line 358
    if (j >= 0) {
#line 358
      if (i >= 0) {
#line 358
        if (j < 22) {
#line 358
          if (i < 79) {
#line 358
            if (grid[j][i]) {
#line 359
              goto __Cont;
            } else {
#line 358
              goto _L___2;
            }
          } else {
#line 358
            goto _L___2;
          }
        } else {
#line 358
          goto _L___2;
        }
      } else {
#line 358
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 360
      tmp___2 = othermove(dy, dx);
      }
#line 360
      if (tmp___2) {
        {
#line 374
        botmsg((char *)"Bad move.", (_Bool)1);
        }
#line 375
        return (1);
      } else {
        {
#line 361
        j -= dy;
#line 362
        i -= dx;
#line 363
        tmp = wmove(stdscr, y, x);
        }
#line 363
        if (! (tmp == -1)) {
          {
#line 363
          waddch(stdscr, (chtype const   )' ');
          }
        }
        {
#line 364
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 364
          if (! (y != j)) {
#line 364
            if (! (x != i)) {
#line 364
              goto while_break___0;
            }
          }
          {
#line 365
          y += dy;
#line 366
          x += dx;
#line 367
          score ++;
#line 368
          tmp___0 = wmove(stdscr, y, x);
          }
#line 368
          if (! (tmp___0 == -1)) {
            {
#line 368
            waddch(stdscr, (chtype const   )' ');
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 370
        tmp___1 = wmove(stdscr, y, x);
        }
#line 370
        if (! (tmp___1 == -1)) {
          {
#line 370
          waddch(stdscr, (chtype const   )'*');
          }
        }
        {
#line 371
        showscore();
        }
#line 372
        return (0);
      }
    }
    __Cont: /* CIL Label */ 
#line 355
    d --;
#line 355
    if (! d) {
#line 355
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  if (allmoves) {
    {
#line 382
    showmoves((_Bool)0, attribs);
    }
  }
#line 384
  if (havebotmsg) {
    {
#line 385
    mvprintw(23, 40, "%s - Hit \'?\' for help.", version);
#line 386
    havebotmsg = (_Bool)0;
    }
  }
  {
#line 389
  tmp___3 = wmove(stdscr, y, x);
  }
#line 389
  if (! (tmp___3 == -1)) {
    {
#line 389
    waddch(stdscr, (chtype const   )' ');
    }
  }
  {
#line 390
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 391
    y += dy;
#line 392
    x += dx;
#line 393
    score ++;
#line 394
    grid[y][x] = 0;
#line 395
    tmp___4 = wmove(stdscr, y, x);
    }
#line 395
    if (! (tmp___4 == -1)) {
      {
#line 395
      waddch(stdscr, (chtype const   )' ');
      }
    }
#line 390
    distance --;
#line 390
    if (! distance) {
#line 390
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 397
  if (stdscr) {
#line 397
    stdscr->_attrs = 1UL << 16;
  }
  {
#line 398
  tmp___5 = wmove(stdscr, y, x);
  }
#line 398
  if (! (tmp___5 == -1)) {
    {
#line 398
    waddch(stdscr, (chtype const   )'@');
    }
  }
#line 399
  if (stdscr) {
#line 399
    stdscr->_attrs = 0UL;
  }
#line 400
  if (allmoves) {
    {
#line 401
    showmoves((_Bool)1, attribs);
    }
  }
  {
#line 402
  showscore();
  }
#line 403
  return (1);
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
int othermove(int bady , int badx ) 
{ 
  int dy ;
  int dx ;
  int j ;
  int i ;
  int d ;

  {
#line 414
  dy = -1;
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (! (dy <= 1)) {
#line 416
      goto while_break;
    }
#line 417
    dx = -1;
    {
#line 417
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 417
      if (! (dx <= 1)) {
#line 417
        goto while_break___0;
      }
#line 418
      if (! dy) {
#line 418
        if (! dx) {
#line 421
          goto __Cont;
        } else {
#line 418
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 418
      if (dy == bady) {
#line 418
        if (dx == badx) {
#line 421
          goto __Cont;
        } else {
#line 418
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 418
      if (y + dy < 0) {
#line 418
        if (x + dx < 0) {
#line 418
          if (y + dy >= 22) {
#line 418
            if (x + dx >= 79) {
#line 421
              goto __Cont;
            } else {
#line 418
              goto _L___1;
            }
          } else {
#line 418
            goto _L___1;
          }
        } else {
#line 418
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 423
        j = y;
#line 423
        i = x;
#line 423
        d = grid[y + dy][x + dx];
#line 425
        if (! d) {
#line 425
          goto __Cont;
        }
        {
#line 426
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 427
          j += dy;
#line 428
          i += dx;
#line 429
          if (j < 0) {
#line 430
            goto while_break___1;
          } else
#line 429
          if (i < 0) {
#line 430
            goto while_break___1;
          } else
#line 429
          if (j >= 22) {
#line 430
            goto while_break___1;
          } else
#line 429
          if (i >= 79) {
#line 430
            goto while_break___1;
          } else
#line 429
          if (! grid[j][i]) {
#line 430
            goto while_break___1;
          }
#line 426
          d --;
#line 426
          if (! d) {
#line 426
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 432
        if (! d) {
#line 432
          return (1);
        }
      }
      __Cont: /* CIL Label */ 
#line 417
      dx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 416
    dy ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (0);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
void showmoves(_Bool on , int *attribs ) 
{ 
  int dy ;
  int dx ;
  int j ;
  int i ;
  int d ;
  int j___0 ;
  int i___0 ;
  int d___0 ;
  int newval ;
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
#line 444
  dy = -1;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (! (dy <= 1)) {
#line 446
      goto while_break;
    }
#line 447
    if (y + dy < 0) {
#line 447
      goto __Cont;
    } else
#line 447
    if (y + dy >= 22) {
#line 447
      goto __Cont;
    }
#line 448
    dx = -1;
    {
#line 448
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 448
      if (! (dx <= 1)) {
#line 448
        goto while_break___0;
      }
#line 449
      j = y;
#line 449
      i = x;
#line 449
      d = grid[y + dy][x + dx];
#line 451
      if (! d) {
#line 451
        goto __Cont___0;
      }
      {
#line 452
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 453
        j += dy;
#line 454
        i += dx;
#line 455
        if (j < 0) {
#line 456
          goto while_break___1;
        } else
#line 455
        if (i < 0) {
#line 456
          goto while_break___1;
        } else
#line 455
        if (j >= 22) {
#line 456
          goto while_break___1;
        } else
#line 455
        if (i >= 79) {
#line 456
          goto while_break___1;
        } else
#line 455
        if (! grid[j][i]) {
#line 456
          goto while_break___1;
        }
#line 452
        d --;
#line 452
        if (! d) {
#line 452
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 458
      if (! d) {
#line 459
        j___0 = y;
#line 459
        i___0 = x;
#line 459
        d___0 = grid[y + dy][x + dx];
#line 465
        if (on) {
#line 466
          if (stdscr) {
#line 466
            stdscr->_attrs = 1UL << 16;
          }
        }
        {
#line 467
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 468
          j___0 += dy;
#line 469
          i___0 += dx;
#line 471
          if (! on) {
            {
#line 471
            tmp___1 = has_colors();
            }
#line 471
            if (tmp___1) {
              {
#line 472
              newval = grid[j___0][i___0];
#line 473
              wattr_on(stdscr, (attr_t )*(attribs + (newval - 1)), (void *)0);
#line 474
              tmp = wmove(stdscr, j___0, i___0);
              }
#line 474
              if (! (tmp == -1)) {
                {
#line 474
                waddch(stdscr, (chtype const   )(newval + 48));
                }
              }
              {
#line 475
              wattr_off(stdscr, (attr_t )*(attribs + (newval - 1)), (void *)0);
              }
            } else {
#line 471
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 479
            tmp___0 = wmove(stdscr, j___0, i___0);
            }
#line 479
            if (! (tmp___0 == -1)) {
              {
#line 479
              waddch(stdscr, (chtype const   )(grid[j___0][i___0] + 48));
              }
            }
          }
#line 467
          d___0 --;
#line 467
          if (! d___0) {
#line 467
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 481
        if (on) {
#line 481
          if (stdscr) {
#line 481
            stdscr->_attrs = 0UL;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 448
      dx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 446
    dy ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
char doputc(char c ) 
{ 
  int tmp ;

  {
  {
#line 490
  tmp = fputc((int )c, stdout);
  }
#line 490
  return ((char )tmp);
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static char termbuf[8192]  ;
#line 505
extern char *tgetstr() ;
#line 506
void lockit(_Bool on ) ;
#line 525
extern int ( /* missing proto */  read)() ;
#line 540
extern int ( /* missing proto */  getuid)() ;
#line 541
extern int ( /* missing proto */  lseek)() ;
#line 542
extern int ( /* missing proto */  write)() ;
#line 546
extern int ( /* missing proto */  close)() ;
#line 554
extern int ( /* missing proto */  tgetent)() ;
#line 566
extern int ( /* missing proto */  tputs)() ;
#line 493 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
static void topscores(int newscore ) 
{ 
  int fd ;
  int count ;
  char *tptr ;
  void *tmp ;
  char *boldon ;
  char *boldoff ;
  struct score *toplist ;
  void *tmp___0 ;
  struct score *ptrtmp ;
  struct score *eof ;
  struct score *new ;
  int tmp___1 ;
  struct passwd *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 500
  count = 1;
#line 502
  tmp = malloc((size_t )16);
#line 502
  tptr = (char *)tmp;
#line 503
  tmp___0 = malloc(10UL * sizeof(struct score ));
#line 503
  toplist = (struct score *)tmp___0;
#line 504
  eof = toplist + 10;
#line 504
  new = (struct score *)((void *)0);
#line 508
  signal(2, (void (*)(int  ))1);
#line 509
  signal(3, (void (*)(int  ))1);
#line 510
  signal(15, (void (*)(int  ))1);
#line 511
  signal(1, (void (*)(int  ))1);
#line 516
  fd = open("/var/games/greed/greed.hs", 66, 384);
  }
#line 516
  if (fd == -1) {
    {
#line 517
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: Cannot open.\n",
            cmdname, "/var/games/greed/greed.hs");
#line 519
    exit(1);
    }
  }
  {
#line 522
  lockit((_Bool)1);
#line 523
  ptrtmp = toplist;
  }
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! ((unsigned long )ptrtmp < (unsigned long )eof)) {
#line 523
      goto while_break;
    }
#line 523
    ptrtmp->score = 0;
#line 523
    ptrtmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 525
  read(fd, toplist, 10UL * sizeof(struct score ));
  }
#line 527
  if (newscore) {
#line 528
    ptrtmp = toplist;
    {
#line 528
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 528
      if (! ((unsigned long )ptrtmp < (unsigned long )eof)) {
#line 528
        goto while_break___0;
      }
#line 530
      if (newscore > ptrtmp->score) {
#line 530
        goto while_break___0;
      }
#line 528
      ptrtmp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 531
    if ((unsigned long )ptrtmp < (unsigned long )eof) {
#line 532
      new = ptrtmp;
#line 533
      ptrtmp = eof - 1;
      {
#line 534
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 534
        if (! ((unsigned long )ptrtmp > (unsigned long )new)) {
#line 534
          goto while_break___1;
        }
#line 535
        *ptrtmp = *(ptrtmp - 1);
#line 536
        ptrtmp --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 539
      new->score = newscore;
#line 540
      tmp___1 = getuid();
#line 540
      tmp___2 = getpwuid((__uid_t )tmp___1);
#line 540
      strncpy((char */* __restrict  */)(new->user), (char const   */* __restrict  */)tmp___2->pw_name,
              (size_t )8);
#line 541
      lseek(fd, 0, 0);
#line 542
      write(fd, toplist, 10UL * sizeof(struct score ));
      }
    }
  }
  {
#line 546
  close(fd);
#line 547
  lockit((_Bool)0);
  }
#line 549
  if (toplist->score) {
    {
#line 550
    puts("Rank  Score  Name     Percentage");
    }
  } else {
    {
#line 552
    puts("No high scores.");
    }
  }
#line 554
  if (new) {
    {
#line 554
    tmp___3 = getenv("TERM");
#line 554
    tmp___4 = tgetent(termbuf, tmp___3);
    }
#line 554
    if (tmp___4 > 0) {
      {
#line 556
      boldon = tgetstr("so", & tptr);
#line 557
      boldoff = tgetstr("se", & tptr);
      }
#line 559
      if ((unsigned long )boldon == (unsigned long )((void *)0)) {
#line 560
        boldoff = (char *)((void *)0);
#line 560
        boldon = boldoff;
      } else
#line 559
      if ((unsigned long )boldoff == (unsigned long )((void *)0)) {
#line 560
        boldoff = (char *)((void *)0);
#line 560
        boldon = boldoff;
      }
    }
  }
#line 564
  ptrtmp = toplist;
  {
#line 564
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 564
    if ((unsigned long )ptrtmp < (unsigned long )eof) {
#line 564
      if (! ptrtmp->score) {
#line 564
        goto while_break___2;
      }
    } else {
#line 564
      goto while_break___2;
    }
#line 565
    if ((unsigned long )ptrtmp == (unsigned long )new) {
#line 565
      if (boldon) {
        {
#line 566
        tputs(boldon, 1, & doputc);
        }
      }
    }
    {
#line 567
    printf((char const   */* __restrict  */)"%-5d %-6d %-8s %.2f%%\n", count, ptrtmp->score,
           ptrtmp->user, (double )((float )ptrtmp->score) / 17.38);
    }
#line 569
    if ((unsigned long )ptrtmp == (unsigned long )new) {
#line 569
      if (boldoff) {
        {
#line 569
        tputs(boldoff, 1, & doputc);
        }
      }
    }
#line 564
    ptrtmp ++;
#line 564
    count ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 571
  return;
}
}
#line 590
extern int ( /* missing proto */  unlink)() ;
#line 597
extern int ( /* missing proto */  sleep)() ;
#line 574 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
void lockit(_Bool on ) 
{ 
  int fd ;
  int x___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 583
  x___0 = 1;
#line 585
  if (on) {
    {
#line 586
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 586
      fd = open("/tmp/Greed.lock", 194, 0);
      }
#line 586
      if (! (fd < 0)) {
#line 586
        goto while_break;
      }
      {
#line 587
      printf((char const   */* __restrict  */)"Waiting for scorefile access... %d/15\n",
             x___0);
#line 588
      tmp___0 = x___0;
#line 588
      x___0 ++;
      }
#line 588
      if (tmp___0 >= 15) {
        {
#line 589
        puts("Overriding stale lock...");
#line 590
        tmp = unlink("/tmp/Greed.lock");
        }
#line 590
        if (tmp == -1) {
          {
#line 591
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: Can\'t unlink lock.\n",
                  cmdname, "/tmp/Greed.lock");
#line 594
          exit(1);
          }
        }
      }
      {
#line 597
      sleep(1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 599
    close(fd);
    }
  } else {
    {
#line 600
    unlink("/tmp/Greed.lock");
    }
  }
#line 601
  return;
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/greed-3.8/greed.c"
void help(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 611
  if (! helpwin) {
    {
#line 612
    helpwin = newwin(18, 65, 1, 7);
#line 614
    wborder(helpwin, acs_map[(unsigned char )'x'], acs_map[(unsigned char )'x'], acs_map[(unsigned char )'q'],
            acs_map[(unsigned char )'q'], (chtype )0, (chtype )0, (chtype )0, (chtype )0);
#line 616
    waddch(helpwin, (chtype const   )acs_map[(unsigned char )'l']);
#line 617
    tmp = wmove(helpwin, 0, 64);
    }
#line 617
    if (! (tmp == -1)) {
      {
#line 617
      waddch(helpwin, (chtype const   )acs_map[(unsigned char )'k']);
      }
    }
    {
#line 618
    tmp___0 = wmove(helpwin, 17, 0);
    }
#line 618
    if (! (tmp___0 == -1)) {
      {
#line 618
      waddch(helpwin, (chtype const   )acs_map[(unsigned char )'m']);
      }
    }
    {
#line 619
    tmp___1 = wmove(helpwin, 17, 64);
    }
#line 619
    if (! (tmp___1 == -1)) {
      {
#line 619
      waddch(helpwin, (chtype const   )acs_map[(unsigned char )'j']);
      }
    }
    {
#line 627
    mvwprintw(helpwin, 1, 2, "Welcome to %s, by Matthew Day <mday@iconsys.uu.net>.",
              version);
#line 629
    tmp___2 = wmove(helpwin, 3, 2);
    }
#line 629
    if (! (tmp___2 == -1)) {
      {
#line 629
      waddnstr(helpwin, " The object of Greed is to erase as much of the screen as",
               -1);
      }
    }
    {
#line 630
    tmp___3 = wmove(helpwin, 4, 2);
    }
#line 630
    if (! (tmp___3 == -1)) {
      {
#line 630
      waddnstr(helpwin, " possible by moving around in a grid of numbers.  To move",
               -1);
      }
    }
    {
#line 631
    tmp___4 = wmove(helpwin, 5, 2);
    }
#line 631
    if (! (tmp___4 == -1)) {
      {
#line 631
      waddnstr(helpwin, " your cursor, simply use the \'hjklyubn\' keys or your number",
               -1);
      }
    }
    {
#line 632
    mvwprintw(helpwin, 6, 2, " keypad.  Your location is signified by the \'%c\' symbol.",
              '@');
#line 634
    tmp___5 = wmove(helpwin, 7, 2);
    }
#line 634
    if (! (tmp___5 == -1)) {
      {
#line 634
      waddnstr(helpwin, " When you move in a direction, you erase N number of grid",
               -1);
      }
    }
    {
#line 635
    tmp___6 = wmove(helpwin, 8, 2);
    }
#line 635
    if (! (tmp___6 == -1)) {
      {
#line 635
      waddnstr(helpwin, " squares in that direction, N being the first number in that",
               -1);
      }
    }
    {
#line 636
    tmp___7 = wmove(helpwin, 9, 2);
    }
#line 636
    if (! (tmp___7 == -1)) {
      {
#line 636
      waddnstr(helpwin, " direction.  Your score reflects the total number of squares",
               -1);
      }
    }
    {
#line 637
    tmp___8 = wmove(helpwin, 10, 2);
    }
#line 637
    if (! (tmp___8 == -1)) {
      {
#line 637
      waddnstr(helpwin, " eaten.  Greed will not let you make a move that would have",
               -1);
      }
    }
    {
#line 638
    tmp___9 = wmove(helpwin, 11, 2);
    }
#line 638
    if (! (tmp___9 == -1)) {
      {
#line 638
      waddnstr(helpwin, " placed you off the grid or over a previously eaten square",
               -1);
      }
    }
    {
#line 639
    tmp___10 = wmove(helpwin, 12, 2);
    }
#line 639
    if (! (tmp___10 == -1)) {
      {
#line 639
      waddnstr(helpwin, " unless no valid moves exist, in which case your game ends.",
               -1);
      }
    }
    {
#line 640
    tmp___11 = wmove(helpwin, 13, 2);
    }
#line 640
    if (! (tmp___11 == -1)) {
      {
#line 640
      waddnstr(helpwin, " Other Greed commands are \'Ctrl-L\' to redraw the screen,",
               -1);
      }
    }
    {
#line 641
    tmp___12 = wmove(helpwin, 14, 2);
    }
#line 641
    if (! (tmp___12 == -1)) {
      {
#line 641
      waddnstr(helpwin, " \'p\' to toggle the highlighting of the possible moves, and",
               -1);
      }
    }
    {
#line 642
    tmp___13 = wmove(helpwin, 15, 2);
    }
#line 642
    if (! (tmp___13 == -1)) {
      {
#line 642
      waddnstr(helpwin, " \'q\' to quit.  Command line options to Greed are \'-s\' to",
               -1);
      }
    }
    {
#line 643
    tmp___14 = wmove(helpwin, 16, 2);
    }
#line 643
    if (! (tmp___14 == -1)) {
      {
#line 643
      waddnstr(helpwin, " output the high score file.", -1);
      }
    }
    {
#line 645
    wmove(helpwin, 17, 64);
#line 646
    wrefresh(helpwin);
    }
  } else {
#line 648
    if (helpwin) {
#line 648
      tmp___15 = (int )helpwin->_maxy + 1;
    } else {
#line 648
      tmp___15 = -1;
    }
    {
#line 648
    wtouchln(helpwin, 0, tmp___15, 1);
#line 649
    wrefresh(helpwin);
    }
  }
  {
#line 651
  wgetch(helpwin);
  }
#line 652
  if (stdscr) {
#line 652
    tmp___16 = (int )stdscr->_maxy + 1;
  } else {
#line 652
    tmp___16 = -1;
  }
  {
#line 652
  wtouchln(stdscr, 0, tmp___16, 1);
#line 653
  wrefresh(stdscr);
  }
#line 654
  return;
}
}
