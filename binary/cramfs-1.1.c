/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 6 "./linux/cramfs_fs.h"
typedef unsigned char u8;
#line 8 "./linux/cramfs_fs.h"
typedef unsigned int u32;
#line 35 "./linux/cramfs_fs.h"
struct cramfs_inode {
   u32 mode : 16 ;
   u32 uid : 16 ;
   u32 size : 24 ;
   u32 gid : 8 ;
   u32 namelen : 6 ;
   u32 offset : 26 ;
};
#line 50 "./linux/cramfs_fs.h"
struct cramfs_info {
   u32 crc ;
   u32 edition ;
   u32 blocks ;
   u32 files ;
};
#line 60 "./linux/cramfs_fs.h"
struct cramfs_super {
   u32 magic ;
   u32 size ;
   u32 flags ;
   u32 future ;
   u8 signature[16] ;
   struct cramfs_info fsid ;
   u8 name[16] ;
   struct cramfs_inode root ;
};
#line 368 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned char Byte;
#line 370 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned int uInt;
#line 371 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned long uLong;
#line 377 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef Byte Bytef;
#line 382 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef uLong uLongf;
#line 98 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
struct entry {
   unsigned char *name ;
   unsigned int mode ;
   unsigned int size ;
   unsigned int uid ;
   unsigned int gid ;
   char *path ;
   int fd ;
   void *uncompressed ;
   struct entry *same ;
   unsigned int offset ;
   unsigned int dir_offset ;
   struct entry *child ;
   struct entry *next ;
};
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 386 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef void *voidpf;
#line 83 "/usr/include/zlib.h"
struct internal_state;
#line 85 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 85 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 106 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1742 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 27 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 30
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 254 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  __dir ,
                                                        struct dirent *** __restrict  __namelist ,
                                                        int (*__selector)(struct dirent  const  * ) ,
                                                        int (*__cmp)(struct dirent  const  ** ,
                                                                     struct dirent  const  ** ) ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 1174 "/usr/include/zlib.h"
extern int compress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ,
                     int level ) ;
#line 1600
extern uLong crc32(uLong crc , Bytef const   *buf , uInt len ) ;
#line 1746
extern char const   *zError(int  ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static char const   *progname  =    "mkcramfs";
#line 73 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static unsigned int blksize  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static long total_blocks  =    0L;
#line 74 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static long total_nodes  =    1L;
#line 75 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int image_length  =    0;
#line 87 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static u32 opt_edition  =    (u32 )0;
#line 88 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int opt_errors  =    0;
#line 89 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int opt_holes  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int opt_pad  =    0;
#line 91 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int opt_verbose  =    0;
#line 92 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static char *opt_image  =    (char *)((void *)0);
#line 93 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static char *opt_name  =    (char *)((void *)0);
#line 95 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int warn_dev  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int warn_gid  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int warn_namelen  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int warn_skip  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int warn_size  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int warn_uid  ;
#line 120 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static void usage(int status ) 
{ 
  FILE *stream___0 ;
  struct _IO_FILE *tmp ;

  {
#line 122
  if (status) {
#line 122
    tmp = stderr;
  } else {
#line 122
    tmp = stdout;
  }
  {
#line 122
  stream___0 = tmp;
#line 124
  fprintf((FILE */* __restrict  */)stream___0, (char const   */* __restrict  */)"usage: %s [-h] [-b blksize] [-e edition] [-i file] [-n name] dirname outfile\n -h         print this help\n -E         make all warnings errors (non-zero exit status)\n -b blksize blocksize to use\n -e edition set edition number (part of fsid)\n -i file    insert a file image into the filesystem (requires >= 2.4.0)\n -n name    set name of cramfs filesystem\n -p         pad by %d bytes for boot code\n -s         sort directory entries (old option, ignored)\n -v         be more verbose\n -z         make explicit holes (requires >= 2.3.39)\n dirname    root of the directory tree to be compressed\n outfile    output file\n",
          progname, 512);
#line 138
  exit(status);
  }
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static void die(int status , int syserr , char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;
  int save ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 144
  tmp = __errno_location();
#line 144
  save = *tmp;
#line 146
  fflush((FILE *)0);
#line 147
  __builtin_va_start(arg_ptr, fmt);
#line 148
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname);
#line 149
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           arg_ptr);
  }
#line 150
  if (syserr) {
    {
#line 151
    tmp___0 = strerror(save);
#line 151
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp___0);
    }
  }
  {
#line 153
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 154
  __builtin_va_end(arg_ptr);
#line 155
  exit(status);
  }
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static void map_entry(struct entry *entry ) 
{ 


  {
#line 160
  if (entry->path) {
    {
#line 161
    entry->fd = open((char const   *)entry->path, 0);
    }
#line 162
    if (entry->fd < 0) {
      {
#line 163
      die(8, 1, "open failed: %s", entry->path);
      }
    }
    {
#line 165
    entry->uncompressed = mmap((void *)0, (size_t )entry->size, 1, 2, entry->fd, (__off_t )0);
    }
#line 166
    if ((unsigned long )entry->uncompressed == (unsigned long )((void *)-1)) {
      {
#line 167
      die(8, 1, "mmap failed: %s", entry->path);
      }
    }
  }
#line 170
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static void unmap_entry(struct entry *entry ) 
{ 
  int tmp ;

  {
#line 174
  if (entry->path) {
    {
#line 175
    tmp = munmap(entry->uncompressed, (size_t )entry->size);
    }
#line 175
    if (tmp < 0) {
      {
#line 176
      die(8, 1, "munmap failed: %s", entry->path);
      }
    }
    {
#line 178
    close(entry->fd);
    }
  }
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int find_identical_file(struct entry *orig , struct entry *newfile ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 184
  if ((unsigned long )orig == (unsigned long )newfile) {
#line 185
    return (1);
  }
#line 186
  if (! orig) {
#line 187
    return (0);
  }
#line 188
  if (orig->size == newfile->size) {
#line 188
    if (orig->path) {
#line 188
      goto _L;
    } else
#line 188
    if (orig->uncompressed) {
      _L: /* CIL Label */ 
      {
#line 190
      map_entry(orig);
#line 191
      map_entry(newfile);
#line 192
      tmp = memcmp((void const   *)orig->uncompressed, (void const   *)newfile->uncompressed,
                   (size_t )orig->size);
      }
#line 192
      if (! tmp) {
        {
#line 194
        newfile->same = orig;
#line 195
        unmap_entry(newfile);
#line 196
        unmap_entry(orig);
        }
#line 197
        return (1);
      }
      {
#line 199
      unmap_entry(newfile);
#line 200
      unmap_entry(orig);
      }
    }
  }
  {
#line 202
  tmp___0 = find_identical_file(orig->child, newfile);
  }
#line 202
  if (tmp___0) {
#line 202
    tmp___2 = 1;
  } else {
    {
#line 202
    tmp___1 = find_identical_file(orig->next, newfile);
    }
#line 202
    if (tmp___1) {
#line 202
      tmp___2 = 1;
    } else {
#line 202
      tmp___2 = 0;
    }
  }
#line 202
  return (tmp___2);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static void eliminate_doubles(struct entry *root , struct entry *orig ) 
{ 


  {
#line 207
  if (orig) {
#line 208
    if (orig->size) {
#line 208
      if (orig->path) {
        {
#line 209
        find_identical_file(root, orig);
        }
      } else
#line 208
      if (orig->uncompressed) {
        {
#line 209
        find_identical_file(root, orig);
        }
      }
    }
    {
#line 210
    eliminate_doubles(root, orig->child);
#line 211
    eliminate_doubles(root, orig->next);
    }
  }
#line 213
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int cramsort(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 221
  tmp = strcmp((char const   *)((*((struct dirent  const  **)a))->d_name), (char const   *)((*((struct dirent  const  **)b))->d_name));
  }
#line 221
  return (tmp);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static unsigned int parse_directory(struct entry *root_entry , char const   *name ,
                                    struct entry **prev , loff_t *fslen_ub ) 
{ 
  struct dirent **dirlist ;
  int totalsize ;
  int dircount ;
  int dirindex ;
  char *path ;
  char *endpath ;
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;
  struct dirent *dirent ;
  struct entry *entry ;
  struct stat st ;
  int size ;
  size_t namelen ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int len___0 ;
  ssize_t tmp___5 ;
  int blocks ;

  {
  {
#line 228
  totalsize = 0;
#line 230
  tmp = strlen(name);
#line 230
  len = tmp;
#line 234
  tmp___0 = malloc(((len + 1UL) + 255UL) + 1UL);
#line 234
  path = (char *)tmp___0;
  }
#line 235
  if (! path) {
    {
#line 236
    die(8, 1, "malloc failed");
    }
  }
  {
#line 238
  memcpy((void */* __restrict  */)path, (void const   */* __restrict  */)name, len);
#line 239
  endpath = path + len;
#line 240
  *endpath = (char )'/';
#line 241
  endpath ++;
#line 244
  dircount = scandir((char const   */* __restrict  */)name, (struct dirent ***/* __restrict  */)(& dirlist),
                     (int (*)(struct dirent  const  * ))0, (int (*)(struct dirent  const  ** ,
                                                                    struct dirent  const  ** ))(& cramsort));
  }
#line 246
  if (dircount < 0) {
    {
#line 247
    die(8, 1, "scandir failed: %s", name);
    }
  }
#line 251
  dirindex = 0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (dirindex < dircount)) {
#line 251
      goto while_break;
    }
#line 258
    dirent = *(dirlist + dirindex);
#line 261
    if ((int )dirent->d_name[0] == 46) {
#line 262
      if ((int )dirent->d_name[1] == 0) {
#line 263
        goto __Cont;
      }
#line 264
      if ((int )dirent->d_name[1] == 46) {
#line 265
        if ((int )dirent->d_name[2] == 0) {
#line 266
          goto __Cont;
        }
      }
    }
    {
#line 269
    namelen = strlen((char const   *)(dirent->d_name));
    }
#line 270
    if (namelen > 255UL) {
      {
#line 271
      die(8, 0, "very long (%u bytes) filename found: %s\nplease increase MAX_INPUT_NAMELEN in mkcramfs.c and recompile",
          namelen, dirent->d_name);
      }
    }
    {
#line 276
    memcpy((void */* __restrict  */)endpath, (void const   */* __restrict  */)(dirent->d_name),
           namelen + 1UL);
#line 278
    tmp___1 = lstat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
    }
#line 278
    if (tmp___1 < 0) {
#line 279
      warn_skip = 1;
#line 280
      goto __Cont;
    }
    {
#line 282
    tmp___2 = calloc((size_t )1, sizeof(struct entry ));
#line 282
    entry = (struct entry *)tmp___2;
    }
#line 283
    if (! entry) {
      {
#line 284
      die(8, 1, "calloc failed");
      }
    }
    {
#line 286
    tmp___3 = strdup((char const   *)(dirent->d_name));
#line 286
    entry->name = (unsigned char *)tmp___3;
    }
#line 287
    if (! entry->name) {
      {
#line 288
      die(8, 1, "strdup failed");
      }
    }
#line 291
    if (namelen > (size_t )(((1 << 6) - 1) << 2)) {
#line 292
      namelen = (size_t )(((1 << 6) - 1) << 2);
#line 293
      warn_namelen = 1;
      {
#line 295
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 295
        if (! (((int )*(entry->name + namelen) & 192) == 128)) {
#line 295
          goto while_break___0;
        }
#line 296
        namelen --;
#line 298
        if ((int )*(entry->name + namelen) < 128) {
          {
#line 299
          die(8, 0, "cannot truncate filenames not encoded in UTF-8");
          }
        } else
#line 298
        if (! namelen) {
          {
#line 299
          die(8, 0, "cannot truncate filenames not encoded in UTF-8");
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 302
      *(entry->name + namelen) = (unsigned char )'\000';
    }
#line 304
    entry->mode = st.st_mode;
#line 305
    entry->size = (unsigned int )st.st_size;
#line 306
    entry->uid = st.st_uid;
#line 307
    if (entry->uid >= (unsigned int )(1 << 16)) {
#line 308
      warn_uid = 1;
    }
#line 309
    entry->gid = st.st_gid;
#line 310
    if (entry->gid >= (unsigned int )(1 << 8)) {
#line 316
      warn_gid = 1;
    }
#line 317
    size = (int )(sizeof(struct cramfs_inode ) + ((namelen + 3UL) & 0xfffffffffffffffcUL));
#line 318
    *fslen_ub += (loff_t )size;
#line 319
    if ((st.st_mode & 61440U) == 16384U) {
      {
#line 320
      entry->size = parse_directory(root_entry, (char const   *)path, & entry->child,
                                    fslen_ub);
      }
    } else
#line 321
    if ((st.st_mode & 61440U) == 32768U) {
#line 322
      if (entry->size) {
        {
#line 323
        tmp___4 = access((char const   *)path, 4);
        }
#line 323
        if (tmp___4 < 0) {
#line 324
          warn_skip = 1;
#line 325
          goto __Cont;
        }
        {
#line 327
        entry->path = strdup((char const   *)path);
        }
#line 328
        if (! entry->path) {
          {
#line 329
          die(8, 1, "strdup failed");
          }
        }
#line 331
        if (entry->size >= (unsigned int )(1 << 24)) {
#line 332
          warn_size = 1;
#line 333
          entry->size = (unsigned int )((1 << 24) - 1);
        }
      }
    } else
#line 336
    if ((st.st_mode & 61440U) == 40960U) {
      {
#line 338
      entry->uncompressed = malloc((size_t )entry->size);
      }
#line 339
      if (! entry->uncompressed) {
        {
#line 340
        die(8, 1, "malloc failed");
        }
      }
      {
#line 342
      tmp___5 = readlink((char const   */* __restrict  */)path, (char */* __restrict  */)entry->uncompressed,
                         (size_t )entry->size);
#line 342
      len___0 = (int )tmp___5;
      }
#line 343
      if (len___0 < 0) {
#line 344
        warn_skip = 1;
#line 345
        goto __Cont;
      }
#line 347
      entry->size = (unsigned int )len___0;
    } else
#line 348
    if ((st.st_mode & 61440U) == 4096U) {
#line 350
      entry->size = 0U;
    } else
#line 348
    if ((st.st_mode & 61440U) == 49152U) {
#line 350
      entry->size = 0U;
    } else
#line 351
    if ((st.st_mode & 61440U) == 8192U) {
#line 351
      goto _L;
    } else
#line 351
    if ((st.st_mode & 61440U) == 24576U) {
      _L: /* CIL Label */ 
#line 352
      entry->size = (unsigned int )st.st_rdev;
#line 353
      if (entry->size & (unsigned int )(- (1 << 24))) {
#line 354
        warn_dev = 1;
      }
    } else {
      {
#line 356
      die(8, 0, "bogus file type: %s", entry->name);
      }
    }
#line 359
    if ((st.st_mode & 61440U) == 32768U) {
#line 359
      goto _L___0;
    } else
#line 359
    if ((st.st_mode & 61440U) == 40960U) {
      _L___0: /* CIL Label */ 
#line 360
      blocks = (int )((entry->size - 1U) / blksize + 1U);
#line 363
      if (entry->size) {
#line 364
        *fslen_ub += (loff_t )(((unsigned int )(30 * blocks) + entry->size) + 3U);
      }
    }
#line 368
    *prev = entry;
#line 369
    prev = & entry->next;
#line 370
    totalsize += size;
    __Cont: /* CIL Label */ 
#line 251
    dirindex ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 372
  free((void *)path);
#line 373
  free((void *)dirlist);
  }
#line 374
  return ((unsigned int )totalsize);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static unsigned int write_superblock(struct entry *root , char *base , int size ) 
{ 
  struct cramfs_super *super___0 ;
  unsigned int offset ;
  uLong tmp ;

  {
#line 380
  super___0 = (struct cramfs_super *)base;
#line 381
  offset = (unsigned int )(sizeof(struct cramfs_super ) + (unsigned long )image_length);
#line 383
  offset += (unsigned int )opt_pad;
#line 385
  super___0->magic = (u32 )684539205;
#line 386
  super___0->flags = (u32 )3;
#line 387
  if (opt_holes) {
#line 388
    super___0->flags |= 256U;
  }
#line 389
  if (image_length > 0) {
#line 390
    super___0->flags |= 1024U;
  }
  {
#line 391
  super___0->size = (u32 )size;
#line 392
  memcpy((void */* __restrict  */)(super___0->signature), (void const   */* __restrict  */)"Compressed ROMFS",
         sizeof(super___0->signature));
#line 394
  tmp = crc32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 394
  super___0->fsid.crc = (u32 )tmp;
#line 395
  super___0->fsid.edition = opt_edition;
#line 396
  super___0->fsid.blocks = (u32 )total_blocks;
#line 397
  super___0->fsid.files = (u32 )total_nodes;
#line 399
  memset((void *)(super___0->name), 0, sizeof(super___0->name));
  }
#line 400
  if (opt_name) {
    {
#line 401
    strncpy((char */* __restrict  */)(super___0->name), (char const   */* __restrict  */)opt_name,
            sizeof(super___0->name));
    }
  } else {
    {
#line 403
    strncpy((char */* __restrict  */)(super___0->name), (char const   */* __restrict  */)"Compressed",
            sizeof(super___0->name));
    }
  }
#line 405
  super___0->root.mode = root->mode;
#line 406
  super___0->root.uid = root->uid;
#line 407
  super___0->root.gid = root->gid;
#line 408
  super___0->root.size = root->size;
#line 409
  super___0->root.offset = offset >> 2;
#line 411
  return (offset);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static void set_data_offset(struct entry *entry , char *base , unsigned long offset ) 
{ 
  struct cramfs_inode *inode ;

  {
#line 416
  inode = (struct cramfs_inode *)(base + entry->dir_offset);
#line 418
  if ((offset & 3UL) != 0UL) {
    {
#line 419
    die(8, 0, "illegal offset of %lu bytes", offset);
    }
  }
#line 421
  if (offset >= (unsigned long )(1 << 28)) {
    {
#line 422
    die(8, 0, "filesystem too big");
    }
  }
#line 424
  inode->offset = (u32 )(offset >> 2);
#line 425
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static void print_node(struct entry *e ) 
{ 
  char info[10] ;
  char type ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 435
  type = (char )'?';
#line 437
  if ((e->mode & 61440U) == 32768U) {
#line 437
    type = (char )'f';
  } else
#line 438
  if ((e->mode & 61440U) == 16384U) {
#line 438
    type = (char )'d';
  } else
#line 439
  if ((e->mode & 61440U) == 40960U) {
#line 439
    type = (char )'l';
  } else
#line 440
  if ((e->mode & 61440U) == 8192U) {
#line 440
    type = (char )'c';
  } else
#line 441
  if ((e->mode & 61440U) == 24576U) {
#line 441
    type = (char )'b';
  } else
#line 442
  if ((e->mode & 61440U) == 4096U) {
#line 442
    type = (char )'p';
  } else
#line 443
  if ((e->mode & 61440U) == 49152U) {
#line 443
    type = (char )'s';
  }
#line 445
  if ((e->mode & 61440U) == 8192U) {
    {
#line 447
    tmp = gnu_dev_minor((unsigned long long )e->size);
#line 447
    tmp___0 = gnu_dev_major((unsigned long long )e->size);
#line 447
    snprintf((char */* __restrict  */)(info), (size_t )10, (char const   */* __restrict  */)"%4d,%4d",
             tmp___0, tmp);
    }
  } else
#line 445
  if ((e->mode & 61440U) == 24576U) {
    {
#line 447
    tmp = gnu_dev_minor((unsigned long long )e->size);
#line 447
    tmp___0 = gnu_dev_major((unsigned long long )e->size);
#line 447
    snprintf((char */* __restrict  */)(info), (size_t )10, (char const   */* __restrict  */)"%4d,%4d",
             tmp___0, tmp);
    }
  } else {
    {
#line 451
    snprintf((char */* __restrict  */)(info), (size_t )10, (char const   */* __restrict  */)"%9d",
             e->size);
    }
  }
  {
#line 454
  printf((char const   */* __restrict  */)"%c %04o %s %5d:%-3d %s\n", (int )type,
         e->mode & 4294905855U, info, e->uid, e->gid, e->name);
  }
#line 456
  return;
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static unsigned int write_directory_structure(struct entry *entry , char *base , unsigned int offset ) 
{ 
  int stack_entries ;
  int stack_size ;
  struct entry **entry_stack ;
  void *tmp ;
  int dir_start ;
  struct cramfs_inode *inode ;
  size_t len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  struct entry **lo ;
  struct entry **hi ;
  struct entry *tmp___2 ;
  struct entry **tmp___3 ;

  {
  {
#line 465
  stack_entries = 0;
#line 466
  stack_size = 64;
#line 469
  tmp = malloc((unsigned long )stack_size * sizeof(struct entry *));
#line 469
  entry_stack = (struct entry **)tmp;
  }
#line 470
  if (! entry_stack) {
    {
#line 471
    die(8, 1, "malloc failed");
    }
  }
#line 474
  if (opt_verbose) {
    {
#line 475
    printf((char const   */* __restrict  */)"root:\n");
    }
  }
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    dir_start = stack_entries;
    {
#line 480
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 480
      if (! entry) {
#line 480
        goto while_break___0;
      }
      {
#line 481
      inode = (struct cramfs_inode *)(base + offset);
#line 482
      tmp___0 = strlen((char const   *)entry->name);
#line 482
      len = tmp___0;
#line 484
      entry->dir_offset = offset;
#line 486
      inode->mode = entry->mode;
#line 487
      inode->uid = entry->uid;
#line 488
      inode->gid = entry->gid;
#line 489
      inode->size = entry->size;
#line 490
      inode->offset = (u32 )0;
#line 494
      offset = (unsigned int )((unsigned long )offset + sizeof(struct cramfs_inode ));
#line 495
      total_nodes ++;
#line 496
      memcpy((void */* __restrict  */)(base + offset), (void const   */* __restrict  */)entry->name,
             len);
      }
      {
#line 498
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 498
        if (! (len & 3UL)) {
#line 498
          goto while_break___1;
        }
#line 499
        *((base + offset) + len) = (char )'\000';
#line 500
        len ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 502
      inode->namelen = (u32 )(len >> 2);
#line 503
      offset = (unsigned int )((size_t )offset + len);
#line 505
      if (opt_verbose) {
        {
#line 506
        print_node(entry);
        }
      }
#line 508
      if (entry->child) {
#line 509
        if (stack_entries >= stack_size) {
          {
#line 510
          stack_size *= 2;
#line 511
          tmp___1 = realloc((void *)entry_stack, (unsigned long )stack_size * sizeof(struct entry *));
#line 511
          entry_stack = (struct entry **)tmp___1;
          }
#line 512
          if (! entry_stack) {
            {
#line 513
            die(8, 1, "realloc failed");
            }
          }
        }
#line 516
        *(entry_stack + stack_entries) = entry;
#line 517
        stack_entries ++;
      }
#line 519
      entry = entry->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 529
    lo = entry_stack + dir_start;
#line 530
    hi = entry_stack + stack_entries;
    {
#line 533
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 533
      hi --;
#line 533
      if (! ((unsigned long )lo < (unsigned long )hi)) {
#line 533
        goto while_break___2;
      }
#line 534
      tmp___2 = *lo;
#line 535
      tmp___3 = lo;
#line 535
      lo ++;
#line 535
      *tmp___3 = *hi;
#line 536
      *hi = tmp___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 541
    if (! stack_entries) {
#line 542
      goto while_break;
    }
    {
#line 543
    stack_entries --;
#line 544
    entry = *(entry_stack + stack_entries);
#line 546
    set_data_offset(entry, base, (unsigned long )offset);
    }
#line 547
    if (opt_verbose) {
      {
#line 548
      printf((char const   */* __restrict  */)"%s:\n", entry->name);
      }
    }
#line 550
    entry = entry->child;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 552
  free((void *)entry_stack);
  }
#line 553
  return (offset);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static int is_zero(char const   *begin , unsigned int len ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 559
  tmp = len;
#line 559
  len --;
#line 559
  if (tmp == 0U) {
#line 559
    tmp___4 = 1;
  } else
#line 559
  if ((int const   )*(begin + 0) == 0) {
#line 559
    tmp___0 = len;
#line 559
    len --;
#line 559
    if (tmp___0 == 0U) {
#line 559
      tmp___4 = 1;
    } else
#line 559
    if ((int const   )*(begin + 1) == 0) {
#line 559
      tmp___1 = len;
#line 559
      len --;
#line 559
      if (tmp___1 == 0U) {
#line 559
        tmp___4 = 1;
      } else
#line 559
      if ((int const   )*(begin + 2) == 0) {
#line 559
        tmp___2 = len;
#line 559
        len --;
#line 559
        if (tmp___2 == 0U) {
#line 559
          tmp___4 = 1;
        } else
#line 559
        if ((int const   )*(begin + 3) == 0) {
          {
#line 559
          tmp___3 = memcmp((void const   *)begin, (void const   *)(begin + 4), (size_t )len);
          }
#line 559
          if (tmp___3 == 0) {
#line 559
            tmp___4 = 1;
          } else {
#line 559
            tmp___4 = 0;
          }
        } else {
#line 559
          tmp___4 = 0;
        }
      } else {
#line 559
        tmp___4 = 0;
      }
    } else {
#line 559
      tmp___4 = 0;
    }
  } else {
#line 559
    tmp___4 = 0;
  }
#line 559
  return (tmp___4);
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static unsigned int do_compress(char *base , unsigned int offset , char const   *name ,
                                char *uncompressed , unsigned int size ) 
{ 
  unsigned long original_size ;
  unsigned long original_offset ;
  unsigned long new_size ;
  unsigned long blocks ;
  unsigned long curr ;
  int change ;
  unsigned long len ;
  unsigned int input ;
  int err ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 582
  original_size = (unsigned long )size;
#line 583
  original_offset = (unsigned long )offset;
#line 585
  blocks = (unsigned long )((size - 1U) / blksize + 1U);
#line 586
  curr = (unsigned long )offset + 4UL * blocks;
#line 589
  total_blocks = (long )((unsigned long )total_blocks + blocks);
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    len = (unsigned long )(2U * blksize);
#line 593
    input = size;
#line 596
    if (input > blksize) {
#line 597
      input = blksize;
    }
#line 598
    size -= input;
#line 599
    if (opt_holes) {
      {
#line 599
      tmp___0 = is_zero((char const   *)uncompressed, input);
      }
#line 599
      if (! tmp___0) {
#line 599
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 600
      err = compress2((Bytef *)(base + curr), & len, (Bytef const   *)uncompressed,
                      (uLong )input, 9);
      }
#line 601
      if (err != 0) {
        {
#line 602
        tmp = zError(err);
#line 602
        die(8, 0, "compression error: %s", tmp);
        }
      }
#line 604
      curr += len;
    }
#line 606
    uncompressed += input;
#line 608
    if (len > (unsigned long )(blksize * 2U)) {
      {
#line 610
      die(8, 0, "AIEEE: block \"compressed\" to > 2*blocklength (%ld)", len);
      }
    }
#line 613
    *((u32 *)(base + offset)) = (u32 )curr;
#line 614
    offset += 4U;
#line 591
    if (! size) {
#line 591
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 617
  curr = (curr + 3UL) & 0xfffffffffffffffcUL;
#line 618
  new_size = curr - original_offset;
#line 622
  change = (int )(new_size - original_size);
#line 623
  if (opt_verbose > 1) {
    {
#line 624
    printf((char const   */* __restrict  */)"%6.2f%% (%+d bytes)\t%s\n", (double )(change * 100) / (double )original_size,
           change, name);
    }
  }
#line 628
  return ((unsigned int )curr);
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static unsigned int write_data(struct entry *entry , char *base , unsigned int offset ) 
{ 


  {
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 640
    if (entry->path) {
#line 640
      goto _L;
    } else
#line 640
    if (entry->uncompressed) {
      _L: /* CIL Label */ 
#line 641
      if (entry->same) {
        {
#line 642
        set_data_offset(entry, base, (unsigned long )(entry->same)->offset);
#line 643
        entry->offset = (entry->same)->offset;
        }
      } else {
        {
#line 646
        set_data_offset(entry, base, (unsigned long )offset);
#line 647
        entry->offset = offset;
#line 648
        map_entry(entry);
#line 649
        offset = do_compress(base, offset, (char const   *)entry->name, (char *)entry->uncompressed,
                             entry->size);
#line 650
        unmap_entry(entry);
        }
      }
    } else
#line 653
    if (entry->child) {
      {
#line 654
      offset = write_data(entry->child, base, offset);
      }
    }
#line 655
    entry = entry->next;
#line 639
    if (! entry) {
#line 639
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  return (offset);
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
static unsigned int write_file(char *file , char *base , unsigned int offset ) 
{ 
  int fd___0 ;
  char *buf ;
  void *tmp ;

  {
  {
#line 665
  fd___0 = open((char const   *)file, 0);
  }
#line 666
  if (fd___0 < 0) {
    {
#line 667
    die(8, 1, "open failed: %s", file);
    }
  }
  {
#line 669
  tmp = mmap((void *)0, (size_t )image_length, 1, 2, fd___0, (__off_t )0);
#line 669
  buf = (char *)tmp;
  }
#line 670
  if ((unsigned long )buf == (unsigned long )((void *)-1)) {
    {
#line 671
    die(8, 1, "mmap failed");
    }
  }
  {
#line 673
  memcpy((void */* __restrict  */)(base + offset), (void const   */* __restrict  */)buf,
         (size_t )image_length);
#line 674
  munmap((void *)buf, (size_t )image_length);
#line 675
  close(fd___0);
  }
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if (! (image_length & 3)) {
#line 677
      goto while_break;
    }
#line 678
    *((base + offset) + image_length) = (char )'\000';
#line 679
    image_length ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 681
  return (offset + (unsigned int )image_length);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/mkcramfs.c"
int main(int argc , char **argv ) 
{ 
  struct stat st ;
  struct entry *root_entry ;
  char *rom_image ;
  ssize_t offset ;
  ssize_t written ;
  int fd___0 ;
  loff_t fslen_ub ;
  char const   *dirname ;
  char const   *outfile ;
  u32 crc ;
  int c ;
  char *ep ;
  long tmp ;
  int *tmp___0 ;
  unsigned long tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  unsigned long tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  loff_t tmp___9 ;
  void *tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  uLong tmp___14 ;
  uLong tmp___15 ;

  {
  {
#line 692
  fslen_ub = (loff_t )sizeof(struct cramfs_super );
#line 698
  tmp = sysconf(30);
#line 698
  blksize = (unsigned int )tmp;
#line 699
  total_blocks = 0L;
  }
#line 701
  if (argc) {
#line 702
    progname = (char const   *)*(argv + 0);
  }
  {
#line 705
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 705
    c = getopt(argc, (char * const  *)argv, "hEb:e:i:n:psvz");
    }
#line 705
    if (! (c != -1)) {
#line 705
      goto while_break;
    }
    {
#line 707
    if (c == 104) {
#line 707
      goto case_104;
    }
#line 709
    if (c == 69) {
#line 709
      goto case_69;
    }
#line 712
    if (c == 98) {
#line 712
      goto case_98;
    }
#line 720
    if (c == 101) {
#line 720
      goto case_101;
    }
#line 726
    if (c == 105) {
#line 726
      goto case_105;
    }
#line 734
    if (c == 110) {
#line 734
      goto case_110;
    }
#line 737
    if (c == 112) {
#line 737
      goto case_112;
    }
#line 741
    if (c == 115) {
#line 741
      goto case_115;
    }
#line 744
    if (c == 118) {
#line 744
      goto case_118;
    }
#line 747
    if (c == 122) {
#line 747
      goto case_122;
    }
#line 706
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 708
    usage(0);
    }
    case_69: /* CIL Label */ 
#line 710
    opt_errors = 1;
#line 711
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 713
    tmp___0 = __errno_location();
#line 713
    *tmp___0 = 0;
#line 714
    tmp___1 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& ep),
                      10);
#line 714
    blksize = (unsigned int )tmp___1;
#line 715
    tmp___2 = __errno_location();
    }
#line 715
    if (*tmp___2) {
      {
#line 716
      usage(16);
      }
    } else
#line 715
    if ((int )*(optarg + 0) == 0) {
      {
#line 716
      usage(16);
      }
    } else
#line 715
    if ((int )*ep != 0) {
      {
#line 716
      usage(16);
      }
    }
#line 717
    if (blksize < 512U) {
      {
#line 718
      die(8, 0, "invalid blocksize: %u", blksize);
      }
    } else
#line 717
    if (blksize & (blksize - 1U)) {
      {
#line 718
      die(8, 0, "invalid blocksize: %u", blksize);
      }
    }
#line 719
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 721
    tmp___3 = __errno_location();
#line 721
    *tmp___3 = 0;
#line 722
    tmp___4 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& ep),
                      10);
#line 722
    opt_edition = (u32 )tmp___4;
#line 723
    tmp___5 = __errno_location();
    }
#line 723
    if (*tmp___5) {
      {
#line 724
      usage(16);
      }
    } else
#line 723
    if ((int )*(optarg + 0) == 0) {
      {
#line 724
      usage(16);
      }
    } else
#line 723
    if ((int )*ep != 0) {
      {
#line 724
      usage(16);
      }
    }
#line 725
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 727
    opt_image = optarg;
#line 728
    tmp___6 = lstat((char const   */* __restrict  */)opt_image, (struct stat */* __restrict  */)(& st));
    }
#line 728
    if (tmp___6 < 0) {
      {
#line 729
      die(8, 1, "lstat failed: %s", opt_image);
      }
    }
#line 731
    image_length = (int )st.st_size;
#line 732
    fslen_ub += (loff_t )(image_length + 3);
#line 733
    goto switch_break;
    case_110: /* CIL Label */ 
#line 735
    opt_name = optarg;
#line 736
    goto switch_break;
    case_112: /* CIL Label */ 
#line 738
    opt_pad = 512;
#line 739
    fslen_ub += 512L;
#line 740
    goto switch_break;
    case_115: /* CIL Label */ 
#line 743
    goto switch_break;
    case_118: /* CIL Label */ 
#line 745
    opt_verbose ++;
#line 746
    goto switch_break;
    case_122: /* CIL Label */ 
#line 748
    opt_holes = 1;
#line 749
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 753
  if (argc - optind != 2) {
    {
#line 754
    usage(16);
    }
  }
  {
#line 755
  dirname = (char const   *)*(argv + optind);
#line 756
  outfile = (char const   *)*(argv + (optind + 1));
#line 758
  tmp___7 = stat((char const   */* __restrict  */)dirname, (struct stat */* __restrict  */)(& st));
  }
#line 758
  if (tmp___7 < 0) {
    {
#line 759
    die(16, 1, "stat failed: %s", dirname);
    }
  }
  {
#line 761
  fd___0 = open(outfile, 577, 438);
  }
#line 762
  if (fd___0 < 0) {
    {
#line 763
    die(16, 1, "open failed: %s", outfile);
    }
  }
  {
#line 766
  tmp___8 = calloc((size_t )1, sizeof(struct entry ));
#line 766
  root_entry = (struct entry *)tmp___8;
  }
#line 767
  if (! root_entry) {
    {
#line 768
    die(8, 1, "calloc failed");
    }
  }
  {
#line 770
  root_entry->mode = st.st_mode;
#line 771
  root_entry->uid = st.st_uid;
#line 772
  root_entry->gid = st.st_gid;
#line 774
  root_entry->size = parse_directory(root_entry, dirname, & root_entry->child, & fslen_ub);
#line 778
  fslen_ub = ((fslen_ub - 1L) | (long )(blksize - 1U)) + 1L;
  }
#line 780
  if (fslen_ub > (loff_t )((unsigned int )(((((1 << 26) - 1) << 2) + (1 << 24)) - 1) + (unsigned int )((1 << 24) * 4) / blksize)) {
    {
#line 781
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: estimate of required size (upper bound) is %jdMB, but maximum image size is %uMB, we might die prematurely\n",
            fslen_ub >> 20, ((unsigned int )(((((1 << 26) - 1) << 2) + (1 << 24)) - 1) + (unsigned int )((1 << 24) * 4) / blksize) >> 20);
#line 785
    fslen_ub = (loff_t )((unsigned int )(((((1 << 26) - 1) << 2) + (1 << 24)) - 1) + (unsigned int )((1 << 24) * 4) / blksize);
    }
  }
  {
#line 790
  eliminate_doubles(root_entry, root_entry);
  }
#line 801
  if (fslen_ub) {
#line 801
    tmp___9 = fslen_ub;
  } else {
#line 801
    tmp___9 = (loff_t )1;
  }
  {
#line 801
  tmp___10 = mmap((void *)0, (size_t )tmp___9, 3, 34, -1, (__off_t )0);
#line 801
  rom_image = (char *)tmp___10;
  }
#line 803
  if ((unsigned long )rom_image == (unsigned long )((void *)-1)) {
    {
#line 804
    die(8, 1, "mmap failed");
    }
  }
  {
#line 808
  offset = (ssize_t )opt_pad;
#line 809
  memset((void *)rom_image, 0, (size_t )opt_pad);
#line 812
  offset = (ssize_t )((unsigned long )offset + sizeof(struct cramfs_super ));
  }
#line 815
  if (opt_image) {
    {
#line 816
    printf((char const   */* __restrict  */)"Including: %s\n", opt_image);
#line 817
    tmp___11 = write_file(opt_image, rom_image, (unsigned int )offset);
#line 817
    offset = (ssize_t )tmp___11;
    }
  }
  {
#line 820
  tmp___12 = write_directory_structure(root_entry->child, rom_image, (unsigned int )offset);
#line 820
  offset = (ssize_t )tmp___12;
#line 821
  printf((char const   */* __restrict  */)"Directory data: %zd bytes\n", offset);
#line 823
  tmp___13 = write_data(root_entry, rom_image, (unsigned int )offset);
#line 823
  offset = (ssize_t )tmp___13;
#line 827
  offset = ((offset - 1L) | (long )(blksize - 1U)) + 1L;
#line 828
  printf((char const   */* __restrict  */)"Everything: %zd kilobytes\n", offset >> 10);
#line 831
  write_superblock(root_entry, rom_image + opt_pad, (int )offset);
#line 832
  printf((char const   */* __restrict  */)"Super block: %zd bytes\n", sizeof(struct cramfs_super ));
#line 835
  tmp___14 = crc32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 835
  crc = (u32 )tmp___14;
#line 836
  tmp___15 = crc32((uLong )crc, (Bytef const   *)(rom_image + opt_pad), (uInt )(offset - (ssize_t )opt_pad));
#line 836
  crc = (u32 )tmp___15;
#line 837
  ((struct cramfs_super *)(rom_image + opt_pad))->fsid.crc = crc;
#line 838
  printf((char const   */* __restrict  */)"CRC: %x\n", crc);
  }
#line 841
  if (fslen_ub < offset) {
    {
#line 842
    die(8, 0, "not enough space allocated for ROM image (%Ld allocated, %d used)",
        fslen_ub, offset);
    }
  }
  {
#line 845
  written = write(fd___0, (void const   *)rom_image, (size_t )offset);
  }
#line 846
  if (written < 0L) {
    {
#line 847
    die(8, 1, "write failed");
    }
  }
#line 849
  if (offset != written) {
    {
#line 850
    die(8, 0, "ROM image write failed (wrote %d of %d bytes): No space left on device?",
        written, offset);
    }
  }
#line 855
  if (warn_namelen) {
    {
#line 856
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: filenames truncated to %d bytes (possibly less if multi-byte UTF-8)\n",
            ((1 << 6) - 1) << 2);
    }
  }
#line 859
  if (warn_skip) {
    {
#line 860
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: files were skipped due to errors\n");
    }
  }
#line 861
  if (warn_size) {
    {
#line 862
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: file sizes truncated to %luMB (minus 1 byte)\n",
            1L << 4);
    }
  }
#line 865
  if (warn_uid) {
    {
#line 866
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: uids truncated to %u bits (this may be a security concern)\n",
            16);
    }
  }
#line 869
  if (warn_gid) {
    {
#line 870
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: gids truncated to %u bits (this may be a security concern)\n",
            8);
    }
  }
#line 873
  if (warn_dev) {
    {
#line 874
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: device numbers truncated to %u bits (this almost certainly means\nthat some device files will be wrong)\n",
            26);
    }
  }
#line 878
  if (opt_errors) {
#line 878
    if (warn_namelen) {
      {
#line 880
      exit(8);
      }
    } else
#line 878
    if (warn_skip) {
      {
#line 880
      exit(8);
      }
    } else
#line 878
    if (warn_size) {
      {
#line 880
      exit(8);
      }
    } else
#line 878
    if (warn_uid) {
      {
#line 880
      exit(8);
      }
    } else
#line 878
    if (warn_gid) {
      {
#line 880
      exit(8);
      }
    } else
#line 878
    if (warn_dev) {
      {
#line 880
      exit(8);
      }
    }
  }
  {
#line 882
  exit(0);
  }
}
}
#line 405 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mknod)(char const   *__path ,
                                                                                            __mode_t __mode ,
                                                                                            __dev_t __dev ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 483
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) lchown)(char const   *__file ,
                                                                                             __uid_t __owner ,
                                                                                             __gid_t __group ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 803
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 392 "/usr/include/zlib.h"
extern int inflate(z_streamp strm , int flush ) ;
#line 508
extern int inflateEnd(z_streamp strm ) ;
#line 892
extern int inflateReset(z_streamp strm ) ;
#line 1635
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static char const   *progname___0  =    "cramfsck";
#line 73 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static int fd  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static char *filename  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
struct cramfs_super super  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static int opt_verbose___0  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static int opt_extract  =    0;
#line 79 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static char *extract_dir  =    (char *)"root";
#line 80 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static uid_t euid  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static unsigned long start_dir  =    ~ 0UL;
#line 84 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static unsigned long end_dir  =    0UL;
#line 85 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static unsigned long start_data  =    ~ 0UL;
#line 86 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static unsigned long end_data  =    0UL;
#line 92 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static char read_buffer[(1 << 13) * 2]  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static unsigned long read_buffer_block  =    ~ 0UL;
#line 96 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static char *outbuffer  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static z_stream stream  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static size_t page_size  ;
#line 102
static void expand_fs(char *path , struct cramfs_inode *inode ) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void usage___0(int status ) 
{ 
  FILE *stream___0 ;
  struct _IO_FILE *tmp ;

  {
#line 108
  if (status) {
#line 108
    tmp = stderr;
  } else {
#line 108
    tmp = stdout;
  }
  {
#line 108
  stream___0 = tmp;
#line 110
  fprintf((FILE */* __restrict  */)stream___0, (char const   */* __restrict  */)"usage: %s [-hv] [-x dir] file\n -h         print this help\n -x dir     extract into dir\n -v         be more verbose\n file       file to test\n",
          progname___0);
#line 116
  exit(status);
  }
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void die___0(int status , int syserr , char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;
  int save ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 122
  tmp = __errno_location();
#line 122
  save = *tmp;
#line 124
  fflush((FILE *)0);
#line 125
  __builtin_va_start(arg_ptr, fmt);
#line 126
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname___0);
#line 127
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           arg_ptr);
  }
#line 128
  if (syserr) {
    {
#line 129
    tmp___0 = strerror(save);
#line 129
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp___0);
    }
  }
  {
#line 131
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 132
  __builtin_va_end(arg_ptr);
#line 133
  exit(status);
  }
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void test_super(int *start , size_t *length ) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 140
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
  }
#line 140
  if (tmp < 0) {
    {
#line 141
    die___0(8, 1, "stat failed: %s", filename);
    }
  }
  {
#line 143
  fd = open((char const   *)filename, 0);
  }
#line 144
  if (fd < 0) {
    {
#line 145
    die___0(8, 1, "open failed: %s", filename);
    }
  }
#line 147
  if ((st.st_mode & 61440U) == 24576U) {
    {
#line 148
    tmp___0 = ioctl(fd, (unsigned long )((unsigned int )(18 << 8) | 96U), length);
    }
#line 148
    if (tmp___0 < 0) {
      {
#line 149
      die___0(8, 1, "ioctl failed: unable to determine device size: %s", filename);
      }
    }
#line 151
    *length *= 512UL;
  } else
#line 153
  if ((st.st_mode & 61440U) == 32768U) {
#line 154
    *length = (size_t )st.st_size;
  } else {
    {
#line 157
    die___0(8, 0, "not a block device or file: %s", filename);
    }
  }
#line 160
  if (*length < sizeof(struct cramfs_super )) {
    {
#line 161
    die___0(4, 0, "file length too short");
    }
  }
  {
#line 165
  tmp___1 = read(fd, (void *)(& super), sizeof(super));
  }
#line 165
  if ((unsigned long )tmp___1 != sizeof(super)) {
    {
#line 166
    die___0(8, 1, "read failed: %s", filename);
    }
  }
#line 168
  if (super.magic == 684539205U) {
#line 169
    *start = 0;
  } else
#line 171
  if (*length >= 512UL + sizeof(super)) {
    {
#line 172
    lseek(fd, (__off_t )512, 0);
#line 173
    tmp___2 = read(fd, (void *)(& super), sizeof(super));
    }
#line 173
    if ((unsigned long )tmp___2 != sizeof(super)) {
      {
#line 174
      die___0(8, 1, "read failed: %s", filename);
      }
    }
#line 176
    if (super.magic == 684539205U) {
#line 177
      *start = 512;
    }
  }
#line 182
  if (super.magic != 684539205U) {
    {
#line 183
    die___0(4, 0, "superblock magic not found");
    }
  }
#line 185
  if (super.flags & 4294965248U) {
    {
#line 186
    die___0(8, 0, "unsupported filesystem features");
    }
  }
#line 188
  if ((size_t )super.size < page_size) {
    {
#line 189
    die___0(4, 0, "superblock size (%d) too small", super.size);
    }
  }
#line 191
  if (super.flags & 1U) {
#line 192
    if (super.fsid.files == 0U) {
      {
#line 193
      die___0(4, 0, "zero file count");
      }
    }
#line 195
    if (*length < (size_t )super.size) {
      {
#line 196
      die___0(4, 0, "file length too short");
      }
    } else
#line 198
    if (*length > (size_t )super.size) {
      {
#line 199
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: file extends past end of filesystem\n");
      }
    }
  } else {
    {
#line 203
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: old cramfs format\n");
    }
  }
#line 205
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void test_crc(int start ) 
{ 
  void *buf ;
  u32 crc ;
  uLong tmp ;
  uLong tmp___0 ;
  uLong tmp___1 ;
  int retval ;
  size_t length ;
  ssize_t tmp___2 ;
  uLong tmp___3 ;
  uLong tmp___4 ;
  uLong tmp___5 ;

  {
#line 212
  if (! (super.flags & 1U)) {
#line 214
    return;
  }
  {
#line 220
  tmp = crc32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 220
  crc = (u32 )tmp;
#line 222
  buf = mmap((void *)0, (size_t )super.size, 3, 2, fd, (__off_t )0);
  }
#line 223
  if ((unsigned long )buf == (unsigned long )((void *)-1)) {
    {
#line 224
    buf = mmap((void *)0, (size_t )super.size, 3, 34, -1, (__off_t )0);
    }
#line 225
    if ((unsigned long )buf != (unsigned long )((void *)-1)) {
      {
#line 226
      lseek(fd, (__off_t )0, 0);
#line 227
      read(fd, buf, (size_t )super.size);
      }
    }
  }
#line 230
  if ((unsigned long )buf != (unsigned long )((void *)-1)) {
    {
#line 231
    tmp___0 = crc32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 231
    ((struct cramfs_super *)(buf + start))->fsid.crc = (u32 )tmp___0;
#line 232
    tmp___1 = crc32((uLong )crc, (Bytef const   *)(buf + start), super.size - (u32 )start);
#line 232
    crc = (u32 )tmp___1;
#line 233
    munmap(buf, (size_t )super.size);
    }
  } else {
    {
#line 237
    length = (size_t )0;
#line 239
    buf = malloc((size_t )4096);
    }
#line 240
    if (! buf) {
      {
#line 241
      die___0(8, 1, "malloc failed");
      }
    }
    {
#line 243
    lseek(fd, (__off_t )start, 0);
    }
    {
#line 244
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 245
      tmp___2 = read(fd, buf, (size_t )4096);
#line 245
      retval = (int )tmp___2;
      }
#line 246
      if (retval < 0) {
        {
#line 247
        die___0(8, 1, "read failed: %s", filename);
        }
      } else
#line 249
      if (retval == 0) {
#line 250
        goto while_break;
      }
#line 252
      if (length == 0UL) {
        {
#line 253
        tmp___3 = crc32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 253
        ((struct cramfs_super *)buf)->fsid.crc = (u32 )tmp___3;
        }
      }
#line 255
      length += (size_t )retval;
#line 256
      if (length > (size_t )(super.size - (u32 )start)) {
        {
#line 257
        tmp___4 = crc32((uLong )crc, (Bytef const   *)buf, (uInt )((size_t )retval - (length - (size_t )(super.size - (u32 )start))));
#line 257
        crc = (u32 )tmp___4;
        }
#line 258
        goto while_break;
      }
      {
#line 260
      tmp___5 = crc32((uLong )crc, (Bytef const   *)buf, (uInt )retval);
#line 260
      crc = (u32 )tmp___5;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 262
    free(buf);
    }
  }
#line 265
  if (crc != super.fsid.crc) {
    {
#line 266
    die___0(4, 0, "crc error");
    }
  }
#line 268
  return;
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void print_node___0(char type , struct cramfs_inode *i , char *name ) 
{ 
  char info[10] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 275
  if ((i->mode & 61440U) == 8192U) {
    {
#line 277
    tmp = gnu_dev_minor((unsigned long long )i->size);
#line 277
    tmp___0 = gnu_dev_major((unsigned long long )i->size);
#line 277
    snprintf((char */* __restrict  */)(info), (size_t )10, (char const   */* __restrict  */)"%4d,%4d",
             tmp___0, tmp);
    }
  } else
#line 275
  if ((i->mode & 61440U) == 24576U) {
    {
#line 277
    tmp = gnu_dev_minor((unsigned long long )i->size);
#line 277
    tmp___0 = gnu_dev_major((unsigned long long )i->size);
#line 277
    snprintf((char */* __restrict  */)(info), (size_t )10, (char const   */* __restrict  */)"%4d,%4d",
             tmp___0, tmp);
    }
  } else {
    {
#line 281
    snprintf((char */* __restrict  */)(info), (size_t )10, (char const   */* __restrict  */)"%9d",
             i->size);
    }
  }
  {
#line 284
  printf((char const   */* __restrict  */)"%c %04o %s %5d:%-3d %s\n", (int )type,
         i->mode & 4294905855U, info, i->uid, i->gid, name);
  }
#line 286
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void *romfs_read(unsigned long offset ) 
{ 
  unsigned int block ;

  {
#line 293
  block = (unsigned int )(offset >> 13);
#line 294
  if ((unsigned long )block != read_buffer_block) {
    {
#line 295
    read_buffer_block = (unsigned long )block;
#line 296
    lseek(fd, (__off_t )(block << 13), 0);
#line 297
    read(fd, (void *)(read_buffer), (size_t )((1 << 13) * 2));
    }
  }
#line 299
  return ((void *)(read_buffer + (offset & (unsigned long )((1 << 13) - 1))));
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static struct cramfs_inode *cramfs_iget(struct cramfs_inode *i ) 
{ 
  struct cramfs_inode *inode ;
  void *tmp ;

  {
  {
#line 304
  tmp = malloc(sizeof(struct cramfs_inode ));
#line 304
  inode = (struct cramfs_inode *)tmp;
  }
#line 306
  if (! inode) {
    {
#line 307
    die___0(8, 1, "malloc failed");
    }
  }
#line 309
  *inode = *i;
#line 310
  return (inode);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static struct cramfs_inode *iget(unsigned int ino ) 
{ 
  void *tmp ;
  struct cramfs_inode *tmp___0 ;

  {
  {
#line 315
  tmp = romfs_read((unsigned long )ino);
#line 315
  tmp___0 = cramfs_iget((struct cramfs_inode *)tmp);
  }
#line 315
  return (tmp___0);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void iput(struct cramfs_inode *inode ) 
{ 


  {
  {
#line 320
  free((void *)inode);
  }
#line 321
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static struct cramfs_inode *read_super(void) 
{ 
  unsigned long offset ;
  struct cramfs_inode *tmp ;

  {
#line 328
  offset = (unsigned long )(super.root.offset << 2);
#line 330
  if (! ((super.root.mode & 61440U) == 16384U)) {
    {
#line 331
    die___0(4, 0, "root inode is not directory");
    }
  }
#line 332
  if (! (super.flags & 1024U)) {
#line 332
    if (offset != sizeof(struct cramfs_super )) {
#line 332
      if (offset != 512UL + sizeof(struct cramfs_super )) {
        {
#line 336
        die___0(4, 0, "bad root offset (%lu)", offset);
        }
      }
    }
  }
  {
#line 338
  tmp = cramfs_iget(& super.root);
  }
#line 338
  return (tmp);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static int uncompress_block(void *src , int len ) 
{ 
  int err ;
  char const   *tmp ;

  {
  {
#line 345
  stream.next_in = (Bytef *)src;
#line 346
  stream.avail_in = (uInt )len;
#line 348
  stream.next_out = (unsigned char *)outbuffer;
#line 349
  stream.avail_out = (uInt )(page_size * 2UL);
#line 351
  inflateReset(& stream);
  }
#line 353
  if ((size_t )len > page_size * 2UL) {
    {
#line 354
    die___0(4, 0, "data block too large");
    }
  }
  {
#line 356
  err = inflate(& stream, 4);
  }
#line 357
  if (err != 1) {
    {
#line 358
    tmp = zError(err);
#line 358
    die___0(4, 0, "decompression error %p(%d): %s", tmp, src, len);
    }
  }
#line 361
  return ((int )stream.total_out);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void do_uncompress(char *path , int fd___0 , unsigned long offset , unsigned long size ) 
{ 
  unsigned long curr ;
  unsigned long out ;
  unsigned long next ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 366
  curr = offset + 4UL * (((size + page_size) - 1UL) / page_size);
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 369
    out = page_size;
#line 370
    tmp = romfs_read(offset);
#line 370
    next = (unsigned long )*((u32 *)tmp);
    }
#line 372
    if (next > end_data) {
#line 373
      end_data = next;
    }
#line 376
    offset += 4UL;
#line 377
    if (curr == next) {
#line 378
      if (opt_verbose___0 > 1) {
        {
#line 379
        printf((char const   */* __restrict  */)"  hole at %ld (%d)\n", curr, page_size);
        }
      }
#line 381
      if (size < page_size) {
#line 382
        out = size;
      }
      {
#line 383
      memset((void *)outbuffer, 0, out);
      }
    } else {
#line 386
      if (opt_verbose___0 > 1) {
        {
#line 387
        printf((char const   */* __restrict  */)"  uncompressing block at %ld to %ld (%ld)\n",
               curr, next, next - curr);
        }
      }
      {
#line 389
      tmp___0 = romfs_read(curr);
#line 389
      tmp___1 = uncompress_block(tmp___0, (int )(next - curr));
#line 389
      out = (unsigned long )tmp___1;
      }
    }
#line 391
    if (size >= page_size) {
#line 392
      if (out != page_size) {
        {
#line 393
        die___0(4, 0, "non-block (%ld) bytes", out);
        }
      }
    } else
#line 396
    if (out != size) {
      {
#line 397
      die___0(4, 0, "non-size (%ld vs %ld) bytes", out, size);
      }
    }
#line 400
    size -= out;
#line 401
    if (opt_extract) {
      {
#line 402
      tmp___2 = write(fd___0, (void const   *)outbuffer, out);
      }
#line 402
      if (tmp___2 < 0L) {
        {
#line 403
        die___0(8, 1, "write failed: %s", path);
        }
      }
    }
#line 406
    curr = next;
#line 368
    if (! size) {
#line 368
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 408
  return;
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void change_file_status(char *path , struct cramfs_inode *i ) 
{ 
  struct utimbuf epoch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 412
  epoch.actime = (__time_t )0;
#line 412
  epoch.modtime = (__time_t )0;
#line 414
  if (euid == 0U) {
    {
#line 415
    tmp = lchown((char const   *)path, i->uid, i->gid);
    }
#line 415
    if (tmp < 0) {
      {
#line 416
      die___0(8, 1, "lchown failed: %s", path);
      }
    }
#line 418
    if ((i->mode & 61440U) == 40960U) {
#line 419
      return;
    }
#line 420
    if (3072U & i->mode) {
      {
#line 421
      tmp___0 = chmod((char const   *)path, i->mode);
      }
#line 421
      if (tmp___0 < 0) {
        {
#line 422
        die___0(8, 1, "chown failed: %s", path);
        }
      }
    }
  }
#line 426
  if ((i->mode & 61440U) == 40960U) {
#line 427
    return;
  }
  {
#line 428
  tmp___1 = utime((char const   *)path, (struct utimbuf  const  *)(& epoch));
  }
#line 428
  if (tmp___1 < 0) {
    {
#line 429
    die___0(8, 1, "utime failed: %s", path);
    }
  }
#line 431
  return;
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void do_directory(char *path , struct cramfs_inode *i ) 
{ 
  int pathlen ;
  size_t tmp ;
  int count ;
  unsigned long offset ;
  char *newpath ;
  void *tmp___0 ;
  int tmp___1 ;
  struct cramfs_inode *child ;
  struct cramfs_inode *tmp___2 ;
  int size ;
  int newlen ;
  void *tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 435
  tmp = strlen((char const   *)path);
#line 435
  pathlen = (int )tmp;
#line 436
  count = (int )i->size;
#line 437
  offset = (unsigned long )(i->offset << 2);
#line 438
  tmp___0 = malloc((size_t )(pathlen + 256));
#line 438
  newpath = (char *)tmp___0;
  }
#line 440
  if (! newpath) {
    {
#line 441
    die___0(8, 1, "malloc failed");
    }
  }
#line 443
  if (offset == 0UL) {
#line 443
    if (count != 0) {
      {
#line 444
      die___0(4, 0, "directory inode has zero offset and non-zero size: %s", path);
      }
    }
  }
#line 446
  if (offset != 0UL) {
#line 446
    if (offset < start_dir) {
#line 447
      start_dir = offset;
    }
  }
  {
#line 450
  memcpy((void */* __restrict  */)newpath, (void const   */* __restrict  */)path,
         (size_t )pathlen);
#line 451
  *(newpath + pathlen) = (char )'/';
#line 452
  pathlen ++;
  }
#line 453
  if (opt_verbose___0) {
    {
#line 454
    print_node___0((char )'d', i, path);
    }
  }
#line 456
  if (opt_extract) {
    {
#line 457
    tmp___1 = mkdir((char const   *)path, i->mode);
    }
#line 457
    if (tmp___1 < 0) {
      {
#line 458
      die___0(8, 1, "mkdir failed: %s", path);
      }
    }
    {
#line 460
    change_file_status(path, i);
    }
  }
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! (count > 0)) {
#line 462
      goto while_break;
    }
    {
#line 463
    tmp___2 = iget((unsigned int )offset);
#line 463
    child = tmp___2;
#line 465
    newlen = (int )(child->namelen << 2);
#line 467
    size = (int )(sizeof(struct cramfs_inode ) + (unsigned long )newlen);
#line 468
    count -= size;
#line 470
    offset += sizeof(struct cramfs_inode );
#line 472
    tmp___3 = romfs_read(offset);
#line 472
    memcpy((void */* __restrict  */)(newpath + pathlen), (void const   */* __restrict  */)tmp___3,
           (size_t )newlen);
#line 473
    *(newpath + (pathlen + newlen)) = (char)0;
    }
#line 474
    if (newlen == 0) {
      {
#line 475
      die___0(4, 0, "filename length is zero");
      }
    }
    {
#line 477
    tmp___4 = strlen((char const   *)newpath);
    }
#line 477
    if ((size_t )(pathlen + newlen) - tmp___4 > 3UL) {
      {
#line 478
      die___0(4, 0, "bad filename length");
      }
    }
    {
#line 480
    expand_fs(newpath, child);
#line 482
    offset += (unsigned long )newlen;
    }
#line 484
    if (offset <= start_dir) {
      {
#line 485
      die___0(4, 0, "bad inode offset");
      }
    }
#line 487
    if (offset > end_dir) {
#line 488
      end_dir = offset;
    }
    {
#line 490
    iput(child);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 492
  free((void *)newpath);
  }
#line 493
  return;
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void do_file(char *path , struct cramfs_inode *i ) 
{ 
  unsigned long offset ;
  int fd___0 ;

  {
#line 497
  offset = (unsigned long )(i->offset << 2);
#line 498
  fd___0 = 0;
#line 500
  if (offset == 0UL) {
#line 500
    if (i->size != 0U) {
      {
#line 501
      die___0(4, 0, "file inode has zero offset and non-zero size");
      }
    }
  }
#line 503
  if (i->size == 0U) {
#line 503
    if (offset != 0UL) {
      {
#line 504
      die___0(4, 0, "file inode has zero size and non-zero offset");
      }
    }
  }
#line 506
  if (offset != 0UL) {
#line 506
    if (offset < start_data) {
#line 507
      start_data = offset;
    }
  }
#line 509
  if (opt_verbose___0) {
    {
#line 510
    print_node___0((char )'f', i, path);
    }
  }
#line 512
  if (opt_extract) {
    {
#line 513
    fd___0 = open((char const   *)path, 577, i->mode);
    }
#line 514
    if (fd___0 < 0) {
      {
#line 515
      die___0(8, 1, "open failed: %s", path);
      }
    }
  }
#line 518
  if (i->size) {
    {
#line 519
    do_uncompress(path, fd___0, offset, (unsigned long )i->size);
    }
  }
#line 521
  if (opt_extract) {
    {
#line 522
    close(fd___0);
#line 523
    change_file_status(path, i);
    }
  }
#line 525
  return;
}
}
#line 527 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void do_symlink(char *path , struct cramfs_inode *i ) 
{ 
  unsigned long offset ;
  unsigned long curr ;
  unsigned long next ;
  void *tmp ;
  unsigned long size ;
  void *tmp___0 ;
  int tmp___1 ;
  char *str ;
  int tmp___2 ;

  {
  {
#line 529
  offset = (unsigned long )(i->offset << 2);
#line 530
  curr = offset + 4UL;
#line 531
  tmp = romfs_read(offset);
#line 531
  next = (unsigned long )*((u32 *)tmp);
  }
#line 534
  if (offset == 0UL) {
    {
#line 535
    die___0(4, 0, "symbolic link has zero offset");
    }
  }
#line 537
  if (i->size == 0U) {
    {
#line 538
    die___0(4, 0, "symbolic link has zero size");
    }
  }
#line 541
  if (offset < start_data) {
#line 542
    start_data = offset;
  }
#line 544
  if (next > end_data) {
#line 545
    end_data = next;
  }
  {
#line 548
  tmp___0 = romfs_read(curr);
#line 548
  tmp___1 = uncompress_block(tmp___0, (int )(next - curr));
#line 548
  size = (unsigned long )tmp___1;
  }
#line 549
  if (size != (unsigned long )i->size) {
    {
#line 550
    die___0(4, 0, "size error in symlink: %s", path);
    }
  }
#line 552
  *(outbuffer + size) = (char)0;
#line 553
  if (opt_verbose___0) {
    {
#line 556
    asprintf((char **/* __restrict  */)(& str), (char const   */* __restrict  */)"%s -> %s",
             path, outbuffer);
#line 557
    print_node___0((char )'l', i, str);
    }
#line 558
    if (opt_verbose___0 > 1) {
      {
#line 559
      printf((char const   */* __restrict  */)"  uncompressing block at %ld to %ld (%ld)\n",
             curr, next, next - curr);
      }
    }
    {
#line 561
    free((void *)str);
    }
  }
#line 563
  if (opt_extract) {
    {
#line 564
    tmp___2 = symlink((char const   *)outbuffer, (char const   *)path);
    }
#line 564
    if (tmp___2 < 0) {
      {
#line 565
      die___0(8, 1, "symlink failed: %s", path);
      }
    }
    {
#line 567
    change_file_status(path, i);
    }
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void do_special_inode(char *path , struct cramfs_inode *i ) 
{ 
  dev_t devtype ;
  char type ;
  int tmp ;

  {
#line 573
  devtype = (dev_t )0;
#line 576
  if (i->offset) {
    {
#line 577
    die___0(4, 0, "special file has non-zero offset: %s", path);
    }
  }
#line 579
  if ((i->mode & 61440U) == 8192U) {
#line 580
    devtype = (dev_t )i->size;
#line 581
    type = (char )'c';
  } else
#line 583
  if ((i->mode & 61440U) == 24576U) {
#line 584
    devtype = (dev_t )i->size;
#line 585
    type = (char )'b';
  } else
#line 587
  if ((i->mode & 61440U) == 4096U) {
#line 588
    if (i->size != 0U) {
      {
#line 589
      die___0(4, 0, "fifo has non-zero size: %s", path);
      }
    }
#line 591
    type = (char )'p';
  } else
#line 593
  if ((i->mode & 61440U) == 49152U) {
#line 594
    if (i->size != 0U) {
      {
#line 595
      die___0(4, 0, "socket has non-zero size: %s", path);
      }
    }
#line 597
    type = (char )'s';
  } else {
    {
#line 600
    die___0(4, 0, "bogus mode: %s (%o)", path, i->mode);
    }
#line 601
    return;
  }
#line 604
  if (opt_verbose___0) {
    {
#line 605
    print_node___0(type, i, path);
    }
  }
#line 608
  if (opt_extract) {
    {
#line 609
    tmp = mknod((char const   *)path, i->mode, devtype);
    }
#line 609
    if (tmp < 0) {
      {
#line 610
      die___0(8, 1, "mknod failed: %s", path);
      }
    }
    {
#line 612
    change_file_status(path, i);
    }
  }
#line 614
  return;
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void expand_fs(char *path , struct cramfs_inode *inode ) 
{ 


  {
#line 618
  if ((inode->mode & 61440U) == 16384U) {
    {
#line 619
    do_directory(path, inode);
    }
  } else
#line 621
  if ((inode->mode & 61440U) == 32768U) {
    {
#line 622
    do_file(path, inode);
    }
  } else
#line 624
  if ((inode->mode & 61440U) == 40960U) {
    {
#line 625
    do_symlink(path, inode);
    }
  } else {
    {
#line 628
    do_special_inode(path, inode);
    }
  }
#line 630
  return;
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/cramfs-1.1/cramfsck.c"
static void test_fs(int start ) 
{ 
  struct cramfs_inode *root ;

  {
  {
#line 636
  root = read_super();
#line 637
  umask((__mode_t )0);
#line 638
  euid = geteuid();
#line 639
  stream.next_in = (Bytef *)((void *)0);
#line 640
  stream.avail_in = (uInt )0;
#line 641
  inflateInit_(& stream, "1.2.8", (int )sizeof(z_stream ));
#line 642
  expand_fs(extract_dir, root);
#line 643
  inflateEnd(& stream);
  }
#line 644
  if (start_data != 0xffffffffffffffffUL) {
#line 645
    if (start_data < sizeof(struct cramfs_super ) + (unsigned long )start) {
      {
#line 646
      die___0(4, 0, "directory data start (%ld) < sizeof(struct cramfs_super) + start (%ld)",
              start_data, sizeof(struct cramfs_super ) + (unsigned long )start);
      }
    }
#line 648
    if (end_dir != start_data) {
      {
#line 649
      die___0(4, 0, "directory data end (%ld) != file data start (%ld)", end_dir,
              start_data);
      }
    }
  }
#line 652
  if (super.flags & 1U) {
#line 653
    if (end_data > (unsigned long )super.size) {
      {
#line 654
      die___0(4, 0, "invalid file data offset");
      }
    }
  }
  {
#line 657
  iput(root);
  }
#line 658
  return;
}
}
