/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 17 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/liblnp.h"
enum __anonenum_lnp_init_result_29 {
    INIT_OK = 0,
    INIT_BAD_PARAM = 1,
    INIT_ERROR = 2
} ;
#line 17 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/liblnp.h"
typedef enum __anonenum_lnp_init_result_29 lnp_init_result;
#line 20 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/liblnp.h"
typedef int lnp_tx_result;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 31 "./lx.h"
struct __anonstruct_lx_t_35 {
   unsigned short version ;
   unsigned short base ;
   unsigned short text_size ;
   unsigned short data_size ;
   unsigned short bss_size ;
   unsigned short stack_size ;
   unsigned short offset ;
   unsigned short num_relocs ;
   unsigned char *text ;
   unsigned short *reloc ;
};
#line 31 "./lx.h"
typedef struct __anonstruct_lx_t_35 lx_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 379 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_32 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_35 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_36 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_37 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_30 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_31 _kill ;
   struct __anonstruct__timer_32 _timer ;
   struct __anonstruct__rt_33 _rt ;
   struct __anonstruct__sigchld_34 _sigchld ;
   struct __anonstruct__sigfault_35 _sigfault ;
   struct __anonstruct__sigpoll_36 _sigpoll ;
   struct __anonstruct__sigsys_37 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_29 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_30 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_29 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_46 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_46 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 14 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/liblnp.h"
typedef void (*lnp_addressing_handler_t)(unsigned char const   * , unsigned char  ,
                                         unsigned char  );
#line 35 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
enum __anonenum_rcv_state_t_58 {
    RCV_WAIT_FIRST = 0,
    RCV_WAIT_LEN = 1,
    RCV_WAIT_DATA = 2
} ;
#line 35 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
typedef enum __anonenum_rcv_state_t_58 rcv_state_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 35 "/usr/include/sched.h"
typedef __pid_t pid_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/sched.h"
struct sched_param {
   int __sched_priority ;
};
#line 68 "/usr/include/errno.h"
typedef int error_t;
#line 77 "/usr/include/argp.h"
struct argp_option {
   char const   *name ;
   int key ;
   char const   *arg ;
   int flags ;
   char const   *doc ;
   int group ;
};
#line 142
struct argp;
#line 143
struct argp_state;
#line 144
struct argp_child;
#line 216 "/usr/include/argp.h"
struct argp {
   struct argp_option  const  *options ;
   error_t (*parser)(int __key , char *__arg , struct argp_state *__state ) ;
   char const   *args_doc ;
   char const   *doc ;
   struct argp_child  const  *children ;
   char *(*help_filter)(int __key , char const   *__text , void *__input ) ;
   char const   *argp_domain ;
};
#line 282 "/usr/include/argp.h"
struct argp_child {
   struct argp  const  *argp ;
   int flags ;
   char const   *header ;
   int group ;
};
#line 307 "/usr/include/argp.h"
struct argp_state {
   struct argp  const  *root_argp ;
   int argc ;
   char **argv ;
   int next ;
   unsigned int flags ;
   unsigned int arg_num ;
   int quoted ;
   void *input ;
   void **child_inputs ;
   void *hook ;
   char *name ;
   FILE *err_stream ;
   FILE *out_stream ;
   void *pstate ;
};
#line 38 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c"
struct arguments {
   int highspeed ;
   int extra_wait ;
   int realtime ;
   int nolock ;
   char *tty_device ;
   unsigned short port ;
   char *logfile ;
   int dologging ;
   int lflag[7] ;
   int nodaemon ;
   int maxclients ;
};
#line 96 "/usr/include/linux/serial.h"
struct serial_icounter_struct {
   int cts ;
   int dsr ;
   int rng ;
   int dcd ;
   int rx ;
   int tx ;
   int frame ;
   int overrun ;
   int parity ;
   int brk ;
   int buf_overrun ;
   int reserved[9] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 19 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.h"
enum __anonenum_lnpd_rcv_state_t_56 {
    LNPD_READ_IDLE = 0,
    LNPD_READ_GOT_HEADER = 1,
    LNPD_READ_RECEIVING = 2,
    LNPD_READ_WAIT_TRANCSEIVER = 3,
    LNPD_READ_WAIT_RESULT = 4,
    LNPD_READ_WAIT_ACCESS = 5,
    LNPD_READ_SENDING_ACK = 6
} ;
#line 19 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.h"
typedef enum __anonenum_lnpd_rcv_state_t_56 lnpd_rcv_state_t;
#line 30
enum __anonenum_lnpd_tx_state_t_57 {
    LNPD_WRITE_IDLE = 0,
    LNPD_WRITE_WAIT_ACCESS = 1,
    LNPD_WRITE_SENDING_PACKET = 2,
    LNPD_WRITE_WAIT_ACK = 3
} ;
#line 30 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.h"
typedef enum __anonenum_lnpd_tx_state_t_57 lnpd_tx_state_t;
#line 38 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.h"
struct lnpd_client_info_struct {
   int descriptor ;
   lnpd_rcv_state_t rcv_state ;
   lnpd_tx_state_t tx_state ;
   unsigned char rcv_buffer[259] ;
   unsigned char tx_buffer[259] ;
   lnp_tx_result tx_result ;
   unsigned char *next_to_rcv ;
   int packet_length ;
   unsigned char *next_to_tx ;
   unsigned char *tx_end ;
   struct lnpd_client_info_struct *next ;
   struct lnpd_client_info_struct *previous ;
   unsigned int identity ;
};
#line 38 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.h"
typedef struct lnpd_client_info_struct lnpd_client_info_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 24 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.c"
enum __anonenum_lnp_integrity_state_t_34 {
    LNPwaitHeader = 0,
    LNPwaitLength = 1,
    LNPwaitData = 2,
    LNPwaitCRC = 3
} ;
#line 24 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.c"
typedef enum __anonenum_lnp_integrity_state_t_34 lnp_integrity_state_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 18 "/usr/include/linux/serial.h"
struct serial_struct {
   int type ;
   int line ;
   unsigned int port ;
   int irq ;
   int flags ;
   int xmit_fifo_size ;
   int custom_divisor ;
   int baud_base ;
   unsigned short close_delay ;
   char io_type ;
   char reserved_char[1] ;
   int hub6 ;
   unsigned short closing_wait ;
   unsigned short closing_wait2 ;
   unsigned char *iomem_base ;
   unsigned short iomem_reg_shift ;
   unsigned int port_high ;
   unsigned long iomap_base ;
};
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 48 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/liblnp.h"
lnp_init_result lnp_init(char *tcp_hostname , unsigned short tcp_port , unsigned char lnp_address ,
                         unsigned char lnp_mask , int flags ) ;
#line 61
void lnp_integrity_set_handler(void (*handler)(unsigned char const   * , unsigned char  ) ) ;
#line 64
void lnp_addressing_set_handler(unsigned char port , void (*handler)(unsigned char const   * ,
                                                                     unsigned char  ,
                                                                     unsigned char  ) ) ;
#line 80
lnp_tx_result lnp_addressing_write(unsigned char const   *data , unsigned char length ,
                                   unsigned char dest , unsigned char srcport___0 ) ;
#line 22 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/lnptest.c"
void addr_handler_1(unsigned char const   *data , unsigned char length , unsigned char src ) 
{ 
  char pbuf[100] ;
  size_t tmp ;

  {
  {
#line 26
  sprintf((char */* __restrict  */)(pbuf), (char const   */* __restrict  */)">> Source:%2X Length:%u PacketNo:%u <<\n",
          (unsigned int )src, (unsigned int )length, (unsigned int )*(data + 0));
#line 28
  tmp = strlen((char const   *)(pbuf));
#line 28
  write(2, (void const   *)(pbuf), tmp);
  }
#line 29
  return;
}
}
#line 31 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/lnptest.c"
void addr_handler_2(unsigned char const   *data , unsigned char length , unsigned char src ) 
{ 
  char pbuf[100] ;
  size_t tmp ;

  {
  {
#line 35
  sprintf((char */* __restrict  */)(pbuf), (char const   */* __restrict  */)">> Source:%2X Length:%u PacketNo:%u <<\n",
          (unsigned int )src, (unsigned int )length, (unsigned int )*(data + 0));
#line 37
  tmp = strlen((char const   *)(pbuf));
#line 37
  write(2, (void const   *)(pbuf), tmp);
  }
#line 38
  return;
}
}
#line 40 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/lnptest.c"
void int_handler(unsigned char const   *data , unsigned char length ) 
{ 
  char pbuf[100] ;
  size_t tmp ;

  {
  {
#line 44
  sprintf((char */* __restrict  */)(pbuf), (char const   */* __restrict  */)">> Integrity Length:%u PacketNo:%u <<\n",
          (unsigned int )length, (unsigned int )*(data + 0));
#line 46
  tmp = strlen((char const   *)(pbuf));
#line 46
  write(2, (void const   *)(pbuf), tmp);
  }
#line 47
  return;
}
}
#line 49 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/lnptest.c"
int main(int argc , char **argv ) 
{ 
  char data[253] ;
  int i ;
  lnp_tx_result result ;
  unsigned char len ;
  int count ;
  lnp_init_result tmp ;
  int tmp___0 ;

  {
#line 55
  count = 0;
#line 57
  i = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! ((unsigned long )i < sizeof(data))) {
#line 57
      goto while_break;
    }
#line 57
    data[i] = (char )i;
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  tmp = lnp_init((char *)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
                 0);
  }
#line 59
  if (tmp) {
    {
#line 61
    perror("lnp_init");
#line 62
    exit(1);
    }
  } else {
    {
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"init OK\n");
    }
  }
  {
#line 67
  lnp_addressing_set_handler((unsigned char)7, & addr_handler_1);
#line 68
  lnp_addressing_set_handler((unsigned char)8, & addr_handler_2);
#line 69
  lnp_integrity_set_handler(& int_handler);
  }
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 75
    len = (unsigned char)253;
#line 76
    result = lnp_addressing_write((unsigned char const   *)(data), len, (unsigned char)2,
                                  (unsigned char)7);
    }
    {
#line 79
    if ((unsigned int )result == 0U) {
#line 79
      goto case_0;
    }
#line 82
    if ((unsigned int )result == 1U) {
#line 82
      goto case_1;
    }
#line 85
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 80
    tmp___0 = count;
#line 80
    count ++;
#line 80
    printf((char const   */* __restrict  */)"Tansmitted %d : %d\n", (int )len, tmp___0);
    }
#line 81
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 83
    printf((char const   */* __restrict  */)"Collision\n");
    }
#line 84
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 86
    perror("Transmit error");
#line 87
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 91
  return (0);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 192
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 48 "./lx.h"
int lx_write(lx_t const   *lx , unsigned char const   *filename ) ;
#line 51
int lx_read(lx_t *lx , unsigned char const   *filename ) ;
#line 54
void lx_relocate(lx_t *lx , unsigned short base ) ;
#line 51 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/lx.c"
int lx_write(lx_t const   *lx , unsigned char const   *filename ) 
{ 
  int i ;
  int rc ;
  int fd___0 ;
  int tmp ;
  unsigned short tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
  {
#line 52
  tmp = creat((char const   *)filename, (mode_t )(384 | (256 >> 3)));
#line 52
  fd___0 = tmp;
  }
#line 55
  if (fd___0 < 0) {
#line 56
    return (fd___0);
  }
  {
#line 60
  tmp___1 = write(fd___0, (void const   *)"brickOS", (size_t )8);
#line 60
  rc = (int )tmp___1;
  }
#line 60
  if (rc != 8) {
    {
#line 60
    close(fd___0);
    }
#line 60
    return (rc);
  }
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < 8)) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp___0 = htons(*((unsigned short *)lx + i));
#line 65
    tmp___2 = write(fd___0, (void const   *)(& tmp___0), (size_t )2);
#line 65
    rc = (int )tmp___2;
    }
#line 65
    if (rc != 2) {
      {
#line 65
      close(fd___0);
      }
#line 65
      return (rc);
    }
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  tmp___3 = write(fd___0, (void const   *)lx->text, (size_t )((int const   )lx->text_size + (int const   )lx->data_size));
#line 70
  rc = (int )tmp___3;
  }
#line 70
  if (rc != (int )((int const   )lx->text_size + (int const   )lx->data_size)) {
    {
#line 70
    close(fd___0);
    }
#line 70
    return (rc);
  }
#line 74
  i = 0;
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 74
    if (! (i < (int )lx->num_relocs)) {
#line 74
      goto while_break___0;
    }
    {
#line 75
    tmp___0 = htons(*(lx->reloc + i));
#line 76
    tmp___4 = write(fd___0, (void const   *)(& tmp___0), (size_t )2);
#line 76
    rc = (int )tmp___4;
    }
#line 76
    if (rc != 2) {
      {
#line 76
      close(fd___0);
      }
#line 76
      return (rc);
    }
#line 74
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 79
  close(fd___0);
  }
#line 80
  return (0);
}
}
#line 83 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/lx.c"
int lx_read(lx_t *lx , unsigned char const   *filename ) 
{ 
  int i ;
  int rc ;
  int fd___0 ;
  int tmp ;
  unsigned char buffer___5[6] ;
  unsigned short tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  unsigned char *tmp___4 ;
  void *tmp___5 ;
  ssize_t tmp___6 ;
  unsigned short *tmp___7 ;
  void *tmp___8 ;
  ssize_t tmp___9 ;

  {
  {
#line 84
  tmp = open((char const   *)filename, 0);
#line 84
  fd___0 = tmp;
  }
#line 88
  if (fd___0 < 0) {
#line 89
    return (fd___0);
  }
  {
#line 93
  tmp___1 = read(fd___0, (void *)(buffer___5), (size_t )8);
#line 93
  rc = (int )tmp___1;
  }
#line 93
  if (rc != 8) {
    {
#line 93
    close(fd___0);
    }
#line 93
    return (rc);
  }
  {
#line 94
  tmp___2 = strcmp((char const   *)(buffer___5), "brickOS");
  }
#line 94
  if (tmp___2) {
    {
#line 95
    close(fd___0);
    }
#line 96
    return (-1);
  }
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < 8)) {
#line 101
      goto while_break;
    }
    {
#line 102
    tmp___3 = read(fd___0, (void *)(& tmp___0), (size_t )2);
#line 102
    rc = (int )tmp___3;
    }
#line 102
    if (rc != 2) {
      {
#line 102
      close(fd___0);
      }
#line 102
      return (rc);
    }
    {
#line 103
    *((unsigned short *)lx + i) = ntohs(tmp___0);
#line 101
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  tmp___5 = malloc((size_t )((int )lx->text_size + (int )lx->data_size));
#line 108
  tmp___4 = (unsigned char *)tmp___5;
#line 108
  lx->text = tmp___4;
  }
#line 108
  if ((unsigned long )tmp___4 == (unsigned long )((unsigned char *)0)) {
    {
#line 109
    close(fd___0);
    }
#line 110
    return (-1);
  }
  {
#line 112
  tmp___6 = read(fd___0, (void *)lx->text, (size_t )((int )lx->text_size + (int )lx->data_size));
#line 112
  rc = (int )tmp___6;
  }
#line 112
  if (rc != (int )lx->text_size + (int )lx->data_size) {
    {
#line 112
    close(fd___0);
    }
#line 112
    return (rc);
  }
#line 116
  if (lx->num_relocs) {
    {
#line 117
    tmp___8 = malloc(sizeof(unsigned short ) * (unsigned long )lx->num_relocs);
#line 117
    tmp___7 = (unsigned short *)tmp___8;
#line 117
    lx->reloc = tmp___7;
    }
#line 117
    if ((unsigned long )tmp___7 == (unsigned long )((unsigned short *)0)) {
      {
#line 118
      close(fd___0);
      }
#line 119
      return (-1);
    }
#line 122
    i = 0;
    {
#line 122
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 122
      if (! (i < (int )lx->num_relocs)) {
#line 122
        goto while_break___0;
      }
      {
#line 123
      tmp___9 = read(fd___0, (void *)(& tmp___0), (size_t )2);
#line 123
      rc = (int )tmp___9;
      }
#line 123
      if (rc != 2) {
        {
#line 123
        close(fd___0);
        }
#line 123
        return (rc);
      }
      {
#line 124
      *(lx->reloc + i) = ntohs(tmp___0);
#line 122
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 128
  return (0);
}
}
#line 131 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/lx.c"
void lx_relocate(lx_t *lx , unsigned short base ) 
{ 
  unsigned short diff ;
  int i ;
  unsigned char *ptr ;
  unsigned short off ;

  {
#line 132
  diff = (unsigned short )((int )base - (int )lx->base);
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < (int )lx->num_relocs)) {
#line 136
      goto while_break;
    }
#line 137
    ptr = lx->text + (int )*(lx->reloc + i);
#line 138
    off = (unsigned short )(((int )*(ptr + 0) << 8) | (int )*(ptr + 1));
#line 140
    off = (unsigned short )((int )off + (int )diff);
#line 141
    *(ptr + 0) = (unsigned char )((int )off >> 8);
#line 142
    *(ptr + 1) = (unsigned char )((int )off & 255);
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  lx->base = base;
#line 146
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 73 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 256
extern int ( __attribute__((__nonnull__(1))) sigsuspend)(sigset_t const   *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 58 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/liblnp.h"
void lnp_shutdown(void) ;
#line 72
lnp_tx_result lnp_integrity_write(unsigned char const   *data , unsigned char length ) ;
#line 86
void block_rcv(void) ;
#line 91
void unblock_rcv(void) ;
#line 37 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_host_address  ;
#line 38 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_host_mask  ;
#line 39 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_port_mask  ;
#line 40 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int discard_while_tx  ;
#line 41 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int socket_fd  ;
#line 42 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int connected  ;
#line 43 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int tx_active  ;
#line 44 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_tx_result tx_result  ;
#line 45 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_buffer[259]  ;
#line 46 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void (*integrity_handler)(unsigned char const   * , unsigned char  )  ;
#line 47 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_addressing_handler_t addressing_handler[256]  ;
#line 48 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static rcv_state_t rcv_state  ;
#line 51 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void msecs2timeval(int msecs , struct timeval *tval ) 
{ 


  {
#line 53
  tval->tv_sec = (__time_t )(msecs / 1000);
#line 54
  tval->tv_usec = (__suseconds_t )((msecs * 1000) % 1000000);
#line 55
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned short lnp_checksum(unsigned char const   *data , unsigned int length ) 
{ 
  unsigned char a ;
  unsigned char b ;

  {
#line 59
  a = (unsigned char)255;
#line 60
  b = (unsigned char)255;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (length > 0U)) {
#line 62
      goto while_break;
    }
#line 63
    a = (unsigned char )((int )a + (int )*data);
#line 64
    b = (unsigned char )((int )b + (int )a);
#line 65
    data ++;
#line 66
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return ((unsigned short )((int )a + ((int )b << 8)));
}
}
#line 72 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
void block_rcv(void) 
{ 
  sigset_t newset ;

  {
  {
#line 75
  sigemptyset(& newset);
#line 76
  sigaddset(& newset, 29);
#line 77
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& newset), (sigset_t */* __restrict  */)((void *)0));
  }
#line 78
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
void unblock_rcv(void) 
{ 
  sigset_t newset ;

  {
  {
#line 83
  sigemptyset(& newset);
#line 84
  sigaddset(& newset, 29);
#line 85
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& newset), (sigset_t */* __restrict  */)((void *)0));
  }
#line 86
  return;
}
}
#line 88 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
void lnp_integrity_set_handler(void (*handler)(unsigned char const   * , unsigned char  ) ) 
{ 


  {
  {
#line 90
  block_rcv();
#line 91
  integrity_handler = handler;
#line 92
  unblock_rcv();
  }
#line 93
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
void lnp_addressing_set_handler(unsigned char port , void (*handler)(unsigned char const   * ,
                                                                     unsigned char  ,
                                                                     unsigned char  ) ) 
{ 


  {
  {
#line 97
  block_rcv();
#line 98
  addressing_handler[port] = handler;
#line 99
  unblock_rcv();
  }
#line 100
  return;
}
}
#line 102 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
void lnp_shutdown(void) 
{ 
  struct sigaction saction ;

  {
  {
#line 106
  block_rcv();
  }
#line 107
  if (connected) {
    {
#line 107
    close(socket_fd);
    }
  }
  {
#line 108
  saction.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 109
  sigemptyset(& saction.sa_mask);
#line 110
  saction.sa_flags = 0;
#line 111
  sigaction(29, (struct sigaction  const  */* __restrict  */)(& saction), (struct sigaction */* __restrict  */)((void *)0));
#line 112
  connected = 0;
#line 113
  tx_active = 0;
#line 114
  rcv_state = (rcv_state_t )0;
#line 115
  unblock_rcv();
  }
#line 116
  return;
}
}
#line 118 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void lnp_receive_packet(unsigned char const   *data ) 
{ 
  unsigned char header ;
  unsigned char const   *tmp ;
  unsigned char length ;
  unsigned char const   *tmp___0 ;
  unsigned char dest ;
  unsigned char const   *tmp___1 ;
  unsigned char port ;
  unsigned char src ;
  unsigned char const   *tmp___2 ;

  {
#line 119
  tmp = data;
#line 119
  data ++;
#line 119
  header = (unsigned char )*tmp;
#line 120
  tmp___0 = data;
#line 120
  data ++;
#line 120
  length = (unsigned char )*tmp___0;
  {
#line 125
  if ((int )header == 240) {
#line 125
    goto case_240;
  }
#line 130
  if ((int )header == 241) {
#line 130
    goto case_241;
  }
#line 124
  goto switch_break;
  case_240: /* CIL Label */ 
#line 126
  if (integrity_handler) {
    {
#line 127
    (*integrity_handler)(data, length);
    }
  }
#line 128
  goto switch_break;
  case_241: /* CIL Label */ 
#line 131
  if ((int )length > 2) {
#line 132
    tmp___1 = data;
#line 132
    data ++;
#line 132
    dest = (unsigned char )*tmp___1;
#line 134
    if ((int )lnp_host_address == ((int )dest & (int )lnp_host_mask)) {
#line 135
      port = (unsigned char )((int )dest & (int )lnp_port_mask);
#line 137
      if (addressing_handler[port]) {
        {
#line 138
        tmp___2 = data;
#line 138
        data ++;
#line 138
        src = (unsigned char )*tmp___2;
#line 139
        (*(addressing_handler[port]))(data, (unsigned char )((int )length - 2), src);
        }
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 144
  return;
}
}
#line 151
static int transmit_ack(void) ;
#line 151 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char ack_byte  =    (unsigned char)51;
#line 146 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int transmit_ack(void) 
{ 
  fd_set fds ;
  struct timeval timeout ;
  int result ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.fds_bits[0]): "memory");
#line 156
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 157
    fds.fds_bits[socket_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket_fd % (8 * (int )sizeof(__fd_mask ));
#line 158
    msecs2timeval(1000, & timeout);
#line 159
    result = select(socket_fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
    }
#line 160
    if (result == 1) {
#line 160
      goto while_break;
    }
#line 161
    if (result < 0) {
      {
#line 161
      tmp = __errno_location();
      }
#line 161
      if (*tmp == 4) {
#line 161
        goto while_continue;
      }
    }
#line 163
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 166
  tmp___0 = write(socket_fd, (void const   *)(& ack_byte), (size_t )1);
#line 166
  result = (int )tmp___0;
  }
#line 166
  if (result != 1) {
#line 167
    return (-1);
  }
#line 169
  return (0);
}
}
#line 173 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char buffer[259]  ;
#line 174 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int bytesRead  ;
#line 174 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int endOfData  ;
#line 172 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int receive_byte(unsigned char byte_read ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 176
  if ((unsigned int )rcv_state == 0U) {
#line 177
    bytesRead = 0;
  }
#line 179
  tmp = bytesRead;
#line 179
  bytesRead ++;
#line 179
  buffer[tmp] = byte_read;
  {
#line 183
  if ((unsigned int )rcv_state == 0U) {
#line 183
    goto case_0;
  }
#line 198
  if ((unsigned int )rcv_state == 1U) {
#line 198
    goto case_1;
  }
#line 202
  if ((unsigned int )rcv_state == 2U) {
#line 202
    goto case_2;
  }
#line 181
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 186
  if ((int )byte_read == 51) {
#line 186
    goto case_51;
  }
#line 190
  if ((int )byte_read == 119) {
#line 190
    goto case_119;
  }
#line 194
  goto switch_default;
  case_51: /* CIL Label */ 
#line 187
  tx_result = (lnp_tx_result )0;
#line 188
  tx_active = 0;
#line 189
  goto switch_break___0;
  case_119: /* CIL Label */ 
#line 191
  tx_result = (lnp_tx_result )1;
#line 192
  tx_active = 0;
#line 193
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 195
  rcv_state = (rcv_state_t )((unsigned int )rcv_state + 1U);
  switch_break___0: /* CIL Label */ ;
  }
#line 197
  goto switch_break;
  case_1: /* CIL Label */ 
#line 199
  endOfData = (int )byte_read + 3;
#line 200
  rcv_state = (rcv_state_t )((unsigned int )rcv_state + 1U);
#line 201
  goto switch_break;
  case_2: /* CIL Label */ 
#line 203
  if (bytesRead == endOfData) {
    {
#line 205
    rcv_state = (rcv_state_t )0;
#line 206
    tmp___0 = transmit_ack();
    }
#line 206
    if (tmp___0) {
#line 206
      return (-1);
    }
#line 207
    if (tx_active) {
#line 207
      if (! discard_while_tx) {
        {
#line 208
        lnp_receive_packet((unsigned char const   *)(buffer));
        }
      }
    } else {
      {
#line 208
      lnp_receive_packet((unsigned char const   *)(buffer));
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 211
  return (0);
}
}
#line 214 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void rcv_handler(int signo ) 
{ 
  unsigned char buffer___5[259] ;
  unsigned char *recvd_byte ;
  int length ;
  int i ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 221
  tmp = read(socket_fd, (void *)(buffer___5), sizeof(buffer___5));
#line 221
  length = (int )tmp;
  }
#line 222
  if (length < 1) {
#line 224
    if (tx_active) {
#line 226
      tx_active = 0;
#line 227
      tx_result = (lnp_tx_result )2;
    } else {
      {
#line 229
      lnp_shutdown();
      }
    }
#line 230
    return;
  }
#line 233
  i = 0;
#line 233
  recvd_byte = buffer___5;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i < length)) {
#line 233
      goto while_break;
    }
    {
#line 235
    tmp___0 = receive_byte(*recvd_byte);
    }
#line 235
    if (tmp___0) {
#line 237
      if (tx_active) {
#line 239
        tx_active = 0;
#line 240
        tx_result = (lnp_tx_result )2;
      } else {
        {
#line 242
        lnp_shutdown();
        }
      }
#line 243
      return;
    }
#line 233
    i ++;
#line 233
    recvd_byte ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return;
}
}
#line 248 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_tx_result lnp_logical_write(unsigned char *data , int length ) 
{ 
  int written ;
  int result ;
  sigset_t newset ;
  sigset_t oldset ;
  fd_set fds ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
#line 250
  written = 0;
#line 255
  if (! connected) {
#line 255
    return ((lnp_tx_result )2);
  }
  {
#line 258
  sigemptyset(& newset);
#line 259
  sigaddset(& newset, 29);
#line 260
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& newset), (sigset_t */* __restrict  */)(& oldset));
#line 262
  tx_active = 1;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! (written != length)) {
#line 265
      goto while_break;
    }
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 270
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 270
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& fds.fds_bits[0]): "memory");
#line 270
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 271
      fds.fds_bits[socket_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket_fd % (8 * (int )sizeof(__fd_mask ));
#line 272
      msecs2timeval(5000, & timeout);
#line 273
      result = select(socket_fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
      }
#line 274
      if (result == 1) {
#line 274
        goto while_break___0;
      }
#line 275
      if (result < 0) {
        {
#line 275
        tmp = __errno_location();
        }
#line 275
        if (*tmp == 4) {
#line 275
          goto while_continue___0;
        }
      }
      {
#line 277
      lnp_shutdown();
      }
#line 278
      return ((lnp_tx_result )2);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 281
    tmp___0 = write(socket_fd, (void const   *)(data + written), (size_t )(length - written));
#line 281
    result = (int )tmp___0;
    }
#line 282
    if (result < 1) {
      {
#line 284
      lnp_shutdown();
      }
#line 285
      return ((lnp_tx_result )2);
    }
#line 287
    written += result;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 291
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 293
    sigsuspend((sigset_t const   *)(& oldset));
    }
#line 294
    if (! tx_active) {
#line 294
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 297
  if ((unsigned int )tx_result == 2U) {
    {
#line 297
    lnp_shutdown();
    }
  }
  {
#line 299
  unblock_rcv();
  }
#line 301
  return (tx_result);
}
}
#line 304 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
lnp_tx_result lnp_integrity_write(unsigned char const   *data , unsigned char length ) 
{ 
  unsigned short tmp ;
  lnp_tx_result tmp___0 ;

  {
  {
#line 305
  lnp_buffer[0] = (unsigned char)240;
#line 306
  lnp_buffer[1] = length;
#line 307
  memcpy((void */* __restrict  */)(lnp_buffer + 2), (void const   */* __restrict  */)data,
         (size_t )length);
#line 308
  tmp = lnp_checksum((unsigned char const   *)(lnp_buffer), (unsigned int )((int )length + 2));
#line 308
  lnp_buffer[(int )length + 2] = (unsigned char )tmp;
#line 310
  tmp___0 = lnp_logical_write(lnp_buffer, (int )length + 3);
  }
#line 310
  return (tmp___0);
}
}
#line 313 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
lnp_tx_result lnp_addressing_write(unsigned char const   *data , unsigned char length ,
                                   unsigned char dest , unsigned char srcport___0 ) 
{ 
  unsigned short tmp ;
  lnp_tx_result tmp___0 ;

  {
  {
#line 315
  lnp_buffer[0] = (unsigned char)241;
#line 316
  lnp_buffer[1] = (unsigned char )((int )length + 2);
#line 317
  lnp_buffer[2] = dest;
#line 318
  lnp_buffer[3] = (unsigned char )((int )lnp_host_address | ((int )srcport___0 & (int )lnp_port_mask));
#line 319
  memcpy((void */* __restrict  */)(lnp_buffer + 4), (void const   */* __restrict  */)data,
         (size_t )length);
#line 320
  tmp = lnp_checksum((unsigned char const   *)(lnp_buffer), (unsigned int )((int )length + 4));
#line 320
  lnp_buffer[(int )length + 4] = (unsigned char )tmp;
#line 322
  tmp___0 = lnp_logical_write(lnp_buffer, (int )length + 5);
  }
#line 322
  return (tmp___0);
}
}
#line 325 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
lnp_init_result lnp_init(char *tcp_hostname , unsigned short tcp_port , unsigned char lnp_address ,
                         unsigned char lnp_mask , int flags ) 
{ 
  struct hostent *hostentry ;
  struct in_addr hostaddress ;
  struct linger opt_nolinger ;
  struct sockaddr_in server_address ;
  struct sigaction saction ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 330
  opt_nolinger.l_onoff = 0;
#line 330
  opt_nolinger.l_linger = 0;
#line 334
  lnp_shutdown();
  }
#line 337
  if (! tcp_hostname) {
    {
#line 338
    inet_aton("127.0.0.1", & hostaddress);
    }
  } else {
    {
#line 339
    tmp = inet_aton((char const   *)tcp_hostname, & hostaddress);
    }
#line 339
    if (! tmp) {
      {
#line 342
      hostentry = gethostbyname((char const   *)tcp_hostname);
      }
#line 343
      if (! hostentry) {
#line 343
        return ((lnp_init_result )1);
      }
#line 344
      hostaddress = *((struct in_addr *)*(hostentry->h_addr_list + 0));
    }
  }
#line 348
  if (! tcp_port) {
#line 348
    tcp_port = (unsigned short)7776;
  }
#line 349
  if (lnp_address) {
#line 349
    lnp_host_address = lnp_address;
  } else {
#line 349
    lnp_host_address = (unsigned char)128;
  }
#line 350
  if (lnp_mask) {
#line 350
    lnp_host_mask = lnp_mask;
  } else {
#line 350
    lnp_host_mask = (unsigned char)240;
  }
#line 351
  lnp_port_mask = (unsigned char )((int )lnp_host_mask ^ 255);
#line 352
  if (((int )lnp_host_address & (int )lnp_host_mask) != (int )lnp_host_address) {
#line 352
    return ((lnp_init_result )1);
  }
  {
#line 353
  discard_while_tx = (flags & 1) == 1;
#line 356
  socket_fd = socket(2, 1, 0);
  }
#line 356
  if (socket_fd < 0) {
#line 356
    return ((lnp_init_result )2);
  }
  {
#line 357
  setsockopt(socket_fd, 1, 13, (void const   *)(& opt_nolinger), (socklen_t )sizeof(opt_nolinger));
#line 359
  block_rcv();
#line 361
  connected = 1;
#line 364
  saction.__sigaction_handler.sa_handler = & rcv_handler;
#line 365
  sigemptyset(& saction.sa_mask);
#line 366
  saction.sa_flags = 0;
#line 367
  sigaction(29, (struct sigaction  const  */* __restrict  */)(& saction), (struct sigaction */* __restrict  */)((void *)0));
#line 370
  server_address.sin_family = (sa_family_t )2;
#line 371
  server_address.sin_port = htons(tcp_port);
#line 372
  server_address.sin_addr = hostaddress;
#line 373
  tmp___0 = connect(socket_fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& server_address)),
                    (socklen_t )sizeof(server_address));
  }
#line 373
  if (tmp___0) {
    {
#line 375
    lnp_shutdown();
    }
#line 376
    return ((lnp_init_result )2);
  }
  {
#line 379
  tmp___1 = fcntl(socket_fd, 4, 10240);
  }
#line 379
  if (tmp___1) {
    {
#line 386
    lnp_shutdown();
    }
#line 387
    return ((lnp_init_result )2);
  } else {
    {
#line 379
    tmp___2 = getpid();
#line 379
    tmp___3 = fcntl(socket_fd, 8, tmp___2);
    }
#line 379
    if (tmp___3) {
      {
#line 386
      lnp_shutdown();
      }
#line 387
      return ((lnp_init_result )2);
    } else {
      {
#line 379
      tmp___4 = fcntl(socket_fd, 10, 29);
      }
#line 379
      if (tmp___4) {
        {
#line 386
        lnp_shutdown();
        }
#line 387
        return ((lnp_init_result )2);
      }
    }
  }
  {
#line 390
  unblock_rcv();
  }
#line 391
  return ((lnp_init_result )0);
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 70 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/loader2.c"
static struct option  const  long_options[6]  = {      {"rcxaddr", 1, (int *)0, 'r'}, 
        {"program", 1, (int *)0, 'p'}, 
        {"srcport", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"lnp_server", 1, (int *)0, 'l'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 79 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/loader2.c"
int volatile   receivedAck  =    (int volatile   )0;
#line 81 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/loader2.c"
unsigned short volatile   relocate_to  =    (unsigned short volatile   )0;
#line 84 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/loader2.c"
unsigned int rcxaddr  =    0U;
#line 85 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/loader2.c"
unsigned int prog  =    1U;
#line 86 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/loader2.c"
unsigned int srcport  =    0U;
#line 87 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/loader2.c"
char *server  ;
#line 88 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/loader2.c"
int verbose_flag  =    0;
#line 93 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/loader2.c"
static void msecs2timeval___0(int msecs , struct timeval *tval ) 
{ 


  {
#line 95
  tval->tv_sec = (__time_t )(msecs / 1000);
#line 96
  tval->tv_usec = (__suseconds_t )((msecs * 1000) % 1000000);
#line 97
  return;
}
}
#line 100 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/loader2.c"
static void msleep(unsigned int msecs ) 
{ 
  struct timeval wtime ;
  struct timeval now ;
  struct timeval end ;
  int tmp ;
  int result ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 104
  tmp = gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
#line 104
  if (tmp) {
    {
#line 104
    perror("gettimeofday");
#line 104
    exit(1);
    }
  }
  {
#line 105
  msecs2timeval___0((int )msecs, & wtime);
  }
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    end.tv_sec = now.tv_sec + wtime.tv_sec;
#line 107
    end.tv_usec = now.tv_usec + wtime.tv_usec;
#line 107
    if (end.tv_usec >= 1000000L) {
#line 107
      (end.tv_sec) ++;
#line 107
      end.tv_usec -= 1000000L;
    }
#line 107
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 111
    tmp___0 = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& wtime));
#line 111
    result = tmp___0;
    }
#line 112
    if (result < 0) {
      {
#line 112
      tmp___1 = __errno_location();
      }
#line 112
      if (*tmp___1 != 4) {
        {
#line 112
        perror("select()");
#line 112
        exit(1);
        }
      }
    }
    {
#line 113
    tmp___2 = gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
    }
#line 113
    if (tmp___2) {
      {
#line 113
      perror("gettimeofday");
#line 113
      exit(1);
      }
    }
#line 114
    if (now.tv_sec == end.tv_sec) {
#line 114
      tmp___3 = now.tv_usec < end.tv_usec;
    } else {
#line 114
      tmp___3 = now.tv_sec < end.tv_sec;
    }
#line 114
    if (! tmp___3) {
#line 114
      goto while_break___0;
    }
    {
#line 115
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 115
      wtime.tv_sec = end.tv_sec - now.tv_sec;
#line 115
      wtime.tv_usec = end.tv_usec - now.tv_usec;
#line 115
      if (wtime.tv_usec < 0L) {
#line 115
        (wtime.tv_sec) --;
#line 115
        wtime.tv_usec += 1000000L;
      }
#line 115
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 117
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/loader2.c"
int lnp_assured_write(unsigned char const   *data , unsigned char length , unsigned char dest ,
                      unsigned char srcport___0 ) 
{ 
  int tx_errors ;
  int rcv_errors ;
  lnp_tx_result result ;
  struct timeval now ;
  struct timeval diff ;
  struct timeval end ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 124
  tx_errors = 0;
#line 124
  rcv_errors = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 130
    receivedAck = (int volatile   )0;
#line 132
    result = lnp_addressing_write(data, length, dest, srcport___0);
    }
#line 133
    if ((unsigned int )result == 2U) {
#line 133
      goto while_break;
    }
#line 134
    if ((unsigned int )result == 1U) {
#line 137
      if (verbose_flag) {
        {
#line 137
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tx_failure %d\n",
                tx_errors);
        }
      }
#line 138
      tx_errors ++;
#line 138
      if (tx_errors > 7) {
#line 138
        goto while_break;
      }
      {
#line 140
      msleep((unsigned int )(100 * (1 << tx_errors)));
      }
    } else {
      {
#line 145
      tmp = gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
      }
#line 145
      if (tmp) {
        {
#line 145
        perror("gettimeofday");
#line 145
        exit(1);
        }
      }
      {
#line 146
      msecs2timeval___0(200, & diff);
      }
      {
#line 147
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 147
        end.tv_sec = now.tv_sec + diff.tv_sec;
#line 147
        end.tv_usec = now.tv_usec + diff.tv_usec;
#line 147
        if (end.tv_usec >= 1000000L) {
#line 147
          (end.tv_sec) ++;
#line 147
          end.tv_usec -= 1000000L;
        }
#line 147
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 148
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 151
        msecs2timeval___0(20, & diff);
#line 152
        tmp___0 = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                         (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& diff));
#line 152
        result = (lnp_tx_result )tmp___0;
        }
#line 153
        if ((unsigned int )result < 0U) {
          {
#line 153
          tmp___1 = __errno_location();
          }
#line 153
          if (*tmp___1 != 4) {
            {
#line 153
            perror("select()");
#line 153
            exit(1);
            }
          }
        }
#line 154
        if (receivedAck) {
          {
#line 156
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"transmitted %u\n",
                  (unsigned int )length);
          }
#line 157
          return (0);
        }
        {
#line 159
        tmp___2 = gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
        }
#line 159
        if (tmp___2) {
          {
#line 159
          perror("gettimeofday");
#line 159
          exit(1);
          }
        }
#line 160
        if (now.tv_sec == end.tv_sec) {
#line 160
          tmp___3 = now.tv_usec < end.tv_usec;
        } else {
#line 160
          tmp___3 = now.tv_sec < end.tv_sec;
        }
#line 160
        if (! tmp___3) {
#line 160
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 163
      if (verbose_flag) {
        {
#line 163
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rx_timeout %d\n",
                rcv_errors);
        }
      }
#line 164
      rcv_errors ++;
#line 164
      if (rcv_errors > 5) {
#line 164
        goto while_break;
      }
      {
#line 166
      msleep((unsigned int )(50 * (1 << rcv_errors)));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return (-1);
}
}
#line 172 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/loader2.c"
void ahandler(unsigned char const   *data , unsigned char len , unsigned char src ) 
{ 


  {
#line 173
  if ((int const   )*data == 0) {
#line 174
    receivedAck = (int volatile   )1;
#line 175
    if ((int )len == 8) {
#line 178
      relocate_to = (unsigned short volatile   )(((int const   )*(data + 2) << 8) | (int const   )*(data + 3));
    }
  }
#line 181
  return;
}
}
#line 184 "/home/wheatley/newnew/temp/lnpd-0.9.0/dllx/loader2.c"
void lnp_download(lx_t const   *lx ) 
{ 
  unsigned char buffer___5[259] ;
  size_t i ;
  size_t chunkSize ;
  size_t totalSize ;
  int tmp ;

  {
#line 187
  totalSize = (size_t )((int const   )lx->text_size + (int const   )lx->data_size);
#line 189
  if (verbose_flag) {
    {
#line 190
    fputs((char const   */* __restrict  */)"data\n", (FILE */* __restrict  */)stderr);
    }
  }
#line 192
  buffer___5[0] = (unsigned char)4;
#line 193
  buffer___5[1] = (unsigned char )prog;
#line 195
  i = (size_t )0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < totalSize)) {
#line 195
      goto while_break;
    }
#line 196
    chunkSize = totalSize - i;
#line 197
    if (chunkSize > 248UL) {
#line 198
      chunkSize = (size_t )248;
    }
    {
#line 200
    buffer___5[2] = (unsigned char )(i >> 8);
#line 201
    buffer___5[3] = (unsigned char )(i & 255UL);
#line 202
    memcpy((void */* __restrict  */)(buffer___5 + 4), (void const   */* __restrict  */)(lx->text + i),
           chunkSize);
#line 203
    tmp = lnp_assured_write((unsigned char const   *)(buffer___5), (unsigned char )(chunkSize + 4UL),
                            (unsigned char )rcxaddr, (unsigned char )srcport);
    }
#line 203
    if (tmp) {
      {
#line 204
      fputs((char const   */* __restrict  */)"error downloading program\n", (FILE */* __restrict  */)stderr);
#line 205
      exit(-1);
      }
    }
#line 195
    i += chunkSize;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 56 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_setscheduler)(__pid_t __pid ,
                                                                                         int __policy ,
                                                                                         struct sched_param  const  *__param ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_get_priority_max)(int __algorithm ) ;
#line 111 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mlockall)(int __flags ) ;
#line 115
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munlockall)(void) ;
#line 667 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 404 "/usr/include/argp.h"
extern error_t argp_parse(struct argp  const  * __restrict  __argp , int __argc ,
                          char ** __restrict  __argv , unsigned int __flags , int * __restrict  __arg_index ,
                          void * __restrict  __input ) ;
#line 419
char const   *argp_program_version ;
#line 435
char const   *argp_program_bug_address ;
#line 498
extern void argp_usage(struct argp_state  const  *__state ) ;
#line 519
extern void ( /* format attribute */  argp_failure)(struct argp_state  const  * __restrict  __state ,
                                                    int __status , int __errnum ,
                                                    char const   * __restrict  __fmt 
                                                    , ...) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int __sig ) ;
#line 19 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/rcxtty.h"
int tty_init(int highspeed , int nolock , char const   *device ) ;
#line 21
void tty_exit(void) ;
#line 12 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.h"
void init_transceiver(int highspeed , unsigned int extra_wait , int rcx_fd ) ;
#line 15
void run_transceiver(void) ;
#line 24 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/logger.h"
void log(int level , char *format  , ...) ;
#line 25
void log_init(char *filename , char *progname ) ;
#line 26
void log_set_level(int level , int enabled ) ;
#line 59 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.h"
void daemon_init(unsigned short port , int maxclients ) ;
#line 30 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c"
static char *default_tty  =    (char *)"/dev/ttyS0";
#line 33 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c"
char const   *argp_program_version  =    "lnpd 0.9";
#line 34 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c"
char const   *argp_program_bug_address  =    "http://brickos.sourceforge.net/rptrvwbugs.htm";
#line 35 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c"
static char doc[61]  = 
#line 35
  {      (char )'l',      (char )'n',      (char )'p',      (char )'d', 
        (char )' ',      (char )'-',      (char )'-',      (char )' ', 
        (char )'a',      (char )' ',      (char )'L',      (char )'i', 
        (char )'n',      (char )'u',      (char )'X',      (char )' ', 
        (char )'I',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'f',      (char )'a',      (char )'c', 
        (char )'e',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'B',      (char )'r',      (char )'i', 
        (char )'c',      (char )'k',      (char )'O',      (char )'S', 
        (char )' ',      (char )'N',      (char )'e',      (char )'t', 
        (char )'w',      (char )'o',      (char )'r',      (char )'k', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'P',      (char )'r',      (char )'o',      (char )'t', 
        (char )'o',      (char )'c',      (char )'o',      (char )'l', 
        (char )'\000'};
#line 54 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c"
static struct argp_option options[11]  = 
#line 54
  {      {"fast", 'f', (char const   *)0, 0, "run LNP at 4800 baud", 0}, 
        {"extrawait", 'e', "mseconds", 0, "extra wait time for lnp", 0}, 
        {"debug", 'd', (char const   *)0, 0, "don\264t go into background", 0}, 
        {"realtime", 'r', (char const   *)0, 0, "run in realtime mode", 0}, 
        {"nolock", 'n', (char const   *)0, 0, "do not manage tty lockfiles", 0}, 
        {"tty", 't', "tty_device", 0, "tty device to use, defaults to /dev/ttyS0", 0}, 
        {"port",
      'p', "TCP_port", 0, "TCP Port to use, defaults to 7776", 0}, 
        {"maxclients", 'm', "number", 0, "max number of clients, default 16", 0}, 
        {"log", 'l', "filename", 1, "enable logging to syslog or file\nfilename \'-\' means: log to stderr",
      0}, 
        {"verbosity", 'v', "level", 0, "enable enhanced logging, valid levels: d,l,i,a,c",
      0}, 
        {(char const   *)0, 0, (char const   *)0, 0, (char const   *)0, 0}};
#line 72 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c"
static error_t parse_opt(int key , char *arg , struct argp_state *state ) 
{ 
  struct arguments *arguments ;
  char *endptr ;
  unsigned long ul_value ;
  int tmp ;

  {
#line 76
  arguments = (struct arguments *)state->input;
  {
#line 83
  if (key == 102) {
#line 83
    goto case_102;
  }
#line 86
  if (key == 109) {
#line 86
    goto case_109;
  }
#line 92
  if (key == 101) {
#line 92
    goto case_101;
  }
#line 98
  if (key == 100) {
#line 98
    goto case_100;
  }
#line 101
  if (key == 114) {
#line 101
    goto case_114;
  }
#line 104
  if (key == 110) {
#line 104
    goto case_110;
  }
#line 107
  if (key == 116) {
#line 107
    goto case_116;
  }
#line 110
  if (key == 112) {
#line 110
    goto case_112;
  }
#line 116
  if (key == 108) {
#line 116
    goto case_108;
  }
#line 120
  if (key == 118) {
#line 120
    goto case_118;
  }
#line 146
  if (key == 0) {
#line 146
    goto case_0;
  }
#line 150
  goto switch_default___0;
  case_102: /* CIL Label */ 
#line 84
  arguments->highspeed = 1;
#line 85
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 87
  ul_value = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& endptr),
                     0);
  }
#line 88
  if (*endptr) {
    {
#line 89
    argp_failure((struct argp_state  const  */* __restrict  */)state, 1, 0, (char const   */* __restrict  */)"invalid number of clients requested");
    }
  } else
#line 88
  if (! ul_value) {
    {
#line 89
    argp_failure((struct argp_state  const  */* __restrict  */)state, 1, 0, (char const   */* __restrict  */)"invalid number of clients requested");
    }
  } else
#line 88
  if (ul_value > 256UL) {
    {
#line 89
    argp_failure((struct argp_state  const  */* __restrict  */)state, 1, 0, (char const   */* __restrict  */)"invalid number of clients requested");
    }
  }
#line 90
  arguments->maxclients = (int )ul_value;
#line 91
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 93
  ul_value = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& endptr),
                     0);
  }
#line 94
  if (*endptr) {
    {
#line 95
    argp_failure((struct argp_state  const  */* __restrict  */)state, 1, 0, (char const   */* __restrict  */)"invalid extra_wait requested");
    }
  } else
#line 94
  if (ul_value > 100UL) {
    {
#line 95
    argp_failure((struct argp_state  const  */* __restrict  */)state, 1, 0, (char const   */* __restrict  */)"invalid extra_wait requested");
    }
  }
#line 96
  arguments->extra_wait = (int )ul_value;
#line 97
  goto switch_break;
  case_100: /* CIL Label */ 
#line 99
  arguments->nodaemon = 1;
#line 100
  goto switch_break;
  case_114: /* CIL Label */ 
#line 102
  arguments->realtime = 1;
#line 103
  goto switch_break;
  case_110: /* CIL Label */ 
#line 105
  arguments->nolock = 1;
#line 106
  goto switch_break;
  case_116: /* CIL Label */ 
#line 108
  arguments->tty_device = arg;
#line 109
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 111
  ul_value = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& endptr),
                     0);
  }
#line 112
  if (*endptr) {
    {
#line 113
    argp_failure((struct argp_state  const  */* __restrict  */)state, 1, 0, (char const   */* __restrict  */)"invalid TCP port requested");
    }
  } else
#line 112
  if (! ul_value) {
    {
#line 113
    argp_failure((struct argp_state  const  */* __restrict  */)state, 1, 0, (char const   */* __restrict  */)"invalid TCP port requested");
    }
  } else
#line 112
  if (ul_value > 65534UL) {
    {
#line 113
    argp_failure((struct argp_state  const  */* __restrict  */)state, 1, 0, (char const   */* __restrict  */)"invalid TCP port requested");
    }
  }
#line 114
  arguments->port = (unsigned short )ul_value;
#line 115
  goto switch_break;
  case_108: /* CIL Label */ 
#line 117
  arguments->dologging = 1;
#line 118
  arguments->logfile = arg;
#line 119
  goto switch_break;
  case_118: /* CIL Label */ 
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! *arg) {
#line 121
      goto while_break;
    }
    {
#line 123
    tmp = tolower((int )*arg);
    }
    {
#line 125
    if (tmp == 100) {
#line 125
      goto case_100___0;
    }
#line 128
    if (tmp == 108) {
#line 128
      goto case_108___0;
    }
#line 131
    if (tmp == 105) {
#line 131
      goto case_105;
    }
#line 134
    if (tmp == 97) {
#line 134
      goto case_97;
    }
#line 137
    if (tmp == 99) {
#line 137
      goto case_99;
    }
#line 140
    goto switch_default;
    case_100___0: /* CIL Label */ 
#line 126
    arguments->lflag[1] = 1;
#line 127
    goto switch_break___0;
    case_108___0: /* CIL Label */ 
#line 129
    arguments->lflag[3] = 1;
#line 130
    goto switch_break___0;
    case_105: /* CIL Label */ 
#line 132
    arguments->lflag[4] = 1;
#line 133
    goto switch_break___0;
    case_97: /* CIL Label */ 
#line 135
    arguments->lflag[5] = 1;
#line 136
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 138
    arguments->lflag[6] = 1;
#line 139
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 141
    argp_failure((struct argp_state  const  */* __restrict  */)state, 1, 0, (char const   */* __restrict  */)"invalid verbosity level requested");
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 143
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 148
  argp_usage((struct argp_state  const  *)state);
  }
#line 149
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 151
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 153
  return (0);
}
}
#line 156 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c"
static struct argp opt_parser  =    {(struct argp_option  const  *)(options), & parse_opt, (char const   *)0, (char const   *)(doc),
    (struct argp_child  const  *)0, (char *(*)(int __key , char const   *__text ,
                                               void *__input ))0, (char const   *)0};
#line 159 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c"
static int go_realtime(void) 
{ 
  char dummystack[131072] ;
  void *dummyheap ;
  int rval ;
  int *tmp ;
  char *tmp___0 ;
  struct sched_param schedParams ;

  {
  {
#line 166
  memset((void *)(dummystack), 0, sizeof(dummystack));
#line 169
  dummyheap = malloc((size_t )131072);
  }
#line 170
  if (! dummyheap) {
    {
#line 170
    tmp = __errno_location();
#line 170
    tmp___0 = strerror(*tmp);
#line 170
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___0, "malloc", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c",
        170);
#line 170
    exit(1);
    }
  }
  {
#line 171
  memset(dummyheap, 0, (size_t )131072);
#line 173
  rval = mlockall(3);
#line 175
  free(dummyheap);
  }
#line 177
  if (! rval) {
    {
#line 181
    schedParams.__sched_priority = sched_get_priority_max(1);
#line 182
    rval = sched_setscheduler(0, 1, (struct sched_param  const  *)(& schedParams));
    }
#line 183
    if (! rval) {
      {
#line 183
      munlockall();
      }
    }
  }
#line 185
  return (rval);
}
}
#line 189 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c"
void daemonise(void) 
{ 
  pid_t pid ;

  {
  {
#line 193
  pid = fork();
  }
#line 193
  if (pid < 0) {
    {
#line 195
    perror("fork");
#line 196
    exit(1);
    }
  } else
#line 200
  if (pid != 0) {
    {
#line 202
    exit(0);
    }
  }
  {
#line 206
  setsid();
#line 207
  umask((__mode_t )0);
  }
#line 208
  return;
}
}
#line 211 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c"
void signal_handler(int signo ) 
{ 
  char *tmp ;

  {
  {
#line 213
  tmp = strsignal(signo);
#line 213
  log(0, (char *)"caught signal %s, exiting", tmp);
#line 214
  exit(0);
  }
}
}
#line 218 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c"
void install_handler(void) 
{ 
  struct sigaction saction ;

  {
  {
#line 222
  sigemptyset(& saction.sa_mask);
#line 223
  sigaddset(& saction.sa_mask, 3);
#line 224
  sigaddset(& saction.sa_mask, 15);
#line 225
  sigaddset(& saction.sa_mask, 2);
#line 226
  saction.sa_flags = 0;
#line 227
  saction.__sigaction_handler.sa_handler = & signal_handler;
#line 228
  sigaction(3, (struct sigaction  const  */* __restrict  */)(& saction), (struct sigaction */* __restrict  */)((void *)0));
#line 229
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& saction), (struct sigaction */* __restrict  */)((void *)0));
#line 230
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& saction), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 231
  return;
}
}
#line 234 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/main.c"
void cleanup(void) 
{ 


  {
  {
#line 236
  tty_exit();
  }
#line 237
  return;
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 90 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcflush)(int __fd ,
                                                                              int __queue_selector ) ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 26 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.h"
int lnp_byte_timeout ;
#line 27
int lnp_byte_safe ;
#line 28
int lnp_wait_coll ;
#line 29
int lnp_wait_txok ;
#line 30
int lnp_wait_keepalive ;
#line 33
void lnp_set_speed(int highspeed , unsigned int extra_wait ) ;
#line 36
void lnp_integrity_byte(unsigned char b ) ;
#line 39
void lnp_integrity_reset(void) ;
#line 43
int lnp_integrity_active(void) ;
#line 56 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.h"
int get_num_clients(void) ;
#line 64
int get_packet(unsigned char *buffer___5 ) ;
#line 67
extern void confirm_packet(lnp_tx_result status ) ;
#line 74
int set_socket_descriptors(fd_set *readset , fd_set *writeset ) ;
#line 77
void serv_clients(fd_set *readset , fd_set *writeset ) ;
#line 29 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static int active  ;
#line 30 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static int rcxfd  ;
#line 31 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static unsigned char tx_buffer[259]  ;
#line 32 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static unsigned char *tx_next  ;
#line 33 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static unsigned char *tx_verify  ;
#line 34 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static unsigned char *tx_end  ;
#line 35 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static struct serial_icounter_struct tty_error_info  ;
#line 36 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static struct timeval inter_byte_time  ;
#line 36 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static struct timeval keep_alive_time  ;
#line 36 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static struct timeval tx_allowed_time  ;
#line 37 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static unsigned char const   keepalive_byte  =    (unsigned char const   )255;
#line 40 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static void msecs2timeval___1(int msecs , struct timeval *tval ) 
{ 


  {
#line 42
  tval->tv_sec = (__time_t )(msecs / 1000);
#line 43
  tval->tv_usec = (__suseconds_t )((msecs * 1000) % 1000000);
#line 44
  return;
}
}
#line 47 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static void msleep___0(unsigned int msecs ) 
{ 
  struct timeval wtime ;
  struct timeval now ;
  struct timeval end ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int result ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 51
  tmp___1 = gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
#line 51
  if (tmp___1) {
    {
#line 51
    tmp = __errno_location();
#line 51
    tmp___0 = strerror(*tmp);
#line 51
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___0, "gettimeofday", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
        51);
#line 51
    exit(1);
    }
  }
  {
#line 52
  msecs2timeval___1((int )msecs, & wtime);
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    end.tv_sec = now.tv_sec + wtime.tv_sec;
#line 54
    end.tv_usec = now.tv_usec + wtime.tv_usec;
#line 54
    if (end.tv_usec >= 1000000L) {
#line 54
      (end.tv_sec) ++;
#line 54
      end.tv_usec -= 1000000L;
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 58
    tmp___2 = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& wtime));
#line 58
    result = tmp___2;
    }
#line 59
    if (result < 0) {
      {
#line 59
      tmp___5 = __errno_location();
      }
#line 59
      if (*tmp___5 != 4) {
        {
#line 59
        tmp___3 = __errno_location();
#line 59
        tmp___4 = strerror(*tmp___3);
#line 59
        log(0, (char *)"%s.  %s(),%s,line %d", tmp___4, "select()", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
            59);
#line 59
        exit(1);
        }
      }
    }
    {
#line 60
    tmp___8 = gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
    }
#line 60
    if (tmp___8) {
      {
#line 60
      tmp___6 = __errno_location();
#line 60
      tmp___7 = strerror(*tmp___6);
#line 60
      log(0, (char *)"%s.  %s(),%s,line %d", tmp___7, "gettimeofday", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
          60);
#line 60
      exit(1);
      }
    }
#line 61
    if (now.tv_sec == end.tv_sec) {
#line 61
      tmp___9 = now.tv_usec > end.tv_usec;
    } else {
#line 61
      tmp___9 = now.tv_sec > end.tv_sec;
    }
#line 61
    if (tmp___9) {
#line 61
      goto while_break___0;
    }
    {
#line 62
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 62
      wtime.tv_sec = end.tv_sec - now.tv_sec;
#line 62
      wtime.tv_usec = end.tv_usec - now.tv_usec;
#line 62
      if (wtime.tv_usec < 0L) {
#line 62
        (wtime.tv_sec) --;
#line 62
        wtime.tv_usec += 1000000L;
      }
#line 62
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 64
  return;
}
}
#line 68 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static void set_time(struct timeval *timeset , int msecs ) 
{ 
  struct timeval now ;
  struct timeval diff ;
  struct timeval new ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 72
  msecs2timeval___1(msecs, & diff);
#line 73
  tmp___1 = gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
#line 73
  if (tmp___1) {
    {
#line 73
    tmp = __errno_location();
#line 73
    tmp___0 = strerror(*tmp);
#line 73
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___0, "gettimeofday", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
        73);
#line 73
    exit(1);
    }
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    new.tv_sec = now.tv_sec + diff.tv_sec;
#line 74
    new.tv_usec = now.tv_usec + diff.tv_usec;
#line 74
    if (new.tv_usec >= 1000000L) {
#line 74
      (new.tv_sec) ++;
#line 74
      new.tv_usec -= 1000000L;
    }
#line 74
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  if (new.tv_sec == timeset->tv_sec) {
#line 75
    tmp___2 = new.tv_usec > timeset->tv_usec;
  } else {
#line 75
    tmp___2 = new.tv_sec > timeset->tv_sec;
  }
#line 75
  if (tmp___2) {
#line 75
    *timeset = new;
  }
#line 76
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static int check_expired(struct timeval *tv ) 
{ 
  struct timeval now ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 84
  if (tv->tv_sec) {
#line 84
    goto _L;
  } else
#line 84
  if (tv->tv_usec) {
    _L: /* CIL Label */ 
    {
#line 86
    tmp___1 = gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
    }
#line 86
    if (tmp___1) {
      {
#line 86
      tmp = __errno_location();
#line 86
      tmp___0 = strerror(*tmp);
#line 86
      log(0, (char *)"%s.  %s(),%s,line %d", tmp___0, "gettimeofday", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
          86);
#line 86
      exit(1);
      }
    }
#line 87
    if (tv->tv_sec == now.tv_sec) {
#line 87
      tmp___2 = tv->tv_usec < now.tv_usec;
    } else {
#line 87
      tmp___2 = tv->tv_sec < now.tv_sec;
    }
#line 87
    if (tmp___2) {
#line 87
      return (1);
    }
  }
#line 89
  return (0);
}
}
#line 94 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static void rx_flush(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 96
  tmp___1 = tcflush(rcxfd, 0);
  }
#line 96
  if (tmp___1) {
    {
#line 96
    tmp = __errno_location();
#line 96
    tmp___0 = strerror(*tmp);
#line 96
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___0, "tcflush", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
        96);
#line 96
    exit(1);
    }
  }
  {
#line 97
  tmp___4 = ioctl(rcxfd, 21597UL, & tty_error_info);
  }
#line 97
  if (tmp___4) {
    {
#line 97
    tmp___2 = __errno_location();
#line 97
    tmp___3 = strerror(*tmp___2);
#line 97
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___3, & ioctl, "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
        97);
#line 97
    exit(1);
    }
  }
#line 98
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static void tx_flush(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 103
  tmp___1 = tcflush(rcxfd, 1);
  }
#line 103
  if (tmp___1) {
    {
#line 103
    tmp = __errno_location();
#line 103
    tmp___0 = strerror(*tmp);
#line 103
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___0, "tcflush", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
        103);
#line 103
    exit(1);
    }
  }
#line 104
  return;
}
}
#line 106 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static void rx_error(void) 
{ 


  {
  {
#line 108
  lnp_integrity_reset();
#line 109
  inter_byte_time.tv_usec = (__suseconds_t )0;
#line 109
  inter_byte_time.tv_sec = inter_byte_time.tv_usec;
#line 110
  rx_flush();
#line 111
  set_time(& tx_allowed_time, lnp_byte_safe);
  }
#line 112
  return;
}
}
#line 114 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static void tx_error(void) 
{ 
  long tmp ;

  {
  {
#line 116
  active = 0;
#line 117
  inter_byte_time.tv_usec = (__suseconds_t )0;
#line 117
  inter_byte_time.tv_sec = inter_byte_time.tv_usec;
#line 118
  tx_flush();
#line 119
  tmp = random();
#line 119
  set_time(& tx_allowed_time, (int )((long )lnp_wait_coll + tmp % 16L));
#line 120
  confirm_packet((lnp_tx_result )1);
  }
#line 121
  return;
}
}
#line 123 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static int send_keepalive(int urgent ) 
{ 
  int result ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 128
  tmp = get_num_clients();
  }
#line 128
  if (! tmp) {
#line 128
    return (0);
  }
  {
#line 130
  tmp___0 = write(rcxfd, (void const   *)(& keepalive_byte), (size_t )1);
#line 130
  result = (int )tmp___0;
  }
#line 131
  if (result < 0) {
    {
#line 131
    tmp___1 = __errno_location();
#line 131
    tmp___2 = strerror(*tmp___1);
#line 131
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___2, "write", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
        131);
#line 131
    exit(1);
    }
  }
#line 132
  if (result) {
#line 134
    if (urgent) {
#line 134
      tmp___3 = "Urgent keepalive sent";
    } else {
#line 134
      tmp___3 = "Keepalive sent";
    }
    {
#line 134
    log(3, (char *)tmp___3);
#line 135
    set_time(& keep_alive_time, 3500);
#line 136
    set_time(& tx_allowed_time, lnp_wait_keepalive);
    }
#line 137
    return (1);
  }
#line 139
  return (0);
}
}
#line 142 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static int check_keepalive_urgent(void) 
{ 
  struct timeval now ;
  struct timeval diff ;
  struct timeval urgent ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 146
  tmp___1 = gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
#line 146
  if (tmp___1) {
    {
#line 146
    tmp = __errno_location();
#line 146
    tmp___0 = strerror(*tmp);
#line 146
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___0, "gettimeofday", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
        146);
#line 146
    exit(1);
    }
  }
  {
#line 148
  msecs2timeval___1(1000, & diff);
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    urgent.tv_sec = now.tv_sec + diff.tv_sec;
#line 149
    urgent.tv_usec = now.tv_usec + diff.tv_usec;
#line 149
    if (urgent.tv_usec >= 1000000L) {
#line 149
      (urgent.tv_sec) ++;
#line 149
      urgent.tv_usec -= 1000000L;
    }
#line 149
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  if (now.tv_sec == urgent.tv_sec) {
#line 150
    tmp___3 = now.tv_usec > urgent.tv_usec;
  } else {
#line 150
    tmp___3 = now.tv_sec > urgent.tv_sec;
  }
#line 150
  if (tmp___3) {
    {
#line 152
    tmp___2 = send_keepalive(1);
    }
#line 152
    return (tmp___2);
  }
#line 154
  return (0);
}
}
#line 157 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static int rcx_read(void) 
{ 
  int badframe ;
  int bytes_read ;
  int total_read ;
  unsigned char rcv_buffer[16] ;
  unsigned char *rcvd ;
  struct serial_icounter_struct new_error_info ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 159
  total_read = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 167
    tmp = read(rcxfd, (void *)(rcv_buffer), (size_t )16);
#line 167
    bytes_read = (int )tmp;
#line 168
    total_read += bytes_read;
    }
#line 169
    if (! bytes_read) {
#line 169
      goto while_break;
    }
#line 170
    if (bytes_read < 0) {
      {
#line 170
      tmp___0 = __errno_location();
#line 170
      tmp___1 = strerror(*tmp___0);
#line 170
      log(0, (char *)"%s.  %s(),%s,line %d", tmp___1, "read", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
          170);
#line 170
      exit(1);
      }
    }
    {
#line 174
    tmp___4 = ioctl(rcxfd, 21597UL, & new_error_info);
    }
#line 174
    if (tmp___4) {
      {
#line 174
      tmp___2 = __errno_location();
#line 174
      tmp___3 = strerror(*tmp___2);
#line 174
      log(0, (char *)"%s.  %s(),%s,line %d", tmp___3, "ioctl", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
          174);
#line 174
      exit(1);
      }
    }
#line 175
    if (new_error_info.frame != tty_error_info.frame) {
#line 175
      tmp___5 = 1;
    } else
#line 175
    if (new_error_info.overrun != tty_error_info.overrun) {
#line 175
      tmp___5 = 1;
    } else {
#line 175
      tmp___5 = 0;
    }
#line 175
    badframe = tmp___5;
#line 178
    tty_error_info = new_error_info;
#line 179
    if (badframe) {
#line 181
      if (active) {
        {
#line 183
        tx_error();
#line 184
        rx_flush();
        }
      } else {
        {
#line 186
        rx_error();
        }
      }
      {
#line 187
      log(3, (char *)"Frame Error");
      }
#line 188
      goto while_break;
    }
#line 191
    rcvd = rcv_buffer;
    {
#line 191
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 191
      if (! ((unsigned long )rcvd < (unsigned long )(rcv_buffer + bytes_read))) {
#line 191
        goto while_break___0;
      }
#line 193
      if (active) {
#line 195
        if ((int )*rcvd != (int )*tx_verify) {
          {
#line 197
          log(3, (char *)"Transmit Collision");
#line 198
          tx_error();
#line 199
          rx_flush();
          }
#line 200
          goto done;
        } else {
#line 202
          tx_verify ++;
#line 202
          if ((unsigned long )tx_verify >= (unsigned long )tx_end) {
            {
#line 204
            active = 0;
#line 205
            set_time(& tx_allowed_time, lnp_wait_txok);
#line 206
            confirm_packet((lnp_tx_result )0);
#line 207
            log(3, (char *)"Transmitted Packet Len %d", tx_end - tx_buffer);
            }
          }
        }
      } else {
        {
#line 212
        lnp_integrity_byte(*rcvd);
#line 213
        tmp___6 = lnp_integrity_active();
        }
#line 213
        if (tmp___6) {
          {
#line 213
          tmp___7 = check_keepalive_urgent();
          }
#line 213
          if (! tmp___7) {
            {
#line 214
            set_time(& tx_allowed_time, lnp_byte_safe);
            }
          }
        } else {
          {
#line 214
          set_time(& tx_allowed_time, lnp_byte_safe);
          }
        }
      }
#line 191
      rcvd ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
  {
#line 219
  tmp___8 = lnp_integrity_active();
  }
#line 219
  if (tmp___8) {
    {
#line 220
    set_time(& inter_byte_time, lnp_byte_timeout);
    }
  } else
#line 219
  if (active) {
    {
#line 220
    set_time(& inter_byte_time, lnp_byte_timeout);
    }
  } else {
#line 221
    inter_byte_time.tv_usec = (__suseconds_t )0;
#line 221
    inter_byte_time.tv_sec = inter_byte_time.tv_usec;
  }
#line 222
  return (total_read);
}
}
#line 225 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static int rcx_write(void) 
{ 
  int length ;
  int written ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 227
  written = 0;
#line 228
  if (! active) {
    {
#line 230
    tmp___2 = check_expired(& tx_allowed_time);
    }
#line 230
    if (tmp___2) {
      {
#line 232
      length = get_packet(tx_buffer);
      }
#line 232
      if (length) {
        {
#line 234
        tx_end = tx_buffer + length;
#line 235
        tx_next = tx_buffer;
#line 236
        tx_verify = tx_buffer;
#line 237
        active = 1;
#line 238
        set_time(& inter_byte_time, lnp_byte_timeout);
#line 239
        log(3, (char *)"Transmit packet of length %d started", length);
        }
      } else {
        {
#line 241
        tmp___0 = check_expired(& keep_alive_time);
        }
#line 241
        if (tmp___0) {
          {
#line 243
          tmp = send_keepalive(0);
          }
#line 243
          return (tmp);
        }
      }
    } else {
      {
#line 246
      tmp___1 = check_keepalive_urgent();
      }
#line 246
      if (tmp___1) {
#line 246
        return (1);
      }
    }
  }
#line 248
  if (active) {
#line 248
    if ((unsigned long )tx_next < (unsigned long )tx_end) {
      {
#line 250
      tmp___3 = write(rcxfd, (void const   *)tx_next, (size_t )(tx_end - tx_next));
#line 250
      written = (int )tmp___3;
      }
#line 251
      if (written < 0) {
        {
#line 251
        tmp___4 = __errno_location();
#line 251
        tmp___5 = strerror(*tmp___4);
#line 251
        log(0, (char *)"%s.  %s(),%s,line %d", tmp___5, "write", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
            251);
#line 251
        exit(1);
        }
      }
#line 252
      if (written) {
        {
#line 254
        tx_next += written;
#line 255
        set_time(& keep_alive_time, 3500);
        }
      }
    }
  }
#line 258
  return (written);
}
}
#line 261 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static void init_tower(int highspeed ) 
{ 
  unsigned char read_back ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 266
  write(rcxfd, (void const   *)(& keepalive_byte), (size_t )1);
#line 267
  set_time(& keep_alive_time, 3500);
#line 270
  msleep___0(100U);
#line 271
  rx_flush();
#line 272
  tmp___1 = ioctl(rcxfd, 21597UL, & tty_error_info);
  }
#line 272
  if (tmp___1) {
    {
#line 272
    tmp = __errno_location();
#line 272
    tmp___0 = strerror(*tmp);
#line 272
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___0, "ioctl", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
        272);
#line 272
    exit(1);
    }
  }
  {
#line 275
  write(rcxfd, (void const   *)(& keepalive_byte), (size_t )1);
#line 276
  msleep___0(100U);
#line 278
  tmp___2 = read(rcxfd, (void *)(& read_back), (size_t )1);
  }
#line 278
  if (tmp___2 != 1L) {
    {
#line 280
    log(0, (char *)"no response from tower");
#line 281
    exit(1);
    }
  }
#line 283
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
static void check_interbyte_timeout(void) 
{ 
  int tmp ;

  {
  {
#line 287
  tmp = check_expired(& inter_byte_time);
  }
#line 287
  if (tmp) {
    {
#line 289
    log(3, (char *)"Inter-Byte Timeout");
    }
#line 290
    if (active) {
      {
#line 290
      tx_error();
      }
    } else {
      {
#line 291
      rx_error();
      }
    }
  }
#line 293
  return;
}
}
#line 295 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
void init_transceiver(int highspeed , unsigned int extra_wait , int rcx_fd ) 
{ 
  struct timeval now ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 299
  rcxfd = rcx_fd;
#line 302
  tmp___1 = gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
#line 302
  if (tmp___1) {
    {
#line 302
    tmp = __errno_location();
#line 302
    tmp___0 = strerror(*tmp);
#line 302
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___0, "gettimeofday", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
        302);
#line 302
    exit(1);
    }
  }
  {
#line 303
  srandom((unsigned int )now.tv_usec);
#line 306
  lnp_set_speed(highspeed, extra_wait);
#line 307
  set_time(& tx_allowed_time, 0);
#line 310
  init_tower(highspeed);
  }
#line 311
  return;
}
}
#line 313 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c"
void run_transceiver(void) 
{ 
  fd_set readset ;
  fd_set writeset ;
  int result ;
  int maxno ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 322
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 322
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readset.fds_bits[0]): "memory");
#line 322
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 323
    readset.fds_bits[rcxfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << rcxfd % (8 * (int )sizeof(__fd_mask ));
    {
#line 324
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 324
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& writeset.fds_bits[0]): "memory");
#line 324
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 325
    if (active) {
#line 325
      if ((unsigned long )tx_next < (unsigned long )tx_end) {
#line 325
        writeset.fds_bits[rcxfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << rcxfd % (8 * (int )sizeof(__fd_mask ));
      }
    }
    {
#line 326
    msecs2timeval___1(10, & timeout);
#line 327
    tmp___1 = set_socket_descriptors(& readset, & writeset);
    }
#line 327
    if (rcxfd > tmp___1) {
#line 327
      maxno = rcxfd;
    } else {
      {
#line 327
      tmp___0 = set_socket_descriptors(& readset, & writeset);
#line 327
      maxno = tmp___0;
      }
    }
    {
#line 329
    result = select(maxno + 1, (fd_set */* __restrict  */)(& readset), (fd_set */* __restrict  */)(& writeset),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
    }
#line 331
    if (result < 0) {
      {
#line 331
      tmp___4 = __errno_location();
      }
#line 331
      if (*tmp___4 != 4) {
        {
#line 331
        tmp___2 = __errno_location();
#line 331
        tmp___3 = strerror(*tmp___2);
#line 331
        log(0, (char *)"%s.  %s(),%s,line %d", tmp___3, "select()", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/transceiver.c",
            331);
#line 331
        exit(1);
        }
      }
    }
#line 333
    if ((readset.fds_bits[rcxfd / (8 * (int )sizeof(__fd_mask ))] & (1L << rcxfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 333
      result = rcx_read();
      }
    } else {
      {
#line 334
      check_interbyte_timeout();
      }
    }
    {
#line 335
    tmp___5 = lnp_integrity_active();
    }
#line 335
    if (! tmp___5) {
      {
#line 335
      rcx_write();
      }
    }
    {
#line 337
    serv_clients(& readset, & writeset);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 70 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.h"
extern void deliver_packet(unsigned char *packet , int length ) ;
#line 21 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static int server_socket  ;
#line 22 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static int num_clients  ;
#line 23 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static int max_clients  ;
#line 26 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static lnpd_client_info_t *client_info_list  ;
#line 27 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static lnpd_client_info_t *next_client_to_transmit  ;
#line 28 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static lnpd_client_info_t *client_to_confirm  ;
#line 29 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static int server_running  ;
#line 30 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static unsigned short myport  ;
#line 31 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static unsigned int connect_count  ;
#line 33 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
int get_num_clients(void) 
{ 


  {
#line 35
  return (num_clients);
}
}
#line 38 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
void start_server(void) 
{ 
  struct sockaddr_in address ;
  struct linger opt_nolinger ;
  int opt_true ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;

  {
  {
#line 41
  opt_nolinger.l_onoff = 0;
#line 41
  opt_nolinger.l_linger = 0;
#line 42
  opt_true = 1;
#line 45
  server_socket = socket(2, 1, 0);
  }
#line 46
  if (server_socket < 0) {
    {
#line 46
    tmp = __errno_location();
#line 46
    tmp___0 = strerror(*tmp);
#line 46
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___0, "socket", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c",
        46);
#line 46
    exit(1);
    }
  }
  {
#line 49
  tmp___3 = setsockopt(server_socket, 1, 2, (void const   *)(& opt_true), (socklen_t )sizeof(opt_true));
  }
#line 49
  if (tmp___3) {
    {
#line 50
    tmp___1 = __errno_location();
#line 50
    tmp___2 = strerror(*tmp___1);
#line 50
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___2, "setsockopt", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c",
        50);
#line 50
    exit(1);
    }
  }
  {
#line 52
  tmp___6 = setsockopt(server_socket, 1, 13, (void const   *)(& opt_nolinger), (socklen_t )sizeof(opt_nolinger));
  }
#line 52
  if (tmp___6) {
    {
#line 53
    tmp___4 = __errno_location();
#line 53
    tmp___5 = strerror(*tmp___4);
#line 53
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___5, "setsockopt", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c",
        53);
#line 53
    exit(1);
    }
  }
  {
#line 55
  address.sin_family = (sa_family_t )2;
#line 56
  address.sin_port = htons(myport);
#line 57
  address.sin_addr.s_addr = (in_addr_t )0;
#line 60
  tmp___9 = bind(server_socket, (struct sockaddr  const  *)((struct sockaddr *)(& address)),
                 (socklen_t )sizeof(address));
  }
#line 60
  if (tmp___9) {
    {
#line 61
    tmp___7 = __errno_location();
#line 61
    tmp___8 = strerror(*tmp___7);
#line 61
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___8, "bind", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c",
        61);
#line 61
    exit(1);
    }
  }
  {
#line 65
  tmp___12 = fcntl(server_socket, 4, 2048);
  }
#line 65
  if (tmp___12) {
    {
#line 66
    tmp___10 = __errno_location();
#line 66
    tmp___11 = strerror(*tmp___10);
#line 66
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___11, "fcntl", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c",
        66);
#line 66
    exit(1);
    }
  }
  {
#line 69
  tmp___15 = listen(server_socket, 3);
  }
#line 69
  if (tmp___15) {
    {
#line 70
    tmp___13 = __errno_location();
#line 70
    tmp___14 = strerror(*tmp___13);
#line 70
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___14, "listen", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c",
        70);
#line 70
    exit(1);
    }
  }
#line 72
  server_running = 1;
#line 73
  return;
}
}
#line 75 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
void daemon_init(unsigned short port , int maxclients ) 
{ 


  {
  {
#line 78
  signal(13, (void (*)(int  ))1);
#line 80
  myport = port;
#line 81
  max_clients = maxclients;
#line 82
  start_server();
  }
#line 83
  return;
}
}
#line 85 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
void stop_server(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 87
  tmp___1 = close(server_socket);
  }
#line 87
  if (tmp___1) {
    {
#line 87
    tmp = __errno_location();
#line 87
    tmp___0 = strerror(*tmp);
#line 87
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___0, "close", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c",
        87);
#line 87
    exit(1);
    }
  }
#line 88
  server_running = 0;
#line 89
  return;
}
}
#line 91 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
int set_socket_descriptors(fd_set *readset , fd_set *writeset ) 
{ 
  lnpd_client_info_t *client_info ;
  int max_fd ;

  {
#line 94
  max_fd = 0;
#line 97
  if (server_running) {
#line 99
    readset->fds_bits[server_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << server_socket % (8 * (int )sizeof(__fd_mask ));
#line 100
    if (max_fd > server_socket) {
#line 100
      max_fd = max_fd;
    } else {
#line 100
      max_fd = server_socket;
    }
  }
#line 104
  client_info = client_info_list;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! client_info) {
#line 104
      goto while_break;
    }
#line 107
    if ((unsigned int )client_info->tx_state == 3U) {
#line 107
      goto _L;
    } else
#line 107
    if ((unsigned int )client_info->rcv_state == 0U) {
#line 107
      goto _L;
    } else
#line 107
    if ((unsigned int )client_info->rcv_state == 1U) {
#line 107
      goto _L;
    } else
#line 107
    if ((unsigned int )client_info->rcv_state == 2U) {
      _L: /* CIL Label */ 
#line 115
      readset->fds_bits[client_info->descriptor / (8 * (int )sizeof(__fd_mask ))] |= 1L << client_info->descriptor % (8 * (int )sizeof(__fd_mask ));
#line 116
      if (max_fd > client_info->descriptor) {
#line 116
        max_fd = max_fd;
      } else {
#line 116
        max_fd = client_info->descriptor;
      }
    }
#line 119
    if ((unsigned int )client_info->tx_state == 2U) {
#line 119
      goto _L___0;
    } else
#line 119
    if ((unsigned int )client_info->rcv_state == 6U) {
      _L___0: /* CIL Label */ 
#line 125
      writeset->fds_bits[client_info->descriptor / (8 * (int )sizeof(__fd_mask ))] |= 1L << client_info->descriptor % (8 * (int )sizeof(__fd_mask ));
#line 126
      if (max_fd > client_info->descriptor) {
#line 126
        max_fd = max_fd;
      } else {
#line 126
        max_fd = client_info->descriptor;
      }
    }
#line 104
    client_info = client_info->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return (max_fd);
}
}
#line 132 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
int get_packet(unsigned char *buffer___5 ) 
{ 
  lnpd_client_info_t *current_client ;

  {
#line 134
  current_client = next_client_to_transmit;
#line 137
  if (! current_client) {
#line 137
    return (0);
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if ((unsigned int )current_client->rcv_state == 3U) {
      {
#line 145
      log(6, (char *)"transmitting packet from client %u", current_client->identity);
#line 147
      memcpy((void */* __restrict  */)buffer___5, (void const   */* __restrict  */)(current_client->rcv_buffer),
             (size_t )current_client->packet_length);
#line 148
      current_client->rcv_state = (lnpd_rcv_state_t )4;
#line 149
      client_to_confirm = current_client;
      }
#line 151
      if (current_client->next) {
#line 151
        next_client_to_transmit = current_client->next;
      } else {
#line 151
        next_client_to_transmit = client_info_list;
      }
#line 153
      return (current_client->packet_length);
    }
#line 156
    if (current_client->next) {
#line 156
      current_client = current_client->next;
    } else {
#line 156
      current_client = client_info_list;
    }
#line 158
    if ((unsigned long )current_client == (unsigned long )next_client_to_transmit) {
#line 158
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (0);
}
}
#line 164 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
extern void confirm_packet(lnp_tx_result status ) 
{ 


  {
#line 167
  if (client_to_confirm) {
#line 169
    client_to_confirm->tx_result = status;
#line 170
    client_to_confirm->rcv_state = (lnpd_rcv_state_t )5;
  }
#line 172
  return;
}
}
#line 174 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
extern void deliver_packet(unsigned char *packet , int length ) 
{ 
  lnpd_client_info_t *cinfo ;

  {
#line 179
  cinfo = client_info_list;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! cinfo) {
#line 179
      goto while_break;
    }
    {
#line 181
    log(6, (char *)"delivered to %u, state %d", cinfo->identity, (unsigned int )cinfo->tx_state);
    }
#line 185
    if ((unsigned int )cinfo->tx_state == 0U) {
      {
#line 187
      memcpy((void */* __restrict  */)(cinfo->tx_buffer), (void const   */* __restrict  */)packet,
             (size_t )length);
#line 188
      cinfo->next_to_tx = cinfo->tx_buffer;
#line 189
      cinfo->tx_end = cinfo->tx_buffer + length;
#line 190
      cinfo->tx_state = (lnpd_tx_state_t )1;
      }
    }
#line 179
    cinfo = cinfo->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  return;
}
}
#line 195 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static void append_to_list(lnpd_client_info_t *client_info ) 
{ 
  lnpd_client_info_t *oldhead ;

  {
#line 197
  oldhead = client_info_list;
#line 199
  client_info_list = client_info;
#line 200
  client_info->next = oldhead;
#line 201
  if (oldhead) {
#line 202
    oldhead->previous = client_info;
  }
#line 204
  if (! next_client_to_transmit) {
#line 204
    next_client_to_transmit = client_info;
  }
#line 206
  num_clients ++;
#line 207
  return;
}
}
#line 209 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static void check_new_clients(fd_set *fileset ) 
{ 
  int client_fd ;
  struct sockaddr_in client_address ;
  socklen_t addrlength ;
  lnpd_client_info_t *client_info ;
  struct linger opt_nolinger ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  uint16_t tmp___8 ;
  char *tmp___9 ;

  {
#line 213
  addrlength = (socklen_t )sizeof(struct sockaddr_in );
#line 215
  opt_nolinger.l_onoff = 0;
#line 215
  opt_nolinger.l_linger = 0;
#line 217
  if (server_running) {
#line 217
    if ((fileset->fds_bits[server_socket / (8 * (int )sizeof(__fd_mask ))] & (1L << server_socket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 219
      client_fd = accept(server_socket, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& client_address)),
                         (socklen_t */* __restrict  */)(& addrlength));
      }
#line 220
      if (client_fd < 0) {
        {
#line 224
        tmp = __errno_location();
#line 224
        tmp___0 = strerror(*tmp);
#line 224
        log(2, (char *)"accept() error: %s", tmp___0);
        }
#line 225
        return;
      }
      {
#line 228
      tmp___1 = malloc(sizeof(lnpd_client_info_t ));
#line 228
      client_info = (lnpd_client_info_t *)tmp___1;
      }
#line 229
      if (! client_info) {
        {
#line 229
        tmp___2 = __errno_location();
#line 229
        tmp___3 = strerror(*tmp___2);
#line 229
        log(0, (char *)"%s.  %s(),%s,line %d", tmp___3, "malloc", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c",
            229);
#line 229
        exit(1);
        }
      }
      {
#line 232
      tmp___6 = setsockopt(client_fd, 1, 13, (void const   *)(& opt_nolinger), (socklen_t )sizeof(opt_nolinger));
      }
#line 232
      if (tmp___6) {
        {
#line 233
        tmp___4 = __errno_location();
#line 233
        tmp___5 = strerror(*tmp___4);
#line 233
        log(0, (char *)"%s.  %s(),%s,line %d", tmp___5, "setsockopt", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c",
            233);
#line 233
        exit(1);
        }
      }
      {
#line 235
      memset((void *)client_info, 0, sizeof(lnpd_client_info_t ));
#line 236
      client_info->descriptor = client_fd;
#line 237
      tmp___7 = connect_count;
#line 237
      connect_count ++;
#line 237
      client_info->identity = tmp___7;
#line 239
      append_to_list(client_info);
#line 242
      tmp___8 = ntohs(client_address.sin_port);
#line 242
      tmp___9 = inet_ntoa(client_address.sin_addr);
#line 242
      log(6, (char *)"connection %u from host %s, port %hu", client_info->identity,
          tmp___9, (int )tmp___8);
      }
#line 247
      if (num_clients >= max_clients) {
        {
#line 247
        stop_server();
        }
      }
    }
  }
#line 249
  return;
}
}
#line 251 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static void delete_client(lnpd_client_info_t *cinfo ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 253
  log(6, (char *)"client %u closed", cinfo->identity);
#line 253
  num_clients --;
#line 257
  tmp___1 = close(cinfo->descriptor);
  }
#line 257
  if (tmp___1) {
    {
#line 258
    tmp = __errno_location();
#line 258
    tmp___0 = strerror(*tmp);
#line 258
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___0, "close", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c",
        258);
#line 258
    exit(1);
    }
  }
#line 260
  if ((unsigned long )client_to_confirm == (unsigned long )cinfo) {
#line 261
    client_to_confirm = (lnpd_client_info_t *)((void *)0);
  }
#line 263
  if (cinfo->previous) {
#line 264
    (cinfo->previous)->next = cinfo->next;
  } else {
#line 267
    client_info_list = cinfo->next;
  }
#line 269
  if (cinfo->next) {
#line 270
    (cinfo->next)->previous = cinfo->previous;
  }
#line 272
  if ((unsigned long )next_client_to_transmit == (unsigned long )cinfo) {
#line 273
    if (cinfo->next) {
#line 273
      next_client_to_transmit = cinfo->next;
    } else {
#line 273
      next_client_to_transmit = client_info_list;
    }
  }
  {
#line 275
  free((void *)cinfo);
  }
#line 276
  if (num_clients < max_clients) {
#line 276
    if (! server_running) {
      {
#line 276
      start_server();
      }
    }
  }
#line 277
  return;
}
}
#line 281 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static int process_rcv(lnpd_client_info_t *cinfo , fd_set *readset , fd_set *writeset ) 
{ 
  int fd___0 ;
  int readable ;
  int writeable ;
  int result ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  int bytes_left ;
  ssize_t tmp___1 ;
  unsigned char ack ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 283
  fd___0 = cinfo->descriptor;
#line 284
  readable = (readset->fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] & (1L << fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L;
#line 285
  writeable = (writeset->fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] & (1L << fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L;
  {
#line 290
  if ((unsigned int )cinfo->rcv_state == 0U) {
#line 290
    goto case_0;
  }
#line 318
  if ((unsigned int )cinfo->rcv_state == 1U) {
#line 318
    goto case_1;
  }
#line 333
  if ((unsigned int )cinfo->rcv_state == 2U) {
#line 333
    goto case_2;
  }
#line 352
  if ((unsigned int )cinfo->rcv_state == 3U) {
#line 352
    goto case_3;
  }
#line 355
  if ((unsigned int )cinfo->rcv_state == 4U) {
#line 355
    goto case_4;
  }
#line 358
  if ((unsigned int )cinfo->rcv_state == 5U) {
#line 358
    goto case_5;
  }
#line 363
  if ((unsigned int )cinfo->rcv_state == 6U) {
#line 363
    goto case_6;
  }
#line 288
  goto switch_break;
  case_0: /* CIL Label */ 
#line 291
  if (readable) {
    {
#line 293
    cinfo->next_to_rcv = cinfo->rcv_buffer;
#line 294
    tmp = read(fd___0, (void *)cinfo->next_to_rcv, (size_t )1);
#line 294
    result = (int )tmp;
    }
#line 294
    if (result < 1) {
#line 296
      return (-1);
    }
    {
#line 298
    log(6, (char *)"READ_IDLE read %2X from client %u", (int )*(cinfo->next_to_rcv),
        cinfo->identity);
    }
#line 301
    if ((int )*(cinfo->next_to_rcv) == 51) {
#line 301
      if ((unsigned int )cinfo->tx_state == 3U) {
#line 303
        cinfo->tx_state = (lnpd_tx_state_t )0;
#line 304
        goto switch_break;
      } else {
#line 301
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 307
    if (((int )*(cinfo->next_to_rcv) & 248) == 240) {
#line 309
      cinfo->rcv_state = (lnpd_rcv_state_t )1;
#line 310
      (cinfo->next_to_rcv) ++;
#line 311
      goto switch_break;
    }
#line 314
    return (-1);
  }
#line 317
  goto switch_break;
  case_1: /* CIL Label */ 
#line 319
  if (readable) {
    {
#line 321
    tmp___0 = read(fd___0, (void *)cinfo->next_to_rcv, (size_t )1);
#line 321
    result = (int )tmp___0;
    }
#line 321
    if (result < 1) {
#line 323
      return (-1);
    }
    {
#line 325
    log(6, (char *)"READ_GOT_HEADER read length %u from client %u", (unsigned int )*(cinfo->next_to_rcv),
        cinfo->identity);
#line 327
    cinfo->packet_length = (int )*(cinfo->next_to_rcv) + 3;
#line 328
    (cinfo->next_to_rcv) ++;
#line 329
    cinfo->rcv_state = (lnpd_rcv_state_t )2;
    }
  }
#line 332
  goto switch_break;
  case_2: /* CIL Label */ 
#line 334
  if (readable) {
    {
#line 336
    bytes_left = (int )((long )cinfo->packet_length - (cinfo->next_to_rcv - cinfo->rcv_buffer));
#line 338
    tmp___1 = read(fd___0, (void *)cinfo->next_to_rcv, (size_t )bytes_left);
#line 338
    result = (int )tmp___1;
    }
#line 338
    if (result < 1) {
#line 340
      return (-1);
    } else {
      {
#line 343
      log(6, (char *)"READ_Receiving read %d bytes client %u", result, cinfo->identity);
      }
#line 344
      if (result == bytes_left) {
#line 346
        cinfo->rcv_state = (lnpd_rcv_state_t )3;
      } else {
#line 348
        cinfo->next_to_rcv += result;
      }
    }
  }
#line 351
  goto switch_break;
  case_3: /* CIL Label */ 
#line 354
  goto switch_break;
  case_4: /* CIL Label */ 
#line 357
  goto switch_break;
  case_5: /* CIL Label */ 
#line 360
  if ((unsigned int )cinfo->tx_state != 2U) {
#line 361
    cinfo->rcv_state = (lnpd_rcv_state_t )6;
  }
#line 362
  goto switch_break;
  case_6: /* CIL Label */ 
#line 364
  if (writeable) {
#line 366
    if ((unsigned int )cinfo->tx_result == 0U) {
#line 366
      tmp___2 = 51;
    } else {
#line 366
      tmp___2 = 119;
    }
    {
#line 366
    ack = (unsigned char )tmp___2;
#line 367
    tmp___3 = write(fd___0, (void const   *)(& ack), (size_t )1);
    }
#line 367
    if (tmp___3 != 1L) {
#line 368
      return (-1);
    }
#line 369
    cinfo->rcv_state = (lnpd_rcv_state_t )0;
  }
  switch_break: /* CIL Label */ ;
  }
#line 372
  return (0);
}
}
#line 377 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
static int process_tx(lnpd_client_info_t *cinfo , fd_set *readset , fd_set *writeset ) 
{ 
  int fd___0 ;
  int readable ;
  int writeable ;
  int result ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 379
  fd___0 = cinfo->descriptor;
#line 380
  readable = (readset->fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] & (1L << fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L;
#line 381
  writeable = (writeset->fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] & (1L << fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L;
  {
#line 386
  if ((unsigned int )cinfo->tx_state == 0U) {
#line 386
    goto case_0;
  }
#line 389
  if ((unsigned int )cinfo->tx_state == 1U) {
#line 389
    goto case_1;
  }
#line 394
  if ((unsigned int )cinfo->tx_state == 2U) {
#line 394
    goto case_2;
  }
#line 409
  if ((unsigned int )cinfo->tx_state == 3U) {
#line 409
    goto case_3;
  }
#line 384
  goto switch_break;
  case_0: /* CIL Label */ 
#line 388
  goto switch_break;
  case_1: /* CIL Label */ 
#line 391
  if ((unsigned int )cinfo->rcv_state != 6U) {
#line 392
    cinfo->tx_state = (lnpd_tx_state_t )2;
  }
#line 393
  goto switch_break;
  case_2: /* CIL Label */ 
#line 395
  if (writeable) {
    {
#line 397
    tmp = write(cinfo->descriptor, (void const   *)cinfo->next_to_tx, (size_t )(cinfo->tx_end - cinfo->next_to_tx));
#line 397
    result = (int )tmp;
    }
#line 398
    if (result < 1) {
#line 400
      return (-1);
    }
    {
#line 402
    log(6, (char *)"wrote %d bytes to client %u", result, cinfo->identity);
#line 402
    cinfo->next_to_tx += result;
    }
#line 405
    if ((unsigned long )cinfo->next_to_tx >= (unsigned long )cinfo->tx_end) {
#line 406
      cinfo->tx_state = (lnpd_tx_state_t )3;
    }
  }
#line 408
  goto switch_break;
  case_3: /* CIL Label */ 
#line 410
  if (readable) {
    {
#line 412
    tmp___0 = read(cinfo->descriptor, (void *)(& cinfo->tx_result), (size_t )1);
#line 412
    result = (int )tmp___0;
    }
#line 413
    if (result != 1) {
#line 413
      return (-1);
    }
#line 414
    if ((unsigned int )cinfo->tx_result != 51U) {
#line 414
      if ((unsigned int )cinfo->tx_result != 119U) {
#line 416
        return (-1);
      }
    }
#line 417
    cinfo->tx_state = (lnpd_tx_state_t )0;
  }
  switch_break: /* CIL Label */ ;
  }
#line 420
  return (0);
}
}
#line 424 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/daemon.c"
void serv_clients(fd_set *readset , fd_set *writeset ) 
{ 
  lnpd_client_info_t *cinfo ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 429
  check_new_clients(readset);
#line 432
  cinfo = client_info_list;
  }
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! cinfo) {
#line 432
      goto while_break;
    }
    {
#line 434
    tmp = process_rcv(cinfo, readset, writeset);
    }
#line 434
    if (tmp) {
      {
#line 435
      delete_client(cinfo);
      }
    } else {
      {
#line 434
      tmp___0 = process_tx(cinfo, readset, writeset);
      }
#line 434
      if (tmp___0) {
        {
#line 435
        delete_client(cinfo);
        }
      }
    }
#line 432
    cinfo = cinfo->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 437
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 379 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 18 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/logger.c"
static char *logstr[7]  = {      (char *)"Fatal",      (char *)"Debug",      (char *)"Info",      (char *)"Logical", 
        (char *)"Integrity",      (char *)"Addressing",      (char *)"Client"};
#line 29 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/logger.c"
static int log_enabled[7]  ;
#line 30 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/logger.c"
static struct timeval starttime  ;
#line 31 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/logger.c"
static int logfd  ;
#line 32 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/logger.c"
static int use_syslog  ;
#line 33 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/logger.c"
static int log_on  ;
#line 35 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/logger.c"
void log_init(char *filename , char *progname ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 37
  gettimeofday((struct timeval */* __restrict  */)(& starttime), (__timezone_ptr_t )((void *)0));
#line 38
  log_on = 1;
  }
#line 40
  if (! filename) {
    {
#line 42
    use_syslog = 1;
#line 43
    openlog((char const   *)progname, 8, 3 << 3);
    }
  } else {
    {
#line 47
    tmp___1 = strcmp((char const   *)filename, "-");
    }
#line 47
    if (tmp___1) {
      {
#line 50
      logfd = open((char const   *)filename, 1089, 420);
      }
#line 51
      if (logfd < 0) {
        {
#line 53
        tmp = __errno_location();
#line 53
        tmp___0 = strerror(*tmp);
#line 53
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot open logfile %s: %s\n",
                filename, tmp___0);
#line 54
        exit(1);
        }
      }
    } else {
#line 47
      logfd = 2;
    }
  }
#line 58
  return;
}
}
#line 60 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/logger.c"
void log_set_level(int level , int enabled ) 
{ 


  {
#line 62
  if (level < 7) {
#line 62
    log_enabled[level] = enabled;
  }
#line 63
  return;
}
}
#line 65 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/logger.c"
void log(int level , char *format  , ...) 
{ 
  struct timeval now ;
  struct timeval diff ;
  unsigned long runtime ;
  char message[256] ;
  va_list arglist ;
  size_t tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 72
  if (! log_on) {
#line 72
    return;
  } else
#line 72
  if (level >= 7) {
#line 72
    return;
  } else
#line 72
  if (! log_enabled[level]) {
#line 72
    return;
  }
  {
#line 73
  __builtin_va_start(arglist, format);
#line 74
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    diff.tv_sec = now.tv_sec - starttime.tv_sec;
#line 75
    diff.tv_usec = now.tv_usec - starttime.tv_usec;
#line 75
    if (diff.tv_usec < 0L) {
#line 75
      (diff.tv_sec) --;
#line 75
      diff.tv_usec += 1000000L;
    }
#line 75
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 76
  runtime = (unsigned long )(diff.tv_sec * 1000L + diff.tv_usec / 1000L);
#line 78
  sprintf((char */* __restrict  */)(message), (char const   */* __restrict  */)"%10lu:%s > ",
          runtime, logstr[level]);
#line 79
  tmp = strlen((char const   *)(message));
#line 79
  vsprintf((char */* __restrict  */)(message + tmp), (char const   */* __restrict  */)format,
           arglist);
  }
#line 81
  if (use_syslog) {
    {
#line 82
    syslog((3 << 3) | 6, "%s", message);
    }
  } else {
    {
#line 85
    tmp___0 = strlen((char const   *)(message));
#line 85
    sprintf((char */* __restrict  */)(message + tmp___0), (char const   */* __restrict  */)"\n");
#line 86
    tmp___3 = strlen((char const   *)(message));
#line 86
    tmp___4 = write(logfd, (void const   *)(message), tmp___3);
#line 86
    tmp___5 = strlen((char const   *)(message));
    }
#line 86
    if ((size_t )tmp___4 != tmp___5) {
      {
#line 88
      tmp___1 = __errno_location();
#line 88
      tmp___2 = strerror(*tmp___1);
#line 88
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot write to logfile %s\n",
              tmp___2);
#line 89
      exit(1);
      }
    }
  }
#line 92
  return;
}
}
#line 26 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.h"
int lnp_byte_timeout  ;
#line 27 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.h"
int lnp_byte_safe  ;
#line 28 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.h"
int lnp_wait_coll  ;
#line 29 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.h"
int lnp_wait_txok  ;
#line 30 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.h"
int lnp_wait_keepalive  ;
#line 33 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.c"
static lnp_integrity_state_t lnp_integrity_state  ;
#line 36 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.c"
static unsigned short lnp_checksum___0(unsigned char const   *data , unsigned int length ) 
{ 
  unsigned char a ;
  unsigned char b ;

  {
#line 38
  a = (unsigned char)255;
#line 39
  b = (unsigned char)255;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (length > 0U)) {
#line 41
      goto while_break;
    }
#line 42
    a = (unsigned char )((int )a + (int )*data);
#line 43
    b = (unsigned char )((int )b + (int )a);
#line 44
    data ++;
#line 45
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return ((unsigned short )((int )a + ((int )b << 8)));
}
}
#line 52 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.c"
void lnp_set_speed(int highspeed , unsigned int extra_wait ) 
{ 
  int lnp_byte_time ;
  int tmp ;

  {
#line 54
  if (highspeed) {
#line 54
    tmp = 3;
  } else {
#line 54
    tmp = 5;
  }
#line 54
  lnp_byte_time = tmp;
#line 55
  lnp_byte_timeout = lnp_byte_time * 3;
#line 56
  lnp_byte_safe = (int )((unsigned int )(lnp_byte_time * 4) + extra_wait);
#line 57
  lnp_wait_coll = (int )((unsigned int )(lnp_byte_timeout * 4) + extra_wait);
#line 58
  lnp_wait_txok = (int )((unsigned int )(lnp_byte_timeout * 2) + extra_wait);
#line 59
  lnp_wait_keepalive = lnp_wait_txok;
#line 60
  return;
}
}
#line 65 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.c"
static unsigned char buffer___0[259]  ;
#line 66 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.c"
static int bytesRead___0  ;
#line 66 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.c"
static int endOfData___0  ;
#line 63 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.c"
void lnp_integrity_byte(unsigned char b ) 
{ 
  int tmp ;
  unsigned short tmp___0 ;

  {
#line 68
  if ((unsigned int )lnp_integrity_state == 0U) {
#line 69
    bytesRead___0 = 0;
  }
#line 71
  tmp = bytesRead___0;
#line 71
  bytesRead___0 ++;
#line 71
  buffer___0[tmp] = b;
  {
#line 75
  if ((unsigned int )lnp_integrity_state == 0U) {
#line 75
    goto case_0;
  }
#line 84
  if ((unsigned int )lnp_integrity_state == 1U) {
#line 84
    goto case_1;
  }
#line 90
  if ((unsigned int )lnp_integrity_state == 2U) {
#line 90
    goto case_2;
  }
#line 95
  if ((unsigned int )lnp_integrity_state == 3U) {
#line 95
    goto case_3;
  }
#line 73
  goto switch_break;
  case_0: /* CIL Label */ 
#line 77
  if (((int )b & 248) == 240) {
    {
#line 79
    log(4, (char *)"Header %2x", (unsigned int )b);
#line 80
    lnp_integrity_state = (lnp_integrity_state_t )((unsigned int )lnp_integrity_state + 1U);
    }
  }
#line 82
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 85
  log(4, (char *)"Length %u", (unsigned int )b);
#line 86
  endOfData___0 = (int )b + 2;
#line 87
  lnp_integrity_state = (lnp_integrity_state_t )((unsigned int )lnp_integrity_state + 1U);
  }
#line 88
  goto switch_break;
  case_2: /* CIL Label */ 
#line 91
  if (bytesRead___0 == endOfData___0) {
#line 92
    lnp_integrity_state = (lnp_integrity_state_t )((unsigned int )lnp_integrity_state + 1U);
  }
#line 93
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 96
  tmp___0 = lnp_checksum___0((unsigned char const   *)(buffer___0), (unsigned int )endOfData___0);
  }
#line 96
  if ((int )b == (int )((unsigned char )tmp___0)) {
    {
#line 98
    log(4, (char *)"Packet received");
#line 99
    deliver_packet(buffer___0, bytesRead___0);
    }
  } else {
    {
#line 101
    log(4, (char *)"Bad checksum");
    }
  }
  {
#line 102
  lnp_integrity_reset();
  }
  switch_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.c"
void lnp_integrity_reset(void) 
{ 


  {
  {
#line 109
  log(4, (char *)"Integrity reset");
#line 110
  lnp_integrity_state = (lnp_integrity_state_t )0;
  }
#line 111
  return;
}
}
#line 114 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/lnp.c"
int lnp_integrity_active(void) 
{ 


  {
#line 116
  return ((unsigned int )lnp_integrity_state != 0U);
}
}
#line 54 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetospeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetispeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 26 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/rcxtty.c"
static int fd  ;
#line 27 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/rcxtty.c"
static char *lockfilename  ;
#line 31 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/rcxtty.c"
static int make_lockfile(char const   *device ) 
{ 
  char lockname[4096] ;
  int nchars ;
  int result ;
  int lockfd ;
  int lockpid ;
  FILE *lockfp ;
  char filepid[16] ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  __pid_t tmp___10 ;
  int *tmp___11 ;
  __pid_t tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  ssize_t tmp___16 ;
  size_t tmp___17 ;

  {
  {
#line 39
  tmp___0 = strchr(device, '/');
  }
#line 39
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 40
    tmp = strrchr(device, '/');
#line 40
    device = (char const   *)(tmp + 1);
    }
  }
  {
#line 41
  nchars = snprintf((char */* __restrict  */)(lockname), (size_t )4096, (char const   */* __restrict  */)"%s/%s%s",
                    "/var/lock", "LCK..", device);
  }
#line 43
  if (nchars < 0) {
    {
#line 45
    log(2, (char *)"tty name too long");
    }
#line 46
    return (-1);
  } else
#line 43
  if (nchars >= 4096) {
    {
#line 45
    log(2, (char *)"tty name too long");
    }
#line 46
    return (-1);
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 50
    lockfd = open((char const   *)(lockname), 193, 420);
    }
#line 50
    if (! (lockfd < 0)) {
#line 50
      goto while_break;
    }
    {
#line 52
    tmp___11 = __errno_location();
    }
#line 52
    if (*tmp___11 != 17) {
      {
#line 54
      tmp___1 = __errno_location();
#line 54
      tmp___2 = strerror(*tmp___1);
#line 54
      log(2, (char *)"cannot create lockfile: %s", tmp___2);
      }
#line 55
      return (-1);
    } else {
      {
#line 61
      lockfp = fopen((char const   */* __restrict  */)(lockname), (char const   */* __restrict  */)"r");
      }
#line 61
      if ((unsigned long )lockfp == (unsigned long )((void *)0)) {
        {
#line 63
        tmp___3 = __errno_location();
        }
#line 63
        if (*tmp___3 == 2) {
#line 63
          goto while_continue;
        } else {
          {
#line 66
          log(2, (char *)"cannot open lockfile %s", lockname);
          }
#line 67
          return (-1);
        }
      }
      {
#line 70
      result = fscanf((FILE */* __restrict  */)lockfp, (char const   */* __restrict  */)"%d",
                      & lockpid);
#line 71
      fclose(lockfp);
      }
#line 73
      if (result != 1) {
        {
#line 75
        log(2, (char *)"cannot read pid from lockfile %s", lockname);
        }
#line 76
        return (-1);
      }
      {
#line 80
      result = kill(lockpid, 0);
      }
#line 81
      if (result < 0) {
        {
#line 81
        tmp___9 = __errno_location();
        }
#line 81
        if (*tmp___9 == 3) {
#line 81
          goto _L;
        } else {
#line 81
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 81
        tmp___10 = getpid();
        }
#line 81
        if (lockpid == tmp___10) {
          _L: /* CIL Label */ 
          {
#line 84
          log(2, (char *)"trying to unlink stale lockfile");
#line 85
          tmp___6 = unlink((char const   *)(lockname));
          }
#line 85
          if (tmp___6 < 0) {
            {
#line 85
            tmp___7 = __errno_location();
            }
#line 85
            if (*tmp___7 != 4) {
              {
#line 85
              tmp___8 = __errno_location();
              }
#line 85
              if (*tmp___8 != 2) {
                {
#line 88
                tmp___4 = __errno_location();
#line 88
                tmp___5 = strerror(*tmp___4);
#line 88
                log(2, (char *)"cannot unlink stale lockfile: %s", tmp___5);
                }
#line 89
                return (-1);
              }
            }
          }
#line 91
          goto while_continue;
        }
      }
      {
#line 94
      log(2, (char *)"device is locked by pid %d ", lockpid);
      }
#line 95
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  lockfilename = strdup((char const   *)(lockname));
#line 102
  tmp___12 = getpid();
#line 102
  sprintf((char */* __restrict  */)(filepid), (char const   */* __restrict  */)"%10d\n",
          tmp___12);
#line 103
  tmp___15 = strlen((char const   *)(filepid));
#line 103
  tmp___16 = write(lockfd, (void const   *)(filepid), tmp___15);
#line 103
  tmp___17 = strlen((char const   *)(filepid));
  }
#line 103
  if ((size_t )tmp___16 != tmp___17) {
    {
#line 105
    tmp___13 = __errno_location();
#line 105
    tmp___14 = strerror(*tmp___13);
#line 105
    log(2, (char *)"cannot write to lockfile %s", tmp___14);
#line 106
    close(lockfd);
    }
#line 107
    return (-1);
  }
  {
#line 110
  close(lockfd);
#line 111
  log(2, (char *)"created lock file %s", lockname);
  }
#line 112
  return (0);
}
}
#line 115 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/rcxtty.c"
void tty_exit(void) 
{ 


  {
#line 117
  if (lockfilename) {
    {
#line 117
    unlink((char const   *)lockfilename);
    }
  }
#line 118
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/rcxtty.c"
int tty_init(int highspeed , int nolock , char const   *device ) 
{ 
  struct termios ios ;
  struct serial_struct ttyinfo ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;

  {
#line 127
  if (! nolock) {
    {
#line 127
    tmp = make_lockfile(device);
    }
#line 127
    if (tmp) {
      {
#line 129
      log(0, (char *)"cannot create lockfile");
#line 130
      exit(1);
      }
    }
  }
  {
#line 134
  fd = open(device, 2);
  }
#line 134
  if (fd < 0) {
    {
#line 135
    tmp___0 = __errno_location();
#line 135
    tmp___1 = strerror(*tmp___0);
#line 135
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___1, "open", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/rcxtty.c",
        135);
#line 135
    exit(1);
    }
  }
  {
#line 138
  tmp___2 = isatty(fd);
  }
#line 138
  if (! tmp___2) {
    {
#line 140
    log(0, (char *)"%s is not a tty", device);
#line 141
    exit(1);
    }
  }
  {
#line 145
  memset((void *)(& ios), 0, sizeof(ios));
  }
#line 146
  if (highspeed) {
#line 146
    tmp___3 = 0;
  } else {
#line 146
    tmp___3 = 768;
  }
#line 146
  ios.c_cflag = (tcflag_t )(2224 | tmp___3);
#line 147
  if (highspeed) {
#line 147
    tmp___4 = 12;
  } else {
#line 147
    tmp___4 = 11;
  }
  {
#line 147
  cfsetispeed(& ios, (speed_t )tmp___4);
  }
#line 148
  if (highspeed) {
#line 148
    tmp___5 = 12;
  } else {
#line 148
    tmp___5 = 11;
  }
  {
#line 148
  cfsetospeed(& ios, (speed_t )tmp___5);
#line 149
  tmp___8 = tcsetattr(fd, 0, (struct termios  const  *)(& ios));
  }
#line 149
  if (tmp___8 == -1) {
    {
#line 150
    tmp___6 = __errno_location();
#line 150
    tmp___7 = strerror(*tmp___6);
#line 150
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___7, "tcsetattr", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/rcxtty.c",
        150);
#line 150
    exit(1);
    }
  }
  {
#line 153
  tmp___11 = ioctl(fd, 21534UL, & ttyinfo);
  }
#line 153
  if (tmp___11) {
    {
#line 154
    tmp___9 = __errno_location();
#line 154
    tmp___10 = strerror(*tmp___9);
#line 154
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___10, "ioctl[TIOCGSERIAL]", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/rcxtty.c",
        154);
#line 154
    exit(1);
    }
  }
  {
#line 158
  if (ttyinfo.type == 4) {
#line 158
    goto case_4;
  }
#line 164
  if (ttyinfo.type == 3) {
#line 164
    goto case_3;
  }
#line 164
  if (ttyinfo.type == 1) {
#line 164
    goto case_3;
  }
#line 164
  if (ttyinfo.type == 2) {
#line 164
    goto case_3;
  }
#line 167
  goto switch_default;
  case_4: /* CIL Label */ 
#line 159
  ttyinfo.type = 2;
#line 160
  ttyinfo.flags = (int )((unsigned int )ttyinfo.flags | (1U << 13));
#line 161
  goto switch_break;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 165
  ttyinfo.flags = (int )((unsigned int )ttyinfo.flags | (1U << 13));
#line 166
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 168
  log(2, (char *)"don\264t know how to configure tty, trying low_latency");
#line 169
  ttyinfo.flags = (int )((unsigned int )ttyinfo.flags | (1U << 13));
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 172
  tmp___14 = ioctl(fd, 21535UL, & ttyinfo);
  }
#line 172
  if (tmp___14) {
    {
#line 174
    tmp___12 = __errno_location();
#line 174
    tmp___13 = strerror(*tmp___12);
#line 174
    log(2, (char *)"failed to configure tty: %s", tmp___13);
    }
  }
  {
#line 178
  close(fd);
#line 179
  fd = open(device, 2);
  }
#line 179
  if (fd < 0) {
    {
#line 180
    tmp___15 = __errno_location();
#line 180
    tmp___16 = strerror(*tmp___15);
#line 180
    log(0, (char *)"%s.  %s(),%s,line %d", tmp___16, "open", "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/lnpd/rcxtty.c",
        180);
#line 180
    exit(1);
    }
  }
#line 182
  return (fd);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 11 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/applications/lnptest2.c"
void addr_handler(unsigned char const   *data , unsigned char length , unsigned char src ) 
{ 


  {
  {
#line 15
  if ((int const   )*(data + 0) == 115) {
#line 15
    goto case_115;
  }
#line 18
  if ((int const   )*(data + 0) == 105) {
#line 18
    goto case_105;
  }
#line 21
  goto switch_default;
  case_115: /* CIL Label */ 
  {
#line 16
  printf((char const   */* __restrict  */)"%s\n", data + 1);
  }
#line 17
  goto switch_break;
  case_105: /* CIL Label */ 
  {
#line 19
  printf((char const   */* __restrict  */)"%d\n", (int const   )*(data + 1) * 256 + (int const   )*(data + 2));
  }
#line 20
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 22
  printf((char const   */* __restrict  */)"unknown type\n");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 24
  fflush(stdout);
  }
#line 25
  return;
}
}
#line 37 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_host_address___0  ;
#line 38 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_host_mask___0  ;
#line 39 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_port_mask___0  ;
#line 40 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int discard_while_tx___0  ;
#line 41 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int socket_fd___0  ;
#line 42 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int connected___0  ;
#line 43 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int tx_active___0  ;
#line 44 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_tx_result tx_result___0  ;
#line 45 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_buffer___0[259]  ;
#line 46 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void (*integrity_handler___0)(unsigned char const   * , unsigned char  )  ;
#line 47 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_addressing_handler_t addressing_handler___0[256]  ;
#line 48 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static rcv_state_t rcv_state___0  ;
#line 51 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void msecs2timeval___2(int msecs , struct timeval *tval ) 
{ 


  {
#line 53
  tval->tv_sec = (__time_t )(msecs / 1000);
#line 54
  tval->tv_usec = (__suseconds_t )((msecs * 1000) % 1000000);
#line 55
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned short lnp_checksum___1(unsigned char const   *data , unsigned int length ) 
{ 
  unsigned char a ;
  unsigned char b ;

  {
#line 59
  a = (unsigned char)255;
#line 60
  b = (unsigned char)255;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (length > 0U)) {
#line 62
      goto while_break;
    }
#line 63
    a = (unsigned char )((int )a + (int )*data);
#line 64
    b = (unsigned char )((int )b + (int )a);
#line 65
    data ++;
#line 66
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return ((unsigned short )((int )a + ((int )b << 8)));
}
}
#line 118 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void lnp_receive_packet___0(unsigned char const   *data ) 
{ 
  unsigned char header ;
  unsigned char const   *tmp ;
  unsigned char length ;
  unsigned char const   *tmp___0 ;
  unsigned char dest ;
  unsigned char const   *tmp___1 ;
  unsigned char port ;
  unsigned char src ;
  unsigned char const   *tmp___2 ;

  {
#line 119
  tmp = data;
#line 119
  data ++;
#line 119
  header = (unsigned char )*tmp;
#line 120
  tmp___0 = data;
#line 120
  data ++;
#line 120
  length = (unsigned char )*tmp___0;
  {
#line 125
  if ((int )header == 240) {
#line 125
    goto case_240;
  }
#line 130
  if ((int )header == 241) {
#line 130
    goto case_241;
  }
#line 124
  goto switch_break;
  case_240: /* CIL Label */ 
#line 126
  if (integrity_handler___0) {
    {
#line 127
    (*integrity_handler___0)(data, length);
    }
  }
#line 128
  goto switch_break;
  case_241: /* CIL Label */ 
#line 131
  if ((int )length > 2) {
#line 132
    tmp___1 = data;
#line 132
    data ++;
#line 132
    dest = (unsigned char )*tmp___1;
#line 134
    if ((int )lnp_host_address___0 == ((int )dest & (int )lnp_host_mask___0)) {
#line 135
      port = (unsigned char )((int )dest & (int )lnp_port_mask___0);
#line 137
      if (addressing_handler___0[port]) {
        {
#line 138
        tmp___2 = data;
#line 138
        data ++;
#line 138
        src = (unsigned char )*tmp___2;
#line 139
        (*(addressing_handler___0[port]))(data, (unsigned char )((int )length - 2),
                                          src);
        }
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 144
  return;
}
}
#line 151
static int transmit_ack___0(void) ;
#line 151 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char ack_byte___0  =    (unsigned char)51;
#line 146 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int transmit_ack___0(void) 
{ 
  fd_set fds ;
  struct timeval timeout ;
  int result ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.fds_bits[0]): "memory");
#line 156
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 157
    fds.fds_bits[socket_fd___0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket_fd___0 % (8 * (int )sizeof(__fd_mask ));
#line 158
    msecs2timeval___2(1000, & timeout);
#line 159
    result = select(socket_fd___0 + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
    }
#line 160
    if (result == 1) {
#line 160
      goto while_break;
    }
#line 161
    if (result < 0) {
      {
#line 161
      tmp = __errno_location();
      }
#line 161
      if (*tmp == 4) {
#line 161
        goto while_continue;
      }
    }
#line 163
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 166
  tmp___0 = write(socket_fd___0, (void const   *)(& ack_byte___0), (size_t )1);
#line 166
  result = (int )tmp___0;
  }
#line 166
  if (result != 1) {
#line 167
    return (-1);
  }
#line 169
  return (0);
}
}
#line 173 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char buffer___1[259]  ;
#line 174 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int bytesRead___1  ;
#line 174 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int endOfData___1  ;
#line 172 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int receive_byte___0(unsigned char byte_read ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 176
  if ((unsigned int )rcv_state___0 == 0U) {
#line 177
    bytesRead___1 = 0;
  }
#line 179
  tmp = bytesRead___1;
#line 179
  bytesRead___1 ++;
#line 179
  buffer___1[tmp] = byte_read;
  {
#line 183
  if ((unsigned int )rcv_state___0 == 0U) {
#line 183
    goto case_0;
  }
#line 198
  if ((unsigned int )rcv_state___0 == 1U) {
#line 198
    goto case_1;
  }
#line 202
  if ((unsigned int )rcv_state___0 == 2U) {
#line 202
    goto case_2;
  }
#line 181
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 186
  if ((int )byte_read == 51) {
#line 186
    goto case_51;
  }
#line 190
  if ((int )byte_read == 119) {
#line 190
    goto case_119;
  }
#line 194
  goto switch_default;
  case_51: /* CIL Label */ 
#line 187
  tx_result___0 = (lnp_tx_result )0;
#line 188
  tx_active___0 = 0;
#line 189
  goto switch_break___0;
  case_119: /* CIL Label */ 
#line 191
  tx_result___0 = (lnp_tx_result )1;
#line 192
  tx_active___0 = 0;
#line 193
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 195
  rcv_state___0 = (rcv_state_t )((unsigned int )rcv_state___0 + 1U);
  switch_break___0: /* CIL Label */ ;
  }
#line 197
  goto switch_break;
  case_1: /* CIL Label */ 
#line 199
  endOfData___1 = (int )byte_read + 3;
#line 200
  rcv_state___0 = (rcv_state_t )((unsigned int )rcv_state___0 + 1U);
#line 201
  goto switch_break;
  case_2: /* CIL Label */ 
#line 203
  if (bytesRead___1 == endOfData___1) {
    {
#line 205
    rcv_state___0 = (rcv_state_t )0;
#line 206
    tmp___0 = transmit_ack___0();
    }
#line 206
    if (tmp___0) {
#line 206
      return (-1);
    }
#line 207
    if (tx_active___0) {
#line 207
      if (! discard_while_tx___0) {
        {
#line 208
        lnp_receive_packet___0((unsigned char const   *)(buffer___1));
        }
      }
    } else {
      {
#line 208
      lnp_receive_packet___0((unsigned char const   *)(buffer___1));
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 211
  return (0);
}
}
#line 214 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void rcv_handler___0(int signo ) 
{ 
  unsigned char buffer___5[259] ;
  unsigned char *recvd_byte ;
  int length ;
  int i ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 221
  tmp = read(socket_fd___0, (void *)(buffer___5), sizeof(buffer___5));
#line 221
  length = (int )tmp;
  }
#line 222
  if (length < 1) {
#line 224
    if (tx_active___0) {
#line 226
      tx_active___0 = 0;
#line 227
      tx_result___0 = (lnp_tx_result )2;
    } else {
      {
#line 229
      lnp_shutdown();
      }
    }
#line 230
    return;
  }
#line 233
  i = 0;
#line 233
  recvd_byte = buffer___5;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i < length)) {
#line 233
      goto while_break;
    }
    {
#line 235
    tmp___0 = receive_byte___0(*recvd_byte);
    }
#line 235
    if (tmp___0) {
#line 237
      if (tx_active___0) {
#line 239
        tx_active___0 = 0;
#line 240
        tx_result___0 = (lnp_tx_result )2;
      } else {
        {
#line 242
        lnp_shutdown();
        }
      }
#line 243
      return;
    }
#line 233
    i ++;
#line 233
    recvd_byte ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return;
}
}
#line 248 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_tx_result lnp_logical_write___0(unsigned char *data , int length ) 
{ 
  int written ;
  int result ;
  sigset_t newset ;
  sigset_t oldset ;
  fd_set fds ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
#line 250
  written = 0;
#line 255
  if (! connected___0) {
#line 255
    return ((lnp_tx_result )2);
  }
  {
#line 258
  sigemptyset(& newset);
#line 259
  sigaddset(& newset, 29);
#line 260
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& newset), (sigset_t */* __restrict  */)(& oldset));
#line 262
  tx_active___0 = 1;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! (written != length)) {
#line 265
      goto while_break;
    }
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 270
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 270
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& fds.fds_bits[0]): "memory");
#line 270
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 271
      fds.fds_bits[socket_fd___0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket_fd___0 % (8 * (int )sizeof(__fd_mask ));
#line 272
      msecs2timeval___2(5000, & timeout);
#line 273
      result = select(socket_fd___0 + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
      }
#line 274
      if (result == 1) {
#line 274
        goto while_break___0;
      }
#line 275
      if (result < 0) {
        {
#line 275
        tmp = __errno_location();
        }
#line 275
        if (*tmp == 4) {
#line 275
          goto while_continue___0;
        }
      }
      {
#line 277
      lnp_shutdown();
      }
#line 278
      return ((lnp_tx_result )2);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 281
    tmp___0 = write(socket_fd___0, (void const   *)(data + written), (size_t )(length - written));
#line 281
    result = (int )tmp___0;
    }
#line 282
    if (result < 1) {
      {
#line 284
      lnp_shutdown();
      }
#line 285
      return ((lnp_tx_result )2);
    }
#line 287
    written += result;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 291
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 293
    sigsuspend((sigset_t const   *)(& oldset));
    }
#line 294
    if (! tx_active___0) {
#line 294
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 297
  if ((unsigned int )tx_result___0 == 2U) {
    {
#line 297
    lnp_shutdown();
    }
  }
  {
#line 299
  unblock_rcv();
  }
#line 301
  return (tx_result___0);
}
}
#line 37 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_host_address___1  ;
#line 38 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_host_mask___1  ;
#line 39 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_port_mask___1  ;
#line 40 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int discard_while_tx___1  ;
#line 41 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int socket_fd___1  ;
#line 42 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int connected___1  ;
#line 43 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int tx_active___1  ;
#line 44 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_tx_result tx_result___1  ;
#line 45 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_buffer___1[259]  ;
#line 46 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void (*integrity_handler___1)(unsigned char const   * , unsigned char  )  ;
#line 47 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_addressing_handler_t addressing_handler___1[256]  ;
#line 48 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static rcv_state_t rcv_state___1  ;
#line 51 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void msecs2timeval___3(int msecs , struct timeval *tval ) 
{ 


  {
#line 53
  tval->tv_sec = (__time_t )(msecs / 1000);
#line 54
  tval->tv_usec = (__suseconds_t )((msecs * 1000) % 1000000);
#line 55
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned short lnp_checksum___2(unsigned char const   *data , unsigned int length ) 
{ 
  unsigned char a ;
  unsigned char b ;

  {
#line 59
  a = (unsigned char)255;
#line 60
  b = (unsigned char)255;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (length > 0U)) {
#line 62
      goto while_break;
    }
#line 63
    a = (unsigned char )((int )a + (int )*data);
#line 64
    b = (unsigned char )((int )b + (int )a);
#line 65
    data ++;
#line 66
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return ((unsigned short )((int )a + ((int )b << 8)));
}
}
#line 118 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void lnp_receive_packet___1(unsigned char const   *data ) 
{ 
  unsigned char header ;
  unsigned char const   *tmp ;
  unsigned char length ;
  unsigned char const   *tmp___0 ;
  unsigned char dest ;
  unsigned char const   *tmp___1 ;
  unsigned char port ;
  unsigned char src ;
  unsigned char const   *tmp___2 ;

  {
#line 119
  tmp = data;
#line 119
  data ++;
#line 119
  header = (unsigned char )*tmp;
#line 120
  tmp___0 = data;
#line 120
  data ++;
#line 120
  length = (unsigned char )*tmp___0;
  {
#line 125
  if ((int )header == 240) {
#line 125
    goto case_240;
  }
#line 130
  if ((int )header == 241) {
#line 130
    goto case_241;
  }
#line 124
  goto switch_break;
  case_240: /* CIL Label */ 
#line 126
  if (integrity_handler___1) {
    {
#line 127
    (*integrity_handler___1)(data, length);
    }
  }
#line 128
  goto switch_break;
  case_241: /* CIL Label */ 
#line 131
  if ((int )length > 2) {
#line 132
    tmp___1 = data;
#line 132
    data ++;
#line 132
    dest = (unsigned char )*tmp___1;
#line 134
    if ((int )lnp_host_address___1 == ((int )dest & (int )lnp_host_mask___1)) {
#line 135
      port = (unsigned char )((int )dest & (int )lnp_port_mask___1);
#line 137
      if (addressing_handler___1[port]) {
        {
#line 138
        tmp___2 = data;
#line 138
        data ++;
#line 138
        src = (unsigned char )*tmp___2;
#line 139
        (*(addressing_handler___1[port]))(data, (unsigned char )((int )length - 2),
                                          src);
        }
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 144
  return;
}
}
#line 151
static int transmit_ack___1(void) ;
#line 151 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char ack_byte___1  =    (unsigned char)51;
#line 146 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int transmit_ack___1(void) 
{ 
  fd_set fds ;
  struct timeval timeout ;
  int result ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.fds_bits[0]): "memory");
#line 156
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 157
    fds.fds_bits[socket_fd___1 / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket_fd___1 % (8 * (int )sizeof(__fd_mask ));
#line 158
    msecs2timeval___3(1000, & timeout);
#line 159
    result = select(socket_fd___1 + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
    }
#line 160
    if (result == 1) {
#line 160
      goto while_break;
    }
#line 161
    if (result < 0) {
      {
#line 161
      tmp = __errno_location();
      }
#line 161
      if (*tmp == 4) {
#line 161
        goto while_continue;
      }
    }
#line 163
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 166
  tmp___0 = write(socket_fd___1, (void const   *)(& ack_byte___1), (size_t )1);
#line 166
  result = (int )tmp___0;
  }
#line 166
  if (result != 1) {
#line 167
    return (-1);
  }
#line 169
  return (0);
}
}
#line 173 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char buffer___2[259]  ;
#line 174 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int bytesRead___2  ;
#line 174 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int endOfData___2  ;
#line 172 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int receive_byte___1(unsigned char byte_read ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 176
  if ((unsigned int )rcv_state___1 == 0U) {
#line 177
    bytesRead___2 = 0;
  }
#line 179
  tmp = bytesRead___2;
#line 179
  bytesRead___2 ++;
#line 179
  buffer___2[tmp] = byte_read;
  {
#line 183
  if ((unsigned int )rcv_state___1 == 0U) {
#line 183
    goto case_0;
  }
#line 198
  if ((unsigned int )rcv_state___1 == 1U) {
#line 198
    goto case_1;
  }
#line 202
  if ((unsigned int )rcv_state___1 == 2U) {
#line 202
    goto case_2;
  }
#line 181
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 186
  if ((int )byte_read == 51) {
#line 186
    goto case_51;
  }
#line 190
  if ((int )byte_read == 119) {
#line 190
    goto case_119;
  }
#line 194
  goto switch_default;
  case_51: /* CIL Label */ 
#line 187
  tx_result___1 = (lnp_tx_result )0;
#line 188
  tx_active___1 = 0;
#line 189
  goto switch_break___0;
  case_119: /* CIL Label */ 
#line 191
  tx_result___1 = (lnp_tx_result )1;
#line 192
  tx_active___1 = 0;
#line 193
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 195
  rcv_state___1 = (rcv_state_t )((unsigned int )rcv_state___1 + 1U);
  switch_break___0: /* CIL Label */ ;
  }
#line 197
  goto switch_break;
  case_1: /* CIL Label */ 
#line 199
  endOfData___2 = (int )byte_read + 3;
#line 200
  rcv_state___1 = (rcv_state_t )((unsigned int )rcv_state___1 + 1U);
#line 201
  goto switch_break;
  case_2: /* CIL Label */ 
#line 203
  if (bytesRead___2 == endOfData___2) {
    {
#line 205
    rcv_state___1 = (rcv_state_t )0;
#line 206
    tmp___0 = transmit_ack___1();
    }
#line 206
    if (tmp___0) {
#line 206
      return (-1);
    }
#line 207
    if (tx_active___1) {
#line 207
      if (! discard_while_tx___1) {
        {
#line 208
        lnp_receive_packet___1((unsigned char const   *)(buffer___2));
        }
      }
    } else {
      {
#line 208
      lnp_receive_packet___1((unsigned char const   *)(buffer___2));
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 211
  return (0);
}
}
#line 214 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void rcv_handler___1(int signo ) 
{ 
  unsigned char buffer___5[259] ;
  unsigned char *recvd_byte ;
  int length ;
  int i ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 221
  tmp = read(socket_fd___1, (void *)(buffer___5), sizeof(buffer___5));
#line 221
  length = (int )tmp;
  }
#line 222
  if (length < 1) {
#line 224
    if (tx_active___1) {
#line 226
      tx_active___1 = 0;
#line 227
      tx_result___1 = (lnp_tx_result )2;
    } else {
      {
#line 229
      lnp_shutdown();
      }
    }
#line 230
    return;
  }
#line 233
  i = 0;
#line 233
  recvd_byte = buffer___5;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i < length)) {
#line 233
      goto while_break;
    }
    {
#line 235
    tmp___0 = receive_byte___1(*recvd_byte);
    }
#line 235
    if (tmp___0) {
#line 237
      if (tx_active___1) {
#line 239
        tx_active___1 = 0;
#line 240
        tx_result___1 = (lnp_tx_result )2;
      } else {
        {
#line 242
        lnp_shutdown();
        }
      }
#line 243
      return;
    }
#line 233
    i ++;
#line 233
    recvd_byte ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return;
}
}
#line 248 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_tx_result lnp_logical_write___1(unsigned char *data , int length ) 
{ 
  int written ;
  int result ;
  sigset_t newset ;
  sigset_t oldset ;
  fd_set fds ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
#line 250
  written = 0;
#line 255
  if (! connected___1) {
#line 255
    return ((lnp_tx_result )2);
  }
  {
#line 258
  sigemptyset(& newset);
#line 259
  sigaddset(& newset, 29);
#line 260
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& newset), (sigset_t */* __restrict  */)(& oldset));
#line 262
  tx_active___1 = 1;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! (written != length)) {
#line 265
      goto while_break;
    }
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 270
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 270
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& fds.fds_bits[0]): "memory");
#line 270
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 271
      fds.fds_bits[socket_fd___1 / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket_fd___1 % (8 * (int )sizeof(__fd_mask ));
#line 272
      msecs2timeval___3(5000, & timeout);
#line 273
      result = select(socket_fd___1 + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
      }
#line 274
      if (result == 1) {
#line 274
        goto while_break___0;
      }
#line 275
      if (result < 0) {
        {
#line 275
        tmp = __errno_location();
        }
#line 275
        if (*tmp == 4) {
#line 275
          goto while_continue___0;
        }
      }
      {
#line 277
      lnp_shutdown();
      }
#line 278
      return ((lnp_tx_result )2);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 281
    tmp___0 = write(socket_fd___1, (void const   *)(data + written), (size_t )(length - written));
#line 281
    result = (int )tmp___0;
    }
#line 282
    if (result < 1) {
      {
#line 284
      lnp_shutdown();
      }
#line 285
      return ((lnp_tx_result )2);
    }
#line 287
    written += result;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 291
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 293
    sigsuspend((sigset_t const   *)(& oldset));
    }
#line 294
    if (! tx_active___1) {
#line 294
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 297
  if ((unsigned int )tx_result___1 == 2U) {
    {
#line 297
    lnp_shutdown();
    }
  }
  {
#line 299
  unblock_rcv();
  }
#line 301
  return (tx_result___1);
}
}
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 63 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/applications/loader.c"
static struct option  const  long_options___0[5]  = {      {"rcxaddr", 1, (int *)0, 'r'}, 
        {"program", 1, (int *)0, 'p'}, 
        {"srcport", 1, (int *)0, 's'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 81 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/applications/loader.c"
int byte_time  =    5;
#line 37 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_host_address___2  ;
#line 38 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_host_mask___2  ;
#line 39 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_port_mask___2  ;
#line 40 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int discard_while_tx___2  ;
#line 41 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int socket_fd___2  ;
#line 42 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int connected___2  ;
#line 43 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int tx_active___2  ;
#line 44 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_tx_result tx_result___2  ;
#line 45 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_buffer___2[259]  ;
#line 46 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void (*integrity_handler___2)(unsigned char const   * , unsigned char  )  ;
#line 47 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_addressing_handler_t addressing_handler___2[256]  ;
#line 48 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static rcv_state_t rcv_state___2  ;
#line 51 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void msecs2timeval___4(int msecs , struct timeval *tval ) 
{ 


  {
#line 53
  tval->tv_sec = (__time_t )(msecs / 1000);
#line 54
  tval->tv_usec = (__suseconds_t )((msecs * 1000) % 1000000);
#line 55
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned short lnp_checksum___3(unsigned char const   *data , unsigned int length ) 
{ 
  unsigned char a ;
  unsigned char b ;

  {
#line 59
  a = (unsigned char)255;
#line 60
  b = (unsigned char)255;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (length > 0U)) {
#line 62
      goto while_break;
    }
#line 63
    a = (unsigned char )((int )a + (int )*data);
#line 64
    b = (unsigned char )((int )b + (int )a);
#line 65
    data ++;
#line 66
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return ((unsigned short )((int )a + ((int )b << 8)));
}
}
#line 118 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void lnp_receive_packet___2(unsigned char const   *data ) 
{ 
  unsigned char header ;
  unsigned char const   *tmp ;
  unsigned char length ;
  unsigned char const   *tmp___0 ;
  unsigned char dest ;
  unsigned char const   *tmp___1 ;
  unsigned char port ;
  unsigned char src ;
  unsigned char const   *tmp___2 ;

  {
#line 119
  tmp = data;
#line 119
  data ++;
#line 119
  header = (unsigned char )*tmp;
#line 120
  tmp___0 = data;
#line 120
  data ++;
#line 120
  length = (unsigned char )*tmp___0;
  {
#line 125
  if ((int )header == 240) {
#line 125
    goto case_240;
  }
#line 130
  if ((int )header == 241) {
#line 130
    goto case_241;
  }
#line 124
  goto switch_break;
  case_240: /* CIL Label */ 
#line 126
  if (integrity_handler___2) {
    {
#line 127
    (*integrity_handler___2)(data, length);
    }
  }
#line 128
  goto switch_break;
  case_241: /* CIL Label */ 
#line 131
  if ((int )length > 2) {
#line 132
    tmp___1 = data;
#line 132
    data ++;
#line 132
    dest = (unsigned char )*tmp___1;
#line 134
    if ((int )lnp_host_address___2 == ((int )dest & (int )lnp_host_mask___2)) {
#line 135
      port = (unsigned char )((int )dest & (int )lnp_port_mask___2);
#line 137
      if (addressing_handler___2[port]) {
        {
#line 138
        tmp___2 = data;
#line 138
        data ++;
#line 138
        src = (unsigned char )*tmp___2;
#line 139
        (*(addressing_handler___2[port]))(data, (unsigned char )((int )length - 2),
                                          src);
        }
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 144
  return;
}
}
#line 151
static int transmit_ack___2(void) ;
#line 151 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char ack_byte___2  =    (unsigned char)51;
#line 146 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int transmit_ack___2(void) 
{ 
  fd_set fds ;
  struct timeval timeout ;
  int result ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.fds_bits[0]): "memory");
#line 156
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 157
    fds.fds_bits[socket_fd___2 / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket_fd___2 % (8 * (int )sizeof(__fd_mask ));
#line 158
    msecs2timeval___4(1000, & timeout);
#line 159
    result = select(socket_fd___2 + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
    }
#line 160
    if (result == 1) {
#line 160
      goto while_break;
    }
#line 161
    if (result < 0) {
      {
#line 161
      tmp = __errno_location();
      }
#line 161
      if (*tmp == 4) {
#line 161
        goto while_continue;
      }
    }
#line 163
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 166
  tmp___0 = write(socket_fd___2, (void const   *)(& ack_byte___2), (size_t )1);
#line 166
  result = (int )tmp___0;
  }
#line 166
  if (result != 1) {
#line 167
    return (-1);
  }
#line 169
  return (0);
}
}
#line 173 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char buffer___3[259]  ;
#line 174 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int bytesRead___3  ;
#line 174 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int endOfData___3  ;
#line 172 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int receive_byte___2(unsigned char byte_read ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 176
  if ((unsigned int )rcv_state___2 == 0U) {
#line 177
    bytesRead___3 = 0;
  }
#line 179
  tmp = bytesRead___3;
#line 179
  bytesRead___3 ++;
#line 179
  buffer___3[tmp] = byte_read;
  {
#line 183
  if ((unsigned int )rcv_state___2 == 0U) {
#line 183
    goto case_0;
  }
#line 198
  if ((unsigned int )rcv_state___2 == 1U) {
#line 198
    goto case_1;
  }
#line 202
  if ((unsigned int )rcv_state___2 == 2U) {
#line 202
    goto case_2;
  }
#line 181
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 186
  if ((int )byte_read == 51) {
#line 186
    goto case_51;
  }
#line 190
  if ((int )byte_read == 119) {
#line 190
    goto case_119;
  }
#line 194
  goto switch_default;
  case_51: /* CIL Label */ 
#line 187
  tx_result___2 = (lnp_tx_result )0;
#line 188
  tx_active___2 = 0;
#line 189
  goto switch_break___0;
  case_119: /* CIL Label */ 
#line 191
  tx_result___2 = (lnp_tx_result )1;
#line 192
  tx_active___2 = 0;
#line 193
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 195
  rcv_state___2 = (rcv_state_t )((unsigned int )rcv_state___2 + 1U);
  switch_break___0: /* CIL Label */ ;
  }
#line 197
  goto switch_break;
  case_1: /* CIL Label */ 
#line 199
  endOfData___3 = (int )byte_read + 3;
#line 200
  rcv_state___2 = (rcv_state_t )((unsigned int )rcv_state___2 + 1U);
#line 201
  goto switch_break;
  case_2: /* CIL Label */ 
#line 203
  if (bytesRead___3 == endOfData___3) {
    {
#line 205
    rcv_state___2 = (rcv_state_t )0;
#line 206
    tmp___0 = transmit_ack___2();
    }
#line 206
    if (tmp___0) {
#line 206
      return (-1);
    }
#line 207
    if (tx_active___2) {
#line 207
      if (! discard_while_tx___2) {
        {
#line 208
        lnp_receive_packet___2((unsigned char const   *)(buffer___3));
        }
      }
    } else {
      {
#line 208
      lnp_receive_packet___2((unsigned char const   *)(buffer___3));
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 211
  return (0);
}
}
#line 214 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void rcv_handler___2(int signo ) 
{ 
  unsigned char buffer___5[259] ;
  unsigned char *recvd_byte ;
  int length ;
  int i ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 221
  tmp = read(socket_fd___2, (void *)(buffer___5), sizeof(buffer___5));
#line 221
  length = (int )tmp;
  }
#line 222
  if (length < 1) {
#line 224
    if (tx_active___2) {
#line 226
      tx_active___2 = 0;
#line 227
      tx_result___2 = (lnp_tx_result )2;
    } else {
      {
#line 229
      lnp_shutdown();
      }
    }
#line 230
    return;
  }
#line 233
  i = 0;
#line 233
  recvd_byte = buffer___5;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i < length)) {
#line 233
      goto while_break;
    }
    {
#line 235
    tmp___0 = receive_byte___2(*recvd_byte);
    }
#line 235
    if (tmp___0) {
#line 237
      if (tx_active___2) {
#line 239
        tx_active___2 = 0;
#line 240
        tx_result___2 = (lnp_tx_result )2;
      } else {
        {
#line 242
        lnp_shutdown();
        }
      }
#line 243
      return;
    }
#line 233
    i ++;
#line 233
    recvd_byte ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return;
}
}
#line 248 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_tx_result lnp_logical_write___2(unsigned char *data , int length ) 
{ 
  int written ;
  int result ;
  sigset_t newset ;
  sigset_t oldset ;
  fd_set fds ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
#line 250
  written = 0;
#line 255
  if (! connected___2) {
#line 255
    return ((lnp_tx_result )2);
  }
  {
#line 258
  sigemptyset(& newset);
#line 259
  sigaddset(& newset, 29);
#line 260
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& newset), (sigset_t */* __restrict  */)(& oldset));
#line 262
  tx_active___2 = 1;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! (written != length)) {
#line 265
      goto while_break;
    }
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 270
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 270
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& fds.fds_bits[0]): "memory");
#line 270
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 271
      fds.fds_bits[socket_fd___2 / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket_fd___2 % (8 * (int )sizeof(__fd_mask ));
#line 272
      msecs2timeval___4(5000, & timeout);
#line 273
      result = select(socket_fd___2 + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
      }
#line 274
      if (result == 1) {
#line 274
        goto while_break___0;
      }
#line 275
      if (result < 0) {
        {
#line 275
        tmp = __errno_location();
        }
#line 275
        if (*tmp == 4) {
#line 275
          goto while_continue___0;
        }
      }
      {
#line 277
      lnp_shutdown();
      }
#line 278
      return ((lnp_tx_result )2);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 281
    tmp___0 = write(socket_fd___2, (void const   *)(data + written), (size_t )(length - written));
#line 281
    result = (int )tmp___0;
    }
#line 282
    if (result < 1) {
      {
#line 284
      lnp_shutdown();
      }
#line 285
      return ((lnp_tx_result )2);
    }
#line 287
    written += result;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 291
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 293
    sigsuspend((sigset_t const   *)(& oldset));
    }
#line 294
    if (! tx_active___2) {
#line 294
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 297
  if ((unsigned int )tx_result___2 == 2U) {
    {
#line 297
    lnp_shutdown();
    }
  }
  {
#line 299
  unblock_rcv();
  }
#line 301
  return (tx_result___2);
}
}
#line 37 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_host_address___3  ;
#line 38 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_host_mask___3  ;
#line 39 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_port_mask___3  ;
#line 40 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int discard_while_tx___3  ;
#line 41 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int socket_fd___3  ;
#line 42 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int connected___3  ;
#line 43 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int tx_active___3  ;
#line 44 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_tx_result tx_result___3  ;
#line 45 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char lnp_buffer___3[259]  ;
#line 46 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void (*integrity_handler___3)(unsigned char const   * , unsigned char  )  ;
#line 47 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_addressing_handler_t addressing_handler___3[256]  ;
#line 48 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static rcv_state_t rcv_state___3  ;
#line 51 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void msecs2timeval___5(int msecs , struct timeval *tval ) 
{ 


  {
#line 53
  tval->tv_sec = (__time_t )(msecs / 1000);
#line 54
  tval->tv_usec = (__suseconds_t )((msecs * 1000) % 1000000);
#line 55
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned short lnp_checksum___4(unsigned char const   *data , unsigned int length ) 
{ 
  unsigned char a ;
  unsigned char b ;

  {
#line 59
  a = (unsigned char)255;
#line 60
  b = (unsigned char)255;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (length > 0U)) {
#line 62
      goto while_break;
    }
#line 63
    a = (unsigned char )((int )a + (int )*data);
#line 64
    b = (unsigned char )((int )b + (int )a);
#line 65
    data ++;
#line 66
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return ((unsigned short )((int )a + ((int )b << 8)));
}
}
#line 118 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void lnp_receive_packet___3(unsigned char const   *data ) 
{ 
  unsigned char header ;
  unsigned char const   *tmp ;
  unsigned char length ;
  unsigned char const   *tmp___0 ;
  unsigned char dest ;
  unsigned char const   *tmp___1 ;
  unsigned char port ;
  unsigned char src ;
  unsigned char const   *tmp___2 ;

  {
#line 119
  tmp = data;
#line 119
  data ++;
#line 119
  header = (unsigned char )*tmp;
#line 120
  tmp___0 = data;
#line 120
  data ++;
#line 120
  length = (unsigned char )*tmp___0;
  {
#line 125
  if ((int )header == 240) {
#line 125
    goto case_240;
  }
#line 130
  if ((int )header == 241) {
#line 130
    goto case_241;
  }
#line 124
  goto switch_break;
  case_240: /* CIL Label */ 
#line 126
  if (integrity_handler___3) {
    {
#line 127
    (*integrity_handler___3)(data, length);
    }
  }
#line 128
  goto switch_break;
  case_241: /* CIL Label */ 
#line 131
  if ((int )length > 2) {
#line 132
    tmp___1 = data;
#line 132
    data ++;
#line 132
    dest = (unsigned char )*tmp___1;
#line 134
    if ((int )lnp_host_address___3 == ((int )dest & (int )lnp_host_mask___3)) {
#line 135
      port = (unsigned char )((int )dest & (int )lnp_port_mask___3);
#line 137
      if (addressing_handler___3[port]) {
        {
#line 138
        tmp___2 = data;
#line 138
        data ++;
#line 138
        src = (unsigned char )*tmp___2;
#line 139
        (*(addressing_handler___3[port]))(data, (unsigned char )((int )length - 2),
                                          src);
        }
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 144
  return;
}
}
#line 151
static int transmit_ack___3(void) ;
#line 151 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char ack_byte___3  =    (unsigned char)51;
#line 146 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int transmit_ack___3(void) 
{ 
  fd_set fds ;
  struct timeval timeout ;
  int result ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.fds_bits[0]): "memory");
#line 156
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 157
    fds.fds_bits[socket_fd___3 / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket_fd___3 % (8 * (int )sizeof(__fd_mask ));
#line 158
    msecs2timeval___5(1000, & timeout);
#line 159
    result = select(socket_fd___3 + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
    }
#line 160
    if (result == 1) {
#line 160
      goto while_break;
    }
#line 161
    if (result < 0) {
      {
#line 161
      tmp = __errno_location();
      }
#line 161
      if (*tmp == 4) {
#line 161
        goto while_continue;
      }
    }
#line 163
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 166
  tmp___0 = write(socket_fd___3, (void const   *)(& ack_byte___3), (size_t )1);
#line 166
  result = (int )tmp___0;
  }
#line 166
  if (result != 1) {
#line 167
    return (-1);
  }
#line 169
  return (0);
}
}
#line 173 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static unsigned char buffer___4[259]  ;
#line 174 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int bytesRead___4  ;
#line 174 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int endOfData___4  ;
#line 172 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static int receive_byte___3(unsigned char byte_read ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 176
  if ((unsigned int )rcv_state___3 == 0U) {
#line 177
    bytesRead___4 = 0;
  }
#line 179
  tmp = bytesRead___4;
#line 179
  bytesRead___4 ++;
#line 179
  buffer___4[tmp] = byte_read;
  {
#line 183
  if ((unsigned int )rcv_state___3 == 0U) {
#line 183
    goto case_0;
  }
#line 198
  if ((unsigned int )rcv_state___3 == 1U) {
#line 198
    goto case_1;
  }
#line 202
  if ((unsigned int )rcv_state___3 == 2U) {
#line 202
    goto case_2;
  }
#line 181
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 186
  if ((int )byte_read == 51) {
#line 186
    goto case_51;
  }
#line 190
  if ((int )byte_read == 119) {
#line 190
    goto case_119;
  }
#line 194
  goto switch_default;
  case_51: /* CIL Label */ 
#line 187
  tx_result___3 = (lnp_tx_result )0;
#line 188
  tx_active___3 = 0;
#line 189
  goto switch_break___0;
  case_119: /* CIL Label */ 
#line 191
  tx_result___3 = (lnp_tx_result )1;
#line 192
  tx_active___3 = 0;
#line 193
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 195
  rcv_state___3 = (rcv_state_t )((unsigned int )rcv_state___3 + 1U);
  switch_break___0: /* CIL Label */ ;
  }
#line 197
  goto switch_break;
  case_1: /* CIL Label */ 
#line 199
  endOfData___4 = (int )byte_read + 3;
#line 200
  rcv_state___3 = (rcv_state_t )((unsigned int )rcv_state___3 + 1U);
#line 201
  goto switch_break;
  case_2: /* CIL Label */ 
#line 203
  if (bytesRead___4 == endOfData___4) {
    {
#line 205
    rcv_state___3 = (rcv_state_t )0;
#line 206
    tmp___0 = transmit_ack___3();
    }
#line 206
    if (tmp___0) {
#line 206
      return (-1);
    }
#line 207
    if (tx_active___3) {
#line 207
      if (! discard_while_tx___3) {
        {
#line 208
        lnp_receive_packet___3((unsigned char const   *)(buffer___4));
        }
      }
    } else {
      {
#line 208
      lnp_receive_packet___3((unsigned char const   *)(buffer___4));
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 211
  return (0);
}
}
#line 214 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static void rcv_handler___3(int signo ) 
{ 
  unsigned char buffer___5[259] ;
  unsigned char *recvd_byte ;
  int length ;
  int i ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 221
  tmp = read(socket_fd___3, (void *)(buffer___5), sizeof(buffer___5));
#line 221
  length = (int )tmp;
  }
#line 222
  if (length < 1) {
#line 224
    if (tx_active___3) {
#line 226
      tx_active___3 = 0;
#line 227
      tx_result___3 = (lnp_tx_result )2;
    } else {
      {
#line 229
      lnp_shutdown();
      }
    }
#line 230
    return;
  }
#line 233
  i = 0;
#line 233
  recvd_byte = buffer___5;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i < length)) {
#line 233
      goto while_break;
    }
    {
#line 235
    tmp___0 = receive_byte___3(*recvd_byte);
    }
#line 235
    if (tmp___0) {
#line 237
      if (tx_active___3) {
#line 239
        tx_active___3 = 0;
#line 240
        tx_result___3 = (lnp_tx_result )2;
      } else {
        {
#line 242
        lnp_shutdown();
        }
      }
#line 243
      return;
    }
#line 233
    i ++;
#line 233
    recvd_byte ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return;
}
}
#line 248 "/home/wheatley/newnew/temp/lnpd-0.9.0/lnpd+liblnp/liblnp/stub.c"
static lnp_tx_result lnp_logical_write___3(unsigned char *data , int length ) 
{ 
  int written ;
  int result ;
  sigset_t newset ;
  sigset_t oldset ;
  fd_set fds ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
#line 250
  written = 0;
#line 255
  if (! connected___3) {
#line 255
    return ((lnp_tx_result )2);
  }
  {
#line 258
  sigemptyset(& newset);
#line 259
  sigaddset(& newset, 29);
#line 260
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& newset), (sigset_t */* __restrict  */)(& oldset));
#line 262
  tx_active___3 = 1;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! (written != length)) {
#line 265
      goto while_break;
    }
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 270
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 270
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& fds.fds_bits[0]): "memory");
#line 270
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 271
      fds.fds_bits[socket_fd___3 / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket_fd___3 % (8 * (int )sizeof(__fd_mask ));
#line 272
      msecs2timeval___5(5000, & timeout);
#line 273
      result = select(socket_fd___3 + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
      }
#line 274
      if (result == 1) {
#line 274
        goto while_break___0;
      }
#line 275
      if (result < 0) {
        {
#line 275
        tmp = __errno_location();
        }
#line 275
        if (*tmp == 4) {
#line 275
          goto while_continue___0;
        }
      }
      {
#line 277
      lnp_shutdown();
      }
#line 278
      return ((lnp_tx_result )2);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 281
    tmp___0 = write(socket_fd___3, (void const   *)(data + written), (size_t )(length - written));
#line 281
    result = (int )tmp___0;
    }
#line 282
    if (result < 1) {
      {
#line 284
      lnp_shutdown();
      }
#line 285
      return ((lnp_tx_result )2);
    }
#line 287
    written += result;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 291
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 293
    sigsuspend((sigset_t const   *)(& oldset));
    }
#line 294
    if (! tx_active___3) {
#line 294
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 297
  if ((unsigned int )tx_result___3 == 2U) {
    {
#line 297
    lnp_shutdown();
    }
  }
  {
#line 299
  unblock_rcv();
  }
#line 301
  return (tx_result___3);
}
}
