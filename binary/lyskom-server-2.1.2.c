/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 94 "./../include/misc-types.h"
enum __anonenum_Bool_26 {
    FALSE = 0,
    TRUE = 1
} ;
#line 94 "./../include/misc-types.h"
typedef enum __anonenum_Bool_26 Bool;
#line 103 "./../include/misc-types.h"
struct success {
   int unused[1] ;
};
#line 107 "./../include/misc-types.h"
typedef struct success  const  *Success;
#line 70 "./../include/kom-types.h"
typedef unsigned short Conf_no;
#line 71 "./../include/kom-types.h"
typedef unsigned long Text_no;
#line 32 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.h"
struct parameter {
   char const   *name ;
   Success (*assigner)(char const   *val , struct parameter  const  *par ) ;
   void (*freer)(struct parameter  const  *par ) ;
   int min_assignments ;
   int max_assignments ;
   char const   *default_val ;
   void *value ;
   char const   *default_suffix ;
};
#line 383 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
struct suffix_conversion {
   char const   *suffix ;
   double factor ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 33 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/param.h"
struct kom_par {
   char *dbase_dir ;
   char *use_locale ;
   Bool send_async_messages ;
   Bool garb_enable ;
   Bool never_save ;
   char *logaccess_file ;
   char *ip_client_host ;
   char *ip_client_port ;
   Bool use_dns ;
   double dns_log_threshold ;
   Conf_no conf_pres_conf ;
   Conf_no pers_pres_conf ;
   Conf_no motd_conf ;
   Conf_no kom_news_conf ;
   Text_no motd_of_lyskom ;
   char *datafile_name ;
   char *backupfile_name ;
   char *backupfile_name_2 ;
   char *lockfile_name ;
   char *textfile_name ;
   char *numberfile_name ;
   char *numberfile_tmp_name ;
   char *textbackupfile_name ;
   char *backup_dir ;
   char *statistic_name ;
   char *pid_name ;
   char *memuse_name ;
   char *logfile_name ;
   char *connection_status_file ;
   char *connection_status_file_tmp ;
   char *aux_def_file ;
   char *status_file ;
   char *core_dir ;
   char *nologin_file ;
   char *lyskomd_path ;
   char *savecore_path ;
   struct timeval garb_busy_postponement ;
   struct timeval garbtimeout ;
   struct timeval synctimeout ;
   struct timeval garb_interval ;
   Bool permissive_sync ;
   struct timeval sync_interval ;
   struct timeval sync_retry_interval ;
   struct timeval stale_timeout ;
   int saved_items_per_call ;
   unsigned int penalty_per_call ;
   unsigned int penalty_per_read ;
   unsigned int max_penalty ;
   unsigned int low_penalty ;
   unsigned int default_priority ;
   unsigned int max_priority ;
   unsigned int default_weight ;
   unsigned int max_weight ;
   struct timeval connect_timeout ;
   struct timeval login_timeout ;
   struct timeval active_timeout ;
   int client_data_len ;
   int conf_name_len ;
   int pwd_len ;
   int what_do_len ;
   int username_len ;
   int text_len ;
   int aux_len ;
   int broadcast_len ;
   int regexp_len ;
   int stat_name_len ;
   int max_marks_person ;
   int max_marks_text ;
   int max_recipients ;
   int max_comm ;
   int max_foot ;
   int max_crea_misc ;
   int mark_as_read_chunk ;
   int accept_async_len ;
   int max_delete_aux ;
   int max_add_aux ;
   int max_read_ranges ;
   int max_super_conf_loop ;
   int default_nice ;
   int default_keep_commented ;
   int maxmsgsize ;
   int maxqueuedsize_bytes ;
   int maxqueuedsize ;
   int maxdequeuelen ;
   Bool anyone_can_create_new_persons ;
   Bool anyone_can_create_new_confs ;
   Bool create_person_before_login ;
   Bool default_change_name ;
   int cache_conferences ;
   int cache_persons ;
   int cache_text_stats ;
   int authentication_level ;
   Bool log_login ;
   Bool force_iso_8859_1 ;
   int no_files ;
   int normal_shutdown_time ;
   int downtime_mail_start ;
   int downtime_mail_end ;
   char *sendmail_path ;
   Bool invite_by_default ;
   Bool secret_memberships ;
   Bool allow_reinvite ;
   unsigned long max_conf ;
   unsigned long max_text ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 61 "./../libraries/libmisc/s-string.h"
typedef long String_size;
#line 93 "./../libraries/libmisc/s-string.h"
struct __anonstruct_String_26 {
   String_size len ;
   unsigned char *string ;
};
#line 93 "./../libraries/libmisc/s-string.h"
typedef struct __anonstruct_String_26 String;
#line 58 "./../include/kom-types.h"
enum object_type {
    NO_OBJECT_TYPE = 0,
    TEXT_OBJECT_TYPE = 1,
    CONF_OBJECT_TYPE = 2,
    INFO_OBJECT_TYPE = 3
} ;
#line 69 "./../include/kom-types.h"
typedef unsigned short Pers_no;
#line 85 "./../include/kom-types.h"
typedef time_t Time;
#line 169 "./../include/kom-types.h"
struct __anonstruct_Aux_item_flags_31 {
   unsigned int deleted : 1 ;
   unsigned int inherit : 1 ;
   unsigned int secret : 1 ;
   unsigned int hide_creator : 1 ;
   unsigned int dont_garb : 1 ;
   unsigned int reserved3 : 1 ;
   unsigned int reserved4 : 1 ;
   unsigned int reserved5 : 1 ;
};
#line 169 "./../include/kom-types.h"
typedef struct __anonstruct_Aux_item_flags_31 Aux_item_flags;
#line 181 "./../include/kom-types.h"
union __anonunion_target_object_33 {
   Conf_no conf ;
   Text_no text ;
};
#line 181 "./../include/kom-types.h"
struct __anonstruct_Aux_item_link_32 {
   enum object_type target_type ;
   unsigned long target_item ;
   union __anonunion_target_object_33 target_object ;
};
#line 181 "./../include/kom-types.h"
typedef struct __anonstruct_Aux_item_link_32 Aux_item_link;
#line 191 "./../include/kom-types.h"
struct __anonstruct_Aux_item_34 {
   unsigned long aux_no ;
   Pers_no creator ;
   Time sent_at ;
   Aux_item_flags flags ;
   unsigned long inherit_limit ;
   unsigned long tag ;
   String data ;
   Aux_item_link linked_item ;
};
#line 191 "./../include/kom-types.h"
typedef struct __anonstruct_Aux_item_34 Aux_item;
#line 202 "./../include/kom-types.h"
struct __anonstruct_Aux_item_list_35 {
   unsigned short length ;
   Aux_item *items ;
};
#line 202 "./../include/kom-types.h"
typedef struct __anonstruct_Aux_item_list_35 Aux_item_list;
#line 369 "./../include/kom-types.h"
struct __anonstruct_Info_51 {
   long version ;
   Conf_no conf_pres_conf ;
   Conf_no pers_pres_conf ;
   Conf_no motd_conf ;
   Conf_no kom_news_conf ;
   Text_no motd_of_lyskom ;
   unsigned long highest_aux_no ;
   Aux_item_list aux_item_list ;
};
#line 369 "./../include/kom-types.h"
typedef struct __anonstruct_Info_51 Info;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 155 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
union overhead {
   unsigned int val ;
   void *b ;
   long c ;
   long *d ;
   long long e ;
   long long *f ;
   float g ;
   double h ;
   void (*i)(void) ;
   long double j ;
};
#line 31 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.h"
struct __anonstruct_s_18 {
   unsigned int exists : 1 ;
   unsigned int dirty : 1 ;
};
#line 31 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.h"
struct cache_node {
   struct __anonstruct_s_18 s ;
   void *snap_shot ;
   void *ptr ;
   long pos ;
   long size ;
   long pos_b ;
   long size_b ;
   struct cache_node *prev ;
   struct cache_node *next ;
   int lock_cnt ;
};
#line 31 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.h"
typedef struct cache_node Cache_node;
#line 56 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.h"
struct cache_node_block {
   int next_free ;
   Cache_node *nodes ;
   struct cache_node_block *link ;
};
#line 56 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.h"
typedef struct cache_node_block Cache_node_block;
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.h"
struct cache_node_mcb {
   int mcb_size ;
   Cache_node_block *last_block ;
   unsigned long hits ;
   unsigned long misses ;
   Cache_node *mru ;
   Cache_node *lru ;
   unsigned long lookup_table_size ;
   Cache_node **lookup_table ;
};
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.h"
typedef struct cache_node_mcb Cache_node_mcb;
#line 72 "./../include/kom-types.h"
typedef unsigned long Local_text_no;
#line 73 "./../include/kom-types.h"
typedef unsigned long Session_no;
#line 83 "./../include/kom-types.h"
typedef char Password[64];
#line 93 "./../include/kom-types.h"
struct __anonstruct_Priv_bits_20 {
   unsigned int wheel : 1 ;
   unsigned int admin : 1 ;
   unsigned int statistic : 1 ;
   unsigned int create_pers : 1 ;
   unsigned int create_conf : 1 ;
   unsigned int change_name : 1 ;
   unsigned int flg7 : 1 ;
   unsigned int flg8 : 1 ;
   unsigned int flg9 : 1 ;
   unsigned int flg10 : 1 ;
   unsigned int flg11 : 1 ;
   unsigned int flg12 : 1 ;
   unsigned int flg13 : 1 ;
   unsigned int flg14 : 1 ;
   unsigned int flg15 : 1 ;
   unsigned int flg16 : 1 ;
};
#line 93 "./../include/kom-types.h"
typedef struct __anonstruct_Priv_bits_20 Priv_bits;
#line 115 "./../include/kom-types.h"
struct __anonstruct_Personal_flags_21 {
   unsigned int unread_is_secret : 1 ;
   unsigned int flg2 : 1 ;
   unsigned int flg3 : 1 ;
   unsigned int flg4 : 1 ;
   unsigned int flg5 : 1 ;
   unsigned int flg6 : 1 ;
   unsigned int flg7 : 1 ;
   unsigned int flg8 : 1 ;
};
#line 115 "./../include/kom-types.h"
typedef struct __anonstruct_Personal_flags_21 Personal_flags;
#line 129
enum info_type {
    recpt = 0,
    cc_recpt = 1,
    comm_to = 2,
    comm_in = 3,
    footn_to = 4,
    footn_in = 5,
    loc_no = 6,
    rec_time = 7,
    sent_by = 8,
    sent_at = 9,
    bcc_recpt = 15,
    unknown_info = 4711
} ;
#line 145 "./../include/kom-types.h"
union info_datum {
   Conf_no recipient ;
   Text_no text_link ;
   Local_text_no local_no ;
   Time received_at ;
   Pers_no sender ;
   Time sent_at ;
   enum info_type unknown_type ;
};
#line 157 "./../include/kom-types.h"
struct __anonstruct_Misc_info_22 {
   enum info_type type ;
   union info_datum datum ;
};
#line 157 "./../include/kom-types.h"
typedef struct __anonstruct_Misc_info_22 Misc_info;
#line 163 "./../include/kom-types.h"
struct __anonstruct_Misc_info_list_23 {
   unsigned short no_of_misc ;
   Misc_info *misc ;
};
#line 163 "./../include/kom-types.h"
typedef struct __anonstruct_Misc_info_list_23 Misc_info_list;
#line 215 "./../include/kom-types.h"
struct __anonstruct_Text_stat_29 {
   Time creation_time ;
   long file_pos ;
   Pers_no author ;
   unsigned short no_of_lines ;
   String_size no_of_chars ;
   unsigned short no_of_marks ;
   unsigned short no_of_misc ;
   unsigned long highest_aux ;
   Misc_info *misc_items ;
   Aux_item_list aux_item_list ;
};
#line 215 "./../include/kom-types.h"
typedef struct __anonstruct_Text_stat_29 Text_stat;
#line 229 "./../include/kom-types.h"
struct __anonstruct_Conf_type_30 {
   unsigned int rd_prot : 1 ;
   unsigned int original : 1 ;
   unsigned int secret : 1 ;
   unsigned int letter_box : 1 ;
   unsigned int allow_anon : 1 ;
   unsigned int forbid_secret : 1 ;
   unsigned int reserved2 : 1 ;
   unsigned int reserved3 : 1 ;
};
#line 229 "./../include/kom-types.h"
typedef struct __anonstruct_Conf_type_30 Conf_type;
#line 248 "./../include/kom-types.h"
struct __anonstruct_Membership_type_31 {
   unsigned int invitation : 1 ;
   unsigned int passive : 1 ;
   unsigned int secret : 1 ;
   unsigned int passive_message_invert : 1 ;
   unsigned int reserved2 : 1 ;
   unsigned int reserved3 : 1 ;
   unsigned int reserved4 : 1 ;
   unsigned int reserved5 : 1 ;
};
#line 248 "./../include/kom-types.h"
typedef struct __anonstruct_Membership_type_31 Membership_type;
#line 269 "./../include/kom-types.h"
struct __anonstruct_Mark_33 {
   Text_no text_no ;
   unsigned char mark_type ;
};
#line 269 "./../include/kom-types.h"
typedef struct __anonstruct_Mark_33 Mark;
#line 279 "./../include/kom-types.h"
struct read_range {
   Local_text_no first_read ;
   Local_text_no last_read ;
};
#line 284 "./../include/kom-types.h"
struct read_range_list {
   unsigned short length ;
   struct read_range *ranges ;
};
#line 289 "./../include/kom-types.h"
struct __anonstruct_Membership_34 {
   unsigned long position ;
   Conf_no conf_no ;
   unsigned char priority ;
   Time last_time_read ;
   unsigned int no_of_read_ranges ;
   struct read_range *read_ranges ;
   Pers_no added_by ;
   Time added_at ;
   Membership_type type ;
   Bool skip_read_texts ;
};
#line 289 "./../include/kom-types.h"
typedef struct __anonstruct_Membership_34 Membership;
#line 313 "./../include/kom-types.h"
struct __anonstruct_Mark_list_35 {
   unsigned short no_of_marks ;
   Mark *marks ;
};
#line 313 "./../include/kom-types.h"
typedef struct __anonstruct_Mark_list_35 Mark_list;
#line 357 "./../include/kom-types.h"
struct __anonstruct_Membership_list_42 {
   unsigned short no_of_confs ;
   Membership *confs ;
};
#line 357 "./../include/kom-types.h"
typedef struct __anonstruct_Membership_list_42 Membership_list;
#line 362 "./../include/kom-types.h"
struct __anonstruct_Number_list_43 {
   int length ;
   long *data ;
};
#line 362 "./../include/kom-types.h"
typedef struct __anonstruct_Number_list_43 Number_list;
#line 381
struct l2g_block_info;
#line 386 "./../include/kom-types.h"
struct __anonstruct_Local_to_global_45 {
   int num_blocks ;
   Local_text_no first_unused ;
   struct l2g_block_info *blocks ;
};
#line 386 "./../include/kom-types.h"
typedef struct __anonstruct_Local_to_global_45 Local_to_global;
#line 492 "./../include/kom-types.h"
struct __anonstruct_Person_54 {
   Text_no user_area ;
   Priv_bits privileges ;
   Personal_flags flags ;
   Time last_login ;
   unsigned long total_time_present ;
   unsigned long sessions ;
   unsigned long created_lines ;
   unsigned long created_bytes ;
   unsigned long read_texts ;
   unsigned long no_of_text_fetches ;
   unsigned short created_persons ;
   unsigned short created_confs ;
   String username ;
   Local_to_global created_texts ;
   Mark_list marks ;
   Membership_list conferences ;
   Password pwd ;
};
#line 492 "./../include/kom-types.h"
typedef struct __anonstruct_Person_54 Person;
#line 524 "./../include/kom-types.h"
struct __anonstruct_Who_info_56 {
   Pers_no person ;
   String what_am_i_doing ;
   String username ;
   Conf_no working_conference ;
   Session_no session_no ;
};
#line 524 "./../include/kom-types.h"
typedef struct __anonstruct_Who_info_56 Who_info;
#line 552 "./../include/kom-types.h"
struct __anonstruct_Session_flags_59 {
   unsigned int invisible : 1 ;
   unsigned int user_active_used : 1 ;
   unsigned int user_absent : 1 ;
   unsigned int reserved3 : 1 ;
   unsigned int reserved4 : 1 ;
   unsigned int reserved5 : 1 ;
   unsigned int reserved6 : 1 ;
   unsigned int reserved7 : 1 ;
};
#line 552 "./../include/kom-types.h"
typedef struct __anonstruct_Session_flags_59 Session_flags;
#line 597 "./../include/kom-types.h"
struct __anonstruct_Scheduling_info_64 {
   unsigned short priority ;
   unsigned short weight ;
};
#line 597 "./../include/kom-types.h"
typedef struct __anonstruct_Scheduling_info_64 Scheduling_info;
#line 6 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/com.h"
enum call_header {
    call_fnc_login_old = 0,
    call_fnc_logout = 1,
    call_fnc_change_conference = 2,
    call_fnc_change_name = 3,
    call_fnc_change_what_i_am_doing = 4,
    call_fnc_create_person_old = 5,
    call_fnc_get_person_stat_old = 6,
    call_fnc_set_priv_bits = 7,
    call_fnc_set_passwd = 8,
    call_fnc_query_read_texts_old = 9,
    call_fnc_create_conf_old = 10,
    call_fnc_delete_conf = 11,
    call_fnc_lookup_name = 12,
    call_fnc_get_conf_stat_older = 13,
    call_fnc_add_member_old = 14,
    call_fnc_sub_member = 15,
    call_fnc_set_presentation = 16,
    call_fnc_set_etc_motd = 17,
    call_fnc_set_supervisor = 18,
    call_fnc_set_permitted_submitters = 19,
    call_fnc_set_super_conf = 20,
    call_fnc_set_conf_type = 21,
    call_fnc_set_garb_nice = 22,
    call_fnc_get_marks = 23,
    call_fnc_mark_text_old = 24,
    call_fnc_get_text = 25,
    call_fnc_get_text_stat_old = 26,
    call_fnc_mark_as_read = 27,
    call_fnc_create_text_old = 28,
    call_fnc_delete_text = 29,
    call_fnc_add_recipient = 30,
    call_fnc_sub_recipient = 31,
    call_fnc_add_comment = 32,
    call_fnc_sub_comment = 33,
    call_fnc_get_map = 34,
    call_fnc_get_time = 35,
    call_fnc_get_info_old = 36,
    call_fnc_add_footnote = 37,
    call_fnc_sub_footnote = 38,
    call_fnc_who_is_on_old = 39,
    call_fnc_set_unread = 40,
    call_fnc_set_motd_of_lyskom = 41,
    call_fnc_enable = 42,
    call_fnc_sync_kom = 43,
    call_fnc_shutdown_kom = 44,
    call_fnc_broadcast = 45,
    call_fnc_get_membership_old = 46,
    call_fnc_get_created_texts = 47,
    call_fnc_get_members_old = 48,
    call_fnc_get_person_stat = 49,
    call_fnc_get_conf_stat_old = 50,
    call_fnc_who_is_on = 51,
    call_fnc_get_unread_confs = 52,
    call_fnc_send_message = 53,
    call_fnc_get_session_info = 54,
    call_fnc_disconnect = 55,
    call_fnc_who_am_i = 56,
    call_fnc_set_user_area = 57,
    call_fnc_get_last_text = 58,
    call_fnc_create_anonymous_text_old = 59,
    call_fnc_find_next_text_no = 60,
    call_fnc_find_previous_text_no = 61,
    call_fnc_login = 62,
    call_fnc_who_is_on_ident = 63,
    call_fnc_get_session_info_ident = 64,
    call_fnc_re_lookup_person = 65,
    call_fnc_re_lookup_conf = 66,
    call_fnc_lookup_person = 67,
    call_fnc_lookup_conf = 68,
    call_fnc_set_client_version = 69,
    call_fnc_get_client_name = 70,
    call_fnc_get_client_version = 71,
    call_fnc_mark_text = 72,
    call_fnc_unmark_text = 73,
    call_fnc_re_z_lookup = 74,
    call_fnc_get_version_info = 75,
    call_fnc_lookup_z_name = 76,
    call_fnc_set_last_read = 77,
    call_fnc_get_uconf_stat = 78,
    call_fnc_set_info = 79,
    call_fnc_accept_async = 80,
    call_fnc_query_async = 81,
    call_fnc_user_active = 82,
    call_fnc_who_is_on_dynamic = 83,
    call_fnc_get_static_session_info = 84,
    call_fnc_get_collate_table = 85,
    call_fnc_create_text = 86,
    call_fnc_create_anonymous_text = 87,
    call_fnc_create_conf = 88,
    call_fnc_create_person = 89,
    call_fnc_get_text_stat = 90,
    call_fnc_get_conf_stat = 91,
    call_fnc_modify_text_info = 92,
    call_fnc_modify_conf_info = 93,
    call_fnc_get_info = 94,
    call_fnc_modify_system_info = 95,
    call_fnc_query_predefined_aux_items = 96,
    call_fnc_set_expire = 97,
    call_fnc_query_read_texts_10 = 98,
    call_fnc_get_membership_10 = 99,
    call_fnc_add_member = 100,
    call_fnc_get_members = 101,
    call_fnc_set_membership_type = 102,
    call_fnc_local_to_global = 103,
    call_fnc_map_created_texts = 104,
    call_fnc_set_keep_commented = 105,
    call_fnc_set_pers_flags = 106,
    call_fnc_query_read_texts = 107,
    call_fnc_get_membership = 108,
    call_fnc_mark_as_unread = 109,
    call_fnc_set_read_ranges = 110,
    call_fnc_get_stats_description = 111,
    call_fnc_get_stats = 112,
    call_fnc_get_boottime_info = 113,
    call_fnc_first_unused_conf_no = 114,
    call_fnc_first_unused_text_no = 115,
    call_fnc_find_next_conf_no = 116,
    call_fnc_find_previous_conf_no = 117,
    call_fnc_get_scheduling = 118,
    call_fnc_set_scheduling = 119,
    call_fnc_set_connection_time_format = 120,
    call_fnc_local_to_global_reverse = 121,
    call_fnc_map_created_texts_reverse = 122,
    illegal_fnc = -1
} ;
#line 79 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
enum kill_state {
    ks_none = 0,
    ks_pending = 1,
    ks_dying = 2
} ;
#line 86
struct isc_scb;
#line 86 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
struct connection {
   struct connection *prev ;
   struct connection *next ;
   Pers_no pers_no ;
   Person *person ;
   struct timeval connect_time ;
   struct timeval login_time ;
   Conf_no cwc ;
   String what_am_i_doing ;
   unsigned char ena_level ;
   String username ;
   String ident_user ;
   String client_name ;
   String client_version ;
   Session_flags flags ;
   Bool username_valid ;
   Bool dns_done ;
   Bool blocked_by_dns ;
   Bool want_async[23] ;
   struct isc_scb *isc_session ;
   String remote_ip ;
   char *peer ;
   unsigned char protocol ;
   Bool use_utc ;
   int parse_pos ;
   int fnc_parse_pos ;
   int array_parse_pos ;
   int array_parse_index ;
   int array_parse_parsed_length ;
   int struct_parse_pos ;
   int string_parse_pos ;
   int hunt_parse_pos ;
   int array_hunt_num ;
   int array_hunt_depth ;
   int ref_no ;
   enum call_header function ;
   int function_index ;
   Number_list num_list ;
   long num0 ;
   long num1 ;
   long num2 ;
   long num3 ;
   long num4 ;
   String c_string0 ;
   String c_string1 ;
   String string0 ;
   Misc_info_list misc_info_list ;
   Aux_item_list aux_item_list ;
   Aux_item aux_item ;
   Aux_item dummy_aux_item ;
   struct read_range_list read_range_list ;
   Priv_bits priv_bits ;
   Conf_type conf_type ;
   Membership_type membership_type ;
   struct tm time ;
   Info info ;
   Personal_flags pers_flags ;
   String unparsed ;
   String_size first_to_parse ;
   Bool more_to_parse ;
   enum kill_state kill_status ;
   unsigned int penalty ;
   unsigned int penalty_generation ;
   struct connection *queue_prev ;
   struct connection *queue_next ;
   Bool on_queue ;
   Scheduling_info schedule ;
   struct timeval active_time ;
   Session_no session_no ;
};
#line 86 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
typedef struct connection Connection;
#line 51 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.h"
enum ignored_conditions {
    ignore_dns = 1,
    ignore_ident = 2
} ;
#line 37 "./../include/kom-errno.h"
enum kom_err {
    KOM_NO_ERROR = 0,
    KOM_NOT_IMPL = 2,
    KOM_OBSOLETE = 3,
    KOM_PWD = 4,
    KOM_LONG_STR = 5,
    KOM_LOGIN = 6,
    KOM_LOGIN_DISALLOWED = 7,
    KOM_CONF_ZERO = 8,
    KOM_UNDEF_CONF = 9,
    KOM_UNDEF_PERS = 10,
    KOM_ACCESS = 11,
    KOM_PERM = 12,
    KOM_NOT_MEMBER = 13,
    KOM_NO_SUCH_TEXT = 14,
    KOM_TEXT_ZERO = 15,
    KOM_NO_SUCH_LOCAL_TEXT = 16,
    KOM_LOCAL_TEXT_ZERO = 17,
    KOM_BAD_NAME = 18,
    KOM_INDEX_OUT_OF_RANGE = 19,
    KOM_CONF_EXISTS = 20,
    KOM_PERS_EXISTS = 21,
    KOM_SECRET_PUBLIC = 22,
    KOM_LETTER_BOX = 23,
    KOM_LDB_ERR = 24,
    KOM_ILL_MISC = 25,
    KOM_ILLEGAL_INFO_TYPE = 26,
    KOM_ALREADY_RECIPIENT = 27,
    KOM_ALREADY_COMMENT = 28,
    KOM_ALREADY_FOOTNOTE = 29,
    KOM_NOT_RECIPIENT = 30,
    KOM_NOT_COMMENT = 31,
    KOM_NOT_FOOTNOTE = 32,
    KOM_RECIPIENT_LIMIT = 33,
    KOM_COMM_LIMIT = 34,
    KOM_FOOT_LIMIT = 35,
    KOM_MARK_LIMIT = 36,
    KOM_NOT_AUTHOR = 37,
    KOM_OUT_OF_MEMORY = 39,
    KOM_CLIENT_IS_CRAZY = 41,
    KOM_UNDEF_SESSION = 42,
    KOM_REGEX_ERROR = 43,
    KOM_NOT_MARKED = 44,
    KOM_TEMPFAIL = 45,
    KOM_LONG_ARRAY = 46,
    KOM_ANON_REJECTED = 47,
    KOM_ILL_AUX = 48,
    KOM_AUX_PERM = 49,
    KOM_UNKNOWN_ASYNC = 50,
    KOM_INTERNAL_ERROR = 51,
    KOM_FEATURE_DISABLED = 52,
    KOM_MESSAGE_NOT_SENT = 53,
    KOM_INVALID_MEMBERSHIP_TYPE = 54,
    KOM_INVALID_RANGE = 55,
    KOM_INVALID_RANGE_LIST = 56,
    KOM_UNDEFINED_MEASUREMENT = 57,
    KOM_PRIORITY_DENIED = 58,
    KOM_WEIGHT_DENIED = 59,
    KOM_WEIGHT_ZERO = 60,
    KOM_BAD_BOOL = 61,
    KOM_num_errs = 62
} ;
#line 208 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/manipulate.h"
enum access {
    error = 0,
    none = 1,
    read_protected = 2,
    limited = 3,
    member = 4,
    unlimited = 5
} ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 211 "./../include/kom-types.h"
typedef unsigned long Garb_nice;
#line 260 "./../include/kom-types.h"
struct __anonstruct_Member_42 {
   Pers_no member ;
   Pers_no added_by ;
   Time added_at ;
   Membership_type type ;
};
#line 260 "./../include/kom-types.h"
typedef struct __anonstruct_Member_42 Member;
#line 325 "./../include/kom-types.h"
struct __anonstruct_Member_list_47 {
   unsigned short no_of_members ;
   Member *members ;
};
#line 325 "./../include/kom-types.h"
typedef struct __anonstruct_Member_list_47 Member_list;
#line 392 "./../include/kom-types.h"
struct __anonstruct_L2g_iterator_56 {
   Local_to_global const   *l2g ;
   struct l2g_block_info  const  *binfo ;
   int arrindex ;
   Local_text_no beginval ;
   Local_text_no endval ;
   int search_ended ;
   Local_text_no lno ;
   Text_no tno ;
};
#line 392 "./../include/kom-types.h"
typedef struct __anonstruct_L2g_iterator_56 L2g_iterator;
#line 419 "./../include/kom-types.h"
struct __anonstruct_Text_mapping_58 {
   Local_text_no first ;
   unsigned long no_of_texts ;
   Local_to_global const   *l2g ;
};
#line 419 "./../include/kom-types.h"
typedef struct __anonstruct_Text_mapping_58 Text_mapping;
#line 429 "./../include/kom-types.h"
struct __anonstruct_Text_mapping_reverse_59 {
   Local_text_no ceiling ;
   unsigned long no_of_texts ;
   Local_to_global const   *l2g ;
};
#line 429 "./../include/kom-types.h"
typedef struct __anonstruct_Text_mapping_reverse_59 Text_mapping_reverse;
#line 438 "./../include/kom-types.h"
struct __anonstruct_Conference_60 {
   Conf_type type ;
   Pers_no creator ;
   Conf_no supervisor ;
   Conf_no permitted_submitters ;
   Conf_no super_conf ;
   Time creation_time ;
   Text_no presentation ;
   Time last_written ;
   Text_no msg_of_day ;
   Garb_nice nice ;
   Garb_nice keep_commented ;
   Garb_nice expire ;
   String name ;
   unsigned long highest_aux ;
   Aux_item_list aux_item_list ;
   Member_list members ;
   Local_to_global texts ;
};
#line 438 "./../include/kom-types.h"
typedef struct __anonstruct_Conference_60 Conference;
#line 243 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/manipulate.h"
enum memb_visibility {
    mv_none = 0,
    mv_censor_unread = 1,
    mv_full = 2
} ;
#line 29 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.h"
enum stat_type {
    STAT_RUN_QUEUE = 0,
    STAT_DNS_QUEUE = 1,
    STAT_IDENT_QUEUE = 2,
    STAT_CLIENTS = 3,
    STAT_REQUESTS = 4,
    STAT_TEXTS = 5,
    STAT_CONFS = 6,
    STAT_PERSONS = 7,
    STAT_SEND_QUEUE = 8,
    STAT_RECV_QUEUE = 9,
    NUM_STAT = 10
} ;
#line 518 "./../include/kom-types.h"
struct __anonstruct_Who_info_old_55 {
   Pers_no person ;
   String what_am_i_doing ;
   Conf_no working_conference ;
};
#line 518 "./../include/kom-types.h"
typedef struct __anonstruct_Who_info_old_55 Who_info_old;
#line 532 "./../include/kom-types.h"
struct __anonstruct_Who_info_ident_57 {
   Pers_no person ;
   String what_am_i_doing ;
   String username ;
   String ident_user ;
   String hostname ;
   Conf_no working_conference ;
   Session_no session_no ;
};
#line 532 "./../include/kom-types.h"
typedef struct __anonstruct_Who_info_ident_57 Who_info_ident;
#line 542 "./../include/kom-types.h"
struct __anonstruct_Session_info_58 {
   Pers_no person ;
   String what_am_i_doing ;
   String username ;
   Conf_no working_conference ;
   Session_no session ;
   Time connection_time ;
   unsigned long idle_time ;
};
#line 542 "./../include/kom-types.h"
typedef struct __anonstruct_Session_info_58 Session_info;
#line 563 "./../include/kom-types.h"
struct __anonstruct_Dynamic_session_info_60 {
   Session_no session ;
   Pers_no person ;
   Conf_no working_conference ;
   unsigned long idle_time ;
   Session_flags flags ;
   String what_am_i_doing ;
};
#line 563 "./../include/kom-types.h"
typedef struct __anonstruct_Dynamic_session_info_60 Dynamic_session_info;
#line 577 "./../include/kom-types.h"
struct __anonstruct_Static_session_info_62 {
   String username ;
   String hostname ;
   String ident_user ;
   Time connection_time ;
};
#line 577 "./../include/kom-types.h"
typedef struct __anonstruct_Static_session_info_62 Static_session_info;
#line 584 "./../include/kom-types.h"
struct __anonstruct_Session_info_ident_63 {
   Pers_no person ;
   String what_am_i_doing ;
   String username ;
   String ident_user ;
   String hostname ;
   Conf_no working_conference ;
   Session_no session ;
   Time connection_time ;
   unsigned long idle_time ;
};
#line 584 "./../include/kom-types.h"
typedef struct __anonstruct_Session_info_ident_63 Session_info_ident;
#line 319 "./../include/kom-types.h"
struct __anonstruct_Conf_no_list_43 {
   unsigned short no_of_confs ;
   Conf_no *conf_nos ;
};
#line 319 "./../include/kom-types.h"
typedef struct __anonstruct_Conf_no_list_43 Conf_no_list;
#line 334 "./../include/kom-types.h"
struct __anonstruct_Conf_list_old_45 {
   unsigned long no_of_conf_nos ;
   Conf_no *conf_nos ;
   Conf_type *type_of_conf ;
};
#line 334 "./../include/kom-types.h"
typedef struct __anonstruct_Conf_list_old_45 Conf_list_old;
#line 404 "./../include/kom-types.h"
struct __anonstruct_L2g_reverse_iterator_54 {
   Local_to_global const   *l2g ;
   struct l2g_block_info  const  *binfo ;
   int arrindex ;
   Local_text_no beginval ;
   Local_text_no endval ;
   int search_ended ;
   Local_text_no lno ;
   Text_no tno ;
};
#line 404 "./../include/kom-types.h"
typedef struct __anonstruct_L2g_reverse_iterator_54 L2g_reverse_iterator;
#line 471 "./../include/kom-types.h"
struct __anonstruct_Small_conf_58 {
   String name ;
   Conf_type type ;
   Conf_no supervisor ;
   Local_text_no highest_local_no ;
   Garb_nice nice ;
   Garb_nice keep_commented ;
};
#line 471 "./../include/kom-types.h"
typedef struct __anonstruct_Small_conf_58 Small_conf;
#line 480 "./../include/kom-types.h"
struct __anonstruct_Conf_z_info_59 {
   String name ;
   Conf_type type ;
   Conf_no conf_no ;
};
#line 480 "./../include/kom-types.h"
typedef struct __anonstruct_Conf_z_info_59 Conf_z_info;
#line 486 "./../include/kom-types.h"
struct __anonstruct_Conf_z_info_list_60 {
   unsigned short no_of_confs ;
   Conf_z_info *confs ;
};
#line 486 "./../include/kom-types.h"
typedef struct __anonstruct_Conf_z_info_list_60 Conf_z_info_list;
#line 572 "./../include/kom-types.h"
struct __anonstruct_Dynamic_session_info_list_68 {
   long no_of_sessions ;
   Dynamic_session_info *sessions ;
};
#line 572 "./../include/kom-types.h"
typedef struct __anonstruct_Dynamic_session_info_list_68 Dynamic_session_info_list;
#line 602 "./../include/kom-types.h"
struct __anonstruct_Who_info_list_old_72 {
   int no_of_persons ;
   Who_info_old *info ;
};
#line 602 "./../include/kom-types.h"
typedef struct __anonstruct_Who_info_list_old_72 Who_info_list_old;
#line 608 "./../include/kom-types.h"
struct __anonstruct_Who_info_list_73 {
   int no_of_persons ;
   Who_info *info ;
};
#line 608 "./../include/kom-types.h"
typedef struct __anonstruct_Who_info_list_73 Who_info_list;
#line 614 "./../include/kom-types.h"
struct __anonstruct_Who_info_ident_list_74 {
   int no_of_persons ;
   Who_info_ident *info ;
};
#line 614 "./../include/kom-types.h"
typedef struct __anonstruct_Who_info_ident_list_74 Who_info_ident_list;
#line 619 "./../include/kom-types.h"
struct __anonstruct_Version_info_75 {
   unsigned long protocol_version ;
   String server_name ;
   String server_version ;
};
#line 619 "./../include/kom-types.h"
typedef struct __anonstruct_Version_info_75 Version_info;
#line 625 "./../include/kom-types.h"
struct __anonstruct_Stats_76 {
   float average ;
   float ascent_rate ;
   float descent_rate ;
};
#line 625 "./../include/kom-types.h"
typedef struct __anonstruct_Stats_76 Stats;
#line 631 "./../include/kom-types.h"
struct __anonstruct_Stats_list_77 {
   int no_of_stats ;
   Stats *stats ;
};
#line 631 "./../include/kom-types.h"
typedef struct __anonstruct_Stats_list_77 Stats_list;
#line 636 "./../include/kom-types.h"
struct __anonstruct_Stats_description_78 {
   int no_of_stats ;
   String *stat_names ;
   Number_list intervals ;
};
#line 636 "./../include/kom-types.h"
typedef struct __anonstruct_Stats_description_78 Stats_description;
#line 642 "./../include/kom-types.h"
struct __anonstruct_Static_server_info_79 {
   time_t boot_time ;
   time_t save_time ;
   String db_status ;
   Text_no existing_texts ;
   Text_no highest_text_no ;
   Conf_no existing_confs ;
   Conf_no existing_persons ;
   Conf_no highest_conf_no ;
};
#line 642 "./../include/kom-types.h"
typedef struct __anonstruct_Static_server_info_79 Static_server_info;
#line 40 "./../libraries/libisc-new/src/isc.h"
struct isc_mcb;
#line 87
union isc_address;
#line 88 "./../libraries/libisc-new/src/isc.h"
struct isc_scb {
   int fd ;
   union isc_address *raddr ;
   union isc_address *laddr ;
   String remote ;
   struct connection *udg ;
   struct isc_mcb *master ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 1974 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
struct jubel {
   struct jubel *next ;
   Pers_no bad_guy ;
   Text_no divisor ;
   Text_no remainder ;
   Bool public ;
};
#line 668 "./../include/kom-types.h"
struct __anonstruct_Version_info_internal_73 {
   unsigned long protocol_version ;
   char const   *server_name ;
   char const   *server_version ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 29 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache.h"
struct matching_info;
#line 62 "./../libraries/libcommon/parser.h"
struct __anonstruct_Parse_token_76 {
   String word ;
   String_size start_in_string ;
};
#line 62 "./../libraries/libcommon/parser.h"
typedef struct __anonstruct_Parse_token_76 Parse_token;
#line 74 "./../libraries/libcommon/parser.h"
struct matching_info {
   Conf_no conf_no ;
   String name ;
   Parse_token *tokens ;
   int priority ;
};
#line 74 "./../libraries/libcommon/parser.h"
typedef struct matching_info Matching_info;
#line 139 "./../libraries/libcommon/parser.h"
struct __anonstruct_Parse_info_77 {
   int no_of_matches ;
   int *indexes ;
   String arguments ;
};
#line 139 "./../libraries/libcommon/parser.h"
typedef struct __anonstruct_Parse_info_77 Parse_info;
#line 38 "./../libraries/regex/regex.h"
typedef unsigned int reg_syntax_t;
#line 278 "./../libraries/regex/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 346 "./../libraries/regex/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 354 "./../libraries/regex/regex.h"
typedef int regoff_t;
#line 359 "./../libraries/regex/regex.h"
struct re_registers {
   unsigned int num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 63 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
enum value_type {
    VT_AVG = 0,
    VT_ASCEND = 1,
    VT_DESCEND = 2,
    NUM_VT = 3
} ;
#line 65 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
struct avg_status {
   struct timeval when ;
   long value ;
   double acc ;
   float avg_history[900] ;
   time_t avenrun_updated ;
   double avenrun[5] ;
};
#line 39 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/async.h"
enum async {
    ay_new_text_old = 0,
    ay_new_name = 5,
    ay_i_am_on = 6,
    ay_sync_db = 7,
    ay_leave_conf = 8,
    ay_login = 9,
    ay_rejected_connection = 11,
    ay_send_message = 12,
    ay_logout = 13,
    ay_deleted_text = 14,
    ay_new_text = 15,
    ay_new_recipient = 16,
    ay_sub_recipient = 17,
    ay_new_membership = 18,
    ay_new_user_area = 19,
    ay_new_presentation = 20,
    ay_new_motd = 21,
    ay_text_aux_changed = 22,
    ay_dummy_last = 23
} ;
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef long ptrdiff_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_6 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_6 __sigset_t;
#line 49 "/usr/include/signal.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_9 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_10 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_11 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_12 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_13 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_14 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_15 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_8 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_9 _kill ;
   struct __anonstruct__timer_10 _timer ;
   struct __anonstruct__rt_11 _rt ;
   struct __anonstruct__sigchld_12 _sigchld ;
   struct __anonstruct__sigfault_13 _sigfault ;
   struct __anonstruct__sigpoll_14 _sigpoll ;
   struct __anonstruct__sigsys_15 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_7 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_8 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_7 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_27 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_27 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_42 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_43 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_42 __wait_terminated ;
   struct __anonstruct___wait_stopped_43 __wait_stopped ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 16 "./../libraries/liboop/oop.h"
struct oop_source;
#line 16 "./../libraries/liboop/oop.h"
typedef struct oop_source oop_source;
#line 19
enum __anonenum_oop_event_69 {
    OOP_READ = 0,
    OOP_WRITE = 1,
    OOP_EXCEPTION = 2,
    OOP_NUM_EVENTS = 3
} ;
#line 19 "./../libraries/liboop/oop.h"
typedef enum __anonenum_oop_event_69 oop_event;
#line 40 "./../libraries/liboop/oop.h"
typedef void *oop_call_fd(oop_source * , int fd , oop_event  , void * );
#line 41 "./../libraries/liboop/oop.h"
typedef void *oop_call_time(oop_source * , struct timeval  , void * );
#line 42 "./../libraries/liboop/oop.h"
typedef void *oop_call_signal(oop_source * , int sig , void * );
#line 44 "./../libraries/liboop/oop.h"
struct oop_source {
   void (*on_fd)(oop_source * , int fd , oop_event  , oop_call_fd * , void * ) ;
   void (*cancel_fd)(oop_source * , int fd , oop_event  ) ;
   void (*on_time)(oop_source * , struct timeval  , oop_call_time * , void * ) ;
   void (*cancel_time)(oop_source * , struct timeval  , oop_call_time * , void * ) ;
   void (*on_signal)(oop_source * , int sig , oop_call_signal * , void * ) ;
   void (*cancel_signal)(oop_source * , int sig , oop_call_signal * , void * ) ;
};
#line 66
struct oop_source_sys;
#line 66 "./../libraries/liboop/oop.h"
typedef struct oop_source_sys oop_source_sys;
#line 113
struct oop_adapter_signal;
#line 113 "./../libraries/liboop/oop.h"
typedef struct oop_adapter_signal oop_adapter_signal;
#line 668 "./../include/kom-types.h"
typedef struct __anonstruct_Version_info_internal_73 Version_info_internal;
#line 48 "./../libraries/libisc-new/src/isc.h"
typedef void *isc_accept_callback(struct isc_scb *cb_accepting_session , struct isc_scb *cb_new_session );
#line 56 "./../libraries/libisc-new/src/isc.h"
typedef void isc_write_queue_change_cb(int delta_bytes );
#line 53 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
struct Aux_item_definition_s;
#line 53 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
typedef struct Aux_item_definition_s Aux_item_definition;
#line 55 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
struct Aux_item_trigger_data_s {
   short action ;
   enum object_type object_type ;
   unsigned long item_index ;
   unsigned long object_no ;
   void *object ;
   Aux_item *item ;
};
#line 55 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
typedef struct Aux_item_trigger_data_s Aux_item_trigger_data;
#line 65 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
typedef void (*Aux_item_trigger)(Aux_item_trigger_data * );
#line 67
enum aux_item_validation_type {
    AUX_VALIDATE_FUNCTION = 0,
    AUX_VALIDATE_REGEXP = 1,
    AUX_VALIDATE_REJECT = 2
} ;
#line 73 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
struct __anonstruct_Aux_item_validation_data_82 {
   Aux_item const   *item ;
   Aux_item_definition const   *def ;
   Connection *creating_conn ;
   Bool creating ;
   Conf_no subordinate ;
};
#line 73 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
typedef struct __anonstruct_Aux_item_validation_data_82 Aux_item_validation_data;
#line 91 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
typedef Success (*Aux_item_validation_function)(Aux_item_validation_data * );
#line 93 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
struct __anonstruct_re_85 {
   char *regexp ;
   struct re_pattern_buffer *cached_re_buf ;
};
#line 93 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
struct __anonstruct_fn_86 {
   Success (*function)(Aux_item_validation_data * ) ;
};
#line 93 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
union __anonunion_v_84 {
   struct __anonstruct_re_85 re ;
   struct __anonstruct_fn_86 fn ;
};
#line 93 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
struct __anonstruct_Aux_item_validator_83 {
   enum aux_item_validation_type type ;
   union __anonunion_v_84 v ;
};
#line 93 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
typedef struct __anonstruct_Aux_item_validator_83 Aux_item_validator;
#line 112 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
struct __anonstruct_Aux_item_validator_mapping_87 {
   char const   *name ;
   Success (*function)(Aux_item_validation_data * ) ;
};
#line 112 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
typedef struct __anonstruct_Aux_item_validator_mapping_87 Aux_item_validator_mapping;
#line 118 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
struct __anonstruct_Aux_item_trigger_mapping_88 {
   char const   *name ;
   void (*function)(Aux_item_trigger_data * ) ;
};
#line 118 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
typedef struct __anonstruct_Aux_item_trigger_mapping_88 Aux_item_trigger_mapping;
#line 124 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
struct Aux_item_definition_s {
   char *name ;
   unsigned long tag ;
   Aux_item_flags clear_flags ;
   Aux_item_flags set_flags ;
   Bool disabled ;
   Bool author_only ;
   Bool supervisor_only ;
   Bool system_only ;
   Bool one_per_person ;
   Bool unique_data ;
   Bool may_not_delete ;
   Bool owner_delete ;
   unsigned long inherit_limit ;
   Bool texts ;
   short text_a ;
   Bool confs ;
   short conf_a ;
   Bool letterboxes ;
   Bool system ;
   unsigned long num_validators ;
   Aux_item_validator *validators ;
   unsigned long num_delete_triggers ;
   Aux_item_trigger *delete_triggers ;
   unsigned long num_add_triggers ;
   Aux_item_trigger *add_triggers ;
   unsigned long num_undelete_triggers ;
   Aux_item_trigger *undelete_triggers ;
   struct Aux_item_definition_s *next ;
};
#line 141 "aux-item-def-parse.y"
struct aux_item_def_value_type;
#line 169 "aux-item-def-parse.y"
union __anonunion_val_90 {
   String str ;
   unsigned long num ;
};
#line 169 "aux-item-def-parse.y"
struct aux_item_def_value_type {
   int type ;
   union __anonunion_val_90 val ;
};
#line 169 "aux-item-def-parse.y"
union __anonunion_yystype_89 {
   String str ;
   unsigned long num ;
   struct aux_item_def_value_type value ;
};
#line 169 "aux-item-def-parse.y"
typedef union __anonunion_yystype_89 yystype;
#line 188 "aux-item-def-parse.y"
struct yyltype {
   int first_line ;
   int first_column ;
   int last_line ;
   int last_column ;
};
#line 188 "aux-item-def-parse.y"
typedef struct yyltype yyltype;
#line 78 "/i/bison/1.35/share/bison/bison.simple"
union yyalloc {
   short yyss ;
   yystype yyvs ;
   yyltype yyls ;
};
#line 218 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
enum res_type {
    rt_number = 0,
    rt_success = 1,
    rt_person = 2,
    rt_membership = 3,
    rt_membership_old = 4,
    rt_membership_10 = 5,
    rt_conf_list = 6,
    rt_conf_no_list = 7,
    rt_conference_old = 8,
    rt_string = 9,
    rt_mark_list = 10,
    rt_text_stat_old = 11,
    rt_who_info_list = 12,
    rt_who_info_list_old = 13,
    rt_info_old = 14,
    rt_membership_list = 15,
    rt_membership_list_old = 16,
    rt_membership_list_10 = 17,
    rt_member_list = 18,
    rt_member_list_old = 19,
    rt_time_date = 20,
    rt_session_info = 21,
    rt_session_no = 22,
    rt_text_no = 23,
    rt_conf_no = 24,
    rt_session_info_ident = 25,
    rt_who_info_ident_list = 26,
    rt_conf_z_info_list = 27,
    rt_version_info = 28,
    rt_uconference = 29,
    rt_num_list = 30,
    rt_dynamic_session_info_list = 31,
    rt_static_session_info = 32,
    rt_text_stat = 33,
    rt_conference = 34,
    rt_info = 35,
    rt_l2g_iterator_as_text_list = 36,
    rt_text_mapping = 37,
    rt_text_mapping_reverse = 38,
    rt_stats_description = 39,
    rt_stats_list = 40,
    rt_static_server_info = 41,
    rt_scheduling_info = 42
} ;
#line 283 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
union result_holder {
   unsigned long number ;
   Person person ;
   Membership membership ;
   Membership membership_10 ;
   Membership membership_old ;
   Conf_list_old conf_list ;
   Conf_no_list conf_no_list ;
   Conference conference ;
   Conference conference_old ;
   Mark_list mark_list ;
   String string ;
   Text_stat text_stat ;
   Text_stat text_stat_old ;
   Info info ;
   Info info_old ;
   Who_info_list who_info_list ;
   Who_info_list_old who_info_list_old ;
   Membership_list membership_list ;
   Membership_list membership_list_10 ;
   Membership_list membership_list_old ;
   Member_list member_list ;
   Member_list member_list_old ;
   time_t time_date ;
   Session_info session_info ;
   Session_no session_no ;
   Text_no text_no ;
   Conf_no conf_no ;
   Who_info_ident_list who_info_ident_list ;
   Session_info_ident session_info_ident ;
   Conf_z_info_list conf_z_info_list ;
   Version_info version_info ;
   Small_conf uconference ;
   Number_list num_list ;
   Dynamic_session_info_list dynamic_session_info_list ;
   Static_session_info static_session_info ;
   L2g_iterator l2g_iterator_as_text_list ;
   Text_mapping text_mapping ;
   Text_mapping_reverse text_mapping_reverse ;
   Stats_description stats_description ;
   Stats_list stats_list ;
   Static_server_info static_server_info ;
   Scheduling_info scheduling_info ;
};
#line 333 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
struct __anonstruct_Fnc_descriptor_81 {
   enum call_header function ;
   enum res_type result ;
   void (*parser)(Connection *client ) ;
};
#line 333 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
typedef struct __anonstruct_Fnc_descriptor_81 Fnc_descriptor;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 134 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
enum __anonenum_sync_state_88 {
    sync_idle = 0,
    sync_save_conf = 1,
    sync_save_pers = 2,
    sync_save_text = 3,
    sync_error = 4,
    sync_wait = 5,
    sync_ready = 6
} ;
#line 205 "./../libraries/adns/src/adns.h"
enum __anonenum_adns_status_62 {
    adns_s_ok = 0,
    adns_s_nomemory = 1,
    adns_s_unknownrrtype = 2,
    adns_s_systemfail = 3,
    adns_s_max_localfail = 29,
    adns_s_timeout = 30,
    adns_s_allservfail = 31,
    adns_s_norecurse = 32,
    adns_s_invalidresponse = 33,
    adns_s_unknownformat = 34,
    adns_s_max_remotefail = 59,
    adns_s_rcodeservfail = 60,
    adns_s_rcodeformaterror = 61,
    adns_s_rcodenotimplemented = 62,
    adns_s_rcoderefused = 63,
    adns_s_rcodeunknown = 64,
    adns_s_max_tempfail = 99,
    adns_s_inconsistent = 100,
    adns_s_prohibitedcname = 101,
    adns_s_answerdomaininvalid = 102,
    adns_s_answerdomaintoolong = 103,
    adns_s_invaliddata = 104,
    adns_s_max_misconfig = 199,
    adns_s_querydomainwrong = 200,
    adns_s_querydomaininvalid = 201,
    adns_s_querydomaintoolong = 202,
    adns_s_max_misquery = 299,
    adns_s_nxdomain = 300,
    adns_s_nodata = 301,
    adns_s_max_permfail = 499
} ;
#line 205 "./../libraries/adns/src/adns.h"
typedef enum __anonenum_adns_status_62 adns_status;
#line 51 "./../libraries/libisc-new/src/isc.h"
typedef void isc_write_error_cb(struct isc_scb *cb_session , int saved_errno );
#line 54 "./../libraries/libisc-new/src/isc.h"
typedef void isc_stale_output_cb(struct isc_scb *cb_session );
#line 58
enum isc_resolve_status {
    isc_resolve_ok = 0,
    isc_resolve_h_errno = 1,
    isc_resolve_adns_error = 2,
    isc_resolve_aborted = 3
} ;
#line 67 "./../libraries/libisc-new/src/isc.h"
typedef void *isc_resolve_done_cb(struct isc_scb *scb , enum isc_resolve_status res ,
                                  long errcode );
#line 197
enum isc_read_result {
    ISC_READ_DATA = 0,
    ISC_READ_LOGOUT = 1,
    ISC_READ_WOULDBLOCK = 2,
    ISC_READ_ERROR = 3,
    ISC_READ_NOMEM = 4
} ;
#line 99 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
struct yy_buffer_state;
#line 99 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 141 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
typedef unsigned int yy_size_t;
#line 144 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 269 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
typedef unsigned char YY_CHAR;
#line 271 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
typedef int yy_state_type;
#line 41 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
struct l2g_block_info {
   int first_free ;
   int zeroes ;
   Local_text_no start ;
   Local_text_no *key_block ;
   Text_no *value_block ;
};
#line 746 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
typedef Local_text_no Local_text_no_iter;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 77 "./getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 53 "./../libraries/libcommon/misc-parser.h"
enum __anonenum_Misc_struct_type_84 {
    m_recpt = 0,
    m_cc_recpt = 1,
    m_bcc_recpt = 2,
    m_comm_to = 3,
    m_comm_in = 4,
    m_footn_to = 5,
    m_footn_in = 6,
    m_end_of_list = 7,
    m_error = 8
} ;
#line 53 "./../libraries/libcommon/misc-parser.h"
typedef enum __anonenum_Misc_struct_type_84 Misc_struct_type;
#line 66 "./../libraries/libcommon/misc-parser.h"
struct __anonstruct_Misc_info_group_85 {
   Misc_struct_type type ;
   Conf_no recipient ;
   Conf_no cc_recipient ;
   Conf_no bcc_recipient ;
   Local_text_no local_no ;
   Time received_at ;
   Text_no comment_to ;
   Text_no commented_in ;
   Text_no footnote_to ;
   Text_no footnoted_in ;
   Pers_no sender ;
   Time sent_at ;
   Bool is_received ;
   Bool is_sent ;
};
#line 66 "./../libraries/libcommon/misc-parser.h"
typedef struct __anonstruct_Misc_info_group_85 Misc_info_group;
#line 156 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
struct __anonstruct_Person_scratchpad_87 {
   int created_confs ;
};
#line 156 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
typedef struct __anonstruct_Person_scratchpad_87 Person_scratchpad;
#line 168 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
struct delete_list {
   struct delete_list *next ;
   Local_text_no lno ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 109 "./../include/misc-types.h"
struct success  const  * const  OK ;
#line 110
struct success  const  * const  FAILURE ;
#line 36 "./../include/server/smalloc.h"
void *smalloc(size_t size ) ;
#line 40
void sfree(void *ptr ) ;
#line 41 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/log.h"
extern void ( /* format attribute */  kom_log)(char const   *format  , ...) ;
#line 44 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.h"
void read_config(char const   *config_file , struct parameter  const  *par ) ;
#line 46
Success assign_text_no(char const   *val , struct parameter  const  *par ) ;
#line 47
Success assign_conf_no(char const   *val , struct parameter  const  *par ) ;
#line 48
Success assign_int(char const   *val , struct parameter  const  *par ) ;
#line 49
Success assign_ulong(char const   *val , struct parameter  const  *par ) ;
#line 50
Success assign_uint(char const   *val , struct parameter  const  *par ) ;
#line 51
Success assign_string(char const   *val , struct parameter  const  *par ) ;
#line 52
Success assign_bool(char const   *val , struct parameter  const  *par ) ;
#line 53
Success assign_double(char const   *val , struct parameter  const  *par ) ;
#line 54
Success assign_timeval(char const   *val , struct parameter  const  *par ) ;
#line 56
void unassign_string(struct parameter  const  *par ) ;
#line 39 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/lyskomd.h"
 __attribute__((__noreturn__)) void ( /* format attribute */  restart_kom)(char const   *format 
                                                                           , ...) ;
#line 28 "../libraries/libeintr/eintr.h"
extern FILE *i_fopen(char const   * , char const   * ) ;
#line 29
extern int i_fclose(FILE * ) ;
#line 28 "./../libraries/libmisc/timeval-util.h"
extern struct timeval timeval_ctor(time_t sec , int usec ) ;
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int *assignment_count  =    (int *)((void *)0);
#line 67 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int npar  =    0;
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static void init_init(struct parameter  const  *par ) 
{ 
  int ix ;
  void *tmp ;

  {
#line 74
  npar = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )(par + npar)->name != (unsigned long )((void *)0))) {
#line 74
      goto while_break;
    }
#line 74
    npar ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if (! ((unsigned long )assignment_count == (unsigned long )((void *)0))) {
    {
#line 77
    __assert_fail("assignment_count == ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c",
                  77U, "init_init");
    }
  }
  {
#line 78
  tmp = smalloc((unsigned long )npar * sizeof(*assignment_count));
#line 78
  assignment_count = (int *)tmp;
#line 80
  ix = 0;
  }
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (ix < npar)) {
#line 80
      goto while_break___0;
    }
#line 81
    *(assignment_count + ix) = 0;
#line 80
    ix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static void assign_defaults(struct parameter  const  *par , int *err ) 
{ 
  int ix ;
  Success tmp ;

  {
#line 93
  ix = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (ix < npar)) {
#line 93
      goto while_break;
    }
#line 95
    if (*(assignment_count + ix) < (int )(par + ix)->min_assignments) {
      {
#line 97
      kom_log("Parameter %s only assigned %d times (%d times needed)\n", (par + ix)->name,
              *(assignment_count + ix), (par + ix)->min_assignments);
#line 99
      (*err) ++;
      }
    } else
#line 101
    if (*(assignment_count + ix) == 0) {
      {
#line 103
      tmp = (*((par + ix)->assigner))((char const   *)(par + ix)->default_val, par + ix);
      }
#line 103
      if ((unsigned long )tmp != (unsigned long )OK) {
        {
#line 105
        kom_log("default assigner failed for %s\n", (par + ix)->name);
#line 106
        (*err) ++;
        }
      }
    }
#line 93
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int configure_line(FILE *fp , struct parameter  const  *par , int *err ) 
{ 
  char line[1001] ;
  char *start ;
  char *val ;
  char *end ;
  int found ;
  int ix ;
  char *tmp ;
  Success tmp___0 ;
  int tmp___1 ;

  {
  {
#line 128
  tmp = fgets((char */* __restrict  */)(line), 1001, (FILE */* __restrict  */)fp);
  }
#line 128
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 129
    return (-1);
  }
#line 135
  start = line;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((int )*start == 32)) {
#line 135
      if (! ((int )*start == 9)) {
#line 135
        goto while_break;
      }
    }
#line 135
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  if ((int )*start == 35) {
#line 139
    goto case_35;
  }
#line 141
  if ((int )*start == 0) {
#line 141
    goto case_0;
  }
#line 145
  if ((int )*start == 10) {
#line 145
    goto case_10;
  }
#line 137
  goto switch_break;
  case_35: /* CIL Label */ 
#line 140
  return (0);
  case_0: /* CIL Label */ 
  {
#line 142
  kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 143
  (*err) ++;
  }
#line 144
  return (0);
  case_10: /* CIL Label */ 
#line 146
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 149
  val = strchr((char const   *)(line), ':');
  }
#line 150
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    {
#line 153
    end = strchr((char const   *)(line), '\n');
    }
#line 154
    if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 155
      *end = (char )'\000';
    }
    {
#line 157
    kom_log("missing colon: %s\n", line);
#line 158
    (*err) ++;
    }
#line 159
    return (0);
  }
#line 161
  *val = (char )'\000';
#line 162
  val ++;
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (! ((int )*val == 32)) {
#line 162
      if (! ((int )*val == 9)) {
#line 162
        goto while_break___0;
      }
    }
#line 162
    val ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 166
  if ((int )*val == 0) {
#line 166
    goto case_0___0;
  }
#line 164
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 167
  kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 168
  (*err) ++;
  }
#line 169
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 172
  end = strchr((char const   *)val, '\n');
  }
#line 173
  if ((unsigned long )end == (unsigned long )((void *)0)) {
    {
#line 175
    kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 176
    (*err) ++;
    }
#line 177
    return (0);
  }
#line 179
  *end = (char )'\000';
#line 182
  found = 0;
#line 183
  ix = 0;
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (! (ix < npar)) {
#line 183
      goto while_break___1;
    }
    {
#line 185
    tmp___1 = strcmp((char const   *)start, (char const   *)(par + ix)->name);
    }
#line 185
    if (! tmp___1) {
#line 187
      found ++;
#line 188
      if (*(assignment_count + ix) >= (int )(par + ix)->max_assignments) {
#line 188
        if ((par + ix)->max_assignments != -1) {
          {
#line 191
          (*err) ++;
#line 192
          kom_log("variable already assigned %d times: %s\n", *(assignment_count + ix),
                  line);
          }
        } else {
#line 188
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 197
        (*(assignment_count + ix)) ++;
#line 198
        tmp___0 = (*((par + ix)->assigner))((char const   *)val, par + ix);
        }
#line 198
        if ((unsigned long )tmp___0 != (unsigned long )OK) {
          {
#line 200
          kom_log("assigner for %s failed\n", (par + ix)->name);
#line 201
          (*err) ++;
          }
        }
      }
    }
#line 183
    ix ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 207
  if (found != 1) {
    {
#line 209
    kom_log("line matches %d times: %s\n", found, line);
#line 210
    (*err) ++;
    }
#line 211
    return (0);
  }
#line 213
  return (0);
}
}
#line 216 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
void read_config(char const   *config_file , struct parameter  const  *par ) 
{ 
  FILE *fp ;
  int errs ;
  int tmp ;

  {
  {
#line 221
  errs = 0;
#line 223
  init_init(par);
#line 225
  fp = i_fopen(config_file, "r");
  }
#line 226
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 227
    restart_kom("cannot open config file %s\n", config_file);
    }
  }
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 229
    tmp = configure_line(fp, par, & errs);
    }
#line 229
    if (! (tmp != -1)) {
#line 229
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 231
  i_fclose(fp);
#line 232
  assign_defaults(par, & errs);
  }
#line 234
  if (errs) {
    {
#line 235
    restart_kom("Please fix the above errors in %s and restart lyskomd\n", config_file);
    }
  }
  {
#line 238
  sfree((void *)assignment_count);
#line 239
  assignment_count = (int *)0;
  }
#line 240
  return;
}
}
#line 242 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
Success assign_text_no(char const   *val , struct parameter  const  *par ) 
{ 
  int c ;
  unsigned short const   **tmp ;
  long tmp___0 ;

  {
#line 249
  if ((unsigned long )val != (unsigned long )((void *)0)) {
#line 251
    c = (int )((unsigned char )*val);
#line 252
    if (! ((c & -128) == 0)) {
#line 253
      return ((Success )FAILURE);
    } else {
      {
#line 252
      tmp = __ctype_b_loc();
      }
#line 252
      if (! ((int const   )*(*tmp + c) & 2048)) {
#line 253
        return ((Success )FAILURE);
      }
    }
    {
#line 254
    tmp___0 = atol(val);
#line 254
    *((Text_no *)par->value) = (Text_no )tmp___0;
    }
  }
#line 256
  return ((Success )OK);
}
}
#line 259 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
Success assign_conf_no(char const   *val , struct parameter  const  *par ) 
{ 
  int c ;
  unsigned short const   **tmp ;
  long tmp___0 ;

  {
#line 266
  if ((unsigned long )val != (unsigned long )((void *)0)) {
#line 268
    c = (int )((unsigned char )*val);
#line 269
    if (! ((c & -128) == 0)) {
#line 270
      return ((Success )FAILURE);
    } else {
      {
#line 269
      tmp = __ctype_b_loc();
      }
#line 269
      if (! ((int const   )*(*tmp + c) & 2048)) {
#line 270
        return ((Success )FAILURE);
      }
    }
    {
#line 271
    tmp___0 = atol(val);
#line 271
    *((Conf_no *)par->value) = (Conf_no )tmp___0;
    }
  }
#line 273
  return ((Success )OK);
}
}
#line 276 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
Success assign_int(char const   *val , struct parameter  const  *par ) 
{ 
  int c ;
  unsigned short const   **tmp ;
  long tmp___0 ;

  {
#line 283
  if ((unsigned long )val != (unsigned long )((void *)0)) {
#line 285
    c = (int )((unsigned char )*val);
#line 286
    if (! ((c & -128) == 0)) {
#line 286
      goto _L;
    } else {
      {
#line 286
      tmp = __ctype_b_loc();
      }
#line 286
      if (! ((int const   )*(*tmp + c) & 2048)) {
        _L: /* CIL Label */ 
#line 286
        if (c != 45) {
#line 287
          return ((Success )FAILURE);
        }
      }
    }
    {
#line 288
    tmp___0 = atol(val);
#line 288
    *((int *)par->value) = (int )tmp___0;
    }
  }
#line 290
  return ((Success )OK);
}
}
#line 293 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
Success assign_ulong(char const   *val , struct parameter  const  *par ) 
{ 
  int c ;
  unsigned short const   **tmp ;
  long tmp___0 ;

  {
#line 299
  if ((unsigned long )val != (unsigned long )((void *)0)) {
#line 301
    c = (int )((unsigned char )*val);
#line 302
    if (! ((c & -128) == 0)) {
#line 302
      goto _L;
    } else {
      {
#line 302
      tmp = __ctype_b_loc();
      }
#line 302
      if (! ((int const   )*(*tmp + c) & 2048)) {
        _L: /* CIL Label */ 
#line 302
        if (c != 45) {
#line 303
          return ((Success )FAILURE);
        }
      }
    }
    {
#line 304
    tmp___0 = atol(val);
#line 304
    *((unsigned long *)par->value) = (unsigned long )tmp___0;
    }
  }
#line 306
  return ((Success )OK);
}
}
#line 309 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
Success assign_uint(char const   *val , struct parameter  const  *par ) 
{ 
  int c ;
  unsigned short const   **tmp ;
  long tmp___0 ;

  {
#line 315
  if ((unsigned long )val != (unsigned long )((void *)0)) {
#line 317
    c = (int )((unsigned char )*val);
#line 318
    if (! ((c & -128) == 0)) {
#line 318
      goto _L;
    } else {
      {
#line 318
      tmp = __ctype_b_loc();
      }
#line 318
      if (! ((int const   )*(*tmp + c) & 2048)) {
        _L: /* CIL Label */ 
#line 318
        if (c != 45) {
#line 319
          return ((Success )FAILURE);
        }
      }
    }
    {
#line 320
    tmp___0 = atol(val);
#line 320
    *((unsigned int *)par->value) = (unsigned int )tmp___0;
    }
  }
#line 322
  return ((Success )OK);
}
}
#line 325 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
Success assign_string(char const   *val , struct parameter  const  *par ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
#line 329
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 330
    *((char **)par->value) = (char *)((void *)0);
  } else {
    {
#line 333
    tmp = strlen(val);
#line 333
    tmp___0 = smalloc(tmp + 1UL);
#line 333
    *((char **)par->value) = (char *)tmp___0;
#line 334
    strcpy((char */* __restrict  */)*((char **)par->value), (char const   */* __restrict  */)val);
    }
  }
#line 336
  return ((Success )OK);
}
}
#line 339 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
Success assign_bool(char const   *val , struct parameter  const  *par ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 343
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 349
    *((Bool *)par->value) = (Bool )0;
  } else {
    {
#line 343
    tmp___3 = strcmp(val, "false");
    }
#line 343
    if (tmp___3) {
      {
#line 343
      tmp___4 = strcmp(val, "off");
      }
#line 343
      if (tmp___4) {
        {
#line 343
        tmp___5 = strcmp(val, "no");
        }
#line 343
        if (tmp___5) {
          {
#line 343
          tmp___6 = strcmp(val, "0");
          }
#line 343
          if (tmp___6) {
            {
#line 351
            tmp = strcmp(val, "true");
            }
#line 351
            if (tmp) {
              {
#line 351
              tmp___0 = strcmp(val, "on");
              }
#line 351
              if (tmp___0) {
                {
#line 351
                tmp___1 = strcmp(val, "yes");
                }
#line 351
                if (tmp___1) {
                  {
#line 351
                  tmp___2 = strcmp(val, "1");
                  }
#line 351
                  if (tmp___2) {
#line 360
                    return ((Success )FAILURE);
                  } else {
#line 356
                    *((Bool *)par->value) = (Bool )1;
                  }
                } else {
#line 356
                  *((Bool *)par->value) = (Bool )1;
                }
              } else {
#line 356
                *((Bool *)par->value) = (Bool )1;
              }
            } else {
#line 356
              *((Bool *)par->value) = (Bool )1;
            }
          } else {
#line 349
            *((Bool *)par->value) = (Bool )0;
          }
        } else {
#line 349
          *((Bool *)par->value) = (Bool )0;
        }
      } else {
#line 349
        *((Bool *)par->value) = (Bool )0;
      }
    } else {
#line 349
      *((Bool *)par->value) = (Bool )0;
    }
  }
#line 363
  return ((Success )OK);
}
}
#line 367 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
Success assign_double(char const   *val , struct parameter  const  *par ) 
{ 
  char *tail ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 371
  tail = (char *)((void *)0);
#line 373
  if ((unsigned long )val != (unsigned long )((void *)0)) {
    {
#line 375
    tmp = __errno_location();
#line 375
    *tmp = 0;
#line 376
    *((double *)par->value) = strtod((char const   */* __restrict  */)val, (char **/* __restrict  */)(& tail));
#line 377
    tmp___0 = __errno_location();
    }
#line 377
    if (*tmp___0) {
#line 378
      return ((Success )FAILURE);
    } else
#line 377
    if ((unsigned long )tail == (unsigned long )val) {
#line 378
      return ((Success )FAILURE);
    } else
#line 377
    if ((int )*tail != 0) {
#line 378
      return ((Success )FAILURE);
    }
  }
#line 380
  return ((Success )OK);
}
}
#line 388 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static struct suffix_conversion  const  suffix_table[27]  = 
#line 388
  {      {"seconds", 1.0}, 
        {"second", 1.0}, 
        {"sec", 1.0}, 
        {"s", 1.0}, 
        {"minutes", 60.0}, 
        {"minute", 60.0}, 
        {"min", 60.0}, 
        {"hours", 3600.0}, 
        {"hour", 3600.0}, 
        {"h", 3600.0}, 
        {"days", 86400.0}, 
        {"day", 86400.0}, 
        {"d", 86400.0}, 
        {"milliseconds", 0.001}, 
        {"millisecond", 0.001}, 
        {"milli", 0.001}, 
        {"ms", 0.001}, 
        {"microseconds", 0.000001}, 
        {"microsecond", 0.000001}, 
        {"micro", 0.000001}, 
        {"us", 0.000001}, 
        {"u", 0.000001}, 
        {"kiloseconds", 1000.0}, 
        {"megaseconds", 1000000.0}, 
        {"microfortnights", 1.2096}, 
        {"microfortnight", 1.2096}, 
        {(char const   *)((void *)0), 0.0}};
#line 426 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
Success assign_timeval(char const   *val , struct parameter  const  *par ) 
{ 
  char *tail ;
  double number ;
  double err ;
  char const   *suffix ;
  struct suffix_conversion  const  *s ;
  struct timeval tv ;
  int *tmp ;
  int *tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
#line 430
  tail = (char *)((void *)0);
#line 437
  if (! ((unsigned long )par->default_suffix != (unsigned long )((void *)0))) {
    {
#line 437
    __assert_fail("par->default_suffix != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c",
                  437U, "assign_timeval");
    }
  }
#line 439
  if ((unsigned long )val != (unsigned long )((void *)0)) {
    {
#line 441
    tmp = __errno_location();
#line 441
    *tmp = 0;
#line 442
    number = strtod((char const   */* __restrict  */)val, (char **/* __restrict  */)(& tail));
#line 443
    tmp___0 = __errno_location();
    }
#line 443
    if (*tmp___0) {
#line 444
      return ((Success )FAILURE);
    } else
#line 443
    if ((unsigned long )tail == (unsigned long )val) {
#line 444
      return ((Success )FAILURE);
    }
#line 446
    if ((int )*tail != 0) {
#line 447
      suffix = (char const   *)tail;
    } else {
#line 449
      suffix = (char const   *)par->default_suffix;
    }
    {
#line 451
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 451
      tmp___1 = __ctype_b_loc();
      }
#line 451
      if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*suffix)) & 8192)) {
#line 451
        goto while_break;
      }
#line 452
      suffix ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 454
    s = suffix_table;
    {
#line 454
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 454
      if (! ((unsigned long )s->suffix != (unsigned long )((void *)0))) {
#line 454
        goto while_break___0;
      }
      {
#line 455
      tmp___2 = strcmp((char const   *)s->suffix, suffix);
      }
#line 455
      if (! tmp___2) {
#line 456
        goto while_break___0;
      }
#line 454
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 458
    if ((unsigned long )s->suffix == (unsigned long )((void *)0)) {
      {
#line 460
      kom_log("Bad suffix for parameter %s\n", par->name);
      }
#line 461
      return ((Success )FAILURE);
    }
#line 464
    number *= (double )s->factor;
#line 466
    if (number < (double )0) {
      {
#line 468
      kom_log("Negative values not supported for parameter %s\n", par->name);
      }
#line 470
      return ((Success )FAILURE);
    }
    {
#line 473
    tv = timeval_ctor((time_t )number, (int )((number - (double )((int )number)) * (double )1000000 + 0.5));
#line 474
    err = ((double )tv.tv_sec + 1.0e-6 * (double )tv.tv_usec) - number;
    }
#line 475
    if (err < (double )0) {
#line 476
      err = - err;
    }
#line 477
    if (err > 1.0e-6) {
#line 477
      if (err > 1.0e-6 * number) {
        {
#line 482
        kom_log("Overflow for parameter %s (%s)\n", par->name, val);
        }
#line 483
        return ((Success )FAILURE);
      } else {
#line 477
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 477
    if (tv.tv_sec < 0L) {
      {
#line 482
      kom_log("Overflow for parameter %s (%s)\n", par->name, val);
      }
#line 483
      return ((Success )FAILURE);
    } else
#line 477
    if (tv.tv_usec < 0L) {
      {
#line 482
      kom_log("Overflow for parameter %s (%s)\n", par->name, val);
      }
#line 483
      return ((Success )FAILURE);
    } else
#line 477
    if (tv.tv_usec >= 1000000L) {
      {
#line 482
      kom_log("Overflow for parameter %s (%s)\n", par->name, val);
      }
#line 483
      return ((Success )FAILURE);
    }
#line 485
    *((struct timeval *)par->value) = tv;
  }
#line 487
  return ((Success )OK);
}
}
#line 491 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
void unassign_string(struct parameter  const  *par ) 
{ 


  {
#line 494
  if ((unsigned long )*((char **)par->value) != (unsigned long )((void *)0)) {
    {
#line 496
    sfree((void *)*((char **)par->value));
#line 497
    *((char **)par->value) = (char *)((void *)0);
    }
  }
#line 499
  return;
}
}
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 43 "./../include/server/smalloc.h"
void *srealloc(void *ptr , size_t size ) ;
#line 34 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/string-malloc.h"
void *string_malloc(size_t size ) ;
#line 38
void string_free(void *ptr ) ;
#line 41
void *string_realloc(void *ptr , size_t size ) ;
#line 45
void dump_string_alloc_counts(FILE *stat_file ) ;
#line 47 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/string-malloc.c"
static int no_of_allocated_blocks  =    0;
#line 49 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/string-malloc.c"
void *string_malloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 52
  no_of_allocated_blocks ++;
#line 53
  tmp = smalloc(size);
  }
#line 53
  return (tmp);
}
}
#line 57 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/string-malloc.c"
void string_free(void *ptr ) 
{ 


  {
  {
#line 60
  no_of_allocated_blocks --;
#line 61
  sfree(ptr);
  }
#line 62
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/string-malloc.c"
void *string_realloc(void *ptr , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 68
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 69
    tmp = string_malloc(size);
    }
#line 69
    return (tmp);
  }
  {
#line 71
  tmp___0 = srealloc(ptr, size);
  }
#line 71
  return (tmp___0);
}
}
#line 75 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/string-malloc.c"
void dump_string_alloc_counts(FILE *stat_file ) 
{ 


  {
  {
#line 78
  fprintf((FILE */* __restrict  */)stat_file, (char const   */* __restrict  */)"---%s:\n\tAllocated strings:    %d\n",
          "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/string-malloc.c",
          no_of_allocated_blocks);
  }
#line 80
  return;
}
}
#line 38 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/misc-types.c"
static struct success succ_ok  ;
#line 39 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/misc-types.c"
static struct success succ_failure  ;
#line 41 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/misc-types.c"
struct success  const  * const  OK  =    (struct success  const  */* const  */)(& succ_ok);
#line 42 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/misc-types.c"
struct success  const  * const  FAILURE  =    (struct success  const  */* const  */)(& succ_failure);
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 717
extern int system(char const   *__command ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 29 "./../libraries/libmisc/ldifftime.h"
extern long ldifftime(time_t t1 , time_t t2 ) ;
#line 26 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/pidfile.h"
pid_t read_pid_file(char const   *pidfile , char const   *arg0 ) ;
#line 130 "./../libraries/libmisc/s-string.h"
extern void s_set_storage_management(void *(*new_malloc)(size_t  ) , void *(*new_realloc)(void * ,
                                                                                          size_t  ) ,
                                     void (*new_free)(void * ) ) ;
#line 47 "./../include/kom-config.h"
char const   *get_default_config_file_name(void) ;
#line 48
void free_default_config_file_name(void) ;
#line 26 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.h"
void read_configuration(char const   *conf_file ) ;
#line 145 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/param.h"
struct kom_par param ;
#line 26 "./../libraries/libansi/linkansi.h"
extern void link_ansi(void) ;
#line 65 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/updateLysKOM.c"
static void usage(char const   *arg0 ) 
{ 


  {
  {
#line 68
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-c config-file] [ -v ] [ -V ]\n",
          arg0);
#line 70
  exit(1);
  }
}
}
#line 73 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/updateLysKOM.c"
static void checkstatus(FILE *fp , long pid , char *progname ) 
{ 
  char lbuf[80] ;
  struct stat sbuf ;
  char *sendmail ;
  FILE *sendfp ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  time_t tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  time_t tmp___13 ;
  long tmp___14 ;
  time_t tmp___15 ;
  long tmp___16 ;

  {
  {
#line 83
  tmp = fileno(fp);
#line 83
  tmp___0 = fstat(tmp, & sbuf);
  }
#line 83
  if (tmp___0 < 0) {
    {
#line 85
    perror("updateLysKOM: stat failed");
#line 86
    exit(1);
    }
  }
#line 89
  if (pid != 0L) {
    {
#line 91
    tmp___4 = kill((__pid_t )pid, 15);
    }
#line 91
    if (tmp___4 != 0) {
      {
#line 93
      tmp___1 = __errno_location();
      }
#line 93
      if (*tmp___1 != 3) {
        {
#line 95
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: kill(%ld, SIGTERM) failed",
                progname, pid);
#line 97
        perror("");
#line 98
        exit(1);
        }
      }
    } else {
      {
#line 104
      tmp___2 = time((time_t *)((void *)0));
#line 104
      tmp___3 = ldifftime(tmp___2, sbuf.st_mtim.tv_sec);
      }
#line 104
      if (tmp___3 > (long )(60 * param.normal_shutdown_time)) {
        {
#line 108
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Warning: it takes lyskomd a long time to die.\nConsider increasing ``Normal shutdown time\'\' in the config file if you get this message often.\n",
                progname);
#line 113
        exit(1);
        }
      }
    }
  }
  {
#line 118
  tmp___15 = time((time_t *)((void *)0));
#line 118
  tmp___16 = ldifftime(tmp___15, sbuf.st_mtim.tv_sec);
  }
#line 118
  if (! (tmp___16 < (long )(60 * param.downtime_mail_start))) {
    {
#line 122
    tmp___13 = time((time_t *)((void *)0));
#line 122
    tmp___14 = ldifftime(tmp___13, sbuf.st_mtim.tv_sec);
    }
#line 122
    if (tmp___14 < (long )(60 * param.downtime_mail_end)) {
      {
#line 128
      tmp___5 = fgets((char */* __restrict  */)(lbuf), (int )sizeof(lbuf), (FILE */* __restrict  */)fp);
      }
#line 128
      if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
        {
#line 131
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"updateLysKOM: LysKOM has been down for a short while\n");
#line 133
        exit(2);
        }
      } else {
        {
#line 128
        tmp___6 = strcmp((char const   *)param.sendmail_path, ":");
        }
#line 128
        if (tmp___6 == 0) {
          {
#line 131
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"updateLysKOM: LysKOM has been down for a short while\n");
#line 133
          exit(2);
          }
        }
      }
      {
#line 135
      tmp___8 = strchr((char const   *)(lbuf), '\n');
      }
#line 135
      if (tmp___8) {
        {
#line 136
        tmp___7 = strchr((char const   *)(lbuf), '\n');
#line 136
        *tmp___7 = (char )'\000';
        }
      }
      {
#line 138
      tmp___9 = strlen((char const   *)param.sendmail_path);
#line 138
      tmp___10 = smalloc(tmp___9 + 4UL);
#line 138
      sendmail = (char *)tmp___10;
#line 139
      strcpy((char */* __restrict  */)sendmail, (char const   */* __restrict  */)param.sendmail_path);
#line 140
      strcat((char */* __restrict  */)sendmail, (char const   */* __restrict  */)" -t");
#line 142
      sendfp = popen((char const   *)sendmail, "w");
      }
#line 143
      if ((unsigned long )sendfp == (unsigned long )((void *)0)) {
        {
#line 145
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"updateLysKOM: failed to open pipe to ");
#line 146
        perror((char const   *)sendmail);
#line 147
        exit(2);
        }
      }
      {
#line 149
      fprintf((FILE */* __restrict  */)sendfp, (char const   */* __restrict  */)"From: %s\n",
              lbuf);
#line 150
      fprintf((FILE */* __restrict  */)sendfp, (char const   */* __restrict  */)"To: %s\n",
              lbuf);
#line 151
      fprintf((FILE */* __restrict  */)sendfp, (char const   */* __restrict  */)"Subject: lyskomd is down\n");
#line 152
      fprintf((FILE */* __restrict  */)sendfp, (char const   */* __restrict  */)"\n");
#line 153
      fprintf((FILE */* __restrict  */)sendfp, (char const   */* __restrict  */)"Reminder: LysKOM is still not running.\n");
#line 154
      fprintf((FILE */* __restrict  */)sendfp, (char const   */* __restrict  */)".\n");
#line 155
      fflush(sendfp);
#line 156
      tmp___11 = ferror(sendfp);
      }
#line 156
      if (tmp___11) {
        {
#line 158
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"writing to sendmail failed.\n");
#line 159
        exit(2);
        }
      }
      {
#line 162
      tmp___12 = pclose(sendfp);
      }
#line 162
      if (tmp___12 != 0) {
        {
#line 164
        perror("updateLysKOM: sending mail might have failed");
#line 165
        exit(2);
        }
      }
    } else {
      {
#line 170
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"updateLysKOM: LysKOM has been down for a long time\n");
#line 172
      exit(2);
      }
    }
  }
#line 174
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/updateLysKOM.c"
static void savecore(void) 
{ 
  struct stat statbuf ;
  char *corefile ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 183
  tmp = strlen((char const   *)param.core_dir);
#line 183
  tmp___0 = smalloc(((tmp + 1UL) + 4UL) + 1UL);
#line 183
  corefile = (char *)tmp___0;
#line 184
  strcpy((char */* __restrict  */)corefile, (char const   */* __restrict  */)param.core_dir);
#line 185
  strcat((char */* __restrict  */)corefile, (char const   */* __restrict  */)"/core");
#line 187
  tmp___1 = stat((char const   */* __restrict  */)corefile, (struct stat */* __restrict  */)(& statbuf));
  }
#line 187
  if (tmp___1 == 0) {
    {
#line 187
    tmp___2 = stat((char const   */* __restrict  */)param.savecore_path, (struct stat */* __restrict  */)(& statbuf));
    }
#line 187
    if (tmp___2 == 0) {
      {
#line 190
      system((char const   *)param.savecore_path);
      }
    }
  }
  {
#line 192
  sfree((void *)corefile);
  }
#line 193
  return;
}
}
#line 195 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/updateLysKOM.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  FILE *fp ;
  long pid ;
  char const   *config_file ;
  __uid_t tmp ;
  __uid_t tmp___0 ;
  pid_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 202
  config_file = (char const   *)((void *)0);
#line 204
  tmp = getuid();
  }
#line 204
  if (tmp == 0U) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: this program should run as lyskom, not root\n",
            *(argv + 0));
#line 208
    exit(1);
    }
  } else {
    {
#line 204
    tmp___0 = geteuid();
    }
#line 204
    if (tmp___0 == 0U) {
      {
#line 206
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: this program should run as lyskom, not root\n",
              *(argv + 0));
#line 208
      exit(1);
      }
    }
  }
  {
#line 211
  link_ansi();
#line 214
  s_set_storage_management(& string_malloc, & string_realloc, & string_free);
#line 217
  i = 1;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (i < argc) {
#line 217
      if (! ((int )*(*(argv + i) + 0) == 45)) {
#line 217
        goto while_break;
      }
    } else {
#line 217
      goto while_break;
    }
#line 219
    if ((int )*(*(argv + i) + 1) == 0) {
      {
#line 220
      usage((char const   *)*(argv + 0));
      }
    } else
#line 219
    if ((int )*(*(argv + i) + 2) != 0) {
      {
#line 220
      usage((char const   *)*(argv + 0));
      }
    }
    {
#line 224
    if ((int )*(*(argv + i) + 1) == 99) {
#line 224
      goto case_99;
    }
#line 236
    if ((int )*(*(argv + i) + 1) == 118) {
#line 236
      goto case_118;
    }
#line 236
    if ((int )*(*(argv + i) + 1) == 86) {
#line 236
      goto case_118;
    }
#line 240
    goto switch_default;
    case_99: /* CIL Label */ 
#line 225
    if ((unsigned long )config_file != (unsigned long )((void *)0)) {
      {
#line 227
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -c may only be used once\n",
              *(argv + 0));
#line 228
      exit(1);
      }
    }
#line 230
    i ++;
#line 230
    if (i >= argc) {
      {
#line 231
      usage((char const   *)*(argv + 0));
      }
    }
#line 232
    config_file = (char const   *)*(argv + i);
#line 233
    goto switch_break;
    case_118: /* CIL Label */ 
    case_86: /* CIL Label */ 
    {
#line 237
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"updateLysKOM from %s-%s\n",
            "lyskom-server", "2.1.2");
#line 238
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 241
    usage((char const   *)*(argv + 0));
    }
    switch_break: /* CIL Label */ ;
    }
#line 217
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  if (i < argc) {
    {
#line 246
    usage((char const   *)*(argv + 0));
    }
  }
#line 250
  if ((unsigned long )config_file == (unsigned long )((void *)0)) {
    {
#line 251
    config_file = get_default_config_file_name();
    }
  }
  {
#line 253
  read_configuration(config_file);
#line 254
  free_default_config_file_name();
#line 256
  tmp___1 = read_pid_file((char const   *)param.pid_name, (char const   *)*(argv + 0));
#line 256
  pid = (long )tmp___1;
  }
#line 257
  if (pid == 1L) {
    {
#line 259
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: got pid %ld.\n",
            *(argv + 0), pid);
#line 260
    exit(1);
    }
  }
  {
#line 263
  fp = i_fopen((char const   *)param.status_file, "r");
  }
#line 264
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 266
    checkstatus(fp, pid, *(argv + 0));
#line 267
    i_fclose(fp);
    }
  } else {
    {
#line 271
    tmp___2 = __errno_location();
#line 271
    *tmp___2 = 3;
    }
#line 272
    if (pid == 0L) {
#line 272
      goto _L;
    } else {
      {
#line 272
      tmp___4 = kill((__pid_t )pid, 10);
      }
#line 272
      if (tmp___4 != 0) {
        _L: /* CIL Label */ 
        {
#line 274
        tmp___3 = __errno_location();
        }
#line 274
        if (*tmp___3 != 3) {
          {
#line 276
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: kill(%ld, SIGUSR1) failed",
                  *(argv + 0), pid);
#line 277
          perror("");
#line 278
          exit(1);
          }
        }
        {
#line 281
        savecore();
#line 283
        execl((char const   *)param.lyskomd_path, "lyskomd", (char *)0);
#line 284
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: execl() failed: ",
                *(argv + 0));
#line 285
        perror("");
#line 286
        exit(1);
        }
      }
    }
  }
  {
#line 290
  exit(0);
  }
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 511 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 58 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/log.c"
static void kom_logv(char const   *format , va_list AP ) ;
#line 60 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/log.c"
extern void ( /* format attribute */  kom_log)(char const   *format  , ...) 
{ 
  va_list AP ;

  {
  {
#line 65
  __builtin_va_start(AP, format);
#line 66
  kom_logv(format, AP);
#line 67
  __builtin_va_end(AP);
  }
#line 68
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/log.c"
static void kom_logv(char const   *format , va_list AP ) 
{ 
  time_t clk ;
  struct tm *t ;
  __pid_t tmp ;

  {
  {
#line 77
  time(& clk);
#line 78
  t = localtime((time_t const   *)(& clk));
#line 80
  tmp = getpid();
#line 80
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02d%02d%02d %02d:%02d:%02d %ld ",
          t->tm_year % 100, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec,
          (long )tmp);
#line 83
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           AP);
#line 85
  fflush(stderr);
  }
#line 86
  return;
}
}
#line 109
 __attribute__((__noreturn__)) void ( /* format attribute */  restart_kom)(char const   *format 
                                                                           , ...) ;
#line 109 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/log.c"
void ( /* format attribute */  restart_kom)(char const   *format  , ...) 
{ 
  va_list AP ;
  char pathname[1026] ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 137
  __builtin_va_start(AP, format);
#line 138
  kom_logv(format, AP);
#line 139
  __builtin_va_end(AP);
#line 144
  kom_log("Previous message is fatal. Will dump core now.\n");
#line 148
  tmp___0 = getcwd(pathname, (size_t )1026);
  }
#line 148
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 149
    tmp = __errno_location();
#line 149
    kom_log("getcwd failed: errno %d\n", *tmp);
    }
  } else {
    {
#line 151
    kom_log("Search for the core in %s\n", pathname);
    }
  }
  {
#line 162
  abort();
  }
}
}
#line 465 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/manipulate.h"
void register_jubel(Pers_no qazwsxedcpno  __attribute__((__unused__)) , Text_no qazwsxedcdivis  __attribute__((__unused__)) ,
                    Text_no qazwsxedctno  __attribute__((__unused__)) , Bool qazwsxedcpublic  __attribute__((__unused__)) ) ;
#line 43 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/standalone.c"
void register_jubel(Pers_no qazwsxedcpno  __attribute__((__unused__)) , Text_no qazwsxedcdivis  __attribute__((__unused__)) ,
                    Text_no qazwsxedctno  __attribute__((__unused__)) , Bool qazwsxedcpublic  __attribute__((__unused__)) ) 
{ 


  {
#line 49
  return;
}
}
#line 51 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/standalone.c"
Info kom_info  = 
#line 51
     {20102L, (Conf_no )1, (Conf_no )2, (Conf_no )3, (Conf_no )4, (Text_no )0, 0UL,
    {(unsigned short)0, (Aux_item *)((void *)0)}};
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 702 "/usr/include/stdio.h"
extern int ungetc(int __c , FILE *__stream ) ;
#line 38 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/pidfile.c"
pid_t read_pid_file(char const   *pidfile , char const   *arg0 ) 
{ 
  FILE *fp ;
  int saved_errno ;
  pid_t pid ;
  int c ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 44
  pid = 0;
#line 47
  fp = i_fopen(pidfile, "r");
  }
#line 48
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 50
    tmp = __errno_location();
#line 50
    saved_errno = *tmp;
#line 51
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: ",
            arg0);
#line 52
    tmp___0 = __errno_location();
#line 52
    *tmp___0 = saved_errno;
#line 53
    perror(pidfile);
    }
  } else {
    {
#line 57
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 57
      c = _IO_getc(fp);
      }
#line 57
      if (c != -1) {
#line 57
        if (! (c == 32)) {
#line 57
          goto while_break;
        }
      } else {
#line 57
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 59
    ungetc(c, fp);
    }
    {
#line 60
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 60
      c = _IO_getc(fp);
      }
#line 60
      if (c != -1) {
#line 60
        if (c >= 48) {
#line 60
          if (! (c <= 57)) {
#line 60
            goto while_break___0;
          }
        } else {
#line 60
          goto while_break___0;
        }
      } else {
#line 60
        goto while_break___0;
      }
#line 61
      pid = (10 * pid + c) - 48;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 62
    i_fclose(fp);
    }
#line 63
    if (pid < 2) {
      {
#line 65
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: got pid %ld.\n",
              arg0, (long )pid);
#line 66
      exit(1);
      }
    }
  }
#line 70
  return (pid);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 96 "./../include/kom-config.h"
int fd_ceiling ;
#line 99
char const   *WHITESPACE ;
#line 27 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.h"
void free_configuration(void) ;
#line 145 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/param.h"
struct kom_par param  ;
#line 73 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success log_param(char const   *val , struct parameter  const  *qazwsxedcpar  __attribute__((__unused__)) ) ;
#line 74
static Success jubel(char const   *val , struct parameter  const  *par ) ;
#line 75
static Success ident_param(char const   *val , struct parameter  const  *par ) ;
#line 85 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static struct parameter  const  parameters[106]  = 
#line 85
  {      {"Locale", & assign_string, & unassign_string, 0, 1, (char const   *)((void *)0),
      (void *)(& param.use_locale), (char const   *)((void *)0)}, 
        {"Force ISO 8859-1", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "no", (void *)(& param.force_iso_8859_1), (char const   *)((void *)0)}, 
        {"Prefix",
      & assign_string, & unassign_string, 0, 1, "/usr/lyskom", (void *)(& param.dbase_dir),
      (char const   *)((void *)0)}, 
        {"Send async", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.send_async_messages), (char const   *)((void *)0)}, 
        {"Client host",
      & assign_string, & unassign_string, 0, 1, (char const   *)((void *)0), (void *)(& param.ip_client_host),
      (char const   *)((void *)0)}, 
        {"Client port", & assign_string, & unassign_string, 1, 1, (char const   *)((void *)0),
      (void *)(& param.ip_client_port), (char const   *)((void *)0)}, 
        {"Presentation of conferences", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& kom_info.conf_pres_conf), (char const   *)((void *)0)}, 
        {"Presentation of persons",
      & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "2", (void *)(& kom_info.pers_pres_conf), (char const   *)((void *)0)}, 
        {"Motd-conference", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "3", (void *)(& kom_info.motd_conf), (char const   *)((void *)0)}, 
        {"News-conference", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "4", (void *)(& kom_info.kom_news_conf), (char const   *)((void *)0)}, 
        {"Message of the day",
      & assign_text_no, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "0", (void *)(& kom_info.motd_of_lyskom), (char const   *)((void *)0)}, 
        {"Garb", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "on", (void *)(& param.garb_enable), (char const   *)((void *)0)}, 
        {"Never save", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "no", (void *)(& param.never_save), (char const   *)((void *)0)}, 
        {"Data file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-data",
      (void *)(& param.datafile_name), (char const   *)((void *)0)}, 
        {"Backup file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-backup",
      (void *)(& param.backupfile_name), (char const   *)((void *)0)}, 
        {"Backup file 2", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-backup-prev",
      (void *)(& param.backupfile_name_2), (char const   *)((void *)0)}, 
        {"Lock file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-lock",
      (void *)(& param.lockfile_name), (char const   *)((void *)0)}, 
        {"Text file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-texts",
      (void *)(& param.textfile_name), (char const   *)((void *)0)}, 
        {"Number file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/number.txt",
      (void *)(& param.numberfile_name), (char const   *)((void *)0)}, 
        {"Number temp file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/number.tmp",
      (void *)(& param.numberfile_tmp_name), (char const   *)((void *)0)}, 
        {"Text backup file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-texts-backup",
      (void *)(& param.textbackupfile_name), (char const   *)((void *)0)}, 
        {"Backup export directory", & assign_string, & unassign_string, 0, 1, "var/lyskomd/exportdb",
      (void *)(& param.backup_dir), (char const   *)((void *)0)}, 
        {"Log file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.log", (void *)(& param.logfile_name),
      (char const   *)((void *)0)}, 
        {"Log statistics", & assign_string, & unassign_string, 0, 1, "var/lyskomd.stats",
      (void *)(& param.statistic_name), (char const   *)((void *)0)}, 
        {"Pid file", & assign_string, & unassign_string, 0, 1, "var/run/lyskomd.pid",
      (void *)(& param.pid_name), (char const   *)((void *)0)}, 
        {"Memory usage file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.memory",
      (void *)(& param.memuse_name), (char const   *)((void *)0)}, 
        {"Aux-item definition file", & assign_string, & unassign_string, 0, 1, "etc/aux-items.conf",
      (void *)(& param.aux_def_file), (char const   *)((void *)0)}, 
        {"Status file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/status",
      (void *)(& param.status_file), (char const   *)((void *)0)}, 
        {"Connection status file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.clients",
      (void *)(& param.connection_status_file), (char const   *)((void *)0)}, 
        {"Connection status temp file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.clnt.tmp",
      (void *)(& param.connection_status_file_tmp), (char const   *)((void *)0)}, 
        {"Core directory", & assign_string, & unassign_string, 0, 1, "var/lyskomd.cores",
      (void *)(& param.core_dir), (char const   *)((void *)0)}, 
        {"Nologin file", & assign_string, & unassign_string, 0, 1, "/etc/nologin", (void *)(& param.nologin_file),
      (char const   *)((void *)0)}, 
        {"Garb busy postponement", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "50", (void *)(& param.garb_busy_postponement), "milliseconds"}, 
        {"Garb timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.garbtimeout), "milliseconds"}, 
        {"Sync timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.synctimeout), "milliseconds"}, 
        {"Garb interval", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1440", (void *)(& param.garb_interval), "minutes"}, 
        {"Permissive sync", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "off", (void *)(& param.permissive_sync), (char const   *)((void *)0)}, 
        {"Sync interval",
      & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "5", (void *)(& param.sync_interval), "minutes"}, 
        {"Sync retry interval", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.sync_retry_interval), "minutes"}, 
        {"Saved items per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "5", (void *)(& param.saved_items_per_call), (char const   *)((void *)0)}, 
        {"Penalty per call",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "10", (void *)(& param.penalty_per_call), (char const   *)((void *)0)}, 
        {"Penalty per read", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.penalty_per_read), (char const   *)((void *)0)}, 
        {"Max penalty",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "100", (void *)(& param.max_penalty), (char const   *)((void *)0)}, 
        {"Low penalty", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.low_penalty), (char const   *)((void *)0)}, 
        {"Default priority", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.default_priority), (char const   *)((void *)0)}, 
        {"Max priority",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "0", (void *)(& param.max_priority), (char const   *)((void *)0)}, 
        {"Default weight", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.default_weight), (char const   *)((void *)0)}, 
        {"Max weight", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "100", (void *)(& param.max_weight), (char const   *)((void *)0)}, 
        {"Connect timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "30", (void *)(& param.connect_timeout), "seconds"}, 
        {"Login timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "30", (void *)(& param.login_timeout), "minutes"}, 
        {"Active timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "11.5", (void *)(& param.active_timeout), "days"}, 
        {"Max client message size", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "8176", (void *)(& param.maxmsgsize), (char const   *)((void *)0)}, 
        {"Max client transmit queue messages", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "50", (void *)(& param.maxqueuedsize), (char const   *)((void *)0)}, 
        {"Max client transmit queue bytes", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "100000", (void *)(& param.maxqueuedsize_bytes), (char const   *)((void *)0)}, 
        {"Stale timeout",
      & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "60", (void *)(& param.stale_timeout), "minutes"}, 
        {"Max simultaneous client replies", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "10", (void *)(& param.maxdequeuelen), (char const   *)((void *)0)}, 
        {"Open files", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "-1", (void *)(& param.no_files), (char const   *)((void *)0)}, 
        {"Use DNS", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "yes", (void *)(& param.use_dns), (char const   *)((void *)0)}, 
        {"DNS log threshold", & assign_double, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1.5", (void *)(& param.dns_log_threshold), (char const   *)((void *)0)}, 
        {"Max conference name length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "60",
      (void *)(& param.conf_name_len), (char const   *)((void *)0)}, 
        {"Max client data length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "60", (void *)(& param.client_data_len), (char const   *)((void *)0)}, 
        {"Max password length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.pwd_len), (char const   *)((void *)0)}, 
        {"Max what am I doing length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "60", (void *)(& param.what_do_len), (char const   *)((void *)0)}, 
        {"Max username length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.username_len), (char const   *)((void *)0)}, 
        {"Max text length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "131072", (void *)(& param.text_len), (char const   *)((void *)0)}, 
        {"Max aux_item length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "16384", (void *)(& param.aux_len), (char const   *)((void *)0)}, 
        {"Max broadcast length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1024", (void *)(& param.broadcast_len), (char const   *)((void *)0)}, 
        {"Max regexp length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "1024",
      (void *)(& param.regexp_len), (char const   *)((void *)0)}, 
        {"Statistic name length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "64", (void *)(& param.stat_name_len), (char const   *)((void *)0)}, 
        {"Max marks per person", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "2048", (void *)(& param.max_marks_person), (char const   *)((void *)0)}, 
        {"Max marks per text",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "1024",
      (void *)(& param.max_marks_text), (char const   *)((void *)0)}, 
        {"Max recipients per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "512", (void *)(& param.max_recipients), (char const   *)((void *)0)}, 
        {"Max comments per text",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.max_comm), (char const   *)((void *)0)}, 
        {"Max footnotes per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "32", (void *)(& param.max_foot), (char const   *)((void *)0)}, 
        {"Max links per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "512", (void *)(& param.max_crea_misc), (char const   *)((void *)0)}, 
        {"Max mark_as_read chunks", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.mark_as_read_chunk), (char const   *)((void *)0)}, 
        {"Max accept_async len",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.accept_async_len), (char const   *)((void *)0)}, 
        {"Max aux_items added per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.max_add_aux), (char const   *)((void *)0)}, 
        {"Max aux_items deleted per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.max_delete_aux), (char const   *)((void *)0)}, 
        {"Max read_ranges per call",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "512",
      (void *)(& param.max_read_ranges), (char const   *)((void *)0)}, 
        {"Max super_conf loop", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "17", (void *)(& param.max_super_conf_loop), (char const   *)((void *)0)}, 
        {"Default garb nice",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "77",
      (void *)(& param.default_nice), (char const   *)((void *)0)}, 
        {"Default keep commented nice", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "77", (void *)(& param.default_keep_commented), (char const   *)((void *)0)}, 
        {"Anyone can create new persons",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.anyone_can_create_new_persons), (char const   *)((void *)0)}, 
        {"Anyone can create new conferences",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.anyone_can_create_new_confs), (char const   *)((void *)0)}, 
        {"Allow creation of persons before login",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.create_person_before_login), (char const   *)((void *)0)}, 
        {"Default change name capability",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "on", (void *)(& param.default_change_name), (char const   *)((void *)0)}, 
        {"Add members by invitation", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "on", (void *)(& param.invite_by_default), (char const   *)((void *)0)}, 
        {"Allow secret memberships",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "on", (void *)(& param.secret_memberships), (char const   *)((void *)0)}, 
        {"Allow reinvitations", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "off", (void *)(& param.allow_reinvite), (char const   *)((void *)0)}, 
        {"Log login",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "off", (void *)(& param.log_login), (char const   *)((void *)0)}, 
        {"Ident-authentication", & ident_param, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "try", (void *)(& param.authentication_level), (char const   *)((void *)0)}, 
        {"Cache conference limit",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "20",
      (void *)(& param.cache_conferences), (char const   *)((void *)0)}, 
        {"Cache person limit", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.cache_persons), (char const   *)((void *)0)}, 
        {"Cache text_stat limit", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.cache_text_stats), (char const   *)((void *)0)}, 
        {"Echo",
      & log_param, (void (*)(struct parameter  const  *par ))((void *)0), 0, -1, (char const   *)((void *)0),
      (void *)0, (char const   *)((void *)0)}, 
        {"Jubel", & jubel, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      -1, (char const   *)((void *)0), (void *)0, (char const   *)((void *)0)}, 
        {"Max conferences", & assign_ulong, (void (*)(struct parameter  const  *par ))((void *)0),
      1, 1, "4765", (void *)(& param.max_conf), (char const   *)((void *)0)}, 
        {"Max texts", & assign_ulong, (void (*)(struct parameter  const  *par ))((void *)0),
      1, 1, "2000000", (void *)(& param.max_text), (char const   *)((void *)0)}, 
        {"Normal shutdown time", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "21", (void *)(& param.normal_shutdown_time), (char const   *)((void *)0)}, 
        {"Mail after downtime",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "60",
      (void *)(& param.downtime_mail_start), (char const   *)((void *)0)}, 
        {"Mail until downtime", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "120", (void *)(& param.downtime_mail_end), (char const   *)((void *)0)}, 
        {"sendmail path",
      & assign_string, & unassign_string, 0, 1, ":", (void *)(& param.sendmail_path),
      (char const   *)((void *)0)}, 
        {"lyskomd path", & assign_string, & unassign_string, 0, 1, "sbin/lyskomd", (void *)(& param.lyskomd_path),
      (char const   *)((void *)0)}, 
        {"savecore path", & assign_string, & unassign_string, 0, 1, "sbin/savecore-lyskom",
      (void *)(& param.savecore_path), (char const   *)((void *)0)}, 
        {(char const   *)((void *)0), (Success (*)(char const   *val , struct parameter  const  *par ))((void *)0),
      (void (*)(struct parameter  const  *par ))((void *)0), 0, 0, (char const   *)((void *)0),
      (void *)0, (char const   *)((void *)0)}};
#line 542 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   compiled_config_file[17]  = 
#line 542
  {      (char const   )'e',      (char const   )'t',      (char const   )'c',      (char const   )'/', 
        (char const   )'l',      (char const   )'y',      (char const   )'s',      (char const   )'k', 
        (char const   )'o',      (char const   )'m',      (char const   )'d',      (char const   )'.', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'f', 
        (char const   )'\000'};
#line 543 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   *default_config  =    (char const   *)((void *)0);
#line 545 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
char const   *get_default_config_file_name(void) 
{ 
  char *cfg ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 548
  if ((unsigned long )default_config == (unsigned long )((void *)0)) {
#line 550
    if ((int const   )compiled_config_file[0] == 47) {
#line 551
      default_config = compiled_config_file;
    } else {
      {
#line 554
      tmp = strlen("/usr/lyskom");
#line 554
      tmp___0 = strlen(compiled_config_file);
#line 554
      tmp___1 = smalloc((tmp + tmp___0) + 2UL);
#line 554
      cfg = (char *)tmp___1;
#line 556
      sprintf((char */* __restrict  */)cfg, (char const   */* __restrict  */)"%s/%s",
              "/usr/lyskom", compiled_config_file);
#line 557
      default_config = (char const   *)cfg;
      }
    }
  }
#line 560
  return (default_config);
}
}
#line 564 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
void free_default_config_file_name(void) 
{ 


  {
#line 567
  if ((unsigned long )default_config != (unsigned long )((void *)0)) {
#line 567
    if ((unsigned long )default_config != (unsigned long )(compiled_config_file)) {
      {
#line 572
      sfree((void *)((char *)default_config));
      }
    }
  }
#line 574
  default_config = (char const   *)((void *)0);
#line 575
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
int fd_ceiling  =    0;
#line 582 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
char const   *WHITESPACE  =    " \t\n\r";
#line 584 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success log_param(char const   *val , struct parameter  const  *qazwsxedcpar  __attribute__((__unused__)) ) 
{ 


  {
#line 587
  if ((unsigned long )val != (unsigned long )((void *)0)) {
    {
#line 588
    kom_log("config: %s\n", val);
    }
  }
#line 589
  return ((Success )OK);
}
}
#line 592 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success jubel(char const   *val , struct parameter  const  *par ) 
{ 
  long a ;
  long b ;
  long c ;
  int res ;
  Bool public ;
  int tmp ;

  {
#line 597
  public = (Bool )0;
#line 599
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 600
    return ((Success )OK);
  }
  {
#line 602
  tmp = strncmp(val, "public ", (size_t )7);
  }
#line 602
  if (! tmp) {
#line 604
    public = (Bool )1;
#line 605
    val += 7;
  }
  {
#line 608
  res = sscanf((char const   */* __restrict  */)val, (char const   */* __restrict  */)"%ld %ld %ld",
               & a, & b, & c);
  }
  {
#line 611
  if (res == 3) {
#line 611
    goto case_3;
  }
#line 614
  if (res == 2) {
#line 614
    goto case_2;
  }
#line 617
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 612
  register_jubel((Pers_no )a, (Text_no )b, (Text_no )c, public);
  }
#line 613
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 615
  register_jubel((Pers_no )a, (Text_no )0, (Text_no )b, public);
  }
#line 616
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 618
  kom_log("%s expecting [public ] x y [z]\n", par->name);
  }
#line 619
  return ((Success )FAILURE);
  switch_break: /* CIL Label */ ;
  }
#line 621
  return ((Success )OK);
}
}
#line 624 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success ident_param(char const   *val , struct parameter  const  *par ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 627
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    {
#line 628
    restart_kom("ident_param(): val == NULL\n");
    }
  }
  {
#line 629
  tmp___3 = strcmp(val, "off");
  }
#line 629
  if (tmp___3) {
    {
#line 629
    tmp___4 = strcmp(val, "never");
    }
#line 629
    if (tmp___4) {
      {
#line 634
      tmp___1 = strcmp(val, "on");
      }
#line 634
      if (tmp___1) {
        {
#line 634
        tmp___2 = strcmp(val, "try");
        }
#line 634
        if (tmp___2) {
          {
#line 639
          tmp = strcmp(val, "require");
          }
#line 639
          if (tmp) {
            {
#line 639
            tmp___0 = strcmp(val, "required");
            }
#line 639
            if (tmp___0) {
              {
#line 646
              kom_log("%s expects \"never\", \"try\" or \"required\" as argument\n",
                      par->name);
              }
#line 648
              return ((Success )FAILURE);
            } else {
#line 642
              *((int *)par->value) = 2;
            }
          } else {
#line 642
            *((int *)par->value) = 2;
          }
        } else {
#line 637
          *((int *)par->value) = 1;
        }
      } else {
#line 637
        *((int *)par->value) = 1;
      }
    } else {
#line 632
      *((int *)par->value) = 0;
    }
  } else {
#line 632
    *((int *)par->value) = 0;
  }
#line 650
  return ((Success )OK);
}
}
#line 653 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void add_prefix(char **name___0 ) 
{ 
  char *s ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 658
  if ((int )*(*name___0) == 47) {
#line 659
    return;
  }
  {
#line 661
  tmp = strlen((char const   *)param.dbase_dir);
#line 661
  tmp___0 = strlen((char const   *)*name___0);
#line 661
  tmp___1 = smalloc((2UL + tmp) + tmp___0);
#line 661
  s = (char *)tmp___1;
#line 662
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%s/%s", param.dbase_dir,
          *name___0);
#line 663
  sfree((void *)*name___0);
#line 664
  *name___0 = s;
  }
#line 665
  return;
}
}
#line 667 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   *param_name(void *value ) 
{ 
  int ix ;

  {
#line 672
  ix = 0;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! ((unsigned long )parameters[ix].name != (unsigned long )((void *)0))) {
#line 672
      goto while_break;
    }
#line 673
    if ((unsigned long )parameters[ix].value == (unsigned long )value) {
#line 674
      return ((char const   *)parameters[ix].name);
    }
#line 672
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  restart_kom("Internal error: non-existing config param in param_name.\n");
  }
#line 678
  return ((char const   *)((void *)0));
}
}
#line 681 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Bool check_abs_path(char **path ) 
{ 
  char const   *tmp ;

  {
#line 684
  if ((int )*(*path) == 47) {
#line 685
    return ((Bool )0);
  }
  {
#line 687
  tmp = param_name((void *)path);
#line 687
  kom_log("Parameter \'%s\' must be an absolute path when \'Prefix\' is empty.\n",
          tmp);
  }
#line 689
  return ((Bool )1);
}
}
#line 692 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void require_less(void *low , void *high ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 696
  tmp = param_name(high);
#line 696
  tmp___0 = param_name(low);
#line 696
  kom_log("Parameter \'%s\' must be less than parameter \'%s\'.\n", tmp___0, tmp);
  }
#line 699
  return;
}
}
#line 701 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void require_less_eq(void *low , void *high ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 705
  tmp = param_name(high);
#line 705
  tmp___0 = param_name(low);
#line 705
  kom_log("Parameter \'%s\' must be less than or equal to parameter \'%s\'.\n", tmp___0,
          tmp);
  }
#line 708
  return;
}
}
#line 710 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
void read_configuration(char const   *conf_file ) 
{ 
  Bool err ;
  int tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;
  Bool tmp___3 ;
  Bool tmp___4 ;
  Bool tmp___5 ;
  Bool tmp___6 ;
  Bool tmp___7 ;
  Bool tmp___8 ;
  Bool tmp___9 ;
  Bool tmp___10 ;
  Bool tmp___11 ;
  Bool tmp___12 ;
  Bool tmp___13 ;
  Bool tmp___14 ;
  Bool tmp___15 ;
  Bool tmp___16 ;
  Bool tmp___17 ;
  Bool tmp___18 ;
  Bool tmp___19 ;
  Bool tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;

  {
  {
#line 713
  err = (Bool )0;
#line 715
  read_config(conf_file, parameters);
  }
#line 717
  if (! ((unsigned long )param.dbase_dir != (unsigned long )((void *)0))) {
    {
#line 717
    __assert_fail("param.dbase_dir != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  717U, "read_configuration");
    }
  }
#line 718
  if (! ((unsigned long )param.datafile_name != (unsigned long )((void *)0))) {
    {
#line 718
    __assert_fail("param.datafile_name != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  718U, "read_configuration");
    }
  }
#line 719
  if (! ((unsigned long )param.backupfile_name != (unsigned long )((void *)0))) {
    {
#line 719
    __assert_fail("param.backupfile_name != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  719U, "read_configuration");
    }
  }
#line 720
  if (! ((unsigned long )param.backupfile_name_2 != (unsigned long )((void *)0))) {
    {
#line 720
    __assert_fail("param.backupfile_name_2 != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  720U, "read_configuration");
    }
  }
#line 721
  if (! ((unsigned long )param.lockfile_name != (unsigned long )((void *)0))) {
    {
#line 721
    __assert_fail("param.lockfile_name != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  721U, "read_configuration");
    }
  }
#line 722
  if (! ((unsigned long )param.textfile_name != (unsigned long )((void *)0))) {
    {
#line 722
    __assert_fail("param.textfile_name != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  722U, "read_configuration");
    }
  }
#line 723
  if (! ((unsigned long )param.numberfile_name != (unsigned long )((void *)0))) {
    {
#line 723
    __assert_fail("param.numberfile_name != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  723U, "read_configuration");
    }
  }
#line 724
  if (! ((unsigned long )param.numberfile_tmp_name != (unsigned long )((void *)0))) {
    {
#line 724
    __assert_fail("param.numberfile_tmp_name != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  724U, "read_configuration");
    }
  }
#line 725
  if (! ((unsigned long )param.textbackupfile_name != (unsigned long )((void *)0))) {
    {
#line 725
    __assert_fail("param.textbackupfile_name != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  725U, "read_configuration");
    }
  }
#line 726
  if (! ((unsigned long )param.backup_dir != (unsigned long )((void *)0))) {
    {
#line 726
    __assert_fail("param.backup_dir != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  726U, "read_configuration");
    }
  }
#line 727
  if (! ((unsigned long )param.statistic_name != (unsigned long )((void *)0))) {
    {
#line 727
    __assert_fail("param.statistic_name != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  727U, "read_configuration");
    }
  }
#line 728
  if (! ((unsigned long )param.pid_name != (unsigned long )((void *)0))) {
    {
#line 728
    __assert_fail("param.pid_name != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  728U, "read_configuration");
    }
  }
#line 729
  if (! ((unsigned long )param.memuse_name != (unsigned long )((void *)0))) {
    {
#line 729
    __assert_fail("param.memuse_name != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  729U, "read_configuration");
    }
  }
#line 730
  if (! ((unsigned long )param.logfile_name != (unsigned long )((void *)0))) {
    {
#line 730
    __assert_fail("param.logfile_name != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  730U, "read_configuration");
    }
  }
#line 731
  if (! ((unsigned long )param.connection_status_file != (unsigned long )((void *)0))) {
    {
#line 731
    __assert_fail("param.connection_status_file != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  731U, "read_configuration");
    }
  }
#line 732
  if (! ((unsigned long )param.connection_status_file_tmp != (unsigned long )((void *)0))) {
    {
#line 732
    __assert_fail("param.connection_status_file_tmp != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  732U, "read_configuration");
    }
  }
#line 733
  if (! ((unsigned long )param.aux_def_file != (unsigned long )((void *)0))) {
    {
#line 733
    __assert_fail("param.aux_def_file != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  733U, "read_configuration");
    }
  }
#line 734
  if (! ((unsigned long )param.status_file != (unsigned long )((void *)0))) {
    {
#line 734
    __assert_fail("param.status_file != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  734U, "read_configuration");
    }
  }
#line 735
  if (! ((unsigned long )param.core_dir != (unsigned long )((void *)0))) {
    {
#line 735
    __assert_fail("param.core_dir != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  735U, "read_configuration");
    }
  }
#line 736
  if (! ((unsigned long )param.lyskomd_path != (unsigned long )((void *)0))) {
    {
#line 736
    __assert_fail("param.lyskomd_path != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  736U, "read_configuration");
    }
  }
#line 737
  if (! ((unsigned long )param.savecore_path != (unsigned long )((void *)0))) {
    {
#line 737
    __assert_fail("param.savecore_path != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  737U, "read_configuration");
    }
  }
#line 738
  if (! ((unsigned long )param.sendmail_path != (unsigned long )((void *)0))) {
    {
#line 738
    __assert_fail("param.sendmail_path != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c",
                  738U, "read_configuration");
    }
  }
  {
#line 740
  tmp___22 = strlen((char const   *)param.dbase_dir);
  }
#line 740
  if (tmp___22 > 0UL) {
#line 742
    if ((int )*(param.dbase_dir + 0) != 47) {
      {
#line 744
      kom_log("The \'Prefix\' parameter must be an absolute path.\n");
#line 745
      err = (Bool )1;
      }
    }
    {
#line 748
    add_prefix(& param.datafile_name);
#line 749
    add_prefix(& param.backupfile_name);
#line 750
    add_prefix(& param.backupfile_name_2);
#line 751
    add_prefix(& param.lockfile_name);
#line 752
    add_prefix(& param.textfile_name);
#line 753
    add_prefix(& param.numberfile_name);
#line 754
    add_prefix(& param.numberfile_tmp_name);
#line 755
    add_prefix(& param.textbackupfile_name);
#line 756
    add_prefix(& param.backup_dir);
#line 757
    add_prefix(& param.statistic_name);
#line 758
    add_prefix(& param.pid_name);
#line 759
    add_prefix(& param.memuse_name);
#line 760
    add_prefix(& param.logfile_name);
#line 761
    add_prefix(& param.connection_status_file);
#line 762
    add_prefix(& param.connection_status_file_tmp);
#line 763
    add_prefix(& param.aux_def_file);
#line 764
    add_prefix(& param.status_file);
#line 765
    add_prefix(& param.core_dir);
#line 766
    add_prefix(& param.lyskomd_path);
#line 767
    add_prefix(& param.savecore_path);
#line 768
    tmp = strcmp((char const   *)param.sendmail_path, ":");
    }
#line 768
    if (tmp != 0) {
      {
#line 769
      add_prefix(& param.sendmail_path);
      }
    }
  } else {
    {
#line 773
    tmp___0 = check_abs_path(& param.datafile_name);
#line 773
    err = (Bool )((unsigned int )err | (unsigned int )tmp___0);
#line 774
    tmp___1 = check_abs_path(& param.backupfile_name);
#line 774
    err = (Bool )((unsigned int )err | (unsigned int )tmp___1);
#line 775
    tmp___2 = check_abs_path(& param.backupfile_name_2);
#line 775
    err = (Bool )((unsigned int )err | (unsigned int )tmp___2);
#line 776
    tmp___3 = check_abs_path(& param.lockfile_name);
#line 776
    err = (Bool )((unsigned int )err | (unsigned int )tmp___3);
#line 777
    tmp___4 = check_abs_path(& param.textfile_name);
#line 777
    err = (Bool )((unsigned int )err | (unsigned int )tmp___4);
#line 778
    tmp___5 = check_abs_path(& param.numberfile_name);
#line 778
    err = (Bool )((unsigned int )err | (unsigned int )tmp___5);
#line 779
    tmp___6 = check_abs_path(& param.numberfile_tmp_name);
#line 779
    err = (Bool )((unsigned int )err | (unsigned int )tmp___6);
#line 780
    tmp___7 = check_abs_path(& param.textbackupfile_name);
#line 780
    err = (Bool )((unsigned int )err | (unsigned int )tmp___7);
#line 781
    tmp___8 = check_abs_path(& param.backup_dir);
#line 781
    err = (Bool )((unsigned int )err | (unsigned int )tmp___8);
#line 782
    tmp___9 = check_abs_path(& param.statistic_name);
#line 782
    err = (Bool )((unsigned int )err | (unsigned int )tmp___9);
#line 783
    tmp___10 = check_abs_path(& param.pid_name);
#line 783
    err = (Bool )((unsigned int )err | (unsigned int )tmp___10);
#line 784
    tmp___11 = check_abs_path(& param.memuse_name);
#line 784
    err = (Bool )((unsigned int )err | (unsigned int )tmp___11);
#line 785
    tmp___12 = check_abs_path(& param.logfile_name);
#line 785
    err = (Bool )((unsigned int )err | (unsigned int )tmp___12);
#line 786
    tmp___13 = check_abs_path(& param.connection_status_file);
#line 786
    err = (Bool )((unsigned int )err | (unsigned int )tmp___13);
#line 787
    tmp___14 = check_abs_path(& param.connection_status_file_tmp);
#line 787
    err = (Bool )((unsigned int )err | (unsigned int )tmp___14);
#line 788
    tmp___15 = check_abs_path(& param.aux_def_file);
#line 788
    err = (Bool )((unsigned int )err | (unsigned int )tmp___15);
#line 789
    tmp___16 = check_abs_path(& param.status_file);
#line 789
    err = (Bool )((unsigned int )err | (unsigned int )tmp___16);
#line 790
    tmp___17 = check_abs_path(& param.core_dir);
#line 790
    err = (Bool )((unsigned int )err | (unsigned int )tmp___17);
#line 791
    tmp___18 = check_abs_path(& param.lyskomd_path);
#line 791
    err = (Bool )((unsigned int )err | (unsigned int )tmp___18);
#line 792
    tmp___19 = check_abs_path(& param.savecore_path);
#line 792
    err = (Bool )((unsigned int )err | (unsigned int )tmp___19);
#line 793
    tmp___21 = strcmp((char const   *)param.sendmail_path, ":");
    }
#line 793
    if (tmp___21 != 0) {
      {
#line 794
      tmp___20 = check_abs_path(& param.sendmail_path);
#line 794
      err = (Bool )((unsigned int )err | (unsigned int )tmp___20);
      }
    }
  }
#line 797
  if (param.saved_items_per_call < 1) {
    {
#line 799
    err = (Bool )1;
#line 800
    tmp___23 = param_name((void *)(& param.saved_items_per_call));
#line 800
    kom_log("Parameter \'%s\' must be at least 1.\n", tmp___23);
    }
  }
#line 807
  (param.max_text) ++;
#line 807
  if (param.max_text < 2UL) {
    {
#line 809
    err = (Bool )1;
#line 810
    tmp___24 = param_name((void *)(& param.max_text));
#line 810
    kom_log("Parameter \'%s\' must be at least 1.\n", tmp___24);
    }
  }
#line 813
  (param.max_conf) ++;
#line 813
  if (param.max_conf < 6UL) {
    {
#line 815
    err = (Bool )1;
#line 816
    tmp___25 = param_name((void *)(& param.max_conf));
#line 816
    kom_log("Parameter \'%s\' must be at least 5.\n", tmp___25);
    }
  }
#line 820
  if (param.low_penalty >= param.max_penalty) {
    {
#line 822
    err = (Bool )1;
#line 823
    require_less((void *)(& param.low_penalty), (void *)(& param.max_penalty));
    }
  }
#line 826
  if (param.default_weight < 1U) {
    {
#line 828
    err = (Bool )1;
#line 829
    tmp___26 = param_name((void *)(& param.default_weight));
#line 829
    kom_log("Parameter \'%s\' must be at least 1.\n", tmp___26);
    }
  }
#line 833
  if (param.default_weight > param.max_weight) {
    {
#line 835
    err = (Bool )1;
#line 836
    require_less_eq((void *)(& param.default_weight), (void *)(& param.max_weight));
    }
  }
#line 840
  if (param.default_priority > param.max_priority) {
    {
#line 842
    err = (Bool )1;
#line 843
    require_less_eq((void *)(& param.default_priority), (void *)(& param.max_priority));
    }
  }
#line 847
  if (param.max_priority > 0U) {
    {
#line 849
    err = (Bool )1;
#line 850
    tmp___27 = param_name((void *)(& param.max_priority));
#line 850
    kom_log("Parameter \'%s\' must be at most 0.\n", tmp___27);
    }
  }
#line 855
  if (param.max_weight >= 65536U) {
    {
#line 857
    err = (Bool )1;
#line 858
    tmp___28 = param_name((void *)(& param.max_weight));
#line 858
    kom_log("Parameter \'%s\' must be at most %d.\n", tmp___28, 65536);
    }
  }
#line 863
  if (param.max_penalty >= 32768U) {
    {
#line 865
    err = (Bool )1;
#line 866
    tmp___29 = param_name((void *)(& param.max_weight));
#line 866
    kom_log("Parameter \'%s\' must be at most %d.\n", tmp___29, 32768);
    }
  }
#line 877
  if (err) {
    {
#line 878
    restart_kom("Please fix the above configuration errors.\n");
    }
  }
#line 879
  return;
}
}
#line 881 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
void free_configuration(void) 
{ 
  int i ;

  {
#line 884
  i = 0;
  {
#line 886
  while (1) {
    while_continue: /* CIL Label */ ;
#line 886
    if (! ((unsigned long )parameters[i].name != (unsigned long )((void *)0))) {
#line 886
      goto while_break;
    }
#line 888
    if ((unsigned long )parameters[i].freer != (unsigned long )((void *)0)) {
      {
#line 890
      (*(parameters[i].freer))(& parameters[i]);
      }
    }
#line 892
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 894
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 51 "./../include/server/smalloc.h"
void *tmp_alloc(unsigned long size ) ;
#line 58
void free_tmp(void) ;
#line 64
void free_all_tmp(void) ;
#line 72
void dump_smalloc_counts(FILE *stat_file ) ;
#line 124 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int no_of_allocated_blocks___0  =    0;
#line 232 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
void *smalloc(size_t size ) 
{ 
  union overhead *p ;
  void *tmp ;

  {
  {
#line 237
  tmp = malloc(size + (2UL * sizeof(union overhead ) + 2UL));
#line 237
  p = (union overhead *)tmp;
  }
#line 239
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 240
    restart_kom("Can\'t allocate %lu bytes.\n", size);
    }
  }
#line 242
  no_of_allocated_blocks___0 ++;
#line 245
  p->val = 318658208U;
#line 246
  p ++;
#line 247
  p->val = (unsigned int )size;
#line 248
  p ++;
#line 249
  *((unsigned char *)p + size) = (unsigned char)137;
#line 250
  *((unsigned char *)p + (size + 1UL)) = (unsigned char)167;
#line 257
  return ((void *)p);
}
}
#line 271 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
void sfree(void *ptr ) 
{ 
  union overhead *ip ;

  {
#line 278
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 288
    ip = (union overhead *)ptr;
#line 289
    ip -= 2;
    {
#line 292
    if (ip->val == 318658208U) {
#line 292
      goto case_318658208;
    }
#line 302
    if (ip->val == 3392441955U) {
#line 302
      goto case_3392441955;
    }
#line 305
    goto switch_default;
    case_318658208: /* CIL Label */ 
#line 293
    if ((int )*((unsigned char *)(ip + 2) + (ip + 1)->val) != 137) {
      {
#line 295
      restart_kom("SFREE: Buffer overflow, bsize = %ul\n", (ip + 1)->val);
      }
    } else
#line 293
    if ((int )*((unsigned char *)(ip + 2) + ((ip + 1)->val + 1U)) != 167) {
      {
#line 295
      restart_kom("SFREE: Buffer overflow, bsize = %ul\n", (ip + 1)->val);
      }
    }
    {
#line 297
    no_of_allocated_blocks___0 --;
#line 298
    ip->val = 3392441955U;
#line 299
    free((void *)ip);
    }
#line 300
    goto switch_break;
    case_3392441955: /* CIL Label */ 
    {
#line 303
    restart_kom("SFREE: Trying to free already freed block\n");
    }
    switch_default: /* CIL Label */ 
    {
#line 306
    restart_kom("SFREE: Illegal magic number\n");
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 310
  return;
}
}
#line 325 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
void *srealloc(void *ptr , size_t size ) 
{ 
  union overhead *ip ;
  union overhead *new_ptr ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 331
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 332
    tmp = smalloc(size);
    }
#line 332
    return (tmp);
  }
#line 334
  ip = (union overhead *)ptr;
#line 336
  ip -= 2;
  {
#line 339
  if (ip->val == 318658208U) {
#line 339
    goto case_318658208;
  }
#line 342
  if (ip->val == 3392441955U) {
#line 342
    goto case_3392441955;
  }
#line 345
  goto switch_default;
  case_318658208: /* CIL Label */ 
#line 340
  goto switch_break;
  case_3392441955: /* CIL Label */ 
  {
#line 343
  restart_kom("SREALLOC: Trying to realloc freed block\n");
  }
  switch_default: /* CIL Label */ 
  {
#line 346
  restart_kom("SREALLOC: Illegal magic number\n");
  }
  switch_break: /* CIL Label */ ;
  }
#line 349
  if ((int )*((unsigned char *)(ip + 2) + (ip + 1)->val) != 137) {
    {
#line 351
    restart_kom("SREALLOC: Buffer overflow, osize = %ul, nsize = %lu.\n", (ip + 1)->val,
                size);
    }
  } else
#line 349
  if ((int )*((unsigned char *)(ip + 2) + ((ip + 1)->val + 1U)) != 167) {
    {
#line 351
    restart_kom("SREALLOC: Buffer overflow, osize = %ul, nsize = %lu.\n", (ip + 1)->val,
                size);
    }
  }
  {
#line 354
  ip->val = 3392441955U;
#line 356
  tmp___0 = realloc((void *)ip, size + (2UL * sizeof(union overhead ) + 2UL));
#line 356
  new_ptr = (union overhead *)tmp___0;
  }
#line 356
  if ((unsigned long )new_ptr == (unsigned long )((void *)0)) {
    {
#line 358
    restart_kom("Out of memory - can\'t realloc. ptr = %lu size = %lu.\n", (unsigned long )ptr,
                size);
    }
  }
#line 362
  new_ptr->val = 318658208U;
#line 363
  new_ptr ++;
#line 364
  new_ptr->val = (unsigned int )size;
#line 365
  new_ptr ++;
#line 367
  *((unsigned char *)new_ptr + size) = (unsigned char)137;
#line 368
  *((unsigned char *)new_ptr + (size + 1UL)) = (unsigned char)167;
#line 375
  return ((void *)new_ptr);
}
}
#line 384 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static void **tmp_alloc_table  =    (void **)((void *)0);
#line 385 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int tmp_alloc_table_size  =    0;
#line 386 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int tmp_alloc_table_use  =    0;
#line 388 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
void *tmp_alloc(unsigned long size ) 
{ 
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 391
  if (tmp_alloc_table_size <= tmp_alloc_table_use) {
    {
#line 394
    tmp_alloc_table_size ++;
#line 394
    tmp = srealloc((void *)tmp_alloc_table, (unsigned long )tmp_alloc_table_size * sizeof(void *));
#line 394
    tmp_alloc_table = (void **)tmp;
    }
  }
  {
#line 399
  tmp___0 = tmp_alloc_table_use;
#line 399
  tmp_alloc_table_use ++;
#line 399
  tmp___1 = smalloc(size);
#line 399
  *(tmp_alloc_table + tmp___0) = tmp___1;
  }
#line 399
  return (tmp___1);
}
}
#line 408 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
void free_tmp(void) 
{ 
  int i ;

  {
#line 413
  i = 0;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! (i < tmp_alloc_table_use)) {
#line 413
      goto while_break;
    }
    {
#line 415
    sfree(*(tmp_alloc_table + i));
#line 416
    *(tmp_alloc_table + i) = (void *)0;
#line 413
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  tmp_alloc_table_use = 0;
#line 420
  return;
}
}
#line 422 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
void free_all_tmp(void) 
{ 


  {
  {
#line 425
  free_tmp();
#line 426
  sfree((void *)tmp_alloc_table);
#line 427
  tmp_alloc_table = (void **)((void *)0);
#line 428
  tmp_alloc_table_size = 0;
  }
#line 429
  return;
}
}
#line 431 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
void dump_smalloc_counts(FILE *stat_file ) 
{ 


  {
  {
#line 434
  fprintf((FILE */* __restrict  */)stat_file, (char const   */* __restrict  */)"---ram-smalloc.c:\n%s%d\n",
          "\tAllocated blocks (grand total): ", no_of_allocated_blocks___0);
  }
#line 437
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.h"
struct cache_node  const  EMPTY_CACHE_NODE ;
#line 63
struct cache_node_block  const  EMPTY_CACHE_NODE_BLOCK ;
#line 79
struct cache_node_mcb  const  EMPTY_CACHE_NODE_MCB ;
#line 81
void unlink_lru(Cache_node *node , Cache_node **lru , Cache_node **mru ) ;
#line 87
Cache_node_mcb *create_cache_node_mcb(int mcb_size , int table_size ) ;
#line 92
void destruct_cache_node(Cache_node_mcb *control , unsigned long key ) ;
#line 96
Cache_node *get_cache_node(Cache_node_mcb *control , unsigned long key ) ;
#line 101
void create_cache_node(Cache_node_mcb *control , unsigned long key ) ;
#line 106
void zero_init_cache_node(Cache_node_mcb *control , unsigned long key ) ;
#line 110
void set_mru(Cache_node_mcb *mcb , unsigned long key ) ;
#line 115
extern void free_cache_node_mcb(Cache_node_mcb *control ) ;
#line 47 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
struct cache_node  const  EMPTY_CACHE_NODE  = 
#line 47 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
     {{0U, 0U}, (void *)0, (void *)0, 0L, 0L, 0L, 0L, (struct cache_node *)((void *)0),
    (struct cache_node *)((void *)0), 0};
#line 50 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
struct cache_node_block  const  EMPTY_CACHE_NODE_BLOCK  =    {0, (Cache_node *)((void *)0), (struct cache_node_block *)((void *)0)};
#line 53 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
struct cache_node_mcb  const  EMPTY_CACHE_NODE_MCB  = 
#line 53
     {0, (Cache_node_block *)((void *)0), 0UL, 0UL, (Cache_node *)((void *)0), (Cache_node *)((void *)0),
    0UL, (Cache_node **)((void *)0)};
#line 57 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
void unlink_lru(Cache_node *node , Cache_node **lru , Cache_node **mru ) 
{ 
  Cache_node *link ;

  {
#line 64
  link = node->next;
#line 66
  if ((unsigned long )node->next != (unsigned long )((void *)0)) {
#line 67
    (node->next)->prev = node->prev;
  } else
#line 68
  if ((unsigned long )*lru == (unsigned long )node) {
#line 69
    *lru = node->prev;
  }
#line 71
  if ((unsigned long )node->prev != (unsigned long )((void *)0)) {
#line 72
    (node->prev)->next = link;
  } else
#line 73
  if ((unsigned long )*mru == (unsigned long )node) {
#line 74
    *mru = link;
  }
#line 76
  node->next = (struct cache_node *)((void *)0);
#line 77
  node->prev = (struct cache_node *)((void *)0);
#line 78
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
static void insert_mru(Cache_node *node , Cache_node **lru , Cache_node **mru ) 
{ 


  {
#line 85
  node->prev = (struct cache_node *)((void *)0);
#line 86
  node->next = *mru;
#line 87
  *mru = node;
#line 88
  if ((unsigned long )*lru == (unsigned long )((void *)0)) {
#line 89
    *lru = node;
  }
#line 91
  if ((unsigned long )node->next != (unsigned long )((void *)0)) {
#line 92
    (node->next)->prev = node;
  }
#line 93
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
static Cache_node_mcb *alloc_cache_node_mcb(void) 
{ 
  Cache_node_mcb *t ;
  void *tmp ;

  {
  {
#line 100
  tmp = smalloc(sizeof(Cache_node_mcb ));
#line 100
  t = (Cache_node_mcb *)tmp;
#line 101
  *t = (Cache_node_mcb )EMPTY_CACHE_NODE_MCB;
  }
#line 102
  return (t);
}
}
#line 105 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
static Cache_node_block *alloc_cache_node_block(int table_size ) 
{ 
  Cache_node_block *t ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 110
  tmp = smalloc(sizeof(Cache_node_block ));
#line 110
  t = (Cache_node_block *)tmp;
#line 111
  *t = (Cache_node_block )EMPTY_CACHE_NODE_BLOCK;
#line 112
  tmp___0 = smalloc((unsigned long )table_size * sizeof(Cache_node ));
#line 112
  t->nodes = (Cache_node *)tmp___0;
#line 113
  t->next_free = 0;
#line 114
  t->link = (struct cache_node_block *)((void *)0);
  }
#line 116
  return (t);
}
}
#line 120 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
Cache_node_mcb *create_cache_node_mcb(int mcb_size , int table_size ) 
{ 
  Cache_node_mcb *tmp ;
  void *tmp___0 ;

  {
  {
#line 126
  tmp = alloc_cache_node_mcb();
#line 127
  *tmp = (Cache_node_mcb )EMPTY_CACHE_NODE_MCB;
#line 128
  tmp___0 = smalloc(sizeof(Cache_node *) * (unsigned long )table_size);
#line 128
  tmp->lookup_table = (Cache_node **)tmp___0;
#line 129
  tmp->lookup_table_size = (unsigned long )table_size;
#line 130
  tmp->mcb_size = mcb_size;
#line 131
  tmp->last_block = (Cache_node_block *)((void *)0);
  }
#line 133
  return (tmp);
}
}
#line 137 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
Cache_node *get_cache_node(Cache_node_mcb *control , unsigned long key ) 
{ 


  {
#line 141
  if (key >= control->lookup_table_size) {
#line 142
    return ((Cache_node *)((void *)0));
  }
#line 144
  return (*(control->lookup_table + key));
}
}
#line 147 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
static Cache_node *alloc_cache_node(Cache_node_mcb *control ) 
{ 
  Cache_node *c ;
  Cache_node_block *new_block ;
  int tmp ;

  {
#line 153
  if ((unsigned long )control->last_block == (unsigned long )((void *)0)) {
    {
#line 156
    new_block = alloc_cache_node_block(control->mcb_size);
#line 157
    new_block->link = control->last_block;
#line 158
    control->last_block = new_block;
    }
  } else
#line 153
  if ((control->last_block)->next_free >= control->mcb_size) {
    {
#line 156
    new_block = alloc_cache_node_block(control->mcb_size);
#line 157
    new_block->link = control->last_block;
#line 158
    control->last_block = new_block;
    }
  }
#line 161
  tmp = (control->last_block)->next_free;
#line 161
  ((control->last_block)->next_free) ++;
#line 161
  c = (control->last_block)->nodes + tmp;
#line 163
  *c = (Cache_node )EMPTY_CACHE_NODE;
#line 164
  return (c);
}
}
#line 167 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
void destruct_cache_node(Cache_node_mcb *control , unsigned long key ) 
{ 


  {
#line 171
  if (key >= control->lookup_table_size) {
#line 172
    return;
  }
#line 174
  *(control->lookup_table + key) = (Cache_node *)((void *)0);
#line 175
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
void create_cache_node(Cache_node_mcb *control , unsigned long key ) 
{ 


  {
#line 181
  if (key >= control->lookup_table_size) {
    {
#line 182
    restart_kom("%s(%lu, %lu): lookup_table_size = %lu\n", "ERROR: create_cache_node",
                (unsigned long )control, key, control->lookup_table_size);
    }
  }
  {
#line 187
  *(control->lookup_table + key) = alloc_cache_node(control);
  }
#line 188
  return;
}
}
#line 190 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
void zero_init_cache_node(Cache_node_mcb *control , unsigned long key ) 
{ 


  {
#line 194
  if (key >= control->lookup_table_size) {
    {
#line 195
    restart_kom("%s(%lu, %lu): lookup_table_size = %lu\n", "ERROR: zero_init_cache_node",
                (unsigned long )control, key, control->lookup_table_size);
    }
  }
#line 200
  *(control->lookup_table + key) = (Cache_node *)((void *)0);
#line 201
  return;
}
}
#line 205 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
void set_mru(Cache_node_mcb *mcb , unsigned long key ) 
{ 
  Cache_node *node ;

  {
  {
#line 211
  node = get_cache_node(mcb, key);
  }
#line 213
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 214
    restart_kom("set_mru(%lu): nonexistent.\n", key);
    }
  }
  {
#line 216
  unlink_lru(node, & mcb->lru, & mcb->mru);
#line 217
  insert_mru(node, & mcb->lru, & mcb->mru);
  }
#line 218
  return;
}
}
#line 220 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
static void free_cache_node_block(Cache_node_block *block ) 
{ 


  {
  {
#line 223
  sfree((void *)block->nodes);
#line 224
  sfree((void *)block);
  }
#line 225
  return;
}
}
#line 227 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache-node.c"
extern void free_cache_node_mcb(Cache_node_mcb *control ) 
{ 
  Cache_node_block *block ;

  {
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! ((unsigned long )control->last_block != (unsigned long )((void *)0))) {
#line 232
      goto while_break;
    }
    {
#line 234
    block = control->last_block;
#line 235
    control->last_block = block->link;
#line 236
    free_cache_node_block(block);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  sfree((void *)control->lookup_table);
#line 240
  sfree((void *)control);
  }
#line 241
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success log_param___0(char const   *val , struct parameter  const  *qazwsxedcpar  __attribute__((__unused__)) ) ;
#line 74
static Success jubel___0(char const   *val , struct parameter  const  *par ) ;
#line 75
static Success ident_param___0(char const   *val , struct parameter  const  *par ) ;
#line 85 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static struct parameter  const  parameters___0[106]  = 
#line 85
  {      {"Locale", & assign_string, & unassign_string, 0, 1, (char const   *)((void *)0),
      (void *)(& param.use_locale), (char const   *)((void *)0)}, 
        {"Force ISO 8859-1", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "no", (void *)(& param.force_iso_8859_1), (char const   *)((void *)0)}, 
        {"Prefix",
      & assign_string, & unassign_string, 0, 1, "/usr/lyskom", (void *)(& param.dbase_dir),
      (char const   *)((void *)0)}, 
        {"Send async", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.send_async_messages), (char const   *)((void *)0)}, 
        {"Client host",
      & assign_string, & unassign_string, 0, 1, (char const   *)((void *)0), (void *)(& param.ip_client_host),
      (char const   *)((void *)0)}, 
        {"Client port", & assign_string, & unassign_string, 1, 1, (char const   *)((void *)0),
      (void *)(& param.ip_client_port), (char const   *)((void *)0)}, 
        {"Presentation of conferences", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& kom_info.conf_pres_conf), (char const   *)((void *)0)}, 
        {"Presentation of persons",
      & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "2", (void *)(& kom_info.pers_pres_conf), (char const   *)((void *)0)}, 
        {"Motd-conference", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "3", (void *)(& kom_info.motd_conf), (char const   *)((void *)0)}, 
        {"News-conference", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "4", (void *)(& kom_info.kom_news_conf), (char const   *)((void *)0)}, 
        {"Message of the day",
      & assign_text_no, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "0", (void *)(& kom_info.motd_of_lyskom), (char const   *)((void *)0)}, 
        {"Garb", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "on", (void *)(& param.garb_enable), (char const   *)((void *)0)}, 
        {"Never save", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "no", (void *)(& param.never_save), (char const   *)((void *)0)}, 
        {"Data file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-data",
      (void *)(& param.datafile_name), (char const   *)((void *)0)}, 
        {"Backup file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-backup",
      (void *)(& param.backupfile_name), (char const   *)((void *)0)}, 
        {"Backup file 2", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-backup-prev",
      (void *)(& param.backupfile_name_2), (char const   *)((void *)0)}, 
        {"Lock file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-lock",
      (void *)(& param.lockfile_name), (char const   *)((void *)0)}, 
        {"Text file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-texts",
      (void *)(& param.textfile_name), (char const   *)((void *)0)}, 
        {"Number file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/number.txt",
      (void *)(& param.numberfile_name), (char const   *)((void *)0)}, 
        {"Number temp file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/number.tmp",
      (void *)(& param.numberfile_tmp_name), (char const   *)((void *)0)}, 
        {"Text backup file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-texts-backup",
      (void *)(& param.textbackupfile_name), (char const   *)((void *)0)}, 
        {"Backup export directory", & assign_string, & unassign_string, 0, 1, "var/lyskomd/exportdb",
      (void *)(& param.backup_dir), (char const   *)((void *)0)}, 
        {"Log file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.log", (void *)(& param.logfile_name),
      (char const   *)((void *)0)}, 
        {"Log statistics", & assign_string, & unassign_string, 0, 1, "var/lyskomd.stats",
      (void *)(& param.statistic_name), (char const   *)((void *)0)}, 
        {"Pid file", & assign_string, & unassign_string, 0, 1, "var/run/lyskomd.pid",
      (void *)(& param.pid_name), (char const   *)((void *)0)}, 
        {"Memory usage file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.memory",
      (void *)(& param.memuse_name), (char const   *)((void *)0)}, 
        {"Aux-item definition file", & assign_string, & unassign_string, 0, 1, "etc/aux-items.conf",
      (void *)(& param.aux_def_file), (char const   *)((void *)0)}, 
        {"Status file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/status",
      (void *)(& param.status_file), (char const   *)((void *)0)}, 
        {"Connection status file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.clients",
      (void *)(& param.connection_status_file), (char const   *)((void *)0)}, 
        {"Connection status temp file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.clnt.tmp",
      (void *)(& param.connection_status_file_tmp), (char const   *)((void *)0)}, 
        {"Core directory", & assign_string, & unassign_string, 0, 1, "var/lyskomd.cores",
      (void *)(& param.core_dir), (char const   *)((void *)0)}, 
        {"Nologin file", & assign_string, & unassign_string, 0, 1, "/etc/nologin", (void *)(& param.nologin_file),
      (char const   *)((void *)0)}, 
        {"Garb busy postponement", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "50", (void *)(& param.garb_busy_postponement), "milliseconds"}, 
        {"Garb timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.garbtimeout), "milliseconds"}, 
        {"Sync timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.synctimeout), "milliseconds"}, 
        {"Garb interval", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1440", (void *)(& param.garb_interval), "minutes"}, 
        {"Permissive sync", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "off", (void *)(& param.permissive_sync), (char const   *)((void *)0)}, 
        {"Sync interval",
      & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "5", (void *)(& param.sync_interval), "minutes"}, 
        {"Sync retry interval", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.sync_retry_interval), "minutes"}, 
        {"Saved items per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "5", (void *)(& param.saved_items_per_call), (char const   *)((void *)0)}, 
        {"Penalty per call",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "10", (void *)(& param.penalty_per_call), (char const   *)((void *)0)}, 
        {"Penalty per read", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.penalty_per_read), (char const   *)((void *)0)}, 
        {"Max penalty",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "100", (void *)(& param.max_penalty), (char const   *)((void *)0)}, 
        {"Low penalty", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.low_penalty), (char const   *)((void *)0)}, 
        {"Default priority", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.default_priority), (char const   *)((void *)0)}, 
        {"Max priority",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "0", (void *)(& param.max_priority), (char const   *)((void *)0)}, 
        {"Default weight", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.default_weight), (char const   *)((void *)0)}, 
        {"Max weight", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "100", (void *)(& param.max_weight), (char const   *)((void *)0)}, 
        {"Connect timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "30", (void *)(& param.connect_timeout), "seconds"}, 
        {"Login timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "30", (void *)(& param.login_timeout), "minutes"}, 
        {"Active timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "11.5", (void *)(& param.active_timeout), "days"}, 
        {"Max client message size", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "8176", (void *)(& param.maxmsgsize), (char const   *)((void *)0)}, 
        {"Max client transmit queue messages", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "50", (void *)(& param.maxqueuedsize), (char const   *)((void *)0)}, 
        {"Max client transmit queue bytes", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "100000", (void *)(& param.maxqueuedsize_bytes), (char const   *)((void *)0)}, 
        {"Stale timeout",
      & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "60", (void *)(& param.stale_timeout), "minutes"}, 
        {"Max simultaneous client replies", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "10", (void *)(& param.maxdequeuelen), (char const   *)((void *)0)}, 
        {"Open files", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "-1", (void *)(& param.no_files), (char const   *)((void *)0)}, 
        {"Use DNS", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "yes", (void *)(& param.use_dns), (char const   *)((void *)0)}, 
        {"DNS log threshold", & assign_double, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1.5", (void *)(& param.dns_log_threshold), (char const   *)((void *)0)}, 
        {"Max conference name length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "60",
      (void *)(& param.conf_name_len), (char const   *)((void *)0)}, 
        {"Max client data length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "60", (void *)(& param.client_data_len), (char const   *)((void *)0)}, 
        {"Max password length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.pwd_len), (char const   *)((void *)0)}, 
        {"Max what am I doing length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "60", (void *)(& param.what_do_len), (char const   *)((void *)0)}, 
        {"Max username length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.username_len), (char const   *)((void *)0)}, 
        {"Max text length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "131072", (void *)(& param.text_len), (char const   *)((void *)0)}, 
        {"Max aux_item length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "16384", (void *)(& param.aux_len), (char const   *)((void *)0)}, 
        {"Max broadcast length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1024", (void *)(& param.broadcast_len), (char const   *)((void *)0)}, 
        {"Max regexp length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "1024",
      (void *)(& param.regexp_len), (char const   *)((void *)0)}, 
        {"Statistic name length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "64", (void *)(& param.stat_name_len), (char const   *)((void *)0)}, 
        {"Max marks per person", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "2048", (void *)(& param.max_marks_person), (char const   *)((void *)0)}, 
        {"Max marks per text",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "1024",
      (void *)(& param.max_marks_text), (char const   *)((void *)0)}, 
        {"Max recipients per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "512", (void *)(& param.max_recipients), (char const   *)((void *)0)}, 
        {"Max comments per text",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.max_comm), (char const   *)((void *)0)}, 
        {"Max footnotes per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "32", (void *)(& param.max_foot), (char const   *)((void *)0)}, 
        {"Max links per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "512", (void *)(& param.max_crea_misc), (char const   *)((void *)0)}, 
        {"Max mark_as_read chunks", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.mark_as_read_chunk), (char const   *)((void *)0)}, 
        {"Max accept_async len",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.accept_async_len), (char const   *)((void *)0)}, 
        {"Max aux_items added per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.max_add_aux), (char const   *)((void *)0)}, 
        {"Max aux_items deleted per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.max_delete_aux), (char const   *)((void *)0)}, 
        {"Max read_ranges per call",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "512",
      (void *)(& param.max_read_ranges), (char const   *)((void *)0)}, 
        {"Max super_conf loop", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "17", (void *)(& param.max_super_conf_loop), (char const   *)((void *)0)}, 
        {"Default garb nice",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "77",
      (void *)(& param.default_nice), (char const   *)((void *)0)}, 
        {"Default keep commented nice", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "77", (void *)(& param.default_keep_commented), (char const   *)((void *)0)}, 
        {"Anyone can create new persons",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.anyone_can_create_new_persons), (char const   *)((void *)0)}, 
        {"Anyone can create new conferences",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.anyone_can_create_new_confs), (char const   *)((void *)0)}, 
        {"Allow creation of persons before login",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.create_person_before_login), (char const   *)((void *)0)}, 
        {"Default change name capability",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "on", (void *)(& param.default_change_name), (char const   *)((void *)0)}, 
        {"Add members by invitation", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "on", (void *)(& param.invite_by_default), (char const   *)((void *)0)}, 
        {"Allow secret memberships",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "on", (void *)(& param.secret_memberships), (char const   *)((void *)0)}, 
        {"Allow reinvitations", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "off", (void *)(& param.allow_reinvite), (char const   *)((void *)0)}, 
        {"Log login",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "off", (void *)(& param.log_login), (char const   *)((void *)0)}, 
        {"Ident-authentication", & ident_param___0, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "try", (void *)(& param.authentication_level), (char const   *)((void *)0)}, 
        {"Cache conference limit",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "20",
      (void *)(& param.cache_conferences), (char const   *)((void *)0)}, 
        {"Cache person limit", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.cache_persons), (char const   *)((void *)0)}, 
        {"Cache text_stat limit", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.cache_text_stats), (char const   *)((void *)0)}, 
        {"Echo",
      & log_param___0, (void (*)(struct parameter  const  *par ))((void *)0), 0, -1,
      (char const   *)((void *)0), (void *)0, (char const   *)((void *)0)}, 
        {"Jubel", & jubel___0, (void (*)(struct parameter  const  *par ))((void *)0),
      0, -1, (char const   *)((void *)0), (void *)0, (char const   *)((void *)0)}, 
        {"Max conferences",
      & assign_ulong, (void (*)(struct parameter  const  *par ))((void *)0), 1, 1,
      "4765", (void *)(& param.max_conf), (char const   *)((void *)0)}, 
        {"Max texts", & assign_ulong, (void (*)(struct parameter  const  *par ))((void *)0),
      1, 1, "2000000", (void *)(& param.max_text), (char const   *)((void *)0)}, 
        {"Normal shutdown time", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "21", (void *)(& param.normal_shutdown_time), (char const   *)((void *)0)}, 
        {"Mail after downtime",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "60",
      (void *)(& param.downtime_mail_start), (char const   *)((void *)0)}, 
        {"Mail until downtime", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "120", (void *)(& param.downtime_mail_end), (char const   *)((void *)0)}, 
        {"sendmail path",
      & assign_string, & unassign_string, 0, 1, ":", (void *)(& param.sendmail_path),
      (char const   *)((void *)0)}, 
        {"lyskomd path", & assign_string, & unassign_string, 0, 1, "sbin/lyskomd", (void *)(& param.lyskomd_path),
      (char const   *)((void *)0)}, 
        {"savecore path", & assign_string, & unassign_string, 0, 1, "sbin/savecore-lyskom",
      (void *)(& param.savecore_path), (char const   *)((void *)0)}, 
        {(char const   *)((void *)0), (Success (*)(char const   *val , struct parameter  const  *par ))((void *)0),
      (void (*)(struct parameter  const  *par ))((void *)0), 0, 0, (char const   *)((void *)0),
      (void *)0, (char const   *)((void *)0)}};
#line 542 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   compiled_config_file___0[17]  = 
#line 542
  {      (char const   )'e',      (char const   )'t',      (char const   )'c',      (char const   )'/', 
        (char const   )'l',      (char const   )'y',      (char const   )'s',      (char const   )'k', 
        (char const   )'o',      (char const   )'m',      (char const   )'d',      (char const   )'.', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'f', 
        (char const   )'\000'};
#line 543 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   *default_config___0  =    (char const   *)((void *)0);
#line 584 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success log_param___0(char const   *val , struct parameter  const  *qazwsxedcpar  __attribute__((__unused__)) ) 
{ 


  {
#line 587
  if ((unsigned long )val != (unsigned long )((void *)0)) {
    {
#line 588
    kom_log("config: %s\n", val);
    }
  }
#line 589
  return ((Success )OK);
}
}
#line 592 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success jubel___0(char const   *val , struct parameter  const  *par ) 
{ 
  long a ;
  long b ;
  long c ;
  int res ;
  Bool public ;
  int tmp ;

  {
#line 597
  public = (Bool )0;
#line 599
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 600
    return ((Success )OK);
  }
  {
#line 602
  tmp = strncmp(val, "public ", (size_t )7);
  }
#line 602
  if (! tmp) {
#line 604
    public = (Bool )1;
#line 605
    val += 7;
  }
  {
#line 608
  res = sscanf((char const   */* __restrict  */)val, (char const   */* __restrict  */)"%ld %ld %ld",
               & a, & b, & c);
  }
  {
#line 611
  if (res == 3) {
#line 611
    goto case_3;
  }
#line 614
  if (res == 2) {
#line 614
    goto case_2;
  }
#line 617
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 612
  register_jubel((Pers_no )a, (Text_no )b, (Text_no )c, public);
  }
#line 613
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 615
  register_jubel((Pers_no )a, (Text_no )0, (Text_no )b, public);
  }
#line 616
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 618
  kom_log("%s expecting [public ] x y [z]\n", par->name);
  }
#line 619
  return ((Success )FAILURE);
  switch_break: /* CIL Label */ ;
  }
#line 621
  return ((Success )OK);
}
}
#line 624 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success ident_param___0(char const   *val , struct parameter  const  *par ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 627
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    {
#line 628
    restart_kom("ident_param(): val == NULL\n");
    }
  }
  {
#line 629
  tmp___3 = strcmp(val, "off");
  }
#line 629
  if (tmp___3) {
    {
#line 629
    tmp___4 = strcmp(val, "never");
    }
#line 629
    if (tmp___4) {
      {
#line 634
      tmp___1 = strcmp(val, "on");
      }
#line 634
      if (tmp___1) {
        {
#line 634
        tmp___2 = strcmp(val, "try");
        }
#line 634
        if (tmp___2) {
          {
#line 639
          tmp = strcmp(val, "require");
          }
#line 639
          if (tmp) {
            {
#line 639
            tmp___0 = strcmp(val, "required");
            }
#line 639
            if (tmp___0) {
              {
#line 646
              kom_log("%s expects \"never\", \"try\" or \"required\" as argument\n",
                      par->name);
              }
#line 648
              return ((Success )FAILURE);
            } else {
#line 642
              *((int *)par->value) = 2;
            }
          } else {
#line 642
            *((int *)par->value) = 2;
          }
        } else {
#line 637
          *((int *)par->value) = 1;
        }
      } else {
#line 637
        *((int *)par->value) = 1;
      }
    } else {
#line 632
      *((int *)par->value) = 0;
    }
  } else {
#line 632
    *((int *)par->value) = 0;
  }
#line 650
  return ((Success )OK);
}
}
#line 653 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void add_prefix___0(char **name___0 ) 
{ 
  char *s ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 658
  if ((int )*(*name___0) == 47) {
#line 659
    return;
  }
  {
#line 661
  tmp = strlen((char const   *)param.dbase_dir);
#line 661
  tmp___0 = strlen((char const   *)*name___0);
#line 661
  tmp___1 = smalloc((2UL + tmp) + tmp___0);
#line 661
  s = (char *)tmp___1;
#line 662
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%s/%s", param.dbase_dir,
          *name___0);
#line 663
  sfree((void *)*name___0);
#line 664
  *name___0 = s;
  }
#line 665
  return;
}
}
#line 667 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   *param_name___0(void *value ) 
{ 
  int ix ;

  {
#line 672
  ix = 0;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! ((unsigned long )parameters___0[ix].name != (unsigned long )((void *)0))) {
#line 672
      goto while_break;
    }
#line 673
    if ((unsigned long )parameters___0[ix].value == (unsigned long )value) {
#line 674
      return ((char const   *)parameters___0[ix].name);
    }
#line 672
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  restart_kom("Internal error: non-existing config param in param_name.\n");
  }
#line 678
  return ((char const   *)((void *)0));
}
}
#line 681 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Bool check_abs_path___0(char **path ) 
{ 
  char const   *tmp ;

  {
#line 684
  if ((int )*(*path) == 47) {
#line 685
    return ((Bool )0);
  }
  {
#line 687
  tmp = param_name___0((void *)path);
#line 687
  kom_log("Parameter \'%s\' must be an absolute path when \'Prefix\' is empty.\n",
          tmp);
  }
#line 689
  return ((Bool )1);
}
}
#line 692 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void require_less___0(void *low , void *high ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 696
  tmp = param_name___0(high);
#line 696
  tmp___0 = param_name___0(low);
#line 696
  kom_log("Parameter \'%s\' must be less than parameter \'%s\'.\n", tmp___0, tmp);
  }
#line 699
  return;
}
}
#line 701 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void require_less_eq___0(void *low , void *high ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 705
  tmp = param_name___0(high);
#line 705
  tmp___0 = param_name___0(low);
#line 705
  kom_log("Parameter \'%s\' must be less than or equal to parameter \'%s\'.\n", tmp___0,
          tmp);
  }
#line 708
  return;
}
}
#line 41 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.h"
Connection *get_conn_by_number(Session_no session_no ) ;
#line 45
Session_no traverse_connections(Session_no session_no ) ;
#line 57
Bool handshake_ok(struct connection *cptr , enum ignored_conditions ignored ) ;
#line 29 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.h"
void async_new_text(struct connection *cptr , Text_no text_no , Text_stat *text_s ) ;
#line 34
void async_new_text_old(struct connection *cptr , Text_no text_no , Text_stat *text_s ) ;
#line 39
void async_i_am_on(Who_info info ) ;
#line 42
void async_logout(Pers_no pers_no , Session_no session_no ) ;
#line 46
void async_new_name(Conf_no conf_no , String const   old_name , String const   new_name ) ;
#line 51
void async_sync_db(void) ;
#line 55
extern void async_forced_leave_conf(struct connection *cptr , Conf_no conf_no ) ;
#line 60
void async_login(Pers_no pers_no , int client_no ) ;
#line 64
void async_rejected_connection(void) ;
#line 67
Success async_send_message(Pers_no recipient , Pers_no sender , String message , Bool force_message ) ;
#line 73
Success async_send_group_message(Pers_no recipient , Conf_no group_recipient , Pers_no sender ,
                                 String message , Bool force_message ) ;
#line 80
void async_deleted_text(struct connection *cptr , Text_no text_no , Text_stat *text_s ) ;
#line 85
void async_new_recipient(struct connection *cptr , Text_no text_no , Conf_no conf_no ,
                         enum info_type type ) ;
#line 91
void async_sub_recipient(struct connection *cptr , Text_no text_no , Conf_no conf_no ,
                         enum info_type type ) ;
#line 97
void async_new_membership(struct connection *cptr , Pers_no pers_no , Conf_no conf_no ) ;
#line 102
void async_new_user_area(Pers_no person , Text_no old_user_area , Text_no new_user_area ) ;
#line 107
void async_new_presentation(Connection *cptr , Conf_no conf_no , Text_no old_presentation ,
                            Text_no new_presentation ) ;
#line 113
void async_new_motd(Connection *cptr , Conf_no conf_no , Text_no old_motd , Text_no new_motd ) ;
#line 119
void async_text_aux_changed(Connection *cptr , Text_no text_no , Aux_item_list *aux_list ,
                            unsigned long highest_old_aux ) ;
#line 37 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.h"
void prot_a_async_new_text(Connection *cptr , Text_no text_no , Text_stat *text_s ) ;
#line 42
void prot_a_async_new_text_old(Connection *cptr , Text_no text_no , Text_stat *text_s ) ;
#line 47
void prot_a_async_i_am_on(Connection *cptr , Who_info info ) ;
#line 50
void prot_a_async_logout(Connection *cptr , Pers_no pers_no , Session_no session_no ) ;
#line 55
void prot_a_async_new_name(Connection *cptr , Conf_no conf_no , String old_name ,
                           String new_name ) ;
#line 61
void prot_a_async_sync_db(Connection *cptr ) ;
#line 64
void prot_a_async_forced_leave_conf(Connection *cptr , Conf_no conf_no ) ;
#line 68
void prot_a_async_login(Connection *cptr , Pers_no pers_no , int session_no ) ;
#line 73
void prot_a_async_rejected_connection(Connection *cptr ) ;
#line 76
void prot_a_async_send_message(Connection *cptr , Conf_no recipient , Pers_no sender ,
                               String message ) ;
#line 87
void prot_a_async_deleted_text(Connection *cptr , Text_no text_no , Text_stat *text_s ) ;
#line 92
void prot_a_async_new_recipient(Connection *cptr , Text_no text_no , Conf_no conf_no ,
                                enum info_type type ) ;
#line 98
void prot_a_async_sub_recipient(Connection *cptr , Text_no text_no , Conf_no conf_no ,
                                enum info_type type ) ;
#line 106
void prot_a_async_new_membership(Connection *cptr , Pers_no pers_no , Conf_no conf_no ) ;
#line 111
void prot_a_async_new_user_area(Connection *cptr , Pers_no pers_no , Text_no old_user_area ,
                                Text_no new_user_area ) ;
#line 117
void prot_a_async_new_presentation(Connection *cptr , Conf_no conf_no , Text_no old_presentation ,
                                   Text_no new_presentation ) ;
#line 123
void prot_a_async_new_motd(Connection *cptr , Conf_no conf_no , Text_no old_motd ,
                           Text_no new_motd ) ;
#line 129
void prot_a_async_text_aux_changed(Connection *cptr , Text_no text_no , Aux_item_list *aux_list ,
                                   unsigned long highest_old_aux ) ;
#line 106 "./../include/kom-errno.h"
extern enum kom_err kom_errno ;
#line 109
extern unsigned long err_stat ;
#line 229 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/manipulate.h"
Bool has_access(Conf_no victim , Connection const   *viewer_conn , enum access wanted_access ) ;
#line 238
Conf_no filter_conf_no(Conf_no victim , Connection const   *viewer_conn ) ;
#line 26 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-time.h"
struct timeval current_time ;
#line 25 "./../libraries/libmisc/timeval-util.h"
extern Bool timeval_nonzero(struct timeval t ) ;
#line 43
extern long timeval_diff_sec(struct timeval a , struct timeval b ) ;
#line 60 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_new_text_old(struct connection *cptr , Text_no text_no , Text_stat *text_s ) 
{ 
  Bool tmp ;

  {
#line 65
  if (! param.send_async_messages) {
#line 66
    return;
  }
  {
#line 70
  if ((int )cptr->protocol == 0) {
#line 70
    goto case_0;
  }
#line 72
  if ((int )cptr->protocol == 65) {
#line 72
    goto case_65;
  }
#line 76
  goto switch_default;
  case_0: /* CIL Label */ 
#line 71
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 73
  tmp = handshake_ok(cptr, (enum ignored_conditions )0);
  }
#line 73
  if (tmp) {
    {
#line 74
    prot_a_async_new_text_old(cptr, text_no, text_s);
    }
  }
#line 75
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 77
  restart_kom("async_new_text(): bad protocol.\n");
  }
#line 78
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 83 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_new_text(struct connection *cptr , Text_no text_no , Text_stat *text_s ) 
{ 
  Bool tmp ;

  {
#line 88
  if (! param.send_async_messages) {
#line 89
    return;
  }
  {
#line 93
  if ((int )cptr->protocol == 0) {
#line 93
    goto case_0;
  }
#line 95
  if ((int )cptr->protocol == 65) {
#line 95
    goto case_65;
  }
#line 99
  goto switch_default;
  case_0: /* CIL Label */ 
#line 94
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 96
  tmp = handshake_ok(cptr, (enum ignored_conditions )0);
  }
#line 96
  if (tmp) {
    {
#line 97
    prot_a_async_new_text(cptr, text_no, text_s);
    }
  }
#line 98
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 100
  restart_kom("async_new_text(): bad protocol.\n");
  }
#line 101
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 108 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_i_am_on(Who_info info ) 
{ 
  Connection *cptr ;
  Session_no i ;
  Who_info filtered ;
  Bool tmp ;

  {
#line 112
  i = (Session_no )0;
#line 115
  if (! param.send_async_messages) {
#line 116
    return;
  }
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 118
    i = traverse_connections(i);
    }
#line 118
    if (! (i != 0UL)) {
#line 118
      goto while_break;
    }
    {
#line 120
    cptr = get_conn_by_number(i);
#line 122
    filtered = info;
#line 123
    filtered.working_conference = filter_conf_no(info.working_conference, (Connection const   *)cptr);
    }
    {
#line 128
    if ((int )cptr->protocol == 0) {
#line 128
      goto case_0;
    }
#line 130
    if ((int )cptr->protocol == 65) {
#line 130
      goto case_65;
    }
#line 134
    goto switch_default;
    case_0: /* CIL Label */ 
#line 129
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 131
    tmp = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 131
    if (tmp) {
      {
#line 132
      prot_a_async_i_am_on(cptr, filtered);
      }
    }
#line 133
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 135
    restart_kom("async_i_am_on(): bad protocol.\n");
    }
#line 136
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 141 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_logout(Pers_no pers_no , Session_no session_no ) 
{ 
  Connection *cptr ;
  Session_no i ;
  Bool tmp ;

  {
#line 146
  i = (Session_no )0;
#line 148
  if (! param.send_async_messages) {
#line 149
    return;
  }
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 151
    i = traverse_connections(i);
    }
#line 151
    if (! (i != 0UL)) {
#line 151
      goto while_break;
    }
    {
#line 153
    cptr = get_conn_by_number(i);
    }
#line 155
    if ((unsigned long )cptr == (unsigned long )((void *)0)) {
      {
#line 157
      kom_log("async_logout(): cptr == NULL\n");
      }
#line 158
      return;
    }
    {
#line 163
    if ((int )cptr->protocol == 0) {
#line 163
      goto case_0;
    }
#line 165
    if ((int )cptr->protocol == 65) {
#line 165
      goto case_65;
    }
#line 169
    goto switch_default;
    case_0: /* CIL Label */ 
#line 164
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 166
    tmp = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 166
    if (tmp) {
      {
#line 167
      prot_a_async_logout(cptr, pers_no, session_no);
      }
    }
#line 168
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 170
    restart_kom("async_logout(): bad protocol.\n");
    }
#line 171
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 178 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_new_name(Conf_no conf_no , String const   old_name , String const   new_name ) 
{ 
  Connection *cptr ;
  Session_no i ;
  Bool tmp ;
  Bool tmp___0 ;

  {
#line 184
  i = (Session_no )0;
#line 186
  if (! param.send_async_messages) {
#line 187
    return;
  }
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 189
    i = traverse_connections(i);
    }
#line 189
    if (! (i != 0UL)) {
#line 189
      goto while_break;
    }
    {
#line 191
    cptr = get_conn_by_number(i);
    }
#line 193
    if ((unsigned long )cptr == (unsigned long )((void *)0)) {
      {
#line 195
      kom_log("async_new_name(): cptr == NULL\n");
      }
#line 196
      return;
    }
    {
#line 201
    if ((int )cptr->protocol == 0) {
#line 201
      goto case_0;
    }
#line 203
    if ((int )cptr->protocol == 65) {
#line 203
      goto case_65;
    }
#line 215
    goto switch_default;
    case_0: /* CIL Label */ 
#line 202
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 206
    tmp = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 206
    if (tmp) {
      {
#line 206
      tmp___0 = has_access(conf_no, (Connection const   *)cptr, (enum access )2);
      }
#line 206
      if (tmp___0) {
        {
#line 211
        prot_a_async_new_name(cptr, conf_no, (String )old_name, (String )new_name);
        }
      } else
#line 206
      if ((int )cptr->ena_level >= 2) {
#line 206
        if (cptr->person) {
#line 206
          if ((cptr->person)->privileges.admin) {
            {
#line 211
            prot_a_async_new_name(cptr, conf_no, (String )old_name, (String )new_name);
            }
          } else {
#line 206
            goto _L___0;
          }
        } else {
#line 206
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 206
      if ((int )cptr->ena_level >= 8) {
#line 206
        if (cptr->person) {
#line 206
          if ((cptr->person)->privileges.wheel) {
            {
#line 211
            prot_a_async_new_name(cptr, conf_no, (String )old_name, (String )new_name);
            }
          }
        }
      }
    }
#line 213
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 216
    restart_kom("async_new_name(): bad protocol.\n");
    }
#line 217
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return;
}
}
#line 230 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_sync_db(void) 
{ 
  Connection *cptr ;
  Session_no i ;
  Bool tmp ;

  {
#line 234
  i = (Session_no )0;
#line 236
  if (! param.send_async_messages) {
#line 237
    return;
  }
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 239
    i = traverse_connections(i);
    }
#line 239
    if (! (i != 0UL)) {
#line 239
      goto while_break;
    }
    {
#line 241
    cptr = get_conn_by_number(i);
    }
#line 243
    if ((unsigned long )cptr == (unsigned long )((void *)0)) {
      {
#line 245
      kom_log("async_sync_db(): cptr == NULL\n");
      }
#line 246
      return;
    }
    {
#line 251
    if ((int )cptr->protocol == 0) {
#line 251
      goto case_0;
    }
#line 253
    if ((int )cptr->protocol == 65) {
#line 253
      goto case_65;
    }
#line 257
    goto switch_default;
    case_0: /* CIL Label */ 
#line 252
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 254
    tmp = handshake_ok(cptr, (enum ignored_conditions )1);
    }
#line 254
    if (tmp) {
      {
#line 255
      prot_a_async_sync_db(cptr);
      }
    }
#line 256
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 258
    restart_kom("async_sync_db(): bad protocol.\n");
    }
#line 259
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return;
}
}
#line 265 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
extern void async_forced_leave_conf(struct connection *cptr , Conf_no conf_no ) 
{ 
  Bool tmp ;

  {
#line 269
  if (! param.send_async_messages) {
#line 270
    return;
  }
  {
#line 274
  if ((int )cptr->protocol == 0) {
#line 274
    goto case_0;
  }
#line 276
  if ((int )cptr->protocol == 65) {
#line 276
    goto case_65;
  }
#line 280
  goto switch_default;
  case_0: /* CIL Label */ 
#line 275
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 277
  tmp = handshake_ok(cptr, (enum ignored_conditions )0);
  }
#line 277
  if (tmp) {
    {
#line 278
    prot_a_async_forced_leave_conf(cptr, conf_no);
    }
  }
#line 279
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 281
  restart_kom("async_forced_leave_conf(): bad protocol.\n");
  }
#line 282
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 284
  return;
}
}
#line 286 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_login(Pers_no pers_no , int client_no ) 
{ 
  Connection *cptr ;
  Session_no i ;
  Bool tmp ;

  {
#line 291
  i = (Session_no )0;
#line 293
  if (! param.send_async_messages) {
#line 294
    return;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 296
    i = traverse_connections(i);
    }
#line 296
    if (! (i != 0UL)) {
#line 296
      goto while_break;
    }
    {
#line 298
    cptr = get_conn_by_number(i);
    }
#line 300
    if ((unsigned long )cptr == (unsigned long )((void *)0)) {
      {
#line 302
      kom_log("async_login(): cptr == NULL\n");
      }
#line 303
      return;
    }
    {
#line 308
    if ((int )cptr->protocol == 0) {
#line 308
      goto case_0;
    }
#line 310
    if ((int )cptr->protocol == 65) {
#line 310
      goto case_65;
    }
#line 315
    goto switch_default;
    case_0: /* CIL Label */ 
#line 309
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 311
    tmp = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 311
    if (tmp) {
      {
#line 312
      prot_a_async_login(cptr, pers_no, client_no);
      }
    }
#line 313
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 316
    restart_kom("async_login(): bad protocol.\n");
    }
#line 317
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  return;
}
}
#line 327 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
static struct timeval last_time  =    {(__time_t )0, (__suseconds_t )0};
#line 322 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_rejected_connection(void) 
{ 
  Connection *cptr ;
  Session_no i ;
  Bool tmp ;
  long tmp___0 ;
  Bool tmp___1 ;

  {
#line 326
  i = (Session_no )0;
#line 329
  if (! param.send_async_messages) {
#line 330
    return;
  }
  {
#line 332
  tmp = timeval_nonzero(last_time);
  }
#line 332
  if (tmp) {
    {
#line 332
    tmp___0 = timeval_diff_sec(current_time, last_time);
    }
#line 332
    if (tmp___0 < 60L) {
#line 335
      return;
    }
  }
#line 338
  last_time = current_time;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 340
    i = traverse_connections(i);
    }
#line 340
    if (! (i != 0UL)) {
#line 340
      goto while_break;
    }
    {
#line 342
    cptr = get_conn_by_number(i);
    }
#line 344
    if ((unsigned long )cptr == (unsigned long )((void *)0)) {
      {
#line 346
      kom_log("async_rejected_connections(): cptr == NULL\n");
      }
#line 347
      return;
    }
    {
#line 352
    if ((int )cptr->protocol == 0) {
#line 352
      goto case_0;
    }
#line 354
    if ((int )cptr->protocol == 65) {
#line 354
      goto case_65;
    }
#line 359
    goto switch_default;
    case_0: /* CIL Label */ 
#line 353
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 355
    tmp___1 = handshake_ok(cptr, (enum ignored_conditions )1);
    }
#line 355
    if (tmp___1) {
      {
#line 356
      prot_a_async_rejected_connection(cptr);
      }
    }
#line 357
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 360
    restart_kom("async_rejected_connection(): bad protocol.\n");
    }
#line 361
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  return;
}
}
#line 370 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
Success async_send_message(Pers_no recipient , Pers_no sender , String message , Bool force_message ) 
{ 
  Success tmp ;

  {
  {
#line 376
  tmp = async_send_group_message(recipient, recipient, sender, message, force_message);
  }
#line 376
  return (tmp);
}
}
#line 383 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
Success async_send_group_message(Pers_no recipient , Conf_no group_recipient , Pers_no sender ,
                                 String message , Bool force_message ) 
{ 
  Connection *cptr ;
  Session_no i ;
  Success retval ;
  Bool tmp ;
  Bool tmp___0 ;

  {
#line 391
  i = (Session_no )0;
#line 392
  retval = (Success )FAILURE;
#line 393
  tmp = (Bool )0;
#line 395
  kom_errno = (enum kom_err )53;
#line 397
  if (! param.send_async_messages) {
#line 399
    err_stat = 0UL;
#line 400
    kom_errno = (enum kom_err )52;
#line 401
    return ((Success )FAILURE);
  }
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 404
    i = traverse_connections(i);
    }
#line 404
    if (! (i != 0UL)) {
#line 404
      goto while_break;
    }
    {
#line 406
    cptr = get_conn_by_number(i);
    }
#line 408
    if ((unsigned long )cptr == (unsigned long )((void *)0)) {
      {
#line 410
      kom_log("async_send_message(): cptr == NULL\n");
#line 411
      err_stat = 0UL;
#line 412
      kom_errno = (enum kom_err )51;
      }
#line 413
      return ((Success )FAILURE);
    }
    {
#line 418
    if ((int )cptr->protocol == 0) {
#line 418
      goto case_0;
    }
#line 420
    if ((int )cptr->protocol == 65) {
#line 420
      goto case_65;
    }
#line 438
    goto switch_default;
    case_0: /* CIL Label */ 
#line 419
    goto switch_break;
    case_65: /* CIL Label */ 
#line 421
    if ((int )recipient == 0) {
#line 421
      goto _L;
    } else
#line 421
    if ((int )recipient == (int )cptr->pers_no) {
#line 421
      if ((int )recipient != 0) {
        _L: /* CIL Label */ 
        {
#line 421
        tmp___0 = handshake_ok(cptr, (enum ignored_conditions )1);
        }
#line 421
        if (tmp___0) {
#line 425
          if (force_message) {
#line 427
            tmp = cptr->want_async[12];
#line 428
            cptr->want_async[12] = (Bool )1;
          }
          {
#line 430
          prot_a_async_send_message(cptr, group_recipient, sender, message);
          }
#line 432
          if (force_message) {
#line 433
            cptr->want_async[12] = tmp;
          }
#line 434
          retval = (Success )OK;
        }
      }
    }
#line 436
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 439
    restart_kom("async_send_message(): bad protocol.\n");
    }
#line 440
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  return (retval);
}
}
#line 448 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_deleted_text(struct connection *cptr , Text_no text_no , Text_stat *text_s ) 
{ 
  Bool tmp ;

  {
#line 453
  if (! param.send_async_messages) {
#line 454
    return;
  }
  {
#line 458
  if ((int )cptr->protocol == 0) {
#line 458
    goto case_0;
  }
#line 460
  if ((int )cptr->protocol == 65) {
#line 460
    goto case_65;
  }
#line 464
  goto switch_default;
  case_0: /* CIL Label */ 
#line 459
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 461
  tmp = handshake_ok(cptr, (enum ignored_conditions )0);
  }
#line 461
  if (tmp) {
    {
#line 462
    prot_a_async_deleted_text(cptr, text_no, text_s);
    }
  }
#line 463
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 465
  restart_kom("async_deleted_text(): bad protocol.\n");
  }
#line 466
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 468
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_new_recipient(struct connection *cptr , Text_no text_no , Conf_no conf_no ,
                         enum info_type type ) 
{ 
  Bool tmp ;

  {
#line 477
  if (! param.send_async_messages) {
#line 478
    return;
  }
  {
#line 482
  if ((int )cptr->protocol == 0) {
#line 482
    goto case_0;
  }
#line 484
  if ((int )cptr->protocol == 65) {
#line 484
    goto case_65;
  }
#line 488
  goto switch_default;
  case_0: /* CIL Label */ 
#line 483
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 485
  tmp = handshake_ok(cptr, (enum ignored_conditions )0);
  }
#line 485
  if (tmp) {
    {
#line 486
    prot_a_async_new_recipient(cptr, text_no, conf_no, type);
    }
  }
#line 487
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 489
  restart_kom("async_new_recipient(): bad protocol.\n");
  }
#line 490
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 492
  return;
}
}
#line 495 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_sub_recipient(struct connection *cptr , Text_no text_no , Conf_no conf_no ,
                         enum info_type type ) 
{ 
  Bool tmp ;

  {
#line 501
  if (! param.send_async_messages) {
#line 502
    return;
  }
  {
#line 506
  if ((int )cptr->protocol == 0) {
#line 506
    goto case_0;
  }
#line 508
  if ((int )cptr->protocol == 65) {
#line 508
    goto case_65;
  }
#line 512
  goto switch_default;
  case_0: /* CIL Label */ 
#line 507
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 509
  tmp = handshake_ok(cptr, (enum ignored_conditions )0);
  }
#line 509
  if (tmp) {
    {
#line 510
    prot_a_async_sub_recipient(cptr, text_no, conf_no, type);
    }
  }
#line 511
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 513
  restart_kom("async_sub_recipient(): bad protocol.\n");
  }
#line 514
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 516
  return;
}
}
#line 519 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_new_membership(struct connection *cptr , Pers_no pers_no , Conf_no conf_no ) 
{ 
  Bool tmp ;

  {
#line 524
  if (! param.send_async_messages) {
#line 525
    return;
  }
  {
#line 529
  if ((int )cptr->protocol == 0) {
#line 529
    goto case_0;
  }
#line 531
  if ((int )cptr->protocol == 65) {
#line 531
    goto case_65;
  }
#line 535
  goto switch_default;
  case_0: /* CIL Label */ 
#line 530
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 532
  tmp = handshake_ok(cptr, (enum ignored_conditions )0);
  }
#line 532
  if (tmp) {
    {
#line 533
    prot_a_async_new_membership(cptr, pers_no, conf_no);
    }
  }
#line 534
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 536
  restart_kom("async_new_membership(): bad protocol.\n");
  }
#line 537
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 539
  return;
}
}
#line 541 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_new_user_area(Pers_no person , Text_no old_user_area , Text_no new_user_area ) 
{ 
  Connection *cptr ;
  Session_no i ;
  Bool tmp ;
  Bool tmp___0 ;

  {
#line 547
  i = (Session_no )0;
#line 549
  if (! param.send_async_messages) {
#line 550
    return;
  }
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 552
    i = traverse_connections(i);
    }
#line 552
    if (! (i != 0UL)) {
#line 552
      goto while_break;
    }
    {
#line 554
    cptr = get_conn_by_number(i);
    }
    {
#line 558
    if ((int )cptr->protocol == 0) {
#line 558
      goto case_0;
    }
#line 561
    if ((int )cptr->protocol == 65) {
#line 561
      goto case_65;
    }
#line 573
    goto switch_default;
    case_0: /* CIL Label */ 
#line 560
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 565
    tmp = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 565
    if (tmp) {
#line 565
      if ((unsigned int )cptr->want_async[19] == 1U) {
        {
#line 565
        tmp___0 = has_access(person, (Connection const   *)cptr, (enum access )5);
        }
#line 565
        if (tmp___0) {
          {
#line 569
          prot_a_async_new_user_area(cptr, person, old_user_area, new_user_area);
          }
        }
      }
    }
#line 572
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 574
    restart_kom("async_new_user_area(): bad protocol.\n");
    }
#line 575
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  return;
}
}
#line 580 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_new_presentation(Connection *cptr , Conf_no conf_no , Text_no old_presentation ,
                            Text_no new_presentation ) 
{ 
  Bool tmp ;

  {
#line 586
  if (! param.send_async_messages) {
#line 587
    return;
  }
  {
#line 591
  if ((int )cptr->protocol == 0) {
#line 591
    goto case_0;
  }
#line 594
  if ((int )cptr->protocol == 65) {
#line 594
    goto case_65;
  }
#line 602
  goto switch_default;
  case_0: /* CIL Label */ 
#line 593
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 595
  tmp = handshake_ok(cptr, (enum ignored_conditions )0);
  }
#line 595
  if (tmp) {
#line 595
    if ((unsigned int )cptr->want_async[20] == 1U) {
      {
#line 598
      prot_a_async_new_presentation(cptr, conf_no, old_presentation, new_presentation);
      }
    }
  }
#line 601
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 603
  restart_kom("async_new_presentation(): bad protocol.\n");
  }
#line 604
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 606
  return;
}
}
#line 609 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_new_motd(Connection *cptr , Conf_no conf_no , Text_no old_motd , Text_no new_motd ) 
{ 
  Bool tmp ;

  {
#line 615
  if (! param.send_async_messages) {
#line 616
    return;
  }
  {
#line 620
  if ((int )cptr->protocol == 0) {
#line 620
    goto case_0;
  }
#line 623
  if ((int )cptr->protocol == 65) {
#line 623
    goto case_65;
  }
#line 627
  goto switch_default;
  case_0: /* CIL Label */ 
#line 622
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 624
  tmp = handshake_ok(cptr, (enum ignored_conditions )0);
  }
#line 624
  if (tmp) {
#line 624
    if ((unsigned int )cptr->want_async[21] == 1U) {
      {
#line 625
      prot_a_async_new_motd(cptr, conf_no, old_motd, new_motd);
      }
    }
  }
#line 626
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 628
  restart_kom("async_new_motd(): bad protocol.\n");
  }
#line 629
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 631
  return;
}
}
#line 633 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/send-async.c"
void async_text_aux_changed(Connection *cptr , Text_no text_no , Aux_item_list *aux_list ,
                            unsigned long highest_old_aux ) 
{ 
  Bool tmp ;

  {
#line 639
  if (! param.send_async_messages) {
#line 640
    return;
  }
  {
#line 644
  if ((int )cptr->protocol == 0) {
#line 644
    goto case_0;
  }
#line 647
  if ((int )cptr->protocol == 65) {
#line 647
    goto case_65;
  }
#line 652
  goto switch_default;
  case_0: /* CIL Label */ 
#line 646
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 648
  tmp = handshake_ok(cptr, (enum ignored_conditions )0);
  }
#line 648
  if (tmp) {
#line 648
    if (cptr->want_async[22]) {
      {
#line 649
      prot_a_async_text_aux_changed(cptr, text_no, aux_list, highest_old_aux);
      }
    }
  }
#line 651
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 653
  restart_kom("async_text_aux_changed(): bad protocol.\n");
  }
#line 654
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 656
  return;
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 32 "/usr/include/crypt.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) crypt)(char const   *__key ,
                                                                                                char const   *__salt ) ;
#line 106 "./../libraries/libmisc/s-string.h"
extern String const   EMPTY_STRING ;
#line 190
extern void s_clear(String *str ) ;
#line 206
extern char *s_crea_c_str(String const   source ) ;
#line 49 "./../include/services.h"
extern Success login(Pers_no pers_no , String const   passwd , Bool invisible ) ;
#line 139
extern Pers_no create_person_old(String const   name___0 , String const   passwd ) ;
#line 143
extern Pers_no create_person(String const   name___0 , String const   passwd , Personal_flags flags ,
                             Aux_item_list *conf_aux ) ;
#line 150
extern Success set_pers_flags(Pers_no pers_no , Personal_flags flags ) ;
#line 155
extern Success get_person_stat_old(Pers_no person , int mask , Person *result ) ;
#line 160
extern Success get_person_stat(Pers_no person , Person *result ) ;
#line 164
extern Success get_created_texts(Pers_no pers_no , Local_text_no first , unsigned long len ,
                                 L2g_iterator *result ) ;
#line 170
extern Success map_created_texts(Pers_no pers_no , Local_text_no first_local_no ,
                                 unsigned long no_of_texts , Text_mapping *result ) ;
#line 176
extern Success map_created_texts_reverse(Pers_no pers_no , Local_text_no local_no_ceiling ,
                                         unsigned long no_of_texts , Text_mapping_reverse *result ) ;
#line 204
extern Success set_priv_bits(Pers_no person , Priv_bits privileges ) ;
#line 212
extern Success set_passwd(Pers_no person , String const   old_pwd , String const   new_pwd ) ;
#line 219
extern Success query_read_texts_old(Pers_no victim , Conf_no conf_no , Membership *result ) ;
#line 224
extern Success query_read_texts_10(Pers_no victim , Conf_no conf_no , Membership *result ) ;
#line 229
extern Success query_read_texts(Pers_no pers_no , Conf_no conf_no , Bool want_read_ranges ,
                                unsigned long max_ranges , Membership *result ) ;
#line 242
extern Success set_user_area(Pers_no pers_no , Text_no user_area ) ;
#line 456
extern Success mark_text_old(Text_no text_no , unsigned char mark_type ) ;
#line 462
extern Success mark_text(Text_no text_no , unsigned char mark_type ) ;
#line 468
extern Success unmark_text(Text_no text_no ) ;
#line 212 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
Connection *active_connection ;
#line 222 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/manipulate.h"
enum access access_perm(Conf_no victim , Connection const   *viewer_conn , enum access wanted_access ) ;
#line 265
enum memb_visibility membership_visible(Connection const   *viewer_conn , Pers_no member___0 ,
                                        Conf_no conf_no , Membership_type type , Bool is_supervisor_of_member ,
                                        Bool is_supervisor_of_conf ) ;
#line 276
void set_conf_errno(Connection const   *viewer_conn , Conf_no conf_no , enum kom_err errcode ) ;
#line 286
Success chk_passwd(char *pwd , String const   try ) ;
#line 304
Bool is_supervisor(Conf_no conf , Connection const   *viewer ) ;
#line 356
Membership *locate_membership(Conf_no conf_no , Person const   *pers_p ) ;
#line 366
Bool adjust_read(Membership *m , Conference const   *conf ) ;
#line 374
Success do_delete_pers(Pers_no pers_no ) ;
#line 389
void do_add_member(Conf_no conf_no , Conference *conf_c , Pers_no pers_no , Person *pers_p ,
                   Pers_no added_by , unsigned char priority , unsigned short where ,
                   Membership_type *type , Bool fake_passive ) ;
#line 406
Bool legal_name(String name___0 ) ;
#line 414
Bool unique_name(String const   name___0 , Conf_no conf_no ) ;
#line 426
Success do_sub_member(Conf_no conf_no , Conference *conf_c , Member *mbr , Pers_no pers_no ,
                      Person *pers_p , Membership *mship ) ;
#line 445
Bool text_read_access(Connection const   *conn , Text_no text_no , Text_stat const   *text_stat ) ;
#line 70 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache.h"
void mark_person_as_changed(Pers_no pers_no ) ;
#line 71
void mark_text_as_changed(Text_no text_no ) ;
#line 72
void mark_conference_as_changed(Conf_no conf_no ) ;
#line 81
extern Success cached_create_person(Pers_no person ) ;
#line 82
extern Conf_no cached_create_conf(String name___0 ) ;
#line 86
extern Person *cached_get_person_stat(Pers_no person ) ;
#line 87
extern Conference *cached_get_conf_stat(Conf_no conf_no ) ;
#line 88
extern Text_stat *cached_get_text_stat(Text_no text ) ;
#line 95
Success cached_delete_person(Pers_no pers ) ;
#line 97
extern Success cached_delete_conf(Conf_no conf ) ;
#line 178 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
void prepare_aux_item_list(Aux_item_list *list , Pers_no creator ) ;
#line 269
Success conf_stat_check_add_aux_item_list(Conference *conf , Conf_no conf_no , Aux_item_list *list ,
                                          Connection *creating_conn , Bool creating ) ;
#line 275
void conf_stat_add_aux_item_list(Conference *conf , Conf_no conf_no , Aux_item_list *item_list ,
                                 Pers_no item_creator ) ;
#line 26 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.h"
void l2g_clear(Local_to_global *l2g ) ;
#line 53
Local_text_no l2g_next_key(Local_to_global const   *l2g , Local_text_no lno ) ;
#line 60
Local_text_no l2g_first_appendable_key(Local_to_global const   *l2g ) ;
#line 123
void l2gi_searchsome(L2g_iterator *l2gi , Local_to_global const   *l2g , Local_text_no begin ,
                     Local_text_no end ) ;
#line 86 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/kom-memory.h"
void init_personal_flags(Personal_flags *p ) ;
#line 46 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.h"
void update_stat(enum stat_type st , long delta ) ;
#line 80 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
int buglevel ;
#line 86 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
static Bool legal_passwd(String const   pwd ) 
{ 
  int i ;

  {
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! ((String_size const   )i < pwd.len)) {
#line 91
      goto while_break;
    }
#line 92
    if ((int )*(pwd.string + i) == 0) {
#line 93
      return ((Bool )0);
    }
#line 91
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return ((Bool )1);
}
}
#line 104
static Success do_set_passwd(char *pwd , String const   new_pwd ) ;
#line 104 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
static char crypt_seed[65]  = 
#line 104
  {      (char )'a',      (char )'b',      (char )'c',      (char )'d', 
        (char )'e',      (char )'f',      (char )'g',      (char )'h', 
        (char )'i',      (char )'j',      (char )'k',      (char )'l', 
        (char )'m',      (char )'n',      (char )'o',      (char )'p', 
        (char )'q',      (char )'r',      (char )'s',      (char )'t', 
        (char )'u',      (char )'v',      (char )'w',      (char )'x', 
        (char )'y',      (char )'z',      (char )'A',      (char )'B', 
        (char )'C',      (char )'D',      (char )'E',      (char )'F', 
        (char )'G',      (char )'H',      (char )'I',      (char )'J', 
        (char )'K',      (char )'L',      (char )'M',      (char )'N', 
        (char )'O',      (char )'P',      (char )'Q',      (char )'R', 
        (char )'S',      (char )'T',      (char )'U',      (char )'V', 
        (char )'W',      (char )'X',      (char )'Y',      (char )'Z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'.',      (char )'/', 
        (char )'\000'};
#line 98 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
static Success do_set_passwd(char *pwd , String const   new_pwd ) 
{ 
  char salt[3] ;
  char *password ;
  Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 108
  tmp = legal_passwd(new_pwd);
  }
#line 108
  if (! tmp) {
#line 109
    return ((Success )FAILURE);
  }
  {
#line 111
  tmp___0 = rand();
#line 111
  salt[0] = crypt_seed[(unsigned long )tmp___0 % (sizeof(crypt_seed) - 1UL)];
#line 112
  tmp___1 = rand();
#line 112
  salt[1] = crypt_seed[(unsigned long )tmp___1 % (sizeof(crypt_seed) - 1UL)];
#line 113
  salt[2] = (char )'\000';
#line 115
  password = s_crea_c_str(new_pwd);
  }
#line 116
  if ((unsigned long )password == (unsigned long )((void *)0)) {
#line 117
    return ((Success )FAILURE);
  } else {
    {
#line 120
    tmp___2 = crypt((char const   *)password, (char const   *)(salt));
#line 120
    strcpy((char */* __restrict  */)((char *)pwd), (char const   */* __restrict  */)((char const   *)tmp___2));
#line 121
    string_free((void *)password);
    }
#line 122
    return ((Success )OK);
  }
}
}
#line 148 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
static Success do_mark_text(Pers_no pers_no , Person *pers_p , Text_no text_no , Text_stat *text_s ,
                            u_char mark_type ) 
{ 
  Mark *markp ;
  Mark *old_mark ;
  int i ;
  void *tmp ;

  {
#line 156
  old_mark = (Mark *)((void *)0);
#line 159
  if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
    {
#line 160
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 160
      pers_p = cached_get_person_stat(pers_no);
      }
#line 160
      if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 160
        return ((Success )FAILURE);
      }
#line 160
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 164
  i = (int )pers_p->marks.no_of_marks;
#line 164
  markp = pers_p->marks.marks;
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 164
    if (i > 0) {
#line 164
      if (! ((unsigned long )old_mark == (unsigned long )((void *)0))) {
#line 164
        goto while_break___0;
      }
    } else {
#line 164
      goto while_break___0;
    }
#line 168
    if (markp->text_no == text_no) {
#line 169
      old_mark = markp;
    }
#line 164
    i --;
#line 164
    markp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 172
  if ((unsigned long )old_mark != (unsigned long )((void *)0)) {
#line 176
    if (buglevel > 0) {
      {
#line 176
      printf((char const   */* __restrict  */)"do_mark_text(): Change type of mark.\n");
      }
    }
    {
#line 178
    old_mark->mark_type = mark_type;
#line 179
    mark_person_as_changed(pers_no);
    }
  } else {
#line 184
    if (buglevel > 0) {
      {
#line 184
      printf((char const   */* __restrict  */)"do_mark_text(): new mark.\n");
      }
    }
#line 186
    if ((unsigned long )text_s == (unsigned long )((void *)0)) {
      {
#line 187
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 187
        text_s = cached_get_text_stat(text_no);
        }
#line 187
        if ((unsigned long )text_s == (unsigned long )((void *)0)) {
#line 187
          return ((Success )FAILURE);
        }
#line 187
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 189
    if ((int )text_s->no_of_marks >= param.max_marks_text) {
#line 192
      err_stat = text_no;
#line 193
      kom_errno = (enum kom_err )36;
#line 194
      return ((Success )FAILURE);
    } else
#line 189
    if ((int )pers_p->marks.no_of_marks >= param.max_marks_person) {
#line 192
      err_stat = text_no;
#line 193
      kom_errno = (enum kom_err )36;
#line 194
      return ((Success )FAILURE);
    }
    {
#line 197
    text_s->no_of_marks = (unsigned short )((int )text_s->no_of_marks + 1);
#line 198
    mark_text_as_changed(text_no);
#line 200
    pers_p->marks.no_of_marks = (unsigned short )((int )pers_p->marks.no_of_marks + 1);
#line 200
    tmp = srealloc((void *)pers_p->marks.marks, (unsigned long )pers_p->marks.no_of_marks * sizeof(Mark ));
#line 200
    pers_p->marks.marks = (Mark *)tmp;
#line 202
    (pers_p->marks.marks + ((int )pers_p->marks.no_of_marks - 1))->text_no = text_no;
#line 203
    (pers_p->marks.marks + ((int )pers_p->marks.no_of_marks - 1))->mark_type = mark_type;
#line 205
    mark_person_as_changed(pers_no);
    }
  }
#line 208
  return ((Success )OK);
}
}
#line 213 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
static Success do_unmark_text(Pers_no pers_no , Person *pers_p , Text_no text_no ,
                              Text_stat *text_s ) 
{ 
  Mark *markp ;
  Mark *old_mark ;
  int i ;

  {
#line 220
  old_mark = (Mark *)((void *)0);
#line 223
  if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
    {
#line 224
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 224
      pers_p = cached_get_person_stat(pers_no);
      }
#line 224
      if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 224
        return ((Success )FAILURE);
      }
#line 224
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 228
  i = (int )pers_p->marks.no_of_marks;
#line 228
  markp = pers_p->marks.marks;
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 228
    if (i > 0) {
#line 228
      if (! ((unsigned long )old_mark == (unsigned long )((void *)0))) {
#line 228
        goto while_break___0;
      }
    } else {
#line 228
      goto while_break___0;
    }
#line 232
    if (markp->text_no == text_no) {
#line 233
      old_mark = markp;
    }
#line 228
    i --;
#line 228
    markp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 236
  if ((unsigned long )old_mark != (unsigned long )((void *)0)) {
#line 239
    if (buglevel > 0) {
      {
#line 239
      printf((char const   */* __restrict  */)"do_unmark_text(): Delete mark.\n");
      }
    }
    {
#line 241
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 241
      if (! ((unsigned long )old_mark < (unsigned long )((pers_p->marks.marks + (int )pers_p->marks.no_of_marks) - 1))) {
#line 241
        goto while_break___1;
      }
#line 244
      *old_mark = *(old_mark + 1);
#line 245
      old_mark ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 248
    pers_p->marks.no_of_marks = (unsigned short )((int )pers_p->marks.no_of_marks - 1);
#line 249
    mark_person_as_changed(pers_no);
#line 253
    text_s = cached_get_text_stat(text_no);
    }
#line 253
    if ((unsigned long )text_s != (unsigned long )((void *)0)) {
#line 255
      if ((int )text_s->no_of_marks == 0) {
        {
#line 257
        kom_log("WNG: do_unmark_text(): Text %lu has no_of_marks==0,  but person %d had marked the text.\n",
                text_no, (int )pers_no);
        }
      } else {
        {
#line 263
        text_s->no_of_marks = (unsigned short )((int )text_s->no_of_marks - 1);
#line 264
        mark_text_as_changed(text_no);
        }
      }
    }
  } else {
#line 272
    if (buglevel > 0) {
      {
#line 272
      printf((char const   */* __restrict  */)"do_unmark_text(): delete non-existent mark.\n");
      }
    }
#line 273
    err_stat = text_no;
#line 274
    kom_errno = (enum kom_err )44;
#line 275
    return ((Success )FAILURE);
  }
#line 278
  return ((Success )OK);
}
}
#line 287 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
static Success do_set_user_area(Pers_no pers_no , Person *pers_p , Text_no new_area ) 
{ 
  Text_no old_area ;
  Text_stat *old_stat ;
  Text_stat *new_stat ;
  Bool tmp ;

  {
#line 294
  new_stat = (Text_stat *)((void *)0);
#line 298
  if (new_area != 0UL) {
    {
#line 300
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 300
      new_stat = cached_get_text_stat(new_area);
      }
#line 300
      if ((unsigned long )new_stat == (unsigned long )((void *)0)) {
#line 300
        return ((Success )FAILURE);
      }
#line 300
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 302
    tmp = text_read_access((Connection const   *)active_connection, new_area, (Text_stat const   *)new_stat);
    }
#line 302
    if (! tmp) {
#line 302
      if (active_connection) {
#line 302
        if ((int )active_connection->ena_level >= 2) {
#line 302
          if (! (active_connection->person)->privileges.admin) {
#line 305
            kom_errno = (enum kom_err )14;
#line 306
            err_stat = new_area;
#line 307
            return ((Success )FAILURE);
          }
        } else {
#line 305
          kom_errno = (enum kom_err )14;
#line 306
          err_stat = new_area;
#line 307
          return ((Success )FAILURE);
        }
      } else {
#line 305
        kom_errno = (enum kom_err )14;
#line 306
        err_stat = new_area;
#line 307
        return ((Success )FAILURE);
      }
    }
#line 310
    if ((int )new_stat->no_of_marks >= param.max_marks_text) {
      {
#line 312
      kom_log("LIMIT: set_user_area(%d, %lu): New user_area\'s mark count (%d) > %d.\n",
              (int )pers_no, new_area, (int )new_stat->no_of_marks, param.max_marks_text);
#line 319
      err_stat = new_area;
#line 320
      kom_errno = (enum kom_err )36;
      }
#line 321
      return ((Success )FAILURE);
    }
  }
#line 325
  if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
    {
#line 326
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 326
      pers_p = cached_get_person_stat(pers_no);
      }
#line 326
      if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 326
        return ((Success )FAILURE);
      }
#line 326
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 330
  old_area = pers_p->user_area;
#line 331
  if (old_area != 0UL) {
    {
#line 331
    old_stat = cached_get_text_stat(old_area);
    }
#line 331
    if ((unsigned long )old_stat != (unsigned long )((void *)0)) {
#line 333
      if ((int )old_stat->no_of_marks > 0) {
        {
#line 335
        old_stat->no_of_marks = (unsigned short )((int )old_stat->no_of_marks - 1);
#line 336
        mark_text_as_changed(old_area);
        }
      } else {
        {
#line 340
        kom_log("ERROR: set_user_area(%d, %lu): Old user_area %lu unmarked.\n", (int )pers_no,
                new_area, old_area);
        }
      }
    }
  }
#line 349
  if (new_area != 0UL) {
    {
#line 351
    new_stat->no_of_marks = (unsigned short )((int )new_stat->no_of_marks + 1);
#line 352
    mark_text_as_changed(new_area);
    }
  }
  {
#line 355
  pers_p->user_area = new_area;
#line 356
  mark_person_as_changed(pers_no);
  }
#line 358
  if (old_area != new_area) {
    {
#line 359
    async_new_user_area(pers_no, old_area, new_area);
    }
  }
#line 361
  return ((Success )OK);
}
}
#line 375 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
Success do_delete_pers(Pers_no pers_no ) 
{ 
  Person *pers_p ;
  int i ;
  Success tmp ;
  Success tmp___0 ;
  Success tmp___1 ;

  {
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    pers_p = cached_get_person_stat(pers_no);
    }
#line 381
    if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 381
      return ((Success )FAILURE);
    }
#line 381
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 386
  i = (int )pers_p->conferences.no_of_confs - 1;
  {
#line 386
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 386
    if (! (i >= 0)) {
#line 386
      goto while_break___0;
    }
    {
#line 388
    tmp = do_sub_member((pers_p->conferences.confs + i)->conf_no, (Conference *)((void *)0),
                        (Member *)((void *)0), pers_no, pers_p, pers_p->conferences.confs + i);
    }
#line 388
    if ((unsigned long )tmp != (unsigned long )OK) {
      {
#line 392
      kom_log("ERROR: do_delete_pers(): can\'t sub_member\n");
      }
    }
#line 386
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 396
  i = (int )pers_p->marks.no_of_marks;
  {
#line 396
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 396
    if (! (i > 0)) {
#line 396
      goto while_break___1;
    }
    {
#line 398
    tmp___0 = do_unmark_text(pers_no, pers_p, (pers_p->marks.marks + 0)->text_no,
                             (Text_stat *)((void *)0));
    }
#line 398
    if ((unsigned long )tmp___0 != (unsigned long )OK) {
      {
#line 401
      kom_log("WNG: do_delete_pers(): can\'t unmark text %lu (i == %d)\n", (pers_p->marks.marks + 0)->text_no,
              i);
      }
    }
#line 396
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 406
  tmp___1 = do_set_user_area(pers_no, pers_p, (Text_no )0);
  }
#line 406
  if ((unsigned long )tmp___1 != (unsigned long )OK) {
    {
#line 408
    kom_log("WNG: do_delete_pers(): can\'t unmark user_area\n");
    }
  }
  {
#line 411
  s_clear(& pers_p->username);
#line 412
  l2g_clear(& pers_p->created_texts);
#line 414
  cached_delete_person(pers_no);
#line 415
  update_stat((enum stat_type )7, -1L);
  }
#line 418
  return ((Success )OK);
}
}
#line 424 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
Success chk_passwd(char *pwd , String const   try ) 
{ 
  char *c_try ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 431
  c_try = s_crea_c_str(try);
  }
#line 432
  if ((unsigned long )c_try == (unsigned long )((void *)0)) {
#line 433
    return ((Success )FAILURE);
  }
  {
#line 435
  tmp = crypt((char const   *)c_try, (char const   *)pwd);
#line 435
  tmp___0 = strcmp((char const   *)pwd, (char const   *)tmp);
  }
#line 435
  if (tmp___0 != 0) {
    {
#line 438
    string_free((void *)c_try);
    }
#line 439
    return ((Success )FAILURE);
  } else {
    {
#line 443
    string_free((void *)c_try);
    }
#line 444
    return ((Success )OK);
  }
}
}
#line 474 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success mark_text_old(Text_no text_no , unsigned char mark_type ) 
{ 
  Success tmp ;
  Success tmp___0 ;

  {
#line 479
  if ((int )mark_type == 0) {
    {
#line 480
    tmp = unmark_text(text_no);
    }
#line 480
    return (tmp);
  } else {
    {
#line 482
    tmp___0 = mark_text(text_no, mark_type);
    }
#line 482
    return (tmp___0);
  }
}
}
#line 485 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success mark_text(Text_no text_no , unsigned char mark_type ) 
{ 
  Text_stat *text_s ;
  Bool tmp ;
  Success tmp___0 ;

  {
#line 489
  text_s = (Text_stat *)((void *)0);
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 491
      err_stat = 0UL;
#line 491
      kom_errno = (enum kom_err )51;
#line 491
      return ((Success )FAILURE);
    }
#line 491
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 492
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 492
    if (! active_connection) {
#line 492
      err_stat = 0UL;
#line 492
      kom_errno = (enum kom_err )6;
#line 492
      return ((Success )FAILURE);
    } else
#line 492
    if (! active_connection->pers_no) {
#line 492
      err_stat = 0UL;
#line 492
      kom_errno = (enum kom_err )6;
#line 492
      return ((Success )FAILURE);
    }
#line 492
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 495
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 495
    text_s = cached_get_text_stat(text_no);
    }
#line 495
    if ((unsigned long )text_s == (unsigned long )((void *)0)) {
#line 495
      return ((Success )FAILURE);
    }
#line 495
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 496
  tmp = text_read_access((Connection const   *)active_connection, text_no, (Text_stat const   *)text_s);
  }
#line 496
  if (! tmp) {
#line 498
    err_stat = text_no;
#line 499
    kom_errno = (enum kom_err )14;
#line 500
    return ((Success )FAILURE);
  }
#line 503
  if (buglevel > 0) {
    {
#line 503
    printf((char const   */* __restrict  */)"Person %d markerar text %lu med typ %d\n",
           (int )active_connection->pers_no, text_no, (int )mark_type);
    }
  }
  {
#line 506
  tmp___0 = do_mark_text(active_connection->pers_no, active_connection->person, text_no,
                         text_s, mark_type);
  }
#line 506
  return (tmp___0);
}
}
#line 509 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success unmark_text(Text_no text_no ) 
{ 
  Text_stat *text_s ;
  Success tmp ;

  {
#line 512
  text_s = (Text_stat *)((void *)0);
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 514
      err_stat = 0UL;
#line 514
      kom_errno = (enum kom_err )51;
#line 514
      return ((Success )FAILURE);
    }
#line 514
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 515
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 515
    if (! active_connection) {
#line 515
      err_stat = 0UL;
#line 515
      kom_errno = (enum kom_err )6;
#line 515
      return ((Success )FAILURE);
    } else
#line 515
    if (! active_connection->pers_no) {
#line 515
      err_stat = 0UL;
#line 515
      kom_errno = (enum kom_err )6;
#line 515
      return ((Success )FAILURE);
    }
#line 515
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 516
  if (buglevel > 0) {
    {
#line 516
    printf((char const   */* __restrict  */)"Person %d avmarkerar text %lu\n", (int )active_connection->pers_no,
           text_no);
    }
  }
  {
#line 518
  tmp = do_unmark_text(active_connection->pers_no, active_connection->person, text_no,
                       text_s);
  }
#line 518
  return (tmp);
}
}
#line 545 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
static Pers_no create_person_generic(String const   name___0 , String const   passwd ,
                                     Aux_item_list *conf_aux , Personal_flags flags ,
                                     Bool do_auto_login ) 
{ 
  Pers_no new_user ;
  Conference *mailbox ;
  Person *pers_p ;
  Membership_type mship_type ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;
  Success tmp___2 ;
  Success tmp___3 ;
  int tmp___4 ;
  Success tmp___5 ;

  {
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 557
      err_stat = 0UL;
#line 557
      kom_errno = (enum kom_err )51;
#line 557
      return ((Pers_no )0);
    }
#line 557
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 558
  if ((int )active_connection->pers_no == 0) {
#line 560
    if (! param.create_person_before_login) {
#line 560
      if ((int )active_connection->pers_no == 0) {
#line 562
        err_stat = 0UL;
#line 563
        kom_errno = (enum kom_err )6;
#line 564
        return ((Pers_no )0);
      }
    }
  } else
#line 569
  if ((unsigned int )param.anyone_can_create_new_persons == 0U) {
#line 569
    if (active_connection->person) {
#line 569
      if (! (active_connection->person)->privileges.create_pers) {
#line 572
        err_stat = 0UL;
#line 573
        kom_errno = (enum kom_err )12;
#line 574
        return ((Pers_no )0);
      }
    } else {
#line 572
      err_stat = 0UL;
#line 573
      kom_errno = (enum kom_err )12;
#line 574
      return ((Pers_no )0);
    }
  }
  {
#line 578
  tmp = legal_name((String )name___0);
  }
#line 578
  if (! tmp) {
#line 581
    return ((Pers_no )0);
  }
  {
#line 584
  tmp___0 = unique_name(name___0, (Conf_no )0);
  }
#line 584
  if (! tmp___0) {
#line 586
    err_stat = 0UL;
#line 587
    kom_errno = (enum kom_err )21;
#line 588
    return ((Pers_no )0);
  }
  {
#line 591
  tmp___1 = legal_passwd(passwd);
  }
#line 591
  if (! tmp___1) {
#line 593
    err_stat = 0UL;
#line 594
    kom_errno = (enum kom_err )4;
#line 595
    return ((Pers_no )0);
  }
  {
#line 598
  new_user = cached_create_conf((String )name___0);
  }
#line 599
  if ((int )new_user == 0) {
    {
#line 602
    kom_log("ERROR: Couldn\'t create person. Too many conferences.\n");
    }
#line 603
    return ((Pers_no )0);
  }
  {
#line 606
  mailbox = cached_get_conf_stat(new_user);
  }
#line 606
  if ((unsigned long )mailbox == (unsigned long )((void *)0)) {
    {
#line 608
    restart_kom("create_person() - can\'t get conf_stat");
    }
  }
#line 611
  if (active_connection->pers_no) {
#line 611
    mailbox->creator = active_connection->pers_no;
  } else {
#line 611
    mailbox->creator = new_user;
  }
#line 612
  mailbox->creation_time = current_time.tv_sec;
#line 613
  mailbox->presentation = (Text_no )0;
#line 614
  if (active_connection->pers_no) {
#line 614
    mailbox->supervisor = active_connection->pers_no;
  } else {
#line 614
    mailbox->supervisor = new_user;
  }
  {
#line 615
  mailbox->permitted_submitters = (Conf_no )0;
#line 616
  mailbox->super_conf = active_connection->pers_no;
#line 617
  mailbox->type.rd_prot = 1U;
#line 618
  mailbox->type.original = 0U;
#line 619
  mailbox->type.secret = 0U;
#line 620
  mailbox->type.letter_box = 1U;
#line 621
  mailbox->type.allow_anon = 1U;
#line 622
  mailbox->type.forbid_secret = 0U;
#line 623
  mailbox->type.reserved2 = 0U;
#line 624
  mailbox->type.reserved3 = 0U;
#line 625
  mailbox->last_written = mailbox->creation_time;
#line 626
  mailbox->msg_of_day = (Text_no )0;
#line 627
  mailbox->nice = (Garb_nice )param.default_nice;
#line 628
  mailbox->keep_commented = (Garb_nice )param.default_keep_commented;
#line 630
  mark_conference_as_changed(new_user);
#line 634
  tmp___2 = cached_create_person(new_user);
  }
#line 634
  if ((unsigned long )tmp___2 == (unsigned long )FAILURE) {
    {
#line 636
    cached_delete_conf(new_user);
#line 639
    mark_conference_as_changed(new_user);
    }
#line 641
    return ((Pers_no )0);
  }
  {
#line 644
  pers_p = cached_get_person_stat(new_user);
  }
#line 644
  if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
    {
#line 646
    cached_delete_conf(new_user);
#line 649
    mark_conference_as_changed(new_user);
#line 651
    restart_kom("create_person() - can\'t get pers_stat");
    }
  }
  {
#line 656
  tmp___3 = do_set_passwd((char *)(pers_p->pwd), passwd);
  }
#line 656
  if ((unsigned long )tmp___3 != (unsigned long )OK) {
    {
#line 657
    restart_kom("create_person(): can\'t set passwd\n");
    }
  }
  {
#line 659
  pers_p->privileges.change_name = (unsigned int )param.default_change_name;
#line 660
  pers_p->flags = flags;
#line 662
  mark_person_as_changed(new_user);
#line 664
  mship_type.invitation = 0U;
#line 665
  mship_type.passive = 0U;
#line 666
  mship_type.secret = 0U;
#line 667
  mship_type.passive_message_invert = 0U;
#line 668
  mship_type.reserved2 = 0U;
#line 669
  mship_type.reserved3 = 0U;
#line 670
  mship_type.reserved4 = 0U;
#line 671
  mship_type.reserved5 = 0U;
  }
#line 673
  if (active_connection->pers_no) {
#line 673
    tmp___4 = (int )active_connection->pers_no;
  } else {
#line 673
    tmp___4 = (int )new_user;
  }
  {
#line 673
  do_add_member(new_user, mailbox, new_user, pers_p, (Pers_no )tmp___4, (unsigned char)255,
                (unsigned short)0, & mship_type, (Bool )0);
#line 677
  prepare_aux_item_list(conf_aux, new_user);
#line 679
  tmp___5 = conf_stat_check_add_aux_item_list(mailbox, new_user, conf_aux, active_connection,
                                              (Bool )1);
  }
#line 679
  if ((unsigned long )tmp___5 != (unsigned long )OK) {
    {
#line 690
    cached_delete_conf(new_user);
#line 691
    cached_delete_person(new_user);
    }
#line 693
    return ((Pers_no )0);
  }
  {
#line 696
  conf_stat_add_aux_item_list(mailbox, new_user, conf_aux, new_user);
#line 701
  mark_conference_as_changed(new_user);
  }
#line 703
  if (active_connection->pers_no) {
    {
#line 705
    (active_connection->person)->created_persons = (unsigned short )((int )(active_connection->person)->created_persons + 1);
#line 706
    mark_person_as_changed(active_connection->pers_no);
    }
  } else
#line 708
  if (do_auto_login) {
    {
#line 711
    login(new_user, passwd, (Bool )0);
    }
  }
  {
#line 714
  update_stat((enum stat_type )6, 1L);
#line 715
  update_stat((enum stat_type )7, 1L);
  }
#line 716
  return (new_user);
}
}
#line 720 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Pers_no create_person_old(String const   name___0 , String const   passwd ) 
{ 
  Personal_flags flags ;
  Pers_no tmp ;

  {
  {
#line 727
  init_personal_flags(& flags);
#line 728
  tmp = create_person_generic(name___0, passwd, (Aux_item_list *)((void *)0), flags,
                              (Bool )1);
  }
#line 728
  return (tmp);
}
}
#line 731 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Pers_no create_person(String const   name___0 , String const   passwd , Personal_flags flags ,
                             Aux_item_list *conf_aux ) 
{ 
  Pers_no pers ;

  {
  {
#line 740
  pers = create_person_generic(name___0, passwd, conf_aux, flags, (Bool )0);
  }
#line 746
  return (pers);
}
}
#line 756 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success get_person_stat(Pers_no person , Person *result ) 
{ 
  Person *p_orig ;
  enum access acc ;

  {
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 763
      err_stat = 0UL;
#line 763
      kom_errno = (enum kom_err )51;
#line 763
      return ((Success )FAILURE);
    }
#line 763
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 764
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 764
    p_orig = cached_get_person_stat(person);
    }
#line 764
    if ((unsigned long )p_orig == (unsigned long )((void *)0)) {
#line 764
      return ((Success )FAILURE);
    }
#line 764
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 766
  acc = access_perm(person, (Connection const   *)active_connection, (enum access )5);
  }
#line 768
  if ((unsigned int )acc == 0U) {
#line 769
    return ((Success )FAILURE);
  }
#line 771
  if ((unsigned int )acc <= 1U) {
#line 773
    err_stat = (unsigned long )person;
#line 774
    kom_errno = (enum kom_err )10;
#line 775
    return ((Success )FAILURE);
  }
#line 778
  *result = *p_orig;
#line 782
  if ((unsigned int )acc != 5U) {
#line 783
    result->user_area = (Text_no )0;
  }
#line 785
  return ((Success )OK);
}
}
#line 790 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success get_person_stat_old(Pers_no person , int mask , Person *result ) 
{ 
  Person *p_orig ;
  enum access acc ;

  {
  {
#line 798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 798
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 798
      err_stat = 0UL;
#line 798
      kom_errno = (enum kom_err )51;
#line 798
      return ((Success )FAILURE);
    }
#line 798
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 799
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 799
    if (! active_connection) {
#line 799
      err_stat = 0UL;
#line 799
      kom_errno = (enum kom_err )6;
#line 799
      return ((Success )FAILURE);
    } else
#line 799
    if (! active_connection->pers_no) {
#line 799
      err_stat = 0UL;
#line 799
      kom_errno = (enum kom_err )6;
#line 799
      return ((Success )FAILURE);
    }
#line 799
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 801
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 801
    p_orig = cached_get_person_stat(person);
    }
#line 801
    if ((unsigned long )p_orig == (unsigned long )((void *)0)) {
#line 801
      return ((Success )FAILURE);
    }
#line 801
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 803
  acc = access_perm(person, (Connection const   *)active_connection, (enum access )5);
  }
#line 805
  if ((unsigned int )acc == 0U) {
#line 806
    return ((Success )FAILURE);
  }
#line 808
  if ((unsigned int )acc <= 1U) {
#line 810
    err_stat = (unsigned long )person;
#line 811
    kom_errno = (enum kom_err )10;
#line 812
    return ((Success )FAILURE);
  }
#line 815
  *result = *p_orig;
#line 819
  if ((unsigned int )acc != 5U) {
#line 820
    result->user_area = (Text_no )0;
  }
#line 822
  if (! (mask & 1)) {
#line 823
    result->username = (String )EMPTY_STRING;
  }
#line 825
  return ((Success )OK);
}
}
#line 829 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success get_created_texts(Pers_no pers_no , Local_text_no first , unsigned long len ,
                                 L2g_iterator *result ) 
{ 
  Person *pers_p ;
  enum access acc ;
  Local_text_no new_first ;
  Local_text_no new_len ;
  Local_text_no tmp ;
  Local_text_no tmp___0 ;

  {
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 840
      err_stat = 0UL;
#line 840
      kom_errno = (enum kom_err )51;
#line 840
      return ((Success )FAILURE);
    }
#line 840
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 841
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 841
    if (! active_connection) {
#line 841
      err_stat = 0UL;
#line 841
      kom_errno = (enum kom_err )6;
#line 841
      return ((Success )FAILURE);
    } else
#line 841
    if (! active_connection->pers_no) {
#line 841
      err_stat = 0UL;
#line 841
      kom_errno = (enum kom_err )6;
#line 841
      return ((Success )FAILURE);
    }
#line 841
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 843
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 843
    pers_p = cached_get_person_stat(pers_no);
    }
#line 843
    if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 843
      return ((Success )FAILURE);
    }
#line 843
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 845
  acc = access_perm(pers_no, (Connection const   *)active_connection, (enum access )2);
  }
#line 847
  if ((unsigned int )acc == 0U) {
#line 848
    return ((Success )FAILURE);
  }
#line 850
  if ((unsigned int )acc <= 1U) {
#line 852
    err_stat = (unsigned long )pers_no;
#line 853
    kom_errno = (enum kom_err )10;
#line 854
    return ((Success )FAILURE);
  }
  {
#line 857
  new_first = l2g_next_key((Local_to_global const   *)(& pers_p->created_texts), (Local_text_no )0);
  }
#line 858
  if (new_first == 0UL) {
    {
#line 859
    new_first = l2g_first_appendable_key((Local_to_global const   *)(& pers_p->created_texts));
    }
  }
#line 860
  if (new_first > first) {
#line 860
    new_first = new_first;
  } else {
#line 860
    new_first = first;
  }
  {
#line 862
  tmp = l2g_first_appendable_key((Local_to_global const   *)(& pers_p->created_texts));
  }
#line 862
  if (first >= tmp) {
#line 864
    err_stat = first;
#line 865
    kom_errno = (enum kom_err )16;
#line 866
    return ((Success )FAILURE);
  }
  {
#line 869
  tmp___0 = l2g_first_appendable_key((Local_to_global const   *)(& pers_p->created_texts));
#line 869
  new_len = tmp___0 - new_first;
  }
#line 870
  if (new_len > len) {
#line 870
    new_len = len;
  } else {
#line 870
    new_len = new_len;
  }
  {
#line 871
  l2gi_searchsome(result, (Local_to_global const   *)(& pers_p->created_texts), new_first,
                  new_first + new_len);
  }
#line 874
  return ((Success )OK);
}
}
#line 878 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success map_created_texts(Pers_no pers_no , Local_text_no first_local_no ,
                                 unsigned long no_of_texts , Text_mapping *result ) 
{ 
  Person *pers_p ;
  enum access acc ;
  Local_text_no tmp ;

  {
  {
#line 887
  while (1) {
    while_continue: /* CIL Label */ ;
#line 887
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 887
      err_stat = 0UL;
#line 887
      kom_errno = (enum kom_err )51;
#line 887
      return ((Success )FAILURE);
    }
#line 887
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 888
  if (first_local_no == 0UL) {
#line 890
    err_stat = first_local_no;
#line 891
    kom_errno = (enum kom_err )17;
#line 892
    return ((Success )FAILURE);
  }
#line 895
  if (no_of_texts > 255UL) {
#line 897
    err_stat = 255UL;
#line 898
    kom_errno = (enum kom_err )46;
#line 899
    return ((Success )FAILURE);
  }
  {
#line 902
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 902
    pers_p = cached_get_person_stat(pers_no);
    }
#line 902
    if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 902
      return ((Success )FAILURE);
    }
#line 902
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 904
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 904
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 904
      err_stat = 0UL;
#line 904
      kom_errno = (enum kom_err )51;
#line 904
      return ((Success )FAILURE);
    }
#line 904
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 905
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 905
    if (! active_connection) {
#line 905
      err_stat = 0UL;
#line 905
      kom_errno = (enum kom_err )6;
#line 905
      return ((Success )FAILURE);
    } else
#line 905
    if (! active_connection->pers_no) {
#line 905
      err_stat = 0UL;
#line 905
      kom_errno = (enum kom_err )6;
#line 905
      return ((Success )FAILURE);
    }
#line 905
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 906
  acc = access_perm(pers_no, (Connection const   *)active_connection, (enum access )2);
  }
#line 908
  if ((unsigned int )acc == 0U) {
#line 909
    return ((Success )FAILURE);
  }
#line 911
  if ((unsigned int )acc <= 1U) {
#line 913
    err_stat = (unsigned long )pers_no;
#line 914
    kom_errno = (enum kom_err )10;
#line 915
    return ((Success )FAILURE);
  }
  {
#line 918
  tmp = l2g_first_appendable_key((Local_to_global const   *)(& pers_p->created_texts));
  }
#line 918
  if (first_local_no >= tmp) {
#line 920
    err_stat = first_local_no;
#line 921
    kom_errno = (enum kom_err )16;
#line 922
    return ((Success )FAILURE);
  }
#line 925
  result->first = first_local_no;
#line 926
  result->no_of_texts = no_of_texts;
#line 927
  result->l2g = (Local_to_global const   *)(& pers_p->created_texts);
#line 929
  return ((Success )OK);
}
}
#line 933 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success map_created_texts_reverse(Pers_no pers_no , Local_text_no local_no_ceiling ,
                                         unsigned long no_of_texts , Text_mapping_reverse *result ) 
{ 
  Person *pers_p ;
  enum access acc ;
  Local_text_no ceiling ;

  {
  {
#line 943
  while (1) {
    while_continue: /* CIL Label */ ;
#line 943
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 943
      err_stat = 0UL;
#line 943
      kom_errno = (enum kom_err )51;
#line 943
      return ((Success )FAILURE);
    }
#line 943
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 945
  if (no_of_texts > 255UL) {
#line 947
    err_stat = 255UL;
#line 948
    kom_errno = (enum kom_err )46;
#line 949
    return ((Success )FAILURE);
  }
  {
#line 952
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 952
    pers_p = cached_get_person_stat(pers_no);
    }
#line 952
    if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 952
      return ((Success )FAILURE);
    }
#line 952
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 954
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 954
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 954
      err_stat = 0UL;
#line 954
      kom_errno = (enum kom_err )51;
#line 954
      return ((Success )FAILURE);
    }
#line 954
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 955
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 955
    if (! active_connection) {
#line 955
      err_stat = 0UL;
#line 955
      kom_errno = (enum kom_err )6;
#line 955
      return ((Success )FAILURE);
    } else
#line 955
    if (! active_connection->pers_no) {
#line 955
      err_stat = 0UL;
#line 955
      kom_errno = (enum kom_err )6;
#line 955
      return ((Success )FAILURE);
    }
#line 955
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 956
  acc = access_perm(pers_no, (Connection const   *)active_connection, (enum access )2);
  }
#line 958
  if ((unsigned int )acc == 0U) {
#line 959
    return ((Success )FAILURE);
  }
#line 961
  if ((unsigned int )acc <= 1U) {
#line 963
    err_stat = (unsigned long )pers_no;
#line 964
    kom_errno = (enum kom_err )10;
#line 965
    return ((Success )FAILURE);
  }
  {
#line 968
  ceiling = l2g_first_appendable_key((Local_to_global const   *)(& pers_p->created_texts));
  }
#line 969
  if (local_no_ceiling == 0UL) {
#line 970
    result->ceiling = ceiling;
  } else
#line 969
  if (local_no_ceiling > ceiling) {
#line 970
    result->ceiling = ceiling;
  } else {
#line 972
    result->ceiling = local_no_ceiling;
  }
#line 974
  result->no_of_texts = no_of_texts;
#line 975
  result->l2g = (Local_to_global const   *)(& pers_p->created_texts);
#line 977
  return ((Success )OK);
}
}
#line 986 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success set_priv_bits(Pers_no person , Priv_bits privileges ) 
{ 
  Person *p ;

  {
  {
#line 992
  while (1) {
    while_continue: /* CIL Label */ ;
#line 992
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 992
      err_stat = 0UL;
#line 992
      kom_errno = (enum kom_err )51;
#line 992
      return ((Success )FAILURE);
    }
#line 992
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 993
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 993
    if (! active_connection) {
#line 993
      err_stat = 0UL;
#line 993
      kom_errno = (enum kom_err )6;
#line 993
      return ((Success )FAILURE);
    } else
#line 993
    if (! active_connection->pers_no) {
#line 993
      err_stat = 0UL;
#line 993
      kom_errno = (enum kom_err )6;
#line 993
      return ((Success )FAILURE);
    }
#line 993
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 995
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 995
    p = cached_get_person_stat(person);
    }
#line 995
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 995
      return ((Success )FAILURE);
    }
#line 995
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 997
  if (active_connection) {
#line 997
    if ((int )active_connection->ena_level >= 6) {
#line 997
      if ((active_connection->person)->privileges.wheel) {
        {
#line 999
        p->privileges = privileges;
#line 1000
        mark_person_as_changed(person);
        }
#line 1001
        return ((Success )OK);
      } else {
#line 1005
        err_stat = 0UL;
#line 1006
        kom_errno = (enum kom_err )12;
#line 1007
        return ((Success )FAILURE);
      }
    } else {
#line 1005
      err_stat = 0UL;
#line 1006
      kom_errno = (enum kom_err )12;
#line 1007
      return ((Success )FAILURE);
    }
  } else {
#line 1005
    err_stat = 0UL;
#line 1006
    kom_errno = (enum kom_err )12;
#line 1007
    return ((Success )FAILURE);
  }
}
}
#line 1015 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success set_passwd(Pers_no person , String const   old_pwd , String const   new_pwd ) 
{ 
  Person *p ;
  Bool tmp ;
  Success tmp___0 ;
  Success tmp___1 ;

  {
  {
#line 1024
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1024
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1024
      err_stat = 0UL;
#line 1024
      kom_errno = (enum kom_err )51;
#line 1024
      return ((Success )FAILURE);
    }
#line 1024
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1025
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1025
    if (! active_connection) {
#line 1025
      err_stat = 0UL;
#line 1025
      kom_errno = (enum kom_err )6;
#line 1025
      return ((Success )FAILURE);
    } else
#line 1025
    if (! active_connection->pers_no) {
#line 1025
      err_stat = 0UL;
#line 1025
      kom_errno = (enum kom_err )6;
#line 1025
      return ((Success )FAILURE);
    }
#line 1025
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1027
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1027
    p = cached_get_person_stat(person);
    }
#line 1027
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1027
      return ((Success )FAILURE);
    }
#line 1027
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1029
  tmp = is_supervisor(person, (Connection const   *)active_connection);
  }
#line 1029
  if (! tmp) {
#line 1029
    if (active_connection) {
#line 1029
      if ((int )active_connection->ena_level >= 7) {
#line 1029
        if (! (active_connection->person)->privileges.wheel) {
#line 1032
          err_stat = (unsigned long )person;
#line 1033
          kom_errno = (enum kom_err )12;
#line 1034
          return ((Success )FAILURE);
        }
      } else {
#line 1032
        err_stat = (unsigned long )person;
#line 1033
        kom_errno = (enum kom_err )12;
#line 1034
        return ((Success )FAILURE);
      }
    } else {
#line 1032
      err_stat = (unsigned long )person;
#line 1033
      kom_errno = (enum kom_err )12;
#line 1034
      return ((Success )FAILURE);
    }
  }
  {
#line 1037
  tmp___0 = chk_passwd((char *)((active_connection->person)->pwd), old_pwd);
  }
#line 1037
  if ((unsigned long )tmp___0 == (unsigned long )FAILURE) {
#line 1039
    err_stat = (unsigned long )person;
#line 1040
    kom_errno = (enum kom_err )4;
#line 1041
    return ((Success )FAILURE);
  }
  {
#line 1044
  tmp___1 = do_set_passwd((char *)(p->pwd), new_pwd);
  }
#line 1044
  if ((unsigned long )tmp___1 != (unsigned long )OK) {
#line 1046
    err_stat = 0UL;
#line 1047
    kom_errno = (enum kom_err )4;
#line 1048
    return ((Success )FAILURE);
  }
  {
#line 1051
  mark_person_as_changed(person);
  }
#line 1053
  return ((Success )OK);
}
}
#line 1066 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
static Success do_query_read_texts(Pers_no victim , Conf_no conf_no , Bool want_read_ranges ,
                                   unsigned long max_ranges , Membership *result ) 
{ 
  Person *victim_p ;
  Membership *membp ;
  enum memb_visibility vis ;
  Bool tmp ;
  Conference const   *conf_c ;
  Conference *tmp___0 ;
  Bool tmp___1 ;

  {
  {
#line 1077
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1077
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1077
      err_stat = 0UL;
#line 1077
      kom_errno = (enum kom_err )51;
#line 1077
      return ((Success )FAILURE);
    }
#line 1077
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1078
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1078
    victim_p = cached_get_person_stat(victim);
    }
#line 1078
    if ((unsigned long )victim_p == (unsigned long )((void *)0)) {
#line 1078
      return ((Success )FAILURE);
    }
#line 1078
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1080
  tmp = has_access(victim, (Connection const   *)active_connection, (enum access )2);
  }
#line 1080
  if (! tmp) {
#line 1082
    err_stat = (unsigned long )victim;
#line 1083
    kom_errno = (enum kom_err )10;
#line 1084
    return ((Success )FAILURE);
  }
  {
#line 1087
  membp = locate_membership(conf_no, (Person const   *)victim_p);
  }
#line 1088
  if ((unsigned long )membp == (unsigned long )((void *)0)) {
    {
#line 1090
    set_conf_errno((Connection const   *)active_connection, conf_no, (enum kom_err )13);
    }
#line 1091
    return ((Success )FAILURE);
  }
  {
#line 1094
  vis = membership_visible((Connection const   *)active_connection, victim, conf_no,
                           membp->type, (Bool )0, (Bool )0);
  }
#line 1096
  if ((unsigned int )vis == 0U) {
    {
#line 1098
    set_conf_errno((Connection const   *)active_connection, conf_no, (enum kom_err )13);
    }
#line 1099
    return ((Success )FAILURE);
  }
#line 1102
  if ((unsigned int )want_read_ranges == 1U) {
    {
#line 1106
    tmp___0 = cached_get_conf_stat(conf_no);
#line 1106
    conf_c = (Conference const   *)tmp___0;
    }
#line 1106
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
      {
#line 1108
      kom_log("do_query_read_texts: %lu is a member of %lu, but that conference doesn\'t exist\n",
              (unsigned long )victim, (unsigned long )conf_no);
      }
#line 1112
      return ((Success )FAILURE);
    }
    {
#line 1115
    tmp___1 = adjust_read(membp, conf_c);
    }
#line 1115
    if ((unsigned int )tmp___1 == 1U) {
      {
#line 1116
      mark_person_as_changed(victim);
      }
    }
  }
#line 1119
  *result = *membp;
#line 1121
  if ((unsigned int )vis == 1U) {
#line 1123
    result->last_time_read = (time_t )0;
#line 1124
    result->no_of_read_ranges = 0U;
#line 1125
    result->read_ranges = (struct read_range *)((void *)0);
  }
#line 1128
  if (want_read_ranges) {
#line 1130
    if (max_ranges != 0UL) {
#line 1130
      if ((unsigned long )result->no_of_read_ranges > max_ranges) {
#line 1131
        result->no_of_read_ranges = (unsigned int )max_ranges;
      }
    }
  } else {
#line 1135
    result->read_ranges = (struct read_range *)((void *)0);
  }
#line 1138
  return ((Success )OK);
}
}
#line 1142 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success query_read_texts(Pers_no pers_no , Conf_no conf_no , Bool want_read_ranges ,
                                unsigned long max_ranges , Membership *result ) 
{ 
  Success tmp ;

  {
  {
#line 1149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1149
    if ((unsigned int )want_read_ranges != 0U) {
#line 1149
      if ((unsigned int )want_read_ranges != 1U) {
#line 1149
        err_stat = 0UL;
#line 1149
        kom_errno = (enum kom_err )61;
#line 1149
        return ((Success )FAILURE);
      }
    }
#line 1149
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1152
  tmp = do_query_read_texts(pers_no, conf_no, want_read_ranges, max_ranges, result);
  }
#line 1152
  return (tmp);
}
}
#line 1159 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success query_read_texts_10(Pers_no victim , Conf_no conf_no , Membership *result ) 
{ 
  Success tmp ;

  {
  {
#line 1165
  tmp = do_query_read_texts(victim, conf_no, (Bool )1, 0UL, result);
  }
#line 1165
  return (tmp);
}
}
#line 1173 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success query_read_texts_old(Pers_no victim , Conf_no conf_no , Membership *result ) 
{ 
  Success tmp ;

  {
  {
#line 1179
  tmp = do_query_read_texts(victim, conf_no, (Bool )1, 0UL, result);
  }
#line 1179
  return (tmp);
}
}
#line 1193 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success set_user_area(Pers_no pers_no , Text_no user_area ) 
{ 
  Person *pers_p ;
  enum access acc ;
  Success tmp ;

  {
  {
#line 1200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1200
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1200
      err_stat = 0UL;
#line 1200
      kom_errno = (enum kom_err )51;
#line 1200
      return ((Success )FAILURE);
    }
#line 1200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1201
    if (! active_connection) {
#line 1201
      err_stat = 0UL;
#line 1201
      kom_errno = (enum kom_err )6;
#line 1201
      return ((Success )FAILURE);
    } else
#line 1201
    if (! active_connection->pers_no) {
#line 1201
      err_stat = 0UL;
#line 1201
      kom_errno = (enum kom_err )6;
#line 1201
      return ((Success )FAILURE);
    }
#line 1201
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1203
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1203
    pers_p = cached_get_person_stat(pers_no);
    }
#line 1203
    if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 1203
      return ((Success )FAILURE);
    }
#line 1203
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1204
  acc = access_perm(pers_no, (Connection const   *)active_connection, (enum access )5);
  }
#line 1205
  if ((unsigned int )acc <= 1U) {
#line 1207
    err_stat = (unsigned long )pers_no;
#line 1208
    kom_errno = (enum kom_err )10;
#line 1209
    return ((Success )FAILURE);
  }
#line 1211
  if ((unsigned int )acc != 5U) {
#line 1213
    err_stat = (unsigned long )pers_no;
#line 1214
    kom_errno = (enum kom_err )12;
#line 1215
    return ((Success )FAILURE);
  }
  {
#line 1218
  tmp = do_set_user_area(pers_no, pers_p, user_area);
  }
#line 1218
  return (tmp);
}
}
#line 1226 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/person.c"
extern Success set_pers_flags(Pers_no pers_no , Personal_flags flags ) 
{ 
  Person *pers_p ;
  enum access acc ;

  {
  {
#line 1233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1233
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1233
      err_stat = 0UL;
#line 1233
      kom_errno = (enum kom_err )51;
#line 1233
      return ((Success )FAILURE);
    }
#line 1233
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1234
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1234
    if (! active_connection) {
#line 1234
      err_stat = 0UL;
#line 1234
      kom_errno = (enum kom_err )6;
#line 1234
      return ((Success )FAILURE);
    } else
#line 1234
    if (! active_connection->pers_no) {
#line 1234
      err_stat = 0UL;
#line 1234
      kom_errno = (enum kom_err )6;
#line 1234
      return ((Success )FAILURE);
    }
#line 1234
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1236
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1236
    pers_p = cached_get_person_stat(pers_no);
    }
#line 1236
    if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 1236
      return ((Success )FAILURE);
    }
#line 1236
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1238
  acc = access_perm(pers_no, (Connection const   *)active_connection, (enum access )5);
  }
#line 1239
  if ((unsigned int )acc <= 1U) {
#line 1241
    err_stat = (unsigned long )pers_no;
#line 1242
    kom_errno = (enum kom_err )10;
#line 1243
    return ((Success )FAILURE);
  }
#line 1245
  if ((unsigned int )acc != 5U) {
#line 1247
    err_stat = (unsigned long )pers_no;
#line 1248
    kom_errno = (enum kom_err )12;
#line 1249
    return ((Success )FAILURE);
  }
  {
#line 1252
  pers_p->flags = flags;
#line 1253
  mark_person_as_changed(pers_no);
  }
#line 1255
  return ((Success )OK);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 217 "./../libraries/libmisc/s-string.h"
extern Success s_strcpy(String *dest_string , String const   source_string ) ;
#line 47 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/kom-memory.h"
void init_conf_type(Conf_type *ct ) ;
#line 50
Conference *alloc_conference(void) ;
#line 51
void free_conference(Conference *confp ) ;
#line 52
void clear_conference(Conference *confp ) ;
#line 53
Conference *copy_conference(Conference const   *o ) ;
#line 54
void init_conference(Conference *c ) ;
#line 58
void init_dynamic_session_info(Dynamic_session_info *d ) ;
#line 61
void init_mark_list(Mark_list *ml ) ;
#line 64
void init_member_list(Member_list *ml ) ;
#line 67
void init_membership_type(Membership_type *m ) ;
#line 70
void init_member(Member *mem ) ;
#line 73
void init_membership(Membership *m ) ;
#line 76
void init_membership_list(Membership_list *m ) ;
#line 79
Person *alloc_person(void) ;
#line 80
void free_person(Person *person ) ;
#line 81
void clear_person(Person *person ) ;
#line 82
Person *copy_person(Person const   *p ) ;
#line 83
void init_person(Person *p ) ;
#line 89
void init_priv_bits(Priv_bits *pb ) ;
#line 92
void init_session_info(Session_info *s ) ;
#line 95
void init_session_info_ident(Session_info_ident *s ) ;
#line 98
void init_static_session_info(Static_session_info *d ) ;
#line 101
Text_stat *alloc_text_stat(void) ;
#line 102
void free_text_stat(Text_stat *t ) ;
#line 103
void clear_text_stat(Text_stat *t ) ;
#line 104
Text_stat *copy_text_stat(Text_stat const   *t ) ;
#line 105
void init_text_stat(Text_stat *t ) ;
#line 108
void init_struct_tm(struct tm *t ) ;
#line 111
void init_who_info(Who_info *w ) ;
#line 114
void init_who_info_ident(Who_info_ident *w ) ;
#line 117
void init_who_info_old(Who_info_old *w ) ;
#line 121
void free_aux_item_list(Aux_item_list *list ) ;
#line 122
void init_aux_item_list(Aux_item_list *list ) ;
#line 124
void init_aux_item_link(Aux_item_link *dest ) ;
#line 125
void init_aux_item_flags(Aux_item_flags *dest ) ;
#line 126
void clear_aux_item(Aux_item *item ) ;
#line 127
void init_aux_item(Aux_item *dest ) ;
#line 128
void copy_aux_item(Aux_item *dest , Aux_item const   *src ) ;
#line 133
void dump_alloc_counts(FILE *fp ) ;
#line 18 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.h"
void l2g_init(Local_to_global *l2g ) ;
#line 22
void l2g_destruct(Local_to_global *l2g ) ;
#line 31
void l2g_copy(Local_to_global *dest , Local_to_global const   *src ) ;
#line 50 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static int person_cnt  =    0;
#line 51 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static int conference_cnt  =    0;
#line 52 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static int text_stat_cnt  =    0;
#line 56
static void clear_mark_list(Mark_list *mark_list ) ;
#line 57
static Mark_list copy_mark_list(Mark_list ml ) ;
#line 58
static void clear_member_list(Member_list *m ) ;
#line 59
static Member_list copy_member_list(Member_list ml ) ;
#line 60
static void clear_membership(Membership *mship ) ;
#line 61
static Membership copy_membership(Membership m ) ;
#line 62
static void clear_membership_list(Membership_list *mlist ) ;
#line 63
static Membership_list copy_membership_list(Membership_list ml ) ;
#line 64
static void copy_aux_item_list(Aux_item_list *dest , Aux_item_list const   *src ) ;
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_conf_type(Conf_type *ct ) 
{ 


  {
#line 72
  ct->rd_prot = 0U;
#line 73
  ct->original = 0U;
#line 74
  ct->secret = 0U;
#line 75
  ct->letter_box = 0U;
#line 76
  ct->allow_anon = 1U;
#line 77
  ct->forbid_secret = 0U;
#line 78
  ct->reserved2 = 0U;
#line 79
  ct->reserved3 = 0U;
#line 80
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
Conference *alloc_conference(void) 
{ 
  Conference *c ;
  void *tmp ;

  {
  {
#line 89
  conference_cnt ++;
#line 91
  tmp = smalloc(sizeof(Conference ));
#line 91
  c = (Conference *)tmp;
#line 92
  init_conference(c);
  }
#line 93
  return (c);
}
}
#line 96 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void free_conference(Conference *confp ) 
{ 


  {
#line 99
  if ((unsigned long )confp == (unsigned long )((void *)0)) {
#line 100
    return;
  }
  {
#line 102
  conference_cnt --;
#line 103
  clear_conference(confp);
#line 104
  l2g_destruct(& confp->texts);
#line 105
  sfree((void *)confp);
  }
#line 106
  return;
}
}
#line 108 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void clear_conference(Conference *confp ) 
{ 


  {
  {
#line 111
  s_clear(& confp->name);
#line 112
  clear_member_list(& confp->members);
#line 113
  l2g_clear(& confp->texts);
#line 114
  free_aux_item_list(& confp->aux_item_list);
#line 115
  init_conference(confp);
  }
#line 116
  return;
}
}
#line 118 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
Conference *copy_conference(Conference const   *o ) 
{ 
  Conference *c ;

  {
  {
#line 123
  c = alloc_conference();
#line 124
  c->type = (Conf_type )o->type;
#line 125
  c->creator = (Pers_no )o->creator;
#line 126
  c->supervisor = (Conf_no )o->supervisor;
#line 127
  c->permitted_submitters = (Conf_no )o->permitted_submitters;
#line 128
  c->super_conf = (Conf_no )o->super_conf;
#line 129
  c->creation_time = (Time )o->creation_time;
#line 130
  c->presentation = (Text_no )o->presentation;
#line 131
  c->last_written = (Time )o->last_written;
#line 132
  c->msg_of_day = (Text_no )o->msg_of_day;
#line 133
  c->nice = (Garb_nice )o->nice;
#line 134
  c->keep_commented = (Garb_nice )o->keep_commented;
#line 135
  c->expire = (Garb_nice )o->expire;
#line 136
  s_strcpy(& c->name, o->name);
#line 137
  c->highest_aux = (unsigned long )o->highest_aux;
#line 138
  copy_aux_item_list(& c->aux_item_list, & o->aux_item_list);
#line 140
  c->members = copy_member_list((Member_list )o->members);
#line 141
  l2g_copy(& c->texts, & o->texts);
  }
#line 142
  return (c);
}
}
#line 145 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_conference(Conference *c ) 
{ 


  {
  {
#line 148
  init_conf_type(& c->type);
#line 149
  c->creator = (Pers_no )0;
#line 150
  c->supervisor = (Conf_no )0;
#line 151
  c->permitted_submitters = (Conf_no )0;
#line 152
  c->super_conf = (Conf_no )0;
#line 153
  c->creation_time = (time_t )0;
#line 154
  c->presentation = (Text_no )0;
#line 155
  c->last_written = (time_t )0;
#line 156
  c->msg_of_day = (Text_no )0;
#line 157
  c->nice = (Garb_nice )0;
#line 158
  c->keep_commented = (Garb_nice )0;
#line 159
  c->highest_aux = 0UL;
#line 160
  c->expire = (Garb_nice )0;
#line 161
  c->name = (String )EMPTY_STRING;
#line 162
  init_member_list(& c->members);
#line 163
  l2g_init(& c->texts);
#line 164
  init_aux_item_list(& c->aux_item_list);
  }
#line 165
  return;
}
}
#line 169 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_dynamic_session_info(Dynamic_session_info *d ) 
{ 


  {
#line 172
  d->session = (Session_no )0;
#line 173
  d->person = (Pers_no )0;
#line 174
  d->working_conference = (Conf_no )0;
#line 175
  d->idle_time = 0UL;
#line 176
  d->flags.invisible = 0U;
#line 177
  d->flags.user_active_used = 0U;
#line 178
  d->flags.user_absent = 0U;
#line 179
  d->flags.reserved3 = 0U;
#line 180
  d->flags.reserved4 = 0U;
#line 181
  d->flags.reserved5 = 0U;
#line 182
  d->flags.reserved6 = 0U;
#line 183
  d->flags.reserved7 = 0U;
#line 184
  d->what_am_i_doing = (String )EMPTY_STRING;
#line 185
  return;
}
}
#line 190 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static void clear_mark_list(Mark_list *mark_list ) 
{ 


  {
#line 193
  if ((unsigned long )mark_list == (unsigned long )((void *)0)) {
    {
#line 195
    kom_log("clear_mark_list(): mark_list == NULL.\n");
    }
#line 196
    return;
  }
  {
#line 199
  sfree((void *)mark_list->marks);
#line 200
  init_mark_list(mark_list);
  }
#line 201
  return;
}
}
#line 203 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static Mark_list copy_mark_list(Mark_list ml ) 
{ 
  Mark_list r ;
  void *tmp ;

  {
  {
#line 208
  r.no_of_marks = ml.no_of_marks;
#line 209
  tmp = smalloc((unsigned long )r.no_of_marks * sizeof(Mark ));
#line 209
  r.marks = (Mark *)tmp;
#line 210
  memcpy((void */* __restrict  */)r.marks, (void const   */* __restrict  */)ml.marks,
         (unsigned long )r.no_of_marks * sizeof(Mark ));
  }
#line 211
  return (r);
}
}
#line 214 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_mark_list(Mark_list *ml ) 
{ 


  {
#line 217
  ml->no_of_marks = (unsigned short)0;
#line 218
  ml->marks = (Mark *)((void *)0);
#line 219
  return;
}
}
#line 223 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static void clear_member_list(Member_list *m ) 
{ 


  {
#line 226
  if ((unsigned long )m == (unsigned long )((void *)0)) {
#line 227
    return;
  }
  {
#line 229
  sfree((void *)m->members);
#line 230
  init_member_list(m);
  }
#line 231
  return;
}
}
#line 233 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static Member_list copy_member_list(Member_list ml ) 
{ 
  Member_list res ;
  void *tmp ;

  {
  {
#line 238
  res.no_of_members = ml.no_of_members;
#line 239
  tmp = smalloc((unsigned long )res.no_of_members * sizeof(Member ));
#line 239
  res.members = (Member *)tmp;
#line 240
  memcpy((void */* __restrict  */)res.members, (void const   */* __restrict  */)ml.members,
         (unsigned long )res.no_of_members * sizeof(Member ));
  }
#line 241
  return (res);
}
}
#line 244 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_member_list(Member_list *ml ) 
{ 


  {
#line 247
  ml->no_of_members = (unsigned short)0;
#line 248
  ml->members = (Member *)((void *)0);
#line 249
  return;
}
}
#line 253 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_member(Member *mem ) 
{ 


  {
#line 256
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
    {
#line 258
    kom_log("init_member(): mem == NULL.\n");
    }
#line 259
    return;
  }
  {
#line 261
  mem->member = (Pers_no )0;
#line 262
  mem->added_by = (Pers_no )0;
#line 263
  mem->added_at = (time_t )0;
#line 264
  init_membership_type(& mem->type);
  }
#line 265
  return;
}
}
#line 269 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static void clear_membership(Membership *mship ) 
{ 


  {
#line 272
  if ((unsigned long )mship == (unsigned long )((void *)0)) {
    {
#line 274
    kom_log("clear_membership(): mship == NULL.\n");
    }
#line 275
    return;
  }
  {
#line 278
  sfree((void *)mship->read_ranges);
#line 279
  init_membership(mship);
  }
#line 280
  return;
}
}
#line 282 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static Membership copy_membership(Membership m ) 
{ 
  Membership res ;
  void *tmp ;

  {
#line 287
  res = m;
#line 288
  if (m.no_of_read_ranges != 0U) {
    {
#line 290
    tmp = smalloc((unsigned long )m.no_of_read_ranges * sizeof(*(res.read_ranges + 0)));
#line 290
    res.read_ranges = (struct read_range *)tmp;
#line 292
    memcpy((void */* __restrict  */)res.read_ranges, (void const   */* __restrict  */)m.read_ranges,
           (unsigned long )m.no_of_read_ranges * sizeof(*(res.read_ranges + 0)));
    }
  } else
#line 295
  if ((unsigned long )m.read_ranges != (unsigned long )((void *)0)) {
    {
#line 297
    kom_log("copy_membership(): read_ranges != NULL but no_of_read_ranges == 0\n");
#line 299
    res.read_ranges = (struct read_range *)((void *)0);
    }
  }
#line 301
  return (res);
}
}
#line 304 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_membership_type(Membership_type *m ) 
{ 


  {
#line 307
  m->invitation = 0U;
#line 308
  m->passive = 0U;
#line 309
  m->secret = 0U;
#line 310
  m->passive_message_invert = 0U;
#line 311
  m->reserved2 = 0U;
#line 312
  m->reserved3 = 0U;
#line 313
  m->reserved4 = 0U;
#line 314
  m->reserved5 = 0U;
#line 315
  return;
}
}
#line 317 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_membership(Membership *m ) 
{ 


  {
  {
#line 320
  m->conf_no = (Conf_no )0;
#line 321
  m->priority = (unsigned char)0;
#line 322
  m->no_of_read_ranges = 0U;
#line 323
  m->read_ranges = (struct read_range *)((void *)0);
#line 324
  m->last_time_read = (time_t )0;
#line 325
  m->added_by = (Pers_no )0;
#line 326
  m->position = 0UL;
#line 327
  m->added_at = (time_t )0;
#line 328
  init_membership_type(& m->type);
#line 329
  m->skip_read_texts = (Bool )0;
  }
#line 330
  return;
}
}
#line 334 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static void clear_membership_list(Membership_list *mlist ) 
{ 
  int i ;

  {
#line 339
  if ((unsigned long )mlist == (unsigned long )((void *)0)) {
    {
#line 341
    kom_log("clear_membership_list(): membership_list == NULL.\n");
    }
#line 342
    return;
  }
#line 345
  i = 0;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! (i < (int )mlist->no_of_confs)) {
#line 345
      goto while_break;
    }
    {
#line 347
    clear_membership(mlist->confs + i);
#line 345
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 350
  sfree((void *)mlist->confs);
#line 351
  init_membership_list(mlist);
  }
#line 352
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static Membership_list copy_membership_list(Membership_list ml ) 
{ 
  Membership_list r ;
  int i ;
  void *tmp ;

  {
  {
#line 360
  r.no_of_confs = ml.no_of_confs;
#line 361
  tmp = smalloc((unsigned long )ml.no_of_confs * sizeof(Membership ));
#line 361
  r.confs = (Membership *)tmp;
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! (i < (int )r.no_of_confs)) {
#line 363
      goto while_break;
    }
    {
#line 365
    *(r.confs + i) = copy_membership(*(ml.confs + i));
#line 363
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return (r);
}
}
#line 371 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_membership_list(Membership_list *m ) 
{ 


  {
#line 374
  m->no_of_confs = (unsigned short)0;
#line 375
  m->confs = (Membership *)((void *)0);
#line 376
  return;
}
}
#line 380 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_static_session_info(Static_session_info *d ) 
{ 


  {
#line 383
  d->username = (String )EMPTY_STRING;
#line 384
  d->hostname = (String )EMPTY_STRING;
#line 385
  d->ident_user = (String )EMPTY_STRING;
#line 386
  d->connection_time = (time_t )0;
#line 387
  return;
}
}
#line 390 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
Person *alloc_person(void) 
{ 
  Person *p ;
  void *tmp ;

  {
  {
#line 395
  person_cnt ++;
#line 397
  tmp = smalloc(sizeof(Person ));
#line 397
  p = (Person *)tmp;
#line 398
  init_person(p);
  }
#line 399
  return (p);
}
}
#line 402 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void free_person(Person *person ) 
{ 


  {
#line 405
  if ((unsigned long )person == (unsigned long )((void *)0)) {
#line 406
    return;
  }
  {
#line 408
  person_cnt --;
#line 409
  clear_person(person);
#line 410
  l2g_destruct(& person->created_texts);
#line 411
  sfree((void *)person);
  }
#line 412
  return;
}
}
#line 414 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void clear_person(Person *person ) 
{ 


  {
  {
#line 417
  s_clear(& person->username);
#line 418
  l2g_clear(& person->created_texts);
#line 419
  clear_mark_list(& person->marks);
#line 420
  clear_membership_list(& person->conferences);
#line 421
  init_person(person);
  }
#line 422
  return;
}
}
#line 424 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
Person *copy_person(Person const   *p ) 
{ 
  Person *c ;

  {
  {
#line 429
  c = alloc_person();
#line 430
  c->user_area = (Text_no )p->user_area;
#line 431
  c->privileges = (Priv_bits )p->privileges;
#line 432
  c->flags = (Personal_flags )p->flags;
#line 433
  c->last_login = (Time )p->last_login;
#line 434
  c->total_time_present = (unsigned long )p->total_time_present;
#line 435
  c->sessions = (unsigned long )p->sessions;
#line 436
  c->created_lines = (unsigned long )p->created_lines;
#line 437
  c->created_bytes = (unsigned long )p->created_bytes;
#line 438
  c->read_texts = (unsigned long )p->read_texts;
#line 439
  c->no_of_text_fetches = (unsigned long )p->no_of_text_fetches;
#line 440
  c->created_persons = (unsigned short )p->created_persons;
#line 441
  c->created_confs = (unsigned short )p->created_confs;
#line 442
  s_strcpy(& c->username, p->username);
#line 443
  l2g_copy(& c->created_texts, & p->created_texts);
#line 444
  c->marks = copy_mark_list((Mark_list )p->marks);
#line 445
  c->conferences = copy_membership_list((Membership_list )p->conferences);
#line 446
  memcpy((void */* __restrict  */)(& c->pwd), (void const   */* __restrict  */)(& p->pwd),
         sizeof(Password ));
  }
#line 447
  return (c);
}
}
#line 450 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_person(Person *p ) 
{ 


  {
  {
#line 453
  p->user_area = (Text_no )0;
#line 454
  p->total_time_present = 0UL;
#line 455
  p->sessions = 0UL;
#line 456
  p->created_lines = 0UL;
#line 457
  p->created_bytes = 0UL;
#line 458
  p->read_texts = 0UL;
#line 459
  p->no_of_text_fetches = 0UL;
#line 460
  p->created_persons = (unsigned short)0;
#line 461
  p->created_confs = (unsigned short)0;
#line 462
  p->username = (String )EMPTY_STRING;
#line 463
  p->last_login = (time_t )0;
#line 465
  init_priv_bits(& p->privileges);
#line 466
  init_personal_flags(& p->flags);
#line 467
  l2g_init(& p->created_texts);
#line 468
  init_mark_list(& p->marks);
#line 469
  init_membership_list(& p->conferences);
#line 473
  memset((void *)(p->pwd), 0, (size_t )64);
  }
#line 474
  return;
}
}
#line 478 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_personal_flags(Personal_flags *p ) 
{ 


  {
#line 481
  p->unread_is_secret = 0U;
#line 482
  p->flg2 = 0U;
#line 483
  p->flg3 = 0U;
#line 484
  p->flg4 = 0U;
#line 485
  p->flg5 = 0U;
#line 486
  p->flg6 = 0U;
#line 487
  p->flg7 = 0U;
#line 488
  p->flg8 = 0U;
#line 489
  return;
}
}
#line 493 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_priv_bits(Priv_bits *pb ) 
{ 


  {
#line 496
  pb->wheel = 0U;
#line 497
  pb->admin = 0U;
#line 498
  pb->statistic = 0U;
#line 499
  pb->create_pers = 0U;
#line 500
  pb->create_conf = 0U;
#line 501
  pb->change_name = 0U;
#line 502
  pb->flg7 = 0U;
#line 503
  pb->flg8 = 0U;
#line 504
  pb->flg9 = 0U;
#line 505
  pb->flg10 = 0U;
#line 506
  pb->flg11 = 0U;
#line 507
  pb->flg12 = 0U;
#line 508
  pb->flg13 = 0U;
#line 509
  pb->flg14 = 0U;
#line 510
  pb->flg15 = 0U;
#line 511
  pb->flg16 = 0U;
#line 512
  return;
}
}
#line 516 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_session_info(Session_info *s ) 
{ 


  {
#line 519
  s->person = (Pers_no )0;
#line 520
  s->what_am_i_doing = (String )EMPTY_STRING;
#line 521
  s->username = (String )EMPTY_STRING;
#line 522
  s->working_conference = (Conf_no )0;
#line 523
  s->session = (Session_no )0;
#line 524
  s->connection_time = (time_t )0;
#line 525
  s->idle_time = 0UL;
#line 526
  return;
}
}
#line 530 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_session_info_ident(Session_info_ident *s ) 
{ 


  {
#line 533
  s->person = (Pers_no )0;
#line 534
  s->what_am_i_doing = (String )EMPTY_STRING;
#line 535
  s->username = (String )EMPTY_STRING;
#line 536
  s->ident_user = (String )EMPTY_STRING;
#line 537
  s->hostname = (String )EMPTY_STRING;
#line 538
  s->working_conference = (Conf_no )0;
#line 539
  s->session = (Session_no )0;
#line 540
  s->connection_time = (time_t )0;
#line 541
  s->idle_time = 0UL;
#line 542
  return;
}
}
#line 546 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
Text_stat *alloc_text_stat(void) 
{ 
  Text_stat *t ;
  void *tmp ;

  {
  {
#line 551
  text_stat_cnt ++;
#line 553
  tmp = smalloc(sizeof(Text_stat ));
#line 553
  t = (Text_stat *)tmp;
#line 554
  init_text_stat(t);
  }
#line 555
  return (t);
}
}
#line 558 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void free_text_stat(Text_stat *t ) 
{ 


  {
#line 561
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 562
    return;
  }
  {
#line 564
  text_stat_cnt --;
#line 565
  clear_text_stat(t);
#line 566
  sfree((void *)t);
  }
#line 567
  return;
}
}
#line 569 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void clear_text_stat(Text_stat *t ) 
{ 
  int i ;

  {
#line 574
  i = 0;
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! (i < (int )t->no_of_misc)) {
#line 574
      goto while_break;
    }
    {
#line 588
    if ((unsigned int )(t->misc_items + i)->type == 9U) {
#line 588
      goto case_9;
    }
#line 588
    if ((unsigned int )(t->misc_items + i)->type == 8U) {
#line 588
      goto case_9;
    }
#line 588
    if ((unsigned int )(t->misc_items + i)->type == 7U) {
#line 588
      goto case_9;
    }
#line 588
    if ((unsigned int )(t->misc_items + i)->type == 6U) {
#line 588
      goto case_9;
    }
#line 588
    if ((unsigned int )(t->misc_items + i)->type == 5U) {
#line 588
      goto case_9;
    }
#line 588
    if ((unsigned int )(t->misc_items + i)->type == 4U) {
#line 588
      goto case_9;
    }
#line 588
    if ((unsigned int )(t->misc_items + i)->type == 3U) {
#line 588
      goto case_9;
    }
#line 588
    if ((unsigned int )(t->misc_items + i)->type == 2U) {
#line 588
      goto case_9;
    }
#line 588
    if ((unsigned int )(t->misc_items + i)->type == 15U) {
#line 588
      goto case_9;
    }
#line 588
    if ((unsigned int )(t->misc_items + i)->type == 1U) {
#line 588
      goto case_9;
    }
#line 588
    if ((unsigned int )(t->misc_items + i)->type == 0U) {
#line 588
      goto case_9;
    }
#line 592
    goto switch_default;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 590
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 593
    restart_kom("clear_text_stat(): unknown enum info_type %d.", (unsigned int )(t->misc_items + i)->type);
    }
    switch_break: /* CIL Label */ ;
    }
#line 574
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 598
  sfree((void *)t->misc_items);
#line 599
  free_aux_item_list(& t->aux_item_list);
#line 600
  init_text_stat(t);
  }
#line 601
  return;
}
}
#line 603 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
Text_stat *copy_text_stat(Text_stat const   *t ) 
{ 
  Text_stat *c ;
  void *tmp ;

  {
  {
#line 608
  c = alloc_text_stat();
#line 609
  c->creation_time = (Time )t->creation_time;
#line 610
  c->file_pos = (long )t->file_pos;
#line 611
  c->author = (Pers_no )t->author;
#line 612
  c->no_of_lines = (unsigned short )t->no_of_lines;
#line 613
  c->no_of_chars = (String_size )t->no_of_chars;
#line 614
  c->no_of_marks = (unsigned short )t->no_of_marks;
#line 615
  c->no_of_misc = (unsigned short )t->no_of_misc;
#line 616
  c->highest_aux = (unsigned long )t->highest_aux;
#line 617
  tmp = smalloc((unsigned long )c->no_of_misc * sizeof(Misc_info ));
#line 617
  c->misc_items = (Misc_info *)tmp;
#line 618
  memcpy((void */* __restrict  */)c->misc_items, (void const   */* __restrict  */)t->misc_items,
         (unsigned long )c->no_of_misc * sizeof(Misc_info ));
#line 619
  copy_aux_item_list(& c->aux_item_list, & t->aux_item_list);
  }
#line 621
  return (c);
}
}
#line 624 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_text_stat(Text_stat *t ) 
{ 


  {
  {
#line 627
  t->creation_time = (time_t )0;
#line 628
  t->file_pos = 0L;
#line 629
  t->author = (Pers_no )0;
#line 630
  t->no_of_lines = (unsigned short)0;
#line 631
  t->no_of_chars = (String_size )0;
#line 632
  t->no_of_marks = (unsigned short)0;
#line 633
  t->no_of_misc = (unsigned short)0;
#line 634
  t->highest_aux = 0UL;
#line 635
  t->misc_items = (Misc_info *)((void *)0);
#line 636
  init_aux_item_list(& t->aux_item_list);
  }
#line 637
  return;
}
}
#line 641 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_struct_tm(struct tm *t ) 
{ 


  {
#line 644
  t->tm_sec = 0;
#line 645
  t->tm_min = 0;
#line 646
  t->tm_hour = 0;
#line 647
  t->tm_mday = 0;
#line 648
  t->tm_mon = 0;
#line 649
  t->tm_year = 0;
#line 650
  t->tm_wday = 0;
#line 651
  t->tm_yday = 0;
#line 652
  t->tm_isdst = 0;
#line 653
  return;
}
}
#line 657 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_who_info(Who_info *w ) 
{ 


  {
#line 660
  w->person = (Pers_no )0;
#line 661
  w->what_am_i_doing = (String )EMPTY_STRING;
#line 662
  w->username = (String )EMPTY_STRING;
#line 663
  w->working_conference = (Conf_no )0;
#line 664
  w->session_no = (Session_no )0;
#line 665
  return;
}
}
#line 669 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_who_info_ident(Who_info_ident *w ) 
{ 


  {
#line 672
  w->person = (Pers_no )0;
#line 673
  w->what_am_i_doing = (String )EMPTY_STRING;
#line 674
  w->username = (String )EMPTY_STRING;
#line 675
  w->ident_user = (String )EMPTY_STRING;
#line 676
  w->hostname = (String )EMPTY_STRING;
#line 677
  w->working_conference = (Conf_no )0;
#line 678
  w->session_no = (Session_no )0;
#line 679
  return;
}
}
#line 683 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_who_info_old(Who_info_old *w ) 
{ 


  {
#line 686
  w->person = (Pers_no )0;
#line 687
  w->what_am_i_doing = (String )EMPTY_STRING;
#line 688
  w->working_conference = (Conf_no )0;
#line 689
  return;
}
}
#line 693 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void free_aux_item_list(Aux_item_list *list ) 
{ 
  unsigned long i ;

  {
#line 698
  if ((unsigned long )list->items != (unsigned long )((void *)0)) {
#line 700
    i = 0UL;
    {
#line 700
    while (1) {
      while_continue: /* CIL Label */ ;
#line 700
      if (! (i < (unsigned long )list->length)) {
#line 700
        goto while_break;
      }
      {
#line 701
      clear_aux_item(list->items + i);
#line 700
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 703
  list->length = (unsigned short)0;
#line 704
  sfree((void *)list->items);
#line 705
  list->items = (Aux_item *)((void *)0);
  }
#line 706
  return;
}
}
#line 708 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static void copy_aux_item_list(Aux_item_list *dest , Aux_item_list const   *src ) 
{ 
  unsigned long i ;
  void *tmp ;

  {
  {
#line 714
  dest->length = (unsigned short )src->length;
#line 715
  tmp = smalloc(sizeof(Aux_item ) * (unsigned long )src->length);
#line 715
  dest->items = (Aux_item *)tmp;
#line 716
  i = 0UL;
  }
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! (i < (unsigned long )src->length)) {
#line 716
      goto while_break;
    }
    {
#line 718
    copy_aux_item(dest->items + i, (Aux_item const   *)(src->items + i));
#line 716
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 720
  return;
}
}
#line 722 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_aux_item_list(Aux_item_list *list ) 
{ 


  {
#line 725
  list->length = (unsigned short)0;
#line 726
  list->items = (Aux_item *)((void *)0);
#line 727
  return;
}
}
#line 729 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_aux_item_link(Aux_item_link *dest ) 
{ 


  {
#line 732
  dest->target_type = (enum object_type )0;
#line 733
  dest->target_item = 0UL;
#line 734
  dest->target_object.conf = (Conf_no )0;
#line 735
  dest->target_object.text = (Text_no )0;
#line 736
  return;
}
}
#line 738 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_aux_item_flags(Aux_item_flags *dest ) 
{ 


  {
#line 741
  dest->deleted = 0U;
#line 742
  dest->inherit = 0U;
#line 743
  dest->secret = 0U;
#line 744
  dest->hide_creator = 0U;
#line 745
  dest->dont_garb = 0U;
#line 746
  dest->reserved3 = 0U;
#line 747
  dest->reserved4 = 0U;
#line 748
  dest->reserved5 = 0U;
#line 749
  return;
}
}
#line 752 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void init_aux_item(Aux_item *dest ) 
{ 


  {
  {
#line 755
  dest->aux_no = 0UL;
#line 756
  dest->creator = (Pers_no )0;
#line 757
  dest->sent_at = (Time )0;
#line 758
  dest->inherit_limit = 0UL;
#line 759
  dest->tag = 0UL;
#line 760
  dest->data = (String )EMPTY_STRING;
#line 761
  init_aux_item_flags(& dest->flags);
#line 762
  init_aux_item_link(& dest->linked_item);
  }
#line 763
  return;
}
}
#line 765 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void clear_aux_item(Aux_item *item ) 
{ 


  {
  {
#line 768
  s_clear(& item->data);
#line 769
  init_aux_item(item);
  }
#line 770
  return;
}
}
#line 772 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void copy_aux_item(Aux_item *dest , Aux_item const   *src ) 
{ 


  {
  {
#line 775
  dest->aux_no = (unsigned long )src->aux_no;
#line 776
  dest->creator = (Pers_no )src->creator;
#line 777
  dest->sent_at = (Time )src->sent_at;
#line 778
  dest->flags = (Aux_item_flags )src->flags;
#line 779
  dest->inherit_limit = (unsigned long )src->inherit_limit;
#line 780
  dest->tag = (unsigned long )src->tag;
#line 781
  dest->data = (String )EMPTY_STRING;
#line 782
  s_strcpy(& dest->data, src->data);
#line 783
  dest->linked_item = (Aux_item_link )src->linked_item;
  }
#line 784
  return;
}
}
#line 790 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
void dump_alloc_counts(FILE *fp ) 
{ 


  {
  {
#line 793
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"---memory.c:\n\tperson:          %d\n\tconference:      %d\n",
          person_cnt, conference_cnt);
#line 795
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\ttext_stat:       %d\n",
          text_stat_cnt);
  }
#line 796
  return;
}
}
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 223 "./../libraries/libisc-new/src/isc.h"
extern int isc_write(struct isc_scb *scb , void const   *buffer , size_t length ) ;
#line 233
extern int isc_putc(int chr , struct isc_scb *scb ) ;
#line 240
extern int isc_puts(char const   *str , struct isc_scb *scb ) ;
#line 247
extern int isc_putul(unsigned long nr , struct isc_scb *scb ) ;
#line 29 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.h"
void prot_a_output_ul(Connection *fp , unsigned long ul ) ;
#line 33
void prot_a_output_person(Connection *fp , Person *person ) ;
#line 42
void prot_a_output_membership(Connection *fp , Membership const   *mship ) ;
#line 46
void prot_a_output_membership_10(Connection *fp , Membership const   *mship ) ;
#line 50
void prot_a_output_membership_old(Connection *fp , Membership const   *mship ) ;
#line 54
void prot_a_output_membership_list(Connection *fp , Membership_list mlist ) ;
#line 58
void prot_a_output_membership_list_10(Connection *fp , Membership_list mlist ) ;
#line 62
void prot_a_output_membership_list_old(Connection *fp , Membership_list mlist ) ;
#line 66
void prot_a_output_membership_type(Connection *fp , Membership_type const   type ) ;
#line 70
void prot_a_output_conf_list(Connection *fp , Conf_list_old conf_list ) ;
#line 74
void prot_a_output_conf_no_list(Connection *fp , Conf_no_list conf_no_list ) ;
#line 78
void prot_a_output_conference(Connection *fp , Conference *conf_c ) ;
#line 82
void prot_a_output_conference_old(Connection *fp , Conference *conf_c ) ;
#line 86
void prot_a_output_uconference(Connection *fp , Small_conf *conf_c ) ;
#line 90
void prot_a_output_mark_list(Connection *fp , Mark_list mark_list ) ;
#line 94
void prot_a_output_aux_item_flags(Connection *fp , Aux_item_flags flags ) ;
#line 98
void prot_a_output_aux_item(Connection *fp , Aux_item *item ) ;
#line 102
void prot_a_output_aux_item_list(Connection *fp , Aux_item_list *aux ) ;
#line 106
void prot_a_output_text_stat_old(Connection *fp , Text_stat *t_stat ) ;
#line 110
void prot_a_output_text_stat(Connection *fp , Text_stat *t_stat ) ;
#line 114
void prot_a_output_info(Connection *fp , Info *info ) ;
#line 118
void prot_a_output_info_old(Connection *fp , Info *info ) ;
#line 122
void prot_a_output_who_info(Connection *fp , Who_info *info ) ;
#line 126
void prot_a_output_who_info_list(Connection *fp , Who_info_list info ) ;
#line 130
void prot_a_output_who_info_ident_list(Connection *fp , Who_info_ident_list info ) ;
#line 134
void prot_a_output_who_info_list_old(Connection *fp , Who_info_list_old info ) ;
#line 138
void prot_a_output_session_info(Connection *fp , Session_info *info ) ;
#line 142
void prot_a_output_session_info_ident(Connection *fp , Session_info_ident *info ) ;
#line 146
extern void prot_a_output_string(Connection *fp , String str ) ;
#line 150
extern void prot_a_output_priv_bits(Connection *fp , Priv_bits bits ) ;
#line 154
extern void prot_a_output_personal_flags(Connection *fp , Personal_flags flags ) ;
#line 159
extern void prot_a_output_conf_type(Connection *fp , Conf_type type ) ;
#line 163
extern void prot_a_output_extended_conf_type(Connection *fp , Conf_type type ) ;
#line 167
extern void prot_a_output_member_list(Connection *fp , Member_list m_list ) ;
#line 171
extern void prot_a_output_member_list_old(Connection *fp , Member_list m_list ) ;
#line 175
extern void prot_a_output_mark(Connection *fp , Mark mark ) ;
#line 179
extern void prot_a_output_misc_info(Connection *fp , Misc_info misc ) ;
#line 183
void prot_a_output_member(Connection *fp , Member member ) ;
#line 187
void prot_a_output_member_old(Connection *fp , Member member ) ;
#line 191
void prot_a_output_time(Connection *fp , time_t clk ) ;
#line 195
void prot_a_output_session_no(Connection *fp , Session_no session_no ) ;
#line 199
void prot_a_output_text_no(Connection *fp , Text_no text ) ;
#line 203
void prot_a_output_conf_no(Connection *fp , Conf_no conf ) ;
#line 207
extern void prot_a_output_conf_z_info_list(Connection *fp , Conf_z_info_list c_list ) ;
#line 211
void prot_a_output_version_info(Connection *fp , Version_info *v_info ) ;
#line 215
void prot_a_output_num_list(Connection *fp , Number_list *num_list ) ;
#line 219
void prot_a_output_static_session_info(Connection *fp , Static_session_info *info ) ;
#line 223
void prot_a_output_dynamic_session_info_list(Connection *fp , Dynamic_session_info_list *list ) ;
#line 226
void prot_a_output_l2g_iterator_as_text_list(Connection *fp , L2g_iterator *iter ) ;
#line 230
void prot_a_output_text_mapping(Connection *fp , Text_mapping *map ) ;
#line 234
void prot_a_output_text_mapping_reverse(Connection *fp , Text_mapping_reverse *map ) ;
#line 238
void prot_a_output_stats_description(Connection *fp , Stats_description *result ) ;
#line 242
void prot_a_output_stats_list(Connection *fp , Stats_list const   *result ) ;
#line 246
void prot_a_output_static_server_info(Connection *fp , Static_server_info const   *result ) ;
#line 250
void prot_a_output_scheduling_info(Connection *fp , Scheduling_info const   *result ) ;
#line 127 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.h"
void l2gi_next(L2g_iterator *l2gi ) ;
#line 132
Local_text_no l2gi_end(L2g_iterator const   *l2gi ) ;
#line 137
Local_text_no l2gi_begin(L2g_iterator const   *l2gi ) ;
#line 171
void l2gi_searchsome_reverse(L2g_reverse_iterator *l2gi , Local_to_global const   *l2g ,
                             Local_text_no begin , Local_text_no end ) ;
#line 177
void l2gi_prev(L2g_reverse_iterator *l2gi ) ;
#line 59 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_ul(Connection *fp , unsigned long ul ) 
{ 


  {
  {
#line 63
  isc_putc(' ', fp->isc_session);
#line 64
  isc_putul(ul, fp->isc_session);
  }
#line 65
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
static void prot_a_output_float(Connection *fp , float v ) 
{ 
  char buf___4[80] ;

  {
  {
#line 74
  snprintf((char */* __restrict  */)(buf___4), sizeof(buf___4), (char const   */* __restrict  */)" %g",
           (double )v);
#line 79
  isc_puts((char const   *)(buf___4), fp->isc_session);
  }
#line 80
  return;
}
}
#line 82 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_person(Connection *fp , Person *person ) 
{ 
  Local_text_no first_created ;
  Local_text_no tmp ;
  Local_text_no uncreated ;
  Local_text_no tmp___0 ;
  Local_text_no num_created ;

  {
  {
#line 86
  tmp = l2g_next_key((Local_to_global const   *)(& person->created_texts), (Local_text_no )0);
#line 86
  first_created = tmp;
#line 87
  tmp___0 = l2g_first_appendable_key((Local_to_global const   *)(& person->created_texts));
#line 87
  uncreated = tmp___0;
  }
#line 90
  if (first_created == 0UL) {
#line 91
    first_created = uncreated;
  }
  {
#line 93
  num_created = uncreated - first_created;
#line 95
  prot_a_output_string(fp, person->username);
#line 96
  prot_a_output_priv_bits(fp, person->privileges);
#line 97
  prot_a_output_personal_flags(fp, person->flags);
#line 99
  prot_a_output_time(fp, person->last_login);
#line 101
  prot_a_output_ul(fp, person->user_area);
#line 102
  prot_a_output_ul(fp, person->total_time_present);
#line 103
  prot_a_output_ul(fp, person->sessions);
#line 104
  prot_a_output_ul(fp, person->created_lines);
#line 105
  prot_a_output_ul(fp, person->created_bytes);
#line 106
  prot_a_output_ul(fp, person->read_texts);
#line 107
  prot_a_output_ul(fp, person->no_of_text_fetches);
#line 108
  prot_a_output_ul(fp, (unsigned long )person->created_persons);
#line 109
  prot_a_output_ul(fp, (unsigned long )person->created_confs);
#line 110
  prot_a_output_ul(fp, first_created);
#line 111
  prot_a_output_ul(fp, num_created);
#line 112
  prot_a_output_ul(fp, (unsigned long )person->marks.no_of_marks);
#line 113
  prot_a_output_ul(fp, (unsigned long )person->conferences.no_of_confs);
  }
#line 114
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_membership_type(Connection *fp , Membership_type const   type ) 
{ 


  {
  {
#line 119
  isc_putc(' ', fp->isc_session);
#line 120
  isc_putc((int )(type.invitation + 48U), fp->isc_session);
#line 121
  isc_putc((int )(type.passive + 48U), fp->isc_session);
#line 122
  isc_putc((int )(type.secret + 48U), fp->isc_session);
#line 123
  isc_putc((int )(type.passive_message_invert + 48U), fp->isc_session);
#line 124
  isc_putc((int )(type.reserved2 + 48U), fp->isc_session);
#line 125
  isc_putc((int )(type.reserved3 + 48U), fp->isc_session);
#line 126
  isc_putc((int )(type.reserved4 + 48U), fp->isc_session);
#line 127
  isc_putc((int )(type.reserved5 + 48U), fp->isc_session);
  }
#line 128
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_membership(Connection *fp , Membership const   *mship ) 
{ 
  unsigned int i ;

  {
  {
#line 136
  prot_a_output_ul(fp, (unsigned long )mship->position);
#line 137
  prot_a_output_time(fp, (time_t )mship->last_time_read);
#line 138
  prot_a_output_ul(fp, (unsigned long )mship->conf_no);
#line 139
  prot_a_output_ul(fp, (unsigned long )mship->priority);
#line 141
  prot_a_output_ul(fp, (unsigned long )mship->no_of_read_ranges);
  }
#line 142
  if ((unsigned long )mship->read_ranges != (unsigned long )((void *)0)) {
#line 142
    if (mship->no_of_read_ranges > 0U) {
      {
#line 144
      isc_puts(" {", fp->isc_session);
#line 145
      i = 0U;
      }
      {
#line 145
      while (1) {
        while_continue: /* CIL Label */ ;
#line 145
        if (! (i < (unsigned int )mship->no_of_read_ranges)) {
#line 145
          goto while_break;
        }
        {
#line 147
        prot_a_output_ul(fp, (mship->read_ranges + i)->first_read);
#line 148
        prot_a_output_ul(fp, (mship->read_ranges + i)->last_read);
#line 145
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 150
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 153
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 153
    isc_puts(" *", fp->isc_session);
    }
  }
  {
#line 155
  prot_a_output_ul(fp, (unsigned long )mship->added_by);
#line 156
  prot_a_output_time(fp, (time_t )mship->added_at);
#line 157
  prot_a_output_membership_type(fp, mship->type);
  }
#line 158
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_membership_10(Connection *fp , Membership const   *mship ) 
{ 


  {
  {
#line 164
  prot_a_output_ul(fp, (unsigned long )mship->position);
#line 165
  prot_a_output_membership_old(fp, mship);
#line 166
  prot_a_output_ul(fp, (unsigned long )mship->added_by);
#line 167
  prot_a_output_time(fp, (time_t )mship->added_at);
#line 168
  prot_a_output_membership_type(fp, mship->type);
  }
#line 169
  return;
}
}
#line 171 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
static void prot_a_output_read_texts(Connection *fp , Membership const   *mship ) 
{ 
  struct read_range *begin ;
  struct read_range *end ;
  unsigned long no_of_read ;
  struct read_range  const  *ptr ;
  Local_text_no lno ;

  {
#line 175
  if ((unsigned long )mship->read_ranges == (unsigned long )((void *)0)) {
    {
#line 176
    isc_puts(" 0 0 *", fp->isc_session);
    }
  } else {
#line 182
    if (! ((unsigned long )mship->read_ranges != (unsigned long )((void *)0))) {
      {
#line 182
      __assert_fail("mship->read_ranges != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c",
                    182U, "prot_a_output_read_texts");
      }
    }
#line 183
    if (! (mship->no_of_read_ranges > 0U)) {
      {
#line 183
      __assert_fail("mship->no_of_read_ranges > 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c",
                    183U, "prot_a_output_read_texts");
      }
    }
#line 185
    begin = mship->read_ranges + 0;
#line 186
    end = begin + mship->no_of_read_ranges;
#line 188
    if (begin->first_read == 1UL) {
      {
#line 190
      prot_a_output_ul(fp, begin->last_read);
#line 191
      begin ++;
      }
    } else {
      {
#line 194
      isc_puts(" 0", fp->isc_session);
      }
    }
#line 196
    if ((unsigned long )begin == (unsigned long )end) {
      {
#line 197
      isc_puts(" 0 *", fp->isc_session);
      }
    } else {
#line 200
      no_of_read = 0UL;
#line 203
      ptr = (struct read_range  const  *)begin;
      {
#line 203
      while (1) {
        while_continue: /* CIL Label */ ;
#line 203
        if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 203
          goto while_break;
        }
#line 204
        no_of_read += (unsigned long )((ptr->last_read - ptr->first_read) + 1UL);
#line 203
        ptr ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 206
      prot_a_output_ul(fp, no_of_read);
      }
#line 207
      if (mship->skip_read_texts) {
        {
#line 208
        isc_puts(" *", fp->isc_session);
        }
      } else {
        {
#line 211
        isc_puts(" {", fp->isc_session);
#line 213
        ptr = (struct read_range  const  *)begin;
        }
        {
#line 213
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 213
          if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 213
            goto while_break___0;
          }
#line 217
          lno = (Local_text_no )ptr->first_read;
          {
#line 217
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 217
            if (! (lno <= (Local_text_no )ptr->last_read)) {
#line 217
              goto while_break___1;
            }
            {
#line 218
            prot_a_output_ul(fp, lno);
#line 217
            lno ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 213
          ptr ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 221
        isc_puts(" }", fp->isc_session);
        }
      }
    }
  }
#line 225
  return;
}
}
#line 227 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_membership_old(Connection *fp , Membership const   *mship ) 
{ 


  {
  {
#line 231
  prot_a_output_time(fp, (time_t )mship->last_time_read);
#line 232
  prot_a_output_ul(fp, (unsigned long )mship->conf_no);
#line 233
  prot_a_output_ul(fp, (unsigned long )mship->priority);
#line 234
  prot_a_output_read_texts(fp, mship);
  }
#line 235
  return;
}
}
#line 238 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_membership_list(Connection *fp , Membership_list mlist ) 
{ 
  int i ;

  {
  {
#line 244
  prot_a_output_ul(fp, (unsigned long )mlist.no_of_confs);
  }
#line 246
  if ((unsigned long )mlist.confs != (unsigned long )((void *)0)) {
#line 246
    if ((int )mlist.no_of_confs > 0) {
      {
#line 248
      isc_puts(" {", fp->isc_session);
#line 249
      i = 0;
      }
      {
#line 249
      while (1) {
        while_continue: /* CIL Label */ ;
#line 249
        if (! (i < (int )mlist.no_of_confs)) {
#line 249
          goto while_break;
        }
        {
#line 250
        prot_a_output_membership(fp, (Membership const   *)(mlist.confs + i));
#line 249
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 251
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 254
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 254
    isc_puts(" *", fp->isc_session);
    }
  }
#line 255
  return;
}
}
#line 257 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_membership_list_old(Connection *fp , Membership_list mlist ) 
{ 
  int i ;

  {
  {
#line 263
  prot_a_output_ul(fp, (unsigned long )mlist.no_of_confs);
  }
#line 265
  if ((unsigned long )mlist.confs != (unsigned long )((void *)0)) {
#line 265
    if ((int )mlist.no_of_confs > 0) {
      {
#line 267
      isc_puts(" {", fp->isc_session);
#line 268
      i = 0;
      }
      {
#line 268
      while (1) {
        while_continue: /* CIL Label */ ;
#line 268
        if (! (i < (int )mlist.no_of_confs)) {
#line 268
          goto while_break;
        }
        {
#line 269
        prot_a_output_membership_old(fp, (Membership const   *)(mlist.confs + i));
#line 268
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 270
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 273
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 273
    isc_puts(" *", fp->isc_session);
    }
  }
#line 274
  return;
}
}
#line 276 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_membership_list_10(Connection *fp , Membership_list mlist ) 
{ 
  int i ;

  {
  {
#line 282
  prot_a_output_ul(fp, (unsigned long )mlist.no_of_confs);
  }
#line 284
  if ((unsigned long )mlist.confs != (unsigned long )((void *)0)) {
#line 284
    if ((int )mlist.no_of_confs > 0) {
      {
#line 286
      isc_puts(" {", fp->isc_session);
#line 287
      i = 0;
      }
      {
#line 287
      while (1) {
        while_continue: /* CIL Label */ ;
#line 287
        if (! (i < (int )mlist.no_of_confs)) {
#line 287
          goto while_break;
        }
        {
#line 288
        prot_a_output_membership_10(fp, (Membership const   *)(mlist.confs + i));
#line 287
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 289
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 292
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 292
    isc_puts(" *", fp->isc_session);
    }
  }
#line 293
  return;
}
}
#line 295 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_conf_list(Connection *fp , Conf_list_old conf_list ) 
{ 
  unsigned long i ;

  {
  {
#line 301
  prot_a_output_ul(fp, conf_list.no_of_conf_nos);
  }
#line 302
  if ((unsigned long )conf_list.conf_nos != (unsigned long )((void *)0)) {
#line 302
    if (conf_list.no_of_conf_nos > 0UL) {
      {
#line 304
      isc_puts(" {", fp->isc_session);
#line 305
      i = 0UL;
      }
      {
#line 305
      while (1) {
        while_continue: /* CIL Label */ ;
#line 305
        if (! (i < conf_list.no_of_conf_nos)) {
#line 305
          goto while_break;
        }
        {
#line 306
        prot_a_output_ul(fp, (unsigned long )*(conf_list.conf_nos + i));
#line 305
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 307
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 310
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 310
    isc_puts(" *", fp->isc_session);
    }
  }
#line 312
  if ((unsigned long )conf_list.type_of_conf != (unsigned long )((void *)0)) {
#line 312
    if (conf_list.no_of_conf_nos > 0UL) {
      {
#line 314
      isc_puts(" {", fp->isc_session);
#line 315
      i = 0UL;
      }
      {
#line 315
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 315
        if (! (i < conf_list.no_of_conf_nos)) {
#line 315
          goto while_break___0;
        }
        {
#line 316
        prot_a_output_conf_type(fp, *(conf_list.type_of_conf + i));
#line 315
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 317
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 320
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 320
    isc_puts(" *", fp->isc_session);
    }
  }
#line 321
  return;
}
}
#line 323 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_conf_no_list(Connection *fp , Conf_no_list conf_no_list ) 
{ 
  int i ;

  {
  {
#line 329
  prot_a_output_ul(fp, (unsigned long )conf_no_list.no_of_confs);
  }
#line 330
  if ((unsigned long )conf_no_list.conf_nos != (unsigned long )((void *)0)) {
#line 330
    if ((int )conf_no_list.no_of_confs > 0) {
      {
#line 332
      isc_puts(" {", fp->isc_session);
#line 333
      i = 0;
      }
      {
#line 333
      while (1) {
        while_continue: /* CIL Label */ ;
#line 333
        if (! (i < (int )conf_no_list.no_of_confs)) {
#line 333
          goto while_break;
        }
        {
#line 334
        prot_a_output_ul(fp, (unsigned long )*(conf_no_list.conf_nos + i));
#line 333
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 335
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 338
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 338
    isc_puts(" *", fp->isc_session);
    }
  }
#line 339
  return;
}
}
#line 342 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_conference(Connection *fp , Conference *conf_c ) 
{ 
  Local_text_no first_local_no ;
  Local_text_no tmp ;
  Local_text_no uncreated ;
  Local_text_no tmp___0 ;
  Local_text_no no_of_texts ;

  {
  {
#line 346
  tmp = l2g_next_key((Local_to_global const   *)(& conf_c->texts), (Local_text_no )0);
#line 346
  first_local_no = tmp;
#line 347
  tmp___0 = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
#line 347
  uncreated = tmp___0;
  }
#line 350
  if (first_local_no == 0UL) {
#line 351
    first_local_no = uncreated;
  }
  {
#line 353
  no_of_texts = uncreated - first_local_no;
#line 355
  prot_a_output_string(fp, conf_c->name);
#line 356
  prot_a_output_extended_conf_type(fp, conf_c->type);
#line 357
  prot_a_output_time(fp, conf_c->creation_time);
#line 358
  prot_a_output_time(fp, conf_c->last_written);
#line 359
  prot_a_output_ul(fp, (unsigned long )conf_c->creator);
#line 360
  prot_a_output_ul(fp, conf_c->presentation);
#line 361
  prot_a_output_ul(fp, (unsigned long )conf_c->supervisor);
#line 362
  prot_a_output_ul(fp, (unsigned long )conf_c->permitted_submitters);
#line 363
  prot_a_output_ul(fp, (unsigned long )conf_c->super_conf);
#line 364
  prot_a_output_ul(fp, conf_c->msg_of_day);
#line 365
  prot_a_output_ul(fp, conf_c->nice);
#line 366
  prot_a_output_ul(fp, conf_c->keep_commented);
#line 367
  prot_a_output_ul(fp, (unsigned long )conf_c->members.no_of_members);
#line 368
  prot_a_output_ul(fp, first_local_no);
#line 369
  prot_a_output_ul(fp, no_of_texts);
#line 370
  prot_a_output_ul(fp, conf_c->expire);
#line 371
  prot_a_output_aux_item_list(fp, & conf_c->aux_item_list);
  }
#line 372
  return;
}
}
#line 374 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_conference_old(Connection *fp , Conference *conf_c ) 
{ 
  Local_text_no first_local_no ;
  Local_text_no tmp ;
  Local_text_no uncreated ;
  Local_text_no tmp___0 ;
  Local_text_no no_of_texts ;

  {
  {
#line 378
  tmp = l2g_next_key((Local_to_global const   *)(& conf_c->texts), (Local_text_no )0);
#line 378
  first_local_no = tmp;
#line 379
  tmp___0 = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
#line 379
  uncreated = tmp___0;
  }
#line 382
  if (first_local_no == 0UL) {
#line 383
    first_local_no = uncreated;
  }
  {
#line 385
  no_of_texts = uncreated - first_local_no;
#line 387
  prot_a_output_string(fp, conf_c->name);
#line 389
  prot_a_output_conf_type(fp, conf_c->type);
#line 391
  prot_a_output_time(fp, conf_c->creation_time);
#line 392
  prot_a_output_time(fp, conf_c->last_written);
#line 394
  prot_a_output_ul(fp, (unsigned long )conf_c->creator);
#line 395
  prot_a_output_ul(fp, conf_c->presentation);
#line 396
  prot_a_output_ul(fp, (unsigned long )conf_c->supervisor);
#line 397
  prot_a_output_ul(fp, (unsigned long )conf_c->permitted_submitters);
#line 398
  prot_a_output_ul(fp, (unsigned long )conf_c->super_conf);
#line 399
  prot_a_output_ul(fp, conf_c->msg_of_day);
#line 400
  prot_a_output_ul(fp, conf_c->nice);
#line 401
  prot_a_output_ul(fp, (unsigned long )conf_c->members.no_of_members);
#line 402
  prot_a_output_ul(fp, first_local_no);
#line 403
  prot_a_output_ul(fp, no_of_texts);
  }
#line 404
  return;
}
}
#line 406 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_uconference(Connection *fp , Small_conf *conf_c ) 
{ 


  {
  {
#line 409
  prot_a_output_string(fp, conf_c->name);
#line 410
  prot_a_output_extended_conf_type(fp, conf_c->type);
#line 411
  prot_a_output_ul(fp, conf_c->highest_local_no);
#line 412
  prot_a_output_ul(fp, conf_c->nice);
  }
#line 413
  return;
}
}
#line 416 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_mark_list(Connection *fp , Mark_list mark_list ) 
{ 
  int i ;

  {
  {
#line 422
  prot_a_output_ul(fp, (unsigned long )mark_list.no_of_marks);
  }
#line 424
  if ((unsigned long )mark_list.marks != (unsigned long )((void *)0)) {
#line 424
    if ((int )mark_list.no_of_marks > 0) {
      {
#line 426
      isc_puts(" {", fp->isc_session);
#line 427
      i = 0;
      }
      {
#line 427
      while (1) {
        while_continue: /* CIL Label */ ;
#line 427
        if (! (i < (int )mark_list.no_of_marks)) {
#line 427
          goto while_break;
        }
        {
#line 428
        prot_a_output_mark(fp, *(mark_list.marks + i));
#line 427
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 429
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 432
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 432
    isc_puts(" *", fp->isc_session);
    }
  }
#line 434
  return;
}
}
#line 436 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_aux_item_flags(Connection *fp , Aux_item_flags flags ) 
{ 


  {
  {
#line 440
  isc_putc(' ', fp->isc_session);
#line 441
  isc_putc((int )(flags.deleted + 48U), fp->isc_session);
#line 442
  isc_putc((int )(flags.inherit + 48U), fp->isc_session);
#line 443
  isc_putc((int )(flags.secret + 48U), fp->isc_session);
#line 444
  isc_putc((int )(flags.hide_creator + 48U), fp->isc_session);
#line 445
  isc_putc((int )(flags.dont_garb + 48U), fp->isc_session);
#line 446
  isc_putc((int )(flags.reserved3 + 48U), fp->isc_session);
#line 447
  isc_putc((int )(flags.reserved4 + 48U), fp->isc_session);
#line 448
  isc_putc((int )(flags.reserved5 + 48U), fp->isc_session);
  }
#line 449
  return;
}
}
#line 451 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_aux_item(Connection *fp , Aux_item *item ) 
{ 


  {
  {
#line 455
  prot_a_output_ul(fp, item->aux_no);
#line 456
  prot_a_output_ul(fp, item->tag);
#line 457
  prot_a_output_ul(fp, (unsigned long )item->creator);
#line 458
  prot_a_output_time(fp, item->sent_at);
#line 459
  prot_a_output_aux_item_flags(fp, item->flags);
#line 460
  prot_a_output_ul(fp, item->inherit_limit);
#line 461
  prot_a_output_string(fp, item->data);
  }
#line 462
  return;
}
}
#line 464 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_text_stat_old(Connection *fp , Text_stat *t_stat ) 
{ 
  int i ;

  {
  {
#line 470
  prot_a_output_time(fp, t_stat->creation_time);
#line 472
  prot_a_output_ul(fp, (unsigned long )t_stat->author);
#line 473
  prot_a_output_ul(fp, (unsigned long )t_stat->no_of_lines);
#line 474
  prot_a_output_ul(fp, (unsigned long )t_stat->no_of_chars);
#line 475
  prot_a_output_ul(fp, (unsigned long )t_stat->no_of_marks);
#line 476
  prot_a_output_ul(fp, (unsigned long )t_stat->no_of_misc);
  }
#line 478
  if ((unsigned long )t_stat->misc_items != (unsigned long )((void *)0)) {
#line 478
    if ((int )t_stat->no_of_misc > 0) {
      {
#line 480
      isc_puts(" {", fp->isc_session);
#line 481
      i = 0;
      }
      {
#line 481
      while (1) {
        while_continue: /* CIL Label */ ;
#line 481
        if (! (i < (int )t_stat->no_of_misc)) {
#line 481
          goto while_break;
        }
        {
#line 482
        prot_a_output_misc_info(fp, *(t_stat->misc_items + i));
#line 481
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 483
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 486
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 486
    isc_puts(" *", fp->isc_session);
    }
  }
#line 487
  return;
}
}
#line 489 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_aux_item_list(Connection *fp , Aux_item_list *aux ) 
{ 
  int i ;

  {
  {
#line 495
  prot_a_output_ul(fp, (unsigned long )aux->length);
  }
#line 497
  if ((unsigned long )aux->items != (unsigned long )((void *)0)) {
#line 497
    if ((int )aux->length > 0) {
      {
#line 499
      isc_puts(" {", fp->isc_session);
#line 500
      i = 0;
      }
      {
#line 500
      while (1) {
        while_continue: /* CIL Label */ ;
#line 500
        if (! (i < (int )aux->length)) {
#line 500
          goto while_break;
        }
        {
#line 501
        prot_a_output_aux_item(fp, aux->items + i);
#line 500
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 502
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 505
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 505
    isc_puts(" *", fp->isc_session);
    }
  }
#line 506
  return;
}
}
#line 508 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_text_stat(Connection *fp , Text_stat *t_stat ) 
{ 


  {
  {
#line 512
  prot_a_output_text_stat_old(fp, t_stat);
#line 513
  prot_a_output_aux_item_list(fp, & t_stat->aux_item_list);
  }
#line 514
  return;
}
}
#line 517 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
static void prot_a_output_who_info_ident(Connection *fp , Who_info_ident *info ) 
{ 


  {
  {
#line 521
  prot_a_output_ul(fp, (unsigned long )info->person);
#line 522
  prot_a_output_ul(fp, (unsigned long )info->working_conference);
#line 523
  prot_a_output_ul(fp, info->session_no);
#line 525
  prot_a_output_string(fp, info->what_am_i_doing);
#line 526
  prot_a_output_string(fp, info->username);
#line 527
  prot_a_output_string(fp, info->hostname);
#line 528
  prot_a_output_string(fp, info->ident_user);
  }
#line 529
  return;
}
}
#line 532 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_who_info(Connection *fp , Who_info *info ) 
{ 


  {
  {
#line 536
  prot_a_output_ul(fp, (unsigned long )info->person);
#line 537
  prot_a_output_ul(fp, (unsigned long )info->working_conference);
#line 538
  prot_a_output_ul(fp, info->session_no);
#line 540
  prot_a_output_string(fp, info->what_am_i_doing);
#line 541
  prot_a_output_string(fp, info->username);
  }
#line 542
  return;
}
}
#line 545 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_who_info_list(Connection *fp , Who_info_list info ) 
{ 
  int i ;

  {
  {
#line 551
  prot_a_output_ul(fp, (unsigned long )info.no_of_persons);
  }
#line 553
  if ((unsigned long )info.info != (unsigned long )((void *)0)) {
#line 553
    if (info.no_of_persons > 0) {
      {
#line 555
      isc_puts(" {", fp->isc_session);
#line 556
      i = 0;
      }
      {
#line 556
      while (1) {
        while_continue: /* CIL Label */ ;
#line 556
        if (! (i < info.no_of_persons)) {
#line 556
          goto while_break;
        }
        {
#line 558
        prot_a_output_who_info(fp, info.info + i);
#line 561
        s_clear(& (info.info + i)->username);
#line 556
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 563
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 566
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 566
    isc_puts(" *", fp->isc_session);
    }
  }
#line 567
  return;
}
}
#line 569 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_who_info_ident_list(Connection *fp , Who_info_ident_list info ) 
{ 
  int i ;

  {
  {
#line 575
  prot_a_output_ul(fp, (unsigned long )info.no_of_persons);
  }
#line 577
  if ((unsigned long )info.info != (unsigned long )((void *)0)) {
#line 577
    if (info.no_of_persons > 0) {
      {
#line 579
      isc_puts(" {", fp->isc_session);
#line 580
      i = 0;
      }
      {
#line 580
      while (1) {
        while_continue: /* CIL Label */ ;
#line 580
        if (! (i < info.no_of_persons)) {
#line 580
          goto while_break;
        }
        {
#line 582
        prot_a_output_who_info_ident(fp, info.info + i);
#line 580
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 584
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 587
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 587
    isc_puts(" *", fp->isc_session);
    }
  }
#line 588
  return;
}
}
#line 590 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_who_info_list_old(Connection *fp , Who_info_list_old info ) 
{ 
  int i ;

  {
  {
#line 596
  prot_a_output_ul(fp, (unsigned long )info.no_of_persons);
  }
#line 598
  if ((unsigned long )info.info != (unsigned long )((void *)0)) {
#line 598
    if (info.no_of_persons > 0) {
      {
#line 600
      isc_puts(" {", fp->isc_session);
#line 601
      i = 0;
      }
      {
#line 601
      while (1) {
        while_continue: /* CIL Label */ ;
#line 601
        if (! (i < info.no_of_persons)) {
#line 601
          goto while_break;
        }
        {
#line 603
        prot_a_output_ul(fp, (unsigned long )(info.info + i)->person);
#line 604
        prot_a_output_ul(fp, (unsigned long )(info.info + i)->working_conference);
#line 606
        prot_a_output_string(fp, (info.info + i)->what_am_i_doing);
#line 601
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 608
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 611
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 611
    isc_puts(" *", fp->isc_session);
    }
  }
#line 612
  return;
}
}
#line 614 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_session_info(Connection *fp , Session_info *info ) 
{ 


  {
  {
#line 618
  prot_a_output_ul(fp, (unsigned long )info->person);
#line 619
  prot_a_output_ul(fp, (unsigned long )info->working_conference);
#line 620
  prot_a_output_ul(fp, info->session);
#line 622
  prot_a_output_string(fp, info->what_am_i_doing);
#line 623
  prot_a_output_string(fp, info->username);
#line 625
  prot_a_output_ul(fp, info->idle_time);
#line 626
  prot_a_output_time(fp, info->connection_time);
  }
#line 627
  return;
}
}
#line 629 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_session_info_ident(Connection *fp , Session_info_ident *info ) 
{ 


  {
  {
#line 633
  prot_a_output_ul(fp, (unsigned long )info->person);
#line 634
  prot_a_output_ul(fp, (unsigned long )info->working_conference);
#line 635
  prot_a_output_ul(fp, info->session);
#line 637
  prot_a_output_string(fp, info->what_am_i_doing);
#line 638
  prot_a_output_string(fp, info->username);
#line 639
  prot_a_output_string(fp, info->hostname);
#line 640
  prot_a_output_string(fp, info->ident_user);
#line 642
  prot_a_output_ul(fp, info->idle_time);
#line 643
  prot_a_output_time(fp, info->connection_time);
  }
#line 644
  return;
}
}
#line 646 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_info(Connection *fp , Info *info ) 
{ 


  {
  {
#line 650
  prot_a_output_info_old(fp, info);
#line 651
  prot_a_output_aux_item_list(fp, & info->aux_item_list);
  }
#line 652
  return;
}
}
#line 654 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_info_old(Connection *fp , Info *info ) 
{ 


  {
  {
#line 658
  prot_a_output_ul(fp, (unsigned long )info->version);
#line 659
  prot_a_output_ul(fp, (unsigned long )info->conf_pres_conf);
#line 660
  prot_a_output_ul(fp, (unsigned long )info->pers_pres_conf);
#line 661
  prot_a_output_ul(fp, (unsigned long )info->motd_conf);
#line 662
  prot_a_output_ul(fp, (unsigned long )info->kom_news_conf);
#line 663
  prot_a_output_ul(fp, info->motd_of_lyskom);
  }
#line 664
  return;
}
}
#line 667 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
extern void prot_a_output_string(Connection *fp , String str ) 
{ 


  {
  {
#line 671
  prot_a_output_ul(fp, (unsigned long )str.len);
#line 672
  isc_putc('H', fp->isc_session);
#line 673
  isc_write(fp->isc_session, (void const   *)str.string, (size_t )str.len);
  }
#line 674
  return;
}
}
#line 677 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
extern void prot_a_output_priv_bits(Connection *fp , Priv_bits bits ) 
{ 


  {
  {
#line 681
  isc_putc(' ', fp->isc_session);
#line 682
  isc_putc((int )(bits.wheel + 48U), fp->isc_session);
#line 683
  isc_putc((int )(bits.admin + 48U), fp->isc_session);
#line 684
  isc_putc((int )(bits.statistic + 48U), fp->isc_session);
#line 685
  isc_putc((int )(bits.create_pers + 48U), fp->isc_session);
#line 686
  isc_putc((int )(bits.create_conf + 48U), fp->isc_session);
#line 687
  isc_putc((int )(bits.change_name + 48U), fp->isc_session);
#line 688
  isc_putc((int )(bits.flg7 + 48U), fp->isc_session);
#line 689
  isc_putc((int )(bits.flg8 + 48U), fp->isc_session);
#line 690
  isc_putc((int )(bits.flg9 + 48U), fp->isc_session);
#line 691
  isc_putc((int )(bits.flg10 + 48U), fp->isc_session);
#line 692
  isc_putc((int )(bits.flg11 + 48U), fp->isc_session);
#line 693
  isc_putc((int )(bits.flg12 + 48U), fp->isc_session);
#line 694
  isc_putc((int )(bits.flg13 + 48U), fp->isc_session);
#line 695
  isc_putc((int )(bits.flg14 + 48U), fp->isc_session);
#line 696
  isc_putc((int )(bits.flg15 + 48U), fp->isc_session);
#line 697
  isc_putc((int )(bits.flg16 + 48U), fp->isc_session);
  }
#line 698
  return;
}
}
#line 701 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
extern void prot_a_output_personal_flags(Connection *fp , Personal_flags flags ) 
{ 


  {
  {
#line 705
  isc_putc(' ', fp->isc_session);
#line 706
  isc_putc((int )(flags.unread_is_secret + 48U), fp->isc_session);
#line 707
  isc_putc((int )(flags.flg2 + 48U), fp->isc_session);
#line 708
  isc_putc((int )(flags.flg3 + 48U), fp->isc_session);
#line 709
  isc_putc((int )(flags.flg4 + 48U), fp->isc_session);
#line 710
  isc_putc((int )(flags.flg5 + 48U), fp->isc_session);
#line 711
  isc_putc((int )(flags.flg6 + 48U), fp->isc_session);
#line 712
  isc_putc((int )(flags.flg7 + 48U), fp->isc_session);
#line 713
  isc_putc((int )(flags.flg8 + 48U), fp->isc_session);
  }
#line 714
  return;
}
}
#line 716 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
extern void prot_a_output_conf_type(Connection *fp , Conf_type type ) 
{ 


  {
  {
#line 720
  isc_putc(' ', fp->isc_session);
#line 721
  isc_putc((int )(type.rd_prot + 48U), fp->isc_session);
#line 722
  isc_putc((int )(type.original + 48U), fp->isc_session);
#line 723
  isc_putc((int )(type.secret + 48U), fp->isc_session);
#line 724
  isc_putc((int )(type.letter_box + 48U), fp->isc_session);
  }
#line 725
  return;
}
}
#line 727 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
extern void prot_a_output_extended_conf_type(Connection *fp , Conf_type type ) 
{ 


  {
  {
#line 731
  isc_putc(' ', fp->isc_session);
#line 732
  isc_putc((int )(type.rd_prot + 48U), fp->isc_session);
#line 733
  isc_putc((int )(type.original + 48U), fp->isc_session);
#line 734
  isc_putc((int )(type.secret + 48U), fp->isc_session);
#line 735
  isc_putc((int )(type.letter_box + 48U), fp->isc_session);
#line 736
  isc_putc((int )(type.allow_anon + 48U), fp->isc_session);
#line 737
  isc_putc((int )(type.forbid_secret + 48U), fp->isc_session);
#line 738
  isc_putc((int )(type.reserved2 + 48U), fp->isc_session);
#line 739
  isc_putc((int )(type.reserved3 + 48U), fp->isc_session);
  }
#line 740
  return;
}
}
#line 742 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
extern void prot_a_output_member_list(Connection *fp , Member_list m_list ) 
{ 
  int i ;

  {
  {
#line 748
  prot_a_output_ul(fp, (unsigned long )m_list.no_of_members);
  }
#line 749
  if ((unsigned long )m_list.members != (unsigned long )((void *)0)) {
#line 749
    if ((int )m_list.no_of_members > 0) {
      {
#line 751
      isc_puts(" {", fp->isc_session);
#line 752
      i = 0;
      }
      {
#line 752
      while (1) {
        while_continue: /* CIL Label */ ;
#line 752
        if (! (i < (int )m_list.no_of_members)) {
#line 752
          goto while_break;
        }
        {
#line 753
        prot_a_output_member(fp, *(m_list.members + i));
#line 752
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 754
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 757
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 757
    isc_puts(" *", fp->isc_session);
    }
  }
#line 758
  return;
}
}
#line 760 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
extern void prot_a_output_member_list_old(Connection *fp , Member_list m_list ) 
{ 
  int i ;

  {
  {
#line 766
  prot_a_output_ul(fp, (unsigned long )m_list.no_of_members);
  }
#line 767
  if ((unsigned long )m_list.members != (unsigned long )((void *)0)) {
#line 767
    if ((int )m_list.no_of_members > 0) {
      {
#line 769
      isc_puts(" {", fp->isc_session);
#line 770
      i = 0;
      }
      {
#line 770
      while (1) {
        while_continue: /* CIL Label */ ;
#line 770
        if (! (i < (int )m_list.no_of_members)) {
#line 770
          goto while_break;
        }
        {
#line 771
        prot_a_output_member_old(fp, *(m_list.members + i));
#line 770
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 772
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 775
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 775
    isc_puts(" *", fp->isc_session);
    }
  }
#line 776
  return;
}
}
#line 779 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_member(Connection *fp , Member member ) 
{ 


  {
  {
#line 783
  prot_a_output_ul(fp, (unsigned long )member.member);
#line 784
  prot_a_output_ul(fp, (unsigned long )member.added_by);
#line 785
  prot_a_output_time(fp, member.added_at);
#line 786
  prot_a_output_membership_type(fp, (Membership_type const   )member.type);
  }
#line 787
  return;
}
}
#line 789 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_member_old(Connection *fp , Member member ) 
{ 


  {
  {
#line 793
  prot_a_output_ul(fp, (unsigned long )member.member);
  }
#line 794
  return;
}
}
#line 797 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
extern void prot_a_output_mark(Connection *fp , Mark mark ) 
{ 


  {
  {
#line 801
  prot_a_output_ul(fp, mark.text_no);
#line 802
  prot_a_output_ul(fp, (unsigned long )mark.mark_type);
  }
#line 803
  return;
}
}
#line 806 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
extern void prot_a_output_misc_info(Connection *fp , Misc_info misc ) 
{ 


  {
  {
#line 810
  prot_a_output_ul(fp, (unsigned long )misc.type);
  }
  {
#line 816
  if ((unsigned int )misc.type == 15U) {
#line 816
    goto case_15;
  }
#line 816
  if ((unsigned int )misc.type == 1U) {
#line 816
    goto case_15;
  }
#line 816
  if ((unsigned int )misc.type == 0U) {
#line 816
    goto case_15;
  }
#line 820
  if ((unsigned int )misc.type == 6U) {
#line 820
    goto case_6;
  }
#line 824
  if ((unsigned int )misc.type == 7U) {
#line 824
    goto case_7;
  }
#line 831
  if ((unsigned int )misc.type == 5U) {
#line 831
    goto case_5;
  }
#line 831
  if ((unsigned int )misc.type == 4U) {
#line 831
    goto case_5;
  }
#line 831
  if ((unsigned int )misc.type == 3U) {
#line 831
    goto case_5;
  }
#line 831
  if ((unsigned int )misc.type == 2U) {
#line 831
    goto case_5;
  }
#line 835
  if ((unsigned int )misc.type == 8U) {
#line 835
    goto case_8;
  }
#line 839
  if ((unsigned int )misc.type == 9U) {
#line 839
    goto case_9;
  }
#line 844
  goto switch_default;
  case_15: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 817
  prot_a_output_ul(fp, (unsigned long )misc.datum.recipient);
  }
#line 818
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 821
  prot_a_output_ul(fp, misc.datum.local_no);
  }
#line 822
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 825
  prot_a_output_time(fp, misc.datum.received_at);
  }
#line 826
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 832
  prot_a_output_ul(fp, misc.datum.text_link);
  }
#line 833
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 836
  prot_a_output_ul(fp, (unsigned long )misc.datum.sender);
  }
#line 837
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 840
  prot_a_output_time(fp, misc.datum.sent_at);
  }
#line 841
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 847
  restart_kom("prot_a_output_misc_info: Illegal misc\n");
  }
  switch_break: /* CIL Label */ ;
  }
#line 849
  return;
}
}
#line 852 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_time(Connection *fp , time_t clk ) 
{ 
  struct tm *t ;

  {
#line 858
  if (fp->use_utc) {
    {
#line 859
    t = gmtime((time_t const   *)(& clk));
    }
  } else {
    {
#line 861
    t = localtime((time_t const   *)(& clk));
    }
  }
  {
#line 863
  prot_a_output_ul(fp, (unsigned long )t->tm_sec);
#line 864
  prot_a_output_ul(fp, (unsigned long )t->tm_min);
#line 865
  prot_a_output_ul(fp, (unsigned long )t->tm_hour);
#line 866
  prot_a_output_ul(fp, (unsigned long )t->tm_mday);
#line 867
  prot_a_output_ul(fp, (unsigned long )t->tm_mon);
#line 868
  prot_a_output_ul(fp, (unsigned long )t->tm_year);
#line 869
  prot_a_output_ul(fp, (unsigned long )t->tm_wday);
#line 870
  prot_a_output_ul(fp, (unsigned long )t->tm_yday);
#line 871
  prot_a_output_ul(fp, (unsigned long )t->tm_isdst);
  }
#line 872
  return;
}
}
#line 875 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_session_no(Connection *fp , Session_no session_no ) 
{ 


  {
  {
#line 879
  prot_a_output_ul(fp, session_no);
  }
#line 880
  return;
}
}
#line 882 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_text_no(Connection *fp , Text_no text ) 
{ 


  {
  {
#line 886
  prot_a_output_ul(fp, text);
  }
#line 887
  return;
}
}
#line 889 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_conf_no(Connection *fp , Conf_no conf ) 
{ 


  {
  {
#line 893
  prot_a_output_ul(fp, (unsigned long )conf);
  }
#line 894
  return;
}
}
#line 896 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
static void prot_a_output_conf_z_info(Connection *fp , Conf_z_info *conf_c ) 
{ 


  {
  {
#line 900
  prot_a_output_string(fp, conf_c->name);
#line 901
  prot_a_output_conf_type(fp, conf_c->type);
#line 902
  prot_a_output_ul(fp, (unsigned long )conf_c->conf_no);
  }
#line 903
  return;
}
}
#line 905 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
extern void prot_a_output_conf_z_info_list(Connection *fp , Conf_z_info_list c_list ) 
{ 
  int i ;

  {
  {
#line 911
  prot_a_output_ul(fp, (unsigned long )c_list.no_of_confs);
  }
#line 912
  if ((unsigned long )c_list.confs != (unsigned long )((void *)0)) {
#line 912
    if ((int )c_list.no_of_confs > 0) {
      {
#line 914
      isc_puts(" {", fp->isc_session);
#line 915
      i = 0;
      }
      {
#line 915
      while (1) {
        while_continue: /* CIL Label */ ;
#line 915
        if (! (i < (int )c_list.no_of_confs)) {
#line 915
          goto while_break;
        }
        {
#line 916
        prot_a_output_conf_z_info(fp, c_list.confs + i);
#line 915
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 917
      isc_puts(" }", fp->isc_session);
      }
    } else {
      {
#line 920
      isc_puts(" *", fp->isc_session);
      }
    }
  } else {
    {
#line 920
    isc_puts(" *", fp->isc_session);
    }
  }
#line 921
  return;
}
}
#line 923 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_version_info(Connection *fp , Version_info *v_info ) 
{ 


  {
  {
#line 927
  prot_a_output_ul(fp, v_info->protocol_version);
#line 928
  prot_a_output_string(fp, v_info->server_name);
#line 929
  prot_a_output_string(fp, v_info->server_version);
  }
#line 930
  return;
}
}
#line 932 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_num_list(Connection *fp , Number_list *num_list ) 
{ 
  int i ;

  {
  {
#line 938
  prot_a_output_ul(fp, (unsigned long )num_list->length);
  }
#line 939
  if (num_list->length == 0) {
    {
#line 940
    isc_puts(" *", fp->isc_session);
    }
  } else {
    {
#line 943
    isc_puts(" {", fp->isc_session);
#line 944
    i = 0;
    }
    {
#line 944
    while (1) {
      while_continue: /* CIL Label */ ;
#line 944
      if (! (i < num_list->length)) {
#line 944
        goto while_break;
      }
      {
#line 945
      prot_a_output_ul(fp, (unsigned long )*(num_list->data + i));
#line 944
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 946
    isc_puts(" }", fp->isc_session);
    }
  }
#line 948
  return;
}
}
#line 950 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
static void prot_a_output_session_flags(Connection *fp , Session_flags flags ) 
{ 


  {
  {
#line 954
  isc_putc(' ', fp->isc_session);
#line 955
  isc_putc((int )(flags.invisible + 48U), fp->isc_session);
#line 956
  isc_putc((int )(flags.user_active_used + 48U), fp->isc_session);
#line 957
  isc_putc((int )(flags.user_absent + 48U), fp->isc_session);
#line 958
  isc_putc((int )(flags.reserved3 + 48U), fp->isc_session);
#line 959
  isc_putc((int )(flags.reserved4 + 48U), fp->isc_session);
#line 960
  isc_putc((int )(flags.reserved5 + 48U), fp->isc_session);
#line 961
  isc_putc((int )(flags.reserved6 + 48U), fp->isc_session);
#line 962
  isc_putc((int )(flags.reserved7 + 48U), fp->isc_session);
  }
#line 963
  return;
}
}
#line 964 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
static void prot_a_output_dynamic_session_info(Connection *fp , Dynamic_session_info *info ) 
{ 


  {
  {
#line 968
  prot_a_output_ul(fp, info->session);
#line 969
  prot_a_output_ul(fp, (unsigned long )info->person);
#line 970
  prot_a_output_ul(fp, (unsigned long )info->working_conference);
#line 971
  prot_a_output_ul(fp, info->idle_time);
#line 972
  prot_a_output_session_flags(fp, info->flags);
#line 973
  prot_a_output_string(fp, info->what_am_i_doing);
  }
#line 974
  return;
}
}
#line 976 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_static_session_info(Connection *fp , Static_session_info *info ) 
{ 


  {
  {
#line 980
  prot_a_output_string(fp, info->username);
#line 981
  prot_a_output_string(fp, info->hostname);
#line 982
  prot_a_output_string(fp, info->ident_user);
#line 983
  prot_a_output_time(fp, info->connection_time);
  }
#line 984
  return;
}
}
#line 986 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_dynamic_session_info_list(Connection *fp , Dynamic_session_info_list *list ) 
{ 
  long i ;

  {
  {
#line 992
  prot_a_output_ul(fp, (unsigned long )list->no_of_sessions);
  }
#line 993
  if (list->no_of_sessions == 0L) {
    {
#line 994
    isc_puts(" *", fp->isc_session);
    }
  } else {
    {
#line 997
    isc_puts(" {", fp->isc_session);
#line 998
    i = 0L;
    }
    {
#line 998
    while (1) {
      while_continue: /* CIL Label */ ;
#line 998
      if (! (i < list->no_of_sessions)) {
#line 998
        goto while_break;
      }
      {
#line 999
      prot_a_output_dynamic_session_info(fp, list->sessions + i);
#line 998
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1000
    isc_puts(" }", fp->isc_session);
    }
  }
#line 1002
  return;
}
}
#line 1004 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_l2g_iterator_as_text_list(Connection *fp , L2g_iterator *iter ) 
{ 
  Local_text_no lno ;
  Local_text_no tmp ;
  Local_text_no limit___0 ;
  Local_text_no tmp___0 ;

  {
  {
#line 1008
  tmp = l2gi_begin((L2g_iterator const   *)iter);
#line 1008
  lno = tmp;
#line 1009
  tmp___0 = l2gi_end((L2g_iterator const   *)iter);
#line 1009
  limit___0 = tmp___0;
#line 1011
  prot_a_output_ul(fp, lno);
#line 1012
  prot_a_output_ul(fp, limit___0 - lno);
  }
#line 1014
  if (limit___0 - lno > 0UL) {
    {
#line 1016
    isc_puts(" {", fp->isc_session);
    }
    {
#line 1017
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1017
      if (! (! iter->search_ended)) {
#line 1017
        goto while_break;
      }
      {
#line 1020
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1020
        if (! (lno < iter->lno)) {
#line 1020
          goto while_break___0;
        }
        {
#line 1021
        isc_puts(" 0", fp->isc_session);
#line 1020
        lno ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1023
      prot_a_output_ul(fp, iter->tno);
#line 1024
      lno ++;
#line 1017
      l2gi_next(iter);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1027
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1027
      if (! (lno < limit___0)) {
#line 1027
        goto while_break___1;
      }
      {
#line 1028
      isc_puts(" 0", fp->isc_session);
#line 1027
      lno ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1029
    isc_puts(" }", fp->isc_session);
    }
  } else {
    {
#line 1032
    isc_puts(" *", fp->isc_session);
    }
  }
#line 1033
  return;
}
}
#line 1035 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_text_mapping(Connection *fp , Text_mapping *map ) 
{ 
  Local_text_no lowest ;
  Local_text_no highest ;
  Local_text_no limit___0 ;
  Local_text_no zeroes ;
  Local_text_no nonzeroes ;
  L2g_iterator iter ;
  Local_text_no tmp ;
  char const   *tmp___0 ;
  Local_text_no tmp___1 ;

  {
  {
#line 1042
  zeroes = (Local_text_no )0;
#line 1043
  nonzeroes = (Local_text_no )0;
#line 1049
  iter.l2g = (Local_to_global const   *)((void *)0);
#line 1050
  iter.binfo = (struct l2g_block_info  const  *)((void *)0);
#line 1051
  iter.arrindex = 0;
#line 1052
  iter.beginval = (Local_text_no )0;
#line 1053
  iter.endval = (Local_text_no )0;
#line 1054
  iter.search_ended = 0;
#line 1055
  iter.lno = (Local_text_no )0;
#line 1056
  iter.tno = (Text_no )0;
#line 1061
  l2gi_searchsome(& iter, map->l2g, map->first, (Local_text_no )0);
  }
#line 1061
  if (iter.search_ended) {
#line 1061
    lowest = map->first;
  } else {
#line 1061
    lowest = iter.lno;
  }
#line 1061
  highest = lowest - 1UL;
  {
#line 1061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1061
    if (! iter.search_ended) {
#line 1061
      if (! (nonzeroes < map->no_of_texts)) {
#line 1061
        goto while_break;
      }
    } else {
#line 1061
      goto while_break;
    }
    {
#line 1066
    zeroes += (iter.lno - highest) - 1UL;
#line 1067
    nonzeroes ++;
#line 1068
    highest = iter.lno;
#line 1061
    l2gi_next(& iter);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1071
  limit___0 = highest + 1UL;
#line 1073
  prot_a_output_ul(fp, map->first);
  }
#line 1074
  if (iter.search_ended) {
    {
#line 1075
    tmp = l2g_first_appendable_key(map->l2g);
#line 1075
    prot_a_output_ul(fp, tmp);
    }
  } else {
    {
#line 1077
    prot_a_output_ul(fp, limit___0);
    }
  }
#line 1081
  if (iter.search_ended) {
#line 1081
    tmp___0 = " 0";
  } else {
#line 1081
    tmp___0 = " 1";
  }
  {
#line 1081
  isc_puts(tmp___0, fp->isc_session);
  }
#line 1086
  if (nonzeroes == 0UL) {
    {
#line 1091
    isc_puts(" 0 0 *", fp->isc_session);
    }
  } else
#line 1093
  if (zeroes >= nonzeroes) {
    {
#line 1098
    isc_puts(" 0", fp->isc_session);
#line 1099
    prot_a_output_ul(fp, nonzeroes);
#line 1100
    isc_puts(" {", fp->isc_session);
#line 1102
    l2gi_searchsome(& iter, map->l2g, map->first, limit___0);
    }
    {
#line 1102
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1102
      if (! (! iter.search_ended)) {
#line 1102
        goto while_break___0;
      }
      {
#line 1106
      prot_a_output_ul(fp, iter.lno);
#line 1107
      prot_a_output_ul(fp, iter.tno);
#line 1102
      l2gi_next(& iter);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1109
    isc_puts(" }", fp->isc_session);
    }
  } else {
    {
#line 1114
    isc_puts(" 1", fp->isc_session);
#line 1115
    prot_a_output_ul(fp, lowest);
#line 1116
    prot_a_output_ul(fp, zeroes + nonzeroes);
#line 1117
    isc_puts(" {", fp->isc_session);
#line 1118
    highest = lowest;
#line 1119
    l2gi_searchsome(& iter, map->l2g, map->first, limit___0);
    }
    {
#line 1119
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1119
      if (! (! iter.search_ended)) {
#line 1119
        goto while_break___1;
      }
      {
#line 1123
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1123
        tmp___1 = highest;
#line 1123
        highest ++;
#line 1123
        if (! (tmp___1 < iter.lno)) {
#line 1123
          goto while_break___2;
        }
        {
#line 1124
        isc_puts(" 0", fp->isc_session);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1125
      prot_a_output_ul(fp, iter.tno);
#line 1119
      l2gi_next(& iter);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1127
    isc_puts(" }", fp->isc_session);
    }
  }
#line 1129
  return;
}
}
#line 1131 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_text_mapping_reverse(Connection *fp , Text_mapping_reverse *map ) 
{ 
  Local_text_no lowest ;
  Local_text_no zeroes ;
  Local_text_no nonzeroes ;
  L2g_iterator iter ;
  L2g_reverse_iterator riter ;
  char const   *tmp ;
  Local_text_no tmp___0 ;

  {
  {
#line 1136
  zeroes = (Local_text_no )0;
#line 1137
  nonzeroes = (Local_text_no )0;
#line 1144
  iter.l2g = (Local_to_global const   *)((void *)0);
#line 1145
  iter.binfo = (struct l2g_block_info  const  *)((void *)0);
#line 1146
  iter.arrindex = 0;
#line 1147
  iter.beginval = (Local_text_no )0;
#line 1148
  iter.endval = (Local_text_no )0;
#line 1149
  iter.search_ended = 0;
#line 1150
  iter.lno = (Local_text_no )0;
#line 1151
  iter.tno = (Text_no )0;
#line 1153
  riter.l2g = (Local_to_global const   *)((void *)0);
#line 1154
  riter.binfo = (struct l2g_block_info  const  *)((void *)0);
#line 1155
  riter.arrindex = 0;
#line 1156
  riter.beginval = (Local_text_no )0;
#line 1157
  riter.endval = (Local_text_no )0;
#line 1158
  riter.search_ended = 0;
#line 1159
  riter.lno = (Local_text_no )0;
#line 1160
  riter.tno = (Text_no )0;
#line 1165
  l2gi_searchsome_reverse(& riter, map->l2g, (Local_text_no )0, map->ceiling);
  }
#line 1165
  if (riter.search_ended) {
#line 1165
    lowest = map->ceiling;
  } else {
#line 1165
    lowest = riter.lno + 1UL;
  }
  {
#line 1165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1165
    if (! riter.search_ended) {
#line 1165
      if (! (nonzeroes < map->no_of_texts)) {
#line 1165
        goto while_break;
      }
    } else {
#line 1165
      goto while_break;
    }
    {
#line 1170
    zeroes += (lowest - riter.lno) - 1UL;
#line 1171
    nonzeroes ++;
#line 1172
    lowest = riter.lno;
#line 1165
    l2gi_prev(& riter);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1175
  prot_a_output_ul(fp, lowest);
#line 1176
  prot_a_output_ul(fp, map->ceiling);
  }
#line 1179
  if (riter.search_ended) {
#line 1179
    tmp = " 0";
  } else {
#line 1179
    tmp = " 1";
  }
  {
#line 1179
  isc_puts(tmp, fp->isc_session);
  }
#line 1182
  if (nonzeroes == 0UL) {
    {
#line 1187
    isc_puts(" 0 0 *", fp->isc_session);
    }
  } else
#line 1189
  if (zeroes >= nonzeroes) {
    {
#line 1194
    isc_puts(" 0", fp->isc_session);
#line 1195
    prot_a_output_ul(fp, nonzeroes);
#line 1196
    isc_puts(" {", fp->isc_session);
#line 1198
    l2gi_searchsome(& iter, map->l2g, lowest, map->ceiling);
    }
    {
#line 1198
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1198
      if (! (! iter.search_ended)) {
#line 1198
        goto while_break___0;
      }
      {
#line 1202
      prot_a_output_ul(fp, iter.lno);
#line 1203
      prot_a_output_ul(fp, iter.tno);
#line 1198
      l2gi_next(& iter);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1205
    isc_puts(" }", fp->isc_session);
    }
  } else {
    {
#line 1210
    isc_puts(" 1", fp->isc_session);
#line 1211
    prot_a_output_ul(fp, lowest);
#line 1212
    prot_a_output_ul(fp, zeroes + nonzeroes);
#line 1213
    isc_puts(" {", fp->isc_session);
#line 1214
    l2gi_searchsome(& iter, map->l2g, lowest, map->ceiling);
    }
    {
#line 1214
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1214
      if (! (! iter.search_ended)) {
#line 1214
        goto while_break___1;
      }
      {
#line 1218
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1218
        tmp___0 = lowest;
#line 1218
        lowest ++;
#line 1218
        if (! (tmp___0 < iter.lno)) {
#line 1218
          goto while_break___2;
        }
        {
#line 1219
        isc_puts(" 0", fp->isc_session);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1220
      prot_a_output_ul(fp, iter.tno);
#line 1214
      l2gi_next(& iter);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1222
    isc_puts(" }", fp->isc_session);
    }
  }
#line 1224
  return;
}
}
#line 1226 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_stats_description(Connection *fp , Stats_description *result ) 
{ 
  int i ;

  {
  {
#line 1232
  prot_a_output_ul(fp, (unsigned long )result->no_of_stats);
  }
#line 1233
  if (result->no_of_stats == 0) {
    {
#line 1234
    isc_puts(" *", fp->isc_session);
    }
  } else {
    {
#line 1237
    isc_puts(" {", fp->isc_session);
#line 1238
    i = 0;
    }
    {
#line 1238
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1238
      if (! (i < result->no_of_stats)) {
#line 1238
        goto while_break;
      }
      {
#line 1239
      prot_a_output_string(fp, *(result->stat_names + i));
#line 1238
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1240
    isc_puts(" }", fp->isc_session);
    }
  }
  {
#line 1243
  prot_a_output_num_list(fp, & result->intervals);
  }
#line 1244
  return;
}
}
#line 1246 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
static void prot_a_output_stats(Connection *fp , Stats const   *result ) 
{ 


  {
  {
#line 1250
  prot_a_output_float(fp, (float )result->average);
#line 1251
  prot_a_output_float(fp, (float )result->ascent_rate);
#line 1252
  prot_a_output_float(fp, (float )result->descent_rate);
  }
#line 1253
  return;
}
}
#line 1255 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_stats_list(Connection *fp , Stats_list const   *result ) 
{ 
  int i ;

  {
  {
#line 1261
  prot_a_output_ul(fp, (unsigned long )result->no_of_stats);
  }
#line 1262
  if (result->no_of_stats == 0) {
    {
#line 1263
    isc_puts(" *", fp->isc_session);
    }
  } else {
    {
#line 1266
    isc_puts(" {", fp->isc_session);
#line 1267
    i = 0;
    }
    {
#line 1267
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1267
      if (! (i < (int )result->no_of_stats)) {
#line 1267
        goto while_break;
      }
      {
#line 1268
      prot_a_output_stats(fp, (Stats const   *)(result->stats + i));
#line 1267
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1269
    isc_puts(" }", fp->isc_session);
    }
  }
#line 1271
  return;
}
}
#line 1273 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_static_server_info(Connection *fp , Static_server_info const   *result ) 
{ 


  {
  {
#line 1277
  prot_a_output_time(fp, (time_t )result->boot_time);
#line 1278
  prot_a_output_time(fp, (time_t )result->save_time);
#line 1279
  prot_a_output_string(fp, (String )result->db_status);
#line 1280
  prot_a_output_ul(fp, (unsigned long )result->existing_texts);
#line 1281
  prot_a_output_ul(fp, (unsigned long )result->highest_text_no);
#line 1282
  prot_a_output_ul(fp, (unsigned long )result->existing_confs);
#line 1283
  prot_a_output_ul(fp, (unsigned long )result->existing_persons);
#line 1284
  prot_a_output_ul(fp, (unsigned long )result->highest_conf_no);
  }
#line 1285
  return;
}
}
#line 1287 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-output.c"
void prot_a_output_scheduling_info(Connection *fp , Scheduling_info const   *result ) 
{ 


  {
  {
#line 1291
  prot_a_output_ul(fp, (unsigned long )result->priority);
#line 1292
  prot_a_output_ul(fp, (unsigned long )result->weight);
  }
#line 1293
  return;
}
}
#line 47 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/string-malloc.c"
static int no_of_allocated_blocks___1  =    0;
#line 38 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/misc-types.c"
static struct success succ_ok___0  ;
#line 39 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/misc-types.c"
static struct success succ_failure___0  ;
#line 438 "./../libraries/libmisc/s-string.h"
extern long s_strtol(String const   str , String_size *first_ill_char ) ;
#line 447 "./../include/services.h"
extern Success get_marks(Mark_list *result ) ;
#line 479
extern Success get_text(Text_no text_no , String_size start_char , String_size end_char ,
                        String *result ) ;
#line 486
extern Success get_text_stat(Text_no text_no , Text_stat *result ) ;
#line 490
extern Success get_text_stat_old(Text_no text_no , Text_stat *result ) ;
#line 509
extern Text_no create_text(String const   message , Misc_info_list *misc_l , Aux_item_list *aux ) ;
#line 514
extern Text_no create_text_old(String const   message , Misc_info_list *misc_l ) ;
#line 519
extern Text_no create_anonymous_text(String const   message , Misc_info_list *misc_l ,
                                     Aux_item_list *aux ) ;
#line 524
extern Text_no create_anonymous_text_old(String const   message , Misc_info_list *misc_l ) ;
#line 528
extern Success delete_text(Text_no text_no ) ;
#line 531
extern Success modify_text_info(Text_no text , Number_list *items_to_delete , Aux_item_list *aux ) ;
#line 537
extern Success add_recipient(Text_no text_no , Conf_no conf_no , enum info_type type ) ;
#line 542
extern Success sub_recipient(Text_no text_no , Conf_no conf_no ) ;
#line 547
extern Success add_comment(Text_no child , Text_no parent ) ;
#line 555
extern Success sub_comment(Text_no child , Text_no parent ) ;
#line 559
extern Success add_footnote(Text_no child , Text_no parent ) ;
#line 563
extern Success sub_footnote(Text_no child , Text_no parent ) ;
#line 567
Success first_unused_text_no(Text_no *result ) ;
#line 570
extern Success get_map(Conf_no conf_no , Local_text_no first_local_no , unsigned long no_of_texts ,
                       L2g_iterator *result ) ;
#line 576
extern Success local_to_global(Conf_no conf_no , Local_text_no first_local_no , unsigned long no_of_texts ,
                               Text_mapping *result ) ;
#line 581
extern Success local_to_global_reverse(Conf_no conf_no , Local_text_no local_no_ceiling ,
                                       unsigned long no_of_texts , Text_mapping_reverse *result ) ;
#line 600
extern Success get_last_text(struct tm *wanted_time , Text_no *result ) ;
#line 607
extern Success find_next_text_no(Text_no start , Text_no *result ) ;
#line 610
extern Success find_previous_text_no(Text_no start , Text_no *result ) ;
#line 471 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/manipulate.h"
void free_all_jubel(void) ;
#line 83 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache.h"
extern Text_no cached_create_text(String const   message ) ;
#line 92
extern String cached_get_text(Text_no text ) ;
#line 96
Success cached_delete_text(Text_no text ) ;
#line 105
Text_no query_next_text_num(void) ;
#line 122
extern Conf_type cached_get_conf_type(Conf_no conf_no ) ;
#line 164 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
void aux_inherit_items(Aux_item_list *target , Aux_item_list const   *parent , unsigned long *counter ,
                       Conf_no subordinate , Text_no object_no , Text_stat *object ) ;
#line 197
void filter_aux_item_list(Aux_item_list const   *original , Aux_item_list *result ,
                          Connection const   *viewer_conn ) ;
#line 205
void delete_aux_item_list(Number_list const   *items_to_delete , Aux_item_list *list_to_delete_from ,
                          enum object_type object_type , unsigned long object_no ,
                          void *object ) ;
#line 216
void undelete_aux_item_list(Number_list const   *items_to_undelete , Aux_item_list *list_to_undelete_from ,
                            enum object_type object_type , unsigned long object_no ,
                            void *object ) ;
#line 223
void commit_aux_item_list(Aux_item_list *list_to_commit ) ;
#line 232
Success check_delete_aux_item_list(Number_list const   *items_to_delete , Aux_item_list const   *list_to_delete_from ,
                                   Conf_no const   subordinate ) ;
#line 241
void text_stat_add_aux_item_list(Text_stat *text_s , Text_no text_no , Aux_item_list *item_list ,
                                 Pers_no item_creator ) ;
#line 257
Success text_stat_check_add_aux_item_list(Text_stat *text_s , Aux_item_list *list ,
                                          Connection *creating_conn ) ;
#line 36 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.h"
void l2g_append(Local_to_global *l2g , Local_text_no lno , Text_no tno ) ;
#line 45
void l2g_delete(Local_to_global *l2g , Local_text_no lno ) ;
#line 72
void l2g_delete_global_in_sorted(Local_to_global *l2g , Text_no tno ) ;
#line 32 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.h"
Success do_delete_text(Text_no text_no , Text_stat *text_s ) ;
#line 77 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Text_no do_create_text(String const   message , u_short no_of_misc , Misc_info *misc ,
                              Aux_item_list *aux , Bool anonymous , Text_stat **ret_stat ) ;
#line 85
static void filter_secret_info(Text_stat *result , Text_stat const   *original , Connection const   *viewer_conn ,
                               Bool output_bcc ) ;
#line 91
static Bool interested_party(Connection const   *cptr , Text_no tno , Text_stat const   *text_s ) ;
#line 105 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Local_text_no add_text_in_conf(Conference *conf_c , Text_no text_no ) 
{ 
  Local_text_no res ;

  {
  {
#line 111
  conf_c->last_written = current_time.tv_sec;
#line 114
  res = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
#line 115
  l2g_append(& conf_c->texts, res, text_no);
  }
#line 116
  return (res);
}
}
#line 124 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static int count_recipients(Text_stat const   *t_stat ) 
{ 
  int n ;
  Misc_info *end ;
  Misc_info *misc ;

  {
#line 127
  n = 0;
#line 128
  end = (Misc_info *)(t_stat->misc_items + (int const   )t_stat->no_of_misc);
#line 131
  misc = (Misc_info *)t_stat->misc_items;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! ((unsigned long )misc < (unsigned long )end)) {
#line 131
      goto while_break;
    }
#line 132
    if ((unsigned int )misc->type == 0U) {
#line 136
      n ++;
    } else
#line 132
    if ((unsigned int )misc->type == 1U) {
#line 136
      n ++;
    } else
#line 132
    if ((unsigned int )misc->type == 15U) {
#line 136
      n ++;
    }
#line 131
    misc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return (n);
}
}
#line 146 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static int count_footn(Text_stat const   *t_stat ) 
{ 
  int n ;
  Misc_info *end ;
  Misc_info *misc ;

  {
#line 149
  n = 0;
#line 150
  end = (Misc_info *)(t_stat->misc_items + (int const   )t_stat->no_of_misc);
#line 153
  misc = (Misc_info *)t_stat->misc_items;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! ((unsigned long )misc < (unsigned long )end)) {
#line 153
      goto while_break;
    }
#line 154
    if ((unsigned int )misc->type == 5U) {
#line 155
      n ++;
    }
#line 153
    misc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return (n);
}
}
#line 164 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static int count_comment(Text_stat const   *t_stat ) 
{ 
  int n ;
  Misc_info *end ;
  Misc_info *misc ;

  {
#line 167
  n = 0;
#line 168
  end = (Misc_info *)(t_stat->misc_items + (int const   )t_stat->no_of_misc);
#line 171
  misc = (Misc_info *)t_stat->misc_items;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! ((unsigned long )misc < (unsigned long )end)) {
#line 171
      goto while_break;
    }
#line 172
    if ((unsigned int )misc->type == 3U) {
#line 173
      n ++;
    }
#line 171
    misc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return (n);
}
}
#line 183 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static int find_recipient(Conf_no conf_no , Text_stat const   *t_stat ) 
{ 
  int i ;

  {
#line 189
  i = 0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (i < (int )t_stat->no_of_misc)) {
#line 189
      goto while_break;
    }
    {
#line 195
    if ((unsigned int )(t_stat->misc_items + i)->type == 15U) {
#line 195
      goto case_15;
    }
#line 195
    if ((unsigned int )(t_stat->misc_items + i)->type == 1U) {
#line 195
      goto case_15;
    }
#line 195
    if ((unsigned int )(t_stat->misc_items + i)->type == 0U) {
#line 195
      goto case_15;
    }
#line 207
    if ((unsigned int )(t_stat->misc_items + i)->type == 6U) {
#line 207
      goto case_6;
    }
#line 207
    if ((unsigned int )(t_stat->misc_items + i)->type == 9U) {
#line 207
      goto case_6;
    }
#line 207
    if ((unsigned int )(t_stat->misc_items + i)->type == 8U) {
#line 207
      goto case_6;
    }
#line 207
    if ((unsigned int )(t_stat->misc_items + i)->type == 5U) {
#line 207
      goto case_6;
    }
#line 207
    if ((unsigned int )(t_stat->misc_items + i)->type == 4U) {
#line 207
      goto case_6;
    }
#line 207
    if ((unsigned int )(t_stat->misc_items + i)->type == 3U) {
#line 207
      goto case_6;
    }
#line 207
    if ((unsigned int )(t_stat->misc_items + i)->type == 2U) {
#line 207
      goto case_6;
    }
#line 207
    if ((unsigned int )(t_stat->misc_items + i)->type == 7U) {
#line 207
      goto case_6;
    }
#line 211
    goto switch_default;
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 196
    if ((int )(t_stat->misc_items + i)->datum.recipient == (int )conf_no) {
#line 197
      return (i);
    }
#line 198
    goto switch_break;
    case_6: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_7: /* CIL Label */ 
#line 208
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 214
    restart_kom("find_recipient(): illegal misc_item\n");
    }
    switch_break: /* CIL Label */ ;
    }
#line 189
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return (-1);
}
}
#line 230 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static int find_textlink(Text_stat const   *child , Text_no parent ) 
{ 
  int i ;

  {
#line 236
  i = 0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i < (int )child->no_of_misc)) {
#line 236
      goto while_break;
    }
    {
#line 241
    if ((unsigned int )(child->misc_items + i)->type == 4U) {
#line 241
      goto case_4;
    }
#line 241
    if ((unsigned int )(child->misc_items + i)->type == 2U) {
#line 241
      goto case_4;
    }
#line 245
    goto switch_default;
    case_4: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 242
    if ((child->misc_items + i)->datum.text_link == parent) {
#line 243
      return (i);
    }
#line 244
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 246
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  return (-1);
}
}
#line 258 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Conf_no submit_to(Conf_no conf_no , Conference const   *conf_c ) 
{ 
  int i ;
  enum access acc ;
  Conference *tmp ;
  Membership *tmp___0 ;
  Conference *tmp___1 ;

  {
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 266
      err_stat = 0UL;
#line 266
      kom_errno = (enum kom_err )51;
#line 266
      return ((Conf_no )0);
    }
#line 266
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 267
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 267
    if (! active_connection) {
#line 267
      err_stat = 0UL;
#line 267
      kom_errno = (enum kom_err )6;
#line 267
      return ((Conf_no )0);
    } else
#line 267
    if (! active_connection->pers_no) {
#line 267
      err_stat = 0UL;
#line 267
      kom_errno = (enum kom_err )6;
#line 267
      return ((Conf_no )0);
    }
#line 267
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 269
  if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
    {
#line 270
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 270
      tmp = cached_get_conf_stat(conf_no);
#line 270
      conf_c = (Conference const   *)tmp;
      }
#line 270
      if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 270
        return ((Conf_no )0);
      }
#line 270
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 272
  i = 0;
  {
#line 272
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 272
    if (! (i < param.max_super_conf_loop)) {
#line 272
      goto while_break___2;
    }
    {
#line 274
    acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )5);
    }
#line 276
    if ((unsigned int )acc <= 1U) {
#line 278
      err_stat = (unsigned long )conf_no;
#line 279
      kom_errno = (enum kom_err )9;
#line 280
      return ((Conf_no )0);
    }
#line 283
    if ((int const   )conf_c->permitted_submitters == 0) {
#line 287
      return (conf_no);
    } else
#line 283
    if ((unsigned int )acc == 5U) {
#line 287
      return (conf_no);
    } else {
      {
#line 283
      tmp___0 = locate_membership((Conf_no )conf_c->permitted_submitters, (Person const   *)active_connection->person);
      }
#line 283
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 287
        return (conf_no);
      }
    }
#line 291
    if ((int const   )conf_c->super_conf == 0) {
#line 293
      err_stat = (unsigned long )conf_no;
#line 294
      kom_errno = (enum kom_err )11;
#line 295
      return ((Conf_no )0);
    }
#line 297
    conf_no = (Conf_no )conf_c->super_conf;
    {
#line 299
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 299
      tmp___1 = cached_get_conf_stat(conf_no);
#line 299
      conf_c = (Conference const   *)tmp___1;
      }
#line 299
      if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 299
        return ((Conf_no )0);
      }
#line 299
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 272
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 302
  err_stat = (unsigned long )conf_no;
#line 303
  kom_errno = (enum kom_err )11;
#line 304
  return ((Conf_no )0);
}
}
#line 312 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success do_add_footnote(Text_no child , Text_stat *child_s , Text_no parent ,
                               Text_stat *parent_s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 318
  if (! ((unsigned long )child_s != (unsigned long )((void *)0))) {
    {
#line 318
    __assert_fail("child_s != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c",
                  318U, "do_add_footnote");
    }
  }
#line 320
  if ((unsigned long )parent_s == (unsigned long )((void *)0)) {
    {
#line 321
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 321
      parent_s = cached_get_text_stat(parent);
      }
#line 321
      if ((unsigned long )parent_s == (unsigned long )((void *)0)) {
#line 321
        return ((Success )FAILURE);
      }
#line 321
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 323
  child_s->no_of_misc = (unsigned short )((int )child_s->no_of_misc + 1);
#line 323
  tmp = srealloc((void *)child_s->misc_items, (unsigned long )child_s->no_of_misc * sizeof(Misc_info ));
#line 323
  child_s->misc_items = (Misc_info *)tmp;
#line 323
  (child_s->misc_items + ((int )child_s->no_of_misc - 1))->type = (enum info_type )4;
#line 323
  (child_s->misc_items + ((int )child_s->no_of_misc - 1))->datum.text_link = parent;
#line 324
  parent_s->no_of_misc = (unsigned short )((int )parent_s->no_of_misc + 1);
#line 324
  tmp___0 = srealloc((void *)parent_s->misc_items, (unsigned long )parent_s->no_of_misc * sizeof(Misc_info ));
#line 324
  parent_s->misc_items = (Misc_info *)tmp___0;
#line 324
  (parent_s->misc_items + ((int )parent_s->no_of_misc - 1))->type = (enum info_type )5;
#line 324
  (parent_s->misc_items + ((int )parent_s->no_of_misc - 1))->datum.text_link = child;
#line 326
  mark_text_as_changed(child);
#line 327
  mark_text_as_changed(parent);
  }
#line 329
  return ((Success )OK);
}
}
#line 337 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success do_add_comment(Text_no child , Text_stat *child_s , Text_no parent ,
                              Text_stat *parent_s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 343
  if (! ((unsigned long )child_s != (unsigned long )((void *)0))) {
    {
#line 343
    __assert_fail("child_s != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c",
                  343U, "do_add_comment");
    }
  }
#line 345
  if ((unsigned long )parent_s == (unsigned long )((void *)0)) {
    {
#line 346
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 346
      parent_s = cached_get_text_stat(parent);
      }
#line 346
      if ((unsigned long )parent_s == (unsigned long )((void *)0)) {
#line 346
        return ((Success )FAILURE);
      }
#line 346
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 348
  child_s->no_of_misc = (unsigned short )((int )child_s->no_of_misc + 1);
#line 348
  tmp = srealloc((void *)child_s->misc_items, (unsigned long )child_s->no_of_misc * sizeof(Misc_info ));
#line 348
  child_s->misc_items = (Misc_info *)tmp;
#line 348
  (child_s->misc_items + ((int )child_s->no_of_misc - 1))->type = (enum info_type )2;
#line 348
  (child_s->misc_items + ((int )child_s->no_of_misc - 1))->datum.text_link = parent;
#line 349
  parent_s->no_of_misc = (unsigned short )((int )parent_s->no_of_misc + 1);
#line 349
  tmp___0 = srealloc((void *)parent_s->misc_items, (unsigned long )parent_s->no_of_misc * sizeof(Misc_info ));
#line 349
  parent_s->misc_items = (Misc_info *)tmp___0;
#line 349
  (parent_s->misc_items + ((int )parent_s->no_of_misc - 1))->type = (enum info_type )3;
#line 349
  (parent_s->misc_items + ((int )parent_s->no_of_misc - 1))->datum.text_link = child;
#line 351
  mark_text_as_changed(child);
#line 352
  mark_text_as_changed(parent);
  }
#line 354
  return ((Success )OK);
}
}
#line 361 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success do_add_recipient(Text_no text , Text_stat *text_s , Conf_no receiver ,
                                enum info_type recv_type ) 
{ 
  Conference *rece_c ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 369
  if (! ((unsigned int )recv_type == 0U)) {
#line 369
    if (! ((unsigned int )recv_type == 1U)) {
#line 369
      if (! ((unsigned int )recv_type == 15U)) {
        {
#line 369
        __assert_fail("recv_type == recpt || recv_type == cc_recpt || recv_type == bcc_recpt",
                      "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c",
                      371U, "do_add_recipient");
        }
      }
    }
  }
#line 373
  if (! ((unsigned long )text_s != (unsigned long )((void *)0))) {
    {
#line 373
    __assert_fail("text_s != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c",
                  373U, "do_add_recipient");
    }
  }
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 375
    rece_c = cached_get_conf_stat(receiver);
    }
#line 375
    if ((unsigned long )rece_c == (unsigned long )((void *)0)) {
#line 375
      return ((Success )FAILURE);
    }
#line 375
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 377
  text_s->no_of_misc = (unsigned short )((int )text_s->no_of_misc + 1);
#line 377
  tmp = srealloc((void *)text_s->misc_items, (unsigned long )text_s->no_of_misc * sizeof(Misc_info ));
#line 377
  text_s->misc_items = (Misc_info *)tmp;
#line 377
  (text_s->misc_items + ((int )text_s->no_of_misc - 1))->type = recv_type;
#line 377
  (text_s->misc_items + ((int )text_s->no_of_misc - 1))->datum.recipient = receiver;
#line 378
  text_s->no_of_misc = (unsigned short )((int )text_s->no_of_misc + 1);
#line 378
  tmp___0 = srealloc((void *)text_s->misc_items, (unsigned long )text_s->no_of_misc * sizeof(Misc_info ));
#line 378
  text_s->misc_items = (Misc_info *)tmp___0;
#line 378
  (text_s->misc_items + ((int )text_s->no_of_misc - 1))->type = (enum info_type )6;
#line 378
  (text_s->misc_items + ((int )text_s->no_of_misc - 1))->datum.local_no = add_text_in_conf(rece_c,
                                                                                           text);
#line 380
  mark_text_as_changed(text);
#line 381
  mark_conference_as_changed(receiver);
  }
#line 383
  return ((Success )OK);
}
}
#line 386 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Bool is_member_in(Person const   *person , Conf_no conf_no , Bool skip_passive ) 
{ 
  Membership *mship ;

  {
  {
#line 393
  mship = locate_membership(conf_no, person);
  }
#line 393
  if ((unsigned long )mship != (unsigned long )((void *)0)) {
#line 395
    if (mship->type.passive) {
#line 395
      if (! skip_passive) {
#line 396
        return ((Bool )1);
      }
    } else {
#line 396
      return ((Bool )1);
    }
  }
#line 398
  return ((Bool )0);
}
}
#line 408 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Bool is_member_in_recpt(Person const   *person , Text_stat const   *text_s ,
                               Bool skip_passive ) 
{ 
  int i ;
  Bool tmp ;

  {
#line 415
  i = 0;
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! (i < (int )text_s->no_of_misc)) {
#line 415
      goto while_break;
    }
    {
#line 421
    if ((unsigned int )(text_s->misc_items + i)->type == 15U) {
#line 421
      goto case_15;
    }
#line 421
    if ((unsigned int )(text_s->misc_items + i)->type == 1U) {
#line 421
      goto case_15;
    }
#line 421
    if ((unsigned int )(text_s->misc_items + i)->type == 0U) {
#line 421
      goto case_15;
    }
#line 434
    if ((unsigned int )(text_s->misc_items + i)->type == 9U) {
#line 434
      goto case_9;
    }
#line 434
    if ((unsigned int )(text_s->misc_items + i)->type == 8U) {
#line 434
      goto case_9;
    }
#line 434
    if ((unsigned int )(text_s->misc_items + i)->type == 7U) {
#line 434
      goto case_9;
    }
#line 434
    if ((unsigned int )(text_s->misc_items + i)->type == 6U) {
#line 434
      goto case_9;
    }
#line 434
    if ((unsigned int )(text_s->misc_items + i)->type == 5U) {
#line 434
      goto case_9;
    }
#line 434
    if ((unsigned int )(text_s->misc_items + i)->type == 4U) {
#line 434
      goto case_9;
    }
#line 434
    if ((unsigned int )(text_s->misc_items + i)->type == 3U) {
#line 434
      goto case_9;
    }
#line 434
    if ((unsigned int )(text_s->misc_items + i)->type == 2U) {
#line 434
      goto case_9;
    }
#line 438
    goto switch_default;
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 422
    tmp = is_member_in(person, (text_s->misc_items + i)->datum.recipient, skip_passive);
    }
#line 422
    if ((unsigned int )tmp == 1U) {
#line 424
      return ((Bool )1);
    }
#line 425
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 435
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 441
    kom_log("is_member_in_recpt(): bad misc_item.\n");
    }
#line 442
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 415
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  return ((Bool )0);
}
}
#line 449 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Bool is_member_in_recpt_of(Person const   *person , Text_no const   text_no ,
                                  Bool skip_passive ) 
{ 
  Text_stat *text_s ;
  Bool tmp ;

  {
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 456
    text_s = cached_get_text_stat((Text_no )text_no);
    }
#line 456
    if ((unsigned long )text_s == (unsigned long )((void *)0)) {
#line 456
      return ((Bool )0);
    }
#line 456
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 457
  tmp = is_member_in_recpt(person, (Text_stat const   *)text_s, skip_passive);
  }
#line 457
  return (tmp);
}
}
#line 467
static void report_bad_aux(Text_no tno , String *data , int tag , char const   *reason ) ;
#line 467 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Text_no last  =    (Text_no )0;
#line 461 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static void report_bad_aux(Text_no tno , String *data , int tag , char const   *reason ) 
{ 
  char *d ;

  {
#line 470
  if (tno == last) {
#line 471
    return;
  }
  {
#line 473
  last = tno;
#line 474
  d = s_crea_c_str((String const   )*data);
#line 475
  kom_log("Bad aux-item %d found in text %ld: \"%s\": %s.\n", tag, tno, d, reason);
#line 477
  string_free((void *)d);
  }
#line 478
  return;
}
}
#line 486 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Bool is_member_in_linked_recpt(Person const   *person , Text_no tno , Text_stat const   *text_s ,
                                      Bool skip_passive ) 
{ 
  int i ;
  Text_no linked_nr ;
  String *data ;
  String_size end ;
  Bool tmp ;
  long tmp___0 ;
  Bool tmp___1 ;
  long tmp___2 ;
  Bool tmp___3 ;

  {
#line 500
  i = 0;
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 500
    if (! (i < (int )text_s->no_of_misc)) {
#line 500
      goto while_break;
    }
    {
#line 507
    if ((unsigned int )(text_s->misc_items + i)->type == 5U) {
#line 507
      goto case_5;
    }
#line 507
    if ((unsigned int )(text_s->misc_items + i)->type == 4U) {
#line 507
      goto case_5;
    }
#line 507
    if ((unsigned int )(text_s->misc_items + i)->type == 3U) {
#line 507
      goto case_5;
    }
#line 507
    if ((unsigned int )(text_s->misc_items + i)->type == 2U) {
#line 507
      goto case_5;
    }
#line 519
    if ((unsigned int )(text_s->misc_items + i)->type == 9U) {
#line 519
      goto case_9;
    }
#line 519
    if ((unsigned int )(text_s->misc_items + i)->type == 8U) {
#line 519
      goto case_9;
    }
#line 519
    if ((unsigned int )(text_s->misc_items + i)->type == 7U) {
#line 519
      goto case_9;
    }
#line 519
    if ((unsigned int )(text_s->misc_items + i)->type == 6U) {
#line 519
      goto case_9;
    }
#line 519
    if ((unsigned int )(text_s->misc_items + i)->type == 15U) {
#line 519
      goto case_9;
    }
#line 519
    if ((unsigned int )(text_s->misc_items + i)->type == 1U) {
#line 519
      goto case_9;
    }
#line 519
    if ((unsigned int )(text_s->misc_items + i)->type == 0U) {
#line 519
      goto case_9;
    }
#line 523
    goto switch_default;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 508
    linked_nr = (text_s->misc_items + i)->datum.text_link;
#line 509
    tmp = is_member_in_recpt_of(person, (Text_no const   )linked_nr, skip_passive);
    }
#line 509
    if ((unsigned int )tmp == 1U) {
#line 510
      return ((Bool )1);
    }
#line 511
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 520
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 526
    kom_log("is_member_in_linked_recpt(): bad misc_item.\n");
    }
#line 527
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 500
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  i = 0;
  {
#line 531
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 531
    if (! (i < (int )text_s->aux_item_list.length)) {
#line 531
      goto while_break___0;
    }
#line 533
    data = & (text_s->aux_item_list.items + i)->data;
    {
#line 536
    if ((text_s->aux_item_list.items + i)->tag == 3UL) {
#line 536
      goto case_3___0;
    }
#line 571
    if ((text_s->aux_item_list.items + i)->tag == 10101UL) {
#line 571
      goto case_10101;
    }
#line 571
    if ((text_s->aux_item_list.items + i)->tag == 10100UL) {
#line 571
      goto case_10101;
    }
#line 592
    if ((text_s->aux_item_list.items + i)->tag == 28UL) {
#line 592
      goto case_28;
    }
#line 605
    goto switch_default___0;
    case_3___0: /* CIL Label */ 
#line 568
    goto switch_break___0;
    case_10101: /* CIL Label */ 
    case_10100: /* CIL Label */ 
    {
#line 574
    tmp___0 = s_strtol((String const   )*data, & end);
#line 574
    linked_nr = (Text_no )tmp___0;
    }
#line 575
    if (end == -1L) {
      {
#line 577
      report_bad_aux(tno, data, (int )(text_s->aux_item_list.items + i)->tag, "bad number");
      }
#line 579
      goto __Cont;
    }
#line 581
    if (end != data->len) {
      {
#line 583
      report_bad_aux(tno, data, (int )(text_s->aux_item_list.items + i)->tag, "trailing garbage");
      }
#line 585
      goto __Cont;
    }
    {
#line 588
    tmp___1 = is_member_in_recpt_of(person, (Text_no const   )linked_nr, skip_passive);
    }
#line 588
    if ((unsigned int )tmp___1 == 1U) {
#line 589
      return ((Bool )1);
    }
#line 590
    goto switch_break___0;
    case_28: /* CIL Label */ 
    {
#line 594
    tmp___2 = s_strtol((String const   )*data, & end);
#line 594
    linked_nr = (Text_no )tmp___2;
    }
#line 595
    if (end == -1L) {
#line 596
      goto __Cont;
    }
#line 597
    if (end != data->len) {
#line 598
      goto __Cont;
    }
#line 600
    if (linked_nr == 0UL) {
#line 602
      return ((Bool )1);
    } else {
      {
#line 600
      tmp___3 = is_member_in(person, (Conf_no )linked_nr, skip_passive);
      }
#line 600
      if ((unsigned int )tmp___3 == 1U) {
#line 602
        return ((Bool )1);
      }
    }
#line 603
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 606
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 531
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 610
  return ((Bool )0);
}
}
#line 618 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static u_short count_lines(String str ) 
{ 
  u_short l ;
  unsigned char *tmp ;
  String_size tmp___0 ;

  {
#line 621
  l = (u_short )0;
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    tmp___0 = str.len;
#line 623
    (str.len) --;
#line 623
    if (! (tmp___0 > 0L)) {
#line 623
      goto while_break;
    }
#line 624
    tmp = str.string;
#line 624
    (str.string) ++;
#line 624
    if ((int )*tmp == 10) {
#line 625
      l = (u_short )((int )l + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 627
  return (l);
}
}
#line 639 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static void do_delete_misc(u_short *no_of_misc , Misc_info *misc , int loc ) 
{ 
  int del ;
  Bool ready ;

  {
#line 644
  del = 1;
#line 646
  ready = (Bool )0;
#line 650
  if (loc < 0) {
    {
#line 651
    restart_kom("do_delete_misc() - loc out of range");
    }
  } else
#line 650
  if (loc >= (int )*no_of_misc) {
    {
#line 651
    restart_kom("do_delete_misc() - loc out of range");
    }
  }
  {
#line 653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 653
    if ((unsigned int )ready == 0U) {
#line 653
      if (! (loc + del < (int )*no_of_misc)) {
#line 653
        goto while_break;
      }
    } else {
#line 653
      goto while_break;
    }
    {
#line 660
    if ((unsigned int )(misc + (loc + del))->type == 9U) {
#line 660
      goto case_9;
    }
#line 660
    if ((unsigned int )(misc + (loc + del))->type == 8U) {
#line 660
      goto case_9;
    }
#line 660
    if ((unsigned int )(misc + (loc + del))->type == 7U) {
#line 660
      goto case_9;
    }
#line 660
    if ((unsigned int )(misc + (loc + del))->type == 6U) {
#line 660
      goto case_9;
    }
#line 670
    if ((unsigned int )(misc + (loc + del))->type == 3U) {
#line 670
      goto case_3;
    }
#line 670
    if ((unsigned int )(misc + (loc + del))->type == 2U) {
#line 670
      goto case_3;
    }
#line 670
    if ((unsigned int )(misc + (loc + del))->type == 5U) {
#line 670
      goto case_3;
    }
#line 670
    if ((unsigned int )(misc + (loc + del))->type == 4U) {
#line 670
      goto case_3;
    }
#line 670
    if ((unsigned int )(misc + (loc + del))->type == 15U) {
#line 670
      goto case_3;
    }
#line 670
    if ((unsigned int )(misc + (loc + del))->type == 1U) {
#line 670
      goto case_3;
    }
#line 670
    if ((unsigned int )(misc + (loc + del))->type == 0U) {
#line 670
      goto case_3;
    }
#line 675
    goto switch_default;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 661
    del ++;
#line 662
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 671
    ready = (Bool )1;
#line 672
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 678
    restart_kom("do_delete_misc() - illegal misc");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  *no_of_misc = (u_short )((int )*no_of_misc - del);
  {
#line 686
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 686
    if (! (loc < (int )*no_of_misc)) {
#line 686
      goto while_break___0;
    }
#line 688
    *(misc + loc) = *(misc + (loc + del));
#line 689
    loc ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 691
  return;
}
}
#line 694 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static void send_async_sub_recipient(Text_no text_no , Text_stat const   *text_s ,
                                     Conf_no conf_no , enum info_type type ) 
{ 
  Connection *cptr ;
  Session_no i ;
  Text_stat copy ;
  int tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;

  {
#line 701
  i = (Session_no )0;
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 703
    i = traverse_connections(i);
    }
#line 703
    if (! (i != 0UL)) {
#line 703
      goto while_break;
    }
    {
#line 705
    cptr = get_conn_by_number(i);
#line 706
    tmp___0 = interested_party((Connection const   *)cptr, text_no, text_s);
    }
#line 706
    if (tmp___0) {
      {
#line 706
      tmp___1 = text_read_access((Connection const   *)cptr, text_no, text_s);
      }
#line 706
      if (tmp___1) {
        {
#line 711
        filter_secret_info(& copy, text_s, (Connection const   *)cptr, (Bool )1);
#line 712
        tmp = find_recipient(conf_no, (Text_stat const   *)(& copy));
        }
#line 712
        if (tmp != -1) {
          {
#line 713
          async_sub_recipient(cptr, text_no, conf_no, type);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 716
  return;
}
}
#line 724 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success perform_subtraction(Text_no text_no , Text_stat *text_s , Conf_no conf_no ,
                                   Conference *conf_s , int loc , Bool want_async ) 
{ 


  {
#line 732
  if ((unsigned long )conf_s != (unsigned long )((void *)0)) {
#line 735
    if ((unsigned int )(text_s->misc_items + (loc + 1))->type == 6U) {
      {
#line 737
      l2g_delete(& conf_s->texts, (text_s->misc_items + (loc + 1))->datum.local_no);
#line 739
      mark_conference_as_changed(conf_no);
      }
    } else {
      {
#line 743
      kom_log("Bad misc-info-list detected in perform_subtraction() for text number %lu.\n",
              text_no);
      }
    }
  }
#line 748
  if (want_async) {
    {
#line 749
    send_async_sub_recipient(text_no, (Text_stat const   *)text_s, conf_no, (text_s->misc_items + loc)->type);
    }
  }
  {
#line 752
  do_delete_misc(& text_s->no_of_misc, text_s->misc_items, loc);
#line 753
  mark_text_as_changed(text_no);
  }
#line 755
  return ((Success )OK);
}
}
#line 763 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success do_sub_recpt(Text_no text_no , Text_stat *text_s , Conf_no conf_no ,
                            Conference *conf_s , Bool want_async ) 
{ 
  int i ;
  Success tmp ;

  {
#line 772
  if ((unsigned long )text_s == (unsigned long )((void *)0)) {
    {
#line 773
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 773
      text_s = cached_get_text_stat(text_no);
      }
#line 773
      if ((unsigned long )text_s == (unsigned long )((void *)0)) {
#line 773
        return ((Success )FAILURE);
      }
#line 773
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 775
  if ((unsigned long )conf_s == (unsigned long )((void *)0)) {
    {
#line 776
    conf_s = cached_get_conf_stat(conf_no);
    }
  }
#line 778
  i = 0;
  {
#line 778
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 778
    if (! (i < (int )text_s->no_of_misc)) {
#line 778
      goto while_break___0;
    }
    {
#line 784
    if ((unsigned int )(text_s->misc_items + i)->type == 15U) {
#line 784
      goto case_15;
    }
#line 784
    if ((unsigned int )(text_s->misc_items + i)->type == 1U) {
#line 784
      goto case_15;
    }
#line 784
    if ((unsigned int )(text_s->misc_items + i)->type == 0U) {
#line 784
      goto case_15;
    }
#line 797
    if ((unsigned int )(text_s->misc_items + i)->type == 9U) {
#line 797
      goto case_9;
    }
#line 797
    if ((unsigned int )(text_s->misc_items + i)->type == 8U) {
#line 797
      goto case_9;
    }
#line 797
    if ((unsigned int )(text_s->misc_items + i)->type == 7U) {
#line 797
      goto case_9;
    }
#line 797
    if ((unsigned int )(text_s->misc_items + i)->type == 6U) {
#line 797
      goto case_9;
    }
#line 797
    if ((unsigned int )(text_s->misc_items + i)->type == 5U) {
#line 797
      goto case_9;
    }
#line 797
    if ((unsigned int )(text_s->misc_items + i)->type == 4U) {
#line 797
      goto case_9;
    }
#line 797
    if ((unsigned int )(text_s->misc_items + i)->type == 3U) {
#line 797
      goto case_9;
    }
#line 797
    if ((unsigned int )(text_s->misc_items + i)->type == 2U) {
#line 797
      goto case_9;
    }
#line 801
    goto switch_default;
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 785
    if ((int )(text_s->misc_items + i)->datum.recipient == (int )conf_no) {
      {
#line 786
      tmp = perform_subtraction(text_no, text_s, conf_no, conf_s, i, want_async);
      }
#line 786
      return (tmp);
    }
#line 788
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 798
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 804
    kom_log("do_sub_recpt(): bad misc_item.\n");
    }
#line 805
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 778
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 809
  err_stat = (unsigned long )conf_no;
#line 810
  kom_errno = (enum kom_err )30;
#line 811
  return ((Success )FAILURE);
}
}
#line 817 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static void remove_misc_item(Text_no text , Text_stat *text_s , enum info_type info_type ,
                             Text_no other ) 
{ 
  int i ;

  {
#line 825
  if (! ((unsigned int )info_type == 2U)) {
#line 825
    if (! ((unsigned int )info_type == 3U)) {
#line 825
      if (! ((unsigned int )info_type == 4U)) {
#line 825
        if (! ((unsigned int )info_type == 5U)) {
          {
#line 825
          __assert_fail("info_type == comm_to || info_type == comm_in || info_type == footn_to || info_type == footn_in",
                        "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c",
                        826U, "remove_misc_item");
          }
        }
      }
    }
  }
#line 828
  i = 0;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! (i < (int )text_s->no_of_misc)) {
#line 828
      goto while_break;
    }
#line 830
    if ((unsigned int )(text_s->misc_items + i)->type == (unsigned int )info_type) {
#line 830
      if ((text_s->misc_items + i)->datum.text_link == other) {
        {
#line 833
        do_delete_misc(& text_s->no_of_misc, text_s->misc_items, i);
#line 834
        mark_text_as_changed(text);
        }
#line 835
        return;
      }
    }
#line 828
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 839
  restart_kom("remove_misc_item() failed.\n");
  }
}
}
#line 845 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static void do_sub_comment(Text_no comment , Text_stat *text_s , Text_no comment_to ,
                           Text_stat *parent_s ) 
{ 


  {
#line 851
  if ((unsigned long )text_s == (unsigned long )((void *)0)) {
    {
#line 852
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 852
      text_s = cached_get_text_stat(comment);
      }
#line 852
      if ((unsigned long )text_s == (unsigned long )((void *)0)) {
#line 852
        return;
      }
#line 852
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 854
  if ((unsigned long )parent_s == (unsigned long )((void *)0)) {
    {
#line 855
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 855
      parent_s = cached_get_text_stat(comment_to);
      }
#line 855
      if ((unsigned long )parent_s == (unsigned long )((void *)0)) {
#line 855
        return;
      }
#line 855
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 857
  remove_misc_item(comment, text_s, (enum info_type )2, comment_to);
#line 858
  remove_misc_item(comment_to, parent_s, (enum info_type )3, comment);
  }
#line 859
  return;
}
}
#line 865 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static void do_sub_footnote(Text_no footnote , Text_stat *text_s , Text_no footnote_to ,
                            Text_stat *parent_s ) 
{ 


  {
#line 871
  if ((unsigned long )text_s == (unsigned long )((void *)0)) {
    {
#line 872
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 872
      text_s = cached_get_text_stat(footnote);
      }
#line 872
      if ((unsigned long )text_s == (unsigned long )((void *)0)) {
#line 872
        return;
      }
#line 872
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 874
  if ((unsigned long )parent_s == (unsigned long )((void *)0)) {
    {
#line 875
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 875
      parent_s = cached_get_text_stat(footnote_to);
      }
#line 875
      if ((unsigned long )parent_s == (unsigned long )((void *)0)) {
#line 875
        return;
      }
#line 875
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 877
  remove_misc_item(footnote, text_s, (enum info_type )4, footnote_to);
#line 878
  remove_misc_item(footnote_to, parent_s, (enum info_type )5, footnote);
  }
#line 879
  return;
}
}
#line 886 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Bool is_supervisor_of_sender(Text_stat const   *t_stat , int i , Connection const   *conn ) 
{ 
  Bool tmp ;

  {
#line 891
  i ++;
  {
#line 891
  while (1) {
    while_continue: /* CIL Label */ ;
#line 891
    if (! (i < (int )t_stat->no_of_misc)) {
#line 891
      goto while_break;
    }
    {
#line 895
    if ((unsigned int )(t_stat->misc_items + i)->type == 8U) {
#line 895
      goto case_8;
    }
#line 905
    if ((unsigned int )(t_stat->misc_items + i)->type == 9U) {
#line 905
      goto case_9;
    }
#line 905
    if ((unsigned int )(t_stat->misc_items + i)->type == 5U) {
#line 905
      goto case_9;
    }
#line 905
    if ((unsigned int )(t_stat->misc_items + i)->type == 4U) {
#line 905
      goto case_9;
    }
#line 905
    if ((unsigned int )(t_stat->misc_items + i)->type == 3U) {
#line 905
      goto case_9;
    }
#line 905
    if ((unsigned int )(t_stat->misc_items + i)->type == 2U) {
#line 905
      goto case_9;
    }
#line 905
    if ((unsigned int )(t_stat->misc_items + i)->type == 15U) {
#line 905
      goto case_9;
    }
#line 905
    if ((unsigned int )(t_stat->misc_items + i)->type == 1U) {
#line 905
      goto case_9;
    }
#line 905
    if ((unsigned int )(t_stat->misc_items + i)->type == 0U) {
#line 905
      goto case_9;
    }
#line 909
    if ((unsigned int )(t_stat->misc_items + i)->type == 7U) {
#line 909
      goto case_7;
    }
#line 909
    if ((unsigned int )(t_stat->misc_items + i)->type == 6U) {
#line 909
      goto case_7;
    }
#line 913
    goto switch_default;
    case_8: /* CIL Label */ 
    {
#line 896
    tmp = is_supervisor((t_stat->misc_items + i)->datum.sender, conn);
    }
#line 896
    return (tmp);
    case_9: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 906
    return ((Bool )0);
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 910
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 916
    restart_kom("ERROR: is_supervisor_of_sender(): Illegal misc_item found.\n");
    }
    switch_break: /* CIL Label */ ;
    }
#line 891
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return ((Bool )0);
}
}
#line 931 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success check_footn(Text_stat const   *t_stat ) 
{ 
  int tmp ;

  {
#line 934
  if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 937
    kom_errno = (enum kom_err )37;
#line 938
    return ((Success )FAILURE);
  } else
#line 934
  if ((int const   )t_stat->author != (int const   )active_connection->pers_no) {
#line 937
    kom_errno = (enum kom_err )37;
#line 938
    return ((Success )FAILURE);
  }
  {
#line 941
  tmp = count_footn(t_stat);
  }
#line 941
  if (tmp >= param.max_foot) {
#line 943
    err_stat = 0UL;
#line 944
    kom_errno = (enum kom_err )35;
#line 945
    return ((Success )FAILURE);
  }
#line 948
  return ((Success )OK);
}
}
#line 957 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success check_comm(Text_stat const   *t_stat ) 
{ 
  int tmp ;

  {
  {
#line 960
  tmp = count_comment(t_stat);
  }
#line 960
  if (tmp >= param.max_comm) {
#line 962
    kom_errno = (enum kom_err )34;
#line 963
    return ((Success )FAILURE);
  }
#line 966
  return ((Success )OK);
}
}
#line 974 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Mark *locate_mark(Pers_no pers_no , Person const   *pers_p , Text_no text_no ) 
{ 
  Mark *mp ;
  Mark *result ;
  int i ;
  Mark_list mlist ;
  Person *tmp ;

  {
#line 980
  result = (Mark *)((void *)0);
#line 984
  if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
    {
#line 985
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 985
      tmp = cached_get_person_stat(pers_no);
#line 985
      pers_p = (Person const   *)tmp;
      }
#line 985
      if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 985
        return ((Mark *)((void *)0));
      }
#line 985
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 987
  mlist = (Mark_list )pers_p->marks;
#line 989
  i = (int )mlist.no_of_marks;
#line 989
  mp = mlist.marks;
  {
#line 989
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 989
    if (i > 0) {
#line 989
      if (! ((unsigned long )result == (unsigned long )((void *)0))) {
#line 989
        goto while_break___0;
      }
    } else {
#line 989
      goto while_break___0;
    }
#line 993
    if (mp->text_no == text_no) {
#line 994
      result = mp;
    }
#line 989
    i --;
#line 989
    mp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 997
  return (result);
}
}
#line 1005 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static unsigned short skip_recp(unsigned short misc_index , Text_stat const   *text_stat ) 
{ 


  {
#line 1009
  misc_index = (unsigned short )((int )misc_index + 1);
  {
#line 1010
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1010
    if (! ((int )misc_index < (int )text_stat->no_of_misc)) {
#line 1010
      goto while_break;
    }
    {
#line 1017
    if ((unsigned int )(text_stat->misc_items + misc_index)->type == 9U) {
#line 1017
      goto case_9;
    }
#line 1017
    if ((unsigned int )(text_stat->misc_items + misc_index)->type == 8U) {
#line 1017
      goto case_9;
    }
#line 1017
    if ((unsigned int )(text_stat->misc_items + misc_index)->type == 7U) {
#line 1017
      goto case_9;
    }
#line 1017
    if ((unsigned int )(text_stat->misc_items + misc_index)->type == 6U) {
#line 1017
      goto case_9;
    }
#line 1027
    if ((unsigned int )(text_stat->misc_items + misc_index)->type == 5U) {
#line 1027
      goto case_5;
    }
#line 1027
    if ((unsigned int )(text_stat->misc_items + misc_index)->type == 4U) {
#line 1027
      goto case_5;
    }
#line 1027
    if ((unsigned int )(text_stat->misc_items + misc_index)->type == 3U) {
#line 1027
      goto case_5;
    }
#line 1027
    if ((unsigned int )(text_stat->misc_items + misc_index)->type == 2U) {
#line 1027
      goto case_5;
    }
#line 1027
    if ((unsigned int )(text_stat->misc_items + misc_index)->type == 15U) {
#line 1027
      goto case_5;
    }
#line 1027
    if ((unsigned int )(text_stat->misc_items + misc_index)->type == 1U) {
#line 1027
      goto case_5;
    }
#line 1027
    if ((unsigned int )(text_stat->misc_items + misc_index)->type == 0U) {
#line 1027
      goto case_5;
    }
#line 1031
    goto switch_default;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 1018
    misc_index = (unsigned short )((int )misc_index + 1);
#line 1019
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1028
    return (misc_index);
#line 1029
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1034
    restart_kom("skip_recp() - illegal misc\n");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1037
  return (misc_index);
}
}
#line 1048 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static void filter_secret_info(Text_stat *result , Text_stat const   *original , Connection const   *viewer_conn ,
                               Bool output_bcc ) 
{ 
  unsigned short orig ;
  unsigned short copy ;
  Pers_no bcc ;
  void *tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  Bool tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  Bool tmp___5 ;
  Membership *tmp___6 ;
  Bool tmp___7 ;
  Bool tmp___8 ;
  Bool tmp___9 ;
  unsigned short tmp___10 ;
  unsigned short tmp___11 ;

  {
  {
#line 1061
  *result = (Text_stat )*original;
#line 1063
  filter_aux_item_list(& original->aux_item_list, & result->aux_item_list, viewer_conn);
#line 1067
  tmp = tmp_alloc((unsigned long )result->no_of_misc * sizeof(Misc_info ));
#line 1067
  result->misc_items = (Misc_info *)tmp;
#line 1068
  result->no_of_misc = (unsigned short)0;
#line 1070
  copy = (unsigned short)0;
#line 1071
  orig = (unsigned short)0;
  }
  {
#line 1071
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1071
    if (! ((int )orig < (int )original->no_of_misc)) {
#line 1071
      goto while_break;
    }
    {
#line 1076
    if ((unsigned int )(original->misc_items + orig)->type == 1U) {
#line 1076
      goto case_1;
    }
#line 1076
    if ((unsigned int )(original->misc_items + orig)->type == 0U) {
#line 1076
      goto case_1;
    }
#line 1090
    if ((unsigned int )(original->misc_items + orig)->type == 15U) {
#line 1090
      goto case_15;
    }
#line 1127
    if ((unsigned int )(original->misc_items + orig)->type == 9U) {
#line 1127
      goto case_9;
    }
#line 1127
    if ((unsigned int )(original->misc_items + orig)->type == 8U) {
#line 1127
      goto case_9;
    }
#line 1127
    if ((unsigned int )(original->misc_items + orig)->type == 5U) {
#line 1127
      goto case_9;
    }
#line 1127
    if ((unsigned int )(original->misc_items + orig)->type == 4U) {
#line 1127
      goto case_9;
    }
#line 1127
    if ((unsigned int )(original->misc_items + orig)->type == 3U) {
#line 1127
      goto case_9;
    }
#line 1127
    if ((unsigned int )(original->misc_items + orig)->type == 2U) {
#line 1127
      goto case_9;
    }
#line 1127
    if ((unsigned int )(original->misc_items + orig)->type == 7U) {
#line 1127
      goto case_9;
    }
#line 1127
    if ((unsigned int )(original->misc_items + orig)->type == 6U) {
#line 1127
      goto case_9;
    }
#line 1133
    goto switch_default;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 1077
    tmp___2 = has_access((original->misc_items + orig)->datum.recipient, viewer_conn,
                         (enum access )2);
    }
#line 1077
    if (tmp___2) {
      _L: /* CIL Label */ 
#line 1085
      tmp___0 = copy;
#line 1085
      copy = (unsigned short )((int )copy + 1);
#line 1085
      tmp___1 = orig;
#line 1085
      orig = (unsigned short )((int )orig + 1);
#line 1085
      *(result->misc_items + tmp___0) = *(original->misc_items + tmp___1);
#line 1086
      result->no_of_misc = (unsigned short )((int )result->no_of_misc + 1);
    } else
#line 1077
    if ((int const   )viewer_conn->ena_level >= 4) {
#line 1077
      if (viewer_conn->person) {
#line 1077
        if ((viewer_conn->person)->privileges.admin) {
#line 1077
          goto _L;
        } else {
          {
#line 1081
          orig = skip_recp(orig, original);
          }
        }
      } else {
        {
#line 1081
        orig = skip_recp(orig, original);
        }
      }
    } else {
      {
#line 1081
      orig = skip_recp(orig, original);
      }
    }
#line 1088
    goto switch_break;
    case_15: /* CIL Label */ 
#line 1100
    bcc = (original->misc_items + orig)->datum.recipient;
#line 1101
    if ((unsigned long )viewer_conn->person != (unsigned long )((void *)0)) {
      {
#line 1101
      tmp___5 = has_access(bcc, viewer_conn, (enum access )3);
      }
#line 1101
      if (tmp___5) {
#line 1101
        goto _L___0;
      } else {
        {
#line 1101
        tmp___6 = locate_membership(bcc, (Person const   *)viewer_conn->person);
        }
#line 1101
        if (tmp___6) {
#line 1101
          goto _L___0;
        } else
#line 1101
        if ((int const   )viewer_conn->ena_level >= 4) {
#line 1101
          if (viewer_conn->person) {
#line 1101
            if ((viewer_conn->person)->privileges.admin) {
#line 1101
              goto _L___0;
            } else {
#line 1101
              goto _L___2;
            }
          } else {
#line 1101
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
          {
#line 1101
          tmp___7 = is_supervisor_of_sender(original, (int )orig, viewer_conn);
          }
#line 1101
          if (tmp___7) {
#line 1101
            goto _L___0;
          } else {
            {
#line 1101
            tmp___8 = is_supervisor((Conf_no )original->author, viewer_conn);
            }
#line 1101
            if (tmp___8) {
              {
#line 1101
              tmp___9 = has_access(bcc, viewer_conn, (enum access )2);
              }
#line 1101
              if (tmp___9) {
                _L___0: /* CIL Label */ 
#line 1109
                tmp___3 = copy;
#line 1109
                copy = (unsigned short )((int )copy + 1);
#line 1109
                tmp___4 = orig;
#line 1109
                orig = (unsigned short )((int )orig + 1);
#line 1109
                *(result->misc_items + tmp___3) = *(original->misc_items + tmp___4);
#line 1110
                result->no_of_misc = (unsigned short )((int )result->no_of_misc + 1);
#line 1111
                if (! output_bcc) {
#line 1112
                  (result->misc_items + ((int )copy - 1))->type = (enum info_type )1;
                }
              } else {
                {
#line 1116
                orig = skip_recp(orig, original);
                }
              }
            } else {
              {
#line 1116
              orig = skip_recp(orig, original);
              }
            }
          }
        }
      }
    } else {
      {
#line 1116
      orig = skip_recp(orig, original);
      }
    }
#line 1118
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 1128
    tmp___10 = copy;
#line 1128
    copy = (unsigned short )((int )copy + 1);
#line 1128
    tmp___11 = orig;
#line 1128
    orig = (unsigned short )((int )orig + 1);
#line 1128
    *(result->misc_items + tmp___10) = *(original->misc_items + tmp___11);
#line 1129
    result->no_of_misc = (unsigned short )((int )result->no_of_misc + 1);
#line 1130
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1136
    restart_kom("filter_secret_info() - illegal misc_item!\n");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  return;
}
}
#line 1141 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Bool interested_party(Connection const   *cptr , Text_no tno , Text_stat const   *text_s ) 
{ 
  Bool tmp ;
  Bool tmp___0 ;

  {
#line 1146
  if ((unsigned long )cptr->person == (unsigned long )((void *)0)) {
#line 1147
    return ((Bool )0);
  }
  {
#line 1149
  tmp = is_member_in_recpt((Person const   *)cptr->person, text_s, (Bool )1);
  }
#line 1149
  if ((unsigned int )tmp == 1U) {
#line 1150
    return ((Bool )1);
  }
  {
#line 1152
  tmp___0 = is_member_in_linked_recpt((Person const   *)cptr->person, tno, text_s,
                                      (Bool )1);
  }
#line 1152
  if ((unsigned int )tmp___0 == 1U) {
#line 1153
    return ((Bool )1);
  }
#line 1155
  return ((Bool )0);
}
}
#line 1163 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static void send_async_deleted_text(Text_no text_no , Text_stat const   *text_s ) 
{ 
  Connection *cptr ;
  Text_stat filtered ;
  Session_no i ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  {
#line 1169
  i = (Session_no )0;
#line 1171
  init_text_stat(& filtered);
  }
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1173
    i = traverse_connections(i);
    }
#line 1173
    if (! (i != 0UL)) {
#line 1173
      goto while_break;
    }
    {
#line 1175
    cptr = get_conn_by_number(i);
#line 1176
    tmp = interested_party((Connection const   *)cptr, text_no, text_s);
    }
#line 1176
    if (tmp) {
      {
#line 1176
      tmp___0 = text_read_access((Connection const   *)cptr, text_no, text_s);
      }
#line 1176
      if (tmp___0) {
        {
#line 1179
        filter_secret_info(& filtered, text_s, (Connection const   *)cptr, (Bool )1);
#line 1180
        async_deleted_text(cptr, text_no, & filtered);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1228
  return;
}
}
#line 1239 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
Bool text_read_access(Connection const   *conn , Text_no text_no , Text_stat const   *text_stat ) 
{ 
  int i ;
  Misc_info *misc ;
  Conference *recipient ;
  Text_stat *tmp ;
  Membership *tmp___0 ;
  Mark *tmp___1 ;
  Bool tmp___2 ;

  {
#line 1244
  i = 0;
#line 1245
  misc = (Misc_info *)((void *)0);
#line 1246
  recipient = (Conference *)((void *)0);
#line 1248
  if ((unsigned long )conn == (unsigned long )((void *)0)) {
    {
#line 1250
    kom_log("ERROR: text_read_access() called with conn==NULL for t=%ld\n", text_no);
    }
#line 1252
    return ((Bool )0);
  }
#line 1257
  if (text_no == kom_info.motd_of_lyskom) {
#line 1258
    return ((Bool )1);
  }
#line 1260
  if ((unsigned long )text_stat == (unsigned long )((void *)0)) {
    {
#line 1260
    tmp = cached_get_text_stat(text_no);
#line 1260
    text_stat = (Text_stat const   *)tmp;
    }
#line 1260
    if ((unsigned long )text_stat == (unsigned long )((void *)0)) {
#line 1263
      if (! conn->pers_no) {
#line 1267
        err_stat = 0UL;
#line 1268
        kom_errno = (enum kom_err )6;
      }
#line 1270
      return ((Bool )0);
    }
  }
#line 1275
  i = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! (i < (int )text_stat->aux_item_list.length)) {
#line 1275
      goto while_break;
    }
#line 1276
    if ((text_stat->aux_item_list.items + i)->tag == 34UL) {
#line 1277
      return ((Bool )1);
    }
#line 1275
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1281
  if (! conn->pers_no) {
#line 1283
    err_stat = 0UL;
#line 1284
    kom_errno = (enum kom_err )6;
#line 1285
    return ((Bool )0);
  }
#line 1290
  if ((int const   )conn->ena_level >= 10) {
#line 1290
    if (conn->person) {
#line 1290
      if ((conn->person)->privileges.wheel) {
#line 1291
        return ((Bool )1);
      }
    }
  }
#line 1293
  if ((int const   )text_stat->author == (int const   )conn->pers_no) {
#line 1294
    return ((Bool )1);
  }
#line 1298
  i = (int )text_stat->no_of_misc;
#line 1298
  misc = (Misc_info *)text_stat->misc_items;
  {
#line 1298
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1298
    if (! i) {
#line 1298
      goto while_break___0;
    }
#line 1301
    if ((unsigned int )misc->type == 0U) {
#line 1301
      goto _L;
    } else
#line 1301
    if ((unsigned int )misc->type == 1U) {
#line 1301
      goto _L;
    } else
#line 1301
    if ((unsigned int )misc->type == 15U) {
      _L: /* CIL Label */ 
#line 1301
      if ((int )misc->datum.recipient == (int )conn->cwc) {
#line 1307
        return ((Bool )1);
      } else
#line 1301
      if ((int )misc->datum.recipient == (int )conn->pers_no) {
#line 1307
        return ((Bool )1);
      }
    }
#line 1298
    i --;
#line 1298
    misc ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1313
  i = (int )text_stat->no_of_misc;
#line 1313
  misc = (Misc_info *)text_stat->misc_items;
  {
#line 1313
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1313
    if (! (i > 0)) {
#line 1313
      goto while_break___1;
    }
#line 1317
    if ((unsigned int )misc->type == 0U) {
#line 1317
      goto _L___0;
    } else
#line 1317
    if ((unsigned int )misc->type == 1U) {
#line 1317
      goto _L___0;
    } else
#line 1317
    if ((unsigned int )misc->type == 15U) {
      _L___0: /* CIL Label */ 
      {
#line 1317
      tmp___0 = locate_membership(misc->datum.recipient, (Person const   *)conn->person);
      }
#line 1317
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1322
        return ((Bool )1);
      }
    }
#line 1313
    i --;
#line 1313
    misc ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1326
  tmp___1 = locate_mark((Pers_no )conn->pers_no, (Person const   *)conn->person, text_no);
  }
#line 1326
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 1327
    return ((Bool )1);
  }
#line 1334
  i = (int )text_stat->no_of_misc;
#line 1334
  misc = (Misc_info *)text_stat->misc_items;
  {
#line 1334
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1334
    if (! (i > 0)) {
#line 1334
      goto while_break___2;
    }
#line 1338
    if ((unsigned int )misc->type == 0U) {
#line 1338
      goto _L___3;
    } else
#line 1338
    if ((unsigned int )misc->type == 1U) {
#line 1338
      goto _L___3;
    } else
#line 1338
    if ((unsigned int )misc->type == 15U) {
      _L___3: /* CIL Label */ 
      {
#line 1338
      recipient = cached_get_conf_stat(misc->datum.recipient);
      }
#line 1338
      if ((unsigned long )recipient != (unsigned long )((void *)0)) {
#line 1343
        if (! recipient->type.rd_prot) {
#line 1347
          return ((Bool )1);
        } else
#line 1343
        if ((int const   )conn->ena_level >= 8) {
#line 1343
          if (conn->person) {
#line 1343
            if ((conn->person)->privileges.wheel) {
#line 1347
              return ((Bool )1);
            } else {
#line 1343
              goto _L___2;
            }
          } else {
#line 1343
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
          {
#line 1343
          tmp___2 = is_supervisor(misc->datum.recipient, conn);
          }
#line 1343
          if ((unsigned int )tmp___2 == 1U) {
#line 1347
            return ((Bool )1);
          }
        }
      }
    }
#line 1334
    i --;
#line 1334
    misc ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1352
  return ((Bool )0);
}
}
#line 1356 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
Success do_delete_text(Text_no text_no , Text_stat *text_s ) 
{ 
  Person *author ;
  Success tmp ;

  {
#line 1362
  if ((unsigned long )text_s == (unsigned long )((void *)0)) {
    {
#line 1363
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1363
      text_s = cached_get_text_stat(text_no);
      }
#line 1363
      if ((unsigned long )text_s == (unsigned long )((void *)0)) {
#line 1363
        return ((Success )FAILURE);
      }
#line 1363
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1365
  send_async_deleted_text(text_no, (Text_stat const   *)text_s);
#line 1367
  author = cached_get_person_stat(text_s->author);
  }
#line 1367
  if ((unsigned long )author != (unsigned long )((void *)0)) {
    {
#line 1369
    l2g_delete_global_in_sorted(& author->created_texts, text_no);
#line 1370
    mark_person_as_changed(text_s->author);
    }
  }
  {
#line 1373
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1373
    if (! ((int )text_s->no_of_misc > 0)) {
#line 1373
      goto while_break___0;
    }
    {
#line 1379
    if ((unsigned int )(text_s->misc_items + 0)->type == 15U) {
#line 1379
      goto case_15;
    }
#line 1379
    if ((unsigned int )(text_s->misc_items + 0)->type == 1U) {
#line 1379
      goto case_15;
    }
#line 1379
    if ((unsigned int )(text_s->misc_items + 0)->type == 0U) {
#line 1379
      goto case_15;
    }
#line 1386
    if ((unsigned int )(text_s->misc_items + 0)->type == 2U) {
#line 1386
      goto case_2;
    }
#line 1391
    if ((unsigned int )(text_s->misc_items + 0)->type == 3U) {
#line 1391
      goto case_3;
    }
#line 1396
    if ((unsigned int )(text_s->misc_items + 0)->type == 4U) {
#line 1396
      goto case_4;
    }
#line 1401
    if ((unsigned int )(text_s->misc_items + 0)->type == 5U) {
#line 1401
      goto case_5;
    }
#line 1410
    if ((unsigned int )(text_s->misc_items + 0)->type == 9U) {
#line 1410
      goto case_9;
    }
#line 1410
    if ((unsigned int )(text_s->misc_items + 0)->type == 8U) {
#line 1410
      goto case_9;
    }
#line 1410
    if ((unsigned int )(text_s->misc_items + 0)->type == 7U) {
#line 1410
      goto case_9;
    }
#line 1410
    if ((unsigned int )(text_s->misc_items + 0)->type == 6U) {
#line 1410
      goto case_9;
    }
#line 1413
    goto switch_default;
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 1380
    tmp = do_sub_recpt(text_no, text_s, (text_s->misc_items + 0)->datum.recipient,
                       (Conference *)((void *)0), (Bool )0);
    }
#line 1380
    if ((unsigned long )tmp != (unsigned long )OK) {
      {
#line 1383
      restart_kom("do_delete_text(): error pos 1.\n");
      }
    }
#line 1384
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1387
    do_sub_comment(text_no, text_s, (text_s->misc_items + 0)->datum.text_link, (Text_stat *)((void *)0));
    }
#line 1389
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1392
    do_sub_comment((text_s->misc_items + 0)->datum.text_link, (Text_stat *)((void *)0),
                   text_no, text_s);
    }
#line 1394
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1397
    do_sub_footnote(text_no, text_s, (text_s->misc_items + 0)->datum.text_link, (Text_stat *)((void *)0));
    }
#line 1399
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1402
    do_sub_footnote((text_s->misc_items + 0)->datum.text_link, (Text_stat *)((void *)0),
                    text_no, text_s);
    }
#line 1404
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    {
#line 1411
    restart_kom("do_delete_text(): Illegal misc-item syntax.\n");
    }
    switch_default: /* CIL Label */ 
    {
#line 1416
    restart_kom("do_delete_text(): Illegal misc-item.\n");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1420
  cached_delete_text(text_no);
#line 1421
  update_stat((enum stat_type )5, -1L);
  }
#line 1422
  return ((Success )OK);
}
}
#line 1438 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success get_marks(Mark_list *result ) 
{ 


  {
  {
#line 1441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1441
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1441
      err_stat = 0UL;
#line 1441
      kom_errno = (enum kom_err )51;
#line 1441
      return ((Success )FAILURE);
    }
#line 1441
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1442
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1442
    if (! active_connection) {
#line 1442
      err_stat = 0UL;
#line 1442
      kom_errno = (enum kom_err )6;
#line 1442
      return ((Success )FAILURE);
    } else
#line 1442
    if (! active_connection->pers_no) {
#line 1442
      err_stat = 0UL;
#line 1442
      kom_errno = (enum kom_err )6;
#line 1442
      return ((Success )FAILURE);
    }
#line 1442
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1443
  *result = (active_connection->person)->marks;
#line 1444
  return ((Success )OK);
}
}
#line 1455 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success get_text(Text_no text_no , String_size start_char , String_size end_char ,
                        String *result ) 
{ 
  Text_stat *text_s ;
  Bool tmp ;
  String_size tmp___0 ;

  {
  {
#line 1463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1463
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1463
      err_stat = 0UL;
#line 1463
      kom_errno = (enum kom_err )51;
#line 1463
      return ((Success )FAILURE);
    }
#line 1463
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1464
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1464
    text_s = cached_get_text_stat(text_no);
    }
#line 1464
    if ((unsigned long )text_s == (unsigned long )((void *)0)) {
#line 1464
      return ((Success )FAILURE);
    }
#line 1464
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1468
  tmp = text_read_access((Connection const   *)active_connection, text_no, (Text_stat const   *)text_s);
  }
#line 1468
  if ((unsigned int )tmp != 1U) {
#line 1470
    kom_errno = (enum kom_err )14;
#line 1471
    err_stat = text_no;
#line 1473
    return ((Success )FAILURE);
  }
  {
#line 1476
  *result = cached_get_text(text_no);
  }
#line 1478
  if (start_char > result->len) {
#line 1480
    err_stat = (unsigned long )start_char;
#line 1481
    kom_errno = (enum kom_err )19;
#line 1482
    return ((Success )FAILURE);
  }
#line 1486
  result->string += start_char;
#line 1487
  if (result->len - 1L > end_char) {
#line 1487
    tmp___0 = end_char;
  } else {
#line 1487
    tmp___0 = result->len - 1L;
  }
#line 1487
  result->len = (tmp___0 + 1L) - start_char;
#line 1489
  if (active_connection->pers_no) {
    {
#line 1491
    ((active_connection->person)->no_of_text_fetches) ++;
#line 1492
    mark_person_as_changed(active_connection->pers_no);
    }
  }
#line 1495
  return ((Success )OK);
}
}
#line 1506 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success get_text_stat_old(Text_no text_no , Text_stat *result ) 
{ 
  Text_stat *text_stat ;
  Bool tmp ;

  {
  {
#line 1512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1512
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1512
      err_stat = 0UL;
#line 1512
      kom_errno = (enum kom_err )51;
#line 1512
      return ((Success )FAILURE);
    }
#line 1512
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1513
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1513
    text_stat = cached_get_text_stat(text_no);
    }
#line 1513
    if ((unsigned long )text_stat == (unsigned long )((void *)0)) {
#line 1513
      return ((Success )FAILURE);
    }
#line 1513
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1515
  tmp = text_read_access((Connection const   *)active_connection, text_no, (Text_stat const   *)text_stat);
  }
#line 1515
  if (! tmp) {
#line 1515
    if (active_connection) {
#line 1515
      if ((int )active_connection->ena_level >= 2) {
#line 1515
        if (! (active_connection->person)->privileges.admin) {
#line 1518
          kom_errno = (enum kom_err )14;
#line 1519
          err_stat = text_no;
#line 1520
          return ((Success )FAILURE);
        }
      } else {
#line 1518
        kom_errno = (enum kom_err )14;
#line 1519
        err_stat = text_no;
#line 1520
        return ((Success )FAILURE);
      }
    } else {
#line 1518
      kom_errno = (enum kom_err )14;
#line 1519
      err_stat = text_no;
#line 1520
      return ((Success )FAILURE);
    }
  }
  {
#line 1523
  filter_secret_info(result, (Text_stat const   *)text_stat, (Connection const   *)active_connection,
                     (Bool )0);
  }
#line 1524
  return ((Success )OK);
}
}
#line 1527 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success get_text_stat(Text_no text_no , Text_stat *result ) 
{ 
  Text_stat *text_stat ;
  Bool tmp ;

  {
  {
#line 1533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1533
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1533
      err_stat = 0UL;
#line 1533
      kom_errno = (enum kom_err )51;
#line 1533
      return ((Success )FAILURE);
    }
#line 1533
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1534
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1534
    text_stat = cached_get_text_stat(text_no);
    }
#line 1534
    if ((unsigned long )text_stat == (unsigned long )((void *)0)) {
#line 1534
      return ((Success )FAILURE);
    }
#line 1534
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1536
  tmp = text_read_access((Connection const   *)active_connection, text_no, (Text_stat const   *)text_stat);
  }
#line 1536
  if (! tmp) {
#line 1536
    if (active_connection) {
#line 1536
      if ((int )active_connection->ena_level >= 2) {
#line 1536
        if (! (active_connection->person)->privileges.admin) {
#line 1541
          kom_errno = (enum kom_err )14;
#line 1542
          err_stat = text_no;
#line 1543
          return ((Success )FAILURE);
        }
      } else {
#line 1541
        kom_errno = (enum kom_err )14;
#line 1542
        err_stat = text_no;
#line 1543
        return ((Success )FAILURE);
      }
    } else {
#line 1541
      kom_errno = (enum kom_err )14;
#line 1542
      err_stat = text_no;
#line 1543
      return ((Success )FAILURE);
    }
  }
  {
#line 1546
  filter_secret_info(result, (Text_stat const   *)text_stat, (Connection const   *)active_connection,
                     (Bool )1);
  }
#line 1547
  return ((Success )OK);
}
}
#line 1559 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success check_anonymous_subm(Conf_no addressee ) 
{ 
  Conf_type conf_type ;

  {
  {
#line 1564
  conf_type = cached_get_conf_type(addressee);
  }
#line 1565
  if (conf_type.allow_anon) {
#line 1566
    return ((Success )OK);
  } else {
#line 1568
    return ((Success )FAILURE);
  }
}
}
#line 1575 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success check_double_subm(Misc_info const   *misc , int loc , Conf_no addressee ) 
{ 
  int j ;

  {
#line 1582
  j = 0;
  {
#line 1582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1582
    if (! (j < loc)) {
#line 1582
      goto while_break;
    }
    {
#line 1588
    if ((unsigned int const   )(misc + j)->type == 15U) {
#line 1588
      goto case_15;
    }
#line 1588
    if ((unsigned int const   )(misc + j)->type == 1U) {
#line 1588
      goto case_15;
    }
#line 1588
    if ((unsigned int const   )(misc + j)->type == 0U) {
#line 1588
      goto case_15;
    }
#line 1601
    if ((unsigned int const   )(misc + j)->type == 9U) {
#line 1601
      goto case_9;
    }
#line 1601
    if ((unsigned int const   )(misc + j)->type == 8U) {
#line 1601
      goto case_9;
    }
#line 1601
    if ((unsigned int const   )(misc + j)->type == 7U) {
#line 1601
      goto case_9;
    }
#line 1601
    if ((unsigned int const   )(misc + j)->type == 6U) {
#line 1601
      goto case_9;
    }
#line 1601
    if ((unsigned int const   )(misc + j)->type == 5U) {
#line 1601
      goto case_9;
    }
#line 1601
    if ((unsigned int const   )(misc + j)->type == 4U) {
#line 1601
      goto case_9;
    }
#line 1601
    if ((unsigned int const   )(misc + j)->type == 3U) {
#line 1601
      goto case_9;
    }
#line 1601
    if ((unsigned int const   )(misc + j)->type == 2U) {
#line 1601
      goto case_9;
    }
#line 1605
    goto switch_default;
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1589
    if ((int const   )(misc + j)->datum.recipient == (int const   )addressee) {
#line 1590
      return ((Success )FAILURE);
    }
#line 1592
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1602
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1608
    kom_log("check_double_subm(): bad misc_item.\n");
    }
#line 1609
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1582
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1612
  return ((Success )OK);
}
}
#line 1619 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success check_double_comm(Misc_info const   *misc , int pos , Text_no forbidden ) 
{ 


  {
  {
#line 1624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1624
    if (! (pos > 0)) {
#line 1624
      goto while_break;
    }
    {
#line 1629
    if ((unsigned int const   )misc->type == 4U) {
#line 1629
      goto case_4;
    }
#line 1629
    if ((unsigned int const   )misc->type == 2U) {
#line 1629
      goto case_4;
    }
#line 1642
    if ((unsigned int const   )misc->type == 9U) {
#line 1642
      goto case_9;
    }
#line 1642
    if ((unsigned int const   )misc->type == 8U) {
#line 1642
      goto case_9;
    }
#line 1642
    if ((unsigned int const   )misc->type == 7U) {
#line 1642
      goto case_9;
    }
#line 1642
    if ((unsigned int const   )misc->type == 6U) {
#line 1642
      goto case_9;
    }
#line 1642
    if ((unsigned int const   )misc->type == 5U) {
#line 1642
      goto case_9;
    }
#line 1642
    if ((unsigned int const   )misc->type == 3U) {
#line 1642
      goto case_9;
    }
#line 1642
    if ((unsigned int const   )misc->type == 15U) {
#line 1642
      goto case_9;
    }
#line 1642
    if ((unsigned int const   )misc->type == 1U) {
#line 1642
      goto case_9;
    }
#line 1642
    if ((unsigned int const   )misc->type == 0U) {
#line 1642
      goto case_9;
    }
#line 1646
    goto switch_default;
    case_4: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1630
    if (misc->datum.text_link == (Text_no const   )forbidden) {
#line 1631
      return ((Success )FAILURE);
    }
#line 1632
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1643
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1649
    kom_log("check_double_comm(): bad misc_item.\n");
    }
#line 1650
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1624
    pos --;
#line 1624
    misc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1654
  return ((Success )OK);
}
}
#line 1665 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success create_text_check_misc(u_short *no_of_misc , Misc_info *misc , Bool anonymous ,
                                      Bool need_public_jubel ) 
{ 
  int i ;
  Text_stat *parent ;
  Conf_no addressee ;
  Bool tmp ;
  Success (*tmp___0)(Text_stat const   *t_stat ) ;
  Success tmp___1 ;
  Success tmp___2 ;
  Success tmp___3 ;
  Success tmp___4 ;
  Conf_type conf_type ;

  {
#line 1675
  i = 0;
  {
#line 1675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1675
    if (! (i < (int )*no_of_misc)) {
#line 1675
      goto while_break;
    }
#line 1677
    err_stat = (unsigned long )i;
    {
#line 1683
    if ((unsigned int )(misc + i)->type == 2U) {
#line 1683
      goto case_2;
    }
#line 1683
    if ((unsigned int )(misc + i)->type == 4U) {
#line 1683
      goto case_2;
    }
#line 1712
    if ((unsigned int )(misc + i)->type == 15U) {
#line 1712
      goto case_15;
    }
#line 1712
    if ((unsigned int )(misc + i)->type == 1U) {
#line 1712
      goto case_15;
    }
#line 1712
    if ((unsigned int )(misc + i)->type == 0U) {
#line 1712
      goto case_15;
    }
#line 1758
    if ((unsigned int )(misc + i)->type == 6U) {
#line 1758
      goto case_6;
    }
#line 1761
    if ((unsigned int )(misc + i)->type == 4711U) {
#line 1761
      goto case_4711;
    }
#line 1773
    goto switch_default;
    case_2: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 1684
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1684
      parent = cached_get_text_stat((misc + i)->datum.text_link);
      }
#line 1684
      if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 1684
        return ((Success )FAILURE);
      }
#line 1684
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1686
    tmp = text_read_access((Connection const   *)active_connection, (misc + i)->datum.text_link,
                           (Text_stat const   *)parent);
    }
#line 1686
    if (! tmp) {
#line 1690
      err_stat = (misc + i)->datum.text_link;
#line 1691
      kom_errno = (enum kom_err )14;
#line 1692
      return ((Success )FAILURE);
    }
#line 1695
    if ((unsigned int )(misc + i)->type == 4U) {
#line 1695
      tmp___0 = & check_footn;
    } else {
#line 1695
      tmp___0 = & check_comm;
    }
    {
#line 1695
    tmp___1 = (*tmp___0)((Text_stat const   *)parent);
    }
#line 1695
    if ((unsigned long )tmp___1 == (unsigned long )FAILURE) {
#line 1698
      err_stat = (misc + i)->datum.text_link;
#line 1699
      return ((Success )FAILURE);
    }
    {
#line 1702
    tmp___2 = check_double_comm((Misc_info const   *)misc, i, (misc + i)->datum.text_link);
    }
#line 1702
    if ((unsigned long )tmp___2 != (unsigned long )OK) {
#line 1704
      err_stat = (unsigned long )i;
#line 1705
      kom_errno = (enum kom_err )25;
#line 1706
      return ((Success )FAILURE);
    }
#line 1708
    goto switch_break;
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 1717
    addressee = submit_to((misc + i)->datum.recipient, (Conference const   *)((void *)0));
#line 1721
    (misc + i)->datum.recipient = addressee;
    }
#line 1722
    if ((int )addressee == 0) {
#line 1725
      return ((Success )FAILURE);
    }
    {
#line 1730
    tmp___3 = check_double_subm((Misc_info const   *)misc, i, addressee);
    }
#line 1730
    if ((unsigned long )tmp___3 != (unsigned long )OK) {
#line 1732
      err_stat = (unsigned long )i;
#line 1733
      kom_errno = (enum kom_err )25;
#line 1734
      return ((Success )FAILURE);
    }
#line 1739
    if (anonymous) {
      {
#line 1739
      tmp___4 = check_anonymous_subm(addressee);
      }
#line 1739
      if ((unsigned long )tmp___4 != (unsigned long )OK) {
#line 1741
        err_stat = (unsigned long )addressee;
#line 1742
        kom_errno = (enum kom_err )47;
#line 1743
        return ((Success )FAILURE);
      }
    }
#line 1748
    if (need_public_jubel) {
      {
#line 1752
      conf_type = cached_get_conf_type(addressee);
      }
#line 1753
      if (! conf_type.rd_prot) {
#line 1754
        need_public_jubel = (Bool )0;
      }
    }
#line 1756
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1759
    goto switch_break;
    case_4711: /* CIL Label */ 
#line 1762
    err_stat = (unsigned long )(misc + i)->datum.unknown_type;
#line 1763
    kom_errno = (enum kom_err )26;
#line 1764
    return ((Success )FAILURE);
    switch_default: /* CIL Label */ 
#line 1775
    err_stat = (unsigned long )i;
#line 1776
    kom_errno = (enum kom_err )25;
#line 1777
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
#line 1675
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1781
  if (need_public_jubel) {
    {
#line 1784
    err_stat = 0UL;
#line 1785
    kom_errno = (enum kom_err )45;
#line 1786
    kom_log("Jubel stopped because no public recipient was found.\n");
    }
#line 1787
    return ((Success )FAILURE);
  }
#line 1790
  return ((Success )OK);
}
}
#line 1797 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success create_text_add_aux(Text_stat *t_stat , Text_no text_no , Aux_item_list *aux ,
                                   Pers_no creator ) 
{ 
  u_short i ;
  Text_stat *parent ;
  Bool tmp ;

  {
  {
#line 1806
  text_stat_add_aux_item_list(t_stat, text_no, aux, creator);
#line 1808
  i = (u_short )0;
  }
  {
#line 1808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1808
    if (! ((int )i < (int )t_stat->no_of_misc)) {
#line 1808
      goto while_break;
    }
    {
#line 1813
    if ((unsigned int )(t_stat->misc_items + i)->type == 2U) {
#line 1813
      goto case_2;
    }
#line 1813
    if ((unsigned int )(t_stat->misc_items + i)->type == 4U) {
#line 1813
      goto case_2;
    }
#line 1829
    goto switch_default;
    case_2: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 1814
    parent = cached_get_text_stat((t_stat->misc_items + i)->datum.text_link);
    }
#line 1816
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
      {
#line 1816
      tmp = text_read_access((Connection const   *)active_connection, (t_stat->misc_items + i)->datum.text_link,
                             (Text_stat const   *)parent);
      }
#line 1816
      if (tmp) {
        {
#line 1821
        aux_inherit_items(& t_stat->aux_item_list, (Aux_item_list const   *)(& parent->aux_item_list),
                          & t_stat->highest_aux, t_stat->author, text_no, t_stat);
        }
      }
    }
#line 1827
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1830
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1808
    i = (u_short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1833
  return ((Success )OK);
}
}
#line 1841 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success create_text_add_miscs(Text_no new_text , Text_stat *new_stat , int no_of_misc ,
                                     Misc_info *misc ) 
{ 
  int i ;
  Conference *conf_c ;
  Success tmp ;
  Success tmp___0 ;
  Success tmp___1 ;

  {
#line 1850
  i = 0;
  {
#line 1850
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1850
    if (! (i < no_of_misc)) {
#line 1850
      goto while_break;
    }
#line 1852
    err_stat = (unsigned long )i;
    {
#line 1857
    if ((unsigned int )(misc + i)->type == 4U) {
#line 1857
      goto case_4;
    }
#line 1864
    if ((unsigned int )(misc + i)->type == 2U) {
#line 1864
      goto case_2;
    }
#line 1873
    if ((unsigned int )(misc + i)->type == 15U) {
#line 1873
      goto case_15;
    }
#line 1873
    if ((unsigned int )(misc + i)->type == 1U) {
#line 1873
      goto case_15;
    }
#line 1873
    if ((unsigned int )(misc + i)->type == 0U) {
#line 1873
      goto case_15;
    }
#line 1881
    if ((unsigned int )(misc + i)->type == 6U) {
#line 1881
      goto case_6;
    }
#line 1891
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 1858
    tmp = do_add_footnote(new_text, new_stat, (misc + i)->datum.text_link, (Text_stat *)((void *)0));
    }
#line 1858
    if ((unsigned long )tmp != (unsigned long )OK) {
#line 1860
      return ((Success )FAILURE);
    }
#line 1862
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1865
    tmp___0 = do_add_comment(new_text, new_stat, (misc + i)->datum.text_link, (Text_stat *)((void *)0));
    }
#line 1865
    if ((unsigned long )tmp___0 != (unsigned long )OK) {
#line 1867
      return ((Success )FAILURE);
    }
#line 1869
    goto switch_break;
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 1874
    tmp___1 = do_add_recipient(new_text, new_stat, (misc + i)->datum.recipient, (misc + i)->type);
    }
#line 1874
    if ((unsigned long )tmp___1 != (unsigned long )OK) {
#line 1876
      return ((Success )FAILURE);
    }
    {
#line 1877
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1877
      conf_c = cached_get_conf_stat((misc + i)->datum.recipient);
      }
#line 1877
      if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 1877
        return ((Success )FAILURE);
      }
#line 1877
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1878
    conf_c->last_written = current_time.tv_sec;
#line 1879
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1882
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1894
    restart_kom("create_text_add_misc() - illegal enum info_type");
    }
    switch_break: /* CIL Label */ ;
    }
#line 1850
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1897
  return ((Success )OK);
}
}
#line 1904 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static void send_async_new_text_old(Text_no text_no , Text_stat const   *text_s ) 
{ 
  Connection *cptr ;
  Session_no i ;
  Text_stat filtered ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  {
#line 1909
  i = (Session_no )0;
#line 1912
  init_text_stat(& filtered);
  }
  {
#line 1914
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1914
    i = traverse_connections(i);
    }
#line 1914
    if (! (i != 0UL)) {
#line 1914
      goto while_break;
    }
    {
#line 1916
    cptr = get_conn_by_number(i);
#line 1923
    tmp = interested_party((Connection const   *)cptr, text_no, text_s);
    }
#line 1923
    if (tmp) {
      {
#line 1923
      tmp___0 = text_read_access((Connection const   *)cptr, text_no, text_s);
      }
#line 1923
      if (tmp___0) {
        {
#line 1926
        filter_secret_info(& filtered, text_s, (Connection const   *)cptr, (Bool )0);
#line 1927
        async_new_text_old(cptr, text_no, & filtered);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1930
  return;
}
}
#line 1932 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static void send_async_new_text(Text_no text_no , Text_stat const   *text_s ) 
{ 
  Connection *cptr ;
  Session_no i ;
  Text_stat filtered ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  {
#line 1937
  i = (Session_no )0;
#line 1940
  init_text_stat(& filtered);
  }
  {
#line 1942
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    i = traverse_connections(i);
    }
#line 1942
    if (! (i != 0UL)) {
#line 1942
      goto while_break;
    }
    {
#line 1944
    cptr = get_conn_by_number(i);
#line 1951
    tmp = interested_party((Connection const   *)cptr, text_no, text_s);
    }
#line 1951
    if (tmp) {
      {
#line 1951
      tmp___0 = text_read_access((Connection const   *)cptr, text_no, text_s);
      }
#line 1951
      if (tmp___0) {
        {
#line 1954
        filter_secret_info(& filtered, text_s, (Connection const   *)cptr, (Bool )1);
#line 1955
        async_new_text(cptr, text_no, & filtered);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1958
  return;
}
}
#line 1981 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static struct jubel *jubel_root  =    (struct jubel *)((void *)0);
#line 2008 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
void free_all_jubel(void) 
{ 
  struct jubel *a ;
  struct jubel *b ;

  {
#line 2014
  a = jubel_root;
  {
#line 2015
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2015
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 2015
      goto while_break;
    }
    {
#line 2017
    b = a;
#line 2018
    a = a->next;
#line 2019
    sfree((void *)b);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2021
  jubel_root = (struct jubel *)((void *)0);
#line 2022
  return;
}
}
#line 2025 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Bool ok_to_create_next_text(Connection const   *conn , Bool *must_be_public ) 
{ 
  struct jubel *j ;
  Text_no next_tno ;
  Bool is_jubel ;

  {
#line 2031
  is_jubel = (Bool )0;
#line 2033
  *must_be_public = (Bool )0;
#line 2035
  if ((unsigned long )conn == (unsigned long )((void *)0)) {
#line 2036
    return ((Bool )0);
  }
  {
#line 2038
  next_tno = query_next_text_num();
#line 2039
  j = jubel_root;
  }
  {
#line 2039
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2039
    if (! ((unsigned long )j != (unsigned long )((void *)0))) {
#line 2039
      goto while_break;
    }
#line 2041
    if (j->divisor == 0UL) {
#line 2041
      if (next_tno == j->remainder) {
#line 2041
        goto _L;
      } else {
#line 2041
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2041
    if (j->divisor != 0UL) {
#line 2041
      if (next_tno % j->divisor == j->remainder) {
        _L: /* CIL Label */ 
#line 2044
        if ((int const   )conn->pers_no == (int const   )j->bad_guy) {
          {
#line 2046
          kom_log("Stopped person %d from creating jubel %lu.\n", (int const   )conn->pers_no,
                  next_tno);
          }
#line 2048
          return ((Bool )0);
        } else {
#line 2051
          is_jubel = (Bool )1;
        }
#line 2053
        if (j->public) {
#line 2054
          *must_be_public = (Bool )1;
        }
      }
    }
#line 2039
    j = j->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2058
  if (is_jubel) {
#line 2060
    if (*must_be_public) {
      {
#line 2061
      kom_log("Granted jubel %lu to person %d, pending public check.\n", next_tno,
              (int const   )conn->pers_no);
      }
    } else {
      {
#line 2064
      kom_log("Granted jubel %lu to person %d.\n", next_tno, (int const   )conn->pers_no);
      }
    }
  }
#line 2068
  return ((Bool )1);
}
}
#line 2083 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Text_no create_text_old(String const   message , Misc_info_list *misc_l ) 
{ 
  Text_stat *t_stat ;
  Text_no text ;

  {
  {
#line 2091
  text = do_create_text(message, misc_l->no_of_misc, misc_l->misc, (Aux_item_list *)((void *)0),
                        (Bool )0, & t_stat);
  }
#line 2094
  if (text != 0UL) {
    {
#line 2096
    send_async_new_text_old(text, (Text_stat const   *)t_stat);
#line 2097
    send_async_new_text(text, (Text_stat const   *)t_stat);
    }
  }
#line 2100
  return (text);
}
}
#line 2103 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Text_no create_text(String const   message , Misc_info_list *misc_l , Aux_item_list *aux ) 
{ 
  Text_stat *t_stat ;
  Text_no text ;

  {
  {
#line 2112
  text = do_create_text(message, misc_l->no_of_misc, misc_l->misc, aux, (Bool )0,
                        & t_stat);
  }
#line 2115
  if (text != 0UL) {
    {
#line 2117
    send_async_new_text_old(text, (Text_stat const   *)t_stat);
#line 2118
    send_async_new_text(text, (Text_stat const   *)t_stat);
    }
  }
#line 2121
  return (text);
}
}
#line 2134 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Text_no create_anonymous_text(String const   message , Misc_info_list *misc_l ,
                                     Aux_item_list *aux ) 
{ 
  Text_no text ;
  Text_stat *t_stat ;

  {
  {
#line 2143
  text = do_create_text(message, misc_l->no_of_misc, misc_l->misc, aux, (Bool )1,
                        & t_stat);
  }
#line 2146
  if (text != 0UL) {
    {
#line 2148
    send_async_new_text_old(text, (Text_stat const   *)t_stat);
#line 2149
    send_async_new_text(text, (Text_stat const   *)t_stat);
    }
  }
#line 2152
  return (text);
}
}
#line 2155 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Text_no create_anonymous_text_old(String const   message , Misc_info_list *misc_l ) 
{ 
  Text_no text ;
  Text_stat *t_stat ;

  {
  {
#line 2163
  text = do_create_text(message, misc_l->no_of_misc, misc_l->misc, (Aux_item_list *)((void *)0),
                        (Bool )1, & t_stat);
  }
#line 2166
  if (text != 0UL) {
    {
#line 2168
    send_async_new_text_old(text, (Text_stat const   *)t_stat);
#line 2169
    send_async_new_text(text, (Text_stat const   *)t_stat);
    }
  }
#line 2172
  return (text);
}
}
#line 2180 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Text_no do_create_text(String const   message , u_short no_of_misc , Misc_info *misc ,
                              Aux_item_list *aux , Bool anonymous , Text_stat **ret_stat ) 
{ 
  Text_no text ;
  Text_stat *t_stat ;
  Bool need_public_jubel ;
  Bool tmp ;
  int tmp___0 ;
  Success tmp___1 ;
  Success tmp___2 ;
  int *tmp___3 ;
  Success tmp___4 ;
  int tmp___5 ;
  Success tmp___6 ;
  Local_text_no tmp___7 ;

  {
#line 2190
  need_public_jubel = (Bool )0;
  {
#line 2192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2192
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2192
      err_stat = 0UL;
#line 2192
      kom_errno = (enum kom_err )51;
#line 2192
      return ((Text_no )0);
    }
#line 2192
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2193
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2193
    if (! active_connection) {
#line 2193
      err_stat = 0UL;
#line 2193
      kom_errno = (enum kom_err )6;
#line 2193
      return ((Text_no )0);
    } else
#line 2193
    if (! active_connection->pers_no) {
#line 2193
      err_stat = 0UL;
#line 2193
      kom_errno = (enum kom_err )6;
#line 2193
      return ((Text_no )0);
    }
#line 2193
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2195
  if ((int )no_of_misc > param.max_crea_misc) {
#line 2197
    err_stat = (unsigned long )param.max_crea_misc;
#line 2198
    kom_errno = (enum kom_err )46;
#line 2199
    return ((Text_no )0);
  }
#line 2204
  if (message.len > (String_size const   )param.text_len) {
#line 2206
    err_stat = (unsigned long )param.text_len;
#line 2207
    kom_errno = (enum kom_err )5;
#line 2208
    return ((Text_no )0);
  }
  {
#line 2213
  tmp = ok_to_create_next_text((Connection const   *)active_connection, & need_public_jubel);
  }
#line 2213
  if ((unsigned int )tmp == 0U) {
#line 2215
    err_stat = 0UL;
#line 2216
    kom_errno = (enum kom_err )45;
#line 2217
    return ((Text_no )0);
  }
#line 2222
  if (anonymous) {
#line 2222
    tmp___0 = 0;
  } else {
#line 2222
    tmp___0 = (int )active_connection->pers_no;
  }
  {
#line 2222
  prepare_aux_item_list(aux, (Pers_no )tmp___0);
#line 2223
  tmp___1 = create_text_check_misc(& no_of_misc, misc, anonymous, need_public_jubel);
  }
#line 2223
  if ((unsigned long )tmp___1 != (unsigned long )OK) {
#line 2229
    return ((Text_no )0);
  } else {
    {
#line 2223
    tmp___2 = text_stat_check_add_aux_item_list((Text_stat *)((void *)0), aux, active_connection);
    }
#line 2223
    if ((unsigned long )tmp___2 != (unsigned long )OK) {
#line 2229
      return ((Text_no )0);
    } else {
      {
#line 2223
      text = cached_create_text(message);
      }
#line 2223
      if (text == 0UL) {
#line 2229
        return ((Text_no )0);
      }
    }
  }
  {
#line 2232
  t_stat = cached_get_text_stat(text);
  }
#line 2232
  if ((unsigned long )t_stat == (unsigned long )((void *)0)) {
    {
#line 2234
    tmp___3 = __errno_location();
#line 2234
    restart_kom("%s.\nText == %lu, kom_errno == %lu, errno == %lu\n", "create_text: can\'t get text-stat of newly created text",
                text, (unsigned long )kom_errno, (unsigned long )*tmp___3);
    }
  }
#line 2241
  *ret_stat = t_stat;
#line 2242
  if (anonymous) {
#line 2242
    t_stat->author = (Pers_no )0;
  } else {
#line 2242
    t_stat->author = active_connection->pers_no;
  }
  {
#line 2243
  t_stat->creation_time = current_time.tv_sec;
#line 2244
  t_stat->no_of_lines = count_lines((String )message);
#line 2245
  t_stat->no_of_chars = (String_size )message.len;
#line 2247
  tmp___4 = create_text_add_miscs(text, t_stat, (int )no_of_misc, misc);
  }
#line 2247
  if ((unsigned long )tmp___4 != (unsigned long )OK) {
    {
#line 2249
    kom_log("ERROR: create_text(): can\'t add miscs.\n");
    }
#line 2250
    return ((Text_no )0);
  }
#line 2253
  if (anonymous) {
#line 2253
    tmp___5 = 0;
  } else {
#line 2253
    tmp___5 = (int )active_connection->pers_no;
  }
  {
#line 2253
  tmp___6 = create_text_add_aux(t_stat, text, aux, (Pers_no )tmp___5);
  }
#line 2253
  if ((unsigned long )tmp___6 != (unsigned long )OK) {
    {
#line 2255
    kom_log("ERROR: create_text(): can\'t add aux.\n");
    }
#line 2256
    return ((Text_no )0);
  }
#line 2259
  if (! anonymous) {
    {
#line 2261
    tmp___7 = l2g_first_appendable_key((Local_to_global const   *)(& (active_connection->person)->created_texts));
#line 2261
    l2g_append(& (active_connection->person)->created_texts, tmp___7, text);
#line 2264
    (active_connection->person)->created_lines += (unsigned long )t_stat->no_of_lines;
#line 2265
    (active_connection->person)->created_bytes += (unsigned long )t_stat->no_of_chars;
#line 2267
    mark_person_as_changed(active_connection->pers_no);
    }
  }
  {
#line 2270
  mark_text_as_changed(text);
#line 2272
  update_stat((enum stat_type )5, 1L);
  }
#line 2273
  return (text);
}
}
#line 2284 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success delete_text(Text_no text_no ) 
{ 
  Text_stat *text_s ;
  Bool tmp ;
  Bool tmp___0 ;
  Success tmp___1 ;

  {
  {
#line 2289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2289
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2289
      err_stat = 0UL;
#line 2289
      kom_errno = (enum kom_err )51;
#line 2289
      return ((Success )FAILURE);
    }
#line 2289
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2290
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2290
    if (! active_connection) {
#line 2290
      err_stat = 0UL;
#line 2290
      kom_errno = (enum kom_err )6;
#line 2290
      return ((Success )FAILURE);
    } else
#line 2290
    if (! active_connection->pers_no) {
#line 2290
      err_stat = 0UL;
#line 2290
      kom_errno = (enum kom_err )6;
#line 2290
      return ((Success )FAILURE);
    }
#line 2290
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2291
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2291
    text_s = cached_get_text_stat(text_no);
    }
#line 2291
    if ((unsigned long )text_s == (unsigned long )((void *)0)) {
#line 2291
      return ((Success )FAILURE);
    }
#line 2291
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2293
  tmp___0 = is_supervisor(text_s->author, (Connection const   *)active_connection);
  }
#line 2293
  if (! tmp___0) {
#line 2293
    if (active_connection) {
#line 2293
      if ((int )active_connection->ena_level >= 8) {
#line 2293
        if (! (active_connection->person)->privileges.wheel) {
#line 2293
          goto _L___2;
        }
      } else {
#line 2293
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2293
    if (active_connection) {
#line 2293
      if ((int )active_connection->ena_level >= 5) {
#line 2293
        if (! (active_connection->person)->privileges.admin) {
#line 2293
          goto _L___0;
        }
      } else {
#line 2293
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 2297
      err_stat = text_no;
#line 2298
      tmp = text_read_access((Connection const   *)active_connection, text_no, (Text_stat const   *)text_s);
      }
#line 2298
      if (tmp) {
#line 2299
        kom_errno = (enum kom_err )37;
      } else {
#line 2301
        kom_errno = (enum kom_err )14;
      }
#line 2302
      return ((Success )FAILURE);
    }
  }
  {
#line 2305
  tmp___1 = do_delete_text(text_no, text_s);
  }
#line 2305
  return (tmp___1);
}
}
#line 2309 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Bool greater(struct tm  const  *a , struct tm  const  *b ) 
{ 


  {
#line 2313
  if (a->tm_year < b->tm_year) {
#line 2314
    return ((Bool )0);
  }
#line 2315
  if (a->tm_year > b->tm_year) {
#line 2316
    return ((Bool )1);
  }
#line 2318
  if (a->tm_mon < b->tm_mon) {
#line 2319
    return ((Bool )0);
  }
#line 2320
  if (a->tm_mon > b->tm_mon) {
#line 2321
    return ((Bool )1);
  }
#line 2323
  if (a->tm_mday < b->tm_mday) {
#line 2324
    return ((Bool )0);
  }
#line 2325
  if (a->tm_mday > b->tm_mday) {
#line 2326
    return ((Bool )1);
  }
#line 2328
  if (a->tm_hour < b->tm_hour) {
#line 2329
    return ((Bool )0);
  }
#line 2330
  if (a->tm_hour > b->tm_hour) {
#line 2331
    return ((Bool )1);
  }
#line 2333
  if (a->tm_min < b->tm_min) {
#line 2334
    return ((Bool )0);
  }
#line 2335
  if (a->tm_min > b->tm_min) {
#line 2336
    return ((Bool )1);
  }
#line 2338
  if (a->tm_sec < b->tm_sec) {
#line 2339
    return ((Bool )0);
  }
#line 2340
  if (a->tm_sec > b->tm_sec) {
#line 2341
    return ((Bool )1);
  }
#line 2344
  return ((Bool )0);
}
}
#line 2352 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success get_last_text(struct tm *wanted_time , Text_no *result ) 
{ 
  struct tm *texttime ;
  Text_no lower ;
  Text_no higher ;
  Text_no tmp ;
  Text_stat *text_stat ;
  Text_no try ;
  Text_no middle ;
  Text_no tmp___0 ;
  Bool tmp___1 ;

  {
  {
#line 2357
  lower = (Text_no )0;
#line 2358
  tmp = query_next_text_num();
#line 2358
  higher = tmp - 1UL;
#line 2359
  text_stat = (Text_stat *)((void *)0);
  }
  {
#line 2370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2370
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2370
      err_stat = 0UL;
#line 2370
      kom_errno = (enum kom_err )51;
#line 2370
      return ((Success )FAILURE);
    }
#line 2370
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2371
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2371
    if (! active_connection) {
#line 2371
      err_stat = 0UL;
#line 2371
      kom_errno = (enum kom_err )6;
#line 2371
      return ((Success )FAILURE);
    } else
#line 2371
    if (! active_connection->pers_no) {
#line 2371
      err_stat = 0UL;
#line 2371
      kom_errno = (enum kom_err )6;
#line 2371
      return ((Success )FAILURE);
    }
#line 2371
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2372
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2372
    if (! (lower < higher)) {
#line 2372
      goto while_break___1;
    }
#line 2374
    middle = (lower + higher) / 2UL + 1UL;
#line 2375
    try = middle;
#line 2376
    text_stat = (Text_stat *)((void *)0);
    {
#line 2382
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2382
      if ((unsigned long )text_stat == (unsigned long )((void *)0)) {
#line 2382
        if (! (try <= higher)) {
#line 2382
          goto while_break___2;
        }
      } else {
#line 2382
        goto while_break___2;
      }
      {
#line 2383
      tmp___0 = try;
#line 2383
      try ++;
#line 2383
      text_stat = cached_get_text_stat(tmp___0);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2385
    if ((unsigned long )text_stat == (unsigned long )((void *)0)) {
#line 2386
      higher = middle - 1UL;
    } else {
#line 2389
      if (active_connection->use_utc) {
        {
#line 2390
        texttime = gmtime((time_t const   *)(& text_stat->creation_time));
        }
      } else {
        {
#line 2392
        texttime = localtime((time_t const   *)(& text_stat->creation_time));
        }
      }
      {
#line 2393
      tmp___1 = greater((struct tm  const  *)wanted_time, (struct tm  const  *)texttime);
      }
#line 2393
      if (tmp___1) {
#line 2394
        lower = try - 1UL;
      } else {
#line 2396
        higher = middle - 1UL;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2400
  *result = lower;
#line 2402
  return ((Success )OK);
}
}
#line 2410 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success find_next_text_no(Text_no start , Text_no *result ) 
{ 
  Text_no highest ;
  Text_no tmp ;
  Text_stat *text_s ;
  Bool tmp___0 ;

  {
  {
#line 2414
  tmp = query_next_text_num();
#line 2414
  highest = tmp;
  }
  {
#line 2417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2417
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2417
      err_stat = 0UL;
#line 2417
      kom_errno = (enum kom_err )51;
#line 2417
      return ((Success )FAILURE);
    }
#line 2417
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2418
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2418
    if (! active_connection) {
#line 2418
      err_stat = 0UL;
#line 2418
      kom_errno = (enum kom_err )6;
#line 2418
      return ((Success )FAILURE);
    } else
#line 2418
    if (! active_connection->pers_no) {
#line 2418
      err_stat = 0UL;
#line 2418
      kom_errno = (enum kom_err )6;
#line 2418
      return ((Success )FAILURE);
    }
#line 2418
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2419
  err_stat = start;
  {
#line 2420
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2420
    start ++;
#line 2420
    if (! (start < highest)) {
#line 2420
      goto while_break___1;
    }
    {
#line 2422
    text_s = cached_get_text_stat(start);
    }
#line 2423
    if ((unsigned long )text_s != (unsigned long )((void *)0)) {
      {
#line 2423
      tmp___0 = text_read_access((Connection const   *)active_connection, start, (Text_stat const   *)text_s);
      }
#line 2423
      if ((unsigned int )tmp___0 == 1U) {
#line 2426
        *result = start;
#line 2427
        return ((Success )OK);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2431
  kom_errno = (enum kom_err )14;
#line 2432
  return ((Success )FAILURE);
}
}
#line 2440 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success find_previous_text_no(Text_no start , Text_no *result ) 
{ 
  Text_stat *text_s ;
  Text_no next_tno ;
  Text_no saved_start ;
  Bool tmp ;
  Text_no tmp___0 ;

  {
#line 2446
  saved_start = start;
  {
#line 2448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2448
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2448
      err_stat = 0UL;
#line 2448
      kom_errno = (enum kom_err )51;
#line 2448
      return ((Success )FAILURE);
    }
#line 2448
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2449
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2449
    if (! active_connection) {
#line 2449
      err_stat = 0UL;
#line 2449
      kom_errno = (enum kom_err )6;
#line 2449
      return ((Success )FAILURE);
    } else
#line 2449
    if (! active_connection->pers_no) {
#line 2449
      err_stat = 0UL;
#line 2449
      kom_errno = (enum kom_err )6;
#line 2449
      return ((Success )FAILURE);
    }
#line 2449
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2451
  next_tno = query_next_text_num();
  }
#line 2451
  if (start > next_tno) {
#line 2452
    start = next_tno;
  }
  {
#line 2454
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2454
    tmp___0 = start;
#line 2454
    start --;
#line 2454
    if (! (tmp___0 > 0UL)) {
#line 2454
      goto while_break___1;
    }
    {
#line 2456
    text_s = cached_get_text_stat(start);
    }
#line 2457
    if ((unsigned long )text_s != (unsigned long )((void *)0)) {
      {
#line 2457
      tmp = text_read_access((Connection const   *)active_connection, start, (Text_stat const   *)text_s);
      }
#line 2457
      if ((unsigned int )tmp == 1U) {
#line 2460
        *result = start;
#line 2461
        return ((Success )OK);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2465
  kom_errno = (enum kom_err )14;
#line 2466
  err_stat = saved_start;
#line 2467
  return ((Success )FAILURE);
}
}
#line 2470 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static void send_async_add_recipient(Text_no text_no , Text_stat const   *text_s ,
                                     Conf_no conf_no , enum info_type type ) 
{ 
  Connection *cptr ;
  Session_no i ;
  Text_stat copy ;
  int tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;

  {
#line 2477
  i = (Session_no )0;
  {
#line 2479
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2479
    i = traverse_connections(i);
    }
#line 2479
    if (! (i != 0UL)) {
#line 2479
      goto while_break;
    }
    {
#line 2481
    cptr = get_conn_by_number(i);
#line 2482
    tmp___0 = interested_party((Connection const   *)cptr, text_no, text_s);
    }
#line 2482
    if (tmp___0) {
      {
#line 2482
      tmp___1 = text_read_access((Connection const   *)cptr, text_no, text_s);
      }
#line 2482
      if (tmp___1) {
        {
#line 2487
        filter_secret_info(& copy, text_s, (Connection const   *)cptr, (Bool )1);
#line 2488
        tmp = find_recipient(conf_no, (Text_stat const   *)(& copy));
        }
#line 2488
        if (tmp != -1) {
          {
#line 2489
          async_new_recipient(cptr, text_no, conf_no, type);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2492
  return;
}
}
#line 2497 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success add_recipient(Text_no text_no , Conf_no conf_no , enum info_type type ) 
{ 
  Text_stat *t_stat ;
  Conference *conf_c ;
  int rcpt_index ;
  Conf_no submit_conf ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;
  Bool tmp___3 ;
  int tmp___4 ;
  Success tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 2507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2507
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2507
      err_stat = 0UL;
#line 2507
      kom_errno = (enum kom_err )51;
#line 2507
      return ((Success )FAILURE);
    }
#line 2507
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2508
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2508
    if (! active_connection) {
#line 2508
      err_stat = 0UL;
#line 2508
      kom_errno = (enum kom_err )6;
#line 2508
      return ((Success )FAILURE);
    } else
#line 2508
    if (! active_connection->pers_no) {
#line 2508
      err_stat = 0UL;
#line 2508
      kom_errno = (enum kom_err )6;
#line 2508
      return ((Success )FAILURE);
    }
#line 2508
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2511
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2511
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 2511
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 2511
      return ((Success )FAILURE);
    }
#line 2511
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2512
  tmp = has_access(conf_no, (Connection const   *)active_connection, (enum access )2);
  }
#line 2512
  if (! tmp) {
#line 2514
    err_stat = (unsigned long )conf_no;
#line 2515
    kom_errno = (enum kom_err )9;
#line 2516
    return ((Success )FAILURE);
  }
  {
#line 2520
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 2520
    t_stat = cached_get_text_stat(text_no);
    }
#line 2520
    if ((unsigned long )t_stat == (unsigned long )((void *)0)) {
#line 2520
      return ((Success )FAILURE);
    }
#line 2520
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2521
  tmp___0 = text_read_access((Connection const   *)active_connection, text_no, (Text_stat const   *)t_stat);
  }
#line 2521
  if (! tmp___0) {
#line 2521
    if (active_connection) {
#line 2521
      if ((int )active_connection->ena_level >= 4) {
#line 2521
        if (! (active_connection->person)->privileges.admin) {
#line 2524
          err_stat = text_no;
#line 2525
          kom_errno = (enum kom_err )14;
#line 2526
          return ((Success )FAILURE);
        }
      } else {
#line 2524
        err_stat = text_no;
#line 2525
        kom_errno = (enum kom_err )14;
#line 2526
        return ((Success )FAILURE);
      }
    } else {
#line 2524
      err_stat = text_no;
#line 2525
      kom_errno = (enum kom_err )14;
#line 2526
      return ((Success )FAILURE);
    }
  }
  {
#line 2529
  rcpt_index = find_recipient(conf_no, (Text_stat const   *)t_stat);
  }
#line 2530
  if (rcpt_index != -1) {
#line 2533
    if ((unsigned int )(t_stat->misc_items + rcpt_index)->type == (unsigned int )type) {
#line 2535
      err_stat = (unsigned long )conf_no;
#line 2536
      kom_errno = (enum kom_err )27;
#line 2537
      return ((Success )FAILURE);
    }
#line 2540
    if ((unsigned int )type != 0U) {
#line 2540
      if ((unsigned int )type != 1U) {
#line 2540
        if ((unsigned int )type != 15U) {
#line 2542
          err_stat = (unsigned long )type;
#line 2543
          kom_errno = (enum kom_err )26;
#line 2544
          return ((Success )FAILURE);
        }
      }
    }
    {
#line 2547
    tmp___1 = is_supervisor(t_stat->author, (Connection const   *)active_connection);
    }
#line 2547
    if (! tmp___1) {
      {
#line 2547
      tmp___2 = is_supervisor(conf_no, (Connection const   *)active_connection);
      }
#line 2547
      if (! tmp___2) {
        {
#line 2547
        tmp___3 = is_supervisor_of_sender((Text_stat const   *)t_stat, rcpt_index,
                                          (Connection const   *)active_connection);
        }
#line 2547
        if (! tmp___3) {
#line 2547
          if (active_connection) {
#line 2547
            if ((int )active_connection->ena_level >= 8) {
#line 2547
              if (! (active_connection->person)->privileges.wheel) {
#line 2552
                err_stat = (unsigned long )conf_no;
#line 2553
                kom_errno = (enum kom_err )12;
#line 2554
                return ((Success )FAILURE);
              }
            } else {
#line 2552
              err_stat = (unsigned long )conf_no;
#line 2553
              kom_errno = (enum kom_err )12;
#line 2554
              return ((Success )FAILURE);
            }
          } else {
#line 2552
            err_stat = (unsigned long )conf_no;
#line 2553
            kom_errno = (enum kom_err )12;
#line 2554
            return ((Success )FAILURE);
          }
        }
      }
    }
    {
#line 2562
    (t_stat->misc_items + rcpt_index)->type = type;
#line 2575
    mark_text_as_changed(text_no);
#line 2576
    send_async_add_recipient(text_no, (Text_stat const   *)t_stat, conf_no, type);
    }
#line 2578
    return ((Success )OK);
  }
  {
#line 2581
  tmp___4 = count_recipients((Text_stat const   *)t_stat);
  }
#line 2581
  if (tmp___4 >= param.max_recipients) {
#line 2583
    err_stat = text_no;
#line 2584
    kom_errno = (enum kom_err )33;
#line 2585
    return ((Success )FAILURE);
  }
  {
#line 2588
  submit_conf = submit_to(conf_no, (Conference const   *)conf_c);
  }
#line 2590
  if ((int )submit_conf == 0) {
#line 2593
    return ((Success )FAILURE);
  } else
#line 2595
  if ((int )submit_conf != (int )conf_no) {
#line 2598
    err_stat = (unsigned long )conf_no;
#line 2599
    kom_errno = (enum kom_err )11;
#line 2600
    return ((Success )FAILURE);
  }
#line 2604
  if (! conf_c->type.allow_anon) {
#line 2604
    if ((int )t_stat->author == 0) {
#line 2606
      kom_errno = (enum kom_err )47;
#line 2607
      err_stat = 0UL;
#line 2608
      return ((Success )FAILURE);
    }
  }
  {
#line 2615
  if ((unsigned int )type == 15U) {
#line 2615
    goto case_15;
  }
#line 2615
  if ((unsigned int )type == 1U) {
#line 2615
    goto case_15;
  }
#line 2615
  if ((unsigned int )type == 0U) {
#line 2615
    goto case_15;
  }
#line 2631
  goto switch_default;
  case_15: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 2616
  tmp___5 = do_add_recipient(text_no, t_stat, conf_no, type);
  }
#line 2616
  if ((unsigned long )tmp___5 != (unsigned long )OK) {
#line 2617
    return ((Success )FAILURE);
  }
#line 2618
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2633
  err_stat = (unsigned long )type;
#line 2634
  kom_errno = (enum kom_err )26;
#line 2635
  return ((Success )FAILURE);
  switch_break: /* CIL Label */ ;
  }
#line 2638
  if ((int )t_stat->author != (int )active_connection->pers_no) {
    {
#line 2639
    t_stat->no_of_misc = (unsigned short )((int )t_stat->no_of_misc + 1);
#line 2639
    tmp___6 = srealloc((void *)t_stat->misc_items, (unsigned long )t_stat->no_of_misc * sizeof(Misc_info ));
#line 2639
    t_stat->misc_items = (Misc_info *)tmp___6;
#line 2639
    (t_stat->misc_items + ((int )t_stat->no_of_misc - 1))->type = (enum info_type )8;
#line 2639
    (t_stat->misc_items + ((int )t_stat->no_of_misc - 1))->datum.sender = active_connection->pers_no;
    }
  }
  {
#line 2641
  t_stat->no_of_misc = (unsigned short )((int )t_stat->no_of_misc + 1);
#line 2641
  tmp___7 = srealloc((void *)t_stat->misc_items, (unsigned long )t_stat->no_of_misc * sizeof(Misc_info ));
#line 2641
  t_stat->misc_items = (Misc_info *)tmp___7;
#line 2641
  (t_stat->misc_items + ((int )t_stat->no_of_misc - 1))->type = (enum info_type )9;
#line 2641
  (t_stat->misc_items + ((int )t_stat->no_of_misc - 1))->datum.sent_at = current_time.tv_sec;
#line 2643
  mark_text_as_changed(text_no);
#line 2644
  send_async_add_recipient(text_no, (Text_stat const   *)t_stat, conf_no, type);
  }
#line 2646
  return ((Success )OK);
}
}
#line 2659 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success sub_recipient(Text_no text_no , Conf_no conf_no ) 
{ 
  Text_stat *text_s ;
  Conference *conf_c ;
  int misc_index ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;
  Bool tmp___3 ;
  Success tmp___4 ;

  {
  {
#line 2667
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2667
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2667
      err_stat = 0UL;
#line 2667
      kom_errno = (enum kom_err )51;
#line 2667
      return ((Success )FAILURE);
    }
#line 2667
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2668
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2668
    if (! active_connection) {
#line 2668
      err_stat = 0UL;
#line 2668
      kom_errno = (enum kom_err )6;
#line 2668
      return ((Success )FAILURE);
    } else
#line 2668
    if (! active_connection->pers_no) {
#line 2668
      err_stat = 0UL;
#line 2668
      kom_errno = (enum kom_err )6;
#line 2668
      return ((Success )FAILURE);
    }
#line 2668
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2669
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2669
    text_s = cached_get_text_stat(text_no);
    }
#line 2669
    if ((unsigned long )text_s == (unsigned long )((void *)0)) {
#line 2669
      return ((Success )FAILURE);
    }
#line 2669
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2671
  tmp = text_read_access((Connection const   *)active_connection, text_no, (Text_stat const   *)text_s);
  }
#line 2671
  if (! tmp) {
#line 2671
    if (active_connection) {
#line 2671
      if ((int )active_connection->ena_level >= 4) {
#line 2671
        if (! (active_connection->person)->privileges.admin) {
#line 2674
          err_stat = text_no;
#line 2675
          kom_errno = (enum kom_err )14;
#line 2676
          return ((Success )FAILURE);
        }
      } else {
#line 2674
        err_stat = text_no;
#line 2675
        kom_errno = (enum kom_err )14;
#line 2676
        return ((Success )FAILURE);
      }
    } else {
#line 2674
      err_stat = text_no;
#line 2675
      kom_errno = (enum kom_err )14;
#line 2676
      return ((Success )FAILURE);
    }
  }
  {
#line 2679
  tmp___0 = has_access(conf_no, (Connection const   *)active_connection, (enum access )2);
  }
#line 2679
  if (! tmp___0) {
#line 2681
    err_stat = (unsigned long )conf_no;
#line 2682
    kom_errno = (enum kom_err )9;
#line 2683
    return ((Success )FAILURE);
  }
  {
#line 2686
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 2686
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 2686
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 2686
      return ((Success )FAILURE);
    }
#line 2686
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2688
  misc_index = find_recipient(conf_no, (Text_stat const   *)text_s);
  }
#line 2688
  if (misc_index == -1) {
#line 2690
    err_stat = (unsigned long )conf_no;
#line 2691
    kom_errno = (enum kom_err )30;
#line 2692
    return ((Success )FAILURE);
  }
  {
#line 2696
  tmp___1 = is_supervisor(text_s->author, (Connection const   *)active_connection);
  }
#line 2696
  if (! tmp___1) {
    {
#line 2696
    tmp___2 = is_supervisor(conf_no, (Connection const   *)active_connection);
    }
#line 2696
    if (! tmp___2) {
#line 2696
      if (active_connection) {
#line 2696
        if ((int )active_connection->ena_level >= 8) {
#line 2696
          if (! (active_connection->person)->privileges.wheel) {
#line 2696
            goto _L___0;
          }
        } else {
#line 2696
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 2696
        tmp___3 = is_supervisor_of_sender((Text_stat const   *)text_s, misc_index,
                                          (Connection const   *)active_connection);
        }
#line 2696
        if (! tmp___3) {
#line 2701
          err_stat = text_no;
#line 2702
          kom_errno = (enum kom_err )12;
#line 2703
          return ((Success )FAILURE);
        }
      }
    }
  }
  {
#line 2706
  tmp___4 = do_sub_recpt(text_no, text_s, conf_no, conf_c, (Bool )1);
  }
#line 2706
  return (tmp___4);
}
}
#line 2715 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static Success check_add_textlink(Text_no child , Text_no parent , Success (*parent_checker)(Text_stat const   * ) ,
                                  Text_stat **child_p , Text_stat **parent_p ) 
{ 
  Text_stat *child_s ;
  Text_stat *parent_s ;
  int misc_index ;
  Bool tmp ;
  Bool tmp___0 ;
  Success tmp___1 ;

  {
  {
#line 2726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2726
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2726
      err_stat = 0UL;
#line 2726
      kom_errno = (enum kom_err )51;
#line 2726
      return ((Success )FAILURE);
    }
#line 2726
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2727
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2727
    if (! active_connection) {
#line 2727
      err_stat = 0UL;
#line 2727
      kom_errno = (enum kom_err )6;
#line 2727
      return ((Success )FAILURE);
    } else
#line 2727
    if (! active_connection->pers_no) {
#line 2727
      err_stat = 0UL;
#line 2727
      kom_errno = (enum kom_err )6;
#line 2727
      return ((Success )FAILURE);
    }
#line 2727
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2734
  if (child == parent) {
#line 2736
    kom_errno = (enum kom_err )19;
#line 2737
    err_stat = child;
#line 2738
    return ((Success )FAILURE);
  }
  {
#line 2741
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2741
    child_s = cached_get_text_stat(child);
    }
#line 2741
    if ((unsigned long )child_s == (unsigned long )((void *)0)) {
#line 2741
      return ((Success )FAILURE);
    }
#line 2741
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2742
  tmp = text_read_access((Connection const   *)active_connection, child, (Text_stat const   *)child_s);
  }
#line 2742
  if (! tmp) {
#line 2744
    kom_errno = (enum kom_err )14;
#line 2745
    err_stat = child;
#line 2746
    return ((Success )FAILURE);
  }
  {
#line 2749
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 2749
    parent_s = cached_get_text_stat(parent);
    }
#line 2749
    if ((unsigned long )parent_s == (unsigned long )((void *)0)) {
#line 2749
      return ((Success )FAILURE);
    }
#line 2749
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2750
  tmp___0 = text_read_access((Connection const   *)active_connection, parent, (Text_stat const   *)parent_s);
  }
#line 2750
  if (! tmp___0) {
#line 2752
    kom_errno = (enum kom_err )14;
#line 2753
    err_stat = parent;
#line 2754
    return ((Success )FAILURE);
  }
  {
#line 2757
  err_stat = parent;
#line 2758
  tmp___1 = (*parent_checker)((Text_stat const   *)parent_s);
  }
#line 2758
  if ((unsigned long )tmp___1 != (unsigned long )OK) {
#line 2759
    return ((Success )FAILURE);
  }
  {
#line 2762
  misc_index = find_textlink((Text_stat const   *)child_s, parent);
  }
#line 2762
  if (misc_index != -1) {
#line 2764
    err_stat = child;
#line 2765
    if ((unsigned int )(child_s->misc_items + misc_index)->type == 2U) {
#line 2766
      kom_errno = (enum kom_err )28;
    } else {
#line 2768
      kom_errno = (enum kom_err )29;
    }
#line 2769
    return ((Success )FAILURE);
  }
#line 2772
  *child_p = child_s;
#line 2773
  *parent_p = parent_s;
#line 2774
  return ((Success )OK);
}
}
#line 2782 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success add_comment(Text_no child , Text_no parent ) 
{ 
  Text_stat *child_s ;
  Text_stat *parent_s ;
  Success tmp ;
  Success tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 2789
  tmp = check_add_textlink(child, parent, & check_comm, & child_s, & parent_s);
  }
#line 2789
  if ((unsigned long )tmp != (unsigned long )OK) {
#line 2791
    return ((Success )FAILURE);
  }
  {
#line 2793
  tmp___0 = do_add_comment(child, child_s, parent, parent_s);
  }
#line 2793
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
#line 2794
    return ((Success )FAILURE);
  }
#line 2796
  if ((int )child_s->author != (int )active_connection->pers_no) {
    {
#line 2797
    child_s->no_of_misc = (unsigned short )((int )child_s->no_of_misc + 1);
#line 2797
    tmp___1 = srealloc((void *)child_s->misc_items, (unsigned long )child_s->no_of_misc * sizeof(Misc_info ));
#line 2797
    child_s->misc_items = (Misc_info *)tmp___1;
#line 2797
    (child_s->misc_items + ((int )child_s->no_of_misc - 1))->type = (enum info_type )8;
#line 2797
    (child_s->misc_items + ((int )child_s->no_of_misc - 1))->datum.sender = active_connection->pers_no;
    }
  }
  {
#line 2799
  child_s->no_of_misc = (unsigned short )((int )child_s->no_of_misc + 1);
#line 2799
  tmp___2 = srealloc((void *)child_s->misc_items, (unsigned long )child_s->no_of_misc * sizeof(Misc_info ));
#line 2799
  child_s->misc_items = (Misc_info *)tmp___2;
#line 2799
  (child_s->misc_items + ((int )child_s->no_of_misc - 1))->type = (enum info_type )9;
#line 2799
  (child_s->misc_items + ((int )child_s->no_of_misc - 1))->datum.sent_at = current_time.tv_sec;
#line 2801
  mark_text_as_changed(child);
  }
#line 2802
  return ((Success )OK);
}
}
#line 2812 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success sub_comment(Text_no child , Text_no parent ) 
{ 
  Text_stat *child_s ;
  Text_stat *parent_s ;
  int misc_index ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  {
#line 2821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2821
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2821
      err_stat = 0UL;
#line 2821
      kom_errno = (enum kom_err )51;
#line 2821
      return ((Success )FAILURE);
    }
#line 2821
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2822
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2822
    if (! active_connection) {
#line 2822
      err_stat = 0UL;
#line 2822
      kom_errno = (enum kom_err )6;
#line 2822
      return ((Success )FAILURE);
    } else
#line 2822
    if (! active_connection->pers_no) {
#line 2822
      err_stat = 0UL;
#line 2822
      kom_errno = (enum kom_err )6;
#line 2822
      return ((Success )FAILURE);
    }
#line 2822
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2824
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2824
    child_s = cached_get_text_stat(child);
    }
#line 2824
    if ((unsigned long )child_s == (unsigned long )((void *)0)) {
#line 2824
      return ((Success )FAILURE);
    }
#line 2824
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2825
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 2825
    parent_s = cached_get_text_stat(parent);
    }
#line 2825
    if ((unsigned long )parent_s == (unsigned long )((void *)0)) {
#line 2825
      return ((Success )FAILURE);
    }
#line 2825
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2827
  misc_index = find_textlink((Text_stat const   *)child_s, parent);
  }
#line 2827
  if (misc_index == -1) {
#line 2830
    err_stat = child;
#line 2831
    kom_errno = (enum kom_err )31;
#line 2832
    return ((Success )FAILURE);
  } else
#line 2827
  if ((unsigned int )(child_s->misc_items + misc_index)->type != 2U) {
#line 2830
    err_stat = child;
#line 2831
    kom_errno = (enum kom_err )31;
#line 2832
    return ((Success )FAILURE);
  }
  {
#line 2835
  tmp = is_supervisor(child_s->author, (Connection const   *)active_connection);
  }
#line 2835
  if (! tmp) {
#line 2835
    if (active_connection) {
#line 2835
      if ((int )active_connection->ena_level >= 8) {
#line 2835
        if (! (active_connection->person)->privileges.wheel) {
#line 2835
          goto _L___0;
        }
      } else {
#line 2835
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 2835
      tmp___0 = is_supervisor_of_sender((Text_stat const   *)child_s, misc_index,
                                        (Connection const   *)active_connection);
      }
#line 2835
      if (! tmp___0) {
#line 2839
        err_stat = child;
#line 2840
        kom_errno = (enum kom_err )12;
#line 2841
        return ((Success )FAILURE);
      }
    }
  }
  {
#line 2844
  do_sub_comment(child, child_s, parent, parent_s);
  }
#line 2845
  return ((Success )OK);
}
}
#line 2852 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success add_footnote(Text_no child , Text_no parent ) 
{ 
  Text_stat *child_s ;
  Text_stat *parent_s ;
  Success tmp ;
  Success tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 2859
  tmp = check_add_textlink(child, parent, & check_footn, & child_s, & parent_s);
  }
#line 2859
  if ((unsigned long )tmp != (unsigned long )OK) {
#line 2861
    return ((Success )FAILURE);
  }
#line 2863
  if ((int )child_s->author != (int )parent_s->author) {
#line 2865
    kom_errno = (enum kom_err )37;
#line 2869
    err_stat = child;
#line 2870
    return ((Success )FAILURE);
  }
  {
#line 2873
  tmp___0 = do_add_footnote(child, child_s, parent, parent_s);
  }
#line 2873
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
#line 2874
    return ((Success )FAILURE);
  }
  {
#line 2876
  child_s->no_of_misc = (unsigned short )((int )child_s->no_of_misc + 1);
#line 2876
  tmp___1 = srealloc((void *)child_s->misc_items, (unsigned long )child_s->no_of_misc * sizeof(Misc_info ));
#line 2876
  child_s->misc_items = (Misc_info *)tmp___1;
#line 2876
  (child_s->misc_items + ((int )child_s->no_of_misc - 1))->type = (enum info_type )9;
#line 2876
  (child_s->misc_items + ((int )child_s->no_of_misc - 1))->datum.sent_at = current_time.tv_sec;
#line 2878
  mark_text_as_changed(child);
  }
#line 2879
  return ((Success )OK);
}
}
#line 2886 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success sub_footnote(Text_no child , Text_no parent ) 
{ 
  Text_stat *child_s ;
  Text_stat *parent_s ;
  int misc_index ;
  Bool tmp ;

  {
  {
#line 2894
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2894
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2894
      err_stat = 0UL;
#line 2894
      kom_errno = (enum kom_err )51;
#line 2894
      return ((Success )FAILURE);
    }
#line 2894
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2895
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2895
    if (! active_connection) {
#line 2895
      err_stat = 0UL;
#line 2895
      kom_errno = (enum kom_err )6;
#line 2895
      return ((Success )FAILURE);
    } else
#line 2895
    if (! active_connection->pers_no) {
#line 2895
      err_stat = 0UL;
#line 2895
      kom_errno = (enum kom_err )6;
#line 2895
      return ((Success )FAILURE);
    }
#line 2895
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2897
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2897
    child_s = cached_get_text_stat(child);
    }
#line 2897
    if ((unsigned long )child_s == (unsigned long )((void *)0)) {
#line 2897
      return ((Success )FAILURE);
    }
#line 2897
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2898
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 2898
    parent_s = cached_get_text_stat(parent);
    }
#line 2898
    if ((unsigned long )parent_s == (unsigned long )((void *)0)) {
#line 2898
      return ((Success )FAILURE);
    }
#line 2898
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2900
  misc_index = find_textlink((Text_stat const   *)child_s, parent);
  }
#line 2900
  if (misc_index == -1) {
#line 2903
    err_stat = child;
#line 2904
    kom_errno = (enum kom_err )32;
#line 2905
    return ((Success )FAILURE);
  } else
#line 2900
  if ((unsigned int )(child_s->misc_items + misc_index)->type != 4U) {
#line 2903
    err_stat = child;
#line 2904
    kom_errno = (enum kom_err )32;
#line 2905
    return ((Success )FAILURE);
  }
  {
#line 2908
  tmp = is_supervisor(child_s->author, (Connection const   *)active_connection);
  }
#line 2908
  if (! tmp) {
#line 2908
    if (active_connection) {
#line 2908
      if ((int )active_connection->ena_level >= 8) {
#line 2908
        if (! (active_connection->person)->privileges.wheel) {
#line 2911
          err_stat = child;
#line 2912
          kom_errno = (enum kom_err )12;
#line 2913
          return ((Success )FAILURE);
        }
      } else {
#line 2911
        err_stat = child;
#line 2912
        kom_errno = (enum kom_err )12;
#line 2913
        return ((Success )FAILURE);
      }
    } else {
#line 2911
      err_stat = child;
#line 2912
      kom_errno = (enum kom_err )12;
#line 2913
      return ((Success )FAILURE);
    }
  }
  {
#line 2916
  do_sub_footnote(child, child_s, parent, parent_s);
  }
#line 2917
  return ((Success )OK);
}
}
#line 2925 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success get_map(Conf_no conf_no , Local_text_no first_local_no , unsigned long no_of_texts ,
                       L2g_iterator *result ) 
{ 
  Conference *conf_c ;
  Local_text_no highest ;
  Local_text_no first_unwanted ;
  Local_text_no res_first ;
  int res_nr ;
  enum access acc ;
  Local_text_no tmp ;

  {
  {
#line 2938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2938
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2938
      err_stat = 0UL;
#line 2938
      kom_errno = (enum kom_err )51;
#line 2938
      return ((Success )FAILURE);
    }
#line 2938
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2939
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2939
    if (! active_connection) {
#line 2939
      err_stat = 0UL;
#line 2939
      kom_errno = (enum kom_err )6;
#line 2939
      return ((Success )FAILURE);
    } else
#line 2939
    if (! active_connection->pers_no) {
#line 2939
      err_stat = 0UL;
#line 2939
      kom_errno = (enum kom_err )6;
#line 2939
      return ((Success )FAILURE);
    }
#line 2939
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2940
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2940
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 2940
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 2940
      return ((Success )FAILURE);
    }
#line 2940
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2942
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )3);
  }
#line 2944
  if ((unsigned int )acc <= 1U) {
#line 2946
    err_stat = (unsigned long )conf_no;
#line 2947
    kom_errno = (enum kom_err )9;
#line 2948
    return ((Success )FAILURE);
  }
#line 2951
  if ((unsigned int )acc == 2U) {
#line 2953
    err_stat = (unsigned long )conf_no;
#line 2954
    kom_errno = (enum kom_err )11;
#line 2955
    return ((Success )FAILURE);
  }
  {
#line 2958
  tmp = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
#line 2958
  highest = tmp - 1UL;
  }
#line 2960
  if (first_local_no > highest) {
#line 2962
    err_stat = first_local_no;
#line 2963
    kom_errno = (enum kom_err )16;
#line 2964
    return ((Success )FAILURE);
  }
  {
#line 2969
  res_first = l2g_next_key((Local_to_global const   *)(& conf_c->texts), (Local_text_no )0);
  }
#line 2970
  if (res_first == 0UL) {
    {
#line 2971
    res_first = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
    }
  }
#line 2974
  if (res_first > first_local_no) {
#line 2974
    res_first = res_first;
  } else {
#line 2974
    res_first = first_local_no;
  }
#line 2977
  if (highest + 1UL > first_local_no + no_of_texts) {
#line 2977
    first_unwanted = first_local_no + no_of_texts;
  } else {
#line 2977
    first_unwanted = highest + 1UL;
  }
#line 2979
  if (first_unwanted >= res_first) {
#line 2980
    res_nr = (int )(first_unwanted - res_first);
  } else {
#line 2982
    res_nr = 0;
  }
  {
#line 2984
  l2gi_searchsome(result, (Local_to_global const   *)(& conf_c->texts), res_first,
                  res_first + (Local_text_no )res_nr);
  }
#line 2986
  return ((Success )OK);
}
}
#line 2989 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success local_to_global(Conf_no conf_no , Local_text_no first_local_no , unsigned long no_of_texts ,
                               Text_mapping *result ) 
{ 
  Conference *conf_c ;
  enum access acc ;
  Local_text_no tmp ;

  {
  {
#line 2998
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2998
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2998
      err_stat = 0UL;
#line 2998
      kom_errno = (enum kom_err )51;
#line 2998
      return ((Success )FAILURE);
    }
#line 2998
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2999
  if (first_local_no == 0UL) {
#line 3001
    err_stat = first_local_no;
#line 3002
    kom_errno = (enum kom_err )17;
#line 3003
    return ((Success )FAILURE);
  }
#line 3006
  if (no_of_texts > 255UL) {
#line 3008
    err_stat = 255UL;
#line 3009
    kom_errno = (enum kom_err )46;
#line 3010
    return ((Success )FAILURE);
  }
  {
#line 3013
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3013
    if (! active_connection) {
#line 3013
      err_stat = 0UL;
#line 3013
      kom_errno = (enum kom_err )6;
#line 3013
      return ((Success )FAILURE);
    } else
#line 3013
    if (! active_connection->pers_no) {
#line 3013
      err_stat = 0UL;
#line 3013
      kom_errno = (enum kom_err )6;
#line 3013
      return ((Success )FAILURE);
    }
#line 3013
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3014
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 3014
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 3014
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 3014
      return ((Success )FAILURE);
    }
#line 3014
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3016
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )3);
  }
#line 3018
  if ((unsigned int )acc <= 1U) {
#line 3020
    err_stat = (unsigned long )conf_no;
#line 3021
    kom_errno = (enum kom_err )9;
#line 3022
    return ((Success )FAILURE);
  }
#line 3025
  if ((unsigned int )acc == 2U) {
#line 3027
    err_stat = (unsigned long )conf_no;
#line 3028
    kom_errno = (enum kom_err )11;
#line 3029
    return ((Success )FAILURE);
  }
  {
#line 3032
  tmp = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
  }
#line 3032
  if (first_local_no >= tmp) {
#line 3034
    err_stat = first_local_no;
#line 3035
    kom_errno = (enum kom_err )16;
#line 3036
    return ((Success )FAILURE);
  }
#line 3039
  result->first = first_local_no;
#line 3040
  result->no_of_texts = no_of_texts;
#line 3041
  result->l2g = (Local_to_global const   *)(& conf_c->texts);
#line 3043
  return ((Success )OK);
}
}
#line 3046 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success local_to_global_reverse(Conf_no conf_no , Local_text_no local_no_ceiling ,
                                       unsigned long no_of_texts , Text_mapping_reverse *result ) 
{ 
  Conference *conf_c ;
  enum access acc ;
  Local_text_no ceiling ;

  {
  {
#line 3056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3056
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 3056
      err_stat = 0UL;
#line 3056
      kom_errno = (enum kom_err )51;
#line 3056
      return ((Success )FAILURE);
    }
#line 3056
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3058
  if (no_of_texts > 255UL) {
#line 3060
    err_stat = 255UL;
#line 3061
    kom_errno = (enum kom_err )46;
#line 3062
    return ((Success )FAILURE);
  }
  {
#line 3065
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3065
    if (! active_connection) {
#line 3065
      err_stat = 0UL;
#line 3065
      kom_errno = (enum kom_err )6;
#line 3065
      return ((Success )FAILURE);
    } else
#line 3065
    if (! active_connection->pers_no) {
#line 3065
      err_stat = 0UL;
#line 3065
      kom_errno = (enum kom_err )6;
#line 3065
      return ((Success )FAILURE);
    }
#line 3065
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3066
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 3066
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 3066
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 3066
      return ((Success )FAILURE);
    }
#line 3066
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3068
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )3);
  }
#line 3070
  if ((unsigned int )acc <= 1U) {
#line 3072
    err_stat = (unsigned long )conf_no;
#line 3073
    kom_errno = (enum kom_err )9;
#line 3074
    return ((Success )FAILURE);
  }
#line 3077
  if ((unsigned int )acc == 2U) {
#line 3079
    err_stat = (unsigned long )conf_no;
#line 3080
    kom_errno = (enum kom_err )11;
#line 3081
    return ((Success )FAILURE);
  }
  {
#line 3084
  ceiling = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
  }
#line 3086
  if (local_no_ceiling == 0UL) {
#line 3087
    result->ceiling = ceiling;
  } else
#line 3086
  if (local_no_ceiling > ceiling) {
#line 3087
    result->ceiling = ceiling;
  } else {
#line 3089
    result->ceiling = local_no_ceiling;
  }
#line 3091
  result->no_of_texts = no_of_texts;
#line 3092
  result->l2g = (Local_to_global const   *)(& conf_c->texts);
#line 3094
  return ((Success )OK);
}
}
#line 3098 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
static void send_async_text_aux_changed(Text_no text_no , Text_stat *text_s , unsigned long highest_aux ) 
{ 
  Connection *cptr ;
  Session_no i ;
  Aux_item_list copy ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;

  {
#line 3104
  i = (Session_no )0;
  {
#line 3107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3107
    i = traverse_connections(i);
    }
#line 3107
    if (! (i != 0UL)) {
#line 3107
      goto while_break;
    }
    {
#line 3109
    cptr = get_conn_by_number(i);
    }
#line 3114
    if ((unsigned int )cptr->want_async[22] == 0U) {
#line 3115
      goto while_continue;
    }
    {
#line 3117
    tmp = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 3117
    if (! tmp) {
#line 3118
      goto while_continue;
    }
    {
#line 3120
    tmp___0 = interested_party((Connection const   *)cptr, text_no, (Text_stat const   *)text_s);
    }
#line 3120
    if (! tmp___0) {
#line 3121
      goto while_continue;
    }
    {
#line 3123
    tmp___1 = text_read_access((Connection const   *)cptr, text_no, (Text_stat const   *)text_s);
    }
#line 3123
    if (! tmp___1) {
#line 3124
      goto while_continue;
    }
    {
#line 3126
    filter_aux_item_list((Aux_item_list const   *)(& text_s->aux_item_list), & copy,
                         (Connection const   *)cptr);
#line 3128
    async_text_aux_changed(cptr, text_no, & copy, highest_aux);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3130
  return;
}
}
#line 3132 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
extern Success modify_text_info(Text_no text , Number_list *items_to_delete , Aux_item_list *aux ) 
{ 
  Text_stat *text_s ;
  unsigned long highest_aux ;
  Bool tmp ;
  Success tmp___0 ;
  Success tmp___1 ;

  {
  {
#line 3140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3140
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 3140
      err_stat = 0UL;
#line 3140
      kom_errno = (enum kom_err )51;
#line 3140
      return ((Success )FAILURE);
    }
#line 3140
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3141
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3141
    if (! active_connection) {
#line 3141
      err_stat = 0UL;
#line 3141
      kom_errno = (enum kom_err )6;
#line 3141
      return ((Success )FAILURE);
    } else
#line 3141
    if (! active_connection->pers_no) {
#line 3141
      err_stat = 0UL;
#line 3141
      kom_errno = (enum kom_err )6;
#line 3141
      return ((Success )FAILURE);
    }
#line 3141
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3143
  if (items_to_delete->length > param.max_delete_aux) {
#line 3145
    kom_errno = (enum kom_err )46;
#line 3146
    err_stat = (unsigned long )param.max_delete_aux;
#line 3147
    return ((Success )FAILURE);
  }
#line 3150
  if ((int )aux->length > param.max_add_aux) {
#line 3152
    kom_errno = (enum kom_err )46;
#line 3153
    err_stat = (unsigned long )param.max_add_aux;
#line 3154
    return ((Success )FAILURE);
  }
  {
#line 3157
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 3157
    text_s = cached_get_text_stat(text);
    }
#line 3157
    if ((unsigned long )text_s == (unsigned long )((void *)0)) {
#line 3157
      return ((Success )FAILURE);
    }
#line 3157
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3158
  tmp = text_read_access((Connection const   *)active_connection, text, (Text_stat const   *)text_s);
  }
#line 3158
  if (! tmp) {
#line 3160
    err_stat = text;
#line 3161
    kom_errno = (enum kom_err )14;
#line 3162
    return ((Success )FAILURE);
  }
  {
#line 3167
  highest_aux = text_s->highest_aux;
#line 3171
  prepare_aux_item_list(aux, active_connection->pers_no);
#line 3173
  tmp___0 = check_delete_aux_item_list((Number_list const   *)items_to_delete, (Aux_item_list const   *)(& text_s->aux_item_list),
                                       (Conf_no const   )text_s->author);
  }
#line 3173
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
#line 3176
    return ((Success )FAILURE);
  }
  {
#line 3177
  delete_aux_item_list((Number_list const   *)items_to_delete, & text_s->aux_item_list,
                       (enum object_type )1, text, (void *)text_s);
#line 3182
  tmp___1 = text_stat_check_add_aux_item_list(text_s, aux, active_connection);
  }
#line 3182
  if ((unsigned long )tmp___1 != (unsigned long )OK) {
    {
#line 3185
    undelete_aux_item_list((Number_list const   *)items_to_delete, & text_s->aux_item_list,
                           (enum object_type )1, text, (void *)text_s);
    }
#line 3190
    return ((Success )FAILURE);
  }
  {
#line 3193
  text_stat_add_aux_item_list(text_s, text, aux, active_connection->pers_no);
#line 3194
  send_async_text_aux_changed(text, text_s, highest_aux);
#line 3195
  commit_aux_item_list(& text_s->aux_item_list);
#line 3197
  mark_text_as_changed(text);
  }
#line 3199
  return ((Success )OK);
}
}
#line 3203 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text.c"
Success first_unused_text_no(Text_no *result ) 
{ 


  {
  {
#line 3206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3206
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 3206
      err_stat = 0UL;
#line 3206
      kom_errno = (enum kom_err )51;
#line 3206
      return ((Success )FAILURE);
    }
#line 3206
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3208
  *result = query_next_text_num();
  }
#line 3209
  return ((Success )OK);
}
}
#line 29 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.h"
long prot_a_parse_long(Connection *client ) ;
#line 32
void prot_a_parse_num_list(Connection *client , Number_list *res , int maxlen ) ;
#line 37
void prot_a_parse_priv_bits(Connection *client , Priv_bits *res ) ;
#line 41
void prot_a_parse_pers_flags(Connection *client , Personal_flags *res ) ;
#line 45
void prot_a_parse_membership_type(Connection *client , Membership_type *res ) ;
#line 49
void prot_a_parse_conf_type(Connection *client , Conf_type *res ) ;
#line 54
void prot_a_parse_string(Connection *client , String *result , int maxlen ) ;
#line 67
extern void prot_a_parse_aux_item_list(Connection *client , Aux_item_list *result ,
                                       int maxlen ) ;
#line 72
extern void prot_a_parse_misc_info_list(Connection *client , Misc_info_list *result ,
                                        int maxlen ) ;
#line 80
void prot_a_parse_read_range_list(Connection *client , struct read_range_list *res ,
                                  int maxlen ) ;
#line 85
void prot_a_parse_time_date(Connection *client , struct tm *result ) ;
#line 89
void prot_a_parse_info(Connection *client , Info *result ) ;
#line 4 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.h"
void prot_a_parse_arg_login_old(Connection *client ) ;
#line 5
void prot_a_parse_arg_logout(Connection *client ) ;
#line 6
void prot_a_parse_arg_change_conference(Connection *client ) ;
#line 7
void prot_a_parse_arg_change_name(Connection *client ) ;
#line 8
void prot_a_parse_arg_change_what_i_am_doing(Connection *client ) ;
#line 9
void prot_a_parse_arg_create_person_old(Connection *client ) ;
#line 10
void prot_a_parse_arg_get_person_stat_old(Connection *client ) ;
#line 11
void prot_a_parse_arg_set_priv_bits(Connection *client ) ;
#line 12
void prot_a_parse_arg_set_passwd(Connection *client ) ;
#line 13
void prot_a_parse_arg_query_read_texts_old(Connection *client ) ;
#line 14
void prot_a_parse_arg_create_conf_old(Connection *client ) ;
#line 15
void prot_a_parse_arg_delete_conf(Connection *client ) ;
#line 16
void prot_a_parse_arg_lookup_name(Connection *client ) ;
#line 17
void prot_a_parse_arg_get_conf_stat_older(Connection *client ) ;
#line 18
void prot_a_parse_arg_add_member_old(Connection *client ) ;
#line 19
void prot_a_parse_arg_sub_member(Connection *client ) ;
#line 20
void prot_a_parse_arg_set_presentation(Connection *client ) ;
#line 21
void prot_a_parse_arg_set_etc_motd(Connection *client ) ;
#line 22
void prot_a_parse_arg_set_supervisor(Connection *client ) ;
#line 23
void prot_a_parse_arg_set_permitted_submitters(Connection *client ) ;
#line 24
void prot_a_parse_arg_set_super_conf(Connection *client ) ;
#line 25
void prot_a_parse_arg_set_conf_type(Connection *client ) ;
#line 26
void prot_a_parse_arg_set_garb_nice(Connection *client ) ;
#line 27
void prot_a_parse_arg_get_marks(Connection *client ) ;
#line 28
void prot_a_parse_arg_mark_text_old(Connection *client ) ;
#line 29
void prot_a_parse_arg_get_text(Connection *client ) ;
#line 30
void prot_a_parse_arg_get_text_stat_old(Connection *client ) ;
#line 31
void prot_a_parse_arg_mark_as_read(Connection *client ) ;
#line 32
void prot_a_parse_arg_create_text_old(Connection *client ) ;
#line 33
void prot_a_parse_arg_delete_text(Connection *client ) ;
#line 34
void prot_a_parse_arg_add_recipient(Connection *client ) ;
#line 35
void prot_a_parse_arg_sub_recipient(Connection *client ) ;
#line 36
void prot_a_parse_arg_add_comment(Connection *client ) ;
#line 37
void prot_a_parse_arg_sub_comment(Connection *client ) ;
#line 38
void prot_a_parse_arg_get_map(Connection *client ) ;
#line 39
void prot_a_parse_arg_get_time(Connection *client ) ;
#line 40
void prot_a_parse_arg_get_info_old(Connection *client ) ;
#line 41
void prot_a_parse_arg_add_footnote(Connection *client ) ;
#line 42
void prot_a_parse_arg_sub_footnote(Connection *client ) ;
#line 43
void prot_a_parse_arg_who_is_on_old(Connection *client ) ;
#line 44
void prot_a_parse_arg_set_unread(Connection *client ) ;
#line 45
void prot_a_parse_arg_set_motd_of_lyskom(Connection *client ) ;
#line 46
void prot_a_parse_arg_enable(Connection *client ) ;
#line 47
void prot_a_parse_arg_sync_kom(Connection *client ) ;
#line 48
void prot_a_parse_arg_shutdown_kom(Connection *client ) ;
#line 49
void prot_a_parse_arg_broadcast(Connection *client ) ;
#line 50
void prot_a_parse_arg_get_membership_old(Connection *client ) ;
#line 51
void prot_a_parse_arg_get_created_texts(Connection *client ) ;
#line 52
void prot_a_parse_arg_get_members_old(Connection *client ) ;
#line 53
void prot_a_parse_arg_get_person_stat(Connection *client ) ;
#line 54
void prot_a_parse_arg_get_conf_stat_old(Connection *client ) ;
#line 55
void prot_a_parse_arg_who_is_on(Connection *client ) ;
#line 56
void prot_a_parse_arg_get_unread_confs(Connection *client ) ;
#line 57
void prot_a_parse_arg_send_message(Connection *client ) ;
#line 58
void prot_a_parse_arg_get_session_info(Connection *client ) ;
#line 59
void prot_a_parse_arg_disconnect(Connection *client ) ;
#line 60
void prot_a_parse_arg_who_am_i(Connection *client ) ;
#line 61
void prot_a_parse_arg_set_user_area(Connection *client ) ;
#line 62
void prot_a_parse_arg_get_last_text(Connection *client ) ;
#line 63
void prot_a_parse_arg_create_anonymous_text_old(Connection *client ) ;
#line 64
void prot_a_parse_arg_find_next_text_no(Connection *client ) ;
#line 65
void prot_a_parse_arg_find_previous_text_no(Connection *client ) ;
#line 66
void prot_a_parse_arg_login(Connection *client ) ;
#line 67
void prot_a_parse_arg_who_is_on_ident(Connection *client ) ;
#line 68
void prot_a_parse_arg_get_session_info_ident(Connection *client ) ;
#line 69
void prot_a_parse_arg_re_lookup_person(Connection *client ) ;
#line 70
void prot_a_parse_arg_re_lookup_conf(Connection *client ) ;
#line 71
void prot_a_parse_arg_lookup_person(Connection *client ) ;
#line 72
void prot_a_parse_arg_lookup_conf(Connection *client ) ;
#line 73
void prot_a_parse_arg_set_client_version(Connection *client ) ;
#line 74
void prot_a_parse_arg_get_client_name(Connection *client ) ;
#line 75
void prot_a_parse_arg_get_client_version(Connection *client ) ;
#line 76
void prot_a_parse_arg_mark_text(Connection *client ) ;
#line 77
void prot_a_parse_arg_unmark_text(Connection *client ) ;
#line 78
void prot_a_parse_arg_re_z_lookup(Connection *client ) ;
#line 79
void prot_a_parse_arg_get_version_info(Connection *client ) ;
#line 80
void prot_a_parse_arg_lookup_z_name(Connection *client ) ;
#line 81
void prot_a_parse_arg_set_last_read(Connection *client ) ;
#line 82
void prot_a_parse_arg_get_uconf_stat(Connection *client ) ;
#line 83
void prot_a_parse_arg_set_info(Connection *client ) ;
#line 84
void prot_a_parse_arg_accept_async(Connection *client ) ;
#line 85
void prot_a_parse_arg_query_async(Connection *client ) ;
#line 86
void prot_a_parse_arg_user_active(Connection *client ) ;
#line 87
void prot_a_parse_arg_who_is_on_dynamic(Connection *client ) ;
#line 88
void prot_a_parse_arg_get_static_session_info(Connection *client ) ;
#line 89
void prot_a_parse_arg_get_collate_table(Connection *client ) ;
#line 90
void prot_a_parse_arg_create_text(Connection *client ) ;
#line 91
void prot_a_parse_arg_create_anonymous_text(Connection *client ) ;
#line 92
void prot_a_parse_arg_create_conf(Connection *client ) ;
#line 93
void prot_a_parse_arg_create_person(Connection *client ) ;
#line 94
void prot_a_parse_arg_get_text_stat(Connection *client ) ;
#line 95
void prot_a_parse_arg_get_conf_stat(Connection *client ) ;
#line 96
void prot_a_parse_arg_modify_text_info(Connection *client ) ;
#line 97
void prot_a_parse_arg_modify_conf_info(Connection *client ) ;
#line 98
void prot_a_parse_arg_get_info(Connection *client ) ;
#line 99
void prot_a_parse_arg_modify_system_info(Connection *client ) ;
#line 100
void prot_a_parse_arg_query_predefined_aux_items(Connection *client ) ;
#line 101
void prot_a_parse_arg_set_expire(Connection *client ) ;
#line 102
void prot_a_parse_arg_query_read_texts_10(Connection *client ) ;
#line 103
void prot_a_parse_arg_get_membership_10(Connection *client ) ;
#line 104
void prot_a_parse_arg_add_member(Connection *client ) ;
#line 105
void prot_a_parse_arg_get_members(Connection *client ) ;
#line 106
void prot_a_parse_arg_set_membership_type(Connection *client ) ;
#line 107
void prot_a_parse_arg_local_to_global(Connection *client ) ;
#line 108
void prot_a_parse_arg_map_created_texts(Connection *client ) ;
#line 109
void prot_a_parse_arg_set_keep_commented(Connection *client ) ;
#line 110
void prot_a_parse_arg_set_pers_flags(Connection *client ) ;
#line 111
void prot_a_parse_arg_query_read_texts(Connection *client ) ;
#line 112
void prot_a_parse_arg_get_membership(Connection *client ) ;
#line 113
void prot_a_parse_arg_mark_as_unread(Connection *client ) ;
#line 114
void prot_a_parse_arg_set_read_ranges(Connection *client ) ;
#line 115
void prot_a_parse_arg_get_stats_description(Connection *client ) ;
#line 116
void prot_a_parse_arg_get_stats(Connection *client ) ;
#line 117
void prot_a_parse_arg_get_boottime_info(Connection *client ) ;
#line 118
void prot_a_parse_arg_first_unused_conf_no(Connection *client ) ;
#line 119
void prot_a_parse_arg_first_unused_text_no(Connection *client ) ;
#line 120
void prot_a_parse_arg_find_next_conf_no(Connection *client ) ;
#line 121
void prot_a_parse_arg_find_previous_conf_no(Connection *client ) ;
#line 122
void prot_a_parse_arg_get_scheduling(Connection *client ) ;
#line 123
void prot_a_parse_arg_set_scheduling(Connection *client ) ;
#line 124
void prot_a_parse_arg_set_connection_time_format(Connection *client ) ;
#line 125
void prot_a_parse_arg_local_to_global_reverse(Connection *client ) ;
#line 126
void prot_a_parse_arg_map_created_texts_reverse(Connection *client ) ;
#line 29 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_login_old(Connection *client ) 
{ 


  {
  {
#line 34
  if (client->fnc_parse_pos == 0) {
#line 34
    goto case_0;
  }
#line 37
  if (client->fnc_parse_pos == 1) {
#line 37
    goto case_1;
  }
#line 39
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 35
  client->num0 = prot_a_parse_long(client);
#line 36
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 38
  prot_a_parse_string(client, & client->c_string0, param.pwd_len);
  }
  switch_default: /* CIL Label */ 
#line 40
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 42
  return;
}
}
#line 44 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_logout(Connection *client ) 
{ 


  {
  {
#line 49
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 50
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 52
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_change_conference(Connection *client ) 
{ 


  {
  {
#line 59
  if (client->fnc_parse_pos == 0) {
#line 59
    goto case_0;
  }
#line 61
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 60
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 62
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 64
  return;
}
}
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_change_name(Connection *client ) 
{ 


  {
  {
#line 71
  if (client->fnc_parse_pos == 0) {
#line 71
    goto case_0;
  }
#line 74
  if (client->fnc_parse_pos == 1) {
#line 74
    goto case_1;
  }
#line 76
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 72
  client->num0 = prot_a_parse_long(client);
#line 73
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 75
  prot_a_parse_string(client, & client->c_string0, param.conf_name_len);
  }
  switch_default: /* CIL Label */ 
#line 77
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 81 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_change_what_i_am_doing(Connection *client ) 
{ 


  {
  {
#line 86
  if (client->fnc_parse_pos == 0) {
#line 86
    goto case_0;
  }
#line 88
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 87
  prot_a_parse_string(client, & client->string0, param.what_do_len);
  }
  switch_default: /* CIL Label */ 
#line 89
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 93 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_create_person_old(Connection *client ) 
{ 


  {
  {
#line 98
  if (client->fnc_parse_pos == 0) {
#line 98
    goto case_0;
  }
#line 101
  if (client->fnc_parse_pos == 1) {
#line 101
    goto case_1;
  }
#line 103
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 99
  prot_a_parse_string(client, & client->c_string0, param.conf_name_len);
#line 100
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 102
  prot_a_parse_string(client, & client->c_string1, param.pwd_len);
  }
  switch_default: /* CIL Label */ 
#line 104
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 108 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_person_stat_old(Connection *client ) 
{ 


  {
  {
#line 113
  if (client->fnc_parse_pos == 0) {
#line 113
    goto case_0;
  }
#line 116
  if (client->fnc_parse_pos == 1) {
#line 116
    goto case_1;
  }
#line 118
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 114
  client->num0 = prot_a_parse_long(client);
#line 115
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 117
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 119
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 123 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_priv_bits(Connection *client ) 
{ 


  {
  {
#line 128
  if (client->fnc_parse_pos == 0) {
#line 128
    goto case_0;
  }
#line 131
  if (client->fnc_parse_pos == 1) {
#line 131
    goto case_1;
  }
#line 133
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 129
  client->num0 = prot_a_parse_long(client);
#line 130
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 132
  prot_a_parse_priv_bits(client, & client->priv_bits);
  }
  switch_default: /* CIL Label */ 
#line 134
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 138 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_passwd(Connection *client ) 
{ 


  {
  {
#line 143
  if (client->fnc_parse_pos == 0) {
#line 143
    goto case_0;
  }
#line 146
  if (client->fnc_parse_pos == 1) {
#line 146
    goto case_1;
  }
#line 149
  if (client->fnc_parse_pos == 2) {
#line 149
    goto case_2;
  }
#line 151
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 144
  client->num0 = prot_a_parse_long(client);
#line 145
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 147
  prot_a_parse_string(client, & client->c_string0, param.pwd_len);
#line 148
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 150
  prot_a_parse_string(client, & client->c_string1, param.pwd_len);
  }
  switch_default: /* CIL Label */ 
#line 152
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 154
  return;
}
}
#line 156 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_query_read_texts_old(Connection *client ) 
{ 


  {
  {
#line 161
  if (client->fnc_parse_pos == 0) {
#line 161
    goto case_0;
  }
#line 164
  if (client->fnc_parse_pos == 1) {
#line 164
    goto case_1;
  }
#line 166
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 162
  client->num0 = prot_a_parse_long(client);
#line 163
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 165
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 167
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 169
  return;
}
}
#line 171 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_create_conf_old(Connection *client ) 
{ 


  {
  {
#line 176
  if (client->fnc_parse_pos == 0) {
#line 176
    goto case_0;
  }
#line 179
  if (client->fnc_parse_pos == 1) {
#line 179
    goto case_1;
  }
#line 181
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 177
  prot_a_parse_string(client, & client->c_string0, param.conf_name_len);
#line 178
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 180
  prot_a_parse_conf_type(client, & client->conf_type);
  }
  switch_default: /* CIL Label */ 
#line 182
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 184
  return;
}
}
#line 186 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_delete_conf(Connection *client ) 
{ 


  {
  {
#line 191
  if (client->fnc_parse_pos == 0) {
#line 191
    goto case_0;
  }
#line 193
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 192
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 194
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 196
  return;
}
}
#line 198 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_lookup_name(Connection *client ) 
{ 


  {
  {
#line 203
  if (client->fnc_parse_pos == 0) {
#line 203
    goto case_0;
  }
#line 205
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 204
  prot_a_parse_string(client, & client->c_string0, param.conf_name_len);
  }
  switch_default: /* CIL Label */ 
#line 206
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 210 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_conf_stat_older(Connection *client ) 
{ 


  {
  {
#line 215
  if (client->fnc_parse_pos == 0) {
#line 215
    goto case_0;
  }
#line 218
  if (client->fnc_parse_pos == 1) {
#line 218
    goto case_1;
  }
#line 220
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 216
  client->num0 = prot_a_parse_long(client);
#line 217
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 219
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 221
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 223
  return;
}
}
#line 225 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_add_member_old(Connection *client ) 
{ 


  {
  {
#line 230
  if (client->fnc_parse_pos == 0) {
#line 230
    goto case_0;
  }
#line 233
  if (client->fnc_parse_pos == 1) {
#line 233
    goto case_1;
  }
#line 236
  if (client->fnc_parse_pos == 2) {
#line 236
    goto case_2;
  }
#line 239
  if (client->fnc_parse_pos == 3) {
#line 239
    goto case_3;
  }
#line 241
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 231
  client->num0 = prot_a_parse_long(client);
#line 232
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 234
  client->num1 = prot_a_parse_long(client);
#line 235
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 237
  client->num2 = prot_a_parse_long(client);
#line 238
  client->fnc_parse_pos = 3;
  }
  case_3: /* CIL Label */ 
  {
#line 240
  client->num3 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 242
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 244
  return;
}
}
#line 246 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_sub_member(Connection *client ) 
{ 


  {
  {
#line 251
  if (client->fnc_parse_pos == 0) {
#line 251
    goto case_0;
  }
#line 254
  if (client->fnc_parse_pos == 1) {
#line 254
    goto case_1;
  }
#line 256
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 252
  client->num0 = prot_a_parse_long(client);
#line 253
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 255
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 257
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 259
  return;
}
}
#line 261 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_presentation(Connection *client ) 
{ 


  {
  {
#line 266
  if (client->fnc_parse_pos == 0) {
#line 266
    goto case_0;
  }
#line 269
  if (client->fnc_parse_pos == 1) {
#line 269
    goto case_1;
  }
#line 271
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 267
  client->num0 = prot_a_parse_long(client);
#line 268
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 270
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 272
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 274
  return;
}
}
#line 276 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_etc_motd(Connection *client ) 
{ 


  {
  {
#line 281
  if (client->fnc_parse_pos == 0) {
#line 281
    goto case_0;
  }
#line 284
  if (client->fnc_parse_pos == 1) {
#line 284
    goto case_1;
  }
#line 286
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 282
  client->num0 = prot_a_parse_long(client);
#line 283
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 285
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 287
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 289
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_supervisor(Connection *client ) 
{ 


  {
  {
#line 296
  if (client->fnc_parse_pos == 0) {
#line 296
    goto case_0;
  }
#line 299
  if (client->fnc_parse_pos == 1) {
#line 299
    goto case_1;
  }
#line 301
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 297
  client->num0 = prot_a_parse_long(client);
#line 298
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 300
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 302
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 304
  return;
}
}
#line 306 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_permitted_submitters(Connection *client ) 
{ 


  {
  {
#line 311
  if (client->fnc_parse_pos == 0) {
#line 311
    goto case_0;
  }
#line 314
  if (client->fnc_parse_pos == 1) {
#line 314
    goto case_1;
  }
#line 316
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 312
  client->num0 = prot_a_parse_long(client);
#line 313
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 315
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 317
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 319
  return;
}
}
#line 321 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_super_conf(Connection *client ) 
{ 


  {
  {
#line 326
  if (client->fnc_parse_pos == 0) {
#line 326
    goto case_0;
  }
#line 329
  if (client->fnc_parse_pos == 1) {
#line 329
    goto case_1;
  }
#line 331
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 327
  client->num0 = prot_a_parse_long(client);
#line 328
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 330
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 332
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 334
  return;
}
}
#line 336 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_conf_type(Connection *client ) 
{ 


  {
  {
#line 341
  if (client->fnc_parse_pos == 0) {
#line 341
    goto case_0;
  }
#line 344
  if (client->fnc_parse_pos == 1) {
#line 344
    goto case_1;
  }
#line 346
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 342
  client->num0 = prot_a_parse_long(client);
#line 343
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 345
  prot_a_parse_conf_type(client, & client->conf_type);
  }
  switch_default: /* CIL Label */ 
#line 347
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 349
  return;
}
}
#line 351 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_garb_nice(Connection *client ) 
{ 


  {
  {
#line 356
  if (client->fnc_parse_pos == 0) {
#line 356
    goto case_0;
  }
#line 359
  if (client->fnc_parse_pos == 1) {
#line 359
    goto case_1;
  }
#line 361
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 357
  client->num0 = prot_a_parse_long(client);
#line 358
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 360
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 362
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 364
  return;
}
}
#line 366 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_marks(Connection *client ) 
{ 


  {
  {
#line 371
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 372
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 374
  return;
}
}
#line 376 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_mark_text_old(Connection *client ) 
{ 


  {
  {
#line 381
  if (client->fnc_parse_pos == 0) {
#line 381
    goto case_0;
  }
#line 384
  if (client->fnc_parse_pos == 1) {
#line 384
    goto case_1;
  }
#line 386
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 382
  client->num0 = prot_a_parse_long(client);
#line 383
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 385
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 387
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 389
  return;
}
}
#line 391 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_text(Connection *client ) 
{ 


  {
  {
#line 396
  if (client->fnc_parse_pos == 0) {
#line 396
    goto case_0;
  }
#line 399
  if (client->fnc_parse_pos == 1) {
#line 399
    goto case_1;
  }
#line 402
  if (client->fnc_parse_pos == 2) {
#line 402
    goto case_2;
  }
#line 404
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 397
  client->num0 = prot_a_parse_long(client);
#line 398
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 400
  client->num1 = prot_a_parse_long(client);
#line 401
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 403
  client->num2 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 405
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_text_stat_old(Connection *client ) 
{ 


  {
  {
#line 414
  if (client->fnc_parse_pos == 0) {
#line 414
    goto case_0;
  }
#line 416
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 415
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 417
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 419
  return;
}
}
#line 421 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_mark_as_read(Connection *client ) 
{ 


  {
  {
#line 426
  if (client->fnc_parse_pos == 0) {
#line 426
    goto case_0;
  }
#line 429
  if (client->fnc_parse_pos == 1) {
#line 429
    goto case_1;
  }
#line 431
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 427
  client->num0 = prot_a_parse_long(client);
#line 428
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 430
  prot_a_parse_num_list(client, & client->num_list, param.mark_as_read_chunk);
  }
  switch_default: /* CIL Label */ 
#line 432
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_create_text_old(Connection *client ) 
{ 


  {
  {
#line 441
  if (client->fnc_parse_pos == 0) {
#line 441
    goto case_0;
  }
#line 444
  if (client->fnc_parse_pos == 1) {
#line 444
    goto case_1;
  }
#line 446
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 442
  prot_a_parse_string(client, & client->c_string0, param.text_len);
#line 443
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 445
  prot_a_parse_misc_info_list(client, & client->misc_info_list, param.max_crea_misc);
  }
  switch_default: /* CIL Label */ 
#line 447
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 449
  return;
}
}
#line 451 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_delete_text(Connection *client ) 
{ 


  {
  {
#line 456
  if (client->fnc_parse_pos == 0) {
#line 456
    goto case_0;
  }
#line 458
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 457
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 459
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 461
  return;
}
}
#line 463 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_add_recipient(Connection *client ) 
{ 


  {
  {
#line 468
  if (client->fnc_parse_pos == 0) {
#line 468
    goto case_0;
  }
#line 471
  if (client->fnc_parse_pos == 1) {
#line 471
    goto case_1;
  }
#line 474
  if (client->fnc_parse_pos == 2) {
#line 474
    goto case_2;
  }
#line 476
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 469
  client->num0 = prot_a_parse_long(client);
#line 470
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 472
  client->num1 = prot_a_parse_long(client);
#line 473
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 475
  client->num2 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 477
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 479
  return;
}
}
#line 481 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_sub_recipient(Connection *client ) 
{ 


  {
  {
#line 486
  if (client->fnc_parse_pos == 0) {
#line 486
    goto case_0;
  }
#line 489
  if (client->fnc_parse_pos == 1) {
#line 489
    goto case_1;
  }
#line 491
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 487
  client->num0 = prot_a_parse_long(client);
#line 488
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 490
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 492
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 494
  return;
}
}
#line 496 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_add_comment(Connection *client ) 
{ 


  {
  {
#line 501
  if (client->fnc_parse_pos == 0) {
#line 501
    goto case_0;
  }
#line 504
  if (client->fnc_parse_pos == 1) {
#line 504
    goto case_1;
  }
#line 506
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 502
  client->num0 = prot_a_parse_long(client);
#line 503
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 505
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 507
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 509
  return;
}
}
#line 511 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_sub_comment(Connection *client ) 
{ 


  {
  {
#line 516
  if (client->fnc_parse_pos == 0) {
#line 516
    goto case_0;
  }
#line 519
  if (client->fnc_parse_pos == 1) {
#line 519
    goto case_1;
  }
#line 521
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 517
  client->num0 = prot_a_parse_long(client);
#line 518
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 520
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 522
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 524
  return;
}
}
#line 526 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_map(Connection *client ) 
{ 


  {
  {
#line 531
  if (client->fnc_parse_pos == 0) {
#line 531
    goto case_0;
  }
#line 534
  if (client->fnc_parse_pos == 1) {
#line 534
    goto case_1;
  }
#line 537
  if (client->fnc_parse_pos == 2) {
#line 537
    goto case_2;
  }
#line 539
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 532
  client->num0 = prot_a_parse_long(client);
#line 533
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 535
  client->num1 = prot_a_parse_long(client);
#line 536
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 538
  client->num2 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 540
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 542
  return;
}
}
#line 544 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_time(Connection *client ) 
{ 


  {
  {
#line 549
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 550
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 552
  return;
}
}
#line 554 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_info_old(Connection *client ) 
{ 


  {
  {
#line 559
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 560
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 562
  return;
}
}
#line 564 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_add_footnote(Connection *client ) 
{ 


  {
  {
#line 569
  if (client->fnc_parse_pos == 0) {
#line 569
    goto case_0;
  }
#line 572
  if (client->fnc_parse_pos == 1) {
#line 572
    goto case_1;
  }
#line 574
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 570
  client->num0 = prot_a_parse_long(client);
#line 571
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 573
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 575
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 577
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_sub_footnote(Connection *client ) 
{ 


  {
  {
#line 584
  if (client->fnc_parse_pos == 0) {
#line 584
    goto case_0;
  }
#line 587
  if (client->fnc_parse_pos == 1) {
#line 587
    goto case_1;
  }
#line 589
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 585
  client->num0 = prot_a_parse_long(client);
#line 586
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 588
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 590
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 592
  return;
}
}
#line 594 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_who_is_on_old(Connection *client ) 
{ 


  {
  {
#line 599
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 600
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 602
  return;
}
}
#line 604 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_unread(Connection *client ) 
{ 


  {
  {
#line 609
  if (client->fnc_parse_pos == 0) {
#line 609
    goto case_0;
  }
#line 612
  if (client->fnc_parse_pos == 1) {
#line 612
    goto case_1;
  }
#line 614
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 610
  client->num0 = prot_a_parse_long(client);
#line 611
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 613
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 615
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 617
  return;
}
}
#line 619 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_motd_of_lyskom(Connection *client ) 
{ 


  {
  {
#line 624
  if (client->fnc_parse_pos == 0) {
#line 624
    goto case_0;
  }
#line 626
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 625
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 627
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 629
  return;
}
}
#line 631 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_enable(Connection *client ) 
{ 


  {
  {
#line 636
  if (client->fnc_parse_pos == 0) {
#line 636
    goto case_0;
  }
#line 638
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 637
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 639
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 641
  return;
}
}
#line 643 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_sync_kom(Connection *client ) 
{ 


  {
  {
#line 648
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 649
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 651
  return;
}
}
#line 653 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_shutdown_kom(Connection *client ) 
{ 


  {
  {
#line 658
  if (client->fnc_parse_pos == 0) {
#line 658
    goto case_0;
  }
#line 660
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 659
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 661
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 663
  return;
}
}
#line 665 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_broadcast(Connection *client ) 
{ 


  {
  {
#line 670
  if (client->fnc_parse_pos == 0) {
#line 670
    goto case_0;
  }
#line 672
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 671
  prot_a_parse_string(client, & client->c_string0, param.broadcast_len);
  }
  switch_default: /* CIL Label */ 
#line 673
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 675
  return;
}
}
#line 677 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_membership_old(Connection *client ) 
{ 


  {
  {
#line 682
  if (client->fnc_parse_pos == 0) {
#line 682
    goto case_0;
  }
#line 685
  if (client->fnc_parse_pos == 1) {
#line 685
    goto case_1;
  }
#line 688
  if (client->fnc_parse_pos == 2) {
#line 688
    goto case_2;
  }
#line 691
  if (client->fnc_parse_pos == 3) {
#line 691
    goto case_3;
  }
#line 693
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 683
  client->num0 = prot_a_parse_long(client);
#line 684
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 686
  client->num1 = prot_a_parse_long(client);
#line 687
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 689
  client->num2 = prot_a_parse_long(client);
#line 690
  client->fnc_parse_pos = 3;
  }
  case_3: /* CIL Label */ 
  {
#line 692
  client->num3 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 694
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 696
  return;
}
}
#line 698 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_created_texts(Connection *client ) 
{ 


  {
  {
#line 703
  if (client->fnc_parse_pos == 0) {
#line 703
    goto case_0;
  }
#line 706
  if (client->fnc_parse_pos == 1) {
#line 706
    goto case_1;
  }
#line 709
  if (client->fnc_parse_pos == 2) {
#line 709
    goto case_2;
  }
#line 711
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 704
  client->num0 = prot_a_parse_long(client);
#line 705
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 707
  client->num1 = prot_a_parse_long(client);
#line 708
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 710
  client->num2 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 712
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 714
  return;
}
}
#line 716 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_members_old(Connection *client ) 
{ 


  {
  {
#line 721
  if (client->fnc_parse_pos == 0) {
#line 721
    goto case_0;
  }
#line 724
  if (client->fnc_parse_pos == 1) {
#line 724
    goto case_1;
  }
#line 727
  if (client->fnc_parse_pos == 2) {
#line 727
    goto case_2;
  }
#line 729
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 722
  client->num0 = prot_a_parse_long(client);
#line 723
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 725
  client->num1 = prot_a_parse_long(client);
#line 726
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 728
  client->num2 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 730
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 732
  return;
}
}
#line 734 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_person_stat(Connection *client ) 
{ 


  {
  {
#line 739
  if (client->fnc_parse_pos == 0) {
#line 739
    goto case_0;
  }
#line 741
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 740
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 742
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 744
  return;
}
}
#line 746 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_conf_stat_old(Connection *client ) 
{ 


  {
  {
#line 751
  if (client->fnc_parse_pos == 0) {
#line 751
    goto case_0;
  }
#line 753
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 752
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 754
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 756
  return;
}
}
#line 758 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_who_is_on(Connection *client ) 
{ 


  {
  {
#line 763
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 764
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 766
  return;
}
}
#line 768 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_unread_confs(Connection *client ) 
{ 


  {
  {
#line 773
  if (client->fnc_parse_pos == 0) {
#line 773
    goto case_0;
  }
#line 775
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 774
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 776
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 778
  return;
}
}
#line 780 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_send_message(Connection *client ) 
{ 


  {
  {
#line 785
  if (client->fnc_parse_pos == 0) {
#line 785
    goto case_0;
  }
#line 788
  if (client->fnc_parse_pos == 1) {
#line 788
    goto case_1;
  }
#line 790
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 786
  client->num0 = prot_a_parse_long(client);
#line 787
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 789
  prot_a_parse_string(client, & client->c_string0, param.broadcast_len);
  }
  switch_default: /* CIL Label */ 
#line 791
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 793
  return;
}
}
#line 795 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_session_info(Connection *client ) 
{ 


  {
  {
#line 800
  if (client->fnc_parse_pos == 0) {
#line 800
    goto case_0;
  }
#line 802
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 801
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 803
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 805
  return;
}
}
#line 807 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_disconnect(Connection *client ) 
{ 


  {
  {
#line 812
  if (client->fnc_parse_pos == 0) {
#line 812
    goto case_0;
  }
#line 814
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 813
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 815
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 817
  return;
}
}
#line 819 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_who_am_i(Connection *client ) 
{ 


  {
  {
#line 824
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 825
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 827
  return;
}
}
#line 829 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_user_area(Connection *client ) 
{ 


  {
  {
#line 834
  if (client->fnc_parse_pos == 0) {
#line 834
    goto case_0;
  }
#line 837
  if (client->fnc_parse_pos == 1) {
#line 837
    goto case_1;
  }
#line 839
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 835
  client->num0 = prot_a_parse_long(client);
#line 836
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 838
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 840
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 842
  return;
}
}
#line 844 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_last_text(Connection *client ) 
{ 


  {
  {
#line 849
  if (client->fnc_parse_pos == 0) {
#line 849
    goto case_0;
  }
#line 851
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 850
  prot_a_parse_time_date(client, & client->time);
  }
  switch_default: /* CIL Label */ 
#line 852
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 854
  return;
}
}
#line 856 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_create_anonymous_text_old(Connection *client ) 
{ 


  {
  {
#line 861
  if (client->fnc_parse_pos == 0) {
#line 861
    goto case_0;
  }
#line 864
  if (client->fnc_parse_pos == 1) {
#line 864
    goto case_1;
  }
#line 866
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 862
  prot_a_parse_string(client, & client->c_string0, param.text_len);
#line 863
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 865
  prot_a_parse_misc_info_list(client, & client->misc_info_list, param.max_crea_misc);
  }
  switch_default: /* CIL Label */ 
#line 867
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 869
  return;
}
}
#line 871 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_find_next_text_no(Connection *client ) 
{ 


  {
  {
#line 876
  if (client->fnc_parse_pos == 0) {
#line 876
    goto case_0;
  }
#line 878
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 877
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 879
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 881
  return;
}
}
#line 883 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_find_previous_text_no(Connection *client ) 
{ 


  {
  {
#line 888
  if (client->fnc_parse_pos == 0) {
#line 888
    goto case_0;
  }
#line 890
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 889
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 891
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 893
  return;
}
}
#line 895 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_login(Connection *client ) 
{ 


  {
  {
#line 900
  if (client->fnc_parse_pos == 0) {
#line 900
    goto case_0;
  }
#line 903
  if (client->fnc_parse_pos == 1) {
#line 903
    goto case_1;
  }
#line 906
  if (client->fnc_parse_pos == 2) {
#line 906
    goto case_2;
  }
#line 908
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 901
  client->num0 = prot_a_parse_long(client);
#line 902
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 904
  prot_a_parse_string(client, & client->c_string0, param.pwd_len);
#line 905
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 907
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 909
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 911
  return;
}
}
#line 913 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_who_is_on_ident(Connection *client ) 
{ 


  {
  {
#line 918
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 919
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 921
  return;
}
}
#line 923 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_session_info_ident(Connection *client ) 
{ 


  {
  {
#line 928
  if (client->fnc_parse_pos == 0) {
#line 928
    goto case_0;
  }
#line 930
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 929
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 931
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 933
  return;
}
}
#line 935 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_re_lookup_person(Connection *client ) 
{ 


  {
  {
#line 940
  if (client->fnc_parse_pos == 0) {
#line 940
    goto case_0;
  }
#line 942
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 941
  prot_a_parse_string(client, & client->c_string0, param.regexp_len);
  }
  switch_default: /* CIL Label */ 
#line 943
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 945
  return;
}
}
#line 947 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_re_lookup_conf(Connection *client ) 
{ 


  {
  {
#line 952
  if (client->fnc_parse_pos == 0) {
#line 952
    goto case_0;
  }
#line 954
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 953
  prot_a_parse_string(client, & client->c_string0, param.regexp_len);
  }
  switch_default: /* CIL Label */ 
#line 955
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 957
  return;
}
}
#line 959 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_lookup_person(Connection *client ) 
{ 


  {
  {
#line 964
  if (client->fnc_parse_pos == 0) {
#line 964
    goto case_0;
  }
#line 966
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 965
  prot_a_parse_string(client, & client->c_string0, param.conf_name_len);
  }
  switch_default: /* CIL Label */ 
#line 967
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 969
  return;
}
}
#line 971 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_lookup_conf(Connection *client ) 
{ 


  {
  {
#line 976
  if (client->fnc_parse_pos == 0) {
#line 976
    goto case_0;
  }
#line 978
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 977
  prot_a_parse_string(client, & client->c_string0, param.conf_name_len);
  }
  switch_default: /* CIL Label */ 
#line 979
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 981
  return;
}
}
#line 983 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_client_version(Connection *client ) 
{ 


  {
  {
#line 988
  if (client->fnc_parse_pos == 0) {
#line 988
    goto case_0;
  }
#line 991
  if (client->fnc_parse_pos == 1) {
#line 991
    goto case_1;
  }
#line 993
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 989
  prot_a_parse_string(client, & client->c_string0, param.client_data_len);
#line 990
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 992
  prot_a_parse_string(client, & client->c_string1, param.client_data_len);
  }
  switch_default: /* CIL Label */ 
#line 994
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 996
  return;
}
}
#line 998 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_client_name(Connection *client ) 
{ 


  {
  {
#line 1003
  if (client->fnc_parse_pos == 0) {
#line 1003
    goto case_0;
  }
#line 1005
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1004
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1006
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1008
  return;
}
}
#line 1010 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_client_version(Connection *client ) 
{ 


  {
  {
#line 1015
  if (client->fnc_parse_pos == 0) {
#line 1015
    goto case_0;
  }
#line 1017
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1016
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1018
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1020
  return;
}
}
#line 1022 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_mark_text(Connection *client ) 
{ 


  {
  {
#line 1027
  if (client->fnc_parse_pos == 0) {
#line 1027
    goto case_0;
  }
#line 1030
  if (client->fnc_parse_pos == 1) {
#line 1030
    goto case_1;
  }
#line 1032
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1028
  client->num0 = prot_a_parse_long(client);
#line 1029
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1031
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1033
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1035
  return;
}
}
#line 1037 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_unmark_text(Connection *client ) 
{ 


  {
  {
#line 1042
  if (client->fnc_parse_pos == 0) {
#line 1042
    goto case_0;
  }
#line 1044
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1043
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1045
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1047
  return;
}
}
#line 1049 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_re_z_lookup(Connection *client ) 
{ 


  {
  {
#line 1054
  if (client->fnc_parse_pos == 0) {
#line 1054
    goto case_0;
  }
#line 1057
  if (client->fnc_parse_pos == 1) {
#line 1057
    goto case_1;
  }
#line 1060
  if (client->fnc_parse_pos == 2) {
#line 1060
    goto case_2;
  }
#line 1062
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1055
  prot_a_parse_string(client, & client->c_string0, param.regexp_len);
#line 1056
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1058
  client->num0 = prot_a_parse_long(client);
#line 1059
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1061
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1063
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1065
  return;
}
}
#line 1067 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_version_info(Connection *client ) 
{ 


  {
  {
#line 1072
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1073
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1075
  return;
}
}
#line 1077 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_lookup_z_name(Connection *client ) 
{ 


  {
  {
#line 1082
  if (client->fnc_parse_pos == 0) {
#line 1082
    goto case_0;
  }
#line 1085
  if (client->fnc_parse_pos == 1) {
#line 1085
    goto case_1;
  }
#line 1088
  if (client->fnc_parse_pos == 2) {
#line 1088
    goto case_2;
  }
#line 1090
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1083
  prot_a_parse_string(client, & client->c_string0, param.conf_name_len);
#line 1084
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1086
  client->num0 = prot_a_parse_long(client);
#line 1087
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1089
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1091
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1093
  return;
}
}
#line 1095 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_last_read(Connection *client ) 
{ 


  {
  {
#line 1100
  if (client->fnc_parse_pos == 0) {
#line 1100
    goto case_0;
  }
#line 1103
  if (client->fnc_parse_pos == 1) {
#line 1103
    goto case_1;
  }
#line 1105
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1101
  client->num0 = prot_a_parse_long(client);
#line 1102
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1104
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1106
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1108
  return;
}
}
#line 1110 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_uconf_stat(Connection *client ) 
{ 


  {
  {
#line 1115
  if (client->fnc_parse_pos == 0) {
#line 1115
    goto case_0;
  }
#line 1117
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1116
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1118
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1120
  return;
}
}
#line 1122 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_info(Connection *client ) 
{ 


  {
  {
#line 1127
  if (client->fnc_parse_pos == 0) {
#line 1127
    goto case_0;
  }
#line 1129
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1128
  prot_a_parse_info(client, & client->info);
  }
  switch_default: /* CIL Label */ 
#line 1130
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1132
  return;
}
}
#line 1134 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_accept_async(Connection *client ) 
{ 


  {
  {
#line 1139
  if (client->fnc_parse_pos == 0) {
#line 1139
    goto case_0;
  }
#line 1141
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1140
  prot_a_parse_num_list(client, & client->num_list, param.accept_async_len);
  }
  switch_default: /* CIL Label */ 
#line 1142
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1144
  return;
}
}
#line 1146 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_query_async(Connection *client ) 
{ 


  {
  {
#line 1151
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1152
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1154
  return;
}
}
#line 1156 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_user_active(Connection *client ) 
{ 


  {
  {
#line 1161
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1162
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1164
  return;
}
}
#line 1166 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_who_is_on_dynamic(Connection *client ) 
{ 


  {
  {
#line 1171
  if (client->fnc_parse_pos == 0) {
#line 1171
    goto case_0;
  }
#line 1174
  if (client->fnc_parse_pos == 1) {
#line 1174
    goto case_1;
  }
#line 1177
  if (client->fnc_parse_pos == 2) {
#line 1177
    goto case_2;
  }
#line 1179
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1172
  client->num0 = prot_a_parse_long(client);
#line 1173
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1175
  client->num1 = prot_a_parse_long(client);
#line 1176
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1178
  client->num2 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1180
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1182
  return;
}
}
#line 1184 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_static_session_info(Connection *client ) 
{ 


  {
  {
#line 1189
  if (client->fnc_parse_pos == 0) {
#line 1189
    goto case_0;
  }
#line 1191
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1190
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1192
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1194
  return;
}
}
#line 1196 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_collate_table(Connection *client ) 
{ 


  {
  {
#line 1201
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1202
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1204
  return;
}
}
#line 1206 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_create_text(Connection *client ) 
{ 


  {
  {
#line 1211
  if (client->fnc_parse_pos == 0) {
#line 1211
    goto case_0;
  }
#line 1214
  if (client->fnc_parse_pos == 1) {
#line 1214
    goto case_1;
  }
#line 1217
  if (client->fnc_parse_pos == 2) {
#line 1217
    goto case_2;
  }
#line 1219
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1212
  prot_a_parse_string(client, & client->c_string0, param.text_len);
#line 1213
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1215
  prot_a_parse_misc_info_list(client, & client->misc_info_list, param.max_crea_misc);
#line 1216
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1218
  prot_a_parse_aux_item_list(client, & client->aux_item_list, param.max_add_aux);
  }
  switch_default: /* CIL Label */ 
#line 1220
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1222
  return;
}
}
#line 1224 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_create_anonymous_text(Connection *client ) 
{ 


  {
  {
#line 1229
  if (client->fnc_parse_pos == 0) {
#line 1229
    goto case_0;
  }
#line 1232
  if (client->fnc_parse_pos == 1) {
#line 1232
    goto case_1;
  }
#line 1235
  if (client->fnc_parse_pos == 2) {
#line 1235
    goto case_2;
  }
#line 1237
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1230
  prot_a_parse_string(client, & client->c_string0, param.text_len);
#line 1231
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1233
  prot_a_parse_misc_info_list(client, & client->misc_info_list, param.max_crea_misc);
#line 1234
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1236
  prot_a_parse_aux_item_list(client, & client->aux_item_list, param.max_add_aux);
  }
  switch_default: /* CIL Label */ 
#line 1238
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1240
  return;
}
}
#line 1242 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_create_conf(Connection *client ) 
{ 


  {
  {
#line 1247
  if (client->fnc_parse_pos == 0) {
#line 1247
    goto case_0;
  }
#line 1250
  if (client->fnc_parse_pos == 1) {
#line 1250
    goto case_1;
  }
#line 1253
  if (client->fnc_parse_pos == 2) {
#line 1253
    goto case_2;
  }
#line 1255
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1248
  prot_a_parse_string(client, & client->c_string0, param.conf_name_len);
#line 1249
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1251
  prot_a_parse_conf_type(client, & client->conf_type);
#line 1252
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1254
  prot_a_parse_aux_item_list(client, & client->aux_item_list, param.max_add_aux);
  }
  switch_default: /* CIL Label */ 
#line 1256
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1258
  return;
}
}
#line 1260 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_create_person(Connection *client ) 
{ 


  {
  {
#line 1265
  if (client->fnc_parse_pos == 0) {
#line 1265
    goto case_0;
  }
#line 1268
  if (client->fnc_parse_pos == 1) {
#line 1268
    goto case_1;
  }
#line 1271
  if (client->fnc_parse_pos == 2) {
#line 1271
    goto case_2;
  }
#line 1274
  if (client->fnc_parse_pos == 3) {
#line 1274
    goto case_3;
  }
#line 1276
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1266
  prot_a_parse_string(client, & client->c_string0, param.conf_name_len);
#line 1267
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1269
  prot_a_parse_string(client, & client->c_string1, param.pwd_len);
#line 1270
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1272
  prot_a_parse_pers_flags(client, & client->pers_flags);
#line 1273
  client->fnc_parse_pos = 3;
  }
  case_3: /* CIL Label */ 
  {
#line 1275
  prot_a_parse_aux_item_list(client, & client->aux_item_list, param.max_add_aux);
  }
  switch_default: /* CIL Label */ 
#line 1277
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1279
  return;
}
}
#line 1281 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_text_stat(Connection *client ) 
{ 


  {
  {
#line 1286
  if (client->fnc_parse_pos == 0) {
#line 1286
    goto case_0;
  }
#line 1288
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1287
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1289
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1291
  return;
}
}
#line 1293 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_conf_stat(Connection *client ) 
{ 


  {
  {
#line 1298
  if (client->fnc_parse_pos == 0) {
#line 1298
    goto case_0;
  }
#line 1300
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1299
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1301
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1303
  return;
}
}
#line 1305 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_modify_text_info(Connection *client ) 
{ 


  {
  {
#line 1310
  if (client->fnc_parse_pos == 0) {
#line 1310
    goto case_0;
  }
#line 1313
  if (client->fnc_parse_pos == 1) {
#line 1313
    goto case_1;
  }
#line 1316
  if (client->fnc_parse_pos == 2) {
#line 1316
    goto case_2;
  }
#line 1318
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1311
  client->num0 = prot_a_parse_long(client);
#line 1312
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1314
  prot_a_parse_num_list(client, & client->num_list, param.max_delete_aux);
#line 1315
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1317
  prot_a_parse_aux_item_list(client, & client->aux_item_list, param.max_add_aux);
  }
  switch_default: /* CIL Label */ 
#line 1319
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1321
  return;
}
}
#line 1323 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_modify_conf_info(Connection *client ) 
{ 


  {
  {
#line 1328
  if (client->fnc_parse_pos == 0) {
#line 1328
    goto case_0;
  }
#line 1331
  if (client->fnc_parse_pos == 1) {
#line 1331
    goto case_1;
  }
#line 1334
  if (client->fnc_parse_pos == 2) {
#line 1334
    goto case_2;
  }
#line 1336
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1329
  client->num0 = prot_a_parse_long(client);
#line 1330
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1332
  prot_a_parse_num_list(client, & client->num_list, param.max_delete_aux);
#line 1333
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1335
  prot_a_parse_aux_item_list(client, & client->aux_item_list, param.max_add_aux);
  }
  switch_default: /* CIL Label */ 
#line 1337
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1339
  return;
}
}
#line 1341 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_info(Connection *client ) 
{ 


  {
  {
#line 1346
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1347
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1349
  return;
}
}
#line 1351 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_modify_system_info(Connection *client ) 
{ 


  {
  {
#line 1356
  if (client->fnc_parse_pos == 0) {
#line 1356
    goto case_0;
  }
#line 1359
  if (client->fnc_parse_pos == 1) {
#line 1359
    goto case_1;
  }
#line 1361
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1357
  prot_a_parse_num_list(client, & client->num_list, param.max_delete_aux);
#line 1358
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1360
  prot_a_parse_aux_item_list(client, & client->aux_item_list, param.max_add_aux);
  }
  switch_default: /* CIL Label */ 
#line 1362
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1364
  return;
}
}
#line 1366 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_query_predefined_aux_items(Connection *client ) 
{ 


  {
  {
#line 1371
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1372
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1374
  return;
}
}
#line 1376 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_expire(Connection *client ) 
{ 


  {
  {
#line 1381
  if (client->fnc_parse_pos == 0) {
#line 1381
    goto case_0;
  }
#line 1384
  if (client->fnc_parse_pos == 1) {
#line 1384
    goto case_1;
  }
#line 1386
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1382
  client->num0 = prot_a_parse_long(client);
#line 1383
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1385
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1387
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1389
  return;
}
}
#line 1391 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_query_read_texts_10(Connection *client ) 
{ 


  {
  {
#line 1396
  if (client->fnc_parse_pos == 0) {
#line 1396
    goto case_0;
  }
#line 1399
  if (client->fnc_parse_pos == 1) {
#line 1399
    goto case_1;
  }
#line 1401
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1397
  client->num0 = prot_a_parse_long(client);
#line 1398
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1400
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1402
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1404
  return;
}
}
#line 1406 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_membership_10(Connection *client ) 
{ 


  {
  {
#line 1411
  if (client->fnc_parse_pos == 0) {
#line 1411
    goto case_0;
  }
#line 1414
  if (client->fnc_parse_pos == 1) {
#line 1414
    goto case_1;
  }
#line 1417
  if (client->fnc_parse_pos == 2) {
#line 1417
    goto case_2;
  }
#line 1420
  if (client->fnc_parse_pos == 3) {
#line 1420
    goto case_3;
  }
#line 1422
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1412
  client->num0 = prot_a_parse_long(client);
#line 1413
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1415
  client->num1 = prot_a_parse_long(client);
#line 1416
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1418
  client->num2 = prot_a_parse_long(client);
#line 1419
  client->fnc_parse_pos = 3;
  }
  case_3: /* CIL Label */ 
  {
#line 1421
  client->num3 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1423
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1425
  return;
}
}
#line 1427 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_add_member(Connection *client ) 
{ 


  {
  {
#line 1432
  if (client->fnc_parse_pos == 0) {
#line 1432
    goto case_0;
  }
#line 1435
  if (client->fnc_parse_pos == 1) {
#line 1435
    goto case_1;
  }
#line 1438
  if (client->fnc_parse_pos == 2) {
#line 1438
    goto case_2;
  }
#line 1441
  if (client->fnc_parse_pos == 3) {
#line 1441
    goto case_3;
  }
#line 1444
  if (client->fnc_parse_pos == 4) {
#line 1444
    goto case_4;
  }
#line 1446
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1433
  client->num0 = prot_a_parse_long(client);
#line 1434
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1436
  client->num1 = prot_a_parse_long(client);
#line 1437
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1439
  client->num2 = prot_a_parse_long(client);
#line 1440
  client->fnc_parse_pos = 3;
  }
  case_3: /* CIL Label */ 
  {
#line 1442
  client->num3 = prot_a_parse_long(client);
#line 1443
  client->fnc_parse_pos = 4;
  }
  case_4: /* CIL Label */ 
  {
#line 1445
  prot_a_parse_membership_type(client, & client->membership_type);
  }
  switch_default: /* CIL Label */ 
#line 1447
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1449
  return;
}
}
#line 1451 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_members(Connection *client ) 
{ 


  {
  {
#line 1456
  if (client->fnc_parse_pos == 0) {
#line 1456
    goto case_0;
  }
#line 1459
  if (client->fnc_parse_pos == 1) {
#line 1459
    goto case_1;
  }
#line 1462
  if (client->fnc_parse_pos == 2) {
#line 1462
    goto case_2;
  }
#line 1464
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1457
  client->num0 = prot_a_parse_long(client);
#line 1458
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1460
  client->num1 = prot_a_parse_long(client);
#line 1461
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1463
  client->num2 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1465
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1467
  return;
}
}
#line 1469 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_membership_type(Connection *client ) 
{ 


  {
  {
#line 1474
  if (client->fnc_parse_pos == 0) {
#line 1474
    goto case_0;
  }
#line 1477
  if (client->fnc_parse_pos == 1) {
#line 1477
    goto case_1;
  }
#line 1480
  if (client->fnc_parse_pos == 2) {
#line 1480
    goto case_2;
  }
#line 1482
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1475
  client->num0 = prot_a_parse_long(client);
#line 1476
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1478
  client->num1 = prot_a_parse_long(client);
#line 1479
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1481
  prot_a_parse_membership_type(client, & client->membership_type);
  }
  switch_default: /* CIL Label */ 
#line 1483
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1485
  return;
}
}
#line 1487 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_local_to_global(Connection *client ) 
{ 


  {
  {
#line 1492
  if (client->fnc_parse_pos == 0) {
#line 1492
    goto case_0;
  }
#line 1495
  if (client->fnc_parse_pos == 1) {
#line 1495
    goto case_1;
  }
#line 1498
  if (client->fnc_parse_pos == 2) {
#line 1498
    goto case_2;
  }
#line 1500
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1493
  client->num0 = prot_a_parse_long(client);
#line 1494
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1496
  client->num1 = prot_a_parse_long(client);
#line 1497
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1499
  client->num2 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1501
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1503
  return;
}
}
#line 1505 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_map_created_texts(Connection *client ) 
{ 


  {
  {
#line 1510
  if (client->fnc_parse_pos == 0) {
#line 1510
    goto case_0;
  }
#line 1513
  if (client->fnc_parse_pos == 1) {
#line 1513
    goto case_1;
  }
#line 1516
  if (client->fnc_parse_pos == 2) {
#line 1516
    goto case_2;
  }
#line 1518
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1511
  client->num0 = prot_a_parse_long(client);
#line 1512
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1514
  client->num1 = prot_a_parse_long(client);
#line 1515
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1517
  client->num2 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1519
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1521
  return;
}
}
#line 1523 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_keep_commented(Connection *client ) 
{ 


  {
  {
#line 1528
  if (client->fnc_parse_pos == 0) {
#line 1528
    goto case_0;
  }
#line 1531
  if (client->fnc_parse_pos == 1) {
#line 1531
    goto case_1;
  }
#line 1533
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1529
  client->num0 = prot_a_parse_long(client);
#line 1530
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1532
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1534
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1536
  return;
}
}
#line 1538 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_pers_flags(Connection *client ) 
{ 


  {
  {
#line 1543
  if (client->fnc_parse_pos == 0) {
#line 1543
    goto case_0;
  }
#line 1546
  if (client->fnc_parse_pos == 1) {
#line 1546
    goto case_1;
  }
#line 1548
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1544
  client->num0 = prot_a_parse_long(client);
#line 1545
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1547
  prot_a_parse_pers_flags(client, & client->pers_flags);
  }
  switch_default: /* CIL Label */ 
#line 1549
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1551
  return;
}
}
#line 1553 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_query_read_texts(Connection *client ) 
{ 


  {
  {
#line 1558
  if (client->fnc_parse_pos == 0) {
#line 1558
    goto case_0;
  }
#line 1561
  if (client->fnc_parse_pos == 1) {
#line 1561
    goto case_1;
  }
#line 1564
  if (client->fnc_parse_pos == 2) {
#line 1564
    goto case_2;
  }
#line 1567
  if (client->fnc_parse_pos == 3) {
#line 1567
    goto case_3;
  }
#line 1569
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1559
  client->num0 = prot_a_parse_long(client);
#line 1560
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1562
  client->num1 = prot_a_parse_long(client);
#line 1563
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1565
  client->num2 = prot_a_parse_long(client);
#line 1566
  client->fnc_parse_pos = 3;
  }
  case_3: /* CIL Label */ 
  {
#line 1568
  client->num3 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1570
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1572
  return;
}
}
#line 1574 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_membership(Connection *client ) 
{ 


  {
  {
#line 1579
  if (client->fnc_parse_pos == 0) {
#line 1579
    goto case_0;
  }
#line 1582
  if (client->fnc_parse_pos == 1) {
#line 1582
    goto case_1;
  }
#line 1585
  if (client->fnc_parse_pos == 2) {
#line 1585
    goto case_2;
  }
#line 1588
  if (client->fnc_parse_pos == 3) {
#line 1588
    goto case_3;
  }
#line 1591
  if (client->fnc_parse_pos == 4) {
#line 1591
    goto case_4;
  }
#line 1593
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1580
  client->num0 = prot_a_parse_long(client);
#line 1581
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1583
  client->num1 = prot_a_parse_long(client);
#line 1584
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1586
  client->num2 = prot_a_parse_long(client);
#line 1587
  client->fnc_parse_pos = 3;
  }
  case_3: /* CIL Label */ 
  {
#line 1589
  client->num3 = prot_a_parse_long(client);
#line 1590
  client->fnc_parse_pos = 4;
  }
  case_4: /* CIL Label */ 
  {
#line 1592
  client->num4 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1594
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1596
  return;
}
}
#line 1598 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_mark_as_unread(Connection *client ) 
{ 


  {
  {
#line 1603
  if (client->fnc_parse_pos == 0) {
#line 1603
    goto case_0;
  }
#line 1606
  if (client->fnc_parse_pos == 1) {
#line 1606
    goto case_1;
  }
#line 1608
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1604
  client->num0 = prot_a_parse_long(client);
#line 1605
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1607
  client->num1 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1609
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1611
  return;
}
}
#line 1613 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_read_ranges(Connection *client ) 
{ 


  {
  {
#line 1618
  if (client->fnc_parse_pos == 0) {
#line 1618
    goto case_0;
  }
#line 1621
  if (client->fnc_parse_pos == 1) {
#line 1621
    goto case_1;
  }
#line 1623
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1619
  client->num0 = prot_a_parse_long(client);
#line 1620
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1622
  prot_a_parse_read_range_list(client, & client->read_range_list, param.max_read_ranges);
  }
  switch_default: /* CIL Label */ 
#line 1624
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1626
  return;
}
}
#line 1628 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_stats_description(Connection *client ) 
{ 


  {
  {
#line 1633
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1634
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1636
  return;
}
}
#line 1638 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_stats(Connection *client ) 
{ 


  {
  {
#line 1643
  if (client->fnc_parse_pos == 0) {
#line 1643
    goto case_0;
  }
#line 1645
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1644
  prot_a_parse_string(client, & client->c_string0, param.stat_name_len);
  }
  switch_default: /* CIL Label */ 
#line 1646
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1648
  return;
}
}
#line 1650 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_boottime_info(Connection *client ) 
{ 


  {
  {
#line 1655
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1656
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1658
  return;
}
}
#line 1660 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_first_unused_conf_no(Connection *client ) 
{ 


  {
  {
#line 1665
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1666
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1668
  return;
}
}
#line 1670 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_first_unused_text_no(Connection *client ) 
{ 


  {
  {
#line 1675
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1676
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1678
  return;
}
}
#line 1680 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_find_next_conf_no(Connection *client ) 
{ 


  {
  {
#line 1685
  if (client->fnc_parse_pos == 0) {
#line 1685
    goto case_0;
  }
#line 1687
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1686
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1688
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1690
  return;
}
}
#line 1692 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_find_previous_conf_no(Connection *client ) 
{ 


  {
  {
#line 1697
  if (client->fnc_parse_pos == 0) {
#line 1697
    goto case_0;
  }
#line 1699
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1698
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1700
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1702
  return;
}
}
#line 1704 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_get_scheduling(Connection *client ) 
{ 


  {
  {
#line 1709
  if (client->fnc_parse_pos == 0) {
#line 1709
    goto case_0;
  }
#line 1711
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1710
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1712
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1714
  return;
}
}
#line 1716 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_scheduling(Connection *client ) 
{ 


  {
  {
#line 1721
  if (client->fnc_parse_pos == 0) {
#line 1721
    goto case_0;
  }
#line 1724
  if (client->fnc_parse_pos == 1) {
#line 1724
    goto case_1;
  }
#line 1727
  if (client->fnc_parse_pos == 2) {
#line 1727
    goto case_2;
  }
#line 1729
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1722
  client->num0 = prot_a_parse_long(client);
#line 1723
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1725
  client->num1 = prot_a_parse_long(client);
#line 1726
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1728
  client->num2 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1730
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1732
  return;
}
}
#line 1734 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_set_connection_time_format(Connection *client ) 
{ 


  {
  {
#line 1739
  if (client->fnc_parse_pos == 0) {
#line 1739
    goto case_0;
  }
#line 1741
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1740
  client->num0 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1742
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1744
  return;
}
}
#line 1746 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_local_to_global_reverse(Connection *client ) 
{ 


  {
  {
#line 1751
  if (client->fnc_parse_pos == 0) {
#line 1751
    goto case_0;
  }
#line 1754
  if (client->fnc_parse_pos == 1) {
#line 1754
    goto case_1;
  }
#line 1757
  if (client->fnc_parse_pos == 2) {
#line 1757
    goto case_2;
  }
#line 1759
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1752
  client->num0 = prot_a_parse_long(client);
#line 1753
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1755
  client->num1 = prot_a_parse_long(client);
#line 1756
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1758
  client->num2 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1760
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1762
  return;
}
}
#line 1764 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse-arg.c"
void prot_a_parse_arg_map_created_texts_reverse(Connection *client ) 
{ 


  {
  {
#line 1769
  if (client->fnc_parse_pos == 0) {
#line 1769
    goto case_0;
  }
#line 1772
  if (client->fnc_parse_pos == 1) {
#line 1772
    goto case_1;
  }
#line 1775
  if (client->fnc_parse_pos == 2) {
#line 1775
    goto case_2;
  }
#line 1777
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1770
  client->num0 = prot_a_parse_long(client);
#line 1771
  client->fnc_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 1773
  client->num1 = prot_a_parse_long(client);
#line 1774
  client->fnc_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 1776
  client->num2 = prot_a_parse_long(client);
  }
  switch_default: /* CIL Label */ 
#line 1778
  client->fnc_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 1780
  return;
}
}
#line 26 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/version-info.h"
struct __anonstruct_Version_info_internal_73  const  kom_version_info ;
#line 11 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/version-info.c"
struct __anonstruct_Version_info_internal_73  const  kom_version_info  =    {11UL, "lyskomd", "2.1.2"};
#line 803 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 29 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/lockdb.h"
int lock_db(void) ;
#line 32
void unlock_db(void) ;
#line 54 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/lockdb.c"
int lock_db(void) 
{ 
  char new_lock[67UL + 3UL * sizeof(pid_t )] ;
  char current_lock[68UL + 3UL * sizeof(pid_t )] ;
  char *end ;
  int retry ;
  size_t sz ;
  size_t ix ;
  pid_t pid ;
  int *tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  ssize_t tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 65
  tmp___0 = gethostname(new_lock, (size_t )64);
  }
#line 65
  if (tmp___0 == -1) {
    {
#line 66
    tmp = __errno_location();
#line 66
    restart_kom("gethostname failed (%d)\n", *tmp);
    }
  }
  {
#line 68
  new_lock[65] = (char )'\000';
#line 69
  end = strchr((char const   *)(new_lock), '\000');
#line 70
  tmp___1 = getpid();
#line 70
  sprintf((char */* __restrict  */)end, (char const   */* __restrict  */)":%ld", (long )tmp___1);
#line 72
  retry = 0;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! (retry < 2)) {
#line 72
      goto while_break;
    }
    {
#line 74
    tmp___2 = symlink((char const   *)(new_lock), (char const   *)param.lockfile_name);
    }
#line 74
    if (tmp___2 == 0) {
      {
#line 76
      kom_log("Created lock %s\n", param.lockfile_name);
      }
#line 77
      return (0);
    }
    {
#line 80
    tmp___4 = __errno_location();
    }
#line 80
    if (*tmp___4 != 17) {
      {
#line 81
      tmp___3 = __errno_location();
#line 81
      restart_kom("Failed to create lock symlink %s pointing to %s: %d\n", param.lockfile_name,
                  new_lock, *tmp___3);
      }
    }
#line 85
    if (retry) {
      {
#line 87
      kom_log("Lock file recreated by some other party\n");
      }
#line 88
      return (-1);
    }
    {
#line 91
    tmp___5 = readlink((char const   */* __restrict  */)param.lockfile_name, (char */* __restrict  */)(current_lock),
                       sizeof(current_lock));
#line 91
    sz = (size_t )tmp___5;
    }
#line 92
    if (sz >= sizeof(current_lock) - 1UL) {
      {
#line 93
      restart_kom("Too much data in lock symlink %s\n", param.lockfile_name);
      }
    }
#line 95
    current_lock[sz] = (char )'\000';
#line 97
    ix = (size_t )0;
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      if (! (ix < sizeof(new_lock))) {
#line 97
        goto while_break___0;
      }
#line 99
      if ((int )new_lock[ix] != (int )current_lock[ix]) {
        {
#line 101
        kom_log("Database already locked by %s\n", current_lock);
        }
#line 102
        return (-1);
      }
#line 105
      if ((int )new_lock[ix] == 58) {
#line 106
        goto while_break___0;
      }
#line 97
      ix ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 109
    tmp___6 = strtol((char const   */* __restrict  */)(& current_lock[ix + 1UL]),
                     (char **/* __restrict  */)(& end), 10);
#line 109
    pid = (pid_t )tmp___6;
    }
#line 110
    if ((unsigned long )end == (unsigned long )(& current_lock[ix + 1UL])) {
      {
#line 111
      restart_kom("Found a broken lock symlink %s: %s\n", param.lockfile_name, current_lock);
      }
    }
    {
#line 114
    tmp___7 = kill(pid, 0);
    }
#line 114
    if (tmp___7 == 0) {
      {
#line 116
      kom_log("Database already locked by %s\n", current_lock);
      }
#line 117
      return (-1);
    } else {
      {
#line 114
      tmp___8 = __errno_location();
      }
#line 114
      if (*tmp___8 != 3) {
        {
#line 116
        kom_log("Database already locked by %s\n", current_lock);
        }
#line 117
        return (-1);
      }
    }
    {
#line 122
    tmp___9 = remove((char const   *)param.lockfile_name);
    }
#line 122
    if (tmp___9 < 0) {
      {
#line 122
      tmp___10 = __errno_location();
      }
#line 122
      if (*tmp___10 != 2) {
        {
#line 123
        restart_kom("Failed to remove stale lock symlink %s\n", param.lockfile_name);
        }
      } else {
        {
#line 126
        kom_log("Removed stale lock file left by %s.\n", current_lock);
        }
      }
    } else {
      {
#line 126
      kom_log("Removed stale lock file left by %s.\n", current_lock);
      }
    }
#line 72
    retry ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  restart_kom("Unreachable code reached in lock_db.\n");
  }
}
}
#line 131 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/lockdb.c"
void unlock_db(void) 
{ 
  int tmp ;

  {
  {
#line 134
  tmp = remove((char const   *)param.lockfile_name);
  }
#line 134
  if (tmp < 0) {
    {
#line 135
    restart_kom("Failed to remove lock file %s\n", param.lockfile_name);
    }
  }
#line 136
  return;
}
}
#line 55 "./../libraries/libmisc/s-collat-tabs.h"
extern unsigned char swedish_collate_tab[256] ;
#line 181 "./../libraries/libmisc/s-string.h"
extern String s_fcrea_str(char const   *c_string ) ;
#line 306
extern int s_usr_strcmp(String str1 , String str2 , unsigned char *collat_tab ) ;
#line 54 "./../include/services.h"
extern Success logout(void) ;
#line 63
extern Success change_name(Conf_no conf_no , String const   new_name ) ;
#line 252
Conf_no create_conf_old(String const   name___0 , Conf_type type ) ;
#line 256
Conf_no create_conf(String const   name___0 , Conf_type type , Aux_item_list *aux ) ;
#line 261
extern Success modify_conf_info(Conf_no conf_no , Number_list *items_to_delete , Aux_item_list *aux ) ;
#line 268
extern Success delete_conf(Conf_no conf_no ) ;
#line 277
extern Success lookup_name(String const   name___0 , Conf_list_old *result ) ;
#line 281
extern Success lookup_z_name(String const   name___0 , int want_persons , int want_confs ,
                             Conf_z_info_list *result ) ;
#line 288
extern Success lookup_person(String const   pattern , Conf_no_list *result ) ;
#line 292
extern Success lookup_conf(String const   pattern , Conf_no_list *result ) ;
#line 314
extern Success get_conf_stat_older(Conf_no conf_no , int mask , Conference *result ) ;
#line 319
extern Success get_conf_stat_old(Conf_no conf_no , Conference *result ) ;
#line 323
extern Success get_conf_stat(Conf_no conf_no , Conference *result ) ;
#line 327
extern Success get_uconf_stat(Conf_no conf_no , Small_conf *result ) ;
#line 392
extern Success set_presentation(Conf_no conf_no , Text_no text_no ) ;
#line 396
extern Success set_etc_motd(Conf_no conf_no , Text_no text_no ) ;
#line 401
extern Success set_supervisor(Conf_no conf_no , Conf_no new_super ) ;
#line 405
extern Success set_permitted_submitters(Conf_no conf_no , Conf_no new_perm_sub ) ;
#line 409
extern Success set_super_conf(Conf_no conf_no , Conf_no new_super_conf ) ;
#line 413
extern Success set_conf_type(Conf_no conf_no , Conf_type type ) ;
#line 416
extern Success set_garb_nice(Conf_no conf_no , Garb_nice nice ) ;
#line 420
extern Success set_expire(Conf_no conf_no , Garb_nice expire ) ;
#line 425
extern Success set_keep_commented(Conf_no conf_no , Garb_nice keep_commented ) ;
#line 429
Success first_unused_conf_no(Conf_no *result ) ;
#line 436
Success find_next_conf_no(Conf_no start , Conf_no *result ) ;
#line 439
extern Success find_previous_conf_no(Conf_no start , Conf_no *result ) ;
#line 29 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache.h"
struct matching_info *match_table ;
#line 89
extern Small_conf *cached_get_small_conf_stat(Conf_no conf_no ) ;
#line 108
Conf_no query_next_conf_no(void) ;
#line 115
void cached_change_name(Conf_no name_num , String new_name ) ;
#line 118
Bool cached_conf_exists(Conf_no conf_no ) ;
#line 126
extern Conf_no cached_get_conf_supervisor(Conf_no conf_no ) ;
#line 135
extern String cached_get_name(Conf_no conf_no ) ;
#line 141
extern Success cached_lookup_name(String const   name___0 , Conf_list_old *result ) ;
#line 308 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/manipulate.h"
Bool is_strictly_supervisor(Conf_no conf , Pers_no viewer , Person const   *viewer_p ) ;
#line 328
Success do_set_presentation(Conf_no conf_no , Conference *conf_c , Text_no new_text_no ) ;
#line 339
Success do_set_etc_motd(Conf_no conf_no , Conference *conf_c , Text_no new_text_no ) ;
#line 100 "./../libraries/libcommon/parser.h"
extern Parse_token *tokenize(String const   source , String const   separators ) ;
#line 119
extern void free_tokens(Parse_token *token_list ) ;
#line 165
extern Parse_info parse(String source_string , Matching_info *match_tbl , Bool allow_trailing_words ,
                        Bool number_of_words_must_match , String separators , unsigned char *collat_tab ) ;
#line 78 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
static void do_delete_conf(Conf_no conf_no , Conference *conf_c ) 
{ 
  int i ;
  Success tmp ;
  Success tmp___0 ;

  {
  {
#line 84
  tmp = do_set_presentation(conf_no, conf_c, (Text_no )0);
  }
#line 84
  if ((unsigned long )tmp != (unsigned long )OK) {
    {
#line 86
    kom_log("ERROR: do_delete_conf() - couldn\'t unmark presentation.\n");
    }
  }
  {
#line 89
  tmp___0 = do_set_etc_motd(conf_no, conf_c, (Text_no )0);
  }
#line 89
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 91
    kom_log("ERROR: do_delete_conf() - couldn\'t unmark motd.\n");
    }
  }
#line 97
  i = (int )conf_c->members.no_of_members - 1;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i >= 0)) {
#line 97
      goto while_break;
    }
    {
#line 99
    do_sub_member(conf_no, conf_c, conf_c->members.members + i, (conf_c->members.members + i)->member,
                  (Person *)((void *)0), (Membership *)((void *)0));
#line 97
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  sfree((void *)conf_c->members.members);
#line 104
  conf_c->members.members = (Member *)((void *)0);
#line 122
  cached_delete_conf(conf_no);
#line 123
  update_stat((enum stat_type )6, -1L);
  }
#line 125
  return;
}
}
#line 132 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
void set_conf_errno(Connection const   *viewer_conn , Conf_no conf_no , enum kom_err errcode ) 
{ 
  Bool tmp ;

  {
  {
#line 137
  err_stat = (unsigned long )conf_no;
#line 138
  tmp = has_access(conf_no, viewer_conn, (enum access )2);
  }
#line 138
  if (tmp) {
#line 141
    kom_errno = errcode;
  } else {
#line 139
    kom_errno = (enum kom_err )9;
  }
#line 142
  return;
}
}
#line 150 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
Bool legal_name(String name___0 ) 
{ 
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  String_size tmp___3 ;

  {
#line 153
  if (name___0.len == 0L) {
#line 153
    goto _L;
  } else
#line 153
  if (name___0.len > (String_size )param.conf_name_len) {
    _L: /* CIL Label */ 
#line 155
    if (name___0.len) {
#line 155
      err_stat = (unsigned long )param.conf_name_len;
    } else {
#line 155
      err_stat = 0UL;
    }
#line 156
    if (name___0.len) {
#line 156
      kom_errno = (enum kom_err )5;
    } else {
#line 156
      kom_errno = (enum kom_err )18;
    }
#line 157
    return ((Bool )0);
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    tmp___3 = name___0.len;
#line 160
    (name___0.len) --;
#line 160
    if (! tmp___3) {
#line 160
      goto while_break;
    }
#line 163
    if (param.force_iso_8859_1) {
#line 163
      if ((int )*(name___0.string) < 32) {
#line 163
        tmp = 1;
      } else
#line 163
      if ((int )*(name___0.string) > 126) {
#line 163
        if ((int )*(name___0.string) < 160) {
#line 163
          tmp = 1;
        } else {
#line 163
          tmp = 0;
        }
      } else {
#line 163
        tmp = 0;
      }
#line 163
      tmp___2 = tmp;
    } else {
      {
#line 163
      tmp___0 = __ctype_b_loc();
      }
#line 163
      if ((int const   )*(*tmp___0 + (int )*(name___0.string)) & 16384) {
#line 163
        tmp___1 = 0;
      } else {
#line 163
        tmp___1 = 1;
      }
#line 163
      tmp___2 = tmp___1;
    }
#line 163
    if (tmp___2) {
#line 168
      err_stat = 0UL;
#line 169
      kom_errno = (enum kom_err )18;
#line 170
      return ((Bool )0);
    }
#line 181
    (name___0.string) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return ((Bool )1);
}
}
#line 191 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
Bool unique_name(String const   name___0 , Conf_no conf_no ) 
{ 
  Parse_info parse_info ;
  Parse_token *name_token ;
  Parse_token *existing_token ;
  Bool exact_match_found ;
  Bool diff_found ;
  int i ;
  int n ;
  String tmp ;
  String tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 202
  tmp = s_fcrea_str(WHITESPACE);
#line 202
  parse_info = parse((String )name___0, match_table, (Bool )0, (Bool )1, tmp, (unsigned char *)(swedish_collate_tab));
  }
#line 206
  if (parse_info.no_of_matches == 0) {
    {
#line 208
    sfree((void *)parse_info.indexes);
    }
#line 209
    return ((Bool )1);
  }
#line 212
  if (parse_info.no_of_matches == -1) {
    {
#line 214
    kom_log("unique_name(): parse returned error.\n");
#line 215
    sfree((void *)parse_info.indexes);
    }
#line 216
    return ((Bool )0);
  }
#line 219
  if (parse_info.no_of_matches == 1) {
#line 219
    if (*(parse_info.indexes + 0) == -1) {
      {
#line 222
      sfree((void *)parse_info.indexes);
      }
#line 223
      return ((Bool )0);
    }
  }
  {
#line 228
  tmp___0 = s_fcrea_str(WHITESPACE);
#line 228
  name_token = tokenize(name___0, (String const   )tmp___0);
#line 230
  exact_match_found = (Bool )0;
#line 232
  i = 0;
  }
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! exact_match_found) {
#line 232
      if (! (i < parse_info.no_of_matches)) {
#line 232
        goto while_break;
      }
    } else {
#line 232
      goto while_break;
    }
#line 234
    existing_token = (match_table + *(parse_info.indexes + i))->tokens;
#line 235
    diff_found = (Bool )0;
#line 237
    n = 0;
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (! diff_found) {
#line 237
        if ((existing_token + n)->word.len == 0L) {
#line 237
          tmp___2 = 1;
        } else {
#line 237
          tmp___2 = 0;
        }
#line 237
        if (tmp___2) {
#line 237
          goto while_break___0;
        } else {
#line 237
          if ((name_token + n)->word.len == 0L) {
#line 237
            tmp___3 = 1;
          } else {
#line 237
            tmp___3 = 0;
          }
#line 237
          if (tmp___3) {
#line 237
            goto while_break___0;
          }
        }
      } else {
#line 237
        goto while_break___0;
      }
      {
#line 242
      tmp___1 = s_usr_strcmp((existing_token + n)->word, (name_token + n)->word, (unsigned char *)(swedish_collate_tab));
      }
#line 242
      if (! (tmp___1 == 0)) {
#line 246
        diff_found = (Bool )1;
      }
#line 237
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 250
    if ((existing_token + n)->word.len == 0L) {
#line 250
      tmp___4 = 1;
    } else {
#line 250
      tmp___4 = 0;
    }
#line 250
    if (tmp___4) {
#line 250
      if ((name_token + n)->word.len == 0L) {
#line 250
        tmp___5 = 1;
      } else {
#line 250
        tmp___5 = 0;
      }
#line 250
      if (! tmp___5) {
#line 254
        diff_found = (Bool )1;
      }
    } else {
#line 254
      diff_found = (Bool )1;
    }
#line 257
    if (! diff_found) {
#line 257
      if ((int )(match_table + *(parse_info.indexes + i))->conf_no != (int )conf_no) {
#line 258
        exact_match_found = (Bool )1;
      }
    }
#line 232
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  sfree((void *)parse_info.indexes);
#line 262
  free_tokens(name_token);
  }
#line 263
  if (exact_match_found) {
#line 263
    tmp___6 = 0;
  } else {
#line 263
    tmp___6 = 1;
  }
#line 263
  return ((Bool )tmp___6);
}
}
#line 269 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
static Conf_no do_create_conf(String name___0 , Pers_no creator , Conf_no supervisor ,
                              Conf_no super_conf , Conf_type type , Connection *creating_connection ,
                              Aux_item_list *aux ) 
{ 
  Conf_no conf_no ;
  Conference *conf_c ;
  Success tmp ;

  {
  {
#line 285
  conf_no = cached_create_conf(name___0);
  }
#line 286
  if ((int )conf_no == 0) {
    {
#line 289
    kom_log("ERROR: Couldn\'t create conference. Too many conferences.\n");
    }
#line 290
    return ((Conf_no )0);
  }
  {
#line 293
  conf_c = cached_get_conf_stat(conf_no);
  }
#line 293
  if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
    {
#line 295
    restart_kom("create_conf() - can\'t get conf_stat\n");
    }
  }
  {
#line 298
  conf_c->creator = creator;
#line 299
  conf_c->creation_time = current_time.tv_sec;
#line 300
  conf_c->presentation = (Text_no )0;
#line 301
  conf_c->supervisor = supervisor;
#line 302
  conf_c->permitted_submitters = (Conf_no )0;
#line 303
  conf_c->super_conf = super_conf;
#line 304
  conf_c->type = type;
#line 305
  conf_c->last_written = conf_c->creation_time;
#line 306
  conf_c->msg_of_day = (Text_no )0;
#line 307
  conf_c->nice = (Garb_nice )param.default_nice;
#line 308
  conf_c->keep_commented = (Garb_nice )param.default_keep_commented;
#line 309
  conf_c->highest_aux = 0UL;
#line 310
  conf_c->expire = (Garb_nice )0;
#line 314
  mark_conference_as_changed(conf_no);
#line 316
  prepare_aux_item_list(aux, creator);
#line 317
  tmp = conf_stat_check_add_aux_item_list(conf_c, conf_no, aux, creating_connection,
                                          (Bool )1);
  }
#line 317
  if ((unsigned long )tmp != (unsigned long )OK) {
    {
#line 328
    cached_delete_conf(conf_no);
    }
#line 329
    return ((Conf_no )0);
  }
  {
#line 332
  conf_stat_add_aux_item_list(conf_c, conf_no, aux, creator);
#line 334
  mark_conference_as_changed(conf_no);
#line 335
  update_stat((enum stat_type )6, 1L);
  }
#line 337
  return (conf_no);
}
}
#line 345 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
Bool is_supervisor(Conf_no conf , Connection const   *viewer ) 
{ 
  Bool tmp ;

  {
#line 349
  if ((int const   )viewer->pers_no == 0) {
#line 350
    return ((Bool )0);
  }
#line 353
  if ((int const   )viewer->pers_no == (int const   )conf) {
#line 354
    return ((Bool )1);
  }
  {
#line 356
  tmp = is_strictly_supervisor(conf, (Pers_no )viewer->pers_no, (Person const   *)viewer->person);
  }
#line 356
  return (tmp);
}
}
#line 360 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
Bool is_strictly_supervisor(Conf_no conf , Pers_no viewer , Person const   *viewer_p ) 
{ 
  Conf_no supervisor ;
  Bool tmp ;
  Person *tmp___0 ;
  Membership *tmp___1 ;

  {
#line 367
  if ((int )viewer == 0) {
#line 368
    return ((Bool )0);
  }
  {
#line 370
  tmp = cached_conf_exists(conf);
  }
#line 370
  if (! tmp) {
#line 371
    return ((Bool )0);
  }
  {
#line 373
  supervisor = cached_get_conf_supervisor(conf);
  }
#line 373
  if ((int )supervisor == 0) {
#line 374
    return ((Bool )0);
  }
#line 376
  if ((int )viewer == (int )supervisor) {
#line 377
    return ((Bool )1);
  }
#line 379
  if ((unsigned long )viewer_p == (unsigned long )((void *)0)) {
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 380
      tmp___0 = cached_get_person_stat(viewer);
#line 380
      viewer_p = (Person const   *)tmp___0;
      }
#line 380
      if ((unsigned long )viewer_p == (unsigned long )((void *)0)) {
#line 380
        return ((Bool )0);
      }
#line 380
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 382
  tmp___1 = locate_membership(supervisor, viewer_p);
  }
#line 382
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 383
    return ((Bool )1);
  }
#line 385
  return ((Bool )0);
}
}
#line 397 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success change_name(Conf_no conf_no , String const   new_name ) 
{ 
  Conference *conf_c ;
  enum access acc ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 404
      err_stat = 0UL;
#line 404
      kom_errno = (enum kom_err )51;
#line 404
      return ((Success )FAILURE);
    }
#line 404
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 405
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 405
    if (! active_connection) {
#line 405
      err_stat = 0UL;
#line 405
      kom_errno = (enum kom_err )6;
#line 405
      return ((Success )FAILURE);
    } else
#line 405
    if (! active_connection->pers_no) {
#line 405
      err_stat = 0UL;
#line 405
      kom_errno = (enum kom_err )6;
#line 405
      return ((Success )FAILURE);
    }
#line 405
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 406
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 406
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 406
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 406
      return ((Success )FAILURE);
    }
#line 406
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 408
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )5);
  }
#line 410
  if ((unsigned int )acc <= 1U) {
#line 412
    err_stat = (unsigned long )conf_no;
#line 413
    kom_errno = (enum kom_err )9;
#line 414
    return ((Success )FAILURE);
  }
#line 417
  if (! (active_connection->person)->privileges.change_name) {
#line 420
    err_stat = (unsigned long )conf_no;
#line 421
    kom_errno = (enum kom_err )12;
#line 422
    return ((Success )FAILURE);
  } else
#line 417
  if ((unsigned int )acc != 5U) {
#line 417
    if (active_connection) {
#line 417
      if ((int )active_connection->ena_level >= 3) {
#line 417
        if (! (active_connection->person)->privileges.admin) {
#line 420
          err_stat = (unsigned long )conf_no;
#line 421
          kom_errno = (enum kom_err )12;
#line 422
          return ((Success )FAILURE);
        }
      } else {
#line 420
        err_stat = (unsigned long )conf_no;
#line 421
        kom_errno = (enum kom_err )12;
#line 422
        return ((Success )FAILURE);
      }
    } else {
#line 420
      err_stat = (unsigned long )conf_no;
#line 421
      kom_errno = (enum kom_err )12;
#line 422
      return ((Success )FAILURE);
    }
  }
  {
#line 425
  tmp = legal_name((String )new_name);
  }
#line 425
  if (! tmp) {
#line 428
    return ((Success )FAILURE);
  }
  {
#line 431
  tmp___0 = unique_name(new_name, conf_no);
  }
#line 431
  if (! tmp___0) {
#line 433
    err_stat = 0UL;
#line 434
    kom_errno = (enum kom_err )20;
#line 435
    return ((Success )FAILURE);
  }
  {
#line 438
  async_new_name(conf_no, (String const   )conf_c->name, new_name);
#line 440
  s_strcpy(& conf_c->name, new_name);
#line 441
  mark_conference_as_changed(conf_no);
#line 443
  cached_change_name(conf_no, (String )new_name);
  }
#line 445
  return ((Success )OK);
}
}
#line 462 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
static Conf_no create_conf_generic(String const   name___0 , Conf_type type , Aux_item_list *aux ) 
{ 
  Conf_no conf_no ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 469
      err_stat = 0UL;
#line 469
      kom_errno = (enum kom_err )51;
#line 469
      return ((Conf_no )0);
    }
#line 469
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 470
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 470
    if (! active_connection) {
#line 470
      err_stat = 0UL;
#line 470
      kom_errno = (enum kom_err )6;
#line 470
      return ((Conf_no )0);
    } else
#line 470
    if (! active_connection->pers_no) {
#line 470
      err_stat = 0UL;
#line 470
      kom_errno = (enum kom_err )6;
#line 470
      return ((Conf_no )0);
    }
#line 470
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 472
  if ((unsigned int )param.anyone_can_create_new_confs == 0U) {
#line 472
    if (active_connection->person) {
#line 472
      if (! (active_connection->person)->privileges.create_conf) {
#line 475
        err_stat = 0UL;
#line 476
        kom_errno = (enum kom_err )12;
#line 477
        return ((Conf_no )0);
      }
    } else {
#line 475
      err_stat = 0UL;
#line 476
      kom_errno = (enum kom_err )12;
#line 477
      return ((Conf_no )0);
    }
  }
  {
#line 480
  tmp = legal_name((String )name___0);
  }
#line 480
  if (! tmp) {
#line 483
    return ((Conf_no )0);
  }
  {
#line 486
  tmp___0 = unique_name(name___0, (Conf_no )0);
  }
#line 486
  if (! tmp___0) {
#line 488
    err_stat = 0UL;
#line 489
    kom_errno = (enum kom_err )20;
#line 490
    return ((Conf_no )0);
  }
#line 493
  if (type.letter_box) {
#line 495
    kom_errno = (enum kom_err )12;
#line 496
    return ((Conf_no )0);
  }
#line 499
  if (type.secret) {
#line 499
    if (! type.rd_prot) {
#line 501
      err_stat = 0UL;
#line 502
      kom_errno = (enum kom_err )22;
#line 503
      return ((Conf_no )0);
    }
  }
  {
#line 506
  conf_no = do_create_conf((String )name___0, active_connection->pers_no, active_connection->pers_no,
                           active_connection->pers_no, type, active_connection, aux);
  }
#line 509
  if ((int )conf_no != 0) {
    {
#line 511
    (active_connection->person)->created_confs = (unsigned short )((int )(active_connection->person)->created_confs + 1);
#line 512
    mark_person_as_changed(active_connection->pers_no);
    }
  }
#line 515
  return (conf_no);
}
}
#line 518 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
Conf_no create_conf_old(String const   name___0 , Conf_type type ) 
{ 
  Conf_no tmp ;

  {
  {
#line 523
  tmp = create_conf_generic(name___0, type, (Aux_item_list *)((void *)0));
  }
#line 523
  return (tmp);
}
}
#line 526 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
Conf_no create_conf(String const   name___0 , Conf_type type , Aux_item_list *aux ) 
{ 
  Conf_no conf ;

  {
  {
#line 534
  conf = create_conf_generic(name___0, type, aux);
  }
#line 540
  return (conf);
}
}
#line 548 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
static void logout_person(Pers_no pers_no ) 
{ 
  Session_no i ;
  Connection *real_active_connection ;

  {
#line 551
  i = (Session_no )0;
#line 554
  real_active_connection = active_connection;
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 556
    i = traverse_connections(i);
    }
#line 556
    if (! (i != 0UL)) {
#line 556
      goto while_break;
    }
    {
#line 558
    active_connection = get_conn_by_number(i);
    }
#line 560
    if ((int )active_connection->pers_no == (int )pers_no) {
      {
#line 561
      logout();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  active_connection = real_active_connection;
#line 565
  return;
}
}
#line 571 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success delete_conf(Conf_no conf_no ) 
{ 
  Conference *conf_c ;
  enum access acc ;
  Success tmp ;

  {
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 577
      err_stat = 0UL;
#line 577
      kom_errno = (enum kom_err )51;
#line 577
      return ((Success )FAILURE);
    }
#line 577
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 578
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 578
    if (! active_connection) {
#line 578
      err_stat = 0UL;
#line 578
      kom_errno = (enum kom_err )6;
#line 578
      return ((Success )FAILURE);
    } else
#line 578
    if (! active_connection->pers_no) {
#line 578
      err_stat = 0UL;
#line 578
      kom_errno = (enum kom_err )6;
#line 578
      return ((Success )FAILURE);
    }
#line 578
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 579
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 579
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 579
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 579
      return ((Success )FAILURE);
    }
#line 579
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 581
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )5);
  }
#line 583
  if ((unsigned int )acc != 5U) {
#line 585
    err_stat = (unsigned long )conf_no;
#line 586
    if ((unsigned int )acc <= 1U) {
#line 586
      kom_errno = (enum kom_err )9;
    } else {
#line 586
      kom_errno = (enum kom_err )12;
    }
#line 587
    return ((Success )FAILURE);
  }
#line 590
  if (conf_c->type.letter_box) {
    {
#line 594
    logout_person(conf_no);
#line 596
    tmp = do_delete_pers(conf_no);
    }
#line 596
    if ((unsigned long )tmp != (unsigned long )OK) {
      {
#line 598
      kom_log("ERROR: delete_conf(): can\'t delete person.\n");
      }
    }
  }
  {
#line 602
  do_delete_conf(conf_no, conf_c);
  }
#line 604
  return ((Success )OK);
}
}
#line 612 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success lookup_name(String const   name___0 , Conf_list_old *result ) 
{ 
  Conf_no *no ;
  Conf_no *no_copy ;
  Conf_type *type ;
  Conf_type *type_copy ;
  int i ;
  Success tmp ;
  Conf_no *tmp___0 ;
  Conf_type *tmp___1 ;
  Bool tmp___2 ;

  {
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 620
      err_stat = 0UL;
#line 620
      kom_errno = (enum kom_err )51;
#line 620
      return ((Success )FAILURE);
    }
#line 620
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 621
  tmp = cached_lookup_name(name___0, result);
  }
#line 621
  if ((unsigned long )tmp != (unsigned long )OK) {
#line 622
    return ((Success )FAILURE);
  }
#line 624
  no_copy = result->conf_nos;
#line 624
  no = no_copy;
#line 625
  type_copy = result->type_of_conf;
#line 625
  type = type_copy;
#line 627
  i = (int )result->no_of_conf_nos;
  {
#line 627
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 627
    if (! (i > 0)) {
#line 627
      goto while_break___0;
    }
    {
#line 629
    tmp___2 = has_access(*no, (Connection const   *)active_connection, (enum access )2);
    }
#line 629
    if (tmp___2) {
#line 633
      tmp___0 = no_copy;
#line 633
      no_copy ++;
#line 633
      *tmp___0 = *no;
#line 634
      tmp___1 = type_copy;
#line 634
      type_copy ++;
#line 634
      *tmp___1 = *type;
    } else {
#line 630
      (result->no_of_conf_nos) --;
    }
#line 637
    no ++;
#line 638
    type ++;
#line 627
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 640
  return ((Success )OK);
}
}
#line 643 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success lookup_z_name(String const   name___0 , int want_persons , int want_confs ,
                             Conf_z_info_list *result ) 
{ 
  Conf_no *no ;
  Conf_type *type ;
  Conf_z_info *res ;
  int i ;
  int n_filtered ;
  Conf_list_old raw_matches ;
  Success tmp ;
  int tmp___0 ;
  Bool tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 656
      err_stat = 0UL;
#line 656
      kom_errno = (enum kom_err )51;
#line 656
      return ((Success )FAILURE);
    }
#line 656
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 657
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 657
    if (want_persons != 0) {
#line 657
      if (want_persons != 1) {
#line 657
        err_stat = 0UL;
#line 657
        kom_errno = (enum kom_err )61;
#line 657
        return ((Success )FAILURE);
      }
    }
#line 657
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 658
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 658
    if (want_confs != 0) {
#line 658
      if (want_confs != 1) {
#line 658
        err_stat = 0UL;
#line 658
        kom_errno = (enum kom_err )61;
#line 658
        return ((Success )FAILURE);
      }
    }
#line 658
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 659
  tmp = cached_lookup_name(name___0, & raw_matches);
  }
#line 659
  if ((unsigned long )tmp != (unsigned long )OK) {
#line 660
    return ((Success )FAILURE);
  }
#line 662
  no = raw_matches.conf_nos;
#line 663
  type = raw_matches.type_of_conf;
#line 664
  n_filtered = (int )raw_matches.no_of_conf_nos;
#line 665
  i = (int )raw_matches.no_of_conf_nos;
  {
#line 665
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 665
    if (! (i > 0)) {
#line 665
      goto while_break___2;
    }
#line 667
    if ((int )*no == 0) {
      {
#line 668
      restart_kom("Internal error detected in lookup_z_name\n");
      }
    }
#line 670
    if (type->letter_box) {
#line 670
      tmp___0 = want_persons;
    } else {
#line 670
      tmp___0 = want_confs;
    }
#line 670
    if (tmp___0 == 0) {
#line 673
      *no = (Conf_no )0;
#line 674
      n_filtered --;
    } else {
      {
#line 670
      tmp___1 = has_access(*no, (Connection const   *)active_connection, (enum access )2);
      }
#line 670
      if (! tmp___1) {
#line 673
        *no = (Conf_no )0;
#line 674
        n_filtered --;
      }
    }
#line 677
    no ++;
#line 678
    type ++;
#line 665
    i --;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 681
  result->no_of_confs = (unsigned short )n_filtered;
#line 682
  tmp___2 = tmp_alloc((unsigned long )n_filtered * sizeof(Conf_z_info ));
#line 682
  result->confs = (Conf_z_info *)tmp___2;
#line 683
  no = raw_matches.conf_nos;
#line 684
  type = raw_matches.type_of_conf;
#line 685
  res = result->confs;
#line 686
  i = (int )raw_matches.no_of_conf_nos;
  }
  {
#line 686
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 686
    if (! (i > 0)) {
#line 686
      goto while_break___3;
    }
#line 688
    if ((int )*no != 0) {
      {
#line 690
      res->conf_no = *no;
#line 691
      res->type = *type;
#line 692
      res->name = cached_get_name(*no);
#line 693
      res ++;
      }
    }
#line 695
    no ++;
#line 696
    type ++;
#line 686
    i --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 699
  if ((unsigned long )res != (unsigned long )(result->confs + n_filtered)) {
    {
#line 700
    restart_kom("Internal error in lookup_z_name\n");
    }
  }
#line 702
  return ((Success )OK);
}
}
#line 705 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
static Success do_lookup(Connection *conn , String const   name___0 , Conf_no_list *result ,
                         Bool want_persons ) 
{ 
  Conf_list_old raw_match ;
  unsigned long i ;
  unsigned short retsize ;
  unsigned int letterflag ;
  Success tmp ;
  void *tmp___0 ;
  unsigned short tmp___1 ;
  Bool tmp___2 ;

  {
  {
#line 714
  letterflag = (unsigned int )want_persons;
#line 716
  tmp = cached_lookup_name(name___0, & raw_match);
  }
#line 716
  if ((unsigned long )tmp != (unsigned long )OK) {
#line 717
    return ((Success )FAILURE);
  }
#line 720
  retsize = (unsigned short)0;
#line 721
  i = 0UL;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < raw_match.no_of_conf_nos)) {
#line 721
      goto while_break;
    }
#line 725
    if ((raw_match.type_of_conf + i)->letter_box == letterflag) {
#line 727
      retsize = (unsigned short )((int )retsize + 1);
#line 732
      if ((int )retsize == 0) {
        {
#line 734
        kom_log("WNG: do_lookup: far too many matches\n");
#line 735
        retsize = (unsigned short )((int )retsize - 1);
        }
      }
    }
#line 721
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 740
  tmp___0 = tmp_alloc(sizeof(Conf_no ) * (unsigned long )retsize);
#line 740
  result->conf_nos = (Conf_no *)tmp___0;
#line 741
  result->no_of_confs = (unsigned short)0;
#line 743
  i = 0UL;
  }
  {
#line 743
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 743
    if (! (i < raw_match.no_of_conf_nos)) {
#line 743
      goto while_break___0;
    }
#line 745
    if ((raw_match.type_of_conf + i)->letter_box == letterflag) {
      {
#line 745
      tmp___2 = has_access(*(raw_match.conf_nos + i), (Connection const   *)conn,
                           (enum access )2);
      }
#line 745
      if (tmp___2) {
#line 748
        tmp___1 = result->no_of_confs;
#line 748
        result->no_of_confs = (unsigned short )((int )result->no_of_confs + 1);
#line 748
        *(result->conf_nos + tmp___1) = *(raw_match.conf_nos + i);
#line 749
        if ((int )result->no_of_confs > (int )retsize) {
          {
#line 750
          restart_kom("ERROR: conference.c: do_lookup: error.\n");
          }
        }
      }
    }
#line 743
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 754
  return ((Success )OK);
}
}
#line 757 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success lookup_person(String const   pattern , Conf_no_list *result ) 
{ 
  Success tmp ;

  {
  {
#line 761
  while (1) {
    while_continue: /* CIL Label */ ;
#line 761
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 761
      err_stat = 0UL;
#line 761
      kom_errno = (enum kom_err )51;
#line 761
      return ((Success )FAILURE);
    }
#line 761
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 762
  tmp = do_lookup(active_connection, pattern, result, (Bool )1);
  }
#line 762
  return (tmp);
}
}
#line 765 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success lookup_conf(String const   pattern , Conf_no_list *result ) 
{ 
  Success tmp ;

  {
  {
#line 769
  while (1) {
    while_continue: /* CIL Label */ ;
#line 769
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 769
      err_stat = 0UL;
#line 769
      kom_errno = (enum kom_err )51;
#line 769
      return ((Success )FAILURE);
    }
#line 769
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 770
  tmp = do_lookup(active_connection, pattern, result, (Bool )0);
  }
#line 770
  return (tmp);
}
}
#line 779 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success get_conf_stat(Conf_no conf_no , Conference *result ) 
{ 
  Aux_item_list filtered ;
  Success tmp ;

  {
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 785
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 785
      err_stat = 0UL;
#line 785
      kom_errno = (enum kom_err )51;
#line 785
      return ((Success )FAILURE);
    }
#line 785
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 786
  tmp = get_conf_stat_old(conf_no, result);
  }
#line 786
  if ((unsigned long )tmp == (unsigned long )OK) {
    {
#line 788
    filter_aux_item_list((Aux_item_list const   *)(& result->aux_item_list), & filtered,
                         (Connection const   *)active_connection);
#line 791
    result->aux_item_list = filtered;
    }
#line 792
    return ((Success )OK);
  }
#line 795
  return ((Success )FAILURE);
}
}
#line 798 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success get_conf_stat_old(Conf_no conf_no , Conference *result ) 
{ 
  Conference *conf_c ;
  enum access acc ;

  {
  {
#line 805
  while (1) {
    while_continue: /* CIL Label */ ;
#line 805
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 805
      err_stat = 0UL;
#line 805
      kom_errno = (enum kom_err )51;
#line 805
      return ((Success )FAILURE);
    }
#line 805
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 806
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 806
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 806
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 806
      return ((Success )FAILURE);
    }
#line 806
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 808
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )2);
  }
#line 810
  if ((unsigned int )acc == 0U) {
#line 811
    return ((Success )FAILURE);
  }
#line 813
  if ((unsigned int )acc <= 1U) {
#line 815
    err_stat = (unsigned long )conf_no;
#line 816
    kom_errno = (enum kom_err )9;
#line 817
    return ((Success )FAILURE);
  }
#line 820
  *result = *conf_c;
#line 822
  return ((Success )OK);
}
}
#line 829 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success get_uconf_stat(Conf_no conf_no , Small_conf *result ) 
{ 
  enum access acc ;
  Small_conf *conf_c ;

  {
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 836
      err_stat = 0UL;
#line 836
      kom_errno = (enum kom_err )51;
#line 836
      return ((Success )FAILURE);
    }
#line 836
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 837
  conf_c = cached_get_small_conf_stat(conf_no);
  }
#line 838
  if ((unsigned long )conf_c != (unsigned long )((void *)0)) {
    {
#line 839
    acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )2);
    }
  } else {
#line 841
    acc = (enum access )0;
  }
  {
#line 845
  if ((unsigned int )acc == 0U) {
#line 845
    goto case_0;
  }
#line 847
  if ((unsigned int )acc == 1U) {
#line 847
    goto case_1;
  }
#line 851
  goto switch_default;
  case_0: /* CIL Label */ 
#line 846
  return ((Success )FAILURE);
  case_1: /* CIL Label */ 
#line 848
  err_stat = (unsigned long )conf_no;
#line 849
  kom_errno = (enum kom_err )9;
#line 850
  return ((Success )FAILURE);
  switch_default: /* CIL Label */ 
#line 852
  *result = *conf_c;
#line 853
  return ((Success )OK);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 857 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success get_conf_stat_older(Conf_no conf_no , int mask , Conference *result ) 
{ 
  Conference *conf_c ;
  enum access acc ;

  {
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 865
      err_stat = 0UL;
#line 865
      kom_errno = (enum kom_err )51;
#line 865
      return ((Success )FAILURE);
    }
#line 865
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 866
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 866
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 866
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 866
      return ((Success )FAILURE);
    }
#line 866
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 868
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )2);
  }
#line 870
  if ((unsigned int )acc == 0U) {
#line 871
    return ((Success )FAILURE);
  }
#line 873
  if ((unsigned int )acc <= 1U) {
#line 875
    err_stat = (unsigned long )conf_no;
#line 876
    kom_errno = (enum kom_err )9;
#line 877
    return ((Success )FAILURE);
  }
#line 880
  *result = *conf_c;
#line 882
  if (! (mask & 1)) {
#line 883
    result->name = (String )EMPTY_STRING;
  }
#line 885
  return ((Success )OK);
}
}
#line 898 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success set_presentation(Conf_no conf_no , Text_no text_no ) 
{ 
  Conference *conf_c ;
  enum access acc ;
  Success tmp ;

  {
  {
#line 905
  while (1) {
    while_continue: /* CIL Label */ ;
#line 905
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 905
      err_stat = 0UL;
#line 905
      kom_errno = (enum kom_err )51;
#line 905
      return ((Success )FAILURE);
    }
#line 905
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 906
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 906
    if (! active_connection) {
#line 906
      err_stat = 0UL;
#line 906
      kom_errno = (enum kom_err )6;
#line 906
      return ((Success )FAILURE);
    } else
#line 906
    if (! active_connection->pers_no) {
#line 906
      err_stat = 0UL;
#line 906
      kom_errno = (enum kom_err )6;
#line 906
      return ((Success )FAILURE);
    }
#line 906
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 907
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 907
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 907
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 907
      return ((Success )FAILURE);
    }
#line 907
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 909
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )5);
  }
#line 911
  if ((unsigned int )acc < 5U) {
#line 913
    err_stat = (unsigned long )conf_no;
#line 914
    if ((unsigned int )acc <= 1U) {
#line 914
      kom_errno = (enum kom_err )9;
    } else {
#line 914
      kom_errno = (enum kom_err )12;
    }
#line 915
    return ((Success )FAILURE);
  }
  {
#line 918
  tmp = do_set_presentation(conf_no, conf_c, text_no);
  }
#line 918
  return (tmp);
}
}
#line 930 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success set_etc_motd(Conf_no conf_no , Text_no text_no ) 
{ 
  Conference *conf_c ;
  enum access acc ;
  Success tmp ;

  {
  {
#line 937
  while (1) {
    while_continue: /* CIL Label */ ;
#line 937
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 937
      err_stat = 0UL;
#line 937
      kom_errno = (enum kom_err )51;
#line 937
      return ((Success )FAILURE);
    }
#line 937
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 938
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 938
    if (! active_connection) {
#line 938
      err_stat = 0UL;
#line 938
      kom_errno = (enum kom_err )6;
#line 938
      return ((Success )FAILURE);
    } else
#line 938
    if (! active_connection->pers_no) {
#line 938
      err_stat = 0UL;
#line 938
      kom_errno = (enum kom_err )6;
#line 938
      return ((Success )FAILURE);
    }
#line 938
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 939
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 939
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 939
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 939
      return ((Success )FAILURE);
    }
#line 939
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 941
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )5);
  }
#line 941
  if ((unsigned int )acc < 5U) {
#line 943
    err_stat = (unsigned long )conf_no;
#line 944
    if ((unsigned int )acc <= 1U) {
#line 944
      kom_errno = (enum kom_err )9;
    } else {
#line 944
      kom_errno = (enum kom_err )12;
    }
#line 945
    if (buglevel > 0) {
      {
#line 945
      printf((char const   */* __restrict  */)"set_etc_motd failed. Conf %ld Text %ld Acc %ld < %ld (%d).\n",
             (u_long )conf_no, text_no, (u_long )acc, (u_long )5, (unsigned int )acc < 5U);
      }
    }
#line 948
    return ((Success )FAILURE);
  }
  {
#line 951
  tmp = do_set_etc_motd(conf_no, conf_c, text_no);
  }
#line 951
  return (tmp);
}
}
#line 963 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success set_supervisor(Conf_no conf_no , Conf_no new_super ) 
{ 
  Conference *conf_c ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  {
#line 969
  while (1) {
    while_continue: /* CIL Label */ ;
#line 969
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 969
      err_stat = 0UL;
#line 969
      kom_errno = (enum kom_err )51;
#line 969
      return ((Success )FAILURE);
    }
#line 969
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 970
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 970
    if (! active_connection) {
#line 970
      err_stat = 0UL;
#line 970
      kom_errno = (enum kom_err )6;
#line 970
      return ((Success )FAILURE);
    } else
#line 970
    if (! active_connection->pers_no) {
#line 970
      err_stat = 0UL;
#line 970
      kom_errno = (enum kom_err )6;
#line 970
      return ((Success )FAILURE);
    }
#line 970
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 971
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 971
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 971
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 971
      return ((Success )FAILURE);
    }
#line 971
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 972
  if ((int )new_super != 0) {
    {
#line 973
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 973
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 973
        if ((int )new_super == 0) {
#line 973
          err_stat = 0UL;
#line 973
          kom_errno = (enum kom_err )8;
#line 973
          return ((Success )FAILURE);
        }
#line 973
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 973
      tmp = cached_conf_exists(new_super);
      }
#line 973
      if (! tmp) {
#line 973
        err_stat = (unsigned long )new_super;
#line 973
        kom_errno = (enum kom_err )9;
#line 973
        return ((Success )FAILURE);
      }
#line 973
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 975
  tmp___0 = is_strictly_supervisor(conf_no, active_connection->pers_no, (Person const   *)active_connection->person);
  }
#line 975
  if (! tmp___0) {
#line 975
    if (active_connection) {
#line 975
      if ((int )active_connection->ena_level >= 8) {
#line 975
        if (! (active_connection->person)->privileges.wheel) {
#line 975
          goto _L___2;
        }
      } else {
#line 975
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 975
    if (active_connection) {
#line 975
      if ((int )active_connection->ena_level >= 6) {
#line 975
        if (! (active_connection->person)->privileges.admin) {
#line 975
          goto _L___0;
        }
      } else {
#line 975
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 979
      err_stat = (unsigned long )conf_no;
#line 980
      if (conf_c->type.secret) {
#line 980
        kom_errno = (enum kom_err )9;
      } else {
#line 980
        kom_errno = (enum kom_err )12;
      }
#line 981
      return ((Success )FAILURE);
    }
  }
  {
#line 984
  conf_c->supervisor = new_super;
#line 985
  mark_conference_as_changed(conf_no);
  }
#line 987
  return ((Success )OK);
}
}
#line 1008 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success set_permitted_submitters(Conf_no conf_no , Conf_no new_perm_sub ) 
{ 
  Conference *conf_c ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  {
#line 1014
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1014
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1014
      err_stat = 0UL;
#line 1014
      kom_errno = (enum kom_err )51;
#line 1014
      return ((Success )FAILURE);
    }
#line 1014
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1015
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1015
    if (! active_connection) {
#line 1015
      err_stat = 0UL;
#line 1015
      kom_errno = (enum kom_err )6;
#line 1015
      return ((Success )FAILURE);
    } else
#line 1015
    if (! active_connection->pers_no) {
#line 1015
      err_stat = 0UL;
#line 1015
      kom_errno = (enum kom_err )6;
#line 1015
      return ((Success )FAILURE);
    }
#line 1015
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1016
  if ((int )new_perm_sub != 0) {
    {
#line 1017
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1017
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1017
        if ((int )new_perm_sub == 0) {
#line 1017
          err_stat = 0UL;
#line 1017
          kom_errno = (enum kom_err )8;
#line 1017
          return ((Success )FAILURE);
        }
#line 1017
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1017
      tmp = cached_conf_exists(new_perm_sub);
      }
#line 1017
      if (! tmp) {
#line 1017
        err_stat = (unsigned long )new_perm_sub;
#line 1017
        kom_errno = (enum kom_err )9;
#line 1017
        return ((Success )FAILURE);
      }
#line 1017
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1018
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 1018
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 1018
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 1018
      return ((Success )FAILURE);
    }
#line 1018
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1020
  tmp___0 = is_supervisor(conf_no, (Connection const   *)active_connection);
  }
#line 1020
  if (! tmp___0) {
#line 1020
    if (active_connection) {
#line 1020
      if ((int )active_connection->ena_level >= 8) {
#line 1020
        if (! (active_connection->person)->privileges.wheel) {
#line 1020
          goto _L___2;
        }
      } else {
#line 1020
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1020
    if (active_connection) {
#line 1020
      if ((int )active_connection->ena_level >= 6) {
#line 1020
        if (! (active_connection->person)->privileges.admin) {
#line 1020
          goto _L___0;
        }
      } else {
#line 1020
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1024
      err_stat = (unsigned long )conf_no;
#line 1025
      if (conf_c->type.secret) {
#line 1025
        kom_errno = (enum kom_err )9;
      } else {
#line 1025
        kom_errno = (enum kom_err )12;
      }
#line 1026
      return ((Success )FAILURE);
    }
  }
  {
#line 1029
  conf_c->permitted_submitters = new_perm_sub;
#line 1030
  mark_conference_as_changed(conf_no);
  }
#line 1032
  return ((Success )OK);
}
}
#line 1041 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success set_super_conf(Conf_no conf_no , Conf_no new_super_conf ) 
{ 
  Conference *conf_c ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  {
#line 1047
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1047
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1047
      err_stat = 0UL;
#line 1047
      kom_errno = (enum kom_err )51;
#line 1047
      return ((Success )FAILURE);
    }
#line 1047
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1048
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1048
    if (! active_connection) {
#line 1048
      err_stat = 0UL;
#line 1048
      kom_errno = (enum kom_err )6;
#line 1048
      return ((Success )FAILURE);
    } else
#line 1048
    if (! active_connection->pers_no) {
#line 1048
      err_stat = 0UL;
#line 1048
      kom_errno = (enum kom_err )6;
#line 1048
      return ((Success )FAILURE);
    }
#line 1048
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1049
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1049
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 1049
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 1049
      return ((Success )FAILURE);
    }
#line 1049
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1050
  if ((int )new_super_conf != 0) {
    {
#line 1051
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1051
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1051
        if ((int )new_super_conf == 0) {
#line 1051
          err_stat = 0UL;
#line 1051
          kom_errno = (enum kom_err )8;
#line 1051
          return ((Success )FAILURE);
        }
#line 1051
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1051
      tmp = cached_conf_exists(new_super_conf);
      }
#line 1051
      if (! tmp) {
#line 1051
        err_stat = (unsigned long )new_super_conf;
#line 1051
        kom_errno = (enum kom_err )9;
#line 1051
        return ((Success )FAILURE);
      }
#line 1051
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 1053
  tmp___0 = is_supervisor(conf_no, (Connection const   *)active_connection);
  }
#line 1053
  if (! tmp___0) {
#line 1053
    if (active_connection) {
#line 1053
      if ((int )active_connection->ena_level >= 8) {
#line 1053
        if (! (active_connection->person)->privileges.wheel) {
#line 1053
          goto _L___2;
        }
      } else {
#line 1053
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1053
    if (active_connection) {
#line 1053
      if ((int )active_connection->ena_level >= 5) {
#line 1053
        if (! (active_connection->person)->privileges.admin) {
#line 1053
          goto _L___0;
        }
      } else {
#line 1053
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1057
      err_stat = (unsigned long )conf_no;
#line 1058
      if (conf_c->type.secret) {
#line 1058
        kom_errno = (enum kom_err )9;
      } else {
#line 1058
        kom_errno = (enum kom_err )12;
      }
#line 1059
      return ((Success )FAILURE);
    }
  }
  {
#line 1062
  conf_c->super_conf = new_super_conf;
#line 1063
  mark_conference_as_changed(conf_no);
  }
#line 1065
  return ((Success )OK);
}
}
#line 1075 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success set_conf_type(Conf_no conf_no , Conf_type type ) 
{ 
  Conference *conf_c ;
  Member *memb ;
  enum access acc ;
  unsigned long i ;

  {
  {
#line 1084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1084
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1084
      err_stat = 0UL;
#line 1084
      kom_errno = (enum kom_err )51;
#line 1084
      return ((Success )FAILURE);
    }
#line 1084
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1085
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1085
    if (! active_connection) {
#line 1085
      err_stat = 0UL;
#line 1085
      kom_errno = (enum kom_err )6;
#line 1085
      return ((Success )FAILURE);
    } else
#line 1085
    if (! active_connection->pers_no) {
#line 1085
      err_stat = 0UL;
#line 1085
      kom_errno = (enum kom_err )6;
#line 1085
      return ((Success )FAILURE);
    }
#line 1085
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1086
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1086
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 1086
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 1086
      return ((Success )FAILURE);
    }
#line 1086
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1092
  if (type.secret) {
#line 1092
    if (! type.rd_prot) {
#line 1094
      err_stat = 0UL;
#line 1095
      kom_errno = (enum kom_err )22;
#line 1096
      return ((Success )FAILURE);
    }
  }
  {
#line 1099
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )5);
  }
#line 1105
  if ((unsigned int )acc < 5U) {
#line 1107
    err_stat = (unsigned long )conf_no;
#line 1108
    if ((unsigned int )acc <= 1U) {
#line 1108
      kom_errno = (enum kom_err )9;
    } else {
#line 1108
      kom_errno = (enum kom_err )12;
    }
#line 1109
    return ((Success )FAILURE);
  }
#line 1116
  if (type.letter_box != conf_c->type.letter_box) {
#line 1118
    err_stat = (unsigned long )conf_no;
#line 1119
    kom_errno = (enum kom_err )23;
#line 1120
    return ((Success )FAILURE);
  }
#line 1129
  if (type.forbid_secret) {
#line 1129
    if (! conf_c->type.forbid_secret) {
#line 1131
      i = 0UL;
      {
#line 1131
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1131
        if (! (i < (unsigned long )conf_c->members.no_of_members)) {
#line 1131
          goto while_break___2;
        }
#line 1133
        memb = conf_c->members.members + i;
#line 1134
        if (memb->type.secret) {
#line 1136
          err_stat = (unsigned long )memb->member;
#line 1137
          kom_errno = (enum kom_err )54;
#line 1138
          return ((Success )FAILURE);
        }
#line 1131
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 1143
  conf_c->type = type;
#line 1144
  mark_conference_as_changed(conf_no);
  }
#line 1146
  return ((Success )OK);
}
}
#line 1156 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success set_garb_nice(Conf_no conf_no , Garb_nice nice ) 
{ 
  Conference *conf_c ;
  enum access acc ;

  {
  {
#line 1163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1163
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1163
      err_stat = 0UL;
#line 1163
      kom_errno = (enum kom_err )51;
#line 1163
      return ((Success )FAILURE);
    }
#line 1163
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1164
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1164
    if (! active_connection) {
#line 1164
      err_stat = 0UL;
#line 1164
      kom_errno = (enum kom_err )6;
#line 1164
      return ((Success )FAILURE);
    } else
#line 1164
    if (! active_connection->pers_no) {
#line 1164
      err_stat = 0UL;
#line 1164
      kom_errno = (enum kom_err )6;
#line 1164
      return ((Success )FAILURE);
    }
#line 1164
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1165
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1165
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 1165
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 1165
      return ((Success )FAILURE);
    }
#line 1165
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1167
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )5);
  }
#line 1169
  if ((unsigned int )acc < 5U) {
#line 1171
    err_stat = (unsigned long )conf_no;
#line 1172
    if ((unsigned int )acc <= 1U) {
#line 1172
      kom_errno = (enum kom_err )9;
    } else {
#line 1172
      kom_errno = (enum kom_err )12;
    }
#line 1173
    return ((Success )FAILURE);
  }
  {
#line 1176
  conf_c->nice = nice;
#line 1177
  mark_conference_as_changed(conf_no);
  }
#line 1179
  return ((Success )OK);
}
}
#line 1187 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success set_expire(Conf_no conf_no , Garb_nice expire ) 
{ 
  Conference *conf_c ;
  enum access acc ;

  {
  {
#line 1194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1194
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1194
      err_stat = 0UL;
#line 1194
      kom_errno = (enum kom_err )51;
#line 1194
      return ((Success )FAILURE);
    }
#line 1194
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1195
    if (! active_connection) {
#line 1195
      err_stat = 0UL;
#line 1195
      kom_errno = (enum kom_err )6;
#line 1195
      return ((Success )FAILURE);
    } else
#line 1195
    if (! active_connection->pers_no) {
#line 1195
      err_stat = 0UL;
#line 1195
      kom_errno = (enum kom_err )6;
#line 1195
      return ((Success )FAILURE);
    }
#line 1195
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1196
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1196
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 1196
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 1196
      return ((Success )FAILURE);
    }
#line 1196
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1198
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )5);
  }
#line 1200
  if ((unsigned int )acc < 5U) {
#line 1202
    err_stat = (unsigned long )conf_no;
#line 1203
    if ((unsigned int )acc <= 1U) {
#line 1203
      kom_errno = (enum kom_err )9;
    } else {
#line 1203
      kom_errno = (enum kom_err )12;
    }
#line 1204
    return ((Success )FAILURE);
  }
  {
#line 1207
  conf_c->expire = expire;
#line 1208
  mark_conference_as_changed(conf_no);
  }
#line 1210
  return ((Success )OK);
}
}
#line 1216 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success set_keep_commented(Conf_no conf_no , Garb_nice keep_commented ) 
{ 
  Conference *conf_c ;
  enum access acc ;

  {
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1223
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1223
      err_stat = 0UL;
#line 1223
      kom_errno = (enum kom_err )51;
#line 1223
      return ((Success )FAILURE);
    }
#line 1223
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1224
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1224
    if (! active_connection) {
#line 1224
      err_stat = 0UL;
#line 1224
      kom_errno = (enum kom_err )6;
#line 1224
      return ((Success )FAILURE);
    } else
#line 1224
    if (! active_connection->pers_no) {
#line 1224
      err_stat = 0UL;
#line 1224
      kom_errno = (enum kom_err )6;
#line 1224
      return ((Success )FAILURE);
    }
#line 1224
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1225
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1225
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 1225
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 1225
      return ((Success )FAILURE);
    }
#line 1225
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1227
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )5);
  }
#line 1229
  if ((unsigned int )acc < 5U) {
#line 1231
    err_stat = (unsigned long )conf_no;
#line 1232
    if ((unsigned int )acc <= 1U) {
#line 1232
      kom_errno = (enum kom_err )9;
    } else {
#line 1232
      kom_errno = (enum kom_err )12;
    }
#line 1233
    return ((Success )FAILURE);
  }
  {
#line 1236
  conf_c->keep_commented = keep_commented;
#line 1237
  mark_conference_as_changed(conf_no);
  }
#line 1239
  return ((Success )OK);
}
}
#line 1242 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
static void send_async_new_presentation(Conf_no conf_no , Text_no old_tno , Text_stat *old_stat ,
                                        Text_no new_tno , Text_stat *new_stat ) 
{ 
  Session_no i ;
  Connection *cptr ;
  Text_no used_old ;
  Text_no used_new ;
  Bool tmp ;
  Bool tmp___1 ;
  Bool tmp___3 ;

  {
#line 1249
  i = (Session_no )0;
#line 1254
  if (! param.send_async_messages) {
#line 1255
    return;
  }
  {
#line 1257
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1257
    i = traverse_connections(i);
    }
#line 1257
    if (! (i != 0UL)) {
#line 1257
      goto while_break;
    }
    {
#line 1259
    cptr = get_conn_by_number(i);
    }
#line 1263
    if ((unsigned int )cptr->want_async[20] == 0U) {
#line 1264
      goto while_continue;
    }
    {
#line 1266
    tmp = has_access(conf_no, (Connection const   *)cptr, (enum access )2);
    }
#line 1266
    if (! tmp) {
#line 1267
      goto while_continue;
    }
    {
#line 1269
    tmp___1 = text_read_access((Connection const   *)cptr, old_tno, (Text_stat const   *)old_stat);
    }
#line 1269
    if (tmp___1) {
#line 1269
      used_old = old_tno;
    } else {
#line 1269
      used_old = (Text_no )0;
    }
    {
#line 1270
    tmp___3 = text_read_access((Connection const   *)cptr, new_tno, (Text_stat const   *)new_stat);
    }
#line 1270
    if (tmp___3) {
#line 1270
      used_new = new_tno;
    } else {
#line 1270
      used_new = (Text_no )0;
    }
#line 1272
    if (used_old == used_new) {
#line 1273
      goto while_continue;
    }
    {
#line 1275
    async_new_presentation(cptr, conf_no, used_old, used_new);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1277
  return;
}
}
#line 1285 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
Success do_set_presentation(Conf_no conf_no , Conference *conf_c , Text_no new_text_no ) 
{ 
  Text_stat *old_stat ;
  Text_stat *new_stat ;
  Text_no old_text_no ;

  {
#line 1290
  old_stat = (Text_stat *)((void *)0);
#line 1291
  new_stat = (Text_stat *)((void *)0);
#line 1292
  old_text_no = (Text_no )0;
#line 1296
  if (new_text_no != 0UL) {
    {
#line 1298
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1298
      new_stat = cached_get_text_stat(new_text_no);
      }
#line 1298
      if ((unsigned long )new_stat == (unsigned long )((void *)0)) {
#line 1298
        return ((Success )FAILURE);
      }
#line 1298
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1299
    if ((int )new_stat->no_of_marks >= param.max_marks_text) {
      {
#line 1301
      kom_log("LIMIT: do_set_presentation(%d, ptr, %lu): New presentation has %d marks.\n",
              (int )conf_no, new_text_no, (int )new_stat->no_of_marks);
#line 1305
      err_stat = new_text_no;
#line 1306
      kom_errno = (enum kom_err )36;
      }
#line 1307
      return ((Success )FAILURE);
    }
  }
#line 1313
  old_text_no = conf_c->presentation;
#line 1314
  if (old_text_no != 0UL) {
    {
#line 1316
    old_stat = cached_get_text_stat(old_text_no);
    }
#line 1316
    if ((unsigned long )old_stat == (unsigned long )((void *)0)) {
      {
#line 1320
      kom_log("do_set_presentation(): Old presentation %lu of conf %lu does not exist.\n",
              old_text_no, (unsigned long )conf_no);
#line 1323
      old_text_no = (Text_no )0;
      }
    } else
#line 1325
    if ((int )old_stat->no_of_marks > 0) {
      {
#line 1327
      old_stat->no_of_marks = (unsigned short )((int )old_stat->no_of_marks - 1);
#line 1328
      mark_text_as_changed(old_text_no);
      }
    } else {
      {
#line 1332
      kom_log("ERROR: do_set_presentation(%d, ptr, %lu): Old presentation %lu not marked.\n",
              (int )conf_no, new_text_no, old_text_no);
      }
    }
  }
#line 1342
  if (new_text_no != 0UL) {
    {
#line 1344
    new_stat->no_of_marks = (unsigned short )((int )new_stat->no_of_marks + 1);
#line 1345
    mark_text_as_changed(new_text_no);
    }
  }
  {
#line 1348
  conf_c->presentation = new_text_no;
#line 1349
  mark_conference_as_changed(conf_no);
#line 1351
  send_async_new_presentation(conf_no, old_text_no, old_stat, new_text_no, new_stat);
  }
#line 1354
  return ((Success )OK);
}
}
#line 1358 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
static void send_async_new_motd(Conf_no conf_no , Text_no old_tno , Text_stat *old_stat ,
                                Text_no new_tno , Text_stat *new_stat ) 
{ 
  Session_no i ;
  Connection *cptr ;
  Text_no used_old ;
  Text_no used_new ;
  Bool tmp ;
  Bool tmp___1 ;
  Bool tmp___3 ;

  {
#line 1365
  i = (Session_no )0;
#line 1370
  if (! param.send_async_messages) {
#line 1371
    return;
  }
  {
#line 1373
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1373
    i = traverse_connections(i);
    }
#line 1373
    if (! (i != 0UL)) {
#line 1373
      goto while_break;
    }
    {
#line 1375
    cptr = get_conn_by_number(i);
    }
#line 1379
    if ((unsigned int )cptr->want_async[21] == 0U) {
#line 1380
      goto while_continue;
    }
    {
#line 1382
    tmp = has_access(conf_no, (Connection const   *)cptr, (enum access )2);
    }
#line 1382
    if (! tmp) {
#line 1383
      goto while_continue;
    }
    {
#line 1385
    tmp___1 = text_read_access((Connection const   *)cptr, old_tno, (Text_stat const   *)old_stat);
    }
#line 1385
    if (tmp___1) {
#line 1385
      used_old = old_tno;
    } else {
#line 1385
      used_old = (Text_no )0;
    }
    {
#line 1386
    tmp___3 = text_read_access((Connection const   *)cptr, new_tno, (Text_stat const   *)new_stat);
    }
#line 1386
    if (tmp___3) {
#line 1386
      used_new = new_tno;
    } else {
#line 1386
      used_new = (Text_no )0;
    }
#line 1388
    if (used_old == used_new) {
#line 1389
      goto while_continue;
    }
    {
#line 1391
    async_new_motd(cptr, conf_no, used_old, used_new);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1393
  return;
}
}
#line 1400 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
Success do_set_etc_motd(Conf_no conf_no , Conference *conf_c , Text_no new_text_no ) 
{ 
  Text_stat *old_stat ;
  Text_stat *new_stat ;
  Text_no old_text_no ;

  {
#line 1405
  old_stat = (Text_stat *)((void *)0);
#line 1406
  new_stat = (Text_stat *)((void *)0);
#line 1407
  old_text_no = (Text_no )0;
#line 1411
  if (new_text_no != 0UL) {
    {
#line 1413
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1413
      new_stat = cached_get_text_stat(new_text_no);
      }
#line 1413
      if ((unsigned long )new_stat == (unsigned long )((void *)0)) {
#line 1413
        return ((Success )FAILURE);
      }
#line 1413
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1414
    if ((int )new_stat->no_of_marks >= param.max_marks_text) {
      {
#line 1416
      kom_log("LIMIT: do_set_etc_motd(%d, ptr, %lu): New motd has %d marks.\n", (int )conf_no,
              new_text_no, (int )new_stat->no_of_marks);
#line 1420
      err_stat = new_text_no;
#line 1421
      kom_errno = (enum kom_err )36;
      }
#line 1422
      return ((Success )FAILURE);
    }
  }
#line 1428
  old_text_no = conf_c->msg_of_day;
#line 1429
  if (old_text_no != 0UL) {
    {
#line 1431
    old_stat = cached_get_text_stat(old_text_no);
    }
#line 1431
    if ((unsigned long )old_stat == (unsigned long )((void *)0)) {
      {
#line 1435
      kom_log("do_set_etc_motd(): Old motd %lu of conf %lu does not exist.\n", old_text_no,
              (unsigned long )conf_no);
#line 1438
      old_text_no = (Text_no )0;
      }
    } else
#line 1440
    if ((int )old_stat->no_of_marks > 0) {
      {
#line 1442
      old_stat->no_of_marks = (unsigned short )((int )old_stat->no_of_marks - 1);
#line 1443
      mark_text_as_changed(old_text_no);
      }
    } else {
      {
#line 1447
      kom_log("ERROR: do_set_etc_motd(%d, ptr, %lu): Old motd %lu not marked.\n",
              (int )conf_no, new_text_no, old_text_no);
      }
    }
  }
#line 1457
  if (new_text_no != 0UL) {
    {
#line 1459
    new_stat->no_of_marks = (unsigned short )((int )new_stat->no_of_marks + 1);
#line 1460
    mark_text_as_changed(new_text_no);
    }
  }
  {
#line 1463
  conf_c->msg_of_day = new_text_no;
#line 1464
  mark_conference_as_changed(conf_no);
#line 1466
  send_async_new_motd(conf_no, old_text_no, old_stat, new_text_no, new_stat);
  }
#line 1469
  return ((Success )OK);
}
}
#line 1473 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success modify_conf_info(Conf_no conf_no , Number_list *items_to_delete , Aux_item_list *aux ) 
{ 
  Conference *conf ;
  Bool tmp ;
  Success tmp___0 ;
  Success tmp___1 ;

  {
  {
#line 1480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1480
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1480
      err_stat = 0UL;
#line 1480
      kom_errno = (enum kom_err )51;
#line 1480
      return ((Success )FAILURE);
    }
#line 1480
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1481
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1481
    if (! active_connection) {
#line 1481
      err_stat = 0UL;
#line 1481
      kom_errno = (enum kom_err )6;
#line 1481
      return ((Success )FAILURE);
    } else
#line 1481
    if (! active_connection->pers_no) {
#line 1481
      err_stat = 0UL;
#line 1481
      kom_errno = (enum kom_err )6;
#line 1481
      return ((Success )FAILURE);
    }
#line 1481
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1483
  if (items_to_delete->length > param.max_delete_aux) {
#line 1485
    kom_errno = (enum kom_err )46;
#line 1486
    err_stat = (unsigned long )param.max_delete_aux;
#line 1487
    return ((Success )FAILURE);
  }
#line 1490
  if ((int )aux->length > param.max_add_aux) {
#line 1492
    kom_errno = (enum kom_err )46;
#line 1493
    err_stat = (unsigned long )param.max_add_aux;
#line 1494
    return ((Success )FAILURE);
  }
  {
#line 1497
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1497
    conf = cached_get_conf_stat(conf_no);
    }
#line 1497
    if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1497
      return ((Success )FAILURE);
    }
#line 1497
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1498
  tmp = has_access(conf_no, (Connection const   *)active_connection, (enum access )2);
  }
#line 1498
  if (! tmp) {
#line 1500
    err_stat = (unsigned long )conf_no;
#line 1501
    kom_errno = (enum kom_err )9;
#line 1502
    return ((Success )FAILURE);
  }
  {
#line 1507
  prepare_aux_item_list(aux, active_connection->pers_no);
#line 1509
  tmp___0 = check_delete_aux_item_list((Number_list const   *)items_to_delete, (Aux_item_list const   *)(& conf->aux_item_list),
                                       (Conf_no const   )conf_no);
  }
#line 1509
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
#line 1512
    return ((Success )FAILURE);
  }
  {
#line 1513
  delete_aux_item_list((Number_list const   *)items_to_delete, & conf->aux_item_list,
                       (enum object_type )2, (unsigned long )conf_no, (void *)conf);
#line 1517
  tmp___1 = conf_stat_check_add_aux_item_list(conf, conf_no, aux, active_connection,
                                              (Bool )0);
  }
#line 1517
  if ((unsigned long )tmp___1 != (unsigned long )OK) {
    {
#line 1520
    undelete_aux_item_list((Number_list const   *)items_to_delete, & conf->aux_item_list,
                           (enum object_type )2, (unsigned long )conf_no, (void *)conf);
    }
#line 1523
    return ((Success )FAILURE);
  }
  {
#line 1528
  conf_stat_add_aux_item_list(conf, conf_no, aux, active_connection->pers_no);
#line 1529
  commit_aux_item_list(& conf->aux_item_list);
#line 1532
  mark_conference_as_changed(conf_no);
  }
#line 1534
  return ((Success )OK);
}
}
#line 1538 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
Success first_unused_conf_no(Conf_no *result ) 
{ 


  {
  {
#line 1541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1541
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1541
      err_stat = 0UL;
#line 1541
      kom_errno = (enum kom_err )51;
#line 1541
      return ((Success )FAILURE);
    }
#line 1541
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1543
  *result = query_next_conf_no();
  }
#line 1544
  return ((Success )OK);
}
}
#line 1547 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
Success find_next_conf_no(Conf_no start , Conf_no *result ) 
{ 
  Conf_no highest ;
  Conf_no tmp ;
  Bool tmp___0 ;

  {
  {
#line 1551
  tmp = query_next_conf_no();
#line 1551
  highest = tmp;
  }
  {
#line 1553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1553
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1553
      err_stat = 0UL;
#line 1553
      kom_errno = (enum kom_err )51;
#line 1553
      return ((Success )FAILURE);
    }
#line 1553
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1554
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1554
    if (! active_connection) {
#line 1554
      err_stat = 0UL;
#line 1554
      kom_errno = (enum kom_err )6;
#line 1554
      return ((Success )FAILURE);
    } else
#line 1554
    if (! active_connection->pers_no) {
#line 1554
      err_stat = 0UL;
#line 1554
      kom_errno = (enum kom_err )6;
#line 1554
      return ((Success )FAILURE);
    }
#line 1554
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1555
  err_stat = (unsigned long )start;
  {
#line 1556
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1556
    start = (Conf_no )((int )start + 1);
#line 1556
    if (! ((int )start < (int )highest)) {
#line 1556
      goto while_break___1;
    }
    {
#line 1557
    tmp___0 = has_access(start, (Connection const   *)active_connection, (enum access )2);
    }
#line 1557
    if (tmp___0) {
#line 1559
      *result = start;
#line 1560
      return ((Success )OK);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1563
  kom_errno = (enum kom_err )9;
#line 1564
  return ((Success )FAILURE);
}
}
#line 1568 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conference.c"
extern Success find_previous_conf_no(Conf_no start , Conf_no *result ) 
{ 
  Conf_no next_cno ;
  Conf_no saved_start ;
  Bool tmp ;
  Conf_no tmp___0 ;

  {
#line 1573
  saved_start = start;
  {
#line 1575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1575
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1575
      err_stat = 0UL;
#line 1575
      kom_errno = (enum kom_err )51;
#line 1575
      return ((Success )FAILURE);
    }
#line 1575
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1576
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1576
    if (! active_connection) {
#line 1576
      err_stat = 0UL;
#line 1576
      kom_errno = (enum kom_err )6;
#line 1576
      return ((Success )FAILURE);
    } else
#line 1576
    if (! active_connection->pers_no) {
#line 1576
      err_stat = 0UL;
#line 1576
      kom_errno = (enum kom_err )6;
#line 1576
      return ((Success )FAILURE);
    }
#line 1576
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1578
  next_cno = query_next_conf_no();
  }
#line 1578
  if ((int )start > (int )next_cno) {
#line 1579
    start = next_cno;
  }
  {
#line 1581
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1581
    tmp___0 = start;
#line 1581
    start = (Conf_no )((int )start - 1);
#line 1581
    if (! ((int )tmp___0 > 0)) {
#line 1581
      goto while_break___1;
    }
    {
#line 1582
    tmp = has_access(start, (Connection const   *)active_connection, (enum access )2);
    }
#line 1582
    if (tmp) {
#line 1584
      *result = start;
#line 1585
      return ((Success )OK);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1588
  kom_errno = (enum kom_err )9;
#line 1589
  err_stat = (unsigned long )saved_start;
#line 1590
  return ((Success )FAILURE);
}
}
#line 297 "./../include/services.h"
Success re_lookup_person(String const   regexp , Conf_no_list *result ) ;
#line 301
Success re_lookup_conf(String const   regexp , Conf_no_list *result ) ;
#line 305
Success re_z_lookup(String const   regexp , int want_persons , int want_confs , Conf_z_info_list *result ) ;
#line 137 "./../libraries/regex/regex.h"
extern reg_syntax_t re_syntax_options ;
#line 409
extern char const   *re_compile_pattern(char const   *pattern , int length , struct re_pattern_buffer *buffer ) ;
#line 425
extern int re_search(struct re_pattern_buffer *buffer , char const   *string , int length ,
                     int start , int range , struct re_registers *regs ) ;
#line 480
extern void regfree(regex_t *preg ) ;
#line 101 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache.h"
Conf_no traverse_conference(Conf_no seed ) ;
#line 144
extern Conf_no cached_no_of_existing_conferences(void) ;
#line 62 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/regex-match.c"
static Success lookup_regexp(Connection *conn , String const   regexp , Conf_z_info_list *result ,
                             Bool want_persons , Bool want_confs ) 
{ 
  struct re_pattern_buffer pat_buf ;
  Conf_no conf_no ;
  String name___0 ;
  char const   *errmsg ;
  Conf_type type ;
  Conf_no tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  unsigned short tmp___3 ;
  unsigned int tmp___4 ;
  Bool tmp___5 ;

  {
  {
#line 71
  name___0 = EMPTY_STRING;
#line 77
  tmp = cached_no_of_existing_conferences();
#line 77
  tmp___0 = tmp_alloc((unsigned long )tmp * sizeof(Conf_z_info ));
#line 77
  result->confs = (Conf_z_info *)tmp___0;
#line 79
  result->no_of_confs = (unsigned short)0;
#line 81
  re_syntax_options = (reg_syntax_t )(((((1 << 1) | ((1 << 1) << 1)) | ((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 83
  pat_buf.translate = (char *)((void *)0);
#line 89
  tmp___1 = malloc((size_t )256);
#line 89
  pat_buf.fastmap = (char *)tmp___1;
#line 90
  pat_buf.allocated = 0UL;
#line 91
  pat_buf.buffer = (unsigned char *)0;
#line 93
  errmsg = re_compile_pattern((char const   *)((char *)regexp.string), (int )regexp.len,
                              & pat_buf);
  }
#line 93
  if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
    {
#line 97
    regfree(& pat_buf);
#line 98
    err_stat = 0UL;
#line 99
    kom_errno = (enum kom_err )43;
    }
#line 100
    return ((Success )FAILURE);
  }
#line 103
  conf_no = (Conf_no )0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    conf_no = traverse_conference(conf_no);
    }
#line 103
    if (! ((int )conf_no != 0)) {
#line 103
      goto while_break;
    }
    {
#line 105
    type = cached_get_conf_type(conf_no);
    }
#line 106
    if (type.letter_box) {
#line 106
      tmp___4 = (unsigned int )want_persons;
    } else {
#line 106
      tmp___4 = (unsigned int )want_confs;
    }
#line 106
    if (tmp___4) {
      {
#line 106
      tmp___5 = has_access(conf_no, (Connection const   *)conn, (enum access )2);
      }
#line 106
      if (tmp___5) {
        {
#line 109
        name___0 = cached_get_name(conf_no);
#line 110
        tmp___2 = re_search(& pat_buf, (char const   *)((char *)name___0.string),
                            (int )name___0.len, 0, (int )name___0.len, (struct re_registers *)((void *)0));
        }
        {
#line 114
        if (tmp___2 == -1) {
#line 114
          goto case_neg_1;
        }
#line 116
        if (tmp___2 == -2) {
#line 116
          goto case_neg_2;
        }
#line 119
        goto switch_default;
        case_neg_1: /* CIL Label */ 
#line 115
        goto switch_break;
        case_neg_2: /* CIL Label */ 
        {
#line 117
        kom_log("Internal error in regex.\n");
        }
#line 118
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 121
        (result->confs + result->no_of_confs)->conf_no = conf_no;
#line 122
        (result->confs + result->no_of_confs)->name = name___0;
#line 123
        tmp___3 = result->no_of_confs;
#line 123
        result->no_of_confs = (unsigned short )((int )result->no_of_confs + 1);
#line 123
        (result->confs + tmp___3)->type = type;
#line 124
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 129
  regfree(& pat_buf);
  }
#line 131
  return ((Success )OK);
}
}
#line 134 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/regex-match.c"
static void downgrade(Conf_z_info_list *in , Conf_no_list *out ) 
{ 
  int ix ;
  void *tmp ;

  {
  {
#line 140
  tmp = tmp_alloc(sizeof(Conf_no ) * (unsigned long )in->no_of_confs);
#line 140
  out->conf_nos = (Conf_no *)tmp;
#line 141
  out->no_of_confs = in->no_of_confs;
#line 142
  ix = 0;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (ix < (int )in->no_of_confs)) {
#line 142
      goto while_break;
    }
#line 144
    *(out->conf_nos + ix) = (in->confs + ix)->conf_no;
#line 142
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 148 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/regex-match.c"
Success re_lookup_person(String const   regexp , Conf_no_list *result ) 
{ 
  Conf_z_info_list tmp ;
  Success retval ;

  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 155
      err_stat = 0UL;
#line 155
      kom_errno = (enum kom_err )51;
#line 155
      return ((Success )FAILURE);
    }
#line 155
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 156
  retval = lookup_regexp(active_connection, regexp, & tmp, (Bool )1, (Bool )0);
  }
#line 157
  if ((unsigned long )retval == (unsigned long )OK) {
    {
#line 158
    downgrade(& tmp, result);
    }
  }
#line 159
  return (retval);
}
}
#line 163 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/regex-match.c"
Success re_lookup_conf(String const   regexp , Conf_no_list *result ) 
{ 
  Conf_z_info_list tmp ;
  Success retval ;

  {
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 170
      err_stat = 0UL;
#line 170
      kom_errno = (enum kom_err )51;
#line 170
      return ((Success )FAILURE);
    }
#line 170
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  retval = lookup_regexp(active_connection, regexp, & tmp, (Bool )0, (Bool )1);
  }
#line 172
  if ((unsigned long )retval == (unsigned long )OK) {
    {
#line 173
    downgrade(& tmp, result);
    }
  }
#line 174
  return (retval);
}
}
#line 177 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/regex-match.c"
Success re_z_lookup(String const   regexp , int want_persons , int want_confs , Conf_z_info_list *result ) 
{ 
  Success tmp ;

  {
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 183
      err_stat = 0UL;
#line 183
      kom_errno = (enum kom_err )51;
#line 183
      return ((Success )FAILURE);
    }
#line 183
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 184
    if (want_persons != 0) {
#line 184
      if (want_persons != 1) {
#line 184
        err_stat = 0UL;
#line 184
        kom_errno = (enum kom_err )61;
#line 184
        return ((Success )FAILURE);
      }
    }
#line 184
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 185
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 185
    if (want_confs != 0) {
#line 185
      if (want_confs != 1) {
#line 185
        err_stat = 0UL;
#line 185
        kom_errno = (enum kom_err )61;
#line 185
        return ((Success )FAILURE);
      }
    }
#line 185
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 186
  tmp = lookup_regexp(active_connection, regexp, result, (Bool )want_persons, (Bool )want_confs);
  }
#line 186
  return (tmp);
}
}
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 45 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.h"
void init_stats(void) ;
#line 47
long read_stat_value(enum stat_type st ) ;
#line 295 "./../libraries/libmisc/s-string.h"
extern int s_strcmp(String str1 , String str2 ) ;
#line 714 "./../include/services.h"
extern Success get_stats_description(Stats_description *result ) ;
#line 717
extern Success get_stats(String const   what , Stats_list *result ) ;
#line 40 "./../libraries/libmisc/timeval-util.h"
extern Bool timeval_less(struct timeval a , struct timeval b ) ;
#line 46
extern double timeval_diff_d(struct timeval a , struct timeval b ) ;
#line 94 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
static struct avg_status status[10][3]  ;
#line 96 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
static int const   factors[5]  = {      (int const   )1,      (int const   )15,      (int const   )60,      (int const   )300, 
        (int const   )900};
#line 104 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
static int ind(unsigned long sec , unsigned int offset ) 
{ 
  int ret ;

  {
#line 108
  ret = (int )((sec - (unsigned long )offset) % 900UL);
#line 109
  if (! (ret >= 0)) {
    {
#line 109
    __assert_fail("ret >= 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c",
                  109U, "ind");
    }
  }
#line 110
  if (! (ret < 900)) {
    {
#line 110
    __assert_fail("ret < (( 3 * ( 5 * ( 4 * (15)))))", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c",
                  110U, "ind");
    }
  }
#line 111
  return (ret);
}
}
#line 115 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
void init_stats(void) 
{ 
  enum stat_type st ;
  enum value_type vt ;
  int i ;
  struct timeval now ;

  {
#line 123
  if (! (sizeof(factors) / sizeof(factors[0]) == 5UL)) {
    {
#line 123
    __assert_fail("sizeof(factors)/sizeof(factors[0]) == 5", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c",
                  123U, "init_stats");
    }
  }
#line 124
  if (! (factors[4] == 900)) {
    {
#line 124
    __assert_fail("factors[5-1] == (( 3 * ( 5 * ( 4 * (15)))))", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c",
                  124U, "init_stats");
    }
  }
  {
#line 126
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 128
  st = (enum stat_type )0;
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! ((unsigned int )st < 10U)) {
#line 128
      goto while_break;
    }
#line 129
    vt = (enum value_type )0;
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! ((unsigned int )vt < 3U)) {
#line 129
        goto while_break___0;
      }
#line 131
      status[st][vt].when = now;
#line 132
      status[st][vt].value = 0L;
#line 133
      status[st][vt].acc = 0.0;
#line 134
      status[st][vt].avenrun_updated = now.tv_sec;
#line 135
      i = 0;
      {
#line 135
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 135
        if (! (i < 900)) {
#line 135
          goto while_break___1;
        }
#line 136
        status[st][vt].avg_history[i] = (float )0.0;
#line 135
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 137
      i = 0;
      {
#line 137
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 137
        if (! (i < 5)) {
#line 137
          goto while_break___2;
        }
#line 138
        status[st][vt].avenrun[i] = 0.0;
#line 137
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 129
      vt = (enum value_type )((unsigned int )vt + 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    st = (enum stat_type )((unsigned int )st + 1U);
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
static void update_history(struct avg_status *s , time_t end , float value ) 
{ 
  int tmp ;

  {
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (s->when.tv_sec < end)) {
#line 148
      goto while_break;
    }
    {
#line 149
    tmp = ind((unsigned long )s->when.tv_sec, 0U);
#line 149
    s->avg_history[tmp] = value;
#line 148
    (s->when.tv_sec) ++;
#line 148
    s->when.tv_usec = (__suseconds_t )0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return;
}
}
#line 162 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
static struct timeval notified  ;
#line 163
static void update_one_stat(enum stat_type st , enum value_type vt , long delta ,
                            struct timeval now ) ;
#line 163 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
static int logged  =    0;
#line 153 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
static void update_one_stat(enum stat_type st , enum value_type vt , long delta ,
                            struct timeval now ) 
{ 
  long time_delta ;
  int i ;
  struct avg_status *s ;
  double tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;

  {
  {
#line 161
  s = & status[st][vt];
#line 165
  tmp___1 = timeval_less(now, s->when);
  }
#line 165
  if (tmp___1) {
#line 167
    if (! logged) {
      {
#line 169
      tmp = timeval_diff_d(s->when, now);
#line 169
      kom_log("Time moved backward at least %g seconds.  Statistics will be wrong for that amount of time.\n",
              tmp);
#line 172
      notified = s->when;
#line 173
      logged = 1;
      }
    } else {
      {
#line 167
      tmp___0 = timeval_less(now, notified);
      }
#line 167
      if (! tmp___0) {
        {
#line 169
        tmp = timeval_diff_d(s->when, now);
#line 169
        kom_log("Time moved backward at least %g seconds.  Statistics will be wrong for that amount of time.\n",
                tmp);
#line 172
        notified = s->when;
#line 173
        logged = 1;
        }
      }
    }
#line 176
    s->value += delta;
#line 177
    return;
  }
#line 180
  if (now.tv_sec == s->when.tv_sec) {
#line 182
    if ((unsigned int )vt == 0U) {
#line 184
      time_delta = now.tv_usec - s->when.tv_usec;
#line 185
      s->acc += (1.0e-6 * (double )s->value) * (double )time_delta;
#line 186
      s->when.tv_usec = now.tv_usec;
    }
  } else
#line 189
  if (now.tv_sec - s->when.tv_sec <= 900L) {
#line 191
    if ((unsigned int )vt == 0U) {
#line 193
      time_delta = 1000000L - s->when.tv_usec;
#line 194
      s->acc += (1.0e-6 * (double )s->value) * (double )time_delta;
    } else {
#line 197
      s->acc = (double )s->value;
    }
    {
#line 199
    update_history(s, s->when.tv_sec + 1L, (float )s->acc);
    }
#line 200
    if ((unsigned int )vt != 0U) {
#line 202
      s->acc = (double )0;
#line 203
      s->value = 0L;
    }
    {
#line 205
    update_history(s, now.tv_sec, (float )s->value);
    }
#line 206
    if (! (s->when.tv_sec == now.tv_sec)) {
      {
#line 206
      __assert_fail("s->when.tv_sec == now.tv_sec", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c",
                    206U, "update_one_stat");
      }
    }
#line 207
    if ((unsigned int )vt == 0U) {
#line 209
      s->acc = (1.0e-6 * (double )s->value) * (double )now.tv_usec;
#line 210
      s->when.tv_usec = now.tv_usec;
    }
  } else {
#line 215
    if ((unsigned int )vt != 0U) {
#line 217
      s->acc = (double )0;
#line 218
      s->value = 0L;
    }
#line 220
    i = 0;
    {
#line 220
    while (1) {
      while_continue: /* CIL Label */ ;
#line 220
      if (! (i < 5)) {
#line 220
        goto while_break;
      }
#line 221
      s->avenrun[i] = (double )s->value;
#line 220
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 222
    i = 0;
    {
#line 222
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 222
      if (! (i < 900)) {
#line 222
        goto while_break___0;
      }
#line 223
      s->avg_history[i] = (float )s->value;
#line 222
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 224
    if ((unsigned int )vt == 0U) {
#line 225
      s->acc = (1.0e-6 * (double )s->value) * (double )now.tv_usec;
    }
#line 226
    s->when = now;
#line 227
    s->avenrun_updated = now.tv_sec;
  }
#line 230
  s->value += delta;
#line 231
  if (s->value < 0L) {
    {
#line 233
    kom_log("update_stat(%d, %ld): current value became negative: %ld\n", (unsigned int )st,
            delta, s->value);
#line 235
    s->value = 0L;
    }
  }
#line 237
  return;
}
}
#line 239 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
void update_stat(enum stat_type st , long delta ) 
{ 
  struct timeval now ;

  {
  {
#line 245
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 247
  update_one_stat(st, (enum value_type )0, delta, now);
  }
#line 248
  if (delta >= 0L) {
    {
#line 249
    update_one_stat(st, (enum value_type )1, delta, now);
    }
  }
#line 250
  if (delta <= 0L) {
    {
#line 251
    update_one_stat(st, (enum value_type )2, - delta, now);
    }
  }
#line 252
  return;
}
}
#line 254 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
static void check_one_stat(enum stat_type st , enum value_type vt ) 
{ 
  struct avg_status *s ;
  double acc ;
  float val ;
  int f ;
  int i ;
  int tmp ;

  {
#line 264
  s = & status[st][vt];
#line 265
  if (s->avenrun_updated == s->when.tv_sec) {
#line 266
    return;
  }
#line 268
  s->avenrun_updated = s->when.tv_sec;
#line 269
  if (! (factors[4] == 900)) {
    {
#line 269
    __assert_fail("factors[5-1] == (( 3 * ( 5 * ( 4 * (15)))))", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c",
                  269U, "check_one_stat");
    }
  }
#line 271
  f = 0;
#line 272
  acc = (double )0;
#line 273
  i = 0;
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (i < 900)) {
#line 273
      goto while_break;
    }
    {
#line 275
    tmp = ind((unsigned long )s->when.tv_sec, (unsigned int )(i + 1));
#line 275
    val = s->avg_history[tmp];
    }
#line 276
    if (! (val >= (float )0)) {
      {
#line 276
      __assert_fail("val >= 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c",
                    276U, "check_one_stat");
      }
    }
#line 277
    acc += (double )val;
#line 279
    if (! (f < 5)) {
      {
#line 279
      __assert_fail("f < 5", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c",
                    279U, "check_one_stat");
      }
    }
#line 280
    if (i == (int )(factors[f] - 1)) {
#line 282
      s->avenrun[f] = acc / (double )factors[f];
#line 283
      f ++;
#line 284
      if (! (f < 5)) {
#line 284
        if (! (i + 1 == 900)) {
          {
#line 284
          __assert_fail("f < 5 || i + 1== (( 3 * ( 5 * ( 4 * (15)))))", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c",
                        284U, "check_one_stat");
          }
        }
      }
    }
#line 273
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
static void check_stat(enum stat_type st ) 
{ 
  enum value_type vt ;

  {
#line 296
  vt = (enum value_type )0;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! ((unsigned int )vt < 3U)) {
#line 296
      goto while_break;
    }
    {
#line 297
    check_one_stat(st, vt);
#line 296
    vt = (enum value_type )((unsigned int )vt + 1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  return;
}
}
#line 301 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
static char const   *name(enum stat_type st ) 
{ 


  {
  {
#line 306
  if ((unsigned int )st == 0U) {
#line 306
    goto case_0;
  }
#line 309
  if ((unsigned int )st == 1U) {
#line 309
    goto case_1;
  }
#line 312
  if ((unsigned int )st == 2U) {
#line 312
    goto case_2;
  }
#line 315
  if ((unsigned int )st == 3U) {
#line 315
    goto case_3;
  }
#line 318
  if ((unsigned int )st == 4U) {
#line 318
    goto case_4;
  }
#line 321
  if ((unsigned int )st == 5U) {
#line 321
    goto case_5;
  }
#line 324
  if ((unsigned int )st == 6U) {
#line 324
    goto case_6;
  }
#line 327
  if ((unsigned int )st == 7U) {
#line 327
    goto case_7;
  }
#line 330
  if ((unsigned int )st == 8U) {
#line 330
    goto case_8;
  }
#line 333
  if ((unsigned int )st == 9U) {
#line 333
    goto case_9;
  }
#line 336
  if ((unsigned int )st == 10U) {
#line 336
    goto case_10;
  }
#line 304
  goto switch_break;
  case_0: /* CIL Label */ 
#line 307
  return ("run-queue-length");
  case_1: /* CIL Label */ 
#line 310
  return ("pending-dns");
  case_2: /* CIL Label */ 
#line 313
  return ("pending-ident");
  case_3: /* CIL Label */ 
#line 316
  return ("clients");
  case_4: /* CIL Label */ 
#line 319
  return ("reqs");
  case_5: /* CIL Label */ 
#line 322
  return ("texts");
  case_6: /* CIL Label */ 
#line 325
  return ("confs");
  case_7: /* CIL Label */ 
#line 328
  return ("persons");
  case_8: /* CIL Label */ 
#line 331
  return ("send-queue-bytes");
  case_9: /* CIL Label */ 
#line 334
  return ("recv-queue-bytes");
  case_10: /* CIL Label */ 
  {
#line 337
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 340
  abort();
  }
}
}
#line 343 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
long read_stat_value(enum stat_type st ) 
{ 


  {
#line 346
  return (status[st][0].value);
}
}
#line 349 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
extern Success get_stats_description(Stats_description *result ) 
{ 
  enum stat_type st ;
  int i ;
  void *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 355
      err_stat = 0UL;
#line 355
      kom_errno = (enum kom_err )51;
#line 355
      return ((Success )FAILURE);
    }
#line 355
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 357
  result->no_of_stats = 10;
#line 358
  tmp = tmp_alloc(10UL * sizeof(*(result->stat_names + 0)));
#line 358
  result->stat_names = (String *)tmp;
#line 360
  st = (enum stat_type )0;
  }
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 360
    if (! ((unsigned int )st < 10U)) {
#line 360
      goto while_break___0;
    }
    {
#line 361
    tmp___0 = name(st);
#line 361
    *(result->stat_names + st) = s_fcrea_str(tmp___0);
#line 360
    st = (enum stat_type )((unsigned int )st + 1U);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 363
  result->intervals.length = 6;
#line 364
  tmp___1 = tmp_alloc(6UL * sizeof(*(result->intervals.data + 0)));
#line 364
  result->intervals.data = (long *)tmp___1;
#line 367
  *(result->intervals.data + 0) = 0L;
#line 368
  i = 0;
  }
  {
#line 368
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 368
    if (! (i < 5)) {
#line 368
      goto while_break___1;
    }
#line 369
    *(result->intervals.data + (i + 1)) = (long )factors[i];
#line 368
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 371
  return ((Success )OK);
}
}
#line 374 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/stats.c"
extern Success get_stats(String const   what , Stats_list *result ) 
{ 
  enum stat_type st ;
  int i ;
  char const   *tmp ;
  String tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 381
      err_stat = 0UL;
#line 381
      kom_errno = (enum kom_err )51;
#line 381
      return ((Success )FAILURE);
    }
#line 381
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  st = (enum stat_type )0;
  {
#line 383
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 383
    if (! ((unsigned int )st < 10U)) {
#line 383
      goto while_break___0;
    }
    {
#line 384
    tmp = name(st);
#line 384
    tmp___0 = s_fcrea_str(tmp);
#line 384
    tmp___1 = s_strcmp((String )what, tmp___0);
    }
#line 384
    if (tmp___1 == 0) {
#line 385
      goto while_break___0;
    }
#line 383
    st = (enum stat_type )((unsigned int )st + 1U);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 387
  if ((unsigned int )st == 10U) {
#line 389
    kom_errno = (enum kom_err )57;
#line 390
    err_stat = 0UL;
#line 391
    return ((Success )FAILURE);
  }
  {
#line 395
  update_stat(st, 0L);
#line 396
  check_stat(st);
#line 398
  result->no_of_stats = 6;
#line 399
  tmp___2 = tmp_alloc(6UL * sizeof(*(result->stats + 0)));
#line 399
  result->stats = (Stats *)tmp___2;
#line 401
  (result->stats + 0)->average = (float )status[st][0].value;
#line 402
  (result->stats + 0)->ascent_rate = (float )0;
#line 403
  (result->stats + 0)->descent_rate = (float )0;
#line 405
  i = 0;
  }
  {
#line 405
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 405
    if (! (i < 5)) {
#line 405
      goto while_break___1;
    }
#line 407
    (result->stats + (i + 1))->average = (float )status[st][0].avenrun[i];
#line 408
    (result->stats + (i + 1))->ascent_rate = (float )status[st][1].avenrun[i];
#line 409
    (result->stats + (i + 1))->descent_rate = (float )status[st][2].avenrun[i];
#line 405
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 412
  return ((Success )OK);
}
}
#line 239 "./../libraries/libmisc/s-string.h"
extern Success s_strcat(String *dest_string , String const   source_string ) ;
#line 45 "./../include/services.h"
extern Success login_old(Pers_no pers_no , String const   passwd ) ;
#line 58
extern Success change_conference(Conf_no conference ) ;
#line 67
extern Success change_what_i_am_doing(String what_am_i_doing ) ;
#line 71
extern Success set_client_version(String const   client_name , String const   client_version ) ;
#line 75
extern Success get_client_name(Session_no session_no , String *result ) ;
#line 79
extern Success get_client_version(Session_no session_no , String *result ) ;
#line 90
extern Success get_session_info(Session_no session_no , Session_info *result ) ;
#line 94
extern Success get_session_info_ident(Session_no session_no , Session_info_ident *result ) ;
#line 98
extern Success get_static_session_info(Session_no session_no , Static_session_info *result ) ;
#line 111
extern Success disconnect(Session_no session_no ) ;
#line 117
extern Success who_am_i(Session_no *session_no ) ;
#line 124
extern Success user_active(void) ;
#line 127
extern Success set_connection_time_format(int use_utc ) ;
#line 592
extern Success get_time(time_t *clk ) ;
#line 617
extern Success who_is_on_old(Who_info_list_old *result ) ;
#line 620
extern Success who_is_on(Who_info_list *result ) ;
#line 623
extern Success who_is_on_ident(Who_info_ident_list *result ) ;
#line 626
extern Success who_is_on_dynamic(int want_visible , int want_invisible , long active_last ,
                                 Dynamic_session_info_list *result ) ;
#line 662
extern Success enable(unsigned char ena_level ) ;
#line 696
extern Success accept_async(Number_list *num_list ) ;
#line 699
extern Success query_async(Number_list *result ) ;
#line 360 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
void add_to_kill_list(Connection *conn ) ;
#line 319 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/manipulate.h"
extern void leave_conf(Connection *conn ) ;
#line 75 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache.h"
void cached_lock_conf(Conf_no conf_no ) ;
#line 76
void cached_unlock_conf(Conf_no conf_no ) ;
#line 77
void cached_lock_person(Pers_no pers_no ) ;
#line 78
void cached_unlock_person(Pers_no pers_no ) ;
#line 186 "./../libraries/libisc-new/src/isc.h"
extern void isc_set_acceptable_idle(struct isc_scb *session , struct timeval acceptable ) ;
#line 71 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
static void create_oldstyle_username(String *result , Connection *connection ) 
{ 
  Success tmp ;
  String tmp___0 ;
  Success tmp___1 ;
  Success tmp___2 ;

  {
  {
#line 75
  tmp = s_strcpy(result, (String const   )connection->username);
  }
#line 75
  if ((unsigned long )tmp != (unsigned long )OK) {
    {
#line 76
    restart_kom("create_oldstyle_username(): s_strcpy\n");
    }
  }
  {
#line 78
  tmp___0 = s_fcrea_str("@");
#line 78
  tmp___1 = s_strcat(result, (String const   )tmp___0);
  }
#line 78
  if ((unsigned long )tmp___1 != (unsigned long )OK) {
    {
#line 79
    restart_kom("create_oldstyle_username: s_strcat\n");
    }
  }
  {
#line 81
  tmp___2 = s_strcat(result, (String const   )(connection->isc_session)->remote);
  }
#line 81
  if ((unsigned long )tmp___2 != (unsigned long )OK) {
    {
#line 82
    restart_kom("create_oldstyle_username: s_strcat II\n");
    }
  }
#line 83
  return;
}
}
#line 90 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern void leave_conf(Connection *conn ) 
{ 
  Membership *mship ;

  {
#line 95
  if ((int )conn->cwc != 0) {
    {
#line 97
    mship = locate_membership(conn->cwc, (Person const   *)conn->person);
    }
#line 97
    if ((unsigned long )mship != (unsigned long )((void *)0)) {
      {
#line 100
      mship->last_time_read = current_time.tv_sec;
#line 101
      mark_person_as_changed(conn->pers_no);
      }
    } else {
      {
#line 105
      kom_log("ERROR: leave_conf(): Can\'t find membership of cwc.\n");
      }
    }
    {
#line 108
    cached_unlock_conf(conn->cwc);
#line 109
    conn->cwc = (Conf_no )0;
    }
  }
#line 111
  return;
}
}
#line 118 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success login_old(Pers_no pers_no , String const   passwd ) 
{ 
  Person *pers_p ;
  Bool tmp ;
  Success tmp___0 ;
  String tmp___1 ;
  Success tmp___2 ;
  Success tmp___3 ;
  String tmp___4 ;
  Success tmp___5 ;
  int tmp___6 ;
  String tmp___7 ;
  Success tmp___8 ;
  Success tmp___9 ;
  char *id ;
  char *tmp___10 ;

  {
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 124
      err_stat = 0UL;
#line 124
      kom_errno = (enum kom_err )51;
#line 124
      return ((Success )FAILURE);
    }
#line 124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 125
    pers_p = cached_get_person_stat(pers_no);
    }
#line 125
    if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 125
      return ((Success )FAILURE);
    }
#line 125
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 127
  tmp = is_supervisor(pers_no, (Connection const   *)active_connection);
  }
#line 127
  if (! tmp) {
#line 127
    if (active_connection) {
#line 127
      if ((int )active_connection->ena_level >= 8) {
#line 127
        if (! (active_connection->person)->privileges.wheel) {
#line 127
          goto _L___0;
        }
      } else {
#line 127
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 127
      tmp___0 = chk_passwd((char *)(pers_p->pwd), passwd);
      }
#line 127
      if ((unsigned long )tmp___0 == (unsigned long )FAILURE) {
#line 131
        err_stat = (unsigned long )pers_no;
#line 132
        kom_errno = (enum kom_err )4;
#line 133
        return ((Success )FAILURE);
      }
    }
  }
  {
#line 136
  logout();
#line 138
  active_connection->flags.invisible = 0U;
#line 140
  active_connection->pers_no = pers_no;
#line 141
  active_connection->person = pers_p;
#line 143
  cached_lock_person(pers_no);
#line 145
  pers_p->last_login = current_time.tv_sec;
#line 146
  active_connection->login_time = current_time;
#line 147
  (pers_p->sessions) ++;
#line 149
  s_strcpy(& pers_p->username, (String const   )active_connection->username);
  }
#line 154
  if (active_connection->ident_user.len == 0L) {
#line 154
    tmp___6 = 1;
  } else {
#line 154
    tmp___6 = 0;
  }
#line 154
  if (! tmp___6) {
    {
#line 156
    tmp___1 = s_fcrea_str("(");
#line 156
    tmp___2 = s_strcat(& pers_p->username, (String const   )tmp___1);
    }
#line 156
    if ((unsigned long )tmp___2 != (unsigned long )OK) {
      {
#line 157
      restart_kom("login_old: s_strcat (\n");
      }
    }
    {
#line 159
    tmp___3 = s_strcat(& pers_p->username, (String const   )active_connection->ident_user);
    }
#line 159
    if ((unsigned long )tmp___3 != (unsigned long )OK) {
      {
#line 160
      restart_kom("login_old: s_strcat ident_user\n");
      }
    }
    {
#line 162
    tmp___4 = s_fcrea_str(")");
#line 162
    tmp___5 = s_strcat(& pers_p->username, (String const   )tmp___4);
    }
#line 162
    if ((unsigned long )tmp___5 != (unsigned long )OK) {
      {
#line 163
      restart_kom("login_old: s_strcat )\n");
      }
    }
  }
  {
#line 166
  tmp___7 = s_fcrea_str("@");
#line 166
  tmp___8 = s_strcat(& pers_p->username, (String const   )tmp___7);
  }
#line 166
  if ((unsigned long )tmp___8 != (unsigned long )OK) {
    {
#line 167
    restart_kom("login_old: s_strcat\n");
    }
  }
  {
#line 169
  tmp___9 = s_strcat(& pers_p->username, (String const   )(active_connection->isc_session)->remote);
  }
#line 169
  if ((unsigned long )tmp___9 != (unsigned long )OK) {
    {
#line 171
    restart_kom("login_old: s_strcat II\n");
    }
  }
  {
#line 173
  mark_person_as_changed(pers_no);
  }
#line 175
  if ((unsigned int )param.log_login == 1U) {
    {
#line 177
    tmp___10 = s_crea_c_str((String const   )pers_p->username);
#line 177
    id = tmp___10;
#line 178
    kom_log("Login %d %s\n", (int )active_connection->pers_no, id);
#line 179
    string_free((void *)id);
    }
  }
  {
#line 182
  isc_set_acceptable_idle(active_connection->isc_session, param.active_timeout);
#line 184
  async_login(active_connection->pers_no, (int )active_connection->session_no);
  }
#line 186
  return ((Success )OK);
}
}
#line 194 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success login(Pers_no pers_no , String const   passwd , Bool invisible ) 
{ 
  Person *pers_p ;
  Bool same_person ;
  Bool tmp ;
  Success tmp___0 ;
  String tmp___1 ;
  Success tmp___2 ;
  Success tmp___3 ;
  String tmp___4 ;
  Success tmp___5 ;
  int tmp___6 ;
  String tmp___7 ;
  Success tmp___8 ;
  Success tmp___9 ;
  char *id ;
  char *tmp___10 ;

  {
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 202
      err_stat = 0UL;
#line 202
      kom_errno = (enum kom_err )51;
#line 202
      return ((Success )FAILURE);
    }
#line 202
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 203
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 203
    if ((unsigned int )invisible != 0U) {
#line 203
      if ((unsigned int )invisible != 1U) {
#line 203
        err_stat = 0UL;
#line 203
        kom_errno = (enum kom_err )61;
#line 203
        return ((Success )FAILURE);
      }
    }
#line 203
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 204
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 204
    pers_p = cached_get_person_stat(pers_no);
    }
#line 204
    if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 204
      return ((Success )FAILURE);
    }
#line 204
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 206
  tmp = is_supervisor(pers_no, (Connection const   *)active_connection);
  }
#line 206
  if (! tmp) {
#line 206
    if (active_connection) {
#line 206
      if ((int )active_connection->ena_level >= 8) {
#line 206
        if (! (active_connection->person)->privileges.wheel) {
#line 206
          goto _L___0;
        }
      } else {
#line 206
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 206
      tmp___0 = chk_passwd((char *)(pers_p->pwd), passwd);
      }
#line 206
      if ((unsigned long )tmp___0 == (unsigned long )FAILURE) {
#line 210
        err_stat = (unsigned long )pers_no;
#line 211
        kom_errno = (enum kom_err )4;
#line 212
        return ((Success )FAILURE);
      }
    }
  }
#line 215
  if ((int )active_connection->pers_no == (int )pers_no) {
#line 215
    same_person = (Bool )1;
  } else {
#line 215
    same_person = (Bool )0;
  }
  {
#line 217
  logout();
  }
#line 219
  if (invisible) {
#line 220
    active_connection->flags.invisible = 1U;
  } else {
#line 222
    active_connection->flags.invisible = 0U;
  }
#line 227
  if ((unsigned int )same_person == 0U) {
#line 228
    (pers_p->sessions) ++;
  }
  {
#line 230
  active_connection->pers_no = pers_no;
#line 231
  active_connection->person = pers_p;
#line 233
  cached_lock_person(pers_no);
#line 235
  pers_p->last_login = current_time.tv_sec;
#line 236
  active_connection->login_time = current_time;
#line 238
  s_strcpy(& pers_p->username, (String const   )active_connection->username);
  }
#line 243
  if (active_connection->ident_user.len == 0L) {
#line 243
    tmp___6 = 1;
  } else {
#line 243
    tmp___6 = 0;
  }
#line 243
  if (! tmp___6) {
    {
#line 245
    tmp___1 = s_fcrea_str("(");
#line 245
    tmp___2 = s_strcat(& pers_p->username, (String const   )tmp___1);
    }
#line 245
    if ((unsigned long )tmp___2 != (unsigned long )OK) {
      {
#line 246
      restart_kom("login: s_strcat (\n");
      }
    }
    {
#line 248
    tmp___3 = s_strcat(& pers_p->username, (String const   )active_connection->ident_user);
    }
#line 248
    if ((unsigned long )tmp___3 != (unsigned long )OK) {
      {
#line 249
      restart_kom("login: s_strcat ident_user\n");
      }
    }
    {
#line 251
    tmp___4 = s_fcrea_str(")");
#line 251
    tmp___5 = s_strcat(& pers_p->username, (String const   )tmp___4);
    }
#line 251
    if ((unsigned long )tmp___5 != (unsigned long )OK) {
      {
#line 253
      restart_kom("login: s_strcat )\n");
      }
    }
  }
  {
#line 256
  tmp___7 = s_fcrea_str("@");
#line 256
  tmp___8 = s_strcat(& pers_p->username, (String const   )tmp___7);
  }
#line 256
  if ((unsigned long )tmp___8 != (unsigned long )OK) {
    {
#line 257
    restart_kom("login: s_strcat\n");
    }
  }
  {
#line 259
  tmp___9 = s_strcat(& pers_p->username, (String const   )(active_connection->isc_session)->remote);
  }
#line 259
  if ((unsigned long )tmp___9 != (unsigned long )OK) {
    {
#line 261
    restart_kom("login: s_strcat II\n");
    }
  }
  {
#line 263
  mark_person_as_changed(pers_no);
  }
#line 265
  if ((unsigned int )param.log_login == 1U) {
#line 265
    if ((unsigned int )same_person == 0U) {
      {
#line 267
      tmp___10 = s_crea_c_str((String const   )pers_p->username);
#line 267
      id = tmp___10;
#line 268
      kom_log("Login %d %s\n", (int )active_connection->pers_no, id);
#line 269
      string_free((void *)id);
      }
    }
  }
#line 272
  if (! active_connection->flags.invisible) {
    {
#line 273
    async_login(active_connection->pers_no, (int )active_connection->session_no);
    }
  }
  {
#line 275
  isc_set_acceptable_idle(active_connection->isc_session, param.active_timeout);
  }
#line 278
  return ((Success )OK);
}
}
#line 287 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success logout(void) 
{ 
  long tmp ;

  {
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 290
      err_stat = 0UL;
#line 290
      kom_errno = (enum kom_err )51;
#line 290
      return ((Success )FAILURE);
    }
#line 290
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  if ((int )active_connection->pers_no != 0) {
#line 293
    if (! active_connection->flags.invisible) {
      {
#line 295
      async_logout(active_connection->pers_no, active_connection->session_no);
      }
    }
    {
#line 298
    leave_conf(active_connection);
#line 299
    (active_connection->person)->last_login = current_time.tv_sec;
#line 300
    tmp = timeval_diff_sec(current_time, active_connection->login_time);
#line 300
    (active_connection->person)->total_time_present += (unsigned long )tmp;
#line 302
    active_connection->login_time = current_time;
#line 304
    cached_unlock_person(active_connection->pers_no);
#line 305
    mark_person_as_changed(active_connection->pers_no);
    }
  }
  {
#line 309
  s_clear(& active_connection->what_am_i_doing);
#line 311
  active_connection->person = (Person *)((void *)0);
#line 312
  active_connection->cwc = (Conf_no )0;
#line 313
  active_connection->pers_no = (Pers_no )0;
#line 314
  active_connection->ena_level = (unsigned char)0;
#line 316
  isc_set_acceptable_idle(active_connection->isc_session, param.login_timeout);
  }
#line 319
  return ((Success )OK);
}
}
#line 344 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success change_conference(Conf_no conference ) 
{ 
  Who_info info ;
  Bool tmp ;
  Membership *tmp___0 ;

  {
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 349
      err_stat = 0UL;
#line 349
      kom_errno = (enum kom_err )51;
#line 349
      return ((Success )FAILURE);
    }
#line 349
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 350
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 350
    if (! active_connection) {
#line 350
      err_stat = 0UL;
#line 350
      kom_errno = (enum kom_err )6;
#line 350
      return ((Success )FAILURE);
    } else
#line 350
    if (! active_connection->pers_no) {
#line 350
      err_stat = 0UL;
#line 350
      kom_errno = (enum kom_err )6;
#line 350
      return ((Success )FAILURE);
    }
#line 350
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 352
  if ((int )conference != 0) {
    {
#line 354
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 354
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 354
        if ((int )conference == 0) {
#line 354
          err_stat = 0UL;
#line 354
          kom_errno = (enum kom_err )8;
#line 354
          return ((Success )FAILURE);
        }
#line 354
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 354
      tmp = cached_conf_exists(conference);
      }
#line 354
      if (! tmp) {
#line 354
        err_stat = (unsigned long )conference;
#line 354
        kom_errno = (enum kom_err )9;
#line 354
        return ((Success )FAILURE);
      }
#line 354
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 356
    tmp___0 = locate_membership(conference, (Person const   *)active_connection->person);
    }
#line 356
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 358
      err_stat = (unsigned long )conference;
#line 359
      kom_errno = (enum kom_err )13;
#line 360
      return ((Success )FAILURE);
    }
  }
  {
#line 364
  leave_conf(active_connection);
#line 366
  active_connection->cwc = conference;
  }
#line 367
  if ((int )conference != 0) {
    {
#line 368
    cached_lock_conf(conference);
    }
  }
  {
#line 370
  init_who_info(& info);
  }
#line 371
  if (! active_connection->flags.invisible) {
    {
#line 373
    info.person = active_connection->pers_no;
#line 374
    info.what_am_i_doing = active_connection->what_am_i_doing;
#line 375
    info.working_conference = conference;
#line 376
    info.session_no = active_connection->session_no;
#line 379
    create_oldstyle_username(& info.username, active_connection);
#line 381
    async_i_am_on(info);
#line 383
    s_clear(& info.username);
    }
  }
#line 386
  return ((Success )OK);
}
}
#line 394 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success change_what_i_am_doing(String what_am_i_doing ) 
{ 
  Who_info info ;

  {
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 399
      err_stat = 0UL;
#line 399
      kom_errno = (enum kom_err )51;
#line 399
      return ((Success )FAILURE);
    }
#line 399
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 400
  init_who_info(& info);
  }
#line 402
  if (what_am_i_doing.len > (String_size )param.what_do_len) {
    {
#line 404
    s_clear(& what_am_i_doing);
#line 405
    err_stat = (unsigned long )param.what_do_len;
#line 406
    kom_errno = (enum kom_err )5;
    }
#line 407
    return ((Success )FAILURE);
  }
  {
#line 410
  s_clear(& active_connection->what_am_i_doing);
#line 411
  active_connection->what_am_i_doing = what_am_i_doing;
  }
#line 413
  if (! active_connection->flags.invisible) {
    {
#line 415
    info.person = active_connection->pers_no;
#line 416
    info.what_am_i_doing = active_connection->what_am_i_doing;
#line 417
    create_oldstyle_username(& info.username, active_connection);
#line 418
    info.working_conference = active_connection->cwc;
#line 419
    info.session_no = active_connection->session_no;
#line 421
    async_i_am_on(info);
#line 423
    s_clear(& info.username);
    }
  }
#line 426
  return ((Success )OK);
}
}
#line 433 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success who_is_on(Who_info_list *result ) 
{ 
  Connection *cptr ;
  int no_of_clients ;
  int i ;
  Session_no session ;
  void *tmp ;

  {
#line 437
  no_of_clients = 0;
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 441
      err_stat = 0UL;
#line 441
      kom_errno = (enum kom_err )51;
#line 441
      return ((Success )FAILURE);
    }
#line 441
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 443
  session = traverse_connections((Session_no )0);
  }
  {
#line 444
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 444
    if (! (session != 0UL)) {
#line 444
      goto while_break___0;
    }
    {
#line 446
    cptr = get_conn_by_number(session);
    }
#line 448
    if ((unsigned long )cptr->person != (unsigned long )((void *)0)) {
#line 448
      if (cptr->flags.invisible == 0U) {
#line 449
        no_of_clients ++;
      }
    }
    {
#line 451
    session = traverse_connections(session);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 454
  result->no_of_persons = no_of_clients;
#line 455
  tmp = tmp_alloc((unsigned long )no_of_clients * sizeof(Who_info ));
#line 455
  result->info = (Who_info *)tmp;
#line 457
  i = 0;
#line 458
  session = traverse_connections((Session_no )0);
  }
  {
#line 459
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 459
    if (i < no_of_clients) {
#line 459
      if (! (session != 0UL)) {
#line 459
        goto while_break___1;
      }
    } else {
#line 459
      goto while_break___1;
    }
    {
#line 461
    cptr = get_conn_by_number(session);
    }
#line 463
    if ((unsigned long )cptr->person != (unsigned long )((void *)0)) {
#line 463
      if (cptr->flags.invisible == 0U) {
        {
#line 465
        init_who_info(result->info + i);
#line 466
        (result->info + i)->person = cptr->pers_no;
#line 467
        (result->info + i)->what_am_i_doing = cptr->what_am_i_doing;
#line 472
        create_oldstyle_username(& (result->info + i)->username, cptr);
#line 474
        (result->info + i)->working_conference = filter_conf_no(cptr->cwc, (Connection const   *)active_connection);
#line 476
        (result->info + i)->session_no = cptr->session_no;
#line 477
        i ++;
        }
      }
    }
    {
#line 479
    session = traverse_connections(session);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 482
  if (i != no_of_clients) {
    {
#line 483
    kom_log("who_is_on: i == %d, no_of_clients == %d\n", i, no_of_clients);
    }
  }
#line 486
  return ((Success )OK);
}
}
#line 492 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success who_is_on_ident(Who_info_ident_list *result ) 
{ 
  Connection *cptr ;
  int no_of_clients ;
  int i ;
  Session_no session ;
  void *tmp ;

  {
#line 496
  no_of_clients = 0;
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 500
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 500
      err_stat = 0UL;
#line 500
      kom_errno = (enum kom_err )51;
#line 500
      return ((Success )FAILURE);
    }
#line 500
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 502
  session = traverse_connections((Session_no )0);
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (session != 0UL)) {
#line 503
      goto while_break___0;
    }
    {
#line 505
    cptr = get_conn_by_number(session);
    }
#line 507
    if ((unsigned long )cptr->person != (unsigned long )((void *)0)) {
#line 507
      if (cptr->flags.invisible == 0U) {
#line 508
        no_of_clients ++;
      }
    }
    {
#line 510
    session = traverse_connections(session);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 513
  result->no_of_persons = no_of_clients;
#line 514
  tmp = tmp_alloc((unsigned long )no_of_clients * sizeof(Who_info_ident ));
#line 514
  result->info = (Who_info_ident *)tmp;
#line 516
  i = 0;
#line 517
  session = traverse_connections((Session_no )0);
  }
  {
#line 518
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 518
    if (i < no_of_clients) {
#line 518
      if (! (session != 0UL)) {
#line 518
        goto while_break___1;
      }
    } else {
#line 518
      goto while_break___1;
    }
    {
#line 520
    cptr = get_conn_by_number(session);
    }
#line 522
    if ((unsigned long )cptr->person != (unsigned long )((void *)0)) {
#line 522
      if (cptr->flags.invisible == 0U) {
        {
#line 524
        init_who_info_ident(result->info + i);
#line 525
        (result->info + i)->person = cptr->pers_no;
#line 526
        (result->info + i)->what_am_i_doing = cptr->what_am_i_doing;
#line 527
        (result->info + i)->username = cptr->username;
#line 528
        (result->info + i)->hostname = (cptr->isc_session)->remote;
#line 529
        (result->info + i)->ident_user = cptr->ident_user;
#line 530
        (result->info + i)->working_conference = filter_conf_no(cptr->cwc, (Connection const   *)active_connection);
#line 532
        (result->info + i)->session_no = cptr->session_no;
#line 533
        i ++;
        }
      }
    }
    {
#line 535
    session = traverse_connections(session);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 538
  if (i != no_of_clients) {
    {
#line 539
    kom_log("who_is_on_ident: i == %d, no_of_clients == %d\n", i, no_of_clients);
    }
  }
#line 542
  return ((Success )OK);
}
}
#line 549 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success who_is_on_dynamic(int want_visible , int want_invisible , long active_last ,
                                 Dynamic_session_info_list *result ) 
{ 
  Connection *cptr ;
  long no_of_clients ;
  long i ;
  Session_no session ;
  int include_it ;
  Bool tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  Bool tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 556
  no_of_clients = 0L;
#line 559
  include_it = 0;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 561
      err_stat = 0UL;
#line 561
      kom_errno = (enum kom_err )51;
#line 561
      return ((Success )FAILURE);
    }
#line 561
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 562
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 562
    if (want_visible != 0) {
#line 562
      if (want_visible != 1) {
#line 562
        err_stat = 0UL;
#line 562
        kom_errno = (enum kom_err )61;
#line 562
        return ((Success )FAILURE);
      }
    }
#line 562
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 563
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 563
    if (want_invisible != 0) {
#line 563
      if (want_invisible != 1) {
#line 563
        err_stat = 0UL;
#line 563
        kom_errno = (enum kom_err )61;
#line 563
        return ((Success )FAILURE);
      }
    }
#line 563
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 564
  session = traverse_connections((Session_no )0);
  }
  {
#line 565
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 565
    if (! (session != 0UL)) {
#line 565
      goto while_break___2;
    }
    {
#line 567
    cptr = get_conn_by_number(session);
#line 569
    tmp = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 569
    if (tmp) {
#line 571
      if ((unsigned long )cptr->person == (unsigned long )((void *)0)) {
#line 572
        include_it = want_invisible;
      } else
#line 571
      if (cptr->flags.invisible == 1U) {
#line 572
        include_it = want_invisible;
      } else {
#line 574
        include_it = want_visible;
      }
    } else {
#line 570
      include_it = 0;
    }
#line 576
    if (active_last != 0L) {
#line 576
      if (include_it) {
        {
#line 576
        tmp___0 = timeval_diff_sec(current_time, cptr->active_time);
        }
#line 576
        if (tmp___0 > active_last) {
#line 576
          if (cptr->flags.user_active_used) {
#line 580
            include_it = 0;
          }
        }
      }
    }
#line 582
    if (include_it != 0) {
#line 583
      no_of_clients ++;
    }
    {
#line 585
    session = traverse_connections(session);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 588
  result->no_of_sessions = no_of_clients;
#line 589
  tmp___1 = tmp_alloc((unsigned long )no_of_clients * sizeof(Dynamic_session_info ));
#line 589
  result->sessions = (Dynamic_session_info *)tmp___1;
#line 591
  i = 0L;
#line 592
  session = traverse_connections((Session_no )0);
  }
  {
#line 593
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 593
    if (i < no_of_clients) {
#line 593
      if (! (session != 0UL)) {
#line 593
        goto while_break___3;
      }
    } else {
#line 593
      goto while_break___3;
    }
    {
#line 595
    cptr = get_conn_by_number(session);
#line 597
    tmp___2 = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 597
    if (tmp___2) {
#line 599
      if ((unsigned long )cptr->person == (unsigned long )((void *)0)) {
#line 600
        include_it = want_invisible;
      } else
#line 599
      if (cptr->flags.invisible == 1U) {
#line 600
        include_it = want_invisible;
      } else {
#line 602
        include_it = want_visible;
      }
    } else {
#line 598
      include_it = 0;
    }
#line 604
    if (active_last != 0L) {
#line 604
      if (include_it) {
        {
#line 604
        tmp___3 = timeval_diff_sec(current_time, cptr->active_time);
        }
#line 604
        if (tmp___3 > active_last) {
#line 604
          if (cptr->flags.user_active_used) {
#line 608
            include_it = 0;
          }
        }
      }
    }
#line 610
    if (include_it != 0) {
      {
#line 612
      init_dynamic_session_info(result->sessions + i);
#line 613
      (result->sessions + i)->session = cptr->session_no;
#line 614
      (result->sessions + i)->person = cptr->pers_no;
#line 615
      (result->sessions + i)->working_conference = filter_conf_no(cptr->cwc, (Connection const   *)active_connection);
#line 617
      tmp___4 = timeval_diff_sec(current_time, cptr->active_time);
#line 617
      (result->sessions + i)->idle_time = (unsigned long )tmp___4;
#line 620
      (result->sessions + i)->flags = cptr->flags;
      }
#line 624
      if ((unsigned long )cptr->person == (unsigned long )((void *)0)) {
#line 625
        (result->sessions + i)->flags.invisible = 1U;
      }
#line 627
      (result->sessions + i)->what_am_i_doing = cptr->what_am_i_doing;
#line 628
      i ++;
    }
    {
#line 631
    session = traverse_connections(session);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 634
  if (i != no_of_clients) {
    {
#line 635
    kom_log("who_is_on_dynamic: i == %ld, no_of_clients == %ld\n", i, no_of_clients);
    }
  }
#line 638
  return ((Success )OK);
}
}
#line 642 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success get_session_info(Session_no session_no , Session_info *result ) 
{ 
  Connection *cptr ;
  long tmp ;
  Bool tmp___0 ;

  {
  {
#line 648
  while (1) {
    while_continue: /* CIL Label */ ;
#line 648
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 648
      err_stat = 0UL;
#line 648
      kom_errno = (enum kom_err )51;
#line 648
      return ((Success )FAILURE);
    }
#line 648
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 649
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 649
    if (! active_connection) {
#line 649
      err_stat = 0UL;
#line 649
      kom_errno = (enum kom_err )6;
#line 649
      return ((Success )FAILURE);
    } else
#line 649
    if (! active_connection->pers_no) {
#line 649
      err_stat = 0UL;
#line 649
      kom_errno = (enum kom_err )6;
#line 649
      return ((Success )FAILURE);
    }
#line 649
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 651
  cptr = get_conn_by_number(session_no);
  }
#line 653
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 653
    tmp___0 = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 653
    if (tmp___0) {
      {
#line 655
      init_session_info(result);
#line 656
      result->person = cptr->pers_no;
#line 657
      result->what_am_i_doing = cptr->what_am_i_doing;
#line 658
      result->working_conference = filter_conf_no(cptr->cwc, (Connection const   *)active_connection);
#line 660
      result->session = cptr->session_no;
#line 661
      result->connection_time = cptr->connect_time.tv_sec;
#line 662
      tmp = timeval_diff_sec(current_time, cptr->active_time);
#line 662
      result->idle_time = (unsigned long )tmp;
#line 666
      create_oldstyle_username(& result->username, cptr);
      }
#line 668
      return ((Success )OK);
    } else {
#line 672
      err_stat = session_no;
#line 673
      kom_errno = (enum kom_err )42;
#line 674
      return ((Success )FAILURE);
    }
  } else {
#line 672
    err_stat = session_no;
#line 673
    kom_errno = (enum kom_err )42;
#line 674
    return ((Success )FAILURE);
  }
}
}
#line 678 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success get_static_session_info(Session_no session_no , Static_session_info *result ) 
{ 
  Connection *cptr ;
  Bool tmp ;

  {
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 684
      err_stat = 0UL;
#line 684
      kom_errno = (enum kom_err )51;
#line 684
      return ((Success )FAILURE);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 685
    if (! active_connection) {
#line 685
      err_stat = 0UL;
#line 685
      kom_errno = (enum kom_err )6;
#line 685
      return ((Success )FAILURE);
    } else
#line 685
    if (! active_connection->pers_no) {
#line 685
      err_stat = 0UL;
#line 685
      kom_errno = (enum kom_err )6;
#line 685
      return ((Success )FAILURE);
    }
#line 685
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 687
  cptr = get_conn_by_number(session_no);
  }
#line 689
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 689
    tmp = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 689
    if (tmp) {
      {
#line 691
      init_static_session_info(result);
#line 693
      result->username = cptr->username;
#line 694
      result->hostname = (cptr->isc_session)->remote;
#line 695
      result->ident_user = cptr->ident_user;
#line 696
      result->connection_time = cptr->connect_time.tv_sec;
      }
#line 698
      return ((Success )OK);
    } else {
#line 702
      err_stat = session_no;
#line 703
      kom_errno = (enum kom_err )42;
#line 704
      return ((Success )FAILURE);
    }
  } else {
#line 702
    err_stat = session_no;
#line 703
    kom_errno = (enum kom_err )42;
#line 704
    return ((Success )FAILURE);
  }
}
}
#line 708 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success get_session_info_ident(Session_no session_no , Session_info_ident *result ) 
{ 
  Connection *cptr ;
  long tmp ;
  Bool tmp___0 ;

  {
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
#line 714
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 714
      err_stat = 0UL;
#line 714
      kom_errno = (enum kom_err )51;
#line 714
      return ((Success )FAILURE);
    }
#line 714
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 715
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 715
    if (! active_connection) {
#line 715
      err_stat = 0UL;
#line 715
      kom_errno = (enum kom_err )6;
#line 715
      return ((Success )FAILURE);
    } else
#line 715
    if (! active_connection->pers_no) {
#line 715
      err_stat = 0UL;
#line 715
      kom_errno = (enum kom_err )6;
#line 715
      return ((Success )FAILURE);
    }
#line 715
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 717
  cptr = get_conn_by_number(session_no);
  }
#line 719
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 719
    tmp___0 = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 719
    if (tmp___0) {
      {
#line 721
      init_session_info_ident(result);
#line 722
      result->person = cptr->pers_no;
#line 723
      result->what_am_i_doing = cptr->what_am_i_doing;
#line 724
      result->working_conference = filter_conf_no(cptr->cwc, (Connection const   *)active_connection);
#line 726
      result->session = cptr->session_no;
#line 727
      result->connection_time = cptr->connect_time.tv_sec;
#line 728
      tmp = timeval_diff_sec(current_time, cptr->active_time);
#line 728
      result->idle_time = (unsigned long )tmp;
#line 729
      result->username = cptr->username;
#line 730
      result->hostname = (cptr->isc_session)->remote;
#line 731
      result->ident_user = cptr->ident_user;
      }
#line 733
      return ((Success )OK);
    } else {
#line 737
      err_stat = session_no;
#line 738
      kom_errno = (enum kom_err )42;
#line 739
      return ((Success )FAILURE);
    }
  } else {
#line 737
    err_stat = session_no;
#line 738
    kom_errno = (enum kom_err )42;
#line 739
    return ((Success )FAILURE);
  }
}
}
#line 743 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success who_am_i(Session_no *session_no ) 
{ 


  {
  {
#line 746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 746
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 746
      err_stat = 0UL;
#line 746
      kom_errno = (enum kom_err )51;
#line 746
      return ((Success )FAILURE);
    }
#line 746
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  *session_no = active_connection->session_no;
#line 748
  return ((Success )OK);
}
}
#line 753 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success disconnect(Session_no session_no ) 
{ 
  Connection *cptr ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 758
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 758
      err_stat = 0UL;
#line 758
      kom_errno = (enum kom_err )51;
#line 758
      return ((Success )FAILURE);
    }
#line 758
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 759
  if (session_no != active_connection->session_no) {
#line 759
    if (session_no != 0UL) {
      {
#line 761
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 761
        if (! active_connection) {
#line 761
          err_stat = 0UL;
#line 761
          kom_errno = (enum kom_err )6;
#line 761
          return ((Success )FAILURE);
        } else
#line 761
        if (! active_connection->pers_no) {
#line 761
          err_stat = 0UL;
#line 761
          kom_errno = (enum kom_err )6;
#line 761
          return ((Success )FAILURE);
        }
#line 761
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 763
  cptr = get_conn_by_number(session_no);
  }
#line 765
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 765
    tmp___0 = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 765
    if (tmp___0) {
#line 767
      if (session_no == active_connection->session_no) {
        {
#line 772
        add_to_kill_list(cptr);
        }
#line 773
        return ((Success )OK);
      } else
#line 767
      if (session_no == 0UL) {
        {
#line 772
        add_to_kill_list(cptr);
        }
#line 773
        return ((Success )OK);
      } else
#line 767
      if (active_connection) {
#line 767
        if ((int )active_connection->ena_level >= 8) {
#line 767
          if ((active_connection->person)->privileges.wheel) {
            {
#line 772
            add_to_kill_list(cptr);
            }
#line 773
            return ((Success )OK);
          } else {
#line 767
            goto _L___0;
          }
        } else {
#line 767
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 767
        tmp = is_supervisor(cptr->pers_no, (Connection const   *)active_connection);
        }
#line 767
        if ((unsigned int )tmp == 1U) {
          {
#line 772
          add_to_kill_list(cptr);
          }
#line 773
          return ((Success )OK);
        } else {
#line 777
          err_stat = session_no;
#line 778
          kom_errno = (enum kom_err )12;
#line 779
          return ((Success )FAILURE);
        }
      }
    } else {
#line 784
      err_stat = session_no;
#line 785
      kom_errno = (enum kom_err )42;
#line 786
      return ((Success )FAILURE);
    }
  } else {
#line 784
    err_stat = session_no;
#line 785
    kom_errno = (enum kom_err )42;
#line 786
    return ((Success )FAILURE);
  }
}
}
#line 792 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success who_is_on_old(Who_info_list_old *result ) 
{ 
  Connection *cptr ;
  int no_of_clients ;
  int i ;
  Session_no session ;
  void *tmp ;

  {
#line 796
  no_of_clients = 0;
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 801
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 801
      err_stat = 0UL;
#line 801
      kom_errno = (enum kom_err )51;
#line 801
      return ((Success )FAILURE);
    }
#line 801
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 802
  session = traverse_connections((Session_no )0);
  }
  {
#line 803
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 803
    if (! (session != 0UL)) {
#line 803
      goto while_break___0;
    }
    {
#line 805
    cptr = get_conn_by_number(session);
    }
#line 807
    if ((unsigned long )cptr->person != (unsigned long )((void *)0)) {
#line 807
      if (cptr->flags.invisible == 0U) {
#line 808
        no_of_clients ++;
      }
    }
    {
#line 809
    session = traverse_connections(session);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 812
  result->no_of_persons = no_of_clients;
#line 813
  tmp = tmp_alloc((unsigned long )no_of_clients * sizeof(Who_info ));
#line 813
  result->info = (Who_info_old *)tmp;
#line 815
  i = 0;
#line 816
  session = traverse_connections((Session_no )0);
  }
  {
#line 817
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 817
    if (session != 0UL) {
#line 817
      if (! (i < no_of_clients)) {
#line 817
        goto while_break___1;
      }
    } else {
#line 817
      goto while_break___1;
    }
    {
#line 819
    cptr = get_conn_by_number(session);
    }
#line 821
    if ((unsigned long )cptr->person != (unsigned long )((void *)0)) {
#line 821
      if (cptr->flags.invisible == 0U) {
        {
#line 823
        init_who_info_old(result->info + i);
#line 824
        (result->info + i)->person = cptr->pers_no;
#line 825
        (result->info + i)->what_am_i_doing = cptr->what_am_i_doing;
#line 826
        (result->info + i)->working_conference = filter_conf_no(cptr->cwc, (Connection const   *)active_connection);
#line 828
        i ++;
        }
      }
    }
    {
#line 830
    session = traverse_connections(session);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 833
  if (i != no_of_clients) {
    {
#line 834
    kom_log("who_is_on_old: i == %d, no_of_clients == %d\n", i, no_of_clients);
    }
  }
#line 837
  return ((Success )OK);
}
}
#line 843 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success get_time(time_t *clk ) 
{ 


  {
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 846
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 846
      err_stat = 0UL;
#line 846
      kom_errno = (enum kom_err )51;
#line 846
      return ((Success )FAILURE);
    }
#line 846
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 847
  *clk = current_time.tv_sec;
#line 849
  return ((Success )OK);
}
}
#line 857 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success enable(unsigned char ena_level ) 
{ 


  {
  {
#line 860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 860
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 860
      err_stat = 0UL;
#line 860
      kom_errno = (enum kom_err )51;
#line 860
      return ((Success )FAILURE);
    }
#line 860
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 861
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 861
    if (! active_connection) {
#line 861
      err_stat = 0UL;
#line 861
      kom_errno = (enum kom_err )6;
#line 861
      return ((Success )FAILURE);
    } else
#line 861
    if (! active_connection->pers_no) {
#line 861
      err_stat = 0UL;
#line 861
      kom_errno = (enum kom_err )6;
#line 861
      return ((Success )FAILURE);
    }
#line 861
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 862
  active_connection->ena_level = ena_level;
#line 863
  return ((Success )OK);
}
}
#line 866 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success set_client_version(String const   client_name , String const   client_version ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 870
      err_stat = 0UL;
#line 870
      kom_errno = (enum kom_err )51;
#line 870
      return ((Success )FAILURE);
    }
#line 870
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 872
  if (client_name.len > (String_size const   )param.client_data_len) {
#line 875
    err_stat = (unsigned long )param.client_data_len;
#line 876
    kom_errno = (enum kom_err )5;
#line 877
    return ((Success )FAILURE);
  } else
#line 872
  if (client_version.len > (String_size const   )param.client_data_len) {
#line 875
    err_stat = (unsigned long )param.client_data_len;
#line 876
    kom_errno = (enum kom_err )5;
#line 877
    return ((Success )FAILURE);
  }
#line 879
  if (active_connection->client_name.len == 0L) {
#line 879
    tmp = 1;
  } else {
#line 879
    tmp = 0;
  }
#line 879
  if (tmp == 0) {
#line 882
    err_stat = 0UL;
#line 883
    kom_errno = (enum kom_err )41;
#line 884
    return ((Success )FAILURE);
  } else {
#line 879
    if (active_connection->client_version.len == 0L) {
#line 879
      tmp___0 = 1;
    } else {
#line 879
      tmp___0 = 0;
    }
#line 879
    if (tmp___0 == 0) {
#line 882
      err_stat = 0UL;
#line 883
      kom_errno = (enum kom_err )41;
#line 884
      return ((Success )FAILURE);
    }
  }
  {
#line 887
  s_strcpy(& active_connection->client_name, client_name);
#line 888
  s_strcpy(& active_connection->client_version, client_version);
  }
#line 889
  return ((Success )OK);
}
}
#line 892 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success get_client_name(Session_no session_no , String *result ) 
{ 
  Connection *cptr ;
  Bool tmp ;

  {
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 898
      err_stat = 0UL;
#line 898
      kom_errno = (enum kom_err )51;
#line 898
      return ((Success )FAILURE);
    }
#line 898
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 899
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 899
    if (! active_connection) {
#line 899
      err_stat = 0UL;
#line 899
      kom_errno = (enum kom_err )6;
#line 899
      return ((Success )FAILURE);
    } else
#line 899
    if (! active_connection->pers_no) {
#line 899
      err_stat = 0UL;
#line 899
      kom_errno = (enum kom_err )6;
#line 899
      return ((Success )FAILURE);
    }
#line 899
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 901
  cptr = get_conn_by_number(session_no);
  }
#line 903
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 903
    tmp = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 903
    if (tmp) {
#line 905
      *result = cptr->client_name;
#line 906
      return ((Success )OK);
    } else {
#line 910
      err_stat = session_no;
#line 911
      kom_errno = (enum kom_err )42;
#line 912
      return ((Success )FAILURE);
    }
  } else {
#line 910
    err_stat = session_no;
#line 911
    kom_errno = (enum kom_err )42;
#line 912
    return ((Success )FAILURE);
  }
}
}
#line 916 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success get_client_version(Session_no session_no , String *result ) 
{ 
  Connection *cptr ;
  Bool tmp ;

  {
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 922
      err_stat = 0UL;
#line 922
      kom_errno = (enum kom_err )51;
#line 922
      return ((Success )FAILURE);
    }
#line 922
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 923
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 923
    if (! active_connection) {
#line 923
      err_stat = 0UL;
#line 923
      kom_errno = (enum kom_err )6;
#line 923
      return ((Success )FAILURE);
    } else
#line 923
    if (! active_connection->pers_no) {
#line 923
      err_stat = 0UL;
#line 923
      kom_errno = (enum kom_err )6;
#line 923
      return ((Success )FAILURE);
    }
#line 923
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 925
  cptr = get_conn_by_number(session_no);
  }
#line 927
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 927
    tmp = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 927
    if (tmp) {
#line 929
      *result = cptr->client_version;
#line 930
      return ((Success )OK);
    } else {
#line 934
      err_stat = session_no;
#line 935
      kom_errno = (enum kom_err )42;
#line 936
      return ((Success )FAILURE);
    }
  } else {
#line 934
    err_stat = session_no;
#line 935
    kom_errno = (enum kom_err )42;
#line 936
    return ((Success )FAILURE);
  }
}
}
#line 941 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success accept_async(Number_list *num_list ) 
{ 
  int i ;
  Success result ;
  int found ;

  {
  {
#line 949
  while (1) {
    while_continue: /* CIL Label */ ;
#line 949
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 949
      err_stat = 0UL;
#line 949
      kom_errno = (enum kom_err )51;
#line 949
      return ((Success )FAILURE);
    }
#line 949
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 951
  result = (Success )OK;
#line 956
  if (num_list->length > param.accept_async_len) {
#line 958
    err_stat = 0UL;
#line 959
    kom_errno = (enum kom_err )46;
#line 960
    return ((Success )FAILURE);
  }
#line 968
  i = 0;
  {
#line 968
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 968
    if (! (i < 23)) {
#line 968
      goto while_break___0;
    }
#line 970
    active_connection->want_async[i] = (Bool )0;
#line 968
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 979
  i = 0;
  {
#line 979
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 979
    if (! (i < num_list->length)) {
#line 979
      goto while_break___1;
    }
#line 981
    found = 0;
#line 982
    if (*(num_list->data + i) >= 0L) {
#line 982
      if (*(num_list->data + i) < 23L) {
        {
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 22U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 21U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 20U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 19U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 18U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 17U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 16U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 15U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 14U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 13U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 12U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 11U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 9U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 8U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 7U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 6U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 5U) {
#line 1004
          goto case_22;
        }
#line 1004
        if ((unsigned int )((enum async )*(num_list->data + i)) == 0U) {
#line 1004
          goto case_22;
        }
#line 1011
        if ((unsigned int )((enum async )*(num_list->data + i)) == 23U) {
#line 1011
          goto case_23;
        }
#line 985
        goto switch_break;
        case_22: /* CIL Label */ 
        case_21: /* CIL Label */ 
        case_20: /* CIL Label */ 
        case_19: /* CIL Label */ 
        case_18: /* CIL Label */ 
        case_17: /* CIL Label */ 
        case_16: /* CIL Label */ 
        case_15: /* CIL Label */ 
        case_14: /* CIL Label */ 
        case_13: /* CIL Label */ 
        case_12: /* CIL Label */ 
        case_11: /* CIL Label */ 
        case_9: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_7: /* CIL Label */ 
        case_6: /* CIL Label */ 
        case_5: /* CIL Label */ 
        case_0: /* CIL Label */ 
#line 1008
        found = 1;
#line 1009
        active_connection->want_async[*(num_list->data + i)] = (Bool )1;
#line 1010
        goto switch_break;
        case_23: /* CIL Label */ 
#line 1012
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 1019
    if (! found) {
#line 1019
      if ((unsigned long )result == (unsigned long )OK) {
#line 1021
        err_stat = (unsigned long )*(num_list->data + i);
#line 1022
        kom_errno = (enum kom_err )50;
#line 1023
        result = (Success )FAILURE;
      }
    }
#line 979
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1027
  return (result);
}
}
#line 1035 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
static long temp[23]  ;
#line 1031 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success query_async(Number_list *result ) 
{ 
  int i ;

  {
  {
#line 1038
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1038
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1038
      err_stat = 0UL;
#line 1038
      kom_errno = (enum kom_err )51;
#line 1038
      return ((Success )FAILURE);
    }
#line 1038
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1039
  result->length = 0;
#line 1040
  i = 0;
  {
#line 1040
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1040
    if (! (i < 23)) {
#line 1040
      goto while_break___0;
    }
#line 1042
    if ((unsigned int )active_connection->want_async[i] != 0U) {
#line 1044
      temp[result->length] = (long )i;
#line 1045
      (result->length) ++;
    }
#line 1040
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1048
  result->data = temp;
#line 1050
  return ((Success )OK);
}
}
#line 1053 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success user_active(void) 
{ 


  {
  {
#line 1056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1056
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1056
      err_stat = 0UL;
#line 1056
      kom_errno = (enum kom_err )51;
#line 1056
      return ((Success )FAILURE);
    }
#line 1056
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1057
  active_connection->active_time = current_time;
#line 1058
  active_connection->flags.user_active_used = 1U;
#line 1059
  return ((Success )OK);
}
}
#line 1062 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/session.c"
extern Success set_connection_time_format(int use_utc ) 
{ 


  {
  {
#line 1065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1065
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1065
      err_stat = 0UL;
#line 1065
      kom_errno = (enum kom_err )51;
#line 1065
      return ((Success )FAILURE);
    }
#line 1065
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1066
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1066
    if (use_utc != 0) {
#line 1066
      if (use_utc != 1) {
#line 1066
        err_stat = 0UL;
#line 1066
        kom_errno = (enum kom_err )61;
#line 1066
        return ((Success )FAILURE);
      }
    }
#line 1066
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1067
  active_connection->use_utc = (Bool )use_utc;
#line 1068
  return ((Success )OK);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 182 "./../include/services.h"
extern Success get_membership_old(Pers_no pers_no , unsigned short first , unsigned short no_of_confs ,
                                  Bool want_read_texts , Membership_list *memberships ) ;
#line 189
extern Success get_membership_10(Pers_no pers_no , unsigned short first , unsigned short no_of_confs ,
                                 Bool want_read_texts , Membership_list *memberships ) ;
#line 196
extern Success get_membership(Pers_no pers_no , unsigned short first , unsigned short no_of_confs ,
                              Bool want_read_ranges , unsigned long max_ranges , Membership_list *memberships ) ;
#line 238
Success get_unread_confs(Pers_no pers_no , Conf_no_list *result ) ;
#line 331
extern Success get_members(Conf_no conf_no , unsigned short first , unsigned short no_of_members ,
                           Member_list *members ) ;
#line 337
extern Success get_members_old(Conf_no conf_no , unsigned short first , unsigned short no_of_members ,
                               Member_list *members ) ;
#line 346
extern Success add_member(Conf_no conf_no , Pers_no pers_no , unsigned char priority ,
                          unsigned short where , Membership_type *type ) ;
#line 353
extern Success add_member_old(Conf_no conf_no , Pers_no pers_no , unsigned char priority ,
                              unsigned short where ) ;
#line 359
extern Success set_membership_type(Pers_no pers_no , Conf_no conf_no , Membership_type *type ) ;
#line 365
extern Success sub_member(Conf_no conf_no , Pers_no pers_no ) ;
#line 378
extern Success set_unread(Conf_no conf_no , Text_no no_of_unread ) ;
#line 382
extern Success set_last_read(Conf_no conf_no , Local_text_no last_read ) ;
#line 494
extern Success mark_as_read(Conf_no conference , Number_list const   *texts ) ;
#line 498
extern Success mark_as_unread(Conf_no conference , Local_text_no lno ) ;
#line 503
Success set_read_ranges(Conf_no conference , struct read_range_list  const  *read_ranges ) ;
#line 295 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/manipulate.h"
Member *locate_member(Pers_no pers_no , Conference *conf_c ) ;
#line 460
extern void forced_leave_conf(Pers_no pers_no , Conf_no conf_no ) ;
#line 138 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache.h"
extern Local_text_no cached_get_highest_local_no(Conf_no conf_no ) ;
#line 49 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.h"
Text_no l2g_lookup(Local_to_global const   *l2g , Local_text_no lno ) ;
#line 53 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.h"
extern void foutput_membership(FILE *fp , Membership *mship ) ;
#line 75 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static void set_membership_type_bits(Membership_type *type , Bool invitation , Bool passive ,
                                     Bool secret , Bool passive_message_invert , Bool reserved2 ,
                                     Bool reserved3 , Bool reserved4 , Bool reserved5 ) 
{ 


  {
#line 86
  type->invitation = (unsigned int )invitation;
#line 87
  type->passive = (unsigned int )passive;
#line 88
  type->secret = (unsigned int )secret;
#line 89
  type->passive_message_invert = (unsigned int )passive_message_invert;
#line 90
  type->reserved2 = (unsigned int )reserved2;
#line 91
  type->reserved3 = (unsigned int )reserved3;
#line 92
  type->reserved4 = (unsigned int )reserved4;
#line 93
  type->reserved5 = (unsigned int )reserved5;
#line 94
  return;
}
}
#line 97 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static enum memb_visibility check_unread(Pers_no member___0 ) 
{ 
  Person *memb_p ;

  {
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    memb_p = cached_get_person_stat(member___0);
    }
#line 101
    if ((unsigned long )memb_p == (unsigned long )((void *)0)) {
#line 101
      return ((enum memb_visibility )0);
    }
#line 101
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if (memb_p->flags.unread_is_secret) {
#line 103
    return ((enum memb_visibility )1);
  } else {
#line 105
    return ((enum memb_visibility )2);
  }
}
}
#line 109 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
enum memb_visibility membership_visible(Connection const   *viewer_conn , Pers_no member___0 ,
                                        Conf_no conf_no , Membership_type type , Bool is_supervisor_of_member ,
                                        Bool is_supervisor_of_conf ) 
{ 
  enum access ma ;
  enum access ca ;
  enum memb_visibility tmp ;
  enum memb_visibility tmp___0 ;

  {
#line 118
  ma = (enum access )0;
#line 119
  ca = (enum access )0;
#line 121
  if ((int const   )viewer_conn->ena_level >= 2) {
#line 121
    if (viewer_conn->person) {
#line 121
      if ((viewer_conn->person)->privileges.admin) {
#line 122
        return ((enum memb_visibility )2);
      } else {
#line 121
        goto _L___0;
      }
    } else {
#line 121
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 121
  if ((int const   )viewer_conn->ena_level >= 8) {
#line 121
    if (viewer_conn->person) {
#line 121
      if ((viewer_conn->person)->privileges.wheel) {
#line 122
        return ((enum memb_visibility )2);
      }
    }
  }
#line 124
  if (is_supervisor_of_member) {
#line 127
    return ((enum memb_visibility )2);
  } else {
    {
#line 124
    ma = access_perm(member___0, viewer_conn, (enum access )5);
    }
#line 124
    if ((unsigned int )ma >= 5U) {
#line 127
      return ((enum memb_visibility )2);
    }
  }
#line 130
  if (is_supervisor_of_conf) {
    {
#line 133
    tmp = check_unread(member___0);
    }
#line 133
    return (tmp);
  } else {
    {
#line 130
    ca = access_perm(conf_no, viewer_conn, (enum access )5);
    }
#line 130
    if ((unsigned int )ca >= 5U) {
      {
#line 133
      tmp = check_unread(member___0);
      }
#line 133
      return (tmp);
    }
  }
#line 136
  if ((unsigned int )ma >= 2U) {
#line 136
    if ((unsigned int )ca >= 2U) {
#line 136
      if (! type.secret) {
        {
#line 137
        tmp___0 = check_unread(member___0);
        }
#line 137
        return (tmp___0);
      }
    }
  }
#line 139
  return ((enum memb_visibility )0);
}
}
#line 148 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static void copy_public_confs(Connection *conn , Pers_no pers_no , Person *censor_p ,
                              Person *orig_p , Bool keep_read , Bool want_read , unsigned long max_ranges ) 
{ 
  int i ;
  Membership *censor_m ;
  Membership *orig_m ;
  void *tmp ;
  enum memb_visibility vis ;
  enum memb_visibility tmp___0 ;

  {
  {
#line 163
  tmp = tmp_alloc((unsigned long )orig_p->conferences.no_of_confs * sizeof(Membership ));
#line 163
  censor_p->conferences.confs = (Membership *)tmp;
#line 165
  censor_p->conferences.no_of_confs = (unsigned short)0;
#line 167
  censor_m = censor_p->conferences.confs;
#line 168
  orig_m = orig_p->conferences.confs;
#line 170
  i = 0;
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i < (int )orig_p->conferences.no_of_confs)) {
#line 170
      goto while_break;
    }
    {
#line 172
    tmp___0 = membership_visible((Connection const   *)conn, pers_no, orig_m->conf_no,
                                 orig_m->type, (Bool )0, (Bool )0);
#line 172
    vis = tmp___0;
    }
#line 175
    if ((unsigned int )vis > 0U) {
#line 177
      *censor_m = *orig_m;
#line 179
      if (! want_read) {
#line 181
        if (keep_read) {
#line 182
          censor_m->skip_read_texts = (Bool )1;
        } else {
#line 184
          censor_m->read_ranges = (struct read_range *)((void *)0);
        }
      } else
#line 188
      if (max_ranges > 0UL) {
#line 188
        if ((unsigned long )censor_m->no_of_read_ranges > max_ranges) {
#line 189
          censor_m->no_of_read_ranges = (unsigned int )max_ranges;
        }
      }
#line 192
      if ((unsigned int )vis == 1U) {
#line 194
        censor_m->last_time_read = (time_t )0;
#line 195
        censor_m->no_of_read_ranges = 0U;
#line 196
        censor_m->read_ranges = (struct read_range *)((void *)0);
      }
#line 199
      censor_m ++;
#line 200
      censor_p->conferences.no_of_confs = (unsigned short )((int )censor_p->conferences.no_of_confs + 1);
    }
#line 170
    i ++;
#line 170
    orig_m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return;
}
}
#line 209 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static void do_change_priority(Membership *mship , Conf_no conf_no , Conference *conf_c ,
                               unsigned char priority , unsigned short where , Pers_no pers_no ,
                               Person *pers_p , Membership_type *type , Bool fake_passive ) 
{ 
  Membership tmp_conf ;
  Member *mem ;

  {
#line 223
  if ((int )priority == 0) {
#line 223
    if (fake_passive) {
#line 225
      type->passive = 1U;
    } else {
#line 229
      mship->priority = priority;
    }
  } else {
#line 229
    mship->priority = priority;
  }
#line 232
  mship->type = *type;
#line 236
  if ((int )where >= (int )pers_p->conferences.no_of_confs) {
#line 238
    where = (unsigned short )((int )pers_p->conferences.no_of_confs - 1);
  }
#line 243
  if ((unsigned long )mship < (unsigned long )(pers_p->conferences.confs + (int )where)) {
#line 245
    tmp_conf = *mship;
    {
#line 246
    while (1) {
      while_continue: /* CIL Label */ ;
#line 246
      if (! ((unsigned long )mship < (unsigned long )(pers_p->conferences.confs + (int )where))) {
#line 246
        goto while_break;
      }
#line 248
      *mship = *(mship + 1);
#line 249
      mship ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 251
    *mship = tmp_conf;
  } else {
#line 255
    tmp_conf = *mship;
    {
#line 256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 256
      if (! ((unsigned long )mship > (unsigned long )(pers_p->conferences.confs + (int )where))) {
#line 256
        goto while_break___0;
      }
#line 258
      *mship = *(mship - 1);
#line 259
      mship --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 261
    *mship = tmp_conf;
  }
  {
#line 265
  mem = locate_member(pers_no, conf_c);
  }
#line 266
  if ((unsigned long )mem != (unsigned long )((void *)0)) {
    {
#line 268
    mem->type = *type;
#line 269
    mark_conference_as_changed(conf_no);
    }
  }
  {
#line 272
  mark_person_as_changed(pers_no);
  }
#line 273
  return;
}
}
#line 286 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static void do_add_rec_time(Text_stat *text_stat_ptr , int pos ) 
{ 
  int i ;
  void *tmp ;

  {
#line 293
  if (pos < 0) {
    {
#line 295
    restart_kom("do_add_rec_time() - illegal pos\n");
    }
  } else
#line 293
  if (pos > (int )text_stat_ptr->no_of_misc) {
    {
#line 295
    restart_kom("do_add_rec_time() - illegal pos\n");
    }
  }
#line 300
  if (pos < (int )text_stat_ptr->no_of_misc) {
#line 300
    if ((unsigned int )(text_stat_ptr->misc_items + pos)->type == 7U) {
#line 303
      return;
    }
  }
  {
#line 307
  text_stat_ptr->no_of_misc = (unsigned short )((int )text_stat_ptr->no_of_misc + 1);
#line 307
  tmp = srealloc((void *)text_stat_ptr->misc_items, (unsigned long )text_stat_ptr->no_of_misc * sizeof(Misc_info ));
#line 307
  text_stat_ptr->misc_items = (Misc_info *)tmp;
#line 313
  i = (int )text_stat_ptr->no_of_misc - 1;
  }
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! (i > pos)) {
#line 313
      goto while_break;
    }
#line 315
    *(text_stat_ptr->misc_items + i) = *(text_stat_ptr->misc_items + (i - 1));
#line 313
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  (text_stat_ptr->misc_items + pos)->type = (enum info_type )7;
#line 322
  (text_stat_ptr->misc_items + pos)->datum.received_at = current_time.tv_sec;
#line 323
  return;
}
}
#line 331 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static void add_rec_time(Conference *conf_c , Local_text_no local_no , Pers_no pers_no ) 
{ 
  Bool found ;
  Text_no text_no ;
  Text_stat *t_stat ;
  int i ;

  {
  {
#line 341
  text_no = l2g_lookup((Local_to_global const   *)(& conf_c->texts), local_no);
  }
#line 343
  if (text_no == 0UL) {
#line 345
    return;
  }
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 348
    t_stat = cached_get_text_stat(text_no);
    }
#line 348
    if ((unsigned long )t_stat == (unsigned long )((void *)0)) {
#line 348
      return;
    }
#line 348
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  found = (Bool )0;
#line 352
  i = 0;
  {
#line 352
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 352
    if (! found) {
#line 352
      if (! (i < (int )t_stat->no_of_misc)) {
#line 352
        goto while_break___0;
      }
    } else {
#line 352
      goto while_break___0;
    }
    {
#line 358
    if ((unsigned int )(t_stat->misc_items + i)->type == 15U) {
#line 358
      goto case_15;
    }
#line 358
    if ((unsigned int )(t_stat->misc_items + i)->type == 1U) {
#line 358
      goto case_15;
    }
#line 358
    if ((unsigned int )(t_stat->misc_items + i)->type == 0U) {
#line 358
      goto case_15;
    }
#line 373
    if ((unsigned int )(t_stat->misc_items + i)->type == 9U) {
#line 373
      goto case_9;
    }
#line 373
    if ((unsigned int )(t_stat->misc_items + i)->type == 8U) {
#line 373
      goto case_9;
    }
#line 373
    if ((unsigned int )(t_stat->misc_items + i)->type == 7U) {
#line 373
      goto case_9;
    }
#line 373
    if ((unsigned int )(t_stat->misc_items + i)->type == 6U) {
#line 373
      goto case_9;
    }
#line 373
    if ((unsigned int )(t_stat->misc_items + i)->type == 5U) {
#line 373
      goto case_9;
    }
#line 373
    if ((unsigned int )(t_stat->misc_items + i)->type == 4U) {
#line 373
      goto case_9;
    }
#line 373
    if ((unsigned int )(t_stat->misc_items + i)->type == 3U) {
#line 373
      goto case_9;
    }
#line 373
    if ((unsigned int )(t_stat->misc_items + i)->type == 2U) {
#line 373
      goto case_9;
    }
#line 377
    goto switch_default;
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 359
    if ((int )(t_stat->misc_items + i)->datum.recipient == (int )pers_no) {
      {
#line 361
      do_add_rec_time(t_stat, i + 2);
#line 362
      found = (Bool )1;
      }
    }
#line 364
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 374
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 378
    restart_kom("ERROR: bogus misc_info type detected in text %lu\n", text_no);
    }
    switch_break: /* CIL Label */ ;
    }
#line 352
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 382
  if ((unsigned int )found == 0U) {
    {
#line 384
    kom_log("ERROR: add_rec_time(): found==FALSE\n");
    }
  }
  {
#line 387
  mark_text_as_changed(text_no);
  }
#line 388
  return;
}
}
#line 401 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
Bool adjust_read(Membership *m , Conference const   *conf ) 
{ 
  struct read_range *ptr ;
  struct read_range *prev ;
  struct read_range *next ;
  struct read_range *tail ;
  struct read_range *begin ;
  struct read_range *end ;
  Bool change ;
  Local_text_no conf_max ;
  Local_text_no conf_min ;
  Local_text_no past_block ;
  Local_text_no limit___0 ;
  Text_no tmp ;
  void *tmp___0 ;

  {
#line 411
  change = (Bool )0;
#line 420
  if (m->no_of_read_ranges == 0U) {
#line 421
    return (change);
  }
  {
#line 424
  conf_min = l2g_next_key(& conf->texts, (Local_text_no )0);
  }
#line 425
  if (conf_min == 0UL) {
    {
#line 426
    conf_min = l2g_first_appendable_key(& conf->texts);
    }
  }
  {
#line 427
  conf_max = l2g_first_appendable_key(& conf->texts);
#line 429
  begin = m->read_ranges + 0;
#line 430
  end = begin + m->no_of_read_ranges;
#line 437
  ptr = begin;
  }
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 437
      goto while_break;
    }
#line 439
    if (ptr->first_read > ptr->last_read) {
      {
#line 441
      kom_log("Bad input to adjust_read. Conference %lu, Priority %lu. Range %lu-%lu is nonsensical.\n",
              (unsigned long )m->conf_no, (unsigned long )m->priority, ptr->first_read,
              ptr->last_read);
      }
#line 447
      return (change);
    }
#line 450
    if ((unsigned long )ptr != (unsigned long )begin) {
#line 450
      if ((ptr - 1)->last_read >= ptr->first_read) {
        {
#line 452
        kom_log("Bad input to adjust_read. Conference %lu, Priority %lu. Overlapping ranges: %lu-%lu, %lu-%lu.\n",
                (unsigned long )m->conf_no, (unsigned long )m->priority, (ptr - 1)->first_read,
                (ptr - 1)->last_read, ptr->first_read, ptr->last_read);
        }
#line 460
        return (change);
      }
    }
#line 437
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  ptr = begin;
  {
#line 465
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 465
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 465
      goto while_break___0;
    }
#line 467
    if ((unsigned long )ptr == (unsigned long )begin) {
#line 468
      prev = (struct read_range *)((void *)0);
    } else {
#line 470
      prev = ptr - 1;
    }
#line 471
    next = ptr + 1;
#line 472
    if ((unsigned long )next == (unsigned long )end) {
#line 473
      next = (struct read_range *)((void *)0);
    }
    {
#line 476
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 476
      if (ptr->first_read > 1UL) {
#line 476
        if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 476
          goto _L;
        } else
#line 476
        if (prev->last_read + 1UL < ptr->first_read) {
          _L: /* CIL Label */ 
          {
#line 476
          tmp = l2g_lookup(& conf->texts, ptr->first_read - 1UL);
          }
#line 476
          if (! (tmp == 0UL)) {
#line 476
            goto while_break___1;
          }
        } else {
#line 476
          goto while_break___1;
        }
      } else {
#line 476
        goto while_break___1;
      }
#line 480
      change = (Bool )1;
#line 481
      (ptr->first_read) --;
#line 482
      if (ptr->first_read < conf_min) {
#line 483
        ptr->first_read = (Local_text_no )1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 487
    past_block = l2g_next_key(& conf->texts, ptr->last_read);
    }
#line 488
    if ((unsigned long )next != (unsigned long )((void *)0)) {
#line 489
      limit___0 = next->first_read;
    } else {
#line 491
      limit___0 = conf_max;
    }
#line 493
    if (past_block == 0UL) {
#line 494
      past_block = limit___0;
    } else
#line 493
    if (past_block > limit___0) {
#line 494
      past_block = limit___0;
    }
#line 495
    if (ptr->last_read != past_block - 1UL) {
#line 497
      ptr->last_read = past_block - 1UL;
#line 498
      change = (Bool )1;
    }
#line 465
    ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 503
  tail = begin;
#line 504
  ptr = begin + 1;
  {
#line 504
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 504
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 504
      goto while_break___2;
    }
#line 506
    if (tail->last_read + 1UL == ptr->first_read) {
#line 507
      tail->last_read = ptr->last_read;
    } else {
#line 508
      tail ++;
#line 508
      if ((unsigned long )tail != (unsigned long )ptr) {
#line 509
        *tail = *ptr;
      }
    }
#line 504
    ptr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 511
  if ((unsigned long )end != (unsigned long )(tail + 1)) {
    {
#line 513
    end = tail + 1;
#line 514
    m->no_of_read_ranges = (unsigned int )(end - begin);
#line 515
    tmp___0 = srealloc((void *)m->read_ranges, (unsigned long )m->no_of_read_ranges * sizeof(*(m->read_ranges + 0)));
#line 515
    m->read_ranges = (struct read_range *)tmp___0;
#line 518
    change = (Bool )1;
    }
  }
#line 526
  ptr = begin;
  {
#line 526
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 526
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 526
      goto while_break___3;
    }
#line 528
    if (ptr->first_read > ptr->last_read) {
      {
#line 530
      kom_log("Bug in adjust_read. Conference %lu, Priority %lu. Range %lu-%lu is nonsensical (fixed).\n",
              (unsigned long )m->conf_no, (unsigned long )m->priority, ptr->first_read,
              ptr->last_read);
#line 536
      ptr->last_read = ptr->first_read;
#line 537
      change = (Bool )1;
      }
#line 538
      return (change);
    }
#line 541
    if ((unsigned long )ptr != (unsigned long )begin) {
#line 541
      if (ptr->first_read <= (ptr - 1)->last_read) {
        {
#line 543
        kom_log("Bug in adjust_read. Conference %lu, Priority %lu. %lu not greater than %lu (fixed).\n",
                (unsigned long )m->conf_no, (unsigned long )m->priority, ptr->first_read,
                (ptr - 1)->last_read);
#line 549
        sfree((void *)m->read_ranges);
#line 550
        m->read_ranges = (struct read_range *)((void *)0);
#line 551
        m->no_of_read_ranges = 0U;
#line 552
        change = (Bool )1;
        }
#line 553
        return (change);
      }
    }
#line 526
    ptr ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 557
  return (change);
}
}
#line 568 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static Success insert_loc_no(Local_text_no text , Membership *m ) 
{ 
  struct read_range *lo ;
  struct read_range *hi ;
  struct read_range *mid ;
  struct read_range *begin ;
  struct read_range *end ;
  ptrdiff_t save ;
  struct read_range *gap ;
  struct read_range *move ;
  void *tmp ;
  void *tmp___0 ;
  Local_text_no tmp___1 ;

  {
#line 581
  if (m->no_of_read_ranges == 0U) {
    {
#line 583
    tmp = smalloc(sizeof(*(m->read_ranges + 0)));
#line 583
    m->read_ranges = (struct read_range *)tmp;
#line 584
    m->no_of_read_ranges = 1U;
#line 585
    (m->read_ranges + 0)->first_read = text;
#line 586
    (m->read_ranges + 0)->last_read = text;
    }
#line 587
    return ((Success )OK);
  }
#line 590
  lo = m->read_ranges + 0;
#line 590
  begin = lo;
#line 591
  hi = lo + m->no_of_read_ranges;
#line 591
  end = hi;
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 593
    if (! (hi - lo > 1L)) {
#line 593
      goto while_break;
    }
#line 595
    mid = lo + (hi - lo) / 2L;
#line 596
    if (text < mid->first_read - 1UL) {
#line 597
      hi = mid;
    } else
#line 598
    if (text > mid->last_read + 1UL) {
#line 599
      lo = mid;
    } else {
#line 602
      lo = mid;
#line 603
      hi = mid + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 607
  if (text >= lo->first_read) {
#line 607
    if (text <= lo->last_read) {
#line 608
      return ((Success )FAILURE);
    }
  }
#line 610
  if (text == lo->first_read - 1UL) {
#line 612
    if ((unsigned long )lo > (unsigned long )begin) {
#line 612
      if (text == (lo - 1)->last_read) {
#line 613
        return ((Success )FAILURE);
      }
    }
#line 615
    lo->first_read = text;
#line 616
    return ((Success )OK);
  }
#line 619
  if (text == lo->last_read + 1UL) {
#line 621
    if ((unsigned long )lo < (unsigned long )end) {
#line 621
      if ((unsigned long )(lo + 1) < (unsigned long )end) {
#line 621
        if (text == (lo + 1)->first_read) {
#line 622
          return ((Success )FAILURE);
        }
      }
    }
#line 624
    lo->last_read = text;
#line 625
    return ((Success )OK);
  }
#line 629
  if (lo->last_read < text) {
#line 630
    lo ++;
  }
  {
#line 632
  save = lo - begin;
#line 633
  (m->no_of_read_ranges) ++;
#line 633
  tmp___0 = srealloc((void *)m->read_ranges, (unsigned long )m->no_of_read_ranges * sizeof(*(m->read_ranges + 0)));
#line 633
  m->read_ranges = (struct read_range *)tmp___0;
#line 636
  begin = m->read_ranges + 0;
#line 637
  gap = begin + save;
#line 638
  end = begin + m->no_of_read_ranges;
#line 639
  move = end - 1;
  }
  {
#line 639
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 639
    if (! ((unsigned long )move > (unsigned long )gap)) {
#line 639
      goto while_break___0;
    }
#line 640
    *move = *(move - 1);
#line 639
    move --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 641
  tmp___1 = text;
#line 641
  gap->last_read = tmp___1;
#line 641
  gap->first_read = tmp___1;
#line 642
  return ((Success )OK);
}
}
#line 645 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static void remove_loc_no(Local_text_no text , Membership *m ) 
{ 
  struct read_range *lo ;
  struct read_range *hi ;
  struct read_range *mid ;
  struct read_range *begin ;
  struct read_range *end ;
  ptrdiff_t save ;
  struct read_range *gap ;
  struct read_range *move ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 658
  if (m->no_of_read_ranges == 0U) {
#line 659
    return;
  }
#line 661
  lo = m->read_ranges + 0;
#line 661
  begin = lo;
#line 662
  hi = lo + m->no_of_read_ranges;
#line 662
  end = hi;
  {
#line 664
  while (1) {
    while_continue: /* CIL Label */ ;
#line 664
    if (! (hi - lo > 1L)) {
#line 664
      goto while_break;
    }
#line 666
    mid = lo + (hi - lo) / 2L;
#line 667
    if (text < mid->first_read - 1UL) {
#line 668
      hi = mid;
    } else
#line 669
    if (text > mid->last_read + 1UL) {
#line 670
      lo = mid;
    } else {
#line 673
      lo = mid;
#line 674
      hi = mid + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  if (text < lo->first_read) {
#line 679
    return;
  } else
#line 678
  if (text > lo->last_read) {
#line 679
    return;
  }
#line 681
  if (text == lo->first_read) {
#line 683
    if (lo->first_read != lo->last_read) {
#line 686
      (lo->first_read) ++;
#line 687
      return;
    }
#line 691
    move = lo;
    {
#line 691
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 691
      if (! ((unsigned long )move < (unsigned long )(end - 1))) {
#line 691
        goto while_break___0;
      }
#line 692
      *move = *(move + 1);
#line 691
      move ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 693
    (m->no_of_read_ranges) --;
#line 694
    if (m->no_of_read_ranges == 0U) {
      {
#line 696
      sfree((void *)m->read_ranges);
#line 697
      m->read_ranges = (struct read_range *)((void *)0);
      }
    } else {
      {
#line 700
      tmp = srealloc((void *)m->read_ranges, (unsigned long )m->no_of_read_ranges * sizeof(*(m->read_ranges + 0)));
#line 700
      m->read_ranges = (struct read_range *)tmp;
      }
    }
#line 704
    return;
  }
#line 707
  if (text == lo->last_read) {
#line 709
    if (! (text != lo->first_read)) {
      {
#line 709
      __assert_fail("text != lo->first_read", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c",
                    709U, "remove_loc_no");
      }
    }
#line 712
    (lo->last_read) --;
#line 713
    return;
  }
#line 716
  if (lo->first_read < text) {
#line 716
    if (! (text < lo->last_read)) {
      {
#line 716
      __assert_fail("lo->first_read < text && text < lo->last_read", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c",
                    716U, "remove_loc_no");
      }
    }
  } else {
    {
#line 716
    __assert_fail("lo->first_read < text && text < lo->last_read", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c",
                  716U, "remove_loc_no");
    }
  }
  {
#line 719
  save = lo - begin;
#line 720
  (m->no_of_read_ranges) ++;
#line 720
  tmp___0 = srealloc((void *)m->read_ranges, (unsigned long )m->no_of_read_ranges * sizeof(*(m->read_ranges + 0)));
#line 720
  m->read_ranges = (struct read_range *)tmp___0;
#line 723
  begin = m->read_ranges + 0;
#line 724
  gap = begin + save;
#line 725
  end = begin + m->no_of_read_ranges;
#line 726
  move = end - 1;
  }
  {
#line 726
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 726
    if (! ((unsigned long )move > (unsigned long )gap)) {
#line 726
      goto while_break___1;
    }
#line 727
    *move = *(move - 1);
#line 726
    move --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 729
  if (! (gap->first_read == (gap + 1)->first_read)) {
    {
#line 729
    __assert_fail("gap->first_read == (gap+1)->first_read", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c",
                  729U, "remove_loc_no");
    }
  }
#line 730
  if (! (gap->last_read == (gap + 1)->last_read)) {
    {
#line 730
    __assert_fail("gap->last_read == (gap+1)->last_read", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c",
                  730U, "remove_loc_no");
    }
  }
#line 731
  if (! (text > gap->first_read)) {
    {
#line 731
    __assert_fail("text > gap->first_read", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c",
                  731U, "remove_loc_no");
    }
  }
#line 732
  if (! (text < gap->last_read)) {
    {
#line 732
    __assert_fail("text < gap->last_read", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c",
                  732U, "remove_loc_no");
    }
  }
#line 734
  gap->last_read = text - 1UL;
#line 735
  (gap + 1)->first_read = text + 1UL;
#line 736
  return;
}
}
#line 744 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static void send_async_new_membership(Pers_no pers_no , Conf_no conf_no ) 
{ 
  Connection *cptr ;
  Session_no i ;

  {
#line 748
  cptr = (Connection *)((void *)0);
#line 749
  i = (Session_no )0;
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 751
    i = traverse_connections(i);
    }
#line 751
    if (! (i != 0UL)) {
#line 751
      goto while_break;
    }
    {
#line 753
    cptr = get_conn_by_number(i);
    }
#line 754
    if ((int )cptr->pers_no == (int )pers_no) {
      {
#line 756
      async_new_membership(cptr, pers_no, conf_no);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 759
  return;
}
}
#line 764 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
__inline static Local_text_no last_text_read(Membership const   *mship ) 
{ 


  {
#line 767
  if (mship->no_of_read_ranges == 0U) {
#line 768
    return ((Local_text_no )0);
  }
#line 769
  if ((mship->read_ranges + 0)->first_read > 1UL) {
#line 770
    return ((Local_text_no )0);
  }
#line 771
  return ((mship->read_ranges + 0)->last_read);
}
}
#line 790 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
void do_add_member(Conf_no conf_no , Conference *conf_c , Pers_no pers_no , Person *pers_p ,
                   Pers_no added_by , unsigned char priority , unsigned short where ,
                   Membership_type *type , Bool fake_passive ) 
{ 
  Membership *mship ;
  Member *mem ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 806
  if (fake_passive) {
#line 806
    if ((int )priority == 0) {
#line 808
      type->passive = 1U;
    }
  }
  {
#line 816
  pers_p->conferences.no_of_confs = (unsigned short )((int )pers_p->conferences.no_of_confs + 1);
#line 816
  tmp = srealloc((void *)pers_p->conferences.confs, (unsigned long )pers_p->conferences.no_of_confs * sizeof(Membership ));
#line 816
  pers_p->conferences.confs = (Membership *)tmp;
#line 823
  mship = (pers_p->conferences.confs + (int )pers_p->conferences.no_of_confs) - 1;
  }
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! ((unsigned long )mship > (unsigned long )(pers_p->conferences.confs + (int )where))) {
#line 826
      goto while_break;
    }
#line 828
    *mship = *(mship - 1);
#line 829
    mship --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 832
  init_membership(mship);
#line 834
  mship->added_by = added_by;
#line 835
  mship->added_at = current_time.tv_sec;
#line 836
  mship->conf_no = conf_no;
#line 837
  mship->priority = priority;
#line 838
  mship->last_time_read = current_time.tv_sec;
#line 839
  mship->no_of_read_ranges = 0U;
#line 840
  mship->read_ranges = (struct read_range *)((void *)0);
#line 841
  mship->type = *type;
#line 842
  mship->skip_read_texts = (Bool )0;
#line 846
  conf_c->members.no_of_members = (unsigned short )((int )conf_c->members.no_of_members + 1);
#line 846
  tmp___0 = srealloc((void *)conf_c->members.members, (unsigned long )conf_c->members.no_of_members * sizeof(Member ));
#line 846
  conf_c->members.members = (Member *)tmp___0;
#line 852
  mem = (conf_c->members.members + (int )conf_c->members.no_of_members) - 1;
#line 853
  mem->member = pers_no;
#line 854
  mem->added_by = added_by;
#line 855
  mem->added_at = current_time.tv_sec;
#line 856
  mem->type = *type;
#line 858
  mark_conference_as_changed(conf_no);
#line 859
  mark_person_as_changed(pers_no);
  }
#line 861
  return;
}
}
#line 869 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern void forced_leave_conf(Pers_no pers_no , Conf_no conf_no ) 
{ 
  Connection *real_active_connection ;
  Session_no i ;

  {
#line 874
  i = (Session_no )0;
#line 876
  real_active_connection = active_connection;
  {
#line 878
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 878
    i = traverse_connections(i);
    }
#line 878
    if (! (i != 0UL)) {
#line 878
      goto while_break;
    }
    {
#line 880
    active_connection = get_conn_by_number(i);
    }
#line 882
    if ((int )active_connection->pers_no == (int )pers_no) {
      {
#line 884
      async_forced_leave_conf(active_connection, conf_no);
      }
#line 886
      if ((int )active_connection->cwc == (int )conf_no) {
        {
#line 887
        leave_conf(active_connection);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 891
  active_connection = real_active_connection;
#line 892
  return;
}
}
#line 902 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
Success do_sub_member(Conf_no conf_no , Conference *conf_c , Member *mbr , Pers_no pers_no ,
                      Person *pers_p , Membership *mship ) 
{ 


  {
#line 911
  if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
    {
#line 912
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 912
      conf_c = cached_get_conf_stat(conf_no);
      }
#line 912
      if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 912
        return ((Success )FAILURE);
      }
#line 912
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 914
  if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
    {
#line 915
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 915
      pers_p = cached_get_person_stat(pers_no);
      }
#line 915
      if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 915
        return ((Success )FAILURE);
      }
#line 915
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 917
  if ((unsigned long )mship == (unsigned long )((void *)0)) {
    {
#line 917
    mship = locate_membership(conf_no, (Person const   *)pers_p);
    }
#line 917
    if ((unsigned long )mship == (unsigned long )((void *)0)) {
      {
#line 918
      restart_kom("do_sub_member() - can\'t find mship\n");
      }
    }
  }
#line 920
  if ((unsigned long )mbr == (unsigned long )((void *)0)) {
    {
#line 920
    mbr = locate_member(pers_no, conf_c);
    }
#line 920
    if ((unsigned long )mbr == (unsigned long )((void *)0)) {
      {
#line 921
      restart_kom("do_sub_member() - can\'t find member.\n");
      }
    }
  }
  {
#line 923
  forced_leave_conf(pers_no, conf_no);
#line 927
  sfree((void *)mship->read_ranges);
#line 928
  pers_p->conferences.no_of_confs = (unsigned short )((int )pers_p->conferences.no_of_confs - 1);
  }
  {
#line 929
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 929
    if (! ((unsigned long )mship < (unsigned long )(pers_p->conferences.confs + (int )pers_p->conferences.no_of_confs))) {
#line 929
      goto while_break___1;
    }
#line 932
    *mship = *(mship + 1);
#line 933
    mship ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 938
  conf_c->members.no_of_members = (unsigned short )((int )conf_c->members.no_of_members - 1);
  {
#line 939
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 939
    if (! ((unsigned long )mbr < (unsigned long )(conf_c->members.members + (int )conf_c->members.no_of_members))) {
#line 939
      goto while_break___2;
    }
#line 941
    *mbr = *(mbr + 1);
#line 942
    mbr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 945
  mark_person_as_changed(pers_no);
#line 946
  mark_conference_as_changed(conf_no);
  }
#line 948
  return ((Success )OK);
}
}
#line 972
static enum access access_perm_helper(Conf_no victim , Connection const   *conn ,
                                      enum access wanted_access ) ;
#line 972 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static int maxwarnings  =    10;
#line 965 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static enum access access_perm_helper(Conf_no victim , Connection const   *conn ,
                                      enum access wanted_access ) 
{ 
  Conf_type victim_type ;
  int victim_type_known ;
  Bool tmp ;
  Bool tmp___0 ;
  Membership *tmp___1 ;

  {
  {
#line 971
  victim_type_known = 0;
#line 974
  tmp = cached_conf_exists(victim);
  }
#line 974
  if (! tmp) {
#line 976
    kom_errno = (enum kom_err )9;
#line 977
    err_stat = (unsigned long )victim;
#line 978
    return ((enum access )0);
  }
#line 981
  if ((int )victim == (int )conn->pers_no) {
#line 982
    return ((enum access )5);
  }
#line 984
  if ((int const   )conn->ena_level >= 2) {
#line 984
    if (conn->person) {
#line 984
      if ((conn->person)->privileges.admin) {
#line 985
        return ((enum access )5);
      } else {
#line 984
        goto _L___0;
      }
    } else {
#line 984
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 984
  if ((int const   )conn->ena_level >= 8) {
#line 984
    if (conn->person) {
#line 984
      if ((conn->person)->privileges.wheel) {
#line 985
        return ((enum access )5);
      }
    }
  }
#line 987
  if ((unsigned int )wanted_access <= 3U) {
    {
#line 989
    victim_type = cached_get_conf_type(victim);
#line 990
    victim_type_known = 1;
    }
#line 992
    if (victim_type.secret == 0U) {
#line 994
      if (victim_type.rd_prot) {
#line 996
        if ((unsigned int )wanted_access <= 2U) {
#line 997
          return ((enum access )2);
        }
      } else {
#line 1000
        return ((enum access )3);
      }
    }
  }
  {
#line 1004
  tmp___0 = is_supervisor(victim, conn);
  }
#line 1004
  if (tmp___0) {
#line 1005
    return ((enum access )5);
  }
#line 1007
  if ((int const   )conn->pers_no != 0) {
#line 1009
    if ((unsigned long )conn->person == (unsigned long )((void *)0)) {
#line 1011
      if (maxwarnings > 0) {
        {
#line 1013
        kom_log("WNG: conn->person unexpectedly NULL in access_perm_helper()\n");
#line 1015
        maxwarnings --;
        }
#line 1015
        if (maxwarnings == 0) {
          {
#line 1016
          kom_log("WNG: Won\'t log the above warning any more.\n");
          }
        }
      }
#line 1018
      kom_errno = (enum kom_err )51;
#line 1019
      err_stat = 0UL;
#line 1020
      return ((enum access )0);
    }
    {
#line 1025
    tmp___1 = locate_membership(victim, (Person const   *)conn->person);
    }
#line 1025
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 1026
      return ((enum access )4);
    }
  }
#line 1029
  if (victim_type_known == 0) {
    {
#line 1030
    victim_type = cached_get_conf_type(victim);
    }
  }
#line 1032
  if (victim_type.secret) {
#line 1033
    return ((enum access )1);
  }
#line 1035
  if (victim_type.rd_prot) {
#line 1036
    return ((enum access )2);
  }
#line 1038
  return ((enum access )3);
}
}
#line 1053 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static int ctr  =    0;
#line 1042 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
enum access access_perm(Conf_no victim , Connection const   *viewer_conn , enum access wanted_access ) 
{ 
  enum access result ;

  {
#line 1049
  if ((unsigned int )wanted_access != 2U) {
#line 1049
    if ((unsigned int )wanted_access != 3U) {
#line 1049
      if ((unsigned int )wanted_access != 5U) {
#line 1054
        if (ctr < 10) {
          {
#line 1056
          kom_log("WNG: access_perm called with wanted_access=%d\n", (int )wanted_access);
#line 1058
          ctr ++;
          }
#line 1059
          if (ctr == 10) {
            {
#line 1060
            kom_log("WNG: won\'t log the above warning any more.\n");
            }
          }
        }
      }
    }
  }
  {
#line 1064
  result = access_perm_helper(victim, viewer_conn, wanted_access);
  }
#line 1066
  if ((unsigned int )wanted_access < (unsigned int )result) {
#line 1067
    return (wanted_access);
  } else {
#line 1069
    return (result);
  }
}
}
#line 1073 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
Bool has_access(Conf_no victim , Connection const   *viewer_conn , enum access wanted_access ) 
{ 
  enum access tmp ;

  {
  {
#line 1078
  tmp = access_perm(victim, viewer_conn, wanted_access);
  }
#line 1078
  return ((Bool )((unsigned int )tmp >= (unsigned int )wanted_access));
}
}
#line 1082 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
Conf_no filter_conf_no(Conf_no victim , Connection const   *viewer_conn ) 
{ 
  Bool tmp ;

  {
  {
#line 1086
  tmp = has_access(victim, viewer_conn, (enum access )2);
  }
#line 1086
  if (tmp) {
#line 1087
    return (victim);
  } else {
#line 1089
    return ((Conf_no )0);
  }
}
}
#line 1097 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
Member *locate_member(Pers_no pers_no , Conference *conf_c ) 
{ 
  Member *mbr ;
  int i ;

  {
#line 1104
  mbr = conf_c->members.members;
#line 1104
  i = (int )conf_c->members.no_of_members;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! (i > 0)) {
#line 1104
      goto while_break;
    }
#line 1107
    if ((int )mbr->member == (int )pers_no) {
#line 1109
      return (mbr);
    }
#line 1104
    i --;
#line 1104
    mbr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1113
  return ((Member *)((void *)0));
}
}
#line 1122 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
Membership *locate_membership(Conf_no conf_no , Person const   *pers_p ) 
{ 
  Membership *confp ;
  int i ;

  {
#line 1129
  confp = (Membership *)pers_p->conferences.confs;
#line 1129
  i = (int )pers_p->conferences.no_of_confs;
  {
#line 1129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1129
    if (! (i > 0)) {
#line 1129
      goto while_break;
    }
#line 1132
    if ((int )confp->conf_no == (int )conf_no) {
#line 1134
      confp->position = (unsigned long )((int const   )pers_p->conferences.no_of_confs - (int const   )i);
#line 1135
      return (confp);
    }
#line 1129
    i --;
#line 1129
    confp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  return ((Membership *)((void *)0));
}
}
#line 1152 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern Success sub_member(Conf_no conf_no , Pers_no pers_no ) 
{ 
  Conference *conf_c ;
  Membership *mship ;
  Person *pers_p ;
  Bool tmp ;
  enum memb_visibility tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;
  Success tmp___3 ;

  {
  {
#line 1160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1160
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1160
      err_stat = 0UL;
#line 1160
      kom_errno = (enum kom_err )51;
#line 1160
      return ((Success )FAILURE);
    }
#line 1160
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1161
    if (! active_connection) {
#line 1161
      err_stat = 0UL;
#line 1161
      kom_errno = (enum kom_err )6;
#line 1161
      return ((Success )FAILURE);
    } else
#line 1161
    if (! active_connection->pers_no) {
#line 1161
      err_stat = 0UL;
#line 1161
      kom_errno = (enum kom_err )6;
#line 1161
      return ((Success )FAILURE);
    }
#line 1161
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1162
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1162
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 1162
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 1162
      return ((Success )FAILURE);
    }
#line 1162
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1164
  pers_p = cached_get_person_stat(pers_no);
  }
#line 1164
  if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
    {
#line 1169
    tmp = has_access(conf_no, (Connection const   *)active_connection, (enum access )2);
    }
#line 1169
    if (! tmp) {
#line 1171
      kom_errno = (enum kom_err )9;
#line 1172
      err_stat = (unsigned long )conf_no;
    }
#line 1174
    return ((Success )FAILURE);
  }
  {
#line 1177
  mship = locate_membership(conf_no, (Person const   *)pers_p);
  }
#line 1177
  if ((unsigned long )mship == (unsigned long )((void *)0)) {
    {
#line 1184
    set_conf_errno((Connection const   *)active_connection, conf_no, (enum kom_err )13);
    }
#line 1185
    return ((Success )FAILURE);
  } else {
    {
#line 1177
    tmp___0 = membership_visible((Connection const   *)active_connection, pers_no,
                                 conf_no, mship->type, (Bool )0, (Bool )0);
    }
#line 1177
    if ((unsigned int )tmp___0 == 0U) {
      {
#line 1184
      set_conf_errno((Connection const   *)active_connection, conf_no, (enum kom_err )13);
      }
#line 1185
      return ((Success )FAILURE);
    }
  }
  {
#line 1188
  tmp___1 = is_supervisor(conf_no, (Connection const   *)active_connection);
  }
#line 1188
  if (! tmp___1) {
    {
#line 1188
    tmp___2 = is_supervisor(pers_no, (Connection const   *)active_connection);
    }
#line 1188
    if (! tmp___2) {
#line 1188
      if (active_connection) {
#line 1188
        if ((int )active_connection->ena_level >= 8) {
#line 1188
          if (! (active_connection->person)->privileges.wheel) {
#line 1188
            goto _L___0;
          }
        } else {
#line 1188
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1188
      if (active_connection) {
#line 1188
        if ((int )active_connection->ena_level >= 4) {
#line 1188
          if (! (active_connection->person)->privileges.admin) {
            {
#line 1193
            set_conf_errno((Connection const   *)active_connection, conf_no, (enum kom_err )12);
            }
#line 1194
            return ((Success )FAILURE);
          }
        } else {
          {
#line 1193
          set_conf_errno((Connection const   *)active_connection, conf_no, (enum kom_err )12);
          }
#line 1194
          return ((Success )FAILURE);
        }
      } else {
        {
#line 1193
        set_conf_errno((Connection const   *)active_connection, conf_no, (enum kom_err )12);
        }
#line 1194
        return ((Success )FAILURE);
      }
    }
  }
  {
#line 1197
  tmp___3 = do_sub_member(conf_no, conf_c, (Member *)((void *)0), pers_no, pers_p,
                          mship);
  }
#line 1197
  return (tmp___3);
}
}
#line 1217 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static Success add_member_common(Conf_no conf_no , Pers_no pers_no , unsigned char priority ,
                                 unsigned short where , Membership_type *type , Bool fake_passive ) 
{ 
  Conference *conf_c ;
  Person *pers_p ;
  Membership *mship ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool pers_supervisor ;
  Bool conf_supervisor ;

  {
  {
#line 1230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1230
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1230
      err_stat = 0UL;
#line 1230
      kom_errno = (enum kom_err )51;
#line 1230
      return ((Success )FAILURE);
    }
#line 1230
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1231
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1231
    if (! active_connection) {
#line 1231
      err_stat = 0UL;
#line 1231
      kom_errno = (enum kom_err )6;
#line 1231
      return ((Success )FAILURE);
    } else
#line 1231
    if (! active_connection->pers_no) {
#line 1231
      err_stat = 0UL;
#line 1231
      kom_errno = (enum kom_err )6;
#line 1231
      return ((Success )FAILURE);
    }
#line 1231
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1232
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1232
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 1232
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 1232
      return ((Success )FAILURE);
    }
#line 1232
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1233
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1233
    pers_p = cached_get_person_stat(pers_no);
    }
#line 1233
    if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 1233
      return ((Success )FAILURE);
    }
#line 1233
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1236
  if (param.invite_by_default) {
    {
#line 1236
    tmp = is_supervisor(pers_no, (Connection const   *)active_connection);
    }
#line 1236
    if (! tmp) {
#line 1236
      if (active_connection) {
#line 1236
        if ((int )active_connection->ena_level >= 2) {
#line 1236
          if (! (active_connection->person)->privileges.admin) {
#line 1240
            type->invitation = 1U;
          }
        } else {
#line 1240
          type->invitation = 1U;
        }
      } else {
#line 1240
        type->invitation = 1U;
      }
    }
  }
#line 1244
  if (type->secret) {
#line 1244
    if (! param.secret_memberships) {
#line 1247
      err_stat = 0UL;
#line 1248
      kom_errno = (enum kom_err )54;
#line 1249
      return ((Success )FAILURE);
    } else
#line 1244
    if (conf_c->type.forbid_secret) {
#line 1247
      err_stat = 0UL;
#line 1248
      kom_errno = (enum kom_err )54;
#line 1249
      return ((Success )FAILURE);
    }
  }
  {
#line 1253
  tmp___0 = has_access(conf_no, (Connection const   *)active_connection, (enum access )3);
  }
#line 1253
  if (! tmp___0) {
#line 1253
    if (active_connection) {
#line 1253
      if ((int )active_connection->ena_level >= 8) {
#line 1253
        if (! (active_connection->person)->privileges.wheel) {
#line 1253
          goto _L___0;
        }
      } else {
#line 1253
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1256
      err_stat = (unsigned long )conf_no;
#line 1257
      if (conf_c->type.secret) {
#line 1257
        kom_errno = (enum kom_err )9;
      } else {
#line 1257
        kom_errno = (enum kom_err )11;
      }
#line 1258
      return ((Success )FAILURE);
    }
  }
  {
#line 1263
  mship = locate_membership(conf_no, (Person const   *)pers_p);
  }
#line 1263
  if ((unsigned long )mship != (unsigned long )((void *)0)) {
    {
#line 1268
    pers_supervisor = is_supervisor(pers_no, (Connection const   *)active_connection);
#line 1269
    conf_supervisor = is_supervisor(conf_no, (Connection const   *)active_connection);
    }
#line 1272
    if (mship->type.secret) {
#line 1272
      if (! pers_supervisor) {
#line 1272
        if (! conf_supervisor) {
#line 1272
          if (active_connection) {
#line 1272
            if ((int )active_connection->ena_level >= 2) {
#line 1272
              if (! (active_connection->person)->privileges.admin) {
#line 1272
                goto _L___2;
              }
            } else {
#line 1272
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 1272
          if (active_connection) {
#line 1272
            if ((int )active_connection->ena_level >= 8) {
#line 1272
              if (! (active_connection->person)->privileges.wheel) {
#line 1283
                return ((Success )OK);
              }
            } else {
#line 1283
              return ((Success )OK);
            }
          } else {
#line 1283
            return ((Success )OK);
          }
        }
      }
    }
#line 1287
    if (! pers_supervisor) {
#line 1287
      if (active_connection) {
#line 1287
        if ((int )active_connection->ena_level >= 2) {
#line 1287
          if (! (active_connection->person)->privileges.admin) {
#line 1287
            goto _L___4;
          }
        } else {
#line 1287
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 1287
      if (active_connection) {
#line 1287
        if ((int )active_connection->ena_level >= 8) {
#line 1287
          if (! (active_connection->person)->privileges.wheel) {
#line 1292
            err_stat = (unsigned long )pers_no;
#line 1293
            kom_errno = (enum kom_err )12;
#line 1294
            return ((Success )FAILURE);
          }
        } else {
#line 1292
          err_stat = (unsigned long )pers_no;
#line 1293
          kom_errno = (enum kom_err )12;
#line 1294
          return ((Success )FAILURE);
        }
      } else {
#line 1292
        err_stat = (unsigned long )pers_no;
#line 1293
        kom_errno = (enum kom_err )12;
#line 1294
        return ((Success )FAILURE);
      }
    }
    {
#line 1297
    do_change_priority(mship, conf_no, conf_c, priority, where, pers_no, pers_p, type,
                       fake_passive);
    }
  } else {
#line 1304
    if ((int )pers_no != (int )active_connection->pers_no) {
      {
#line 1306
      kom_log("Person %lu added to conference %lu by %lu.\n", (unsigned long )pers_no,
              (unsigned long )conf_no, (unsigned long )active_connection->pers_no);
      }
    }
    {
#line 1312
    do_add_member(conf_no, conf_c, pers_no, pers_p, active_connection->pers_no, priority,
                  where, type, fake_passive);
#line 1315
    send_async_new_membership(pers_no, conf_no);
    }
  }
#line 1318
  return ((Success )OK);
}
}
#line 1322 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern Success add_member_old(Conf_no conf_no , Pers_no pers_no , unsigned char priority ,
                              unsigned short where ) 
{ 
  Membership_type type ;
  Success tmp ;

  {
  {
#line 1331
  set_membership_type_bits(& type, (Bool )0, (Bool )0, (Bool )0, (Bool )0, (Bool )0,
                           (Bool )0, (Bool )0, (Bool )0);
#line 1332
  tmp = add_member_common(conf_no, pers_no, priority, where, & type, (Bool )1);
  }
#line 1332
  return (tmp);
}
}
#line 1336 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern Success add_member(Conf_no conf_no , Pers_no pers_no , unsigned char priority ,
                          unsigned short where , Membership_type *type ) 
{ 
  Success tmp ;

  {
  {
#line 1345
  tmp = add_member_common(conf_no, pers_no, priority, where, type, (Bool )0);
  }
#line 1345
  return (tmp);
}
}
#line 1355
static int check_membership(Pers_no pno , Conference const   *conf , Membership *mship ) ;
#line 1355 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static int log_no  =    0;
#line 1350 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static int check_membership(Pers_no pno , Conference const   *conf , Membership *mship ) 
{ 
  int errors ;
  struct read_range *begin ;
  struct read_range *end ;
  struct read_range *ptr ;
  Local_text_no tmp ;
  Local_text_no tmp___0 ;

  {
#line 1357
  errors = 0;
#line 1362
  if (mship->no_of_read_ranges == 0U) {
#line 1362
    if ((unsigned long )mship->read_ranges != (unsigned long )((void *)0)) {
#line 1364
      if (log_no < 80) {
        {
#line 1365
        log_no ++;
#line 1365
        kom_log("ERROR: check_membership(): (%d): no_of_read_ranges == 0 but read_ranges != NULL\n",
                log_no);
        }
      }
#line 1369
      mship->read_ranges = (struct read_range *)((void *)0);
#line 1370
      errors ++;
    }
  }
#line 1373
  if (mship->no_of_read_ranges != 0U) {
#line 1373
    if ((unsigned long )mship->read_ranges == (unsigned long )((void *)0)) {
#line 1375
      if (log_no < 80) {
        {
#line 1376
        log_no ++;
#line 1376
        kom_log("ERROR: check_membership(): (%d): no_of_read_ranges == %ld but read_ranges == NULL\n",
                log_no, (long )mship->no_of_read_ranges);
        }
      }
#line 1379
      mship->no_of_read_ranges = 0U;
#line 1380
      errors ++;
    }
  }
#line 1383
  if ((unsigned long )mship->read_ranges == (unsigned long )((void *)0)) {
#line 1384
    return (errors);
  }
#line 1386
  begin = mship->read_ranges + 0;
#line 1387
  end = begin + mship->no_of_read_ranges;
#line 1389
  ptr = begin;
  {
#line 1389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1389
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 1389
      goto while_break;
    }
#line 1391
    if ((unsigned long )ptr != (unsigned long )begin) {
#line 1391
      if ((ptr - 1)->last_read + 1UL >= ptr->first_read) {
#line 1393
        if (log_no < 80) {
          {
#line 1394
          log_no ++;
#line 1394
          kom_log("ERROR: check_membership(): (%d): bad range sequence %lu-%lu, %lu-%lu\n",
                  log_no, (ptr - 1)->first_read, (ptr - 1)->last_read, ptr->first_read,
                  ptr->last_read);
          }
        }
#line 1401
        errors ++;
      }
    }
#line 1404
    if (ptr->first_read > ptr->last_read) {
#line 1406
      if (log_no < 80) {
        {
#line 1407
        log_no ++;
#line 1407
        kom_log("ERROR: check_membership(): (%d): bad range %lu-%lu\n", log_no, ptr->first_read,
                ptr->last_read);
        }
      }
#line 1411
      errors ++;
    }
#line 1389
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1415
  tmp___0 = l2g_first_appendable_key(& conf->texts);
  }
#line 1415
  if ((end - 1)->last_read >= tmp___0) {
#line 1417
    if (log_no < 80) {
      {
#line 1418
      tmp = l2g_first_appendable_key(& conf->texts);
#line 1418
      kom_log("ERROR: check_membership(): (%d): Person %lu has read text %lu in conf %lu, which only has %lu texts.\n",
              log_no, (unsigned long )pno, (end - 1)->last_read, (unsigned long )mship->conf_no,
              tmp - 1UL);
      }
    }
#line 1425
    errors ++;
  }
#line 1428
  return (errors);
}
}
#line 1431 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static void read_ranges_precondition(Membership *m , Membership *save , Conference const   *conf_c ,
                                     char const   *func ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 1437
  tmp = check_membership(active_connection->pers_no, conf_c, m);
  }
#line 1437
  if (tmp > 0) {
    {
#line 1438
    kom_log("%s(): the above error was detected on entry to me.\n", func);
    }
  }
#line 1440
  if ((unsigned long )m->read_ranges == (unsigned long )((void *)0)) {
#line 1440
    if (m->no_of_read_ranges != 0U) {
      {
#line 1442
      kom_log("%s(): m->read_ranges == NULL && m->no_of_read_ranges == %lu (corrected).\n",
              func, (unsigned long )m->no_of_read_ranges);
#line 1446
      m->no_of_read_ranges = 0U;
      }
    }
  }
#line 1449
  *save = *m;
#line 1450
  if ((unsigned long )m->read_ranges != (unsigned long )((void *)0)) {
    {
#line 1452
    tmp___0 = smalloc((unsigned long )m->no_of_read_ranges * sizeof(*(save->read_ranges + 0)));
#line 1452
    save->read_ranges = (struct read_range *)tmp___0;
#line 1454
    memcpy((void */* __restrict  */)save->read_ranges, (void const   */* __restrict  */)m->read_ranges,
           (unsigned long )m->no_of_read_ranges * sizeof(*(save->read_ranges + 0)));
    }
  }
#line 1457
  return;
}
}
#line 1465
static int read_ranges_postcondition(Membership *m , Membership *save , Conference const   *conf_c ,
                                     char const   *func ) ;
#line 1465 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static int log_no___0  =    0;
#line 1459 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static int read_ranges_postcondition(Membership *m , Membership *save , Conference const   *conf_c ,
                                     char const   *func ) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 1466
  ret = 0;
#line 1469
  tmp = check_membership(active_connection->pers_no, conf_c, m);
  }
#line 1469
  if (tmp > 0) {
#line 1469
    if (log_no___0 < 40) {
      {
#line 1471
      log_no___0 ++;
#line 1471
      kom_log("%s(): (%d) Person %lu has a corrupt membership:\n", func, log_no___0,
              (unsigned long )active_connection->pers_no);
#line 1473
      kom_log("Dump of data follows: <original membership><updated membership>\n");
#line 1475
      foutput_membership(stderr, save);
#line 1476
      _IO_putc('\n', stderr);
#line 1477
      foutput_membership(stderr, m);
#line 1478
      _IO_putc('\n', stderr);
#line 1479
      ret = -1;
      }
    }
  }
  {
#line 1482
  sfree((void *)save->read_ranges);
  }
#line 1483
  return (ret);
}
}
#line 1515 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern Success mark_as_read(Conf_no conference , Number_list const   *texts ) 
{ 
  int i ;
  Membership *m ;
  Conference *conf_c ;
  Success retval ;
  Local_text_no lno ;
  Membership original ;
  Local_text_no tmp ;
  Success tmp___0 ;
  int tmp___1 ;

  {
#line 1522
  retval = (Success )OK;
  {
#line 1528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1528
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1528
      err_stat = 0UL;
#line 1528
      kom_errno = (enum kom_err )51;
#line 1528
      return ((Success )FAILURE);
    }
#line 1528
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1530
  if (texts->length > (int const   )param.mark_as_read_chunk) {
#line 1532
    kom_errno = (enum kom_err )46;
#line 1533
    err_stat = (unsigned long )param.mark_as_read_chunk;
#line 1534
    return ((Success )FAILURE);
  }
  {
#line 1537
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1537
    if (! active_connection) {
#line 1537
      err_stat = 0UL;
#line 1537
      kom_errno = (enum kom_err )6;
#line 1537
      return ((Success )FAILURE);
    } else
#line 1537
    if (! active_connection->pers_no) {
#line 1537
      err_stat = 0UL;
#line 1537
      kom_errno = (enum kom_err )6;
#line 1537
      return ((Success )FAILURE);
    }
#line 1537
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1538
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1538
    conf_c = cached_get_conf_stat(conference);
    }
#line 1538
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 1538
      return ((Success )FAILURE);
    }
#line 1538
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1540
  m = locate_membership(conference, (Person const   *)active_connection->person);
  }
#line 1540
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 1542
    set_conf_errno((Connection const   *)active_connection, conference, (enum kom_err )13);
    }
#line 1543
    return ((Success )FAILURE);
  }
  {
#line 1547
  read_ranges_precondition(m, & original, (Conference const   *)conf_c, "mark_as_read");
#line 1550
  i = 0;
  }
  {
#line 1550
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1550
    if (! (i < (int )texts->length)) {
#line 1550
      goto while_break___2;
    }
    {
#line 1552
    lno = (Local_text_no )*(texts->data + i);
#line 1553
    tmp = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
    }
#line 1553
    if (lno >= tmp) {
#line 1555
      kom_errno = (enum kom_err )16;
#line 1556
      err_stat = (unsigned long )i;
#line 1557
      retval = (Success )FAILURE;
#line 1558
      goto while_break___2;
    }
#line 1561
    if (lno == 0UL) {
#line 1563
      kom_errno = (enum kom_err )17;
#line 1564
      err_stat = (unsigned long )i;
#line 1565
      retval = (Success )FAILURE;
#line 1566
      goto while_break___2;
    }
#line 1550
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1570
  if ((unsigned long )retval == (unsigned long )OK) {
#line 1572
    i = 0;
    {
#line 1572
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1572
      if (! (i < (int )texts->length)) {
#line 1572
        goto while_break___3;
      }
#line 1574
      lno = (Local_text_no )*(texts->data + i);
#line 1577
      if ((int )conference == (int )active_connection->pers_no) {
        {
#line 1578
        add_rec_time(conf_c, lno, active_connection->pers_no);
        }
      }
      {
#line 1581
      tmp___0 = insert_loc_no(lno, m);
      }
#line 1581
      if ((unsigned long )tmp___0 == (unsigned long )OK) {
#line 1581
        if ((int )active_connection->cwc == (int )conference) {
#line 1584
          ((active_connection->person)->read_texts) ++;
        }
      }
#line 1572
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1588
    adjust_read(m, (Conference const   *)conf_c);
#line 1589
    mark_person_as_changed(active_connection->pers_no);
    }
  }
  {
#line 1593
  tmp___1 = read_ranges_postcondition(m, & original, (Conference const   *)conf_c,
                                      "mark_as_read");
  }
#line 1593
  if (tmp___1 < 0) {
    {
#line 1595
    kom_log("this was triggered by an attempt to mark this as read\n");
#line 1596
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%lu { ",
            (unsigned long )texts->length);
#line 1597
    i = 0;
    }
    {
#line 1597
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1597
      if (! (i < (int )texts->length)) {
#line 1597
        goto while_break___4;
      }
      {
#line 1598
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%lu ",
              (unsigned long )*(texts->data + i));
#line 1597
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1599
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"}\n");
    }
  }
#line 1602
  return (retval);
}
}
#line 1606 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern Success mark_as_unread(Conf_no conference , Local_text_no lno ) 
{ 
  Membership *m ;
  Conference *conf_c ;
  Success retval ;
  Membership original ;
  Local_text_no tmp ;
  int tmp___0 ;

  {
#line 1612
  retval = (Success )OK;
  {
#line 1617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1617
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1617
      err_stat = 0UL;
#line 1617
      kom_errno = (enum kom_err )51;
#line 1617
      return ((Success )FAILURE);
    }
#line 1617
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1618
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1618
    if (! active_connection) {
#line 1618
      err_stat = 0UL;
#line 1618
      kom_errno = (enum kom_err )6;
#line 1618
      return ((Success )FAILURE);
    } else
#line 1618
    if (! active_connection->pers_no) {
#line 1618
      err_stat = 0UL;
#line 1618
      kom_errno = (enum kom_err )6;
#line 1618
      return ((Success )FAILURE);
    }
#line 1618
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1619
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1619
    conf_c = cached_get_conf_stat(conference);
    }
#line 1619
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 1619
      return ((Success )FAILURE);
    }
#line 1619
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1621
  m = locate_membership(conference, (Person const   *)active_connection->person);
  }
#line 1621
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 1623
    set_conf_errno((Connection const   *)active_connection, conference, (enum kom_err )13);
    }
#line 1624
    return ((Success )FAILURE);
  }
  {
#line 1628
  read_ranges_precondition(m, & original, (Conference const   *)conf_c, "unmark_as_read");
  }
#line 1631
  if (lno == 0UL) {
#line 1633
    kom_errno = (enum kom_err )17;
#line 1634
    err_stat = 0UL;
#line 1635
    retval = (Success )FAILURE;
  } else {
    {
#line 1637
    tmp = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
    }
#line 1637
    if (lno >= tmp) {
#line 1639
      kom_errno = (enum kom_err )16;
#line 1640
      err_stat = lno;
#line 1641
      retval = (Success )FAILURE;
    } else {
      {
#line 1645
      remove_loc_no(lno, m);
#line 1646
      adjust_read(m, (Conference const   *)conf_c);
#line 1647
      mark_person_as_changed(active_connection->pers_no);
      }
    }
  }
  {
#line 1651
  tmp___0 = read_ranges_postcondition(m, & original, (Conference const   *)conf_c,
                                      "unmark_as_read");
  }
#line 1651
  if (tmp___0 < 0) {
    {
#line 1653
    kom_log("this was triggered by an attempt to mark %lu as not read\n", lno);
    }
  }
#line 1657
  return (retval);
}
}
#line 1660 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static Success check_range_list(struct read_range_list  const  *read_ranges ) 
{ 
  Local_text_no last___0 ;
  unsigned short i ;

  {
#line 1663
  last___0 = (Local_text_no )0;
#line 1666
  if ((int const   )read_ranges->length > (int const   )param.max_read_ranges) {
#line 1668
    kom_errno = (enum kom_err )46;
#line 1669
    err_stat = (unsigned long )param.max_read_ranges;
#line 1670
    return ((Success )FAILURE);
  }
#line 1673
  i = (unsigned short)0;
  {
#line 1673
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1673
    if (! ((int )i < (int )read_ranges->length)) {
#line 1673
      goto while_break;
    }
#line 1675
    if ((read_ranges->ranges + i)->first_read > (read_ranges->ranges + i)->last_read) {
#line 1678
      kom_errno = (enum kom_err )55;
#line 1679
      err_stat = (unsigned long )i;
#line 1680
      return ((Success )FAILURE);
    }
#line 1683
    if ((read_ranges->ranges + i)->first_read <= last___0) {
#line 1685
      if ((read_ranges->ranges + i)->first_read == 0UL) {
#line 1686
        kom_errno = (enum kom_err )17;
      } else {
#line 1688
        kom_errno = (enum kom_err )56;
      }
#line 1689
      err_stat = (unsigned long )i;
#line 1690
      return ((Success )FAILURE);
    }
#line 1693
    last___0 = (read_ranges->ranges + i)->last_read;
#line 1673
    i = (unsigned short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1696
  return ((Success )OK);
}
}
#line 1700 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
Success set_read_ranges(Conf_no conference , struct read_range_list  const  *read_ranges ) 
{ 
  Membership *m ;
  Conference *conf_c ;
  Success retval ;
  Membership original ;
  Success tmp ;
  void *tmp___0 ;
  Local_text_no tmp___1 ;

  {
#line 1706
  retval = (Success )OK;
  {
#line 1711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1711
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1711
      err_stat = 0UL;
#line 1711
      kom_errno = (enum kom_err )51;
#line 1711
      return ((Success )FAILURE);
    }
#line 1711
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1713
  tmp = check_range_list(read_ranges);
  }
#line 1713
  if ((unsigned long )tmp == (unsigned long )FAILURE) {
#line 1714
    return ((Success )FAILURE);
  }
  {
#line 1716
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1716
    if (! active_connection) {
#line 1716
      err_stat = 0UL;
#line 1716
      kom_errno = (enum kom_err )6;
#line 1716
      return ((Success )FAILURE);
    } else
#line 1716
    if (! active_connection->pers_no) {
#line 1716
      err_stat = 0UL;
#line 1716
      kom_errno = (enum kom_err )6;
#line 1716
      return ((Success )FAILURE);
    }
#line 1716
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1717
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1717
    conf_c = cached_get_conf_stat(conference);
    }
#line 1717
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 1717
      return ((Success )FAILURE);
    }
#line 1717
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1719
  m = locate_membership(conference, (Person const   *)active_connection->person);
  }
#line 1719
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 1721
    set_conf_errno((Connection const   *)active_connection, conference, (enum kom_err )13);
    }
#line 1722
    return ((Success )FAILURE);
  }
  {
#line 1726
  read_ranges_precondition(m, & original, (Conference const   *)conf_c, "set_read_ranges");
  }
#line 1729
  if ((int const   )read_ranges->length == 0) {
#line 1731
    if (m->no_of_read_ranges != 0U) {
      {
#line 1733
      sfree((void *)m->read_ranges);
#line 1734
      m->read_ranges = (struct read_range *)((void *)0);
#line 1735
      m->no_of_read_ranges = 0U;
#line 1736
      mark_person_as_changed(active_connection->pers_no);
      }
    }
  } else {
    {
#line 1739
    tmp___1 = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
    }
#line 1739
    if ((read_ranges->ranges + ((int const   )read_ranges->length - 1))->last_read >= tmp___1) {
#line 1742
      kom_errno = (enum kom_err )16;
#line 1743
      err_stat = (read_ranges->ranges + ((int const   )read_ranges->length - 1))->last_read;
#line 1744
      retval = (Success )FAILURE;
    } else {
#line 1748
      if (m->no_of_read_ranges != (unsigned int )read_ranges->length) {
        {
#line 1750
        m->no_of_read_ranges = (unsigned int )read_ranges->length;
#line 1751
        tmp___0 = srealloc((void *)m->read_ranges, (unsigned long )m->no_of_read_ranges * sizeof(*(m->read_ranges + 0)));
#line 1751
        m->read_ranges = (struct read_range *)tmp___0;
        }
      }
      {
#line 1755
      memcpy((void */* __restrict  */)m->read_ranges, (void const   */* __restrict  */)read_ranges->ranges,
             (unsigned long )m->no_of_read_ranges * sizeof(*(m->read_ranges + 0)));
#line 1757
      adjust_read(m, (Conference const   *)conf_c);
#line 1758
      mark_person_as_changed(active_connection->pers_no);
      }
    }
  }
  {
#line 1762
  read_ranges_postcondition(m, & original, (Conference const   *)conf_c, "set_read_ranges");
  }
#line 1764
  return (retval);
}
}
#line 1774 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static Success do_get_membership(Pers_no pers_no , unsigned short first , unsigned short no_of_confs ,
                                 Bool keep_ranges , Bool want_read_ranges , unsigned long max_ranges ,
                                 Membership_list *memberships ) 
{ 
  Person *p_orig ;
  Person temp_pers ;
  enum access acc ;
  int i ;
  void *tmp ;

  {
  {
#line 1788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1788
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1788
      err_stat = 0UL;
#line 1788
      kom_errno = (enum kom_err )51;
#line 1788
      return ((Success )FAILURE);
    }
#line 1788
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1789
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1789
    if (! active_connection) {
#line 1789
      err_stat = 0UL;
#line 1789
      kom_errno = (enum kom_err )6;
#line 1789
      return ((Success )FAILURE);
    } else
#line 1789
    if (! active_connection->pers_no) {
#line 1789
      err_stat = 0UL;
#line 1789
      kom_errno = (enum kom_err )6;
#line 1789
      return ((Success )FAILURE);
    }
#line 1789
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1791
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1791
    p_orig = cached_get_person_stat(pers_no);
    }
#line 1791
    if ((unsigned long )p_orig == (unsigned long )((void *)0)) {
#line 1791
      return ((Success )FAILURE);
    }
#line 1791
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1793
  acc = access_perm(pers_no, (Connection const   *)active_connection, (enum access )5);
  }
#line 1795
  if ((unsigned int )acc == 0U) {
#line 1796
    return ((Success )FAILURE);
  }
#line 1798
  if ((unsigned int )acc == 1U) {
#line 1800
    err_stat = (unsigned long )pers_no;
#line 1801
    kom_errno = (enum kom_err )10;
#line 1802
    return ((Success )FAILURE);
  }
#line 1807
  temp_pers = *p_orig;
#line 1811
  if ((unsigned int )acc != 5U) {
    {
#line 1813
    copy_public_confs(active_connection, pers_no, & temp_pers, p_orig, keep_ranges,
                      want_read_ranges, max_ranges);
    }
  } else
#line 1817
  if (! want_read_ranges) {
#line 1817
    goto _L;
  } else
#line 1817
  if (max_ranges != 0UL) {
    _L: /* CIL Label */ 
    {
#line 1820
    tmp = tmp_alloc((unsigned long )temp_pers.conferences.no_of_confs * sizeof(Membership ));
#line 1820
    temp_pers.conferences.confs = (Membership *)tmp;
#line 1824
    memcpy((void */* __restrict  */)temp_pers.conferences.confs, (void const   */* __restrict  */)p_orig->conferences.confs,
           (unsigned long )temp_pers.conferences.no_of_confs * sizeof(Membership ));
    }
#line 1829
    if (! want_read_ranges) {
#line 1831
      i = 0;
      {
#line 1831
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1831
        if (! (i < (int )temp_pers.conferences.no_of_confs)) {
#line 1831
          goto while_break___2;
        }
#line 1832
        if (keep_ranges) {
#line 1833
          (temp_pers.conferences.confs + i)->skip_read_texts = (Bool )1;
        } else {
#line 1835
          (temp_pers.conferences.confs + i)->read_ranges = (struct read_range *)((void *)0);
        }
#line 1831
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 1839
      if (! (max_ranges != 0UL)) {
        {
#line 1839
        __assert_fail("max_ranges != 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c",
                      1839U, "do_get_membership");
        }
      }
#line 1840
      i = 0;
      {
#line 1840
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1840
        if (! (i < (int )temp_pers.conferences.no_of_confs)) {
#line 1840
          goto while_break___3;
        }
#line 1841
        if ((unsigned long )(temp_pers.conferences.confs + i)->no_of_read_ranges > max_ranges) {
#line 1844
          (temp_pers.conferences.confs + i)->no_of_read_ranges = (unsigned int )max_ranges;
        }
#line 1840
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 1850
  *memberships = temp_pers.conferences;
#line 1852
  if ((int )first >= (int )memberships->no_of_confs) {
#line 1854
    err_stat = (unsigned long )first;
#line 1855
    kom_errno = (enum kom_err )19;
#line 1856
    return ((Success )FAILURE);
  }
#line 1859
  memberships->confs += (int )first;
#line 1860
  if ((int )memberships->no_of_confs - (int )first > (int )no_of_confs) {
#line 1860
    memberships->no_of_confs = no_of_confs;
  } else {
#line 1860
    memberships->no_of_confs = (unsigned short )((int )memberships->no_of_confs - (int )first);
  }
#line 1863
  i = 0;
  {
#line 1863
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1863
    if (! (i < (int )memberships->no_of_confs)) {
#line 1863
      goto while_break___4;
    }
#line 1865
    (memberships->confs + i)->position = (unsigned long )((int )first + i);
#line 1863
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1868
  return ((Success )OK);
}
}
#line 1871 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern Success get_membership_old(Pers_no pers_no , unsigned short first , unsigned short no_of_confs ,
                                  Bool want_read_texts , Membership_list *memberships ) 
{ 
  Success result ;
  long i ;

  {
  {
#line 1881
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1881
    if ((unsigned int )want_read_texts != 0U) {
#line 1881
      if ((unsigned int )want_read_texts != 1U) {
#line 1881
        err_stat = 0UL;
#line 1881
        kom_errno = (enum kom_err )61;
#line 1881
        return ((Success )FAILURE);
      }
    }
#line 1881
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1884
  result = do_get_membership(pers_no, first, no_of_confs, (Bool )1, want_read_texts,
                             0UL, memberships);
  }
#line 1893
  if ((unsigned long )result == (unsigned long )OK) {
#line 1896
    i = 0L;
    {
#line 1896
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1896
      if (! (i < (long )memberships->no_of_confs)) {
#line 1896
        goto while_break___0;
      }
#line 1898
      if ((memberships->confs + i)->type.passive) {
#line 1900
        (memberships->confs + i)->priority = (unsigned char)0;
      }
#line 1896
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1905
  return (result);
}
}
#line 1908 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern Success get_membership_10(Pers_no pers_no , unsigned short first , unsigned short no_of_confs ,
                                 Bool want_read_texts , Membership_list *memberships ) 
{ 
  Success tmp ;

  {
  {
#line 1915
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1915
    if ((unsigned int )want_read_texts != 0U) {
#line 1915
      if ((unsigned int )want_read_texts != 1U) {
#line 1915
        err_stat = 0UL;
#line 1915
        kom_errno = (enum kom_err )61;
#line 1915
        return ((Success )FAILURE);
      }
    }
#line 1915
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1918
  tmp = do_get_membership(pers_no, first, no_of_confs, (Bool )1, want_read_texts,
                          0UL, memberships);
  }
#line 1918
  return (tmp);
}
}
#line 1927 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern Success get_membership(Pers_no pers_no , unsigned short first , unsigned short no_of_confs ,
                              Bool want_read_ranges , unsigned long max_ranges , Membership_list *memberships ) 
{ 
  Success tmp ;

  {
  {
#line 1935
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1935
    if ((unsigned int )want_read_ranges != 0U) {
#line 1935
      if ((unsigned int )want_read_ranges != 1U) {
#line 1935
        err_stat = 0UL;
#line 1935
        kom_errno = (enum kom_err )61;
#line 1935
        return ((Success )FAILURE);
      }
    }
#line 1935
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1938
  tmp = do_get_membership(pers_no, first, no_of_confs, (Bool )0, want_read_ranges,
                          max_ranges, memberships);
  }
#line 1938
  return (tmp);
}
}
#line 1951 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
static Success do_get_members(Conf_no conf_no , unsigned short first , unsigned short no_of_members ,
                              Member_list *members ) 
{ 
  Conference *conf_c ;
  enum access acc ;
  unsigned long src ;
  unsigned long dst ;
  Bool is_supervisor_of_conf ;
  void *tmp ;
  Member const   *current ;
  enum memb_visibility tmp___0 ;

  {
  {
#line 1963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1963
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1963
      err_stat = 0UL;
#line 1963
      kom_errno = (enum kom_err )51;
#line 1963
      return ((Success )FAILURE);
    }
#line 1963
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1964
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1964
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 1964
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 1964
      return ((Success )FAILURE);
    }
#line 1964
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1966
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )2);
  }
#line 1968
  if ((unsigned int )acc == 0U) {
#line 1969
    return ((Success )FAILURE);
  }
#line 1971
  if ((unsigned int )acc == 1U) {
#line 1973
    err_stat = (unsigned long )conf_no;
#line 1974
    kom_errno = (enum kom_err )9;
#line 1975
    return ((Success )FAILURE);
  }
#line 1978
  if ((int )first >= (int )conf_c->members.no_of_members) {
#line 1980
    err_stat = (unsigned long )first;
#line 1981
    kom_errno = (enum kom_err )19;
#line 1982
    return ((Success )FAILURE);
  }
#line 1985
  *members = conf_c->members;
#line 1986
  members->members += (int )first;
#line 1988
  if ((int )no_of_members > (int )members->no_of_members - (int )first) {
#line 1988
    members->no_of_members = (unsigned short )((int )members->no_of_members - (int )first);
  } else {
#line 1988
    members->no_of_members = no_of_members;
  }
  {
#line 1990
  tmp = tmp_alloc((unsigned long )members->no_of_members * sizeof(Member ));
#line 1990
  members->members = (Member *)tmp;
#line 1993
  is_supervisor_of_conf = is_supervisor(conf_no, (Connection const   *)active_connection);
#line 1994
  src = (unsigned long )first;
#line 1994
  dst = 0UL;
  }
  {
#line 1994
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1994
    if (! (dst < (unsigned long )members->no_of_members)) {
#line 1994
      goto while_break___1;
    }
    {
#line 1996
    current = (Member const   *)(conf_c->members.members + src);
#line 1998
    tmp___0 = membership_visible((Connection const   *)active_connection, (Pers_no )current->member,
                                 conf_no, (Membership_type )current->type, (Bool )0,
                                 is_supervisor_of_conf);
    }
#line 1998
    if ((unsigned int )tmp___0 > 0U) {
#line 2002
      *(members->members + dst) = (Member )*current;
    } else {
      {
#line 2006
      init_member(members->members + dst);
#line 2007
      (members->members + dst)->type.secret = 1U;
      }
    }
#line 1994
    src ++;
#line 1994
    dst ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2011
  return ((Success )OK);
}
}
#line 2015 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern Success get_members(Conf_no conf_no , unsigned short first , unsigned short no_of_members ,
                           Member_list *members ) 
{ 
  Success tmp ;

  {
  {
#line 2023
  tmp = do_get_members(conf_no, first, no_of_members, members);
  }
#line 2023
  return (tmp);
}
}
#line 2029 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern Success get_members_old(Conf_no conf_no , unsigned short first , unsigned short no_of_members ,
                               Member_list *members ) 
{ 
  Success tmp ;

  {
  {
#line 2036
  tmp = do_get_members(conf_no, first, no_of_members, members);
  }
#line 2036
  return (tmp);
}
}
#line 2048 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
Success get_unread_confs(Pers_no pers_no , Conf_no_list *result ) 
{ 
  Person *pers_p ;
  Membership const   *confs ;
  Membership const   *end ;
  void *tmp ;
  Conf_no conf_no ;
  unsigned short tmp___0 ;
  Local_text_no tmp___1 ;
  Local_text_no tmp___2 ;
  enum memb_visibility tmp___3 ;

  {
  {
#line 2056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2056
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2056
      err_stat = 0UL;
#line 2056
      kom_errno = (enum kom_err )51;
#line 2056
      return ((Success )FAILURE);
    }
#line 2056
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2057
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2057
    if (! active_connection) {
#line 2057
      err_stat = 0UL;
#line 2057
      kom_errno = (enum kom_err )6;
#line 2057
      return ((Success )FAILURE);
    } else
#line 2057
    if (! active_connection->pers_no) {
#line 2057
      err_stat = 0UL;
#line 2057
      kom_errno = (enum kom_err )6;
#line 2057
      return ((Success )FAILURE);
    }
#line 2057
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2058
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2058
    pers_p = cached_get_person_stat(pers_no);
    }
#line 2058
    if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 2058
      return ((Success )FAILURE);
    }
#line 2058
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2060
  tmp = tmp_alloc((unsigned long )pers_p->conferences.no_of_confs * sizeof(Conf_no ));
#line 2060
  result->conf_nos = (Conf_no *)tmp;
#line 2062
  result->no_of_confs = (unsigned short)0;
#line 2064
  end = (Membership const   *)(pers_p->conferences.confs + pers_p->conferences.no_of_confs);
#line 2065
  confs = (Membership const   *)pers_p->conferences.confs;
  }
  {
#line 2065
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2065
    if (! ((unsigned long )confs < (unsigned long )end)) {
#line 2065
      goto while_break___2;
    }
#line 2067
    conf_no = (Conf_no )confs->conf_no;
#line 2069
    if (confs->type.passive == 0U) {
      {
#line 2069
      tmp___1 = last_text_read(confs);
#line 2069
      tmp___2 = cached_get_highest_local_no(conf_no);
      }
#line 2069
      if (tmp___1 < tmp___2) {
        {
#line 2069
        tmp___3 = membership_visible((Connection const   *)active_connection, pers_no,
                                     conf_no, (Membership_type )confs->type, (Bool )0,
                                     (Bool )0);
        }
#line 2069
        if ((unsigned int )tmp___3 > 0U) {
#line 2075
          tmp___0 = result->no_of_confs;
#line 2075
          result->no_of_confs = (unsigned short )((int )result->no_of_confs + 1);
#line 2075
          *(result->conf_nos + tmp___0) = conf_no;
        }
      }
    }
#line 2065
    confs ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2078
  return ((Success )OK);
}
}
#line 2086 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern Success set_unread(Conf_no conf_no , Text_no no_of_unread ) 
{ 
  Membership *mship ;
  Conference *conf_c ;
  Local_text_no highest ;
  Local_text_no tmp ;
  void *tmp___0 ;

  {
  {
#line 2094
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2094
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2094
      err_stat = 0UL;
#line 2094
      kom_errno = (enum kom_err )51;
#line 2094
      return ((Success )FAILURE);
    }
#line 2094
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2095
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2095
    if (! active_connection) {
#line 2095
      err_stat = 0UL;
#line 2095
      kom_errno = (enum kom_err )6;
#line 2095
      return ((Success )FAILURE);
    } else
#line 2095
    if (! active_connection->pers_no) {
#line 2095
      err_stat = 0UL;
#line 2095
      kom_errno = (enum kom_err )6;
#line 2095
      return ((Success )FAILURE);
    }
#line 2095
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2097
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2097
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 2097
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 2097
      return ((Success )FAILURE);
    }
#line 2097
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2099
  mship = locate_membership(conf_no, (Person const   *)active_connection->person);
  }
#line 2099
  if ((unsigned long )mship == (unsigned long )((void *)0)) {
#line 2101
    err_stat = (unsigned long )conf_no;
#line 2102
    kom_errno = (enum kom_err )13;
#line 2103
    return ((Success )FAILURE);
  }
  {
#line 2106
  tmp = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
#line 2106
  highest = tmp - 1UL;
  }
#line 2108
  if (highest > no_of_unread) {
    {
#line 2110
    mship->no_of_read_ranges = 1U;
#line 2111
    tmp___0 = srealloc((void *)mship->read_ranges, sizeof(*(mship->read_ranges + 0)));
#line 2111
    mship->read_ranges = (struct read_range *)tmp___0;
#line 2113
    (mship->read_ranges + 0)->first_read = (Local_text_no )1;
#line 2114
    (mship->read_ranges + 0)->last_read = highest - no_of_unread;
    }
  } else {
    {
#line 2118
    sfree((void *)mship->read_ranges);
#line 2119
    mship->read_ranges = (struct read_range *)((void *)0);
#line 2120
    mship->no_of_read_ranges = 0U;
    }
  }
  {
#line 2123
  mark_person_as_changed(active_connection->pers_no);
  }
#line 2124
  return ((Success )OK);
}
}
#line 2131 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern Success set_last_read(Conf_no conf_no , Local_text_no last_read ) 
{ 
  Membership *mship ;
  Conference *conf_c ;
  Local_text_no last___0 ;
  Local_text_no tmp ;
  void *tmp___0 ;

  {
  {
#line 2139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2139
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2139
      err_stat = 0UL;
#line 2139
      kom_errno = (enum kom_err )51;
#line 2139
      return ((Success )FAILURE);
    }
#line 2139
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2140
    if (! active_connection) {
#line 2140
      err_stat = 0UL;
#line 2140
      kom_errno = (enum kom_err )6;
#line 2140
      return ((Success )FAILURE);
    } else
#line 2140
    if (! active_connection->pers_no) {
#line 2140
      err_stat = 0UL;
#line 2140
      kom_errno = (enum kom_err )6;
#line 2140
      return ((Success )FAILURE);
    }
#line 2140
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2142
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2142
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 2142
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 2142
      return ((Success )FAILURE);
    }
#line 2142
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2144
  mship = locate_membership(conf_no, (Person const   *)active_connection->person);
  }
#line 2144
  if ((unsigned long )mship == (unsigned long )((void *)0)) {
#line 2146
    err_stat = (unsigned long )conf_no;
#line 2147
    kom_errno = (enum kom_err )13;
#line 2148
    return ((Success )FAILURE);
  }
  {
#line 2151
  tmp = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
#line 2151
  last___0 = tmp - 1UL;
  }
#line 2153
  if (last_read > last___0) {
#line 2154
    last_read = last___0;
  }
#line 2156
  if (last_read > 0UL) {
    {
#line 2158
    mship->no_of_read_ranges = 1U;
#line 2159
    tmp___0 = srealloc((void *)mship->read_ranges, sizeof(*(mship->read_ranges + 0)));
#line 2159
    mship->read_ranges = (struct read_range *)tmp___0;
#line 2161
    (mship->read_ranges + 0)->first_read = (Local_text_no )1;
#line 2162
    (mship->read_ranges + 0)->last_read = last_read;
    }
  } else {
    {
#line 2166
    sfree((void *)mship->read_ranges);
#line 2167
    mship->read_ranges = (struct read_range *)((void *)0);
#line 2168
    mship->no_of_read_ranges = 0U;
    }
  }
  {
#line 2171
  mark_person_as_changed(active_connection->pers_no);
  }
#line 2172
  return ((Success )OK);
}
}
#line 2175 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/membership.c"
extern Success set_membership_type(Pers_no pers_no , Conf_no conf_no , Membership_type *type ) 
{ 
  Conference *conf_c ;
  Person *pers_p ;
  Membership *membership ;
  Member *mbr ;
  enum access acc ;

  {
  {
#line 2186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2186
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 2186
      err_stat = 0UL;
#line 2186
      kom_errno = (enum kom_err )51;
#line 2186
      return ((Success )FAILURE);
    }
#line 2186
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2187
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2187
    if (! active_connection) {
#line 2187
      err_stat = 0UL;
#line 2187
      kom_errno = (enum kom_err )6;
#line 2187
      return ((Success )FAILURE);
    } else
#line 2187
    if (! active_connection->pers_no) {
#line 2187
      err_stat = 0UL;
#line 2187
      kom_errno = (enum kom_err )6;
#line 2187
      return ((Success )FAILURE);
    }
#line 2187
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2190
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2190
    conf_c = cached_get_conf_stat(conf_no);
    }
#line 2190
    if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 2190
      return ((Success )FAILURE);
    }
#line 2190
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2192
  acc = access_perm(conf_no, (Connection const   *)active_connection, (enum access )2);
  }
#line 2193
  if ((unsigned int )acc == 0U) {
#line 2195
    return ((Success )FAILURE);
  }
#line 2198
  if ((unsigned int )acc == 1U) {
#line 2200
    err_stat = (unsigned long )conf_no;
#line 2201
    kom_errno = (enum kom_err )9;
#line 2202
    return ((Success )FAILURE);
  }
  {
#line 2205
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 2205
    pers_p = cached_get_person_stat(pers_no);
    }
#line 2205
    if ((unsigned long )pers_p == (unsigned long )((void *)0)) {
#line 2205
      return ((Success )FAILURE);
    }
#line 2205
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2207
  acc = access_perm(pers_no, (Connection const   *)active_connection, (enum access )5);
  }
#line 2208
  if ((unsigned int )acc != 5U) {
#line 2208
    if (active_connection) {
#line 2208
      if ((int )active_connection->ena_level >= 8) {
#line 2208
        if (! (active_connection->person)->privileges.wheel) {
#line 2208
          goto _L___2;
        }
      } else {
#line 2208
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2208
    if (active_connection) {
#line 2208
      if ((int )active_connection->ena_level >= 6) {
#line 2208
        if (! (active_connection->person)->privileges.admin) {
#line 2208
          goto _L___0;
        }
      } else {
#line 2208
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2212
      err_stat = (unsigned long )pers_no;
#line 2213
      if (conf_c->type.secret) {
#line 2213
        kom_errno = (enum kom_err )9;
      } else {
#line 2213
        kom_errno = (enum kom_err )12;
      }
#line 2214
      return ((Success )FAILURE);
    }
  }
  {
#line 2218
  membership = locate_membership(conf_no, (Person const   *)pers_p);
  }
#line 2219
  if ((unsigned long )membership == (unsigned long )((void *)0)) {
#line 2221
    err_stat = (unsigned long )conf_no;
#line 2222
    kom_errno = (enum kom_err )13;
#line 2223
    return ((Success )FAILURE);
  }
  {
#line 2228
  mbr = locate_member(pers_no, conf_c);
  }
#line 2229
  if ((unsigned long )mbr == (unsigned long )((void *)0)) {
    {
#line 2236
    kom_log("Membership and member record mismatch for pers %lu in conf %lu\n", (unsigned long )pers_no,
            (unsigned long )conf_no);
#line 2239
    kom_log("You should run dbck\n");
#line 2240
    err_stat = (unsigned long )conf_no;
#line 2241
    kom_errno = (enum kom_err )13;
    }
#line 2242
    return ((Success )FAILURE);
  }
#line 2246
  if (type->secret) {
#line 2246
    if (! param.secret_memberships) {
#line 2250
      err_stat = 0UL;
#line 2251
      kom_errno = (enum kom_err )54;
#line 2252
      return ((Success )FAILURE);
    } else {
#line 2246
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 2246
  if (type->secret) {
#line 2246
    if (conf_c->type.forbid_secret) {
#line 2250
      err_stat = 0UL;
#line 2251
      kom_errno = (enum kom_err )54;
#line 2252
      return ((Success )FAILURE);
    } else {
#line 2246
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 2246
  if (! param.allow_reinvite) {
#line 2246
    if (type->invitation) {
#line 2246
      if (! membership->type.invitation) {
#line 2250
        err_stat = 0UL;
#line 2251
        kom_errno = (enum kom_err )54;
#line 2252
        return ((Success )FAILURE);
      }
    }
  }
  {
#line 2257
  membership->type = *type;
#line 2258
  mbr->type = *type;
#line 2261
  mark_conference_as_changed(conf_no);
#line 2262
  mark_person_as_changed(pers_no);
  }
#line 2265
  return ((Success )OK);
}
}
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 538 "/usr/include/stdio.h"
extern int getchar(void) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 376 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 264 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 34 "./../libraries/liboop/oop.h"
extern int _oop_continue ;
#line 59
extern void *(*oop_malloc)(size_t  ) ;
#line 60
extern void *(*oop_realloc)(void * , size_t  ) ;
#line 61
extern void (*oop_free)(void * ) ;
#line 69
extern oop_source_sys *oop_sys_new(void) ;
#line 79
extern void oop_sys_delete(oop_source_sys * ) ;
#line 82
extern oop_source *oop_sys_source(oop_source_sys * ) ;
#line 115
extern oop_adapter_signal *oop_signal_new(oop_source * ) ;
#line 116
extern void oop_signal_delete(oop_adapter_signal * ) ;
#line 117
extern oop_source *oop_signal_source(oop_adapter_signal * ) ;
#line 119
extern void oop_signal_use_sa_restart(void) ;
#line 205 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
struct isc_mcb *kom_server_mcb ;
#line 351
void toploop(void) ;
#line 354
void dump_statistics(void) ;
#line 357
void logout_all_clients(void) ;
#line 364
void *handle_accept_event(struct isc_scb *qazwsxedcaccepting_session  __attribute__((__unused__)) ,
                          struct isc_scb *new_session ) ;
#line 48 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.h"
void dump_allocated_connections(FILE *fp ) ;
#line 31 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/oop-malloc.h"
void *oop_malloc_wrapper(size_t size ) ;
#line 35
void oop_free_wrapper(void *ptr ) ;
#line 38
void *oop_realloc_wrapper(void *ptr , size_t size ) ;
#line 42
void dump_oop_alloc_counts(FILE *stat_file ) ;
#line 34 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/isc-malloc.h"
void *isc_malloc_wrapper(size_t size ) ;
#line 38
void isc_free_wrapper(void *ptr ) ;
#line 41
void *isc_realloc_wrapper(void *ptr , size_t size ) ;
#line 45
void dump_isc_alloc_counts(FILE *stat_file ) ;
#line 106 "./../libraries/libisc-new/src/isc.h"
extern void isc_setallocfn(void *(*mallocfn)(size_t size ) , void *(*reallocfn)(void *buf ,
                                                                                size_t size ) ,
                           void (*freefn)(void *buf ) ) ;
#line 114
extern struct isc_mcb *isc_initialize(oop_source * , isc_write_queue_change_cb * ) ;
#line 118
extern void isc_cfg_fd_relocate(struct isc_mcb * , int fd_relocate ) ;
#line 135
extern void isc_cfg_stale_timeout(struct isc_mcb * , struct timeval stale , struct timeval default_idle ) ;
#line 140
extern void isc_cfg_queue_size(struct isc_mcb * , int max_queue_size_bytes , int max_msg_size ,
                               int max_queue_size_msgs , int max_dequeue_msgs ) ;
#line 152
extern void isc_shutdown(struct isc_mcb *mcb ) ;
#line 161
extern struct isc_scb *isc_listentcp(struct isc_mcb *mcb , char const   *address ,
                                     char const   *service , isc_accept_callback *cb ) ;
#line 295
extern int isc_getportnum(union isc_address *ia ) ;
#line 34 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/isc-interface.h"
oop_source_sys *kom_server_oop_src ;
#line 36 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache.h"
extern Success init_cache(void) ;
#line 39
void free_all_cache(void) ;
#line 58
extern void cache_sync_all(void) ;
#line 64
void dump_cache_stats(FILE *fp ) ;
#line 65
void dump_cache_mem_usage(FILE *fp ) ;
#line 290 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
void initialize_aux_items(char *aux_def_file ) ;
#line 291
void free_aux_item_definitions(void) ;
#line 28 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/sigflags.h"
Bool go_and_die ;
#line 87 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.h"
extern void dump_l2g_stats(FILE *file ) ;
#line 120 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
struct timeval current_time  =    {(__time_t )0, (__suseconds_t )0};
#line 124 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
int buglevel  =    0;
#line 130 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static int foreground  =    0;
#line 132 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static oop_adapter_signal *kom_signal_adapter  ;
#line 134
static void dump_exit_statistics(void) ;
#line 135
static void free_kom_info(void) ;
#line 136
static void *sighandler_term(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                             int sig , void *qazwsxedcuser  __attribute__((__unused__)) ) ;
#line 137
static void *sighandler_quit(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                             int qazwsxedcsig  __attribute__((__unused__)) , void *qazwsxedcuser  __attribute__((__unused__)) ) ;
#line 138
static void *sighandler_usr1(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                             int qazwsxedcsig  __attribute__((__unused__)) , void *qazwsxedcuser  __attribute__((__unused__)) ) ;
#line 139
static void *sighandler_usr2(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                             int qazwsxedcsig  __attribute__((__unused__)) , void *qazwsxedcuser  __attribute__((__unused__)) ) ;
#line 140
static void *sighandler_winch(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                              int qazwsxedcsig  __attribute__((__unused__)) , void *qazwsxedcuser  __attribute__((__unused__)) ) ;
#line 153 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
__inline static void set_handler_sig_ign(struct sigaction *ptr ) 
{ 


  {
#line 156
  ptr->__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 157
  return;
}
}
#line 161
static void write_queue_change_callback(int delta ) ;
#line 163 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static void write_queue_change_callback(int delta ) 
{ 


  {
  {
#line 166
  update_stat((enum stat_type )8, (long )delta);
  }
#line 167
  return;
}
}
#line 170 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static void server_init(char const   *host , char const   *client_port ) 
{ 
  struct isc_scb *listen_client ;
  oop_source *src ;
  struct sigaction act ;
  oop_source *tmp ;
  oop_source *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 179
  oop_malloc = & oop_malloc_wrapper;
#line 180
  oop_realloc = & oop_realloc_wrapper;
#line 181
  oop_free = & oop_free_wrapper;
#line 183
  kom_server_oop_src = oop_sys_new();
  }
#line 184
  if ((unsigned long )kom_server_oop_src == (unsigned long )((void *)0)) {
    {
#line 185
    restart_kom("server_init: can\'t get system event source\n");
    }
  }
  {
#line 187
  tmp = oop_sys_source(kom_server_oop_src);
#line 187
  kom_signal_adapter = oop_signal_new(tmp);
  }
#line 188
  if ((unsigned long )kom_signal_adapter == (unsigned long )((void *)0)) {
    {
#line 189
    restart_kom("server_init: can\'t create signal adapter\n");
    }
  }
  {
#line 197
  sigemptyset(& act.sa_mask);
#line 198
  act.sa_flags = 0;
#line 199
  set_handler_sig_ign(& act);
#line 200
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 201
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 202
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 203
  sigaction(3, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 204
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 205
  sigaction(12, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 206
  sigaction(28, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 217
  src = oop_signal_source(kom_signal_adapter);
#line 218
  oop_signal_use_sa_restart();
#line 219
  (*(src->on_signal))(src, 1, & sighandler_term, (void *)0);
#line 220
  (*(src->on_signal))(src, 15, & sighandler_term, (void *)0);
#line 221
  (*(src->on_signal))(src, 2, & sighandler_term, (void *)0);
#line 222
  (*(src->on_signal))(src, 3, & sighandler_quit, (void *)0);
#line 223
  (*(src->on_signal))(src, 10, & sighandler_usr1, (void *)0);
#line 224
  (*(src->on_signal))(src, 12, & sighandler_usr2, (void *)0);
#line 225
  (*(src->on_signal))(src, 28, & sighandler_winch, (void *)0);
#line 230
  isc_setallocfn(& isc_malloc_wrapper, & isc_realloc_wrapper, & isc_free_wrapper);
#line 234
  tmp___0 = oop_sys_source(kom_server_oop_src);
#line 234
  kom_server_mcb = isc_initialize(tmp___0, & write_queue_change_callback);
  }
#line 236
  if ((unsigned long )kom_server_mcb == (unsigned long )((void *)0)) {
    {
#line 237
    restart_kom("server_init: can\'t isc_initialize()\n");
    }
  }
  {
#line 238
  isc_cfg_fd_relocate(kom_server_mcb, 22);
#line 239
  isc_cfg_stale_timeout(kom_server_mcb, param.stale_timeout, param.connect_timeout);
#line 241
  isc_cfg_queue_size(kom_server_mcb, param.maxqueuedsize_bytes, param.maxmsgsize,
                     param.maxqueuedsize, param.maxdequeuelen);
#line 247
  listen_client = isc_listentcp(kom_server_mcb, host, client_port, & handle_accept_event);
  }
#line 249
  if ((unsigned long )listen_client == (unsigned long )((void *)0)) {
    {
#line 250
    restart_kom("server_init: can\'t isc_listentcp(CLIENT)\n");
    }
  }
  {
#line 252
  tmp___1 = isc_getportnum(listen_client->laddr);
#line 252
  kom_log("Listening for clients on %d.\n", tmp___1);
#line 261
  sigemptyset(& act.sa_mask);
#line 262
  act.sa_flags = 0;
#line 263
  set_handler_sig_ign(& act);
#line 264
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 268
  return;
}
}
#line 270 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static void init_data_base(void) 
{ 
  Success tmp ;

  {
  {
#line 273
  kom_log("Database = %s\n", param.datafile_name);
#line 274
  kom_log("Backup = %s\n", param.backupfile_name);
#line 275
  kom_log("2nd Backup = %s\n", param.backupfile_name_2);
#line 276
  kom_log("Lock File = %s\n", param.lockfile_name);
#line 278
  tmp = init_cache();
  }
#line 278
  if ((unsigned long )tmp == (unsigned long )FAILURE) {
    {
#line 279
    restart_kom("Cannot find database.\n");
    }
  }
#line 280
  return;
}
}
#line 282 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static void *sighandler_term(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                             int sig , void *qazwsxedcuser  __attribute__((__unused__)) ) 
{ 


  {
#line 287
  if (sig == 15) {
    {
#line 288
    kom_log("Signal TERM received. Shutting down server.\n");
    }
  } else
#line 289
  if (sig == 1) {
    {
#line 290
    kom_log("Signal HUP received. Shutting down server. Please use SIGTERM instead.\n");
    }
  } else
#line 292
  if (sig == 2) {
    {
#line 293
    kom_log("Signal INT received. Shutting down server. Please use SIGTERM instead.\n");
    }
  } else {
    {
#line 296
    kom_log("Some signal received. Shutting down server. Please use SIGTERM instead.\n");
    }
  }
#line 299
  go_and_die = (Bool )1;
#line 300
  return ((void *)0);
}
}
#line 303 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static void *sighandler_quit(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                             int qazwsxedcsig  __attribute__((__unused__)) , void *qazwsxedcuser  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 308
  kom_log("Signal QUIT received - syncing...\n");
#line 309
  cache_sync_all();
#line 310
  kom_log("Dumping core now.\n");
#line 311
  abort();
  }
}
}
#line 314 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static void *sighandler_usr1(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                             int qazwsxedcsig  __attribute__((__unused__)) , void *qazwsxedcuser  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 319
  dump_statistics();
  }
#line 320
  return ((void *)(& _oop_continue));
}
}
#line 323 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static void *sighandler_usr2(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                             int qazwsxedcsig  __attribute__((__unused__)) , void *qazwsxedcuser  __attribute__((__unused__)) ) 
{ 
  int child ;

  {
  {
#line 330
  kom_log("Signal USR2 received - will dump core now.  (Check that child dies.)\n");
#line 331
  child = fork();
  }
#line 331
  if (child == 0) {
    {
#line 333
    abort();
#line 334
    kom_log("Abort() failed!!!\n");
#line 335
    exit(1);
    }
  } else
#line 337
  if (child < 0) {
    {
#line 339
    kom_log("Couldn\'t fork.\n");
    }
  } else {
    {
#line 343
    wait((union wait *)((void *)0));
    }
  }
#line 345
  return ((void *)(& _oop_continue));
}
}
#line 348 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static void *sighandler_winch(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                              int qazwsxedcsig  __attribute__((__unused__)) , void *qazwsxedcuser  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 353
  free_aux_item_definitions();
#line 354
  initialize_aux_items(param.aux_def_file);
#line 355
  kom_log("Signal WINCH received. aux definitions reloaded.\n");
  }
#line 356
  return ((void *)(& _oop_continue));
}
}
#line 359 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static void save_pid(void) 
{ 
  FILE *fp ;
  __pid_t tmp ;

  {
  {
#line 364
  fp = i_fopen((char const   *)param.pid_name, "w");
  }
#line 364
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 365
    return;
  }
  {
#line 367
  tmp = getpid();
#line 367
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%ld\n", (long )tmp);
#line 368
  i_fclose(fp);
  }
#line 369
  return;
}
}
#line 371 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static void go_daemon(void) 
{ 
  pid_t child ;
  int fd ;
  struct sigaction act ;
  int *tmp ;
  __pid_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __pid_t tmp___5 ;

  {
#line 380
  if (foreground != 0) {
#line 382
    return;
  }
  {
#line 385
  tmp___0 = getppid();
  }
#line 385
  if (tmp___0 != 1) {
    {
#line 391
    sigemptyset(& act.sa_mask);
#line 392
    act.sa_flags = 0;
#line 393
    set_handler_sig_ign(& act);
#line 396
    sigaction(22, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 399
    sigaction(21, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 402
    sigaction(20, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 419
    child = fork();
    }
#line 420
    if (child < 0) {
      {
#line 421
      tmp = __errno_location();
#line 421
      restart_kom("fork failed: %d\n", *tmp);
      }
    } else
#line 422
    if (child > 0) {
      {
#line 423
      exit(0);
      }
    }
    {
#line 425
    setsid();
    }
  }
#line 429
  fd = 0;
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! (fd < fd_ceiling)) {
#line 429
      goto while_break;
    }
    {
#line 430
    close(fd);
#line 429
    fd ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 431
  tmp___2 = open("/dev/null", 0);
  }
#line 431
  if (tmp___2 != 0) {
    {
#line 437
    tmp___1 = __errno_location();
#line 437
    restart_kom("open of log file failed: %d\n", *tmp___1);
    }
  } else {
    {
#line 431
    tmp___3 = open("/dev/null", 1);
    }
#line 431
    if (tmp___3 != 1) {
      {
#line 437
      tmp___1 = __errno_location();
#line 437
      restart_kom("open of log file failed: %d\n", *tmp___1);
      }
    } else {
      {
#line 431
      tmp___4 = open((char const   *)param.logfile_name, 1089, 420);
      }
#line 431
      if (tmp___4 != 2) {
        {
#line 437
        tmp___1 = __errno_location();
#line 437
        restart_kom("open of log file failed: %d\n", *tmp___1);
        }
      }
    }
  }
  {
#line 439
  tmp___5 = getpid();
#line 439
  kom_log("*** Version %s (process %lu) coming up.\n", kom_version_info.server_version,
          (unsigned long )tmp___5);
  }
#line 441
  return;
}
}
#line 443 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static void initialize(char const   *config_file ) 
{ 
  struct rlimit rlim ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 450
  read_configuration(config_file);
#line 451
  initialize_aux_items(param.aux_def_file);
  }
#line 454
  if ((unsigned long )param.use_locale != (unsigned long )((void *)0)) {
    {
#line 455
    tmp = setlocale(0, (char const   *)param.use_locale);
    }
#line 455
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 457
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"setlocale: ");
#line 458
      perror((char const   *)param.use_locale);
#line 459
      exit(1);
      }
    }
  }
#line 469
  if (param.no_files != -1) {
#line 469
    if (param.no_files > 1024) {
      {
#line 471
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The \"Open files: %ld\" is too large: FD_SETSIZE is %ld\n",
              (long )param.no_files, 1024L);
#line 474
      exit(1);
      }
    }
  }
  {
#line 478
  tmp___0 = getrlimit(7, & rlim);
  }
#line 478
  if (tmp___0 < 0) {
    {
#line 480
    perror("getrlimit(RLIMIT_NOFILE) failed");
#line 481
    exit(1);
    }
  }
#line 484
  if (param.no_files != -1) {
#line 486
    if ((rlim_t )param.no_files > rlim.rlim_max) {
      {
#line 488
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"attempt to raise open files from %ld to %ld, but only %ld is allowed\n",
              (long )rlim.rlim_cur, (long )param.no_files, (long )rlim.rlim_max);
#line 492
      rlim.rlim_cur = rlim.rlim_max;
      }
    } else {
#line 495
      rlim.rlim_cur = (rlim_t )param.no_files;
    }
    {
#line 497
    tmp___1 = setrlimit(7, (struct rlimit  const  *)(& rlim));
    }
#line 497
    if (tmp___1 < 0) {
      {
#line 499
      perror("setrlimit failed");
#line 500
      exit(1);
      }
    }
    {
#line 502
    tmp___2 = getrlimit(7, & rlim);
    }
#line 502
    if (tmp___2 < 0) {
      {
#line 504
      perror("getrlimit(RLIMIT_NOFILE) failed");
#line 505
      exit(1);
      }
    }
#line 507
    if (rlim.rlim_cur != (rlim_t )param.no_files) {
      {
#line 508
      restart_kom("getrlimit after setrlimit returns %ld, not %ld.\n", (long )rlim.rlim_cur,
                  (long )param.no_files);
      }
    }
  }
#line 511
  fd_ceiling = (int )rlim.rlim_cur;
#line 538
  if (fd_ceiling > 1024) {
#line 539
    fd_ceiling = 1024;
  }
  {
#line 541
  go_daemon();
#line 542
  tmp___3 = lock_db();
  }
#line 542
  if (tmp___3 < 0) {
    {
#line 548
    kom_log("Cannot obtain database lock.  Exiting.\n");
    }
#line 549
    if (foreground) {
      {
#line 551
      kom_log("Press enter to terminate lyskomd\n");
#line 552
      getchar();
      }
    }
    {
#line 555
    exit(1);
    }
  }
  {
#line 558
  server_init((char const   *)param.ip_client_host, (char const   *)param.ip_client_port);
#line 559
  init_data_base();
  }
#line 560
  return;
}
}
#line 683 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static void dump_exit_statistics(void) 
{ 
  FILE *stat_file ;
  time_t now ;
  char *tmp ;

  {
  {
#line 689
  time(& now);
#line 690
  stat_file = i_fopen((char const   *)param.memuse_name, "a");
  }
#line 692
  if ((unsigned long )stat_file == (unsigned long )((void *)0)) {
    {
#line 693
    restart_kom("Can\'t open file to save memory usage to.\n");
    }
  }
  {
#line 695
  tmp = ctime((time_t const   *)(& now));
#line 695
  fprintf((FILE */* __restrict  */)stat_file, (char const   */* __restrict  */)"\nLysKOM Server going down at %s\n",
          tmp);
#line 697
  dump_cache_stats(stat_file);
#line 699
  free_all_tmp();
#line 700
  free_all_cache();
#line 701
  free_all_jubel();
#line 702
  free_kom_info();
#line 703
  free_aux_item_definitions();
#line 704
  free_configuration();
#line 705
  free_default_config_file_name();
#line 707
  dump_smalloc_counts(stat_file);
#line 708
  dump_alloc_counts(stat_file);
#line 709
  dump_cache_mem_usage(stat_file);
#line 710
  dump_string_alloc_counts(stat_file);
#line 711
  dump_allocated_connections(stat_file);
#line 712
  dump_isc_alloc_counts(stat_file);
#line 713
  dump_oop_alloc_counts(stat_file);
#line 714
  dump_l2g_stats(stat_file);
#line 715
  i_fclose(stat_file);
  }
#line 716
  return;
}
}
#line 718 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ramkomd.c"
static void free_kom_info(void) 
{ 
  unsigned long i ;

  {
#line 723
  if ((unsigned long )kom_info.aux_item_list.items != (unsigned long )((void *)0)) {
#line 725
    i = 0UL;
    {
#line 725
    while (1) {
      while_continue: /* CIL Label */ ;
#line 725
      if (! (i < (unsigned long )kom_info.aux_item_list.length)) {
#line 725
        goto while_break;
      }
      {
#line 727
      s_clear(& (kom_info.aux_item_list.items + i)->data);
#line 725
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 729
    sfree((void *)kom_info.aux_item_list.items);
    }
  }
#line 731
  kom_info.aux_item_list.length = (unsigned short)0;
#line 732
  kom_info.aux_item_list.items = (Aux_item *)0;
#line 733
  return;
}
}
#line 33 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.h"
Connection *new_client(void) ;
#line 36
void kill_client(Connection *cp ) ;
#line 59 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c"
static Connection *all_connections  =    (Connection *)((void *)0);
#line 60 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c"
static Session_no no_of_connection_attempts  =    (Session_no )0;
#line 64 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c"
static Connection *last_conn  =    (Connection *)((void *)0);
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c"
static int no_of_allocated_connections  =    0;
#line 71
static void init_connection(Connection *conn ) ;
#line 71 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c"
static enum async  const  default_want_async[8]  = 
#line 71
  {      (enum async  const  )0,      (enum async  const  )5,      (enum async  const  )7,      (enum async  const  )8, 
        (enum async  const  )9,      (enum async  const  )11,      (enum async  const  )12,      (enum async  const  )13};
#line 68 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c"
static void init_connection(Connection *conn ) 
{ 
  int i ;

  {
  {
#line 74
  conn->prev = (struct connection *)((void *)0);
#line 75
  conn->next = (struct connection *)((void *)0);
#line 76
  conn->pers_no = (Pers_no )0;
#line 77
  conn->person = (Person *)((void *)0);
#line 78
  conn->connect_time = timeval_ctor((time_t )0, 0);
#line 79
  conn->login_time = timeval_ctor((time_t )0, 0);
#line 80
  conn->cwc = (Conf_no )0;
#line 81
  conn->what_am_i_doing = (String )EMPTY_STRING;
#line 82
  conn->ena_level = (unsigned char)0;
#line 83
  conn->username = (String )EMPTY_STRING;
#line 84
  conn->ident_user = (String )EMPTY_STRING;
#line 85
  conn->client_name = (String )EMPTY_STRING;
#line 86
  conn->client_version = (String )EMPTY_STRING;
#line 87
  conn->flags.invisible = 0U;
#line 88
  conn->flags.user_active_used = 0U;
#line 89
  conn->flags.user_absent = 0U;
#line 90
  conn->flags.reserved3 = 0U;
#line 91
  conn->flags.reserved4 = 0U;
#line 92
  conn->flags.reserved5 = 0U;
#line 93
  conn->flags.reserved6 = 0U;
#line 94
  conn->flags.reserved7 = 0U;
#line 95
  conn->username_valid = (Bool )0;
#line 96
  conn->dns_done = (Bool )0;
#line 97
  conn->blocked_by_dns = (Bool )0;
#line 98
  conn->isc_session = (struct isc_scb *)((void *)0);
#line 99
  conn->remote_ip = (String )EMPTY_STRING;
#line 100
  conn->peer = (char *)((void *)0);
#line 101
  conn->protocol = (unsigned char )'\000';
#line 102
  conn->use_utc = (Bool )0;
#line 103
  conn->parse_pos = 0;
#line 104
  conn->fnc_parse_pos = 0;
#line 105
  conn->array_parse_pos = 0;
#line 106
  conn->array_parse_index = 0;
#line 107
  conn->array_parse_parsed_length = 0;
#line 108
  conn->struct_parse_pos = 0;
#line 109
  conn->string_parse_pos = 0;
#line 110
  conn->hunt_parse_pos = 0;
#line 111
  conn->array_hunt_num = 0;
#line 112
  conn->array_hunt_depth = 0;
#line 113
  conn->ref_no = 0;
#line 114
  conn->function = (enum call_header )0;
#line 115
  conn->function_index = 0;
#line 116
  conn->num_list.length = 0;
#line 117
  conn->num_list.data = (long *)((void *)0);
#line 119
  conn->num0 = 0L;
#line 120
  conn->num1 = 0L;
#line 121
  conn->num2 = 0L;
#line 122
  conn->num3 = 0L;
#line 123
  conn->num4 = 0L;
#line 124
  conn->c_string0 = (String )EMPTY_STRING;
#line 125
  conn->c_string1 = (String )EMPTY_STRING;
#line 126
  conn->string0 = (String )EMPTY_STRING;
#line 127
  conn->misc_info_list.no_of_misc = (unsigned short)0;
#line 128
  conn->misc_info_list.misc = (Misc_info *)((void *)0);
#line 129
  conn->aux_item_list.items = (Aux_item *)((void *)0);
#line 130
  conn->aux_item_list.length = (unsigned short)0;
#line 131
  conn->aux_item.data = (String )EMPTY_STRING;
#line 132
  conn->dummy_aux_item.data = (String )EMPTY_STRING;
#line 133
  conn->read_range_list.ranges = (struct read_range *)((void *)0);
#line 134
  conn->read_range_list.length = (unsigned short)0;
#line 135
  init_priv_bits(& conn->priv_bits);
#line 136
  init_conf_type(& conn->conf_type);
#line 137
  init_membership_type(& conn->membership_type);
#line 138
  init_struct_tm(& conn->time);
#line 140
  conn->info.pers_pres_conf = (Conf_no )0;
#line 141
  conn->info.conf_pres_conf = (Conf_no )0;
#line 142
  conn->info.motd_conf = (Conf_no )0;
#line 143
  conn->info.kom_news_conf = (Conf_no )0;
#line 144
  conn->info.motd_of_lyskom = (Text_no )0;
#line 145
  conn->info.version = 0L;
#line 146
  conn->info.highest_aux_no = 0UL;
#line 147
  conn->info.aux_item_list.length = (unsigned short)0;
#line 148
  conn->info.aux_item_list.items = (Aux_item *)((void *)0);
#line 150
  init_personal_flags(& conn->pers_flags);
#line 151
  conn->unparsed = (String )EMPTY_STRING;
#line 152
  conn->first_to_parse = (String_size )0;
#line 153
  conn->more_to_parse = (Bool )0;
#line 154
  conn->kill_status = (enum kill_state )0;
#line 155
  conn->penalty = 0U;
#line 156
  conn->penalty_generation = 0U;
#line 158
  conn->queue_next = (struct connection *)((void *)0);
#line 159
  conn->queue_prev = (struct connection *)((void *)0);
#line 160
  conn->on_queue = (Bool )0;
#line 162
  conn->schedule.priority = (unsigned short)0;
#line 163
  conn->schedule.weight = (unsigned short)1;
#line 165
  conn->active_time = current_time;
#line 166
  conn->session_no = (Session_no )0;
#line 168
  i = 0;
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i < 23)) {
#line 168
      goto while_break;
    }
#line 169
    conn->want_async[i] = (Bool )0;
#line 168
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  i = 0;
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (! ((size_t )i < sizeof(default_want_async) / sizeof(default_want_async[0]))) {
#line 171
      goto while_break___0;
    }
#line 174
    conn->want_async[default_want_async[i]] = (Bool )1;
#line 171
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c"
static Connection *alloc_connection(void) 
{ 
  Connection *res ;
  void *tmp ;

  {
  {
#line 182
  tmp = smalloc(sizeof(Connection ));
#line 182
  res = (Connection *)tmp;
#line 183
  init_connection(res);
#line 184
  no_of_allocated_connections ++;
  }
#line 185
  return (res);
}
}
#line 188 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c"
Connection *new_client(void) 
{ 
  Connection *c ;

  {
  {
#line 193
  c = alloc_connection();
  }
#line 195
  if ((unsigned long )all_connections != (unsigned long )((void *)0)) {
#line 197
    (all_connections->prev)->next = c;
#line 198
    c->prev = all_connections->prev;
#line 199
    all_connections->prev = c;
#line 200
    c->next = all_connections;
  } else {
#line 204
    c->prev = c;
#line 205
    c->next = c;
  }
#line 208
  all_connections = c;
#line 210
  no_of_connection_attempts ++;
#line 210
  c->session_no = no_of_connection_attempts;
#line 211
  c->protocol = (unsigned char )'\000';
#line 212
  c->unparsed = (String )EMPTY_STRING;
#line 213
  c->first_to_parse = (String_size )0;
#line 214
  c->kill_status = (enum kill_state )0;
#line 215
  c->more_to_parse = (Bool )1;
#line 216
  c->active_time = current_time;
#line 217
  c->pers_no = (Pers_no )0;
#line 218
  c->person = (Person *)((void *)0);
#line 219
  c->connect_time = current_time;
#line 220
  c->login_time = current_time;
#line 221
  c->cwc = (Conf_no )0;
#line 222
  c->what_am_i_doing = (String )EMPTY_STRING;
#line 223
  c->ena_level = (unsigned char)0;
#line 224
  c->username = (String )EMPTY_STRING;
#line 225
  c->ident_user = (String )EMPTY_STRING;
#line 226
  c->client_name = (String )EMPTY_STRING;
#line 227
  c->client_version = (String )EMPTY_STRING;
#line 228
  c->flags.invisible = 0U;
#line 229
  c->flags.user_active_used = 0U;
#line 230
  c->flags.user_absent = 0U;
#line 231
  c->flags.reserved3 = 0U;
#line 232
  c->flags.reserved4 = 0U;
#line 233
  c->flags.reserved5 = 0U;
#line 234
  c->flags.reserved6 = 0U;
#line 235
  c->flags.reserved7 = 0U;
#line 236
  c->username_valid = (Bool )0;
#line 237
  c->dns_done = (Bool )0;
#line 238
  c->blocked_by_dns = (Bool )0;
#line 239
  c->use_utc = (Bool )0;
#line 241
  return (c);
}
}
#line 247 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c"
void kill_client(Connection *cp ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 250
  if ((unsigned long )all_connections == (unsigned long )((void *)0)) {
    {
#line 251
    restart_kom("kill_client(): No clients in all_connections list\n");
    }
  }
#line 253
  if ((unsigned long )all_connections == (unsigned long )all_connections->next) {
#line 255
    if ((unsigned long )all_connections->prev != (unsigned long )all_connections) {
      {
#line 256
      restart_kom("kill_client(): all_connections corrupt (LINK)\n");
      }
    }
#line 258
    if ((unsigned long )all_connections != (unsigned long )cp) {
      {
#line 259
      restart_kom("kill_client(): all_connections corrupt (SINGLE)\n");
      }
    }
#line 261
    all_connections = (Connection *)((void *)0);
  } else {
#line 265
    if ((unsigned long )cp->prev == (unsigned long )((void *)0)) {
      {
#line 266
      restart_kom("kill_client(): all_connections corrupt (NULL)\n");
      }
    } else
#line 265
    if ((unsigned long )cp->next == (unsigned long )((void *)0)) {
      {
#line 266
      restart_kom("kill_client(): all_connections corrupt (NULL)\n");
      }
    }
#line 268
    (cp->prev)->next = cp->next;
#line 269
    (cp->next)->prev = cp->prev;
#line 271
    if ((unsigned long )all_connections == (unsigned long )cp) {
#line 272
      all_connections = cp->next;
    }
  }
#line 275
  if ((unsigned long )last_conn == (unsigned long )cp) {
#line 276
    last_conn = (Connection *)((void *)0);
  }
  {
#line 278
  update_stat((enum stat_type )9, - (cp->unparsed.len - cp->first_to_parse));
#line 281
  s_clear(& cp->unparsed);
#line 282
  s_clear(& cp->what_am_i_doing);
#line 283
  s_clear(& cp->username);
#line 284
  s_clear(& cp->ident_user);
#line 285
  s_clear(& cp->client_name);
#line 286
  s_clear(& cp->client_version);
#line 287
  s_clear(& cp->remote_ip);
  }
#line 289
  if ((unsigned long )cp->isc_session != (unsigned long )((void *)0)) {
    {
#line 291
    kom_log("kill_client(): client %ld has isc_session != NULL.\n", cp->session_no);
    }
  }
#line 295
  if (! ((unsigned int )cp->on_queue == 0U)) {
    {
#line 295
    __assert_fail("cp->on_queue == FALSE", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c",
                  295U, "kill_client");
    }
  }
#line 297
  if (cp->c_string0.len == 0L) {
#line 297
    tmp = 1;
  } else {
#line 297
    tmp = 0;
  }
#line 297
  if (tmp) {
#line 297
    if (cp->c_string1.len == 0L) {
#line 297
      tmp___0 = 1;
    } else {
#line 297
      tmp___0 = 0;
    }
#line 297
    if (tmp___0) {
#line 297
      if (cp->string0.len == 0L) {
#line 297
        tmp___1 = 1;
      } else {
#line 297
        tmp___1 = 0;
      }
#line 297
      if (! tmp___1) {
        {
#line 300
        kom_log("kill_client(): unexpected string remains.\n");
        }
      }
    } else {
      {
#line 300
      kom_log("kill_client(): unexpected string remains.\n");
      }
    }
  } else {
    {
#line 300
    kom_log("kill_client(): unexpected string remains.\n");
    }
  }
#line 303
  if ((unsigned long )cp->misc_info_list.misc != (unsigned long )((void *)0)) {
    {
#line 304
    kom_log("kill_client(): unexpected misc_info_list remains.\n");
    }
  }
#line 306
  if ((unsigned long )cp->num_list.data != (unsigned long )((void *)0)) {
    {
#line 307
    kom_log("kill_client(): unexpected num_list remains.\n");
    }
  }
#line 309
  if (cp->aux_item.data.len == 0L) {
#line 309
    tmp___2 = 1;
  } else {
#line 309
    tmp___2 = 0;
  }
#line 309
  if (! tmp___2) {
    {
#line 310
    kom_log("kill_client(): unexpected aux_item string remains.\n");
    }
  }
#line 312
  if (cp->dummy_aux_item.data.len == 0L) {
#line 312
    tmp___3 = 1;
  } else {
#line 312
    tmp___3 = 0;
  }
#line 312
  if (! tmp___3) {
    {
#line 313
    kom_log("kill_client(): unexpected dummy_aux_item string remains.\n");
    }
  }
#line 315
  if ((unsigned long )cp->aux_item_list.items != (unsigned long )((void *)0)) {
    {
#line 316
    kom_log("kill_client(): unexpected aux-item list reamins.\n");
    }
  }
  {
#line 318
  sfree((void *)cp->peer);
#line 319
  sfree((void *)cp);
#line 320
  no_of_allocated_connections --;
  }
#line 321
  return;
}
}
#line 326 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c"
Connection *get_conn_by_number(Session_no session_no ) 
{ 
  Connection *end ;

  {
#line 331
  if ((unsigned long )all_connections == (unsigned long )((void *)0)) {
#line 332
    return ((Connection *)((void *)0));
  }
#line 334
  if ((unsigned long )last_conn == (unsigned long )((void *)0)) {
#line 335
    last_conn = all_connections;
  }
#line 337
  end = last_conn;
#line 339
  if (session_no == 0UL) {
#line 341
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
      {
#line 342
      restart_kom("get_conn_by_number: No session-no and no active connection");
      }
    }
#line 344
    session_no = active_connection->session_no;
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (last_conn->session_no == session_no) {
#line 350
      return (last_conn);
    }
#line 352
    last_conn = last_conn->next;
#line 347
    if (! ((unsigned long )last_conn != (unsigned long )end)) {
#line 347
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return ((Connection *)((void *)0));
}
}
#line 360 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c"
Session_no traverse_connections(Session_no session_no ) 
{ 
  Connection *prev ;

  {
#line 363
  prev = (Connection *)((void *)0);
#line 365
  if ((unsigned long )all_connections == (unsigned long )((void *)0)) {
#line 366
    return ((Session_no )0);
  }
#line 368
  if (session_no == 0UL) {
#line 369
    prev = (Connection *)((void *)0);
  } else {
    {
#line 371
    prev = get_conn_by_number(session_no);
    }
  }
#line 375
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 376
    return (all_connections->session_no);
  } else
#line 377
  if ((unsigned long )prev->next == (unsigned long )all_connections) {
#line 378
    return ((Session_no )0);
  } else {
#line 380
    return ((prev->next)->session_no);
  }
}
}
#line 383 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c"
void dump_allocated_connections(FILE *fp ) 
{ 


  {
  {
#line 386
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"---%s:\n\tConnections:      %d\n",
          "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c",
          no_of_allocated_connections);
#line 389
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\tConnection attempts:\t%lu\n",
          no_of_connection_attempts);
  }
#line 391
  return;
}
}
#line 393 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/internal-connections.c"
Bool handshake_ok(struct connection *cptr , enum ignored_conditions ignored ) 
{ 


  {
#line 397
  if (! cptr->dns_done) {
#line 397
    if (! ((unsigned int )ignored & 1U)) {
#line 398
      return ((Bool )0);
    }
  }
#line 400
  if (! cptr->username_valid) {
#line 401
    return ((Bool )0);
  }
#line 403
  return ((Bool )1);
}
}
#line 124 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int no_of_allocated_blocks___2  =    0;
#line 384 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static void **tmp_alloc_table___0  =    (void **)((void *)0);
#line 385 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int tmp_alloc_table_size___0  =    0;
#line 386 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int tmp_alloc_table_use___0  =    0;
#line 28 "./../libraries/liboop/oop.h"
static struct timeval  const  OOP_TIME_NOW  =    {(__time_t )0, (__suseconds_t )0};
#line 50 "./../libraries/libmisc/timeval-util.h"
extern int setup_timer(struct timeval *tv , struct timeval interval ) ;
#line 29 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.h"
void start_garb_thread(oop_source *src ) ;
#line 30
void stop_garb_thread(oop_source *src ) ;
#line 61 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache.h"
void tell_cache_garb_text(int running ) ;
#line 102
Text_no traverse_text(Text_no seed ) ;
#line 129
extern Garb_nice cached_get_garb_nice(Conf_no conf_no ) ;
#line 132
extern Garb_nice cached_get_keep_commented(Conf_no conf_no ) ;
#line 369 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
Bool server_idle(void) ;
#line 373
void set_time(void) ;
#line 105 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static Text_no last_checked  =    (Text_no )0;
#line 107 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static struct timeval garb_timer  ;
#line 108 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static Bool garb_timer_running  =    (Bool )0;
#line 110 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static double const   day_to_sec  =    (double const   )86400;
#line 111 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static double const   default_save  =    (double const   )((1.0 * (double )24) * (double )3600);
#line 113 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static Bool saved_by_aux(Text_stat *text_s ) 
{ 
  unsigned short naux ;

  {
#line 118
  naux = (unsigned short)0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! ((int )naux < (int )text_s->aux_item_list.length)) {
#line 118
      goto while_break;
    }
#line 119
    if ((text_s->aux_item_list.items + naux)->flags.dont_garb) {
#line 120
      return ((Bool )1);
    }
#line 118
    naux = (unsigned short )((int )naux + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return ((Bool )0);
}
}
#line 125 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static Bool saved_by_recipient(Text_stat *text_s , double age ) 
{ 
  unsigned short nmisc ;
  Misc_info *misc ;
  double limit___0 ;
  Bool in_rec_group ;
  Garb_nice tmp ;
  Bool tmp___0 ;
  long tmp___1 ;

  {
#line 131
  limit___0 = (double )0;
#line 132
  in_rec_group = (Bool )0;
#line 134
  nmisc = text_s->no_of_misc;
#line 134
  misc = text_s->misc_items;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((int )nmisc > 0)) {
#line 134
      goto while_break;
    }
    {
#line 142
    if ((unsigned int )misc->type == 15U) {
#line 142
      goto case_15;
    }
#line 142
    if ((unsigned int )misc->type == 1U) {
#line 142
      goto case_15;
    }
#line 142
    if ((unsigned int )misc->type == 0U) {
#line 142
      goto case_15;
    }
#line 158
    if ((unsigned int )misc->type == 5U) {
#line 158
      goto case_5;
    }
#line 158
    if ((unsigned int )misc->type == 4U) {
#line 158
      goto case_5;
    }
#line 158
    if ((unsigned int )misc->type == 3U) {
#line 158
      goto case_5;
    }
#line 158
    if ((unsigned int )misc->type == 2U) {
#line 158
      goto case_5;
    }
#line 164
    if ((unsigned int )misc->type == 8U) {
#line 164
      goto case_8;
    }
#line 164
    if ((unsigned int )misc->type == 7U) {
#line 164
      goto case_8;
    }
#line 164
    if ((unsigned int )misc->type == 6U) {
#line 164
      goto case_8;
    }
#line 167
    if ((unsigned int )misc->type == 9U) {
#line 167
      goto case_9;
    }
#line 176
    goto switch_default;
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 143
    tmp___0 = cached_conf_exists(misc->datum.recipient);
    }
#line 143
    if (tmp___0) {
      {
#line 145
      tmp = cached_get_garb_nice(misc->datum.recipient);
#line 145
      limit___0 = (double )(day_to_sec * (double const   )tmp);
      }
#line 147
      if (age < limit___0) {
#line 148
        return ((Bool )1);
      }
#line 149
      in_rec_group = (Bool )1;
    } else {
#line 152
      in_rec_group = (Bool )0;
    }
#line 153
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 159
    in_rec_group = (Bool )0;
#line 160
    goto switch_break;
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 165
    goto switch_break;
    case_9: /* CIL Label */ 
#line 168
    if (in_rec_group) {
      {
#line 168
      tmp___1 = ldifftime(current_time.tv_sec, misc->datum.sent_at);
      }
#line 168
      if ((double )tmp___1 < limit___0) {
#line 171
        return ((Bool )1);
      }
    }
#line 173
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 179
    restart_kom("saved_by_recipient(): Illegal misc-item.\n");
    }
    switch_break: /* CIL Label */ ;
    }
#line 134
    nmisc = (unsigned short )((int )nmisc - 1);
#line 134
    misc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  return ((Bool )0);
}
}
#line 186 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static Bool saved_by_comment(Text_stat *text_s ) 
{ 
  unsigned short nmisc ;
  Misc_info *misc ;
  Bool in_comm_group ;
  long tmp ;

  {
#line 191
  in_comm_group = (Bool )0;
#line 193
  nmisc = text_s->no_of_misc;
#line 193
  misc = text_s->misc_items;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! ((int )nmisc > 0)) {
#line 193
      goto while_break;
    }
    {
#line 201
    if ((unsigned int )misc->type == 15U) {
#line 201
      goto case_15;
    }
#line 201
    if ((unsigned int )misc->type == 1U) {
#line 201
      goto case_15;
    }
#line 201
    if ((unsigned int )misc->type == 0U) {
#line 201
      goto case_15;
    }
#line 208
    if ((unsigned int )misc->type == 5U) {
#line 208
      goto case_5;
    }
#line 208
    if ((unsigned int )misc->type == 4U) {
#line 208
      goto case_5;
    }
#line 208
    if ((unsigned int )misc->type == 3U) {
#line 208
      goto case_5;
    }
#line 208
    if ((unsigned int )misc->type == 2U) {
#line 208
      goto case_5;
    }
#line 214
    if ((unsigned int )misc->type == 8U) {
#line 214
      goto case_8;
    }
#line 214
    if ((unsigned int )misc->type == 7U) {
#line 214
      goto case_8;
    }
#line 214
    if ((unsigned int )misc->type == 6U) {
#line 214
      goto case_8;
    }
#line 217
    if ((unsigned int )misc->type == 9U) {
#line 217
      goto case_9;
    }
#line 226
    goto switch_default;
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 202
    in_comm_group = (Bool )0;
#line 203
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 209
    in_comm_group = (Bool )1;
#line 210
    goto switch_break;
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 215
    goto switch_break;
    case_9: /* CIL Label */ 
#line 218
    if (in_comm_group) {
      {
#line 218
      tmp = ldifftime(current_time.tv_sec, misc->datum.sent_at);
      }
#line 218
      if ((double const   )tmp < default_save) {
#line 221
        return ((Bool )1);
      }
    }
#line 223
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 229
    restart_kom("saved_by_comment(): Illegal misc-item.\n");
    }
    switch_break: /* CIL Label */ ;
    }
#line 193
    nmisc = (unsigned short )((int )nmisc - 1);
#line 193
    misc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  return ((Bool )0);
}
}
#line 249 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static Bool find_comment_limit_and_age(Text_no text_no , Text_stat *text_s , Text_no parent ,
                                       double *comment_age , double *limit___0 ) 
{ 
  unsigned short nmisc ;
  Misc_info *misc ;
  Bool in_comm_group ;
  Bool has_comments ;
  double tmp ;
  long tmp___0 ;
  Garb_nice tmp___1 ;
  Bool tmp___2 ;
  long tmp___3 ;

  {
#line 258
  in_comm_group = (Bool )0;
#line 259
  has_comments = (Bool )0;
#line 262
  if ((unsigned long )text_s == (unsigned long )((void *)0)) {
    {
#line 263
    text_s = cached_get_text_stat(text_no);
    }
  }
#line 265
  if ((unsigned long )text_s == (unsigned long )((void *)0)) {
#line 267
    *comment_age = (double )0;
#line 268
    *limit___0 = (double )0;
#line 269
    return ((Bool )0);
  }
  {
#line 272
  tmp___0 = ldifftime(current_time.tv_sec, text_s->creation_time);
#line 272
  *comment_age = (double )tmp___0;
#line 273
  *limit___0 = (double )default_save;
#line 275
  nmisc = text_s->no_of_misc;
#line 275
  misc = text_s->misc_items;
  }
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! ((int )nmisc > 0)) {
#line 275
      goto while_break;
    }
    {
#line 283
    if ((unsigned int )misc->type == 15U) {
#line 283
      goto case_15;
    }
#line 283
    if ((unsigned int )misc->type == 1U) {
#line 283
      goto case_15;
    }
#line 283
    if ((unsigned int )misc->type == 0U) {
#line 283
      goto case_15;
    }
#line 295
    if ((unsigned int )misc->type == 4U) {
#line 295
      goto case_4;
    }
#line 295
    if ((unsigned int )misc->type == 2U) {
#line 295
      goto case_4;
    }
#line 300
    if ((unsigned int )misc->type == 5U) {
#line 300
      goto case_5;
    }
#line 300
    if ((unsigned int )misc->type == 3U) {
#line 300
      goto case_5;
    }
#line 307
    if ((unsigned int )misc->type == 8U) {
#line 307
      goto case_8;
    }
#line 307
    if ((unsigned int )misc->type == 7U) {
#line 307
      goto case_8;
    }
#line 307
    if ((unsigned int )misc->type == 6U) {
#line 307
      goto case_8;
    }
#line 310
    if ((unsigned int )misc->type == 9U) {
#line 310
      goto case_9;
    }
#line 317
    goto switch_default;
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 284
    in_comm_group = (Bool )0;
#line 285
    tmp___2 = cached_conf_exists(misc->datum.recipient);
    }
#line 285
    if (tmp___2) {
      {
#line 287
      tmp___1 = cached_get_keep_commented(misc->datum.recipient);
#line 287
      tmp = (double )(day_to_sec * (double const   )tmp___1);
      }
#line 289
      if (tmp > *limit___0) {
#line 290
        *limit___0 = tmp;
      }
    }
#line 292
    goto switch_break;
    case_4: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 296
    in_comm_group = (Bool )(misc->datum.text_link == parent);
#line 297
    goto switch_break;
    case_5: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 301
    in_comm_group = (Bool )0;
#line 302
    has_comments = (Bool )1;
#line 303
    goto switch_break;
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 308
    goto switch_break;
    case_9: /* CIL Label */ 
#line 311
    if (in_comm_group) {
      {
#line 312
      tmp___3 = ldifftime(current_time.tv_sec, misc->datum.sent_at);
#line 312
      *comment_age = (double )tmp___3;
      }
    }
#line 314
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 320
    restart_kom("find_comment_limit_and_age(): Illegal misc-item.\n");
    }
    switch_break: /* CIL Label */ ;
    }
#line 275
    nmisc = (unsigned short )((int )nmisc - 1);
#line 275
    misc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  return (has_comments);
}
}
#line 327 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static Bool saved_by_keep_commented(Text_no text_no , Text_stat *text_s ) 
{ 
  unsigned short nmisc ;
  Misc_info *misc ;
  double comment_age ;
  double parent_limit ;
  double limit___0 ;
  Bool tmp ;

  {
  {
#line 337
  tmp = find_comment_limit_and_age(text_no, text_s, (Text_no )0, & comment_age, & parent_limit);
  }
#line 337
  if (! tmp) {
#line 339
    return ((Bool )0);
  }
#line 341
  nmisc = text_s->no_of_misc;
#line 341
  misc = text_s->misc_items;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((int )nmisc > 0)) {
#line 341
      goto while_break;
    }
    {
#line 348
    if ((unsigned int )misc->type == 5U) {
#line 348
      goto case_5;
    }
#line 348
    if ((unsigned int )misc->type == 3U) {
#line 348
      goto case_5;
    }
#line 366
    if ((unsigned int )misc->type == 9U) {
#line 366
      goto case_9;
    }
#line 366
    if ((unsigned int )misc->type == 8U) {
#line 366
      goto case_9;
    }
#line 366
    if ((unsigned int )misc->type == 7U) {
#line 366
      goto case_9;
    }
#line 366
    if ((unsigned int )misc->type == 6U) {
#line 366
      goto case_9;
    }
#line 366
    if ((unsigned int )misc->type == 4U) {
#line 366
      goto case_9;
    }
#line 366
    if ((unsigned int )misc->type == 2U) {
#line 366
      goto case_9;
    }
#line 366
    if ((unsigned int )misc->type == 15U) {
#line 366
      goto case_9;
    }
#line 366
    if ((unsigned int )misc->type == 1U) {
#line 366
      goto case_9;
    }
#line 366
    if ((unsigned int )misc->type == 0U) {
#line 366
      goto case_9;
    }
#line 370
    goto switch_default;
    case_5: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 349
    find_comment_limit_and_age(misc->datum.text_link, (Text_stat *)((void *)0), text_no,
                               & comment_age, & limit___0);
    }
#line 351
    if (limit___0 < parent_limit) {
#line 352
      limit___0 = parent_limit;
    }
#line 354
    if (comment_age < limit___0) {
#line 355
      return ((Bool )1);
    }
#line 356
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 367
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 373
    restart_kom("saved_by_keep_commented(): Illegal misc-item.\n");
    }
    switch_break: /* CIL Label */ ;
    }
#line 341
    nmisc = (unsigned short )((int )nmisc - 1);
#line 341
    misc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  return ((Bool )0);
}
}
#line 380 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static Bool saved(Text_no text_no , Text_stat *text_s ) 
{ 
  double age ;
  long tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;
  Bool tmp___3 ;

  {
#line 386
  if ((int )text_s->no_of_marks > 0) {
#line 387
    return ((Bool )1);
  }
  {
#line 389
  tmp = ldifftime(current_time.tv_sec, text_s->creation_time);
#line 389
  age = (double )tmp;
  }
#line 390
  if (age < (double )default_save) {
#line 391
    return ((Bool )1);
  }
  {
#line 393
  tmp___0 = saved_by_aux(text_s);
  }
#line 393
  if (tmp___0) {
#line 394
    return ((Bool )1);
  }
  {
#line 396
  tmp___1 = saved_by_recipient(text_s, age);
  }
#line 396
  if (tmp___1) {
#line 397
    return ((Bool )1);
  }
  {
#line 399
  tmp___2 = saved_by_comment(text_s);
  }
#line 399
  if (tmp___2) {
#line 400
    return ((Bool )1);
  }
  {
#line 402
  tmp___3 = saved_by_keep_commented(text_no, text_s);
  }
#line 402
  if (tmp___3) {
#line 403
    return ((Bool )1);
  }
#line 405
  return ((Bool )0);
}
}
#line 420
static Bool garb_text(void) ;
#line 420 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static long deleted_texts  =    0L;
#line 417 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static Bool garb_text(void) 
{ 
  Text_stat *text_s ;
  Bool tmp ;

  {
#line 423
  if ((unsigned int )param.garb_enable == 0U) {
#line 424
    return ((Bool )1);
  }
#line 426
  if (last_checked == 0UL) {
    {
#line 427
    kom_log("MSG: garb started.\n");
    }
  }
  {
#line 429
  tell_cache_garb_text(1);
#line 430
  last_checked = traverse_text(last_checked);
  }
#line 432
  if (last_checked == 0UL) {
    {
#line 434
    kom_log("MSG: garb ready. %lu texts deleted.\n", (unsigned long )deleted_texts);
#line 436
    tell_cache_garb_text(0);
#line 440
    deleted_texts = 0L;
    }
#line 441
    return ((Bool )1);
  }
  {
#line 444
  text_s = cached_get_text_stat(last_checked);
  }
#line 444
  if ((unsigned long )text_s == (unsigned long )((void *)0)) {
    {
#line 446
    kom_log("ERROR: garb_text(): Can\'t get text-stat.\n");
#line 447
    tell_cache_garb_text(0);
    }
#line 448
    return ((Bool )0);
  }
  {
#line 451
  tmp = saved(last_checked, text_s);
  }
#line 451
  if (! tmp) {
#line 453
    if (buglevel > 1) {
      {
#line 453
      printf((char const   */* __restrict  */)"garb_text: deleting %lu\n", last_checked);
      }
    }
    {
#line 454
    do_delete_text(last_checked, text_s);
#line 455
    deleted_texts ++;
    }
  }
  {
#line 458
  tell_cache_garb_text(0);
  }
#line 459
  return ((Bool )0);
}
}
#line 462 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
static void *garb_callback(oop_source *source , struct timeval qazwsxedctv  __attribute__((__unused__)) ,
                           void *qazwsxedcuser  __attribute__((__unused__)) ) 
{ 
  int rv ;
  Bool tmp ;
  Bool tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 467
  rv = 0;
#line 469
  set_time();
#line 470
  tmp___0 = garb_text();
  }
#line 470
  if ((unsigned int )tmp___0 == 0U) {
    {
#line 471
    tmp = server_idle();
    }
#line 471
    if (tmp) {
      {
#line 472
      rv = setup_timer(& garb_timer, param.garbtimeout);
      }
    } else {
      {
#line 474
      rv = setup_timer(& garb_timer, param.garb_busy_postponement);
      }
    }
  } else {
    {
#line 476
    rv = setup_timer(& garb_timer, param.garb_interval);
    }
  }
#line 478
  if (rv < 0) {
    {
#line 479
    tmp___1 = __errno_location();
#line 479
    tmp___2 = strerror(*tmp___1);
#line 479
    kom_log("gettimeofday failed: %s\n", tmp___2);
    }
  }
  {
#line 481
  (*(source->on_time))(source, garb_timer, & garb_callback, (void *)0);
  }
#line 482
  return ((void *)(& _oop_continue));
}
}
#line 485 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
void start_garb_thread(oop_source *src ) 
{ 


  {
  {
#line 488
  stop_garb_thread(src);
#line 490
  garb_timer = (struct timeval )OOP_TIME_NOW;
#line 491
  (*(src->on_time))(src, garb_timer, & garb_callback, (void *)0);
#line 492
  garb_timer_running = (Bool )1;
  }
#line 493
  return;
}
}
#line 495 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/text-garb.c"
void stop_garb_thread(oop_source *src ) 
{ 


  {
#line 498
  if (garb_timer_running) {
    {
#line 500
    (*(src->cancel_time))(src, garb_timer, & garb_callback, (void *)0);
#line 501
    garb_timer_running = (Bool )0;
    }
  }
#line 503
  return;
}
}
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int *assignment_count___0  =    (int *)((void *)0);
#line 67 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int npar___0  =    0;
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static void init_init___0(struct parameter  const  *par ) 
{ 
  int ix ;
  void *tmp ;

  {
#line 74
  npar___0 = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )(par + npar___0)->name != (unsigned long )((void *)0))) {
#line 74
      goto while_break;
    }
#line 74
    npar___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if (! ((unsigned long )assignment_count___0 == (unsigned long )((void *)0))) {
    {
#line 77
    __assert_fail("assignment_count == ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c",
                  77U, "init_init");
    }
  }
  {
#line 78
  tmp = smalloc((unsigned long )npar___0 * sizeof(*assignment_count___0));
#line 78
  assignment_count___0 = (int *)tmp;
#line 80
  ix = 0;
  }
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (ix < npar___0)) {
#line 80
      goto while_break___0;
    }
#line 81
    *(assignment_count___0 + ix) = 0;
#line 80
    ix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static void assign_defaults___0(struct parameter  const  *par , int *err ) 
{ 
  int ix ;
  Success tmp ;

  {
#line 93
  ix = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (ix < npar___0)) {
#line 93
      goto while_break;
    }
#line 95
    if (*(assignment_count___0 + ix) < (int )(par + ix)->min_assignments) {
      {
#line 97
      kom_log("Parameter %s only assigned %d times (%d times needed)\n", (par + ix)->name,
              *(assignment_count___0 + ix), (par + ix)->min_assignments);
#line 99
      (*err) ++;
      }
    } else
#line 101
    if (*(assignment_count___0 + ix) == 0) {
      {
#line 103
      tmp = (*((par + ix)->assigner))((char const   *)(par + ix)->default_val, par + ix);
      }
#line 103
      if ((unsigned long )tmp != (unsigned long )OK) {
        {
#line 105
        kom_log("default assigner failed for %s\n", (par + ix)->name);
#line 106
        (*err) ++;
        }
      }
    }
#line 93
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int configure_line___0(FILE *fp , struct parameter  const  *par , int *err ) 
{ 
  char line[1001] ;
  char *start ;
  char *val ;
  char *end ;
  int found ;
  int ix ;
  char *tmp ;
  Success tmp___0 ;
  int tmp___1 ;

  {
  {
#line 128
  tmp = fgets((char */* __restrict  */)(line), 1001, (FILE */* __restrict  */)fp);
  }
#line 128
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 129
    return (-1);
  }
#line 135
  start = line;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((int )*start == 32)) {
#line 135
      if (! ((int )*start == 9)) {
#line 135
        goto while_break;
      }
    }
#line 135
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  if ((int )*start == 35) {
#line 139
    goto case_35;
  }
#line 141
  if ((int )*start == 0) {
#line 141
    goto case_0;
  }
#line 145
  if ((int )*start == 10) {
#line 145
    goto case_10;
  }
#line 137
  goto switch_break;
  case_35: /* CIL Label */ 
#line 140
  return (0);
  case_0: /* CIL Label */ 
  {
#line 142
  kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 143
  (*err) ++;
  }
#line 144
  return (0);
  case_10: /* CIL Label */ 
#line 146
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 149
  val = strchr((char const   *)(line), ':');
  }
#line 150
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    {
#line 153
    end = strchr((char const   *)(line), '\n');
    }
#line 154
    if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 155
      *end = (char )'\000';
    }
    {
#line 157
    kom_log("missing colon: %s\n", line);
#line 158
    (*err) ++;
    }
#line 159
    return (0);
  }
#line 161
  *val = (char )'\000';
#line 162
  val ++;
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (! ((int )*val == 32)) {
#line 162
      if (! ((int )*val == 9)) {
#line 162
        goto while_break___0;
      }
    }
#line 162
    val ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 166
  if ((int )*val == 0) {
#line 166
    goto case_0___0;
  }
#line 164
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 167
  kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 168
  (*err) ++;
  }
#line 169
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 172
  end = strchr((char const   *)val, '\n');
  }
#line 173
  if ((unsigned long )end == (unsigned long )((void *)0)) {
    {
#line 175
    kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 176
    (*err) ++;
    }
#line 177
    return (0);
  }
#line 179
  *end = (char )'\000';
#line 182
  found = 0;
#line 183
  ix = 0;
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (! (ix < npar___0)) {
#line 183
      goto while_break___1;
    }
    {
#line 185
    tmp___1 = strcmp((char const   *)start, (char const   *)(par + ix)->name);
    }
#line 185
    if (! tmp___1) {
#line 187
      found ++;
#line 188
      if (*(assignment_count___0 + ix) >= (int )(par + ix)->max_assignments) {
#line 188
        if ((par + ix)->max_assignments != -1) {
          {
#line 191
          (*err) ++;
#line 192
          kom_log("variable already assigned %d times: %s\n", *(assignment_count___0 + ix),
                  line);
          }
        } else {
#line 188
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 197
        (*(assignment_count___0 + ix)) ++;
#line 198
        tmp___0 = (*((par + ix)->assigner))((char const   *)val, par + ix);
        }
#line 198
        if ((unsigned long )tmp___0 != (unsigned long )OK) {
          {
#line 200
          kom_log("assigner for %s failed\n", (par + ix)->name);
#line 201
          (*err) ++;
          }
        }
      }
    }
#line 183
    ix ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 207
  if (found != 1) {
    {
#line 209
    kom_log("line matches %d times: %s\n", found, line);
#line 210
    (*err) ++;
    }
#line 211
    return (0);
  }
#line 213
  return (0);
}
}
#line 388 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static struct suffix_conversion  const  suffix_table___0[27]  = 
#line 388
  {      {"seconds", 1.0}, 
        {"second", 1.0}, 
        {"sec", 1.0}, 
        {"s", 1.0}, 
        {"minutes", 60.0}, 
        {"minute", 60.0}, 
        {"min", 60.0}, 
        {"hours", 3600.0}, 
        {"hour", 3600.0}, 
        {"h", 3600.0}, 
        {"days", 86400.0}, 
        {"day", 86400.0}, 
        {"d", 86400.0}, 
        {"milliseconds", 0.001}, 
        {"millisecond", 0.001}, 
        {"milli", 0.001}, 
        {"ms", 0.001}, 
        {"microseconds", 0.000001}, 
        {"microsecond", 0.000001}, 
        {"micro", 0.000001}, 
        {"us", 0.000001}, 
        {"u", 0.000001}, 
        {"kiloseconds", 1000.0}, 
        {"megaseconds", 1000000.0}, 
        {"microfortnights", 1.2096}, 
        {"microfortnight", 1.2096}, 
        {(char const   *)((void *)0), 0.0}};
#line 157 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.h"
Aux_item_definition empty_aux_item_definition ;
#line 183
Aux_item_trigger aux_item_find_trigger(char const   *trigger_name ) ;
#line 187
Aux_item_validation_function aux_item_find_validator(char const   *validator_name ) ;
#line 281
void system_add_aux_item_list(Info *info , Aux_item_list *item_list , Pers_no item_creator ) ;
#line 286
Success system_check_add_aux_item_list(Info *info , Aux_item_list *list , Connection *creating_conn ) ;
#line 293
void aux_item_definition_add(Aux_item_definition *def___0 ) ;
#line 296
void parse_aux_item_definitions(char *file ) ;
#line 706 "./../include/services.h"
extern Success query_predefined_aux_items(Number_list *result ) ;
#line 68 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
Aux_item_definition *aux_item_definition_list  =    (Aux_item_definition *)((void *)0);
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
unsigned long num_aux_item_definitions  =    0UL;
#line 80
static void aux_item_trigger_mark_text(Aux_item_trigger_data *data ) ;
#line 81
static void aux_item_trigger_unmark_text(Aux_item_trigger_data *data ) ;
#line 82
static void aux_item_trigger_mirror_faq(Aux_item_trigger_data *data ) ;
#line 83
static void aux_item_trigger_link_item(Aux_item_trigger_data *data ) ;
#line 88
static Success aux_item_validate_existing_text(Aux_item_validation_data *v_data ) ;
#line 91
static Aux_item const   *find_aux_item(Aux_item_list const   *list , unsigned long aux_no ) ;
#line 94
static void prepare_aux_item(Aux_item *item , Pers_no creator , Aux_item_definition const   *def___0 ) ;
#line 101 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static Aux_item_trigger_mapping aux_item_triggers[5]  = {      {"mark-text", & aux_item_trigger_mark_text}, 
        {"unmark-text", & aux_item_trigger_unmark_text}, 
        {"link-faq", & aux_item_trigger_mirror_faq}, 
        {"link-item", & aux_item_trigger_link_item}, 
        {(char const   *)((void *)0), (void (*)(Aux_item_trigger_data * ))((void *)0)}};
#line 114 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static Aux_item_validator_mapping aux_item_validators[2]  = {      {"existing-readable-text", & aux_item_validate_existing_text}, 
        {(char const   *)((void *)0), (Success (*)(Aux_item_validation_data * ))((void *)0)}};
#line 124 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
Aux_item_definition empty_aux_item_definition  = 
#line 124
     {(char *)((void *)0), 0UL, {0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U, 0U,
                                                                 0U, 0U, 0U}, (Bool )0,
    (Bool )0, (Bool )0, (Bool )0, (Bool )0, (Bool )0, (Bool )0, (Bool )0, 0UL, (Bool )0,
    (short)0, (Bool )0, (short)0, (Bool )0, (Bool )0, 0UL, (Aux_item_validator *)((void *)0),
    0UL, (Aux_item_trigger *)((void *)0), 0UL, (Aux_item_trigger *)((void *)0), 0UL,
    (Aux_item_trigger *)((void *)0), (struct Aux_item_definition_s *)((void *)0)};
#line 161 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static Aux_item_definition simple_aux_item  = 
#line 161
     {(char *)"simple", 0UL, {0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}, {0U, 0U, 0U, 0U, 0U,
                                                              0U, 0U, 0U}, (Bool )0,
    (Bool )0, (Bool )0, (Bool )0, (Bool )0, (Bool )0, (Bool )0, (Bool )0, 0UL, (Bool )1,
    (short)0, (Bool )1, (short)0, (Bool )1, (Bool )1, 0UL, (Aux_item_validator *)((void *)0),
    0UL, (Aux_item_trigger *)((void *)0), 0UL, (Aux_item_trigger *)((void *)0), 0UL,
    (Aux_item_trigger *)((void *)0), (struct Aux_item_definition_s *)((void *)0)};
#line 192
static Bool aux_item_check_unique(Aux_item const   *item , Aux_item_definition const   *def___0 ,
                                  Aux_item_list *add_to_list , unsigned long start_looking_at ) ;
#line 206 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static Aux_item_definition *aux_item_default_definition(Aux_item const   *item ) 
{ 


  {
#line 212
  if (item->tag < 1UL) {
#line 213
    return ((Aux_item_definition *)((void *)0));
  }
#line 215
  if (item->tag >= 1UL) {
#line 215
    if (item->tag <= 9999UL) {
#line 216
      return ((Aux_item_definition *)((void *)0));
    } else {
#line 215
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 215
  if (item->tag > 29999UL) {
#line 216
    return ((Aux_item_definition *)((void *)0));
  }
#line 218
  return (& simple_aux_item);
}
}
#line 226 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
Aux_item_trigger aux_item_find_trigger(char const   *trigger_name ) 
{ 
  unsigned long i ;
  int tmp ;

  {
#line 229
  i = 0UL;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! ((unsigned long )aux_item_triggers[i].name != (unsigned long )((void *)0))) {
#line 231
      goto while_break;
    }
    {
#line 233
    tmp = strcmp(aux_item_triggers[i].name, trigger_name);
    }
#line 233
    if (! tmp) {
#line 234
      return (aux_item_triggers[i].function);
    }
#line 235
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return ((Aux_item_trigger )((void *)0));
}
}
#line 240 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
Aux_item_validation_function aux_item_find_validator(char const   *validator_name ) 
{ 
  unsigned long i ;
  int tmp ;

  {
#line 243
  i = 0UL;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )aux_item_validators[i].name != (unsigned long )((void *)0))) {
#line 245
      goto while_break;
    }
    {
#line 247
    tmp = strcmp(aux_item_validators[i].name, validator_name);
    }
#line 247
    if (! tmp) {
#line 248
      return (aux_item_validators[i].function);
    }
#line 249
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  return ((Aux_item_validation_function )((void *)0));
}
}
#line 262 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static Aux_item_definition const   *find_aux_item_definition(Aux_item const   *item ) 
{ 
  Aux_item_definition *def___0 ;
  Aux_item_definition *tmp ;

  {
#line 267
  def___0 = aux_item_definition_list;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! ((unsigned long )def___0 != (unsigned long )((void *)0))) {
#line 268
      goto while_break;
    }
#line 270
    if (def___0->tag == (unsigned long )item->tag) {
#line 271
      return ((Aux_item_definition const   *)def___0);
    }
#line 272
    def___0 = def___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  tmp = aux_item_default_definition(item);
  }
#line 275
  return ((Aux_item_definition const   *)tmp);
}
}
#line 289 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void aux_item_fix_trigger_data(Aux_item_trigger_data *data ) 
{ 


  {
  {
#line 294
  if ((unsigned int )data->object_type == 1U) {
#line 294
    goto case_1;
  }
#line 297
  if ((unsigned int )data->object_type == 2U) {
#line 297
    goto case_2;
  }
#line 300
  if ((unsigned int )data->object_type == 3U) {
#line 300
    goto case_3;
  }
#line 304
  goto switch_default;
  case_1: /* CIL Label */ 
#line 295
  data->item = ((Text_stat *)data->object)->aux_item_list.items + data->item_index;
#line 296
  goto switch_break;
  case_2: /* CIL Label */ 
#line 298
  data->item = ((Conference *)data->object)->aux_item_list.items + data->item_index;
#line 299
  goto switch_break;
  case_3: /* CIL Label */ 
#line 301
  data->item = ((Info *)data->object)->aux_item_list.items + data->item_index;
#line 302
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 305
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 307
  return;
}
}
#line 310 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void aux_item_call_add_triggers(Aux_item_definition const   *def___0 , enum object_type object_type ,
                                       unsigned long item_index , unsigned long integer_argument ,
                                       void *pointer_argument , Aux_item *item ) 
{ 
  unsigned long i ;
  Aux_item_trigger_data data ;

  {
#line 321
  data.action = (short)1;
#line 322
  data.object_type = object_type;
#line 323
  data.item_index = item_index;
#line 324
  data.object_no = integer_argument;
#line 325
  data.object = pointer_argument;
#line 326
  data.item = item;
#line 328
  i = 0UL;
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! (i < (unsigned long )def___0->num_add_triggers)) {
#line 328
      goto while_break;
    }
    {
#line 330
    (*(*(def___0->add_triggers + i)))(& data);
#line 331
    aux_item_fix_trigger_data(& data);
#line 328
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return;
}
}
#line 335 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void aux_item_call_delete_triggers(Aux_item_definition const   *def___0 , enum object_type object_type ,
                                          unsigned long item_index , unsigned long integer_argument ,
                                          void *pointer_argument , Aux_item *item ) 
{ 
  unsigned long i ;
  Aux_item_trigger_data data ;

  {
#line 346
  data.action = (short)2;
#line 347
  data.object_type = object_type;
#line 348
  data.item_index = item_index;
#line 349
  data.object_no = integer_argument;
#line 350
  data.object = pointer_argument;
#line 351
  data.item = item;
#line 353
  i = 0UL;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! (i < (unsigned long )def___0->num_delete_triggers)) {
#line 353
      goto while_break;
    }
    {
#line 355
    (*(*(def___0->delete_triggers + i)))(& data);
#line 353
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 359 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void aux_item_call_undelete_triggers(Aux_item_definition const   *def___0 ,
                                            enum object_type object_type , unsigned long item_index ,
                                            unsigned long integer_argument , void *pointer_argument ,
                                            Aux_item *item ) 
{ 
  unsigned long i ;
  Aux_item_trigger_data data ;

  {
#line 370
  data.action = (short)3;
#line 371
  data.object_type = object_type;
#line 372
  data.item_index = item_index;
#line 373
  data.object_no = integer_argument;
#line 374
  data.object = pointer_argument;
#line 375
  data.item = item;
#line 377
  i = 0UL;
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! (i < (unsigned long )def___0->num_undelete_triggers)) {
#line 377
      goto while_break;
    }
    {
#line 379
    (*(*(def___0->undelete_triggers + i)))(& data);
#line 377
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 391 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
void aux_item_definition_add(Aux_item_definition *def___0 ) 
{ 
  Aux_item_definition *new_definition ;
  void *tmp ;

  {
  {
#line 396
  tmp = smalloc(sizeof(Aux_item_definition ));
#line 396
  new_definition = (Aux_item_definition *)tmp;
  }
#line 397
  if ((unsigned long )new_definition == (unsigned long )((void *)0)) {
    {
#line 399
    restart_kom("out of memory adding aux-item definition");
    }
  }
#line 401
  *new_definition = *def___0;
#line 402
  num_aux_item_definitions ++;
#line 404
  new_definition->next = aux_item_definition_list;
#line 405
  aux_item_definition_list = new_definition;
#line 406
  return;
}
}
#line 415 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void aux_item_definition_cache_regexp(Aux_item_definition const   *def___0 ,
                                             unsigned long ix ) 
{ 
  struct re_pattern_buffer *pat_buf ;
  char const   *errmsg ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 422
  re_syntax_options = (reg_syntax_t )((((((((((((1 << 1) << 1) | ((((((1 << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1 << 1) << 1) << 1)) | ((((1 << 1) << 1) << 1) << 1)) | ((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 424
  tmp = smalloc(sizeof(*pat_buf));
#line 424
  (def___0->validators + ix)->v.re.cached_re_buf = (struct re_pattern_buffer *)tmp;
  }
#line 425
  if ((unsigned long )(def___0->validators + ix)->v.re.cached_re_buf == (unsigned long )((void *)0)) {
    {
#line 427
    kom_log("Out of memory compiling aux-item regexp %lu (%s).\n", def___0->tag, def___0->name);
    }
#line 430
    return;
  }
  {
#line 432
  pat_buf = (def___0->validators + ix)->v.re.cached_re_buf;
#line 433
  pat_buf->translate = (char *)((void *)0);
#line 434
  pat_buf->fastmap = (char *)0;
#line 435
  pat_buf->allocated = 0UL;
#line 436
  pat_buf->buffer = (unsigned char *)0;
#line 438
  tmp___0 = strlen((char const   *)(def___0->validators + ix)->v.re.regexp);
#line 438
  errmsg = re_compile_pattern((char const   *)(def___0->validators + ix)->v.re.regexp,
                              (int )tmp___0, pat_buf);
  }
#line 438
  if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
    {
#line 444
    kom_log("%s in validate regexp of aux-item definition %lu (%s).\n", errmsg, def___0->tag,
            def___0->name);
    }
#line 448
    if ((def___0->validators + ix)->v.re.cached_re_buf) {
      {
#line 452
      regfree((def___0->validators + ix)->v.re.cached_re_buf);
#line 453
      sfree((void *)(def___0->validators + ix)->v.re.cached_re_buf);
      }
    }
#line 455
    if ((def___0->validators + ix)->v.re.regexp) {
      {
#line 456
      string_free((void *)(def___0->validators + ix)->v.re.regexp);
      }
    }
#line 457
    (def___0->validators + ix)->v.re.cached_re_buf = (struct re_pattern_buffer *)((void *)0);
#line 458
    (def___0->validators + ix)->v.re.regexp = (char *)((void *)0);
#line 459
    return;
  }
#line 461
  return;
}
}
#line 463 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
void initialize_aux_items(char *aux_def_file ) 
{ 


  {
  {
#line 480
  parse_aux_item_definitions(aux_def_file);
  }
#line 481
  return;
}
}
#line 483 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
void free_aux_item_definitions(void) 
{ 
  unsigned long i ;
  Aux_item_definition *def___0 ;
  Aux_item_definition *tmp ;

  {
#line 490
  def___0 = aux_item_definition_list;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if (! ((unsigned long )def___0 != (unsigned long )((void *)0))) {
#line 491
      goto while_break;
    }
    {
#line 493
    string_free((void *)def___0->name);
#line 494
    i = 0UL;
    }
    {
#line 494
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 494
      if (! (i < def___0->num_validators)) {
#line 494
        goto while_break___0;
      }
#line 496
      if ((unsigned int )(def___0->validators + i)->type == 1U) {
#line 498
        if ((unsigned long )(def___0->validators + i)->v.re.regexp != (unsigned long )((void *)0)) {
          {
#line 499
          string_free((void *)(def___0->validators + i)->v.re.regexp);
          }
        }
#line 500
        if ((unsigned long )(def___0->validators + i)->v.re.cached_re_buf != (unsigned long )((void *)0)) {
          {
#line 502
          regfree((def___0->validators + i)->v.re.cached_re_buf);
#line 503
          sfree((void *)(def___0->validators + i)->v.re.cached_re_buf);
          }
        }
      }
#line 494
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 507
    if ((unsigned long )def___0->validators != (unsigned long )((void *)0)) {
      {
#line 509
      sfree((void *)def___0->validators);
#line 510
      def___0->validators = (Aux_item_validator *)((void *)0);
#line 511
      def___0->num_validators = 0UL;
      }
    }
#line 513
    if ((unsigned long )def___0->add_triggers != (unsigned long )((void *)0)) {
      {
#line 515
      sfree((void *)def___0->add_triggers);
#line 516
      def___0->add_triggers = (Aux_item_trigger *)((void *)0);
#line 517
      def___0->num_add_triggers = 0UL;
      }
    }
#line 519
    if ((unsigned long )def___0->delete_triggers != (unsigned long )((void *)0)) {
      {
#line 521
      sfree((void *)def___0->delete_triggers);
#line 522
      def___0->delete_triggers = (Aux_item_trigger *)((void *)0);
#line 523
      def___0->num_delete_triggers = 0UL;
      }
    }
#line 525
    if ((unsigned long )def___0->undelete_triggers != (unsigned long )((void *)0)) {
      {
#line 527
      sfree((void *)def___0->undelete_triggers);
#line 528
      def___0->undelete_triggers = (Aux_item_trigger *)((void *)0);
#line 529
      def___0->num_undelete_triggers = 0UL;
      }
    }
    {
#line 531
    tmp = def___0->next;
#line 532
    sfree((void *)def___0);
#line 533
    def___0 = tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  aux_item_definition_list = (Aux_item_definition *)((void *)0);
#line 537
  return;
}
}
#line 541 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static long find_aux_item_index(Aux_item_list const   *list , unsigned long aux_no ) 
{ 
  unsigned long i ;

  {
#line 546
  i = 0UL;
  {
#line 546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 546
    if (! (i < (unsigned long )list->length)) {
#line 546
      goto while_break;
    }
#line 548
    if ((list->items + i)->aux_no == aux_no) {
#line 549
      return ((long )i);
    }
#line 546
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 552
  return (-1L);
}
}
#line 558 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static Aux_item_list *find_linked_aux_item_list(Aux_item *item ) 
{ 
  Text_stat *text_stat ;
  Conference *conf_stat ;

  {
  {
#line 566
  if ((unsigned int )item->linked_item.target_type == 0U) {
#line 566
    goto case_0;
  }
#line 569
  if ((unsigned int )item->linked_item.target_type == 1U) {
#line 569
    goto case_1;
  }
#line 573
  if ((unsigned int )item->linked_item.target_type == 2U) {
#line 573
    goto case_2;
  }
#line 577
  if ((unsigned int )item->linked_item.target_type == 3U) {
#line 577
    goto case_3;
  }
#line 580
  goto switch_default;
  case_0: /* CIL Label */ 
#line 567
  return ((Aux_item_list *)((void *)0));
  case_1: /* CIL Label */ 
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 570
    text_stat = cached_get_text_stat(item->linked_item.target_object.text);
    }
#line 570
    if ((unsigned long )text_stat == (unsigned long )((void *)0)) {
#line 570
      return ((Aux_item_list *)((void *)0));
    }
#line 570
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  return (& text_stat->aux_item_list);
  case_2: /* CIL Label */ 
  {
#line 574
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 574
    conf_stat = cached_get_conf_stat(item->linked_item.target_object.conf);
    }
#line 574
    if ((unsigned long )conf_stat == (unsigned long )((void *)0)) {
#line 574
      return ((Aux_item_list *)((void *)0));
    }
#line 574
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 575
  return (& conf_stat->aux_item_list);
  case_3: /* CIL Label */ 
#line 578
  return (& kom_info.aux_item_list);
  switch_default: /* CIL Label */ 
  {
#line 582
  kom_log("find_linked_aux_item_list: Bad aux_item somewhere: link to person or other kind.\n");
  }
#line 584
  return ((Aux_item_list *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 590 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static Aux_item const   *find_linked_aux_item(Aux_item *item ) 
{ 
  Aux_item_list *target_list ;
  Aux_item const   *tmp ;

  {
  {
#line 595
  target_list = find_linked_aux_item_list(item);
  }
#line 596
  if ((unsigned long )target_list == (unsigned long )((void *)0)) {
#line 597
    return ((Aux_item const   *)((void *)0));
  }
  {
#line 599
  tmp = find_aux_item((Aux_item_list const   *)target_list, item->linked_item.target_item);
  }
#line 599
  return (tmp);
}
}
#line 604 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void mark_linked_object_as_changed(Aux_item *item ) 
{ 
  Text_stat *text_stat ;
  Conference *conf_stat ;

  {
  {
#line 612
  if ((unsigned int )item->linked_item.target_type == 1U) {
#line 612
    goto case_1;
  }
#line 617
  if ((unsigned int )item->linked_item.target_type == 2U) {
#line 617
    goto case_2;
  }
#line 623
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 613
    text_stat = cached_get_text_stat(item->linked_item.target_object.text);
    }
#line 613
    if ((unsigned long )text_stat == (unsigned long )((void *)0)) {
#line 613
      return;
    }
#line 613
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 614
  mark_text_as_changed(item->linked_item.target_object.text);
  }
#line 615
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 618
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 618
    conf_stat = cached_get_conf_stat(item->linked_item.target_object.conf);
    }
#line 618
    if ((unsigned long )conf_stat == (unsigned long )((void *)0)) {
#line 618
      return;
    }
#line 618
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 619
  mark_conference_as_changed(item->linked_item.target_object.conf);
  }
#line 620
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 627
  return;
}
}
#line 645 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void aux_item_link_items(enum object_type src_type , unsigned long src_no ,
                                void *src_ptr , Aux_item *src_item , enum object_type dst_type ,
                                unsigned long dst_no , void *dst_ptr , Aux_item *dst_item_data ) 
{ 
  Aux_item_list item_list ;
  Text_stat *tmp ;
  Conference *tmp___0 ;

  {
#line 660
  if ((unsigned long )dst_ptr == (unsigned long )((void *)0)) {
    {
#line 664
    if ((unsigned int )dst_type == 1U) {
#line 664
      goto case_1;
    }
#line 667
    if ((unsigned int )dst_type == 2U) {
#line 667
      goto case_2;
    }
#line 670
    if ((unsigned int )dst_type == 3U) {
#line 670
      goto case_3;
    }
#line 673
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 665
    tmp = cached_get_text_stat(dst_no);
#line 665
    dst_ptr = (void *)tmp;
    }
#line 666
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 668
    tmp___0 = cached_get_conf_stat((Conf_no )dst_no);
#line 668
    dst_ptr = (void *)tmp___0;
    }
#line 669
    goto switch_break;
    case_3: /* CIL Label */ 
#line 671
    dst_ptr = (void *)(& kom_info);
#line 672
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 674
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 678
  if ((unsigned long )dst_ptr == (unsigned long )((void *)0)) {
#line 679
    return;
  } else
#line 678
  if ((unsigned long )src_ptr == (unsigned long )((void *)0)) {
#line 679
    return;
  }
#line 684
  dst_item_data->linked_item.target_type = src_type;
#line 685
  dst_item_data->linked_item.target_item = src_item->aux_no;
  {
#line 688
  if ((unsigned int )src_type == 1U) {
#line 688
    goto case_1___0;
  }
#line 689
  if ((unsigned int )src_type == 2U) {
#line 689
    goto case_2___0;
  }
#line 691
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 688
  dst_item_data->linked_item.target_object.text = src_no;
#line 688
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 689
  dst_item_data->linked_item.target_object.conf = (Conf_no )src_no;
#line 689
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 692
  dst_item_data->linked_item.target_object.text = (Text_no )0;
  switch_break___0: /* CIL Label */ ;
  }
#line 698
  src_item->linked_item.target_type = dst_type;
#line 699
  src_item->linked_item.target_item = 0UL;
  {
#line 702
  if ((unsigned int )dst_type == 1U) {
#line 702
    goto case_1___1;
  }
#line 706
  if ((unsigned int )dst_type == 2U) {
#line 706
    goto case_2___1;
  }
#line 710
  if ((unsigned int )dst_type == 3U) {
#line 710
    goto case_3___0;
  }
#line 715
  goto switch_default___1;
  case_1___1: /* CIL Label */ 
#line 703
  src_item->linked_item.target_object.text = dst_no;
#line 704
  src_item->linked_item.target_item = ((Text_stat *)dst_ptr)->highest_aux + 1UL;
#line 705
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 707
  src_item->linked_item.target_object.conf = (Conf_no )dst_no;
#line 708
  src_item->linked_item.target_item = ((Conference *)dst_ptr)->highest_aux + 1UL;
#line 709
  goto switch_break___1;
  case_3___0: /* CIL Label */ 
#line 711
  src_item->linked_item.target_item = ((Info *)dst_ptr)->highest_aux_no + 1UL;
#line 712
  src_item->linked_item.target_object.text = (Text_no )0;
#line 713
  src_item->linked_item.target_object.conf = (Conf_no )0;
#line 714
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 716
  src_item->linked_item.target_item = 0UL;
#line 717
  src_item->linked_item.target_object.text = (Text_no )0;
#line 718
  src_item->linked_item.target_object.conf = (Conf_no )0;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 724
  item_list.length = (unsigned short)1;
#line 725
  item_list.items = dst_item_data;
#line 726
  prepare_aux_item_list(& item_list, src_item->creator);
  }
  {
#line 738
  if ((unsigned int )dst_type == 1U) {
#line 738
    goto case_1___2;
  }
#line 747
  if ((unsigned int )dst_type == 2U) {
#line 747
    goto case_2___2;
  }
#line 757
  if ((unsigned int )dst_type == 3U) {
#line 757
    goto case_3___1;
  }
#line 762
  goto switch_default___2;
  case_1___2: /* CIL Label */ 
  {
#line 739
  text_stat_add_aux_item_list((Text_stat *)dst_ptr, dst_no, & item_list, src_item->creator);
#line 745
  mark_text_as_changed(dst_no);
  }
#line 746
  goto switch_break___2;
  case_2___2: /* CIL Label */ 
  {
#line 748
  conf_stat_add_aux_item_list((Conference *)dst_ptr, (Conf_no )dst_no, & item_list,
                              src_item->creator);
#line 754
  mark_conference_as_changed((Conf_no )dst_no);
  }
#line 755
  goto switch_break___2;
  case_3___1: /* CIL Label */ 
  {
#line 758
  system_add_aux_item_list((Info *)dst_ptr, & item_list, src_item->creator);
  }
#line 760
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
#line 763
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
  {
#line 775
  src_item = (Aux_item *)((void *)0);
#line 781
  mark_linked_object_as_changed(dst_item_data);
  }
#line 782
  return;
}
}
#line 787 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void aux_item_list_add_items(Aux_item_list *add_to_list , Aux_item_list *items_to_add ,
                                    enum object_type object_type , unsigned long object_no ,
                                    void *object_ptr , unsigned long *highest_ptr ,
                                    Pers_no item_creator ) 
{ 
  unsigned long i ;
  unsigned long highest_local ;
  unsigned long start_index ;
  void *tmp ;
  Aux_item_definition const   *tmp___0 ;

  {
#line 800
  if ((unsigned long )items_to_add == (unsigned long )((void *)0)) {
#line 801
    return;
  }
  {
#line 807
  start_index = (unsigned long )add_to_list->length;
#line 808
  highest_local = *highest_ptr;
#line 816
  add_to_list->length = (unsigned short )((int )add_to_list->length + (int )items_to_add->length);
#line 817
  tmp = srealloc((void *)add_to_list->items, (unsigned long )add_to_list->length * sizeof(Aux_item ));
#line 817
  add_to_list->items = (Aux_item *)tmp;
#line 819
  *highest_ptr += (unsigned long )items_to_add->length;
#line 821
  i = 0UL;
  }
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    if (! (i < (unsigned long )items_to_add->length)) {
#line 821
      goto while_break;
    }
    {
#line 823
    init_aux_item(add_to_list->items + (start_index + i));
#line 821
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 830
  i = 0UL;
  {
#line 830
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 830
    if (! (i < (unsigned long )items_to_add->length)) {
#line 830
      goto while_break___0;
    }
    {
#line 832
    highest_local ++;
#line 833
    copy_aux_item(add_to_list->items + (i + start_index), (Aux_item const   *)(items_to_add->items + i));
#line 835
    (add_to_list->items + (i + start_index))->aux_no = highest_local;
#line 836
    (add_to_list->items + (i + start_index))->creator = item_creator;
#line 837
    tmp___0 = find_aux_item_definition((Aux_item const   *)(items_to_add->items + i));
#line 837
    aux_item_call_add_triggers(tmp___0, object_type, i + start_index, object_no, object_ptr,
                               add_to_list->items + (i + start_index));
#line 830
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 845
  return;
}
}
#line 860 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
void prepare_aux_item_list(Aux_item_list *list , Pers_no creator ) 
{ 
  unsigned long i ;

  {
#line 866
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 867
    return;
  }
#line 869
  i = 0UL;
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 869
    if (! (i < (unsigned long )list->length)) {
#line 869
      goto while_break;
    }
    {
#line 870
    prepare_aux_item(list->items + i, creator, (Aux_item_definition const   *)((void *)0));
#line 869
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 871
  return;
}
}
#line 873 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void prepare_aux_item(Aux_item *item , Pers_no creator , Aux_item_definition const   *def___0 ) 
{ 
  Aux_item_definition const   *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 878
  if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 879
    return;
  }
#line 880
  if (def___0) {
#line 880
    def___0 = def___0;
  } else {
    {
#line 880
    tmp = find_aux_item_definition((Aux_item const   *)item);
#line 880
    def___0 = tmp;
    }
  }
#line 881
  if ((unsigned long )def___0 == (unsigned long )((void *)0)) {
#line 882
    return;
  }
#line 884
  if (def___0->clear_flags.inherit) {
#line 884
    item->flags.inherit = 0U;
  } else {
#line 884
    if (def___0->set_flags.inherit) {
#line 884
      tmp___0 = 1U;
    } else {
#line 884
      tmp___0 = item->flags.inherit;
    }
#line 884
    item->flags.inherit = tmp___0;
  }
#line 885
  if (def___0->clear_flags.secret) {
#line 885
    item->flags.secret = 0U;
  } else {
#line 885
    if (def___0->set_flags.secret) {
#line 885
      tmp___1 = 1U;
    } else {
#line 885
      tmp___1 = item->flags.secret;
    }
#line 885
    item->flags.secret = tmp___1;
  }
#line 886
  if (def___0->clear_flags.hide_creator) {
#line 886
    item->flags.hide_creator = 0U;
  } else {
#line 886
    if (def___0->set_flags.hide_creator) {
#line 886
      tmp___2 = 1U;
    } else {
#line 886
      tmp___2 = item->flags.hide_creator;
    }
#line 886
    item->flags.hide_creator = tmp___2;
  }
#line 887
  if (def___0->clear_flags.dont_garb) {
#line 887
    item->flags.dont_garb = 0U;
  } else {
#line 887
    if (def___0->set_flags.dont_garb) {
#line 887
      tmp___3 = 1U;
    } else {
#line 887
      tmp___3 = item->flags.dont_garb;
    }
#line 887
    item->flags.dont_garb = tmp___3;
  }
#line 888
  if (def___0->clear_flags.reserved3) {
#line 888
    item->flags.reserved3 = 0U;
  } else {
#line 888
    if (def___0->set_flags.reserved3) {
#line 888
      tmp___4 = 1U;
    } else {
#line 888
      tmp___4 = item->flags.reserved3;
    }
#line 888
    item->flags.reserved3 = tmp___4;
  }
#line 889
  if (def___0->clear_flags.reserved4) {
#line 889
    item->flags.reserved4 = 0U;
  } else {
#line 889
    if (def___0->set_flags.reserved4) {
#line 889
      tmp___5 = 1U;
    } else {
#line 889
      tmp___5 = item->flags.reserved4;
    }
#line 889
    item->flags.reserved4 = tmp___5;
  }
#line 890
  if (def___0->clear_flags.reserved5) {
#line 890
    item->flags.reserved5 = 0U;
  } else {
#line 890
    if (def___0->set_flags.reserved5) {
#line 890
      tmp___6 = 1U;
    } else {
#line 890
      tmp___6 = item->flags.reserved5;
    }
#line 890
    item->flags.reserved5 = tmp___6;
  }
#line 892
  item->flags.deleted = 0U;
#line 894
  if (def___0->inherit_limit != 0UL) {
#line 894
    if (item->inherit_limit > (unsigned long )def___0->inherit_limit) {
#line 898
      item->inherit_limit = (unsigned long )def___0->inherit_limit;
    } else
#line 894
    if (item->inherit_limit == 0UL) {
#line 898
      item->inherit_limit = (unsigned long )def___0->inherit_limit;
    }
  }
#line 901
  item->creator = creator;
#line 902
  item->sent_at = current_time.tv_sec;
#line 903
  return;
}
}
#line 907 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static Success aux_item_validate(Aux_item_validation_data validation_data ) 
{ 
  unsigned long i ;
  Aux_item_definition const   *def___0 ;
  Success tmp ;
  int tmp___0 ;

  {
#line 913
  def___0 = validation_data.def;
#line 914
  i = 0UL;
  {
#line 914
  while (1) {
    while_continue: /* CIL Label */ ;
#line 914
    if (! (i < (unsigned long )def___0->num_validators)) {
#line 914
      goto while_break;
    }
    {
#line 918
    if ((unsigned int )(def___0->validators + i)->type == 0U) {
#line 918
      goto case_0;
    }
#line 932
    if ((unsigned int )(def___0->validators + i)->type == 1U) {
#line 932
      goto case_1;
    }
#line 990
    if ((unsigned int )(def___0->validators + i)->type == 2U) {
#line 990
      goto case_2;
    }
#line 1000
    goto switch_default___0;
    case_0: /* CIL Label */ 
    {
#line 926
    tmp = (*((def___0->validators + i)->v.fn.function))(& validation_data);
    }
#line 926
    if ((unsigned long )tmp != (unsigned long )OK) {
#line 928
      return ((Success )FAILURE);
    }
#line 930
    goto switch_break;
    case_1: /* CIL Label */ 
#line 938
    if ((unsigned long )(def___0->validators + i)->v.re.cached_re_buf == (unsigned long )((void *)0)) {
      {
#line 940
      aux_item_definition_cache_regexp(def___0, i);
      }
    }
#line 949
    if ((unsigned long )(def___0->validators + i)->v.re.cached_re_buf == (unsigned long )((void *)0)) {
      {
#line 951
      kom_log("Failed to cache regexp validator for \"%s\". Rejecting all such items.\n",
              def___0->name);
#line 954
      sfree((void *)(def___0->validators + i)->v.re.regexp);
#line 955
      (def___0->validators + i)->v.re.regexp = (char *)((void *)0);
#line 956
      (def___0->validators + i)->type = (enum aux_item_validation_type )2;
#line 957
      kom_errno = (enum kom_err )48;
      }
#line 958
      return ((Success )FAILURE);
    }
    {
#line 965
    tmp___0 = re_search((def___0->validators + i)->v.re.cached_re_buf, (char const   *)((char *)(validation_data.item)->data.string),
                        (int )(validation_data.item)->data.len, 0, (int )(validation_data.item)->data.len,
                        (struct re_registers *)((void *)0));
    }
    {
#line 972
    if (tmp___0 == -1) {
#line 972
      goto case_neg_1;
    }
#line 976
    if (tmp___0 == -2) {
#line 976
      goto case_neg_2;
    }
#line 982
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 974
    kom_errno = (enum kom_err )48;
#line 975
    return ((Success )FAILURE);
    case_neg_2: /* CIL Label */ 
    {
#line 978
    kom_log("Internal error in regex matching aux-item data.\n");
#line 979
    kom_errno = (enum kom_err )48;
    }
#line 980
    return ((Success )FAILURE);
#line 981
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 984
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 988
    goto switch_break;
    case_2: /* CIL Label */ 
#line 996
    kom_errno = (enum kom_err )48;
#line 997
    return ((Success )FAILURE);
#line 998
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 1001
    kom_log("BUG: unknown aux_item validator type\n");
    }
    switch_break: /* CIL Label */ ;
    }
#line 914
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1010
  return ((Success )OK);
}
}
#line 1036 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static Bool aux_item_add_perm(Aux_item const   *item , Aux_item_definition const   *def___0 ,
                              Connection *creating_conn , Pers_no subordinate , Aux_item_list *add_to_list ,
                              unsigned long start_looking_at , Bool creating , enum object_type object_type ) 
{ 
  short can_add_when ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;
  Aux_item_validation_data validation_data ;
  Success tmp___2 ;

  {
#line 1046
  can_add_when = (short)0;
#line 1048
  kom_errno = (enum kom_err )0;
#line 1052
  if (! ((unsigned long )creating_conn != (unsigned long )((void *)0))) {
#line 1052
    if (! creating) {
      {
#line 1052
      __assert_fail("creating_conn != ((void *)0) || creating", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c",
                    1052U, "aux_item_add_perm");
      }
    }
  }
#line 1054
  if ((unsigned long )def___0 == (unsigned long )((void *)0)) {
    {
#line 1055
    def___0 = find_aux_item_definition(item);
    }
  }
#line 1059
  if ((unsigned long )def___0 == (unsigned long )((void *)0)) {
#line 1061
    kom_errno = (enum kom_err )48;
#line 1062
    return ((Bool )0);
  }
#line 1065
  if (def___0->disabled) {
#line 1067
    kom_errno = (enum kom_err )48;
#line 1068
    return ((Bool )0);
  }
  {
#line 1073
  if ((unsigned int )object_type == 1U) {
#line 1073
    goto case_1;
  }
#line 1074
  if ((unsigned int )object_type == 2U) {
#line 1074
    goto case_2;
  }
#line 1075
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1073
  can_add_when = (short )def___0->text_a;
#line 1073
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1074
  can_add_when = (short )def___0->conf_a;
#line 1074
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1075
  can_add_when = (short)0;
  switch_break: /* CIL Label */ ;
  }
#line 1078
  if (can_add_when) {
#line 1080
    if (creating) {
#line 1080
      if (! ((int )can_add_when & 1)) {
#line 1080
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1080
    if (! creating) {
#line 1080
      if (! ((int )can_add_when & 2)) {
#line 1083
        kom_errno = (enum kom_err )49;
#line 1084
        return ((Bool )0);
      }
    } else {
#line 1083
      kom_errno = (enum kom_err )49;
#line 1084
      return ((Bool )0);
    }
  }
#line 1088
  if (def___0->system_only) {
#line 1090
    kom_errno = (enum kom_err )49;
#line 1091
    return ((Bool )0);
  }
#line 1094
  if (def___0->author_only) {
#line 1094
    goto _L___2;
  } else
#line 1094
  if (def___0->supervisor_only) {
    _L___2: /* CIL Label */ 
#line 1094
    if (! creating) {
#line 1094
      if ((unsigned long )creating_conn != (unsigned long )((void *)0)) {
#line 1094
        if ((int )creating_conn->ena_level >= 8) {
#line 1094
          if (creating_conn->person) {
#line 1094
            if (! (creating_conn->person)->privileges.wheel) {
#line 1094
              goto _L___1;
            }
          } else {
#line 1094
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 1099
          if (def___0->author_only) {
            {
#line 1099
            tmp = is_supervisor(subordinate, (Connection const   *)creating_conn);
            }
#line 1099
            if (! tmp) {
#line 1102
              kom_errno = (enum kom_err )49;
#line 1103
              return ((Bool )0);
            }
          }
#line 1107
          if (def___0->supervisor_only) {
            {
#line 1107
            tmp___0 = is_strictly_supervisor(subordinate, creating_conn->pers_no,
                                             (Person const   *)creating_conn->person);
            }
#line 1107
            if (! tmp___0) {
#line 1112
              kom_errno = (enum kom_err )49;
#line 1113
              return ((Bool )0);
            }
          }
        }
      }
    }
  }
  {
#line 1119
  kom_errno = (enum kom_err )0;
#line 1120
  tmp___1 = aux_item_check_unique(item, def___0, add_to_list, start_looking_at);
  }
#line 1120
  if (! tmp___1) {
#line 1122
    if (kom_errno) {
#line 1122
      kom_errno = kom_errno;
    } else {
#line 1122
      kom_errno = (enum kom_err )49;
    }
#line 1123
    return ((Bool )0);
  }
#line 1128
  if (def___0->num_validators > 0UL) {
    {
#line 1132
    validation_data.item = item;
#line 1133
    validation_data.def = def___0;
#line 1134
    validation_data.creating_conn = creating_conn;
#line 1135
    validation_data.creating = creating;
#line 1136
    validation_data.subordinate = subordinate;
#line 1147
    tmp___2 = aux_item_validate(validation_data);
    }
#line 1147
    if ((unsigned long )tmp___2 != (unsigned long )OK) {
#line 1149
      kom_errno = (enum kom_err )48;
#line 1150
      return ((Bool )0);
    }
  }
#line 1154
  return ((Bool )1);
}
}
#line 1168 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static Bool aux_item_check_unique(Aux_item const   *item , Aux_item_definition const   *def___0 ,
                                  Aux_item_list *add_to_list , unsigned long start_looking_at ) 
{ 
  unsigned long i ;
  int tmp ;

  {
#line 1176
  if ((unsigned long )add_to_list == (unsigned long )((void *)0)) {
#line 1180
    return ((Bool )1);
  } else
#line 1176
  if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 1180
    return ((Bool )1);
  } else
#line 1176
  if (start_looking_at >= (unsigned long )add_to_list->length) {
#line 1180
    return ((Bool )1);
  }
#line 1183
  if ((unsigned long )def___0 != (unsigned long )((void *)0)) {
    {
#line 1184
    def___0 = find_aux_item_definition(item);
    }
  }
#line 1185
  if ((unsigned long )def___0 == (unsigned long )((void *)0)) {
#line 1186
    return ((Bool )1);
  }
#line 1188
  i = start_looking_at;
  {
#line 1188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1188
    if (! (i < (unsigned long )add_to_list->length)) {
#line 1188
      goto while_break;
    }
#line 1190
    if (def___0->one_per_person) {
#line 1190
      if ((add_to_list->items + i)->tag == (unsigned long )item->tag) {
#line 1190
        if ((int )(add_to_list->items + i)->creator == (int )item->creator) {
#line 1190
          if (! (add_to_list->items + i)->flags.deleted) {
#line 1194
            return ((Bool )0);
          }
        }
      }
    }
#line 1196
    if (def___0->unique_data) {
#line 1196
      if ((add_to_list->items + i)->tag == (unsigned long )item->tag) {
        {
#line 1196
        tmp = s_strcmp((add_to_list->items + i)->data, (String )item->data);
        }
#line 1196
        if (tmp == 0) {
#line 1200
          kom_errno = (enum kom_err )48;
#line 1201
          return ((Bool )0);
        }
      }
    }
#line 1188
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1205
  return ((Bool )1);
}
}
#line 1217 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
void aux_inherit_items(Aux_item_list *target , Aux_item_list const   *parent , unsigned long *counter ,
                       Conf_no subordinate , Text_no object_no , Text_stat *object ) 
{ 
  int i ;
  Aux_item item ;
  Aux_item_definition const   *def___0 ;
  Bool tmp ;
  void *tmp___0 ;

  {
#line 1231
  if (! target) {
#line 1232
    return;
  } else
#line 1231
  if (! parent) {
#line 1232
    return;
  }
#line 1234
  i = 0;
  {
#line 1234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1234
    if (! (i < (int )parent->length)) {
#line 1234
      goto while_break;
    }
#line 1236
    if ((parent->items + i)->flags.inherit) {
#line 1236
      if (! (parent->items + i)->flags.deleted) {
#line 1236
        if ((parent->items + i)->inherit_limit != 1UL) {
          {
#line 1240
          def___0 = find_aux_item_definition((Aux_item const   *)(parent->items + i));
          }
#line 1241
          if ((unsigned long )def___0 == (unsigned long )((void *)0)) {
#line 1250
            goto __Cont;
          } else {
            {
#line 1241
            tmp = aux_item_add_perm((Aux_item const   *)(parent->items + i), def___0,
                                    (Connection *)((void *)0), subordinate, target,
                                    0UL, (Bool )1, (enum object_type )1);
            }
#line 1241
            if (! tmp) {
#line 1250
              goto __Cont;
            }
          }
          {
#line 1252
          copy_aux_item(& item, (Aux_item const   *)(parent->items + i));
#line 1253
          init_aux_item_link(& item.linked_item);
#line 1254
          prepare_aux_item(& item, (parent->items + i)->creator, def___0);
          }
#line 1255
          if (item.inherit_limit != 0UL) {
#line 1256
            (item.inherit_limit) --;
          }
          {
#line 1258
          tmp___0 = srealloc((void *)target->items, (unsigned long )((int )target->length + 1) * sizeof(Aux_item ));
#line 1258
          target->items = (Aux_item *)tmp___0;
#line 1260
          *(target->items + target->length) = item;
#line 1261
          (*counter) ++;
#line 1262
          (target->items + target->length)->aux_no = *counter;
#line 1263
          target->length = (unsigned short )((int )target->length + 1);
#line 1265
          aux_item_call_add_triggers(def___0, (enum object_type )1, (unsigned long )((int )target->length - 1),
                                     object_no, (void *)object, target->items + target->length);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1234
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1273
  return;
}
}
#line 1282 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
void filter_aux_item_list(Aux_item_list const   *original , Aux_item_list *result ,
                          Connection const   *viewer_conn ) 
{ 
  Aux_item *orig_aux ;
  unsigned long from ;
  unsigned long to ;
  void *tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;

  {
#line 1290
  if (! ((unsigned long )viewer_conn != (unsigned long )((void *)0))) {
    {
#line 1290
    __assert_fail("viewer_conn != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c",
                  1290U, "filter_aux_item_list");
    }
  }
  {
#line 1292
  tmp = tmp_alloc((unsigned long )original->length * sizeof(Aux_item ));
#line 1292
  result->items = (Aux_item *)tmp;
#line 1293
  result->length = (unsigned short)0;
#line 1294
  to = 0UL;
#line 1296
  from = 0UL;
  }
  {
#line 1296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1296
    if (! (from < (unsigned long )original->length)) {
#line 1296
      goto while_break;
    }
#line 1298
    orig_aux = original->items + from;
#line 1299
    if (orig_aux->flags.secret) {
      {
#line 1299
      tmp___0 = is_supervisor(orig_aux->creator, viewer_conn);
      }
#line 1299
      if (! tmp___0) {
#line 1299
        if ((int const   )viewer_conn->ena_level >= 4) {
#line 1299
          if (viewer_conn->person) {
#line 1299
            if (! (viewer_conn->person)->privileges.admin) {
#line 1303
              goto __Cont;
            }
          } else {
#line 1303
            goto __Cont;
          }
        } else {
#line 1303
          goto __Cont;
        }
      }
    }
#line 1306
    *(result->items + to) = *orig_aux;
#line 1308
    if (orig_aux->flags.hide_creator) {
      {
#line 1308
      tmp___1 = is_supervisor(orig_aux->creator, viewer_conn);
      }
#line 1308
      if (! tmp___1) {
#line 1308
        if ((int const   )viewer_conn->ena_level >= 4) {
#line 1308
          if (viewer_conn->person) {
#line 1308
            if (! (viewer_conn->person)->privileges.admin) {
#line 1312
              (result->items + to)->creator = (Pers_no )0;
            }
          } else {
#line 1312
            (result->items + to)->creator = (Pers_no )0;
          }
        } else {
#line 1312
          (result->items + to)->creator = (Pers_no )0;
        }
      }
    }
#line 1315
    result->length = (unsigned short )((int )result->length + 1);
#line 1316
    to ++;
    __Cont: /* CIL Label */ 
#line 1296
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1318
  return;
}
}
#line 1327 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
Success check_delete_aux_item_list(Number_list const   *items_to_delete , Aux_item_list const   *list_to_delete_from ,
                                   Conf_no const   subordinate ) 
{ 
  long i ;
  Aux_item const   *item ;
  Aux_item_definition const   *def___0 ;
  Bool tmp ;
  Bool tmp___0 ;

  {
#line 1336
  i = 0L;
  {
#line 1336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1336
    if (! (i < (long )items_to_delete->length)) {
#line 1336
      goto while_break;
    }
#line 1338
    if (*(items_to_delete->data + i) == 0L) {
#line 1339
      goto __Cont;
    }
    {
#line 1344
    item = find_aux_item(list_to_delete_from, (unsigned long )*(items_to_delete->data + i));
    }
#line 1344
    if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 1347
      kom_errno = (enum kom_err )49;
#line 1348
      err_stat = (unsigned long )i;
#line 1349
      return ((Success )FAILURE);
    }
    {
#line 1355
    def___0 = find_aux_item_definition(item);
    }
#line 1358
    if ((unsigned long )def___0 == (unsigned long )((void *)0)) {
#line 1360
      kom_errno = (enum kom_err )49;
#line 1361
      err_stat = (unsigned long )i;
#line 1362
      return ((Success )FAILURE);
    } else
#line 1364
    if (def___0->may_not_delete) {
#line 1366
      kom_errno = (enum kom_err )49;
#line 1367
      err_stat = (unsigned long )i;
#line 1368
      return ((Success )FAILURE);
    } else
#line 1370
    if ((int const   )item->creator == 0) {
#line 1372
      if (active_connection) {
#line 1372
        if ((int )active_connection->ena_level >= 8) {
#line 1372
          if (! (active_connection->person)->privileges.wheel) {
#line 1374
            kom_errno = (enum kom_err )49;
#line 1375
            err_stat = (unsigned long )i;
#line 1376
            return ((Success )FAILURE);
          }
        } else {
#line 1374
          kom_errno = (enum kom_err )49;
#line 1375
          err_stat = (unsigned long )i;
#line 1376
          return ((Success )FAILURE);
        }
      } else {
#line 1374
        kom_errno = (enum kom_err )49;
#line 1375
        err_stat = (unsigned long )i;
#line 1376
        return ((Success )FAILURE);
      }
    } else
#line 1379
    if ((int const   )item->creator != (int const   )active_connection->pers_no) {
#line 1381
      if (active_connection) {
#line 1381
        if ((int )active_connection->ena_level >= 8) {
#line 1381
          if (! (active_connection->person)->privileges.wheel) {
#line 1381
            goto _L___0;
          }
        } else {
#line 1381
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 1381
        tmp = is_supervisor((Conf_no )item->creator, (Connection const   *)active_connection);
        }
#line 1381
        if (! tmp) {
#line 1381
          if (! def___0->owner_delete) {
#line 1386
            kom_errno = (enum kom_err )49;
#line 1387
            err_stat = (unsigned long )i;
#line 1388
            return ((Success )FAILURE);
          } else {
            {
#line 1381
            tmp___0 = is_supervisor((Conf_no )subordinate, (Connection const   *)active_connection);
            }
#line 1381
            if (! tmp___0) {
#line 1386
              kom_errno = (enum kom_err )49;
#line 1387
              err_stat = (unsigned long )i;
#line 1388
              return ((Success )FAILURE);
            }
          }
        }
      }
    }
#line 1394
    if (item->flags.deleted) {
#line 1395
      *(items_to_delete->data + i) = 0L;
    }
    __Cont: /* CIL Label */ 
#line 1336
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1398
  return ((Success )OK);
}
}
#line 1410 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
void delete_aux_item_list(Number_list const   *items_to_delete , Aux_item_list *list_to_delete_from ,
                          enum object_type object_type , unsigned long object_no ,
                          void *object ) 
{ 
  long i ;
  Aux_item *item ;
  Aux_item const   *linked_item ;
  long item_index ;
  long item_to_delete ;
  unsigned long linked_object_no ;
  Number_list linked_delete ;
  Aux_item_list *linked_item_list ;
  void *linked_object ;
  Aux_item_definition const   *tmp ;
  Conference *tmp___0 ;
  Text_stat *tmp___1 ;

  {
#line 1427
  i = 0L;
  {
#line 1427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1427
    if (! (i < (long )items_to_delete->length)) {
#line 1427
      goto while_break;
    }
#line 1429
    if (*(items_to_delete->data + i) == 0L) {
#line 1430
      goto __Cont;
    }
    {
#line 1432
    item_index = find_aux_item_index((Aux_item_list const   *)list_to_delete_from,
                                     (unsigned long )*(items_to_delete->data + i));
    }
#line 1434
    if (item_index == -1L) {
      {
#line 1435
      restart_kom("Call to delete_aux_item_list without call to check_delete_aux_item_list");
      }
    }
    {
#line 1436
    item = list_to_delete_from->items + item_index;
#line 1437
    item->flags.deleted = 1U;
#line 1438
    tmp = find_aux_item_definition((Aux_item const   *)item);
#line 1438
    aux_item_call_delete_triggers(tmp, object_type, (unsigned long )item_index, object_no,
                                  object, item);
#line 1451
    linked_item = find_linked_aux_item(item);
    }
#line 1452
    if (linked_item) {
#line 1452
      if (! linked_item->flags.deleted) {
        {
#line 1455
        item_to_delete = (long )item->linked_item.target_item;
#line 1456
        linked_delete.length = 1;
#line 1457
        linked_delete.data = & item_to_delete;
#line 1460
        linked_item_list = find_linked_aux_item_list(item);
        }
        {
#line 1465
        if ((unsigned int )item->linked_item.target_type == 2U) {
#line 1465
          goto case_2;
        }
#line 1469
        if ((unsigned int )item->linked_item.target_type == 1U) {
#line 1469
          goto case_1;
        }
#line 1473
        if ((unsigned int )item->linked_item.target_type == 3U) {
#line 1473
          goto case_3;
        }
#line 1477
        goto switch_default;
        case_2: /* CIL Label */ 
        {
#line 1466
        linked_object_no = (unsigned long )item->linked_item.target_object.conf;
#line 1467
        tmp___0 = cached_get_conf_stat((Conf_no )linked_object_no);
#line 1467
        linked_object = (void *)tmp___0;
        }
#line 1468
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 1470
        linked_object_no = item->linked_item.target_object.text;
#line 1471
        tmp___1 = cached_get_text_stat(linked_object_no);
#line 1471
        linked_object = (void *)tmp___1;
        }
#line 1472
        goto switch_break;
        case_3: /* CIL Label */ 
#line 1474
        linked_object_no = 0UL;
#line 1475
        linked_object = (void *)0;
#line 1476
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1478
        kom_log("delete_aux_item_list(): bad target type\n");
        }
#line 1479
        return;
        switch_break: /* CIL Label */ ;
        }
        {
#line 1484
        delete_aux_item_list((Number_list const   *)(& linked_delete), linked_item_list,
                             item->linked_item.target_type, linked_object_no, linked_object);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1427
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1491
  return;
}
}
#line 1499 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
void undelete_aux_item_list(Number_list const   *items_to_undelete , Aux_item_list *list_to_undelete_from ,
                            enum object_type object_type , unsigned long object_no ,
                            void *object ) 
{ 
  enum kom_err saved_kom_errno ;
  unsigned long saved_err_stat ;
  long i ;
  Aux_item *item ;
  Aux_item const   *linked_item ;
  Aux_item_list *linked_item_list ;
  long item_index ;
  long item_to_undelete ;
  unsigned long linked_object_no ;
  Number_list linked_undelete ;
  void *linked_object ;
  Aux_item_definition const   *tmp ;
  Conference *tmp___0 ;
  Text_stat *tmp___1 ;

  {
#line 1518
  saved_kom_errno = kom_errno;
#line 1519
  saved_err_stat = err_stat;
#line 1521
  i = 0L;
  {
#line 1521
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1521
    if (! (i < (long )items_to_undelete->length)) {
#line 1521
      goto while_break;
    }
#line 1523
    if (*(items_to_undelete->data + i) == 0L) {
#line 1524
      goto __Cont;
    }
    {
#line 1526
    item_index = find_aux_item_index((Aux_item_list const   *)list_to_undelete_from,
                                     (unsigned long )*(items_to_undelete->data + i));
    }
#line 1528
    if (item_index == -1L) {
      {
#line 1529
      restart_kom("Call to undelete_aux_item_list without call to check_delete_aux_item_list");
      }
    }
    {
#line 1530
    item = list_to_undelete_from->items + item_index;
#line 1531
    item->flags.deleted = 0U;
#line 1532
    tmp = find_aux_item_definition((Aux_item const   *)item);
#line 1532
    aux_item_call_undelete_triggers(tmp, object_type, (unsigned long )item_index,
                                    object_no, object, item);
#line 1546
    linked_item = find_linked_aux_item(item);
    }
#line 1547
    if (linked_item) {
#line 1547
      if (linked_item->flags.deleted) {
        {
#line 1550
        item_to_undelete = (long )item->linked_item.target_item;
#line 1551
        linked_undelete.length = 1;
#line 1552
        linked_undelete.data = & item_to_undelete;
#line 1555
        linked_item_list = find_linked_aux_item_list(item);
        }
        {
#line 1560
        if ((unsigned int )item->linked_item.target_type == 2U) {
#line 1560
          goto case_2;
        }
#line 1564
        if ((unsigned int )item->linked_item.target_type == 1U) {
#line 1564
          goto case_1;
        }
#line 1568
        if ((unsigned int )item->linked_item.target_type == 3U) {
#line 1568
          goto case_3;
        }
#line 1572
        goto switch_default;
        case_2: /* CIL Label */ 
        {
#line 1561
        linked_object_no = (unsigned long )item->linked_item.target_object.conf;
#line 1562
        tmp___0 = cached_get_conf_stat((Conf_no )linked_object_no);
#line 1562
        linked_object = (void *)tmp___0;
        }
#line 1563
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 1565
        linked_object_no = item->linked_item.target_object.text;
#line 1566
        tmp___1 = cached_get_text_stat(linked_object_no);
#line 1566
        linked_object = (void *)tmp___1;
        }
#line 1567
        goto switch_break;
        case_3: /* CIL Label */ 
#line 1569
        linked_object_no = 0UL;
#line 1570
        linked_object = (void *)0;
#line 1571
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1573
        kom_log("undelete_aux_item_list(): bad link type\n");
#line 1574
        kom_errno = saved_kom_errno;
#line 1575
        err_stat = saved_err_stat;
        }
#line 1576
        return;
        switch_break: /* CIL Label */ ;
        }
        {
#line 1581
        undelete_aux_item_list((Number_list const   *)(& linked_undelete), linked_item_list,
                               item->linked_item.target_type, linked_object_no, linked_object);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1521
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1589
  kom_errno = saved_kom_errno;
#line 1590
  err_stat = saved_err_stat;
#line 1591
  return;
}
}
#line 1601 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void commit_aux_item_list_internal(Aux_item_list *list_to_commit , Bool shallow ) 
{ 
  long i ;
  long target ;
  Aux_item const   *linked_item ;
  Aux_item_list *aux_item_list ;

  {
#line 1610
  target = 0L;
#line 1611
  i = 0L;
  {
#line 1611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1611
    if (! (i < (long )list_to_commit->length)) {
#line 1611
      goto while_break;
    }
#line 1613
    if ((list_to_commit->items + i)->flags.deleted) {
      {
#line 1617
      s_clear(& (list_to_commit->items + i)->data);
#line 1625
      linked_item = find_linked_aux_item(list_to_commit->items + i);
      }
#line 1626
      if (linked_item) {
#line 1626
        if (linked_item->flags.deleted) {
#line 1626
          if (! shallow) {
            {
#line 1630
            aux_item_list = find_linked_aux_item_list(list_to_commit->items + i);
#line 1631
            commit_aux_item_list_internal(aux_item_list, (Bool )1);
#line 1632
            mark_linked_object_as_changed(list_to_commit->items + i);
            }
          }
        }
      }
    } else
#line 1635
    if (target != i) {
#line 1638
      *(list_to_commit->items + target) = *(list_to_commit->items + i);
#line 1639
      (list_to_commit->items + i)->data = (String )EMPTY_STRING;
#line 1640
      target ++;
    } else {
#line 1645
      target ++;
    }
#line 1611
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1655
  memset((void *)(list_to_commit->items + target), 0, (unsigned long )((long )list_to_commit->length - target) * sizeof(Aux_item ));
#line 1659
  list_to_commit->length = (unsigned short )target;
  }
#line 1660
  return;
}
}
#line 1663 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
void commit_aux_item_list(Aux_item_list *list_to_commit ) 
{ 


  {
  {
#line 1665
  commit_aux_item_list_internal(list_to_commit, (Bool )0);
  }
#line 1666
  return;
}
}
#line 1679 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static Aux_item const   *find_aux_item(Aux_item_list const   *list , unsigned long aux_no ) 
{ 
  long item_index ;
  long tmp ;

  {
  {
#line 1682
  tmp = find_aux_item_index(list, aux_no);
#line 1682
  item_index = tmp;
  }
#line 1684
  if (item_index == -1L) {
#line 1685
    return ((Aux_item const   *)((void *)0));
  }
#line 1687
  return ((Aux_item const   *)(list->items + item_index));
}
}
#line 1721 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
Success text_stat_check_add_aux_item_list(Text_stat *text_s , Aux_item_list *list ,
                                          Connection *creating_conn ) 
{ 
  Aux_item *item ;
  unsigned long i ;
  Aux_item_definition const   *def___0 ;
  Aux_item_list *tmp ;
  int tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;

  {
#line 1730
  if (! ((unsigned long )creating_conn != (unsigned long )((void *)0))) {
    {
#line 1730
    __assert_fail("creating_conn != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c",
                  1730U, "text_stat_check_add_aux_item_list");
    }
  }
#line 1732
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 1733
    return ((Success )OK);
  }
#line 1735
  kom_errno = (enum kom_err )0;
#line 1737
  i = 0UL;
  {
#line 1737
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1737
    if (! (i < (unsigned long )list->length)) {
#line 1737
      goto while_break;
    }
    {
#line 1739
    item = list->items + i;
#line 1741
    def___0 = find_aux_item_definition((Aux_item const   *)item);
    }
#line 1742
    if ((unsigned long )def___0 == (unsigned long )((void *)0)) {
#line 1744
      kom_errno = (enum kom_err )48;
#line 1745
      err_stat = i;
#line 1746
      return ((Success )FAILURE);
    }
#line 1749
    if (text_s) {
#line 1749
      tmp = & text_s->aux_item_list;
    } else {
#line 1749
      tmp = (Aux_item_list *)((void *)0);
    }
#line 1749
    if (text_s) {
#line 1749
      tmp___0 = (int )text_s->author;
    } else {
#line 1749
      tmp___0 = (int )creating_conn->pers_no;
    }
    {
#line 1749
    tmp___1 = aux_item_add_perm((Aux_item const   *)item, def___0, creating_conn,
                                (Pers_no )tmp___0, tmp, 0UL, (Bool )((unsigned long )text_s == (unsigned long )((void *)0)),
                                (enum object_type )1);
    }
#line 1749
    if (tmp___1) {
      {
#line 1749
      tmp___2 = aux_item_check_unique((Aux_item const   *)item, def___0, list, i + 1UL);
      }
#line 1749
      if (tmp___2) {
#line 1749
        if (! def___0->texts) {
          _L: /* CIL Label */ 
#line 1760
          if (kom_errno) {
#line 1760
            kom_errno = kom_errno;
          } else {
#line 1760
            kom_errno = (enum kom_err )49;
          }
#line 1761
          err_stat = i;
#line 1762
          return ((Success )FAILURE);
        }
      } else {
#line 1749
        goto _L;
      }
    } else {
#line 1749
      goto _L;
    }
#line 1737
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1766
  return ((Success )OK);
}
}
#line 1769 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
void text_stat_add_aux_item_list(Text_stat *text_s , Text_no text_no , Aux_item_list *item_list ,
                                 Pers_no item_creator ) 
{ 


  {
  {
#line 1774
  aux_item_list_add_items(& text_s->aux_item_list, item_list, (enum object_type )1,
                          text_no, (void *)text_s, & text_s->highest_aux, item_creator);
  }
#line 1781
  return;
}
}
#line 1787 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
Success conf_stat_check_add_aux_item_list(Conference *conf , Conf_no conf_no , Aux_item_list *list ,
                                          Connection *creating_conn , Bool creating ) 
{ 
  unsigned long i ;
  Aux_item *item ;
  Aux_item_definition const   *def___0 ;
  Bool tmp ;
  Bool tmp___0 ;

  {
#line 1798
  if (! ((unsigned long )conf != (unsigned long )((void *)0))) {
    {
#line 1798
    __assert_fail("conf != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c",
                  1798U, "conf_stat_check_add_aux_item_list");
    }
  }
#line 1799
  if (! ((int )conf_no != 0)) {
    {
#line 1799
    __assert_fail("conf_no != 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c",
                  1799U, "conf_stat_check_add_aux_item_list");
    }
  }
#line 1800
  if (! ((unsigned long )creating_conn != (unsigned long )((void *)0))) {
    {
#line 1800
    __assert_fail("creating_conn != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c",
                  1800U, "conf_stat_check_add_aux_item_list");
    }
  }
#line 1802
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 1803
    return ((Success )OK);
  }
#line 1805
  kom_errno = (enum kom_err )0;
#line 1807
  i = 0UL;
  {
#line 1807
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1807
    if (! (i < (unsigned long )list->length)) {
#line 1807
      goto while_break;
    }
    {
#line 1809
    item = list->items + i;
#line 1810
    def___0 = find_aux_item_definition((Aux_item const   *)item);
    }
#line 1811
    if ((unsigned long )def___0 == (unsigned long )((void *)0)) {
#line 1813
      kom_errno = (enum kom_err )48;
#line 1814
      err_stat = i;
#line 1815
      return ((Success )FAILURE);
    }
    {
#line 1818
    tmp = aux_item_add_perm((Aux_item const   *)item, def___0, creating_conn, conf_no,
                            & conf->aux_item_list, 0UL, creating, (enum object_type )2);
    }
#line 1818
    if (tmp) {
      {
#line 1818
      tmp___0 = aux_item_check_unique((Aux_item const   *)item, def___0, list, i + 1UL);
      }
#line 1818
      if (tmp___0) {
#line 1818
        if (! conf->type.letter_box) {
#line 1818
          if (! def___0->confs) {
#line 1818
            goto _L;
          } else {
#line 1818
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1818
        if (conf->type.letter_box) {
#line 1818
          if (! def___0->letterboxes) {
            _L: /* CIL Label */ 
#line 1830
            if (kom_errno) {
#line 1830
              kom_errno = kom_errno;
            } else {
#line 1830
              kom_errno = (enum kom_err )49;
            }
#line 1831
            err_stat = i;
#line 1832
            return ((Success )FAILURE);
          }
        }
      } else {
#line 1818
        goto _L;
      }
    } else {
#line 1818
      goto _L;
    }
#line 1807
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1836
  return ((Success )OK);
}
}
#line 1839 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
void conf_stat_add_aux_item_list(Conference *conf , Conf_no conf_no , Aux_item_list *item_list ,
                                 Pers_no item_creator ) 
{ 


  {
  {
#line 1845
  aux_item_list_add_items(& conf->aux_item_list, item_list, (enum object_type )2,
                          (unsigned long )conf_no, (void *)conf, & conf->highest_aux,
                          item_creator);
  }
#line 1852
  return;
}
}
#line 1856 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
Success system_check_add_aux_item_list(Info *info , Aux_item_list *list , Connection *creating_conn ) 
{ 
  unsigned long i ;
  Aux_item *item ;
  Aux_item_definition const   *def___0 ;
  Bool tmp ;
  Bool tmp___0 ;

  {
#line 1864
  if (! ((unsigned long )creating_conn != (unsigned long )((void *)0))) {
    {
#line 1864
    __assert_fail("creating_conn != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c",
                  1864U, "system_check_add_aux_item_list");
    }
  }
#line 1866
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 1867
    return ((Success )OK);
  }
#line 1869
  kom_errno = (enum kom_err )0;
#line 1871
  i = 0UL;
  {
#line 1871
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1871
    if (! (i < (unsigned long )list->length)) {
#line 1871
      goto while_break;
    }
    {
#line 1873
    item = list->items + i;
#line 1874
    def___0 = find_aux_item_definition((Aux_item const   *)item);
    }
#line 1875
    if ((unsigned long )def___0 == (unsigned long )((void *)0)) {
#line 1877
      kom_errno = (enum kom_err )48;
#line 1878
      err_stat = i;
#line 1879
      return ((Success )FAILURE);
    }
    {
#line 1887
    tmp = aux_item_add_perm((Aux_item const   *)item, def___0, creating_conn, creating_conn->pers_no,
                            & info->aux_item_list, 0UL, (Bool )0, (enum object_type )3);
    }
#line 1887
    if (tmp) {
      {
#line 1887
      tmp___0 = aux_item_check_unique((Aux_item const   *)item, def___0, list, i + 1UL);
      }
#line 1887
      if (tmp___0) {
#line 1887
        if (! def___0->system) {
          _L: /* CIL Label */ 
#line 1898
          if (kom_errno) {
#line 1898
            kom_errno = kom_errno;
          } else {
#line 1898
            kom_errno = (enum kom_err )49;
          }
#line 1899
          err_stat = i;
#line 1900
          return ((Success )FAILURE);
        }
      } else {
#line 1887
        goto _L;
      }
    } else {
#line 1887
      goto _L;
    }
#line 1871
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1904
  return ((Success )OK);
}
}
#line 1908 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
void system_add_aux_item_list(Info *info , Aux_item_list *item_list , Pers_no item_creator ) 
{ 


  {
  {
#line 1913
  aux_item_list_add_items(& info->aux_item_list, item_list, (enum object_type )3,
                          0UL, (void *)info, & info->highest_aux_no, item_creator);
  }
#line 1920
  return;
}
}
#line 1922 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
extern Success query_predefined_aux_items(Number_list *result ) 
{ 
  Aux_item_definition *def___0 ;
  void *tmp ;

  {
  {
#line 1927
  tmp = tmp_alloc(sizeof(unsigned long ) * num_aux_item_definitions);
#line 1927
  result->data = (long *)tmp;
  }
#line 1928
  if ((unsigned long )result->data == (unsigned long )((void *)0)) {
    {
#line 1930
    restart_kom("Out of memory in query_predefined_aux_items.\n");
    }
  }
#line 1933
  result->length = 0;
#line 1934
  def___0 = aux_item_definition_list;
  {
#line 1935
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1935
    if (! ((unsigned long )def___0 != (unsigned long )((void *)0))) {
#line 1935
      goto while_break;
    }
#line 1937
    if (def___0->tag != 0UL) {
#line 1939
      if (! ((unsigned long )result->length < num_aux_item_definitions)) {
        {
#line 1939
        __assert_fail("(unsigned long)result->length < num_aux_item_definitions",
                      "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c",
                      1939U, "query_predefined_aux_items");
        }
      }
#line 1940
      *(result->data + result->length) = (long )def___0->tag;
#line 1941
      (result->length) ++;
    }
#line 1943
    def___0 = def___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1946
  return ((Success )OK);
}
}
#line 1950 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void aux_item_trigger_mark_text(Aux_item_trigger_data *data ) 
{ 
  Text_no text_no ;
  Text_stat *text_stat ;
  String_size ill_char ;
  long tmp ;

  {
  {
#line 1957
  tmp = s_strtol((String const   )(data->item)->data, & ill_char);
#line 1957
  text_no = (Text_no )tmp;
  }
  {
#line 1958
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1958
    text_stat = cached_get_text_stat(text_no);
    }
#line 1958
    if ((unsigned long )text_stat == (unsigned long )((void *)0)) {
#line 1958
      return;
    }
#line 1958
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1959
  if ((int )text_stat->no_of_marks < param.max_marks_text) {
#line 1960
    text_stat->no_of_marks = (unsigned short )((int )text_stat->no_of_marks + 1);
  }
  {
#line 1961
  mark_text_as_changed(text_no);
  }
#line 1962
  return;
}
}
#line 1964 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void aux_item_trigger_unmark_text(Aux_item_trigger_data *data ) 
{ 
  Text_no text_no ;
  Text_stat *text_stat ;
  String_size ill_char ;
  long tmp ;

  {
  {
#line 1971
  tmp = s_strtol((String const   )(data->item)->data, & ill_char);
#line 1971
  text_no = (Text_no )tmp;
  }
  {
#line 1972
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1972
    text_stat = cached_get_text_stat(text_no);
    }
#line 1972
    if ((unsigned long )text_stat == (unsigned long )((void *)0)) {
#line 1972
      return;
    }
#line 1972
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1973
  if ((int )text_stat->no_of_marks > 0) {
#line 1974
    text_stat->no_of_marks = (unsigned short )((int )text_stat->no_of_marks - 1);
  }
  {
#line 1975
  mark_text_as_changed(text_no);
  }
#line 1976
  return;
}
}
#line 1978 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void aux_item_trigger_mirror_faq(Aux_item_trigger_data *data ) 
{ 
  Text_no text_no ;
  Aux_item item_data ;
  char conf_no_string[2UL + 3UL * sizeof(unsigned long )] ;
  String_size ill_char ;
  String str ;
  long tmp ;

  {
#line 1988
  if ((unsigned long )data->object == (unsigned long )((void *)0)) {
#line 1989
    return;
  }
#line 1991
  if ((unsigned int )data->object_type != 2U) {
#line 1991
    if ((unsigned int )data->object_type != 3U) {
#line 1994
      return;
    }
  }
  {
#line 1999
  tmp = s_strtol((String const   )(data->item)->data, & ill_char);
#line 1999
  text_no = (Text_no )tmp;
#line 2003
  sprintf((char */* __restrict  */)(conf_no_string), (char const   */* __restrict  */)"%lu",
          data->object_no);
#line 2004
  str = s_fcrea_str((char const   *)(conf_no_string));
#line 2008
  init_aux_item(& item_data);
#line 2009
  item_data.tag = 28UL;
#line 2010
  item_data.data = str;
#line 2015
  aux_item_link_items(data->object_type, data->object_no, data->object, data->item,
                      (enum object_type )1, text_no, (void *)0, & item_data);
  }
#line 2025
  return;
}
}
#line 2050 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static void aux_item_trigger_link_item(Aux_item_trigger_data *data ) 
{ 
  char object_no_string[100] ;
  char *tmp_str ;
  char type_char ;
  enum object_type target_object_type ;
  unsigned long target_item_tag ;
  unsigned long target_object_no ;
  int nread ;
  Aux_item item_data ;

  {
  {
#line 2061
  init_aux_item(& item_data);
#line 2074
  tmp_str = s_crea_c_str((String const   )(data->item)->data);
#line 2075
  nread = sscanf((char const   */* __restrict  */)tmp_str, (char const   */* __restrict  */)"%c %lu %lu",
                 & type_char, & target_item_tag, & target_object_no);
#line 2080
  string_free((void *)tmp_str);
  }
#line 2082
  if (nread != 3) {
#line 2083
    return;
  }
  {
#line 2087
  if ((int )type_char == 84) {
#line 2087
    goto case_84;
  }
#line 2088
  if ((int )type_char == 67) {
#line 2088
    goto case_67;
  }
#line 2089
  if ((int )type_char == 73) {
#line 2089
    goto case_73;
  }
#line 2090
  goto switch_default;
  case_84: /* CIL Label */ 
#line 2087
  target_object_type = (enum object_type )1;
#line 2087
  goto switch_break;
  case_67: /* CIL Label */ 
#line 2088
  target_object_type = (enum object_type )2;
#line 2088
  goto switch_break;
  case_73: /* CIL Label */ 
#line 2089
  target_object_type = (enum object_type )3;
#line 2089
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2090
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2098
  if ((unsigned int )data->object_type == 1U) {
#line 2098
    goto case_1;
  }
#line 2099
  if ((unsigned int )data->object_type == 2U) {
#line 2099
    goto case_2;
  }
#line 2100
  if ((unsigned int )data->object_type == 3U) {
#line 2100
    goto case_3;
  }
#line 2101
  goto switch_default___0;
  case_1: /* CIL Label */ 
#line 2098
  type_char = (char )'T';
#line 2098
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 2099
  type_char = (char )'C';
#line 2099
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 2100
  type_char = (char )'I';
#line 2100
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 2101
  type_char = (char )'?';
#line 2101
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 2104
  sprintf((char */* __restrict  */)(object_no_string), (char const   */* __restrict  */)"%c %lu %lu",
          (int )type_char, (data->item)->tag, data->object_no);
#line 2120
  item_data.tag = target_item_tag;
#line 2121
  item_data.data = s_fcrea_str((char const   *)(object_no_string));
#line 2123
  aux_item_link_items(data->object_type, data->object_no, data->object, data->item,
                      target_object_type, target_object_no, (void *)0, & item_data);
  }
#line 2133
  return;
}
}
#line 2143 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-items.c"
static Success aux_item_validate_existing_text(Aux_item_validation_data *v_data ) 
{ 
  Text_stat *text_stat ;
  Text_no text_no ;
  String_size ill_char ;
  long tmp ;
  Bool tmp___0 ;

  {
  {
#line 2150
  tmp = s_strtol((v_data->item)->data, & ill_char);
#line 2150
  text_no = (Text_no )tmp;
  }
  {
#line 2151
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2151
    text_stat = cached_get_text_stat(text_no);
    }
#line 2151
    if ((unsigned long )text_stat == (unsigned long )((void *)0)) {
#line 2151
      return ((Success )FAILURE);
    }
#line 2151
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2153
  if ((unsigned long )v_data->creating_conn != (unsigned long )((void *)0)) {
    {
#line 2153
    tmp___0 = text_read_access((Connection const   *)v_data->creating_conn, text_no,
                               (Text_stat const   *)text_stat);
    }
#line 2153
    if (tmp___0) {
#line 2156
      return ((Success )OK);
    }
  }
#line 2159
  return ((Success )FAILURE);
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 103 "aux-item-def-parse.y"
static Aux_item_definition def  ;
#line 104 "aux-item-def-parse.y"
static Bool errorFlag  =    (Bool )0;
#line 125
int aid_lex(void) ;
#line 127 "aux-item-def-parse.y"
static char *inputFile  ;
#line 128 "aux-item-def-parse.y"
int aux_item_def_error_line  ;
#line 132
void ( /* format attribute */  aid_error)(char const   *format  , ...) ;
#line 142
static int aux_item_def_check_assign(char const   *id , String field , void *data ,
                                     int type , struct aux_item_def_value_type *val ,
                                     int lineno ) ;
#line 148
static char const   *aux_item_def_typename(int type ) ;
#line 149
static short aux_item_def_check_trigger(char const   *check_name , int type , String trigger_name ,
                                        String function_name , unsigned long *counter ,
                                        Aux_item_trigger **triggers ) ;
#line 157
static short aux_item_def_check_validate(char const   *check_name , String field_name ,
                                         int type , String data , Aux_item_definition *def___0 ) ;
#line 215 "aux-item-def-parse.y"
static char const   yytranslate[270]  = 
#line 215
  {      (char const   )0,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )19,      (char const   )20,      (char const   )2,      (char const   )2, 
        (char const   )21,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )18,      (char const   )23, 
        (char const   )2,      (char const   )22,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )16, 
        (char const   )2,      (char const   )17,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )1,      (char const   )3,      (char const   )4,      (char const   )5, 
        (char const   )6,      (char const   )7,      (char const   )8,      (char const   )9, 
        (char const   )10,      (char const   )11,      (char const   )12,      (char const   )13, 
        (char const   )14,      (char const   )15};
#line 247 "aux-item-def-parse.y"
static short const   yyprhs[25]  = 
#line 247
  {      (short const   )0,      (short const   )0,      (short const   )3,      (short const   )4, 
        (short const   )9,      (short const   )16,      (short const   )24,      (short const   )28, 
        (short const   )30,      (short const   )33,      (short const   )36,      (short const   )39, 
        (short const   )41,      (short const   )44,      (short const   )47,      (short const   )50, 
        (short const   )51,      (short const   )54,      (short const   )57,      (short const   )58, 
        (short const   )63,      (short const   )65,      (short const   )67,      (short const   )69, 
        (short const   )73};
#line 253 "aux-item-def-parse.y"
static short const   yyrhs[75]  = 
#line 253
  {      (short const   )24,      (short const   )25,      (short const   )0,      (short const   )0, 
        (short const   )26,      (short const   )16,      (short const   )30,      (short const   )17, 
        (short const   )0,      (short const   )3,      (short const   )18,      (short const   )5, 
        (short const   )19,      (short const   )27,      (short const   )20,      (short const   )0, 
        (short const   )3,      (short const   )18,      (short const   )5,      (short const   )19, 
        (short const   )27,      (short const   )20,      (short const   )7,      (short const   )0, 
        (short const   )27,      (short const   )21,      (short const   )28,      (short const   )0, 
        (short const   )28,      (short const   )0,      (short const   )29,      (short const   )8, 
        (short const   )0,      (short const   )29,      (short const   )9,      (short const   )0, 
        (short const   )29,      (short const   )10,      (short const   )0,      (short const   )11, 
        (short const   )0,      (short const   )29,      (short const   )12,      (short const   )0, 
        (short const   )29,      (short const   )14,      (short const   )0,      (short const   )29, 
        (short const   )15,      (short const   )0,      (short const   )0,      (short const   )30, 
        (short const   )31,      (short const   )0,      (short const   )30,      (short const   )1, 
        (short const   )0,      (short const   )0,      (short const   )5,      (short const   )22, 
        (short const   )32,      (short const   )23,      (short const   )0,      (short const   )4, 
        (short const   )0,      (short const   )6,      (short const   )0,      (short const   )3, 
        (short const   )0,      (short const   )5,      (short const   )19,      (short const   )20, 
        (short const   )0,      (short const   )13,      (short const   )0};
#line 269 "aux-item-def-parse.y"
static short const   yyrline[25]  = 
#line 269
  {      (short const   )0,      (short const   )193,      (short const   )194,      (short const   )197, 
        (short const   )207,      (short const   )220,      (short const   )231,      (short const   )232, 
        (short const   )235,      (short const   )236,      (short const   )237,      (short const   )239, 
        (short const   )240,      (short const   )249,      (short const   )250,      (short const   )251, 
        (short const   )254,      (short const   )255,      (short const   )256,      (short const   )259, 
        (short const   )345,      (short const   )346,      (short const   )347,      (short const   )348, 
        (short const   )349};
#line 281 "aux-item-def-parse.y"
static char const   * const  yytname[34]  = 
#line 281
  {      (char const   */* const  */)"$",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined.",      (char const   */* const  */)"NUMBER", 
        (char const   */* const  */)"BOOLEAN",      (char const   */* const  */)"ID",      (char const   */* const  */)"STRING",      (char const   */* const  */)"DISABLED", 
        (char const   */* const  */)"TEXT",      (char const   */* const  */)"CONFERENCE",      (char const   */* const  */)"LETTERBOX",      (char const   */* const  */)"TOK_SERVER", 
        (char const   */* const  */)"TOK_ANY",      (char const   */* const  */)"VOID",      (char const   */* const  */)"CREATE",      (char const   */* const  */)"MODIFY", 
        (char const   */* const  */)"\'{\'",      (char const   */* const  */)"\'}\'",      (char const   */* const  */)"\':\'",      (char const   */* const  */)"\'(\'", 
        (char const   */* const  */)"\')\'",      (char const   */* const  */)"\',\'",      (char const   */* const  */)"\'=\'",      (char const   */* const  */)"\';\'", 
        (char const   */* const  */)"items",      (char const   */* const  */)"item",      (char const   */* const  */)"head",      (char const   */* const  */)"targets", 
        (char const   */* const  */)"target",      (char const   */* const  */)"action",      (char const   */* const  */)"body",      (char const   */* const  */)"assign", 
        (char const   */* const  */)"value",      (char const   */* const  */)0};
#line 292 "aux-item-def-parse.y"
static short const   aid_r1[25]  = 
#line 292
  {      (short const   )0,      (short const   )24,      (short const   )24,      (short const   )25, 
        (short const   )26,      (short const   )26,      (short const   )27,      (short const   )27, 
        (short const   )28,      (short const   )28,      (short const   )28,      (short const   )28, 
        (short const   )28,      (short const   )29,      (short const   )29,      (short const   )29, 
        (short const   )30,      (short const   )30,      (short const   )30,      (short const   )31, 
        (short const   )32,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )32};
#line 300 "aux-item-def-parse.y"
static short const   aid_r2[25]  = 
#line 300
  {      (short const   )0,      (short const   )2,      (short const   )0,      (short const   )4, 
        (short const   )6,      (short const   )7,      (short const   )3,      (short const   )1, 
        (short const   )2,      (short const   )2,      (short const   )2,      (short const   )1, 
        (short const   )2,      (short const   )2,      (short const   )2,      (short const   )0, 
        (short const   )2,      (short const   )2,      (short const   )0,      (short const   )4, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )3, 
        (short const   )1};
#line 310 "aux-item-def-parse.y"
static short const   yydefact[40]  = 
#line 310
  {      (short const   )2,      (short const   )0,      (short const   )0,      (short const   )1, 
        (short const   )0,      (short const   )0,      (short const   )18,      (short const   )0, 
        (short const   )0,      (short const   )15,      (short const   )17,      (short const   )0, 
        (short const   )3,      (short const   )16,      (short const   )11,      (short const   )0, 
        (short const   )7,      (short const   )0,      (short const   )0,      (short const   )4, 
        (short const   )15,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )12,      (short const   )13,      (short const   )14,      (short const   )22, 
        (short const   )20,      (short const   )0,      (short const   )21,      (short const   )24, 
        (short const   )0,      (short const   )5,      (short const   )6,      (short const   )0, 
        (short const   )19,      (short const   )23,      (short const   )0,      (short const   )0};
#line 318 "aux-item-def-parse.y"
static short const   yydefgoto[9]  = 
#line 318
  {      (short const   )1,      (short const   )3,      (short const   )4,      (short const   )15, 
        (short const   )16,      (short const   )17,      (short const   )8,      (short const   )13, 
        (short const   )32};
#line 323 "aux-item-def-parse.y"
static short const   aid_pact[40]  = 
#line 323
  {      (short const   )-32768,      (short const   )10,      (short const   )-15,      (short const   )-32768, 
        (short const   )-7,      (short const   )6,      (short const   )-32768,      (short const   )-5, 
        (short const   )-1,      (short const   )1,      (short const   )-32768,      (short const   )-2, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-19, 
        (short const   )-32768,      (short const   )9,      (short const   )2,      (short const   )15, 
        (short const   )1,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )7,      (short const   )-32768,      (short const   )-32768, 
        (short const   )4,      (short const   )-32768,      (short const   )-32768,      (short const   )5, 
        (short const   )-32768,      (short const   )-32768,      (short const   )28,      (short const   )-32768};
#line 331 "aux-item-def-parse.y"
static short const   yypgoto[9]  = 
#line 331
  {      (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )11,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768};
#line 340 "aux-item-def-parse.y"
static short const   aid_yytable[32]  = 
#line 340
  {      (short const   )10,      (short const   )19,      (short const   )20,      (short const   )5, 
        (short const   )11,      (short const   )27,      (short const   )28,      (short const   )29, 
        (short const   )30,      (short const   )6,      (short const   )38,      (short const   )7, 
        (short const   )14,      (short const   )2,      (short const   )9,      (short const   )31, 
        (short const   )12,      (short const   )21,      (short const   )22,      (short const   )23, 
        (short const   )18,      (short const   )24,      (short const   )33,      (short const   )25, 
        (short const   )26,      (short const   )37,      (short const   )35,      (short const   )36, 
        (short const   )39,      (short const   )0,      (short const   )0,      (short const   )34};
#line 348 "aux-item-def-parse.y"
static short const   aid_yycheck[32]  = 
#line 348
  {      (short const   )1,      (short const   )20,      (short const   )21,      (short const   )18, 
        (short const   )5,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )16,      (short const   )0,      (short const   )5, 
        (short const   )11,      (short const   )3,      (short const   )19,      (short const   )13, 
        (short const   )17,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )22,      (short const   )12,      (short const   )7,      (short const   )14, 
        (short const   )15,      (short const   )20,      (short const   )19,      (short const   )23, 
        (short const   )0,      (short const   )-1,      (short const   )-1,      (short const   )20};
#line 238 "/i/bison/1.35/share/bison/bison.simple"
int aid_debug  ;
#line 294 "/i/bison/1.35/share/bison/bison.simple"
static char *yystpcpy(char *yydest , char const   *yysrc ) 
{ 
  register char *yyd ;
  register char const   *aid_s ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 303
  yyd = yydest;
#line 304
  aid_s = yysrc;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    tmp = yyd;
#line 306
    yyd ++;
#line 306
    tmp___1 = aid_s;
#line 306
    aid_s ++;
#line 306
    tmp___0 = (char )*tmp___1;
#line 306
    *tmp = tmp___0;
#line 306
    if (! ((int )tmp___0 != 0)) {
#line 306
      goto while_break;
    }
#line 307
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  return (yyd - 1);
}
}
#line 341
int aid_parse(void) ;
#line 373 "/i/bison/1.35/share/bison/bison.simple"
int aid_char  ;
#line 373 "/i/bison/1.35/share/bison/bison.simple"
yystype aid_lval  ;
#line 373 "/i/bison/1.35/share/bison/bison.simple"
int aid_nerrs  ;
#line 373 "/i/bison/1.35/share/bison/bison.simple"
yyltype aid_lloc  ;
#line 376 "/i/bison/1.35/share/bison/bison.simple"
int aid_parse(void) 
{ 
  register int aid_state ;
  register int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yychar1 ;
  short yyssa[200] ;
  short *yyss ;
  register short *yyssp ;
  yystype yyvsa[200] ;
  yystype *yyvs ;
  register yystype *yyvsp ;
  yyltype yylsa[200] ;
  yyltype *yyls ;
  yyltype *yylsp ;
  unsigned long yystacksize ;
  yystype aid_val ;
  yyltype yyloc ;
  int aid_yylen ;
  unsigned long yysize ;
  short *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  unsigned long yynewbytes___1 ;
  int yyi ;
  int found ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  String tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  String tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  String tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  String tmp___30 ;
  int tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  String tmp___34 ;
  int tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  String tmp___38 ;
  int tmp___39 ;
  char const   *tmp___40 ;
  char const   *tmp___41 ;
  String tmp___42 ;
  int tmp___43 ;
  short tmp___44 ;
  short tmp___45 ;
  short tmp___46 ;
  short tmp___47 ;
  char *tmp___48 ;
  short *yyssp1 ;
  unsigned long yysize___0 ;
  char *yymsg ;
  int yyx ;
  int yycount ;
  size_t tmp___49 ;
  size_t tmp___50 ;
  int tmp___51 ;
  size_t tmp___52 ;
  void *tmp___53 ;
  char *yyp ;
  char *tmp___54 ;
  int tmp___55 ;
  char const   *yyq ;
  char const   *tmp___56 ;
  short *yyssp1___0 ;

  {
#line 391
  yychar1 = 0;
#line 403
  yyss = yyssa;
#line 408
  yyvs = yyvsa;
#line 414
  yyls = yylsa;
#line 424
  yystacksize = 200UL;
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 438
    if (aid_debug) {
      {
#line 438
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting parse\n");
      }
    }
#line 438
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 440
  aid_state = 0;
#line 441
  yyerrstatus = 0;
#line 442
  aid_nerrs = 0;
#line 443
  aid_char = -2;
#line 450
  yyssp = yyss;
#line 451
  yyvsp = yyvs;
#line 453
  yylsp = yyls;
#line 455
  goto yysetstate;
  yynewstate: 
#line 464
  yyssp ++;
  yysetstate: 
#line 467
  *yyssp = (short )aid_state;
#line 469
  if ((unsigned long )yyssp >= (unsigned long )((yyss + yystacksize) - 1)) {
#line 472
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 508
    if (yystacksize >= 10000UL) {
#line 509
      goto yyoverflowlab;
    }
#line 510
    yystacksize *= 2UL;
#line 511
    if (yystacksize > 10000UL) {
#line 512
      yystacksize = 10000UL;
    }
    {
#line 515
    yyss1 = yyss;
#line 516
    tmp = __builtin_alloca(yystacksize * ((sizeof(short ) + sizeof(yystype )) + sizeof(yyltype )) + 2UL * (sizeof(union yyalloc ) - 1UL));
#line 516
    yyptr = (union yyalloc *)tmp;
    }
#line 518
    if (! yyptr) {
#line 519
      goto yyoverflowlab;
    }
    {
#line 520
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 520
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 520
      yyss = & yyptr->yyss;
#line 520
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 520
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 520
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 521
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 521
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 521
      yyvs = & yyptr->yyvs;
#line 521
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 521
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 521
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 523
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 523
      __builtin_memcpy((void *)(& yyptr->yyls), (void const   *)yyls, yysize * sizeof(*yyls));
#line 523
      yyls = & yyptr->yyls;
#line 523
      yynewbytes___1 = yystacksize * sizeof(*yyls) + (sizeof(union yyalloc ) - 1UL);
#line 523
      yyptr += yynewbytes___1 / sizeof(*yyptr);
      }
#line 523
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 526
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 527
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 527
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 532
    yyssp = (yyss + yysize) - 1;
#line 533
    yyvsp = (yyvs + yysize) - 1;
#line 535
    yylsp = (yyls + yysize) - 1;
    {
#line 538
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 538
      if (aid_debug) {
        {
#line 538
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack size increased to %lu\n",
                yystacksize);
        }
      }
#line 538
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 541
    if ((unsigned long )yyssp >= (unsigned long )((yyss + yystacksize) - 1)) {
#line 542
      goto yyabortlab;
    }
  }
  {
#line 545
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 545
    if (aid_debug) {
      {
#line 545
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering state %d\n",
              aid_state);
      }
    }
#line 545
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 547
  goto yybackup;
  yybackup: 
#line 561
  yyn = (int )aid_pact[aid_state];
#line 562
  if (yyn == -32768) {
#line 563
    goto yydefault;
  }
#line 570
  if (aid_char == -2) {
    {
#line 572
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 572
      if (aid_debug) {
        {
#line 572
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading a token: ");
        }
      }
#line 572
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 573
    aid_char = aid_lex();
    }
  }
#line 578
  if (aid_char <= 0) {
#line 580
    yychar1 = 0;
#line 581
    aid_char = 0;
    {
#line 583
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 583
      if (aid_debug) {
        {
#line 583
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now at end of input.\n");
        }
      }
#line 583
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
#line 587
    if ((unsigned int )aid_char <= 269U) {
#line 587
      yychar1 = (int )yytranslate[aid_char];
    } else {
#line 587
      yychar1 = 33;
    }
#line 592
    if (aid_debug) {
      {
#line 594
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Next token is %d (%s",
              aid_char, yytname[yychar1]);
#line 601
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)")\n");
      }
    }
  }
#line 606
  yyn += yychar1;
#line 607
  if (yyn < 0) {
#line 608
    goto yydefault;
  } else
#line 607
  if (yyn > 31) {
#line 608
    goto yydefault;
  } else
#line 607
  if ((int const   )aid_yycheck[yyn] != (int const   )yychar1) {
#line 608
    goto yydefault;
  }
#line 610
  yyn = (int )aid_yytable[yyn];
#line 619
  if (yyn < 0) {
#line 621
    if (yyn == -32768) {
#line 622
      goto yyerrlab;
    }
#line 623
    yyn = - yyn;
#line 624
    goto yyreduce;
  } else
#line 626
  if (yyn == 0) {
#line 627
    goto yyerrlab;
  }
#line 629
  if (yyn == 39) {
#line 630
    goto yyacceptlab;
  }
  {
#line 633
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 633
    if (aid_debug) {
      {
#line 633
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Shifting token %d (%s), ",
              aid_char, yytname[yychar1]);
      }
    }
#line 633
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 637
  if (aid_char != 0) {
#line 638
    aid_char = -2;
  }
#line 640
  yyvsp ++;
#line 640
  *yyvsp = aid_lval;
#line 642
  yylsp ++;
#line 642
  *yylsp = aid_lloc;
#line 647
  if (yyerrstatus) {
#line 648
    yyerrstatus --;
  }
#line 650
  aid_state = yyn;
#line 651
  goto yynewstate;
  yydefault: 
#line 658
  yyn = (int )yydefact[aid_state];
#line 659
  if (yyn == 0) {
#line 660
    goto yyerrlab;
  }
#line 661
  goto yyreduce;
  yyreduce: 
#line 669
  aid_yylen = (int )aid_r2[yyn];
#line 679
  aid_val = *(yyvsp + (1 - aid_yylen));
#line 684
  yyloc = *(yylsp + (1 - aid_yylen));
#line 685
  yyloc.last_line = ((yylsp - aid_yylen) + aid_yylen)->last_line;
#line 685
  yyloc.last_column = ((yylsp - aid_yylen) + aid_yylen)->last_column;
#line 691
  if (aid_debug) {
    {
#line 695
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reducing via rule %d (line %d), ",
            yyn, (int const   )yyrline[yyn]);
#line 699
    yyi = (int )yyprhs[yyn];
    }
    {
#line 699
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 699
      if (! ((int const   )yyrhs[yyi] > 0)) {
#line 699
        goto while_break___9;
      }
      {
#line 700
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              yytname[yyrhs[yyi]]);
#line 699
      yyi ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 701
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -> %s\n",
            yytname[aid_r1[yyn]]);
    }
  }
  {
#line 707
  if (yyn == 3) {
#line 707
    goto case_3;
  }
#line 206
  if (yyn == 4) {
#line 206 "aux-item-def-parse.y"
    goto case_4;
  }
#line 221
  if (yyn == 5) {
#line 221
    goto case_5;
  }
#line 230
  if (yyn == 8) {
#line 230
    goto case_8;
  }
#line 237
  if (yyn == 9) {
#line 237
    goto case_9;
  }
#line 238
  if (yyn == 10) {
#line 238
    goto case_10;
  }
#line 240
  if (yyn == 11) {
#line 240
    goto case_11;
  }
#line 241
  if (yyn == 12) {
#line 241
    goto case_12;
  }
#line 248
  if (yyn == 13) {
#line 248
    goto case_13;
  }
#line 251
  if (yyn == 14) {
#line 251
    goto case_14;
  }
#line 252
  if (yyn == 15) {
#line 252
    goto case_15;
  }
#line 253
  if (yyn == 19) {
#line 253
    goto case_19;
  }
#line 344
  if (yyn == 20) {
#line 344
    goto case_20;
  }
#line 347
  if (yyn == 21) {
#line 347
    goto case_21;
  }
#line 348
  if (yyn == 22) {
#line 348
    goto case_22;
  }
#line 349
  if (yyn == 23) {
#line 349
    goto case_23;
  }
#line 350
  if (yyn == 24) {
#line 350
    goto case_24;
  }
#line 705 "/i/bison/1.35/share/bison/bison.simple"
  goto switch_break;
  case_3: /* CIL Label */ 
#line 199
  if (def.tag != 0UL) {
    {
#line 201 "aux-item-def-parse.y"
    aux_item_definition_add(& def);
    }
  }
#line 203
  def = empty_aux_item_definition;
#line 205
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 209
  def.tag = (yyvsp + -5)->num;
#line 210
  def.name = s_crea_c_str((String const   )(yyvsp + -3)->str);
  }
#line 211
  if (buglevel) {
    {
#line 213
    kom_log("Parsing definition of aux-item %ld (%s)\n", def.tag, def.name);
    }
  }
  {
#line 216
  s_clear(& (yyvsp + -3)->str);
#line 217
  (yyvsp + -3)->str = (String )EMPTY_STRING;
#line 218
  aid_lval.str = (String )EMPTY_STRING;
  }
#line 220
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 222
  def.tag = (yyvsp + -6)->num;
#line 223
  def.name = s_crea_c_str((String const   )(yyvsp + -4)->str);
#line 224
  def.disabled = (Bool )1;
#line 225
  s_clear(& (yyvsp + -4)->str);
#line 226
  (yyvsp + -4)->str = (String )EMPTY_STRING;
#line 227
  aid_lval.str = (String )EMPTY_STRING;
  }
#line 229
  goto switch_break;
  case_8: /* CIL Label */ 
#line 235
  def.texts = (Bool )1;
#line 235
  def.text_a = (short )(yyvsp + -1)->num;
#line 236
  goto switch_break;
  case_9: /* CIL Label */ 
#line 236
  def.confs = (Bool )1;
#line 236
  def.conf_a = (short )(yyvsp + -1)->num;
#line 237
  goto switch_break;
  case_10: /* CIL Label */ 
#line 237
  def.letterboxes = (Bool )1;
#line 238
  def.conf_a = (short )(yyvsp + -1)->num;
#line 239
  goto switch_break;
  case_11: /* CIL Label */ 
#line 239
  def.system = (Bool )1;
#line 240
  goto switch_break;
  case_12: /* CIL Label */ 
#line 242
  def.texts = (Bool )1;
#line 242
  def.text_a = (short )(yyvsp + -1)->num;
#line 243
  def.confs = (Bool )1;
#line 243
  def.conf_a = (short )(yyvsp + -1)->num;
#line 244
  def.letterboxes = (Bool )1;
#line 245
  def.system = (Bool )1;
#line 247
  goto switch_break;
  case_13: /* CIL Label */ 
#line 249
  aid_val.num = (yyvsp + -1)->num | 1UL;
#line 250
  goto switch_break;
  case_14: /* CIL Label */ 
#line 250
  aid_val.num = (yyvsp + -1)->num | 2UL;
#line 251
  goto switch_break;
  case_15: /* CIL Label */ 
#line 251
  aid_val.num = 0UL;
#line 252
  goto switch_break;
  case_19: /* CIL Label */ 
#line 261
  found = 0;
#line 263
  if (found) {
#line 263
    tmp___1 = 1;
  } else {
    {
#line 263
    tmp___0 = aux_item_def_check_assign("author-only", (yyvsp + -3)->str, (void *)(& def.author_only),
                                        258, & (yyvsp + -1)->value, (yylsp + -1)->first_line);
    }
#line 263
    if (tmp___0) {
#line 263
      tmp___1 = 1;
    } else {
#line 263
      tmp___1 = 0;
    }
  }
#line 263
  found = tmp___1;
#line 265
  if (found) {
#line 265
    tmp___3 = 1;
  } else {
    {
#line 265
    tmp___2 = aux_item_def_check_assign("supervisor-only", (yyvsp + -3)->str, (void *)(& def.supervisor_only),
                                        258, & (yyvsp + -1)->value, (yylsp + -1)->first_line);
    }
#line 265
    if (tmp___2) {
#line 265
      tmp___3 = 1;
    } else {
#line 265
      tmp___3 = 0;
    }
  }
#line 265
  found = tmp___3;
#line 267
  if (found) {
#line 267
    tmp___5 = 1;
  } else {
    {
#line 267
    tmp___4 = aux_item_def_check_assign("system-only", (yyvsp + -3)->str, (void *)(& def.system_only),
                                        258, & (yyvsp + -1)->value, (yylsp + -1)->first_line);
    }
#line 267
    if (tmp___4) {
#line 267
      tmp___5 = 1;
    } else {
#line 267
      tmp___5 = 0;
    }
  }
#line 267
  found = tmp___5;
#line 269
  if (found) {
#line 269
    tmp___7 = 1;
  } else {
    {
#line 269
    tmp___6 = aux_item_def_check_assign("inherit-limit", (yyvsp + -3)->str, (void *)(& def.inherit_limit),
                                        257, & (yyvsp + -1)->value, (yylsp + -1)->first_line);
    }
#line 269
    if (tmp___6) {
#line 269
      tmp___7 = 1;
    } else {
#line 269
      tmp___7 = 0;
    }
  }
#line 269
  found = tmp___7;
#line 271
  if (found) {
#line 271
    tmp___9 = 1;
  } else {
    {
#line 271
    tmp___8 = aux_item_def_check_assign("unique", (yyvsp + -3)->str, (void *)(& def.one_per_person),
                                        258, & (yyvsp + -1)->value, (yylsp + -1)->first_line);
    }
#line 271
    if (tmp___8) {
#line 271
      tmp___9 = 1;
    } else {
#line 271
      tmp___9 = 0;
    }
  }
#line 271
  found = tmp___9;
#line 273
  if (found) {
#line 273
    tmp___11 = 1;
  } else {
    {
#line 273
    tmp___10 = aux_item_def_check_assign("unique-data", (yyvsp + -3)->str, (void *)(& def.unique_data),
                                         258, & (yyvsp + -1)->value, (yylsp + -1)->first_line);
    }
#line 273
    if (tmp___10) {
#line 273
      tmp___11 = 1;
    } else {
#line 273
      tmp___11 = 0;
    }
  }
#line 273
  found = tmp___11;
#line 275
  if (found) {
#line 275
    tmp___13 = 1;
  } else {
    {
#line 275
    tmp___12 = aux_item_def_check_assign("permanent", (yyvsp + -3)->str, (void *)(& def.may_not_delete),
                                         258, & (yyvsp + -1)->value, (yylsp + -1)->first_line);
    }
#line 275
    if (tmp___12) {
#line 275
      tmp___13 = 1;
    } else {
#line 275
      tmp___13 = 0;
    }
  }
#line 275
  found = tmp___13;
#line 277
  if (found) {
#line 277
    tmp___15 = 1;
  } else {
    {
#line 277
    tmp___14 = aux_item_def_check_assign("owner-delete", (yyvsp + -3)->str, (void *)(& def.owner_delete),
                                         258, & (yyvsp + -1)->value, (yylsp + -1)->first_line);
    }
#line 277
    if (tmp___14) {
#line 277
      tmp___15 = 1;
    } else {
#line 277
      tmp___15 = 0;
    }
  }
  {
#line 277
  found = tmp___15;
#line 279
  tmp___18 = s_fcrea_str("inherit");
#line 279
  tmp___19 = s_strcmp(tmp___18, (yyvsp + -3)->str);
  }
#line 279
  if (! tmp___19) {
#line 279
    found = 1;
#line 279
    if ((yyvsp + -1)->value.type != 258) {
      {
#line 279
      aux_item_def_error_line = (yylsp + -1)->first_line;
#line 279
      tmp___16 = aux_item_def_typename((yyvsp + -1)->value.type);
#line 279
      tmp___17 = aux_item_def_typename(258);
#line 279
      aid_error("invalid type: expected %s, got %s", tmp___17, tmp___16);
      }
    }
#line 279
    if ((yyvsp + -1)->value.val.num) {
#line 279
      def.set_flags.inherit = 1U;
    } else {
#line 279
      def.clear_flags.inherit = 1U;
    }
  }
  {
#line 280
  tmp___22 = s_fcrea_str("secret");
#line 280
  tmp___23 = s_strcmp(tmp___22, (yyvsp + -3)->str);
  }
#line 280
  if (! tmp___23) {
#line 280
    found = 1;
#line 280
    if ((yyvsp + -1)->value.type != 258) {
      {
#line 280
      aux_item_def_error_line = (yylsp + -1)->first_line;
#line 280
      tmp___20 = aux_item_def_typename((yyvsp + -1)->value.type);
#line 280
      tmp___21 = aux_item_def_typename(258);
#line 280
      aid_error("invalid type: expected %s, got %s", tmp___21, tmp___20);
      }
    }
#line 280
    if ((yyvsp + -1)->value.val.num) {
#line 280
      def.set_flags.secret = 1U;
    } else {
#line 280
      def.clear_flags.secret = 1U;
    }
  }
  {
#line 281
  tmp___26 = s_fcrea_str("hide-creator");
#line 281
  tmp___27 = s_strcmp(tmp___26, (yyvsp + -3)->str);
  }
#line 281
  if (! tmp___27) {
#line 281
    found = 1;
#line 281
    if ((yyvsp + -1)->value.type != 258) {
      {
#line 281
      aux_item_def_error_line = (yylsp + -1)->first_line;
#line 281
      tmp___24 = aux_item_def_typename((yyvsp + -1)->value.type);
#line 281
      tmp___25 = aux_item_def_typename(258);
#line 281
      aid_error("invalid type: expected %s, got %s", tmp___25, tmp___24);
      }
    }
#line 281
    if ((yyvsp + -1)->value.val.num) {
#line 281
      def.set_flags.hide_creator = 1U;
    } else {
#line 281
      def.clear_flags.hide_creator = 1U;
    }
  }
  {
#line 283
  tmp___30 = s_fcrea_str("dont-garb");
#line 283
  tmp___31 = s_strcmp(tmp___30, (yyvsp + -3)->str);
  }
#line 283
  if (! tmp___31) {
#line 283
    found = 1;
#line 283
    if ((yyvsp + -1)->value.type != 258) {
      {
#line 283
      aux_item_def_error_line = (yylsp + -1)->first_line;
#line 283
      tmp___28 = aux_item_def_typename((yyvsp + -1)->value.type);
#line 283
      tmp___29 = aux_item_def_typename(258);
#line 283
      aid_error("invalid type: expected %s, got %s", tmp___29, tmp___28);
      }
    }
#line 283
    if ((yyvsp + -1)->value.val.num) {
#line 283
      def.set_flags.dont_garb = 1U;
    } else {
#line 283
      def.clear_flags.dont_garb = 1U;
    }
  }
  {
#line 284
  tmp___34 = s_fcrea_str("reserved-2");
#line 284
  tmp___35 = s_strcmp(tmp___34, (yyvsp + -3)->str);
  }
#line 284
  if (! tmp___35) {
#line 284
    found = 1;
#line 284
    if ((yyvsp + -1)->value.type != 258) {
      {
#line 284
      aux_item_def_error_line = (yylsp + -1)->first_line;
#line 284
      tmp___32 = aux_item_def_typename((yyvsp + -1)->value.type);
#line 284
      tmp___33 = aux_item_def_typename(258);
#line 284
      aid_error("invalid type: expected %s, got %s", tmp___33, tmp___32);
      }
    }
#line 284
    if ((yyvsp + -1)->value.val.num) {
#line 284
      def.set_flags.reserved3 = 1U;
    } else {
#line 284
      def.clear_flags.reserved3 = 1U;
    }
  }
  {
#line 285
  tmp___38 = s_fcrea_str("reserved-3");
#line 285
  tmp___39 = s_strcmp(tmp___38, (yyvsp + -3)->str);
  }
#line 285
  if (! tmp___39) {
#line 285
    found = 1;
#line 285
    if ((yyvsp + -1)->value.type != 258) {
      {
#line 285
      aux_item_def_error_line = (yylsp + -1)->first_line;
#line 285
      tmp___36 = aux_item_def_typename((yyvsp + -1)->value.type);
#line 285
      tmp___37 = aux_item_def_typename(258);
#line 285
      aid_error("invalid type: expected %s, got %s", tmp___37, tmp___36);
      }
    }
#line 285
    if ((yyvsp + -1)->value.val.num) {
#line 285
      def.set_flags.reserved4 = 1U;
    } else {
#line 285
      def.clear_flags.reserved4 = 1U;
    }
  }
  {
#line 286
  tmp___42 = s_fcrea_str("reserved-4");
#line 286
  tmp___43 = s_strcmp(tmp___42, (yyvsp + -3)->str);
  }
#line 286
  if (! tmp___43) {
#line 286
    found = 1;
#line 286
    if ((yyvsp + -1)->value.type != 258) {
      {
#line 286
      aux_item_def_error_line = (yylsp + -1)->first_line;
#line 286
      tmp___40 = aux_item_def_typename((yyvsp + -1)->value.type);
#line 286
      tmp___41 = aux_item_def_typename(258);
#line 286
      aid_error("invalid type: expected %s, got %s", tmp___41, tmp___40);
      }
    }
#line 286
    if ((yyvsp + -1)->value.val.num) {
#line 286
      def.set_flags.reserved5 = 1U;
    } else {
#line 286
      def.clear_flags.reserved5 = 1U;
    }
  }
#line 289
  if (found) {
#line 289
    found = 1;
  } else {
    {
#line 289
    tmp___44 = aux_item_def_check_validate("validate", (yyvsp + -3)->str, (yyvsp + -1)->value.type,
                                           (yyvsp + -1)->value.val.str, & def);
#line 289
    found = (int )tmp___44;
    }
  }
#line 296
  if (found) {
#line 296
    found = 1;
  } else {
    {
#line 296
    tmp___45 = aux_item_def_check_trigger("delete-trigger", (yyvsp + -1)->value.type,
                                          (yyvsp + -3)->str, (yyvsp + -1)->value.val.str,
                                          & def.num_delete_triggers, & def.delete_triggers);
#line 296
    found = (int )tmp___45;
    }
  }
#line 305
  if (found) {
#line 305
    found = 1;
  } else {
    {
#line 305
    tmp___46 = aux_item_def_check_trigger("undelete-trigger", (yyvsp + -1)->value.type,
                                          (yyvsp + -3)->str, (yyvsp + -1)->value.val.str,
                                          & def.num_undelete_triggers, & def.undelete_triggers);
#line 305
    found = (int )tmp___46;
    }
  }
#line 314
  if (found) {
#line 314
    found = 1;
  } else {
    {
#line 314
    tmp___47 = aux_item_def_check_trigger("add-trigger", (yyvsp + -1)->value.type,
                                          (yyvsp + -3)->str, (yyvsp + -1)->value.val.str,
                                          & def.num_add_triggers, & def.add_triggers);
#line 314
    found = (int )tmp___47;
    }
  }
#line 323
  if (found == 0) {
    {
#line 327
    tmp___48 = s_crea_c_str((String const   )(yyvsp + -3)->str);
#line 328
    aux_item_def_error_line = (yylsp + -3)->first_line;
#line 329
    aid_error("invalid field name: %s", tmp___48);
#line 330
    string_free((void *)tmp___48);
    }
  }
#line 333
  if ((yyvsp + -1)->value.type == 260) {
    {
#line 335
    s_clear(& (yyvsp + -1)->value.val.str);
#line 336
    (yyvsp + -1)->value.val.str = (String )EMPTY_STRING;
#line 337
    aid_lval.value.val.str = (String )EMPTY_STRING;
    }
  } else
#line 333
  if ((yyvsp + -1)->value.type == 259) {
    {
#line 335
    s_clear(& (yyvsp + -1)->value.val.str);
#line 336
    (yyvsp + -1)->value.val.str = (String )EMPTY_STRING;
#line 337
    aid_lval.value.val.str = (String )EMPTY_STRING;
    }
  }
  {
#line 339
  s_clear(& (yyvsp + -3)->str);
#line 340
  (yyvsp + -3)->str = (String )EMPTY_STRING;
#line 341
  aid_lval.str = (String )EMPTY_STRING;
  }
#line 343
  goto switch_break;
  case_20: /* CIL Label */ 
#line 345
  aid_val.value.val.num = (yyvsp + 0)->num;
#line 345
  aid_val.value.type = 258;
#line 346
  goto switch_break;
  case_21: /* CIL Label */ 
#line 346
  aid_val.value.val.str = (yyvsp + 0)->str;
#line 346
  aid_val.value.type = 260;
#line 347
  goto switch_break;
  case_22: /* CIL Label */ 
#line 347
  aid_val.value.val.num = (yyvsp + 0)->num;
#line 347
  aid_val.value.type = 257;
#line 348
  goto switch_break;
  case_23: /* CIL Label */ 
#line 348
  aid_val.value.val.str = (yyvsp + -2)->str;
#line 348
  aid_val.value.type = 259;
#line 349
  goto switch_break;
  case_24: /* CIL Label */ 
#line 349
  goto yyerrlab1;
#line 350
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 707 "/i/bison/1.35/share/bison/bison.simple"
  yyvsp -= aid_yylen;
#line 708
  yyssp -= aid_yylen;
#line 710
  yylsp -= aid_yylen;
#line 714
  if (aid_debug) {
    {
#line 716
    yyssp1 = yyss - 1;
#line 717
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"state stack now");
    }
    {
#line 718
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 718
      if (! ((unsigned long )yyssp1 != (unsigned long )yyssp)) {
#line 718
        goto while_break___10;
      }
      {
#line 719
      yyssp1 ++;
#line 719
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
              (int )*yyssp1);
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 720
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 724
  yyvsp ++;
#line 724
  *yyvsp = aid_val;
#line 726
  yylsp ++;
#line 726
  *yylsp = yyloc;
#line 733
  yyn = (int )aid_r1[yyn];
#line 735
  aid_state = (int )((int const   )yypgoto[yyn - 24] + (int const   )*yyssp);
#line 736
  if (aid_state >= 0) {
#line 736
    if (aid_state <= 31) {
#line 736
      if ((int const   )aid_yycheck[aid_state] == (int const   )*yyssp) {
#line 737
        aid_state = (int )aid_yytable[aid_state];
      } else {
#line 739
        aid_state = (int )yydefgoto[yyn - 24];
      }
    } else {
#line 739
      aid_state = (int )yydefgoto[yyn - 24];
    }
  } else {
#line 739
    aid_state = (int )yydefgoto[yyn - 24];
  }
#line 741
  goto yynewstate;
  yyerrlab: 
#line 749
  if (! yyerrstatus) {
#line 751
    aid_nerrs ++;
#line 754
    yyn = (int )aid_pact[aid_state];
#line 756
    if (yyn > -32768) {
#line 756
      if (yyn < 31) {
#line 758
        yysize___0 = 0UL;
#line 762
        yycount = 0;
#line 765
        if (yyn < 0) {
#line 765
          yyx = - yyn;
        } else {
#line 765
          yyx = 0;
        }
        {
#line 765
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 765
          if (! (yyx < (int )(sizeof(yytname) / sizeof(char *)))) {
#line 765
            goto while_break___11;
          }
#line 767
          if ((int const   )aid_yycheck[yyx + yyn] == (int const   )yyx) {
            {
#line 768
            tmp___49 = strlen((char const   *)yytname[yyx]);
#line 768
            yysize___0 += tmp___49 + 15UL;
#line 768
            yycount ++;
            }
          }
#line 765
          yyx ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 769
        tmp___50 = strlen("parse error, unexpected ");
#line 769
        yysize___0 += tmp___50 + 1UL;
        }
#line 770
        if ((unsigned int )aid_char <= 269U) {
#line 770
          tmp___51 = (int const   )yytranslate[aid_char];
        } else {
#line 770
          tmp___51 = (int const   )33;
        }
        {
#line 770
        tmp___52 = strlen((char const   *)yytname[tmp___51]);
#line 770
        yysize___0 += tmp___52;
#line 771
        tmp___53 = __builtin_alloca(yysize___0);
#line 771
        yymsg = (char *)tmp___53;
        }
#line 772
        if ((unsigned long )yymsg != (unsigned long )((char *)0)) {
          {
#line 774
          tmp___54 = yystpcpy(yymsg, "parse error, unexpected ");
#line 774
          yyp = tmp___54;
          }
#line 775
          if ((unsigned int )aid_char <= 269U) {
#line 775
            tmp___55 = (int const   )yytranslate[aid_char];
          } else {
#line 775
            tmp___55 = (int const   )33;
          }
          {
#line 775
          yyp = yystpcpy(yyp, (char const   *)yytname[tmp___55]);
          }
#line 777
          if (yycount < 5) {
#line 779
            yycount = 0;
#line 780
            if (yyn < 0) {
#line 780
              yyx = - yyn;
            } else {
#line 780
              yyx = 0;
            }
            {
#line 780
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 780
              if (! (yyx < (int )(sizeof(yytname) / sizeof(char *)))) {
#line 780
                goto while_break___12;
              }
#line 783
              if ((int const   )aid_yycheck[yyx + yyn] == (int const   )yyx) {
#line 785
                if (! yycount) {
#line 785
                  tmp___56 = ", expecting ";
                } else {
#line 785
                  tmp___56 = " or ";
                }
                {
#line 785
                yyq = tmp___56;
#line 786
                yyp = yystpcpy(yyp, yyq);
#line 787
                yyp = yystpcpy(yyp, (char const   *)yytname[yyx]);
#line 788
                yycount ++;
                }
              }
#line 780
              yyx ++;
            }
            while_break___12: /* CIL Label */ ;
            }
          }
          {
#line 791
          aid_error((char const   *)yymsg);
          }
          {
#line 792
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 792
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
        } else {
          {
#line 795
          aid_error("parse error; also virtual memory exhausted");
          }
        }
      } else {
        {
#line 799
        aid_error("parse error");
        }
      }
    } else {
      {
#line 799
      aid_error("parse error");
      }
    }
  }
#line 801
  goto yyerrlab1;
  yyerrlab1: 
#line 808
  if (yyerrstatus == 3) {
#line 814
    if (aid_char == 0) {
#line 815
      goto yyabortlab;
    }
    {
#line 816
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 816
      if (aid_debug) {
        {
#line 816
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Discarding token %d (%s).\n",
                aid_char, yytname[yychar1]);
        }
      }
#line 816
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 818
    aid_char = -2;
  }
#line 824
  yyerrstatus = 3;
#line 826
  goto yyerrhandle;
  yyerrdefault: 
#line 850
  if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 851
    goto yyabortlab;
  }
#line 852
  yyvsp --;
#line 853
  yyssp --;
#line 853
  aid_state = (int )*yyssp;
#line 855
  yylsp --;
#line 859
  if (aid_debug) {
    {
#line 861
    yyssp1___0 = yyss - 1;
#line 862
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: state stack now");
    }
    {
#line 863
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 863
      if (! ((unsigned long )yyssp1___0 != (unsigned long )yyssp)) {
#line 863
        goto while_break___15;
      }
      {
#line 864
      yyssp1___0 ++;
#line 864
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
              (int )*yyssp1___0);
      }
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 865
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  yyerrhandle: 
#line 873
  yyn = (int )aid_pact[aid_state];
#line 874
  if (yyn == -32768) {
#line 875
    goto yyerrdefault;
  }
#line 877
  yyn ++;
#line 878
  if (yyn < 0) {
#line 879
    goto yyerrdefault;
  } else
#line 878
  if (yyn > 31) {
#line 879
    goto yyerrdefault;
  } else
#line 878
  if ((int const   )aid_yycheck[yyn] != 1) {
#line 879
    goto yyerrdefault;
  }
#line 881
  yyn = (int )aid_yytable[yyn];
#line 882
  if (yyn < 0) {
#line 884
    if (yyn == -32768) {
#line 885
      goto yyerrdefault;
    }
#line 886
    yyn = - yyn;
#line 887
    goto yyreduce;
  } else
#line 889
  if (yyn == 0) {
#line 890
    goto yyerrdefault;
  }
#line 892
  if (yyn == 39) {
#line 893
    goto yyacceptlab;
  }
  {
#line 895
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 895
    if (aid_debug) {
      {
#line 895
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Shifting error token, ");
      }
    }
#line 895
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 897
  yyvsp ++;
#line 897
  *yyvsp = aid_lval;
#line 899
  yylsp ++;
#line 899
  *yylsp = aid_lloc;
#line 902
  aid_state = yyn;
#line 903
  goto yynewstate;
  yyacceptlab: 
#line 910
  yyresult = 0;
#line 911
  goto yyreturn;
  yyabortlab: 
#line 917
  yyresult = 1;
#line 918
  goto yyreturn;
  yyoverflowlab: 
  {
#line 924
  aid_error("parser stack overflow");
#line 925
  yyresult = 2;
  }
  yyreturn: 
#line 930
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 931
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 931
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
  }
#line 933
  return (yyresult);
}
}
#line 354 "aux-item-def-parse.y"
FILE *yyin ;
#line 357 "aux-item-def-parse.y"
void ( /* format attribute */  aid_error)(char const   *format  , ...) 
{ 
  va_list AP ;

  {
  {
#line 361
  __builtin_va_start(AP, format);
#line 362
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %d: ",
          inputFile, aux_item_def_error_line);
#line 363
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           AP);
#line 364
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 365
  fflush(stderr);
#line 367
  errorFlag = (Bool )1;
#line 368
  __builtin_va_end(AP);
  }
#line 369
  return;
}
}
#line 383 "aux-item-def-parse.y"
static char const   *aux_item_def_typename(int type ) 
{ 


  {
  {
#line 387
  if (type == 260) {
#line 387
    goto case_260;
  }
#line 388
  if (type == 257) {
#line 388
    goto case_257;
  }
#line 389
  if (type == 258) {
#line 389
    goto case_258;
  }
#line 390
  if (type == 259) {
#line 390
    goto case_259;
  }
#line 391
  goto switch_default;
  case_260: /* CIL Label */ 
#line 387
  return ("string");
  case_257: /* CIL Label */ 
#line 388
  return ("number");
  case_258: /* CIL Label */ 
#line 389
  return ("boolean");
  case_259: /* CIL Label */ 
#line 390
  return ("identifier");
  switch_default: /* CIL Label */ 
#line 392
  return ("unknown");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 396 "aux-item-def-parse.y"
static int aux_item_def_check_assign(char const   *id , String field , void *data ,
                                     int type , struct aux_item_def_value_type *val ,
                                     int lineno ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  String tmp___1 ;
  int tmp___2 ;

  {
  {
#line 403
  tmp___1 = s_fcrea_str(id);
#line 403
  tmp___2 = s_strcmp(tmp___1, field);
  }
#line 403
  if (tmp___2) {
#line 434
    return (0);
  } else {
#line 405
    if (type != val->type) {
      {
#line 407
      aux_item_def_error_line = lineno;
#line 408
      tmp = aux_item_def_typename(val->type);
#line 408
      tmp___0 = aux_item_def_typename(type);
#line 408
      aid_error("invalid type: expected %s, got %s", tmp___0, tmp);
      }
#line 411
      return (0);
    } else
#line 413
    if (type == 260) {
      {
#line 415
      *((char **)data) = s_crea_c_str((String const   )val->val.str);
      }
    } else
#line 417
    if (type == 257) {
#line 419
      *((unsigned long *)data) = val->val.num;
    } else
#line 421
    if (type == 258) {
#line 423
      if (val->val.num) {
#line 423
        *((Bool *)data) = (Bool )1;
      } else {
#line 423
        *((Bool *)data) = (Bool )0;
      }
    } else {
      {
#line 427
      restart_kom("Internal error: bad type in aux-item definition assignment (can\'t happen.)\n");
      }
    }
#line 430
    return (1);
  }
}
}
#line 438 "aux-item-def-parse.y"
static short aux_item_def_check_trigger(char const   *check_name , int type , String trigger_name ,
                                        String function_name , unsigned long *counter ,
                                        Aux_item_trigger **triggers ) 
{ 
  void (*trigger)(Aux_item_trigger_data * ) ;
  char *tmp_string ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  String tmp___2 ;
  int tmp___3 ;

  {
  {
#line 448
  tmp___2 = s_fcrea_str(check_name);
#line 448
  tmp___3 = s_strcmp(tmp___2, trigger_name);
  }
#line 448
  if (tmp___3 == 0) {
#line 450
    if (type != 259) {
      {
#line 452
      tmp = aux_item_def_typename(type);
#line 452
      tmp___0 = aux_item_def_typename(259);
#line 452
      aid_error("invalid type: expected %s, got %s", tmp___0, tmp);
      }
#line 455
      return ((short)0);
    }
    {
#line 458
    tmp_string = s_crea_c_str((String const   )function_name);
#line 459
    trigger = aux_item_find_trigger((char const   *)tmp_string);
#line 460
    string_free((void *)tmp_string);
    }
#line 462
    if ((unsigned long )trigger == (unsigned long )((void *)0)) {
      {
#line 464
      aid_error("undefined function: %s", tmp_string);
      }
#line 466
      return ((short)1);
    }
    {
#line 469
    (*counter) ++;
#line 470
    tmp___1 = srealloc((void *)*triggers, *counter * sizeof(void (*)(Aux_item_trigger_data * )));
#line 470
    *triggers = (Aux_item_trigger *)tmp___1;
#line 474
    *(*(triggers + (*counter - 1UL))) = trigger;
    }
#line 476
    return ((short)1);
  }
#line 478
  return ((short)0);
}
}
#line 481 "aux-item-def-parse.y"
void parse_aux_item_definitions(char *file ) 
{ 


  {
  {
#line 483
  inputFile = file;
#line 484
  yyin = i_fopen((char const   *)file, "r");
  }
#line 485
  if ((unsigned long )yyin == (unsigned long )((void *)0)) {
    {
#line 487
    perror((char const   *)file);
#line 488
    restart_kom("Unable to open aux-item definition file\n");
    }
  }
  {
#line 491
  def = empty_aux_item_definition;
#line 492
  aid_parse();
#line 493
  i_fclose(yyin);
  }
#line 495
  if ((unsigned int )errorFlag == 1U) {
    {
#line 497
    restart_kom("Errors reading aux-item definition file\n");
    }
  }
#line 548
  return;
}
}
#line 551 "aux-item-def-parse.y"
static short aux_item_def_check_validate(char const   *check_name , String field_name ,
                                         int type , String data , Aux_item_definition *def___0 ) 
{ 
  Success (*validator)(Aux_item_validation_data * ) ;
  char *tmp_string ;
  void *tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  String tmp___4 ;
  int tmp___5 ;

  {
  {
#line 560
  tmp___4 = s_fcrea_str(check_name);
#line 560
  tmp___5 = s_strcmp(tmp___4, field_name);
  }
#line 560
  if (tmp___5 == 0) {
#line 566
    if (type == 259) {
      {
#line 568
      tmp_string = s_crea_c_str((String const   )data);
#line 569
      validator = aux_item_find_validator((char const   *)tmp_string);
#line 570
      string_free((void *)tmp_string);
      }
#line 572
      if ((unsigned long )validator == (unsigned long )((void *)0)) {
        {
#line 574
        aid_error("undefined function: %s", tmp_string);
        }
#line 576
        return ((short)1);
      }
      {
#line 579
      (def___0->num_validators) ++;
#line 580
      tmp = srealloc((void *)def___0->validators, def___0->num_validators * sizeof(*(def___0->validators)));
#line 580
      def___0->validators = (Aux_item_validator *)tmp;
#line 584
      (def___0->validators + (def___0->num_validators - 1UL))->type = (enum aux_item_validation_type )0;
#line 585
      (def___0->validators + (def___0->num_validators - 1UL))->v.fn.function = validator;
      }
#line 587
      return ((short)1);
    } else
#line 590
    if (type == 260) {
      {
#line 596
      (def___0->num_validators) ++;
#line 597
      tmp___0 = srealloc((void *)def___0->validators, def___0->num_validators * sizeof(*(def___0->validators)));
#line 597
      def___0->validators = (Aux_item_validator *)tmp___0;
#line 602
      (def___0->validators + (def___0->num_validators - 1UL))->type = (enum aux_item_validation_type )1;
#line 603
      (def___0->validators + (def___0->num_validators - 1UL))->v.re.regexp = s_crea_c_str((String const   )data);
#line 604
      (def___0->validators + (def___0->num_validators - 1UL))->v.re.cached_re_buf = (struct re_pattern_buffer *)((void *)0);
      }
    } else {
      {
#line 608
      tmp___1 = aux_item_def_typename(type);
#line 608
      tmp___2 = aux_item_def_typename(260);
#line 608
      tmp___3 = aux_item_def_typename(259);
#line 608
      aid_error("invalid type: expected %s or %s, got %s", tmp___3, tmp___2, tmp___1);
      }
#line 612
      return ((short)0);
    }
#line 615
    return ((short)1);
  }
#line 617
  return ((short)0);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 478 "./../libraries/libmisc/s-string.h"
extern Success s_fputs(FILE *stream , String const   str ) ;
#line 340 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
Fnc_descriptor const   fnc_defs[124] ;
#line 341
int const   num_fnc_defs ;
#line 217 "./../libraries/libisc-new/src/isc.h"
extern void isc_flush(struct isc_scb *scb ) ;
#line 259
extern int isc_disable(struct isc_scb *scb ) ;
#line 29 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a.h"
void prot_a_init(Connection *conn ) ;
#line 32
void prot_a_destruct(Connection *conn ) ;
#line 35
void prot_a_reply(Connection *client , Success status___0 , union result_holder *res ) ;
#line 40
void prot_a_parse_packet(Connection *client ) ;
#line 96 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.h"
void prot_a_parse_skip_whitespace(Connection *client ) ;
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a.c"
void prot_a_reply(Connection *client , Success status___0 , union result_holder *res ) 
{ 


  {
#line 75
  if ((unsigned long )status___0 == (unsigned long )OK) {
    {
#line 77
    isc_putc('=', client->isc_session);
#line 78
    isc_putul((unsigned long )client->ref_no, client->isc_session);
    }
    {
#line 82
    if ((unsigned int const   )fnc_defs[client->function_index].result == 0U) {
#line 82
      goto case_0;
    }
#line 88
    if ((unsigned int const   )fnc_defs[client->function_index].result == 1U) {
#line 88
      goto case_1;
    }
#line 92
    if ((unsigned int const   )fnc_defs[client->function_index].result == 2U) {
#line 92
      goto case_2;
    }
#line 97
    if ((unsigned int const   )fnc_defs[client->function_index].result == 3U) {
#line 97
      goto case_3;
    }
#line 102
    if ((unsigned int const   )fnc_defs[client->function_index].result == 4U) {
#line 102
      goto case_4;
    }
#line 107
    if ((unsigned int const   )fnc_defs[client->function_index].result == 5U) {
#line 107
      goto case_5;
    }
#line 112
    if ((unsigned int const   )fnc_defs[client->function_index].result == 6U) {
#line 112
      goto case_6;
    }
#line 117
    if ((unsigned int const   )fnc_defs[client->function_index].result == 7U) {
#line 117
      goto case_7;
    }
#line 122
    if ((unsigned int const   )fnc_defs[client->function_index].result == 34U) {
#line 122
      goto case_34;
    }
#line 127
    if ((unsigned int const   )fnc_defs[client->function_index].result == 8U) {
#line 127
      goto case_8;
    }
#line 132
    if ((unsigned int const   )fnc_defs[client->function_index].result == 9U) {
#line 132
      goto case_9;
    }
#line 139
    if ((unsigned int const   )fnc_defs[client->function_index].result == 10U) {
#line 139
      goto case_10;
    }
#line 144
    if ((unsigned int const   )fnc_defs[client->function_index].result == 11U) {
#line 144
      goto case_11;
    }
#line 149
    if ((unsigned int const   )fnc_defs[client->function_index].result == 33U) {
#line 149
      goto case_33;
    }
#line 154
    if ((unsigned int const   )fnc_defs[client->function_index].result == 12U) {
#line 154
      goto case_12;
    }
#line 159
    if ((unsigned int const   )fnc_defs[client->function_index].result == 13U) {
#line 159
      goto case_13;
    }
#line 165
    if ((unsigned int const   )fnc_defs[client->function_index].result == 21U) {
#line 165
      goto case_21;
    }
#line 175
    if ((unsigned int const   )fnc_defs[client->function_index].result == 35U) {
#line 175
      goto case_35;
    }
#line 180
    if ((unsigned int const   )fnc_defs[client->function_index].result == 14U) {
#line 180
      goto case_14;
    }
#line 185
    if ((unsigned int const   )fnc_defs[client->function_index].result == 15U) {
#line 185
      goto case_15;
    }
#line 190
    if ((unsigned int const   )fnc_defs[client->function_index].result == 17U) {
#line 190
      goto case_17;
    }
#line 195
    if ((unsigned int const   )fnc_defs[client->function_index].result == 16U) {
#line 195
      goto case_16;
    }
#line 201
    if ((unsigned int const   )fnc_defs[client->function_index].result == 18U) {
#line 201
      goto case_18;
    }
#line 206
    if ((unsigned int const   )fnc_defs[client->function_index].result == 19U) {
#line 206
      goto case_19;
    }
#line 211
    if ((unsigned int const   )fnc_defs[client->function_index].result == 20U) {
#line 211
      goto case_20;
    }
#line 216
    if ((unsigned int const   )fnc_defs[client->function_index].result == 22U) {
#line 216
      goto case_22;
    }
#line 221
    if ((unsigned int const   )fnc_defs[client->function_index].result == 23U) {
#line 221
      goto case_23;
    }
#line 226
    if ((unsigned int const   )fnc_defs[client->function_index].result == 24U) {
#line 226
      goto case_24;
    }
#line 231
    if ((unsigned int const   )fnc_defs[client->function_index].result == 26U) {
#line 231
      goto case_26;
    }
#line 237
    if ((unsigned int const   )fnc_defs[client->function_index].result == 25U) {
#line 237
      goto case_25;
    }
#line 243
    if ((unsigned int const   )fnc_defs[client->function_index].result == 27U) {
#line 243
      goto case_27;
    }
#line 248
    if ((unsigned int const   )fnc_defs[client->function_index].result == 28U) {
#line 248
      goto case_28;
    }
#line 253
    if ((unsigned int const   )fnc_defs[client->function_index].result == 29U) {
#line 253
      goto case_29;
    }
#line 258
    if ((unsigned int const   )fnc_defs[client->function_index].result == 30U) {
#line 258
      goto case_30;
    }
#line 263
    if ((unsigned int const   )fnc_defs[client->function_index].result == 31U) {
#line 263
      goto case_31;
    }
#line 269
    if ((unsigned int const   )fnc_defs[client->function_index].result == 32U) {
#line 269
      goto case_32;
    }
#line 275
    if ((unsigned int const   )fnc_defs[client->function_index].result == 36U) {
#line 275
      goto case_36;
    }
#line 281
    if ((unsigned int const   )fnc_defs[client->function_index].result == 37U) {
#line 281
      goto case_37;
    }
#line 286
    if ((unsigned int const   )fnc_defs[client->function_index].result == 38U) {
#line 286
      goto case_38;
    }
#line 292
    if ((unsigned int const   )fnc_defs[client->function_index].result == 39U) {
#line 292
      goto case_39;
    }
#line 297
    if ((unsigned int const   )fnc_defs[client->function_index].result == 40U) {
#line 297
      goto case_40;
    }
#line 302
    if ((unsigned int const   )fnc_defs[client->function_index].result == 41U) {
#line 302
      goto case_41;
    }
#line 307
    if ((unsigned int const   )fnc_defs[client->function_index].result == 42U) {
#line 307
      goto case_42;
    }
#line 80
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 83
    isc_putc(' ', client->isc_session);
#line 84
    isc_putul(res->number, client->isc_session);
    }
#line 85
    if (buglevel > 0) {
      {
#line 85
      printf((char const   */* __restrict  */)"=%lu\n", res->number);
      }
    }
#line 86
    goto switch_break;
    case_1: /* CIL Label */ 
#line 89
    if (buglevel > 0) {
      {
#line 89
      printf((char const   */* __restrict  */)"=Success\n");
      }
    }
#line 90
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 93
    prot_a_output_person(client, & res->person);
    }
#line 94
    if (buglevel > 0) {
      {
#line 94
      printf((char const   */* __restrict  */)"={Person struct not listed}\n");
      }
    }
#line 95
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 98
    prot_a_output_membership(client, (Membership const   *)(& res->membership));
    }
#line 99
    if (buglevel > 0) {
      {
#line 99
      printf((char const   */* __restrict  */)"={Membership struct not listed}\n");
      }
    }
#line 100
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 103
    prot_a_output_membership_old(client, (Membership const   *)(& res->membership_old));
    }
#line 104
    if (buglevel > 0) {
      {
#line 104
      printf((char const   */* __restrict  */)"={Membership_old struct not listed}\n");
      }
    }
#line 105
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 108
    prot_a_output_membership_10(client, (Membership const   *)(& res->membership_10));
    }
#line 109
    if (buglevel > 0) {
      {
#line 109
      printf((char const   */* __restrict  */)"={Membership_10 struct not listed}\n");
      }
    }
#line 110
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 113
    prot_a_output_conf_list(client, res->conf_list);
    }
#line 114
    if (buglevel > 0) {
      {
#line 114
      printf((char const   */* __restrict  */)"={Conf_list not listed}\n");
      }
    }
#line 115
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 118
    prot_a_output_conf_no_list(client, res->conf_no_list);
    }
#line 119
    if (buglevel > 0) {
      {
#line 119
      printf((char const   */* __restrict  */)"={Conf_no_list not listed}\n");
      }
    }
#line 120
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 123
    prot_a_output_conference(client, & res->conference);
    }
#line 124
    if (buglevel > 0) {
      {
#line 124
      printf((char const   */* __restrict  */)"={Conference struct not listed}\n");
      }
    }
#line 125
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 128
    prot_a_output_conference_old(client, & res->conference);
    }
#line 129
    if (buglevel > 0) {
      {
#line 129
      printf((char const   */* __restrict  */)"={Conference (old) struct not listed}\n");
      }
    }
#line 130
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 133
    prot_a_output_string(client, res->string);
    }
#line 134
    if (buglevel > 0) {
      {
#line 134
      printf((char const   */* __restrict  */)"={%luH", res->string.len);
      }
    }
#line 135
    if (buglevel > 0) {
      {
#line 135
      s_fputs(stdout, (String const   )res->string);
      }
    }
#line 136
    if (buglevel > 0) {
      {
#line 136
      printf((char const   */* __restrict  */)"}\n");
      }
    }
#line 137
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 140
    prot_a_output_mark_list(client, res->mark_list);
    }
#line 141
    if (buglevel > 0) {
      {
#line 141
      printf((char const   */* __restrict  */)"={Mark_list not listed}\n");
      }
    }
#line 142
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 145
    prot_a_output_text_stat_old(client, & res->text_stat);
    }
#line 146
    if (buglevel > 0) {
      {
#line 146
      printf((char const   */* __restrict  */)"={Text_stat (old) struct not listed}\n");
      }
    }
#line 147
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 150
    prot_a_output_text_stat(client, & res->text_stat);
    }
#line 151
    if (buglevel > 0) {
      {
#line 151
      printf((char const   */* __restrict  */)"={Text_stat struct not listed}\n");
      }
    }
#line 152
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 155
    prot_a_output_who_info_list(client, res->who_info_list);
    }
#line 156
    if (buglevel > 0) {
      {
#line 156
      printf((char const   */* __restrict  */)"={Who_info_list not listed}\n");
      }
    }
#line 157
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 160
    prot_a_output_who_info_list_old(client, res->who_info_list_old);
    }
#line 162
    if (buglevel > 0) {
      {
#line 162
      printf((char const   */* __restrict  */)"={Old who_info_list not listed}\n");
      }
    }
#line 163
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 166
    prot_a_output_session_info(client, & res->session_info);
#line 171
    s_clear(& res->session_info.username);
    }
#line 172
    if (buglevel > 0) {
      {
#line 172
      printf((char const   */* __restrict  */)"={Session_info not listed}\n");
      }
    }
#line 173
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 176
    prot_a_output_info(client, & res->info);
    }
#line 177
    if (buglevel > 0) {
      {
#line 177
      printf((char const   */* __restrict  */)"={Who_info struct not listed}\n");
      }
    }
#line 178
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 181
    prot_a_output_info_old(client, & res->info);
    }
#line 182
    if (buglevel > 0) {
      {
#line 182
      printf((char const   */* __restrict  */)"={Who_info struct not listed}\n");
      }
    }
#line 183
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 186
    prot_a_output_membership_list(client, res->membership_list);
    }
#line 187
    if (buglevel > 0) {
      {
#line 187
      printf((char const   */* __restrict  */)"={Membership_list not listed}\n");
      }
    }
#line 188
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 191
    prot_a_output_membership_list_10(client, res->membership_list_10);
    }
#line 192
    if (buglevel > 0) {
      {
#line 192
      printf((char const   */* __restrict  */)"={Membership_list_10 not listed}\n");
      }
    }
#line 193
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 196
    prot_a_output_membership_list_old(client, res->membership_list_old);
    }
#line 198
    if (buglevel > 0) {
      {
#line 198
      printf((char const   */* __restrict  */)"={Membership_list_old not listed}\n");
      }
    }
#line 199
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 202
    prot_a_output_member_list(client, res->member_list);
    }
#line 203
    if (buglevel > 0) {
      {
#line 203
      printf((char const   */* __restrict  */)"={Member_list not listed}\n");
      }
    }
#line 204
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 207
    prot_a_output_member_list_old(client, res->member_list);
    }
#line 208
    if (buglevel > 0) {
      {
#line 208
      printf((char const   */* __restrict  */)"={Member_list not listed}\n");
      }
    }
#line 209
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 212
    prot_a_output_time(client, res->time_date);
    }
#line 213
    if (buglevel > 0) {
      {
#line 213
      printf((char const   */* __restrict  */)"=(time_t)%lu\n", (unsigned long )res->time_date);
      }
    }
#line 214
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 217
    prot_a_output_session_no(client, res->session_no);
    }
#line 218
    if (buglevel > 0) {
      {
#line 218
      printf((char const   */* __restrict  */)"=(Session_no)%lu\n", res->session_no);
      }
    }
#line 219
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 222
    prot_a_output_text_no(client, res->text_no);
    }
#line 223
    if (buglevel > 0) {
      {
#line 223
      printf((char const   */* __restrict  */)"=(Text_no)%lu\n", res->text_no);
      }
    }
#line 224
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 227
    prot_a_output_conf_no(client, res->conf_no);
    }
#line 228
    if (buglevel > 0) {
      {
#line 228
      printf((char const   */* __restrict  */)"=(Conf_no)%lu\n", (unsigned long )res->conf_no);
      }
    }
#line 229
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 232
    prot_a_output_who_info_ident_list(client, res->who_info_ident_list);
    }
#line 234
    if (buglevel > 0) {
      {
#line 234
      printf((char const   */* __restrict  */)"={Who_info_ident_list not listed}\n");
      }
    }
#line 235
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 238
    prot_a_output_session_info_ident(client, & res->session_info_ident);
    }
#line 240
    if (buglevel > 0) {
      {
#line 240
      printf((char const   */* __restrict  */)"={Session_info_ident not listed}\n");
      }
    }
#line 241
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 244
    prot_a_output_conf_z_info_list(client, res->conf_z_info_list);
    }
#line 245
    if (buglevel > 0) {
      {
#line 245
      printf((char const   */* __restrict  */)"={Conf_z_info_list not listed}\n");
      }
    }
#line 246
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 249
    prot_a_output_version_info(client, & res->version_info);
    }
#line 250
    if (buglevel > 0) {
      {
#line 250
      printf((char const   */* __restrict  */)"={Version_info not listed}\n");
      }
    }
#line 251
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 254
    prot_a_output_uconference(client, & res->uconference);
    }
#line 255
    if (buglevel > 0) {
      {
#line 255
      printf((char const   */* __restrict  */)"={UConference not listed}\n");
      }
    }
#line 256
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 259
    prot_a_output_num_list(client, & res->num_list);
    }
#line 260
    if (buglevel > 0) {
      {
#line 260
      printf((char const   */* __restrict  */)"={num_list not listed}\n");
      }
    }
#line 261
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 264
    prot_a_output_dynamic_session_info_list(client, & res->dynamic_session_info_list);
    }
#line 266
    if (buglevel > 0) {
      {
#line 266
      printf((char const   */* __restrict  */)"={dynamic_session_list not listed}\n");
      }
    }
#line 267
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 270
    prot_a_output_static_session_info(client, & res->static_session_info);
    }
#line 272
    if (buglevel > 0) {
      {
#line 272
      printf((char const   */* __restrict  */)"={static_session_info not listed");
      }
    }
#line 273
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 276
    prot_a_output_l2g_iterator_as_text_list(client, & res->l2g_iterator_as_text_list);
    }
#line 278
    if (buglevel > 0) {
      {
#line 278
      printf((char const   */* __restrict  */)"={l2g_iterator_as_text_list not listed");
      }
    }
#line 279
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 282
    prot_a_output_text_mapping(client, & res->text_mapping);
    }
#line 283
    if (buglevel > 0) {
      {
#line 283
      printf((char const   */* __restrict  */)"={text_mapping not listed");
      }
    }
#line 284
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 287
    prot_a_output_text_mapping_reverse(client, & res->text_mapping_reverse);
    }
#line 289
    if (buglevel > 0) {
      {
#line 289
      printf((char const   */* __restrict  */)"={text_mapping_reverse not listed");
      }
    }
#line 290
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 293
    prot_a_output_stats_description(client, & res->stats_description);
    }
#line 294
    if (buglevel > 0) {
      {
#line 294
      printf((char const   */* __restrict  */)"={stats_description not listed");
      }
    }
#line 295
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 298
    prot_a_output_stats_list(client, (Stats_list const   *)(& res->stats_list));
    }
#line 299
    if (buglevel > 0) {
      {
#line 299
      printf((char const   */* __restrict  */)"={stats_list not listed");
      }
    }
#line 300
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 303
    prot_a_output_static_server_info(client, (Static_server_info const   *)(& res->static_server_info));
    }
#line 304
    if (buglevel > 0) {
      {
#line 304
      printf((char const   */* __restrict  */)"={static_server_info not listed");
      }
    }
#line 305
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 308
    prot_a_output_scheduling_info(client, (Scheduling_info const   *)(& res->scheduling_info));
    }
#line 309
    if (buglevel > 0) {
      {
#line 309
      printf((char const   */* __restrict  */)"={scheduling_info not listed");
      }
    }
#line 310
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 319
    isc_putc('\n', client->isc_session);
    }
  } else {
    {
#line 324
    isc_putc('%', client->isc_session);
#line 325
    isc_putul((unsigned long )client->ref_no, client->isc_session);
#line 326
    prot_a_output_ul(client, (unsigned long )kom_errno);
#line 327
    prot_a_output_ul(client, err_stat);
#line 328
    isc_putc('\n', client->isc_session);
    }
#line 330
    if (buglevel > 0) {
      {
#line 330
      printf((char const   */* __restrict  */)"%%Err %d\n", (unsigned int )kom_errno);
      }
    }
  }
#line 332
  return;
}
}
#line 340 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a.c"
void prot_a_init(Connection *conn ) 
{ 


  {
  {
#line 343
  conn->parse_pos = 0;
#line 344
  conn->fnc_parse_pos = 0;
#line 345
  conn->array_parse_index = 0;
#line 346
  conn->array_parse_parsed_length = 0;
#line 347
  conn->array_parse_pos = 0;
#line 348
  conn->struct_parse_pos = 0;
#line 349
  conn->string_parse_pos = 0;
#line 350
  conn->hunt_parse_pos = 0;
#line 351
  conn->array_hunt_num = 0;
#line 352
  conn->array_hunt_depth = 0;
#line 353
  conn->ref_no = 0;
#line 354
  conn->function = (enum call_header )0;
#line 355
  conn->function_index = 0;
#line 356
  conn->num0 = 0L;
#line 357
  conn->num1 = 0L;
#line 358
  conn->num2 = 0L;
#line 359
  conn->num3 = 0L;
#line 360
  conn->c_string0 = (String )EMPTY_STRING;
#line 361
  conn->c_string1 = (String )EMPTY_STRING;
#line 362
  conn->string0 = (String )EMPTY_STRING;
#line 363
  conn->misc_info_list.misc = (Misc_info *)((void *)0);
#line 364
  conn->misc_info_list.no_of_misc = (unsigned short)0;
#line 365
  conn->aux_item_list.items = (Aux_item *)((void *)0);
#line 366
  conn->aux_item_list.length = (unsigned short)0;
#line 367
  conn->aux_item.data = (String )EMPTY_STRING;
#line 368
  conn->dummy_aux_item.data = (String )EMPTY_STRING;
#line 369
  init_priv_bits(& conn->priv_bits);
#line 370
  init_conf_type(& conn->conf_type);
  }
#line 371
  return;
}
}
#line 373 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a.c"
void prot_a_destruct(Connection *conn ) 
{ 
  int i ;

  {
  {
#line 384
  s_clear(& conn->string0);
#line 385
  s_clear(& conn->c_string0);
#line 386
  s_clear(& conn->c_string1);
#line 387
  s_clear(& conn->aux_item.data);
#line 388
  s_clear(& conn->dummy_aux_item.data);
#line 390
  i = 0;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i < (int )conn->aux_item_list.length)) {
#line 390
      goto while_break;
    }
    {
#line 391
    s_clear(& (conn->aux_item_list.items + i)->data);
#line 390
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 392
  conn->aux_item_list.length = (unsigned short)0;
#line 393
  sfree((void *)conn->aux_item_list.items);
#line 394
  conn->aux_item_list.items = (Aux_item *)((void *)0);
#line 396
  conn->misc_info_list.no_of_misc = (unsigned short)0;
#line 397
  sfree((void *)conn->misc_info_list.misc);
#line 398
  conn->misc_info_list.misc = (Misc_info *)((void *)0);
#line 400
  conn->num_list.length = 0;
#line 401
  sfree((void *)conn->num_list.data);
#line 402
  conn->num_list.data = (long *)((void *)0);
#line 404
  sfree((void *)conn->read_range_list.ranges);
#line 405
  conn->read_range_list.ranges = (struct read_range *)((void *)0);
#line 406
  conn->read_range_list.length = (unsigned short)0;
  }
#line 407
  return;
}
}
#line 413 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a.c"
static int prot_a_is_legal_fnc(enum call_header fnc ) 
{ 


  {
  {
#line 5
  if ((int )fnc == 0) {
#line 5 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-is-legal-fnc.incl"
    goto case_0;
  }
#line 6
  if ((int )fnc == 1) {
#line 6
    goto case_1;
  }
#line 7
  if ((int )fnc == 2) {
#line 7
    goto case_2;
  }
#line 8
  if ((int )fnc == 3) {
#line 8
    goto case_3;
  }
#line 9
  if ((int )fnc == 4) {
#line 9
    goto case_4;
  }
#line 10
  if ((int )fnc == 5) {
#line 10
    goto case_5;
  }
#line 11
  if ((int )fnc == 6) {
#line 11
    goto case_6;
  }
#line 12
  if ((int )fnc == 7) {
#line 12
    goto case_7;
  }
#line 13
  if ((int )fnc == 8) {
#line 13
    goto case_8;
  }
#line 14
  if ((int )fnc == 9) {
#line 14
    goto case_9;
  }
#line 15
  if ((int )fnc == 10) {
#line 15
    goto case_10;
  }
#line 16
  if ((int )fnc == 11) {
#line 16
    goto case_11;
  }
#line 17
  if ((int )fnc == 12) {
#line 17
    goto case_12;
  }
#line 18
  if ((int )fnc == 13) {
#line 18
    goto case_13;
  }
#line 19
  if ((int )fnc == 14) {
#line 19
    goto case_14;
  }
#line 20
  if ((int )fnc == 15) {
#line 20
    goto case_15;
  }
#line 21
  if ((int )fnc == 16) {
#line 21
    goto case_16;
  }
#line 22
  if ((int )fnc == 17) {
#line 22
    goto case_17;
  }
#line 23
  if ((int )fnc == 18) {
#line 23
    goto case_18;
  }
#line 24
  if ((int )fnc == 19) {
#line 24
    goto case_19;
  }
#line 25
  if ((int )fnc == 20) {
#line 25
    goto case_20;
  }
#line 26
  if ((int )fnc == 21) {
#line 26
    goto case_21;
  }
#line 27
  if ((int )fnc == 22) {
#line 27
    goto case_22;
  }
#line 28
  if ((int )fnc == 23) {
#line 28
    goto case_23;
  }
#line 29
  if ((int )fnc == 24) {
#line 29
    goto case_24;
  }
#line 30
  if ((int )fnc == 25) {
#line 30
    goto case_25;
  }
#line 31
  if ((int )fnc == 26) {
#line 31
    goto case_26;
  }
#line 32
  if ((int )fnc == 27) {
#line 32
    goto case_27;
  }
#line 33
  if ((int )fnc == 28) {
#line 33
    goto case_28;
  }
#line 34
  if ((int )fnc == 29) {
#line 34
    goto case_29;
  }
#line 35
  if ((int )fnc == 30) {
#line 35
    goto case_30;
  }
#line 36
  if ((int )fnc == 31) {
#line 36
    goto case_31;
  }
#line 37
  if ((int )fnc == 32) {
#line 37
    goto case_32;
  }
#line 38
  if ((int )fnc == 33) {
#line 38
    goto case_33;
  }
#line 39
  if ((int )fnc == 34) {
#line 39
    goto case_34;
  }
#line 40
  if ((int )fnc == 35) {
#line 40
    goto case_35;
  }
#line 41
  if ((int )fnc == 36) {
#line 41
    goto case_36;
  }
#line 42
  if ((int )fnc == 37) {
#line 42
    goto case_37;
  }
#line 43
  if ((int )fnc == 38) {
#line 43
    goto case_38;
  }
#line 44
  if ((int )fnc == 39) {
#line 44
    goto case_39;
  }
#line 45
  if ((int )fnc == 40) {
#line 45
    goto case_40;
  }
#line 46
  if ((int )fnc == 41) {
#line 46
    goto case_41;
  }
#line 47
  if ((int )fnc == 42) {
#line 47
    goto case_42;
  }
#line 48
  if ((int )fnc == 43) {
#line 48
    goto case_43;
  }
#line 49
  if ((int )fnc == 44) {
#line 49
    goto case_44;
  }
#line 50
  if ((int )fnc == 45) {
#line 50
    goto case_45;
  }
#line 51
  if ((int )fnc == 46) {
#line 51
    goto case_46;
  }
#line 52
  if ((int )fnc == 47) {
#line 52
    goto case_47;
  }
#line 53
  if ((int )fnc == 48) {
#line 53
    goto case_48;
  }
#line 54
  if ((int )fnc == 49) {
#line 54
    goto case_49;
  }
#line 55
  if ((int )fnc == 50) {
#line 55
    goto case_50;
  }
#line 56
  if ((int )fnc == 51) {
#line 56
    goto case_51;
  }
#line 57
  if ((int )fnc == 52) {
#line 57
    goto case_52;
  }
#line 58
  if ((int )fnc == 53) {
#line 58
    goto case_53;
  }
#line 59
  if ((int )fnc == 54) {
#line 59
    goto case_54;
  }
#line 60
  if ((int )fnc == 55) {
#line 60
    goto case_55;
  }
#line 61
  if ((int )fnc == 56) {
#line 61
    goto case_56;
  }
#line 62
  if ((int )fnc == 57) {
#line 62
    goto case_57;
  }
#line 63
  if ((int )fnc == 58) {
#line 63
    goto case_58;
  }
#line 64
  if ((int )fnc == 59) {
#line 64
    goto case_59;
  }
#line 65
  if ((int )fnc == 60) {
#line 65
    goto case_60;
  }
#line 66
  if ((int )fnc == 61) {
#line 66
    goto case_61;
  }
#line 67
  if ((int )fnc == 62) {
#line 67
    goto case_62;
  }
#line 68
  if ((int )fnc == 63) {
#line 68
    goto case_63;
  }
#line 69
  if ((int )fnc == 64) {
#line 69
    goto case_64;
  }
#line 70
  if ((int )fnc == 65) {
#line 70
    goto case_65;
  }
#line 71
  if ((int )fnc == 66) {
#line 71
    goto case_66;
  }
#line 72
  if ((int )fnc == 67) {
#line 72
    goto case_67;
  }
#line 73
  if ((int )fnc == 68) {
#line 73
    goto case_68;
  }
#line 74
  if ((int )fnc == 69) {
#line 74
    goto case_69;
  }
#line 75
  if ((int )fnc == 70) {
#line 75
    goto case_70;
  }
#line 76
  if ((int )fnc == 71) {
#line 76
    goto case_71;
  }
#line 77
  if ((int )fnc == 72) {
#line 77
    goto case_72;
  }
#line 78
  if ((int )fnc == 73) {
#line 78
    goto case_73;
  }
#line 79
  if ((int )fnc == 74) {
#line 79
    goto case_74;
  }
#line 80
  if ((int )fnc == 75) {
#line 80
    goto case_75;
  }
#line 81
  if ((int )fnc == 76) {
#line 81
    goto case_76;
  }
#line 82
  if ((int )fnc == 77) {
#line 82
    goto case_77;
  }
#line 83
  if ((int )fnc == 78) {
#line 83
    goto case_78;
  }
#line 84
  if ((int )fnc == 79) {
#line 84
    goto case_79;
  }
#line 85
  if ((int )fnc == 80) {
#line 85
    goto case_80;
  }
#line 86
  if ((int )fnc == 81) {
#line 86
    goto case_81;
  }
#line 87
  if ((int )fnc == 82) {
#line 87
    goto case_82;
  }
#line 88
  if ((int )fnc == 83) {
#line 88
    goto case_83;
  }
#line 89
  if ((int )fnc == 84) {
#line 89
    goto case_84;
  }
#line 90
  if ((int )fnc == 85) {
#line 90
    goto case_85;
  }
#line 91
  if ((int )fnc == 86) {
#line 91
    goto case_86;
  }
#line 92
  if ((int )fnc == 87) {
#line 92
    goto case_87;
  }
#line 93
  if ((int )fnc == 88) {
#line 93
    goto case_88;
  }
#line 94
  if ((int )fnc == 89) {
#line 94
    goto case_89;
  }
#line 95
  if ((int )fnc == 90) {
#line 95
    goto case_90;
  }
#line 96
  if ((int )fnc == 91) {
#line 96
    goto case_91;
  }
#line 97
  if ((int )fnc == 92) {
#line 97
    goto case_92;
  }
#line 98
  if ((int )fnc == 93) {
#line 98
    goto case_93;
  }
#line 99
  if ((int )fnc == 94) {
#line 99
    goto case_94;
  }
#line 100
  if ((int )fnc == 95) {
#line 100
    goto case_95;
  }
#line 101
  if ((int )fnc == 96) {
#line 101
    goto case_96;
  }
#line 102
  if ((int )fnc == 97) {
#line 102
    goto case_97;
  }
#line 103
  if ((int )fnc == 98) {
#line 103
    goto case_98;
  }
#line 104
  if ((int )fnc == 99) {
#line 104
    goto case_99;
  }
#line 105
  if ((int )fnc == 100) {
#line 105
    goto case_100;
  }
#line 106
  if ((int )fnc == 101) {
#line 106
    goto case_101;
  }
#line 107
  if ((int )fnc == 102) {
#line 107
    goto case_102;
  }
#line 108
  if ((int )fnc == 103) {
#line 108
    goto case_103;
  }
#line 109
  if ((int )fnc == 104) {
#line 109
    goto case_104;
  }
#line 110
  if ((int )fnc == 105) {
#line 110
    goto case_105;
  }
#line 111
  if ((int )fnc == 106) {
#line 111
    goto case_106;
  }
#line 112
  if ((int )fnc == 107) {
#line 112
    goto case_107;
  }
#line 113
  if ((int )fnc == 108) {
#line 113
    goto case_108;
  }
#line 114
  if ((int )fnc == 109) {
#line 114
    goto case_109;
  }
#line 115
  if ((int )fnc == 110) {
#line 115
    goto case_110;
  }
#line 116
  if ((int )fnc == 111) {
#line 116
    goto case_111;
  }
#line 117
  if ((int )fnc == 112) {
#line 117
    goto case_112;
  }
#line 118
  if ((int )fnc == 113) {
#line 118
    goto case_113;
  }
#line 119
  if ((int )fnc == 114) {
#line 119
    goto case_114;
  }
#line 120
  if ((int )fnc == 115) {
#line 120
    goto case_115;
  }
#line 121
  if ((int )fnc == 116) {
#line 121
    goto case_116;
  }
#line 122
  if ((int )fnc == 117) {
#line 122
    goto case_117;
  }
#line 123
  if ((int )fnc == 118) {
#line 123
    goto case_118;
  }
#line 124
  if ((int )fnc == 119) {
#line 124
    goto case_119;
  }
#line 125
  if ((int )fnc == 120) {
#line 125
    goto case_120;
  }
#line 126
  if ((int )fnc == 121) {
#line 126
    goto case_121;
  }
#line 127
  if ((int )fnc == 122) {
#line 127
    goto case_122;
  }
#line 139
  goto switch_default;
  case_0: /* CIL Label */ 
#line 5
  return (0);
  case_1: /* CIL Label */ 
#line 6
  return (1);
  case_2: /* CIL Label */ 
#line 7
  return (2);
  case_3: /* CIL Label */ 
#line 8
  return (3);
  case_4: /* CIL Label */ 
#line 9
  return (4);
  case_5: /* CIL Label */ 
#line 10
  return (5);
  case_6: /* CIL Label */ 
#line 11
  return (6);
  case_7: /* CIL Label */ 
#line 12
  return (7);
  case_8: /* CIL Label */ 
#line 13
  return (8);
  case_9: /* CIL Label */ 
#line 14
  return (9);
  case_10: /* CIL Label */ 
#line 15
  return (10);
  case_11: /* CIL Label */ 
#line 16
  return (11);
  case_12: /* CIL Label */ 
#line 17
  return (12);
  case_13: /* CIL Label */ 
#line 18
  return (13);
  case_14: /* CIL Label */ 
#line 19
  return (14);
  case_15: /* CIL Label */ 
#line 20
  return (15);
  case_16: /* CIL Label */ 
#line 21
  return (16);
  case_17: /* CIL Label */ 
#line 22
  return (17);
  case_18: /* CIL Label */ 
#line 23
  return (18);
  case_19: /* CIL Label */ 
#line 24
  return (19);
  case_20: /* CIL Label */ 
#line 25
  return (20);
  case_21: /* CIL Label */ 
#line 26
  return (21);
  case_22: /* CIL Label */ 
#line 27
  return (22);
  case_23: /* CIL Label */ 
#line 28
  return (23);
  case_24: /* CIL Label */ 
#line 29
  return (24);
  case_25: /* CIL Label */ 
#line 30
  return (25);
  case_26: /* CIL Label */ 
#line 31
  return (26);
  case_27: /* CIL Label */ 
#line 32
  return (27);
  case_28: /* CIL Label */ 
#line 33
  return (28);
  case_29: /* CIL Label */ 
#line 34
  return (29);
  case_30: /* CIL Label */ 
#line 35
  return (30);
  case_31: /* CIL Label */ 
#line 36
  return (31);
  case_32: /* CIL Label */ 
#line 37
  return (32);
  case_33: /* CIL Label */ 
#line 38
  return (33);
  case_34: /* CIL Label */ 
#line 39
  return (34);
  case_35: /* CIL Label */ 
#line 40
  return (35);
  case_36: /* CIL Label */ 
#line 41
  return (36);
  case_37: /* CIL Label */ 
#line 42
  return (37);
  case_38: /* CIL Label */ 
#line 43
  return (38);
  case_39: /* CIL Label */ 
#line 44
  return (39);
  case_40: /* CIL Label */ 
#line 45
  return (40);
  case_41: /* CIL Label */ 
#line 46
  return (41);
  case_42: /* CIL Label */ 
#line 47
  return (42);
  case_43: /* CIL Label */ 
#line 48
  return (43);
  case_44: /* CIL Label */ 
#line 49
  return (44);
  case_45: /* CIL Label */ 
#line 50
  return (45);
  case_46: /* CIL Label */ 
#line 51
  return (46);
  case_47: /* CIL Label */ 
#line 52
  return (47);
  case_48: /* CIL Label */ 
#line 53
  return (48);
  case_49: /* CIL Label */ 
#line 54
  return (49);
  case_50: /* CIL Label */ 
#line 55
  return (50);
  case_51: /* CIL Label */ 
#line 56
  return (51);
  case_52: /* CIL Label */ 
#line 57
  return (52);
  case_53: /* CIL Label */ 
#line 58
  return (53);
  case_54: /* CIL Label */ 
#line 59
  return (54);
  case_55: /* CIL Label */ 
#line 60
  return (55);
  case_56: /* CIL Label */ 
#line 61
  return (56);
  case_57: /* CIL Label */ 
#line 62
  return (57);
  case_58: /* CIL Label */ 
#line 63
  return (58);
  case_59: /* CIL Label */ 
#line 64
  return (59);
  case_60: /* CIL Label */ 
#line 65
  return (60);
  case_61: /* CIL Label */ 
#line 66
  return (61);
  case_62: /* CIL Label */ 
#line 67
  return (62);
  case_63: /* CIL Label */ 
#line 68
  return (63);
  case_64: /* CIL Label */ 
#line 69
  return (64);
  case_65: /* CIL Label */ 
#line 70
  return (65);
  case_66: /* CIL Label */ 
#line 71
  return (66);
  case_67: /* CIL Label */ 
#line 72
  return (67);
  case_68: /* CIL Label */ 
#line 73
  return (68);
  case_69: /* CIL Label */ 
#line 74
  return (69);
  case_70: /* CIL Label */ 
#line 75
  return (70);
  case_71: /* CIL Label */ 
#line 76
  return (71);
  case_72: /* CIL Label */ 
#line 77
  return (72);
  case_73: /* CIL Label */ 
#line 78
  return (73);
  case_74: /* CIL Label */ 
#line 79
  return (74);
  case_75: /* CIL Label */ 
#line 80
  return (75);
  case_76: /* CIL Label */ 
#line 81
  return (76);
  case_77: /* CIL Label */ 
#line 82
  return (77);
  case_78: /* CIL Label */ 
#line 83
  return (78);
  case_79: /* CIL Label */ 
#line 84
  return (79);
  case_80: /* CIL Label */ 
#line 85
  return (80);
  case_81: /* CIL Label */ 
#line 86
  return (81);
  case_82: /* CIL Label */ 
#line 87
  return (82);
  case_83: /* CIL Label */ 
#line 88
  return (83);
  case_84: /* CIL Label */ 
#line 89
  return (84);
  case_85: /* CIL Label */ 
#line 90
  return (85);
  case_86: /* CIL Label */ 
#line 91
  return (86);
  case_87: /* CIL Label */ 
#line 92
  return (87);
  case_88: /* CIL Label */ 
#line 93
  return (88);
  case_89: /* CIL Label */ 
#line 94
  return (89);
  case_90: /* CIL Label */ 
#line 95
  return (90);
  case_91: /* CIL Label */ 
#line 96
  return (91);
  case_92: /* CIL Label */ 
#line 97
  return (92);
  case_93: /* CIL Label */ 
#line 98
  return (93);
  case_94: /* CIL Label */ 
#line 99
  return (94);
  case_95: /* CIL Label */ 
#line 100
  return (95);
  case_96: /* CIL Label */ 
#line 101
  return (96);
  case_97: /* CIL Label */ 
#line 102
  return (97);
  case_98: /* CIL Label */ 
#line 103
  return (98);
  case_99: /* CIL Label */ 
#line 104
  return (99);
  case_100: /* CIL Label */ 
#line 105
  return (100);
  case_101: /* CIL Label */ 
#line 106
  return (101);
  case_102: /* CIL Label */ 
#line 107
  return (102);
  case_103: /* CIL Label */ 
#line 108
  return (103);
  case_104: /* CIL Label */ 
#line 109
  return (104);
  case_105: /* CIL Label */ 
#line 110
  return (105);
  case_106: /* CIL Label */ 
#line 111
  return (106);
  case_107: /* CIL Label */ 
#line 112
  return (107);
  case_108: /* CIL Label */ 
#line 113
  return (108);
  case_109: /* CIL Label */ 
#line 114
  return (109);
  case_110: /* CIL Label */ 
#line 115
  return (110);
  case_111: /* CIL Label */ 
#line 116
  return (111);
  case_112: /* CIL Label */ 
#line 117
  return (112);
  case_113: /* CIL Label */ 
#line 118
  return (113);
  case_114: /* CIL Label */ 
#line 119
  return (114);
  case_115: /* CIL Label */ 
#line 120
  return (115);
  case_116: /* CIL Label */ 
#line 121
  return (116);
  case_117: /* CIL Label */ 
#line 122
  return (117);
  case_118: /* CIL Label */ 
#line 123
  return (118);
  case_119: /* CIL Label */ 
#line 124
  return (119);
  case_120: /* CIL Label */ 
#line 125
  return (120);
  case_121: /* CIL Label */ 
#line 126
  return (121);
  case_122: /* CIL Label */ 
#line 127
  return (122);
  switch_default: /* CIL Label */ 
#line 140
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 420 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a.c"
void prot_a_parse_packet(Connection *client ) 
{ 
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 423
  if ((unsigned int )client->username_valid == 0U) {
    {
#line 427
    prot_a_parse_string(client, & client->c_string0, param.username_len);
#line 430
    client->username = client->c_string0;
#line 431
    client->c_string0 = (String )EMPTY_STRING;
#line 434
    client->username_valid = (Bool )1;
#line 435
    isc_puts("LysKOM\n", client->isc_session);
#line 436
    isc_flush(client->isc_session);
#line 437
    isc_set_acceptable_idle(client->isc_session, param.login_timeout);
    }
#line 439
    if (buglevel > 0) {
      {
#line 439
      printf((char const   */* __restrict  */)"[Handshake with client %lu completed]\n",
             client->session_no);
      }
    }
  }
#line 442
  if ((unsigned int )client->dns_done == 0U) {
    {
#line 444
    prot_a_parse_skip_whitespace(client);
#line 445
    isc_disable(client->isc_session);
#line 446
    client->blocked_by_dns = (Bool )1;
    }
#line 447
    return;
  }
  {
#line 452
  if (client->parse_pos == 0) {
#line 452
    goto case_0;
  }
#line 462
  if (client->parse_pos == 1) {
#line 462
    goto case_1;
  }
#line 471
  if (client->parse_pos == 2) {
#line 471
    goto case_2;
  }
#line 479
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 457
  prot_a_parse_skip_whitespace(client);
#line 459
  tmp = prot_a_parse_long(client);
#line 459
  client->ref_no = (int )tmp;
#line 460
  client->parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 463
  tmp___0 = prot_a_parse_long(client);
#line 463
  client->function = (enum call_header )((int )tmp___0);
#line 464
  tmp___1 = prot_a_is_legal_fnc(client->function);
#line 464
  client->function_index = tmp___1;
  }
#line 464
  if (tmp___1 == -1) {
#line 466
    client->function = (enum call_header )-1;
#line 467
    client->function_index = (int )(num_fnc_defs - 1);
  }
#line 469
  client->parse_pos = 2;
  case_2: /* CIL Label */ 
  {
#line 473
  (*(fnc_defs[client->function_index].parser))(client);
#line 476
  prot_a_parse_skip_whitespace(client);
  }
  switch_default: /* CIL Label */ 
#line 480
  client->parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 26 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/rfc931.h"
char const   *get_real_username(struct isc_scb *qazwsxedcscb  __attribute__((__unused__)) ,
                                char *qazwsxedchostname  __attribute__((__unused__)) ) ;
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/rfc931.c"
char const   *get_real_username(struct isc_scb *qazwsxedcscb  __attribute__((__unused__)) ,
                                char *qazwsxedchostname  __attribute__((__unused__)) ) 
{ 


  {
#line 104
  return ("unknown");
}
}
#line 56 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
static void async_header(Connection *fp , int no_of_tokens , enum async fnc ) 
{ 


  {
  {
#line 61
  isc_putc(':', fp->isc_session);
#line 62
  isc_putul((unsigned long )no_of_tokens, fp->isc_session);
#line 63
  prot_a_output_ul(fp, (unsigned long )fnc);
  }
#line 64
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
static void async_trailer(Connection *fp ) 
{ 


  {
  {
#line 72
  isc_putc('\n', fp->isc_session);
#line 76
  isc_flush(fp->isc_session);
  }
#line 77
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_new_text_old(Connection *cptr , Text_no text_no , Text_stat *text_s ) 
{ 


  {
#line 85
  if ((unsigned int )cptr->want_async[0] == 0U) {
#line 85
    return;
  }
  {
#line 86
  async_header(cptr, 16, (enum async )0);
#line 87
  prot_a_output_ul(cptr, text_no);
#line 88
  prot_a_output_text_stat_old(cptr, text_s);
#line 89
  async_trailer(cptr);
  }
#line 90
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_new_text(Connection *cptr , Text_no text_no , Text_stat *text_s ) 
{ 


  {
#line 97
  if ((unsigned int )cptr->want_async[15] == 0U) {
#line 97
    return;
  }
  {
#line 98
  async_header(cptr, 18, (enum async )15);
#line 99
  prot_a_output_ul(cptr, text_no);
#line 100
  prot_a_output_text_stat(cptr, text_s);
#line 101
  async_trailer(cptr);
  }
#line 102
  return;
}
}
#line 105 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_i_am_on(Connection *cptr , Who_info info ) 
{ 


  {
#line 109
  if ((unsigned int )cptr->want_async[6] == 0U) {
#line 109
    return;
  }
  {
#line 110
  async_header(cptr, 5, (enum async )6);
#line 111
  prot_a_output_who_info(cptr, & info);
#line 112
  async_trailer(cptr);
  }
#line 113
  return;
}
}
#line 115 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_logout(Connection *cptr , Pers_no pers_no , Session_no session_no ) 
{ 


  {
#line 120
  if ((unsigned int )cptr->want_async[13] == 0U) {
#line 120
    return;
  }
  {
#line 121
  async_header(cptr, 2, (enum async )13);
#line 122
  prot_a_output_ul(cptr, (unsigned long )pers_no);
#line 123
  prot_a_output_ul(cptr, session_no);
#line 124
  async_trailer(cptr);
  }
#line 125
  return;
}
}
#line 127 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_new_name(Connection *cptr , Conf_no conf_no , String old_name ,
                           String new_name ) 
{ 


  {
#line 133
  if ((unsigned int )cptr->want_async[5] == 0U) {
#line 133
    return;
  }
  {
#line 134
  async_header(cptr, 3, (enum async )5);
#line 135
  prot_a_output_ul(cptr, (unsigned long )conf_no);
#line 136
  prot_a_output_string(cptr, old_name);
#line 137
  prot_a_output_string(cptr, new_name);
#line 138
  async_trailer(cptr);
  }
#line 139
  return;
}
}
#line 141 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_sync_db(Connection *cptr ) 
{ 


  {
#line 144
  if ((unsigned int )cptr->want_async[7] == 0U) {
#line 144
    return;
  }
  {
#line 145
  async_header(cptr, 0, (enum async )7);
#line 146
  async_trailer(cptr);
  }
#line 147
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_forced_leave_conf(Connection *cptr , Conf_no conf_no ) 
{ 


  {
#line 153
  if ((unsigned int )cptr->want_async[8] == 0U) {
#line 153
    return;
  }
  {
#line 154
  async_header(cptr, 1, (enum async )8);
#line 155
  prot_a_output_ul(cptr, (unsigned long )conf_no);
#line 156
  async_trailer(cptr);
  }
#line 157
  return;
}
}
#line 159 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_login(Connection *cptr , Pers_no pers_no , int session_no ) 
{ 


  {
#line 164
  if ((unsigned int )cptr->want_async[9] == 0U) {
#line 164
    return;
  }
  {
#line 165
  async_header(cptr, 2, (enum async )9);
#line 166
  prot_a_output_ul(cptr, (unsigned long )pers_no);
#line 167
  prot_a_output_ul(cptr, (unsigned long )session_no);
#line 168
  async_trailer(cptr);
  }
#line 169
  return;
}
}
#line 171 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_rejected_connection(Connection *cptr ) 
{ 


  {
#line 174
  if ((unsigned int )cptr->want_async[11] == 0U) {
#line 174
    return;
  }
  {
#line 175
  async_header(cptr, 0, (enum async )11);
#line 176
  async_trailer(cptr);
  }
#line 177
  return;
}
}
#line 179 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_send_message(Connection *cptr , Conf_no recipient , Pers_no sender ,
                               String message ) 
{ 


  {
#line 185
  if ((unsigned int )cptr->want_async[12] == 0U) {
#line 185
    return;
  }
  {
#line 186
  async_header(cptr, 3, (enum async )12);
#line 187
  prot_a_output_ul(cptr, (unsigned long )recipient);
#line 188
  prot_a_output_ul(cptr, (unsigned long )sender);
#line 189
  prot_a_output_string(cptr, message);
#line 190
  async_trailer(cptr);
  }
#line 191
  return;
}
}
#line 193 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_deleted_text(Connection *cptr , Text_no text_no , Text_stat *text_s ) 
{ 


  {
#line 198
  if ((unsigned int )cptr->want_async[14] == 0U) {
#line 198
    return;
  }
  {
#line 199
  async_header(cptr, 18, (enum async )14);
#line 200
  prot_a_output_ul(cptr, text_no);
#line 201
  prot_a_output_text_stat(cptr, text_s);
#line 202
  async_trailer(cptr);
  }
#line 203
  return;
}
}
#line 205 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_new_recipient(Connection *cptr , Text_no text_no , Conf_no conf_no ,
                                enum info_type type ) 
{ 


  {
#line 211
  if ((unsigned int )cptr->want_async[16] == 0U) {
#line 211
    return;
  }
  {
#line 212
  async_header(cptr, 3, (enum async )16);
#line 213
  prot_a_output_ul(cptr, text_no);
#line 214
  prot_a_output_ul(cptr, (unsigned long )conf_no);
#line 215
  prot_a_output_ul(cptr, (unsigned long )type);
#line 216
  async_trailer(cptr);
  }
#line 217
  return;
}
}
#line 219 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_sub_recipient(Connection *cptr , Text_no text_no , Conf_no conf_no ,
                                enum info_type type ) 
{ 


  {
#line 225
  if ((unsigned int )cptr->want_async[17] == 0U) {
#line 225
    return;
  }
  {
#line 226
  async_header(cptr, 3, (enum async )17);
#line 227
  prot_a_output_ul(cptr, text_no);
#line 228
  prot_a_output_ul(cptr, (unsigned long )conf_no);
#line 229
  prot_a_output_ul(cptr, (unsigned long )type);
#line 230
  async_trailer(cptr);
  }
#line 231
  return;
}
}
#line 233 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_new_membership(Connection *cptr , Pers_no pers_no , Conf_no conf_no ) 
{ 


  {
#line 238
  if ((unsigned int )cptr->want_async[18] == 0U) {
#line 238
    return;
  }
  {
#line 239
  async_header(cptr, 2, (enum async )18);
#line 240
  prot_a_output_ul(cptr, (unsigned long )pers_no);
#line 241
  prot_a_output_ul(cptr, (unsigned long )conf_no);
#line 242
  async_trailer(cptr);
  }
#line 243
  return;
}
}
#line 245 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_new_user_area(Connection *cptr , Pers_no pers_no , Text_no old_user_area ,
                                Text_no new_user_area ) 
{ 


  {
#line 251
  if ((unsigned int )cptr->want_async[19] == 0U) {
#line 251
    return;
  }
  {
#line 252
  async_header(cptr, 3, (enum async )19);
#line 253
  prot_a_output_ul(cptr, (unsigned long )pers_no);
#line 254
  prot_a_output_ul(cptr, old_user_area);
#line 255
  prot_a_output_ul(cptr, new_user_area);
#line 256
  async_trailer(cptr);
  }
#line 257
  return;
}
}
#line 259 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_new_presentation(Connection *cptr , Conf_no conf_no , Text_no old_presentation ,
                                   Text_no new_presentation ) 
{ 


  {
#line 265
  if ((unsigned int )cptr->want_async[20] == 0U) {
#line 265
    return;
  }
  {
#line 266
  async_header(cptr, 3, (enum async )20);
#line 267
  prot_a_output_ul(cptr, (unsigned long )conf_no);
#line 268
  prot_a_output_ul(cptr, old_presentation);
#line 269
  prot_a_output_ul(cptr, new_presentation);
#line 270
  async_trailer(cptr);
  }
#line 271
  return;
}
}
#line 273 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_new_motd(Connection *cptr , Conf_no conf_no , Text_no old_motd ,
                           Text_no new_motd ) 
{ 


  {
#line 279
  if ((unsigned int )cptr->want_async[21] == 0U) {
#line 279
    return;
  }
  {
#line 280
  async_header(cptr, 3, (enum async )21);
#line 281
  prot_a_output_ul(cptr, (unsigned long )conf_no);
#line 282
  prot_a_output_ul(cptr, old_motd);
#line 283
  prot_a_output_ul(cptr, new_motd);
#line 284
  async_trailer(cptr);
  }
#line 285
  return;
}
}
#line 287 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-send-async.c"
void prot_a_async_text_aux_changed(Connection *cptr , Text_no text_no , Aux_item_list *aux_list ,
                                   unsigned long highest_old_aux ) 
{ 
  unsigned short added ;
  unsigned short deleted ;
  unsigned short ix ;

  {
#line 293
  added = (unsigned short)0;
#line 294
  deleted = (unsigned short)0;
#line 297
  if ((unsigned int )cptr->want_async[22] == 0U) {
#line 297
    return;
  }
#line 299
  ix = (unsigned short)0;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((int )ix < (int )aux_list->length)) {
#line 299
      goto while_break;
    }
#line 301
    if ((aux_list->items + ix)->flags.deleted) {
#line 302
      deleted = (unsigned short )((int )deleted + 1);
    }
#line 303
    if ((aux_list->items + ix)->aux_no > highest_old_aux) {
#line 304
      added = (unsigned short )((int )added + 1);
    }
#line 299
    ix = (unsigned short )((int )ix + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  if ((int )deleted + (int )added == 0) {
#line 308
    return;
  }
  {
#line 310
  async_header(cptr, 5, (enum async )22);
#line 312
  prot_a_output_ul(cptr, text_no);
#line 314
  prot_a_output_ul(cptr, (unsigned long )deleted);
  }
#line 315
  if ((int )deleted == 0) {
    {
#line 316
    isc_puts(" *", cptr->isc_session);
    }
  } else {
    {
#line 319
    isc_puts(" {", cptr->isc_session);
#line 320
    ix = (unsigned short)0;
    }
    {
#line 320
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 320
      if (! ((int )ix < (int )aux_list->length)) {
#line 320
        goto while_break___0;
      }
#line 321
      if ((aux_list->items + ix)->flags.deleted) {
        {
#line 322
        prot_a_output_aux_item(cptr, aux_list->items + ix);
        }
      }
#line 320
      ix = (unsigned short )((int )ix + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 323
    isc_puts(" }", cptr->isc_session);
    }
  }
  {
#line 326
  prot_a_output_ul(cptr, (unsigned long )added);
  }
#line 327
  if ((int )added == 0) {
    {
#line 328
    isc_puts(" *", cptr->isc_session);
    }
  } else {
    {
#line 331
    isc_puts(" {", cptr->isc_session);
#line 332
    ix = (unsigned short)0;
    }
    {
#line 332
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 332
      if (! ((int )ix < (int )aux_list->length)) {
#line 332
        goto while_break___1;
      }
#line 333
      if ((aux_list->items + ix)->aux_no > highest_old_aux) {
        {
#line 334
        prot_a_output_aux_item(cptr, aux_list->items + ix);
        }
      }
#line 332
      ix = (unsigned short )((int )ix + 1);
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 335
    isc_puts(" }", cptr->isc_session);
    }
  }
  {
#line 337
  async_trailer(cptr);
  }
#line 338
  return;
}
}
#line 39 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/end-of-atomic.h"
struct timeval end_of_atomic(void) ;
#line 47 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache.h"
void cache_limit_size(void) ;
#line 55
struct timeval sync_part(void) ;
#line 64 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/disk-end-of-atomic.c"
static int limit  =    0;
#line 60 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/disk-end-of-atomic.c"
struct timeval end_of_atomic(void) 
{ 
  struct timeval timeout ;
  int parts_left ;
  int tmp ;
  Bool tmp___0 ;

  {
  {
#line 67
  free_tmp();
#line 70
  tmp = limit;
#line 70
  limit ++;
  }
#line 70
  if (tmp > 100) {
    {
#line 72
    cache_limit_size();
#line 73
    limit = 0;
    }
  }
#line 76
  parts_left = param.saved_items_per_call;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (parts_left > 0)) {
#line 76
      goto while_break;
    }
    {
#line 78
    timeout = sync_part();
#line 79
    tmp___0 = timeval_nonzero(timeout);
    }
#line 79
    if (tmp___0) {
#line 80
      return (timeout);
    }
#line 76
    parts_left --;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (param.synctimeout);
}
}
#line 47 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/isc-malloc.c"
static int no_of_allocated_blocks___3  =    0;
#line 49 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/isc-malloc.c"
void *isc_malloc_wrapper(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 52
  no_of_allocated_blocks___3 ++;
#line 53
  tmp = smalloc(size);
  }
#line 53
  return (tmp);
}
}
#line 57 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/isc-malloc.c"
void isc_free_wrapper(void *ptr ) 
{ 


  {
  {
#line 60
  no_of_allocated_blocks___3 --;
#line 61
  sfree(ptr);
  }
#line 62
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/isc-malloc.c"
void *isc_realloc_wrapper(void *ptr , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 68
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 69
    tmp = isc_malloc_wrapper(size);
    }
#line 69
    return (tmp);
  }
  {
#line 71
  tmp___0 = srealloc(ptr, size);
  }
#line 71
  return (tmp___0);
}
}
#line 75 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/isc-malloc.c"
void dump_isc_alloc_counts(FILE *stat_file ) 
{ 


  {
  {
#line 78
  fprintf((FILE */* __restrict  */)stat_file, (char const   */* __restrict  */)"---%s:\n\tAllocated blocks by isc: %d\n",
          "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/isc-malloc.c",
          no_of_allocated_blocks___3);
  }
#line 80
  return;
}
}
#line 311 "./../include/services.h"
extern Success get_collate_table(String *result ) ;
#line 635
extern Success get_info_old(Info *result ) ;
#line 638
extern Success get_info(Info *result ) ;
#line 641
extern Success get_version_info(Version_info *result ) ;
#line 649
extern Success set_info(Info *info ) ;
#line 652
extern Success modify_system_info(Number_list *items_to_delete , Aux_item_list *items_to_add ) ;
#line 656
extern Success set_motd_of_lyskom(Text_no motd ) ;
#line 668
extern Success sync_kom(void) ;
#line 674
extern Success shutdown_kom(int qazwsxedcexit_val  __attribute__((__unused__)) ) ;
#line 681
extern Success broadcast(String const   message ) ;
#line 688
extern Success send_message(Conf_no recipient , String const   message ) ;
#line 92 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/admin.c"
extern Success get_info_old(Info *result ) 
{ 


  {
#line 95
  *result = kom_info;
#line 96
  return ((Success )OK);
}
}
#line 99 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/admin.c"
extern Success get_info(Info *result ) 
{ 
  Aux_item_list filtered ;

  {
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 104
      err_stat = 0UL;
#line 104
      kom_errno = (enum kom_err )51;
#line 104
      return ((Success )FAILURE);
    }
#line 104
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  *result = kom_info;
#line 106
  filter_aux_item_list((Aux_item_list const   *)(& result->aux_item_list), & filtered,
                       (Connection const   *)active_connection);
#line 109
  result->aux_item_list = filtered;
  }
#line 110
  return ((Success )OK);
}
}
#line 113 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/admin.c"
extern Success get_version_info(Version_info *result ) 
{ 


  {
  {
#line 117
  result->protocol_version = (unsigned long )kom_version_info.protocol_version;
#line 118
  result->server_name = s_fcrea_str((char const   *)kom_version_info.server_name);
#line 119
  result->server_version = s_fcrea_str((char const   *)kom_version_info.server_version);
  }
#line 120
  return ((Success )OK);
}
}
#line 123 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/admin.c"
extern Success set_info(Info *info ) 
{ 
  Conference *conf ;
  Text_stat *text ;
  Success tmp ;

  {
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! active_connection) {
#line 130
      err_stat = 0UL;
#line 130
      kom_errno = (enum kom_err )6;
#line 130
      return ((Success )FAILURE);
    } else
#line 130
    if (! active_connection->pers_no) {
#line 130
      err_stat = 0UL;
#line 130
      kom_errno = (enum kom_err )6;
#line 130
      return ((Success )FAILURE);
    }
#line 130
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  if (active_connection) {
#line 131
    if ((int )active_connection->ena_level >= 1) {
#line 131
      if (! (active_connection->person)->privileges.admin) {
#line 133
        err_stat = 0UL;
#line 134
        kom_errno = (enum kom_err )12;
#line 135
        return ((Success )FAILURE);
      }
    } else {
#line 133
      err_stat = 0UL;
#line 134
      kom_errno = (enum kom_err )12;
#line 135
      return ((Success )FAILURE);
    }
  } else {
#line 133
    err_stat = 0UL;
#line 134
    kom_errno = (enum kom_err )12;
#line 135
    return ((Success )FAILURE);
  }
#line 140
  if (info->motd_of_lyskom != 0UL) {
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 142
      text = cached_get_text_stat(info->motd_of_lyskom);
      }
#line 142
      if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 142
        return ((Success )FAILURE);
      }
#line 142
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 145
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 145
    conf = cached_get_conf_stat(info->conf_pres_conf);
    }
#line 145
    if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 145
      return ((Success )FAILURE);
    }
#line 145
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 146
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 146
    conf = cached_get_conf_stat(info->pers_pres_conf);
    }
#line 146
    if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 146
      return ((Success )FAILURE);
    }
#line 146
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 147
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 147
    conf = cached_get_conf_stat(info->motd_conf);
    }
#line 147
    if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 147
      return ((Success )FAILURE);
    }
#line 147
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 148
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 148
    conf = cached_get_conf_stat(info->kom_news_conf);
    }
#line 148
    if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 148
      return ((Success )FAILURE);
    }
#line 148
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 150
  tmp = set_motd_of_lyskom(info->motd_of_lyskom);
  }
#line 150
  if ((unsigned long )tmp != (unsigned long )OK) {
#line 151
    return (tmp);
  }
#line 153
  kom_info.conf_pres_conf = info->conf_pres_conf;
#line 154
  kom_info.pers_pres_conf = info->pers_pres_conf;
#line 155
  kom_info.motd_conf = info->motd_conf;
#line 156
  kom_info.kom_news_conf = info->kom_news_conf;
#line 158
  return ((Success )OK);
}
}
#line 161 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/admin.c"
extern Success set_motd_of_lyskom(Text_no motd ) 
{ 
  Text_stat *old_motd ;
  Text_stat *new_motd ;

  {
#line 164
  old_motd = (Text_stat *)((void *)0);
#line 165
  new_motd = (Text_stat *)((void *)0);
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! active_connection) {
#line 167
      err_stat = 0UL;
#line 167
      kom_errno = (enum kom_err )6;
#line 167
      return ((Success )FAILURE);
    } else
#line 167
    if (! active_connection->pers_no) {
#line 167
      err_stat = 0UL;
#line 167
      kom_errno = (enum kom_err )6;
#line 167
      return ((Success )FAILURE);
    }
#line 167
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  if (active_connection) {
#line 169
    if ((int )active_connection->ena_level >= 1) {
#line 169
      if (! (active_connection->person)->privileges.admin) {
#line 171
        err_stat = 0UL;
#line 172
        kom_errno = (enum kom_err )12;
#line 173
        return ((Success )FAILURE);
      }
    } else {
#line 171
      err_stat = 0UL;
#line 172
      kom_errno = (enum kom_err )12;
#line 173
      return ((Success )FAILURE);
    }
  } else {
#line 171
    err_stat = 0UL;
#line 172
    kom_errno = (enum kom_err )12;
#line 173
    return ((Success )FAILURE);
  }
#line 178
  if (motd != 0UL) {
    {
#line 180
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 180
      new_motd = cached_get_text_stat(motd);
      }
#line 180
      if ((unsigned long )new_motd == (unsigned long )((void *)0)) {
#line 180
        return ((Success )FAILURE);
      }
#line 180
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 181
    if ((int )new_motd->no_of_marks >= param.max_marks_text) {
      {
#line 183
      kom_log("LIMIT: set_motd_of_lyskom(%lu): New motd has %d marks.\n", motd, (int )new_motd->no_of_marks);
#line 185
      err_stat = motd;
#line 186
      kom_errno = (enum kom_err )36;
      }
#line 187
      return ((Success )FAILURE);
    }
  }
#line 193
  if (kom_info.motd_of_lyskom != 0UL) {
    {
#line 193
    old_motd = cached_get_text_stat(kom_info.motd_of_lyskom);
    }
#line 193
    if ((unsigned long )old_motd != (unsigned long )((void *)0)) {
#line 196
      if ((int )old_motd->no_of_marks > 0) {
        {
#line 198
        old_motd->no_of_marks = (unsigned short )((int )old_motd->no_of_marks - 1);
#line 199
        mark_text_as_changed(kom_info.motd_of_lyskom);
        }
      } else {
        {
#line 203
        kom_log("ERROR: set_motd_of_lyskom(): Old motd not marked.\n");
        }
      }
    }
  }
#line 209
  if (motd != 0UL) {
    {
#line 211
    new_motd->no_of_marks = (unsigned short )((int )new_motd->no_of_marks + 1);
#line 212
    mark_text_as_changed(motd);
    }
  }
#line 216
  kom_info.motd_of_lyskom = motd;
#line 218
  return ((Success )OK);
}
}
#line 228 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/admin.c"
extern Success broadcast(String const   message ) 
{ 
  Success tmp ;

  {
  {
#line 231
  tmp = send_message((Conf_no )0, message);
  }
#line 231
  return (tmp);
}
}
#line 237 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/admin.c"
extern Success send_message(Conf_no recipient , String const   message ) 
{ 
  Conference *conf_c ;
  unsigned short end ;
  unsigned short ix ;
  Success retval ;
  Bool tmp ;
  int tmp___0 ;
  Success tmp___1 ;
  int tmp___2 ;

  {
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 246
      err_stat = 0UL;
#line 246
      kom_errno = (enum kom_err )51;
#line 246
      return ((Success )FAILURE);
    }
#line 246
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 247
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 247
    if (! active_connection) {
#line 247
      err_stat = 0UL;
#line 247
      kom_errno = (enum kom_err )6;
#line 247
      return ((Success )FAILURE);
    } else
#line 247
    if (! active_connection->pers_no) {
#line 247
      err_stat = 0UL;
#line 247
      kom_errno = (enum kom_err )6;
#line 247
      return ((Success )FAILURE);
    }
#line 247
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 251
  if (message.len > (String_size const   )param.broadcast_len) {
#line 253
    err_stat = (unsigned long )param.broadcast_len;
#line 254
    kom_errno = (enum kom_err )5;
#line 255
    return ((Success )FAILURE);
  }
#line 260
  if ((int )recipient != 0) {
    {
#line 262
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 262
      conf_c = cached_get_conf_stat(recipient);
      }
#line 262
      if ((unsigned long )conf_c == (unsigned long )((void *)0)) {
#line 262
        return ((Success )FAILURE);
      }
#line 262
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 266
    tmp = has_access(recipient, (Connection const   *)active_connection, (enum access )2);
    }
#line 266
    if (! tmp) {
#line 268
      err_stat = (unsigned long )recipient;
#line 269
      kom_errno = (enum kom_err )9;
#line 270
      return ((Success )FAILURE);
    }
#line 275
    end = conf_c->members.no_of_members;
#line 276
    retval = (Success )FAILURE;
#line 277
    err_stat = 0UL;
#line 278
    kom_errno = (enum kom_err )53;
#line 280
    ix = (unsigned short)0;
    {
#line 280
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 280
      if (! ((int )ix < (int )end)) {
#line 280
        goto while_break___2;
      }
#line 284
      if ((conf_c->members.members + ix)->type.passive ^ (conf_c->members.members + ix)->type.passive_message_invert) {
#line 286
        goto __Cont;
      }
#line 290
      if (active_connection) {
#line 290
        if ((int )active_connection->ena_level >= 1) {
#line 290
          if ((active_connection->person)->privileges.admin) {
#line 290
            tmp___0 = 1;
          } else {
#line 290
            tmp___0 = 0;
          }
        } else {
#line 290
          tmp___0 = 0;
        }
      } else {
#line 290
        tmp___0 = 0;
      }
      {
#line 290
      tmp___1 = async_send_group_message((conf_c->members.members + ix)->member, recipient,
                                         active_connection->pers_no, (String )message,
                                         (Bool )tmp___0);
      }
#line 290
      if ((unsigned long )tmp___1 == (unsigned long )OK) {
#line 296
        retval = (Success )OK;
      }
      __Cont: /* CIL Label */ 
#line 280
      ix = (unsigned short )((int )ix + 1);
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 304
    if (active_connection) {
#line 304
      if ((int )active_connection->ena_level >= 1) {
#line 304
        if ((active_connection->person)->privileges.admin) {
#line 304
          tmp___2 = 1;
        } else {
#line 304
          tmp___2 = 0;
        }
      } else {
#line 304
        tmp___2 = 0;
      }
    } else {
#line 304
      tmp___2 = 0;
    }
    {
#line 304
    retval = async_send_message(recipient, active_connection->pers_no, (String )message,
                                (Bool )tmp___2);
    }
  }
#line 308
  return (retval);
}
}
#line 315 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/admin.c"
extern Success sync_kom(void) 
{ 


  {
#line 318
  if (! param.permissive_sync) {
    {
#line 320
    while (1) {
      while_continue: /* CIL Label */ ;
#line 320
      if (! active_connection) {
#line 320
        err_stat = 0UL;
#line 320
        kom_errno = (enum kom_err )6;
#line 320
        return ((Success )FAILURE);
      } else
#line 320
      if (! active_connection->pers_no) {
#line 320
        err_stat = 0UL;
#line 320
        kom_errno = (enum kom_err )6;
#line 320
        return ((Success )FAILURE);
      }
#line 320
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 321
    if (active_connection) {
#line 321
      if ((int )active_connection->ena_level >= 1) {
#line 321
        if (! (active_connection->person)->privileges.admin) {
#line 323
          err_stat = 0UL;
#line 324
          kom_errno = (enum kom_err )12;
#line 325
          return ((Success )FAILURE);
        }
      } else {
#line 323
        err_stat = 0UL;
#line 324
        kom_errno = (enum kom_err )12;
#line 325
        return ((Success )FAILURE);
      }
    } else {
#line 323
      err_stat = 0UL;
#line 324
      kom_errno = (enum kom_err )12;
#line 325
      return ((Success )FAILURE);
    }
  }
  {
#line 329
  cache_sync_all();
#line 330
  dump_statistics();
  }
#line 331
  return ((Success )OK);
}
}
#line 337 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/admin.c"
extern Success shutdown_kom(int qazwsxedcexit_val  __attribute__((__unused__)) ) 
{ 
  char *name___0 ;
  char *user ;
  char *host ;

  {
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 344
      err_stat = 0UL;
#line 344
      kom_errno = (enum kom_err )51;
#line 344
      return ((Success )FAILURE);
    }
#line 344
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 345
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 345
    if (! active_connection) {
#line 345
      err_stat = 0UL;
#line 345
      kom_errno = (enum kom_err )6;
#line 345
      return ((Success )FAILURE);
    } else
#line 345
    if (! active_connection->pers_no) {
#line 345
      err_stat = 0UL;
#line 345
      kom_errno = (enum kom_err )6;
#line 345
      return ((Success )FAILURE);
    }
#line 345
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 346
  if (active_connection) {
#line 346
    if ((int )active_connection->ena_level >= 1) {
#line 346
      if (! (active_connection->person)->privileges.admin) {
#line 348
        err_stat = 0UL;
#line 349
        kom_errno = (enum kom_err )12;
#line 350
        return ((Success )FAILURE);
      }
    } else {
#line 348
      err_stat = 0UL;
#line 349
      kom_errno = (enum kom_err )12;
#line 350
      return ((Success )FAILURE);
    }
  } else {
#line 348
    err_stat = 0UL;
#line 349
    kom_errno = (enum kom_err )12;
#line 350
    return ((Success )FAILURE);
  }
  {
#line 353
  name___0 = s_crea_c_str((String const   )active_connection->username);
#line 354
  user = s_crea_c_str((String const   )active_connection->ident_user);
#line 355
  host = s_crea_c_str((String const   )(active_connection->isc_session)->remote);
#line 356
  kom_log("shutdown initiated by person %d (%s) via %s@%s.\n", (int )active_connection->pers_no,
          name___0, user, host);
#line 358
  string_free((void *)host);
#line 359
  string_free((void *)user);
#line 360
  string_free((void *)name___0);
#line 362
  go_and_die = (Bool )1;
  }
#line 363
  return ((Success )OK);
}
}
#line 366 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/admin.c"
extern Success modify_system_info(Number_list *items_to_delete , Aux_item_list *items_to_add ) 
{ 
  Success tmp ;
  Success tmp___0 ;

  {
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 370
      err_stat = 0UL;
#line 370
      kom_errno = (enum kom_err )51;
#line 370
      return ((Success )FAILURE);
    }
#line 370
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 371
    if (! active_connection) {
#line 371
      err_stat = 0UL;
#line 371
      kom_errno = (enum kom_err )6;
#line 371
      return ((Success )FAILURE);
    } else
#line 371
    if (! active_connection->pers_no) {
#line 371
      err_stat = 0UL;
#line 371
      kom_errno = (enum kom_err )6;
#line 371
      return ((Success )FAILURE);
    }
#line 371
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 373
  if (items_to_delete->length > param.max_delete_aux) {
#line 375
    kom_errno = (enum kom_err )46;
#line 376
    err_stat = (unsigned long )param.max_delete_aux;
#line 377
    return ((Success )FAILURE);
  }
#line 380
  if ((int )items_to_add->length > param.max_add_aux) {
#line 382
    kom_errno = (enum kom_err )46;
#line 383
    err_stat = (unsigned long )param.max_add_aux;
#line 384
    return ((Success )FAILURE);
  }
#line 387
  if (active_connection) {
#line 387
    if ((int )active_connection->ena_level >= 1) {
#line 387
      if (! (active_connection->person)->privileges.admin) {
#line 389
        err_stat = 0UL;
#line 390
        kom_errno = (enum kom_err )12;
#line 391
        return ((Success )FAILURE);
      }
    } else {
#line 389
      err_stat = 0UL;
#line 390
      kom_errno = (enum kom_err )12;
#line 391
      return ((Success )FAILURE);
    }
  } else {
#line 389
    err_stat = 0UL;
#line 390
    kom_errno = (enum kom_err )12;
#line 391
    return ((Success )FAILURE);
  }
  {
#line 394
  prepare_aux_item_list(items_to_add, active_connection->pers_no);
#line 396
  tmp = check_delete_aux_item_list((Number_list const   *)items_to_delete, (Aux_item_list const   *)(& kom_info.aux_item_list),
                                   (Conf_no const   )0);
  }
#line 396
  if ((unsigned long )tmp != (unsigned long )OK) {
#line 399
    return ((Success )FAILURE);
  }
  {
#line 400
  delete_aux_item_list((Number_list const   *)items_to_delete, & kom_info.aux_item_list,
                       (enum object_type )3, 0UL, (void *)0);
#line 405
  tmp___0 = system_check_add_aux_item_list(& kom_info, items_to_add, active_connection);
  }
#line 405
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 408
    undelete_aux_item_list((Number_list const   *)items_to_delete, & kom_info.aux_item_list,
                           (enum object_type )3, 0UL, (void *)0);
    }
#line 411
    return ((Success )FAILURE);
  }
  {
#line 414
  system_add_aux_item_list(& kom_info, items_to_add, active_connection->pers_no);
#line 415
  commit_aux_item_list(& kom_info.aux_item_list);
  }
#line 417
  return ((Success )OK);
}
}
#line 422 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/admin.c"
extern Success get_collate_table(String *result ) 
{ 


  {
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 425
      err_stat = 0UL;
#line 425
      kom_errno = (enum kom_err )51;
#line 425
      return ((Success )FAILURE);
    }
#line 425
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  result->string = swedish_collate_tab;
#line 427
  result->len = (String_size )256;
#line 428
  return ((Success )OK);
}
}
#line 74 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 349 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
jmp_buf parse_env ;
#line 33 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/isc-parse.h"
int parse_char(Connection *client ) ;
#line 36
int parse_nonwhite_char(Connection *client ) ;
#line 56 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/isc-parse.c"
int parse_char(Connection *client ) 
{ 
  String_size tmp ;

  {
#line 59
  if (client->unparsed.len <= client->first_to_parse) {
    {
#line 60
    longjmp((struct __jmp_buf_tag *)(parse_env), 2);
    }
  }
#line 62
  tmp = client->first_to_parse;
#line 62
  (client->first_to_parse) ++;
#line 62
  return ((int )*(client->unparsed.string + tmp));
}
}
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/isc-parse.c"
int parse_nonwhite_char(Connection *client ) 
{ 
  int c ;
  char *tmp ;

  {
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 71
    c = parse_char(client);
#line 71
    tmp = strchr(WHITESPACE, c);
    }
#line 71
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 71
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (c);
}
}
#line 156 "./../libraries/libmisc/s-string.h"
extern Success s_mem_crea_str(String *dest_string , unsigned char const   *buffer ,
                              String_size length ) ;
#line 270
extern String s_fsubstr(String const   source_string , String_size start_char , String_size end_char ) ;
#line 417
extern String s_strtok(String const   source , String_size *start_pos , String const   separators ) ;
#line 59 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.h"
extern void prot_a_parse_aux_item_flags(Connection *client , Aux_item_flags *res ) ;
#line 63
extern void prot_a_parse_aux_item(Connection *client , Aux_item *result ) ;
#line 76
extern void prot_a_parse_misc_info(Connection *client , Misc_info *result ) ;
#line 93
void prot_a_hunt_nl(Connection *client ) ;
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
static void prot_a_hunt_array_end(Connection *client ) ;
#line 77 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
static String prot_a_get_token(Connection *client ) 
{ 
  String result ;
  String_size old_first ;
  String tmp ;

  {
  {
#line 83
  old_first = client->first_to_parse;
#line 85
  tmp = s_fcrea_str(WHITESPACE);
#line 85
  result = s_strtok((String const   )client->unparsed, & client->first_to_parse, (String const   )tmp);
  }
#line 90
  if (client->first_to_parse >= client->unparsed.len) {
#line 92
    if (client->first_to_parse - old_first > 1000L) {
      {
#line 94
      isc_puts("%%Insane token length.\n", client->isc_session);
#line 95
      isc_flush(client->isc_session);
#line 96
      longjmp((struct __jmp_buf_tag *)(parse_env), 3);
      }
    }
    {
#line 98
    client->first_to_parse = old_first;
#line 99
    longjmp((struct __jmp_buf_tag *)(parse_env), 2);
    }
  }
#line 102
  return (result);
}
}
#line 106 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
long prot_a_parse_long(Connection *client ) 
{ 
  String token ;
  String_size end ;
  long res ;

  {
  {
#line 113
  token = prot_a_get_token(client);
#line 114
  res = s_strtol((String const   )token, & end);
  }
#line 115
  if (end != token.len) {
    {
#line 116
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
#line 118
  return (res);
}
}
#line 127 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
static unsigned long err_cnt  =    0UL;
#line 122 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
void prot_a_parse_num_list(Connection *client , Number_list *res , int maxlen ) 
{ 
  unsigned long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 131
  if (client->array_parse_pos == 0) {
#line 131
    goto case_0;
  }
#line 154
  if (client->array_parse_pos == 1) {
#line 154
    goto case_1;
  }
#line 164
  if (client->array_parse_pos == 2) {
#line 164
    goto case_2;
  }
#line 180
  if (client->array_parse_pos == 3) {
#line 180
    goto case_3;
  }
#line 186
  goto switch_default;
  case_0: /* CIL Label */ 
#line 134
  if (res->length != 0) {
#line 134
    goto _L;
  } else
#line 134
  if ((unsigned long )res->data != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 134
    tmp = err_cnt;
#line 134
    err_cnt ++;
#line 134
    if (tmp < 20UL) {
      {
#line 136
      kom_log("WNG: prot_a_parse_num_list(): len = %lu data = %lu\n", (unsigned long )res->length,
              (unsigned long )res->data);
#line 138
      res->length = 0;
#line 139
      res->data = (long *)((void *)0);
      }
#line 140
      if (err_cnt == 20UL) {
        {
#line 141
        kom_log("The above warning is now turned off.\n");
        }
      }
    }
  }
  {
#line 144
  tmp___0 = prot_a_parse_long(client);
#line 144
  client->array_parse_parsed_length = (int )tmp___0;
  }
#line 145
  if (client->array_parse_parsed_length < 0) {
    {
#line 147
    isc_puts("%%Insane array size.\n", client->isc_session);
#line 148
    isc_flush(client->isc_session);
#line 149
    longjmp((struct __jmp_buf_tag *)(parse_env), 3);
    }
  }
#line 152
  client->array_parse_pos = 1;
  case_1: /* CIL Label */ 
  {
#line 155
  tmp___1 = parse_nonwhite_char(client);
  }
#line 155
  if (tmp___1 != 123) {
    {
#line 156
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
#line 158
  if (maxlen + 1 > client->array_parse_parsed_length) {
#line 158
    res->length = client->array_parse_parsed_length;
  } else {
#line 158
    res->length = maxlen + 1;
  }
  {
#line 159
  tmp___2 = smalloc(sizeof(*(res->data)) * (unsigned long )res->length);
#line 159
  res->data = (long *)tmp___2;
#line 161
  client->array_parse_index = 0;
#line 162
  client->array_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (client->array_parse_index < client->array_parse_parsed_length)) {
#line 165
      goto while_break;
    }
    {
#line 167
    tmp___4 = prot_a_parse_long(client);
#line 167
    tmp___3 = tmp___4;
    }
#line 172
    if (client->array_parse_index < res->length) {
#line 174
      *(res->data + client->array_parse_index) = tmp___3;
    }
#line 176
    (client->array_parse_index) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  client->array_parse_pos = 3;
  case_3: /* CIL Label */ 
  {
#line 184
  tmp___5 = parse_nonwhite_char(client);
  }
#line 184
  if (tmp___5 != 125) {
    {
#line 185
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
  switch_default: /* CIL Label */ 
#line 187
  client->array_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 189
  return;
}
}
#line 191 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
void prot_a_parse_priv_bits(Connection *client , Priv_bits *res ) 
{ 
  String token ;
  String_size len ;

  {
  {
#line 198
  token = prot_a_get_token(client);
#line 199
  len = token.len;
  }
#line 200
  if (len <= 0L) {
    {
#line 201
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
  {
#line 203
  init_priv_bits(res);
  }
  {
#line 208
  if (len == 15L) {
#line 208
    goto case_15;
  }
#line 209
  if (len == 14L) {
#line 209
    goto case_14;
  }
#line 210
  if (len == 13L) {
#line 210
    goto case_13;
  }
#line 211
  if (len == 12L) {
#line 211
    goto case_12;
  }
#line 212
  if (len == 11L) {
#line 212
    goto case_11;
  }
#line 213
  if (len == 10L) {
#line 213
    goto case_10;
  }
#line 214
  if (len == 9L) {
#line 214
    goto case_9;
  }
#line 215
  if (len == 8L) {
#line 215
    goto case_8;
  }
#line 216
  if (len == 7L) {
#line 216
    goto case_7;
  }
#line 217
  if (len == 6L) {
#line 217
    goto case_6;
  }
#line 218
  if (len == 5L) {
#line 218
    goto case_5;
  }
#line 219
  if (len == 4L) {
#line 219
    goto case_4;
  }
#line 220
  if (len == 3L) {
#line 220
    goto case_3;
  }
#line 221
  if (len == 2L) {
#line 221
    goto case_2;
  }
#line 222
  if (len == 1L) {
#line 222
    goto case_1;
  }
#line 206
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 207
  res->flg16 = (unsigned int )((int )*(token.string + 15) != 48);
  case_15: /* CIL Label */ 
#line 208
  res->flg15 = (unsigned int )((int )*(token.string + 14) != 48);
  case_14: /* CIL Label */ 
#line 209
  res->flg14 = (unsigned int )((int )*(token.string + 13) != 48);
  case_13: /* CIL Label */ 
#line 210
  res->flg13 = (unsigned int )((int )*(token.string + 12) != 48);
  case_12: /* CIL Label */ 
#line 211
  res->flg12 = (unsigned int )((int )*(token.string + 11) != 48);
  case_11: /* CIL Label */ 
#line 212
  res->flg11 = (unsigned int )((int )*(token.string + 10) != 48);
  case_10: /* CIL Label */ 
#line 213
  res->flg10 = (unsigned int )((int )*(token.string + 9) != 48);
  case_9: /* CIL Label */ 
#line 214
  res->flg9 = (unsigned int )((int )*(token.string + 8) != 48);
  case_8: /* CIL Label */ 
#line 215
  res->flg8 = (unsigned int )((int )*(token.string + 7) != 48);
  case_7: /* CIL Label */ 
#line 216
  res->flg7 = (unsigned int )((int )*(token.string + 6) != 48);
  case_6: /* CIL Label */ 
#line 217
  res->change_name = (unsigned int )((int )*(token.string + 5) != 48);
  case_5: /* CIL Label */ 
#line 218
  res->create_conf = (unsigned int )((int )*(token.string + 4) != 48);
  case_4: /* CIL Label */ 
#line 219
  res->create_pers = (unsigned int )((int )*(token.string + 3) != 48);
  case_3: /* CIL Label */ 
#line 220
  res->statistic = (unsigned int )((int )*(token.string + 2) != 48);
  case_2: /* CIL Label */ 
#line 221
  res->admin = (unsigned int )((int )*(token.string + 1) != 48);
  case_1: /* CIL Label */ 
#line 222
  res->wheel = (unsigned int )((int )*(token.string + 0) != 48);
  switch_break: /* CIL Label */ ;
  }
#line 224
  return;
}
}
#line 226 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
void prot_a_parse_pers_flags(Connection *client , Personal_flags *res ) 
{ 
  String token ;
  String_size len ;

  {
  {
#line 233
  token = prot_a_get_token(client);
#line 234
  len = token.len;
  }
#line 235
  if (len <= 0L) {
    {
#line 236
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
  {
#line 238
  init_personal_flags(res);
  }
  {
#line 243
  if (len == 7L) {
#line 243
    goto case_7;
  }
#line 244
  if (len == 6L) {
#line 244
    goto case_6;
  }
#line 245
  if (len == 5L) {
#line 245
    goto case_5;
  }
#line 246
  if (len == 4L) {
#line 246
    goto case_4;
  }
#line 247
  if (len == 3L) {
#line 247
    goto case_3;
  }
#line 248
  if (len == 2L) {
#line 248
    goto case_2;
  }
#line 249
  if (len == 1L) {
#line 249
    goto case_1;
  }
#line 241
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 242
  res->flg8 = (unsigned int )((int )*(token.string + 7) != 48);
  case_7: /* CIL Label */ 
#line 243
  res->flg7 = (unsigned int )((int )*(token.string + 6) != 48);
  case_6: /* CIL Label */ 
#line 244
  res->flg6 = (unsigned int )((int )*(token.string + 5) != 48);
  case_5: /* CIL Label */ 
#line 245
  res->flg5 = (unsigned int )((int )*(token.string + 4) != 48);
  case_4: /* CIL Label */ 
#line 246
  res->flg4 = (unsigned int )((int )*(token.string + 3) != 48);
  case_3: /* CIL Label */ 
#line 247
  res->flg3 = (unsigned int )((int )*(token.string + 2) != 48);
  case_2: /* CIL Label */ 
#line 248
  res->flg2 = (unsigned int )((int )*(token.string + 1) != 48);
  case_1: /* CIL Label */ 
#line 249
  res->unread_is_secret = (unsigned int )((int )*(token.string + 0) != 48);
  switch_break: /* CIL Label */ ;
  }
#line 251
  return;
}
}
#line 253 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
void prot_a_parse_membership_type(Connection *client , Membership_type *res ) 
{ 
  String token ;
  String_size len ;

  {
  {
#line 260
  token = prot_a_get_token(client);
#line 261
  len = token.len;
  }
#line 262
  if (len <= 0L) {
    {
#line 263
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
  {
#line 265
  init_membership_type(res);
  }
  {
#line 270
  if (len == 7L) {
#line 270
    goto case_7;
  }
#line 271
  if (len == 6L) {
#line 271
    goto case_6;
  }
#line 272
  if (len == 5L) {
#line 272
    goto case_5;
  }
#line 273
  if (len == 4L) {
#line 273
    goto case_4;
  }
#line 274
  if (len == 3L) {
#line 274
    goto case_3;
  }
#line 275
  if (len == 2L) {
#line 275
    goto case_2;
  }
#line 276
  if (len == 1L) {
#line 276
    goto case_1;
  }
#line 268
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 269
  res->reserved5 = (unsigned int )((int )*(token.string + 7) != 48);
  case_7: /* CIL Label */ 
#line 270
  res->reserved4 = (unsigned int )((int )*(token.string + 6) != 48);
  case_6: /* CIL Label */ 
#line 271
  res->reserved3 = (unsigned int )((int )*(token.string + 5) != 48);
  case_5: /* CIL Label */ 
#line 272
  res->reserved2 = (unsigned int )((int )*(token.string + 4) != 48);
  case_4: /* CIL Label */ 
#line 273
  res->passive_message_invert = (unsigned int )((int )*(token.string + 3) != 48);
  case_3: /* CIL Label */ 
#line 274
  res->secret = (unsigned int )((int )*(token.string + 2) != 48);
  case_2: /* CIL Label */ 
#line 275
  res->passive = (unsigned int )((int )*(token.string + 1) != 48);
  case_1: /* CIL Label */ 
#line 276
  res->invitation = (unsigned int )((int )*(token.string + 0) != 48);
  switch_break: /* CIL Label */ ;
  }
#line 278
  return;
}
}
#line 280 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
void prot_a_parse_conf_type(Connection *client , Conf_type *res ) 
{ 
  String token ;
  String_size len ;

  {
  {
#line 287
  token = prot_a_get_token(client);
#line 288
  len = token.len;
  }
#line 289
  if (len <= 0L) {
    {
#line 290
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
  {
#line 292
  init_conf_type(res);
  }
  {
#line 297
  if (len == 7L) {
#line 297
    goto case_7;
  }
#line 298
  if (len == 6L) {
#line 298
    goto case_6;
  }
#line 299
  if (len == 5L) {
#line 299
    goto case_5;
  }
#line 300
  if (len == 4L) {
#line 300
    goto case_4;
  }
#line 301
  if (len == 3L) {
#line 301
    goto case_3;
  }
#line 302
  if (len == 2L) {
#line 302
    goto case_2;
  }
#line 303
  if (len == 1L) {
#line 303
    goto case_1;
  }
#line 295
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 296
  res->reserved3 = (unsigned int )((int )*(token.string + 7) != 48);
  case_7: /* CIL Label */ 
#line 297
  res->reserved2 = (unsigned int )((int )*(token.string + 6) != 48);
  case_6: /* CIL Label */ 
#line 298
  res->forbid_secret = (unsigned int )((int )*(token.string + 5) != 48);
  case_5: /* CIL Label */ 
#line 299
  res->allow_anon = (unsigned int )((int )*(token.string + 4) != 48);
  case_4: /* CIL Label */ 
#line 300
  res->letter_box = (unsigned int )((int )*(token.string + 3) != 48);
  case_3: /* CIL Label */ 
#line 301
  res->secret = (unsigned int )((int )*(token.string + 2) != 48);
  case_2: /* CIL Label */ 
#line 302
  res->original = (unsigned int )((int )*(token.string + 1) != 48);
  case_1: /* CIL Label */ 
#line 303
  res->rd_prot = (unsigned int )((int )*(token.string + 0) != 48);
  switch_break: /* CIL Label */ ;
  }
#line 305
  return;
}
}
#line 321 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
static unsigned long err_cnt___0  =    0UL;
#line 312 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
void prot_a_parse_string(Connection *client , String *result , int maxlen ) 
{ 
  String_size hptr ;
  String_size client_len ;
  String_size truncated_len ;
  String_size to_skip ;
  unsigned long tmp ;
  String tmp___0 ;

  {
  {
#line 325
  if (client->string_parse_pos == 0) {
#line 325
    goto case_0;
  }
#line 382
  if (client->string_parse_pos == 1) {
#line 382
    goto case_1;
  }
#line 413
  if (client->string_parse_pos == 2) {
#line 413
    goto case_2;
  }
#line 435
  goto switch_default;
  case_0: /* CIL Label */ 
#line 326
  if (result->len != 0L) {
#line 326
    goto _L;
  } else
#line 326
  if ((unsigned long )result->string != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 326
    tmp = err_cnt___0;
#line 326
    err_cnt___0 ++;
#line 326
    if (tmp < 20UL) {
      {
#line 328
      kom_log("%s == %lu, result->string == %lu. %s\n", "prot_a_parse_string(): result->len",
              (unsigned long )result->len, (unsigned long )result->string, "This memory will not be free()\'d.");
#line 332
      *result = (String )EMPTY_STRING;
      }
#line 333
      if (err_cnt___0 == 20UL) {
        {
#line 334
        kom_log("Won\'t log the above warning no more.\n");
        }
      }
    }
  }
  {
#line 338
  tmp___0 = s_fsubstr((String const   )client->unparsed, client->first_to_parse, 9223372036854775807L);
#line 338
  client_len = s_strtol((String const   )tmp___0, & hptr);
  }
#line 343
  if (hptr == -1L) {
    {
#line 347
    longjmp((struct __jmp_buf_tag *)(parse_env), 2);
    }
  } else
#line 343
  if (client->first_to_parse + hptr >= client->unparsed.len) {
    {
#line 347
    longjmp((struct __jmp_buf_tag *)(parse_env), 2);
    }
  }
#line 350
  if (client_len < 0L) {
    {
#line 352
    isc_puts("%%Insane string length.\n", client->isc_session);
#line 353
    isc_flush(client->isc_session);
    }
#line 354
    if (buglevel > 0) {
      {
#line 354
      printf((char const   */* __restrict  */)"%%%%Insane string length.\n");
      }
    }
    {
#line 355
    longjmp((struct __jmp_buf_tag *)(parse_env), 3);
    }
  }
#line 362
  if ((int )*(client->unparsed.string + (client->first_to_parse + hptr)) != 72) {
    {
#line 366
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  } else
#line 362
  if (hptr <= 0L) {
    {
#line 366
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
#line 369
  client->first_to_parse += 1L + hptr;
#line 370
  client->string_parse_pos = 1;
#line 380
  result->len = client_len;
  case_1: /* CIL Label */ 
#line 383
  client_len = result->len;
#line 387
  if ((String_size )(maxlen + 1) > client_len) {
#line 387
    truncated_len = client_len;
  } else {
#line 387
    truncated_len = (String_size )(maxlen + 1);
  }
#line 389
  if (client->first_to_parse + truncated_len > client->unparsed.len) {
    {
#line 392
    longjmp((struct __jmp_buf_tag *)(parse_env), 2);
    }
  }
  {
#line 395
  *result = (String )EMPTY_STRING;
#line 397
  s_mem_crea_str(result, (unsigned char const   *)(client->unparsed.string + client->first_to_parse),
                 truncated_len);
#line 408
  result->len = client_len;
#line 410
  client->first_to_parse += truncated_len;
#line 411
  client->string_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
#line 419
  client_len = result->len;
#line 420
  if ((String_size )(maxlen + 1) > client_len) {
#line 420
    truncated_len = client_len;
  } else {
#line 420
    truncated_len = (String_size )(maxlen + 1);
  }
#line 422
  if (client_len > truncated_len) {
#line 424
    if (client_len - truncated_len > client->unparsed.len - client->first_to_parse) {
#line 424
      to_skip = client->unparsed.len - client->first_to_parse;
    } else {
#line 424
      to_skip = client_len - truncated_len;
    }
#line 426
    client_len -= to_skip;
#line 427
    client->first_to_parse += to_skip;
  }
#line 430
  result->len = client_len;
#line 432
  if (client_len > truncated_len) {
    {
#line 433
    longjmp((struct __jmp_buf_tag *)(parse_env), 2);
    }
  }
  switch_default: /* CIL Label */ 
#line 436
  client->string_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 438
  return;
}
}
#line 440 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
extern void prot_a_parse_aux_item_flags(Connection *client , Aux_item_flags *res ) 
{ 
  String token ;
  String_size len ;

  {
  {
#line 447
  token = prot_a_get_token(client);
#line 448
  len = token.len;
  }
#line 449
  if (len <= 0L) {
    {
#line 450
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
  {
#line 452
  init_aux_item_flags(res);
  }
  {
#line 457
  if (len == 7L) {
#line 457
    goto case_7;
  }
#line 458
  if (len == 6L) {
#line 458
    goto case_6;
  }
#line 459
  if (len == 5L) {
#line 459
    goto case_5;
  }
#line 460
  if (len == 4L) {
#line 460
    goto case_4;
  }
#line 461
  if (len == 3L) {
#line 461
    goto case_3;
  }
#line 462
  if (len == 2L) {
#line 462
    goto case_2;
  }
#line 463
  if (len == 1L) {
#line 463
    goto case_1;
  }
#line 455
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 456
  res->reserved5 = (unsigned int )((int )*(token.string + 7) != 48);
  case_7: /* CIL Label */ 
#line 457
  res->reserved4 = (unsigned int )((int )*(token.string + 6) != 48);
  case_6: /* CIL Label */ 
#line 458
  res->reserved3 = (unsigned int )((int )*(token.string + 5) != 48);
  case_5: /* CIL Label */ 
#line 459
  res->dont_garb = (unsigned int )((int )*(token.string + 4) != 48);
  case_4: /* CIL Label */ 
#line 460
  res->hide_creator = (unsigned int )((int )*(token.string + 3) != 48);
  case_3: /* CIL Label */ 
#line 461
  res->secret = (unsigned int )((int )*(token.string + 2) != 48);
  case_2: /* CIL Label */ 
#line 462
  res->inherit = (unsigned int )((int )*(token.string + 1) != 48);
  case_1: /* CIL Label */ 
#line 463
  res->deleted = (unsigned int )((int )*(token.string + 0) != 48);
  switch_break: /* CIL Label */ ;
  }
#line 465
  return;
}
}
#line 468 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
extern void prot_a_parse_aux_item(Connection *client , Aux_item *result ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  {
#line 474
  if (client->struct_parse_pos == 0) {
#line 474
    goto case_0;
  }
#line 478
  if (client->struct_parse_pos == 1) {
#line 478
    goto case_1;
  }
#line 481
  if (client->struct_parse_pos == 2) {
#line 481
    goto case_2;
  }
#line 484
  if (client->struct_parse_pos == 3) {
#line 484
    goto case_3;
  }
#line 488
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 475
  init_aux_item(result);
#line 476
  tmp = prot_a_parse_long(client);
#line 476
  result->tag = (unsigned long )tmp;
#line 477
  client->struct_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 479
  prot_a_parse_aux_item_flags(client, & result->flags);
#line 480
  client->struct_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 482
  tmp___0 = prot_a_parse_long(client);
#line 482
  result->inherit_limit = (unsigned long )tmp___0;
#line 483
  client->struct_parse_pos = 3;
  }
  case_3: /* CIL Label */ 
  {
#line 485
  prot_a_parse_string(client, & result->data, param.aux_len);
  }
  switch_default: /* CIL Label */ 
#line 489
  client->struct_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 491
  return;
}
}
#line 498 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
static unsigned long err_cnt___1  =    0UL;
#line 493 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
extern void prot_a_parse_aux_item_list(Connection *client , Aux_item_list *result ,
                                       int maxlen ) 
{ 
  int i ;
  unsigned long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 503
  if (client->array_parse_pos == 0) {
#line 503
    goto case_0;
  }
#line 525
  if (client->array_parse_pos == 1) {
#line 525
    goto case_1;
  }
#line 538
  if (client->array_parse_pos == 2) {
#line 538
    goto case_2;
  }
#line 557
  if (client->array_parse_pos == 3) {
#line 557
    goto case_3;
  }
#line 563
  goto switch_default;
  case_0: /* CIL Label */ 
#line 504
  if ((int )result->length != 0) {
#line 504
    goto _L;
  } else
#line 504
  if ((unsigned long )result->items != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 504
    tmp = err_cnt___1;
#line 504
    err_cnt___1 ++;
#line 504
    if (tmp < 20UL) {
      {
#line 506
      kom_log("WNG: prot_a_parse_aux_item_list(): len = %lu data = %lu\n", (unsigned long )result->length,
              (unsigned long )result->items);
#line 508
      result->length = (unsigned short)0;
#line 509
      result->items = (Aux_item *)((void *)0);
      }
#line 510
      if (err_cnt___1 == 20UL) {
        {
#line 511
        kom_log("The above warning is now turned off.\n");
        }
      }
    }
  }
  {
#line 514
  tmp___0 = prot_a_parse_long(client);
#line 514
  client->array_parse_parsed_length = (int )tmp___0;
  }
#line 515
  if (client->array_parse_parsed_length < 0) {
    {
#line 517
    isc_puts("%%Insane array size.\n", client->isc_session);
#line 518
    isc_flush(client->isc_session);
#line 519
    longjmp((struct __jmp_buf_tag *)(parse_env), 3);
    }
  }
#line 522
  client->array_parse_pos = 1;
  case_1: /* CIL Label */ 
  {
#line 526
  tmp___1 = parse_nonwhite_char(client);
  }
#line 526
  if (tmp___1 != 123) {
    {
#line 527
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
#line 529
  if (maxlen + 1 > client->array_parse_parsed_length) {
#line 529
    result->length = (unsigned short )client->array_parse_parsed_length;
  } else {
#line 529
    result->length = (unsigned short )(maxlen + 1);
  }
  {
#line 530
  tmp___2 = smalloc((unsigned long )result->length * sizeof(Aux_item ));
#line 530
  result->items = (Aux_item *)tmp___2;
#line 532
  i = 0;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < (int )result->length)) {
#line 532
      goto while_break;
    }
#line 534
    (result->items + i)->data = (String )EMPTY_STRING;
#line 532
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  client->array_parse_index = 0;
#line 537
  client->array_parse_pos = 2;
  case_2: /* CIL Label */ 
  {
#line 539
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 539
    if (! (client->array_parse_index < client->array_parse_parsed_length)) {
#line 539
      goto while_break___0;
    }
#line 543
    if (client->array_parse_index < (int )result->length) {
      {
#line 545
      prot_a_parse_aux_item(client, result->items + client->array_parse_index);
      }
    } else {
      {
#line 551
      prot_a_parse_aux_item(client, & client->dummy_aux_item);
#line 552
      clear_aux_item(& client->dummy_aux_item);
      }
    }
#line 554
    (client->array_parse_index) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 556
  client->array_parse_pos = 3;
  case_3: /* CIL Label */ 
  {
#line 561
  tmp___3 = parse_nonwhite_char(client);
  }
#line 561
  if (tmp___3 != 125) {
    {
#line 562
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
  switch_default: /* CIL Label */ 
#line 564
  client->array_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 566
  return;
}
}
#line 573 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
static unsigned long err_cnt___2  =    0UL;
#line 568 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
extern void prot_a_parse_misc_info_list(Connection *client , Misc_info_list *result ,
                                        int maxlen ) 
{ 
  int i ;
  Misc_info dummy_misc_info ;
  unsigned long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 579
  if (client->array_parse_pos == 0) {
#line 579
    goto case_0;
  }
#line 603
  if (client->array_parse_pos == 1) {
#line 603
    goto case_1;
  }
#line 616
  if (client->array_parse_pos == 2) {
#line 616
    goto case_2;
  }
#line 642
  if (client->array_parse_pos == 3) {
#line 642
    goto case_3;
  }
#line 648
  goto switch_default;
  case_0: /* CIL Label */ 
#line 580
  if ((int )result->no_of_misc != 0) {
#line 580
    goto _L;
  } else
#line 580
  if ((unsigned long )result->misc != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 580
    tmp = err_cnt___2;
#line 580
    err_cnt___2 ++;
#line 580
    if (tmp < 20UL) {
      {
#line 582
      kom_log("WNG: prot_a_parse_misc_info_list(): len = %lu data = %lu\n", (unsigned long )result->no_of_misc,
              (unsigned long )result->misc);
#line 586
      result->no_of_misc = (unsigned short)0;
#line 587
      result->misc = (Misc_info *)((void *)0);
      }
#line 588
      if (err_cnt___2 == 20UL) {
        {
#line 589
        kom_log("The above warning is now turned off.\n");
        }
      }
    }
  }
  {
#line 592
  tmp___0 = prot_a_parse_long(client);
#line 592
  client->array_parse_parsed_length = (int )tmp___0;
  }
#line 593
  if (client->array_parse_parsed_length < 0) {
    {
#line 595
    isc_puts("%%Insane array size.\n", client->isc_session);
#line 596
    isc_flush(client->isc_session);
#line 597
    longjmp((struct __jmp_buf_tag *)(parse_env), 3);
    }
  }
#line 600
  client->array_parse_pos = 1;
  case_1: /* CIL Label */ 
  {
#line 604
  tmp___1 = parse_nonwhite_char(client);
  }
#line 604
  if (tmp___1 != 123) {
    {
#line 605
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
#line 607
  if (maxlen + 1 > client->array_parse_parsed_length) {
#line 607
    result->no_of_misc = (unsigned short )client->array_parse_parsed_length;
  } else {
#line 607
    result->no_of_misc = (unsigned short )(maxlen + 1);
  }
  {
#line 608
  tmp___2 = smalloc((unsigned long )result->no_of_misc * sizeof(Misc_info ));
#line 608
  result->misc = (Misc_info *)tmp___2;
#line 610
  i = 0;
  }
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! (i < (int )result->no_of_misc)) {
#line 610
      goto while_break;
    }
#line 612
    (result->misc + i)->type = (enum info_type )4711;
#line 610
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 614
  client->array_parse_index = 0;
#line 615
  client->array_parse_pos = 2;
  case_2: /* CIL Label */ 
  {
#line 617
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 617
    if (! (client->array_parse_index < client->array_parse_parsed_length)) {
#line 617
      goto while_break___0;
    }
#line 621
    if (client->array_parse_index < (int )result->no_of_misc) {
      {
#line 623
      prot_a_parse_misc_info(client, result->misc + client->array_parse_index);
      }
#line 630
      if ((unsigned int )(result->misc + client->array_parse_index)->type == 4711U) {
#line 632
        result->no_of_misc = (unsigned short )(client->array_parse_index + 1);
      }
    } else {
      {
#line 637
      prot_a_parse_misc_info(client, & dummy_misc_info);
      }
    }
#line 639
    (client->array_parse_index) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 641
  client->array_parse_pos = 3;
  case_3: /* CIL Label */ 
  {
#line 646
  tmp___3 = parse_nonwhite_char(client);
  }
#line 646
  if (tmp___3 != 125) {
    {
#line 647
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
  switch_default: /* CIL Label */ 
#line 649
  client->array_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 651
  return;
}
}
#line 654 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
extern void prot_a_parse_misc_info(Connection *client , Misc_info *result ) 
{ 
  struct tm tmp_time ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 662
  if (client->struct_parse_pos == 0) {
#line 662
    goto case_0;
  }
#line 666
  if (client->struct_parse_pos == 1) {
#line 666
    goto case_1;
  }
#line 720
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 663
  tmp = prot_a_parse_long(client);
#line 663
  result->type = (enum info_type )tmp;
#line 664
  client->struct_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 671
  if ((unsigned int )result->type == 15U) {
#line 671
    goto case_15;
  }
#line 671
  if ((unsigned int )result->type == 1U) {
#line 671
    goto case_15;
  }
#line 671
  if ((unsigned int )result->type == 0U) {
#line 671
    goto case_15;
  }
#line 675
  if ((unsigned int )result->type == 6U) {
#line 675
    goto case_6;
  }
#line 682
  if ((unsigned int )result->type == 5U) {
#line 682
    goto case_5;
  }
#line 682
  if ((unsigned int )result->type == 3U) {
#line 682
    goto case_5;
  }
#line 682
  if ((unsigned int )result->type == 4U) {
#line 682
    goto case_5;
  }
#line 682
  if ((unsigned int )result->type == 2U) {
#line 682
    goto case_5;
  }
#line 686
  if ((unsigned int )result->type == 7U) {
#line 686
    goto case_7;
  }
#line 698
  if ((unsigned int )result->type == 8U) {
#line 698
    goto case_8;
  }
#line 702
  if ((unsigned int )result->type == 9U) {
#line 702
    goto case_9;
  }
#line 714
  goto switch_default;
  case_15: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
  {
#line 672
  tmp___0 = prot_a_parse_long(client);
#line 672
  result->datum.recipient = (Conf_no )tmp___0;
  }
#line 673
  goto switch_break___0;
  case_6: /* CIL Label */ 
  {
#line 676
  tmp___1 = prot_a_parse_long(client);
#line 676
  result->datum.local_no = (Local_text_no )tmp___1;
  }
#line 677
  goto switch_break___0;
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 683
  tmp___2 = prot_a_parse_long(client);
#line 683
  result->datum.text_link = (Text_no )tmp___2;
  }
#line 684
  goto switch_break___0;
  case_7: /* CIL Label */ 
  {
#line 687
  prot_a_parse_time_date(client, & tmp_time);
#line 695
  result->datum.received_at = (Time )0;
  }
#line 696
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 699
  tmp___3 = prot_a_parse_long(client);
#line 699
  result->datum.sender = (Pers_no )tmp___3;
  }
#line 700
  goto switch_break___0;
  case_9: /* CIL Label */ 
  {
#line 703
  prot_a_parse_time_date(client, & tmp_time);
#line 711
  result->datum.sent_at = (Time )0;
  }
#line 712
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 715
  result->datum.unknown_type = result->type;
#line 716
  result->type = (enum info_type )4711;
#line 717
  client->array_hunt_depth = 1;
#line 718
  prot_a_hunt_array_end(client);
  }
  switch_break___0: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
#line 721
  client->struct_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 723
  return;
}
}
#line 725 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
static void prot_a_parse_read_range(Connection *client , struct read_range *result ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  {
#line 731
  if (client->struct_parse_pos == 0) {
#line 731
    goto case_0;
  }
#line 735
  if (client->struct_parse_pos == 1) {
#line 735
    goto case_1;
  }
#line 738
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 732
  tmp = prot_a_parse_long(client);
#line 732
  result->first_read = (Local_text_no )tmp;
#line 733
  client->struct_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 736
  tmp___0 = prot_a_parse_long(client);
#line 736
  result->last_read = (Local_text_no )tmp___0;
  }
  switch_default: /* CIL Label */ 
#line 739
  client->struct_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 741
  return;
}
}
#line 748 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
static unsigned long err_cnt___3  =    0UL;
#line 743 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
void prot_a_parse_read_range_list(Connection *client , struct read_range_list *res ,
                                  int maxlen ) 
{ 
  struct read_range dummy_read_range ;
  long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 753
  if (client->array_parse_pos == 0) {
#line 753
    goto case_0;
  }
#line 777
  if (client->array_parse_pos == 1) {
#line 777
    goto case_1;
  }
#line 786
  if (client->array_parse_pos == 2) {
#line 786
    goto case_2;
  }
#line 799
  if (client->array_parse_pos == 3) {
#line 799
    goto case_3;
  }
#line 803
  goto switch_default;
  case_0: /* CIL Label */ 
#line 754
  if ((int )res->length != 0) {
#line 754
    goto _L;
  } else
#line 754
  if ((unsigned long )res->ranges != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 754
    if (err_cnt___3 < 20UL) {
      {
#line 756
      kom_log("WNG: prot_a_parse_read_range_list(): len = %lu data = %lu\n", (unsigned long )res->length,
              (unsigned long )res->ranges);
#line 760
      res->length = (unsigned short)0;
#line 761
      res->ranges = (struct read_range *)((void *)0);
#line 762
      err_cnt___3 ++;
      }
#line 762
      if (err_cnt___3 == 20UL) {
        {
#line 763
        kom_log("The above warning is now turned off.\n");
        }
      }
    }
  }
  {
#line 766
  tmp = prot_a_parse_long(client);
#line 766
  client->array_parse_parsed_length = (int )tmp;
  }
#line 767
  if (client->array_parse_parsed_length < 0) {
    {
#line 769
    isc_puts("%%Insane array size.\n", client->isc_session);
#line 770
    isc_flush(client->isc_session);
#line 771
    longjmp((struct __jmp_buf_tag *)(parse_env), 3);
    }
  }
#line 774
  client->array_parse_pos = 1;
  case_1: /* CIL Label */ 
  {
#line 778
  tmp___0 = parse_nonwhite_char(client);
  }
#line 778
  if (tmp___0 != 123) {
    {
#line 779
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
#line 781
  if (maxlen + 1 > client->array_parse_parsed_length) {
#line 781
    res->length = (unsigned short )client->array_parse_parsed_length;
  } else {
#line 781
    res->length = (unsigned short )(maxlen + 1);
  }
  {
#line 782
  tmp___1 = smalloc((unsigned long )res->length * sizeof(struct read_range ));
#line 782
  res->ranges = (struct read_range *)tmp___1;
#line 784
  client->array_parse_index = 0;
#line 785
  client->array_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 787
  while (1) {
    while_continue: /* CIL Label */ ;
#line 787
    if (! (client->array_parse_index < client->array_parse_parsed_length)) {
#line 787
      goto while_break;
    }
#line 791
    if (client->array_parse_index < (int )res->length) {
      {
#line 792
      prot_a_parse_read_range(client, res->ranges + client->array_parse_index);
      }
    } else {
      {
#line 795
      prot_a_parse_read_range(client, & dummy_read_range);
      }
    }
#line 796
    (client->array_parse_index) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 798
  client->array_parse_pos = 3;
  case_3: /* CIL Label */ 
  {
#line 801
  tmp___2 = parse_nonwhite_char(client);
  }
#line 801
  if (tmp___2 != 125) {
    {
#line 802
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
  }
  switch_default: /* CIL Label */ 
#line 804
  client->array_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 806
  return;
}
}
#line 809 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
void prot_a_parse_time_date(Connection *client , struct tm *result ) 
{ 
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
  {
#line 819
  if (client->string_parse_pos == 0) {
#line 819
    goto case_0;
  }
#line 823
  if (client->string_parse_pos == 1) {
#line 823
    goto case_1;
  }
#line 827
  if (client->string_parse_pos == 2) {
#line 827
    goto case_2;
  }
#line 831
  if (client->string_parse_pos == 3) {
#line 831
    goto case_3;
  }
#line 835
  if (client->string_parse_pos == 4) {
#line 835
    goto case_4;
  }
#line 839
  if (client->string_parse_pos == 5) {
#line 839
    goto case_5;
  }
#line 843
  if (client->string_parse_pos == 6) {
#line 843
    goto case_6;
  }
#line 847
  if (client->string_parse_pos == 7) {
#line 847
    goto case_7;
  }
#line 851
  if (client->string_parse_pos == 8) {
#line 851
    goto case_8;
  }
#line 854
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 820
  tmp = prot_a_parse_long(client);
#line 820
  result->tm_sec = (int )tmp;
#line 821
  client->string_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 824
  tmp___0 = prot_a_parse_long(client);
#line 824
  result->tm_min = (int )tmp___0;
#line 825
  client->string_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 828
  tmp___1 = prot_a_parse_long(client);
#line 828
  result->tm_hour = (int )tmp___1;
#line 829
  client->string_parse_pos = 3;
  }
  case_3: /* CIL Label */ 
  {
#line 832
  tmp___2 = prot_a_parse_long(client);
#line 832
  result->tm_mday = (int )tmp___2;
#line 833
  client->string_parse_pos = 4;
  }
  case_4: /* CIL Label */ 
  {
#line 836
  tmp___3 = prot_a_parse_long(client);
#line 836
  result->tm_mon = (int )tmp___3;
#line 837
  client->string_parse_pos = 5;
  }
  case_5: /* CIL Label */ 
  {
#line 840
  tmp___4 = prot_a_parse_long(client);
#line 840
  result->tm_year = (int )tmp___4;
#line 841
  client->string_parse_pos = 6;
  }
  case_6: /* CIL Label */ 
  {
#line 844
  tmp___5 = prot_a_parse_long(client);
#line 844
  result->tm_wday = (int )tmp___5;
#line 845
  client->string_parse_pos = 7;
  }
  case_7: /* CIL Label */ 
  {
#line 848
  tmp___6 = prot_a_parse_long(client);
#line 848
  result->tm_yday = (int )tmp___6;
#line 849
  client->string_parse_pos = 8;
  }
  case_8: /* CIL Label */ 
  {
#line 852
  tmp___7 = prot_a_parse_long(client);
#line 852
  result->tm_isdst = (int )tmp___7;
  }
  switch_default: /* CIL Label */ 
#line 855
  client->string_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 857
  return;
}
}
#line 861 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
void prot_a_parse_info(Connection *client , Info *result ) 
{ 
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 866
  if (client->struct_parse_pos == 0) {
#line 866
    goto case_0;
  }
#line 870
  if (client->struct_parse_pos == 1) {
#line 870
    goto case_1;
  }
#line 874
  if (client->struct_parse_pos == 2) {
#line 874
    goto case_2;
  }
#line 878
  if (client->struct_parse_pos == 3) {
#line 878
    goto case_3;
  }
#line 882
  if (client->struct_parse_pos == 4) {
#line 882
    goto case_4;
  }
#line 886
  if (client->struct_parse_pos == 5) {
#line 886
    goto case_5;
  }
#line 889
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 867
  result->version = prot_a_parse_long(client);
#line 868
  client->struct_parse_pos = 1;
  }
  case_1: /* CIL Label */ 
  {
#line 871
  tmp = prot_a_parse_long(client);
#line 871
  result->conf_pres_conf = (Conf_no )tmp;
#line 872
  client->struct_parse_pos = 2;
  }
  case_2: /* CIL Label */ 
  {
#line 875
  tmp___0 = prot_a_parse_long(client);
#line 875
  result->pers_pres_conf = (Conf_no )tmp___0;
#line 876
  client->struct_parse_pos = 3;
  }
  case_3: /* CIL Label */ 
  {
#line 879
  tmp___1 = prot_a_parse_long(client);
#line 879
  result->motd_conf = (Conf_no )tmp___1;
#line 880
  client->struct_parse_pos = 4;
  }
  case_4: /* CIL Label */ 
  {
#line 883
  tmp___2 = prot_a_parse_long(client);
#line 883
  result->kom_news_conf = (Conf_no )tmp___2;
#line 884
  client->struct_parse_pos = 5;
  }
  case_5: /* CIL Label */ 
  {
#line 887
  tmp___3 = prot_a_parse_long(client);
#line 887
  result->motd_of_lyskom = (Text_no )tmp___3;
  }
  switch_default: /* CIL Label */ 
#line 890
  client->struct_parse_pos = 0;
  switch_break: /* CIL Label */ ;
  }
#line 892
  return;
}
}
#line 894 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
void prot_a_hunt_nl(Connection *client ) 
{ 
  String_size number_end ;
  String_size len ;

  {
  {
#line 900
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 904
    if (client->fnc_parse_pos == 0) {
#line 904
      goto case_0;
    }
#line 932
    if (client->fnc_parse_pos == 1) {
#line 932
      goto case_1;
    }
#line 971
    if (client->fnc_parse_pos == 2) {
#line 971
      goto case_2;
    }
#line 994
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 905
    if (client->first_to_parse >= client->unparsed.len) {
      {
#line 906
      longjmp((struct __jmp_buf_tag *)(parse_env), 2);
      }
    }
    {
#line 915
    if ((int )*(client->unparsed.string + client->first_to_parse) == 42) {
#line 915
      goto case_42;
    }
#line 915
    if ((int )*(client->unparsed.string + client->first_to_parse) == 125) {
#line 915
      goto case_42;
    }
#line 915
    if ((int )*(client->unparsed.string + client->first_to_parse) == 123) {
#line 915
      goto case_42;
    }
#line 915
    if ((int )*(client->unparsed.string + client->first_to_parse) == 9) {
#line 915
      goto case_42;
    }
#line 915
    if ((int )*(client->unparsed.string + client->first_to_parse) == 13) {
#line 915
      goto case_42;
    }
#line 915
    if ((int )*(client->unparsed.string + client->first_to_parse) == 32) {
#line 915
      goto case_42;
    }
#line 918
    if ((int )*(client->unparsed.string + client->first_to_parse) == 10) {
#line 918
      goto case_10;
    }
#line 923
    if ((int )*(client->unparsed.string + client->first_to_parse) == 57) {
#line 923
      goto case_57;
    }
#line 923
    if ((int )*(client->unparsed.string + client->first_to_parse) == 56) {
#line 923
      goto case_57;
    }
#line 923
    if ((int )*(client->unparsed.string + client->first_to_parse) == 55) {
#line 923
      goto case_57;
    }
#line 923
    if ((int )*(client->unparsed.string + client->first_to_parse) == 54) {
#line 923
      goto case_57;
    }
#line 923
    if ((int )*(client->unparsed.string + client->first_to_parse) == 53) {
#line 923
      goto case_57;
    }
#line 923
    if ((int )*(client->unparsed.string + client->first_to_parse) == 52) {
#line 923
      goto case_57;
    }
#line 923
    if ((int )*(client->unparsed.string + client->first_to_parse) == 51) {
#line 923
      goto case_57;
    }
#line 923
    if ((int )*(client->unparsed.string + client->first_to_parse) == 50) {
#line 923
      goto case_57;
    }
#line 923
    if ((int )*(client->unparsed.string + client->first_to_parse) == 49) {
#line 923
      goto case_57;
    }
#line 923
    if ((int )*(client->unparsed.string + client->first_to_parse) == 48) {
#line 923
      goto case_57;
    }
#line 928
    goto switch_default;
    case_42: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 916
    (client->first_to_parse) ++;
#line 917
    goto switch_break___0;
    case_10: /* CIL Label */ 
#line 920
    (client->first_to_parse) ++;
#line 921
    return;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 926
    client->fnc_parse_pos = 1;
#line 927
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 929
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 931
    goto switch_break;
    case_1: /* CIL Label */ 
#line 935
    len = (String_size )((int )*(client->unparsed.string + client->first_to_parse) - 48);
#line 936
    number_end = client->first_to_parse + 1L;
    {
#line 936
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 936
      if (! (number_end < client->unparsed.len)) {
#line 936
        goto while_break___0;
      }
#line 940
      if ((int )*(client->unparsed.string + number_end) >= 48) {
#line 940
        if ((int )*(client->unparsed.string + number_end) <= 57) {
#line 943
          len = (10L * len + (String_size )*(client->unparsed.string + number_end)) - 48L;
        } else {
#line 948
          goto while_break___0;
        }
      } else {
#line 948
        goto while_break___0;
      }
#line 936
      number_end ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 952
    if (number_end == client->unparsed.len) {
      {
#line 953
      longjmp((struct __jmp_buf_tag *)(parse_env), 2);
      }
    }
#line 955
    if ((int )*(client->unparsed.string + number_end) == 72) {
#line 959
      client->num0 = len;
#line 960
      client->first_to_parse = number_end + 1L;
#line 961
      client->fnc_parse_pos = 2;
    } else {
#line 967
      client->first_to_parse = number_end;
#line 968
      client->fnc_parse_pos = 0;
    }
#line 970
    goto switch_break;
    case_2: /* CIL Label */ 
#line 972
    if (client->num0 == 0L) {
#line 975
      client->fnc_parse_pos = 0;
#line 976
      goto switch_break;
    }
#line 978
    len = client->unparsed.len - client->first_to_parse;
#line 979
    if (client->num0 <= len) {
#line 982
      client->first_to_parse += client->num0;
#line 983
      client->fnc_parse_pos = 0;
#line 984
      goto switch_break;
    } else {
      {
#line 989
      client->num0 -= len;
#line 990
      client->first_to_parse = client->unparsed.len;
#line 991
      longjmp((struct __jmp_buf_tag *)(parse_env), 2);
      }
    }
    {
#line 993
    abort();
    }
    switch_default___0: /* CIL Label */ 
    {
#line 995
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1008 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
static void prot_a_hunt_array_end(Connection *client ) 
{ 
  String_size number_end ;
  String_size len ;

  {
  {
#line 1014
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1018
    if (client->hunt_parse_pos == 0) {
#line 1018
      goto case_0;
    }
#line 1058
    if (client->hunt_parse_pos == 1) {
#line 1058
      goto case_1;
    }
#line 1097
    if (client->hunt_parse_pos == 2) {
#line 1097
      goto case_2;
    }
#line 1120
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 1019
    if (client->first_to_parse >= client->unparsed.len) {
      {
#line 1020
      longjmp((struct __jmp_buf_tag *)(parse_env), 2);
      }
    }
    {
#line 1028
    if ((int )*(client->unparsed.string + client->first_to_parse) == 10) {
#line 1028
      goto case_10;
    }
#line 1028
    if ((int )*(client->unparsed.string + client->first_to_parse) == 42) {
#line 1028
      goto case_10;
    }
#line 1028
    if ((int )*(client->unparsed.string + client->first_to_parse) == 9) {
#line 1028
      goto case_10;
    }
#line 1028
    if ((int )*(client->unparsed.string + client->first_to_parse) == 13) {
#line 1028
      goto case_10;
    }
#line 1028
    if ((int )*(client->unparsed.string + client->first_to_parse) == 32) {
#line 1028
      goto case_10;
    }
#line 1031
    if ((int )*(client->unparsed.string + client->first_to_parse) == 123) {
#line 1031
      goto case_123;
    }
#line 1035
    if ((int )*(client->unparsed.string + client->first_to_parse) == 125) {
#line 1035
      goto case_125;
    }
#line 1049
    if ((int )*(client->unparsed.string + client->first_to_parse) == 57) {
#line 1049
      goto case_57;
    }
#line 1049
    if ((int )*(client->unparsed.string + client->first_to_parse) == 56) {
#line 1049
      goto case_57;
    }
#line 1049
    if ((int )*(client->unparsed.string + client->first_to_parse) == 55) {
#line 1049
      goto case_57;
    }
#line 1049
    if ((int )*(client->unparsed.string + client->first_to_parse) == 54) {
#line 1049
      goto case_57;
    }
#line 1049
    if ((int )*(client->unparsed.string + client->first_to_parse) == 53) {
#line 1049
      goto case_57;
    }
#line 1049
    if ((int )*(client->unparsed.string + client->first_to_parse) == 52) {
#line 1049
      goto case_57;
    }
#line 1049
    if ((int )*(client->unparsed.string + client->first_to_parse) == 51) {
#line 1049
      goto case_57;
    }
#line 1049
    if ((int )*(client->unparsed.string + client->first_to_parse) == 50) {
#line 1049
      goto case_57;
    }
#line 1049
    if ((int )*(client->unparsed.string + client->first_to_parse) == 49) {
#line 1049
      goto case_57;
    }
#line 1049
    if ((int )*(client->unparsed.string + client->first_to_parse) == 48) {
#line 1049
      goto case_57;
    }
#line 1054
    goto switch_default;
    case_10: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 1029
    (client->first_to_parse) ++;
#line 1030
    goto switch_break___0;
    case_123: /* CIL Label */ 
#line 1032
    (client->array_hunt_depth) ++;
#line 1033
    (client->first_to_parse) ++;
#line 1034
    goto switch_break___0;
    case_125: /* CIL Label */ 
#line 1036
    (client->array_hunt_depth) --;
#line 1037
    if (client->array_hunt_depth <= 0) {
#line 1039
      client->hunt_parse_pos = 0;
#line 1040
      return;
    } else {
#line 1044
      (client->first_to_parse) ++;
    }
#line 1046
    goto switch_break___0;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 1052
    client->hunt_parse_pos = 1;
#line 1053
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 1055
    longjmp((struct __jmp_buf_tag *)(parse_env), 1);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 1057
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1061
    len = (String_size )((int )*(client->unparsed.string + client->first_to_parse) - 48);
#line 1062
    number_end = client->first_to_parse + 1L;
    {
#line 1062
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1062
      if (! (number_end < client->unparsed.len)) {
#line 1062
        goto while_break___0;
      }
#line 1066
      if ((int )*(client->unparsed.string + number_end) >= 48) {
#line 1066
        if ((int )*(client->unparsed.string + number_end) <= 57) {
#line 1069
          len = (10L * len + (String_size )*(client->unparsed.string + number_end)) - 48L;
        } else {
#line 1074
          goto while_break___0;
        }
      } else {
#line 1074
        goto while_break___0;
      }
#line 1062
      number_end ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1078
    if (number_end == client->unparsed.len) {
      {
#line 1079
      longjmp((struct __jmp_buf_tag *)(parse_env), 2);
      }
    }
#line 1081
    if ((int )*(client->unparsed.string + number_end) == 72) {
#line 1085
      client->array_hunt_num = (int )len;
#line 1086
      client->first_to_parse = number_end + 1L;
#line 1087
      client->hunt_parse_pos = 2;
    } else {
#line 1093
      client->first_to_parse = number_end;
#line 1094
      client->hunt_parse_pos = 0;
    }
#line 1096
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1098
    if (client->array_hunt_num == 0) {
#line 1101
      client->hunt_parse_pos = 0;
#line 1102
      goto switch_break;
    }
#line 1104
    len = client->unparsed.len - client->first_to_parse;
#line 1105
    if ((String_size )client->array_hunt_num <= len) {
#line 1108
      client->first_to_parse += (String_size )client->array_hunt_num;
#line 1109
      client->hunt_parse_pos = 0;
#line 1110
      goto switch_break;
    } else {
      {
#line 1115
      client->array_hunt_num = (int )((String_size )client->array_hunt_num - len);
#line 1116
      client->first_to_parse = client->unparsed.len;
#line 1117
      longjmp((struct __jmp_buf_tag *)(parse_env), 2);
      }
    }
    {
#line 1119
    abort();
    }
    switch_default___0: /* CIL Label */ 
    {
#line 1121
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1126 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/prot-a-parse.c"
void prot_a_parse_skip_whitespace(Connection *client ) 
{ 
  char *tmp ;

  {
  {
#line 1129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1129
    if (client->first_to_parse < client->unparsed.len) {
      {
#line 1129
      tmp = strchr(WHITESPACE, (int )*(client->unparsed.string + client->first_to_parse));
      }
#line 1129
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1129
        goto while_break;
      }
    } else {
#line 1129
      goto while_break;
    }
#line 1132
    (client->first_to_parse) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1133
  return;
}
}
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 36 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.h"
void foutput_info(FILE *fp , Info *info ) ;
#line 40
extern void foutput_person(FILE *fp , Person const   *person ) ;
#line 44
void foutput_conference(FILE *fp , Conference *conf_c ) ;
#line 48
void foutput_text_stat(FILE *fp , Text_stat *t_stat ) ;
#line 57
void set_output_format(int fmt ) ;
#line 80 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.h"
void l2g_write(FILE *fp , Local_to_global const   *l2g ) ;
#line 53 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_aux_item_list(FILE *fp , Aux_item_list const   *aux ) ;
#line 54
static void foutput_conf_type(FILE *fp , Conf_type type ) ;
#line 55
static void foutput_mark(FILE *fp , Mark mark ) ;
#line 56
static void foutput_mark_list(FILE *fp , Mark_list const   mark_list ) ;
#line 57
static void foutput_member(FILE *fp , Member member ) ;
#line 58
static void foutput_member_list(FILE *fp , Member_list m_list ) ;
#line 59
static void foutput_membership_list(FILE *fp , Membership_list mlist ) ;
#line 60
static void foutput_misc_info(FILE *fp , Misc_info misc ) ;
#line 61
static void foutput_personal_flags(FILE *fp , Personal_flags flags ) ;
#line 62
static void foutput_priv_bits(FILE *fp , Priv_bits bits ) ;
#line 63
static void foutput_string(FILE *fp , String str ) ;
#line 64
static void foutput_text_list(FILE *fp , Local_to_global const   *text_list ) ;
#line 65
static void foutput_time(FILE *fp , time_t clk ) ;
#line 66
static void foutput_ulong(unsigned long l , FILE *fp ) ;
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static int output_format  =    2;
#line 71 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
void set_output_format(int fmt ) 
{ 


  {
#line 74
  output_format = fmt;
  {
#line 79
  if (fmt == 2) {
#line 79
    goto case_2;
  }
#line 79
  if (fmt == 1) {
#line 79
    goto case_2;
  }
#line 79
  if (fmt == 0) {
#line 79
    goto case_2;
  }
#line 81
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 80
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 82
  restart_kom("unknown output format selected: %d\n", fmt);
  }
#line 83
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_info_0(FILE *fp , Info *info ) 
{ 


  {
  {
#line 90
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu",
          (unsigned long )info->conf_pres_conf, (unsigned long )info->pers_pres_conf,
          (unsigned long )info->motd_conf, (unsigned long )info->kom_news_conf, info->motd_of_lyskom);
  }
#line 96
  return;
}
}
#line 98 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_info_2(FILE *fp , Info *info ) 
{ 


  {
  {
#line 101
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu %lu",
          (unsigned long )info->conf_pres_conf, (unsigned long )info->pers_pres_conf,
          (unsigned long )info->motd_conf, (unsigned long )info->kom_news_conf, info->motd_of_lyskom,
          info->highest_aux_no);
#line 108
  foutput_aux_item_list(fp, (Aux_item_list const   *)(& info->aux_item_list));
  }
#line 109
  return;
}
}
#line 112 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
void foutput_info(FILE *fp , Info *info ) 
{ 


  {
  {
#line 117
  if (output_format == 1) {
#line 117
    goto case_1;
  }
#line 117
  if (output_format == 0) {
#line 117
    goto case_1;
  }
#line 120
  if (output_format == 2) {
#line 120
    goto case_2;
  }
#line 123
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 118
  foutput_info_0(fp, info);
  }
#line 119
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 121
  foutput_info_2(fp, info);
  }
#line 122
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 124
  restart_kom("unknown database format: %d", output_format);
  }
#line 125
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 127
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_person_0(FILE *fp , Person const   *person ) 
{ 


  {
  {
#line 134
  foutput_string(fp, (String )person->username);
#line 135
  foutput_priv_bits(fp, (Priv_bits )person->privileges);
#line 136
  foutput_personal_flags(fp, (Personal_flags )person->flags);
#line 138
  foutput_text_list(fp, & person->created_texts);
#line 139
  foutput_mark_list(fp, person->marks);
#line 140
  foutput_membership_list(fp, (Membership_list )person->conferences);
#line 142
  foutput_time(fp, (time_t )person->last_login);
#line 144
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu %lu %lu %lu %lu",
          (unsigned long )person->user_area, (unsigned long )person->total_time_present,
          (unsigned long )person->sessions, (unsigned long )person->created_lines,
          (unsigned long )person->created_bytes, (unsigned long )person->read_texts,
          (unsigned long )person->no_of_text_fetches, (unsigned long )person->created_persons,
          (unsigned long )person->created_confs);
  }
#line 156
  return;
}
}
#line 158 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_person_2(FILE *fp , Person const   *person ) 
{ 


  {
  {
#line 162
  foutput_string(fp, (String )person->username);
#line 163
  foutput_priv_bits(fp, (Priv_bits )person->privileges);
#line 164
  foutput_personal_flags(fp, (Personal_flags )person->flags);
#line 166
  _IO_putc(' ', fp);
#line 167
  l2g_write(fp, & person->created_texts);
#line 168
  foutput_mark_list(fp, person->marks);
#line 169
  foutput_membership_list(fp, (Membership_list )person->conferences);
#line 171
  foutput_time(fp, (time_t )person->last_login);
#line 173
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu %lu %lu %lu %lu",
          (unsigned long )person->user_area, (unsigned long )person->total_time_present,
          (unsigned long )person->sessions, (unsigned long )person->created_lines,
          (unsigned long )person->created_bytes, (unsigned long )person->read_texts,
          (unsigned long )person->no_of_text_fetches, (unsigned long )person->created_persons,
          (unsigned long )person->created_confs);
  }
#line 185
  return;
}
}
#line 187 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
extern void foutput_person(FILE *fp , Person const   *person ) 
{ 


  {
  {
#line 194
  if (output_format == 1) {
#line 194
    goto case_1;
  }
#line 194
  if (output_format == 0) {
#line 194
    goto case_1;
  }
#line 197
  if (output_format == 2) {
#line 197
    goto case_2;
  }
#line 200
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 195
  foutput_person_0(fp, person);
  }
#line 196
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 198
  foutput_person_2(fp, person);
  }
#line 199
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 201
  restart_kom("unknown database format: %d", output_format);
  }
#line 202
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 204
  return;
}
}
#line 207 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_conference_2(FILE *fp , Conference const   *conf_c ) 
{ 


  {
  {
#line 211
  foutput_string(fp, (String )conf_c->name);
#line 212
  foutput_member_list(fp, (Member_list )conf_c->members);
#line 213
  _IO_putc(' ', fp);
#line 214
  l2g_write(fp, & conf_c->texts);
#line 215
  foutput_conf_type(fp, (Conf_type )conf_c->type);
#line 217
  foutput_time(fp, (time_t )conf_c->creation_time);
#line 218
  foutput_time(fp, (time_t )conf_c->last_written);
#line 220
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu %lu %lu",
          (unsigned long )conf_c->creator, (unsigned long )conf_c->presentation, (unsigned long )conf_c->supervisor,
          (unsigned long )conf_c->permitted_submitters, (unsigned long )conf_c->super_conf,
          (unsigned long )conf_c->msg_of_day, (unsigned long )conf_c->nice);
#line 228
  foutput_ulong((unsigned long )conf_c->keep_commented, fp);
#line 229
  foutput_ulong((unsigned long )conf_c->expire, fp);
#line 230
  foutput_ulong((unsigned long )conf_c->highest_aux, fp);
#line 231
  foutput_aux_item_list(fp, & conf_c->aux_item_list);
  }
#line 232
  return;
}
}
#line 234 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_conference_1(FILE *fp , Conference *conf_c ) 
{ 


  {
  {
#line 238
  foutput_string(fp, conf_c->name);
#line 239
  foutput_member_list(fp, conf_c->members);
#line 240
  foutput_text_list(fp, (Local_to_global const   *)(& conf_c->texts));
#line 241
  foutput_conf_type(fp, conf_c->type);
#line 243
  foutput_time(fp, conf_c->creation_time);
#line 244
  foutput_time(fp, conf_c->last_written);
#line 246
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu %lu %lu",
          (unsigned long )conf_c->creator, conf_c->presentation, (unsigned long )conf_c->supervisor,
          (unsigned long )conf_c->permitted_submitters, (unsigned long )conf_c->super_conf,
          conf_c->msg_of_day, conf_c->nice);
  }
#line 254
  return;
}
}
#line 256 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_conference_0(FILE *fp , Conference *conf_c ) 
{ 


  {
  {
#line 260
  foutput_string(fp, conf_c->name);
#line 261
  foutput_member_list(fp, conf_c->members);
#line 262
  foutput_text_list(fp, (Local_to_global const   *)(& conf_c->texts));
#line 263
  foutput_conf_type(fp, conf_c->type);
#line 265
  foutput_time(fp, conf_c->creation_time);
#line 266
  foutput_time(fp, conf_c->last_written);
#line 268
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu %lu %lu",
          (unsigned long )conf_c->creator, conf_c->presentation, (unsigned long )conf_c->supervisor,
          (unsigned long )conf_c->permitted_submitters, (unsigned long )conf_c->super_conf,
          conf_c->msg_of_day, conf_c->nice);
  }
#line 276
  return;
}
}
#line 278 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
void foutput_conference(FILE *fp , Conference *conf_c ) 
{ 


  {
  {
#line 283
  if (output_format == 0) {
#line 283
    goto case_0;
  }
#line 286
  if (output_format == 1) {
#line 286
    goto case_1;
  }
#line 289
  if (output_format == 2) {
#line 289
    goto case_2;
  }
#line 292
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 284
  foutput_conference_0(fp, conf_c);
  }
#line 285
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 287
  foutput_conference_1(fp, conf_c);
  }
#line 288
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 290
  foutput_conference_2(fp, (Conference const   *)conf_c);
  }
#line 291
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 293
  restart_kom("unknown database format: %d", output_format);
  }
#line 294
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 300 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_text_stat_0(FILE *fp , Text_stat *t_stat ) 
{ 
  int i ;

  {
  {
#line 306
  foutput_time(fp, t_stat->creation_time);
#line 308
  foutput_ulong((unsigned long )t_stat->author, fp);
#line 309
  foutput_ulong((unsigned long )t_stat->file_pos, fp);
#line 310
  foutput_ulong((unsigned long )t_stat->no_of_lines, fp);
#line 311
  foutput_ulong((unsigned long )t_stat->no_of_chars, fp);
#line 312
  foutput_ulong((unsigned long )t_stat->no_of_marks, fp);
#line 313
  foutput_ulong((unsigned long )t_stat->no_of_misc, fp);
  }
#line 315
  if ((unsigned long )t_stat->misc_items != (unsigned long )((void *)0)) {
#line 315
    if ((int )t_stat->no_of_misc > 0) {
      {
#line 317
      fputs((char const   */* __restrict  */)" {", (FILE */* __restrict  */)fp);
#line 318
      i = 0;
      }
      {
#line 318
      while (1) {
        while_continue: /* CIL Label */ ;
#line 318
        if (! (i < (int )t_stat->no_of_misc)) {
#line 318
          goto while_break;
        }
        {
#line 319
        foutput_misc_info(fp, *(t_stat->misc_items + i));
#line 318
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 320
      fputs((char const   */* __restrict  */)" }", (FILE */* __restrict  */)fp);
      }
    } else {
      {
#line 323
      fputs((char const   */* __restrict  */)" *", (FILE */* __restrict  */)fp);
      }
    }
  } else {
    {
#line 323
    fputs((char const   */* __restrict  */)" *", (FILE */* __restrict  */)fp);
    }
  }
#line 324
  return;
}
}
#line 326 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_text_stat_2(FILE *fp , Text_stat *t_stat ) 
{ 
  int i ;

  {
  {
#line 332
  foutput_time(fp, t_stat->creation_time);
#line 334
  foutput_ulong((unsigned long )t_stat->author, fp);
#line 335
  foutput_ulong((unsigned long )t_stat->file_pos, fp);
#line 336
  foutput_ulong((unsigned long )t_stat->no_of_lines, fp);
#line 337
  foutput_ulong((unsigned long )t_stat->no_of_chars, fp);
#line 338
  foutput_ulong((unsigned long )t_stat->no_of_marks, fp);
#line 339
  foutput_ulong((unsigned long )t_stat->no_of_misc, fp);
  }
#line 341
  if ((unsigned long )t_stat->misc_items != (unsigned long )((void *)0)) {
#line 341
    if ((int )t_stat->no_of_misc > 0) {
      {
#line 343
      fputs((char const   */* __restrict  */)" {", (FILE */* __restrict  */)fp);
#line 344
      i = 0;
      }
      {
#line 344
      while (1) {
        while_continue: /* CIL Label */ ;
#line 344
        if (! (i < (int )t_stat->no_of_misc)) {
#line 344
          goto while_break;
        }
        {
#line 345
        foutput_misc_info(fp, *(t_stat->misc_items + i));
#line 344
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 346
      fputs((char const   */* __restrict  */)" }", (FILE */* __restrict  */)fp);
      }
    } else {
      {
#line 349
      fputs((char const   */* __restrict  */)" *", (FILE */* __restrict  */)fp);
      }
    }
  } else {
    {
#line 349
    fputs((char const   */* __restrict  */)" *", (FILE */* __restrict  */)fp);
    }
  }
  {
#line 351
  foutput_ulong(t_stat->highest_aux, fp);
#line 352
  foutput_aux_item_list(fp, (Aux_item_list const   *)(& t_stat->aux_item_list));
  }
#line 353
  return;
}
}
#line 355 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
void foutput_text_stat(FILE *fp , Text_stat *t_stat ) 
{ 


  {
  {
#line 362
  if (output_format == 1) {
#line 362
    goto case_1;
  }
#line 362
  if (output_format == 0) {
#line 362
    goto case_1;
  }
#line 365
  if (output_format == 2) {
#line 365
    goto case_2;
  }
#line 368
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 363
  foutput_text_stat_0(fp, t_stat);
  }
#line 364
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 366
  foutput_text_stat_2(fp, t_stat);
  }
#line 367
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 369
  restart_kom("unknown database format: %d\n", output_format);
  }
#line 370
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 372
  return;
}
}
#line 376 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_aux_flags(FILE *fp , Aux_item_flags f ) 
{ 


  {
  {
#line 380
  _IO_putc(' ', fp);
#line 381
  _IO_putc((int )(f.deleted + 48U), fp);
#line 382
  _IO_putc((int )(f.inherit + 48U), fp);
#line 383
  _IO_putc((int )(f.secret + 48U), fp);
#line 384
  _IO_putc((int )(f.hide_creator + 48U), fp);
#line 385
  _IO_putc((int )(f.dont_garb + 48U), fp);
#line 386
  _IO_putc((int )(f.reserved3 + 48U), fp);
#line 387
  _IO_putc((int )(f.reserved4 + 48U), fp);
#line 388
  _IO_putc((int )(f.reserved5 + 48U), fp);
  }
#line 389
  return;
}
}
#line 391 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_aux_item_link(FILE *fp , Aux_item_link *link ) 
{ 


  {
  {
#line 395
  foutput_ulong((unsigned long )link->target_type, fp);
#line 396
  foutput_ulong(link->target_item, fp);
  }
  {
#line 399
  if ((unsigned int )link->target_type == 2U) {
#line 399
    goto case_2;
  }
#line 402
  if ((unsigned int )link->target_type == 1U) {
#line 402
    goto case_1;
  }
#line 405
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 400
  foutput_ulong((unsigned long )link->target_object.conf, fp);
  }
#line 401
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 403
  foutput_ulong(link->target_object.text, fp);
  }
#line 404
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 408
  return;
}
}
#line 410 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_aux_item(FILE *fp , Aux_item *a_item ) 
{ 


  {
  {
#line 414
  foutput_ulong(a_item->aux_no, fp);
#line 415
  foutput_ulong(a_item->tag, fp);
#line 416
  foutput_ulong((unsigned long )a_item->creator, fp);
#line 417
  foutput_time(fp, a_item->sent_at);
#line 418
  foutput_aux_flags(fp, a_item->flags);
#line 419
  foutput_ulong(a_item->inherit_limit, fp);
#line 420
  foutput_string(fp, a_item->data);
#line 421
  foutput_aux_item_link(fp, & a_item->linked_item);
  }
#line 422
  return;
}
}
#line 424 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_aux_item_list(FILE *fp , Aux_item_list const   *aux ) 
{ 
  int i ;

  {
  {
#line 430
  foutput_ulong((unsigned long )aux->length, fp);
  }
#line 431
  if (aux->items) {
#line 431
    if ((int const   )aux->length > 0) {
      {
#line 433
      fputs((char const   */* __restrict  */)" {", (FILE */* __restrict  */)fp);
#line 434
      i = 0;
      }
      {
#line 434
      while (1) {
        while_continue: /* CIL Label */ ;
#line 434
        if (! (i < (int )aux->length)) {
#line 434
          goto while_break;
        }
        {
#line 435
        foutput_aux_item(fp, aux->items + i);
#line 434
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 436
      fputs((char const   */* __restrict  */)" }", (FILE */* __restrict  */)fp);
      }
    } else {
      {
#line 439
      fputs((char const   */* __restrict  */)" *", (FILE */* __restrict  */)fp);
      }
    }
  } else {
    {
#line 439
    fputs((char const   */* __restrict  */)" *", (FILE */* __restrict  */)fp);
    }
  }
#line 440
  return;
}
}
#line 443 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_membership_type(FILE *fp , Membership_type type ) 
{ 


  {
  {
#line 447
  _IO_putc(' ', fp);
#line 448
  _IO_putc((int )(type.invitation + 48U), fp);
#line 449
  _IO_putc((int )(type.passive + 48U), fp);
#line 450
  _IO_putc((int )(type.secret + 48U), fp);
#line 451
  _IO_putc((int )(type.passive_message_invert + 48U), fp);
#line 452
  _IO_putc((int )(type.reserved2 + 48U), fp);
#line 453
  _IO_putc((int )(type.reserved3 + 48U), fp);
#line 454
  _IO_putc((int )(type.reserved4 + 48U), fp);
#line 455
  _IO_putc((int )(type.reserved5 + 48U), fp);
  }
#line 456
  return;
}
}
#line 458 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_read_ranges_0(FILE *fp , Membership *mship ) 
{ 
  struct read_range *begin ;
  struct read_range *end ;
  unsigned long no_of_read ;
  struct read_range  const  *ptr ;
  Local_text_no lno ;

  {
#line 462
  if ((unsigned long )mship->read_ranges == (unsigned long )((void *)0)) {
#line 462
    if (mship->no_of_read_ranges != 0U) {
      {
#line 464
      kom_log("foutput_read_ranges_0(): no_of_read_ranges forced to 0 in a membership in %lu.\n",
              (unsigned long )mship->conf_no);
#line 466
      mship->no_of_read_ranges = 0U;
      }
    }
  }
#line 469
  if (mship->no_of_read_ranges == 0U) {
    {
#line 470
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" 0 0 *");
    }
  } else {
#line 476
    begin = mship->read_ranges + 0;
#line 477
    end = begin + mship->no_of_read_ranges;
#line 479
    if (begin->first_read == 1UL) {
      {
#line 481
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu",
              begin->last_read);
#line 482
      begin ++;
      }
    } else {
      {
#line 485
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" 0");
      }
    }
#line 487
    if ((unsigned long )begin == (unsigned long )end) {
      {
#line 488
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" 0 *");
      }
    } else {
#line 491
      no_of_read = 0UL;
#line 494
      ptr = (struct read_range  const  *)begin;
      {
#line 494
      while (1) {
        while_continue: /* CIL Label */ ;
#line 494
        if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 494
          goto while_break;
        }
#line 495
        no_of_read += (unsigned long )((ptr->last_read - ptr->first_read) + 1UL);
#line 494
        ptr ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 497
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu {",
              no_of_read);
#line 499
      ptr = (struct read_range  const  *)begin;
      }
      {
#line 499
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 499
        if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 499
          goto while_break___0;
        }
#line 503
        lno = (Local_text_no )ptr->first_read;
        {
#line 503
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 503
          if (! (lno <= (Local_text_no )ptr->last_read)) {
#line 503
            goto while_break___1;
          }
          {
#line 504
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu",
                  lno);
#line 503
          lno ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 499
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 507
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" }");
      }
    }
  }
#line 510
  return;
}
}
#line 512 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_membership_0(FILE *fp , Membership *mship ) 
{ 


  {
  {
#line 516
  foutput_time(fp, mship->last_time_read);
#line 518
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu",
          (unsigned long )mship->conf_no, (unsigned long )mship->priority);
#line 521
  foutput_read_ranges_0(fp, mship);
  }
#line 522
  return;
}
}
#line 524 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_membership_2(FILE *fp , Membership *mship ) 
{ 


  {
  {
#line 528
  foutput_time(fp, mship->last_time_read);
#line 530
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu",
          (unsigned long )mship->conf_no, (unsigned long )mship->priority);
#line 533
  foutput_read_ranges_0(fp, mship);
#line 534
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu", (unsigned long )mship->added_by);
#line 535
  foutput_time(fp, mship->added_at);
#line 536
  foutput_membership_type(fp, mship->type);
  }
#line 537
  return;
}
}
#line 540 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
extern void foutput_membership(FILE *fp , Membership *mship ) 
{ 


  {
  {
#line 547
  if (output_format == 1) {
#line 547
    goto case_1;
  }
#line 547
  if (output_format == 0) {
#line 547
    goto case_1;
  }
#line 550
  if (output_format == 2) {
#line 550
    goto case_2;
  }
#line 553
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 548
  foutput_membership_0(fp, mship);
  }
#line 549
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 551
  foutput_membership_2(fp, mship);
  }
#line 552
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 554
  restart_kom("unknown database format: %d", output_format);
  }
#line 555
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 561 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_string(FILE *fp , String str ) 
{ 


  {
  {
#line 565
  foutput_ulong((unsigned long )str.len, fp);
#line 566
  _IO_putc('H', fp);
  }
#line 568
  if (str.len) {
    {
#line 569
    fwrite((void const   */* __restrict  */)str.string, (size_t )str.len, (size_t )1,
           (FILE */* __restrict  */)fp);
    }
  }
#line 570
  return;
}
}
#line 572 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_priv_bits(FILE *fp , Priv_bits bits ) 
{ 


  {
  {
#line 576
  _IO_putc(' ', fp);
#line 577
  _IO_putc((int )(bits.wheel + 48U), fp);
#line 578
  _IO_putc((int )(bits.admin + 48U), fp);
#line 579
  _IO_putc((int )(bits.statistic + 48U), fp);
#line 580
  _IO_putc((int )(bits.create_pers + 48U), fp);
#line 581
  _IO_putc((int )(bits.create_conf + 48U), fp);
#line 582
  _IO_putc((int )(bits.change_name + 48U), fp);
#line 583
  _IO_putc((int )(bits.flg7 + 48U), fp);
#line 584
  _IO_putc((int )(bits.flg8 + 48U), fp);
#line 585
  _IO_putc((int )(bits.flg9 + 48U), fp);
#line 586
  _IO_putc((int )(bits.flg10 + 48U), fp);
#line 587
  _IO_putc((int )(bits.flg11 + 48U), fp);
#line 588
  _IO_putc((int )(bits.flg12 + 48U), fp);
#line 589
  _IO_putc((int )(bits.flg13 + 48U), fp);
#line 590
  _IO_putc((int )(bits.flg14 + 48U), fp);
#line 591
  _IO_putc((int )(bits.flg15 + 48U), fp);
#line 592
  _IO_putc((int )(bits.flg16 + 48U), fp);
  }
#line 593
  return;
}
}
#line 595 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_personal_flags(FILE *fp , Personal_flags flags ) 
{ 


  {
  {
#line 599
  _IO_putc(' ', fp);
#line 600
  _IO_putc((int )(flags.unread_is_secret + 48U), fp);
#line 601
  _IO_putc((int )(flags.flg2 + 48U), fp);
#line 602
  _IO_putc((int )(flags.flg3 + 48U), fp);
#line 603
  _IO_putc((int )(flags.flg4 + 48U), fp);
#line 604
  _IO_putc((int )(flags.flg5 + 48U), fp);
#line 605
  _IO_putc((int )(flags.flg6 + 48U), fp);
#line 606
  _IO_putc((int )(flags.flg7 + 48U), fp);
#line 607
  _IO_putc((int )(flags.flg8 + 48U), fp);
  }
#line 608
  return;
}
}
#line 611 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_text_list(FILE *fp , Local_to_global const   *text_list ) 
{ 
  Local_text_no first ;
  Local_text_no end ;
  Local_text_no tmp ;
  Text_no tmp___0 ;

  {
  {
#line 618
  first = l2g_next_key(text_list, (Local_text_no )0);
#line 619
  end = l2g_first_appendable_key(text_list);
  }
#line 621
  if (first == 0UL) {
#line 622
    first = end;
  }
  {
#line 624
  foutput_ulong(first, fp);
#line 625
  foutput_ulong(end - first, fp);
  }
#line 627
  if (first < end) {
    {
#line 629
    fputs((char const   */* __restrict  */)" {", (FILE */* __restrict  */)fp);
    }
    {
#line 630
    while (1) {
      while_continue: /* CIL Label */ ;
#line 630
      if (! (first < end)) {
#line 630
        goto while_break;
      }
      {
#line 631
      tmp = first;
#line 631
      first ++;
#line 631
      tmp___0 = l2g_lookup(text_list, tmp);
#line 631
      foutput_ulong(tmp___0, fp);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 632
    fputs((char const   */* __restrict  */)" }", (FILE */* __restrict  */)fp);
    }
  } else {
    {
#line 635
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
    }
  }
#line 636
  return;
}
}
#line 639 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_mark_list(FILE *fp , Mark_list const   mark_list ) 
{ 
  int i ;

  {
  {
#line 645
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu", (unsigned long )mark_list.no_of_marks);
  }
#line 647
  if ((unsigned long )mark_list.marks != (unsigned long )((void *)0)) {
#line 647
    if ((int const   )mark_list.no_of_marks > 0) {
      {
#line 649
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" {");
#line 650
      i = 0;
      }
      {
#line 650
      while (1) {
        while_continue: /* CIL Label */ ;
#line 650
        if (! (i < (int )mark_list.no_of_marks)) {
#line 650
          goto while_break;
        }
        {
#line 651
        foutput_mark(fp, *(mark_list.marks + i));
#line 650
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 652
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" }");
      }
    } else {
      {
#line 655
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
      }
    }
  } else {
    {
#line 655
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
    }
  }
#line 657
  return;
}
}
#line 660 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_mark(FILE *fp , Mark mark ) 
{ 


  {
  {
#line 664
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu",
          mark.text_no, (unsigned long )mark.mark_type);
  }
#line 665
  return;
}
}
#line 667 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_membership_list_0(FILE *fp , Membership_list mlist ) 
{ 
  int i ;

  {
  {
#line 673
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu", (unsigned long )mlist.no_of_confs);
  }
#line 675
  if ((unsigned long )mlist.confs != (unsigned long )((void *)0)) {
#line 675
    if ((int )mlist.no_of_confs > 0) {
      {
#line 677
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" {");
#line 678
      i = 0;
      }
      {
#line 678
      while (1) {
        while_continue: /* CIL Label */ ;
#line 678
        if (! (i < (int )mlist.no_of_confs)) {
#line 678
          goto while_break;
        }
        {
#line 679
        foutput_membership_0(fp, mlist.confs + i);
#line 678
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 680
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" }");
      }
    } else {
      {
#line 683
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
      }
    }
  } else {
    {
#line 683
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
    }
  }
#line 684
  return;
}
}
#line 686 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_membership_list_2(FILE *fp , Membership_list mlist ) 
{ 
  int i ;

  {
  {
#line 692
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu", (unsigned long )mlist.no_of_confs);
  }
#line 694
  if ((unsigned long )mlist.confs != (unsigned long )((void *)0)) {
#line 694
    if ((int )mlist.no_of_confs > 0) {
      {
#line 696
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" {");
#line 697
      i = 0;
      }
      {
#line 697
      while (1) {
        while_continue: /* CIL Label */ ;
#line 697
        if (! (i < (int )mlist.no_of_confs)) {
#line 697
          goto while_break;
        }
        {
#line 698
        foutput_membership_2(fp, mlist.confs + i);
#line 697
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 699
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" }");
      }
    } else {
      {
#line 702
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
      }
    }
  } else {
    {
#line 702
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
    }
  }
#line 703
  return;
}
}
#line 705 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_membership_list(FILE *fp , Membership_list mlist ) 
{ 


  {
  {
#line 712
  if (output_format == 1) {
#line 712
    goto case_1;
  }
#line 712
  if (output_format == 0) {
#line 712
    goto case_1;
  }
#line 715
  if (output_format == 2) {
#line 715
    goto case_2;
  }
#line 718
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 713
  foutput_membership_list_0(fp, mlist);
  }
#line 714
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 716
  foutput_membership_list_2(fp, mlist);
  }
#line 717
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 719
  restart_kom("unknown database format: %d", output_format);
  }
#line 720
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 722
  return;
}
}
#line 724 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_time(FILE *fp , time_t clk ) 
{ 


  {
  {
#line 728
  foutput_ulong((unsigned long )clk, fp);
  }
#line 729
  return;
}
}
#line 732 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_member_list(FILE *fp , Member_list m_list ) 
{ 
  int i ;

  {
  {
#line 738
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu", (unsigned long )m_list.no_of_members);
  }
#line 739
  if ((unsigned long )m_list.members != (unsigned long )((void *)0)) {
#line 739
    if ((int )m_list.no_of_members > 0) {
      {
#line 741
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" {");
#line 742
      i = 0;
      }
      {
#line 742
      while (1) {
        while_continue: /* CIL Label */ ;
#line 742
        if (! (i < (int )m_list.no_of_members)) {
#line 742
          goto while_break;
        }
        {
#line 743
        foutput_member(fp, *(m_list.members + i));
#line 742
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 744
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" }");
      }
    } else {
      {
#line 747
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
      }
    }
  } else {
    {
#line 747
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
    }
  }
#line 748
  return;
}
}
#line 751 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_member_0(FILE *fp , Member member ) 
{ 


  {
  {
#line 755
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu", (unsigned long )member.member);
  }
#line 756
  return;
}
}
#line 758 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_member_2(FILE *fp , Member member ) 
{ 


  {
  {
#line 762
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu",
          (unsigned long )member.member, (unsigned long )member.added_by);
#line 765
  foutput_time(fp, member.added_at);
#line 766
  foutput_membership_type(fp, member.type);
  }
#line 767
  return;
}
}
#line 769 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_member(FILE *fp , Member member ) 
{ 


  {
  {
#line 776
  if (output_format == 1) {
#line 776
    goto case_1;
  }
#line 776
  if (output_format == 0) {
#line 776
    goto case_1;
  }
#line 779
  if (output_format == 2) {
#line 779
    goto case_2;
  }
#line 782
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 777
  foutput_member_0(fp, member);
  }
#line 778
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 780
  foutput_member_2(fp, member);
  }
#line 781
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 783
  restart_kom("unknown database format: %d", output_format);
  }
#line 784
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 786
  return;
}
}
#line 788 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_conf_type_1(FILE *fp , Conf_type type ) 
{ 


  {
  {
#line 792
  _IO_putc(' ', fp);
#line 793
  _IO_putc((int )(type.rd_prot + 48U), fp);
#line 794
  _IO_putc((int )(type.original + 48U), fp);
#line 795
  _IO_putc((int )(type.secret + 48U), fp);
#line 796
  _IO_putc((int )(type.letter_box + 48U), fp);
#line 797
  _IO_putc((int )(type.allow_anon + 48U), fp);
#line 798
  _IO_putc((int )(type.forbid_secret + 48U), fp);
#line 799
  _IO_putc((int )(type.reserved2 + 48U), fp);
#line 800
  _IO_putc((int )(type.reserved3 + 48U), fp);
  }
#line 801
  return;
}
}
#line 803 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_conf_type_0(FILE *fp , Conf_type type ) 
{ 


  {
  {
#line 807
  _IO_putc(' ', fp);
#line 808
  _IO_putc((int )(type.rd_prot + 48U), fp);
#line 809
  _IO_putc((int )(type.original + 48U), fp);
#line 810
  _IO_putc((int )(type.secret + 48U), fp);
#line 811
  _IO_putc((int )(type.letter_box + 48U), fp);
  }
#line 812
  return;
}
}
#line 814 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_conf_type(FILE *fp , Conf_type type ) 
{ 


  {
  {
#line 820
  if (output_format == 0) {
#line 820
    goto case_0;
  }
#line 824
  if (output_format == 2) {
#line 824
    goto case_2;
  }
#line 824
  if (output_format == 1) {
#line 824
    goto case_2;
  }
#line 827
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 821
  foutput_conf_type_0(fp, type);
  }
#line 822
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 825
  foutput_conf_type_1(fp, type);
  }
#line 826
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 828
  restart_kom("unknown database format: %d", output_format);
  }
#line 829
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 831
  return;
}
}
#line 834 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_misc_info(FILE *fp , Misc_info misc ) 
{ 


  {
  {
#line 838
  foutput_ulong((unsigned long )misc.type, fp);
  }
  {
#line 844
  if ((unsigned int )misc.type == 15U) {
#line 844
    goto case_15;
  }
#line 844
  if ((unsigned int )misc.type == 1U) {
#line 844
    goto case_15;
  }
#line 844
  if ((unsigned int )misc.type == 0U) {
#line 844
    goto case_15;
  }
#line 848
  if ((unsigned int )misc.type == 6U) {
#line 848
    goto case_6;
  }
#line 852
  if ((unsigned int )misc.type == 7U) {
#line 852
    goto case_7;
  }
#line 859
  if ((unsigned int )misc.type == 5U) {
#line 859
    goto case_5;
  }
#line 859
  if ((unsigned int )misc.type == 4U) {
#line 859
    goto case_5;
  }
#line 859
  if ((unsigned int )misc.type == 3U) {
#line 859
    goto case_5;
  }
#line 859
  if ((unsigned int )misc.type == 2U) {
#line 859
    goto case_5;
  }
#line 863
  if ((unsigned int )misc.type == 8U) {
#line 863
    goto case_8;
  }
#line 867
  if ((unsigned int )misc.type == 9U) {
#line 867
    goto case_9;
  }
#line 872
  goto switch_default;
  case_15: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 845
  foutput_ulong((unsigned long )misc.datum.recipient, fp);
  }
#line 846
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 849
  foutput_ulong(misc.datum.local_no, fp);
  }
#line 850
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 853
  foutput_time(fp, misc.datum.received_at);
  }
#line 854
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 860
  foutput_ulong(misc.datum.text_link, fp);
  }
#line 861
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 864
  foutput_ulong((unsigned long )misc.datum.sender, fp);
  }
#line 865
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 868
  foutput_time(fp, misc.datum.sent_at);
  }
#line 869
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 875
  restart_kom("prot_a_output_misc_info: Illegal misc\n");
  }
  switch_break: /* CIL Label */ ;
  }
#line 877
  return;
}
}
#line 889 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static char buf[25UL]  ;
#line 885 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_ulong(unsigned long l , FILE *fp ) 
{ 
  char *cp ;

  {
  {
#line 892
  _IO_putc(' ', fp);
  }
#line 893
  if (l < 10UL) {
    {
#line 894
    _IO_putc((int )*("0123456789" + l), fp);
    }
  } else {
#line 897
    cp = buf + sizeof(buf);
    {
#line 898
    while (1) {
      while_continue: /* CIL Label */ ;
#line 898
      if (! (l > 0UL)) {
#line 898
        goto while_break;
      }
#line 900
      cp --;
#line 900
      *cp = (char )(l % 10UL + 48UL);
#line 901
      l /= 10UL;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 903
    fwrite((void const   */* __restrict  */)cp, (size_t )((buf + sizeof(buf)) - cp),
           (size_t )1, (FILE */* __restrict  */)fp);
    }
  }
#line 905
  return;
}
}
#line 425 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 755 "/usr/include/stdlib.h"
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 956 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 31 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.h"
extern unsigned long fparse_long(FILE *fp ) ;
#line 34
void fskipwhite(FILE *fp ) ;
#line 40
extern Success fparse_info(FILE *fp , Info *info ) ;
#line 44
extern Success fparse_conference(FILE *fp , Conference *result ) ;
#line 49
extern Success fparse_person(FILE *fp , Person *result ) ;
#line 69
extern Success fparse_text_stat(FILE *fp , Text_stat *result ) ;
#line 139
void set_input_format(int fmt ) ;
#line 30 "../libraries/libeintr/eintr.h"
extern int i_rename(char const   * , char const   * ) ;
#line 26 "./../libraries/libmisc/timeval-util.h"
extern Bool timeval_zero(struct timeval t ) ;
#line 34
extern Bool timeval_remaining(struct timeval *remaining , struct timeval wanted_interval ,
                              struct timeval start , struct timeval now ) ;
#line 39
extern Bool timeval_greater(struct timeval a , struct timeval b ) ;
#line 725 "./../include/services.h"
Success get_boottime_info(Static_server_info *result ) ;
#line 109 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Small_conf **small_conf_arr  ;
#line 110 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Cache_node_mcb *pers_mcb  ;
#line 111 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Cache_node_mcb *conf_mcb  ;
#line 112 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Conf_no next_free_num  =    (Conf_no )1;
#line 114 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Cache_node_mcb *text_mcb  ;
#line 115 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Text_no next_text_num  =    (Text_no )1;
#line 121 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static int no_of_match_info  ;
#line 122 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
struct matching_info *match_table  =    (struct matching_info *)((void *)0);
#line 124 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static FILE *text_file  =    (FILE *)((void *)0);
#line 125 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static FILE *file_a  =    (FILE *)((void *)0);
#line 126 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static FILE *file_b  =    (FILE *)((void *)0);
#line 134 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static enum __anonenum_sync_state_88 sync_state  ;
#line 165 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static unsigned long sync_next  ;
#line 168 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Conf_no highest_conf_no  =    (Conf_no )0;
#line 169 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Text_no highest_text_no  =    (Text_no )0;
#line 233 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Static_server_info boottime_info  = 
#line 233
     {(time_t )0, (time_t )0, {(String_size )0, (unsigned char *)((void *)0)}, (Text_no )0,
    (Text_no )0, (Conf_no )0, (Conf_no )0, (Conf_no )0};
#line 240
static Success build_matching_info(void) ;
#line 241
static Success rebuild_matching_info_entry(Conf_no conf_no ) ;
#line 242
static Matching_info *find_matching_info(Conf_no conf_no ) ;
#line 254 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Person *read_person(FILE *fp , long pos , long qazwsxedcsize  __attribute__((__unused__)) ) 
{ 
  Person *p ;
  long dummy ;
  unsigned long tmp ;
  Success tmp___0 ;

  {
  {
#line 262
  p = alloc_person();
#line 263
  fseek(fp, pos + 1L, 0);
#line 264
  tmp = fparse_long(fp);
#line 264
  dummy = (long )tmp;
#line 265
  tmp___0 = fparse_person(fp, p);
  }
#line 265
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 267
    free_person(p);
    }
#line 268
    return ((Person *)((void *)0));
  } else {
#line 271
    return (p);
  }
}
}
#line 276 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Conference *read_conference(FILE *fp , long pos , long qazwsxedcsize  __attribute__((__unused__)) ) 
{ 
  Conference *c ;
  long dummy ;
  unsigned long tmp ;
  Success tmp___0 ;

  {
  {
#line 284
  c = alloc_conference();
#line 285
  fseek(fp, pos + 1L, 0);
#line 286
  tmp = fparse_long(fp);
#line 286
  dummy = (long )tmp;
#line 287
  tmp___0 = fparse_conference(fp, c);
  }
#line 287
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 289
    free_conference(c);
    }
#line 290
    return ((Conference *)((void *)0));
  } else {
#line 293
    return (c);
  }
}
}
#line 297 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Text_stat *read_text_stat(FILE *fp , long pos , long qazwsxedcsize  __attribute__((__unused__)) ) 
{ 
  Text_stat *t ;
  long dummy ;
  unsigned long tmp ;
  Success tmp___0 ;

  {
  {
#line 305
  t = alloc_text_stat();
#line 306
  fseek(fp, pos + 1L, 0);
#line 307
  tmp = fparse_long(fp);
#line 307
  dummy = (long )tmp;
#line 308
  tmp___0 = fparse_text_stat(fp, t);
  }
#line 308
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 310
    free_text_stat(t);
    }
#line 311
    return ((Text_stat *)((void *)0));
  } else {
#line 314
    return (t);
  }
}
}
#line 317 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void pers_set_mru(Pers_no pers_no ) 
{ 


  {
  {
#line 320
  set_mru(pers_mcb, (unsigned long )pers_no);
  }
#line 321
  return;
}
}
#line 323 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void text_set_mru(Text_no text_no ) 
{ 


  {
  {
#line 326
  set_mru(text_mcb, text_no);
  }
#line 327
  return;
}
}
#line 329 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void conf_set_mru(Conf_no conf_no ) 
{ 


  {
  {
#line 332
  set_mru(conf_mcb, (unsigned long )conf_no);
  }
#line 333
  return;
}
}
#line 335 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Cache_node *get_pers_node(Pers_no pers_no ) 
{ 
  Cache_node *tmp ;

  {
#line 338
  if ((int )pers_no >= (int )next_free_num) {
#line 339
    return ((Cache_node *)((void *)0));
  } else
#line 338
  if ((int )pers_no < 1) {
#line 339
    return ((Cache_node *)((void *)0));
  }
  {
#line 341
  tmp = get_cache_node(pers_mcb, (unsigned long )pers_no);
  }
#line 341
  return (tmp);
}
}
#line 344 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void unlink_text_lru(Cache_node *node ) 
{ 


  {
  {
#line 347
  unlink_lru(node, & text_mcb->lru, & text_mcb->mru);
  }
#line 348
  return;
}
}
#line 350 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void unlink_conf_lru(Cache_node *node ) 
{ 


  {
  {
#line 353
  unlink_lru(node, & conf_mcb->lru, & conf_mcb->mru);
  }
#line 354
  return;
}
}
#line 356 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void unlink_pers_lru(Cache_node *node ) 
{ 


  {
  {
#line 359
  unlink_lru(node, & pers_mcb->lru, & pers_mcb->mru);
  }
#line 360
  return;
}
}
#line 362 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Cache_node *get_conf_node(Conf_no conf_no ) 
{ 
  Cache_node *tmp ;

  {
#line 365
  if ((int )conf_no >= (int )next_free_num) {
#line 366
    return ((Cache_node *)((void *)0));
  } else
#line 365
  if ((int )conf_no < 1) {
#line 366
    return ((Cache_node *)((void *)0));
  }
  {
#line 368
  tmp = get_cache_node(conf_mcb, (unsigned long )conf_no);
  }
#line 368
  return (tmp);
}
}
#line 371 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Cache_node *get_text_node(Text_no text_no ) 
{ 
  Cache_node *tmp ;

  {
#line 374
  if (text_no >= next_text_num) {
#line 375
    return ((Cache_node *)((void *)0));
  } else
#line 374
  if (text_no < 1UL) {
#line 375
    return ((Cache_node *)((void *)0));
  }
  {
#line 377
  tmp = get_cache_node(text_mcb, text_no);
  }
#line 377
  return (tmp);
}
}
#line 389 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
void cached_change_name(Conf_no name_num , String new_name ) 
{ 


  {
#line 393
  if ((int )name_num < 1) {
    {
#line 394
    restart_kom("cached_change_name(%d, ----): next_free_num==%d\n", (int )name_num,
                (int )next_free_num);
    }
  } else
#line 393
  if ((int )name_num >= (int )next_free_num) {
    {
#line 394
    restart_kom("cached_change_name(%d, ----): next_free_num==%d\n", (int )name_num,
                (int )next_free_num);
    }
  }
  {
#line 397
  s_clear(& (*(small_conf_arr + name_num))->name);
#line 398
  s_strcpy(& (*(small_conf_arr + name_num))->name, (String const   )new_name);
#line 399
  rebuild_matching_info_entry(name_num);
  }
#line 400
  return;
}
}
#line 403 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Conf_type cached_get_conf_type(Conf_no conf_no ) 
{ 


  {
#line 406
  if ((int )conf_no < 1) {
    {
#line 407
    restart_kom("cached_get_conf_type(%d): next_free_num==%d", (int )conf_no, (int )next_free_num);
    }
  } else
#line 406
  if ((int )conf_no >= (int )next_free_num) {
    {
#line 407
    restart_kom("cached_get_conf_type(%d): next_free_num==%d", (int )conf_no, (int )next_free_num);
    }
  }
#line 410
  if ((unsigned long )*(small_conf_arr + conf_no) == (unsigned long )((void *)0)) {
    {
#line 411
    restart_kom("cached_get_conf_type(%d): conference does not exist.\n", (int )conf_no);
    }
  }
#line 416
  return ((*(small_conf_arr + conf_no))->type);
}
}
#line 419 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Conf_no cached_get_conf_supervisor(Conf_no conf_no ) 
{ 


  {
#line 422
  if ((int )conf_no < 1) {
    {
#line 423
    restart_kom("cached_get_conf_supervisor(%d): next_free_num==%d\n", (int )conf_no,
                (int )next_free_num);
    }
  } else
#line 422
  if ((int )conf_no >= (int )next_free_num) {
    {
#line 423
    restart_kom("cached_get_conf_supervisor(%d): next_free_num==%d\n", (int )conf_no,
                (int )next_free_num);
    }
  }
#line 426
  if ((unsigned long )*(small_conf_arr + conf_no) == (unsigned long )((void *)0)) {
    {
#line 427
    restart_kom("cached_get_conf_supervisor(%d): conference does not exist.\n", (int )conf_no);
    }
  }
#line 432
  return ((*(small_conf_arr + conf_no))->supervisor);
}
}
#line 439 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Conf_no cached_no_of_existing_conferences(void) 
{ 


  {
#line 442
  return (next_free_num);
}
}
#line 454 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
void mark_person_as_changed(Pers_no pers_no ) 
{ 
  Cache_node *node ;

  {
  {
#line 459
  node = get_pers_node(pers_no);
  }
#line 461
  if (buglevel > 2) {
    {
#line 461
    printf((char const   */* __restrict  */)"Person %d is changed\n", (int )pers_no);
    }
  }
#line 462
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 463
    restart_kom("mark_person_as_changed(%d): nonexistent.\n", (int )pers_no);
    }
  } else
#line 462
  if (node->s.exists == 0U) {
    {
#line 463
    restart_kom("mark_person_as_changed(%d): nonexistent.\n", (int )pers_no);
    }
  }
  {
#line 465
  node->s.dirty = 1U;
#line 466
  pers_set_mru(pers_no);
  }
#line 467
  return;
}
}
#line 481 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
void mark_conference_as_changed(Conf_no conf_no ) 
{ 
  Cache_node *node ;
  Conference *conf_c ;
  Local_text_no tmp ;

  {
  {
#line 487
  node = get_conf_node(conf_no);
  }
#line 489
  if (buglevel > 2) {
    {
#line 489
    printf((char const   */* __restrict  */)"Conf.  %d is changed\n", (int )conf_no);
    }
  }
#line 490
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 491
    restart_kom("mark_conference_as_changed(%d): nonexistent.\n", (int )conf_no);
    }
  } else
#line 490
  if (node->s.exists == 0U) {
    {
#line 491
    restart_kom("mark_conference_as_changed(%d): nonexistent.\n", (int )conf_no);
    }
  }
  {
#line 493
  node->s.dirty = 1U;
#line 494
  conf_set_mru(conf_no);
#line 496
  conf_c = (Conference *)node->ptr;
#line 498
  tmp = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
#line 498
  (*(small_conf_arr + conf_no))->highest_local_no = tmp - 1UL;
#line 501
  (*(small_conf_arr + conf_no))->nice = conf_c->nice;
#line 502
  (*(small_conf_arr + conf_no))->keep_commented = conf_c->keep_commented;
#line 503
  (*(small_conf_arr + conf_no))->type = conf_c->type;
#line 504
  (*(small_conf_arr + conf_no))->supervisor = conf_c->supervisor;
  }
#line 505
  return;
}
}
#line 507 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
void mark_text_as_changed(Text_no text_no ) 
{ 
  Cache_node *node ;

  {
  {
#line 512
  node = get_text_node(text_no);
  }
#line 514
  if (buglevel > 2) {
    {
#line 514
    printf((char const   */* __restrict  */)"Text %lu is changed.\n", text_no);
    }
  }
#line 515
  if (text_no < 1UL) {
    {
#line 518
    restart_kom("mark_text_as_changed(%lu): nonexistent.\n", text_no);
    }
  } else
#line 515
  if (text_no >= next_text_num) {
    {
#line 518
    restart_kom("mark_text_as_changed(%lu): nonexistent.\n", text_no);
    }
  } else
#line 515
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 518
    restart_kom("mark_text_as_changed(%lu): nonexistent.\n", text_no);
    }
  } else
#line 515
  if (node->s.exists == 0U) {
    {
#line 518
    restart_kom("mark_text_as_changed(%lu): nonexistent.\n", text_no);
    }
  }
  {
#line 521
  node->s.dirty = 1U;
#line 522
  text_set_mru(text_no);
  }
#line 523
  return;
}
}
#line 530 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static int write_number_file(void) 
{ 
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 535
  fp = i_fopen((char const   *)param.numberfile_tmp_name, "w");
  }
#line 535
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 537
    tmp = __errno_location();
#line 537
    tmp___0 = strerror(*tmp);
#line 537
    kom_log("opening %s: %s\n", param.numberfile_tmp_name, tmp___0);
    }
#line 539
    return (-1);
  }
  {
#line 541
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Text_no: %lu Conf_no: %lu End.\n",
          next_text_num, (unsigned long )next_free_num);
#line 544
  tmp___1 = fflush(fp);
  }
#line 544
  if (tmp___1 != 0) {
    {
#line 546
    kom_log("fflush to %s failed\n", param.numberfile_tmp_name);
#line 547
    i_fclose(fp);
    }
#line 548
    return (-1);
  }
  {
#line 551
  tmp___2 = ferror(fp);
  }
#line 551
  if (tmp___2 != 0) {
    {
#line 553
    kom_log("fprintf to %s failed\n", param.numberfile_tmp_name);
#line 554
    i_fclose(fp);
    }
#line 555
    return (-1);
  }
  {
#line 558
  tmp___3 = i_fclose(fp);
  }
#line 558
  if (tmp___3 != 0) {
    {
#line 560
    kom_log("fclose %s failed\n", param.numberfile_tmp_name);
    }
#line 561
    return (-1);
  }
  {
#line 564
  tmp___6 = i_rename((char const   *)param.numberfile_tmp_name, (char const   *)param.numberfile_name);
  }
#line 564
  if (tmp___6 != 0) {
    {
#line 566
    tmp___4 = __errno_location();
#line 566
    tmp___5 = strerror(*tmp___4);
#line 566
    kom_log("failed to rename %s to %s: %s\n", param.numberfile_tmp_name, param.numberfile_name,
            tmp___5);
    }
#line 569
    return (-1);
  }
#line 571
  return (0);
}
}
#line 574 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void read_number_file(void) 
{ 
  FILE *fp ;
  unsigned long txt ;
  unsigned long cno ;
  Text_no text_no ;
  Conf_no conf_no ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 578
  txt = 0UL;
#line 579
  cno = 0UL;
#line 583
  fp = i_fopen((char const   *)param.numberfile_name, "r");
  }
#line 583
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 585
    tmp___1 = __errno_location();
    }
#line 585
    if (*tmp___1 == 2) {
      {
#line 586
      kom_log("WARN: %s: No such file\n", param.numberfile_name);
      }
    } else {
      {
#line 588
      tmp = __errno_location();
#line 588
      tmp___0 = strerror(*tmp);
#line 588
      restart_kom("opening %s: %s\n", param.numberfile_name, tmp___0);
      }
    }
#line 590
    return;
  }
  {
#line 592
  tmp___2 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Text_no: %lu Conf_no: %lu",
                   & txt, & cno);
  }
#line 592
  if (tmp___2 != 2) {
    {
#line 596
    kom_log("WARN: %s: broken file (ignored)\n", param.numberfile_name);
#line 597
    i_fclose(fp);
    }
#line 598
    return;
  } else {
    {
#line 592
    tmp___3 = _IO_getc(fp);
    }
#line 592
    if (tmp___3 != 32) {
      {
#line 596
      kom_log("WARN: %s: broken file (ignored)\n", param.numberfile_name);
#line 597
      i_fclose(fp);
      }
#line 598
      return;
    } else {
      {
#line 592
      tmp___4 = _IO_getc(fp);
      }
#line 592
      if (tmp___4 != 69) {
        {
#line 596
        kom_log("WARN: %s: broken file (ignored)\n", param.numberfile_name);
#line 597
        i_fclose(fp);
        }
#line 598
        return;
      } else {
        {
#line 592
        tmp___5 = _IO_getc(fp);
        }
#line 592
        if (tmp___5 != 110) {
          {
#line 596
          kom_log("WARN: %s: broken file (ignored)\n", param.numberfile_name);
#line 597
          i_fclose(fp);
          }
#line 598
          return;
        } else {
          {
#line 592
          tmp___6 = _IO_getc(fp);
          }
#line 592
          if (tmp___6 != 100) {
            {
#line 596
            kom_log("WARN: %s: broken file (ignored)\n", param.numberfile_name);
#line 597
            i_fclose(fp);
            }
#line 598
            return;
          } else {
            {
#line 592
            tmp___7 = _IO_getc(fp);
            }
#line 592
            if (tmp___7 != 46) {
              {
#line 596
              kom_log("WARN: %s: broken file (ignored)\n", param.numberfile_name);
#line 597
              i_fclose(fp);
              }
#line 598
              return;
            }
          }
        }
      }
    }
  }
  {
#line 600
  i_fclose(fp);
#line 602
  text_no = txt;
#line 603
  conf_no = (Conf_no )cno;
  }
#line 605
  if (text_no > next_text_num) {
    {
#line 607
    kom_log("WARN: Texts %lu - %lu were lost.\n", next_text_num, text_no - 1UL);
#line 610
    next_text_num = text_no;
    }
  }
#line 612
  if ((int )conf_no > (int )next_free_num) {
    {
#line 614
    kom_log("WARN: Confs %lu - %lu were lost.\n", (unsigned long )next_free_num, (unsigned long )conf_no - 1UL);
#line 617
    next_free_num = conf_no;
    }
  }
#line 619
  return;
}
}
#line 626 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Success cached_create_person(Pers_no person ) 
{ 
  Cache_node *node ;
  Cache_node *tmp ;
  Person *tmp___0 ;

  {
#line 631
  if (buglevel > 2) {
    {
#line 631
    printf((char const   */* __restrict  */)"Person %d is being created.\n", (int )person);
    }
  }
#line 633
  if ((int )person < 1) {
    {
#line 635
    restart_kom("cached_create_person(%d): next_free_num == %d.\n", (int )person,
                (int )next_free_num);
    }
  } else
#line 633
  if ((int )person >= (int )next_free_num) {
    {
#line 635
    restart_kom("cached_create_person(%d): next_free_num == %d.\n", (int )person,
                (int )next_free_num);
    }
  }
  {
#line 639
  tmp = get_pers_node(person);
  }
#line 639
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    {
#line 641
    restart_kom("cached_create_person(%d): Person existed.\n", (int )person);
    }
  }
  {
#line 645
  create_cache_node(pers_mcb, (unsigned long )person);
#line 646
  node = get_pers_node(person);
  }
#line 648
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 649
    restart_kom("cached_create_person(): couldn\'t get cache_node.\n");
    }
  }
  {
#line 651
  tmp___0 = alloc_person();
#line 651
  node->ptr = (void *)tmp___0;
#line 652
  node->s.dirty = 1U;
#line 653
  node->s.exists = 1U;
#line 654
  pers_set_mru(person);
  }
#line 658
  return ((Success )OK);
}
}
#line 662 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Person *cached_get_person_stat(Pers_no person ) 
{ 
  Cache_node *node ;
  Person *tmp ;
  Person *tmp___0 ;

  {
#line 667
  if (buglevel > 2) {
    {
#line 667
    printf((char const   */* __restrict  */)"cached_get_person_stat %d\n", (int )person);
    }
  }
#line 669
  if ((int )person == 0) {
#line 671
    err_stat = 0UL;
#line 672
    kom_errno = (enum kom_err )8;
#line 673
    return ((Person *)((void *)0));
  }
#line 676
  if ((int )person >= (int )next_free_num) {
#line 678
    err_stat = (unsigned long )person;
#line 679
    kom_errno = (enum kom_err )10;
#line 680
    return ((Person *)((void *)0));
  }
  {
#line 683
  node = get_pers_node(person);
  }
#line 685
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 687
    err_stat = (unsigned long )person;
#line 688
    kom_errno = (enum kom_err )10;
#line 689
    return ((Person *)((void *)0));
  } else
#line 685
  if (node->s.exists == 0U) {
#line 687
    err_stat = (unsigned long )person;
#line 688
    kom_errno = (enum kom_err )10;
#line 689
    return ((Person *)((void *)0));
  }
#line 694
  if ((unsigned long )node->ptr != (unsigned long )((void *)0)) {
    {
#line 696
    pers_set_mru(person);
#line 697
    (pers_mcb->hits) ++;
    }
#line 698
    return ((Person *)node->ptr);
  }
#line 701
  if ((unsigned long )node->snap_shot != (unsigned long )((void *)0)) {
    {
#line 703
    tmp = copy_person((Person const   *)node->snap_shot);
#line 703
    node->ptr = (void *)tmp;
#line 704
    pers_set_mru(person);
#line 705
    (pers_mcb->hits) ++;
    }
#line 706
    return ((Person *)node->ptr);
  }
  {
#line 709
  tmp___0 = read_person(file_a, node->pos, node->size);
#line 709
  node->ptr = (void *)tmp___0;
#line 711
  (pers_mcb->misses) ++;
#line 712
  pers_set_mru(person);
  }
#line 713
  return ((Person *)node->ptr);
}
}
#line 722 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static int no_of_allocated_small_confs  =    0;
#line 724 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void free_small_conf(Small_conf *sc ) 
{ 


  {
#line 727
  if ((unsigned long )sc != (unsigned long )((void *)0)) {
    {
#line 729
    no_of_allocated_small_confs --;
#line 730
    s_clear(& sc->name);
#line 731
    sfree((void *)sc);
    }
  }
#line 733
  return;
}
}
#line 736 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void init_small_conf(Small_conf *sc ) 
{ 


  {
  {
#line 739
  sc->name = (String )EMPTY_STRING;
#line 740
  init_conf_type(& sc->type);
#line 741
  sc->supervisor = (Conf_no )0;
#line 742
  sc->highest_local_no = (Local_text_no )0;
#line 743
  sc->nice = (Garb_nice )param.default_nice;
#line 744
  sc->keep_commented = (Garb_nice )param.default_keep_commented;
  }
#line 745
  return;
}
}
#line 747 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Small_conf *alloc_small_conf(void) 
{ 
  Small_conf *s ;
  void *tmp ;

  {
  {
#line 751
  tmp = smalloc(sizeof(Small_conf ));
#line 751
  s = (Small_conf *)tmp;
#line 752
  init_small_conf(s);
#line 753
  no_of_allocated_small_confs ++;
  }
#line 755
  return (s);
}
}
#line 764 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Conf_no cached_create_conf(String name___0 ) 
{ 
  Conference *conf_c ;
  Conf_no conf_no ;
  Cache_node *node ;
  Conf_no tmp ;
  int tmp___0 ;

  {
#line 771
  if (buglevel > 2) {
    {
#line 771
    printf((char const   */* __restrict  */)"cached_create_conf( ");
    }
  }
#line 772
  if (buglevel > 2) {
    {
#line 772
    s_fputs(stdout, (String const   )name___0);
    }
  }
#line 773
  if (buglevel > 2) {
    {
#line 773
    printf((char const   */* __restrict  */)" )\n");
    }
  }
#line 775
  if ((unsigned long )next_free_num >= param.max_conf) {
#line 777
    err_stat = (unsigned long )next_free_num;
#line 778
    kom_errno = (enum kom_err )19;
#line 779
    return ((Conf_no )0);
  }
  {
#line 782
  tmp = next_free_num;
#line 782
  next_free_num = (Conf_no )((int )next_free_num + 1);
#line 782
  conf_no = tmp;
#line 784
  tmp___0 = write_number_file();
  }
#line 784
  if (tmp___0 < 0) {
#line 786
    next_free_num = (Conf_no )((int )next_free_num - 1);
#line 787
    err_stat = 0UL;
#line 788
    kom_errno = (enum kom_err )45;
#line 789
    return ((Conf_no )0);
  }
  {
#line 792
  create_cache_node(conf_mcb, (unsigned long )conf_no);
#line 793
  node = get_conf_node(conf_no);
  }
#line 795
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 796
    restart_kom("cached_create_conf(): failed to allocate cache_node.\n");
    }
  }
  {
#line 798
  node->s.exists = 1U;
#line 799
  node->s.dirty = 1U;
#line 800
  conf_c = alloc_conference();
#line 800
  node->ptr = (void *)conf_c;
#line 801
  conf_set_mru(conf_no);
#line 803
  zero_init_cache_node(pers_mcb, (unsigned long )conf_no);
#line 804
  *(small_conf_arr + conf_no) = alloc_small_conf();
#line 806
  conf_c->name = (String )EMPTY_STRING;
#line 807
  s_strcpy(& conf_c->name, (String const   )name___0);
#line 808
  cached_change_name(conf_no, name___0);
  }
#line 810
  if (buglevel > 2) {
    {
#line 810
    printf((char const   */* __restrict  */)"Created conference number %d\n", (int )conf_no);
    }
  }
#line 814
  return (conf_no);
}
}
#line 818 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Success cached_delete_conf(Conf_no conf ) 
{ 
  Cache_node *node ;

  {
#line 823
  if ((int )conf == 0) {
#line 825
    err_stat = (unsigned long )conf;
#line 826
    kom_errno = (enum kom_err )8;
#line 827
    return ((Success )FAILURE);
  }
#line 830
  if ((int )conf >= (int )next_free_num) {
#line 832
    err_stat = (unsigned long )conf;
#line 833
    kom_errno = (enum kom_err )9;
#line 834
    return ((Success )FAILURE);
  }
  {
#line 837
  node = get_conf_node(conf);
  }
#line 839
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 841
    err_stat = (unsigned long )conf;
#line 842
    kom_errno = (enum kom_err )9;
#line 843
    return ((Success )FAILURE);
  } else
#line 839
  if (node->s.exists == 0U) {
#line 841
    err_stat = (unsigned long )conf;
#line 842
    kom_errno = (enum kom_err )9;
#line 843
    return ((Success )FAILURE);
  }
#line 846
  if (node->lock_cnt > 0) {
    {
#line 847
    kom_log("WNG: cached_delete_conf(%d): lock_cnt === %d\n", (int )conf, node->lock_cnt);
    }
  }
  {
#line 850
  free_small_conf(*(small_conf_arr + conf));
#line 851
  *(small_conf_arr + conf) = (Small_conf *)((void *)0);
#line 853
  free_conference((Conference *)node->ptr);
#line 854
  node->ptr = (void *)0;
#line 855
  node->s.exists = 0U;
#line 859
  rebuild_matching_info_entry(conf);
  }
#line 860
  return ((Success )OK);
}
}
#line 863 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
Success cached_delete_person(Pers_no pers ) 
{ 
  Cache_node *node ;

  {
#line 868
  if ((int )pers == 0) {
#line 870
    err_stat = (unsigned long )pers;
#line 871
    kom_errno = (enum kom_err )8;
#line 872
    return ((Success )FAILURE);
  }
#line 875
  if ((int )pers >= (int )next_free_num) {
    {
#line 877
    kom_log("cached_delete_person(%lu): next_free_num == %lu\n", (unsigned long )pers,
            (unsigned long )next_free_num);
#line 879
    err_stat = (unsigned long )pers;
#line 880
    kom_errno = (enum kom_err )10;
    }
#line 881
    return ((Success )FAILURE);
  }
  {
#line 884
  node = get_pers_node(pers);
  }
#line 886
  if ((int )pers >= (int )next_free_num) {
    {
#line 888
    kom_log("cached_delete_person(): attempt to delete void person.\n");
#line 889
    err_stat = (unsigned long )pers;
#line 890
    kom_errno = (enum kom_err )10;
    }
#line 891
    return ((Success )FAILURE);
  } else
#line 886
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 888
    kom_log("cached_delete_person(): attempt to delete void person.\n");
#line 889
    err_stat = (unsigned long )pers;
#line 890
    kom_errno = (enum kom_err )10;
    }
#line 891
    return ((Success )FAILURE);
  } else
#line 886
  if (node->s.exists == 0U) {
    {
#line 888
    kom_log("cached_delete_person(): attempt to delete void person.\n");
#line 889
    err_stat = (unsigned long )pers;
#line 890
    kom_errno = (enum kom_err )10;
    }
#line 891
    return ((Success )FAILURE);
  }
#line 894
  if (node->lock_cnt > 0) {
    {
#line 895
    kom_log("cached_delete_pers(%lu): lock_cnt === %lu\n", (unsigned long )pers, (unsigned long )node->lock_cnt);
    }
  }
  {
#line 900
  free_person((Person *)node->ptr);
#line 901
  node->ptr = (void *)0;
#line 902
  node->s.exists = 0U;
  }
#line 903
  return ((Success )OK);
}
}
#line 906 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
Success cached_delete_text(Text_no text ) 
{ 
  Cache_node *node ;

  {
#line 911
  if (text == 0UL) {
#line 913
    err_stat = text;
#line 914
    kom_errno = (enum kom_err )15;
#line 915
    return ((Success )FAILURE);
  }
  {
#line 918
  node = get_text_node(text);
  }
#line 920
  if (text >= next_text_num) {
    {
#line 923
    kom_log("cached_delete_text(): attempt to delete void text %lu.\n", text);
#line 924
    err_stat = text;
#line 925
    kom_errno = (enum kom_err )14;
    }
#line 926
    return ((Success )FAILURE);
  } else
#line 920
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 923
    kom_log("cached_delete_text(): attempt to delete void text %lu.\n", text);
#line 924
    err_stat = text;
#line 925
    kom_errno = (enum kom_err )14;
    }
#line 926
    return ((Success )FAILURE);
  } else
#line 920
  if (node->s.exists == 0U) {
    {
#line 923
    kom_log("cached_delete_text(): attempt to delete void text %lu.\n", text);
#line 924
    err_stat = text;
#line 925
    kom_errno = (enum kom_err )14;
    }
#line 926
    return ((Success )FAILURE);
  }
#line 929
  if (node->lock_cnt > 0) {
    {
#line 930
    kom_log("cached_delete_text(%lu): lock_cnt === %d\n", text, node->lock_cnt);
    }
  }
  {
#line 934
  free_text_stat((Text_stat *)node->ptr);
#line 935
  node->ptr = (void *)0;
#line 936
  node->s.exists = 0U;
  }
#line 946
  return ((Success )OK);
}
}
#line 950 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Conference *cached_get_conf_stat(Conf_no conf_no ) 
{ 
  Cache_node *node ;
  Conference *tmp ;
  Conference *tmp___0 ;

  {
#line 955
  if (buglevel > 2) {
    {
#line 955
    printf((char const   */* __restrict  */)"cached_get_conf_stat %d\n", (int )conf_no);
    }
  }
#line 957
  if ((int )conf_no == 0) {
#line 959
    err_stat = (unsigned long )conf_no;
#line 960
    kom_errno = (enum kom_err )8;
#line 961
    return ((Conference *)((void *)0));
  }
  {
#line 964
  node = get_conf_node(conf_no);
  }
#line 966
  if ((int )conf_no >= (int )next_free_num) {
#line 968
    err_stat = (unsigned long )conf_no;
#line 969
    kom_errno = (enum kom_err )9;
#line 970
    return ((Conference *)((void *)0));
  } else
#line 966
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 968
    err_stat = (unsigned long )conf_no;
#line 969
    kom_errno = (enum kom_err )9;
#line 970
    return ((Conference *)((void *)0));
  } else
#line 966
  if (node->s.exists == 0U) {
#line 968
    err_stat = (unsigned long )conf_no;
#line 969
    kom_errno = (enum kom_err )9;
#line 970
    return ((Conference *)((void *)0));
  }
#line 975
  if ((unsigned long )node->ptr != (unsigned long )((void *)0)) {
    {
#line 977
    conf_set_mru(conf_no);
#line 978
    (conf_mcb->hits) ++;
    }
#line 979
    return ((Conference *)node->ptr);
  }
#line 982
  if ((unsigned long )node->snap_shot != (unsigned long )((void *)0)) {
    {
#line 984
    tmp = copy_conference((Conference const   *)node->snap_shot);
#line 984
    node->ptr = (void *)tmp;
#line 985
    conf_set_mru(conf_no);
#line 986
    (conf_mcb->hits) ++;
    }
#line 987
    return ((Conference *)node->ptr);
  }
  {
#line 990
  tmp___0 = read_conference(file_a, node->pos, node->size);
#line 990
  node->ptr = (void *)tmp___0;
#line 991
  (conf_mcb->misses) ++;
#line 993
  conf_set_mru(conf_no);
  }
#line 994
  return ((Conference *)node->ptr);
}
}
#line 1000 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
Bool cached_conf_exists(Conf_no conf_no ) 
{ 
  int tmp ;

  {
#line 1003
  if ((int )conf_no == 0) {
#line 1004
    return ((Bool )0);
  } else
#line 1003
  if ((int )conf_no >= (int )next_free_num) {
#line 1004
    return ((Bool )0);
  }
#line 1006
  if ((unsigned long )*(small_conf_arr + conf_no) != (unsigned long )((void *)0)) {
#line 1006
    tmp = 1;
  } else {
#line 1006
    tmp = 0;
  }
#line 1006
  return ((Bool )tmp);
}
}
#line 1017 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern String cached_get_text(Text_no text ) 
{ 
  String the_string ;
  Text_stat *t_stat ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 1023
  if (buglevel > 2) {
    {
#line 1023
    printf((char const   */* __restrict  */)"cached_get_text %lu\n", text);
    }
  }
  {
#line 1025
  t_stat = cached_get_text_stat(text);
  }
#line 1025
  if ((unsigned long )t_stat == (unsigned long )((void *)0)) {
#line 1026
    return ((String )EMPTY_STRING);
  } else {
    {
#line 1030
    tmp = tmp_alloc((unsigned long )t_stat->no_of_chars);
#line 1030
    the_string.string = (unsigned char *)tmp;
#line 1031
    the_string.len = t_stat->no_of_chars;
#line 1032
    fseek(text_file, t_stat->file_pos, 0);
#line 1034
    tmp___0 = fread((void */* __restrict  */)the_string.string, sizeof(char ), (size_t )the_string.len,
                    (FILE */* __restrict  */)text_file);
    }
#line 1034
    if (tmp___0 != (size_t )the_string.len) {
      {
#line 1037
      kom_log("WARNING: cached_get_text: premature end on text %lu\n", text);
      }
#line 1039
      return ((String )EMPTY_STRING);
    }
#line 1042
    return (the_string);
  }
}
}
#line 1047 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Text_stat *cached_get_text_stat(Text_no text ) 
{ 
  Cache_node *node ;
  Text_stat *tmp ;
  Text_stat *tmp___0 ;

  {
#line 1052
  if (buglevel > 2) {
    {
#line 1052
    printf((char const   */* __restrict  */)"cached_get_text_stat(%lu);  next_text_num == ",
           text);
    }
  }
#line 1053
  if (buglevel > 2) {
    {
#line 1053
    printf((char const   */* __restrict  */)"%lu\n", next_text_num);
    }
  }
#line 1055
  if (text == 0UL) {
#line 1057
    err_stat = text;
#line 1058
    kom_errno = (enum kom_err )15;
#line 1059
    return ((Text_stat *)((void *)0));
  }
  {
#line 1062
  node = get_text_node(text);
  }
#line 1064
  if (text >= next_text_num) {
#line 1064
    goto _L;
  } else
#line 1064
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 1064
    goto _L;
  } else
#line 1064
  if (node->s.exists == 0U) {
    _L: /* CIL Label */ 
#line 1066
    if (buglevel > 2) {
      {
#line 1066
      printf((char const   */* __restrict  */)"cached_get_text_stat: no such text.\n");
      }
    }
#line 1067
    err_stat = text;
#line 1068
    kom_errno = (enum kom_err )14;
#line 1069
    return ((Text_stat *)((void *)0));
  }
#line 1074
  if ((unsigned long )node->ptr != (unsigned long )((void *)0)) {
#line 1076
    if (buglevel > 2) {
      {
#line 1076
      printf((char const   */* __restrict  */)"Found in ptr.\n");
      }
    }
    {
#line 1077
    text_set_mru(text);
#line 1078
    (text_mcb->hits) ++;
    }
#line 1079
    return ((Text_stat *)node->ptr);
  }
#line 1082
  if ((unsigned long )node->snap_shot != (unsigned long )((void *)0)) {
#line 1084
    if (buglevel > 2) {
      {
#line 1084
      printf((char const   */* __restrict  */)"Found in snap_shot\n");
      }
    }
    {
#line 1085
    tmp = copy_text_stat((Text_stat const   *)node->snap_shot);
#line 1085
    node->ptr = (void *)tmp;
#line 1086
    text_set_mru(text);
#line 1087
    (text_mcb->hits) ++;
    }
#line 1088
    return ((Text_stat *)node->ptr);
  }
#line 1091
  if (buglevel > 2) {
    {
#line 1091
    printf((char const   */* __restrict  */)"Found in file A.\n");
    }
  }
  {
#line 1092
  tmp___0 = read_text_stat(file_a, node->pos, node->size);
#line 1092
  node->ptr = (void *)tmp___0;
#line 1094
  text_set_mru(text);
#line 1095
  (text_mcb->misses) ++;
  }
#line 1096
  return ((Text_stat *)node->ptr);
}
}
#line 1106 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Text_no cached_create_text(String const   message ) 
{ 
  Text_no tno ;
  Cache_node *node ;
  long file_pos ;
  Text_no tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  size_t tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  Text_stat *tmp___17 ;

  {
#line 1113
  tmp = next_text_num;
#line 1113
  next_text_num ++;
#line 1113
  tno = tmp;
#line 1115
  if (buglevel > 2) {
    {
#line 1115
    printf((char const   */* __restrict  */)"cached_create_text (len=%lu)\n", message.len);
    }
  }
#line 1117
  if (tno >= param.max_text) {
#line 1119
    err_stat = tno;
#line 1120
    kom_errno = (enum kom_err )19;
#line 1121
    next_text_num = param.max_text;
#line 1123
    return ((Text_no )0);
  }
  {
#line 1126
  tmp___0 = write_number_file();
  }
#line 1126
  if (tmp___0 < 0) {
#line 1128
    next_text_num --;
#line 1129
    err_stat = 0UL;
#line 1130
    kom_errno = (enum kom_err )45;
#line 1131
    return ((Text_no )0);
  }
  {
#line 1134
  tmp___3 = fseek(text_file, 0L, 2);
  }
#line 1134
  if (tmp___3 != 0) {
    {
#line 1136
    tmp___1 = __errno_location();
#line 1136
    tmp___2 = strerror(*tmp___1);
#line 1136
    kom_log("ERROR: cannot seek to end of text_file: %s\n", tmp___2);
#line 1137
    clearerr(text_file);
    }
#line 1138
    return ((Text_no )0);
  }
  {
#line 1141
  file_pos = ftell(text_file);
#line 1143
  tmp___7 = fwrite((void const   */* __restrict  */)message.string, (size_t )1, (size_t )message.len,
                   (FILE */* __restrict  */)text_file);
  }
#line 1143
  if (tmp___7 != (size_t )message.len) {
    {
#line 1146
    tmp___6 = __errno_location();
    }
#line 1146
    if (*tmp___6 != 28) {
      {
#line 1147
      tmp___4 = __errno_location();
#line 1147
      tmp___5 = strerror(*tmp___4);
#line 1147
      kom_log("WARNING: cached_create_text: Couldn\'t write text %lu: %s\n", tno,
              tmp___5);
      }
    }
    {
#line 1149
    err_stat = 0UL;
#line 1150
    kom_errno = (enum kom_err )45;
#line 1151
    clearerr(text_file);
    }
#line 1152
    return ((Text_no )0);
  }
  {
#line 1155
  tmp___11 = fflush(text_file);
  }
#line 1155
  if (tmp___11 != 0) {
    {
#line 1157
    tmp___10 = __errno_location();
    }
#line 1157
    if (*tmp___10 != 28) {
      {
#line 1158
      tmp___8 = __errno_location();
#line 1158
      tmp___9 = strerror(*tmp___8);
#line 1158
      kom_log("WARNING: cached_create_text: Couldn\'t fflush text %lu: %s\n", tno,
              tmp___9);
      }
    }
    {
#line 1160
    err_stat = 0UL;
#line 1161
    kom_errno = (enum kom_err )45;
#line 1162
    clearerr(text_file);
    }
#line 1163
    return ((Text_no )0);
  }
  {
#line 1166
  tmp___15 = fileno(text_file);
#line 1166
  tmp___16 = fsync(tmp___15);
  }
#line 1166
  if (tmp___16 != 0) {
    {
#line 1168
    tmp___14 = __errno_location();
    }
#line 1168
    if (*tmp___14 != 28) {
      {
#line 1169
      tmp___12 = __errno_location();
#line 1169
      tmp___13 = strerror(*tmp___12);
#line 1169
      kom_log("WARNING: cached_create_text: Couldn\'t fsync text %lu: %s\n", tno,
              tmp___13);
      }
    }
    {
#line 1171
    err_stat = 0UL;
#line 1172
    kom_errno = (enum kom_err )45;
#line 1173
    clearerr(text_file);
    }
#line 1174
    return ((Text_no )0);
  }
  {
#line 1177
  create_cache_node(text_mcb, tno);
#line 1178
  node = get_text_node(tno);
  }
#line 1180
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 1181
    restart_kom("cached_create_text(): couldn\'t create cache-node.\n");
    }
  }
  {
#line 1183
  node->s.exists = 1U;
#line 1184
  node->s.dirty = 1U;
#line 1185
  tmp___17 = alloc_text_stat();
#line 1185
  node->ptr = (void *)tmp___17;
#line 1186
  ((Text_stat *)node->ptr)->no_of_misc = (unsigned short)0;
#line 1187
  ((Text_stat *)node->ptr)->misc_items = (Misc_info *)((void *)0);
#line 1188
  ((Text_stat *)node->ptr)->no_of_marks = (unsigned short)0;
#line 1189
  ((Text_stat *)node->ptr)->no_of_lines = (unsigned short)0;
#line 1190
  ((Text_stat *)node->ptr)->no_of_chars = (String_size )0;
#line 1191
  ((Text_stat *)node->ptr)->file_pos = file_pos;
#line 1193
  text_set_mru(tno);
  }
#line 1197
  if (buglevel > 2) {
    {
#line 1197
    printf((char const   */* __restrict  */)"cached_create_text -> %lu\n", tno);
    }
  }
#line 1199
  return (tno);
}
}
#line 1203 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
Text_no traverse_text(Text_no seed ) 
{ 
  Cache_node *node ;
  Text_no tmp ;

  {
#line 1208
  seed ++;
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1210
    if (! (seed < next_text_num)) {
#line 1210
      goto while_break;
    }
    {
#line 1212
    node = get_text_node(seed);
    }
#line 1213
    if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 1213
      if (node->s.exists != 0U) {
#line 1214
        goto while_break;
      }
    }
#line 1216
    seed ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1219
  if (seed >= next_text_num) {
#line 1219
    tmp = (Text_no )0;
  } else {
#line 1219
    tmp = seed;
  }
#line 1219
  return (tmp);
}
}
#line 1243 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
Conf_no traverse_conference(Conf_no seed ) 
{ 
  Cache_node *node ;
  int tmp ;

  {
#line 1248
  seed = (Conf_no )((int )seed + 1);
  {
#line 1250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1250
    if (! ((int )seed < (int )next_free_num)) {
#line 1250
      goto while_break;
    }
    {
#line 1252
    node = get_conf_node(seed);
    }
#line 1253
    if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 1253
      if (node->s.exists != 0U) {
#line 1254
        goto while_break;
      }
    }
#line 1256
    seed = (Conf_no )((int )seed + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1259
  if ((int )seed >= (int )next_free_num) {
#line 1259
    tmp = 0;
  } else {
#line 1259
    tmp = (int )seed;
  }
#line 1259
  return ((Conf_no )tmp);
}
}
#line 1262 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Garb_nice cached_get_garb_nice(Conf_no conf_no ) 
{ 


  {
#line 1265
  return ((*(small_conf_arr + conf_no))->nice);
}
}
#line 1268 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Garb_nice cached_get_keep_commented(Conf_no conf_no ) 
{ 


  {
#line 1271
  return ((*(small_conf_arr + conf_no))->keep_commented);
}
}
#line 1274 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern String cached_get_name(Conf_no conf_no ) 
{ 


  {
#line 1277
  return ((*(small_conf_arr + conf_no))->name);
}
}
#line 1280 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Local_text_no cached_get_highest_local_no(Conf_no conf_no ) 
{ 


  {
#line 1285
  return ((*(small_conf_arr + conf_no))->highest_local_no);
}
}
#line 1288 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Small_conf *cached_get_small_conf_stat(Conf_no conf_no ) 
{ 


  {
#line 1291
  if (buglevel > 2) {
    {
#line 1291
    printf((char const   */* __restrict  */)"cached_get_small_conf_stat %d\n", (int )conf_no);
    }
  }
#line 1293
  if ((int )conf_no == 0) {
#line 1295
    err_stat = (unsigned long )conf_no;
#line 1296
    kom_errno = (enum kom_err )8;
#line 1297
    return ((Small_conf *)((void *)0));
  }
#line 1300
  if ((int )conf_no >= (int )next_free_num) {
#line 1303
    err_stat = (unsigned long )conf_no;
#line 1304
    kom_errno = (enum kom_err )9;
#line 1305
    return ((Small_conf *)((void *)0));
  } else
#line 1300
  if ((unsigned long )*(small_conf_arr + conf_no) == (unsigned long )((void *)0)) {
#line 1303
    err_stat = (unsigned long )conf_no;
#line 1304
    kom_errno = (enum kom_err )9;
#line 1305
    return ((Small_conf *)((void *)0));
  }
#line 1307
  return (*(small_conf_arr + conf_no));
}
}
#line 1311 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
void cached_lock_person(Pers_no pers_no ) 
{ 
  Cache_node *node ;
  Person *pers_stat_ptr ;

  {
  {
#line 1318
  node = get_pers_node(pers_no);
  }
#line 1320
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 1321
    restart_kom("cached_lock_person(%d): nonexistent.\n", (int )pers_no);
    }
  } else
#line 1320
  if (node->s.exists == 0U) {
    {
#line 1321
    restart_kom("cached_lock_person(%d): nonexistent.\n", (int )pers_no);
    }
  }
#line 1323
  if ((unsigned long )node->ptr == (unsigned long )((void *)0)) {
    {
#line 1327
    pers_stat_ptr = cached_get_person_stat(pers_no);
    }
#line 1329
    if ((unsigned long )pers_stat_ptr == (unsigned long )((void *)0)) {
      {
#line 1330
      restart_kom("cached_lock_person(%d): couldn\'t read in person.\n", (int )pers_no);
      }
    }
#line 1333
    if ((unsigned long )pers_stat_ptr != (unsigned long )node->ptr) {
      {
#line 1334
      restart_kom("%s(%d): pers_stat_ptr == %lu, node->ptr == %lu.\n", "cached_lock_person",
                  (int )pers_no, (unsigned long )pers_stat_ptr, (unsigned long )node->ptr);
      }
    }
  }
#line 1340
  (node->lock_cnt) ++;
#line 1341
  return;
}
}
#line 1344 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
void cached_unlock_person(Pers_no pers_no ) 
{ 
  Cache_node *node ;

  {
  {
#line 1351
  node = get_pers_node(pers_no);
  }
#line 1353
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 1354
    restart_kom("cached_unlock_person(): couldn\'t get cache-node.\n");
    }
  }
#line 1356
  if (node->lock_cnt <= 0) {
    {
#line 1358
    kom_log("cached_unlock_person(%d): lock_cnt == %d.\n", (int )pers_no, node->lock_cnt);
#line 1361
    node->lock_cnt = 0;
    }
  } else {
#line 1364
    (node->lock_cnt) --;
  }
#line 1365
  return;
}
}
#line 1369 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
void cached_lock_conf(Conf_no conf_no ) 
{ 
  Cache_node *node ;
  Conference *conference_ptr ;

  {
  {
#line 1374
  node = get_conf_node(conf_no);
  }
#line 1376
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 1377
    restart_kom("cached_lock_conf(): can\'t get cache-node.\n");
    }
  }
#line 1379
  if (node->s.exists == 0U) {
    {
#line 1380
    restart_kom("cached_lock_conf(%d): nonexistent.\n", (int )conf_no);
    }
  }
#line 1384
  if ((unsigned long )node->ptr == (unsigned long )((void *)0)) {
    {
#line 1388
    conference_ptr = cached_get_conf_stat(conf_no);
    }
#line 1390
    if ((unsigned long )conference_ptr == (unsigned long )((void *)0)) {
      {
#line 1391
      restart_kom("cached_lock_conf(%d): couldn\'t read in conf.\n", (int )conf_no);
      }
    }
#line 1394
    if ((unsigned long )conference_ptr != (unsigned long )node->ptr) {
      {
#line 1395
      restart_kom("%s(%d): conference_ptr == %lu, node->ptr == %lu.\n", "cached_lock_conf",
                  (int )conf_no, (unsigned long )conference_ptr, (unsigned long )node->ptr);
      }
    }
  }
#line 1401
  (node->lock_cnt) ++;
#line 1402
  return;
}
}
#line 1405 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
void cached_unlock_conf(Conf_no conf_no ) 
{ 
  Cache_node *node ;

  {
  {
#line 1412
  node = get_conf_node(conf_no);
  }
#line 1413
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 1414
    restart_kom("cached_unlock_conf(): can\'t get node.\n");
    }
  }
#line 1416
  if (node->lock_cnt <= 0) {
    {
#line 1418
    kom_log("cached_unlock_conf(%d): lock_cnt == %d.\n", (int )conf_no, node->lock_cnt);
#line 1421
    node->lock_cnt = 0;
    }
  } else {
#line 1424
    (node->lock_cnt) --;
  }
#line 1425
  return;
}
}
#line 1435 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void free_match_table(Matching_info *mtch ) 
{ 


  {
#line 1438
  if ((unsigned long )mtch == (unsigned long )((void *)0)) {
#line 1439
    return;
  }
  {
#line 1441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1441
    if (! ((int )mtch->conf_no != 0)) {
#line 1441
      goto while_break;
    }
    {
#line 1443
    free_tokens(mtch->tokens);
#line 1446
    mtch ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1448
  return;
}
}
#line 1459 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static int find_matching_info_compare(void const   *a , void const   *b ) 
{ 
  Matching_info *info_a ;
  Matching_info *info_b ;

  {
#line 1462
  info_a = (Matching_info *)a;
#line 1463
  info_b = (Matching_info *)b;
#line 1465
  return ((int )info_a->conf_no - (int )info_b->conf_no);
}
}
#line 1468 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Matching_info *find_matching_info(Conf_no conf_no ) 
{ 
  Matching_info *info ;
  Matching_info key ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1482
  key.conf_no = conf_no;
#line 1483
  tmp = bsearch((void const   *)(& key), (void const   *)match_table, (size_t )no_of_match_info,
                sizeof(Matching_info ), & find_matching_info_compare);
#line 1483
  info = (Matching_info *)tmp;
  }
#line 1488
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 1489
    return ((Matching_info *)((void *)0));
  } else {
#line 1490
    if (info->name.len == 0L) {
#line 1490
      tmp___0 = 1;
    } else {
#line 1490
      tmp___0 = 0;
    }
#line 1490
    if (tmp___0) {
#line 1490
      if ((unsigned long )info->tokens == (unsigned long )((void *)0)) {
#line 1491
        return ((Matching_info *)((void *)0));
      } else {
#line 1493
        return (info);
      }
    } else {
#line 1493
      return (info);
    }
  }
}
}
#line 1503 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Success rebuild_matching_info_entry(Conf_no conf_no ) 
{ 
  Matching_info *mtch ;
  Cache_node *node ;
  String tmp ;
  int tmp___0 ;
  Success tmp___1 ;
  void *tmp___2 ;
  String tmp___3 ;

  {
  {
#line 1509
  mtch = find_matching_info(conf_no);
  }
#line 1510
  if ((unsigned long )mtch != (unsigned long )((void *)0)) {
    {
#line 1513
    free_tokens(mtch->tokens);
    }
#line 1516
    if ((unsigned long )*(small_conf_arr + conf_no) != (unsigned long )((void *)0)) {
      {
#line 1519
      mtch->name = (*(small_conf_arr + conf_no))->name;
#line 1520
      tmp = s_fcrea_str(WHITESPACE);
#line 1520
      mtch->tokens = tokenize((String const   )(*(small_conf_arr + conf_no))->name,
                              (String const   )tmp);
      }
    } else {
#line 1537
      mtch->name = (String )EMPTY_STRING;
#line 1538
      mtch->tokens = (Parse_token *)((void *)0);
#line 1539
      mtch->priority = 0;
    }
  } else {
    {
#line 1566
    node = get_conf_node(conf_no);
    }
#line 1567
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 1571
      return ((Success )OK);
    } else
#line 1567
    if (node->s.exists == 0U) {
#line 1571
      return ((Success )OK);
    } else {
#line 1567
      if ((*(small_conf_arr + conf_no))->name.len == 0L) {
#line 1567
        tmp___0 = 1;
      } else {
#line 1567
        tmp___0 = 0;
      }
#line 1567
      if (tmp___0) {
#line 1571
        return ((Success )OK);
      }
    }
#line 1577
    if ((int )conf_no <= (int )(match_table + (no_of_match_info - 1))->conf_no) {
      {
#line 1579
      kom_log("Rebuilding entire match_table. It doesn\'t look right.\n");
#line 1580
      tmp___1 = build_matching_info();
      }
#line 1580
      return (tmp___1);
    }
    {
#line 1586
    tmp___2 = srealloc((void *)match_table, (unsigned long )(no_of_match_info + 2) * sizeof(Matching_info ));
#line 1586
    match_table = (struct matching_info *)tmp___2;
#line 1588
    (match_table + no_of_match_info)->name = (*(small_conf_arr + conf_no))->name;
#line 1589
    tmp___3 = s_fcrea_str(WHITESPACE);
#line 1589
    (match_table + no_of_match_info)->tokens = tokenize((String const   )(*(small_conf_arr + conf_no))->name,
                                                        (String const   )tmp___3);
#line 1591
    (match_table + no_of_match_info)->priority = 7;
#line 1592
    (match_table + no_of_match_info)->conf_no = conf_no;
#line 1596
    no_of_match_info ++;
#line 1597
    (match_table + no_of_match_info)->name = (String )EMPTY_STRING;
#line 1598
    (match_table + no_of_match_info)->tokens = (Parse_token *)((void *)0);
#line 1599
    (match_table + no_of_match_info)->priority = 0;
#line 1600
    (match_table + no_of_match_info)->conf_no = (Conf_no )0;
    }
  }
#line 1603
  return ((Success )OK);
}
}
#line 1606 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Success build_matching_info(void) 
{ 
  Conf_no i ;
  Matching_info *mtch ;
  Conf_no *conf ;
  void *tmp ;
  String tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1613
  free_match_table(match_table);
#line 1615
  tmp = srealloc((void *)match_table, (unsigned long )next_free_num * sizeof(Matching_info ));
#line 1615
  match_table = (struct matching_info *)tmp;
#line 1617
  no_of_match_info = 0;
#line 1619
  mtch = match_table;
#line 1621
  i = (Conf_no )1;
  }
  {
#line 1621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1621
    if (! ((int )i < (int )next_free_num)) {
#line 1621
      goto while_break;
    }
#line 1623
    if ((unsigned long )*(small_conf_arr + i) != (unsigned long )((void *)0)) {
#line 1623
      if ((*(small_conf_arr + i))->name.len == 0L) {
#line 1623
        tmp___1 = 1;
      } else {
#line 1623
        tmp___1 = 0;
      }
#line 1623
      if (! tmp___1) {
        {
#line 1626
        mtch->name = (*(small_conf_arr + i))->name;
#line 1627
        tmp___0 = s_fcrea_str(WHITESPACE);
#line 1627
        mtch->tokens = tokenize((String const   )mtch->name, (String const   )tmp___0);
#line 1628
        mtch->priority = 7;
#line 1629
        mtch->conf_no = i;
#line 1630
        mtch ++;
#line 1631
        conf ++;
#line 1632
        no_of_match_info ++;
        }
      }
    }
#line 1621
    i = (Conf_no )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1636
  mtch->name = (String )EMPTY_STRING;
#line 1637
  mtch->tokens = (Parse_token *)((void *)0);
#line 1638
  mtch->priority = 0;
#line 1639
  mtch->conf_no = (Conf_no )0;
#line 1641
  return ((Success )OK);
}
}
#line 1647 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Success cached_lookup_name(String const   name___0 , Conf_list_old *result ) 
{ 
  Parse_info tmp ;
  int i ;
  String tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 1657
  tmp___0 = s_fcrea_str(WHITESPACE);
#line 1657
  tmp = parse((String )name___0, match_table, (Bool )0, (Bool )0, tmp___0, (unsigned char *)(swedish_collate_tab));
  }
#line 1660
  if (tmp.no_of_matches == -1) {
#line 1662
    kom_errno = (enum kom_err )51;
#line 1663
    err_stat = 0UL;
#line 1664
    return ((Success )FAILURE);
  }
#line 1667
  if (tmp.no_of_matches == 1) {
#line 1667
    if (*(tmp.indexes + 0) == -1) {
      {
#line 1672
      result->no_of_conf_nos = 0UL;
#line 1673
      tmp___1 = tmp_alloc((unsigned long )no_of_match_info * sizeof(Conf_no ));
#line 1673
      result->conf_nos = (Conf_no *)tmp___1;
#line 1674
      tmp___2 = tmp_alloc((unsigned long )no_of_match_info * sizeof(Conf_type ));
#line 1674
      result->type_of_conf = (Conf_type *)tmp___2;
#line 1676
      i = 0;
      }
      {
#line 1676
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1676
        if (! (i < no_of_match_info)) {
#line 1676
          goto while_break;
        }
#line 1678
        if ((match_table + i)->name.len == 0L) {
#line 1678
          tmp___3 = 1;
        } else {
#line 1678
          tmp___3 = 0;
        }
#line 1678
        if (tmp___3) {
#line 1679
          goto __Cont;
        }
#line 1680
        *(result->conf_nos + result->no_of_conf_nos) = (match_table + i)->conf_no;
#line 1681
        *(result->type_of_conf + result->no_of_conf_nos) = (*(small_conf_arr + (match_table + i)->conf_no))->type;
#line 1683
        (result->no_of_conf_nos) ++;
        __Cont: /* CIL Label */ 
#line 1676
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1667
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1689
    result->no_of_conf_nos = (unsigned long )tmp.no_of_matches;
#line 1690
    tmp___4 = tmp_alloc((unsigned long )tmp.no_of_matches * sizeof(Conf_no ));
#line 1690
    result->conf_nos = (Conf_no *)tmp___4;
#line 1691
    tmp___5 = tmp_alloc((unsigned long )tmp.no_of_matches * sizeof(Conf_type ));
#line 1691
    result->type_of_conf = (Conf_type *)tmp___5;
#line 1694
    i = 0;
    }
    {
#line 1694
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1694
      if (! (i < tmp.no_of_matches)) {
#line 1694
        goto while_break___0;
      }
#line 1696
      *(result->conf_nos + i) = (match_table + *(tmp.indexes + i))->conf_no;
#line 1697
      *(result->type_of_conf + i) = (*(small_conf_arr + (match_table + *(tmp.indexes + i))->conf_no))->type;
#line 1694
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1701
  sfree((void *)tmp.indexes);
  }
#line 1702
  return ((Success )OK);
}
}
#line 1706 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Bool is_clean(char const   *fn ) 
{ 
  FILE *fp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1711
  fp = i_fopen(fn, "rb");
  }
#line 1711
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1712
    return ((Bool )0);
  }
  {
#line 1714
  tmp = _IO_getc(fp);
  }
#line 1714
  if (tmp == 67) {
    {
#line 1714
    tmp___0 = _IO_getc(fp);
    }
#line 1714
    if (tmp___0 == 76) {
      {
#line 1714
      tmp___1 = _IO_getc(fp);
      }
#line 1714
      if (tmp___1 == 69) {
        {
#line 1714
        tmp___2 = _IO_getc(fp);
        }
#line 1714
        if (tmp___2 == 65) {
          {
#line 1714
          tmp___3 = _IO_getc(fp);
          }
#line 1714
          if (tmp___3 == 78) {
            {
#line 1720
            i_fclose(fp);
            }
#line 1721
            return ((Bool )1);
          } else {
            {
#line 1725
            i_fclose(fp);
            }
#line 1726
            return ((Bool )0);
          }
        } else {
          {
#line 1725
          i_fclose(fp);
          }
#line 1726
          return ((Bool )0);
        }
      } else {
        {
#line 1725
        i_fclose(fp);
        }
#line 1726
        return ((Bool )0);
      }
    } else {
      {
#line 1725
      i_fclose(fp);
      }
#line 1726
      return ((Bool )0);
    }
  } else {
    {
#line 1725
    i_fclose(fp);
    }
#line 1726
    return ((Bool )0);
  }
}
}
#line 1731 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static long get_version(char const   *fn ) 
{ 
  FILE *fp ;
  long version ;
  int tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 1737
  fp = i_fopen(fn, "rb");
  }
#line 1737
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1738
    return (-1L);
  }
  {
#line 1740
  fseek(fp, 5L, 0);
#line 1741
  tmp = _IO_getc(fp);
  }
#line 1741
  if (tmp == 10) {
    {
#line 1743
    i_fclose(fp);
    }
#line 1744
    return (0L);
  }
  {
#line 1746
  tmp___0 = fparse_long(fp);
#line 1746
  version = (long )tmp___0;
#line 1747
  i_fclose(fp);
  }
#line 1749
  return (version);
}
}
#line 1752 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void sync_output_header(FILE *fp , char const   *state ) 
{ 


  {
  {
#line 1755
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s:%05ld\n",
          state, 2L);
#line 1756
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%020lu\n",
          (unsigned long )current_time.tv_sec);
  }
#line 1757
  return;
}
}
#line 1759 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void pre_sync(void) 
{ 
  Text_no tno_iter ;
  Conf_no cno_iter ;
  Cache_node *node ;
  Conference *tmp ;
  Person *tmp___0 ;
  Text_stat *tmp___1 ;
  int tmp___2 ;
  Bool tmp___3 ;
  int tmp___4 ;
  Bool tmp___5 ;

  {
  {
#line 1766
  async_sync_db();
  }
#line 1770
  if (buglevel > 0) {
    {
#line 1770
    printf((char const   */* __restrict  */)"Sync starting\n");
    }
  }
#line 1772
  highest_text_no = next_text_num;
#line 1773
  highest_conf_no = next_free_num;
#line 1776
  cno_iter = (Conf_no )1;
  {
#line 1776
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1776
    if (! ((int )cno_iter < (int )highest_conf_no)) {
#line 1776
      goto while_break;
    }
    {
#line 1778
    node = get_conf_node(cno_iter);
    }
#line 1780
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 1781
      goto __Cont;
    }
#line 1783
    if (node->s.exists == 0U) {
      {
#line 1785
      unlink_conf_lru(node);
#line 1786
      destruct_cache_node(conf_mcb, (unsigned long )cno_iter);
      }
    } else
#line 1790
    if (node->s.dirty != 0U) {
      {
#line 1792
      free_conference((Conference *)node->snap_shot);
      }
#line 1794
      if (node->lock_cnt == 0) {
        {
#line 1796
        unlink_conf_lru(node);
#line 1797
        node->snap_shot = node->ptr;
#line 1798
        node->ptr = (void *)0;
        }
      } else {
        {
#line 1801
        tmp = copy_conference((Conference const   *)node->ptr);
#line 1801
        node->snap_shot = (void *)tmp;
        }
      }
#line 1803
      node->s.dirty = 0U;
    }
    __Cont: /* CIL Label */ 
#line 1776
    cno_iter = (Conf_no )((int )cno_iter + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1808
  cno_iter = (Conf_no )1;
  {
#line 1808
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1808
    if (! ((int )cno_iter < (int )highest_conf_no)) {
#line 1808
      goto while_break___0;
    }
    {
#line 1810
    node = get_pers_node(cno_iter);
    }
#line 1812
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 1813
      goto __Cont___0;
    }
#line 1815
    if (node->s.exists == 0U) {
      {
#line 1817
      unlink_pers_lru(node);
#line 1818
      destruct_cache_node(pers_mcb, (unsigned long )cno_iter);
      }
    } else
#line 1822
    if (node->s.dirty != 0U) {
      {
#line 1824
      free_person((Person *)node->snap_shot);
      }
#line 1826
      if (node->lock_cnt == 0) {
        {
#line 1828
        unlink_pers_lru(node);
#line 1829
        node->snap_shot = node->ptr;
#line 1830
        node->ptr = (void *)0;
        }
      } else {
        {
#line 1833
        tmp___0 = copy_person((Person const   *)node->ptr);
#line 1833
        node->snap_shot = (void *)tmp___0;
        }
      }
#line 1835
      node->s.dirty = 0U;
    }
    __Cont___0: /* CIL Label */ 
#line 1808
    cno_iter = (Conf_no )((int )cno_iter + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1840
  tno_iter = (Text_no )1;
  {
#line 1840
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1840
    if (! (tno_iter < highest_text_no)) {
#line 1840
      goto while_break___1;
    }
    {
#line 1842
    node = get_text_node(tno_iter);
    }
#line 1844
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 1845
      goto __Cont___1;
    }
#line 1847
    if (node->s.exists == 0U) {
      {
#line 1849
      unlink_text_lru(node);
#line 1850
      destruct_cache_node(text_mcb, tno_iter);
      }
    } else
#line 1854
    if (node->s.dirty != 0U) {
      {
#line 1856
      free_text_stat((Text_stat *)node->snap_shot);
      }
#line 1858
      if (node->lock_cnt == 0) {
        {
#line 1860
        unlink_text_lru(node);
#line 1861
        node->snap_shot = node->ptr;
#line 1862
        node->ptr = (void *)0;
        }
      } else {
        {
#line 1865
        tmp___1 = copy_text_stat((Text_stat const   *)node->ptr);
#line 1865
        node->snap_shot = (void *)tmp___1;
        }
      }
#line 1867
      node->s.dirty = 0U;
    }
    __Cont___1: /* CIL Label */ 
#line 1840
    tno_iter ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1875
  tmp___5 = is_clean((char const   *)param.datafile_name);
  }
#line 1875
  if (tmp___5) {
    {
#line 1877
    tmp___3 = is_clean((char const   *)param.backupfile_name);
    }
#line 1877
    if (tmp___3) {
      {
#line 1879
      tmp___2 = i_rename((char const   *)param.backupfile_name, (char const   *)param.backupfile_name_2);
      }
#line 1879
      if (tmp___2 != 0) {
        {
#line 1882
        kom_log("pre_sync: can\'t do extra backup.\n");
        }
      }
    }
    {
#line 1886
    tmp___4 = i_rename((char const   *)param.datafile_name, (char const   *)param.backupfile_name);
    }
#line 1886
    if (tmp___4 != 0) {
      {
#line 1887
      restart_kom("pre_sync: can\'t backup.\n");
      }
    }
  } else {
    {
#line 1890
    kom_log("pre_sync: datafile not clean. No backup taken.\n");
    }
  }
#line 1892
  if ((unsigned long )file_b != (unsigned long )((void *)0)) {
    {
#line 1894
    kom_log("pre_sync: Save in progress aborted.\n");
#line 1895
    i_fclose(file_b);
    }
  }
  {
#line 1901
  file_b = i_fopen((char const   *)param.datafile_name, "wb");
  }
#line 1901
  if ((unsigned long )file_b == (unsigned long )((void *)0)) {
    {
#line 1903
    kom_log("WARNING: pre_sync: can\'t open file to save in.\n");
#line 1904
    sync_state = (enum __anonenum_sync_state_88 )5;
    }
#line 1906
    return;
  }
  {
#line 1923
  sync_output_header(file_b, "DIRTY");
#line 1924
  fprintf((FILE */* __restrict  */)file_b, (char const   */* __restrict  */)"#C %d\n",
          (int )highest_conf_no);
#line 1925
  fprintf((FILE */* __restrict  */)file_b, (char const   */* __restrict  */)"#T %ld\n",
          highest_text_no);
#line 1926
  fprintf((FILE */* __restrict  */)file_b, (char const   */* __restrict  */)"I");
#line 1927
  foutput_info(file_b, & kom_info);
#line 1928
  fprintf((FILE */* __restrict  */)file_b, (char const   */* __restrict  */)"\n");
#line 1929
  sync_state = (enum __anonenum_sync_state_88 )1;
#line 1934
  sync_next = 1UL;
  }
#line 1936
  return;
}
}
#line 1945 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static char buf___0[8192]  ;
#line 1938 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void copy_file(FILE *from , FILE *to , long from_pos , long len , long no ) 
{ 
  long result ;
  long num ;
  long new_num ;
  long num_ix ;
  long chunk_len ;
  long orig_len ;
  int first_chunk ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 1951
  orig_len = len;
#line 1952
  first_chunk = 1;
#line 1954
  if (len < 3L) {
    {
#line 1956
    restart_kom("copy_file: insane len %ld\n", len);
    }
  }
  {
#line 1960
  len ++;
#line 1962
  tmp = fseek(from, from_pos, 0);
  }
#line 1962
  if (tmp == -1) {
    {
#line 1964
    sync_state = (enum __anonenum_sync_state_88 )4;
#line 1965
    restart_kom("sync: copy_file(): src fseek failed.\n");
    }
#line 1966
    return;
  }
  {
#line 1969
  tmp___0 = fseek(to, 0L, 2);
  }
#line 1969
  if (tmp___0 == -1) {
    {
#line 1971
    sync_state = (enum __anonenum_sync_state_88 )4;
#line 1972
    kom_log("sync: copy_file(): dst fseek failed.\n");
    }
#line 1973
    return;
  }
#line 1976
  first_chunk = 1;
  {
#line 1977
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1977
    if (! (len > 0L)) {
#line 1977
      goto while_break;
    }
#line 1979
    chunk_len = len;
#line 1980
    if (chunk_len > 8192L) {
#line 1981
      chunk_len = 8192L;
    }
    {
#line 1983
    tmp___1 = fread((void */* __restrict  */)(buf___0), (size_t )1, (size_t )chunk_len,
                    (FILE */* __restrict  */)from);
#line 1983
    result = (long )tmp___1;
    }
#line 1983
    if (result != chunk_len) {
      {
#line 1985
      restart_kom("%s.\nfrom_pos = %ld, len = %ld, result = %ld\n", "sync: copy_file(): fread failed",
                  from_pos, len, result);
#line 1989
      sync_state = (enum __anonenum_sync_state_88 )4;
      }
#line 1990
      return;
    }
#line 1993
    if (first_chunk) {
#line 1996
      if ((int )buf___0[0] != 84) {
#line 1996
        if ((int )buf___0[0] != 67) {
#line 1996
          if ((int )buf___0[0] != 80) {
            {
#line 1998
            restart_kom("Found char %d at pos %ld; expected T, C or P\n", (int )buf___0[0],
                        from_pos);
            }
          }
        }
      }
#line 2001
      if ((int )buf___0[1] != 32) {
        {
#line 2003
        restart_kom("Expected space after T, C or P but got %d at %ld\n", (int )buf___0[1],
                    from_pos);
        }
      }
#line 2006
      num = 0L;
#line 2007
      num_ix = 2L;
      {
#line 2007
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2007
        if (num_ix < chunk_len) {
#line 2007
          if ((int )buf___0[num_ix] >= 48) {
#line 2007
            if (! ((int )buf___0[num_ix] <= 57)) {
#line 2007
              goto while_break___0;
            }
          } else {
#line 2007
            goto while_break___0;
          }
        } else {
#line 2007
          goto while_break___0;
        }
#line 2012
        new_num = (10L * num + (long )buf___0[num_ix]) - 48L;
#line 2013
        if (new_num / 10L != num) {
          {
#line 2015
          restart_kom("copy_file: number overflow at %ld\n", from_pos);
          }
        }
#line 2018
        num = new_num;
#line 2007
        num_ix ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2020
      if (num != no) {
        {
#line 2022
        restart_kom("copy_file: expected %ld, got %ld; no sanity at %ld\n", no, num,
                    from_pos);
        }
      }
#line 2025
      if (num_ix >= chunk_len) {
        {
#line 2027
        restart_kom("copy_file: to little data at %ld\n", from_pos);
        }
      }
#line 2029
      if ((int )buf___0[num_ix] != 32) {
        {
#line 2031
        restart_kom("copy_file: expected space after number %ld at %ld; got %d\n",
                    num, from_pos, (int )buf___0[num_ix]);
        }
      }
#line 2035
      first_chunk = 0;
    }
#line 2039
    if (len == result) {
#line 2041
      if ((int )buf___0[len - 1L] != 10) {
        {
#line 2043
        restart_kom("Failed to find a newline at %ld + %ld - 1\n", from_pos, orig_len);
        }
      }
#line 2048
      len --;
#line 2049
      chunk_len --;
#line 2050
      if (len == 0L) {
#line 2051
        return;
      }
    }
    {
#line 2055
    tmp___2 = fwrite((void const   */* __restrict  */)(buf___0), (size_t )1, (size_t )chunk_len,
                     (FILE */* __restrict  */)to);
    }
#line 2055
    if (tmp___2 != (size_t )chunk_len) {
      {
#line 2057
      sync_state = (enum __anonenum_sync_state_88 )4;
#line 2058
      kom_log("sync: copy_file(): fwrite failed.\n");
      }
#line 2059
      return;
    }
#line 2061
    len -= chunk_len;
  }
  while_break: /* CIL Label */ ;
  }
#line 2063
  return;
}
}
#line 2065 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void save_one_conf(void) 
{ 
  Cache_node *cn ;
  long tmp ;

  {
#line 2078
  if (sync_next < (unsigned long )highest_conf_no) {
    {
#line 2081
    cn = get_conf_node((Conf_no )sync_next);
    }
#line 2083
    if (! ((unsigned long )cn == (unsigned long )((void *)0))) {
      {
#line 2093
      cn->pos_b = ftell(file_b);
      }
#line 2096
      if ((unsigned long )cn->snap_shot != (unsigned long )((void *)0)) {
        {
#line 2098
        fprintf((FILE */* __restrict  */)file_b, (char const   */* __restrict  */)"C %lu ",
                sync_next);
#line 2099
        foutput_conference(file_b, (Conference *)cn->snap_shot);
        }
      } else
#line 2104
      if (cn->s.dirty == 0U) {
#line 2104
        if ((unsigned long )cn->ptr != (unsigned long )((void *)0)) {
          {
#line 2106
          fprintf((FILE */* __restrict  */)file_b, (char const   */* __restrict  */)"C %lu",
                  sync_next);
#line 2107
          foutput_conference(file_b, (Conference *)cn->ptr);
          }
        } else {
          {
#line 2111
          copy_file(file_a, file_b, cn->pos, cn->size - 1L, (long )sync_next);
          }
        }
      } else {
        {
#line 2111
        copy_file(file_a, file_b, cn->pos, cn->size - 1L, (long )sync_next);
        }
      }
      {
#line 2114
      _IO_putc('\n', file_b);
#line 2120
      tmp = ftell(file_b);
#line 2120
      cn->size_b = tmp - cn->pos_b;
      }
    }
#line 2126
    sync_next ++;
  } else {
#line 2134
    sync_next = 1UL;
#line 2135
    sync_state = (enum __anonenum_sync_state_88 )2;
  }
#line 2138
  return;
}
}
#line 2140 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void write_pers(FILE *fp , Person *p , int pers_no ) 
{ 


  {
  {
#line 2145
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"P %d %dH",
          pers_no, 64);
#line 2146
  fwrite((void const   */* __restrict  */)(p->pwd), (size_t )64, (size_t )1, (FILE */* __restrict  */)fp);
#line 2147
  foutput_person(fp, (Person const   *)p);
  }
#line 2148
  return;
}
}
#line 2150 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void save_one_pers(void) 
{ 
  Cache_node *cn ;
  long tmp ;

  {
#line 2158
  if (sync_next < (unsigned long )highest_conf_no) {
    {
#line 2160
    cn = get_pers_node((Pers_no )sync_next);
    }
#line 2162
    if (! ((unsigned long )cn == (unsigned long )((void *)0))) {
      {
#line 2167
      cn->pos_b = ftell(file_b);
      }
#line 2169
      if ((unsigned long )cn->snap_shot != (unsigned long )((void *)0)) {
        {
#line 2171
        write_pers(file_b, (Person *)cn->snap_shot, (int )sync_next);
        }
      } else
#line 2173
      if (cn->s.dirty == 0U) {
#line 2173
        if ((unsigned long )cn->ptr != (unsigned long )((void *)0)) {
          {
#line 2175
          write_pers(file_b, (Person *)cn->ptr, (int )sync_next);
          }
        } else {
          {
#line 2179
          copy_file(file_a, file_b, cn->pos, cn->size - 1L, (long )sync_next);
          }
        }
      } else {
        {
#line 2179
        copy_file(file_a, file_b, cn->pos, cn->size - 1L, (long )sync_next);
        }
      }
      {
#line 2182
      _IO_putc('\n', file_b);
#line 2183
      tmp = ftell(file_b);
#line 2183
      cn->size_b = tmp - cn->pos_b;
      }
    }
#line 2185
    sync_next ++;
  } else {
#line 2189
    sync_next = 1UL;
#line 2190
    sync_state = (enum __anonenum_sync_state_88 )3;
  }
#line 2192
  return;
}
}
#line 2194 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void post_sync(void) 
{ 
  Text_no tno_iter ;
  Conf_no cno_iter ;
  Cache_node *node ;

  {
  {
#line 2201
  async_sync_db();
  }
#line 2203
  if ((unsigned long )file_a == (unsigned long )((void *)0)) {
    {
#line 2204
    kom_log("WARNING: post_sync(): file_a == NULL. This is only normal %s", "if this is the first sync ever on this data file.\n");
    }
  } else {
    {
#line 2207
    i_fclose(file_a);
    }
  }
  {
#line 2209
  file_a = i_fopen((char const   *)param.datafile_name, "rb");
  }
#line 2209
  if ((unsigned long )file_a == (unsigned long )((void *)0)) {
    {
#line 2211
    kom_log("post_sync: can\'t open the file I just saved.\n");
#line 2212
    sync_state = (enum __anonenum_sync_state_88 )5;
    }
#line 2213
    return;
  }
#line 2216
  cno_iter = (Conf_no )1;
  {
#line 2216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2216
    if (! ((int )cno_iter < (int )highest_conf_no)) {
#line 2216
      goto while_break;
    }
    {
#line 2218
    node = get_conf_node(cno_iter);
    }
#line 2219
    if ((unsigned long )node != (unsigned long )((void *)0)) {
      {
#line 2221
      node->pos = node->pos_b;
#line 2222
      node->size = node->size_b;
#line 2223
      free_conference((Conference *)node->snap_shot);
#line 2224
      node->snap_shot = (void *)0;
      }
    }
#line 2216
    cno_iter = (Conf_no )((int )cno_iter + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2228
  cno_iter = (Conf_no )1;
  {
#line 2228
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2228
    if (! ((int )cno_iter < (int )highest_conf_no)) {
#line 2228
      goto while_break___0;
    }
    {
#line 2230
    node = get_pers_node(cno_iter);
    }
#line 2231
    if ((unsigned long )node != (unsigned long )((void *)0)) {
      {
#line 2233
      node->pos = node->pos_b;
#line 2234
      node->size = node->size_b;
#line 2235
      free_person((Person *)node->snap_shot);
#line 2236
      node->snap_shot = (void *)0;
      }
    }
#line 2228
    cno_iter = (Conf_no )((int )cno_iter + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2240
  tno_iter = (Text_no )1;
  {
#line 2240
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2240
    if (! (tno_iter < highest_text_no)) {
#line 2240
      goto while_break___1;
    }
    {
#line 2242
    node = get_text_node(tno_iter);
    }
#line 2243
    if ((unsigned long )node != (unsigned long )((void *)0)) {
      {
#line 2245
      node->pos = node->pos_b;
#line 2246
      node->size = node->size_b;
#line 2247
      free_text_stat((Text_stat *)node->snap_shot);
#line 2248
      node->snap_shot = (void *)0;
      }
    }
#line 2240
    tno_iter ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2251
  return;
}
}
#line 2255 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void save_one_text(void) 
{ 
  Cache_node *cn ;
  long offset ;
  long offset2 ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 2265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2265
    if (! (sync_next < highest_text_no)) {
#line 2265
      goto while_break;
    }
    {
#line 2268
    cn = get_text_node(sync_next);
    }
#line 2270
    if ((unsigned long )cn == (unsigned long )((void *)0)) {
#line 2275
      sync_next ++;
#line 2277
      goto while_continue;
    } else {
      {
#line 2286
      cn->pos_b = ftell(file_b);
      }
#line 2289
      if ((unsigned long )cn->snap_shot != (unsigned long )((void *)0)) {
        {
#line 2291
        fprintf((FILE */* __restrict  */)file_b, (char const   */* __restrict  */)"T %lu",
                sync_next);
#line 2292
        foutput_text_stat(file_b, (Text_stat *)cn->snap_shot);
        }
      } else
#line 2297
      if (cn->s.dirty == 0U) {
#line 2297
        if ((unsigned long )cn->ptr != (unsigned long )((void *)0)) {
          {
#line 2299
          fprintf((FILE */* __restrict  */)file_b, (char const   */* __restrict  */)"T %lu",
                  sync_next);
#line 2300
          foutput_text_stat(file_b, (Text_stat *)cn->ptr);
          }
        } else {
          {
#line 2305
          copy_file(file_a, file_b, cn->pos, cn->size - 1L, (long )sync_next);
          }
        }
      } else {
        {
#line 2305
        copy_file(file_a, file_b, cn->pos, cn->size - 1L, (long )sync_next);
        }
      }
      {
#line 2308
      _IO_putc('\n', file_b);
#line 2314
      tmp = ftell(file_b);
#line 2314
      cn->size_b = tmp - cn->pos_b;
#line 2315
      sync_next ++;
      }
#line 2318
      goto while_break;
    }
    {
#line 2321
    restart_kom("Unreachable statement reached.");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2328
  if (sync_next == highest_text_no) {
    {
#line 2331
    tmp___0 = ferror(file_b);
    }
#line 2331
    if (tmp___0 != 0) {
      {
#line 2333
      kom_log("save_one_text(): ferror() detected.\n");
#line 2334
      sync_state = (enum __anonenum_sync_state_88 )4;
      }
#line 2335
      return;
    }
    {
#line 2338
    offset = ftell(file_b);
    }
#line 2343
    if (offset == -1L) {
      {
#line 2345
      kom_log("save_one_text(): ftell returned -1.\n");
#line 2346
      sync_state = (enum __anonenum_sync_state_88 )4;
      }
#line 2347
      return;
    }
    {
#line 2350
    rewind(file_b);
#line 2351
    tmp___1 = ferror(file_b);
    }
#line 2351
    if (tmp___1 != 0) {
      {
#line 2353
      kom_log("save_one_text(): rewind failed.\n");
#line 2354
      sync_state = (enum __anonenum_sync_state_88 )4;
      }
#line 2355
      return;
    }
    {
#line 2358
    sync_output_header(file_b, "CLEAN");
#line 2360
    tmp___2 = ferror(file_b);
    }
#line 2360
    if (tmp___2 != 0) {
      {
#line 2362
      kom_log("save_one_text(): Set state to CLEAN failed.\n");
#line 2363
      sync_state = (enum __anonenum_sync_state_88 )4;
      }
#line 2364
      return;
    }
    {
#line 2369
    tmp___3 = fflush(file_b);
    }
#line 2369
    if (tmp___3 != 0) {
      {
#line 2371
      kom_log("save_one_text(): fflush failed.\n");
#line 2372
      sync_state = (enum __anonenum_sync_state_88 )4;
      }
#line 2373
      return;
    }
    {
#line 2376
    tmp___4 = ferror(file_b);
    }
#line 2376
    if (tmp___4 != 0) {
      {
#line 2378
      kom_log("save_one_text(): ferror after fflush failed.\n");
#line 2379
      sync_state = (enum __anonenum_sync_state_88 )4;
      }
#line 2380
      return;
    }
    {
#line 2383
    tmp___5 = i_fclose(file_b);
    }
#line 2383
    if (tmp___5 != 0) {
      {
#line 2385
      file_b = (FILE *)((void *)0);
#line 2387
      kom_log("Sync: fclose() failed in save_one_text.  Retrying.\n");
#line 2388
      remove((char const   *)param.datafile_name);
#line 2389
      sync_state = (enum __anonenum_sync_state_88 )5;
      }
#line 2390
      return;
    }
    {
#line 2407
    file_b = i_fopen((char const   *)param.datafile_name, "rb");
    }
#line 2408
    if ((unsigned long )file_b == (unsigned long )((void *)0)) {
      {
#line 2410
      kom_log("save_one_text(): failed to reopen file.\n");
#line 2411
      remove((char const   *)param.datafile_name);
#line 2412
      sync_state = (enum __anonenum_sync_state_88 )5;
      }
#line 2413
      return;
    }
    {
#line 2416
    tmp___6 = fseek(file_b, 0L, 2);
    }
#line 2416
    if (tmp___6 != 0) {
      {
#line 2418
      kom_log("save_one_text(): fseek failed.\n");
#line 2419
      sync_state = (enum __anonenum_sync_state_88 )4;
      }
#line 2420
      return;
    }
    {
#line 2423
    offset2 = ftell(file_b);
    }
#line 2424
    if (offset2 != offset) {
      {
#line 2426
      kom_log("save_one_text(): ftell confused (%ld and %ld).\n", offset, offset2);
#line 2428
      sync_state = (enum __anonenum_sync_state_88 )4;
      }
#line 2429
      return;
    }
    {
#line 2431
    i_fclose(file_b);
#line 2432
    file_b = (FILE *)((void *)0);
#line 2434
    sync_state = (enum __anonenum_sync_state_88 )6;
    }
#line 2436
    if (buglevel > 0) {
      {
#line 2436
      printf((char const   */* __restrict  */)"Sync ready\n");
      }
    }
    {
#line 2437
    post_sync();
    }
  }
#line 2439
  return;
}
}
#line 2449 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static struct timeval last_sync_start  =    {(__time_t )0, (__suseconds_t )0};
#line 2446 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
struct timeval sync_part(void) 
{ 
  struct timeval timeleft ;
  Bool tmp ;
  struct timeval tmp___0 ;
  struct timeval tmp___1 ;
  Bool tmp___2 ;
  Bool tmp___3 ;
  String tmp___4 ;
  int tmp___5 ;
  struct timeval tmp___6 ;

  {
  {
#line 2452
  tmp = timeval_zero(last_sync_start);
  }
#line 2452
  if (tmp) {
#line 2454
    last_sync_start = current_time;
#line 2455
    sync_state = (enum __anonenum_sync_state_88 )0;
  }
  {
#line 2464
  if ((unsigned int )sync_state == 1U) {
#line 2464
    goto case_1;
  }
#line 2469
  if ((unsigned int )sync_state == 2U) {
#line 2469
    goto case_2;
  }
#line 2474
  if ((unsigned int )sync_state == 3U) {
#line 2474
    goto case_3;
  }
#line 2478
  if ((unsigned int )sync_state == 6U) {
#line 2478
    goto case_6;
  }
#line 2482
  if ((unsigned int )sync_state == 0U) {
#line 2482
    goto case_0;
  }
#line 2500
  if ((unsigned int )sync_state == 5U) {
#line 2500
    goto case_5;
  }
#line 2515
  if ((unsigned int )sync_state == 4U) {
#line 2515
    goto case_4;
  }
#line 2540
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2465
  save_one_conf();
  }
#line 2466
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2470
  save_one_pers();
  }
#line 2471
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2475
  save_one_text();
  }
#line 2476
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 2479
  sync_state = (enum __anonenum_sync_state_88 )0;
#line 2480
  tmp___0 = timeval_ctor((time_t )1, 0);
  }
#line 2480
  return (tmp___0);
  case_0: /* CIL Label */ 
#line 2483
  if (param.never_save) {
    {
#line 2484
    tmp___1 = timeval_ctor((time_t )60, 0);
    }
#line 2484
    return (tmp___1);
  }
  {
#line 2486
  tmp___2 = timeval_remaining(& timeleft, param.sync_interval, last_sync_start, current_time);
  }
#line 2486
  if (tmp___2) {
#line 2492
    return (timeleft);
  }
  {
#line 2495
  last_sync_start = current_time;
#line 2497
  pre_sync();
  }
#line 2498
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2501
  tmp___3 = timeval_remaining(& timeleft, param.sync_retry_interval, last_sync_start,
                              current_time);
  }
#line 2501
  if (tmp___3) {
#line 2507
    return (timeleft);
  }
  {
#line 2510
  last_sync_start = current_time;
#line 2512
  pre_sync();
  }
#line 2513
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2516
  kom_log("sync: Error saving new file. Retrying.\n");
#line 2517
  i_fclose(file_b);
#line 2518
  file_b = (FILE *)((void *)0);
#line 2526
  remove((char const   *)param.datafile_name);
#line 2529
  tmp___4 = s_fcrea_str("A serious error occurred while saving the database. Tell\nthe administrator to check the server. This could be caused\nby insufficient disc space.");
#line 2529
  async_send_message((Pers_no )0, (Pers_no )0, tmp___4, (Bool )0);
#line 2537
  sync_state = (enum __anonenum_sync_state_88 )5;
  }
#line 2538
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2541
  restart_kom("sync(): sync_state==%d", (unsigned int )sync_state);
  }
  switch_break: /* CIL Label */ ;
  }
#line 2544
  if ((unsigned long )file_b != (unsigned long )((void *)0)) {
    {
#line 2544
    tmp___5 = ferror(file_b);
    }
#line 2544
    if (tmp___5 != 0) {
#line 2545
      sync_state = (enum __anonenum_sync_state_88 )4;
    }
  }
  {
#line 2551
  tmp___6 = timeval_ctor((time_t )0, 0);
  }
#line 2551
  return (tmp___6);
}
}
#line 2555 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void setup_small_conf(Conf_no conf_no , Conference *conf_c ) 
{ 
  Local_text_no tmp ;

  {
  {
#line 2559
  *(small_conf_arr + conf_no) = alloc_small_conf();
#line 2560
  s_strcpy(& (*(small_conf_arr + conf_no))->name, (String const   )conf_c->name);
#line 2561
  (*(small_conf_arr + conf_no))->type = conf_c->type;
#line 2562
  (*(small_conf_arr + conf_no))->supervisor = conf_c->supervisor;
#line 2563
  tmp = l2g_first_appendable_key((Local_to_global const   *)(& conf_c->texts));
#line 2563
  (*(small_conf_arr + conf_no))->highest_local_no = tmp - 1UL;
#line 2565
  (*(small_conf_arr + conf_no))->nice = conf_c->nice;
#line 2566
  (*(small_conf_arr + conf_no))->keep_commented = conf_c->keep_commented;
  }
#line 2567
  return;
}
}
#line 2571 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern Success init_cache(void) 
{ 
  Conf_no ic ;
  Text_no it ;
  Cache_node *node ;
  Conference tmp_conf ;
  Person tmp_pers ;
  Text_stat tmp_text ;
  long datafile_version ;
  long pos ;
  long num ;
  Bool done ;
  Bool read_text_no ;
  Bool read_conf_no ;
  int c ;
  struct timeval saved_time ;
  long record ;
  void *tmp ;
  int *tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;
  unsigned long tmp___3 ;
  Bool tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  Success tmp___12 ;
  long tmp___13 ;
  unsigned long tmp___14 ;
  Success tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  unsigned long tmp___18 ;
  Success tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  unsigned long tmp___22 ;
  Success tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  long tmp___27 ;
  long tmp___28 ;

  {
  {
#line 2582
  done = (Bool )0;
#line 2583
  read_text_no = (Bool )0;
#line 2584
  read_conf_no = (Bool )0;
#line 2585
  c = 0;
#line 2589
  boottime_info.boot_time = current_time.tv_sec;
#line 2591
  tmp = smalloc(sizeof(*small_conf_arr) * param.max_conf);
#line 2591
  small_conf_arr = (Small_conf **)tmp;
#line 2592
  pers_mcb = create_cache_node_mcb(100, (int )param.max_conf);
#line 2593
  conf_mcb = create_cache_node_mcb(100, (int )param.max_conf);
#line 2594
  text_mcb = create_cache_node_mcb(100, (int )param.max_text);
#line 2596
  init_conference(& tmp_conf);
#line 2597
  init_person(& tmp_pers);
#line 2598
  init_text_stat(& tmp_text);
#line 2614
  ic = (Conf_no )0;
  }
  {
#line 2614
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2614
    if (! ((unsigned long )ic < param.max_conf)) {
#line 2614
      goto while_break;
    }
#line 2615
    *(small_conf_arr + ic) = (Small_conf *)((void *)0);
#line 2614
    ic = (Conf_no )((int )ic + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2617
  ic = (Conf_no )1;
  {
#line 2617
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2617
    if (! ((unsigned long )ic < param.max_conf)) {
#line 2617
      goto while_break___0;
    }
    {
#line 2618
    zero_init_cache_node(pers_mcb, (unsigned long )ic);
#line 2617
    ic = (Conf_no )((int )ic + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2620
  ic = (Conf_no )1;
  {
#line 2620
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2620
    if (! ((unsigned long )ic < param.max_conf)) {
#line 2620
      goto while_break___1;
    }
    {
#line 2621
    zero_init_cache_node(conf_mcb, (unsigned long )ic);
#line 2620
    ic = (Conf_no )((int )ic + 1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2623
  it = (Text_no )1;
  {
#line 2623
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2623
    if (! (it < param.max_text)) {
#line 2623
      goto while_break___2;
    }
    {
#line 2624
    zero_init_cache_node(text_mcb, it);
#line 2623
    it ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2628
  datafile_version = -1L;
#line 2630
  text_file = i_fopen((char const   *)param.textfile_name, "a+b");
  }
#line 2630
  if ((unsigned long )text_file == (unsigned long )((void *)0)) {
    {
#line 2632
    tmp___0 = __errno_location();
#line 2632
    restart_kom("%s \"%s\". errno = %d\n", "ERROR: init_cache: can\'t open text file",
                param.textfile_name, *tmp___0);
    }
  }
  {
#line 2637
  tmp___2 = is_clean((char const   *)param.datafile_name);
  }
#line 2637
  if (tmp___2) {
    {
#line 2639
    file_a = i_fopen((char const   *)param.datafile_name, "rb");
    }
#line 2639
    if ((unsigned long )file_a == (unsigned long )((void *)0)) {
      {
#line 2641
      kom_log("WARNING: init_cache: can\'t open datafile.\n");
#line 2642
      kom_errno = (enum kom_err )51;
#line 2643
      err_stat = 0UL;
      }
#line 2644
      return ((Success )FAILURE);
    }
    {
#line 2646
    kom_log("MSG: init_cache: using datafile.\n");
#line 2647
    datafile_version = get_version((char const   *)param.datafile_name);
#line 2648
    boottime_info.db_status = s_fcrea_str("clean");
    }
  } else {
    {
#line 2650
    tmp___1 = is_clean((char const   *)param.backupfile_name);
    }
#line 2650
    if (tmp___1) {
      {
#line 2652
      file_a = i_fopen((char const   *)param.backupfile_name, "rb");
      }
#line 2652
      if ((unsigned long )file_a == (unsigned long )((void *)0)) {
        {
#line 2654
        kom_log("WARNING: init_cache: can\'t open backupfile.\n");
#line 2655
        kom_errno = (enum kom_err )51;
#line 2656
        err_stat = 0UL;
        }
#line 2657
        return ((Success )FAILURE);
      }
      {
#line 2659
      kom_log("MSG: init_cache: using backup file.\n");
#line 2660
      datafile_version = get_version((char const   *)param.backupfile_name);
#line 2661
      boottime_info.db_status = s_fcrea_str("backup");
      }
    } else {
      {
#line 2668
      kom_log("WARNING: init_cache: can\'t find old data base.\n");
#line 2669
      kom_errno = (enum kom_err )51;
#line 2670
      err_stat = 0UL;
      }
#line 2671
      return ((Success )FAILURE);
    }
  }
  {
#line 2676
  if (datafile_version == 0L) {
#line 2676
    goto case_0;
  }
#line 2679
  if (datafile_version == 1L) {
#line 2679
    goto case_1;
  }
#line 2683
  if (datafile_version == 2L) {
#line 2683
    goto case_2;
  }
#line 2699
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 2677
  restart_kom("Database is version 0. Please convert it with dbck.\n");
  }
#line 2678
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2680
  fseek(file_a, 12L, 0);
#line 2681
  restart_kom("You need to run dbck to convert your datafile to version 2.\n");
  }
#line 2682
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2688
  fseek(file_a, 12L, 0);
#line 2689
  tmp___3 = fparse_long(file_a);
#line 2689
  saved_time.tv_sec = (__time_t )tmp___3;
#line 2690
  saved_time.tv_usec = (__suseconds_t )0;
#line 2691
  tmp___4 = timeval_greater(saved_time, current_time);
  }
#line 2691
  if (tmp___4) {
    {
#line 2693
    restart_kom("Saved time is later than current time. Exiting.\n");
    }
  }
  {
#line 2695
  tmp___5 = ctime((time_t const   *)(& saved_time.tv_sec));
#line 2695
  kom_log("Database saved on %s", tmp___5);
#line 2697
  boottime_info.save_time = saved_time.tv_sec;
  }
#line 2698
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2700
  restart_kom("Can\'t read database version %ld. Giving up.\n", datafile_version);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 2704
  set_input_format((int )datafile_version);
#line 2706
  record = 1L;
  }
  {
#line 2706
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2706
    if (! (! done)) {
#line 2706
      goto while_break___3;
    }
    {
#line 2708
    fskipwhite(file_a);
#line 2709
    c = _IO_getc(file_a);
    }
    {
#line 2711
    if (c == -1) {
#line 2711
      goto case_neg_1;
    }
#line 2716
    if (c == 43) {
#line 2716
      goto case_43;
    }
#line 2716
    if (c == 64) {
#line 2716
      goto case_43;
    }
#line 2720
    if (c == 35) {
#line 2720
      goto case_35;
    }
#line 2737
    if (c == 45) {
#line 2737
      goto case_45;
    }
#line 2788
    if (c == 73) {
#line 2788
      goto case_73;
    }
#line 2793
    if (c == 67) {
#line 2793
      goto case_67___1;
    }
#line 2826
    if (c == 80) {
#line 2826
      goto case_80___0;
    }
#line 2852
    if (c == 84) {
#line 2852
      goto case_84___1;
    }
#line 2878
    goto switch_default___2;
    case_neg_1: /* CIL Label */ 
#line 2712
    done = (Bool )1;
#line 2713
    goto switch_break___0;
    case_43: /* CIL Label */ 
    case_64: /* CIL Label */ 
    {
#line 2717
    restart_kom("init_cache(): old type record in new type file\n");
    }
#line 2718
    goto switch_break___0;
    case_35: /* CIL Label */ 
    {
#line 2721
    fskipwhite(file_a);
#line 2722
    tmp___6 = _IO_getc(file_a);
    }
    {
#line 2724
    if (tmp___6 == 67) {
#line 2724
      goto case_67;
    }
#line 2728
    if (tmp___6 == 84) {
#line 2728
      goto case_84;
    }
#line 2732
    goto switch_default___0;
    case_67: /* CIL Label */ 
    {
#line 2725
    tmp___7 = fparse_long(file_a);
#line 2725
    next_free_num = (Conf_no )tmp___7;
#line 2726
    read_conf_no = (Bool )1;
    }
#line 2727
    goto switch_break___1;
    case_84: /* CIL Label */ 
    {
#line 2729
    next_text_num = fparse_long(file_a);
#line 2730
    read_text_no = (Bool )1;
    }
#line 2731
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 2733
    restart_kom("init_cache(): Bad number in database\n");
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 2735
    goto switch_break___0;
    case_45: /* CIL Label */ 
    {
#line 2738
    fskipwhite(file_a);
#line 2739
    tmp___8 = _IO_getc(file_a);
    }
    {
#line 2741
    if (tmp___8 == 67) {
#line 2741
      goto case_67___0;
    }
#line 2755
    if (tmp___8 == 80) {
#line 2755
      goto case_80;
    }
#line 2769
    if (tmp___8 == 84) {
#line 2769
      goto case_84___0;
    }
#line 2783
    goto switch_default___1;
    case_67___0: /* CIL Label */ 
    {
#line 2742
    tmp___9 = fparse_long(file_a);
#line 2742
    num = (long )tmp___9;
#line 2743
    node = get_conf_node((Conf_no )num);
    }
#line 2744
    if (node) {
#line 2746
      if (node->s.exists) {
        {
#line 2748
        update_stat((enum stat_type )6, -1L);
#line 2749
        node->s.exists = 0U;
#line 2750
        node->pos = -1L;
        }
      }
    }
#line 2753
    goto switch_break___2;
    case_80: /* CIL Label */ 
    {
#line 2756
    tmp___10 = fparse_long(file_a);
#line 2756
    num = (long )tmp___10;
#line 2757
    node = get_pers_node((Pers_no )num);
    }
#line 2758
    if (node) {
#line 2760
      if (node->s.exists) {
        {
#line 2762
        update_stat((enum stat_type )7, -1L);
#line 2763
        node->s.exists = 0U;
#line 2764
        node->pos = -1L;
        }
      }
    }
#line 2767
    goto switch_break___2;
    case_84___0: /* CIL Label */ 
    {
#line 2770
    tmp___11 = fparse_long(file_a);
#line 2770
    num = (long )tmp___11;
#line 2771
    node = get_text_node((Text_no )num);
    }
#line 2772
    if (node) {
#line 2774
      if (node->s.exists) {
        {
#line 2776
        update_stat((enum stat_type )5, -1L);
#line 2777
        node->s.exists = 0U;
#line 2778
        node->pos = -1L;
        }
      }
    }
#line 2781
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 2784
    restart_kom("init_cache(): bad remove block in data file\n");
    }
    switch_break___2: /* CIL Label */ ;
    }
    case_73: /* CIL Label */ 
    {
#line 2789
    tmp___12 = fparse_info(file_a, & kom_info);
    }
#line 2789
    if ((unsigned long )tmp___12 != (unsigned long )OK) {
      {
#line 2790
      restart_kom("init_cache(): fparse_info() failed.\n");
      }
    }
#line 2791
    goto switch_break___0;
    case_67___1: /* CIL Label */ 
    {
#line 2794
    tmp___13 = ftell(file_a);
#line 2794
    pos = tmp___13 - 1L;
#line 2795
    tmp___14 = fparse_long(file_a);
#line 2795
    num = (long )tmp___14;
    }
#line 2798
    if (num < 1L) {
      {
#line 2800
      restart_kom("ERROR: init_cache(), bad conf_no %ld at record %ld\n", num, record);
      }
    }
    {
#line 2805
    node = get_conf_node((Conf_no )num);
    }
#line 2806
    if (! node) {
      {
#line 2808
      create_cache_node(conf_mcb, (unsigned long )num);
#line 2809
      node = get_conf_node((Conf_no )num);
#line 2810
      update_stat((enum stat_type )6, 1L);
      }
    }
    {
#line 2813
    node->s.exists = 1U;
#line 2814
    node->pos = pos;
#line 2816
    tmp___15 = fparse_conference(file_a, & tmp_conf);
    }
#line 2816
    if ((unsigned long )tmp___15 != (unsigned long )OK) {
      {
#line 2817
      restart_kom("init_cache(): fparse_conference() failed at record %ld.\n", record);
      }
    }
    {
#line 2821
    tmp___16 = ftell(file_a);
#line 2821
    node->size = tmp___16 - node->pos;
#line 2822
    setup_small_conf((Conf_no )num, & tmp_conf);
#line 2823
    clear_conference(& tmp_conf);
    }
#line 2824
    goto switch_break___0;
    case_80___0: /* CIL Label */ 
    {
#line 2827
    tmp___17 = ftell(file_a);
#line 2827
    pos = tmp___17 - 1L;
#line 2828
    tmp___18 = fparse_long(file_a);
#line 2828
    num = (long )tmp___18;
#line 2831
    node = get_pers_node((Pers_no )num);
    }
#line 2832
    if (! node) {
      {
#line 2834
      create_cache_node(pers_mcb, (unsigned long )num);
#line 2835
      node = get_pers_node((Pers_no )num);
#line 2836
      update_stat((enum stat_type )7, 1L);
      }
    }
    {
#line 2839
    node->s.exists = 1U;
#line 2840
    node->pos = pos;
#line 2842
    tmp___19 = fparse_person(file_a, & tmp_pers);
    }
#line 2842
    if ((unsigned long )tmp___19 != (unsigned long )OK) {
      {
#line 2843
      restart_kom("init_cache: fparse_person failed at record %ld.\n", record);
      }
    }
    {
#line 2847
    tmp___20 = ftell(file_a);
#line 2847
    node->size = tmp___20 - node->pos;
#line 2848
    clear_person(& tmp_pers);
    }
#line 2850
    goto switch_break___0;
    case_84___1: /* CIL Label */ 
    {
#line 2853
    tmp___21 = ftell(file_a);
#line 2853
    pos = tmp___21 - 1L;
#line 2854
    tmp___22 = fparse_long(file_a);
#line 2854
    num = (long )tmp___22;
#line 2857
    node = get_text_node((Text_no )num);
    }
#line 2858
    if (! node) {
      {
#line 2860
      create_cache_node(text_mcb, (unsigned long )num);
#line 2861
      node = get_text_node((Text_no )num);
#line 2862
      update_stat((enum stat_type )5, 1L);
      }
    }
    {
#line 2865
    node->s.exists = 1U;
#line 2867
    node->pos = pos;
#line 2869
    tmp___23 = fparse_text_stat(file_a, & tmp_text);
    }
#line 2869
    if ((unsigned long )tmp___23 != (unsigned long )OK) {
      {
#line 2870
      restart_kom("init_cache(): fparse_text_stat failed at record %ld.\n", record);
      }
    }
    {
#line 2874
    tmp___24 = ftell(file_a);
#line 2874
    node->size = tmp___24 - node->pos;
#line 2875
    clear_text_stat(& tmp_text);
    }
#line 2876
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
    {
#line 2879
    tmp___25 = ftell(file_a);
#line 2879
    restart_kom("init_cache(): Unknown key %c (%d) in data file at %lu\n", c, c, (unsigned long )tmp___25);
    }
#line 2882
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 2706
    record ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2886
  if ((unsigned int )read_conf_no == 0U) {
    {
#line 2888
    restart_kom("init_cache(): highest text or conf no not read!\n");
    }
  } else
#line 2886
  if ((unsigned int )read_text_no == 0U) {
    {
#line 2888
    restart_kom("init_cache(): highest text or conf no not read!\n");
    }
  }
  {
#line 2891
  build_matching_info();
#line 2894
  kom_log("Read %d confs/persons and %ld texts\n", (int )next_free_num, next_text_num);
#line 2897
  read_number_file();
#line 2899
  boottime_info.highest_text_no = next_text_num - 1UL;
#line 2900
  boottime_info.highest_conf_no = (Conf_no )((int )next_free_num - 1);
#line 2901
  tmp___26 = read_stat_value((enum stat_type )5);
#line 2901
  boottime_info.existing_texts = (Text_no )tmp___26;
#line 2902
  tmp___27 = read_stat_value((enum stat_type )6);
#line 2902
  boottime_info.existing_confs = (Conf_no )tmp___27;
#line 2903
  tmp___28 = read_stat_value((enum stat_type )7);
#line 2903
  boottime_info.existing_persons = (Conf_no )tmp___28;
  }
#line 2905
  return ((Success )OK);
}
}
#line 2908 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
extern void cache_sync_all(void) 
{ 
  struct timeval tmp ;
  Bool tmp___0 ;

  {
#line 2911
  if (param.never_save) {
#line 2912
    return;
  }
  {
#line 2919
  pre_sync();
  }
  {
#line 2920
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2920
    tmp = sync_part();
#line 2920
    tmp___0 = timeval_zero(tmp);
    }
#line 2920
    if (! tmp___0) {
#line 2920
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2922
  return;
}
}
#line 2958 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
void free_all_cache(void) 
{ 
  unsigned int i ;
  Cache_node *node ;

  {
#line 2969
  i = 1U;
  {
#line 2969
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2969
    if (! (i < (unsigned int )next_free_num)) {
#line 2969
      goto while_break;
    }
    {
#line 2971
    node = get_conf_node((Conf_no )i);
    }
#line 2972
    if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 2974
      if ((unsigned long )node->snap_shot != (unsigned long )((void *)0)) {
        {
#line 2976
        free_conference((Conference *)node->snap_shot);
#line 2977
        node->snap_shot = (void *)0;
        }
      }
#line 2980
      if ((unsigned long )node->ptr != (unsigned long )((void *)0)) {
        {
#line 2982
        free_conference((Conference *)node->ptr);
#line 2983
        node->ptr = (void *)0;
        }
      }
    }
    {
#line 2987
    destruct_cache_node(conf_mcb, (unsigned long )i);
#line 2989
    node = get_pers_node((Pers_no )i);
    }
#line 2990
    if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 2992
      if ((unsigned long )node->snap_shot != (unsigned long )((void *)0)) {
        {
#line 2994
        free_person((Person *)node->snap_shot);
#line 2995
        node->snap_shot = (void *)0;
        }
      }
#line 2998
      if ((unsigned long )node->ptr != (unsigned long )((void *)0)) {
        {
#line 3000
        free_person((Person *)node->ptr);
#line 3001
        node->ptr = (void *)0;
        }
      }
    }
    {
#line 3005
    destruct_cache_node(pers_mcb, (unsigned long )i);
    }
#line 3007
    if ((unsigned long )*(small_conf_arr + i) != (unsigned long )((void *)0)) {
      {
#line 3009
      free_small_conf(*(small_conf_arr + i));
#line 3010
      *(small_conf_arr + i) = (Small_conf *)((void *)0);
      }
    }
#line 2969
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3014
  i = 1U;
  {
#line 3014
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3014
    if (! ((Text_no )i < next_text_num)) {
#line 3014
      goto while_break___0;
    }
    {
#line 3016
    node = get_text_node((Text_no )i);
    }
#line 3017
    if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 3019
      if ((unsigned long )node->snap_shot != (unsigned long )((void *)0)) {
        {
#line 3021
        free_text_stat((Text_stat *)node->snap_shot);
#line 3022
        node->snap_shot = (void *)0;
        }
      }
#line 3025
      if ((unsigned long )node->ptr != (unsigned long )((void *)0)) {
        {
#line 3027
        free_text_stat((Text_stat *)node->ptr);
#line 3028
        node->ptr = (void *)0;
        }
      }
    }
    {
#line 3032
    destruct_cache_node(text_mcb, (unsigned long )i);
#line 3014
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3035
  free_match_table(match_table);
#line 3037
  free_cache_node_mcb(conf_mcb);
#line 3038
  free_cache_node_mcb(text_mcb);
#line 3039
  free_cache_node_mcb(pers_mcb);
#line 3040
  sfree((void *)small_conf_arr);
#line 3042
  sfree((void *)match_table);
  }
#line 3043
  return;
}
}
#line 3049 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static Bool throwable_p(Cache_node *node ) 
{ 
  int tmp ;

  {
#line 3052
  if (node->s.dirty == 0U) {
#line 3052
    goto _L;
  } else
#line 3052
  if (node->s.exists == 0U) {
    _L: /* CIL Label */ 
#line 3052
    if ((unsigned long )node->snap_shot == (unsigned long )((void *)0)) {
#line 3052
      if (node->lock_cnt == 0) {
#line 3052
        tmp = 1;
      } else {
#line 3052
        tmp = 0;
      }
    } else {
#line 3052
      tmp = 0;
    }
  } else {
#line 3052
    tmp = 0;
  }
#line 3052
  return ((Bool )tmp);
}
}
#line 3057 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void limit_pers(void) 
{ 
  Cache_node *node ;
  Cache_node *next_node ;
  int i ;
  Bool tmp ;
  Bool tmp___0 ;

  {
#line 3064
  node = pers_mcb->mru;
#line 3067
  i = 0;
  {
#line 3067
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3067
    if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 3067
      if (! (i < param.cache_persons)) {
#line 3067
        goto while_break;
      }
    } else {
#line 3067
      goto while_break;
    }
    {
#line 3069
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3069
      if ((unsigned long )node != (unsigned long )((void *)0)) {
        {
#line 3069
        tmp = throwable_p(node);
        }
#line 3069
        if (tmp) {
#line 3069
          goto while_break___0;
        }
      } else {
#line 3069
        goto while_break___0;
      }
#line 3070
      node = node->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3072
    if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 3073
      node = node->next;
    }
#line 3067
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3077
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3077
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 3077
      goto while_break___1;
    }
    {
#line 3079
    next_node = node->next;
#line 3080
    tmp___0 = throwable_p(node);
    }
#line 3080
    if (tmp___0) {
      {
#line 3083
      unlink_pers_lru(node);
#line 3084
      free_person((Person *)node->ptr);
#line 3085
      node->ptr = (void *)0;
      }
    }
#line 3088
    node = next_node;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3090
  return;
}
}
#line 3092 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void limit_conf(void) 
{ 
  Cache_node *node ;
  Cache_node *next_node ;
  int i ;
  Bool tmp ;
  Bool tmp___0 ;

  {
#line 3099
  node = conf_mcb->mru;
#line 3102
  i = 0;
  {
#line 3102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3102
    if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 3102
      if (! (i < param.cache_conferences)) {
#line 3102
        goto while_break;
      }
    } else {
#line 3102
      goto while_break;
    }
    {
#line 3104
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3104
      if ((unsigned long )node != (unsigned long )((void *)0)) {
        {
#line 3104
        tmp = throwable_p(node);
        }
#line 3104
        if (tmp) {
#line 3104
          goto while_break___0;
        }
      } else {
#line 3104
        goto while_break___0;
      }
#line 3105
      node = node->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3107
    if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 3108
      node = node->next;
    }
#line 3102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3112
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3112
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 3112
      goto while_break___1;
    }
    {
#line 3114
    next_node = node->next;
#line 3115
    tmp___0 = throwable_p(node);
    }
#line 3115
    if (tmp___0) {
      {
#line 3117
      unlink_conf_lru(node);
#line 3118
      free_conference((Conference *)node->ptr);
#line 3119
      node->ptr = (void *)0;
      }
    }
#line 3122
    node = next_node;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3124
  return;
}
}
#line 3127 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
static void limit_text_stat(void) 
{ 
  Cache_node *node ;
  Cache_node *next_node ;
  int i ;
  Bool tmp ;
  Bool tmp___0 ;

  {
#line 3134
  node = text_mcb->mru;
#line 3137
  i = 0;
  {
#line 3137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3137
    if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 3137
      if (! (i < param.cache_text_stats)) {
#line 3137
        goto while_break;
      }
    } else {
#line 3137
      goto while_break;
    }
    {
#line 3139
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3139
      if ((unsigned long )node != (unsigned long )((void *)0)) {
        {
#line 3139
        tmp = throwable_p(node);
        }
#line 3139
        if (tmp) {
#line 3139
          goto while_break___0;
        }
      } else {
#line 3139
        goto while_break___0;
      }
#line 3140
      node = node->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3142
    if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 3143
      node = node->next;
    }
#line 3137
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3147
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3147
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 3147
      goto while_break___1;
    }
    {
#line 3149
    next_node = node->next;
#line 3150
    tmp___0 = throwable_p(node);
    }
#line 3150
    if (tmp___0) {
      {
#line 3152
      unlink_text_lru(node);
#line 3153
      free_text_stat((Text_stat *)node->ptr);
#line 3154
      node->ptr = (void *)0;
      }
    }
#line 3157
    node = next_node;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3159
  return;
}
}
#line 3166 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
void cache_limit_size(void) 
{ 


  {
  {
#line 3169
  limit_pers();
#line 3170
  limit_conf();
#line 3171
  limit_text_stat();
  }
#line 3172
  return;
}
}
#line 3174 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
void dump_cache_mem_usage(FILE *fp ) 
{ 


  {
  {
#line 3177
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"---simple-cache.c:\n");
#line 3178
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\tSmall_confs: %d\n",
          no_of_allocated_small_confs);
  }
#line 3179
  return;
}
}
#line 3182 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
void dump_cache_stats(FILE *fp ) 
{ 


  {
  {
#line 3185
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"---simple-cache.c:\n");
#line 3186
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\tPersons (cache size: %d):\n",
          param.cache_persons);
#line 3187
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t hits:  %lu\n\t miss:  %lu\n",
          pers_mcb->hits, pers_mcb->misses);
#line 3189
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\tConferences (cache size: %d):\n",
          param.cache_conferences);
#line 3190
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t hits:  %lu\n\t miss:  %lu\n",
          conf_mcb->hits, conf_mcb->misses);
#line 3192
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\tText_stats (cache size: %d):\n",
          param.cache_text_stats);
#line 3193
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t hits:  %lu\n\t miss:  %lu\n",
          text_mcb->hits, text_mcb->misses);
  }
#line 3195
  return;
}
}
#line 3198 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
Text_no query_next_text_num(void) 
{ 


  {
#line 3201
  return (next_text_num);
}
}
#line 3204 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
Conf_no query_next_conf_no(void) 
{ 


  {
#line 3207
  return (next_free_num);
}
}
#line 3210 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
void tell_cache_garb_text(int running ) 
{ 


  {
#line 3218
  running = running;
#line 3220
  return;
}
}
#line 3222 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/simple-cache.c"
Success get_boottime_info(Static_server_info *result ) 
{ 


  {
  {
#line 3225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3225
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 3225
      err_stat = 0UL;
#line 3225
      kom_errno = (enum kom_err )51;
#line 3225
      return ((Success )FAILURE);
    }
#line 3225
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3226
  *result = boottime_info;
#line 3227
  return ((Success )OK);
}
}
#line 45 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/oop-malloc.c"
static int no_of_allocated_blocks___4  =    0;
#line 47 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/oop-malloc.c"
void *oop_malloc_wrapper(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 50
  no_of_allocated_blocks___4 ++;
#line 51
  tmp = smalloc(size);
  }
#line 51
  return (tmp);
}
}
#line 55 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/oop-malloc.c"
void oop_free_wrapper(void *ptr ) 
{ 


  {
  {
#line 58
  no_of_allocated_blocks___4 --;
#line 59
  sfree(ptr);
  }
#line 60
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/oop-malloc.c"
void *oop_realloc_wrapper(void *ptr , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 66
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 67
    tmp = oop_malloc_wrapper(size);
    }
#line 67
    return (tmp);
  }
  {
#line 69
  tmp___0 = srealloc(ptr, size);
  }
#line 69
  return (tmp___0);
}
}
#line 73 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/oop-malloc.c"
void dump_oop_alloc_counts(FILE *stat_file ) 
{ 


  {
  {
#line 76
  fprintf((FILE */* __restrict  */)stat_file, (char const   */* __restrict  */)"---%s:\n\tAllocated blocks by liboop: %d\n",
          "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/oop-malloc.c",
          no_of_allocated_blocks___4);
  }
#line 78
  return;
}
}
#line 58 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/log.c"
static void kom_logv___0(char const   *format , va_list AP ) ;
#line 71 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/log.c"
static void kom_logv___0(char const   *format , va_list AP ) 
{ 
  time_t clk ;
  struct tm *t ;
  __pid_t tmp ;

  {
  {
#line 77
  time(& clk);
#line 78
  t = localtime((time_t const   *)(& clk));
#line 80
  tmp = getpid();
#line 80
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02d%02d%02d %02d:%02d:%02d %ld ",
          t->tm_year % 100, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec,
          (long )tmp);
#line 83
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           AP);
#line 85
  fflush(stderr);
  }
#line 86
  return;
}
}
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 834 "./../libraries/adns/src/adns.h"
extern char const   *adns_strerror(adns_status st ) ;
#line 28 "./../libraries/liboop/oop.h"
static struct timeval  const  OOP_TIME_NOW___0  =    {(__time_t )0, (__suseconds_t )0};
#line 34
extern int _oop_error ;
#line 76
extern void *oop_sys_run(oop_source_sys * ) ;
#line 146 "./../libraries/libmisc/s-string.h"
extern Success s_crea_str(String *dest_string , char const   *c_string ) ;
#line 447
extern Success s_trim_left(String *str , String_size rm ) ;
#line 172 "./../libraries/libisc-new/src/isc.h"
extern void isc_set_read_callback(struct isc_scb *session , oop_call_fd *data_available_cb ,
                                  isc_write_error_cb *write_error_cb , isc_stale_output_cb *stale_output_cb ,
                                  isc_stale_output_cb *idle_cb ) ;
#line 190
extern int isc_destroy(struct isc_mcb *mcb , struct isc_scb *scb ) ;
#line 205
extern enum isc_read_result isc_read_data(struct isc_scb *scb , String *result , String_size *unused ) ;
#line 252
extern int isc_enable(struct isc_scb *scb ) ;
#line 278
extern char *isc_getipnum(union isc_address *ia , char *address , int len ) ;
#line 291
extern int isc_resolve_remote(struct isc_scb *scb , isc_resolve_done_cb *callback ) ;
#line 298
extern oop_source *isc_getoopsource(struct isc_scb *scb ) ;
#line 347 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
unsigned long service_statistics[sizeof(fnc_defs) / sizeof(Fnc_descriptor )]  ;
#line 349 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.h"
jmp_buf parse_env  ;
#line 83 "./../include/services.h"
Success set_scheduling(Session_no session_no , unsigned short priority , unsigned short weight ) ;
#line 102
Success get_scheduling(Session_no session_no , Scheduling_info *result ) ;
#line 92 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
oop_source_sys *kom_server_oop_src  =    (oop_source_sys *)((void *)0);
#line 93 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
struct isc_mcb *kom_server_mcb  =    (struct isc_mcb *)((void *)0);
#line 94 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
Connection *active_connection  =    (Connection *)((void *)0);
#line 102 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
Bool go_and_die  =    (Bool )0;
#line 108 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static unsigned int penalty_generation  =    0U;
#line 115 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static Bool work_done  =    (Bool )0;
#line 116 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static Bool is_idle  =    (Bool )0;
#line 121 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
Fnc_descriptor const   fnc_defs[124]  = 
#line 121
  {      {(enum call_header )0, (enum res_type )1, & prot_a_parse_arg_login_old}, 
        {(enum call_header )1, (enum res_type )1, & prot_a_parse_arg_logout}, 
        {(enum call_header )2, (enum res_type )1, & prot_a_parse_arg_change_conference}, 
        {(enum call_header )3,
      (enum res_type )1, & prot_a_parse_arg_change_name}, 
        {(enum call_header )4, (enum res_type )1, & prot_a_parse_arg_change_what_i_am_doing}, 
        {(enum call_header )5,
      (enum res_type )0, & prot_a_parse_arg_create_person_old}, 
        {(enum call_header )6, (enum res_type )2, & prot_a_parse_arg_get_person_stat_old}, 
        {(enum call_header )7,
      (enum res_type )1, & prot_a_parse_arg_set_priv_bits}, 
        {(enum call_header )8, (enum res_type )1, & prot_a_parse_arg_set_passwd}, 
        {(enum call_header )9, (enum res_type )4, & prot_a_parse_arg_query_read_texts_old}, 
        {(enum call_header )10,
      (enum res_type )0, & prot_a_parse_arg_create_conf_old}, 
        {(enum call_header )11, (enum res_type )1, & prot_a_parse_arg_delete_conf}, 
        {(enum call_header )12, (enum res_type )6, & prot_a_parse_arg_lookup_name}, 
        {(enum call_header )13, (enum res_type )8, & prot_a_parse_arg_get_conf_stat_older}, 
        {(enum call_header )14,
      (enum res_type )1, & prot_a_parse_arg_add_member_old}, 
        {(enum call_header )15, (enum res_type )1, & prot_a_parse_arg_sub_member}, 
        {(enum call_header )16, (enum res_type )1, & prot_a_parse_arg_set_presentation}, 
        {(enum call_header )17,
      (enum res_type )1, & prot_a_parse_arg_set_etc_motd}, 
        {(enum call_header )18, (enum res_type )1, & prot_a_parse_arg_set_supervisor}, 
        {(enum call_header )19,
      (enum res_type )1, & prot_a_parse_arg_set_permitted_submitters}, 
        {(enum call_header )20, (enum res_type )1, & prot_a_parse_arg_set_super_conf}, 
        {(enum call_header )21,
      (enum res_type )1, & prot_a_parse_arg_set_conf_type}, 
        {(enum call_header )22, (enum res_type )1, & prot_a_parse_arg_set_garb_nice}, 
        {(enum call_header )23,
      (enum res_type )10, & prot_a_parse_arg_get_marks}, 
        {(enum call_header )24, (enum res_type )1, & prot_a_parse_arg_mark_text_old}, 
        {(enum call_header )25,
      (enum res_type )9, & prot_a_parse_arg_get_text}, 
        {(enum call_header )26, (enum res_type )11, & prot_a_parse_arg_get_text_stat_old}, 
        {(enum call_header )27,
      (enum res_type )1, & prot_a_parse_arg_mark_as_read}, 
        {(enum call_header )28, (enum res_type )0, & prot_a_parse_arg_create_text_old}, 
        {(enum call_header )29,
      (enum res_type )1, & prot_a_parse_arg_delete_text}, 
        {(enum call_header )30, (enum res_type )1, & prot_a_parse_arg_add_recipient}, 
        {(enum call_header )31,
      (enum res_type )1, & prot_a_parse_arg_sub_recipient}, 
        {(enum call_header )32, (enum res_type )1, & prot_a_parse_arg_add_comment}, 
        {(enum call_header )33, (enum res_type )1, & prot_a_parse_arg_sub_comment}, 
        {(enum call_header )34, (enum res_type )36, & prot_a_parse_arg_get_map}, 
        {(enum call_header )35, (enum res_type )20, & prot_a_parse_arg_get_time}, 
        {(enum call_header )36, (enum res_type )14, & prot_a_parse_arg_get_info_old}, 
        {(enum call_header )37,
      (enum res_type )1, & prot_a_parse_arg_add_footnote}, 
        {(enum call_header )38, (enum res_type )1, & prot_a_parse_arg_sub_footnote}, 
        {(enum call_header )39, (enum res_type )13, & prot_a_parse_arg_who_is_on_old}, 
        {(enum call_header )40,
      (enum res_type )1, & prot_a_parse_arg_set_unread}, 
        {(enum call_header )41, (enum res_type )1, & prot_a_parse_arg_set_motd_of_lyskom}, 
        {(enum call_header )42,
      (enum res_type )1, & prot_a_parse_arg_enable}, 
        {(enum call_header )43, (enum res_type )1, & prot_a_parse_arg_sync_kom}, 
        {(enum call_header )44, (enum res_type )1, & prot_a_parse_arg_shutdown_kom}, 
        {(enum call_header )45, (enum res_type )1, & prot_a_parse_arg_broadcast}, 
        {(enum call_header )46, (enum res_type )16, & prot_a_parse_arg_get_membership_old}, 
        {(enum call_header )47,
      (enum res_type )36, & prot_a_parse_arg_get_created_texts}, 
        {(enum call_header )48, (enum res_type )19, & prot_a_parse_arg_get_members_old}, 
        {(enum call_header )49,
      (enum res_type )2, & prot_a_parse_arg_get_person_stat}, 
        {(enum call_header )50, (enum res_type )8, & prot_a_parse_arg_get_conf_stat_old}, 
        {(enum call_header )51,
      (enum res_type )12, & prot_a_parse_arg_who_is_on}, 
        {(enum call_header )52, (enum res_type )7, & prot_a_parse_arg_get_unread_confs}, 
        {(enum call_header )53,
      (enum res_type )1, & prot_a_parse_arg_send_message}, 
        {(enum call_header )54, (enum res_type )21, & prot_a_parse_arg_get_session_info}, 
        {(enum call_header )55,
      (enum res_type )1, & prot_a_parse_arg_disconnect}, 
        {(enum call_header )56, (enum res_type )22, & prot_a_parse_arg_who_am_i}, 
        {(enum call_header )57, (enum res_type )1, & prot_a_parse_arg_set_user_area}, 
        {(enum call_header )58,
      (enum res_type )23, & prot_a_parse_arg_get_last_text}, 
        {(enum call_header )59, (enum res_type )0, & prot_a_parse_arg_create_anonymous_text_old}, 
        {(enum call_header )60,
      (enum res_type )23, & prot_a_parse_arg_find_next_text_no}, 
        {(enum call_header )61, (enum res_type )23, & prot_a_parse_arg_find_previous_text_no}, 
        {(enum call_header )62,
      (enum res_type )1, & prot_a_parse_arg_login}, 
        {(enum call_header )63, (enum res_type )26, & prot_a_parse_arg_who_is_on_ident}, 
        {(enum call_header )64,
      (enum res_type )25, & prot_a_parse_arg_get_session_info_ident}, 
        {(enum call_header )65, (enum res_type )7, & prot_a_parse_arg_re_lookup_person}, 
        {(enum call_header )66,
      (enum res_type )7, & prot_a_parse_arg_re_lookup_conf}, 
        {(enum call_header )67, (enum res_type )7, & prot_a_parse_arg_lookup_person}, 
        {(enum call_header )68,
      (enum res_type )7, & prot_a_parse_arg_lookup_conf}, 
        {(enum call_header )69, (enum res_type )1, & prot_a_parse_arg_set_client_version}, 
        {(enum call_header )70,
      (enum res_type )9, & prot_a_parse_arg_get_client_name}, 
        {(enum call_header )71, (enum res_type )9, & prot_a_parse_arg_get_client_version}, 
        {(enum call_header )72,
      (enum res_type )1, & prot_a_parse_arg_mark_text}, 
        {(enum call_header )73, (enum res_type )1, & prot_a_parse_arg_unmark_text}, 
        {(enum call_header )74, (enum res_type )27, & prot_a_parse_arg_re_z_lookup}, 
        {(enum call_header )75, (enum res_type )28, & prot_a_parse_arg_get_version_info}, 
        {(enum call_header )76,
      (enum res_type )27, & prot_a_parse_arg_lookup_z_name}, 
        {(enum call_header )77, (enum res_type )1, & prot_a_parse_arg_set_last_read}, 
        {(enum call_header )78,
      (enum res_type )29, & prot_a_parse_arg_get_uconf_stat}, 
        {(enum call_header )79, (enum res_type )1, & prot_a_parse_arg_set_info}, 
        {(enum call_header )80, (enum res_type )1, & prot_a_parse_arg_accept_async}, 
        {(enum call_header )81, (enum res_type )30, & prot_a_parse_arg_query_async}, 
        {(enum call_header )82, (enum res_type )1, & prot_a_parse_arg_user_active}, 
        {(enum call_header )83, (enum res_type )31, & prot_a_parse_arg_who_is_on_dynamic}, 
        {(enum call_header )84,
      (enum res_type )32, & prot_a_parse_arg_get_static_session_info}, 
        {(enum call_header )85, (enum res_type )9, & prot_a_parse_arg_get_collate_table}, 
        {(enum call_header )86,
      (enum res_type )0, & prot_a_parse_arg_create_text}, 
        {(enum call_header )87, (enum res_type )0, & prot_a_parse_arg_create_anonymous_text}, 
        {(enum call_header )88,
      (enum res_type )0, & prot_a_parse_arg_create_conf}, 
        {(enum call_header )89, (enum res_type )0, & prot_a_parse_arg_create_person}, 
        {(enum call_header )90,
      (enum res_type )33, & prot_a_parse_arg_get_text_stat}, 
        {(enum call_header )91, (enum res_type )34, & prot_a_parse_arg_get_conf_stat}, 
        {(enum call_header )92,
      (enum res_type )1, & prot_a_parse_arg_modify_text_info}, 
        {(enum call_header )93, (enum res_type )1, & prot_a_parse_arg_modify_conf_info}, 
        {(enum call_header )94,
      (enum res_type )35, & prot_a_parse_arg_get_info}, 
        {(enum call_header )95, (enum res_type )1, & prot_a_parse_arg_modify_system_info}, 
        {(enum call_header )96,
      (enum res_type )30, & prot_a_parse_arg_query_predefined_aux_items}, 
        {(enum call_header )97, (enum res_type )1, & prot_a_parse_arg_set_expire}, 
        {(enum call_header )98, (enum res_type )5, & prot_a_parse_arg_query_read_texts_10}, 
        {(enum call_header )99,
      (enum res_type )17, & prot_a_parse_arg_get_membership_10}, 
        {(enum call_header )100, (enum res_type )1, & prot_a_parse_arg_add_member}, 
        {(enum call_header )101, (enum res_type )18, & prot_a_parse_arg_get_members}, 
        {(enum call_header )102,
      (enum res_type )1, & prot_a_parse_arg_set_membership_type}, 
        {(enum call_header )103, (enum res_type )37, & prot_a_parse_arg_local_to_global}, 
        {(enum call_header )104,
      (enum res_type )37, & prot_a_parse_arg_map_created_texts}, 
        {(enum call_header )105, (enum res_type )1, & prot_a_parse_arg_set_keep_commented}, 
        {(enum call_header )106,
      (enum res_type )1, & prot_a_parse_arg_set_pers_flags}, 
        {(enum call_header )107, (enum res_type )3, & prot_a_parse_arg_query_read_texts}, 
        {(enum call_header )108,
      (enum res_type )15, & prot_a_parse_arg_get_membership}, 
        {(enum call_header )109, (enum res_type )1, & prot_a_parse_arg_mark_as_unread}, 
        {(enum call_header )110,
      (enum res_type )1, & prot_a_parse_arg_set_read_ranges}, 
        {(enum call_header )111, (enum res_type )39, & prot_a_parse_arg_get_stats_description}, 
        {(enum call_header )112,
      (enum res_type )40, & prot_a_parse_arg_get_stats}, 
        {(enum call_header )113, (enum res_type )41, & prot_a_parse_arg_get_boottime_info}, 
        {(enum call_header )114,
      (enum res_type )24, & prot_a_parse_arg_first_unused_conf_no}, 
        {(enum call_header )115, (enum res_type )23, & prot_a_parse_arg_first_unused_text_no}, 
        {(enum call_header )116,
      (enum res_type )24, & prot_a_parse_arg_find_next_conf_no}, 
        {(enum call_header )117, (enum res_type )24, & prot_a_parse_arg_find_previous_conf_no}, 
        {(enum call_header )118,
      (enum res_type )42, & prot_a_parse_arg_get_scheduling}, 
        {(enum call_header )119, (enum res_type )1, & prot_a_parse_arg_set_scheduling}, 
        {(enum call_header )120,
      (enum res_type )1, & prot_a_parse_arg_set_connection_time_format}, 
        {(enum call_header )121, (enum res_type )38, & prot_a_parse_arg_local_to_global_reverse}, 
        {(enum call_header )122,
      (enum res_type )38, & prot_a_parse_arg_map_created_texts_reverse}, 
        {(enum call_header )1009, (enum res_type )1, & prot_a_hunt_nl}};
#line 125 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
int const   num_fnc_defs  =    (int const   )(sizeof(fnc_defs) / sizeof(Fnc_descriptor ));
#line 131
static void *data_available_callback(oop_source *source , int fd , oop_event event ,
                                     void *user ) ;
#line 132
static void *check_kill_flg(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                            struct timeval qazwsxedctv  __attribute__((__unused__)) ,
                            void *qazwsxedcuser  __attribute__((__unused__)) ) ;
#line 133
static void *check_idle_callback(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                                 struct timeval qazwsxedctv  __attribute__((__unused__)) ,
                                 void *qazwsxedcuser  __attribute__((__unused__)) ) ;
#line 134
static void write_err_cb(struct isc_scb *cb_session , int saved_errno ) ;
#line 135
static void stale_cb(struct isc_scb *cb_session ) ;
#line 136
static void idle_cb(struct isc_scb *cb_session ) ;
#line 138 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static Connection *queue_first  =    (Connection *)((void *)0);
#line 139 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static Connection *queue_last  =    (Connection *)((void *)0);
#line 141
static void busy(void) ;
#line 144 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void queue_add(Connection *c ) 
{ 


  {
#line 147
  if (! ((unsigned int )c->on_queue == 0U)) {
    {
#line 147
    __assert_fail("c->on_queue == FALSE", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c",
                  147U, "queue_add");
    }
  }
#line 148
  c->on_queue = (Bool )1;
#line 150
  c->queue_prev = queue_last;
#line 151
  c->queue_next = (struct connection *)((void *)0);
#line 153
  if ((unsigned long )queue_first == (unsigned long )((void *)0)) {
#line 154
    queue_first = c;
  } else {
#line 156
    queue_last->queue_next = c;
  }
  {
#line 158
  queue_last = c;
#line 159
  update_stat((enum stat_type )0, 1L);
  }
#line 160
  return;
}
}
#line 162 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void queue_remove(Connection *c ) 
{ 


  {
#line 165
  if (! ((unsigned int )c->on_queue == 1U)) {
    {
#line 165
    __assert_fail("c->on_queue == TRUE", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c",
                  165U, "queue_remove");
    }
  }
#line 166
  c->on_queue = (Bool )0;
#line 168
  if ((unsigned long )c->queue_next != (unsigned long )((void *)0)) {
#line 169
    (c->queue_next)->queue_prev = c->queue_prev;
  } else {
#line 171
    queue_last = c->queue_prev;
  }
#line 173
  if ((unsigned long )c->queue_prev != (unsigned long )((void *)0)) {
#line 174
    (c->queue_prev)->queue_next = c->queue_next;
  } else {
#line 176
    queue_first = c->queue_next;
  }
  {
#line 178
  c->queue_prev = (struct connection *)((void *)0);
#line 179
  c->queue_next = (struct connection *)((void *)0);
#line 180
  update_stat((enum stat_type )0, -1L);
  }
#line 181
  return;
}
}
#line 187 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static int limiter  =    0;
#line 183 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
void set_time(void) 
{ 
  struct timeval last_time___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  Bool tmp___3 ;

  {
  {
#line 189
  last_time___0 = current_time;
#line 190
  tmp___1 = gettimeofday((struct timeval */* __restrict  */)(& current_time), (__timezone_ptr_t )((void *)0));
  }
#line 190
  if (tmp___1 < 0) {
#line 192
    if (limiter < 50) {
      {
#line 194
      tmp = __errno_location();
#line 194
      tmp___0 = strerror(*tmp);
#line 194
      kom_log("WARNING: gettimeofday failed: %s\n", tmp___0);
#line 195
      limiter ++;
      }
#line 195
      if (limiter == 50) {
        {
#line 196
        kom_log("WARNING: will not log the above message again.\n");
        }
      }
    }
  }
  {
#line 200
  tmp___3 = timeval_less(current_time, last_time___0);
  }
#line 200
  if (tmp___3) {
    {
#line 202
    tmp___2 = timeval_diff_d(last_time___0, current_time);
#line 202
    kom_log("WARNING: Time moved backward at least %g seconds.", tmp___2);
    }
  }
#line 206
  return;
}
}
#line 208 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void logout_client(Connection *cp ) 
{ 
  Connection *real_active_connection ;
  int ret ;
  int ctr___0 ;

  {
#line 214
  if ((unsigned long )active_connection != (unsigned long )((void *)0)) {
    {
#line 216
    kom_log("BUGCHK: logout_client(%ld): connection %ld is active.\n", cp->session_no,
            active_connection->session_no);
    }
  }
#line 220
  if ((int )cp->pers_no != 0) {
#line 222
    ctr___0 = 0;
#line 224
    if ((unsigned long )active_connection != (unsigned long )((void *)0)) {
      {
#line 226
      kom_log("WNG: logout_client(): active_connection != NULL\n");
      }
#line 227
      if (ctr___0 < 100) {
#line 228
        ctr___0 ++;
      } else {
        {
#line 230
        kom_log("WNG: won\'t log the above message more\n");
        }
      }
    }
    {
#line 233
    real_active_connection = active_connection;
#line 234
    active_connection = cp;
#line 235
    logout();
#line 236
    active_connection = real_active_connection;
    }
  }
  {
#line 250
  if ((int )cp->protocol == 0) {
#line 250
    goto case_0;
  }
#line 253
  if ((int )cp->protocol == 65) {
#line 253
    goto case_65;
  }
#line 257
  goto switch_default;
  case_0: /* CIL Label */ 
#line 251
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 254
  prot_a_destruct(cp);
  }
#line 255
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 258
  restart_kom("logout_client(): Bad protocol.\n");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 261
  ret = isc_destroy(kom_server_mcb, cp->isc_session);
  }
#line 262
  if (ret < 0) {
    {
#line 263
    kom_log("logout_client(): isc_destroyed returned %d\n", ret);
    }
  }
#line 264
  cp->isc_session = (struct isc_scb *)((void *)0);
#line 265
  if (cp->on_queue) {
    {
#line 266
    queue_remove(cp);
    }
  }
  {
#line 268
  kill_client(cp);
#line 269
  update_stat((enum stat_type )3, -1L);
  }
#line 270
  return;
}
}
#line 275 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
void logout_all_clients(void) 
{ 
  Session_no sess ;
  Connection *conn ;
  Session_no tmp ;
  Session_no tmp___0 ;

  {
#line 278
  sess = (Session_no )0;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 281
    sess = traverse_connections(sess);
    }
#line 281
    if (! (sess != 0UL)) {
#line 281
      goto while_break;
    }
    {
#line 283
    conn = get_conn_by_number(sess);
    }
#line 285
    if ((unsigned long )conn == (unsigned long )((void *)0)) {
      {
#line 286
      restart_kom("logout_all_clients(): cant get session %ld.\n", sess);
      }
    } else {
      {
#line 289
      logout_client(conn);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 292
  tmp___0 = traverse_connections((Session_no )0);
  }
#line 292
  if (tmp___0 != 0UL) {
    {
#line 293
    tmp = traverse_connections((Session_no )0);
#line 293
    restart_kom("logout_all_clients(): traverse_connections(0) == %ld.\n", tmp);
    }
  }
#line 295
  return;
}
}
#line 305 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static Success call_function(Connection *client , union result_holder *res ) 
{ 
  Success status___0 ;
  Pers_no tmp ;
  Conf_no tmp___0 ;
  Conf_no tmp___1 ;
  Pers_no tmp___2 ;

  {
#line 309
  status___0 = (Success )FAILURE;
#line 311
  if ((unsigned long )active_connection != (unsigned long )((void *)0)) {
    {
#line 313
    kom_log("call_function(%ld): active_connection = %ld\n", client->session_no, active_connection->session_no);
    }
  }
#line 317
  if ((int )client->function == -1) {
#line 319
    err_stat = 0UL;
#line 320
    kom_errno = (enum kom_err )2;
#line 321
    return ((Success )FAILURE);
  }
#line 324
  active_connection = client;
#line 326
  (service_statistics[client->function_index]) ++;
  {
#line 5
  if ((int )client->function == 0) {
#line 5 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/call-switch.incl"
    goto case_0;
  }
#line 9
  if ((int )client->function == 1) {
#line 9
    goto case_1;
  }
#line 13
  if ((int )client->function == 2) {
#line 13
    goto case_2;
  }
#line 17
  if ((int )client->function == 3) {
#line 17
    goto case_3;
  }
#line 21
  if ((int )client->function == 4) {
#line 21
    goto case_4;
  }
#line 25
  if ((int )client->function == 5) {
#line 25
    goto case_5;
  }
#line 30
  if ((int )client->function == 6) {
#line 30
    goto case_6;
  }
#line 34
  if ((int )client->function == 7) {
#line 34
    goto case_7;
  }
#line 38
  if ((int )client->function == 8) {
#line 38
    goto case_8;
  }
#line 42
  if ((int )client->function == 9) {
#line 42
    goto case_9;
  }
#line 46
  if ((int )client->function == 10) {
#line 46
    goto case_10;
  }
#line 51
  if ((int )client->function == 11) {
#line 51
    goto case_11;
  }
#line 55
  if ((int )client->function == 12) {
#line 55
    goto case_12;
  }
#line 59
  if ((int )client->function == 13) {
#line 59
    goto case_13;
  }
#line 63
  if ((int )client->function == 14) {
#line 63
    goto case_14;
  }
#line 67
  if ((int )client->function == 15) {
#line 67
    goto case_15;
  }
#line 71
  if ((int )client->function == 16) {
#line 71
    goto case_16;
  }
#line 75
  if ((int )client->function == 17) {
#line 75
    goto case_17;
  }
#line 79
  if ((int )client->function == 18) {
#line 79
    goto case_18;
  }
#line 83
  if ((int )client->function == 19) {
#line 83
    goto case_19;
  }
#line 87
  if ((int )client->function == 20) {
#line 87
    goto case_20;
  }
#line 91
  if ((int )client->function == 21) {
#line 91
    goto case_21;
  }
#line 95
  if ((int )client->function == 22) {
#line 95
    goto case_22;
  }
#line 99
  if ((int )client->function == 23) {
#line 99
    goto case_23;
  }
#line 103
  if ((int )client->function == 24) {
#line 103
    goto case_24;
  }
#line 107
  if ((int )client->function == 25) {
#line 107
    goto case_25;
  }
#line 111
  if ((int )client->function == 26) {
#line 111
    goto case_26;
  }
#line 115
  if ((int )client->function == 27) {
#line 115
    goto case_27;
  }
#line 119
  if ((int )client->function == 28) {
#line 119
    goto case_28;
  }
#line 124
  if ((int )client->function == 29) {
#line 124
    goto case_29;
  }
#line 128
  if ((int )client->function == 30) {
#line 128
    goto case_30;
  }
#line 132
  if ((int )client->function == 31) {
#line 132
    goto case_31;
  }
#line 136
  if ((int )client->function == 32) {
#line 136
    goto case_32;
  }
#line 140
  if ((int )client->function == 33) {
#line 140
    goto case_33;
  }
#line 144
  if ((int )client->function == 34) {
#line 144
    goto case_34;
  }
#line 148
  if ((int )client->function == 35) {
#line 148
    goto case_35;
  }
#line 152
  if ((int )client->function == 36) {
#line 152
    goto case_36;
  }
#line 156
  if ((int )client->function == 37) {
#line 156
    goto case_37;
  }
#line 160
  if ((int )client->function == 38) {
#line 160
    goto case_38;
  }
#line 164
  if ((int )client->function == 39) {
#line 164
    goto case_39;
  }
#line 168
  if ((int )client->function == 40) {
#line 168
    goto case_40;
  }
#line 172
  if ((int )client->function == 41) {
#line 172
    goto case_41;
  }
#line 176
  if ((int )client->function == 42) {
#line 176
    goto case_42;
  }
#line 180
  if ((int )client->function == 43) {
#line 180
    goto case_43;
  }
#line 184
  if ((int )client->function == 44) {
#line 184
    goto case_44;
  }
#line 188
  if ((int )client->function == 45) {
#line 188
    goto case_45;
  }
#line 192
  if ((int )client->function == 46) {
#line 192
    goto case_46;
  }
#line 196
  if ((int )client->function == 47) {
#line 196
    goto case_47;
  }
#line 200
  if ((int )client->function == 48) {
#line 200
    goto case_48;
  }
#line 204
  if ((int )client->function == 49) {
#line 204
    goto case_49;
  }
#line 208
  if ((int )client->function == 50) {
#line 208
    goto case_50;
  }
#line 212
  if ((int )client->function == 51) {
#line 212
    goto case_51;
  }
#line 216
  if ((int )client->function == 52) {
#line 216
    goto case_52;
  }
#line 220
  if ((int )client->function == 53) {
#line 220
    goto case_53;
  }
#line 224
  if ((int )client->function == 54) {
#line 224
    goto case_54;
  }
#line 228
  if ((int )client->function == 55) {
#line 228
    goto case_55;
  }
#line 232
  if ((int )client->function == 56) {
#line 232
    goto case_56;
  }
#line 236
  if ((int )client->function == 57) {
#line 236
    goto case_57;
  }
#line 240
  if ((int )client->function == 58) {
#line 240
    goto case_58;
  }
#line 244
  if ((int )client->function == 59) {
#line 244
    goto case_59;
  }
#line 249
  if ((int )client->function == 60) {
#line 249
    goto case_60;
  }
#line 253
  if ((int )client->function == 61) {
#line 253
    goto case_61;
  }
#line 257
  if ((int )client->function == 62) {
#line 257
    goto case_62;
  }
#line 261
  if ((int )client->function == 63) {
#line 261
    goto case_63;
  }
#line 265
  if ((int )client->function == 64) {
#line 265
    goto case_64;
  }
#line 269
  if ((int )client->function == 65) {
#line 269
    goto case_65;
  }
#line 273
  if ((int )client->function == 66) {
#line 273
    goto case_66;
  }
#line 277
  if ((int )client->function == 67) {
#line 277
    goto case_67;
  }
#line 281
  if ((int )client->function == 68) {
#line 281
    goto case_68;
  }
#line 285
  if ((int )client->function == 69) {
#line 285
    goto case_69;
  }
#line 289
  if ((int )client->function == 70) {
#line 289
    goto case_70;
  }
#line 293
  if ((int )client->function == 71) {
#line 293
    goto case_71;
  }
#line 297
  if ((int )client->function == 72) {
#line 297
    goto case_72;
  }
#line 301
  if ((int )client->function == 73) {
#line 301
    goto case_73;
  }
#line 305
  if ((int )client->function == 74) {
#line 305
    goto case_74;
  }
#line 309
  if ((int )client->function == 75) {
#line 309
    goto case_75;
  }
#line 313
  if ((int )client->function == 76) {
#line 313
    goto case_76;
  }
#line 317
  if ((int )client->function == 77) {
#line 317
    goto case_77;
  }
#line 321
  if ((int )client->function == 78) {
#line 321
    goto case_78;
  }
#line 325
  if ((int )client->function == 79) {
#line 325
    goto case_79;
  }
#line 329
  if ((int )client->function == 80) {
#line 329
    goto case_80;
  }
#line 333
  if ((int )client->function == 81) {
#line 333
    goto case_81;
  }
#line 337
  if ((int )client->function == 82) {
#line 337
    goto case_82;
  }
#line 341
  if ((int )client->function == 83) {
#line 341
    goto case_83;
  }
#line 345
  if ((int )client->function == 84) {
#line 345
    goto case_84;
  }
#line 349
  if ((int )client->function == 85) {
#line 349
    goto case_85;
  }
#line 353
  if ((int )client->function == 86) {
#line 353
    goto case_86;
  }
#line 358
  if ((int )client->function == 87) {
#line 358
    goto case_87;
  }
#line 363
  if ((int )client->function == 88) {
#line 363
    goto case_88;
  }
#line 368
  if ((int )client->function == 89) {
#line 368
    goto case_89;
  }
#line 373
  if ((int )client->function == 90) {
#line 373
    goto case_90;
  }
#line 377
  if ((int )client->function == 91) {
#line 377
    goto case_91;
  }
#line 381
  if ((int )client->function == 92) {
#line 381
    goto case_92;
  }
#line 385
  if ((int )client->function == 93) {
#line 385
    goto case_93;
  }
#line 389
  if ((int )client->function == 94) {
#line 389
    goto case_94;
  }
#line 393
  if ((int )client->function == 95) {
#line 393
    goto case_95;
  }
#line 397
  if ((int )client->function == 96) {
#line 397
    goto case_96;
  }
#line 401
  if ((int )client->function == 97) {
#line 401
    goto case_97;
  }
#line 405
  if ((int )client->function == 98) {
#line 405
    goto case_98;
  }
#line 409
  if ((int )client->function == 99) {
#line 409
    goto case_99;
  }
#line 413
  if ((int )client->function == 100) {
#line 413
    goto case_100;
  }
#line 417
  if ((int )client->function == 101) {
#line 417
    goto case_101;
  }
#line 421
  if ((int )client->function == 102) {
#line 421
    goto case_102;
  }
#line 425
  if ((int )client->function == 103) {
#line 425
    goto case_103;
  }
#line 429
  if ((int )client->function == 104) {
#line 429
    goto case_104;
  }
#line 433
  if ((int )client->function == 105) {
#line 433
    goto case_105;
  }
#line 437
  if ((int )client->function == 106) {
#line 437
    goto case_106;
  }
#line 441
  if ((int )client->function == 107) {
#line 441
    goto case_107;
  }
#line 445
  if ((int )client->function == 108) {
#line 445
    goto case_108;
  }
#line 449
  if ((int )client->function == 109) {
#line 449
    goto case_109;
  }
#line 453
  if ((int )client->function == 110) {
#line 453
    goto case_110;
  }
#line 457
  if ((int )client->function == 111) {
#line 457
    goto case_111;
  }
#line 461
  if ((int )client->function == 112) {
#line 461
    goto case_112;
  }
#line 465
  if ((int )client->function == 113) {
#line 465
    goto case_113;
  }
#line 469
  if ((int )client->function == 114) {
#line 469
    goto case_114;
  }
#line 473
  if ((int )client->function == 115) {
#line 473
    goto case_115;
  }
#line 477
  if ((int )client->function == 116) {
#line 477
    goto case_116;
  }
#line 481
  if ((int )client->function == 117) {
#line 481
    goto case_117;
  }
#line 485
  if ((int )client->function == 118) {
#line 485
    goto case_118;
  }
#line 489
  if ((int )client->function == 119) {
#line 489
    goto case_119;
  }
#line 493
  if ((int )client->function == 120) {
#line 493
    goto case_120;
  }
#line 497
  if ((int )client->function == 121) {
#line 497
    goto case_121;
  }
#line 501
  if ((int )client->function == 122) {
#line 501
    goto case_122;
  }
#line 543
  if ((int )client->function == -1) {
#line 543
    goto case_neg_1;
  }
#line 3
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 6
  status___0 = login_old((Pers_no )client->num0, (String const   )client->c_string0);
  }
#line 7
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 10
  status___0 = logout();
  }
#line 11
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 14
  status___0 = change_conference((Conf_no )client->num0);
  }
#line 15
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 18
  status___0 = change_name((Conf_no )client->num0, (String const   )client->c_string0);
  }
#line 19
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 22
  status___0 = change_what_i_am_doing(client->string0);
  }
#line 23
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 26
  tmp = create_person_old((String const   )client->c_string0, (String const   )client->c_string1);
#line 26
  res->number = (unsigned long )tmp;
  }
#line 27
  if (res->number != 0UL) {
#line 27
    status___0 = (Success )OK;
  } else {
#line 27
    status___0 = (Success )FAILURE;
  }
#line 28
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 31
  status___0 = get_person_stat_old((Pers_no )client->num0, (int )client->num1, & res->person);
  }
#line 32
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 35
  status___0 = set_priv_bits((Pers_no )client->num0, client->priv_bits);
  }
#line 36
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 39
  status___0 = set_passwd((Pers_no )client->num0, (String const   )client->c_string0,
                          (String const   )client->c_string1);
  }
#line 40
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 43
  status___0 = query_read_texts_old((Pers_no )client->num0, (Conf_no )client->num1,
                                    & res->membership_old);
  }
#line 44
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 47
  tmp___0 = create_conf_old((String const   )client->c_string0, client->conf_type);
#line 47
  res->number = (unsigned long )tmp___0;
  }
#line 48
  if (res->number != 0UL) {
#line 48
    status___0 = (Success )OK;
  } else {
#line 48
    status___0 = (Success )FAILURE;
  }
#line 49
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 52
  status___0 = delete_conf((Conf_no )client->num0);
  }
#line 53
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 56
  status___0 = lookup_name((String const   )client->c_string0, & res->conf_list);
  }
#line 57
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 60
  status___0 = get_conf_stat_older((Conf_no )client->num0, (int )client->num1, & res->conference_old);
  }
#line 61
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 64
  status___0 = add_member_old((Conf_no )client->num0, (Pers_no )client->num1, (unsigned char )client->num2,
                              (unsigned short )client->num3);
  }
#line 65
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 68
  status___0 = sub_member((Conf_no )client->num0, (Pers_no )client->num1);
  }
#line 69
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 72
  status___0 = set_presentation((Conf_no )client->num0, (Text_no )client->num1);
  }
#line 73
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 76
  status___0 = set_etc_motd((Conf_no )client->num0, (Text_no )client->num1);
  }
#line 77
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 80
  status___0 = set_supervisor((Conf_no )client->num0, (Conf_no )client->num1);
  }
#line 81
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 84
  status___0 = set_permitted_submitters((Conf_no )client->num0, (Conf_no )client->num1);
  }
#line 85
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 88
  status___0 = set_super_conf((Conf_no )client->num0, (Conf_no )client->num1);
  }
#line 89
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 92
  status___0 = set_conf_type((Conf_no )client->num0, client->conf_type);
  }
#line 93
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 96
  status___0 = set_garb_nice((Conf_no )client->num0, (Garb_nice )client->num1);
  }
#line 97
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 100
  status___0 = get_marks(& res->mark_list);
  }
#line 101
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 104
  status___0 = mark_text_old((Text_no )client->num0, (unsigned char )client->num1);
  }
#line 105
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 108
  status___0 = get_text((Text_no )client->num0, client->num1, client->num2, & res->string);
  }
#line 109
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 112
  status___0 = get_text_stat_old((Text_no )client->num0, & res->text_stat_old);
  }
#line 113
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 116
  status___0 = mark_as_read((Conf_no )client->num0, (Number_list const   *)(& client->num_list));
  }
#line 117
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 120
  res->number = create_text_old((String const   )client->c_string0, & client->misc_info_list);
  }
#line 121
  if (res->number != 0UL) {
#line 121
    status___0 = (Success )OK;
  } else {
#line 121
    status___0 = (Success )FAILURE;
  }
#line 122
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 125
  status___0 = delete_text((Text_no )client->num0);
  }
#line 126
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 129
  status___0 = add_recipient((Text_no )client->num0, (Conf_no )client->num1, (enum info_type )client->num2);
  }
#line 130
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 133
  status___0 = sub_recipient((Text_no )client->num0, (Conf_no )client->num1);
  }
#line 134
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 137
  status___0 = add_comment((Text_no )client->num0, (Text_no )client->num1);
  }
#line 138
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 141
  status___0 = sub_comment((Text_no )client->num0, (Text_no )client->num1);
  }
#line 142
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 145
  status___0 = get_map((Conf_no )client->num0, (Local_text_no )client->num1, (unsigned long )client->num2,
                       & res->l2g_iterator_as_text_list);
  }
#line 146
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 149
  status___0 = get_time(& res->time_date);
  }
#line 150
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 153
  status___0 = get_info_old(& res->info_old);
  }
#line 154
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 157
  status___0 = add_footnote((Text_no )client->num0, (Text_no )client->num1);
  }
#line 158
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 161
  status___0 = sub_footnote((Text_no )client->num0, (Text_no )client->num1);
  }
#line 162
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 165
  status___0 = who_is_on_old(& res->who_info_list_old);
  }
#line 166
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 169
  status___0 = set_unread((Conf_no )client->num0, (Text_no )client->num1);
  }
#line 170
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 173
  status___0 = set_motd_of_lyskom((Text_no )client->num0);
  }
#line 174
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 177
  status___0 = enable((unsigned char )client->num0);
  }
#line 178
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 181
  status___0 = sync_kom();
  }
#line 182
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 185
  status___0 = shutdown_kom((int )client->num0);
  }
#line 186
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 189
  status___0 = broadcast((String const   )client->c_string0);
  }
#line 190
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 193
  status___0 = get_membership_old((Pers_no )client->num0, (unsigned short )client->num1,
                                  (unsigned short )client->num2, (Bool )client->num3,
                                  & res->membership_list_old);
  }
#line 194
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 197
  status___0 = get_created_texts((Pers_no )client->num0, (Local_text_no )client->num1,
                                 (unsigned long )client->num2, & res->l2g_iterator_as_text_list);
  }
#line 198
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 201
  status___0 = get_members_old((Conf_no )client->num0, (unsigned short )client->num1,
                               (unsigned short )client->num2, & res->member_list_old);
  }
#line 202
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 205
  status___0 = get_person_stat((Pers_no )client->num0, & res->person);
  }
#line 206
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 209
  status___0 = get_conf_stat_old((Conf_no )client->num0, & res->conference_old);
  }
#line 210
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 213
  status___0 = who_is_on(& res->who_info_list);
  }
#line 214
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 217
  status___0 = get_unread_confs((Pers_no )client->num0, & res->conf_no_list);
  }
#line 218
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 221
  status___0 = send_message((Conf_no )client->num0, (String const   )client->c_string0);
  }
#line 222
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 225
  status___0 = get_session_info((Session_no )client->num0, & res->session_info);
  }
#line 226
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 229
  status___0 = disconnect((Session_no )client->num0);
  }
#line 230
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 233
  status___0 = who_am_i(& res->session_no);
  }
#line 234
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 237
  status___0 = set_user_area((Pers_no )client->num0, (Text_no )client->num1);
  }
#line 238
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 241
  status___0 = get_last_text(& client->time, & res->text_no);
  }
#line 242
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 245
  res->number = create_anonymous_text_old((String const   )client->c_string0, & client->misc_info_list);
  }
#line 246
  if (res->number != 0UL) {
#line 246
    status___0 = (Success )OK;
  } else {
#line 246
    status___0 = (Success )FAILURE;
  }
#line 247
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 250
  status___0 = find_next_text_no((Text_no )client->num0, & res->text_no);
  }
#line 251
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 254
  status___0 = find_previous_text_no((Text_no )client->num0, & res->text_no);
  }
#line 255
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 258
  status___0 = login((Pers_no )client->num0, (String const   )client->c_string0, (Bool )client->num1);
  }
#line 259
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 262
  status___0 = who_is_on_ident(& res->who_info_ident_list);
  }
#line 263
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 266
  status___0 = get_session_info_ident((Session_no )client->num0, & res->session_info_ident);
  }
#line 267
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 270
  status___0 = re_lookup_person((String const   )client->c_string0, & res->conf_no_list);
  }
#line 271
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 274
  status___0 = re_lookup_conf((String const   )client->c_string0, & res->conf_no_list);
  }
#line 275
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 278
  status___0 = lookup_person((String const   )client->c_string0, & res->conf_no_list);
  }
#line 279
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 282
  status___0 = lookup_conf((String const   )client->c_string0, & res->conf_no_list);
  }
#line 283
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 286
  status___0 = set_client_version((String const   )client->c_string0, (String const   )client->c_string1);
  }
#line 287
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 290
  status___0 = get_client_name((Session_no )client->num0, & res->string);
  }
#line 291
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 294
  status___0 = get_client_version((Session_no )client->num0, & res->string);
  }
#line 295
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 298
  status___0 = mark_text((Text_no )client->num0, (unsigned char )client->num1);
  }
#line 299
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 302
  status___0 = unmark_text((Text_no )client->num0);
  }
#line 303
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 306
  status___0 = re_z_lookup((String const   )client->c_string0, (int )client->num0,
                           (int )client->num1, & res->conf_z_info_list);
  }
#line 307
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 310
  status___0 = get_version_info(& res->version_info);
  }
#line 311
  goto switch_break;
  case_76: /* CIL Label */ 
  {
#line 314
  status___0 = lookup_z_name((String const   )client->c_string0, (int )client->num0,
                             (int )client->num1, & res->conf_z_info_list);
  }
#line 315
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 318
  status___0 = set_last_read((Conf_no )client->num0, (Local_text_no )client->num1);
  }
#line 319
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 322
  status___0 = get_uconf_stat((Conf_no )client->num0, & res->uconference);
  }
#line 323
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 326
  status___0 = set_info(& client->info);
  }
#line 327
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 330
  status___0 = accept_async(& client->num_list);
  }
#line 331
  goto switch_break;
  case_81: /* CIL Label */ 
  {
#line 334
  status___0 = query_async(& res->num_list);
  }
#line 335
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 338
  status___0 = user_active();
  }
#line 339
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 342
  status___0 = who_is_on_dynamic((int )client->num0, (int )client->num1, client->num2,
                                 & res->dynamic_session_info_list);
  }
#line 343
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 346
  status___0 = get_static_session_info((Session_no )client->num0, & res->static_session_info);
  }
#line 347
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 350
  status___0 = get_collate_table(& res->string);
  }
#line 351
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 354
  res->number = create_text((String const   )client->c_string0, & client->misc_info_list,
                            & client->aux_item_list);
  }
#line 355
  if (res->number != 0UL) {
#line 355
    status___0 = (Success )OK;
  } else {
#line 355
    status___0 = (Success )FAILURE;
  }
#line 356
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 359
  res->number = create_anonymous_text((String const   )client->c_string0, & client->misc_info_list,
                                      & client->aux_item_list);
  }
#line 360
  if (res->number != 0UL) {
#line 360
    status___0 = (Success )OK;
  } else {
#line 360
    status___0 = (Success )FAILURE;
  }
#line 361
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 364
  tmp___1 = create_conf((String const   )client->c_string0, client->conf_type, & client->aux_item_list);
#line 364
  res->number = (unsigned long )tmp___1;
  }
#line 365
  if (res->number != 0UL) {
#line 365
    status___0 = (Success )OK;
  } else {
#line 365
    status___0 = (Success )FAILURE;
  }
#line 366
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 369
  tmp___2 = create_person((String const   )client->c_string0, (String const   )client->c_string1,
                          client->pers_flags, & client->aux_item_list);
#line 369
  res->number = (unsigned long )tmp___2;
  }
#line 370
  if (res->number != 0UL) {
#line 370
    status___0 = (Success )OK;
  } else {
#line 370
    status___0 = (Success )FAILURE;
  }
#line 371
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 374
  status___0 = get_text_stat((Text_no )client->num0, & res->text_stat);
  }
#line 375
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 378
  status___0 = get_conf_stat((Conf_no )client->num0, & res->conference);
  }
#line 379
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 382
  status___0 = modify_text_info((Text_no )client->num0, & client->num_list, & client->aux_item_list);
  }
#line 383
  goto switch_break;
  case_93: /* CIL Label */ 
  {
#line 386
  status___0 = modify_conf_info((Conf_no )client->num0, & client->num_list, & client->aux_item_list);
  }
#line 387
  goto switch_break;
  case_94: /* CIL Label */ 
  {
#line 390
  status___0 = get_info(& res->info);
  }
#line 391
  goto switch_break;
  case_95: /* CIL Label */ 
  {
#line 394
  status___0 = modify_system_info(& client->num_list, & client->aux_item_list);
  }
#line 395
  goto switch_break;
  case_96: /* CIL Label */ 
  {
#line 398
  status___0 = query_predefined_aux_items(& res->num_list);
  }
#line 399
  goto switch_break;
  case_97: /* CIL Label */ 
  {
#line 402
  status___0 = set_expire((Conf_no )client->num0, (Garb_nice )client->num1);
  }
#line 403
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 406
  status___0 = query_read_texts_10((Pers_no )client->num0, (Conf_no )client->num1,
                                   & res->membership_10);
  }
#line 407
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 410
  status___0 = get_membership_10((Pers_no )client->num0, (unsigned short )client->num1,
                                 (unsigned short )client->num2, (Bool )client->num3,
                                 & res->membership_list_10);
  }
#line 411
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 414
  status___0 = add_member((Conf_no )client->num0, (Pers_no )client->num1, (unsigned char )client->num2,
                          (unsigned short )client->num3, & client->membership_type);
  }
#line 415
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 418
  status___0 = get_members((Conf_no )client->num0, (unsigned short )client->num1,
                           (unsigned short )client->num2, & res->member_list);
  }
#line 419
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 422
  status___0 = set_membership_type((Pers_no )client->num0, (Conf_no )client->num1,
                                   & client->membership_type);
  }
#line 423
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 426
  status___0 = local_to_global((Conf_no )client->num0, (Local_text_no )client->num1,
                               (unsigned long )client->num2, & res->text_mapping);
  }
#line 427
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 430
  status___0 = map_created_texts((Pers_no )client->num0, (Local_text_no )client->num1,
                                 (unsigned long )client->num2, & res->text_mapping);
  }
#line 431
  goto switch_break;
  case_105: /* CIL Label */ 
  {
#line 434
  status___0 = set_keep_commented((Conf_no )client->num0, (Garb_nice )client->num1);
  }
#line 435
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 438
  status___0 = set_pers_flags((Pers_no )client->num0, client->pers_flags);
  }
#line 439
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 442
  status___0 = query_read_texts((Pers_no )client->num0, (Conf_no )client->num1, (Bool )client->num2,
                                (unsigned long )client->num3, & res->membership);
  }
#line 443
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 446
  status___0 = get_membership((Pers_no )client->num0, (unsigned short )client->num1,
                              (unsigned short )client->num2, (Bool )client->num3,
                              (unsigned long )client->num4, & res->membership_list);
  }
#line 447
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 450
  status___0 = mark_as_unread((Conf_no )client->num0, (Local_text_no )client->num1);
  }
#line 451
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 454
  status___0 = set_read_ranges((Conf_no )client->num0, (struct read_range_list  const  *)(& client->read_range_list));
  }
#line 455
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 458
  status___0 = get_stats_description(& res->stats_description);
  }
#line 459
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 462
  status___0 = get_stats((String const   )client->c_string0, & res->stats_list);
  }
#line 463
  goto switch_break;
  case_113: /* CIL Label */ 
  {
#line 466
  status___0 = get_boottime_info(& res->static_server_info);
  }
#line 467
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 470
  status___0 = first_unused_conf_no(& res->conf_no);
  }
#line 471
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 474
  status___0 = first_unused_text_no(& res->text_no);
  }
#line 475
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 478
  status___0 = find_next_conf_no((Conf_no )client->num0, & res->conf_no);
  }
#line 479
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 482
  status___0 = find_previous_conf_no((Conf_no )client->num0, & res->conf_no);
  }
#line 483
  goto switch_break;
  case_118: /* CIL Label */ 
  {
#line 486
  status___0 = get_scheduling((Session_no )client->num0, & res->scheduling_info);
  }
#line 487
  goto switch_break;
  case_119: /* CIL Label */ 
  {
#line 490
  status___0 = set_scheduling((Session_no )client->num0, (unsigned short )client->num1,
                              (unsigned short )client->num2);
  }
#line 491
  goto switch_break;
  case_120: /* CIL Label */ 
  {
#line 494
  status___0 = set_connection_time_format((int )client->num0);
  }
#line 495
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 498
  status___0 = local_to_global_reverse((Conf_no )client->num0, (Local_text_no )client->num1,
                                       (unsigned long )client->num2, & res->text_mapping_reverse);
  }
#line 499
  goto switch_break;
  case_122: /* CIL Label */ 
  {
#line 502
  status___0 = map_created_texts_reverse((Pers_no )client->num0, (Local_text_no )client->num1,
                                         (unsigned long )client->num2, & res->text_mapping_reverse);
  }
#line 503
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 544
  restart_kom("unreachable code reached -- illegal_fnc");
  }
#line 545
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 330 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
  active_connection = (Connection *)((void *)0);
#line 332
  return (status___0);
}
}
#line 336 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void parse_packet(Connection *client ) 
{ 
  int tmp ;

  {
#line 339
  if ((int )client->protocol == 0) {
    {
#line 341
    tmp = parse_char(client);
#line 341
    client->protocol = (unsigned char )tmp;
    }
    {
#line 344
    if ((int )client->protocol == 65) {
#line 344
      goto case_65;
    }
#line 348
    goto switch_default;
    case_65: /* CIL Label */ 
    {
#line 345
    prot_a_init(client);
    }
#line 346
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 349
    client->protocol = (unsigned char )'\000';
#line 350
    isc_puts("%%LysKOM unsupported protocol.\n", client->isc_session);
#line 351
    isc_flush(client->isc_session);
    }
#line 352
    if (buglevel > 0) {
      {
#line 352
      printf((char const   */* __restrict  */)"%%%%Unsupported protocol.\n");
      }
    }
    {
#line 353
    longjmp((struct __jmp_buf_tag *)(parse_env), 3);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 359
  if ((int )client->protocol == 65) {
#line 359
    goto case_65___0;
  }
#line 363
  goto switch_default___0;
  case_65___0: /* CIL Label */ 
  {
#line 360
  prot_a_parse_packet(client);
  }
#line 361
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 364
  restart_kom("parse_packet(): Bad protocol.\n");
  }
#line 365
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 367
  return;
}
}
#line 377 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void free_parsed(Connection *client ) 
{ 


  {
  {
#line 380
  s_clear(& client->c_string0);
#line 381
  s_clear(& client->c_string1);
#line 382
  client->string0 = (String )EMPTY_STRING;
#line 383
  sfree((void *)client->misc_info_list.misc);
#line 384
  client->misc_info_list.misc = (Misc_info *)0;
#line 385
  client->misc_info_list.no_of_misc = (unsigned short)0;
#line 386
  s_clear(& client->aux_item.data);
#line 387
  s_clear(& client->dummy_aux_item.data);
#line 388
  sfree((void *)client->read_range_list.ranges);
#line 389
  client->read_range_list.ranges = (struct read_range *)((void *)0);
#line 390
  client->read_range_list.length = (unsigned short)0;
#line 391
  client->parse_pos = 0;
#line 392
  client->fnc_parse_pos = 0;
#line 393
  client->array_parse_index = 0;
#line 394
  client->array_parse_parsed_length = 0;
#line 395
  client->array_parse_pos = 0;
#line 396
  client->struct_parse_pos = 0;
#line 397
  client->string_parse_pos = 0;
#line 398
  client->hunt_parse_pos = 0;
#line 399
  client->array_hunt_num = 0;
#line 400
  client->array_hunt_depth = 0;
#line 401
  sfree((void *)client->num_list.data);
#line 402
  client->num_list.data = (long *)((void *)0);
#line 403
  client->num_list.length = 0;
#line 404
  free_aux_item_list(& client->aux_item_list);
#line 405
  client->info.highest_aux_no = 0UL;
  }
#line 406
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void reply(Connection *client , Success status___0 , union result_holder *result ) 
{ 


  {
  {
#line 418
  if ((int )client->protocol == 65) {
#line 418
    goto case_65;
  }
#line 422
  goto switch_default;
  case_65: /* CIL Label */ 
  {
#line 419
  prot_a_reply(client, status___0, result);
  }
#line 420
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 423
  restart_kom("reply(): Bad protocol.\n");
  }
#line 424
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 426
  return;
}
}
#line 434 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static Bool parse_unparsed(Connection *client ) 
{ 
  Success status___0 ;
  union result_holder result ;
  int tmp ;

  {
  {
#line 440
  tmp = _setjmp((struct __jmp_buf_tag *)(parse_env));
  }
  {
#line 442
  if (tmp == 0) {
#line 442
    goto case_0;
  }
#line 456
  if (tmp == 1) {
#line 456
    goto case_1;
  }
#line 468
  if (tmp == 2) {
#line 468
    goto case_2;
  }
#line 472
  if (tmp == 3) {
#line 472
    goto case_3;
  }
#line 476
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 444
  parse_packet(client);
  }
#line 445
  if (client->blocked_by_dns) {
#line 446
    return ((Bool )1);
  }
  {
#line 447
  update_stat((enum stat_type )4, 1L);
#line 448
  status___0 = call_function(client, & result);
#line 449
  update_stat((enum stat_type )4, -1L);
#line 450
  reply(client, status___0, & result);
#line 451
  client->penalty += param.penalty_per_call;
#line 452
  free_parsed(client);
#line 453
  end_of_atomic();
  }
#line 454
  return ((Bool )1);
  case_1: /* CIL Label */ 
  {
#line 457
  s_clear(& client->string0);
#line 458
  free_parsed(client);
#line 459
  isc_puts("%% LysKOM protocol error.\n", client->isc_session);
  }
#line 460
  if (buglevel > 0) {
    {
#line 460
    printf((char const   */* __restrict  */)"%%%% Protocol error.\n");
    }
  }
  {
#line 461
  client->penalty += param.max_penalty;
#line 462
  s_clear(& client->unparsed);
#line 463
  client->first_to_parse = (String_size )0;
#line 464
  client->more_to_parse = (Bool )0;
#line 465
  end_of_atomic();
  }
#line 466
  return ((Bool )1);
  case_2: /* CIL Label */ 
#line 469
  client->more_to_parse = (Bool )0;
#line 470
  return ((Bool )0);
  case_3: /* CIL Label */ 
  {
#line 473
  add_to_kill_list(client);
#line 474
  client->more_to_parse = (Bool )0;
  }
#line 475
  return ((Bool )1);
  switch_default: /* CIL Label */ 
  {
#line 477
  restart_kom("Bad longjmp return value.\n");
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 484 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static int fexists(char const   *filename ) 
{ 
  struct stat buf___4 ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 490
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& buf___4));
  }
#line 490
  if (tmp) {
#line 490
    tmp___0 = 0;
  } else {
#line 490
    tmp___0 = 1;
  }
  {
#line 490
  code = tmp___0;
#line 491
  tmp___1 = __errno_location();
#line 491
  *tmp___1 = 0;
  }
#line 493
  return (code);
}
}
#line 500 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static struct timeval last_dump  =    {(__time_t )0, (__suseconds_t )0};
#line 497 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
void dump_statistics(void) 
{ 
  int i ;
  FILE *fp ;
  Bool tmp ;
  char *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 504
  fp = i_fopen((char const   *)param.statistic_name, "a");
  }
#line 504
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 506
    kom_log("dump_statistics(): can\'t open file %s\n", param.statistic_name);
    }
#line 508
    return;
  }
  {
#line 511
  tmp = timeval_zero(last_dump);
  }
#line 511
  if (tmp) {
    {
#line 513
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"RESTART\n");
#line 514
    last_dump = current_time;
    }
  }
  {
#line 517
  tmp___0 = ctime((time_t const   *)(& current_time.tv_sec));
#line 517
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"TIME: %s",
          tmp___0);
#line 518
  tmp___1 = timeval_diff_sec(current_time, last_dump);
#line 518
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"SECONDS: %ld\n",
          tmp___1);
#line 519
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"STATISTICS:");
#line 524
  i = 0;
  }
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 524
    if (! (i < (int )(num_fnc_defs - 1))) {
#line 524
      goto while_break;
    }
    {
#line 526
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %d:%lu",
            (int const   )fnc_defs[i].function, service_statistics[i]);
#line 527
    service_statistics[i] = 0UL;
#line 524
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 530
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 531
  i_fclose(fp);
#line 533
  last_dump = current_time;
  }
#line 534
  return;
}
}
#line 538 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static Session_no *kill_list  =    (Session_no *)((void *)0);
#line 539 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static int kill_list_size  =    0;
#line 540 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static int kill_pending  =    0;
#line 543 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
void add_to_kill_list(Connection *conn ) 
{ 
  oop_source *source ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 551
  if ((unsigned int )conn->kill_status == 1U) {
#line 551
    goto case_1;
  }
#line 561
  if ((unsigned int )conn->kill_status == 2U) {
#line 561
    goto case_2;
  }
#line 566
  if ((unsigned int )conn->kill_status == 0U) {
#line 566
    goto case_0;
  }
#line 549
  goto switch_break;
  case_1: /* CIL Label */ 
#line 554
  i = 0;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    if (! (i < kill_list_size)) {
#line 554
      goto while_break;
    }
#line 555
    if (*(kill_list + i) == conn->session_no) {
#line 556
      return;
    }
#line 554
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 558
  restart_kom("add_to_kill_list(): kill_pending set but not on list.\n");
  }
#line 559
  return;
  case_2: /* CIL Label */ 
#line 564
  return;
  case_0: /* CIL Label */ 
#line 568
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 572
  i = 0;
  {
#line 572
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 572
    if (! (i < kill_list_size)) {
#line 572
      goto while_break___0;
    }
#line 573
    if (*(kill_list + i) == conn->session_no) {
      {
#line 574
      restart_kom("add_to_kill_list(): on list but not kill_pending.\n");
      }
    }
#line 572
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 576
  if ((unsigned long )kill_list == (unsigned long )((void *)0)) {
#line 578
    if (kill_list_size != 0) {
      {
#line 579
      restart_kom("add_to_kill_list(): size = %d\n", kill_list_size);
      }
    }
    {
#line 581
    kill_list_size = 1;
#line 582
    tmp = smalloc(sizeof(Session_no ));
#line 582
    kill_list = (Session_no *)tmp;
    }
  } else {
    {
#line 586
    kill_list_size ++;
#line 587
    tmp___0 = srealloc((void *)kill_list, (unsigned long )kill_list_size * sizeof(Session_no ));
#line 587
    kill_list = (Session_no *)tmp___0;
    }
  }
#line 590
  *(kill_list + (kill_list_size - 1)) = conn->session_no;
#line 591
  conn->kill_status = (enum kill_state )1;
#line 593
  if (! kill_pending) {
    {
#line 595
    source = isc_getoopsource(conn->isc_session);
#line 596
    (*(source->on_time))(source, (struct timeval )OOP_TIME_NOW___0, & check_kill_flg,
                         (void *)0);
#line 597
    kill_pending = 1;
    }
  }
#line 599
  return;
}
}
#line 602 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void dump_connections(void) 
{ 
  Session_no s ;
  Connection *conn ;
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  Bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 609
  fp = i_fopen((char const   *)param.connection_status_file_tmp, "w");
  }
#line 609
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 611
    tmp = __errno_location();
#line 611
    tmp___0 = strerror(*tmp);
#line 611
    kom_log("dump_connections(): can\'t open file %s: %s\n", param.connection_status_file_tmp,
            tmp___0);
    }
#line 613
    return;
  }
#line 616
  s = (Session_no )0;
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 616
    s = traverse_connections(s);
    }
#line 616
    if (! (s != 0UL)) {
#line 616
      goto while_break;
    }
    {
#line 618
    conn = get_conn_by_number(s);
#line 619
    tmp___1 = handshake_ok(conn, (enum ignored_conditions )0);
#line 619
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d %lu %d %s\n",
            (conn->isc_session)->fd, conn->session_no, (unsigned int )tmp___1, conn->peer);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 624
  tmp___2 = fflush(fp);
  }
#line 624
  if (tmp___2 != 0) {
    {
#line 625
    kom_log("dump_connections(): fflush() says an error has occured.\n");
    }
  }
  {
#line 627
  tmp___3 = ferror(fp);
  }
#line 627
  if (tmp___3) {
    {
#line 628
    kom_log("dump_connections(): ferror() says an error has occured.\n");
    }
  }
  {
#line 630
  tmp___6 = i_fclose(fp);
  }
#line 630
  if (tmp___6 < 0) {
    {
#line 632
    tmp___4 = __errno_location();
#line 632
    tmp___5 = strerror(*tmp___4);
#line 632
    kom_log("dump_connections(): fclose failed: %s (ignored)\n", tmp___5);
    }
  }
  {
#line 636
  tmp___7 = __errno_location();
#line 636
  *tmp___7 = 0;
#line 637
  tmp___10 = i_rename((char const   *)param.connection_status_file_tmp, (char const   *)param.connection_status_file);
  }
#line 637
  if (tmp___10 < 0) {
    {
#line 640
    tmp___8 = __errno_location();
#line 640
    tmp___9 = strerror(*tmp___8);
#line 640
    kom_log("dump_connections(): can\'t rename %s to %s: %s\n", param.connection_status_file_tmp,
            param.connection_status_file, tmp___9);
    }
  }
#line 645
  return;
}
}
#line 651 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void *check_kill_flg(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                            struct timeval qazwsxedctv  __attribute__((__unused__)) ,
                            void *qazwsxedcuser  __attribute__((__unused__)) ) 
{ 
  Connection *conn ;
  Bool changed ;

  {
#line 657
  changed = (Bool )0;
#line 659
  kill_pending = 0;
#line 661
  if ((unsigned long )active_connection != (unsigned long )((void *)0)) {
    {
#line 663
    restart_kom("check_kill_flg: active_connection == %ld", active_connection->session_no);
    }
  }
  {
#line 667
  while (1) {
    while_continue: /* CIL Label */ ;
#line 667
    if (! (kill_list_size > 0)) {
#line 667
      goto while_break;
    }
    {
#line 669
    kill_list_size --;
#line 670
    conn = get_conn_by_number(*(kill_list + kill_list_size));
    }
#line 671
    if ((unsigned long )conn == (unsigned long )((void *)0)) {
      {
#line 673
      kom_log("check_kill_flg(): Connection %ld doesn\'t exist.\n", *(kill_list + kill_list_size));
      }
    } else {
#line 678
      if (! ((unsigned int )conn->kill_status == 1U)) {
        {
#line 678
        __assert_fail("conn->kill_status == ks_pending", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c",
                      678U, "check_kill_flg");
        }
      }
      {
#line 679
      conn->kill_status = (enum kill_state )2;
#line 680
      logout_client(conn);
#line 681
      end_of_atomic();
#line 682
      changed = (Bool )1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if ((unsigned long )kill_list != (unsigned long )((void *)0)) {
    {
#line 688
    sfree((void *)kill_list);
#line 689
    kill_list = (Session_no *)((void *)0);
    }
  }
#line 692
  if ((unsigned int )changed == 1U) {
    {
#line 693
    dump_connections();
    }
  }
#line 695
  return ((void *)(& _oop_continue));
}
}
#line 698 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void *dns_resolution(struct isc_scb *scb , enum isc_resolve_status res , long errcode ) 
{ 
  struct timeval after ;
  double diff ;
  Connection *conn ;
  char *hostname ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  Bool tmp___4 ;

  {
  {
#line 704
  diff = - 1.0;
#line 706
  hostname = (char *)((void *)0);
#line 708
  update_stat((enum stat_type )1, -1L);
#line 710
  conn = scb->udg;
#line 712
  conn->dns_done = (Bool )1;
  }
#line 713
  if (conn->blocked_by_dns) {
#line 715
    conn->blocked_by_dns = (Bool )0;
#line 716
    if (! conn->on_queue) {
      {
#line 717
      queue_add(conn);
      }
    }
  }
#line 720
  if ((unsigned int )res == 3U) {
#line 721
    return ((void *)(& _oop_continue));
  }
  {
#line 723
  tmp___1 = gettimeofday((struct timeval */* __restrict  */)(& after), (__timezone_ptr_t )((void *)0));
  }
#line 723
  if (tmp___1 < 0) {
    {
#line 724
    tmp = __errno_location();
#line 724
    tmp___0 = strerror(*tmp);
#line 724
    kom_log("gettimeofday failed: %s\n", tmp___0);
    }
  }
  {
#line 726
  diff = timeval_diff_d(after, conn->connect_time);
#line 728
  busy();
  }
  {
#line 732
  if ((unsigned int )res == 1U) {
#line 732
    goto case_1;
  }
#line 749
  if ((unsigned int )res == 2U) {
#line 749
    goto case_2;
  }
#line 761
  if ((unsigned int )res == 3U) {
#line 761
    goto case_3;
  }
#line 764
  if ((unsigned int )res == 0U) {
#line 764
    goto case_0;
  }
#line 730
  goto switch_break;
  case_1: /* CIL Label */ 
#line 733
  if ((unsigned long )hostname == (unsigned long )((void *)0)) {
    {
#line 734
    hostname = s_crea_c_str((String const   )scb->remote);
    }
  }
#line 736
  if (errcode == 1L) {
    {
#line 737
    kom_log("No hostname found for %s.\n", hostname);
    }
  } else
#line 738
  if (errcode == 2L) {
    {
#line 739
    kom_log("Lookup of %s timed out.\n", hostname);
    }
  } else
#line 740
  if (errcode == 3L) {
    {
#line 741
    kom_log("Non-recoverable error looking up %s.\n", hostname);
    }
  } else
#line 742
  if (errcode == 4L) {
    {
#line 743
    kom_log("Got NO_ADDRESS error looking up %s.\n", hostname);
    }
  } else {
    {
#line 745
    kom_log("Unknown resolver error %ld looking up %s.\n", errcode, hostname);
    }
  }
#line 747
  goto switch_break;
  case_2: /* CIL Label */ 
#line 750
  if ((unsigned long )hostname == (unsigned long )((void *)0)) {
    {
#line 751
    hostname = s_crea_c_str((String const   )scb->remote);
    }
  }
#line 755
  if (errcode != 100L) {
#line 755
    if (errcode != 300L) {
      {
#line 757
      tmp___2 = adns_strerror((adns_status )errcode);
#line 757
      kom_log("Error looking up %s: %s\n", hostname, tmp___2);
      }
    } else {
#line 755
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 755
    tmp___3 = strcmp((char const   *)hostname, "127.0.0.1");
    }
#line 755
    if (tmp___3 != 0) {
      {
#line 757
      tmp___2 = adns_strerror((adns_status )errcode);
#line 757
      kom_log("Error looking up %s: %s\n", hostname, tmp___2);
      }
    }
  }
#line 759
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 762
  abort();
  }
  case_0: /* CIL Label */ 
#line 765
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 768
  if (diff > param.dns_log_threshold) {
#line 770
    if ((unsigned long )hostname == (unsigned long )((void *)0)) {
      {
#line 771
      hostname = s_crea_c_str((String const   )scb->remote);
      }
    }
#line 773
    if ((unsigned int )res == 0U) {
      {
#line 774
      kom_log("Slow DNS: got %s after %f seconds\n", hostname, diff);
      }
    } else {
      {
#line 776
      kom_log("Slow bad DNS: %s failed after %f seconds\n", hostname, diff);
      }
    }
  }
#line 780
  if ((unsigned long )hostname != (unsigned long )((void *)0)) {
    {
#line 781
    string_free((void *)hostname);
    }
  }
  {
#line 783
  tmp___4 = handshake_ok(conn, (enum ignored_conditions )0);
  }
#line 783
  if (tmp___4) {
    {
#line 784
    dump_connections();
    }
  }
#line 786
  return ((void *)(& _oop_continue));
}
}
#line 790 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void write_err_cb(struct isc_scb *cb_session , int saved_errno ) 
{ 
  Connection *cp ;
  char *tmp ;

  {
#line 794
  cp = cb_session->udg;
#line 795
  if (saved_errno != 104) {
#line 795
    if (saved_errno != 32) {
      {
#line 796
      tmp = strerror(saved_errno);
#line 796
      kom_log("Failed to write to client %lu from %s: %s\n", cp->session_no, cp->peer,
              tmp);
      }
    }
  }
  {
#line 798
  cp->penalty += param.max_penalty;
#line 799
  add_to_kill_list(cp);
  }
#line 800
  return;
}
}
#line 803 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void stale_cb(struct isc_scb *cb_session ) 
{ 
  Connection *cp ;

  {
  {
#line 806
  cp = cb_session->udg;
#line 807
  kom_log("Client %lu from %s has stalled.  Killing it.\n", cp->session_no, cp->peer);
#line 809
  cp->penalty += param.max_penalty;
#line 810
  add_to_kill_list(cp);
  }
#line 811
  return;
}
}
#line 814 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void idle_cb(struct isc_scb *cb_session ) 
{ 
  Connection *cp ;

  {
  {
#line 817
  cp = cb_session->udg;
#line 818
  kom_log("Client %lu from %s has been idle too long.  Killing it.\n", cp->session_no,
          cp->peer);
#line 820
  cp->penalty += param.max_penalty;
#line 821
  add_to_kill_list(cp);
  }
#line 822
  return;
}
}
#line 825 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void login_request(struct isc_scb *session ) 
{ 
  Connection *cp ;
  char const   *realuser ;
  char portbuf[3UL + 3UL * sizeof(long )] ;
  size_t portlen ;
  char *remote_ip ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 832
  remote_ip = (char *)((void *)0);
#line 835
  tmp = fexists((char const   *)param.nologin_file);
  }
#line 835
  if (tmp) {
    {
#line 837
    isc_puts("%% No logins allowed.\n", session);
#line 838
    isc_flush(session);
#line 839
    isc_destroy(kom_server_mcb, session);
    }
#line 840
    return;
  }
  {
#line 846
  cp = new_client();
#line 847
  cp->isc_session = session;
#line 848
  session->udg = cp;
#line 849
  update_stat((enum stat_type )3, 1L);
#line 852
  tmp___0 = isc_getipnum(session->raddr, (char *)((void *)0), 0);
#line 852
  s_crea_str(& cp->remote_ip, (char const   *)tmp___0);
#line 853
  remote_ip = s_crea_c_str((String const   )cp->remote_ip);
  }
#line 856
  if (param.use_dns) {
    {
#line 856
    tmp___1 = isc_resolve_remote(session, & dns_resolution);
    }
#line 856
    if (tmp___1 == 0) {
      {
#line 857
      update_stat((enum stat_type )1, 1L);
      }
    } else {
      {
#line 859
      s_strcpy(& session->remote, (String const   )cp->remote_ip);
      }
    }
  } else {
    {
#line 859
    s_strcpy(& session->remote, (String const   )cp->remote_ip);
    }
  }
  {
#line 862
  tmp___2 = isc_getportnum(session->raddr);
#line 862
  sprintf((char */* __restrict  */)(portbuf), (char const   */* __restrict  */)" %d",
          tmp___2);
#line 863
  portlen = strlen((char const   *)(portbuf));
#line 864
  tmp___3 = smalloc(((size_t )cp->remote_ip.len + portlen) + 1UL);
#line 864
  cp->peer = (char *)tmp___3;
#line 865
  strcpy((char */* __restrict  */)cp->peer, (char const   */* __restrict  */)remote_ip);
#line 866
  strcpy((char */* __restrict  */)(cp->peer + cp->remote_ip.len), (char const   */* __restrict  */)(portbuf));
#line 868
  dump_connections();
#line 872
  cp->penalty = param.max_penalty;
#line 873
  cp->penalty_generation = penalty_generation;
#line 875
  cp->schedule.priority = (unsigned short )param.default_priority;
#line 876
  cp->schedule.weight = (unsigned short )param.default_weight;
#line 879
  realuser = get_real_username(session, remote_ip);
  }
#line 880
  if ((unsigned long )realuser == (unsigned long )((void *)0)) {
#line 880
    if (param.authentication_level == 2) {
      {
#line 882
      kom_log("Connection from %s rejected - no IDENT available.\n", remote_ip);
#line 885
      isc_puts("%% No IDENT server reachable at your site.\n", session);
#line 887
      isc_flush(session);
#line 888
      logout_client(cp);
#line 889
      string_free((void *)remote_ip);
      }
#line 890
      return;
    }
  }
#line 893
  if ((unsigned long )realuser != (unsigned long )((void *)0)) {
    {
#line 894
    s_crea_str(& cp->ident_user, realuser);
    }
  }
#line 896
  if (buglevel > 0) {
    {
#line 896
    printf((char const   */* __restrict  */)"\n[Client %lu from %s is connecting]\n",
           cp->session_no, remote_ip);
    }
  }
  {
#line 898
  isc_set_read_callback(session, & data_available_callback, & write_err_cb, & stale_cb,
                        & idle_cb);
#line 900
  string_free((void *)remote_ip);
  }
#line 901
  return;
}
}
#line 903 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void adjust_penalty(Connection *conn ) 
{ 
  unsigned int gens ;
  unsigned int tmp ;

  {
#line 906
  gens = penalty_generation - conn->penalty_generation;
#line 907
  if (gens > 0U) {
#line 913
    if (conn->penalty <= gens) {
#line 914
      conn->penalty = 0U;
    } else {
#line 917
      tmp = conn->penalty - gens * (unsigned int )conn->schedule.weight;
#line 918
      if (tmp < conn->penalty) {
#line 919
        conn->penalty = tmp;
      } else {
#line 921
        conn->penalty = 0U;
      }
    }
#line 924
    conn->penalty_generation = penalty_generation;
  }
#line 926
  return;
}
}
#line 929 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void read_from_connection(Connection *conn ) 
{ 
  Bool would_block ;
  Bool need_flush ;
  String_size pre ;
  Bool tmp ;
  enum isc_read_result tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  Success tmp___5 ;
  int tmp___6 ;

  {
  {
#line 932
  would_block = (Bool )0;
#line 933
  need_flush = (Bool )0;
#line 936
  adjust_penalty(conn);
  }
  {
#line 938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 938
    if (! would_block) {
#line 938
      if (! go_and_die) {
#line 938
        if (conn->penalty < param.max_penalty) {
#line 938
          if ((unsigned int )conn->kill_status == 0U) {
#line 938
            if (! (! conn->blocked_by_dns)) {
#line 938
              goto while_break;
            }
          } else {
#line 938
            goto while_break;
          }
        } else {
#line 938
          goto while_break;
        }
      } else {
#line 938
        goto while_break;
      }
    } else {
#line 938
      goto while_break;
    }
#line 941
    pre = conn->unparsed.len - conn->first_to_parse;
    {
#line 942
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 942
      if (conn->more_to_parse) {
#line 942
        if (! go_and_die) {
#line 942
          if (conn->penalty < param.max_penalty) {
#line 942
            if ((unsigned int )conn->kill_status == 0U) {
#line 942
              if (! (! conn->blocked_by_dns)) {
#line 942
                goto while_break___0;
              }
            } else {
#line 942
              goto while_break___0;
            }
          } else {
#line 942
            goto while_break___0;
          }
        } else {
#line 942
          goto while_break___0;
        }
      } else {
#line 942
        goto while_break___0;
      }
      {
#line 945
      tmp = parse_unparsed(conn);
#line 945
      need_flush = (Bool )((unsigned int )need_flush | (unsigned int )tmp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 946
    update_stat((enum stat_type )9, (conn->unparsed.len - conn->first_to_parse) - pre);
    }
#line 949
    if (go_and_die) {
#line 951
      goto while_break;
    } else
#line 949
    if (conn->penalty >= param.max_penalty) {
#line 951
      goto while_break;
    } else
#line 949
    if ((unsigned int )conn->kill_status != 0U) {
#line 951
      goto while_break;
    } else
#line 949
    if (conn->blocked_by_dns) {
#line 951
      goto while_break;
    }
#line 953
    if (! conn->more_to_parse) {
      {
#line 955
      pre = conn->unparsed.len - conn->first_to_parse;
#line 956
      tmp___0 = isc_read_data(conn->isc_session, & conn->unparsed, & conn->first_to_parse);
      }
      {
#line 960
      if ((unsigned int )tmp___0 == 0U) {
#line 960
        goto case_0;
      }
#line 967
      if ((unsigned int )tmp___0 == 3U) {
#line 967
        goto case_3;
      }
#line 972
      if ((unsigned int )tmp___0 == 1U) {
#line 972
        goto case_1;
      }
#line 975
      if ((unsigned int )tmp___0 == 2U) {
#line 975
        goto case_2;
      }
#line 978
      if ((unsigned int )tmp___0 == 4U) {
#line 978
        goto case_4;
      }
#line 956
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 961
      update_stat((enum stat_type )9, (conn->unparsed.len - conn->first_to_parse) - pre);
#line 964
      conn->penalty += param.penalty_per_read;
#line 965
      conn->more_to_parse = (Bool )1;
      }
#line 966
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 968
      tmp___3 = __errno_location();
      }
#line 968
      if (*tmp___3 != 104) {
        {
#line 968
        tmp___4 = __errno_location();
        }
#line 968
        if (*tmp___4 != 110) {
          {
#line 969
          tmp___1 = __errno_location();
#line 969
          tmp___2 = strerror(*tmp___1);
#line 969
          kom_log("Error reading from client: %s\n", tmp___2);
          }
        }
      }
      case_1: /* CIL Label */ 
      {
#line 973
      add_to_kill_list(conn);
      }
#line 974
      goto switch_break;
      case_2: /* CIL Label */ 
#line 976
      would_block = (Bool )1;
#line 977
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 979
      restart_kom("isc_read_data() reports no memory\n");
      }
      switch_break: /* CIL Label */ ;
      }
#line 982
      if (! conn->more_to_parse) {
#line 983
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 987
  if (need_flush) {
    {
#line 988
    isc_flush(conn->isc_session);
    }
  }
  {
#line 991
  tmp___5 = s_trim_left(& conn->unparsed, conn->first_to_parse);
  }
#line 991
  if ((unsigned long )tmp___5 != (unsigned long )OK) {
    {
#line 992
    restart_kom("parse_unparsed: s_trim_left\n");
    }
  }
#line 993
  conn->first_to_parse = (String_size )0;
#line 995
  if (conn->penalty >= param.max_penalty) {
#line 995
    if (! conn->blocked_by_dns) {
      {
#line 1000
      tmp___6 = isc_disable(conn->isc_session);
      }
#line 1000
      if (tmp___6 == 0) {
        {
#line 1001
        queue_add(conn);
        }
      }
    }
  }
#line 1003
  return;
}
}
#line 1006 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void enable_idle_check(void) 
{ 
  oop_source *source ;
  oop_source *tmp ;

  {
  {
#line 1009
  tmp = oop_sys_source(kom_server_oop_src);
#line 1009
  source = tmp;
#line 1011
  (*(source->on_time))(source, (struct timeval )OOP_TIME_NOW___0, & check_idle_callback,
                       (void *)0);
  }
#line 1012
  return;
}
}
#line 1015 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void *check_idle_callback(oop_source *qazwsxedcsource  __attribute__((__unused__)) ,
                                 struct timeval qazwsxedctv  __attribute__((__unused__)) ,
                                 void *qazwsxedcuser  __attribute__((__unused__)) ) 
{ 
  Connection *c ;
  Connection *next ;
  Connection *head ;
  Connection *tail ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 1022
  head = (Connection *)((void *)0);
#line 1023
  tail = (Connection *)((void *)0);
#line 1025
  set_time();
#line 1026
  is_idle = (Bool )(! work_done);
#line 1027
  work_done = (Bool )0;
  }
#line 1029
  if (is_idle) {
#line 1029
    if ((unsigned long )queue_first != (unsigned long )((void *)0)) {
#line 1031
      is_idle = (Bool )0;
#line 1032
      penalty_generation ++;
#line 1034
      next = queue_first;
      {
#line 1034
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1034
        if (! ((unsigned long )next != (unsigned long )((void *)0))) {
#line 1034
          goto while_break;
        }
        {
#line 1036
        c = next;
#line 1037
        next = next->queue_next;
#line 1038
        adjust_penalty(c);
        }
#line 1039
        if (c->penalty < param.low_penalty) {
          {
#line 1041
          queue_remove(c);
          }
#line 1043
          if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 1044
            head = c;
          } else {
#line 1046
            tail->queue_next = c;
          }
#line 1047
          tail = c;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1052
  next = head;
  {
#line 1052
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1052
    if (! ((unsigned long )next != (unsigned long )((void *)0))) {
#line 1052
      goto while_break___0;
    }
    {
#line 1054
    c = next;
#line 1055
    next = next->queue_next;
#line 1056
    c->queue_next = (struct connection *)((void *)0);
#line 1057
    tmp = isc_enable(c->isc_session);
    }
#line 1057
    if (tmp < 0) {
      {
#line 1058
      restart_kom("failed to re-enable session\n");
      }
    }
#line 1063
    if (! go_and_die) {
      {
#line 1064
      read_from_connection(c);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1067
  if (! is_idle) {
    {
#line 1068
    enable_idle_check();
    }
  }
#line 1071
  if (go_and_die) {
#line 1071
    tmp___0 = (void *)0;
  } else {
#line 1071
    tmp___0 = (void *)(& _oop_continue);
  }
#line 1071
  return (tmp___0);
}
}
#line 1074 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void *saver_callback(oop_source *source , struct timeval qazwsxedctv  __attribute__((__unused__)) ,
                            void *user ) 
{ 
  struct timeval timeout ;
  struct timeval *next_timer ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1080
  next_timer = (struct timeval *)user;
#line 1082
  timeout = end_of_atomic();
#line 1083
  tmp___1 = setup_timer(next_timer, timeout);
  }
#line 1083
  if (tmp___1 < 0) {
    {
#line 1084
    tmp = __errno_location();
#line 1084
    tmp___0 = strerror(*tmp);
#line 1084
    kom_log("gettimeofday failed: %s\n", tmp___0);
    }
  }
  {
#line 1086
  (*(source->on_time))(source, *next_timer, & saver_callback, user);
  }
#line 1087
  return ((void *)(& _oop_continue));
}
}
#line 1091 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void busy(void) 
{ 


  {
#line 1095
  if (is_idle) {
    {
#line 1097
    is_idle = (Bool )0;
#line 1098
    enable_idle_check();
    }
  }
#line 1101
  work_done = (Bool )1;
#line 1102
  return;
}
}
#line 1104 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static void *data_available_callback(oop_source *source , int fd , oop_event event ,
                                     void *user ) 
{ 
  Connection *conn ;
  oop_source *tmp ;
  void *tmp___0 ;

  {
#line 1110
  conn = ((struct isc_scb *)user)->udg;
#line 1112
  if (! ((unsigned int )event == 0U)) {
    {
#line 1112
    __assert_fail("event == OOP_READ", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c",
                  1112U, "data_available_callback");
    }
  }
#line 1113
  if (! ((conn->isc_session)->fd == fd)) {
    {
#line 1113
    __assert_fail("conn->isc_session->fd == fd", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c",
                  1113U, "data_available_callback");
    }
  }
  {
#line 1114
  tmp = isc_getoopsource(conn->isc_session);
  }
#line 1114
  if (! ((unsigned long )tmp == (unsigned long )source)) {
    {
#line 1114
    __assert_fail("isc_getoopsource(conn->isc_session) == source", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c",
                  1114U, "data_available_callback");
    }
  }
#line 1115
  if (! ((unsigned int )conn->on_queue == 0U)) {
    {
#line 1115
    __assert_fail("conn->on_queue == FALSE", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c",
                  1115U, "data_available_callback");
    }
  }
  {
#line 1117
  busy();
#line 1118
  set_time();
#line 1119
  read_from_connection(conn);
  }
#line 1122
  if (go_and_die) {
#line 1122
    tmp___0 = (void *)0;
  } else {
#line 1122
    tmp___0 = (void *)(& _oop_continue);
  }
#line 1122
  return (tmp___0);
}
}
#line 1126 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
void *handle_accept_event(struct isc_scb *qazwsxedcaccepting_session  __attribute__((__unused__)) ,
                          struct isc_scb *new_session ) 
{ 


  {
  {
#line 1130
  new_session->udg = (struct connection *)((void *)0);
#line 1132
  set_time();
  }
#line 1134
  if (new_session->fd <= 22) {
#line 1134
    goto _L;
  } else
#line 1134
  if (new_session->fd >= fd_ceiling) {
    _L: /* CIL Label */ 
#line 1136
    if (buglevel > 0) {
      {
#line 1136
      printf((char const   */* __restrict  */)"Connection attempt rejected.\n");
      }
    }
    {
#line 1137
    isc_puts("%% No connections left.\n", new_session);
#line 1138
    isc_flush(new_session);
#line 1139
    isc_destroy(new_session->master, new_session);
#line 1141
    async_rejected_connection();
    }
  } else {
    {
#line 1144
    login_request(new_session);
    }
  }
#line 1146
  return ((void *)(& _oop_continue));
}
}
#line 1150 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
void toploop(void) 
{ 
  struct timeval saver_timer ;
  void *exit_reason ;
  oop_source *source ;
  oop_source *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1156
  tmp = oop_sys_source(kom_server_oop_src);
#line 1156
  source = tmp;
#line 1159
  start_garb_thread(source);
#line 1162
  enable_idle_check();
#line 1165
  saver_timer = (struct timeval )OOP_TIME_NOW___0;
#line 1166
  (*(source->on_time))(source, saver_timer, & saver_callback, (void *)(& saver_timer));
#line 1168
  exit_reason = oop_sys_run(kom_server_oop_src);
  }
#line 1170
  if ((unsigned long )exit_reason == (unsigned long )((void *)(& _oop_error))) {
    {
#line 1171
    tmp___0 = __errno_location();
#line 1171
    tmp___1 = strerror(*tmp___0);
#line 1171
    kom_log("ERROR: unexpected error from oop_sys_run: %s\n", tmp___1);
    }
  } else
#line 1173
  if ((unsigned long )exit_reason == (unsigned long )((void *)(& _oop_continue))) {
    {
#line 1174
    kom_log("ERROR: all oop sinks disappeared\n");
    }
  } else
#line 1175
  if ((unsigned long )exit_reason != (unsigned long )((void *)0)) {
    {
#line 1176
    tmp___2 = __errno_location();
#line 1176
    tmp___3 = strerror(*tmp___2);
#line 1176
    kom_log("ERROR: unexpected error from oop_sys_run: %s\n", tmp___3);
    }
  }
#line 1179
  if (kill_pending) {
    {
#line 1181
    (*(source->cancel_time))(source, (struct timeval )OOP_TIME_NOW___0, & check_kill_flg,
                             (void *)0);
#line 1182
    check_kill_flg((oop_source *)((void *)0), (struct timeval )OOP_TIME_NOW___0, (void *)0);
    }
  }
#line 1185
  if ((unsigned int )is_idle == 0U) {
    {
#line 1186
    (*(source->cancel_time))(source, (struct timeval )OOP_TIME_NOW___0, & check_idle_callback,
                             (void *)0);
    }
  }
  {
#line 1188
  stop_garb_thread(source);
#line 1189
  (*(source->cancel_time))(source, saver_timer, & saver_callback, (void *)(& saver_timer));
  }
#line 1190
  return;
}
}
#line 1192 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
Bool server_idle(void) 
{ 


  {
#line 1195
  return (is_idle);
}
}
#line 1198 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
Success get_scheduling(Session_no session_no , Scheduling_info *result ) 
{ 
  Connection *cptr ;
  Bool tmp ;

  {
  {
#line 1204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1204
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1204
      err_stat = 0UL;
#line 1204
      kom_errno = (enum kom_err )51;
#line 1204
      return ((Success )FAILURE);
    }
#line 1204
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1205
  if (session_no != 0UL) {
#line 1205
    if (session_no != active_connection->session_no) {
      {
#line 1206
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1206
        if (! active_connection) {
#line 1206
          err_stat = 0UL;
#line 1206
          kom_errno = (enum kom_err )6;
#line 1206
          return ((Success )FAILURE);
        } else
#line 1206
        if (! active_connection->pers_no) {
#line 1206
          err_stat = 0UL;
#line 1206
          kom_errno = (enum kom_err )6;
#line 1206
          return ((Success )FAILURE);
        }
#line 1206
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 1208
  cptr = get_conn_by_number(session_no);
  }
#line 1208
  if ((unsigned long )cptr == (unsigned long )((void *)0)) {
#line 1211
    kom_errno = (enum kom_err )42;
#line 1212
    err_stat = session_no;
#line 1213
    return ((Success )FAILURE);
  } else {
    {
#line 1208
    tmp = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 1208
    if (! tmp) {
#line 1211
      kom_errno = (enum kom_err )42;
#line 1212
      err_stat = session_no;
#line 1213
      return ((Success )FAILURE);
    }
  }
#line 1216
  *result = cptr->schedule;
#line 1218
  return ((Success )OK);
}
}
#line 1222 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
static Bool may_change_scheduling(Session_no session_no , Connection *cptr ) 
{ 
  Bool tmp ;

  {
#line 1226
  if (session_no == 0UL) {
#line 1227
    return ((Bool )1);
  }
#line 1229
  if (session_no == active_connection->session_no) {
#line 1230
    return ((Bool )1);
  }
#line 1232
  if ((int )cptr->pers_no == 0) {
#line 1232
    if ((int )active_connection->ena_level >= 2) {
#line 1232
      if (active_connection->person) {
#line 1232
        if ((active_connection->person)->privileges.admin) {
#line 1235
          return ((Bool )1);
        } else {
#line 1232
          goto _L___0;
        }
      } else {
#line 1232
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1232
    if ((int )active_connection->ena_level >= 8) {
#line 1232
      if (active_connection->person) {
#line 1232
        if ((active_connection->person)->privileges.wheel) {
#line 1235
          return ((Bool )1);
        }
      }
    }
  }
  {
#line 1237
  tmp = has_access(cptr->pers_no, (Connection const   *)active_connection, (enum access )5);
  }
#line 1237
  if (tmp) {
#line 1238
    return ((Bool )1);
  }
#line 1240
  return ((Bool )0);
}
}
#line 1244 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/connections.c"
Success set_scheduling(Session_no session_no , unsigned short priority , unsigned short weight ) 
{ 
  Connection *cptr ;
  Bool tmp ;
  Bool tmp___0 ;

  {
  {
#line 1251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1251
    if ((unsigned long )active_connection == (unsigned long )((void *)0)) {
#line 1251
      err_stat = 0UL;
#line 1251
      kom_errno = (enum kom_err )51;
#line 1251
      return ((Success )FAILURE);
    }
#line 1251
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1253
  if ((int )weight == 0) {
#line 1255
    kom_errno = (enum kom_err )60;
#line 1256
    err_stat = 0UL;
#line 1257
    return ((Success )FAILURE);
  }
#line 1260
  if (session_no != 0UL) {
#line 1260
    if (session_no != active_connection->session_no) {
      {
#line 1261
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1261
        if (! active_connection) {
#line 1261
          err_stat = 0UL;
#line 1261
          kom_errno = (enum kom_err )6;
#line 1261
          return ((Success )FAILURE);
        } else
#line 1261
        if (! active_connection->pers_no) {
#line 1261
          err_stat = 0UL;
#line 1261
          kom_errno = (enum kom_err )6;
#line 1261
          return ((Success )FAILURE);
        }
#line 1261
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 1263
  cptr = get_conn_by_number(session_no);
  }
#line 1263
  if ((unsigned long )cptr == (unsigned long )((void *)0)) {
#line 1266
    kom_errno = (enum kom_err )42;
#line 1267
    err_stat = session_no;
#line 1268
    return ((Success )FAILURE);
  } else {
    {
#line 1263
    tmp = handshake_ok(cptr, (enum ignored_conditions )0);
    }
#line 1263
    if (! tmp) {
#line 1266
      kom_errno = (enum kom_err )42;
#line 1267
      err_stat = session_no;
#line 1268
      return ((Success )FAILURE);
    }
  }
  {
#line 1271
  tmp___0 = may_change_scheduling(session_no, cptr);
  }
#line 1271
  if (! tmp___0) {
#line 1273
    kom_errno = (enum kom_err )11;
#line 1274
    err_stat = session_no;
#line 1275
    return ((Success )FAILURE);
  }
#line 1278
  if ((unsigned int )priority > param.max_priority) {
#line 1280
    kom_errno = (enum kom_err )19;
#line 1281
    err_stat = (unsigned long )param.max_priority;
#line 1282
    return ((Success )FAILURE);
  }
#line 1295
  if ((unsigned int )weight > param.max_weight) {
#line 1297
    kom_errno = (enum kom_err )59;
#line 1298
    err_stat = (unsigned long )param.max_weight;
#line 1299
    return ((Success )FAILURE);
  }
#line 1302
  cptr->schedule.priority = priority;
#line 1303
  cptr->schedule.weight = weight;
#line 1305
  return ((Success )OK);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 101 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
int yyleng  ;
#line 102
FILE *yyout ;
#line 201 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static YY_BUFFER_STATE yy_current_buffer  =    (YY_BUFFER_STATE )0;
#line 211 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static char yy_hold_char  ;
#line 213 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static int yy_n_chars  ;
#line 219 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static char *yy_c_buf_p  =    (char *)0;
#line 220 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static int yy_init  =    1;
#line 221 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static int yy_start  =    0;
#line 226 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static int yy_did_buffer_switch_on_eof  ;
#line 228
void yyrestart(FILE *input_file ) ;
#line 230
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 231
void yy_load_buffer_state(void) ;
#line 232
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
#line 233
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 234
void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 235
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 238
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
#line 239
YY_BUFFER_STATE yy_scan_string(char const   *yy_str ) ;
#line 240
YY_BUFFER_STATE yy_scan_bytes(char const   *bytes , int len ) ;
#line 242
static void *yy_flex_alloc(yy_size_t size ) ;
#line 244
static void yy_flex_free(void *ptr ) ;
#line 270 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
FILE *yyin  =    (FILE *)0;
#line 270 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
FILE *yyout  =    (FILE *)0;
#line 272
int yylineno ;
#line 273 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
int yylineno  =    1;
#line 274 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
char *yytext  ;
#line 277
static yy_state_type yy_get_previous_state(void) ;
#line 278
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 279
static int yy_get_next_buffer(void) ;
#line 280
static void yy_fatal_error(char const   *msg ) ;
#line 294 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static short const   yy_acclist[154]  = 
#line 294
  {      (short const   )0,      (short const   )32,      (short const   )30,      (short const   )31, 
        (short const   )12,      (short const   )30,      (short const   )31,      (short const   )12, 
        (short const   )31,      (short const   )15,      (short const   )30,      (short const   )31, 
        (short const   )11,      (short const   )30,      (short const   )31,      (short const   )14, 
        (short const   )30,      (short const   )31,      (short const   )13,      (short const   )30, 
        (short const   )31,      (short const   )13,      (short const   )30,      (short const   )31, 
        (short const   )13,      (short const   )30,      (short const   )31,      (short const   )13, 
        (short const   )30,      (short const   )31,      (short const   )13,      (short const   )30, 
        (short const   )31,      (short const   )13,      (short const   )30,      (short const   )31, 
        (short const   )13,      (short const   )30,      (short const   )31,      (short const   )13, 
        (short const   )30,      (short const   )31,      (short const   )13,      (short const   )30, 
        (short const   )31,      (short const   )13,      (short const   )30,      (short const   )31, 
        (short const   )13,      (short const   )30,      (short const   )31,      (short const   )13, 
        (short const   )30,      (short const   )31,      (short const   )28,      (short const   )31, 
        (short const   )29,      (short const   )31,      (short const   )17,      (short const   )31, 
        (short const   )28,      (short const   )31,      (short const   )31,      (short const   )12, 
        (short const   )11,      (short const   )14,      (short const   )13,      (short const   )13, 
        (short const   )13,      (short const   )13,      (short const   )13,      (short const   )13, 
        (short const   )13,      (short const   )13,      (short const   )2,      (short const   )13, 
        (short const   )13,      (short const   )1,      (short const   )13,      (short const   )13, 
        (short const   )13,      (short const   )13,      (short const   )13,      (short const   )28, 
        (short const   )28,      (short const   )27,      (short const   )25,      (short const   )27, 
        (short const   )24,      (short const   )27,      (short const   )18,      (short const   )27, 
        (short const   )22,      (short const   )27,      (short const   )23,      (short const   )27, 
        (short const   )19,      (short const   )27,      (short const   )21,      (short const   )27, 
        (short const   )20,      (short const   )27,      (short const   )8,      (short const   )13, 
        (short const   )13,      (short const   )13,      (short const   )13,      (short const   )13, 
        (short const   )13,      (short const   )13,      (short const   )13,      (short const   )13, 
        (short const   )13,      (short const   )28,      (short const   )26,      (short const   )18, 
        (short const   )13,      (short const   )13,      (short const   )13,      (short const   )13, 
        (short const   )13,      (short const   )13,      (short const   )13,      (short const   )4, 
        (short const   )13,      (short const   )18,      (short const   )13,      (short const   )13, 
        (short const   )13,      (short const   )13,      (short const   )13,      (short const   )13, 
        (short const   )13,      (short const   )9,      (short const   )13,      (short const   )13, 
        (short const   )13,      (short const   )10,      (short const   )13,      (short const   )7, 
        (short const   )13,      (short const   )16,      (short const   )13,      (short const   )13, 
        (short const   )13,      (short const   )13,      (short const   )3,      (short const   )13, 
        (short const   )13,      (short const   )13,      (short const   )6,      (short const   )13, 
        (short const   )5,      (short const   )13};
#line 315 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static short const   yy_accept[107]  = 
#line 315
  {      (short const   )0,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )2,      (short const   )4, 
        (short const   )7,      (short const   )9,      (short const   )12,      (short const   )15, 
        (short const   )18,      (short const   )21,      (short const   )24,      (short const   )27, 
        (short const   )30,      (short const   )33,      (short const   )36,      (short const   )39, 
        (short const   )42,      (short const   )45,      (short const   )48,      (short const   )51, 
        (short const   )54,      (short const   )56,      (short const   )58,      (short const   )60, 
        (short const   )62,      (short const   )63,      (short const   )64,      (short const   )65, 
        (short const   )66,      (short const   )67,      (short const   )68,      (short const   )69, 
        (short const   )70,      (short const   )71,      (short const   )72,      (short const   )73, 
        (short const   )74,      (short const   )76,      (short const   )77,      (short const   )79, 
        (short const   )80,      (short const   )81,      (short const   )82,      (short const   )83, 
        (short const   )84,      (short const   )85,      (short const   )86,      (short const   )86, 
        (short const   )88,      (short const   )90,      (short const   )92,      (short const   )94, 
        (short const   )96,      (short const   )98,      (short const   )100,      (short const   )102, 
        (short const   )104,      (short const   )105,      (short const   )106,      (short const   )107, 
        (short const   )108,      (short const   )109,      (short const   )110,      (short const   )111, 
        (short const   )112,      (short const   )113,      (short const   )114,      (short const   )115, 
        (short const   )116,      (short const   )117,      (short const   )118,      (short const   )119, 
        (short const   )120,      (short const   )121,      (short const   )122,      (short const   )123, 
        (short const   )125,      (short const   )125,      (short const   )126,      (short const   )127, 
        (short const   )128,      (short const   )129,      (short const   )130,      (short const   )131, 
        (short const   )132,      (short const   )132,      (short const   )133,      (short const   )135, 
        (short const   )136,      (short const   )137,      (short const   )139,      (short const   )141, 
        (short const   )142,      (short const   )143,      (short const   )144,      (short const   )145, 
        (short const   )146,      (short const   )148,      (short const   )149,      (short const   )150, 
        (short const   )152,      (short const   )154,      (short const   )154};
#line 331 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static int const   yy_ec[256]  = 
#line 331
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )4,      (int const   )1,      (int const   )5,      (int const   )6, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )7, 
        (int const   )1,      (int const   )1,      (int const   )8,      (int const   )1, 
        (int const   )1,      (int const   )9,      (int const   )1,      (int const   )1, 
        (int const   )10,      (int const   )10,      (int const   )10,      (int const   )10, 
        (int const   )10,      (int const   )10,      (int const   )10,      (int const   )10, 
        (int const   )10,      (int const   )10,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )11,      (int const   )11,      (int const   )11, 
        (int const   )11,      (int const   )11,      (int const   )11,      (int const   )11, 
        (int const   )11,      (int const   )11,      (int const   )11,      (int const   )11, 
        (int const   )11,      (int const   )11,      (int const   )11,      (int const   )11, 
        (int const   )11,      (int const   )11,      (int const   )11,      (int const   )11, 
        (int const   )11,      (int const   )11,      (int const   )11,      (int const   )11, 
        (int const   )11,      (int const   )11,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )1,      (int const   )9, 
        (int const   )1,      (int const   )15,      (int const   )16,      (int const   )17, 
        (int const   )18,      (int const   )19,      (int const   )20,      (int const   )11, 
        (int const   )11,      (int const   )21,      (int const   )11,      (int const   )11, 
        (int const   )22,      (int const   )23,      (int const   )24,      (int const   )25, 
        (int const   )11,      (int const   )11,      (int const   )26,      (int const   )27, 
        (int const   )28,      (int const   )29,      (int const   )30,      (int const   )11, 
        (int const   )31,      (int const   )32,      (int const   )11,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1};
#line 363 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static int const   yy_meta[33]  = 
#line 363
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )2, 
        (int const   )1,      (int const   )3,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )1,      (int const   )3,      (int const   )1,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4};
#line 371 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static short const   yy_base[111]  = 
#line 371
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )30, 
        (short const   )33,      (short const   )143,      (short const   )144,      (short const   )37, 
        (short const   )45,      (short const   )144,      (short const   )0,      (short const   )132, 
        (short const   )0,      (short const   )117,      (short const   )25,      (short const   )119, 
        (short const   )124,      (short const   )119,      (short const   )112,      (short const   )111, 
        (short const   )32,      (short const   )116,      (short const   )18,      (short const   )115, 
        (short const   )0,      (short const   )144,      (short const   )144,      (short const   )129, 
        (short const   )54,      (short const   )51,      (short const   )0,      (short const   )122, 
        (short const   )0,      (short const   )99,      (short const   )106,      (short const   )110, 
        (short const   )101,      (short const   )105,      (short const   )98,      (short const   )107, 
        (short const   )0,      (short const   )104,      (short const   )0,      (short const   )97, 
        (short const   )91,      (short const   )92,      (short const   )93,      (short const   )0, 
        (short const   )117,      (short const   )144,      (short const   )56,      (short const   )144, 
        (short const   )144,      (short const   )108,      (short const   )144,      (short const   )144, 
        (short const   )144,      (short const   )144,      (short const   )144,      (short const   )0, 
        (short const   )97,      (short const   )101,      (short const   )100,      (short const   )87, 
        (short const   )85,      (short const   )91,      (short const   )81,      (short const   )82, 
        (short const   )90,      (short const   )105,      (short const   )61,      (short const   )97, 
        (short const   )87,      (short const   )77,      (short const   )88,      (short const   )84, 
        (short const   )83,      (short const   )81,      (short const   )81,      (short const   )0, 
        (short const   )85,      (short const   )144,      (short const   )67,      (short const   )73, 
        (short const   )66,      (short const   )55,      (short const   )47,      (short const   )51, 
        (short const   )68,      (short const   )56,      (short const   )0,      (short const   )54, 
        (short const   )56,      (short const   )0,      (short const   )0,      (short const   )144, 
        (short const   )47,      (short const   )51,      (short const   )43,      (short const   )50, 
        (short const   )0,      (short const   )35,      (short const   )43,      (short const   )0, 
        (short const   )0,      (short const   )144,      (short const   )82,      (short const   )86, 
        (short const   )30,      (short const   )90,      (short const   )94};
#line 387 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static short const   yy_def[111]  = 
#line 387
  {      (short const   )0,      (short const   )105,      (short const   )1,      (short const   )106, 
        (short const   )106,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )107,      (short const   )105, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )109,      (short const   )105,      (short const   )105,      (short const   )109, 
        (short const   )110,      (short const   )105,      (short const   )107,      (short const   )105, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )109, 
        (short const   )109,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )108, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )109,      (short const   )105,      (short const   )105, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )105,      (short const   )105,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )105,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )105, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )0,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105};
#line 403 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static short const   yy_nxt[177]  = 
#line 403
  {      (short const   )0,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )7,      (short const   )9,      (short const   )10,      (short const   )6, 
        (short const   )6,      (short const   )6,      (short const   )11,      (short const   )12, 
        (short const   )6,      (short const   )6,      (short const   )6,      (short const   )13, 
        (short const   )12,      (short const   )14,      (short const   )15,      (short const   )12, 
        (short const   )16,      (short const   )12,      (short const   )17,      (short const   )18, 
        (short const   )19,      (short const   )20,      (short const   )12,      (short const   )21, 
        (short const   )22,      (short const   )12,      (short const   )12,      (short const   )12, 
        (short const   )23,      (short const   )25,      (short const   )32,      (short const   )26, 
        (short const   )25,      (short const   )44,      (short const   )26,      (short const   )29, 
        (short const   )29,      (short const   )29,      (short const   )27,      (short const   )28, 
        (short const   )45,      (short const   )27,      (short const   )28,      (short const   )29, 
        (short const   )29,      (short const   )29,      (short const   )34,      (short const   )35, 
        (short const   )41,      (short const   )29,      (short const   )29,      (short const   )29, 
        (short const   )42,      (short const   )50,      (short const   )70,      (short const   )51, 
        (short const   )70,      (short const   )52,      (short const   )104,      (short const   )70, 
        (short const   )53,      (short const   )70,      (short const   )103,      (short const   )102, 
        (short const   )101,      (short const   )100,      (short const   )54,      (short const   )99, 
        (short const   )98,      (short const   )97,      (short const   )55,      (short const   )96, 
        (short const   )95,      (short const   )94,      (short const   )56,      (short const   )93, 
        (short const   )57,      (short const   )92,      (short const   )58,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )30, 
        (short const   )91,      (short const   )30,      (short const   )30,      (short const   )47, 
        (short const   )90,      (short const   )89,      (short const   )47,      (short const   )49, 
        (short const   )49,      (short const   )49,      (short const   )49,      (short const   )88, 
        (short const   )87,      (short const   )86,      (short const   )85,      (short const   )40, 
        (short const   )84,      (short const   )83,      (short const   )82,      (short const   )81, 
        (short const   )80,      (short const   )42,      (short const   )79,      (short const   )78, 
        (short const   )77,      (short const   )76,      (short const   )75,      (short const   )74, 
        (short const   )73,      (short const   )72,      (short const   )71,      (short const   )69, 
        (short const   )42,      (short const   )68,      (short const   )67,      (short const   )66, 
        (short const   )40,      (short const   )65,      (short const   )64,      (short const   )63, 
        (short const   )62,      (short const   )61,      (short const   )60,      (short const   )59, 
        (short const   )31,      (short const   )48,      (short const   )46,      (short const   )43, 
        (short const   )40,      (short const   )39,      (short const   )38,      (short const   )37, 
        (short const   )36,      (short const   )33,      (short const   )31,      (short const   )105, 
        (short const   )5,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105};
#line 426 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static short const   yy_chk[177]  = 
#line 426
  {      (short const   )0,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )3,      (short const   )108,      (short const   )3, 
        (short const   )4,      (short const   )22,      (short const   )4,      (short const   )7, 
        (short const   )7,      (short const   )7,      (short const   )3,      (short const   )3, 
        (short const   )22,      (short const   )4,      (short const   )4,      (short const   )8, 
        (short const   )8,      (short const   )8,      (short const   )14,      (short const   )14, 
        (short const   )20,      (short const   )29,      (short const   )29,      (short const   )29, 
        (short const   )20,      (short const   )28,      (short const   )50,      (short const   )28, 
        (short const   )50,      (short const   )28,      (short const   )102,      (short const   )70, 
        (short const   )28,      (short const   )70,      (short const   )101,      (short const   )99, 
        (short const   )98,      (short const   )97,      (short const   )28,      (short const   )96, 
        (short const   )92,      (short const   )91,      (short const   )28,      (short const   )89, 
        (short const   )88,      (short const   )87,      (short const   )28,      (short const   )86, 
        (short const   )28,      (short const   )85,      (short const   )28,      (short const   )106, 
        (short const   )106,      (short const   )106,      (short const   )106,      (short const   )107, 
        (short const   )84,      (short const   )107,      (short const   )107,      (short const   )109, 
        (short const   )83,      (short const   )82,      (short const   )109,      (short const   )110, 
        (short const   )110,      (short const   )110,      (short const   )110,      (short const   )80, 
        (short const   )78,      (short const   )77,      (short const   )76,      (short const   )75, 
        (short const   )74,      (short const   )73,      (short const   )72,      (short const   )71, 
        (short const   )69,      (short const   )68,      (short const   )67,      (short const   )66, 
        (short const   )65,      (short const   )64,      (short const   )63,      (short const   )62, 
        (short const   )61,      (short const   )60,      (short const   )53,      (short const   )48, 
        (short const   )46,      (short const   )45,      (short const   )44,      (short const   )43, 
        (short const   )41,      (short const   )39,      (short const   )38,      (short const   )37, 
        (short const   )36,      (short const   )35,      (short const   )34,      (short const   )33, 
        (short const   )31,      (short const   )27,      (short const   )23,      (short const   )21, 
        (short const   )19,      (short const   )18,      (short const   )17,      (short const   )16, 
        (short const   )15,      (short const   )13,      (short const   )11,      (short const   )5, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105};
#line 449 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static yy_state_type yy_state_buf[16386]  ;
#line 449 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static yy_state_type *yy_state_ptr  ;
#line 450 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static char *yy_full_match  ;
#line 451 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/aux-item-def-scan.c"
static int yy_lp  ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 93 "aux-item-def-scan.l"
static String stringBuffer  =    {(String_size )0, (unsigned char *)((void *)0)};
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 708 "aux-item-def-scan.c"
int aid_lex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  yy_state_type *tmp ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp___0 ;
  int yyl ;
  char *s ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  String tmp___4 ;
  String tmp___5 ;
  String tmp___6 ;
  String tmp___7 ;
  String tmp___8 ;
  String tmp___9 ;
  String tmp___10 ;
  String tmp___11 ;
  String tmp___12 ;
  String tmp___13 ;
  String tmp___14 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___15 ;

  {
#line 719
  if (yy_init) {
#line 721
    yy_init = 0;
#line 727
    if (! yy_start) {
#line 728
      yy_start = 1;
    }
#line 730
    if (! yyin) {
#line 731
      yyin = stdin;
    }
#line 733
    if (! yyout) {
#line 734
      yyout = stdout;
    }
#line 736
    if (! yy_current_buffer) {
      {
#line 737
      yy_current_buffer = yy_create_buffer(yyin, 16384);
      }
    }
    {
#line 740
    yy_load_buffer_state();
    }
  }
  {
#line 743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 745
    yy_cp = yy_c_buf_p;
#line 748
    *yy_cp = yy_hold_char;
#line 753
    yy_bp = yy_cp;
#line 755
    yy_current_state = yy_start;
#line 756
    yy_state_ptr = yy_state_buf;
#line 757
    tmp = yy_state_ptr;
#line 757
    yy_state_ptr ++;
#line 757
    *tmp = yy_current_state;
    yy_match: 
    {
#line 759
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 761
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
      {
#line 762
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 762
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 762
          goto while_break___1;
        }
#line 764
        yy_current_state = (int )yy_def[yy_current_state];
#line 765
        if (yy_current_state >= 106) {
#line 766
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 768
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 769
      tmp___0 = yy_state_ptr;
#line 769
      yy_state_ptr ++;
#line 769
      *tmp___0 = yy_current_state;
#line 770
      yy_cp ++;
#line 759
      if (! ((int const   )yy_base[yy_current_state] != 144)) {
#line 759
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 775
    yy_state_ptr --;
#line 775
    yy_current_state = *yy_state_ptr;
#line 776
    yy_lp = (int )yy_accept[yy_current_state];
    {
#line 778
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 780
      if (yy_lp) {
#line 780
        if (yy_lp < (int )yy_accept[yy_current_state + 1]) {
#line 782
          yy_act = (int )yy_acclist[yy_lp];
#line 784
          yy_full_match = yy_cp;
#line 785
          goto while_break___2;
        }
      }
#line 788
      yy_cp --;
#line 789
      yy_state_ptr --;
#line 789
      yy_current_state = *yy_state_ptr;
#line 790
      yy_lp = (int )yy_accept[yy_current_state];
    }
    while_break___2: /* CIL Label */ ;
    }
#line 793
    yytext = yy_bp;
#line 793
    yyleng = (int )(yy_cp - yy_bp);
#line 793
    yy_hold_char = *yy_cp;
#line 793
    *yy_cp = (char )'\000';
#line 793
    yy_c_buf_p = yy_cp;
#line 795
    if (yy_act != 32) {
#line 798
      yyl = 0;
      {
#line 798
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 798
        if (! (yyl < yyleng)) {
#line 798
          goto while_break___3;
        }
#line 799
        if ((int )*(yytext + yyl) == 10) {
#line 800
          yylineno ++;
        }
#line 798
        yyl ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    do_action: 
    {
#line 808
    if (yy_act == 1) {
#line 808
      goto case_1;
    }
#line 113
    if (yy_act == 2) {
#line 113 "aux-item-def-scan.l"
      goto case_2;
    }
#line 118
    if (yy_act == 3) {
#line 118
      goto case_3;
    }
#line 122
    if (yy_act == 4) {
#line 122
      goto case_4;
    }
#line 126
    if (yy_act == 5) {
#line 126
      goto case_5;
    }
#line 130
    if (yy_act == 6) {
#line 130
      goto case_6;
    }
#line 134
    if (yy_act == 7) {
#line 134
      goto case_7;
    }
#line 138
    if (yy_act == 8) {
#line 138
      goto case_8;
    }
#line 142
    if (yy_act == 9) {
#line 142
      goto case_9;
    }
#line 146
    if (yy_act == 10) {
#line 146
      goto case_10;
    }
#line 151
    if (yy_act == 11) {
#line 151
      goto case_11;
    }
#line 154
    if (yy_act == 12) {
#line 154
      goto case_12;
    }
#line 155
    if (yy_act == 13) {
#line 155
      goto case_13;
    }
#line 164
    if (yy_act == 14) {
#line 164
      goto case_14;
    }
#line 170
    if (yy_act == 15) {
#line 170
      goto case_15;
    }
#line 178
    if (yy_act == 16) {
#line 178
      goto case_16;
    }
#line 179
    if (yy_act == 17) {
#line 179
      goto case_17;
    }
#line 185
    if (yy_act == 18) {
#line 185
      goto case_18;
    }
#line 200
    if (yy_act == 19) {
#line 200
      goto case_19;
    }
#line 201
    if (yy_act == 20) {
#line 201
      goto case_20;
    }
#line 202
    if (yy_act == 21) {
#line 202
      goto case_21;
    }
#line 203
    if (yy_act == 22) {
#line 203
      goto case_22;
    }
#line 204
    if (yy_act == 23) {
#line 204
      goto case_23;
    }
#line 205
    if (yy_act == 24) {
#line 205
      goto case_24;
    }
#line 206
    if (yy_act == 25) {
#line 206
      goto case_25;
    }
#line 207
    if (yy_act == 26) {
#line 207
      goto case_26;
    }
#line 208
    if (yy_act == 27) {
#line 208
      goto case_27;
    }
#line 209
    if (yy_act == 28) {
#line 209
      goto case_28;
    }
#line 210
    if (yy_act == 29) {
#line 210
      goto case_29;
    }
#line 216
    if (yy_act == 30) {
#line 216
      goto case_30;
    }
#line 218
    if (yy_act == 31) {
#line 218
      goto case_31;
    }
#line 1038
    if (yy_act == 34) {
#line 1038 "aux-item-def-scan.c"
      goto case_34;
    }
#line 1038
    if (yy_act == 33) {
#line 1038
      goto case_34;
    }
#line 1041
    if (yy_act == 32) {
#line 1041
      goto case_32;
    }
#line 1163
    goto switch_default;
    case_1: /* CIL Label */ 
#line 108 "aux-item-def-scan.l"
    aid_lval.num = 1UL;
#line 109
    aid_lloc.first_line = yylineno;
#line 110
    aux_item_def_error_line = yylineno;
#line 110
    return (258);
#line 112
    goto switch_break;
    case_2: /* CIL Label */ 
#line 113
    aid_lval.num = 0UL;
#line 114
    aid_lloc.first_line = yylineno;
#line 115
    aux_item_def_error_line = yylineno;
#line 115
    return (258);
#line 117
    goto switch_break;
    case_3: /* CIL Label */ 
#line 118
    aid_lloc.first_line = yylineno;
#line 119
    aux_item_def_error_line = yylineno;
#line 119
    return (261);
#line 121
    goto switch_break;
    case_4: /* CIL Label */ 
#line 122
    aid_lloc.first_line = yylineno;
#line 123
    aux_item_def_error_line = yylineno;
#line 123
    return (262);
#line 125
    goto switch_break;
    case_5: /* CIL Label */ 
#line 126
    aid_lloc.first_line = yylineno;
#line 127
    aux_item_def_error_line = yylineno;
#line 127
    return (263);
#line 129
    goto switch_break;
    case_6: /* CIL Label */ 
#line 130
    aid_lloc.first_line = yylineno;
#line 131
    aux_item_def_error_line = yylineno;
#line 131
    return (264);
#line 133
    goto switch_break;
    case_7: /* CIL Label */ 
#line 134
    aid_lloc.first_line = yylineno;
#line 135
    aux_item_def_error_line = yylineno;
#line 135
    return (265);
#line 137
    goto switch_break;
    case_8: /* CIL Label */ 
#line 138
    aid_lloc.first_line = yylineno;
#line 139
    aux_item_def_error_line = yylineno;
#line 139
    return (266);
#line 141
    goto switch_break;
    case_9: /* CIL Label */ 
#line 142
    aid_lloc.first_line = yylineno;
#line 143
    aux_item_def_error_line = yylineno;
#line 143
    return (268);
#line 145
    goto switch_break;
    case_10: /* CIL Label */ 
#line 147
    aid_lloc.first_line = yylineno;
#line 148
    aux_item_def_error_line = yylineno;
#line 148
    return (269);
#line 150
    goto switch_break;
    case_11: /* CIL Label */ 
#line 153
    goto switch_break;
    case_12: /* CIL Label */ 
#line 154
    goto switch_break;
    case_13: /* CIL Label */ 
#line 156
    s = yytext;
    {
#line 157
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 157
      tmp___1 = tolower((int )*s);
#line 157
      *s = (char )tmp___1;
#line 157
      s ++;
      }
#line 157
      if (! *s) {
#line 157
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 158
    aid_lval.str = (String )EMPTY_STRING;
#line 159
    s_crea_str(& aid_lval.str, (char const   *)yytext);
#line 160
    aid_lloc.first_line = yylineno;
#line 161
    aux_item_def_error_line = yylineno;
    }
#line 161
    return (259);
#line 163
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 165
    aid_lloc.first_line = yylineno;
#line 166
    tmp___2 = atoi((char const   *)yytext);
#line 166
    aid_lval.num = (unsigned long )tmp___2;
#line 167
    aux_item_def_error_line = yylineno;
    }
#line 167
    return (257);
#line 169
    goto switch_break;
    case_15: /* CIL Label */ 
#line 171
    yy_start = 3;
#line 172
    stringBuffer = (String )EMPTY_STRING;
#line 173
    aid_lloc.first_line = yylineno;
#line 175
    goto switch_break;
    case_16: /* CIL Label */ 
#line 178
    goto switch_break;
    case_17: /* CIL Label */ 
#line 179
    yy_start = 1;
#line 180
    aid_lval.str = stringBuffer;
#line 181
    stringBuffer = (String )EMPTY_STRING;
#line 182
    aux_item_def_error_line = yylineno;
#line 182
    return (260);
#line 184
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 186
    sscanf((char const   */* __restrict  */)(yytext + 1), (char const   */* __restrict  */)"%o",
           & tmp___3);
    }
#line 187
    if (tmp___3 > 255U) {
      {
#line 188
      tmp___4 = s_fcrea_str((char const   *)yytext);
#line 188
      s_strcat(& stringBuffer, (String const   )tmp___4);
      }
    } else {
      {
#line 192
      sprintf((char */* __restrict  */)yytext, (char const   */* __restrict  */)"%c",
              (int )((unsigned char )tmp___3));
#line 194
      *(yytext + 1) = (char )'\000';
#line 195
      tmp___5 = s_fcrea_str((char const   *)yytext);
#line 195
      s_strcat(& stringBuffer, (String const   )tmp___5);
      }
    }
#line 199
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 199
    tmp___6 = s_fcrea_str("\n");
#line 199
    s_strcat(& stringBuffer, (String const   )tmp___6);
    }
#line 200
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 200
    tmp___7 = s_fcrea_str("\t");
#line 200
    s_strcat(& stringBuffer, (String const   )tmp___7);
    }
#line 201
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 201
    tmp___8 = s_fcrea_str("\r");
#line 201
    s_strcat(& stringBuffer, (String const   )tmp___8);
    }
#line 202
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 202
    tmp___9 = s_fcrea_str("\b");
#line 202
    s_strcat(& stringBuffer, (String const   )tmp___9);
    }
#line 203
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 203
    tmp___10 = s_fcrea_str("\f");
#line 203
    s_strcat(& stringBuffer, (String const   )tmp___10);
    }
#line 204
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 204
    tmp___11 = s_fcrea_str("\'");
#line 204
    s_strcat(& stringBuffer, (String const   )tmp___11);
    }
#line 205
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 205
    tmp___12 = s_fcrea_str("\"");
#line 205
    s_strcat(& stringBuffer, (String const   )tmp___12);
    }
#line 206
    goto switch_break;
    case_26: /* CIL Label */ 
#line 207
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 207
    tmp___13 = s_fcrea_str((char const   *)(yytext + 1));
#line 207
    s_strcat(& stringBuffer, (String const   )tmp___13);
    }
#line 208
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 208
    tmp___14 = s_fcrea_str((char const   *)yytext);
#line 208
    s_strcat(& stringBuffer, (String const   )tmp___14);
    }
#line 209
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 210
    aid_error("unterminated string", aid_lloc.first_line);
#line 212
    aux_item_def_error_line = yylineno;
    }
#line 212
    return (267);
#line 214
    goto switch_break;
    case_30: /* CIL Label */ 
#line 216
    aux_item_def_error_line = yylineno;
#line 216
    return ((int )*(yytext + 0));
#line 217
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 218
    fwrite((void const   */* __restrict  */)yytext, (size_t )yyleng, (size_t )1, (FILE */* __restrict  */)yyout);
    }
#line 219
    goto switch_break;
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
#line 1039 "aux-item-def-scan.c"
    return (0);
    case_32: /* CIL Label */ 
#line 1044
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
#line 1047
    *yy_cp = yy_hold_char;
#line 1050
    if (yy_current_buffer->yy_buffer_status == 0) {
#line 1061
      yy_n_chars = yy_current_buffer->yy_n_chars;
#line 1062
      yy_current_buffer->yy_input_file = yyin;
#line 1063
      yy_current_buffer->yy_buffer_status = 1;
    }
#line 1073
    if ((unsigned long )yy_c_buf_p <= (unsigned long )(yy_current_buffer->yy_ch_buf + yy_n_chars)) {
      {
#line 1077
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1079
      yy_current_state = yy_get_previous_state();
#line 1090
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1092
      yy_bp = yytext + 0;
      }
#line 1094
      if (yy_next_state) {
#line 1097
        yy_c_buf_p ++;
#line 1097
        yy_cp = yy_c_buf_p;
#line 1098
        yy_current_state = yy_next_state;
#line 1099
        goto yy_match;
      } else {
#line 1104
        yy_cp = yy_c_buf_p;
#line 1105
        goto yy_find_action;
      }
    } else {
      {
#line 1109
      tmp___15 = yy_get_next_buffer();
      }
      {
#line 1111
      if (tmp___15 == 1) {
#line 1111
        goto case_1___0;
      }
#line 1140
      if (tmp___15 == 0) {
#line 1140
        goto case_0;
      }
#line 1150
      if (tmp___15 == 2) {
#line 1150
        goto case_2___0;
      }
#line 1109
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1113
      yy_did_buffer_switch_on_eof = 0;
#line 1126
      yy_c_buf_p = yytext + 0;
#line 1128
      yy_act = (32 + (yy_start - 1) / 2) + 1;
#line 1129
      goto do_action;
#line 1137
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 1141
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1144
      yy_current_state = yy_get_previous_state();
#line 1146
      yy_cp = yy_c_buf_p;
#line 1147
      yy_bp = yytext + 0;
      }
#line 1148
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1151
      yy_c_buf_p = yy_current_buffer->yy_ch_buf + yy_n_chars;
#line 1154
      yy_current_state = yy_get_previous_state();
#line 1156
      yy_cp = yy_c_buf_p;
#line 1157
      yy_bp = yytext + 0;
      }
#line 1158
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1160
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1164
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1179 "aux-item-def-scan.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  int c ;
  int n ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 1181
  dest = yy_current_buffer->yy_ch_buf;
#line 1182
  source = yytext;
#line 1186
  if ((unsigned long )yy_c_buf_p > (unsigned long )(yy_current_buffer->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1187
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1190
  if (yy_current_buffer->yy_fill_buffer == 0) {
#line 1192
    if (yy_c_buf_p - yytext == 1L) {
#line 1197
      return (1);
    } else {
#line 1205
      return (2);
    }
  }
#line 1212
  number_to_move = (int )(yy_c_buf_p - yytext) - 1;
#line 1214
  i = 0;
  {
#line 1214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1214
    if (! (i < number_to_move)) {
#line 1214
      goto while_break;
    }
#line 1215
    tmp = dest;
#line 1215
    dest ++;
#line 1215
    tmp___0 = source;
#line 1215
    source ++;
#line 1215
    *tmp = *tmp___0;
#line 1214
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1217
  if (yy_current_buffer->yy_buffer_status == 2) {
#line 1221
    yy_n_chars = 0;
#line 1221
    yy_current_buffer->yy_n_chars = yy_n_chars;
  } else {
#line 1225
    num_to_read = (int )((yy_current_buffer->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1228
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1228
      if (! (num_to_read <= 0)) {
#line 1228
        goto while_break___0;
      }
      {
#line 1231
      yy_fatal_error("input buffer overflow, can\'t enlarge buffer because scanner uses REJECT");
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1270
    if (num_to_read > 8192) {
#line 1271
      num_to_read = 8192;
    }
#line 1274
    if (yy_current_buffer->yy_is_interactive) {
#line 1274
      c = '*';
#line 1274
      n = 0;
      {
#line 1274
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1274
        if (n < num_to_read) {
          {
#line 1274
          c = _IO_getc(yyin);
          }
#line 1274
          if (c != -1) {
#line 1274
            if (! (c != 10)) {
#line 1274
              goto while_break___1;
            }
          } else {
#line 1274
            goto while_break___1;
          }
        } else {
#line 1274
          goto while_break___1;
        }
#line 1274
        *((yy_current_buffer->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1274
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1274
      if (c == 10) {
#line 1274
        tmp___1 = n;
#line 1274
        n ++;
#line 1274
        *((yy_current_buffer->yy_ch_buf + number_to_move) + tmp___1) = (char )c;
      }
#line 1274
      if (c == -1) {
        {
#line 1274
        tmp___2 = ferror(yyin);
        }
#line 1274
        if (tmp___2) {
          {
#line 1274
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1274
      yy_n_chars = n;
    } else {
      {
#line 1274
      tmp___3 = fread((void */* __restrict  */)(yy_current_buffer->yy_ch_buf + number_to_move),
                      (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyin);
#line 1274
      yy_n_chars = (int )tmp___3;
      }
#line 1274
      if (yy_n_chars == 0) {
        {
#line 1274
        tmp___4 = ferror(yyin);
        }
#line 1274
        if (tmp___4) {
          {
#line 1274
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
    }
#line 1277
    yy_current_buffer->yy_n_chars = yy_n_chars;
  }
#line 1280
  if (yy_n_chars == 0) {
#line 1282
    if (number_to_move == 0) {
      {
#line 1284
      ret_val = 1;
#line 1285
      yyrestart(yyin);
      }
    } else {
#line 1290
      ret_val = 2;
#line 1291
      yy_current_buffer->yy_buffer_status = 2;
    }
  } else {
#line 1297
    ret_val = 0;
  }
#line 1299
  yy_n_chars += number_to_move;
#line 1300
  *(yy_current_buffer->yy_ch_buf + yy_n_chars) = (char)0;
#line 1301
  *(yy_current_buffer->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1303
  yytext = yy_current_buffer->yy_ch_buf + 0;
#line 1305
  return (ret_val);
}
}
#line 1311 "aux-item-def-scan.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  yy_state_type *tmp ;
  register YY_CHAR yy_c ;
  int tmp___0 ;
  yy_state_type *tmp___1 ;

  {
#line 1316
  yy_current_state = yy_start;
#line 1317
  yy_state_ptr = yy_state_buf;
#line 1318
  tmp = yy_state_ptr;
#line 1318
  yy_state_ptr ++;
#line 1318
  *tmp = yy_current_state;
#line 1320
  yy_cp = yytext + 0;
  {
#line 1320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1320
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1320
      goto while_break;
    }
#line 1322
    if (*yy_cp) {
#line 1322
      tmp___0 = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1322
      tmp___0 = (int const   )1;
    }
#line 1322
    yy_c = (YY_CHAR )tmp___0;
    {
#line 1323
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1323
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1323
        goto while_break___0;
      }
#line 1325
      yy_current_state = (int )yy_def[yy_current_state];
#line 1326
      if (yy_current_state >= 106) {
#line 1327
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1329
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1330
    tmp___1 = yy_state_ptr;
#line 1330
    yy_state_ptr ++;
#line 1330
    *tmp___1 = yy_current_state;
#line 1320
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1333
  return (yy_current_state);
}
}
#line 1344 "aux-item-def-scan.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp ;
  int tmp___0 ;

  {
#line 1352
  yy_c = (YY_CHAR )1;
  {
#line 1353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1353
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1353
      goto while_break;
    }
#line 1355
    yy_current_state = (int )yy_def[yy_current_state];
#line 1356
    if (yy_current_state >= 106) {
#line 1357
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1359
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1360
  yy_is_jam = yy_current_state == 105;
#line 1361
  if (! yy_is_jam) {
#line 1362
    tmp = yy_state_ptr;
#line 1362
    yy_state_ptr ++;
#line 1362
    *tmp = yy_current_state;
  }
#line 1364
  if (yy_is_jam) {
#line 1364
    tmp___0 = 0;
  } else {
#line 1364
    tmp___0 = yy_current_state;
  }
#line 1364
  return (tmp___0);
}
}
#line 1491 "aux-item-def-scan.c"
void yyrestart(FILE *input_file ) 
{ 


  {
#line 1497
  if (! yy_current_buffer) {
    {
#line 1498
    yy_current_buffer = yy_create_buffer(yyin, 16384);
    }
  }
  {
#line 1500
  yy_init_buffer(yy_current_buffer, input_file);
#line 1501
  yy_load_buffer_state();
  }
#line 1502
  return;
}
}
#line 1506 "aux-item-def-scan.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 


  {
#line 1512
  if ((unsigned long )yy_current_buffer == (unsigned long )new_buffer) {
#line 1513
    return;
  }
#line 1515
  if (yy_current_buffer) {
#line 1518
    *yy_c_buf_p = yy_hold_char;
#line 1519
    yy_current_buffer->yy_buf_pos = yy_c_buf_p;
#line 1520
    yy_current_buffer->yy_n_chars = yy_n_chars;
  }
  {
#line 1523
  yy_current_buffer = new_buffer;
#line 1524
  yy_load_buffer_state();
#line 1531
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1532
  return;
}
}
#line 1536 "aux-item-def-scan.c"
void yy_load_buffer_state(void) 
{ 


  {
#line 1541
  yy_n_chars = yy_current_buffer->yy_n_chars;
#line 1542
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
#line 1542
  yytext = yy_c_buf_p;
#line 1543
  yyin = yy_current_buffer->yy_input_file;
#line 1544
  yy_hold_char = *yy_c_buf_p;
#line 1545
  return;
}
}
#line 1549 "aux-item-def-scan.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1558
  tmp = yy_flex_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1558
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1559
  if (! b) {
    {
#line 1560
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1562
  b->yy_buf_size = (yy_size_t )size;
#line 1567
  tmp___0 = yy_flex_alloc(b->yy_buf_size + 2U);
#line 1567
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1568
  if (! b->yy_ch_buf) {
    {
#line 1569
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1571
  b->yy_is_our_buffer = 1;
#line 1573
  yy_init_buffer(b, file);
  }
#line 1575
  return (b);
}
}
#line 1580 "aux-item-def-scan.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 


  {
#line 1586
  if (! b) {
#line 1587
    return;
  }
#line 1589
  if ((unsigned long )b == (unsigned long )yy_current_buffer) {
#line 1590
    yy_current_buffer = (YY_BUFFER_STATE )0;
  }
#line 1592
  if (b->yy_is_our_buffer) {
    {
#line 1593
    yy_flex_free((void *)b->yy_ch_buf);
    }
  }
  {
#line 1595
  yy_flex_free((void *)b);
  }
#line 1596
  return;
}
}
#line 1601
extern int isatty(int  ) ;
#line 1606 "aux-item-def-scan.c"
void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1615
  yy_flush_buffer(b);
#line 1617
  b->yy_input_file = file;
#line 1618
  b->yy_fill_buffer = 1;
  }
#line 1626
  if (file) {
    {
#line 1626
    tmp = fileno(file);
#line 1626
    tmp___0 = isatty(tmp);
#line 1626
    b->yy_is_interactive = tmp___0 > 0;
    }
  } else {
#line 1626
    b->yy_is_interactive = 0;
  }
#line 1629
  return;
}
}
#line 1633 "aux-item-def-scan.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 


  {
#line 1640
  if (! b) {
#line 1641
    return;
  }
#line 1643
  b->yy_n_chars = 0;
#line 1649
  *(b->yy_ch_buf + 0) = (char)0;
#line 1650
  *(b->yy_ch_buf + 1) = (char)0;
#line 1652
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1654
  b->yy_at_bol = 1;
#line 1655
  b->yy_buffer_status = 0;
#line 1657
  if ((unsigned long )b == (unsigned long )yy_current_buffer) {
    {
#line 1658
    yy_load_buffer_state();
    }
  }
#line 1659
  return;
}
}
#line 1664 "aux-item-def-scan.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1673
  if (size < 2U) {
#line 1677
    return ((YY_BUFFER_STATE )0);
  } else
#line 1673
  if ((int )*(base + (size - 2U)) != 0) {
#line 1677
    return ((YY_BUFFER_STATE )0);
  } else
#line 1673
  if ((int )*(base + (size - 1U)) != 0) {
#line 1677
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1679
  tmp = yy_flex_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1679
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1680
  if (! b) {
    {
#line 1681
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
  }
  {
#line 1683
  b->yy_buf_size = size - 2U;
#line 1684
  tmp___0 = base;
#line 1684
  b->yy_ch_buf = tmp___0;
#line 1684
  b->yy_buf_pos = tmp___0;
#line 1685
  b->yy_is_our_buffer = 0;
#line 1686
  b->yy_input_file = (FILE *)0;
#line 1687
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1688
  b->yy_is_interactive = 0;
#line 1689
  b->yy_at_bol = 1;
#line 1690
  b->yy_fill_buffer = 0;
#line 1691
  b->yy_buffer_status = 0;
#line 1693
  yy_switch_to_buffer(b);
  }
#line 1695
  return (b);
}
}
#line 1702 "aux-item-def-scan.c"
YY_BUFFER_STATE yy_scan_string(char const   *yy_str ) 
{ 
  int len ;
  YY_BUFFER_STATE tmp ;

  {
#line 1709
  len = 0;
  {
#line 1709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1709
    if (! *(yy_str + len)) {
#line 1709
      goto while_break;
    }
#line 1709
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1712
  tmp = yy_scan_bytes(yy_str, len);
  }
#line 1712
  return (tmp);
}
}
#line 1719 "aux-item-def-scan.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *bytes , int len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___4 ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 1732
  n = (yy_size_t )(len + 2);
#line 1733
  tmp = yy_flex_alloc(n);
#line 1733
  buf___4 = (char *)tmp;
  }
#line 1734
  if (! buf___4) {
    {
#line 1735
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
    }
  }
#line 1737
  i = 0;
  {
#line 1737
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1737
    if (! (i < len)) {
#line 1737
      goto while_break;
    }
#line 1738
    *(buf___4 + i) = (char )*(bytes + i);
#line 1737
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1740
  tmp___0 = (char)0;
#line 1740
  *(buf___4 + (len + 1)) = tmp___0;
#line 1740
  *(buf___4 + len) = tmp___0;
#line 1742
  b = yy_scan_buffer(buf___4, n);
  }
#line 1743
  if (! b) {
    {
#line 1744
    yy_fatal_error("bad buffer in yy_scan_bytes()");
    }
  }
#line 1749
  b->yy_is_our_buffer = 1;
#line 1751
  return (b);
}
}
#line 1813 "aux-item-def-scan.c"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 1819
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1820
  exit(2);
  }
}
}
#line 1877 "aux-item-def-scan.c"
static void *yy_flex_alloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1883
  tmp = malloc((size_t )size);
  }
#line 1883
  return (tmp);
}
}
#line 1905 "aux-item-def-scan.c"
static void yy_flex_free(void *ptr ) 
{ 


  {
  {
#line 1911
  free(ptr);
  }
#line 1912
  return;
}
}
#line 14 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.h"
void l2g_set_block_size(int sz ) ;
#line 42
void l2g_expensive_set(Local_to_global *l2g , Local_text_no lno , Text_no tno ) ;
#line 66
void l2g_set_first_appendable_key(Local_to_global *l2g , Local_text_no key ) ;
#line 77
void l2g_dump(FILE *file , Local_to_global const   *l2g ) ;
#line 84
Success l2g_read(FILE *fp , Local_to_global *l2g ) ;
#line 117
void l2gi_searchall(L2g_iterator *l2gi , Local_to_global const   *l2g ) ;
#line 38 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static int L2G_BLOCKSIZE  =    -1;
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_constructs  =    0L;
#line 67 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_l2gs  =    0L;
#line 68 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_l2gs_peak  =    0L;
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_destructs  =    0L;
#line 70 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_clears  =    0L;
#line 71 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_copies  =    0L;
#line 72 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_joins  =    0L;
#line 73 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_joined_blocks  =    0L;
#line 74 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_blocks  =    0L;
#line 75 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_blocks_peak  =    0L;
#line 76 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_blocks_sparse  =    0L;
#line 77 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_blocks_sparse_peak  =    0L;
#line 78 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long sparse_skip_cost  =    0L;
#line 79 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_sparse_compactions  =    0L;
#line 80 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_sparsifications  =    0L;
#line 89 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
__inline static int is_dense(struct l2g_block_info  const  *binfo ) 
{ 


  {
#line 92
  return ((unsigned long )binfo->key_block == (unsigned long )((void *)0));
}
}
#line 95 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
__inline static int is_empty(struct l2g_block_info  const  *binfo ) 
{ 


  {
#line 98
  return (binfo->zeroes == (int const   )L2G_BLOCKSIZE);
}
}
#line 101 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
__inline static Local_text_no key_value(struct l2g_block_info  const  *binfo , int index ) 
{ 
  int tmp ;

  {
  {
#line 105
  tmp = is_dense(binfo);
  }
#line 105
  if (tmp) {
#line 106
    return ((Local_text_no )(binfo->start + (Local_text_no const   )index));
  } else {
#line 108
    return (*(binfo->key_block + index));
  }
}
}
#line 112 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
__inline static int sparse_skip_deleted(struct l2g_block_info  const  *binfo , int i ) 
{ 


  {
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (i < (int )binfo->first_free) {
#line 116
      if (! (*(binfo->value_block + i) == 0UL)) {
#line 116
        goto while_break;
      }
    } else {
#line 116
      goto while_break;
    }
#line 118
    sparse_skip_cost ++;
#line 119
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (i);
}
}
#line 131 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
__inline static int sparse_locate_value(struct l2g_block_info  const  *binfo , Local_text_no lno ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 137
  tmp = is_empty(binfo);
  }
#line 137
  if (tmp) {
    {
#line 137
    __assert_fail("!is_empty(binfo)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  137U, "sparse_locate_value");
    }
  }
  {
#line 138
  tmp___0 = is_dense(binfo);
  }
#line 138
  if (tmp___0) {
    {
#line 138
    __assert_fail("!is_dense(binfo)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  138U, "sparse_locate_value");
    }
  }
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (i < (int )binfo->first_free) {
#line 144
      if (! (*(binfo->key_block + i) < lno)) {
#line 144
        goto while_break;
      }
    } else {
#line 144
      goto while_break;
    }
#line 145
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  i = sparse_skip_deleted(binfo, i);
  }
#line 150
  if (! (i == (int )binfo->first_free)) {
#line 150
    if (! (*(binfo->key_block + i) >= lno)) {
      {
#line 150
      __assert_fail("i == binfo->first_free || binfo->key_block[i] >= lno", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    150U, "sparse_locate_value");
      }
    }
  }
#line 151
  if (! (i == (int )binfo->first_free)) {
#line 151
    if (! (*(binfo->value_block + i) != 0UL)) {
      {
#line 151
      __assert_fail("i == binfo->first_free || binfo->value_block[i] != 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    151U, "sparse_locate_value");
      }
    }
  }
#line 153
  return (i);
}
}
#line 156 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static void sparse_compact(struct l2g_block_info *binfo ) 
{ 
  int from ;
  int to ;

  {
#line 161
  if (binfo->first_free + binfo->zeroes == L2G_BLOCKSIZE) {
#line 162
    return;
  }
#line 164
  if (! (binfo->first_free + binfo->zeroes > L2G_BLOCKSIZE)) {
    {
#line 164
    __assert_fail("binfo->first_free + binfo->zeroes > L2G_BLOCKSIZE", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  164U, "sparse_compact");
    }
  }
#line 166
  to = 0;
#line 166
  from = to;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (from < binfo->first_free)) {
#line 166
      goto while_break;
    }
#line 167
    if (*(binfo->value_block + from) != 0UL) {
#line 169
      if (from != to) {
#line 171
        *(binfo->value_block + to) = *(binfo->value_block + from);
#line 172
        *(binfo->key_block + to) = *(binfo->key_block + from);
      }
#line 174
      to ++;
    }
#line 166
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  binfo->first_free = to;
#line 178
  if (! (binfo->first_free + binfo->zeroes == L2G_BLOCKSIZE)) {
    {
#line 178
    __assert_fail("binfo->first_free + binfo->zeroes == L2G_BLOCKSIZE", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  178U, "sparse_compact");
    }
  }
#line 179
  nr_sparse_compactions ++;
#line 180
  return;
}
}
#line 191 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static struct l2g_block_info *add_block(Local_to_global *l2g ) 
{ 
  struct l2g_block_info *binfo ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 200
  (l2g->num_blocks) ++;
#line 201
  tmp = srealloc((void *)l2g->blocks, (unsigned long )l2g->num_blocks * sizeof(struct l2g_block_info ));
#line 201
  l2g->blocks = (struct l2g_block_info *)tmp;
#line 205
  binfo = l2g->blocks + (l2g->num_blocks - 1);
#line 206
  binfo->first_free = 0;
#line 207
  binfo->zeroes = L2G_BLOCKSIZE;
#line 209
  binfo->start = (Local_text_no )3735928559U;
#line 211
  binfo->key_block = (Local_text_no *)((void *)0);
#line 212
  tmp___0 = smalloc((unsigned long )L2G_BLOCKSIZE * sizeof(Text_no ));
#line 212
  binfo->value_block = (Text_no *)tmp___0;
#line 215
  i = 0;
  }
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < L2G_BLOCKSIZE)) {
#line 215
      goto while_break;
    }
#line 216
    *(binfo->value_block + i) = (Text_no )3735928559U;
#line 215
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  nr_blocks ++;
#line 218
  if (nr_blocks > nr_blocks_peak) {
#line 219
    nr_blocks_peak = nr_blocks;
  }
#line 221
  return (binfo);
}
}
#line 227 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static void add_block_before(Local_to_global *l2g , int position ) 
{ 
  struct l2g_block_info *binfo ;
  struct l2g_block_info *new_blocks ;
  int ix ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 236
  tmp = smalloc((unsigned long )(l2g->num_blocks + 1) * sizeof(struct l2g_block_info ));
#line 236
  new_blocks = (struct l2g_block_info *)tmp;
#line 239
  ix = 0;
  }
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! (ix < position)) {
#line 239
      goto while_break;
    }
#line 240
    *(new_blocks + ix) = *(l2g->blocks + ix);
#line 239
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  ix = position;
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 241
    if (! (ix < l2g->num_blocks)) {
#line 241
      goto while_break___0;
    }
#line 242
    *(new_blocks + (ix + 1)) = *(l2g->blocks + ix);
#line 241
    ix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 245
  sfree((void *)l2g->blocks);
#line 246
  l2g->blocks = new_blocks;
#line 247
  (l2g->num_blocks) ++;
#line 250
  binfo = new_blocks + position;
#line 251
  binfo->first_free = 0;
#line 252
  binfo->zeroes = L2G_BLOCKSIZE;
#line 254
  binfo->start = (Local_text_no )3735928559U;
#line 256
  binfo->key_block = (Local_text_no *)((void *)0);
#line 257
  tmp___0 = smalloc((unsigned long )L2G_BLOCKSIZE * sizeof(Text_no ));
#line 257
  binfo->value_block = (Text_no *)tmp___0;
#line 260
  ix = 0;
  }
  {
#line 260
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 260
    if (! (ix < L2G_BLOCKSIZE)) {
#line 260
      goto while_break___1;
    }
#line 261
    *(binfo->value_block + ix) = (Text_no )3735928559U;
#line 260
    ix ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 263
  nr_blocks ++;
#line 263
  if (nr_blocks > nr_blocks_peak) {
#line 264
    nr_blocks_peak = nr_blocks;
  }
#line 265
  return;
}
}
#line 273 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static void delete_block(Local_to_global *l2g , struct l2g_block_info *binfo ) 
{ 
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 277
  tmp = is_empty((struct l2g_block_info  const  *)binfo);
  }
#line 277
  if (! tmp) {
    {
#line 277
    __assert_fail("is_empty(binfo)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  277U, "delete_block");
    }
  }
  {
#line 279
  tmp___0 = is_dense((struct l2g_block_info  const  *)binfo);
  }
#line 279
  if (! tmp___0) {
#line 280
    nr_blocks_sparse --;
  }
#line 281
  nr_blocks --;
#line 284
  if ((unsigned long )binfo->key_block != (unsigned long )((void *)0)) {
    {
#line 285
    sfree((void *)binfo->key_block);
    }
  }
  {
#line 286
  sfree((void *)binfo->value_block);
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    binfo ++;
#line 289
    if (! ((unsigned long )binfo < (unsigned long )(l2g->blocks + l2g->num_blocks))) {
#line 289
      goto while_break;
    }
#line 290
    *(binfo - 1) = *binfo;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 291
  (l2g->num_blocks) --;
#line 292
  tmp___1 = srealloc((void *)l2g->blocks, (unsigned long )l2g->num_blocks * sizeof(struct l2g_block_info ));
#line 292
  l2g->blocks = (struct l2g_block_info *)tmp___1;
  }
#line 294
  return;
}
}
#line 300 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static void make_sparse(struct l2g_block_info *binfo ) 
{ 
  int next ;
  int i ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 306
  tmp = is_dense((struct l2g_block_info  const  *)binfo);
  }
#line 306
  if (! tmp) {
    {
#line 306
    __assert_fail("is_dense(binfo)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  306U, "make_sparse");
    }
  }
#line 307
  nr_blocks_sparse ++;
#line 307
  if (nr_blocks_sparse > nr_blocks_sparse_peak) {
#line 308
    nr_blocks_sparse_peak = nr_blocks_sparse;
  }
  {
#line 309
  nr_sparsifications ++;
#line 312
  tmp___0 = smalloc((unsigned long )L2G_BLOCKSIZE * sizeof(Local_text_no ));
#line 312
  binfo->key_block = (Local_text_no *)tmp___0;
#line 314
  i = 0;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (i < L2G_BLOCKSIZE)) {
#line 314
      goto while_break;
    }
#line 315
    *(binfo->key_block + i) = 3735928559UL;
#line 314
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  next = 0;
#line 320
  i = 0;
  {
#line 320
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 320
    if (! (i < binfo->first_free)) {
#line 320
      goto while_break___0;
    }
#line 321
    if (*(binfo->value_block + i) != 0UL) {
#line 323
      *(binfo->key_block + next) = binfo->start + (Local_text_no )i;
#line 324
      *(binfo->value_block + next) = *(binfo->value_block + i);
#line 325
      next ++;
    }
#line 320
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 329
  binfo->first_free = next;
#line 330
  binfo->zeroes = L2G_BLOCKSIZE - next;
#line 331
  return;
}
}
#line 346 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static struct l2g_block_info *find_block(Local_to_global const   *l2g , Local_text_no lno ) 
{ 
  struct l2g_block_info *binfo ;

  {
#line 352
  if (l2g->num_blocks == 0) {
#line 353
    return ((struct l2g_block_info *)((void *)0));
  }
#line 356
  binfo = l2g->blocks + (l2g->num_blocks - 1);
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! ((unsigned long )binfo > (unsigned long )l2g->blocks)) {
#line 360
      goto while_break;
    }
#line 362
    if (lno >= binfo->start) {
#line 363
      return (binfo);
    }
#line 364
    binfo --;
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  return (binfo);
}
}
#line 378 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static Local_text_no find_block_index_key(Local_to_global const   *l2g , Local_text_no lno ,
                                          struct l2g_block_info  const  **binfo_out ,
                                          int *index_out ) 
{ 
  struct l2g_block_info  const  *binfo ;
  int i ;
  struct l2g_block_info *tmp ;
  int tmp___0 ;
  Local_text_no tmp___1 ;

  {
  {
#line 387
  tmp = find_block(l2g, lno);
#line 387
  binfo = (struct l2g_block_info  const  *)tmp;
  }
#line 388
  if ((unsigned long )binfo == (unsigned long )((void *)0)) {
#line 389
    return ((Local_text_no )0);
  }
#line 394
  if (lno >= (Local_text_no )binfo->start) {
    {
#line 398
    tmp___0 = is_dense(binfo);
    }
#line 398
    if (tmp___0) {
#line 400
      i = (int )((lno - (Local_text_no )binfo->start) + 1UL);
      {
#line 400
      while (1) {
        while_continue: /* CIL Label */ ;
#line 400
        if (! (i < (int )binfo->first_free)) {
#line 400
          goto while_break;
        }
#line 401
        if (*(binfo->value_block + i) != 0UL) {
#line 403
          *binfo_out = binfo;
#line 404
          *index_out = i;
#line 406
          return ((Local_text_no )(binfo->start + (Local_text_no const   )i));
        }
#line 400
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 411
      i = sparse_locate_value(binfo, lno);
      }
#line 412
      if (i < (int )binfo->first_free) {
#line 412
        if (*(binfo->key_block + i) == lno) {
#line 413
          i ++;
        }
      }
      {
#line 414
      i = sparse_skip_deleted(binfo, i);
      }
#line 415
      if (i < (int )binfo->first_free) {
#line 417
        *binfo_out = binfo;
#line 418
        *index_out = i;
#line 420
        return (*(binfo->key_block + i));
      }
    }
#line 427
    binfo ++;
  }
#line 434
  if ((unsigned long )binfo >= (unsigned long )(l2g->blocks + l2g->num_blocks)) {
#line 435
    return ((Local_text_no )0);
  }
#line 437
  i = 0;
  {
#line 437
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 437
    if (! (i < (int )binfo->first_free)) {
#line 437
      goto while_break___0;
    }
#line 438
    if (*(binfo->value_block + i) != 0UL) {
      {
#line 440
      *binfo_out = binfo;
#line 441
      *index_out = i;
#line 442
      tmp___1 = key_value(binfo, i);
      }
#line 442
      return (tmp___1);
    }
#line 437
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 445
  restart_kom("find_block_index_key found nothing\n");
  }
}
}
#line 455 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static Local_text_no find_block_index_key_reverse(Local_to_global const   *l2g , Local_text_no lno ,
                                                  struct l2g_block_info  const  **binfo_out ,
                                                  int *index_out ) 
{ 
  struct l2g_block_info  const  *binfo ;
  int i ;
  struct l2g_block_info *tmp ;
  int tmp___0 ;
  Local_text_no tmp___1 ;

  {
#line 465
  if (lno > 0UL) {
#line 466
    lno --;
  }
  {
#line 469
  tmp = find_block(l2g, lno);
#line 469
  binfo = (struct l2g_block_info  const  *)tmp;
  }
#line 470
  if ((unsigned long )binfo == (unsigned long )((void *)0)) {
#line 471
    return ((Local_text_no )0);
  }
#line 474
  if (lno < (Local_text_no )binfo->start) {
#line 475
    return ((Local_text_no )0);
  }
  {
#line 478
  tmp___0 = is_dense(binfo);
  }
#line 478
  if (tmp___0) {
#line 480
    i = (int )(lno - (Local_text_no )binfo->start);
#line 481
    if (i >= (int )binfo->first_free) {
#line 482
      i = (int )(binfo->first_free - 1);
    }
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
#line 483
      if (! (i >= 0)) {
#line 483
        goto while_break;
      }
#line 484
      if (*(binfo->value_block + i) != 0UL) {
#line 486
        *binfo_out = binfo;
#line 487
        *index_out = i;
#line 489
        return ((Local_text_no )(binfo->start + (Local_text_no const   )i));
      }
#line 483
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 494
    i = sparse_locate_value(binfo, lno);
    }
#line 495
    if (i >= (int )binfo->first_free) {
#line 496
      i = (int )(binfo->first_free - 1);
    }
    {
#line 497
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 497
      if (i > 0) {
#line 497
        if (! (*(binfo->value_block + i) == 0UL)) {
#line 497
          if (! (*(binfo->key_block + i) > lno)) {
#line 497
            goto while_break___0;
          }
        }
      } else {
#line 497
        goto while_break___0;
      }
#line 500
      sparse_skip_cost ++;
#line 501
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 503
    if (*(binfo->value_block + i) != 0UL) {
#line 503
      if (*(binfo->key_block + i) <= lno) {
#line 505
        *binfo_out = binfo;
#line 506
        *index_out = i;
#line 508
        return (*(binfo->key_block + i));
      }
    }
  }
#line 515
  if ((unsigned long )binfo == (unsigned long )l2g->blocks) {
#line 516
    return ((Local_text_no )0);
  }
#line 518
  binfo --;
#line 524
  i = (int )(binfo->first_free - 1);
  {
#line 524
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 524
    if (! (i >= 0)) {
#line 524
      goto while_break___1;
    }
#line 525
    if (*(binfo->value_block + i) != 0UL) {
      {
#line 527
      *binfo_out = binfo;
#line 528
      *index_out = i;
#line 529
      tmp___1 = key_value(binfo, i);
      }
#line 529
      return (tmp___1);
    }
#line 524
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 532
  restart_kom("find_block_index_key_reverse found nothing\n");
  }
}
}
#line 535 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static void join_range(Local_to_global *l2g , struct l2g_block_info *first , struct l2g_block_info *last___0 ) 
{ 
  int next ;
  int i ;
  struct l2g_block_info *binfo ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 544
  if (! ((unsigned long )first < (unsigned long )last___0)) {
    {
#line 544
    __assert_fail("first < last", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  544U, "join_range");
    }
  }
#line 545
  if ((unsigned long )l2g->blocks <= (unsigned long )first) {
#line 545
    if (! ((unsigned long )first < (unsigned long )(l2g->blocks + l2g->num_blocks))) {
      {
#line 545
      __assert_fail("l2g->blocks <= first && first < l2g->blocks + l2g->num_blocks",
                    "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    545U, "join_range");
      }
    }
  } else {
    {
#line 545
    __assert_fail("l2g->blocks <= first && first < l2g->blocks + l2g->num_blocks",
                  "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  545U, "join_range");
    }
  }
#line 546
  if ((unsigned long )l2g->blocks <= (unsigned long )last___0) {
#line 546
    if (! ((unsigned long )last___0 < (unsigned long )(l2g->blocks + l2g->num_blocks))) {
      {
#line 546
      __assert_fail("l2g->blocks <= last && last < l2g->blocks + l2g->num_blocks",
                    "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    546U, "join_range");
      }
    }
  } else {
    {
#line 546
    __assert_fail("l2g->blocks <= last && last < l2g->blocks + l2g->num_blocks", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  546U, "join_range");
    }
  }
  {
#line 548
  tmp = is_dense((struct l2g_block_info  const  *)first);
  }
#line 548
  if (tmp) {
    {
#line 549
    make_sparse(first);
    }
  } else {
    {
#line 551
    sparse_compact(first);
    }
  }
#line 553
  nr_joins ++;
#line 554
  next = first->first_free;
#line 555
  binfo = first + 1;
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! ((unsigned long )binfo <= (unsigned long )last___0)) {
#line 555
      goto while_break;
    }
#line 557
    nr_joined_blocks ++;
#line 558
    i = 0;
    {
#line 558
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 558
      if (! (i < binfo->first_free)) {
#line 558
        goto while_break___0;
      }
#line 559
      if (*(binfo->value_block + i) != 0UL) {
        {
#line 561
        *(first->value_block + next) = *(binfo->value_block + i);
#line 562
        *(first->key_block + next) = key_value((struct l2g_block_info  const  *)binfo,
                                               i);
#line 563
        next ++;
        }
      }
#line 558
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 565
    tmp___0 = is_dense((struct l2g_block_info  const  *)binfo);
    }
#line 565
    if (! tmp___0) {
      {
#line 567
      nr_blocks_sparse --;
#line 568
      sfree((void *)binfo->key_block);
      }
    }
    {
#line 570
    sfree((void *)binfo->value_block);
#line 555
    binfo ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 573
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 573
    if (! ((unsigned long )binfo < (unsigned long )(l2g->blocks + l2g->num_blocks))) {
#line 573
      goto while_break___1;
    }
#line 575
    if (! ((unsigned long )(binfo - (last___0 - first)) > (unsigned long )first)) {
      {
#line 575
      __assert_fail("binfo - (last - first) > first", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    575U, "join_range");
      }
    }
#line 576
    *(binfo - (last___0 - first)) = *binfo;
#line 577
    binfo ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 580
  if (! (next <= L2G_BLOCKSIZE)) {
    {
#line 580
    __assert_fail("next <= L2G_BLOCKSIZE", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  580U, "join_range");
    }
  }
  {
#line 581
  first->first_free = next;
#line 582
  first->zeroes = L2G_BLOCKSIZE - next;
#line 584
  nr_blocks -= last___0 - first;
#line 585
  l2g->num_blocks = (int )((long )l2g->num_blocks - (last___0 - first));
#line 586
  tmp___1 = srealloc((void *)l2g->blocks, (unsigned long )l2g->num_blocks * sizeof(struct l2g_block_info ));
#line 586
  l2g->blocks = (struct l2g_block_info *)tmp___1;
  }
#line 588
  return;
}
}
#line 591 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static int join_blocks(Local_to_global *l2g , struct l2g_block_info *binfo ) 
{ 
  int zeroes ;
  int gain ;
  int best ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 600
  if (binfo->zeroes == 0) {
#line 602
    return (0);
  }
#line 609
  zeroes = L2G_BLOCKSIZE;
#line 610
  gain = 0;
#line 611
  best = 0;
#line 613
  i = 0;
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if (zeroes > 0) {
#line 613
      if (! ((long )i <= binfo - l2g->blocks)) {
#line 613
        goto while_break;
      }
    } else {
#line 613
      goto while_break;
    }
    {
#line 615
    zeroes -= L2G_BLOCKSIZE - (binfo - i)->zeroes;
#line 616
    tmp___1 = is_dense((struct l2g_block_info  const  *)(binfo - i));
    }
#line 616
    if (tmp___1) {
#line 616
      tmp___0 = 1;
    } else {
#line 616
      tmp___0 = 2;
    }
#line 616
    gain += tmp___0;
#line 617
    if (gain > 2) {
#line 617
      if (zeroes >= 0) {
#line 618
        best = i;
      }
    }
#line 613
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  if (best > 0) {
    {
#line 623
    join_range(l2g, binfo - best, binfo);
    }
#line 624
    return (1);
  }
#line 627
  zeroes = L2G_BLOCKSIZE;
#line 628
  gain = 0;
#line 629
  best = 0;
#line 630
  i = 0;
  {
#line 630
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 630
    if (zeroes > 0) {
#line 630
      if (! ((long )i < (long )l2g->num_blocks - (binfo - l2g->blocks))) {
#line 630
        goto while_break___0;
      }
    } else {
#line 630
      goto while_break___0;
    }
    {
#line 632
    zeroes -= L2G_BLOCKSIZE - (binfo + i)->zeroes;
#line 633
    tmp___4 = is_dense((struct l2g_block_info  const  *)(binfo + i));
    }
#line 633
    if (tmp___4) {
#line 633
      tmp___3 = 1;
    } else {
#line 633
      tmp___3 = 2;
    }
#line 633
    gain += tmp___3;
#line 634
    if (gain > 2) {
#line 634
      if (zeroes >= 0) {
#line 635
        best = i;
      }
    }
#line 630
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 638
  if (best > 0) {
    {
#line 640
    join_range(l2g, binfo, binfo + best);
    }
#line 641
    return (1);
  }
#line 644
  return (0);
}
}
#line 652 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2g_set_block_size(int sz ) 
{ 


  {
#line 655
  if (! (L2G_BLOCKSIZE == -1)) {
    {
#line 655
    __assert_fail("L2G_BLOCKSIZE == -1", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  655U, "l2g_set_block_size");
    }
  }
#line 656
  L2G_BLOCKSIZE = sz;
#line 657
  return;
}
}
#line 660 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2g_destruct(Local_to_global *l2g ) 
{ 


  {
  {
#line 663
  l2g_clear(l2g);
#line 664
  nr_destructs ++;
#line 665
  nr_l2gs --;
#line 667
  l2g->num_blocks = -559038737;
#line 668
  l2g->first_unused = (Local_text_no )3735928559U;
#line 669
  l2g->blocks = (struct l2g_block_info *)((void *)3735928559U);
  }
#line 671
  return;
}
}
#line 674 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2g_init(Local_to_global *l2g ) 
{ 


  {
#line 677
  if (L2G_BLOCKSIZE == -1) {
#line 678
    L2G_BLOCKSIZE = 250;
  }
#line 681
  l2g->num_blocks = 0;
#line 682
  l2g->first_unused = (Local_text_no )1;
#line 683
  l2g->blocks = (struct l2g_block_info *)((void *)0);
#line 684
  nr_constructs ++;
#line 685
  nr_l2gs ++;
#line 685
  if (nr_l2gs > nr_l2gs_peak) {
#line 686
    nr_l2gs_peak = nr_l2gs;
  }
#line 687
  return;
}
}
#line 690 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2g_clear(Local_to_global *l2g ) 
{ 
  struct l2g_block_info *binfo ;
  int i ;

  {
#line 697
  binfo = l2g->blocks;
#line 698
  i = 0;
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    if (! (i < l2g->num_blocks)) {
#line 698
      goto while_break;
    }
#line 700
    if ((unsigned long )binfo->key_block != (unsigned long )((void *)0)) {
      {
#line 702
      nr_blocks_sparse --;
#line 703
      sfree((void *)binfo->key_block);
      }
    }
    {
#line 705
    sfree((void *)binfo->value_block);
#line 707
    binfo ++;
#line 698
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  nr_blocks -= (long )l2g->num_blocks;
#line 712
  l2g->num_blocks = 0;
#line 713
  l2g->first_unused = (Local_text_no )1;
#line 714
  if ((unsigned long )l2g->blocks != (unsigned long )((void *)0)) {
    {
#line 716
    sfree((void *)l2g->blocks);
#line 717
    l2g->blocks = (struct l2g_block_info *)((void *)0);
    }
  }
#line 719
  nr_clears ++;
#line 720
  return;
}
}
#line 728 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2g_copy(Local_to_global *dest , Local_to_global const   *src ) 
{ 
  struct l2g_block_info  const  *binfo ;
  int i ;
  Local_text_no tmp ;

  {
  {
#line 735
  l2g_clear(dest);
#line 737
  binfo = (struct l2g_block_info  const  *)src->blocks;
  }
  {
#line 737
  while (1) {
    while_continue: /* CIL Label */ ;
#line 737
    if (! ((unsigned long )binfo < (unsigned long )(src->blocks + src->num_blocks))) {
#line 737
      goto while_break;
    }
#line 738
    i = 0;
    {
#line 738
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 738
      if (! (i < (int )binfo->first_free)) {
#line 738
        goto while_break___0;
      }
      {
#line 739
      tmp = key_value(binfo, i);
#line 739
      l2g_append(dest, tmp, *(binfo->value_block + i));
#line 738
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 737
    binfo ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 740
  if (! (src->first_unused >= (Local_text_no const   )dest->first_unused)) {
    {
#line 740
    __assert_fail("src->first_unused >= dest->first_unused", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  740U, "l2g_copy");
    }
  }
#line 741
  dest->first_unused = (Local_text_no )src->first_unused;
#line 742
  nr_copies ++;
#line 743
  return;
}
}
#line 748 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2g_append(Local_to_global *l2g , Local_text_no lno , Text_no tno ) 
{ 
  struct l2g_block_info *binfo ;
  Local_text_no_iter ix ;
  int tmp ;
  int tmp___0 ;

  {
#line 756
  if (lno < l2g->first_unused) {
    {
#line 758
    kom_log("l2g_append: won\'t add %lu<%lu> when first_unused=%lu\n", tno, lno, l2g->first_unused);
    }
#line 761
    return;
  }
#line 764
  l2g->first_unused = lno + 1UL;
#line 767
  if (tno == 0UL) {
#line 768
    return;
  }
#line 770
  if (l2g->num_blocks == 0) {
    {
#line 773
    binfo = add_block(l2g);
#line 774
    binfo->start = lno;
    }
  } else {
#line 779
    binfo = l2g->blocks + (l2g->num_blocks - 1);
  }
  {
#line 785
  tmp = is_dense((struct l2g_block_info  const  *)binfo);
  }
#line 785
  if (tmp) {
#line 787
    if (lno - binfo->start >= (Local_text_no )L2G_BLOCKSIZE) {
#line 792
      if (binfo->zeroes >= L2G_BLOCKSIZE / 2) {
        {
#line 797
        make_sparse(binfo);
        }
      } else {
        {
#line 807
        binfo = add_block(l2g);
        }
      }
    }
  } else {
    {
#line 813
    sparse_compact(binfo);
    }
#line 814
    if (binfo->first_free == L2G_BLOCKSIZE) {
      {
#line 815
      binfo = add_block(l2g);
      }
    }
  }
#line 819
  if (binfo->first_free == 0) {
#line 820
    binfo->start = lno;
  }
  {
#line 822
  tmp___0 = is_dense((struct l2g_block_info  const  *)binfo);
  }
#line 822
  if (tmp___0) {
#line 824
    ix = (Local_text_no_iter )binfo->first_free;
    {
#line 824
    while (1) {
      while_continue: /* CIL Label */ ;
#line 824
      if (! (ix < lno - binfo->start)) {
#line 824
        goto while_break;
      }
#line 825
      *(binfo->value_block + ix) = (Text_no )0;
#line 824
      ix ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 826
    *(binfo->value_block + (lno - binfo->start)) = tno;
#line 827
    binfo->first_free = (int )((lno - binfo->start) + 1UL);
  } else {
#line 831
    *(binfo->key_block + binfo->first_free) = lno;
#line 832
    *(binfo->value_block + binfo->first_free) = tno;
#line 833
    (binfo->first_free) ++;
  }
#line 836
  (binfo->zeroes) --;
#line 837
  return;
}
}
#line 840 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2g_expensive_set(Local_to_global *l2g , Local_text_no lno , Text_no tno ) 
{ 
  struct l2g_block_info *binfo ;
  Local_text_no_iter ix ;
  int block_no ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 849
  if (lno >= l2g->first_unused) {
    {
#line 851
    l2g_append(l2g, lno, tno);
    }
#line 852
    return;
  }
#line 855
  if (tno == 0UL) {
    {
#line 857
    l2g_delete(l2g, lno);
    }
#line 858
    return;
  }
  {
#line 861
  binfo = find_block((Local_to_global const   *)l2g, lno);
  }
#line 862
  if ((unsigned long )binfo == (unsigned long )((void *)0)) {
#line 864
    if (! (l2g->num_blocks == 0)) {
      {
#line 864
      __assert_fail("l2g->num_blocks == 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    864U, "l2g_expensive_set");
      }
    }
    {
#line 867
    binfo = add_block(l2g);
    }
#line 868
    if (! (binfo->first_free == 0)) {
      {
#line 868
      __assert_fail("binfo->first_free == 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    868U, "l2g_expensive_set");
      }
    }
#line 869
    if (! ((unsigned long )binfo->key_block == (unsigned long )((void *)0))) {
      {
#line 869
      __assert_fail("binfo->key_block == ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    869U, "l2g_expensive_set");
      }
    }
#line 870
    binfo->start = lno;
#line 871
    *(binfo->value_block + 0) = tno;
#line 872
    binfo->first_free = 1;
#line 873
    (binfo->zeroes) --;
  } else
#line 875
  if (lno < binfo->start) {
#line 877
    if (! ((unsigned long )binfo == (unsigned long )l2g->blocks)) {
      {
#line 877
      __assert_fail("binfo == l2g->blocks", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    877U, "l2g_expensive_set");
      }
    }
    {
#line 880
    add_block_before(l2g, 0);
#line 881
    binfo = l2g->blocks;
#line 882
    binfo->start = lno;
#line 883
    *(binfo->value_block + 0) = tno;
#line 884
    binfo->first_free = 1;
#line 885
    (binfo->zeroes) --;
    }
  } else {
    {
#line 887
    tmp___1 = is_dense((struct l2g_block_info  const  *)binfo);
    }
#line 887
    if (tmp___1) {
#line 889
      if (! (binfo->start <= lno)) {
        {
#line 889
        __assert_fail("binfo->start <= lno", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                      889U, "l2g_expensive_set");
        }
      }
#line 890
      if (lno < binfo->start + (Local_text_no )L2G_BLOCKSIZE) {
        {
#line 893
        while (1) {
          while_continue: /* CIL Label */ ;
#line 893
          if (! (binfo->start + (Local_text_no )binfo->first_free <= lno)) {
#line 893
            goto while_break;
          }
#line 895
          tmp = binfo->first_free;
#line 895
          (binfo->first_free) ++;
#line 895
          *(binfo->value_block + tmp) = (Text_no )0;
#line 896
          if (! (binfo->first_free <= L2G_BLOCKSIZE)) {
            {
#line 896
            __assert_fail("binfo->first_free <= L2G_BLOCKSIZE", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                          896U, "l2g_expensive_set");
            }
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 899
        if (! (lno < binfo->start + (Local_text_no )binfo->first_free)) {
          {
#line 899
          __assert_fail("lno < binfo->start + binfo->first_free", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                        899U, "l2g_expensive_set");
          }
        }
#line 900
        if (! (binfo->first_free <= L2G_BLOCKSIZE)) {
          {
#line 900
          __assert_fail("binfo->first_free <= L2G_BLOCKSIZE", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                        900U, "l2g_expensive_set");
          }
        }
#line 902
        if (*(binfo->value_block + (lno - binfo->start)) == 0UL) {
#line 903
          (binfo->zeroes) --;
        }
#line 904
        *(binfo->value_block + (lno - binfo->start)) = tno;
      } else {
        {
#line 910
        block_no = (int )((binfo + 1) - l2g->blocks);
#line 911
        add_block_before(l2g, block_no);
#line 912
        binfo = l2g->blocks + block_no;
#line 913
        binfo->start = lno;
#line 914
        *(binfo->value_block + 0) = tno;
#line 915
        binfo->first_free = 1;
#line 916
        (binfo->zeroes) --;
        }
      }
    } else {
      {
#line 921
      tmp___0 = sparse_locate_value((struct l2g_block_info  const  *)binfo, lno);
#line 921
      ix = (Local_text_no_iter )tmp___0;
      }
#line 922
      if (ix < (Local_text_no_iter )binfo->first_free) {
#line 922
        if (*(binfo->key_block + ix) == lno) {
#line 926
          if (! (*(binfo->value_block + ix) != 0UL)) {
            {
#line 926
            __assert_fail("binfo->value_block[ix] != 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                          926U, "l2g_expensive_set");
            }
          }
#line 927
          *(binfo->value_block + ix) = tno;
        } else {
#line 922
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 931
        if (binfo->zeroes == 0) {
          {
#line 934
          block_no = (int )((binfo + 1) - l2g->blocks);
#line 935
          add_block_before(l2g, block_no);
#line 936
          binfo = l2g->blocks + block_no;
          }
#line 938
          if (! ((binfo + -1)->first_free == L2G_BLOCKSIZE)) {
            {
#line 938
            __assert_fail("binfo[-1].first_free == L2G_BLOCKSIZE", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                          938U, "l2g_expensive_set");
            }
          }
#line 940
          if (lno > *((binfo + -1)->key_block + (L2G_BLOCKSIZE - 1))) {
#line 943
            binfo->start = lno;
#line 944
            *(binfo->value_block + 0) = tno;
#line 945
            binfo->first_free = 1;
#line 946
            (binfo->zeroes) --;
#line 947
            return;
          } else {
#line 955
            binfo->start = *((binfo + -1)->key_block + (L2G_BLOCKSIZE - 1));
#line 956
            *(binfo->value_block + 0) = *((binfo + -1)->value_block + (L2G_BLOCKSIZE - 1));
#line 958
            binfo->first_free = 1;
#line 959
            (binfo->zeroes) --;
#line 962
            binfo --;
#line 963
            (binfo->zeroes) ++;
#line 964
            (binfo->first_free) --;
          }
#line 968
          if (! (binfo->zeroes == 1)) {
            {
#line 968
            __assert_fail("binfo->zeroes == 1", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                          968U, "l2g_expensive_set");
            }
          }
        } else {
          {
#line 971
          sparse_compact(binfo);
          }
        }
#line 974
        if (! (binfo->zeroes > 0)) {
          {
#line 974
          __assert_fail("binfo->zeroes > 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                        974U, "l2g_expensive_set");
          }
        }
#line 975
        ix = (Local_text_no_iter )binfo->first_free;
        {
#line 975
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 975
          if (! (ix > 0UL)) {
#line 975
            goto while_break___0;
          }
#line 977
          if (! (*(binfo->key_block + (ix - 1UL)) != lno)) {
            {
#line 977
            __assert_fail("binfo->key_block[ix-1] != lno", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                          977U, "l2g_expensive_set");
            }
          }
#line 978
          if (*(binfo->key_block + (ix - 1UL)) > lno) {
#line 980
            *(binfo->key_block + ix) = *(binfo->key_block + (ix - 1UL));
#line 981
            *(binfo->value_block + ix) = *(binfo->value_block + (ix - 1UL));
          } else {
#line 984
            goto while_break___0;
          }
#line 975
          ix --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 987
        if (! (ix == 0UL)) {
#line 987
          if (! (*(binfo->key_block + (ix - 1UL)) < lno)) {
            {
#line 987
            __assert_fail("ix == 0 || binfo->key_block[ix-1] < lno", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                          987U, "l2g_expensive_set");
            }
          }
        }
#line 988
        if (! (ix == (Local_text_no_iter )binfo->first_free)) {
#line 988
          if (! (*(binfo->key_block + (ix + 1UL)) > lno)) {
            {
#line 988
            __assert_fail("ix == (Local_text_no_iter)binfo->first_free || binfo->key_block[ix+1] > lno",
                          "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                          989U, "l2g_expensive_set");
            }
          }
        }
#line 991
        *(binfo->key_block + ix) = lno;
#line 992
        *(binfo->value_block + ix) = tno;
#line 993
        (binfo->first_free) ++;
#line 994
        (binfo->zeroes) --;
      }
    }
  }
#line 997
  return;
}
}
#line 1004 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2g_delete(Local_to_global *l2g , Local_text_no lno ) 
{ 
  struct l2g_block_info *binfo ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1012
  binfo = find_block((Local_to_global const   *)l2g, lno);
  }
#line 1013
  if ((unsigned long )binfo == (unsigned long )((void *)0)) {
#line 1014
    return;
  }
  {
#line 1017
  tmp = is_dense((struct l2g_block_info  const  *)binfo);
  }
#line 1017
  if (tmp) {
#line 1019
    if (binfo->start <= lno) {
#line 1019
      if (lno < binfo->start + (Local_text_no )L2G_BLOCKSIZE) {
#line 1020
        if (*(binfo->value_block + (lno - binfo->start)) != 0UL) {
#line 1022
          *(binfo->value_block + (lno - binfo->start)) = (Text_no )0;
#line 1023
          (binfo->zeroes) ++;
        }
      }
    }
  } else {
    {
#line 1028
    i = sparse_locate_value((struct l2g_block_info  const  *)binfo, lno);
    }
#line 1029
    if (i < binfo->first_free) {
#line 1029
      if (*(binfo->key_block + i) == lno) {
#line 1031
        if (! (*(binfo->value_block + i) != 0UL)) {
          {
#line 1031
          __assert_fail("binfo->value_block[i] != 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                        1031U, "l2g_delete");
          }
        }
#line 1032
        *(binfo->value_block + i) = (Text_no )0;
#line 1033
        (binfo->zeroes) ++;
      }
    }
  }
  {
#line 1038
  tmp___0 = is_empty((struct l2g_block_info  const  *)binfo);
  }
#line 1038
  if (tmp___0) {
    {
#line 1040
    delete_block(l2g, binfo);
    }
#line 1041
    return;
  }
  {
#line 1045
  tmp___2 = join_blocks(l2g, binfo);
  }
#line 1045
  if (! tmp___2) {
    {
#line 1048
    tmp___1 = is_dense((struct l2g_block_info  const  *)binfo);
    }
#line 1048
    if (! tmp___1) {
#line 1048
      if (binfo->zeroes + binfo->first_free / 2 > L2G_BLOCKSIZE) {
        {
#line 1051
        sparse_compact(binfo);
        }
      }
    }
  }
#line 1053
  return;
}
}
#line 1056 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
Text_no l2g_lookup(Local_to_global const   *l2g , Local_text_no lno ) 
{ 
  struct l2g_block_info  const  *binfo ;
  int i ;
  struct l2g_block_info *tmp ;
  int tmp___0 ;

  {
  {
#line 1063
  tmp = find_block(l2g, lno);
#line 1063
  binfo = (struct l2g_block_info  const  *)tmp;
  }
#line 1064
  if ((unsigned long )binfo == (unsigned long )((void *)0)) {
#line 1065
    return ((Text_no )0);
  }
  {
#line 1067
  tmp___0 = is_dense(binfo);
  }
#line 1067
  if (tmp___0) {
#line 1069
    if (binfo->start <= (Local_text_no const   )lno) {
#line 1069
      if (lno < (Local_text_no )(binfo->start + (Local_text_no const   )binfo->first_free)) {
#line 1070
        return (*(binfo->value_block + (lno - (Local_text_no )binfo->start)));
      }
    }
  } else {
    {
#line 1074
    i = sparse_locate_value(binfo, lno);
    }
#line 1075
    if (i < (int )binfo->first_free) {
#line 1075
      if (*(binfo->key_block + i) == lno) {
#line 1076
        return (*(binfo->value_block + i));
      }
    }
  }
#line 1079
  return ((Text_no )0);
}
}
#line 1083 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
Local_text_no l2g_next_key(Local_to_global const   *l2g , Local_text_no lno ) 
{ 
  struct l2g_block_info  const  *binfo ;
  int i ;
  Local_text_no tmp ;

  {
  {
#line 1090
  tmp = find_block_index_key(l2g, lno, & binfo, & i);
  }
#line 1090
  return (tmp);
}
}
#line 1094 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
Local_text_no l2g_first_appendable_key(Local_to_global const   *l2g ) 
{ 


  {
#line 1097
  return ((Local_text_no )l2g->first_unused);
}
}
#line 1101 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2g_set_first_appendable_key(Local_to_global *l2g , Local_text_no key ) 
{ 


  {
#line 1105
  if (key < l2g->first_unused) {
    {
#line 1107
    kom_log("l2g_append: won\'t decrease first_unused from %lu to %lu\n", l2g->first_unused,
            key);
    }
#line 1109
    return;
  }
#line 1112
  l2g->first_unused = key;
#line 1113
  return;
}
}
#line 1116 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2g_delete_global_in_sorted(Local_to_global *l2g , Text_no tno ) 
{ 
  L2g_iterator iter ;

  {
  {
#line 1128
  l2gi_searchall(& iter, (Local_to_global const   *)l2g);
  }
  {
#line 1128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1128
    if (! (! iter.search_ended)) {
#line 1128
      goto while_break;
    }
#line 1129
    if (iter.tno == tno) {
      {
#line 1131
      l2g_delete(l2g, iter.lno);
      }
#line 1132
      return;
    }
    {
#line 1128
    l2gi_next(& iter);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1134
  return;
}
}
#line 1137 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2g_dump(FILE *file , Local_to_global const   *l2g ) 
{ 
  struct l2g_block_info *binfo ;
  int i ;
  int j ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1144
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Number of blocks: %d\n",
          l2g->num_blocks);
#line 1145
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"First unused: %lu\n",
          l2g->first_unused);
#line 1147
  binfo = (struct l2g_block_info *)l2g->blocks;
#line 1148
  i = 0;
  }
  {
#line 1148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1148
    if (! (i < (int )l2g->num_blocks)) {
#line 1148
      goto while_break;
    }
    {
#line 1149
    tmp___1 = is_dense((struct l2g_block_info  const  *)binfo);
    }
#line 1149
    if (tmp___1) {
#line 1149
      tmp___0 = "dense";
    } else {
#line 1149
      tmp___0 = "sparse";
    }
    {
#line 1149
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d: %d %d %d (%s) [",
            i, binfo->first_free, binfo->zeroes, (int )binfo->start, tmp___0);
#line 1155
    tmp___2 = is_dense((struct l2g_block_info  const  *)binfo);
    }
#line 1155
    if (tmp___2) {
#line 1156
      j = 0;
      {
#line 1156
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1156
        if (! (j < binfo->first_free)) {
#line 1156
          goto while_break___0;
        }
        {
#line 1157
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d ",
                (int )*(binfo->value_block + j));
#line 1156
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1160
      j = 0;
      {
#line 1160
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1160
        if (! (j < binfo->first_free)) {
#line 1160
          goto while_break___1;
        }
        {
#line 1161
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d:%d ",
                (int )*(binfo->key_block + j), (int )*(binfo->value_block + j));
#line 1160
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1166
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"]\n");
#line 1168
    binfo ++;
#line 1148
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1170
  return;
}
}
#line 1173 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
Success l2g_read(FILE *fp , Local_to_global *l2g ) 
{ 
  int c ;
  Local_text_no lno ;
  Text_no tno ;
  Local_text_no first_unused ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 1177
  lno = (Local_text_no )0;
#line 1181
  l2g_clear(l2g);
#line 1184
  fskipwhite(fp);
#line 1185
  c = _IO_getc(fp);
  }
#line 1185
  if (c == -1) {
    {
#line 1187
    tmp = ftell(fp);
#line 1187
    kom_log("l2g_read() failed to find ``[\'\' marker at pos %lu.\n", (unsigned long )tmp);
    }
#line 1189
    return ((Success )FAILURE);
  } else
#line 1185
  if (c != 91) {
    {
#line 1187
    tmp = ftell(fp);
#line 1187
    kom_log("l2g_read() failed to find ``[\'\' marker at pos %lu.\n", (unsigned long )tmp);
    }
#line 1189
    return ((Success )FAILURE);
  }
  {
#line 1192
  first_unused = fparse_long(fp);
  }
  {
#line 1195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1197
    c = _IO_getc(fp);
    }
#line 1197
    if (c == -1) {
      {
#line 1199
      tmp___0 = ftell(fp);
#line 1199
      kom_log("l2g_read(): unexpected EOF at pos %lu.\n", (unsigned long )tmp___0);
      }
#line 1201
      return ((Success )FAILURE);
    }
    {
#line 1206
    if (c == 32) {
#line 1206
      goto case_32;
    }
#line 1215
    if (c == 44) {
#line 1215
      goto case_44;
    }
#line 1224
    if (c == 58) {
#line 1224
      goto case_58;
    }
#line 1234
    if (c == 93) {
#line 1234
      goto case_93;
    }
#line 1238
    goto switch_default;
    case_32: /* CIL Label */ 
    {
#line 1207
    lno = fparse_long(fp);
    }
#line 1208
    if (lno == 0UL) {
      {
#line 1210
      tmp___1 = ftell(fp);
#line 1210
      kom_log("l2g_read(): got local number 0 at pos %lu.\n", (unsigned long )tmp___1);
      }
#line 1212
      return ((Success )FAILURE);
    }
#line 1214
    goto switch_break;
    case_44: /* CIL Label */ 
#line 1216
    if (lno == 0UL) {
      {
#line 1218
      tmp___2 = ftell(fp);
#line 1218
      kom_log("l2g_read(): missing local number at pos %lu.\n", (unsigned long )tmp___2);
      }
#line 1220
      return ((Success )FAILURE);
    }
#line 1222
    lno ++;
    case_58: /* CIL Label */ 
#line 1225
    if (lno == 0UL) {
      {
#line 1227
      tmp___3 = ftell(fp);
#line 1227
      kom_log("l2g_read(): missing local number at pos %lu.\n", (unsigned long )tmp___3);
      }
#line 1229
      return ((Success )FAILURE);
    }
    {
#line 1231
    tno = fparse_long(fp);
#line 1232
    l2g_append(l2g, lno, tno);
    }
#line 1233
    goto switch_break;
    case_93: /* CIL Label */ 
#line 1235
    if (! (first_unused >= l2g->first_unused)) {
      {
#line 1235
      __assert_fail("first_unused >= l2g->first_unused", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    1235U, "l2g_read");
      }
    }
#line 1236
    l2g->first_unused = first_unused;
#line 1237
    return ((Success )OK);
    switch_default: /* CIL Label */ 
    {
#line 1239
    tmp___4 = ftell(fp);
#line 1239
    kom_log("l2g_read(): unexpected character ``%c\'\' at pos %lu.\n", c, (unsigned long )tmp___4);
    }
#line 1241
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1251 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static char buf___1[25UL]  ;
#line 1247 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static void put_ulong(unsigned long l , FILE *fp ) 
{ 
  char *cp ;

  {
#line 1254
  if (l < 10UL) {
    {
#line 1255
    _IO_putc((int )*("0123456789" + l), fp);
    }
  } else {
#line 1258
    cp = buf___1 + sizeof(buf___1);
    {
#line 1259
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1259
      if (! (l > 0UL)) {
#line 1259
        goto while_break;
      }
#line 1261
      cp --;
#line 1261
      *cp = (char )(l % 10UL + 48UL);
#line 1262
      l /= 10UL;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1264
    fwrite((void const   */* __restrict  */)cp, (size_t )((buf___1 + sizeof(buf___1)) - cp),
           (size_t )1, (FILE */* __restrict  */)fp);
    }
  }
#line 1266
  return;
}
}
#line 1268 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2g_write(FILE *fp , Local_to_global const   *l2g ) 
{ 
  struct l2g_block_info  const  *binfo ;
  int ix ;
  Local_text_no key ;
  Text_no val ;
  Local_text_no current ;

  {
  {
#line 1275
  current = (Local_text_no )0;
#line 1277
  _IO_putc('[', fp);
#line 1278
  put_ulong((unsigned long )l2g->first_unused, fp);
#line 1280
  binfo = (struct l2g_block_info  const  *)l2g->blocks;
  }
  {
#line 1280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1280
    if (! ((unsigned long )binfo < (unsigned long )(l2g->blocks + l2g->num_blocks))) {
#line 1280
      goto while_break;
    }
#line 1281
    ix = 0;
    {
#line 1281
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1281
      if (! (ix < (int )binfo->first_free)) {
#line 1281
        goto while_break___0;
      }
#line 1282
      val = *(binfo->value_block + ix);
#line 1282
      if (val != 0UL) {
        {
#line 1284
        key = key_value(binfo, ix);
        }
#line 1285
        if (key > current + 3UL) {
          {
#line 1287
          _IO_putc(' ', fp);
#line 1288
          put_ulong(key, fp);
#line 1289
          _IO_putc(':', fp);
#line 1290
          put_ulong(val, fp);
#line 1291
          current = key;
          }
        } else
#line 1285
        if (current == 0UL) {
          {
#line 1287
          _IO_putc(' ', fp);
#line 1288
          put_ulong(key, fp);
#line 1289
          _IO_putc(':', fp);
#line 1290
          put_ulong(val, fp);
#line 1291
          current = key;
          }
        } else {
          {
#line 1295
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1295
            current ++;
#line 1295
            if (! (current < key)) {
#line 1295
              goto while_break___1;
            }
            {
#line 1297
            _IO_putc(',', fp);
#line 1298
            _IO_putc('0', fp);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 1300
          _IO_putc(',', fp);
#line 1301
          put_ulong(val, fp);
          }
        }
      }
#line 1281
      ix ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1280
    binfo ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1305
  _IO_putc(']', fp);
  }
#line 1306
  return;
}
}
#line 1314 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2gi_searchall(L2g_iterator *l2gi , Local_to_global const   *l2g ) 
{ 


  {
  {
#line 1318
  l2gi_searchsome(l2gi, l2g, (Local_text_no )1, (Local_text_no )0);
  }
#line 1319
  return;
}
}
#line 1322 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2gi_searchsome(L2g_iterator *l2gi , Local_to_global const   *l2g , Local_text_no begin ,
                     Local_text_no end ) 
{ 
  struct l2g_block_info  const  *binfo ;
  int index ;
  Local_text_no tmp ;

  {
#line 1331
  if (begin < 1UL) {
    {
#line 1333
    kom_log("l2gi_searchsome(%lu, %lu) called: min is 1\n", begin, end);
#line 1335
    begin = (Local_text_no )1;
    }
  }
#line 1338
  l2gi->l2g = l2g;
#line 1339
  l2gi->beginval = begin;
#line 1340
  l2gi->endval = end;
#line 1341
  l2gi->search_ended = 1;
#line 1343
  if (end != 0UL) {
#line 1343
    if (begin >= end) {
#line 1344
      return;
    }
  }
  {
#line 1346
  tmp = find_block_index_key(l2g, begin - 1UL, & binfo, & index);
  }
#line 1346
  if (tmp == 0UL) {
#line 1347
    return;
  }
#line 1349
  l2gi->binfo = binfo;
#line 1350
  l2gi->arrindex = index;
#line 1352
  if (! ((unsigned long )binfo != (unsigned long )((void *)0))) {
    {
#line 1352
    __assert_fail("binfo != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  1352U, "l2gi_searchsome");
    }
  }
  {
#line 1354
  l2gi->lno = key_value(binfo, index);
#line 1355
  l2gi->tno = *(binfo->value_block + index);
  }
#line 1357
  if (end == 0UL) {
#line 1358
    l2gi->search_ended = 0;
  } else {
#line 1360
    l2gi->search_ended = l2gi->lno >= end;
  }
#line 1361
  return;
}
}
#line 1364 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2gi_next(L2g_iterator *l2gi ) 
{ 
  Local_to_global const   *l2g ;
  struct l2g_block_info  const  *binfo ;
  int arrindex ;
  Local_text_no tmp ;

  {
#line 1371
  if (! (! l2gi->search_ended)) {
    {
#line 1371
    __assert_fail("!l2gi->search_ended", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  1371U, "l2gi_next");
    }
  }
#line 1373
  l2g = l2gi->l2g;
#line 1374
  arrindex = l2gi->arrindex + 1;
#line 1375
  binfo = l2gi->binfo;
  {
#line 1375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1375
    if (! ((unsigned long )binfo < (unsigned long )(l2g->blocks + l2g->num_blocks))) {
#line 1375
      goto while_break;
    }
    {
#line 1379
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1379
      if (! (arrindex < (int )binfo->first_free)) {
#line 1379
        goto while_break___0;
      }
#line 1381
      if (l2gi->endval != 0UL) {
        {
#line 1381
        tmp = key_value(binfo, arrindex);
        }
#line 1381
        if (tmp >= l2gi->endval) {
#line 1384
          l2gi->search_ended = 1;
#line 1385
          return;
        }
      }
#line 1388
      if (*(binfo->value_block + arrindex) != 0UL) {
        {
#line 1390
        l2gi->binfo = binfo;
#line 1391
        l2gi->arrindex = arrindex;
#line 1393
        l2gi->lno = key_value(binfo, arrindex);
#line 1394
        l2gi->tno = *(binfo->value_block + arrindex);
        }
#line 1396
        return;
      }
#line 1379
      arrindex ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1375
    binfo ++;
#line 1375
    arrindex = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1401
  l2gi->search_ended = 1;
#line 1402
  return;
}
}
#line 1406 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
Local_text_no l2gi_begin(L2g_iterator const   *l2gi ) 
{ 


  {
#line 1409
  return ((Local_text_no )l2gi->beginval);
}
}
#line 1413 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
Local_text_no l2gi_end(L2g_iterator const   *l2gi ) 
{ 


  {
#line 1416
  return ((Local_text_no )l2gi->endval);
}
}
#line 1424 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2gi_searchsome_reverse(L2g_reverse_iterator *l2gi , Local_to_global const   *l2g ,
                             Local_text_no begin , Local_text_no end ) 
{ 
  struct l2g_block_info  const  *binfo ;
  int index ;
  Local_text_no tmp ;

  {
#line 1433
  l2gi->l2g = l2g;
#line 1434
  l2gi->beginval = begin;
#line 1435
  l2gi->endval = end;
#line 1436
  l2gi->search_ended = 1;
#line 1438
  if (begin >= end) {
#line 1439
    return;
  }
  {
#line 1441
  tmp = find_block_index_key_reverse(l2g, end, & binfo, & index);
  }
#line 1441
  if (tmp == 0UL) {
#line 1442
    return;
  }
#line 1444
  l2gi->binfo = binfo;
#line 1445
  l2gi->arrindex = index;
#line 1447
  if (! ((unsigned long )binfo != (unsigned long )((void *)0))) {
    {
#line 1447
    __assert_fail("binfo != ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  1447U, "l2gi_searchsome_reverse");
    }
  }
  {
#line 1449
  l2gi->lno = key_value(binfo, index);
#line 1450
  l2gi->tno = *(binfo->value_block + index);
#line 1451
  l2gi->search_ended = l2gi->lno < begin;
  }
#line 1452
  return;
}
}
#line 1455 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
void l2gi_prev(L2g_reverse_iterator *l2gi ) 
{ 
  Local_to_global const   *l2g ;
  struct l2g_block_info  const  *binfo ;
  int arrindex ;
  Local_text_no tmp ;

  {
#line 1462
  if (! (! l2gi->search_ended)) {
    {
#line 1462
    __assert_fail("!l2gi->search_ended", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  1462U, "l2gi_prev");
    }
  }
#line 1464
  l2g = l2gi->l2g;
#line 1465
  arrindex = l2gi->arrindex - 1;
#line 1466
  binfo = l2gi->binfo;
  {
#line 1467
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1469
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1469
      if (! (arrindex >= 0)) {
#line 1469
        goto while_break___0;
      }
      {
#line 1471
      tmp = key_value(binfo, arrindex);
      }
#line 1471
      if (tmp < l2gi->beginval) {
#line 1473
        l2gi->search_ended = 1;
#line 1474
        return;
      }
#line 1477
      if (*(binfo->value_block + arrindex) != 0UL) {
        {
#line 1479
        l2gi->binfo = binfo;
#line 1480
        l2gi->arrindex = arrindex;
#line 1482
        l2gi->lno = key_value(binfo, arrindex);
#line 1483
        l2gi->tno = *(binfo->value_block + arrindex);
        }
#line 1485
        return;
      }
#line 1469
      arrindex --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1489
    if ((unsigned long )binfo == (unsigned long )l2g->blocks) {
#line 1491
      l2gi->search_ended = 1;
#line 1492
      return;
    }
#line 1495
    binfo --;
#line 1496
    arrindex = (int )(binfo->first_free - 1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1505 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
extern void dump_l2g_stats(FILE *file ) 
{ 


  {
  {
#line 1508
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"---%s:\n\tExisting l2gs:    %ld\n",
          "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
          nr_l2gs);
#line 1510
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tExisting sparse blocks: %ld\n",
          nr_blocks_sparse);
#line 1511
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tExisting blocks (total): %ld\n",
          nr_blocks);
#line 1512
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tPeak l2gs: %ld\n",
          nr_l2gs_peak);
#line 1513
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tPeak sparse blocks: %ld\n",
          nr_blocks_sparse_peak);
#line 1514
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tPeak blocks (total): %ld\n",
          nr_blocks_peak);
#line 1515
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tctor calls: %ld\n",
          nr_constructs);
#line 1516
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tdtor calls: %ld\n",
          nr_destructs);
#line 1517
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tclear calls: %ld\n",
          nr_clears);
#line 1518
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tcopy calls: %ld\n",
          nr_copies);
#line 1519
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tjoin operations: %ld\n",
          nr_joins);
#line 1520
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tjoined blocks: %ld\n",
          nr_joined_blocks);
#line 1521
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tsparse skip cost: %ld\n",
          sparse_skip_cost);
#line 1522
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tsparse compactions: %ld\n",
          nr_sparse_compactions);
#line 1523
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\tsparsifications: %ld\n",
          nr_sparsifications);
  }
#line 1524
  return;
}
}
#line 170 "./../libraries/libmisc/s-string.h"
extern Success s_size_crea_str(String *result , String_size length ) ;
#line 37 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.h"
extern time_t fparse_time(FILE *fp ) ;
#line 54
extern Success fparse_membership_list(FILE *fp , Membership_list *result ) ;
#line 59
extern Success fparse_conf_list(FILE *fp , Conf_list_old *result ) ;
#line 64
extern Success fparse_mark_list(FILE *fp , Mark_list *result ) ;
#line 79
extern Success fparse_string(FILE *fp , String *result ) ;
#line 83
extern Success fparse_member_list(FILE *fp , Member_list *result ) ;
#line 88
extern Success fparse_member(FILE *fp , Member *result ) ;
#line 92
extern Success fparse_mark(FILE *fp , Mark *result ) ;
#line 97
extern Success fparse_priv_bits(FILE *fp , Priv_bits *result ) ;
#line 102
extern Success fparse_personal_flags(FILE *fp , Personal_flags *result ) ;
#line 106
extern Success fparse_conf_type(FILE *fp , Conf_type *result ) ;
#line 111
extern Success fparse_who_info(FILE *fp , Who_info *result ) ;
#line 116
extern Success fparse_who_info_list(FILE *fp , Who_info_list *result ) ;
#line 120
extern Success fparse_aux_item_flags(FILE *fp , Aux_item_flags *f ) ;
#line 124
extern Success fparse_aux_item_link(FILE *fp , Aux_item_link *link ) ;
#line 127
extern Success fparse_aux_item(FILE *fp , Aux_item *item ) ;
#line 131
extern Success fparse_aux_item_list(FILE *fp , Aux_item_list *result ) ;
#line 135
extern Success fparse_misc_info(FILE *fp , Misc_info *result ) ;
#line 53 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static int input_format  =    2;
#line 55
static Success fparse_text_list(FILE *fp , Local_to_global *result ) ;
#line 57 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
void set_input_format(int fmt ) 
{ 


  {
#line 60
  input_format = fmt;
  {
#line 65
  if (fmt == 2) {
#line 65
    goto case_2;
  }
#line 65
  if (fmt == 1) {
#line 65
    goto case_2;
  }
#line 65
  if (fmt == 0) {
#line 65
    goto case_2;
  }
#line 67
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 66
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 68
  restart_kom("unknown input format selected: %d\n", fmt);
  }
#line 69
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 82 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static int fparse_long_errors  =    0;
#line 84 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
void fskipwhite(FILE *fp ) 
{ 
  int c ;
  unsigned short const   **tmp ;

  {
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 89
    c = _IO_getc(fp);
    }
#line 89
    if (c != -1) {
      {
#line 89
      tmp = __ctype_b_loc();
      }
#line 89
      if (! ((int const   )*(*tmp + c) & 8192)) {
#line 89
        goto while_break;
      }
    } else {
#line 89
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  ungetc(c, fp);
  }
#line 93
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern unsigned long fparse_long(FILE *fp ) 
{ 
  unsigned long res ;
  int foo ;
  int c ;
  unsigned short const   **tmp ;
  long tmp___0 ;

  {
  {
#line 98
  res = 0UL;
#line 99
  foo = 0;
#line 102
  fskipwhite(fp);
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    c = _IO_getc(fp);
    }
#line 103
    if (c != -1) {
      {
#line 103
      tmp = __ctype_b_loc();
      }
#line 103
      if (! ((int const   )*(*tmp + c) & 2048)) {
#line 103
        goto while_break;
      }
    } else {
#line 103
      goto while_break;
    }
#line 105
    foo = 1;
#line 106
    res = (10UL * res + (unsigned long )c) - 48UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  if (foo == 0) {
    {
#line 111
    tmp___0 = ftell(fp);
#line 111
    kom_log("fparse_long() failed at pos %lu.\n", (unsigned long )tmp___0);
#line 112
    fparse_long_errors ++;
    }
  }
  {
#line 115
  ungetc(c, fp);
  }
#line 117
  return (res);
}
}
#line 120 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern time_t fparse_time(FILE *fp ) 
{ 
  unsigned long tmp ;

  {
  {
#line 123
  tmp = fparse_long(fp);
  }
#line 123
  return ((time_t )tmp);
}
}
#line 126 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_info_0(FILE *fp , Info *info ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 129
  tmp = fparse_long(fp);
#line 129
  info->conf_pres_conf = (Conf_no )tmp;
#line 130
  tmp___0 = fparse_long(fp);
#line 130
  info->pers_pres_conf = (Conf_no )tmp___0;
#line 131
  tmp___1 = fparse_long(fp);
#line 131
  info->motd_conf = (Conf_no )tmp___1;
#line 132
  tmp___2 = fparse_long(fp);
#line 132
  info->kom_news_conf = (Conf_no )tmp___2;
#line 133
  info->motd_of_lyskom = fparse_long(fp);
  }
#line 135
  return ((Success )OK);
}
}
#line 138 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_info_2(FILE *fp , Info *info ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  Success tmp___3 ;

  {
  {
#line 141
  tmp = fparse_long(fp);
#line 141
  info->conf_pres_conf = (Conf_no )tmp;
#line 142
  tmp___0 = fparse_long(fp);
#line 142
  info->pers_pres_conf = (Conf_no )tmp___0;
#line 143
  tmp___1 = fparse_long(fp);
#line 143
  info->motd_conf = (Conf_no )tmp___1;
#line 144
  tmp___2 = fparse_long(fp);
#line 144
  info->kom_news_conf = (Conf_no )tmp___2;
#line 145
  info->motd_of_lyskom = fparse_long(fp);
#line 146
  info->highest_aux_no = fparse_long(fp);
#line 147
  free_aux_item_list(& info->aux_item_list);
#line 148
  tmp___3 = fparse_aux_item_list(fp, & info->aux_item_list);
  }
#line 148
  return (tmp___3);
}
}
#line 151 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_info(FILE *fp , Info *info ) 
{ 
  Success tmp ;
  Success tmp___0 ;

  {
#line 154
  if (fparse_long_errors != 0) {
    {
#line 156
    kom_log("fparse_info(): fparse_long_errors == %d on entry. Reset.\n", fparse_long_errors);
#line 158
    fparse_long_errors = 0;
    }
  }
  {
#line 164
  if (input_format == 1) {
#line 164
    goto case_1;
  }
#line 164
  if (input_format == 0) {
#line 164
    goto case_1;
  }
#line 167
  if (input_format == 2) {
#line 167
    goto case_2;
  }
#line 170
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 165
  tmp = fparse_info_0(fp, info);
  }
#line 165
  return (tmp);
#line 166
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 168
  tmp___0 = fparse_info_2(fp, info);
  }
#line 168
  return (tmp___0);
#line 169
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 171
  restart_kom("unknown input format: %d\n", input_format);
  }
#line 172
  return ((Success )FAILURE);
#line 173
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 175
  return ((struct success  const  *)0);
}
}
#line 179 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_conference_2(FILE *fp , Conference *result ) 
{ 
  Success tmp ;
  Success tmp___0 ;
  Success tmp___1 ;
  Success tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  Success tmp___7 ;

  {
#line 183
  if (fparse_long_errors != 0) {
    {
#line 185
    kom_log("fparse_conference(): fparse_long_errors == %d on entry. Reset.\n", fparse_long_errors);
#line 187
    fparse_long_errors = 0;
    }
  }
  {
#line 190
  tmp = fparse_string(fp, & result->name);
  }
#line 190
  if ((unsigned long )tmp != (unsigned long )OK) {
    {
#line 192
    kom_log("fparse_conference(): Can\'t parse name.\n");
    }
#line 193
    return ((Success )FAILURE);
  }
  {
#line 196
  tmp___0 = fparse_member_list(fp, & result->members);
  }
#line 196
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 200
    kom_log("fparse_conference: file is corrupt.\n");
    }
#line 201
    return ((Success )FAILURE);
  } else {
    {
#line 196
    tmp___1 = l2g_read(fp, & result->texts);
    }
#line 196
    if ((unsigned long )tmp___1 != (unsigned long )OK) {
      {
#line 200
      kom_log("fparse_conference: file is corrupt.\n");
      }
#line 201
      return ((Success )FAILURE);
    } else {
      {
#line 196
      tmp___2 = fparse_conf_type(fp, & result->type);
      }
#line 196
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
        {
#line 200
        kom_log("fparse_conference: file is corrupt.\n");
        }
#line 201
        return ((Success )FAILURE);
      }
    }
  }
  {
#line 204
  result->creation_time = fparse_time(fp);
#line 205
  result->last_written = fparse_time(fp);
#line 207
  tmp___3 = fparse_long(fp);
#line 207
  result->creator = (Pers_no )tmp___3;
#line 208
  result->presentation = fparse_long(fp);
#line 209
  tmp___4 = fparse_long(fp);
#line 209
  result->supervisor = (Conf_no )tmp___4;
#line 210
  tmp___5 = fparse_long(fp);
#line 210
  result->permitted_submitters = (Conf_no )tmp___5;
#line 211
  tmp___6 = fparse_long(fp);
#line 211
  result->super_conf = (Conf_no )tmp___6;
#line 212
  result->msg_of_day = fparse_long(fp);
  }
#line 214
  if (fparse_long_errors != 0) {
    {
#line 216
    kom_log("fparse_conference(): %d %s before \'nice\'. Reset.\n", fparse_long_errors,
            "fparse_long_errors");
#line 218
    fparse_long_errors = 0;
    }
#line 219
    return ((Success )FAILURE);
  }
  {
#line 222
  result->nice = fparse_long(fp);
#line 224
  result->keep_commented = fparse_long(fp);
#line 225
  result->expire = fparse_long(fp);
#line 226
  result->highest_aux = fparse_long(fp);
#line 227
  tmp___7 = fparse_aux_item_list(fp, & result->aux_item_list);
  }
#line 227
  if ((unsigned long )tmp___7 != (unsigned long )OK) {
#line 228
    return ((Success )FAILURE);
  }
  {
#line 229
  fskipwhite(fp);
  }
#line 231
  return ((Success )OK);
}
}
#line 235 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_conference_0(FILE *fp , Conference *result ) 
{ 
  Success tmp ;
  Success tmp___0 ;
  Success tmp___1 ;
  Success tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;

  {
#line 239
  if (fparse_long_errors != 0) {
    {
#line 241
    kom_log("fparse_conference(): fparse_long_errors == %d on entry. Reset.\n", fparse_long_errors);
#line 243
    fparse_long_errors = 0;
    }
  }
  {
#line 246
  tmp = fparse_string(fp, & result->name);
  }
#line 246
  if ((unsigned long )tmp != (unsigned long )OK) {
    {
#line 248
    kom_log("fparse_conference(): Can\'t parse name.\n");
    }
#line 249
    return ((Success )FAILURE);
  }
  {
#line 252
  tmp___0 = fparse_member_list(fp, & result->members);
  }
#line 252
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 256
    kom_log("fparse_conference: file is corrupt.\n");
    }
#line 257
    return ((Success )FAILURE);
  } else {
    {
#line 252
    tmp___1 = fparse_text_list(fp, & result->texts);
    }
#line 252
    if ((unsigned long )tmp___1 != (unsigned long )OK) {
      {
#line 256
      kom_log("fparse_conference: file is corrupt.\n");
      }
#line 257
      return ((Success )FAILURE);
    } else {
      {
#line 252
      tmp___2 = fparse_conf_type(fp, & result->type);
      }
#line 252
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
        {
#line 256
        kom_log("fparse_conference: file is corrupt.\n");
        }
#line 257
        return ((Success )FAILURE);
      }
    }
  }
  {
#line 260
  result->creation_time = fparse_time(fp);
#line 261
  result->last_written = fparse_time(fp);
#line 263
  tmp___3 = fparse_long(fp);
#line 263
  result->creator = (Pers_no )tmp___3;
#line 264
  result->presentation = fparse_long(fp);
#line 265
  tmp___4 = fparse_long(fp);
#line 265
  result->supervisor = (Conf_no )tmp___4;
#line 266
  tmp___5 = fparse_long(fp);
#line 266
  result->permitted_submitters = (Conf_no )tmp___5;
#line 267
  tmp___6 = fparse_long(fp);
#line 267
  result->super_conf = (Conf_no )tmp___6;
#line 268
  result->msg_of_day = fparse_long(fp);
  }
#line 270
  if (fparse_long_errors != 0) {
    {
#line 272
    kom_log("fparse_conference(): %d %s before \'nice\'. Reset.\n", fparse_long_errors,
            "fparse_long_errors");
#line 274
    fparse_long_errors = 0;
    }
#line 275
    return ((Success )FAILURE);
  }
  {
#line 278
  result->nice = fparse_long(fp);
#line 279
  result->highest_aux = 0UL;
#line 280
  result->aux_item_list.length = (unsigned short)0;
#line 281
  result->aux_item_list.items = (Aux_item *)0;
#line 283
  fskipwhite(fp);
  }
#line 284
  return ((Success )OK);
}
}
#line 287 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_conference(FILE *fp , Conference *result ) 
{ 
  Success tmp ;
  Success tmp___0 ;

  {
  {
#line 294
  if (input_format == 1) {
#line 294
    goto case_1;
  }
#line 294
  if (input_format == 0) {
#line 294
    goto case_1;
  }
#line 297
  if (input_format == 2) {
#line 297
    goto case_2;
  }
#line 300
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 295
  tmp = fparse_conference_0(fp, result);
  }
#line 295
  return (tmp);
#line 296
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 298
  tmp___0 = fparse_conference_2(fp, result);
  }
#line 298
  return (tmp___0);
#line 299
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 301
  restart_kom("unknown input format: %d\n", input_format);
  }
#line 302
  return ((Success )FAILURE);
#line 303
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 305
  return ((struct success  const  *)0);
}
}
#line 308 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_person_0(FILE *fp , Person *person ) 
{ 
  String pwd ;
  Success tmp ;
  Success tmp___0 ;
  Success tmp___1 ;
  Success tmp___2 ;
  Success tmp___3 ;
  Success tmp___4 ;
  Success tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;

  {
#line 312
  pwd = EMPTY_STRING;
#line 314
  if (fparse_long_errors != 0) {
    {
#line 316
    kom_log("fparse_person(): fparse_long_errors == %d on entry. Reset.\n", fparse_long_errors);
#line 318
    fparse_long_errors = 0;
    }
  }
  {
#line 321
  tmp = fparse_string(fp, & pwd);
  }
#line 321
  if ((unsigned long )tmp != (unsigned long )OK) {
    {
#line 323
    kom_log("fparse_person(): Failed to parse password.\n");
    }
#line 324
    return ((Success )FAILURE);
  }
  {
#line 327
  memcpy((void */* __restrict  */)(person->pwd), (void const   */* __restrict  */)pwd.string,
         (size_t )64);
#line 328
  s_clear(& pwd);
#line 330
  tmp___0 = fparse_string(fp, & person->username);
  }
#line 330
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 337
    kom_log("fparse_person(): parse error.\n");
    }
#line 338
    return ((Success )FAILURE);
  } else {
    {
#line 330
    tmp___1 = fparse_priv_bits(fp, & person->privileges);
    }
#line 330
    if ((unsigned long )tmp___1 != (unsigned long )OK) {
      {
#line 337
      kom_log("fparse_person(): parse error.\n");
      }
#line 338
      return ((Success )FAILURE);
    } else {
      {
#line 330
      tmp___2 = fparse_personal_flags(fp, & person->flags);
      }
#line 330
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
        {
#line 337
        kom_log("fparse_person(): parse error.\n");
        }
#line 338
        return ((Success )FAILURE);
      } else {
        {
#line 330
        tmp___3 = fparse_text_list(fp, & person->created_texts);
        }
#line 330
        if ((unsigned long )tmp___3 != (unsigned long )OK) {
          {
#line 337
          kom_log("fparse_person(): parse error.\n");
          }
#line 338
          return ((Success )FAILURE);
        } else {
          {
#line 330
          tmp___4 = fparse_mark_list(fp, & person->marks);
          }
#line 330
          if ((unsigned long )tmp___4 != (unsigned long )OK) {
            {
#line 337
            kom_log("fparse_person(): parse error.\n");
            }
#line 338
            return ((Success )FAILURE);
          } else {
            {
#line 330
            tmp___5 = fparse_membership_list(fp, & person->conferences);
            }
#line 330
            if ((unsigned long )tmp___5 != (unsigned long )OK) {
              {
#line 337
              kom_log("fparse_person(): parse error.\n");
              }
#line 338
              return ((Success )FAILURE);
            }
          }
        }
      }
    }
  }
  {
#line 341
  person->last_login = fparse_time(fp);
#line 343
  person->user_area = fparse_long(fp);
#line 344
  person->total_time_present = fparse_long(fp);
#line 345
  person->sessions = fparse_long(fp);
#line 346
  person->created_lines = fparse_long(fp);
#line 347
  person->created_bytes = fparse_long(fp);
#line 348
  person->read_texts = fparse_long(fp);
#line 349
  person->no_of_text_fetches = fparse_long(fp);
#line 350
  tmp___6 = fparse_long(fp);
#line 350
  person->created_persons = (unsigned short )tmp___6;
  }
#line 352
  if (fparse_long_errors != 0) {
    {
#line 354
    kom_log("fparse_person(): %d %s before \'created_confs\'. Reset.\n", fparse_long_errors,
            "fparse_long_errors");
#line 356
    fparse_long_errors = 0;
    }
#line 357
    return ((Success )FAILURE);
  }
  {
#line 360
  tmp___7 = fparse_long(fp);
#line 360
  person->created_confs = (unsigned short )tmp___7;
#line 362
  fskipwhite(fp);
  }
#line 363
  return ((Success )OK);
}
}
#line 366 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_person_2(FILE *fp , Person *person ) 
{ 
  String pwd ;
  Success tmp ;
  Success tmp___0 ;
  Success tmp___1 ;
  Success tmp___2 ;
  Success tmp___3 ;
  Success tmp___4 ;
  Success tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;

  {
#line 370
  pwd = EMPTY_STRING;
#line 372
  if (fparse_long_errors != 0) {
    {
#line 374
    kom_log("fparse_person(): fparse_long_errors == %d on entry. Reset.\n", fparse_long_errors);
#line 376
    fparse_long_errors = 0;
    }
  }
  {
#line 379
  tmp = fparse_string(fp, & pwd);
  }
#line 379
  if ((unsigned long )tmp != (unsigned long )OK) {
    {
#line 381
    kom_log("fparse_person(): Failed to parse password.\n");
    }
#line 382
    return ((Success )FAILURE);
  }
  {
#line 385
  memcpy((void */* __restrict  */)(person->pwd), (void const   */* __restrict  */)pwd.string,
         (size_t )64);
#line 386
  s_clear(& pwd);
#line 388
  tmp___0 = fparse_string(fp, & person->username);
  }
#line 388
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 395
    kom_log("fparse_person(): parse error.\n");
    }
#line 396
    return ((Success )FAILURE);
  } else {
    {
#line 388
    tmp___1 = fparse_priv_bits(fp, & person->privileges);
    }
#line 388
    if ((unsigned long )tmp___1 != (unsigned long )OK) {
      {
#line 395
      kom_log("fparse_person(): parse error.\n");
      }
#line 396
      return ((Success )FAILURE);
    } else {
      {
#line 388
      tmp___2 = fparse_personal_flags(fp, & person->flags);
      }
#line 388
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
        {
#line 395
        kom_log("fparse_person(): parse error.\n");
        }
#line 396
        return ((Success )FAILURE);
      } else {
        {
#line 388
        tmp___3 = l2g_read(fp, & person->created_texts);
        }
#line 388
        if ((unsigned long )tmp___3 != (unsigned long )OK) {
          {
#line 395
          kom_log("fparse_person(): parse error.\n");
          }
#line 396
          return ((Success )FAILURE);
        } else {
          {
#line 388
          tmp___4 = fparse_mark_list(fp, & person->marks);
          }
#line 388
          if ((unsigned long )tmp___4 != (unsigned long )OK) {
            {
#line 395
            kom_log("fparse_person(): parse error.\n");
            }
#line 396
            return ((Success )FAILURE);
          } else {
            {
#line 388
            tmp___5 = fparse_membership_list(fp, & person->conferences);
            }
#line 388
            if ((unsigned long )tmp___5 != (unsigned long )OK) {
              {
#line 395
              kom_log("fparse_person(): parse error.\n");
              }
#line 396
              return ((Success )FAILURE);
            }
          }
        }
      }
    }
  }
  {
#line 399
  person->last_login = fparse_time(fp);
#line 401
  person->user_area = fparse_long(fp);
#line 402
  person->total_time_present = fparse_long(fp);
#line 403
  person->sessions = fparse_long(fp);
#line 404
  person->created_lines = fparse_long(fp);
#line 405
  person->created_bytes = fparse_long(fp);
#line 406
  person->read_texts = fparse_long(fp);
#line 407
  person->no_of_text_fetches = fparse_long(fp);
#line 408
  tmp___6 = fparse_long(fp);
#line 408
  person->created_persons = (unsigned short )tmp___6;
  }
#line 410
  if (fparse_long_errors != 0) {
    {
#line 412
    kom_log("fparse_person(): %d %s before \'created_confs\'. Reset.\n", fparse_long_errors,
            "fparse_long_errors");
#line 414
    fparse_long_errors = 0;
    }
#line 415
    return ((Success )FAILURE);
  }
  {
#line 418
  tmp___7 = fparse_long(fp);
#line 418
  person->created_confs = (unsigned short )tmp___7;
#line 420
  fskipwhite(fp);
  }
#line 422
  return ((Success )OK);
}
}
#line 425 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_person(FILE *fp , Person *result ) 
{ 
  Success tmp ;
  Success tmp___0 ;

  {
  {
#line 432
  if (input_format == 1) {
#line 432
    goto case_1;
  }
#line 432
  if (input_format == 0) {
#line 432
    goto case_1;
  }
#line 435
  if (input_format == 2) {
#line 435
    goto case_2;
  }
#line 438
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 433
  tmp = fparse_person_0(fp, result);
  }
#line 433
  return (tmp);
#line 434
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 436
  tmp___0 = fparse_person_2(fp, result);
  }
#line 436
  return (tmp___0);
#line 437
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 439
  restart_kom("unknown input format: %d\n", input_format);
  }
#line 440
  return ((Success )FAILURE);
#line 441
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 443
  return ((struct success  const  *)0);
}
}
#line 445 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_membership_type(FILE *fp , Membership_type *result ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 449
  fskipwhite(fp);
#line 451
  tmp = _IO_getc(fp);
#line 451
  result->invitation = (unsigned int )(tmp != 48);
#line 452
  tmp___0 = _IO_getc(fp);
#line 452
  result->passive = (unsigned int )(tmp___0 != 48);
#line 453
  tmp___1 = _IO_getc(fp);
#line 453
  result->secret = (unsigned int )(tmp___1 != 48);
#line 454
  tmp___2 = _IO_getc(fp);
#line 454
  result->passive_message_invert = (unsigned int )(tmp___2 != 48);
#line 455
  tmp___3 = _IO_getc(fp);
#line 455
  result->reserved2 = (unsigned int )(tmp___3 != 48);
#line 456
  tmp___4 = _IO_getc(fp);
#line 456
  result->reserved3 = (unsigned int )(tmp___4 != 48);
#line 457
  tmp___5 = _IO_getc(fp);
#line 457
  result->reserved4 = (unsigned int )(tmp___5 != 48);
#line 458
  tmp___6 = _IO_getc(fp);
#line 458
  result->reserved5 = (unsigned int )(tmp___6 != 48);
  }
#line 460
  return ((Success )OK);
}
}
#line 464 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_read_range_0(FILE *fp , Membership *mship ) 
{ 
  Local_text_no last_text_read___0 ;
  unsigned int no_of_read ;
  unsigned int i ;
  unsigned int n ;
  struct read_range *res ;
  struct read_range *tail ;
  Local_text_no tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  Local_text_no tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
  {
#line 478
  last_text_read___0 = fparse_long(fp);
#line 479
  tmp___0 = fparse_long(fp);
#line 479
  no_of_read = (unsigned int )tmp___0;
#line 481
  sfree((void *)mship->read_ranges);
  }
#line 482
  if (last_text_read___0 == 0UL) {
#line 484
    mship->read_ranges = (struct read_range *)((void *)0);
#line 485
    mship->no_of_read_ranges = 0U;
  } else {
    {
#line 489
    mship->no_of_read_ranges = 1U;
#line 490
    tmp___1 = smalloc(sizeof(*(mship->read_ranges + 0)));
#line 490
    mship->read_ranges = (struct read_range *)tmp___1;
#line 491
    (mship->read_ranges)->first_read = (Local_text_no )1;
#line 492
    (mship->read_ranges)->last_read = last_text_read___0;
    }
  }
#line 495
  if (no_of_read > 0U) {
    {
#line 497
    fskipwhite(fp);
#line 498
    tmp___2 = _IO_getc(fp);
    }
    {
#line 500
    if (tmp___2 == 123) {
#line 500
      goto case_123;
    }
#line 537
    if (tmp___2 == 42) {
#line 537
      goto case_42;
    }
#line 543
    goto switch_default;
    case_123: /* CIL Label */ 
#line 501
    n = mship->no_of_read_ranges;
#line 502
    res = mship->read_ranges;
#line 502
    tail = res;
#line 504
    i = 0U;
    {
#line 504
    while (1) {
      while_continue: /* CIL Label */ ;
#line 504
      if (! (i < no_of_read)) {
#line 504
        goto while_break;
      }
      {
#line 506
      tmp = fparse_long(fp);
      }
#line 507
      if ((unsigned long )tail != (unsigned long )((void *)0)) {
#line 507
        if (tmp <= tail->last_read) {
          {
#line 509
          kom_log("fparse_read_range_0: discarded out-of-order local number %lu probably introduced by bug 1121\n",
                  tmp);
          }
        } else {
#line 507
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 513
      if ((unsigned long )tail != (unsigned long )((void *)0)) {
#line 513
        if (tmp == tail->last_read + 1UL) {
#line 514
          tail->last_read = tmp;
        } else {
#line 513
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 517
        n ++;
#line 517
        tmp___3 = srealloc((void *)res, (unsigned long )n * sizeof(*res));
#line 517
        res = (struct read_range *)tmp___3;
#line 518
        tail = res + (n - 1U);
#line 519
        tmp___4 = tmp;
#line 519
        tail->last_read = tmp___4;
#line 519
        tail->first_read = tmp___4;
        }
      }
#line 504
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 523
    mship->no_of_read_ranges = n;
#line 524
    mship->read_ranges = res;
#line 526
    fskipwhite(fp);
#line 527
    tmp___6 = _IO_getc(fp);
    }
#line 527
    if (tmp___6 != 125) {
      {
#line 529
      err_stat = 1UL;
#line 530
      kom_errno = (enum kom_err )24;
#line 531
      tmp___5 = ftell(fp);
#line 531
      kom_log("fparse_read_range_0(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___5);
      }
#line 533
      return ((Success )FAILURE);
    }
#line 535
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 538
    kom_log("fparse_read_range_0(): empty read_ranges with %lu elements (corrected)\n",
            (unsigned long )no_of_read);
#line 541
    mship->no_of_read_ranges = 0U;
    }
#line 542
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 544
    tmp___7 = ftell(fp);
#line 544
    kom_log("fparse_read_range_0(): expected \'*\' or \'{\' at pos %lu.\n", (unsigned long )tmp___7);
#line 546
    err_stat = 2UL;
#line 547
    kom_errno = (enum kom_err )24;
    }
#line 548
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 553
    fskipwhite(fp);
#line 554
    tmp___9 = _IO_getc(fp);
    }
#line 554
    if (tmp___9 != 42) {
      {
#line 556
      tmp___8 = ftell(fp);
#line 556
      kom_log("fparse_read_range_0(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___8);
#line 558
      err_stat = 3UL;
#line 559
      kom_errno = (enum kom_err )24;
      }
#line 560
      return ((Success )FAILURE);
    }
  }
#line 563
  return ((Success )OK);
}
}
#line 566 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_membership_2(FILE *fp , Membership *mship ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  Success tmp___1 ;
  unsigned long tmp___2 ;
  Success tmp___3 ;

  {
  {
#line 570
  mship->last_time_read = fparse_time(fp);
#line 572
  tmp = fparse_long(fp);
#line 572
  mship->conf_no = (Conf_no )tmp;
#line 573
  tmp___0 = fparse_long(fp);
#line 573
  mship->priority = (unsigned char )tmp___0;
#line 574
  tmp___1 = fparse_read_range_0(fp, mship);
  }
#line 574
  if ((unsigned long )tmp___1 != (unsigned long )OK) {
#line 575
    return ((Success )FAILURE);
  }
  {
#line 576
  tmp___2 = fparse_long(fp);
#line 576
  mship->added_by = (Pers_no )tmp___2;
#line 577
  mship->added_at = fparse_time(fp);
#line 578
  tmp___3 = fparse_membership_type(fp, & mship->type);
  }
#line 578
  if ((unsigned long )tmp___3 != (unsigned long )OK) {
#line 579
    return ((Success )FAILURE);
  }
#line 581
  return ((Success )OK);
}
}
#line 584 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_membership_0(FILE *fp , Membership *mship ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  Success tmp___1 ;

  {
  {
#line 588
  mship->last_time_read = fparse_time(fp);
#line 590
  tmp = fparse_long(fp);
#line 590
  mship->conf_no = (Conf_no )tmp;
#line 591
  tmp___0 = fparse_long(fp);
#line 591
  mship->priority = (unsigned char )tmp___0;
#line 592
  tmp___1 = fparse_read_range_0(fp, mship);
  }
#line 592
  if ((unsigned long )tmp___1 != (unsigned long )OK) {
#line 593
    return ((Success )FAILURE);
  }
#line 595
  return ((Success )OK);
}
}
#line 598 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_membership(FILE *fp , Membership *mship ) 
{ 
  Success tmp ;
  Success tmp___0 ;

  {
  {
#line 605
  if (input_format == 1) {
#line 605
    goto case_1;
  }
#line 605
  if (input_format == 0) {
#line 605
    goto case_1;
  }
#line 608
  if (input_format == 2) {
#line 608
    goto case_2;
  }
#line 611
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 606
  tmp = fparse_membership_0(fp, mship);
  }
#line 606
  return (tmp);
#line 607
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 609
  tmp___0 = fparse_membership_2(fp, mship);
  }
#line 609
  return (tmp___0);
#line 610
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 612
  restart_kom("unknown input format: %d\n", input_format);
  }
#line 613
  return ((Success )FAILURE);
#line 614
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 616
  return ((struct success  const  *)0);
}
}
#line 620 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_membership_list_0(FILE *fp , Membership_list *result ) 
{ 
  int i ;
  unsigned long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  Success tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
#line 628
  if ((unsigned long )result->confs != (unsigned long )((void *)0)) {
#line 630
    i = 0;
    {
#line 630
    while (1) {
      while_continue: /* CIL Label */ ;
#line 630
      if (! (i < (int )result->no_of_confs)) {
#line 630
        goto while_break;
      }
      {
#line 631
      sfree((void *)(result->confs + i)->read_ranges);
#line 630
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 634
  tmp = fparse_long(fp);
#line 634
  result->no_of_confs = (unsigned short )tmp;
  }
#line 636
  if ((int )result->no_of_confs > 0) {
    {
#line 638
    fskipwhite(fp);
#line 639
    tmp___0 = _IO_getc(fp);
    }
    {
#line 641
    if (tmp___0 == 123) {
#line 641
      goto case_123;
    }
#line 670
    if (tmp___0 == 42) {
#line 670
      goto case_42;
    }
#line 682
    goto switch_default;
    case_123: /* CIL Label */ 
    {
#line 642
    tmp___1 = srealloc((void *)result->confs, (unsigned long )result->no_of_confs * sizeof(Membership ));
#line 642
    result->confs = (Membership *)tmp___1;
    }
#line 645
    if ((unsigned long )result->confs == (unsigned long )((void *)0)) {
#line 645
      if ((int )result->no_of_confs > 0) {
#line 647
        err_stat = 0UL;
#line 648
        kom_errno = (enum kom_err )39;
#line 649
        return ((Success )FAILURE);
      }
    }
#line 652
    i = 0;
    {
#line 652
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 652
      if (! (i < (int )result->no_of_confs)) {
#line 652
        goto while_break___0;
      }
      {
#line 654
      init_membership(result->confs + i);
#line 655
      tmp___2 = fparse_membership_0(fp, result->confs + i);
      }
#line 655
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
#line 656
        return ((Success )FAILURE);
      }
#line 652
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 659
    fskipwhite(fp);
#line 660
    tmp___4 = _IO_getc(fp);
    }
#line 660
    if (tmp___4 != 125) {
      {
#line 662
      tmp___3 = ftell(fp);
#line 662
      kom_log("fparse_membership_list(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___3);
#line 664
      err_stat = 4UL;
#line 665
      kom_errno = (enum kom_err )24;
      }
#line 666
      return ((Success )FAILURE);
    }
#line 669
    goto switch_break;
    case_42: /* CIL Label */ 
#line 671
    if ((unsigned long )result->confs != (unsigned long )((void *)0)) {
      {
#line 673
      sfree((void *)result->confs);
#line 674
      result->confs = (Membership *)((void *)0);
      }
    }
    {
#line 676
    kom_log("%s empty list with %lu elements (corrected).\n", "fparse_membership_list():",
            (unsigned long )result->no_of_confs);
#line 680
    result->no_of_confs = (unsigned short)0;
    }
#line 681
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 683
    tmp___5 = ftell(fp);
#line 683
    kom_log("fparse_membership_list(): expected \'*\' or \'{\' at pos %lu.\n", (unsigned long )tmp___5);
#line 685
    err_stat = 5UL;
#line 686
    kom_errno = (enum kom_err )24;
    }
#line 687
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 692
    fskipwhite(fp);
#line 693
    tmp___7 = _IO_getc(fp);
    }
#line 693
    if (tmp___7 != 42) {
      {
#line 695
      tmp___6 = ftell(fp);
#line 695
      kom_log("fparse_membership_list(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___6);
#line 697
      err_stat = 6UL;
#line 698
      kom_errno = (enum kom_err )24;
      }
#line 699
      return ((Success )FAILURE);
    }
#line 701
    if ((unsigned long )result->confs != (unsigned long )((void *)0)) {
      {
#line 703
      sfree((void *)result->confs);
#line 704
      result->confs = (Membership *)((void *)0);
      }
    }
  }
#line 707
  return ((Success )OK);
}
}
#line 710 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_membership_list_2(FILE *fp , Membership_list *result ) 
{ 
  int i ;
  unsigned long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  Success tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
#line 718
  if ((unsigned long )result->confs != (unsigned long )((void *)0)) {
#line 720
    i = 0;
    {
#line 720
    while (1) {
      while_continue: /* CIL Label */ ;
#line 720
      if (! (i < (int )result->no_of_confs)) {
#line 720
        goto while_break;
      }
      {
#line 721
      sfree((void *)(result->confs + i)->read_ranges);
#line 720
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 724
  tmp = fparse_long(fp);
#line 724
  result->no_of_confs = (unsigned short )tmp;
  }
#line 726
  if ((int )result->no_of_confs > 0) {
    {
#line 728
    fskipwhite(fp);
#line 729
    tmp___0 = _IO_getc(fp);
    }
    {
#line 731
    if (tmp___0 == 123) {
#line 731
      goto case_123;
    }
#line 760
    if (tmp___0 == 42) {
#line 760
      goto case_42;
    }
#line 772
    goto switch_default;
    case_123: /* CIL Label */ 
    {
#line 732
    tmp___1 = srealloc((void *)result->confs, (unsigned long )result->no_of_confs * sizeof(Membership ));
#line 732
    result->confs = (Membership *)tmp___1;
    }
#line 735
    if ((unsigned long )result->confs == (unsigned long )((void *)0)) {
#line 735
      if ((int )result->no_of_confs > 0) {
#line 737
        err_stat = 0UL;
#line 738
        kom_errno = (enum kom_err )39;
#line 739
        return ((Success )FAILURE);
      }
    }
#line 742
    i = 0;
    {
#line 742
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 742
      if (! (i < (int )result->no_of_confs)) {
#line 742
        goto while_break___0;
      }
      {
#line 744
      init_membership(result->confs + i);
#line 745
      tmp___2 = fparse_membership(fp, result->confs + i);
      }
#line 745
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
#line 746
        return ((Success )FAILURE);
      }
#line 742
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 749
    fskipwhite(fp);
#line 750
    tmp___4 = _IO_getc(fp);
    }
#line 750
    if (tmp___4 != 125) {
      {
#line 752
      tmp___3 = ftell(fp);
#line 752
      kom_log("fparse_membership_list(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___3);
#line 754
      err_stat = 4UL;
#line 755
      kom_errno = (enum kom_err )24;
      }
#line 756
      return ((Success )FAILURE);
    }
#line 759
    goto switch_break;
    case_42: /* CIL Label */ 
#line 761
    if ((unsigned long )result->confs != (unsigned long )((void *)0)) {
      {
#line 763
      sfree((void *)result->confs);
#line 764
      result->confs = (Membership *)((void *)0);
      }
    }
    {
#line 766
    kom_log("%s empty list with %lu elements (corrected).\n", "fparse_membership_list():",
            (unsigned long )result->no_of_confs);
#line 770
    result->no_of_confs = (unsigned short)0;
    }
#line 771
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 773
    tmp___5 = ftell(fp);
#line 773
    kom_log("fparse_membership_list(): expected \'*\' or \'{\' at pos %lu.\n", (unsigned long )tmp___5);
#line 775
    err_stat = 5UL;
#line 776
    kom_errno = (enum kom_err )24;
    }
#line 777
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 782
    fskipwhite(fp);
#line 783
    tmp___7 = _IO_getc(fp);
    }
#line 783
    if (tmp___7 != 42) {
      {
#line 785
      tmp___6 = ftell(fp);
#line 785
      kom_log("fparse_membership_list(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___6);
#line 787
      err_stat = 6UL;
#line 788
      kom_errno = (enum kom_err )24;
      }
#line 789
      return ((Success )FAILURE);
    }
#line 791
    if ((unsigned long )result->confs != (unsigned long )((void *)0)) {
      {
#line 793
      sfree((void *)result->confs);
#line 794
      result->confs = (Membership *)((void *)0);
      }
    }
  }
#line 797
  return ((Success )OK);
}
}
#line 801 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_membership_list(FILE *fp , Membership_list *result ) 
{ 
  Success tmp ;
  Success tmp___0 ;

  {
  {
#line 808
  if (input_format == 1) {
#line 808
    goto case_1;
  }
#line 808
  if (input_format == 0) {
#line 808
    goto case_1;
  }
#line 811
  if (input_format == 2) {
#line 811
    goto case_2;
  }
#line 814
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 809
  tmp = fparse_membership_list_0(fp, result);
  }
#line 809
  return (tmp);
#line 810
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 812
  tmp___0 = fparse_membership_list_2(fp, result);
  }
#line 812
  return (tmp___0);
#line 813
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 815
  restart_kom("unknown input format: %d\n", input_format);
  }
#line 816
  return ((Success )FAILURE);
#line 817
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 819
  return ((struct success  const  *)0);
}
}
#line 823 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_conf_list(FILE *fp , Conf_list_old *result ) 
{ 
  unsigned long i ;
  int tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  Success tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;

  {
  {
#line 829
  result->no_of_conf_nos = fparse_long(fp);
  }
#line 830
  if (result->no_of_conf_nos > 0UL) {
    {
#line 832
    fskipwhite(fp);
#line 833
    tmp = _IO_getc(fp);
    }
    {
#line 835
    if (tmp == 123) {
#line 835
      goto case_123;
    }
#line 860
    if (tmp == 42) {
#line 860
      goto case_42;
    }
#line 867
    goto switch_default;
    case_123: /* CIL Label */ 
    {
#line 836
    tmp___0 = srealloc((void *)result->conf_nos, result->no_of_conf_nos * sizeof(Conf_no ));
#line 836
    result->conf_nos = (Conf_no *)tmp___0;
    }
#line 839
    if ((unsigned long )result->conf_nos == (unsigned long )((void *)0)) {
#line 841
      err_stat = 0UL;
#line 842
      kom_errno = (enum kom_err )39;
#line 843
      return ((Success )FAILURE);
    }
#line 846
    i = 0UL;
    {
#line 846
    while (1) {
      while_continue: /* CIL Label */ ;
#line 846
      if (! (i < result->no_of_conf_nos)) {
#line 846
        goto while_break;
      }
      {
#line 847
      tmp___1 = fparse_long(fp);
#line 847
      *(result->conf_nos + i) = (Conf_no )tmp___1;
#line 846
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 849
    fskipwhite(fp);
#line 850
    tmp___3 = _IO_getc(fp);
    }
#line 850
    if (tmp___3 != 125) {
      {
#line 852
      tmp___2 = ftell(fp);
#line 852
      kom_log("fparse_conf_list(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___2);
#line 854
      err_stat = 7UL;
#line 855
      kom_errno = (enum kom_err )24;
      }
#line 856
      return ((Success )FAILURE);
    }
#line 859
    goto switch_break;
    case_42: /* CIL Label */ 
#line 861
    if ((unsigned long )result->conf_nos != (unsigned long )((void *)0)) {
      {
#line 863
      sfree((void *)result->conf_nos);
#line 864
      result->conf_nos = (Conf_no *)((void *)0);
      }
    }
#line 866
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 868
    tmp___4 = ftell(fp);
#line 868
    kom_log("fparse_conf_list(): expected \'*\' or \'{\' at pos %lu.\n", (unsigned long )tmp___4);
#line 870
    err_stat = 8UL;
#line 871
    kom_errno = (enum kom_err )24;
    }
#line 872
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 877
    fskipwhite(fp);
#line 878
    tmp___6 = _IO_getc(fp);
    }
#line 878
    if (tmp___6 != 42) {
      {
#line 880
      tmp___5 = ftell(fp);
#line 880
      kom_log("fparse_conf_list(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___5);
#line 882
      err_stat = 9UL;
#line 883
      kom_errno = (enum kom_err )24;
      }
#line 884
      return ((Success )FAILURE);
    }
#line 886
    if ((unsigned long )result->conf_nos != (unsigned long )((void *)0)) {
      {
#line 888
      sfree((void *)result->conf_nos);
#line 889
      result->conf_nos = (Conf_no *)((void *)0);
      }
    }
  }
#line 893
  if (result->no_of_conf_nos > 0UL) {
    {
#line 895
    fskipwhite(fp);
#line 896
    tmp___7 = _IO_getc(fp);
    }
    {
#line 898
    if (tmp___7 == 123) {
#line 898
      goto case_123___0;
    }
#line 927
    if (tmp___7 == 42) {
#line 927
      goto case_42___0;
    }
#line 934
    goto switch_default___0;
    case_123___0: /* CIL Label */ 
    {
#line 899
    tmp___8 = srealloc((void *)result->type_of_conf, result->no_of_conf_nos * sizeof(Conf_type ));
#line 899
    result->type_of_conf = (Conf_type *)tmp___8;
    }
#line 903
    if ((unsigned long )result->type_of_conf == (unsigned long )((void *)0)) {
#line 905
      err_stat = 0UL;
#line 906
      kom_errno = (enum kom_err )39;
#line 907
      return ((Success )FAILURE);
    }
#line 910
    i = 0UL;
    {
#line 910
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 910
      if (! (i < result->no_of_conf_nos)) {
#line 910
        goto while_break___0;
      }
      {
#line 911
      tmp___9 = fparse_conf_type(fp, result->type_of_conf + i);
      }
#line 911
      if ((unsigned long )tmp___9 != (unsigned long )OK) {
#line 913
        return ((Success )FAILURE);
      }
#line 910
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 916
    fskipwhite(fp);
#line 917
    tmp___11 = _IO_getc(fp);
    }
#line 917
    if (tmp___11 != 125) {
      {
#line 919
      tmp___10 = ftell(fp);
#line 919
      kom_log("fparse_conf_list(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___10);
#line 921
      err_stat = 10UL;
#line 922
      kom_errno = (enum kom_err )24;
      }
#line 923
      return ((Success )FAILURE);
    }
#line 926
    goto switch_break___0;
    case_42___0: /* CIL Label */ 
#line 928
    if ((unsigned long )result->type_of_conf != (unsigned long )((void *)0)) {
      {
#line 930
      sfree((void *)result->type_of_conf);
#line 931
      result->type_of_conf = (Conf_type *)((void *)0);
      }
    }
#line 933
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 935
    tmp___12 = ftell(fp);
#line 935
    kom_log("fparse_conf_list(): expected \'*\' or \'+\' at pos %lu.\n", (unsigned long )tmp___12);
#line 937
    err_stat = 11UL;
#line 938
    kom_errno = (enum kom_err )24;
    }
#line 939
    return ((Success )FAILURE);
    switch_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 944
    fskipwhite(fp);
#line 945
    tmp___14 = _IO_getc(fp);
    }
#line 945
    if (tmp___14 != 42) {
      {
#line 947
      tmp___13 = ftell(fp);
#line 947
      kom_log("fparse_conf_list(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___13);
#line 949
      err_stat = 12UL;
#line 950
      kom_errno = (enum kom_err )24;
      }
#line 951
      return ((Success )FAILURE);
    }
#line 954
    if ((unsigned long )result->type_of_conf != (unsigned long )((void *)0)) {
      {
#line 956
      sfree((void *)result->type_of_conf);
#line 957
      result->type_of_conf = (Conf_type *)((void *)0);
      }
    }
  }
#line 960
  return ((Success )OK);
}
}
#line 964 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_mark_list(FILE *fp , Mark_list *result ) 
{ 
  int i ;
  unsigned long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  Success tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
  {
#line 970
  tmp = fparse_long(fp);
#line 970
  result->no_of_marks = (unsigned short )tmp;
  }
#line 972
  if ((int )result->no_of_marks > 0) {
    {
#line 974
    fskipwhite(fp);
#line 975
    tmp___0 = _IO_getc(fp);
    }
    {
#line 977
    if (tmp___0 == 123) {
#line 977
      goto case_123;
    }
#line 1007
    if (tmp___0 == 42) {
#line 1007
      goto case_42;
    }
#line 1015
    goto switch_default;
    case_123: /* CIL Label */ 
    {
#line 978
    tmp___1 = srealloc((void *)result->marks, (unsigned long )result->no_of_marks * sizeof(Mark ));
#line 978
    result->marks = (Mark *)tmp___1;
    }
#line 982
    if ((unsigned long )result->marks == (unsigned long )((void *)0)) {
#line 984
      err_stat = 0UL;
#line 985
      kom_errno = (enum kom_err )39;
#line 986
      return ((Success )FAILURE);
    }
#line 989
    i = 0;
    {
#line 989
    while (1) {
      while_continue: /* CIL Label */ ;
#line 989
      if (! (i < (int )result->no_of_marks)) {
#line 989
        goto while_break;
      }
      {
#line 990
      tmp___2 = fparse_mark(fp, result->marks + i);
      }
#line 990
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
#line 992
        return ((Success )FAILURE);
      }
#line 989
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 995
    fskipwhite(fp);
#line 996
    tmp___4 = _IO_getc(fp);
    }
#line 996
    if (tmp___4 != 125) {
      {
#line 998
      tmp___3 = ftell(fp);
#line 998
      kom_log("fparse_mark_list(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___3);
#line 1000
      err_stat = 13UL;
#line 1001
      kom_errno = (enum kom_err )24;
      }
#line 1002
      return ((Success )FAILURE);
    }
#line 1005
    goto switch_break;
    case_42: /* CIL Label */ 
#line 1008
    if ((unsigned long )result->marks != (unsigned long )((void *)0)) {
      {
#line 1010
      sfree((void *)result->marks);
#line 1011
      result->marks = (Mark *)((void *)0);
      }
    }
#line 1013
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1016
    tmp___5 = ftell(fp);
#line 1016
    kom_log("fparse_mark_list(): expected \'*\' or \'{\' at pos %lu.\n", (unsigned long )tmp___5);
#line 1018
    err_stat = 14UL;
#line 1019
    kom_errno = (enum kom_err )24;
    }
#line 1020
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1025
    fskipwhite(fp);
#line 1026
    tmp___7 = _IO_getc(fp);
    }
#line 1026
    if (tmp___7 != 42) {
      {
#line 1028
      tmp___6 = ftell(fp);
#line 1028
      kom_log("fparse_mark_list(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___6);
#line 1030
      err_stat = 15UL;
#line 1031
      kom_errno = (enum kom_err )24;
      }
#line 1032
      return ((Success )FAILURE);
    }
#line 1034
    if ((unsigned long )result->marks != (unsigned long )((void *)0)) {
      {
#line 1036
      sfree((void *)result->marks);
#line 1037
      result->marks = (Mark *)((void *)0);
      }
    }
  }
#line 1040
  return ((Success )OK);
}
}
#line 1043 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_text_stat_2(FILE *fp , Text_stat *result ) 
{ 
  int i ;
  int c ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  void *tmp___5 ;
  Success tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  Success tmp___11 ;

  {
#line 1050
  if (fparse_long_errors != 0) {
    {
#line 1052
    kom_log("fparse_text_stat(): fparse_long_errors == %d on entry. Reset.\n", fparse_long_errors);
#line 1054
    fparse_long_errors = 0;
    }
  }
  {
#line 1057
  result->creation_time = fparse_time(fp);
#line 1059
  tmp = fparse_long(fp);
#line 1059
  result->author = (Pers_no )tmp;
#line 1060
  tmp___0 = fparse_long(fp);
#line 1060
  result->file_pos = (long )tmp___0;
#line 1061
  tmp___1 = fparse_long(fp);
#line 1061
  result->no_of_lines = (unsigned short )tmp___1;
#line 1062
  tmp___2 = fparse_long(fp);
#line 1062
  result->no_of_chars = (String_size )tmp___2;
#line 1063
  tmp___3 = fparse_long(fp);
#line 1063
  result->no_of_marks = (unsigned short )tmp___3;
#line 1064
  tmp___4 = fparse_long(fp);
#line 1064
  result->no_of_misc = (unsigned short )tmp___4;
  }
#line 1066
  if (fparse_long_errors != 0) {
    {
#line 1068
    kom_log("%s(): %d fparse_long_errors before \'misc_items\'. Reset.\n", "fparse_text_stat",
            fparse_long_errors);
#line 1071
    fparse_long_errors = 0;
    }
#line 1072
    return ((Success )FAILURE);
  }
#line 1075
  if ((int )result->no_of_misc > 0) {
    {
#line 1077
    fskipwhite(fp);
#line 1078
    c = _IO_getc(fp);
    }
    {
#line 1080
    if (c == 123) {
#line 1080
      goto case_123;
    }
#line 1109
    if (c == 43) {
#line 1109
      goto case_43;
    }
#line 1109
    if (c == 64) {
#line 1109
      goto case_43;
    }
#line 1115
    if (c == 42) {
#line 1115
      goto case_42;
    }
#line 1123
    goto switch_default;
    case_123: /* CIL Label */ 
    {
#line 1081
    tmp___5 = srealloc((void *)result->misc_items, (unsigned long )result->no_of_misc * sizeof(Misc_info ));
#line 1081
    result->misc_items = (Misc_info *)tmp___5;
    }
#line 1085
    if ((unsigned long )result->misc_items == (unsigned long )((void *)0)) {
#line 1087
      err_stat = 0UL;
#line 1088
      kom_errno = (enum kom_err )39;
#line 1089
      return ((Success )FAILURE);
    }
#line 1092
    i = 0;
    {
#line 1092
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1092
      if (! (i < (int )result->no_of_misc)) {
#line 1092
        goto while_break;
      }
      {
#line 1093
      tmp___6 = fparse_misc_info(fp, result->misc_items + i);
      }
#line 1093
      if ((unsigned long )tmp___6 != (unsigned long )OK) {
#line 1094
        return ((Success )FAILURE);
      }
#line 1092
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1096
    fskipwhite(fp);
#line 1097
    c = _IO_getc(fp);
    }
#line 1097
    if (c != 125) {
      {
#line 1099
      tmp___7 = ftell(fp);
#line 1099
      kom_log("fparse_text_stat(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___7);
#line 1101
      err_stat = 16UL;
#line 1102
      kom_errno = (enum kom_err )24;
      }
#line 1103
      return ((Success )FAILURE);
    }
#line 1106
    goto switch_break;
    case_43: /* CIL Label */ 
    case_64: /* CIL Label */ 
    {
#line 1110
    ungetc(c, fp);
#line 1111
    kom_log("fparse_text_stat(): got \'%c\'; expected \'{\' or \'*\'\n.", c);
#line 1112
    tmp___8 = ftell(fp);
#line 1112
    kom_log("Character ungetc\'d and interpreted as a \'*\'. (pos %lu).\n", (unsigned long )tmp___8);
    }
    case_42: /* CIL Label */ 
#line 1116
    if ((unsigned long )result->misc_items != (unsigned long )((void *)0)) {
      {
#line 1118
      sfree((void *)result->misc_items);
#line 1119
      result->misc_items = (Misc_info *)((void *)0);
      }
    }
#line 1121
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1124
    tmp___9 = ftell(fp);
#line 1124
    kom_log("fparse_text_stat(): expected \'*\' or \'}\' at pos %lu.\n", (unsigned long )tmp___9);
#line 1126
    err_stat = 17UL;
#line 1127
    kom_errno = (enum kom_err )24;
    }
#line 1128
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1133
    fskipwhite(fp);
#line 1134
    c = _IO_getc(fp);
    }
#line 1134
    if (c != 42) {
      {
#line 1136
      tmp___10 = ftell(fp);
#line 1136
      kom_log("fparse_text_stat(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___10);
#line 1138
      err_stat = 18UL;
#line 1139
      kom_errno = (enum kom_err )24;
      }
#line 1140
      return ((Success )FAILURE);
    }
#line 1143
    if ((unsigned long )result->misc_items != (unsigned long )((void *)0)) {
      {
#line 1145
      sfree((void *)result->misc_items);
#line 1146
      result->misc_items = (Misc_info *)((void *)0);
      }
    }
  }
  {
#line 1150
  result->highest_aux = fparse_long(fp);
#line 1151
  tmp___11 = fparse_aux_item_list(fp, & result->aux_item_list);
  }
#line 1151
  if ((unsigned long )tmp___11 != (unsigned long )OK) {
#line 1152
    return ((Success )FAILURE);
  }
  {
#line 1154
  fskipwhite(fp);
  }
#line 1156
  return ((Success )OK);
}
}
#line 1159 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_text_stat_0(FILE *fp , Text_stat *result ) 
{ 
  int i ;
  int c ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  void *tmp___5 ;
  Success tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
#line 1166
  if (fparse_long_errors != 0) {
    {
#line 1168
    kom_log("fparse_text_stat(): fparse_long_errors == %d on entry. Reset.\n", fparse_long_errors);
#line 1170
    fparse_long_errors = 0;
    }
  }
  {
#line 1173
  result->creation_time = fparse_time(fp);
#line 1175
  tmp = fparse_long(fp);
#line 1175
  result->author = (Pers_no )tmp;
#line 1176
  tmp___0 = fparse_long(fp);
#line 1176
  result->file_pos = (long )tmp___0;
#line 1177
  tmp___1 = fparse_long(fp);
#line 1177
  result->no_of_lines = (unsigned short )tmp___1;
#line 1178
  tmp___2 = fparse_long(fp);
#line 1178
  result->no_of_chars = (String_size )tmp___2;
#line 1179
  tmp___3 = fparse_long(fp);
#line 1179
  result->no_of_marks = (unsigned short )tmp___3;
#line 1180
  tmp___4 = fparse_long(fp);
#line 1180
  result->no_of_misc = (unsigned short )tmp___4;
  }
#line 1182
  if (fparse_long_errors != 0) {
    {
#line 1184
    kom_log("%s(): %d fparse_long_errors before \'misc_items\'. Reset.\n", "fparse_text_stat",
            fparse_long_errors);
#line 1187
    fparse_long_errors = 0;
    }
#line 1188
    return ((Success )FAILURE);
  }
#line 1191
  if ((int )result->no_of_misc > 0) {
    {
#line 1193
    fskipwhite(fp);
#line 1194
    c = _IO_getc(fp);
    }
    {
#line 1196
    if (c == 123) {
#line 1196
      goto case_123;
    }
#line 1225
    if (c == 43) {
#line 1225
      goto case_43;
    }
#line 1225
    if (c == 64) {
#line 1225
      goto case_43;
    }
#line 1231
    if (c == 42) {
#line 1231
      goto case_42;
    }
#line 1239
    goto switch_default;
    case_123: /* CIL Label */ 
    {
#line 1197
    tmp___5 = srealloc((void *)result->misc_items, (unsigned long )result->no_of_misc * sizeof(Misc_info ));
#line 1197
    result->misc_items = (Misc_info *)tmp___5;
    }
#line 1201
    if ((unsigned long )result->misc_items == (unsigned long )((void *)0)) {
#line 1203
      err_stat = 0UL;
#line 1204
      kom_errno = (enum kom_err )39;
#line 1205
      return ((Success )FAILURE);
    }
#line 1208
    i = 0;
    {
#line 1208
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1208
      if (! (i < (int )result->no_of_misc)) {
#line 1208
        goto while_break;
      }
      {
#line 1209
      tmp___6 = fparse_misc_info(fp, result->misc_items + i);
      }
#line 1209
      if ((unsigned long )tmp___6 != (unsigned long )OK) {
#line 1210
        return ((Success )FAILURE);
      }
#line 1208
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1212
    fskipwhite(fp);
#line 1213
    c = _IO_getc(fp);
    }
#line 1213
    if (c != 125) {
      {
#line 1215
      tmp___7 = ftell(fp);
#line 1215
      kom_log("fparse_text_stat(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___7);
#line 1217
      err_stat = 19UL;
#line 1218
      kom_errno = (enum kom_err )24;
      }
#line 1219
      return ((Success )FAILURE);
    }
#line 1222
    goto switch_break;
    case_43: /* CIL Label */ 
    case_64: /* CIL Label */ 
    {
#line 1226
    ungetc(c, fp);
#line 1227
    kom_log("fparse_text_stat(): got \'%c\'; expected \'{\' or \'*\'\n.", c);
#line 1228
    tmp___8 = ftell(fp);
#line 1228
    kom_log("Character ungetc\'d and interpreted as a \'*\'. (pos %lu).\n", (unsigned long )tmp___8);
    }
    case_42: /* CIL Label */ 
#line 1232
    if ((unsigned long )result->misc_items != (unsigned long )((void *)0)) {
      {
#line 1234
      sfree((void *)result->misc_items);
#line 1235
      result->misc_items = (Misc_info *)((void *)0);
      }
    }
#line 1237
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1240
    tmp___9 = ftell(fp);
#line 1240
    kom_log("fparse_text_stat(): expected \'*\' or \'}\' at pos %lu.\n", (unsigned long )tmp___9);
#line 1242
    err_stat = 20UL;
#line 1243
    kom_errno = (enum kom_err )24;
    }
#line 1244
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1249
    fskipwhite(fp);
#line 1250
    c = _IO_getc(fp);
    }
#line 1250
    if (c != 42) {
      {
#line 1252
      tmp___10 = ftell(fp);
#line 1252
      kom_log("fparse_text_stat(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___10);
#line 1254
      err_stat = 21UL;
#line 1255
      kom_errno = (enum kom_err )24;
      }
#line 1256
      return ((Success )FAILURE);
    }
#line 1259
    if ((unsigned long )result->misc_items != (unsigned long )((void *)0)) {
      {
#line 1261
      sfree((void *)result->misc_items);
#line 1262
      result->misc_items = (Misc_info *)((void *)0);
      }
    }
  }
  {
#line 1266
  result->highest_aux = 0UL;
#line 1267
  result->aux_item_list.length = (unsigned short)0;
#line 1268
  result->aux_item_list.items = (Aux_item *)((void *)0);
#line 1270
  fskipwhite(fp);
  }
#line 1271
  return ((Success )OK);
}
}
#line 1274 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_text_stat(FILE *fp , Text_stat *result ) 
{ 
  Success tmp ;
  Success tmp___0 ;

  {
  {
#line 1281
  if (input_format == 1) {
#line 1281
    goto case_1;
  }
#line 1281
  if (input_format == 0) {
#line 1281
    goto case_1;
  }
#line 1284
  if (input_format == 2) {
#line 1284
    goto case_2;
  }
#line 1287
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 1282
  tmp = fparse_text_stat_0(fp, result);
  }
#line 1282
  return (tmp);
#line 1283
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1285
  tmp___0 = fparse_text_stat_2(fp, result);
  }
#line 1285
  return (tmp___0);
#line 1286
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1288
  restart_kom("unknown input format: %d\n", input_format);
  }
#line 1289
  return ((Success )FAILURE);
#line 1290
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1292
  return ((struct success  const  *)0);
}
}
#line 1295 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_text_list(FILE *fp , Local_to_global *result ) 
{ 
  unsigned long i ;
  Local_text_no lno ;
  Local_text_no no_of_texts ;
  int tmp ;
  unsigned long tmp___0 ;
  Local_text_no tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1303
  lno = fparse_long(fp);
#line 1304
  no_of_texts = fparse_long(fp);
#line 1305
  l2g_clear(result);
  }
#line 1307
  if (no_of_texts > 0UL) {
    {
#line 1309
    fskipwhite(fp);
#line 1310
    tmp = _IO_getc(fp);
    }
    {
#line 1312
    if (tmp == 123) {
#line 1312
      goto case_123;
    }
#line 1328
    goto switch_default;
    case_123: /* CIL Label */ 
#line 1313
    i = 0UL;
    {
#line 1313
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1313
      if (! (i < no_of_texts)) {
#line 1313
        goto while_break;
      }
      {
#line 1314
      tmp___0 = fparse_long(fp);
#line 1314
      tmp___1 = lno;
#line 1314
      lno ++;
#line 1314
      l2g_append(result, tmp___1, tmp___0);
#line 1313
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1316
    fskipwhite(fp);
#line 1317
    tmp___3 = _IO_getc(fp);
    }
#line 1317
    if (tmp___3 != 125) {
      {
#line 1319
      tmp___2 = ftell(fp);
#line 1319
      kom_log("fparse_text_list(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___2);
#line 1321
      err_stat = 22UL;
#line 1322
      kom_errno = (enum kom_err )24;
      }
#line 1323
      return ((Success )FAILURE);
    }
#line 1326
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1329
    tmp___4 = ftell(fp);
#line 1329
    kom_log("fparse_text_list(): expected \'{\' at pos %lu.\n", (unsigned long )tmp___4);
#line 1331
    err_stat = 23UL;
#line 1332
    kom_errno = (enum kom_err )24;
    }
#line 1333
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1338
    fskipwhite(fp);
#line 1339
    tmp___6 = _IO_getc(fp);
    }
#line 1339
    if (tmp___6 != 42) {
      {
#line 1341
      tmp___5 = ftell(fp);
#line 1341
      kom_log("fparse_text_list(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___5);
#line 1343
      err_stat = 24UL;
#line 1344
      kom_errno = (enum kom_err )24;
      }
#line 1345
      return ((Success )FAILURE);
    }
    {
#line 1347
    l2g_set_first_appendable_key(result, lno);
    }
  }
#line 1349
  return ((Success )OK);
}
}
#line 1353 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_string(FILE *fp , String *result ) 
{ 
  String_size length ;
  unsigned long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 1359
  tmp = fparse_long(fp);
#line 1359
  length = (String_size )tmp;
#line 1361
  tmp___1 = _IO_getc(fp);
  }
#line 1361
  if (tmp___1 != 72) {
    {
#line 1363
    tmp___0 = ftell(fp);
#line 1363
    kom_log("fparse_string(): expected \'H\' at pos %lu.\n", (unsigned long )tmp___0);
#line 1365
    err_stat = 25UL;
#line 1366
    kom_errno = (enum kom_err )24;
    }
#line 1367
    return ((Success )FAILURE);
  }
  {
#line 1370
  s_size_crea_str(result, length);
  }
#line 1372
  if ((unsigned long )result->string == (unsigned long )((void *)0)) {
#line 1374
    err_stat = 0UL;
#line 1375
    kom_errno = (enum kom_err )39;
#line 1376
    return ((Success )FAILURE);
  }
  {
#line 1379
  tmp___3 = fread((void */* __restrict  */)result->string, sizeof(char ), (size_t )result->len,
                  (FILE */* __restrict  */)fp);
  }
#line 1379
  if (tmp___3 != (size_t )result->len) {
    {
#line 1382
    tmp___2 = ftell(fp);
#line 1382
    kom_log("fparse_string(): unexpected eof at pos %lu.\n", (unsigned long )tmp___2);
#line 1384
    err_stat = 26UL;
#line 1385
    kom_errno = (enum kom_err )24;
    }
#line 1386
    return ((Success )FAILURE);
  }
#line 1389
  return ((Success )OK);
}
}
#line 1392 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_member_list(FILE *fp , Member_list *result ) 
{ 
  int i ;
  unsigned long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  Success tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1398
  tmp = fparse_long(fp);
#line 1398
  result->no_of_members = (unsigned short )tmp;
  }
#line 1399
  if ((int )result->no_of_members > 0) {
    {
#line 1401
    fskipwhite(fp);
#line 1402
    tmp___0 = _IO_getc(fp);
    }
    {
#line 1404
    if (tmp___0 == 123) {
#line 1404
      goto case_123;
    }
#line 1438
    if (tmp___0 == 42) {
#line 1438
      goto case_42;
    }
#line 1446
    goto switch_default;
    case_123: /* CIL Label */ 
    {
#line 1405
    tmp___1 = srealloc((void *)result->members, (unsigned long )result->no_of_members * sizeof(Member ));
#line 1405
    result->members = (Member *)tmp___1;
    }
#line 1409
    if ((unsigned long )result->members == (unsigned long )((void *)0)) {
#line 1411
      err_stat = 0UL;
#line 1412
      kom_errno = (enum kom_err )39;
#line 1413
      return ((Success )FAILURE);
    }
#line 1416
    i = 0;
    {
#line 1416
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1416
      if (! (i < (int )result->no_of_members)) {
#line 1416
        goto while_break;
      }
      {
#line 1418
      init_member(result->members + i);
#line 1419
      tmp___2 = fparse_member(fp, result->members + i);
      }
#line 1419
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
#line 1421
        return ((Success )FAILURE);
      }
#line 1416
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1426
    fskipwhite(fp);
#line 1427
    tmp___4 = _IO_getc(fp);
    }
#line 1427
    if (tmp___4 != 125) {
      {
#line 1429
      tmp___3 = ftell(fp);
#line 1429
      kom_log("fparse_member_list(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___3);
#line 1431
      err_stat = 27UL;
#line 1432
      kom_errno = (enum kom_err )24;
      }
#line 1433
      return ((Success )FAILURE);
    }
#line 1436
    goto switch_break;
    case_42: /* CIL Label */ 
#line 1439
    if ((unsigned long )result->members != (unsigned long )((void *)0)) {
      {
#line 1441
      sfree((void *)result->members);
#line 1442
      result->members = (Member *)((void *)0);
      }
    }
#line 1444
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1447
    tmp___5 = ftell(fp);
#line 1447
    kom_log("fparse_member_list(): expected \'*\' or \'{\' at pos %lu.\n", (unsigned long )tmp___5);
#line 1449
    err_stat = 28UL;
#line 1450
    kom_errno = (enum kom_err )24;
    }
#line 1451
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1456
    fskipwhite(fp);
#line 1457
    tmp___7 = _IO_getc(fp);
    }
#line 1457
    if (tmp___7 != 42) {
      {
#line 1459
      tmp___6 = ftell(fp);
#line 1459
      kom_log("fparse_member_list(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___6);
#line 1461
      err_stat = 29UL;
#line 1462
      kom_errno = (enum kom_err )24;
      }
#line 1463
      return ((Success )FAILURE);
    }
#line 1465
    if ((unsigned long )result->members != (unsigned long )((void *)0)) {
      {
#line 1467
      sfree((void *)result->members);
#line 1468
      result->members = (Member *)((void *)0);
      }
    }
  }
#line 1471
  return ((Success )OK);
}
}
#line 1475 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_member_0(FILE *fp , Member *result ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1479
  tmp = fparse_long(fp);
#line 1479
  result->member = (Pers_no )tmp;
  }
#line 1480
  return ((Success )OK);
}
}
#line 1483 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_member_2(FILE *fp , Member *result ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  Success tmp___1 ;

  {
  {
#line 1487
  tmp = fparse_long(fp);
#line 1487
  result->member = (Pers_no )tmp;
#line 1488
  tmp___0 = fparse_long(fp);
#line 1488
  result->added_by = (Pers_no )tmp___0;
#line 1489
  result->added_at = fparse_time(fp);
#line 1490
  tmp___1 = fparse_membership_type(fp, & result->type);
  }
#line 1490
  return (tmp___1);
}
}
#line 1493 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_member(FILE *fp , Member *result ) 
{ 
  Success tmp ;
  Success tmp___0 ;

  {
  {
#line 1500
  if (input_format == 1) {
#line 1500
    goto case_1;
  }
#line 1500
  if (input_format == 0) {
#line 1500
    goto case_1;
  }
#line 1503
  if (input_format == 2) {
#line 1503
    goto case_2;
  }
#line 1506
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 1501
  tmp = fparse_member_0(fp, result);
  }
#line 1501
  return (tmp);
#line 1502
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1504
  tmp___0 = fparse_member_2(fp, result);
  }
#line 1504
  return (tmp___0);
#line 1505
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1507
  restart_kom("unknown database format: %d", input_format);
  }
#line 1508
  return ((Success )FAILURE);
  switch_break: /* CIL Label */ ;
  }
#line 1510
  return ((struct success  const  *)0);
}
}
#line 1512 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_mark(FILE *fp , Mark *result ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1516
  result->text_no = fparse_long(fp);
#line 1517
  tmp = fparse_long(fp);
#line 1517
  result->mark_type = (unsigned char )tmp;
  }
#line 1518
  return ((Success )OK);
}
}
#line 1522 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_priv_bits(FILE *fp , Priv_bits *result ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 1526
  fskipwhite(fp);
#line 1528
  tmp = _IO_getc(fp);
#line 1528
  result->wheel = (unsigned int )(tmp != 48);
#line 1529
  tmp___0 = _IO_getc(fp);
#line 1529
  result->admin = (unsigned int )(tmp___0 != 48);
#line 1530
  tmp___1 = _IO_getc(fp);
#line 1530
  result->statistic = (unsigned int )(tmp___1 != 48);
#line 1531
  tmp___2 = _IO_getc(fp);
#line 1531
  result->create_pers = (unsigned int )(tmp___2 != 48);
#line 1532
  tmp___3 = _IO_getc(fp);
#line 1532
  result->create_conf = (unsigned int )(tmp___3 != 48);
#line 1533
  tmp___4 = _IO_getc(fp);
#line 1533
  result->change_name = (unsigned int )(tmp___4 != 48);
#line 1534
  tmp___5 = _IO_getc(fp);
#line 1534
  result->flg7 = (unsigned int )(tmp___5 != 48);
#line 1535
  tmp___6 = _IO_getc(fp);
#line 1535
  result->flg8 = (unsigned int )(tmp___6 != 48);
#line 1536
  tmp___7 = _IO_getc(fp);
#line 1536
  result->flg9 = (unsigned int )(tmp___7 != 48);
#line 1537
  tmp___8 = _IO_getc(fp);
#line 1537
  result->flg10 = (unsigned int )(tmp___8 != 48);
#line 1538
  tmp___9 = _IO_getc(fp);
#line 1538
  result->flg11 = (unsigned int )(tmp___9 != 48);
#line 1539
  tmp___10 = _IO_getc(fp);
#line 1539
  result->flg12 = (unsigned int )(tmp___10 != 48);
#line 1540
  tmp___11 = _IO_getc(fp);
#line 1540
  result->flg13 = (unsigned int )(tmp___11 != 48);
#line 1541
  tmp___12 = _IO_getc(fp);
#line 1541
  result->flg14 = (unsigned int )(tmp___12 != 48);
#line 1542
  tmp___13 = _IO_getc(fp);
#line 1542
  result->flg15 = (unsigned int )(tmp___13 != 48);
#line 1543
  tmp___14 = _IO_getc(fp);
#line 1543
  result->flg16 = (unsigned int )(tmp___14 != 48);
  }
#line 1545
  return ((Success )OK);
}
}
#line 1549 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_personal_flags(FILE *fp , Personal_flags *result ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1553
  fskipwhite(fp);
#line 1555
  tmp = _IO_getc(fp);
#line 1555
  result->unread_is_secret = (unsigned int )(tmp != 48);
#line 1556
  tmp___0 = _IO_getc(fp);
#line 1556
  result->flg2 = (unsigned int )(tmp___0 != 48);
#line 1557
  tmp___1 = _IO_getc(fp);
#line 1557
  result->flg3 = (unsigned int )(tmp___1 != 48);
#line 1558
  tmp___2 = _IO_getc(fp);
#line 1558
  result->flg4 = (unsigned int )(tmp___2 != 48);
#line 1559
  tmp___3 = _IO_getc(fp);
#line 1559
  result->flg5 = (unsigned int )(tmp___3 != 48);
#line 1560
  tmp___4 = _IO_getc(fp);
#line 1560
  result->flg6 = (unsigned int )(tmp___4 != 48);
#line 1561
  tmp___5 = _IO_getc(fp);
#line 1561
  result->flg7 = (unsigned int )(tmp___5 != 48);
#line 1562
  tmp___6 = _IO_getc(fp);
#line 1562
  result->flg8 = (unsigned int )(tmp___6 != 48);
  }
#line 1564
  return ((Success )OK);
}
}
#line 1567 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_conf_type(FILE *fp , Conf_type *result ) 
{ 
  char c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1573
  fskipwhite(fp);
#line 1575
  tmp = _IO_getc(fp);
#line 1575
  result->rd_prot = (unsigned int )(tmp != 48);
#line 1576
  tmp___0 = _IO_getc(fp);
#line 1576
  result->original = (unsigned int )(tmp___0 != 48);
#line 1577
  tmp___1 = _IO_getc(fp);
#line 1577
  result->secret = (unsigned int )(tmp___1 != 48);
#line 1578
  tmp___2 = _IO_getc(fp);
#line 1578
  result->letter_box = (unsigned int )(tmp___2 != 48);
#line 1579
  tmp___3 = _IO_getc(fp);
#line 1579
  c = (char )tmp___3;
  }
#line 1580
  if ((int )c != 48) {
#line 1580
    if ((int )c != 49) {
      {
#line 1582
      result->allow_anon = 1U;
#line 1583
      result->forbid_secret = 0U;
#line 1584
      result->reserved2 = 0U;
#line 1585
      result->reserved3 = 0U;
#line 1586
      ungetc((int )c, fp);
      }
#line 1587
      return ((Success )OK);
    }
  }
  {
#line 1590
  result->allow_anon = (unsigned int )((int )c != 48);
#line 1591
  tmp___4 = _IO_getc(fp);
#line 1591
  result->forbid_secret = (unsigned int )(tmp___4 != 48);
#line 1592
  tmp___5 = _IO_getc(fp);
#line 1592
  result->reserved2 = (unsigned int )(tmp___5 != 48);
#line 1593
  tmp___6 = _IO_getc(fp);
#line 1593
  result->reserved3 = (unsigned int )(tmp___6 != 48);
  }
#line 1595
  return ((Success )OK);
}
}
#line 1599 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_who_info(FILE *fp , Who_info *result ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  Success tmp___1 ;

  {
  {
#line 1603
  tmp = fparse_long(fp);
#line 1603
  result->person = (Pers_no )tmp;
#line 1604
  tmp___0 = fparse_long(fp);
#line 1604
  result->working_conference = (Conf_no )tmp___0;
#line 1605
  tmp___1 = fparse_string(fp, & result->what_am_i_doing);
  }
#line 1605
  if ((unsigned long )tmp___1 != (unsigned long )OK) {
    {
#line 1607
    kom_log("fparse_who_info(): parse error.\n");
#line 1608
    err_stat = 30UL;
#line 1609
    kom_errno = (enum kom_err )24;
    }
#line 1610
    return ((Success )FAILURE);
  }
#line 1613
  return ((Success )OK);
}
}
#line 1617 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_who_info_list(FILE *fp , Who_info_list *result ) 
{ 
  int i ;
  unsigned long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  Success tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1623
  fskipwhite(fp);
#line 1625
  tmp = fparse_long(fp);
#line 1625
  result->no_of_persons = (int )tmp;
  }
#line 1627
  if (result->no_of_persons > 0) {
    {
#line 1629
    fskipwhite(fp);
#line 1630
    tmp___0 = _IO_getc(fp);
    }
    {
#line 1632
    if (tmp___0 == 123) {
#line 1632
      goto case_123;
    }
#line 1664
    if (tmp___0 == 42) {
#line 1664
      goto case_42;
    }
#line 1672
    goto switch_default;
    case_123: /* CIL Label */ 
    {
#line 1633
    tmp___1 = srealloc((void *)result->info, (unsigned long )result->no_of_persons * sizeof(Who_info ));
#line 1633
    result->info = (Who_info *)tmp___1;
    }
#line 1637
    if ((unsigned long )result->info == (unsigned long )((void *)0)) {
#line 1639
      err_stat = 0UL;
#line 1640
      kom_errno = (enum kom_err )39;
#line 1641
      return ((Success )FAILURE);
    }
#line 1644
    i = 0;
    {
#line 1644
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1644
      if (! (i < result->no_of_persons)) {
#line 1644
        goto while_break;
      }
      {
#line 1646
      init_who_info(result->info + i);
#line 1647
      tmp___2 = fparse_who_info(fp, result->info + i);
      }
#line 1647
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
#line 1648
        return ((Success )FAILURE);
      }
#line 1644
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1652
    fskipwhite(fp);
#line 1653
    tmp___4 = _IO_getc(fp);
    }
#line 1653
    if (tmp___4 != 125) {
      {
#line 1655
      tmp___3 = ftell(fp);
#line 1655
      kom_log("fparse_who_info_list(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___3);
#line 1657
      err_stat = 31UL;
#line 1658
      kom_errno = (enum kom_err )24;
      }
#line 1659
      return ((Success )FAILURE);
    }
#line 1662
    goto switch_break;
    case_42: /* CIL Label */ 
#line 1665
    if ((unsigned long )result->info != (unsigned long )((void *)0)) {
      {
#line 1667
      sfree((void *)result->info);
#line 1668
      result->info = (Who_info *)((void *)0);
      }
    }
#line 1670
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1673
    tmp___5 = ftell(fp);
#line 1673
    kom_log("fparse_who_info_list(): expected \'*\' or \'{\' at pos %lu.\n", (unsigned long )tmp___5);
#line 1675
    err_stat = 32UL;
#line 1676
    kom_errno = (enum kom_err )24;
    }
#line 1677
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1682
    fskipwhite(fp);
#line 1683
    tmp___7 = _IO_getc(fp);
    }
#line 1683
    if (tmp___7 != 42) {
      {
#line 1685
      tmp___6 = ftell(fp);
#line 1685
      kom_log("fparse_who_info_list(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___6);
#line 1687
      err_stat = 33UL;
#line 1688
      kom_errno = (enum kom_err )24;
      }
#line 1689
      return ((Success )FAILURE);
    }
#line 1691
    if ((unsigned long )result->info != (unsigned long )((void *)0)) {
      {
#line 1693
      sfree((void *)result->info);
#line 1694
      result->info = (Who_info *)((void *)0);
      }
    }
  }
#line 1697
  return ((Success )OK);
}
}
#line 1701 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_aux_item_flags(FILE *fp , Aux_item_flags *f ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1705
  fskipwhite(fp);
#line 1707
  tmp = _IO_getc(fp);
#line 1707
  f->deleted = (unsigned int )(tmp != 48);
#line 1708
  tmp___0 = _IO_getc(fp);
#line 1708
  f->inherit = (unsigned int )(tmp___0 != 48);
#line 1709
  tmp___1 = _IO_getc(fp);
#line 1709
  f->secret = (unsigned int )(tmp___1 != 48);
#line 1710
  tmp___2 = _IO_getc(fp);
#line 1710
  f->hide_creator = (unsigned int )(tmp___2 != 48);
#line 1711
  tmp___3 = _IO_getc(fp);
#line 1711
  f->dont_garb = (unsigned int )(tmp___3 != 48);
#line 1712
  tmp___4 = _IO_getc(fp);
#line 1712
  f->reserved3 = (unsigned int )(tmp___4 != 48);
#line 1713
  tmp___5 = _IO_getc(fp);
#line 1713
  f->reserved4 = (unsigned int )(tmp___5 != 48);
#line 1714
  tmp___6 = _IO_getc(fp);
#line 1714
  f->reserved5 = (unsigned int )(tmp___6 != 48);
  }
#line 1716
  return ((Success )OK);
}
}
#line 1719 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_aux_item_link(FILE *fp , Aux_item_link *link ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 1723
  tmp = fparse_long(fp);
#line 1723
  link->target_type = (enum object_type )((long )tmp);
#line 1724
  link->target_item = fparse_long(fp);
  }
  {
#line 1727
  if ((unsigned int )link->target_type == 2U) {
#line 1727
    goto case_2;
  }
#line 1730
  if ((unsigned int )link->target_type == 1U) {
#line 1730
    goto case_1;
  }
#line 1733
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1728
  tmp___0 = fparse_long(fp);
#line 1728
  link->target_object.conf = (Conf_no )tmp___0;
  }
#line 1729
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1731
  tmp___1 = fparse_long(fp);
#line 1731
  link->target_object.text = tmp___1;
  }
#line 1732
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1737
  return ((Success )OK);
}
}
#line 1740 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_aux_item(FILE *fp , Aux_item *item ) 
{ 
  unsigned long tmp ;
  Success tmp___0 ;
  Success tmp___1 ;

  {
  {
#line 1744
  item->aux_no = fparse_long(fp);
#line 1745
  item->tag = fparse_long(fp);
#line 1746
  tmp = fparse_long(fp);
#line 1746
  item->creator = (Pers_no )tmp;
#line 1747
  item->sent_at = fparse_time(fp);
#line 1748
  fparse_aux_item_flags(fp, & item->flags);
#line 1749
  item->inherit_limit = fparse_long(fp);
#line 1750
  item->data = (String )EMPTY_STRING;
#line 1751
  tmp___0 = fparse_string(fp, & item->data);
  }
#line 1751
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 1753
    kom_log("fparse_aux_item(): Can\'t parse name.\n");
    }
#line 1754
    return ((Success )FAILURE);
  }
  {
#line 1757
  tmp___1 = fparse_aux_item_link(fp, & item->linked_item);
  }
#line 1757
  if ((unsigned long )tmp___1 != (unsigned long )OK) {
    {
#line 1759
    kom_log("fparse_aux_item(): Can\'t parse link.\n");
    }
#line 1760
    return ((Success )FAILURE);
  }
#line 1763
  return ((Success )OK);
}
}
#line 1766 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_aux_item_list(FILE *fp , Aux_item_list *result ) 
{ 
  int c ;
  int i ;
  unsigned long tmp ;
  void *tmp___0 ;
  Success tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 1772
  result->items = (Aux_item *)((void *)0);
#line 1773
  tmp = fparse_long(fp);
#line 1773
  result->length = (unsigned short )tmp;
  }
#line 1775
  if (fparse_long_errors != 0) {
    {
#line 1777
    kom_log("%s(): %d fparse_long_errors before \'aux_items\'. Reset.\n", "fparse_text_stat",
            fparse_long_errors);
#line 1780
    fparse_long_errors = 0;
    }
#line 1781
    return ((Success )FAILURE);
  }
#line 1784
  if ((int )result->length > 0) {
    {
#line 1786
    fskipwhite(fp);
#line 1787
    c = _IO_getc(fp);
    }
    {
#line 1789
    if (c == 123) {
#line 1789
      goto case_123;
    }
#line 1817
    if (c == 42) {
#line 1817
      goto case_42;
    }
#line 1826
    goto switch_default;
    case_123: /* CIL Label */ 
    {
#line 1790
    tmp___0 = srealloc((void *)result->items, (unsigned long )result->length * sizeof(Aux_item ));
#line 1790
    result->items = (Aux_item *)tmp___0;
    }
#line 1794
    if ((unsigned long )result->items == (unsigned long )((void *)0)) {
#line 1796
      err_stat = 0UL;
#line 1797
      kom_errno = (enum kom_err )39;
#line 1798
      return ((Success )FAILURE);
    }
#line 1801
    i = 0;
    {
#line 1801
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1801
      if (! (i < (int )result->length)) {
#line 1801
        goto while_break;
      }
      {
#line 1802
      tmp___1 = fparse_aux_item(fp, result->items + i);
      }
#line 1802
      if ((unsigned long )tmp___1 != (unsigned long )OK) {
#line 1803
        return ((Success )FAILURE);
      }
#line 1801
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1805
    fskipwhite(fp);
#line 1806
    c = _IO_getc(fp);
    }
#line 1806
    if (c != 125) {
      {
#line 1808
      tmp___2 = ftell(fp);
#line 1808
      kom_log("fparse_aux_item_list(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___2);
#line 1810
      err_stat = 34UL;
#line 1811
      kom_errno = (enum kom_err )24;
      }
#line 1812
      return ((Success )FAILURE);
    }
#line 1815
    goto switch_break;
    case_42: /* CIL Label */ 
#line 1818
    if ((unsigned long )result->items != (unsigned long )((void *)0)) {
      {
#line 1820
      sfree((void *)result->items);
#line 1821
      result->items = (Aux_item *)((void *)0);
#line 1822
      result->length = (unsigned short)0;
      }
    }
#line 1824
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1827
    tmp___3 = ftell(fp);
#line 1827
    kom_log("fparse_aux_item_list(): expected \'*\' or \'}\' at pos %lu.\n", (unsigned long )tmp___3);
#line 1829
    err_stat = 35UL;
#line 1830
    kom_errno = (enum kom_err )24;
    }
#line 1831
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1836
    fskipwhite(fp);
#line 1837
    c = _IO_getc(fp);
    }
#line 1837
    if (c != 42) {
      {
#line 1839
      tmp___4 = ftell(fp);
#line 1839
      kom_log("fparse_aux_item_list(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___4);
#line 1841
      err_stat = 36UL;
#line 1842
      kom_errno = (enum kom_err )24;
      }
#line 1843
      return ((Success )FAILURE);
    }
#line 1846
    result->items = (Aux_item *)((void *)0);
#line 1847
    result->length = (unsigned short)0;
  }
#line 1849
  return ((Success )OK);
}
}
#line 1853 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
extern Success fparse_misc_info(FILE *fp , Misc_info *result ) 
{ 
  long typ ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1859
  tmp = fparse_long(fp);
#line 1859
  typ = (long )tmp;
  }
  {
#line 1865
  if (typ == 15L) {
#line 1865
    goto case_15;
  }
#line 1865
  if (typ == 1L) {
#line 1865
    goto case_15;
  }
#line 1865
  if (typ == 0L) {
#line 1865
    goto case_15;
  }
#line 1869
  if (typ == 6L) {
#line 1869
    goto case_6;
  }
#line 1873
  if (typ == 7L) {
#line 1873
    goto case_7;
  }
#line 1880
  if (typ == 5L) {
#line 1880
    goto case_5;
  }
#line 1880
  if (typ == 4L) {
#line 1880
    goto case_5;
  }
#line 1880
  if (typ == 3L) {
#line 1880
    goto case_5;
  }
#line 1880
  if (typ == 2L) {
#line 1880
    goto case_5;
  }
#line 1884
  if (typ == 8L) {
#line 1884
    goto case_8;
  }
#line 1888
  if (typ == 9L) {
#line 1888
    goto case_9;
  }
#line 1892
  goto switch_default;
  case_15: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 1866
  tmp___0 = fparse_long(fp);
#line 1866
  result->datum.recipient = (Conf_no )tmp___0;
  }
#line 1867
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1870
  result->datum.local_no = fparse_long(fp);
  }
#line 1871
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1874
  result->datum.received_at = fparse_time(fp);
  }
#line 1875
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 1881
  result->datum.text_link = fparse_long(fp);
  }
#line 1882
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1885
  tmp___1 = fparse_long(fp);
#line 1885
  result->datum.sender = (Pers_no )tmp___1;
  }
#line 1886
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1889
  result->datum.sent_at = fparse_time(fp);
  }
#line 1890
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1893
  tmp___2 = ftell(fp);
#line 1893
  kom_log("fparse_misc_info(): illegal info_type %d at pos %lu.\n", (unsigned int )result->type,
          (unsigned long )tmp___2);
#line 1895
  err_stat = 37UL;
#line 1896
  kom_errno = (enum kom_err )24;
  }
#line 1897
  return ((Success )FAILURE);
  switch_break: /* CIL Label */ ;
  }
#line 1900
  result->type = (enum info_type )typ;
#line 1902
  return ((Success )OK);
}
}
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int *assignment_count___1  =    (int *)((void *)0);
#line 67 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int npar___1  =    0;
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static void init_init___1(struct parameter  const  *par ) 
{ 
  int ix ;
  void *tmp ;

  {
#line 74
  npar___1 = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )(par + npar___1)->name != (unsigned long )((void *)0))) {
#line 74
      goto while_break;
    }
#line 74
    npar___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if (! ((unsigned long )assignment_count___1 == (unsigned long )((void *)0))) {
    {
#line 77
    __assert_fail("assignment_count == ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c",
                  77U, "init_init");
    }
  }
  {
#line 78
  tmp = smalloc((unsigned long )npar___1 * sizeof(*assignment_count___1));
#line 78
  assignment_count___1 = (int *)tmp;
#line 80
  ix = 0;
  }
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (ix < npar___1)) {
#line 80
      goto while_break___0;
    }
#line 81
    *(assignment_count___1 + ix) = 0;
#line 80
    ix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static void assign_defaults___1(struct parameter  const  *par , int *err ) 
{ 
  int ix ;
  Success tmp ;

  {
#line 93
  ix = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (ix < npar___1)) {
#line 93
      goto while_break;
    }
#line 95
    if (*(assignment_count___1 + ix) < (int )(par + ix)->min_assignments) {
      {
#line 97
      kom_log("Parameter %s only assigned %d times (%d times needed)\n", (par + ix)->name,
              *(assignment_count___1 + ix), (par + ix)->min_assignments);
#line 99
      (*err) ++;
      }
    } else
#line 101
    if (*(assignment_count___1 + ix) == 0) {
      {
#line 103
      tmp = (*((par + ix)->assigner))((char const   *)(par + ix)->default_val, par + ix);
      }
#line 103
      if ((unsigned long )tmp != (unsigned long )OK) {
        {
#line 105
        kom_log("default assigner failed for %s\n", (par + ix)->name);
#line 106
        (*err) ++;
        }
      }
    }
#line 93
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int configure_line___1(FILE *fp , struct parameter  const  *par , int *err ) 
{ 
  char line[1001] ;
  char *start ;
  char *val ;
  char *end ;
  int found ;
  int ix ;
  char *tmp ;
  Success tmp___0 ;
  int tmp___1 ;

  {
  {
#line 128
  tmp = fgets((char */* __restrict  */)(line), 1001, (FILE */* __restrict  */)fp);
  }
#line 128
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 129
    return (-1);
  }
#line 135
  start = line;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((int )*start == 32)) {
#line 135
      if (! ((int )*start == 9)) {
#line 135
        goto while_break;
      }
    }
#line 135
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  if ((int )*start == 35) {
#line 139
    goto case_35;
  }
#line 141
  if ((int )*start == 0) {
#line 141
    goto case_0;
  }
#line 145
  if ((int )*start == 10) {
#line 145
    goto case_10;
  }
#line 137
  goto switch_break;
  case_35: /* CIL Label */ 
#line 140
  return (0);
  case_0: /* CIL Label */ 
  {
#line 142
  kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 143
  (*err) ++;
  }
#line 144
  return (0);
  case_10: /* CIL Label */ 
#line 146
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 149
  val = strchr((char const   *)(line), ':');
  }
#line 150
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    {
#line 153
    end = strchr((char const   *)(line), '\n');
    }
#line 154
    if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 155
      *end = (char )'\000';
    }
    {
#line 157
    kom_log("missing colon: %s\n", line);
#line 158
    (*err) ++;
    }
#line 159
    return (0);
  }
#line 161
  *val = (char )'\000';
#line 162
  val ++;
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (! ((int )*val == 32)) {
#line 162
      if (! ((int )*val == 9)) {
#line 162
        goto while_break___0;
      }
    }
#line 162
    val ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 166
  if ((int )*val == 0) {
#line 166
    goto case_0___0;
  }
#line 164
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 167
  kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 168
  (*err) ++;
  }
#line 169
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 172
  end = strchr((char const   *)val, '\n');
  }
#line 173
  if ((unsigned long )end == (unsigned long )((void *)0)) {
    {
#line 175
    kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 176
    (*err) ++;
    }
#line 177
    return (0);
  }
#line 179
  *end = (char )'\000';
#line 182
  found = 0;
#line 183
  ix = 0;
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (! (ix < npar___1)) {
#line 183
      goto while_break___1;
    }
    {
#line 185
    tmp___1 = strcmp((char const   *)start, (char const   *)(par + ix)->name);
    }
#line 185
    if (! tmp___1) {
#line 187
      found ++;
#line 188
      if (*(assignment_count___1 + ix) >= (int )(par + ix)->max_assignments) {
#line 188
        if ((par + ix)->max_assignments != -1) {
          {
#line 191
          (*err) ++;
#line 192
          kom_log("variable already assigned %d times: %s\n", *(assignment_count___1 + ix),
                  line);
          }
        } else {
#line 188
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 197
        (*(assignment_count___1 + ix)) ++;
#line 198
        tmp___0 = (*((par + ix)->assigner))((char const   *)val, par + ix);
        }
#line 198
        if ((unsigned long )tmp___0 != (unsigned long )OK) {
          {
#line 200
          kom_log("assigner for %s failed\n", (par + ix)->name);
#line 201
          (*err) ++;
          }
        }
      }
    }
#line 183
    ix ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 207
  if (found != 1) {
    {
#line 209
    kom_log("line matches %d times: %s\n", found, line);
#line 210
    (*err) ++;
    }
#line 211
    return (0);
  }
#line 213
  return (0);
}
}
#line 388 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static struct suffix_conversion  const  suffix_table___1[27]  = 
#line 388
  {      {"seconds", 1.0}, 
        {"second", 1.0}, 
        {"sec", 1.0}, 
        {"s", 1.0}, 
        {"minutes", 60.0}, 
        {"minute", 60.0}, 
        {"min", 60.0}, 
        {"hours", 3600.0}, 
        {"hour", 3600.0}, 
        {"h", 3600.0}, 
        {"days", 86400.0}, 
        {"day", 86400.0}, 
        {"d", 86400.0}, 
        {"milliseconds", 0.001}, 
        {"millisecond", 0.001}, 
        {"milli", 0.001}, 
        {"ms", 0.001}, 
        {"microseconds", 0.000001}, 
        {"microsecond", 0.000001}, 
        {"micro", 0.000001}, 
        {"us", 0.000001}, 
        {"u", 0.000001}, 
        {"kiloseconds", 1000.0}, 
        {"megaseconds", 1000000.0}, 
        {"microfortnights", 1.2096}, 
        {"microfortnight", 1.2096}, 
        {(char const   *)((void *)0), 0.0}};
#line 47 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/string-malloc.c"
static int no_of_allocated_blocks___5  =    0;
#line 38 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/misc-types.c"
static struct success succ_ok___1  ;
#line 39 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/misc-types.c"
static struct success succ_failure___1  ;
#line 58 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/log.c"
static void kom_logv___1(char const   *format , va_list AP ) ;
#line 71 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/log.c"
static void kom_logv___1(char const   *format , va_list AP ) 
{ 
  time_t clk ;
  struct tm *t ;
  __pid_t tmp ;

  {
  {
#line 77
  time(& clk);
#line 78
  t = localtime((time_t const   *)(& clk));
#line 80
  tmp = getpid();
#line 80
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02d%02d%02d %02d:%02d:%02d %ld ",
          t->tm_year % 100, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec,
          (long )tmp);
#line 83
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           AP);
#line 85
  fflush(stderr);
  }
#line 86
  return;
}
}
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 52 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/komrunning.c"
static void usage___0(char const   *arg0 ) 
{ 


  {
  {
#line 55
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-c config-file] [ -v ] [ -V ] [start | stop]\n",
          arg0);
#line 58
  exit(1);
  }
}
}
#line 61 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/komrunning.c"
static void create_status(char const   *arg0 ) 
{ 
  FILE *fp ;
  int saved_errno ;
  struct passwd *pwent ;
  char const   *user ;
  char *tmp ;
  __uid_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 69
  tmp = getenv("USER");
#line 69
  user = (char const   *)tmp;
  }
#line 71
  if ((unsigned long )user == (unsigned long )((void *)0)) {
    {
#line 73
    tmp___0 = getuid();
#line 73
    pwent = getpwuid(tmp___0);
    }
#line 74
    if ((unsigned long )pwent != (unsigned long )((void *)0)) {
#line 75
      user = (char const   *)pwent->pw_name;
    }
  }
#line 78
  if ((unsigned long )user == (unsigned long )((void *)0)) {
#line 79
    user = "root";
  }
  {
#line 81
  fp = i_fopen((char const   *)param.status_file, "w");
  }
#line 82
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 84
    tmp___1 = __errno_location();
#line 84
    saved_errno = *tmp___1;
#line 85
    fputs((char const   */* __restrict  */)arg0, (FILE */* __restrict  */)stderr);
#line 86
    tmp___2 = __errno_location();
#line 86
    *tmp___2 = saved_errno;
#line 87
    perror((char const   *)param.status_file);
#line 88
    exit(1);
    }
  }
  {
#line 91
  tmp___5 = fputs((char const   */* __restrict  */)user, (FILE */* __restrict  */)fp);
  }
#line 91
  if (tmp___5 == -1) {
#line 91
    goto _L;
  } else {
    {
#line 91
    tmp___6 = _IO_putc('\n', fp);
    }
#line 91
    if (tmp___6 == -1) {
      _L: /* CIL Label */ 
      {
#line 93
      tmp___3 = __errno_location();
#line 93
      saved_errno = *tmp___3;
#line 94
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: writing to ",
              arg0);
#line 95
      tmp___4 = __errno_location();
#line 95
      *tmp___4 = saved_errno;
#line 96
      perror((char const   *)param.status_file);
#line 97
      exit(1);
      }
    }
  }
  {
#line 100
  tmp___9 = i_fclose(fp);
  }
#line 100
  if (tmp___9 != 0) {
    {
#line 102
    tmp___7 = __errno_location();
#line 102
    saved_errno = *tmp___7;
#line 103
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: closing ",
            arg0);
#line 104
    tmp___8 = __errno_location();
#line 104
    *tmp___8 = saved_errno;
#line 105
    perror((char const   *)param.status_file);
#line 106
    exit(1);
    }
  }
#line 108
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/komrunning.c"
static void shutdown_lyskom(pid_t pid , char const   *arg0 ) 
{ 
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 116
  if (pid < 2) {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: insane pid %ld found in %s\n",
            arg0, (long )pid, param.pid_name);
#line 120
    exit(1);
    }
  }
  {
#line 123
  tmp___1 = kill(pid, 15);
  }
#line 123
  if (tmp___1 != 0) {
    {
#line 125
    tmp = __errno_location();
#line 125
    saved_errno = *tmp;
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: sending SIGTERM to pid %ld",
            arg0, (long )pid);
#line 127
    tmp___0 = __errno_location();
#line 127
    *tmp___0 = saved_errno;
#line 128
    perror("");
#line 129
    exit(1);
    }
  }
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 132
    tmp___2 = kill(pid, 0);
    }
#line 132
    if (! (tmp___2 == 0)) {
#line 132
      goto while_break;
    }
    {
#line 133
    sleep(1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  tmp___5 = __errno_location();
  }
#line 135
  if (*tmp___5 != 3) {
    {
#line 137
    tmp___3 = __errno_location();
#line 137
    saved_errno = *tmp___3;
#line 138
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: sending signal 0 to pid %ld",
            arg0, (long )pid);
#line 139
    tmp___4 = __errno_location();
#line 139
    *tmp___4 = saved_errno;
#line 140
    perror("");
#line 141
    exit(1);
    }
  }
#line 143
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success log_param___1(char const   *val , struct parameter  const  *qazwsxedcpar  __attribute__((__unused__)) ) ;
#line 74
static Success jubel___1(char const   *val , struct parameter  const  *par ) ;
#line 75
static Success ident_param___1(char const   *val , struct parameter  const  *par ) ;
#line 85 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static struct parameter  const  parameters___1[106]  = 
#line 85
  {      {"Locale", & assign_string, & unassign_string, 0, 1, (char const   *)((void *)0),
      (void *)(& param.use_locale), (char const   *)((void *)0)}, 
        {"Force ISO 8859-1", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "no", (void *)(& param.force_iso_8859_1), (char const   *)((void *)0)}, 
        {"Prefix",
      & assign_string, & unassign_string, 0, 1, "/usr/lyskom", (void *)(& param.dbase_dir),
      (char const   *)((void *)0)}, 
        {"Send async", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.send_async_messages), (char const   *)((void *)0)}, 
        {"Client host",
      & assign_string, & unassign_string, 0, 1, (char const   *)((void *)0), (void *)(& param.ip_client_host),
      (char const   *)((void *)0)}, 
        {"Client port", & assign_string, & unassign_string, 1, 1, (char const   *)((void *)0),
      (void *)(& param.ip_client_port), (char const   *)((void *)0)}, 
        {"Presentation of conferences", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& kom_info.conf_pres_conf), (char const   *)((void *)0)}, 
        {"Presentation of persons",
      & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "2", (void *)(& kom_info.pers_pres_conf), (char const   *)((void *)0)}, 
        {"Motd-conference", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "3", (void *)(& kom_info.motd_conf), (char const   *)((void *)0)}, 
        {"News-conference", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "4", (void *)(& kom_info.kom_news_conf), (char const   *)((void *)0)}, 
        {"Message of the day",
      & assign_text_no, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "0", (void *)(& kom_info.motd_of_lyskom), (char const   *)((void *)0)}, 
        {"Garb", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "on", (void *)(& param.garb_enable), (char const   *)((void *)0)}, 
        {"Never save", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "no", (void *)(& param.never_save), (char const   *)((void *)0)}, 
        {"Data file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-data",
      (void *)(& param.datafile_name), (char const   *)((void *)0)}, 
        {"Backup file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-backup",
      (void *)(& param.backupfile_name), (char const   *)((void *)0)}, 
        {"Backup file 2", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-backup-prev",
      (void *)(& param.backupfile_name_2), (char const   *)((void *)0)}, 
        {"Lock file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-lock",
      (void *)(& param.lockfile_name), (char const   *)((void *)0)}, 
        {"Text file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-texts",
      (void *)(& param.textfile_name), (char const   *)((void *)0)}, 
        {"Number file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/number.txt",
      (void *)(& param.numberfile_name), (char const   *)((void *)0)}, 
        {"Number temp file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/number.tmp",
      (void *)(& param.numberfile_tmp_name), (char const   *)((void *)0)}, 
        {"Text backup file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-texts-backup",
      (void *)(& param.textbackupfile_name), (char const   *)((void *)0)}, 
        {"Backup export directory", & assign_string, & unassign_string, 0, 1, "var/lyskomd/exportdb",
      (void *)(& param.backup_dir), (char const   *)((void *)0)}, 
        {"Log file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.log", (void *)(& param.logfile_name),
      (char const   *)((void *)0)}, 
        {"Log statistics", & assign_string, & unassign_string, 0, 1, "var/lyskomd.stats",
      (void *)(& param.statistic_name), (char const   *)((void *)0)}, 
        {"Pid file", & assign_string, & unassign_string, 0, 1, "var/run/lyskomd.pid",
      (void *)(& param.pid_name), (char const   *)((void *)0)}, 
        {"Memory usage file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.memory",
      (void *)(& param.memuse_name), (char const   *)((void *)0)}, 
        {"Aux-item definition file", & assign_string, & unassign_string, 0, 1, "etc/aux-items.conf",
      (void *)(& param.aux_def_file), (char const   *)((void *)0)}, 
        {"Status file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/status",
      (void *)(& param.status_file), (char const   *)((void *)0)}, 
        {"Connection status file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.clients",
      (void *)(& param.connection_status_file), (char const   *)((void *)0)}, 
        {"Connection status temp file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.clnt.tmp",
      (void *)(& param.connection_status_file_tmp), (char const   *)((void *)0)}, 
        {"Core directory", & assign_string, & unassign_string, 0, 1, "var/lyskomd.cores",
      (void *)(& param.core_dir), (char const   *)((void *)0)}, 
        {"Nologin file", & assign_string, & unassign_string, 0, 1, "/etc/nologin", (void *)(& param.nologin_file),
      (char const   *)((void *)0)}, 
        {"Garb busy postponement", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "50", (void *)(& param.garb_busy_postponement), "milliseconds"}, 
        {"Garb timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.garbtimeout), "milliseconds"}, 
        {"Sync timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.synctimeout), "milliseconds"}, 
        {"Garb interval", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1440", (void *)(& param.garb_interval), "minutes"}, 
        {"Permissive sync", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "off", (void *)(& param.permissive_sync), (char const   *)((void *)0)}, 
        {"Sync interval",
      & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "5", (void *)(& param.sync_interval), "minutes"}, 
        {"Sync retry interval", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.sync_retry_interval), "minutes"}, 
        {"Saved items per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "5", (void *)(& param.saved_items_per_call), (char const   *)((void *)0)}, 
        {"Penalty per call",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "10", (void *)(& param.penalty_per_call), (char const   *)((void *)0)}, 
        {"Penalty per read", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.penalty_per_read), (char const   *)((void *)0)}, 
        {"Max penalty",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "100", (void *)(& param.max_penalty), (char const   *)((void *)0)}, 
        {"Low penalty", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.low_penalty), (char const   *)((void *)0)}, 
        {"Default priority", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.default_priority), (char const   *)((void *)0)}, 
        {"Max priority",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "0", (void *)(& param.max_priority), (char const   *)((void *)0)}, 
        {"Default weight", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.default_weight), (char const   *)((void *)0)}, 
        {"Max weight", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "100", (void *)(& param.max_weight), (char const   *)((void *)0)}, 
        {"Connect timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "30", (void *)(& param.connect_timeout), "seconds"}, 
        {"Login timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "30", (void *)(& param.login_timeout), "minutes"}, 
        {"Active timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "11.5", (void *)(& param.active_timeout), "days"}, 
        {"Max client message size", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "8176", (void *)(& param.maxmsgsize), (char const   *)((void *)0)}, 
        {"Max client transmit queue messages", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "50", (void *)(& param.maxqueuedsize), (char const   *)((void *)0)}, 
        {"Max client transmit queue bytes", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "100000", (void *)(& param.maxqueuedsize_bytes), (char const   *)((void *)0)}, 
        {"Stale timeout",
      & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "60", (void *)(& param.stale_timeout), "minutes"}, 
        {"Max simultaneous client replies", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "10", (void *)(& param.maxdequeuelen), (char const   *)((void *)0)}, 
        {"Open files", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "-1", (void *)(& param.no_files), (char const   *)((void *)0)}, 
        {"Use DNS", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "yes", (void *)(& param.use_dns), (char const   *)((void *)0)}, 
        {"DNS log threshold", & assign_double, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1.5", (void *)(& param.dns_log_threshold), (char const   *)((void *)0)}, 
        {"Max conference name length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "60",
      (void *)(& param.conf_name_len), (char const   *)((void *)0)}, 
        {"Max client data length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "60", (void *)(& param.client_data_len), (char const   *)((void *)0)}, 
        {"Max password length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.pwd_len), (char const   *)((void *)0)}, 
        {"Max what am I doing length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "60", (void *)(& param.what_do_len), (char const   *)((void *)0)}, 
        {"Max username length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.username_len), (char const   *)((void *)0)}, 
        {"Max text length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "131072", (void *)(& param.text_len), (char const   *)((void *)0)}, 
        {"Max aux_item length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "16384", (void *)(& param.aux_len), (char const   *)((void *)0)}, 
        {"Max broadcast length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1024", (void *)(& param.broadcast_len), (char const   *)((void *)0)}, 
        {"Max regexp length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "1024",
      (void *)(& param.regexp_len), (char const   *)((void *)0)}, 
        {"Statistic name length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "64", (void *)(& param.stat_name_len), (char const   *)((void *)0)}, 
        {"Max marks per person", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "2048", (void *)(& param.max_marks_person), (char const   *)((void *)0)}, 
        {"Max marks per text",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "1024",
      (void *)(& param.max_marks_text), (char const   *)((void *)0)}, 
        {"Max recipients per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "512", (void *)(& param.max_recipients), (char const   *)((void *)0)}, 
        {"Max comments per text",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.max_comm), (char const   *)((void *)0)}, 
        {"Max footnotes per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "32", (void *)(& param.max_foot), (char const   *)((void *)0)}, 
        {"Max links per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "512", (void *)(& param.max_crea_misc), (char const   *)((void *)0)}, 
        {"Max mark_as_read chunks", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.mark_as_read_chunk), (char const   *)((void *)0)}, 
        {"Max accept_async len",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.accept_async_len), (char const   *)((void *)0)}, 
        {"Max aux_items added per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.max_add_aux), (char const   *)((void *)0)}, 
        {"Max aux_items deleted per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.max_delete_aux), (char const   *)((void *)0)}, 
        {"Max read_ranges per call",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "512",
      (void *)(& param.max_read_ranges), (char const   *)((void *)0)}, 
        {"Max super_conf loop", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "17", (void *)(& param.max_super_conf_loop), (char const   *)((void *)0)}, 
        {"Default garb nice",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "77",
      (void *)(& param.default_nice), (char const   *)((void *)0)}, 
        {"Default keep commented nice", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "77", (void *)(& param.default_keep_commented), (char const   *)((void *)0)}, 
        {"Anyone can create new persons",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.anyone_can_create_new_persons), (char const   *)((void *)0)}, 
        {"Anyone can create new conferences",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.anyone_can_create_new_confs), (char const   *)((void *)0)}, 
        {"Allow creation of persons before login",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.create_person_before_login), (char const   *)((void *)0)}, 
        {"Default change name capability",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "on", (void *)(& param.default_change_name), (char const   *)((void *)0)}, 
        {"Add members by invitation", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "on", (void *)(& param.invite_by_default), (char const   *)((void *)0)}, 
        {"Allow secret memberships",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "on", (void *)(& param.secret_memberships), (char const   *)((void *)0)}, 
        {"Allow reinvitations", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "off", (void *)(& param.allow_reinvite), (char const   *)((void *)0)}, 
        {"Log login",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "off", (void *)(& param.log_login), (char const   *)((void *)0)}, 
        {"Ident-authentication", & ident_param___1, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "try", (void *)(& param.authentication_level), (char const   *)((void *)0)}, 
        {"Cache conference limit",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "20",
      (void *)(& param.cache_conferences), (char const   *)((void *)0)}, 
        {"Cache person limit", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.cache_persons), (char const   *)((void *)0)}, 
        {"Cache text_stat limit", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.cache_text_stats), (char const   *)((void *)0)}, 
        {"Echo",
      & log_param___1, (void (*)(struct parameter  const  *par ))((void *)0), 0, -1,
      (char const   *)((void *)0), (void *)0, (char const   *)((void *)0)}, 
        {"Jubel", & jubel___1, (void (*)(struct parameter  const  *par ))((void *)0),
      0, -1, (char const   *)((void *)0), (void *)0, (char const   *)((void *)0)}, 
        {"Max conferences",
      & assign_ulong, (void (*)(struct parameter  const  *par ))((void *)0), 1, 1,
      "4765", (void *)(& param.max_conf), (char const   *)((void *)0)}, 
        {"Max texts", & assign_ulong, (void (*)(struct parameter  const  *par ))((void *)0),
      1, 1, "2000000", (void *)(& param.max_text), (char const   *)((void *)0)}, 
        {"Normal shutdown time", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "21", (void *)(& param.normal_shutdown_time), (char const   *)((void *)0)}, 
        {"Mail after downtime",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "60",
      (void *)(& param.downtime_mail_start), (char const   *)((void *)0)}, 
        {"Mail until downtime", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "120", (void *)(& param.downtime_mail_end), (char const   *)((void *)0)}, 
        {"sendmail path",
      & assign_string, & unassign_string, 0, 1, ":", (void *)(& param.sendmail_path),
      (char const   *)((void *)0)}, 
        {"lyskomd path", & assign_string, & unassign_string, 0, 1, "sbin/lyskomd", (void *)(& param.lyskomd_path),
      (char const   *)((void *)0)}, 
        {"savecore path", & assign_string, & unassign_string, 0, 1, "sbin/savecore-lyskom",
      (void *)(& param.savecore_path), (char const   *)((void *)0)}, 
        {(char const   *)((void *)0), (Success (*)(char const   *val , struct parameter  const  *par ))((void *)0),
      (void (*)(struct parameter  const  *par ))((void *)0), 0, 0, (char const   *)((void *)0),
      (void *)0, (char const   *)((void *)0)}};
#line 542 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   compiled_config_file___1[17]  = 
#line 542
  {      (char const   )'e',      (char const   )'t',      (char const   )'c',      (char const   )'/', 
        (char const   )'l',      (char const   )'y',      (char const   )'s',      (char const   )'k', 
        (char const   )'o',      (char const   )'m',      (char const   )'d',      (char const   )'.', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'f', 
        (char const   )'\000'};
#line 543 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   *default_config___1  =    (char const   *)((void *)0);
#line 584 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success log_param___1(char const   *val , struct parameter  const  *qazwsxedcpar  __attribute__((__unused__)) ) 
{ 


  {
#line 587
  if ((unsigned long )val != (unsigned long )((void *)0)) {
    {
#line 588
    kom_log("config: %s\n", val);
    }
  }
#line 589
  return ((Success )OK);
}
}
#line 592 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success jubel___1(char const   *val , struct parameter  const  *par ) 
{ 
  long a ;
  long b ;
  long c ;
  int res ;
  Bool public ;
  int tmp ;

  {
#line 597
  public = (Bool )0;
#line 599
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 600
    return ((Success )OK);
  }
  {
#line 602
  tmp = strncmp(val, "public ", (size_t )7);
  }
#line 602
  if (! tmp) {
#line 604
    public = (Bool )1;
#line 605
    val += 7;
  }
  {
#line 608
  res = sscanf((char const   */* __restrict  */)val, (char const   */* __restrict  */)"%ld %ld %ld",
               & a, & b, & c);
  }
  {
#line 611
  if (res == 3) {
#line 611
    goto case_3;
  }
#line 614
  if (res == 2) {
#line 614
    goto case_2;
  }
#line 617
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 612
  register_jubel((Pers_no )a, (Text_no )b, (Text_no )c, public);
  }
#line 613
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 615
  register_jubel((Pers_no )a, (Text_no )0, (Text_no )b, public);
  }
#line 616
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 618
  kom_log("%s expecting [public ] x y [z]\n", par->name);
  }
#line 619
  return ((Success )FAILURE);
  switch_break: /* CIL Label */ ;
  }
#line 621
  return ((Success )OK);
}
}
#line 624 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success ident_param___1(char const   *val , struct parameter  const  *par ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 627
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    {
#line 628
    restart_kom("ident_param(): val == NULL\n");
    }
  }
  {
#line 629
  tmp___3 = strcmp(val, "off");
  }
#line 629
  if (tmp___3) {
    {
#line 629
    tmp___4 = strcmp(val, "never");
    }
#line 629
    if (tmp___4) {
      {
#line 634
      tmp___1 = strcmp(val, "on");
      }
#line 634
      if (tmp___1) {
        {
#line 634
        tmp___2 = strcmp(val, "try");
        }
#line 634
        if (tmp___2) {
          {
#line 639
          tmp = strcmp(val, "require");
          }
#line 639
          if (tmp) {
            {
#line 639
            tmp___0 = strcmp(val, "required");
            }
#line 639
            if (tmp___0) {
              {
#line 646
              kom_log("%s expects \"never\", \"try\" or \"required\" as argument\n",
                      par->name);
              }
#line 648
              return ((Success )FAILURE);
            } else {
#line 642
              *((int *)par->value) = 2;
            }
          } else {
#line 642
            *((int *)par->value) = 2;
          }
        } else {
#line 637
          *((int *)par->value) = 1;
        }
      } else {
#line 637
        *((int *)par->value) = 1;
      }
    } else {
#line 632
      *((int *)par->value) = 0;
    }
  } else {
#line 632
    *((int *)par->value) = 0;
  }
#line 650
  return ((Success )OK);
}
}
#line 653 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void add_prefix___1(char **name___0 ) 
{ 
  char *s ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 658
  if ((int )*(*name___0) == 47) {
#line 659
    return;
  }
  {
#line 661
  tmp = strlen((char const   *)param.dbase_dir);
#line 661
  tmp___0 = strlen((char const   *)*name___0);
#line 661
  tmp___1 = smalloc((2UL + tmp) + tmp___0);
#line 661
  s = (char *)tmp___1;
#line 662
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%s/%s", param.dbase_dir,
          *name___0);
#line 663
  sfree((void *)*name___0);
#line 664
  *name___0 = s;
  }
#line 665
  return;
}
}
#line 667 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   *param_name___1(void *value ) 
{ 
  int ix ;

  {
#line 672
  ix = 0;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! ((unsigned long )parameters___1[ix].name != (unsigned long )((void *)0))) {
#line 672
      goto while_break;
    }
#line 673
    if ((unsigned long )parameters___1[ix].value == (unsigned long )value) {
#line 674
      return ((char const   *)parameters___1[ix].name);
    }
#line 672
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  restart_kom("Internal error: non-existing config param in param_name.\n");
  }
#line 678
  return ((char const   *)((void *)0));
}
}
#line 681 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Bool check_abs_path___1(char **path ) 
{ 
  char const   *tmp ;

  {
#line 684
  if ((int )*(*path) == 47) {
#line 685
    return ((Bool )0);
  }
  {
#line 687
  tmp = param_name___1((void *)path);
#line 687
  kom_log("Parameter \'%s\' must be an absolute path when \'Prefix\' is empty.\n",
          tmp);
  }
#line 689
  return ((Bool )1);
}
}
#line 692 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void require_less___1(void *low , void *high ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 696
  tmp = param_name___1(high);
#line 696
  tmp___0 = param_name___1(low);
#line 696
  kom_log("Parameter \'%s\' must be less than parameter \'%s\'.\n", tmp___0, tmp);
  }
#line 699
  return;
}
}
#line 701 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void require_less_eq___1(void *low , void *high ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 705
  tmp = param_name___1(high);
#line 705
  tmp___0 = param_name___1(low);
#line 705
  kom_log("Parameter \'%s\' must be less than or equal to parameter \'%s\'.\n", tmp___0,
          tmp);
  }
#line 708
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int no_of_allocated_blocks___6  =    0;
#line 384 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static void **tmp_alloc_table___1  =    (void **)((void *)0);
#line 385 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int tmp_alloc_table_size___1  =    0;
#line 386 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int tmp_alloc_table_use___1  =    0;
#line 124 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int no_of_allocated_blocks___7  =    0;
#line 384 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static void **tmp_alloc_table___2  =    (void **)((void *)0);
#line 385 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int tmp_alloc_table_size___2  =    0;
#line 386 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int tmp_alloc_table_use___2  =    0;
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int *assignment_count___2  =    (int *)((void *)0);
#line 67 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int npar___2  =    0;
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static void init_init___2(struct parameter  const  *par ) 
{ 
  int ix ;
  void *tmp ;

  {
#line 74
  npar___2 = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )(par + npar___2)->name != (unsigned long )((void *)0))) {
#line 74
      goto while_break;
    }
#line 74
    npar___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if (! ((unsigned long )assignment_count___2 == (unsigned long )((void *)0))) {
    {
#line 77
    __assert_fail("assignment_count == ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c",
                  77U, "init_init");
    }
  }
  {
#line 78
  tmp = smalloc((unsigned long )npar___2 * sizeof(*assignment_count___2));
#line 78
  assignment_count___2 = (int *)tmp;
#line 80
  ix = 0;
  }
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (ix < npar___2)) {
#line 80
      goto while_break___0;
    }
#line 81
    *(assignment_count___2 + ix) = 0;
#line 80
    ix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static void assign_defaults___2(struct parameter  const  *par , int *err ) 
{ 
  int ix ;
  Success tmp ;

  {
#line 93
  ix = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (ix < npar___2)) {
#line 93
      goto while_break;
    }
#line 95
    if (*(assignment_count___2 + ix) < (int )(par + ix)->min_assignments) {
      {
#line 97
      kom_log("Parameter %s only assigned %d times (%d times needed)\n", (par + ix)->name,
              *(assignment_count___2 + ix), (par + ix)->min_assignments);
#line 99
      (*err) ++;
      }
    } else
#line 101
    if (*(assignment_count___2 + ix) == 0) {
      {
#line 103
      tmp = (*((par + ix)->assigner))((char const   *)(par + ix)->default_val, par + ix);
      }
#line 103
      if ((unsigned long )tmp != (unsigned long )OK) {
        {
#line 105
        kom_log("default assigner failed for %s\n", (par + ix)->name);
#line 106
        (*err) ++;
        }
      }
    }
#line 93
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int configure_line___2(FILE *fp , struct parameter  const  *par , int *err ) 
{ 
  char line[1001] ;
  char *start ;
  char *val ;
  char *end ;
  int found ;
  int ix ;
  char *tmp ;
  Success tmp___0 ;
  int tmp___1 ;

  {
  {
#line 128
  tmp = fgets((char */* __restrict  */)(line), 1001, (FILE */* __restrict  */)fp);
  }
#line 128
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 129
    return (-1);
  }
#line 135
  start = line;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((int )*start == 32)) {
#line 135
      if (! ((int )*start == 9)) {
#line 135
        goto while_break;
      }
    }
#line 135
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  if ((int )*start == 35) {
#line 139
    goto case_35;
  }
#line 141
  if ((int )*start == 0) {
#line 141
    goto case_0;
  }
#line 145
  if ((int )*start == 10) {
#line 145
    goto case_10;
  }
#line 137
  goto switch_break;
  case_35: /* CIL Label */ 
#line 140
  return (0);
  case_0: /* CIL Label */ 
  {
#line 142
  kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 143
  (*err) ++;
  }
#line 144
  return (0);
  case_10: /* CIL Label */ 
#line 146
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 149
  val = strchr((char const   *)(line), ':');
  }
#line 150
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    {
#line 153
    end = strchr((char const   *)(line), '\n');
    }
#line 154
    if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 155
      *end = (char )'\000';
    }
    {
#line 157
    kom_log("missing colon: %s\n", line);
#line 158
    (*err) ++;
    }
#line 159
    return (0);
  }
#line 161
  *val = (char )'\000';
#line 162
  val ++;
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (! ((int )*val == 32)) {
#line 162
      if (! ((int )*val == 9)) {
#line 162
        goto while_break___0;
      }
    }
#line 162
    val ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 166
  if ((int )*val == 0) {
#line 166
    goto case_0___0;
  }
#line 164
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 167
  kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 168
  (*err) ++;
  }
#line 169
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 172
  end = strchr((char const   *)val, '\n');
  }
#line 173
  if ((unsigned long )end == (unsigned long )((void *)0)) {
    {
#line 175
    kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 176
    (*err) ++;
    }
#line 177
    return (0);
  }
#line 179
  *end = (char )'\000';
#line 182
  found = 0;
#line 183
  ix = 0;
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (! (ix < npar___2)) {
#line 183
      goto while_break___1;
    }
    {
#line 185
    tmp___1 = strcmp((char const   *)start, (char const   *)(par + ix)->name);
    }
#line 185
    if (! tmp___1) {
#line 187
      found ++;
#line 188
      if (*(assignment_count___2 + ix) >= (int )(par + ix)->max_assignments) {
#line 188
        if ((par + ix)->max_assignments != -1) {
          {
#line 191
          (*err) ++;
#line 192
          kom_log("variable already assigned %d times: %s\n", *(assignment_count___2 + ix),
                  line);
          }
        } else {
#line 188
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 197
        (*(assignment_count___2 + ix)) ++;
#line 198
        tmp___0 = (*((par + ix)->assigner))((char const   *)val, par + ix);
        }
#line 198
        if ((unsigned long )tmp___0 != (unsigned long )OK) {
          {
#line 200
          kom_log("assigner for %s failed\n", (par + ix)->name);
#line 201
          (*err) ++;
          }
        }
      }
    }
#line 183
    ix ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 207
  if (found != 1) {
    {
#line 209
    kom_log("line matches %d times: %s\n", found, line);
#line 210
    (*err) ++;
    }
#line 211
    return (0);
  }
#line 213
  return (0);
}
}
#line 388 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static struct suffix_conversion  const  suffix_table___2[27]  = 
#line 388
  {      {"seconds", 1.0}, 
        {"second", 1.0}, 
        {"sec", 1.0}, 
        {"s", 1.0}, 
        {"minutes", 60.0}, 
        {"minute", 60.0}, 
        {"min", 60.0}, 
        {"hours", 3600.0}, 
        {"hour", 3600.0}, 
        {"h", 3600.0}, 
        {"days", 86400.0}, 
        {"day", 86400.0}, 
        {"d", 86400.0}, 
        {"milliseconds", 0.001}, 
        {"millisecond", 0.001}, 
        {"milli", 0.001}, 
        {"ms", 0.001}, 
        {"microseconds", 0.000001}, 
        {"microsecond", 0.000001}, 
        {"micro", 0.000001}, 
        {"us", 0.000001}, 
        {"u", 0.000001}, 
        {"kiloseconds", 1000.0}, 
        {"megaseconds", 1000000.0}, 
        {"microfortnights", 1.2096}, 
        {"microfortnight", 1.2096}, 
        {(char const   *)((void *)0), 0.0}};
#line 336 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 62 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c"
static char const   *text_base  =    (char const   *)((void *)0);
#line 63 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c"
static char const   *text_tail  =    (char const   *)((void *)0);
#line 64 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c"
static char const   *data_copy  =    (char const   *)((void *)0);
#line 67 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c"
static char const   *argv0  ;
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c"
static char *create_filename(char const   *suffix ) 
{ 
  char *res ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 72
  tmp = strlen((char const   *)param.backup_dir);
#line 72
  tmp___0 = strlen(suffix);
#line 72
  tmp___1 = smalloc(((tmp + 1UL) + tmp___0) + 1UL);
#line 72
  res = (char *)tmp___1;
#line 73
  sprintf((char */* __restrict  */)res, (char const   */* __restrict  */)"%s/%s",
          param.backup_dir, suffix);
  }
#line 74
  return (res);
}
}
#line 78 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c"
static void compute_filenames(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 81
  tmp = create_filename("lyskomd-texts-base.backup");
#line 81
  text_base = (char const   *)tmp;
#line 82
  tmp___0 = create_filename("lyskomd-texts-tail.backup");
#line 82
  text_tail = (char const   *)tmp___0;
#line 83
  tmp___1 = create_filename("lyskomd-data.backup");
#line 83
  data_copy = (char const   *)tmp___1;
  }
#line 84
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c"
static void safe_remove(char const   *filename ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 90
  tmp = __errno_location();
#line 90
  *tmp = 0;
#line 91
  tmp___0 = remove(filename);
  }
#line 91
  if (tmp___0 != 0) {
    {
#line 91
    tmp___1 = __errno_location();
    }
#line 91
    if (*tmp___1 != 2) {
      {
#line 93
      perror(filename);
#line 94
      exit(1);
      }
    }
  }
#line 96
  return;
}
}
#line 99 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c"
static void usage___1(char const   *arg0 ) 
{ 


  {
  {
#line 102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-c config-file] [ -f ] [ -v ] [ -V ]\n",
          arg0);
#line 104
  exit(1);
  }
}
}
#line 108 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c"
static int is_clean___0(FILE *fp ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 111
  tmp = _IO_getc(fp);
  }
#line 111
  if (tmp == 67) {
    {
#line 111
    tmp___0 = _IO_getc(fp);
    }
#line 111
    if (tmp___0 == 76) {
      {
#line 111
      tmp___1 = _IO_getc(fp);
      }
#line 111
      if (tmp___1 == 69) {
        {
#line 111
        tmp___2 = _IO_getc(fp);
        }
#line 111
        if (tmp___2 == 65) {
          {
#line 111
          tmp___3 = _IO_getc(fp);
          }
#line 111
          if (tmp___3 == 78) {
#line 111
            tmp___4 = 1;
          } else {
#line 111
            tmp___4 = 0;
          }
        } else {
#line 111
          tmp___4 = 0;
        }
      } else {
#line 111
        tmp___4 = 0;
      }
    } else {
#line 111
      tmp___4 = 0;
    }
  } else {
#line 111
    tmp___4 = 0;
  }
#line 111
  return (tmp___4);
}
}
#line 118 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c"
static void copy_file___0(char const   *from , FILE *fromfp , char const   *to ) 
{ 
  char buf___4[8192] ;
  FILE *tofp ;
  size_t sz ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 127
  tofp = i_fopen(to, "w");
  }
#line 127
  if ((unsigned long )tofp == (unsigned long )((void *)0)) {
    {
#line 129
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: opening ",
            argv0);
#line 130
    perror(to);
#line 131
    exit(1);
    }
  }
  {
#line 134
  tmp = setvbuf((FILE */* __restrict  */)tofp, (char */* __restrict  */)((void *)0),
                2, (size_t )0);
  }
#line 134
  if (tmp != 0) {
    {
#line 136
    perror("setvbuf");
#line 137
    exit(1);
    }
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 142
    sz = fread((void */* __restrict  */)(buf___4), (size_t )1, (size_t )8192, (FILE */* __restrict  */)fromfp);
#line 143
    tmp___0 = ferror(fromfp);
    }
#line 143
    if (tmp___0) {
      {
#line 145
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error reading from ",
              argv0);
#line 146
      perror(from);
#line 147
      exit(1);
      }
    }
#line 150
    if (sz == 0UL) {
#line 151
      goto while_break;
    }
    {
#line 153
    tmp___1 = fwrite((void const   */* __restrict  */)(buf___4), (size_t )1, sz, (FILE */* __restrict  */)tofp);
    }
#line 153
    if (tmp___1 != sz) {
      {
#line 155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: writing to ",
              argv0);
#line 156
      perror(to);
#line 157
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  tmp___2 = ferror(tofp);
  }
#line 161
  if (tmp___2) {
    {
#line 163
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: writing to ",
            argv0);
#line 164
    perror(to);
#line 165
    exit(1);
    }
  }
  {
#line 168
  tmp___3 = i_fclose(tofp);
  }
#line 168
  if (tmp___3 != 0) {
    {
#line 170
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: closing ",
            argv0);
#line 171
    perror(to);
#line 172
    exit(1);
    }
  }
#line 174
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c"
static void copy_db_file(void) 
{ 
  FILE *fp ;
  char const   *from ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 183
  from = (char const   *)param.datafile_name;
#line 183
  fp = i_fopen(from, "r");
  }
#line 184
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 184
    goto _L;
  } else {
    {
#line 184
    tmp___0 = is_clean___0(fp);
    }
#line 184
    if (! tmp___0) {
      _L: /* CIL Label */ 
#line 186
      if ((unsigned long )fp != (unsigned long )((void *)0)) {
        {
#line 187
        i_fclose(fp);
        }
      }
      {
#line 188
      from = (char const   *)param.backupfile_name;
#line 188
      fp = i_fopen(from, "r");
#line 189
      tmp = is_clean___0(fp);
      }
#line 189
      if (! tmp) {
        {
#line 189
        __assert_fail("is_clean(fp)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c",
                      189U, "copy_db_file");
        }
      }
    }
  }
  {
#line 191
  tmp___1 = fseek(fp, 0L, 0);
  }
#line 191
  if (tmp___1 != 0) {
    {
#line 193
    perror("fseek");
#line 194
    exit(1);
    }
  }
  {
#line 196
  copy_file___0(from, fp, data_copy);
#line 197
  i_fclose(fp);
  }
#line 198
  return;
}
}
#line 201 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c"
static int file_equal(char const   *from , FILE *fromfp , char const   *assumed_copy ) 
{ 
  FILE *copyfp ;
  int c1 ;
  int c2 ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 210
  copyfp = i_fopen(assumed_copy, "r");
  }
#line 210
  if ((unsigned long )copyfp == (unsigned long )((void *)0)) {
    {
#line 212
    tmp = __errno_location();
    }
#line 212
    if (*tmp == 2) {
#line 213
      return (0);
    }
    {
#line 215
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: opening ",
            argv0);
#line 216
    perror(assumed_copy);
#line 217
    exit(1);
    }
  }
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 222
    c1 = _IO_getc(copyfp);
    }
#line 222
    if (c1 == -1) {
      {
#line 224
      tmp___0 = ferror(copyfp);
      }
#line 224
      if (tmp___0) {
        {
#line 226
        i_fclose(copyfp);
        }
#line 227
        return (0);
      } else {
        {
#line 231
        i_fclose(copyfp);
        }
#line 232
        return (1);
      }
    }
    {
#line 236
    c2 = _IO_getc(fromfp);
    }
#line 236
    if (c2 == -1) {
#line 236
      goto _L;
    } else
#line 236
    if (c1 != c2) {
      _L: /* CIL Label */ 
      {
#line 238
      tmp___1 = ferror(fromfp);
      }
#line 238
      if (tmp___1) {
        {
#line 240
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: reading ",
                argv0);
#line 241
        perror(from);
#line 242
        exit(1);
        }
      }
      {
#line 245
      i_fclose(copyfp);
      }
#line 246
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 252 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/splitkomdb.c"
static void copy_text_file(void) 
{ 
  FILE *fromfp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 257
  fromfp = i_fopen((char const   *)param.textfile_name, "r");
  }
#line 257
  if ((unsigned long )fromfp == (unsigned long )((void *)0)) {
    {
#line 259
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: opening ",
            argv0);
#line 260
    perror((char const   *)param.textfile_name);
#line 261
    exit(1);
    }
  }
  {
#line 264
  tmp___0 = file_equal((char const   *)param.textfile_name, fromfp, text_base);
  }
#line 264
  if (tmp___0) {
    {
#line 266
    copy_file___0((char const   *)param.textfile_name, fromfp, text_tail);
#line 267
    i_fclose(fromfp);
    }
  } else {
    {
#line 271
    safe_remove(text_base);
#line 272
    safe_remove(text_tail);
#line 273
    tmp = fseek(fromfp, 0L, 0);
    }
#line 273
    if (tmp != 0) {
      {
#line 275
      perror("fseek");
#line 276
      exit(1);
      }
    }
    {
#line 278
    copy_file___0((char const   *)param.textfile_name, fromfp, text_base);
    }
  }
#line 280
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success log_param___2(char const   *val , struct parameter  const  *qazwsxedcpar  __attribute__((__unused__)) ) ;
#line 74
static Success jubel___2(char const   *val , struct parameter  const  *par ) ;
#line 75
static Success ident_param___2(char const   *val , struct parameter  const  *par ) ;
#line 85 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static struct parameter  const  parameters___2[106]  = 
#line 85
  {      {"Locale", & assign_string, & unassign_string, 0, 1, (char const   *)((void *)0),
      (void *)(& param.use_locale), (char const   *)((void *)0)}, 
        {"Force ISO 8859-1", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "no", (void *)(& param.force_iso_8859_1), (char const   *)((void *)0)}, 
        {"Prefix",
      & assign_string, & unassign_string, 0, 1, "/usr/lyskom", (void *)(& param.dbase_dir),
      (char const   *)((void *)0)}, 
        {"Send async", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.send_async_messages), (char const   *)((void *)0)}, 
        {"Client host",
      & assign_string, & unassign_string, 0, 1, (char const   *)((void *)0), (void *)(& param.ip_client_host),
      (char const   *)((void *)0)}, 
        {"Client port", & assign_string, & unassign_string, 1, 1, (char const   *)((void *)0),
      (void *)(& param.ip_client_port), (char const   *)((void *)0)}, 
        {"Presentation of conferences", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& kom_info.conf_pres_conf), (char const   *)((void *)0)}, 
        {"Presentation of persons",
      & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "2", (void *)(& kom_info.pers_pres_conf), (char const   *)((void *)0)}, 
        {"Motd-conference", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "3", (void *)(& kom_info.motd_conf), (char const   *)((void *)0)}, 
        {"News-conference", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "4", (void *)(& kom_info.kom_news_conf), (char const   *)((void *)0)}, 
        {"Message of the day",
      & assign_text_no, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "0", (void *)(& kom_info.motd_of_lyskom), (char const   *)((void *)0)}, 
        {"Garb", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "on", (void *)(& param.garb_enable), (char const   *)((void *)0)}, 
        {"Never save", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "no", (void *)(& param.never_save), (char const   *)((void *)0)}, 
        {"Data file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-data",
      (void *)(& param.datafile_name), (char const   *)((void *)0)}, 
        {"Backup file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-backup",
      (void *)(& param.backupfile_name), (char const   *)((void *)0)}, 
        {"Backup file 2", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-backup-prev",
      (void *)(& param.backupfile_name_2), (char const   *)((void *)0)}, 
        {"Lock file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-lock",
      (void *)(& param.lockfile_name), (char const   *)((void *)0)}, 
        {"Text file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-texts",
      (void *)(& param.textfile_name), (char const   *)((void *)0)}, 
        {"Number file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/number.txt",
      (void *)(& param.numberfile_name), (char const   *)((void *)0)}, 
        {"Number temp file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/number.tmp",
      (void *)(& param.numberfile_tmp_name), (char const   *)((void *)0)}, 
        {"Text backup file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-texts-backup",
      (void *)(& param.textbackupfile_name), (char const   *)((void *)0)}, 
        {"Backup export directory", & assign_string, & unassign_string, 0, 1, "var/lyskomd/exportdb",
      (void *)(& param.backup_dir), (char const   *)((void *)0)}, 
        {"Log file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.log", (void *)(& param.logfile_name),
      (char const   *)((void *)0)}, 
        {"Log statistics", & assign_string, & unassign_string, 0, 1, "var/lyskomd.stats",
      (void *)(& param.statistic_name), (char const   *)((void *)0)}, 
        {"Pid file", & assign_string, & unassign_string, 0, 1, "var/run/lyskomd.pid",
      (void *)(& param.pid_name), (char const   *)((void *)0)}, 
        {"Memory usage file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.memory",
      (void *)(& param.memuse_name), (char const   *)((void *)0)}, 
        {"Aux-item definition file", & assign_string, & unassign_string, 0, 1, "etc/aux-items.conf",
      (void *)(& param.aux_def_file), (char const   *)((void *)0)}, 
        {"Status file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/status",
      (void *)(& param.status_file), (char const   *)((void *)0)}, 
        {"Connection status file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.clients",
      (void *)(& param.connection_status_file), (char const   *)((void *)0)}, 
        {"Connection status temp file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.clnt.tmp",
      (void *)(& param.connection_status_file_tmp), (char const   *)((void *)0)}, 
        {"Core directory", & assign_string, & unassign_string, 0, 1, "var/lyskomd.cores",
      (void *)(& param.core_dir), (char const   *)((void *)0)}, 
        {"Nologin file", & assign_string, & unassign_string, 0, 1, "/etc/nologin", (void *)(& param.nologin_file),
      (char const   *)((void *)0)}, 
        {"Garb busy postponement", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "50", (void *)(& param.garb_busy_postponement), "milliseconds"}, 
        {"Garb timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.garbtimeout), "milliseconds"}, 
        {"Sync timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.synctimeout), "milliseconds"}, 
        {"Garb interval", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1440", (void *)(& param.garb_interval), "minutes"}, 
        {"Permissive sync", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "off", (void *)(& param.permissive_sync), (char const   *)((void *)0)}, 
        {"Sync interval",
      & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "5", (void *)(& param.sync_interval), "minutes"}, 
        {"Sync retry interval", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.sync_retry_interval), "minutes"}, 
        {"Saved items per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "5", (void *)(& param.saved_items_per_call), (char const   *)((void *)0)}, 
        {"Penalty per call",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "10", (void *)(& param.penalty_per_call), (char const   *)((void *)0)}, 
        {"Penalty per read", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.penalty_per_read), (char const   *)((void *)0)}, 
        {"Max penalty",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "100", (void *)(& param.max_penalty), (char const   *)((void *)0)}, 
        {"Low penalty", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.low_penalty), (char const   *)((void *)0)}, 
        {"Default priority", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.default_priority), (char const   *)((void *)0)}, 
        {"Max priority",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "0", (void *)(& param.max_priority), (char const   *)((void *)0)}, 
        {"Default weight", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.default_weight), (char const   *)((void *)0)}, 
        {"Max weight", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "100", (void *)(& param.max_weight), (char const   *)((void *)0)}, 
        {"Connect timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "30", (void *)(& param.connect_timeout), "seconds"}, 
        {"Login timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "30", (void *)(& param.login_timeout), "minutes"}, 
        {"Active timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "11.5", (void *)(& param.active_timeout), "days"}, 
        {"Max client message size", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "8176", (void *)(& param.maxmsgsize), (char const   *)((void *)0)}, 
        {"Max client transmit queue messages", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "50", (void *)(& param.maxqueuedsize), (char const   *)((void *)0)}, 
        {"Max client transmit queue bytes", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "100000", (void *)(& param.maxqueuedsize_bytes), (char const   *)((void *)0)}, 
        {"Stale timeout",
      & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "60", (void *)(& param.stale_timeout), "minutes"}, 
        {"Max simultaneous client replies", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "10", (void *)(& param.maxdequeuelen), (char const   *)((void *)0)}, 
        {"Open files", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "-1", (void *)(& param.no_files), (char const   *)((void *)0)}, 
        {"Use DNS", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "yes", (void *)(& param.use_dns), (char const   *)((void *)0)}, 
        {"DNS log threshold", & assign_double, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1.5", (void *)(& param.dns_log_threshold), (char const   *)((void *)0)}, 
        {"Max conference name length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "60",
      (void *)(& param.conf_name_len), (char const   *)((void *)0)}, 
        {"Max client data length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "60", (void *)(& param.client_data_len), (char const   *)((void *)0)}, 
        {"Max password length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.pwd_len), (char const   *)((void *)0)}, 
        {"Max what am I doing length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "60", (void *)(& param.what_do_len), (char const   *)((void *)0)}, 
        {"Max username length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.username_len), (char const   *)((void *)0)}, 
        {"Max text length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "131072", (void *)(& param.text_len), (char const   *)((void *)0)}, 
        {"Max aux_item length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "16384", (void *)(& param.aux_len), (char const   *)((void *)0)}, 
        {"Max broadcast length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1024", (void *)(& param.broadcast_len), (char const   *)((void *)0)}, 
        {"Max regexp length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "1024",
      (void *)(& param.regexp_len), (char const   *)((void *)0)}, 
        {"Statistic name length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "64", (void *)(& param.stat_name_len), (char const   *)((void *)0)}, 
        {"Max marks per person", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "2048", (void *)(& param.max_marks_person), (char const   *)((void *)0)}, 
        {"Max marks per text",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "1024",
      (void *)(& param.max_marks_text), (char const   *)((void *)0)}, 
        {"Max recipients per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "512", (void *)(& param.max_recipients), (char const   *)((void *)0)}, 
        {"Max comments per text",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.max_comm), (char const   *)((void *)0)}, 
        {"Max footnotes per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "32", (void *)(& param.max_foot), (char const   *)((void *)0)}, 
        {"Max links per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "512", (void *)(& param.max_crea_misc), (char const   *)((void *)0)}, 
        {"Max mark_as_read chunks", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.mark_as_read_chunk), (char const   *)((void *)0)}, 
        {"Max accept_async len",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.accept_async_len), (char const   *)((void *)0)}, 
        {"Max aux_items added per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.max_add_aux), (char const   *)((void *)0)}, 
        {"Max aux_items deleted per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.max_delete_aux), (char const   *)((void *)0)}, 
        {"Max read_ranges per call",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "512",
      (void *)(& param.max_read_ranges), (char const   *)((void *)0)}, 
        {"Max super_conf loop", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "17", (void *)(& param.max_super_conf_loop), (char const   *)((void *)0)}, 
        {"Default garb nice",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "77",
      (void *)(& param.default_nice), (char const   *)((void *)0)}, 
        {"Default keep commented nice", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "77", (void *)(& param.default_keep_commented), (char const   *)((void *)0)}, 
        {"Anyone can create new persons",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.anyone_can_create_new_persons), (char const   *)((void *)0)}, 
        {"Anyone can create new conferences",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.anyone_can_create_new_confs), (char const   *)((void *)0)}, 
        {"Allow creation of persons before login",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.create_person_before_login), (char const   *)((void *)0)}, 
        {"Default change name capability",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "on", (void *)(& param.default_change_name), (char const   *)((void *)0)}, 
        {"Add members by invitation", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "on", (void *)(& param.invite_by_default), (char const   *)((void *)0)}, 
        {"Allow secret memberships",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "on", (void *)(& param.secret_memberships), (char const   *)((void *)0)}, 
        {"Allow reinvitations", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "off", (void *)(& param.allow_reinvite), (char const   *)((void *)0)}, 
        {"Log login",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "off", (void *)(& param.log_login), (char const   *)((void *)0)}, 
        {"Ident-authentication", & ident_param___2, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "try", (void *)(& param.authentication_level), (char const   *)((void *)0)}, 
        {"Cache conference limit",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "20",
      (void *)(& param.cache_conferences), (char const   *)((void *)0)}, 
        {"Cache person limit", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.cache_persons), (char const   *)((void *)0)}, 
        {"Cache text_stat limit", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.cache_text_stats), (char const   *)((void *)0)}, 
        {"Echo",
      & log_param___2, (void (*)(struct parameter  const  *par ))((void *)0), 0, -1,
      (char const   *)((void *)0), (void *)0, (char const   *)((void *)0)}, 
        {"Jubel", & jubel___2, (void (*)(struct parameter  const  *par ))((void *)0),
      0, -1, (char const   *)((void *)0), (void *)0, (char const   *)((void *)0)}, 
        {"Max conferences",
      & assign_ulong, (void (*)(struct parameter  const  *par ))((void *)0), 1, 1,
      "4765", (void *)(& param.max_conf), (char const   *)((void *)0)}, 
        {"Max texts", & assign_ulong, (void (*)(struct parameter  const  *par ))((void *)0),
      1, 1, "2000000", (void *)(& param.max_text), (char const   *)((void *)0)}, 
        {"Normal shutdown time", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "21", (void *)(& param.normal_shutdown_time), (char const   *)((void *)0)}, 
        {"Mail after downtime",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "60",
      (void *)(& param.downtime_mail_start), (char const   *)((void *)0)}, 
        {"Mail until downtime", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "120", (void *)(& param.downtime_mail_end), (char const   *)((void *)0)}, 
        {"sendmail path",
      & assign_string, & unassign_string, 0, 1, ":", (void *)(& param.sendmail_path),
      (char const   *)((void *)0)}, 
        {"lyskomd path", & assign_string, & unassign_string, 0, 1, "sbin/lyskomd", (void *)(& param.lyskomd_path),
      (char const   *)((void *)0)}, 
        {"savecore path", & assign_string, & unassign_string, 0, 1, "sbin/savecore-lyskom",
      (void *)(& param.savecore_path), (char const   *)((void *)0)}, 
        {(char const   *)((void *)0), (Success (*)(char const   *val , struct parameter  const  *par ))((void *)0),
      (void (*)(struct parameter  const  *par ))((void *)0), 0, 0, (char const   *)((void *)0),
      (void *)0, (char const   *)((void *)0)}};
#line 542 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   compiled_config_file___2[17]  = 
#line 542
  {      (char const   )'e',      (char const   )'t',      (char const   )'c',      (char const   )'/', 
        (char const   )'l',      (char const   )'y',      (char const   )'s',      (char const   )'k', 
        (char const   )'o',      (char const   )'m',      (char const   )'d',      (char const   )'.', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'f', 
        (char const   )'\000'};
#line 543 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   *default_config___2  =    (char const   *)((void *)0);
#line 584 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success log_param___2(char const   *val , struct parameter  const  *qazwsxedcpar  __attribute__((__unused__)) ) 
{ 


  {
#line 587
  if ((unsigned long )val != (unsigned long )((void *)0)) {
    {
#line 588
    kom_log("config: %s\n", val);
    }
  }
#line 589
  return ((Success )OK);
}
}
#line 592 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success jubel___2(char const   *val , struct parameter  const  *par ) 
{ 
  long a ;
  long b ;
  long c ;
  int res ;
  Bool public ;
  int tmp ;

  {
#line 597
  public = (Bool )0;
#line 599
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 600
    return ((Success )OK);
  }
  {
#line 602
  tmp = strncmp(val, "public ", (size_t )7);
  }
#line 602
  if (! tmp) {
#line 604
    public = (Bool )1;
#line 605
    val += 7;
  }
  {
#line 608
  res = sscanf((char const   */* __restrict  */)val, (char const   */* __restrict  */)"%ld %ld %ld",
               & a, & b, & c);
  }
  {
#line 611
  if (res == 3) {
#line 611
    goto case_3;
  }
#line 614
  if (res == 2) {
#line 614
    goto case_2;
  }
#line 617
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 612
  register_jubel((Pers_no )a, (Text_no )b, (Text_no )c, public);
  }
#line 613
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 615
  register_jubel((Pers_no )a, (Text_no )0, (Text_no )b, public);
  }
#line 616
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 618
  kom_log("%s expecting [public ] x y [z]\n", par->name);
  }
#line 619
  return ((Success )FAILURE);
  switch_break: /* CIL Label */ ;
  }
#line 621
  return ((Success )OK);
}
}
#line 624 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success ident_param___2(char const   *val , struct parameter  const  *par ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 627
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    {
#line 628
    restart_kom("ident_param(): val == NULL\n");
    }
  }
  {
#line 629
  tmp___3 = strcmp(val, "off");
  }
#line 629
  if (tmp___3) {
    {
#line 629
    tmp___4 = strcmp(val, "never");
    }
#line 629
    if (tmp___4) {
      {
#line 634
      tmp___1 = strcmp(val, "on");
      }
#line 634
      if (tmp___1) {
        {
#line 634
        tmp___2 = strcmp(val, "try");
        }
#line 634
        if (tmp___2) {
          {
#line 639
          tmp = strcmp(val, "require");
          }
#line 639
          if (tmp) {
            {
#line 639
            tmp___0 = strcmp(val, "required");
            }
#line 639
            if (tmp___0) {
              {
#line 646
              kom_log("%s expects \"never\", \"try\" or \"required\" as argument\n",
                      par->name);
              }
#line 648
              return ((Success )FAILURE);
            } else {
#line 642
              *((int *)par->value) = 2;
            }
          } else {
#line 642
            *((int *)par->value) = 2;
          }
        } else {
#line 637
          *((int *)par->value) = 1;
        }
      } else {
#line 637
        *((int *)par->value) = 1;
      }
    } else {
#line 632
      *((int *)par->value) = 0;
    }
  } else {
#line 632
    *((int *)par->value) = 0;
  }
#line 650
  return ((Success )OK);
}
}
#line 653 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void add_prefix___2(char **name___0 ) 
{ 
  char *s ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 658
  if ((int )*(*name___0) == 47) {
#line 659
    return;
  }
  {
#line 661
  tmp = strlen((char const   *)param.dbase_dir);
#line 661
  tmp___0 = strlen((char const   *)*name___0);
#line 661
  tmp___1 = smalloc((2UL + tmp) + tmp___0);
#line 661
  s = (char *)tmp___1;
#line 662
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%s/%s", param.dbase_dir,
          *name___0);
#line 663
  sfree((void *)*name___0);
#line 664
  *name___0 = s;
  }
#line 665
  return;
}
}
#line 667 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   *param_name___2(void *value ) 
{ 
  int ix ;

  {
#line 672
  ix = 0;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! ((unsigned long )parameters___2[ix].name != (unsigned long )((void *)0))) {
#line 672
      goto while_break;
    }
#line 673
    if ((unsigned long )parameters___2[ix].value == (unsigned long )value) {
#line 674
      return ((char const   *)parameters___2[ix].name);
    }
#line 672
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  restart_kom("Internal error: non-existing config param in param_name.\n");
  }
#line 678
  return ((char const   *)((void *)0));
}
}
#line 681 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Bool check_abs_path___2(char **path ) 
{ 
  char const   *tmp ;

  {
#line 684
  if ((int )*(*path) == 47) {
#line 685
    return ((Bool )0);
  }
  {
#line 687
  tmp = param_name___2((void *)path);
#line 687
  kom_log("Parameter \'%s\' must be an absolute path when \'Prefix\' is empty.\n",
          tmp);
  }
#line 689
  return ((Bool )1);
}
}
#line 692 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void require_less___2(void *low , void *high ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 696
  tmp = param_name___2(high);
#line 696
  tmp___0 = param_name___2(low);
#line 696
  kom_log("Parameter \'%s\' must be less than parameter \'%s\'.\n", tmp___0, tmp);
  }
#line 699
  return;
}
}
#line 701 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void require_less_eq___2(void *low , void *high ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 705
  tmp = param_name___2(high);
#line 705
  tmp___0 = param_name___2(low);
#line 705
  kom_log("Parameter \'%s\' must be less than or equal to parameter \'%s\'.\n", tmp___0,
          tmp);
  }
#line 708
  return;
}
}
#line 38 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/misc-types.c"
static struct success succ_ok___2  ;
#line 39 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/misc-types.c"
static struct success succ_failure___2  ;
#line 58 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/log.c"
static void kom_logv___2(char const   *format , va_list AP ) ;
#line 71 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/log.c"
static void kom_logv___2(char const   *format , va_list AP ) 
{ 
  time_t clk ;
  struct tm *t ;
  __pid_t tmp ;

  {
  {
#line 77
  time(& clk);
#line 78
  t = localtime((time_t const   *)(& clk));
#line 80
  tmp = getpid();
#line 80
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02d%02d%02d %02d:%02d:%02d %ld ",
          t->tm_year % 100, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec,
          (long )tmp);
#line 83
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           AP);
#line 85
  fflush(stderr);
  }
#line 86
  return;
}
}
#line 47 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/string-malloc.c"
static int no_of_allocated_blocks___8  =    0;
#line 50 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static int person_cnt___0  =    0;
#line 51 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static int conference_cnt___0  =    0;
#line 52 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static int text_stat_cnt___0  =    0;
#line 56
static void clear_mark_list___0(Mark_list *mark_list ) ;
#line 57
static Mark_list copy_mark_list___0(Mark_list ml ) ;
#line 58
static void clear_member_list___0(Member_list *m ) ;
#line 59
static Member_list copy_member_list___0(Member_list ml ) ;
#line 60
static void clear_membership___0(Membership *mship ) ;
#line 61
static Membership copy_membership___0(Membership m ) ;
#line 62
static void clear_membership_list___0(Membership_list *mlist ) ;
#line 63
static Membership_list copy_membership_list___0(Membership_list ml ) ;
#line 64
static void copy_aux_item_list___0(Aux_item_list *dest , Aux_item_list const   *src ) ;
#line 190 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static void clear_mark_list___0(Mark_list *mark_list ) 
{ 


  {
#line 193
  if ((unsigned long )mark_list == (unsigned long )((void *)0)) {
    {
#line 195
    kom_log("clear_mark_list(): mark_list == NULL.\n");
    }
#line 196
    return;
  }
  {
#line 199
  sfree((void *)mark_list->marks);
#line 200
  init_mark_list(mark_list);
  }
#line 201
  return;
}
}
#line 203 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static Mark_list copy_mark_list___0(Mark_list ml ) 
{ 
  Mark_list r ;
  void *tmp ;

  {
  {
#line 208
  r.no_of_marks = ml.no_of_marks;
#line 209
  tmp = smalloc((unsigned long )r.no_of_marks * sizeof(Mark ));
#line 209
  r.marks = (Mark *)tmp;
#line 210
  memcpy((void */* __restrict  */)r.marks, (void const   */* __restrict  */)ml.marks,
         (unsigned long )r.no_of_marks * sizeof(Mark ));
  }
#line 211
  return (r);
}
}
#line 223 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static void clear_member_list___0(Member_list *m ) 
{ 


  {
#line 226
  if ((unsigned long )m == (unsigned long )((void *)0)) {
#line 227
    return;
  }
  {
#line 229
  sfree((void *)m->members);
#line 230
  init_member_list(m);
  }
#line 231
  return;
}
}
#line 233 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static Member_list copy_member_list___0(Member_list ml ) 
{ 
  Member_list res ;
  void *tmp ;

  {
  {
#line 238
  res.no_of_members = ml.no_of_members;
#line 239
  tmp = smalloc((unsigned long )res.no_of_members * sizeof(Member ));
#line 239
  res.members = (Member *)tmp;
#line 240
  memcpy((void */* __restrict  */)res.members, (void const   */* __restrict  */)ml.members,
         (unsigned long )res.no_of_members * sizeof(Member ));
  }
#line 241
  return (res);
}
}
#line 269 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static void clear_membership___0(Membership *mship ) 
{ 


  {
#line 272
  if ((unsigned long )mship == (unsigned long )((void *)0)) {
    {
#line 274
    kom_log("clear_membership(): mship == NULL.\n");
    }
#line 275
    return;
  }
  {
#line 278
  sfree((void *)mship->read_ranges);
#line 279
  init_membership(mship);
  }
#line 280
  return;
}
}
#line 282 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static Membership copy_membership___0(Membership m ) 
{ 
  Membership res ;
  void *tmp ;

  {
#line 287
  res = m;
#line 288
  if (m.no_of_read_ranges != 0U) {
    {
#line 290
    tmp = smalloc((unsigned long )m.no_of_read_ranges * sizeof(*(res.read_ranges + 0)));
#line 290
    res.read_ranges = (struct read_range *)tmp;
#line 292
    memcpy((void */* __restrict  */)res.read_ranges, (void const   */* __restrict  */)m.read_ranges,
           (unsigned long )m.no_of_read_ranges * sizeof(*(res.read_ranges + 0)));
    }
  } else
#line 295
  if ((unsigned long )m.read_ranges != (unsigned long )((void *)0)) {
    {
#line 297
    kom_log("copy_membership(): read_ranges != NULL but no_of_read_ranges == 0\n");
#line 299
    res.read_ranges = (struct read_range *)((void *)0);
    }
  }
#line 301
  return (res);
}
}
#line 334 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static void clear_membership_list___0(Membership_list *mlist ) 
{ 
  int i ;

  {
#line 339
  if ((unsigned long )mlist == (unsigned long )((void *)0)) {
    {
#line 341
    kom_log("clear_membership_list(): membership_list == NULL.\n");
    }
#line 342
    return;
  }
#line 345
  i = 0;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! (i < (int )mlist->no_of_confs)) {
#line 345
      goto while_break;
    }
    {
#line 347
    clear_membership___0(mlist->confs + i);
#line 345
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 350
  sfree((void *)mlist->confs);
#line 351
  init_membership_list(mlist);
  }
#line 352
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static Membership_list copy_membership_list___0(Membership_list ml ) 
{ 
  Membership_list r ;
  int i ;
  void *tmp ;

  {
  {
#line 360
  r.no_of_confs = ml.no_of_confs;
#line 361
  tmp = smalloc((unsigned long )ml.no_of_confs * sizeof(Membership ));
#line 361
  r.confs = (Membership *)tmp;
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! (i < (int )r.no_of_confs)) {
#line 363
      goto while_break;
    }
    {
#line 365
    *(r.confs + i) = copy_membership___0(*(ml.confs + i));
#line 363
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return (r);
}
}
#line 708 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/memory.c"
static void copy_aux_item_list___0(Aux_item_list *dest , Aux_item_list const   *src ) 
{ 
  unsigned long i ;
  void *tmp ;

  {
  {
#line 714
  dest->length = (unsigned short )src->length;
#line 715
  tmp = smalloc(sizeof(Aux_item ) * (unsigned long )src->length);
#line 715
  dest->items = (Aux_item *)tmp;
#line 716
  i = 0UL;
  }
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! (i < (unsigned long )src->length)) {
#line 716
      goto while_break;
    }
    {
#line 718
    copy_aux_item(dest->items + i, (Aux_item const   *)(src->items + i));
#line 716
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 720
  return;
}
}
#line 38 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/misc-types.c"
static struct success succ_ok___3  ;
#line 39 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/misc-types.c"
static struct success succ_failure___3  ;
#line 73 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success log_param___3(char const   *val , struct parameter  const  *qazwsxedcpar  __attribute__((__unused__)) ) ;
#line 74
static Success jubel___3(char const   *val , struct parameter  const  *par ) ;
#line 75
static Success ident_param___3(char const   *val , struct parameter  const  *par ) ;
#line 85 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static struct parameter  const  parameters___3[106]  = 
#line 85
  {      {"Locale", & assign_string, & unassign_string, 0, 1, (char const   *)((void *)0),
      (void *)(& param.use_locale), (char const   *)((void *)0)}, 
        {"Force ISO 8859-1", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "no", (void *)(& param.force_iso_8859_1), (char const   *)((void *)0)}, 
        {"Prefix",
      & assign_string, & unassign_string, 0, 1, "/usr/lyskom", (void *)(& param.dbase_dir),
      (char const   *)((void *)0)}, 
        {"Send async", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.send_async_messages), (char const   *)((void *)0)}, 
        {"Client host",
      & assign_string, & unassign_string, 0, 1, (char const   *)((void *)0), (void *)(& param.ip_client_host),
      (char const   *)((void *)0)}, 
        {"Client port", & assign_string, & unassign_string, 1, 1, (char const   *)((void *)0),
      (void *)(& param.ip_client_port), (char const   *)((void *)0)}, 
        {"Presentation of conferences", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& kom_info.conf_pres_conf), (char const   *)((void *)0)}, 
        {"Presentation of persons",
      & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "2", (void *)(& kom_info.pers_pres_conf), (char const   *)((void *)0)}, 
        {"Motd-conference", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "3", (void *)(& kom_info.motd_conf), (char const   *)((void *)0)}, 
        {"News-conference", & assign_conf_no, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "4", (void *)(& kom_info.kom_news_conf), (char const   *)((void *)0)}, 
        {"Message of the day",
      & assign_text_no, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "0", (void *)(& kom_info.motd_of_lyskom), (char const   *)((void *)0)}, 
        {"Garb", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "on", (void *)(& param.garb_enable), (char const   *)((void *)0)}, 
        {"Never save", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "no", (void *)(& param.never_save), (char const   *)((void *)0)}, 
        {"Data file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-data",
      (void *)(& param.datafile_name), (char const   *)((void *)0)}, 
        {"Backup file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-backup",
      (void *)(& param.backupfile_name), (char const   *)((void *)0)}, 
        {"Backup file 2", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-backup-prev",
      (void *)(& param.backupfile_name_2), (char const   *)((void *)0)}, 
        {"Lock file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-lock",
      (void *)(& param.lockfile_name), (char const   *)((void *)0)}, 
        {"Text file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-texts",
      (void *)(& param.textfile_name), (char const   *)((void *)0)}, 
        {"Number file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/number.txt",
      (void *)(& param.numberfile_name), (char const   *)((void *)0)}, 
        {"Number temp file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/number.tmp",
      (void *)(& param.numberfile_tmp_name), (char const   *)((void *)0)}, 
        {"Text backup file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/lyskomd-texts-backup",
      (void *)(& param.textbackupfile_name), (char const   *)((void *)0)}, 
        {"Backup export directory", & assign_string, & unassign_string, 0, 1, "var/lyskomd/exportdb",
      (void *)(& param.backup_dir), (char const   *)((void *)0)}, 
        {"Log file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.log", (void *)(& param.logfile_name),
      (char const   *)((void *)0)}, 
        {"Log statistics", & assign_string, & unassign_string, 0, 1, "var/lyskomd.stats",
      (void *)(& param.statistic_name), (char const   *)((void *)0)}, 
        {"Pid file", & assign_string, & unassign_string, 0, 1, "var/run/lyskomd.pid",
      (void *)(& param.pid_name), (char const   *)((void *)0)}, 
        {"Memory usage file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.memory",
      (void *)(& param.memuse_name), (char const   *)((void *)0)}, 
        {"Aux-item definition file", & assign_string, & unassign_string, 0, 1, "etc/aux-items.conf",
      (void *)(& param.aux_def_file), (char const   *)((void *)0)}, 
        {"Status file", & assign_string, & unassign_string, 0, 1, "var/lyskomd/db/status",
      (void *)(& param.status_file), (char const   *)((void *)0)}, 
        {"Connection status file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.clients",
      (void *)(& param.connection_status_file), (char const   *)((void *)0)}, 
        {"Connection status temp file", & assign_string, & unassign_string, 0, 1, "var/lyskomd.clnt.tmp",
      (void *)(& param.connection_status_file_tmp), (char const   *)((void *)0)}, 
        {"Core directory", & assign_string, & unassign_string, 0, 1, "var/lyskomd.cores",
      (void *)(& param.core_dir), (char const   *)((void *)0)}, 
        {"Nologin file", & assign_string, & unassign_string, 0, 1, "/etc/nologin", (void *)(& param.nologin_file),
      (char const   *)((void *)0)}, 
        {"Garb busy postponement", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "50", (void *)(& param.garb_busy_postponement), "milliseconds"}, 
        {"Garb timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.garbtimeout), "milliseconds"}, 
        {"Sync timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.synctimeout), "milliseconds"}, 
        {"Garb interval", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1440", (void *)(& param.garb_interval), "minutes"}, 
        {"Permissive sync", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "off", (void *)(& param.permissive_sync), (char const   *)((void *)0)}, 
        {"Sync interval",
      & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "5", (void *)(& param.sync_interval), "minutes"}, 
        {"Sync retry interval", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.sync_retry_interval), "minutes"}, 
        {"Saved items per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "5", (void *)(& param.saved_items_per_call), (char const   *)((void *)0)}, 
        {"Penalty per call",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "10", (void *)(& param.penalty_per_call), (char const   *)((void *)0)}, 
        {"Penalty per read", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1", (void *)(& param.penalty_per_read), (char const   *)((void *)0)}, 
        {"Max penalty",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "100", (void *)(& param.max_penalty), (char const   *)((void *)0)}, 
        {"Low penalty", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.low_penalty), (char const   *)((void *)0)}, 
        {"Default priority", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "0", (void *)(& param.default_priority), (char const   *)((void *)0)}, 
        {"Max priority",
      & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "0", (void *)(& param.max_priority), (char const   *)((void *)0)}, 
        {"Default weight", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.default_weight), (char const   *)((void *)0)}, 
        {"Max weight", & assign_uint, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "100", (void *)(& param.max_weight), (char const   *)((void *)0)}, 
        {"Connect timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "30", (void *)(& param.connect_timeout), "seconds"}, 
        {"Login timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "30", (void *)(& param.login_timeout), "minutes"}, 
        {"Active timeout", & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "11.5", (void *)(& param.active_timeout), "days"}, 
        {"Max client message size", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "8176", (void *)(& param.maxmsgsize), (char const   *)((void *)0)}, 
        {"Max client transmit queue messages", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "50", (void *)(& param.maxqueuedsize), (char const   *)((void *)0)}, 
        {"Max client transmit queue bytes", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "100000", (void *)(& param.maxqueuedsize_bytes), (char const   *)((void *)0)}, 
        {"Stale timeout",
      & assign_timeval, (void (*)(struct parameter  const  *par ))((void *)0), 0,
      1, "60", (void *)(& param.stale_timeout), "minutes"}, 
        {"Max simultaneous client replies", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "10", (void *)(& param.maxdequeuelen), (char const   *)((void *)0)}, 
        {"Open files", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "-1", (void *)(& param.no_files), (char const   *)((void *)0)}, 
        {"Use DNS", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "yes", (void *)(& param.use_dns), (char const   *)((void *)0)}, 
        {"DNS log threshold", & assign_double, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1.5", (void *)(& param.dns_log_threshold), (char const   *)((void *)0)}, 
        {"Max conference name length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "60",
      (void *)(& param.conf_name_len), (char const   *)((void *)0)}, 
        {"Max client data length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "60", (void *)(& param.client_data_len), (char const   *)((void *)0)}, 
        {"Max password length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.pwd_len), (char const   *)((void *)0)}, 
        {"Max what am I doing length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "60", (void *)(& param.what_do_len), (char const   *)((void *)0)}, 
        {"Max username length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.username_len), (char const   *)((void *)0)}, 
        {"Max text length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "131072", (void *)(& param.text_len), (char const   *)((void *)0)}, 
        {"Max aux_item length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "16384", (void *)(& param.aux_len), (char const   *)((void *)0)}, 
        {"Max broadcast length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "1024", (void *)(& param.broadcast_len), (char const   *)((void *)0)}, 
        {"Max regexp length",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "1024",
      (void *)(& param.regexp_len), (char const   *)((void *)0)}, 
        {"Statistic name length", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "64", (void *)(& param.stat_name_len), (char const   *)((void *)0)}, 
        {"Max marks per person", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "2048", (void *)(& param.max_marks_person), (char const   *)((void *)0)}, 
        {"Max marks per text",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "1024",
      (void *)(& param.max_marks_text), (char const   *)((void *)0)}, 
        {"Max recipients per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "512", (void *)(& param.max_recipients), (char const   *)((void *)0)}, 
        {"Max comments per text",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.max_comm), (char const   *)((void *)0)}, 
        {"Max footnotes per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "32", (void *)(& param.max_foot), (char const   *)((void *)0)}, 
        {"Max links per text", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "512", (void *)(& param.max_crea_misc), (char const   *)((void *)0)}, 
        {"Max mark_as_read chunks", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.mark_as_read_chunk), (char const   *)((void *)0)}, 
        {"Max accept_async len",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "128",
      (void *)(& param.accept_async_len), (char const   *)((void *)0)}, 
        {"Max aux_items added per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.max_add_aux), (char const   *)((void *)0)}, 
        {"Max aux_items deleted per call", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "128", (void *)(& param.max_delete_aux), (char const   *)((void *)0)}, 
        {"Max read_ranges per call",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "512",
      (void *)(& param.max_read_ranges), (char const   *)((void *)0)}, 
        {"Max super_conf loop", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "17", (void *)(& param.max_super_conf_loop), (char const   *)((void *)0)}, 
        {"Default garb nice",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "77",
      (void *)(& param.default_nice), (char const   *)((void *)0)}, 
        {"Default keep commented nice", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "77", (void *)(& param.default_keep_commented), (char const   *)((void *)0)}, 
        {"Anyone can create new persons",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.anyone_can_create_new_persons), (char const   *)((void *)0)}, 
        {"Anyone can create new conferences",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.anyone_can_create_new_confs), (char const   *)((void *)0)}, 
        {"Allow creation of persons before login",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "yes", (void *)(& param.create_person_before_login), (char const   *)((void *)0)}, 
        {"Default change name capability",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "on", (void *)(& param.default_change_name), (char const   *)((void *)0)}, 
        {"Add members by invitation", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "on", (void *)(& param.invite_by_default), (char const   *)((void *)0)}, 
        {"Allow secret memberships",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "on", (void *)(& param.secret_memberships), (char const   *)((void *)0)}, 
        {"Allow reinvitations", & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "off", (void *)(& param.allow_reinvite), (char const   *)((void *)0)}, 
        {"Log login",
      & assign_bool, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1,
      "off", (void *)(& param.log_login), (char const   *)((void *)0)}, 
        {"Ident-authentication", & ident_param___3, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "try", (void *)(& param.authentication_level), (char const   *)((void *)0)}, 
        {"Cache conference limit",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "20",
      (void *)(& param.cache_conferences), (char const   *)((void *)0)}, 
        {"Cache person limit", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.cache_persons), (char const   *)((void *)0)}, 
        {"Cache text_stat limit", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "20", (void *)(& param.cache_text_stats), (char const   *)((void *)0)}, 
        {"Echo",
      & log_param___3, (void (*)(struct parameter  const  *par ))((void *)0), 0, -1,
      (char const   *)((void *)0), (void *)0, (char const   *)((void *)0)}, 
        {"Jubel", & jubel___3, (void (*)(struct parameter  const  *par ))((void *)0),
      0, -1, (char const   *)((void *)0), (void *)0, (char const   *)((void *)0)}, 
        {"Max conferences",
      & assign_ulong, (void (*)(struct parameter  const  *par ))((void *)0), 1, 1,
      "4765", (void *)(& param.max_conf), (char const   *)((void *)0)}, 
        {"Max texts", & assign_ulong, (void (*)(struct parameter  const  *par ))((void *)0),
      1, 1, "2000000", (void *)(& param.max_text), (char const   *)((void *)0)}, 
        {"Normal shutdown time", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "21", (void *)(& param.normal_shutdown_time), (char const   *)((void *)0)}, 
        {"Mail after downtime",
      & assign_int, (void (*)(struct parameter  const  *par ))((void *)0), 0, 1, "60",
      (void *)(& param.downtime_mail_start), (char const   *)((void *)0)}, 
        {"Mail until downtime", & assign_int, (void (*)(struct parameter  const  *par ))((void *)0),
      0, 1, "120", (void *)(& param.downtime_mail_end), (char const   *)((void *)0)}, 
        {"sendmail path",
      & assign_string, & unassign_string, 0, 1, ":", (void *)(& param.sendmail_path),
      (char const   *)((void *)0)}, 
        {"lyskomd path", & assign_string, & unassign_string, 0, 1, "sbin/lyskomd", (void *)(& param.lyskomd_path),
      (char const   *)((void *)0)}, 
        {"savecore path", & assign_string, & unassign_string, 0, 1, "sbin/savecore-lyskom",
      (void *)(& param.savecore_path), (char const   *)((void *)0)}, 
        {(char const   *)((void *)0), (Success (*)(char const   *val , struct parameter  const  *par ))((void *)0),
      (void (*)(struct parameter  const  *par ))((void *)0), 0, 0, (char const   *)((void *)0),
      (void *)0, (char const   *)((void *)0)}};
#line 542 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   compiled_config_file___3[17]  = 
#line 542
  {      (char const   )'e',      (char const   )'t',      (char const   )'c',      (char const   )'/', 
        (char const   )'l',      (char const   )'y',      (char const   )'s',      (char const   )'k', 
        (char const   )'o',      (char const   )'m',      (char const   )'d',      (char const   )'.', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'f', 
        (char const   )'\000'};
#line 543 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   *default_config___3  =    (char const   *)((void *)0);
#line 584 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success log_param___3(char const   *val , struct parameter  const  *qazwsxedcpar  __attribute__((__unused__)) ) 
{ 


  {
#line 587
  if ((unsigned long )val != (unsigned long )((void *)0)) {
    {
#line 588
    kom_log("config: %s\n", val);
    }
  }
#line 589
  return ((Success )OK);
}
}
#line 592 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success jubel___3(char const   *val , struct parameter  const  *par ) 
{ 
  long a ;
  long b ;
  long c ;
  int res ;
  Bool public ;
  int tmp ;

  {
#line 597
  public = (Bool )0;
#line 599
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 600
    return ((Success )OK);
  }
  {
#line 602
  tmp = strncmp(val, "public ", (size_t )7);
  }
#line 602
  if (! tmp) {
#line 604
    public = (Bool )1;
#line 605
    val += 7;
  }
  {
#line 608
  res = sscanf((char const   */* __restrict  */)val, (char const   */* __restrict  */)"%ld %ld %ld",
               & a, & b, & c);
  }
  {
#line 611
  if (res == 3) {
#line 611
    goto case_3;
  }
#line 614
  if (res == 2) {
#line 614
    goto case_2;
  }
#line 617
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 612
  register_jubel((Pers_no )a, (Text_no )b, (Text_no )c, public);
  }
#line 613
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 615
  register_jubel((Pers_no )a, (Text_no )0, (Text_no )b, public);
  }
#line 616
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 618
  kom_log("%s expecting [public ] x y [z]\n", par->name);
  }
#line 619
  return ((Success )FAILURE);
  switch_break: /* CIL Label */ ;
  }
#line 621
  return ((Success )OK);
}
}
#line 624 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Success ident_param___3(char const   *val , struct parameter  const  *par ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 627
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    {
#line 628
    restart_kom("ident_param(): val == NULL\n");
    }
  }
  {
#line 629
  tmp___3 = strcmp(val, "off");
  }
#line 629
  if (tmp___3) {
    {
#line 629
    tmp___4 = strcmp(val, "never");
    }
#line 629
    if (tmp___4) {
      {
#line 634
      tmp___1 = strcmp(val, "on");
      }
#line 634
      if (tmp___1) {
        {
#line 634
        tmp___2 = strcmp(val, "try");
        }
#line 634
        if (tmp___2) {
          {
#line 639
          tmp = strcmp(val, "require");
          }
#line 639
          if (tmp) {
            {
#line 639
            tmp___0 = strcmp(val, "required");
            }
#line 639
            if (tmp___0) {
              {
#line 646
              kom_log("%s expects \"never\", \"try\" or \"required\" as argument\n",
                      par->name);
              }
#line 648
              return ((Success )FAILURE);
            } else {
#line 642
              *((int *)par->value) = 2;
            }
          } else {
#line 642
            *((int *)par->value) = 2;
          }
        } else {
#line 637
          *((int *)par->value) = 1;
        }
      } else {
#line 637
        *((int *)par->value) = 1;
      }
    } else {
#line 632
      *((int *)par->value) = 0;
    }
  } else {
#line 632
    *((int *)par->value) = 0;
  }
#line 650
  return ((Success )OK);
}
}
#line 653 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void add_prefix___3(char **name___0 ) 
{ 
  char *s ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 658
  if ((int )*(*name___0) == 47) {
#line 659
    return;
  }
  {
#line 661
  tmp = strlen((char const   *)param.dbase_dir);
#line 661
  tmp___0 = strlen((char const   *)*name___0);
#line 661
  tmp___1 = smalloc((2UL + tmp) + tmp___0);
#line 661
  s = (char *)tmp___1;
#line 662
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%s/%s", param.dbase_dir,
          *name___0);
#line 663
  sfree((void *)*name___0);
#line 664
  *name___0 = s;
  }
#line 665
  return;
}
}
#line 667 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static char const   *param_name___3(void *value ) 
{ 
  int ix ;

  {
#line 672
  ix = 0;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! ((unsigned long )parameters___3[ix].name != (unsigned long )((void *)0))) {
#line 672
      goto while_break;
    }
#line 673
    if ((unsigned long )parameters___3[ix].value == (unsigned long )value) {
#line 674
      return ((char const   *)parameters___3[ix].name);
    }
#line 672
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  restart_kom("Internal error: non-existing config param in param_name.\n");
  }
#line 678
  return ((char const   *)((void *)0));
}
}
#line 681 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static Bool check_abs_path___3(char **path ) 
{ 
  char const   *tmp ;

  {
#line 684
  if ((int )*(*path) == 47) {
#line 685
    return ((Bool )0);
  }
  {
#line 687
  tmp = param_name___3((void *)path);
#line 687
  kom_log("Parameter \'%s\' must be an absolute path when \'Prefix\' is empty.\n",
          tmp);
  }
#line 689
  return ((Bool )1);
}
}
#line 692 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void require_less___3(void *low , void *high ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 696
  tmp = param_name___3(high);
#line 696
  tmp___0 = param_name___3(low);
#line 696
  kom_log("Parameter \'%s\' must be less than parameter \'%s\'.\n", tmp___0, tmp);
  }
#line 699
  return;
}
}
#line 701 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/server-config.c"
static void require_less_eq___3(void *low , void *high ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 705
  tmp = param_name___3(high);
#line 705
  tmp___0 = param_name___3(low);
#line 705
  kom_log("Parameter \'%s\' must be less than or equal to parameter \'%s\'.\n", tmp___0,
          tmp);
  }
#line 708
  return;
}
}
#line 38 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static int L2G_BLOCKSIZE___0  =    -1;
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_constructs___0  =    0L;
#line 67 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_l2gs___0  =    0L;
#line 68 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_l2gs_peak___0  =    0L;
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_destructs___0  =    0L;
#line 70 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_clears___0  =    0L;
#line 71 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_copies___0  =    0L;
#line 72 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_joins___0  =    0L;
#line 73 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_joined_blocks___0  =    0L;
#line 74 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_blocks___0  =    0L;
#line 75 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_blocks_peak___0  =    0L;
#line 76 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_blocks_sparse___0  =    0L;
#line 77 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_blocks_sparse_peak___0  =    0L;
#line 78 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long sparse_skip_cost___0  =    0L;
#line 79 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_sparse_compactions___0  =    0L;
#line 80 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static long nr_sparsifications___0  =    0L;
#line 95 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
__inline static int is_empty___0(struct l2g_block_info  const  *binfo ) 
{ 


  {
#line 98
  return (binfo->zeroes == (int const   )L2G_BLOCKSIZE___0);
}
}
#line 112 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
__inline static int sparse_skip_deleted___0(struct l2g_block_info  const  *binfo ,
                                            int i ) 
{ 


  {
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (i < (int )binfo->first_free) {
#line 116
      if (! (*(binfo->value_block + i) == 0UL)) {
#line 116
        goto while_break;
      }
    } else {
#line 116
      goto while_break;
    }
#line 118
    sparse_skip_cost___0 ++;
#line 119
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (i);
}
}
#line 131 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
__inline static int sparse_locate_value___0(struct l2g_block_info  const  *binfo ,
                                            Local_text_no lno ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 137
  tmp = is_empty___0(binfo);
  }
#line 137
  if (tmp) {
    {
#line 137
    __assert_fail("!is_empty(binfo)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  137U, "sparse_locate_value");
    }
  }
  {
#line 138
  tmp___0 = is_dense(binfo);
  }
#line 138
  if (tmp___0) {
    {
#line 138
    __assert_fail("!is_dense(binfo)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  138U, "sparse_locate_value");
    }
  }
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (i < (int )binfo->first_free) {
#line 144
      if (! (*(binfo->key_block + i) < lno)) {
#line 144
        goto while_break;
      }
    } else {
#line 144
      goto while_break;
    }
#line 145
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  i = sparse_skip_deleted___0(binfo, i);
  }
#line 150
  if (! (i == (int )binfo->first_free)) {
#line 150
    if (! (*(binfo->key_block + i) >= lno)) {
      {
#line 150
      __assert_fail("i == binfo->first_free || binfo->key_block[i] >= lno", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    150U, "sparse_locate_value");
      }
    }
  }
#line 151
  if (! (i == (int )binfo->first_free)) {
#line 151
    if (! (*(binfo->value_block + i) != 0UL)) {
      {
#line 151
      __assert_fail("i == binfo->first_free || binfo->value_block[i] != 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    151U, "sparse_locate_value");
      }
    }
  }
#line 153
  return (i);
}
}
#line 156 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static void sparse_compact___0(struct l2g_block_info *binfo ) 
{ 
  int from ;
  int to ;

  {
#line 161
  if (binfo->first_free + binfo->zeroes == L2G_BLOCKSIZE___0) {
#line 162
    return;
  }
#line 164
  if (! (binfo->first_free + binfo->zeroes > L2G_BLOCKSIZE___0)) {
    {
#line 164
    __assert_fail("binfo->first_free + binfo->zeroes > L2G_BLOCKSIZE", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  164U, "sparse_compact");
    }
  }
#line 166
  to = 0;
#line 166
  from = to;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (from < binfo->first_free)) {
#line 166
      goto while_break;
    }
#line 167
    if (*(binfo->value_block + from) != 0UL) {
#line 169
      if (from != to) {
#line 171
        *(binfo->value_block + to) = *(binfo->value_block + from);
#line 172
        *(binfo->key_block + to) = *(binfo->key_block + from);
      }
#line 174
      to ++;
    }
#line 166
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  binfo->first_free = to;
#line 178
  if (! (binfo->first_free + binfo->zeroes == L2G_BLOCKSIZE___0)) {
    {
#line 178
    __assert_fail("binfo->first_free + binfo->zeroes == L2G_BLOCKSIZE", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  178U, "sparse_compact");
    }
  }
#line 179
  nr_sparse_compactions___0 ++;
#line 180
  return;
}
}
#line 191 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static struct l2g_block_info *add_block___0(Local_to_global *l2g ) 
{ 
  struct l2g_block_info *binfo ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 200
  (l2g->num_blocks) ++;
#line 201
  tmp = srealloc((void *)l2g->blocks, (unsigned long )l2g->num_blocks * sizeof(struct l2g_block_info ));
#line 201
  l2g->blocks = (struct l2g_block_info *)tmp;
#line 205
  binfo = l2g->blocks + (l2g->num_blocks - 1);
#line 206
  binfo->first_free = 0;
#line 207
  binfo->zeroes = L2G_BLOCKSIZE___0;
#line 209
  binfo->start = (Local_text_no )3735928559U;
#line 211
  binfo->key_block = (Local_text_no *)((void *)0);
#line 212
  tmp___0 = smalloc((unsigned long )L2G_BLOCKSIZE___0 * sizeof(Text_no ));
#line 212
  binfo->value_block = (Text_no *)tmp___0;
#line 215
  i = 0;
  }
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < L2G_BLOCKSIZE___0)) {
#line 215
      goto while_break;
    }
#line 216
    *(binfo->value_block + i) = (Text_no )3735928559U;
#line 215
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  nr_blocks___0 ++;
#line 218
  if (nr_blocks___0 > nr_blocks_peak___0) {
#line 219
    nr_blocks_peak___0 = nr_blocks___0;
  }
#line 221
  return (binfo);
}
}
#line 227 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static void add_block_before___0(Local_to_global *l2g , int position ) 
{ 
  struct l2g_block_info *binfo ;
  struct l2g_block_info *new_blocks ;
  int ix ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 236
  tmp = smalloc((unsigned long )(l2g->num_blocks + 1) * sizeof(struct l2g_block_info ));
#line 236
  new_blocks = (struct l2g_block_info *)tmp;
#line 239
  ix = 0;
  }
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! (ix < position)) {
#line 239
      goto while_break;
    }
#line 240
    *(new_blocks + ix) = *(l2g->blocks + ix);
#line 239
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  ix = position;
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 241
    if (! (ix < l2g->num_blocks)) {
#line 241
      goto while_break___0;
    }
#line 242
    *(new_blocks + (ix + 1)) = *(l2g->blocks + ix);
#line 241
    ix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 245
  sfree((void *)l2g->blocks);
#line 246
  l2g->blocks = new_blocks;
#line 247
  (l2g->num_blocks) ++;
#line 250
  binfo = new_blocks + position;
#line 251
  binfo->first_free = 0;
#line 252
  binfo->zeroes = L2G_BLOCKSIZE___0;
#line 254
  binfo->start = (Local_text_no )3735928559U;
#line 256
  binfo->key_block = (Local_text_no *)((void *)0);
#line 257
  tmp___0 = smalloc((unsigned long )L2G_BLOCKSIZE___0 * sizeof(Text_no ));
#line 257
  binfo->value_block = (Text_no *)tmp___0;
#line 260
  ix = 0;
  }
  {
#line 260
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 260
    if (! (ix < L2G_BLOCKSIZE___0)) {
#line 260
      goto while_break___1;
    }
#line 261
    *(binfo->value_block + ix) = (Text_no )3735928559U;
#line 260
    ix ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 263
  nr_blocks___0 ++;
#line 263
  if (nr_blocks___0 > nr_blocks_peak___0) {
#line 264
    nr_blocks_peak___0 = nr_blocks___0;
  }
#line 265
  return;
}
}
#line 273 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static void delete_block___0(Local_to_global *l2g , struct l2g_block_info *binfo ) 
{ 
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 277
  tmp = is_empty___0((struct l2g_block_info  const  *)binfo);
  }
#line 277
  if (! tmp) {
    {
#line 277
    __assert_fail("is_empty(binfo)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  277U, "delete_block");
    }
  }
  {
#line 279
  tmp___0 = is_dense((struct l2g_block_info  const  *)binfo);
  }
#line 279
  if (! tmp___0) {
#line 280
    nr_blocks_sparse___0 --;
  }
#line 281
  nr_blocks___0 --;
#line 284
  if ((unsigned long )binfo->key_block != (unsigned long )((void *)0)) {
    {
#line 285
    sfree((void *)binfo->key_block);
    }
  }
  {
#line 286
  sfree((void *)binfo->value_block);
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    binfo ++;
#line 289
    if (! ((unsigned long )binfo < (unsigned long )(l2g->blocks + l2g->num_blocks))) {
#line 289
      goto while_break;
    }
#line 290
    *(binfo - 1) = *binfo;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 291
  (l2g->num_blocks) --;
#line 292
  tmp___1 = srealloc((void *)l2g->blocks, (unsigned long )l2g->num_blocks * sizeof(struct l2g_block_info ));
#line 292
  l2g->blocks = (struct l2g_block_info *)tmp___1;
  }
#line 294
  return;
}
}
#line 300 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static void make_sparse___0(struct l2g_block_info *binfo ) 
{ 
  int next ;
  int i ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 306
  tmp = is_dense((struct l2g_block_info  const  *)binfo);
  }
#line 306
  if (! tmp) {
    {
#line 306
    __assert_fail("is_dense(binfo)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  306U, "make_sparse");
    }
  }
#line 307
  nr_blocks_sparse___0 ++;
#line 307
  if (nr_blocks_sparse___0 > nr_blocks_sparse_peak___0) {
#line 308
    nr_blocks_sparse_peak___0 = nr_blocks_sparse___0;
  }
  {
#line 309
  nr_sparsifications___0 ++;
#line 312
  tmp___0 = smalloc((unsigned long )L2G_BLOCKSIZE___0 * sizeof(Local_text_no ));
#line 312
  binfo->key_block = (Local_text_no *)tmp___0;
#line 314
  i = 0;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (i < L2G_BLOCKSIZE___0)) {
#line 314
      goto while_break;
    }
#line 315
    *(binfo->key_block + i) = 3735928559UL;
#line 314
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  next = 0;
#line 320
  i = 0;
  {
#line 320
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 320
    if (! (i < binfo->first_free)) {
#line 320
      goto while_break___0;
    }
#line 321
    if (*(binfo->value_block + i) != 0UL) {
#line 323
      *(binfo->key_block + next) = binfo->start + (Local_text_no )i;
#line 324
      *(binfo->value_block + next) = *(binfo->value_block + i);
#line 325
      next ++;
    }
#line 320
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 329
  binfo->first_free = next;
#line 330
  binfo->zeroes = L2G_BLOCKSIZE___0 - next;
#line 331
  return;
}
}
#line 346 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static struct l2g_block_info *find_block___0(Local_to_global const   *l2g , Local_text_no lno ) 
{ 
  struct l2g_block_info *binfo ;

  {
#line 352
  if (l2g->num_blocks == 0) {
#line 353
    return ((struct l2g_block_info *)((void *)0));
  }
#line 356
  binfo = l2g->blocks + (l2g->num_blocks - 1);
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! ((unsigned long )binfo > (unsigned long )l2g->blocks)) {
#line 360
      goto while_break;
    }
#line 362
    if (lno >= binfo->start) {
#line 363
      return (binfo);
    }
#line 364
    binfo --;
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  return (binfo);
}
}
#line 378 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static Local_text_no find_block_index_key___0(Local_to_global const   *l2g , Local_text_no lno ,
                                              struct l2g_block_info  const  **binfo_out ,
                                              int *index_out ) 
{ 
  struct l2g_block_info  const  *binfo ;
  int i ;
  struct l2g_block_info *tmp ;
  int tmp___0 ;
  Local_text_no tmp___1 ;

  {
  {
#line 387
  tmp = find_block___0(l2g, lno);
#line 387
  binfo = (struct l2g_block_info  const  *)tmp;
  }
#line 388
  if ((unsigned long )binfo == (unsigned long )((void *)0)) {
#line 389
    return ((Local_text_no )0);
  }
#line 394
  if (lno >= (Local_text_no )binfo->start) {
    {
#line 398
    tmp___0 = is_dense(binfo);
    }
#line 398
    if (tmp___0) {
#line 400
      i = (int )((lno - (Local_text_no )binfo->start) + 1UL);
      {
#line 400
      while (1) {
        while_continue: /* CIL Label */ ;
#line 400
        if (! (i < (int )binfo->first_free)) {
#line 400
          goto while_break;
        }
#line 401
        if (*(binfo->value_block + i) != 0UL) {
#line 403
          *binfo_out = binfo;
#line 404
          *index_out = i;
#line 406
          return ((Local_text_no )(binfo->start + (Local_text_no const   )i));
        }
#line 400
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 411
      i = sparse_locate_value___0(binfo, lno);
      }
#line 412
      if (i < (int )binfo->first_free) {
#line 412
        if (*(binfo->key_block + i) == lno) {
#line 413
          i ++;
        }
      }
      {
#line 414
      i = sparse_skip_deleted___0(binfo, i);
      }
#line 415
      if (i < (int )binfo->first_free) {
#line 417
        *binfo_out = binfo;
#line 418
        *index_out = i;
#line 420
        return (*(binfo->key_block + i));
      }
    }
#line 427
    binfo ++;
  }
#line 434
  if ((unsigned long )binfo >= (unsigned long )(l2g->blocks + l2g->num_blocks)) {
#line 435
    return ((Local_text_no )0);
  }
#line 437
  i = 0;
  {
#line 437
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 437
    if (! (i < (int )binfo->first_free)) {
#line 437
      goto while_break___0;
    }
#line 438
    if (*(binfo->value_block + i) != 0UL) {
      {
#line 440
      *binfo_out = binfo;
#line 441
      *index_out = i;
#line 442
      tmp___1 = key_value(binfo, i);
      }
#line 442
      return (tmp___1);
    }
#line 437
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 445
  restart_kom("find_block_index_key found nothing\n");
  }
}
}
#line 455 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static Local_text_no find_block_index_key_reverse___0(Local_to_global const   *l2g ,
                                                      Local_text_no lno , struct l2g_block_info  const  **binfo_out ,
                                                      int *index_out ) 
{ 
  struct l2g_block_info  const  *binfo ;
  int i ;
  struct l2g_block_info *tmp ;
  int tmp___0 ;
  Local_text_no tmp___1 ;

  {
#line 465
  if (lno > 0UL) {
#line 466
    lno --;
  }
  {
#line 469
  tmp = find_block___0(l2g, lno);
#line 469
  binfo = (struct l2g_block_info  const  *)tmp;
  }
#line 470
  if ((unsigned long )binfo == (unsigned long )((void *)0)) {
#line 471
    return ((Local_text_no )0);
  }
#line 474
  if (lno < (Local_text_no )binfo->start) {
#line 475
    return ((Local_text_no )0);
  }
  {
#line 478
  tmp___0 = is_dense(binfo);
  }
#line 478
  if (tmp___0) {
#line 480
    i = (int )(lno - (Local_text_no )binfo->start);
#line 481
    if (i >= (int )binfo->first_free) {
#line 482
      i = (int )(binfo->first_free - 1);
    }
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
#line 483
      if (! (i >= 0)) {
#line 483
        goto while_break;
      }
#line 484
      if (*(binfo->value_block + i) != 0UL) {
#line 486
        *binfo_out = binfo;
#line 487
        *index_out = i;
#line 489
        return ((Local_text_no )(binfo->start + (Local_text_no const   )i));
      }
#line 483
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 494
    i = sparse_locate_value___0(binfo, lno);
    }
#line 495
    if (i >= (int )binfo->first_free) {
#line 496
      i = (int )(binfo->first_free - 1);
    }
    {
#line 497
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 497
      if (i > 0) {
#line 497
        if (! (*(binfo->value_block + i) == 0UL)) {
#line 497
          if (! (*(binfo->key_block + i) > lno)) {
#line 497
            goto while_break___0;
          }
        }
      } else {
#line 497
        goto while_break___0;
      }
#line 500
      sparse_skip_cost___0 ++;
#line 501
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 503
    if (*(binfo->value_block + i) != 0UL) {
#line 503
      if (*(binfo->key_block + i) <= lno) {
#line 505
        *binfo_out = binfo;
#line 506
        *index_out = i;
#line 508
        return (*(binfo->key_block + i));
      }
    }
  }
#line 515
  if ((unsigned long )binfo == (unsigned long )l2g->blocks) {
#line 516
    return ((Local_text_no )0);
  }
#line 518
  binfo --;
#line 524
  i = (int )(binfo->first_free - 1);
  {
#line 524
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 524
    if (! (i >= 0)) {
#line 524
      goto while_break___1;
    }
#line 525
    if (*(binfo->value_block + i) != 0UL) {
      {
#line 527
      *binfo_out = binfo;
#line 528
      *index_out = i;
#line 529
      tmp___1 = key_value(binfo, i);
      }
#line 529
      return (tmp___1);
    }
#line 524
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 532
  restart_kom("find_block_index_key_reverse found nothing\n");
  }
}
}
#line 535 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static void join_range___0(Local_to_global *l2g , struct l2g_block_info *first , struct l2g_block_info *last___0 ) 
{ 
  int next ;
  int i ;
  struct l2g_block_info *binfo ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 544
  if (! ((unsigned long )first < (unsigned long )last___0)) {
    {
#line 544
    __assert_fail("first < last", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  544U, "join_range");
    }
  }
#line 545
  if ((unsigned long )l2g->blocks <= (unsigned long )first) {
#line 545
    if (! ((unsigned long )first < (unsigned long )(l2g->blocks + l2g->num_blocks))) {
      {
#line 545
      __assert_fail("l2g->blocks <= first && first < l2g->blocks + l2g->num_blocks",
                    "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    545U, "join_range");
      }
    }
  } else {
    {
#line 545
    __assert_fail("l2g->blocks <= first && first < l2g->blocks + l2g->num_blocks",
                  "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  545U, "join_range");
    }
  }
#line 546
  if ((unsigned long )l2g->blocks <= (unsigned long )last___0) {
#line 546
    if (! ((unsigned long )last___0 < (unsigned long )(l2g->blocks + l2g->num_blocks))) {
      {
#line 546
      __assert_fail("l2g->blocks <= last && last < l2g->blocks + l2g->num_blocks",
                    "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    546U, "join_range");
      }
    }
  } else {
    {
#line 546
    __assert_fail("l2g->blocks <= last && last < l2g->blocks + l2g->num_blocks", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  546U, "join_range");
    }
  }
  {
#line 548
  tmp = is_dense((struct l2g_block_info  const  *)first);
  }
#line 548
  if (tmp) {
    {
#line 549
    make_sparse___0(first);
    }
  } else {
    {
#line 551
    sparse_compact___0(first);
    }
  }
#line 553
  nr_joins___0 ++;
#line 554
  next = first->first_free;
#line 555
  binfo = first + 1;
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! ((unsigned long )binfo <= (unsigned long )last___0)) {
#line 555
      goto while_break;
    }
#line 557
    nr_joined_blocks___0 ++;
#line 558
    i = 0;
    {
#line 558
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 558
      if (! (i < binfo->first_free)) {
#line 558
        goto while_break___0;
      }
#line 559
      if (*(binfo->value_block + i) != 0UL) {
        {
#line 561
        *(first->value_block + next) = *(binfo->value_block + i);
#line 562
        *(first->key_block + next) = key_value((struct l2g_block_info  const  *)binfo,
                                               i);
#line 563
        next ++;
        }
      }
#line 558
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 565
    tmp___0 = is_dense((struct l2g_block_info  const  *)binfo);
    }
#line 565
    if (! tmp___0) {
      {
#line 567
      nr_blocks_sparse___0 --;
#line 568
      sfree((void *)binfo->key_block);
      }
    }
    {
#line 570
    sfree((void *)binfo->value_block);
#line 555
    binfo ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 573
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 573
    if (! ((unsigned long )binfo < (unsigned long )(l2g->blocks + l2g->num_blocks))) {
#line 573
      goto while_break___1;
    }
#line 575
    if (! ((unsigned long )(binfo - (last___0 - first)) > (unsigned long )first)) {
      {
#line 575
      __assert_fail("binfo - (last - first) > first", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                    575U, "join_range");
      }
    }
#line 576
    *(binfo - (last___0 - first)) = *binfo;
#line 577
    binfo ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 580
  if (! (next <= L2G_BLOCKSIZE___0)) {
    {
#line 580
    __assert_fail("next <= L2G_BLOCKSIZE", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c",
                  580U, "join_range");
    }
  }
  {
#line 581
  first->first_free = next;
#line 582
  first->zeroes = L2G_BLOCKSIZE___0 - next;
#line 584
  nr_blocks___0 -= last___0 - first;
#line 585
  l2g->num_blocks = (int )((long )l2g->num_blocks - (last___0 - first));
#line 586
  tmp___1 = srealloc((void *)l2g->blocks, (unsigned long )l2g->num_blocks * sizeof(struct l2g_block_info ));
#line 586
  l2g->blocks = (struct l2g_block_info *)tmp___1;
  }
#line 588
  return;
}
}
#line 591 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static int join_blocks___0(Local_to_global *l2g , struct l2g_block_info *binfo ) 
{ 
  int zeroes ;
  int gain ;
  int best ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 600
  if (binfo->zeroes == 0) {
#line 602
    return (0);
  }
#line 609
  zeroes = L2G_BLOCKSIZE___0;
#line 610
  gain = 0;
#line 611
  best = 0;
#line 613
  i = 0;
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if (zeroes > 0) {
#line 613
      if (! ((long )i <= binfo - l2g->blocks)) {
#line 613
        goto while_break;
      }
    } else {
#line 613
      goto while_break;
    }
    {
#line 615
    zeroes -= L2G_BLOCKSIZE___0 - (binfo - i)->zeroes;
#line 616
    tmp___1 = is_dense((struct l2g_block_info  const  *)(binfo - i));
    }
#line 616
    if (tmp___1) {
#line 616
      tmp___0 = 1;
    } else {
#line 616
      tmp___0 = 2;
    }
#line 616
    gain += tmp___0;
#line 617
    if (gain > 2) {
#line 617
      if (zeroes >= 0) {
#line 618
        best = i;
      }
    }
#line 613
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  if (best > 0) {
    {
#line 623
    join_range___0(l2g, binfo - best, binfo);
    }
#line 624
    return (1);
  }
#line 627
  zeroes = L2G_BLOCKSIZE___0;
#line 628
  gain = 0;
#line 629
  best = 0;
#line 630
  i = 0;
  {
#line 630
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 630
    if (zeroes > 0) {
#line 630
      if (! ((long )i < (long )l2g->num_blocks - (binfo - l2g->blocks))) {
#line 630
        goto while_break___0;
      }
    } else {
#line 630
      goto while_break___0;
    }
    {
#line 632
    zeroes -= L2G_BLOCKSIZE___0 - (binfo + i)->zeroes;
#line 633
    tmp___4 = is_dense((struct l2g_block_info  const  *)(binfo + i));
    }
#line 633
    if (tmp___4) {
#line 633
      tmp___3 = 1;
    } else {
#line 633
      tmp___3 = 2;
    }
#line 633
    gain += tmp___3;
#line 634
    if (gain > 2) {
#line 634
      if (zeroes >= 0) {
#line 635
        best = i;
      }
    }
#line 630
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 638
  if (best > 0) {
    {
#line 640
    join_range___0(l2g, binfo, binfo + best);
    }
#line 641
    return (1);
  }
#line 644
  return (0);
}
}
#line 1251 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static char buf___2[25UL]  ;
#line 1247 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/local-to-global.c"
static void put_ulong___0(unsigned long l , FILE *fp ) 
{ 
  char *cp ;

  {
#line 1254
  if (l < 10UL) {
    {
#line 1255
    _IO_putc((int )*("0123456789" + l), fp);
    }
  } else {
#line 1258
    cp = buf___2 + sizeof(buf___2);
    {
#line 1259
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1259
      if (! (l > 0UL)) {
#line 1259
        goto while_break;
      }
#line 1261
      cp --;
#line 1261
      *cp = (char )(l % 10UL + 48UL);
#line 1262
      l /= 10UL;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1264
    fwrite((void const   */* __restrict  */)cp, (size_t )((buf___2 + sizeof(buf___2)) - cp),
           (size_t )1, (FILE */* __restrict  */)fp);
    }
  }
#line 1266
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_aux_item_list___0(FILE *fp , Aux_item_list const   *aux ) ;
#line 54
static void foutput_conf_type___0(FILE *fp , Conf_type type ) ;
#line 55
static void foutput_mark___0(FILE *fp , Mark mark ) ;
#line 56
static void foutput_mark_list___0(FILE *fp , Mark_list const   mark_list ) ;
#line 57
static void foutput_member___0(FILE *fp , Member member ) ;
#line 58
static void foutput_member_list___0(FILE *fp , Member_list m_list ) ;
#line 59
static void foutput_membership_list___0(FILE *fp , Membership_list mlist ) ;
#line 60
static void foutput_misc_info___0(FILE *fp , Misc_info misc ) ;
#line 61
static void foutput_personal_flags___0(FILE *fp , Personal_flags flags ) ;
#line 62
static void foutput_priv_bits___0(FILE *fp , Priv_bits bits ) ;
#line 63
static void foutput_string___0(FILE *fp , String str ) ;
#line 64
static void foutput_text_list___0(FILE *fp , Local_to_global const   *text_list ) ;
#line 65
static void foutput_time___0(FILE *fp , time_t clk ) ;
#line 66
static void foutput_ulong___0(unsigned long l , FILE *fp ) ;
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static int output_format___0  =    2;
#line 87 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_info_0___0(FILE *fp , Info *info ) 
{ 


  {
  {
#line 90
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu",
          (unsigned long )info->conf_pres_conf, (unsigned long )info->pers_pres_conf,
          (unsigned long )info->motd_conf, (unsigned long )info->kom_news_conf, info->motd_of_lyskom);
  }
#line 96
  return;
}
}
#line 98 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_info_2___0(FILE *fp , Info *info ) 
{ 


  {
  {
#line 101
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu %lu",
          (unsigned long )info->conf_pres_conf, (unsigned long )info->pers_pres_conf,
          (unsigned long )info->motd_conf, (unsigned long )info->kom_news_conf, info->motd_of_lyskom,
          info->highest_aux_no);
#line 108
  foutput_aux_item_list___0(fp, (Aux_item_list const   *)(& info->aux_item_list));
  }
#line 109
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_person_0___0(FILE *fp , Person const   *person ) 
{ 


  {
  {
#line 134
  foutput_string___0(fp, (String )person->username);
#line 135
  foutput_priv_bits___0(fp, (Priv_bits )person->privileges);
#line 136
  foutput_personal_flags___0(fp, (Personal_flags )person->flags);
#line 138
  foutput_text_list___0(fp, & person->created_texts);
#line 139
  foutput_mark_list___0(fp, person->marks);
#line 140
  foutput_membership_list___0(fp, (Membership_list )person->conferences);
#line 142
  foutput_time___0(fp, (time_t )person->last_login);
#line 144
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu %lu %lu %lu %lu",
          (unsigned long )person->user_area, (unsigned long )person->total_time_present,
          (unsigned long )person->sessions, (unsigned long )person->created_lines,
          (unsigned long )person->created_bytes, (unsigned long )person->read_texts,
          (unsigned long )person->no_of_text_fetches, (unsigned long )person->created_persons,
          (unsigned long )person->created_confs);
  }
#line 156
  return;
}
}
#line 158 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_person_2___0(FILE *fp , Person const   *person ) 
{ 


  {
  {
#line 162
  foutput_string___0(fp, (String )person->username);
#line 163
  foutput_priv_bits___0(fp, (Priv_bits )person->privileges);
#line 164
  foutput_personal_flags___0(fp, (Personal_flags )person->flags);
#line 166
  _IO_putc(' ', fp);
#line 167
  l2g_write(fp, & person->created_texts);
#line 168
  foutput_mark_list___0(fp, person->marks);
#line 169
  foutput_membership_list___0(fp, (Membership_list )person->conferences);
#line 171
  foutput_time___0(fp, (time_t )person->last_login);
#line 173
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu %lu %lu %lu %lu",
          (unsigned long )person->user_area, (unsigned long )person->total_time_present,
          (unsigned long )person->sessions, (unsigned long )person->created_lines,
          (unsigned long )person->created_bytes, (unsigned long )person->read_texts,
          (unsigned long )person->no_of_text_fetches, (unsigned long )person->created_persons,
          (unsigned long )person->created_confs);
  }
#line 185
  return;
}
}
#line 207 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_conference_2___0(FILE *fp , Conference const   *conf_c ) 
{ 


  {
  {
#line 211
  foutput_string___0(fp, (String )conf_c->name);
#line 212
  foutput_member_list___0(fp, (Member_list )conf_c->members);
#line 213
  _IO_putc(' ', fp);
#line 214
  l2g_write(fp, & conf_c->texts);
#line 215
  foutput_conf_type___0(fp, (Conf_type )conf_c->type);
#line 217
  foutput_time___0(fp, (time_t )conf_c->creation_time);
#line 218
  foutput_time___0(fp, (time_t )conf_c->last_written);
#line 220
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu %lu %lu",
          (unsigned long )conf_c->creator, (unsigned long )conf_c->presentation, (unsigned long )conf_c->supervisor,
          (unsigned long )conf_c->permitted_submitters, (unsigned long )conf_c->super_conf,
          (unsigned long )conf_c->msg_of_day, (unsigned long )conf_c->nice);
#line 228
  foutput_ulong___0((unsigned long )conf_c->keep_commented, fp);
#line 229
  foutput_ulong___0((unsigned long )conf_c->expire, fp);
#line 230
  foutput_ulong___0((unsigned long )conf_c->highest_aux, fp);
#line 231
  foutput_aux_item_list___0(fp, & conf_c->aux_item_list);
  }
#line 232
  return;
}
}
#line 234 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_conference_1___0(FILE *fp , Conference *conf_c ) 
{ 


  {
  {
#line 238
  foutput_string___0(fp, conf_c->name);
#line 239
  foutput_member_list___0(fp, conf_c->members);
#line 240
  foutput_text_list___0(fp, (Local_to_global const   *)(& conf_c->texts));
#line 241
  foutput_conf_type___0(fp, conf_c->type);
#line 243
  foutput_time___0(fp, conf_c->creation_time);
#line 244
  foutput_time___0(fp, conf_c->last_written);
#line 246
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu %lu %lu",
          (unsigned long )conf_c->creator, conf_c->presentation, (unsigned long )conf_c->supervisor,
          (unsigned long )conf_c->permitted_submitters, (unsigned long )conf_c->super_conf,
          conf_c->msg_of_day, conf_c->nice);
  }
#line 254
  return;
}
}
#line 256 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_conference_0___0(FILE *fp , Conference *conf_c ) 
{ 


  {
  {
#line 260
  foutput_string___0(fp, conf_c->name);
#line 261
  foutput_member_list___0(fp, conf_c->members);
#line 262
  foutput_text_list___0(fp, (Local_to_global const   *)(& conf_c->texts));
#line 263
  foutput_conf_type___0(fp, conf_c->type);
#line 265
  foutput_time___0(fp, conf_c->creation_time);
#line 266
  foutput_time___0(fp, conf_c->last_written);
#line 268
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu %lu %lu %lu %lu %lu",
          (unsigned long )conf_c->creator, conf_c->presentation, (unsigned long )conf_c->supervisor,
          (unsigned long )conf_c->permitted_submitters, (unsigned long )conf_c->super_conf,
          conf_c->msg_of_day, conf_c->nice);
  }
#line 276
  return;
}
}
#line 300 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_text_stat_0___0(FILE *fp , Text_stat *t_stat ) 
{ 
  int i ;

  {
  {
#line 306
  foutput_time___0(fp, t_stat->creation_time);
#line 308
  foutput_ulong___0((unsigned long )t_stat->author, fp);
#line 309
  foutput_ulong___0((unsigned long )t_stat->file_pos, fp);
#line 310
  foutput_ulong___0((unsigned long )t_stat->no_of_lines, fp);
#line 311
  foutput_ulong___0((unsigned long )t_stat->no_of_chars, fp);
#line 312
  foutput_ulong___0((unsigned long )t_stat->no_of_marks, fp);
#line 313
  foutput_ulong___0((unsigned long )t_stat->no_of_misc, fp);
  }
#line 315
  if ((unsigned long )t_stat->misc_items != (unsigned long )((void *)0)) {
#line 315
    if ((int )t_stat->no_of_misc > 0) {
      {
#line 317
      fputs((char const   */* __restrict  */)" {", (FILE */* __restrict  */)fp);
#line 318
      i = 0;
      }
      {
#line 318
      while (1) {
        while_continue: /* CIL Label */ ;
#line 318
        if (! (i < (int )t_stat->no_of_misc)) {
#line 318
          goto while_break;
        }
        {
#line 319
        foutput_misc_info___0(fp, *(t_stat->misc_items + i));
#line 318
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 320
      fputs((char const   */* __restrict  */)" }", (FILE */* __restrict  */)fp);
      }
    } else {
      {
#line 323
      fputs((char const   */* __restrict  */)" *", (FILE */* __restrict  */)fp);
      }
    }
  } else {
    {
#line 323
    fputs((char const   */* __restrict  */)" *", (FILE */* __restrict  */)fp);
    }
  }
#line 324
  return;
}
}
#line 326 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_text_stat_2___0(FILE *fp , Text_stat *t_stat ) 
{ 
  int i ;

  {
  {
#line 332
  foutput_time___0(fp, t_stat->creation_time);
#line 334
  foutput_ulong___0((unsigned long )t_stat->author, fp);
#line 335
  foutput_ulong___0((unsigned long )t_stat->file_pos, fp);
#line 336
  foutput_ulong___0((unsigned long )t_stat->no_of_lines, fp);
#line 337
  foutput_ulong___0((unsigned long )t_stat->no_of_chars, fp);
#line 338
  foutput_ulong___0((unsigned long )t_stat->no_of_marks, fp);
#line 339
  foutput_ulong___0((unsigned long )t_stat->no_of_misc, fp);
  }
#line 341
  if ((unsigned long )t_stat->misc_items != (unsigned long )((void *)0)) {
#line 341
    if ((int )t_stat->no_of_misc > 0) {
      {
#line 343
      fputs((char const   */* __restrict  */)" {", (FILE */* __restrict  */)fp);
#line 344
      i = 0;
      }
      {
#line 344
      while (1) {
        while_continue: /* CIL Label */ ;
#line 344
        if (! (i < (int )t_stat->no_of_misc)) {
#line 344
          goto while_break;
        }
        {
#line 345
        foutput_misc_info___0(fp, *(t_stat->misc_items + i));
#line 344
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 346
      fputs((char const   */* __restrict  */)" }", (FILE */* __restrict  */)fp);
      }
    } else {
      {
#line 349
      fputs((char const   */* __restrict  */)" *", (FILE */* __restrict  */)fp);
      }
    }
  } else {
    {
#line 349
    fputs((char const   */* __restrict  */)" *", (FILE */* __restrict  */)fp);
    }
  }
  {
#line 351
  foutput_ulong___0(t_stat->highest_aux, fp);
#line 352
  foutput_aux_item_list___0(fp, (Aux_item_list const   *)(& t_stat->aux_item_list));
  }
#line 353
  return;
}
}
#line 376 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_aux_flags___0(FILE *fp , Aux_item_flags f ) 
{ 


  {
  {
#line 380
  _IO_putc(' ', fp);
#line 381
  _IO_putc((int )(f.deleted + 48U), fp);
#line 382
  _IO_putc((int )(f.inherit + 48U), fp);
#line 383
  _IO_putc((int )(f.secret + 48U), fp);
#line 384
  _IO_putc((int )(f.hide_creator + 48U), fp);
#line 385
  _IO_putc((int )(f.dont_garb + 48U), fp);
#line 386
  _IO_putc((int )(f.reserved3 + 48U), fp);
#line 387
  _IO_putc((int )(f.reserved4 + 48U), fp);
#line 388
  _IO_putc((int )(f.reserved5 + 48U), fp);
  }
#line 389
  return;
}
}
#line 391 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_aux_item_link___0(FILE *fp , Aux_item_link *link ) 
{ 


  {
  {
#line 395
  foutput_ulong___0((unsigned long )link->target_type, fp);
#line 396
  foutput_ulong___0(link->target_item, fp);
  }
  {
#line 399
  if ((unsigned int )link->target_type == 2U) {
#line 399
    goto case_2;
  }
#line 402
  if ((unsigned int )link->target_type == 1U) {
#line 402
    goto case_1;
  }
#line 405
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 400
  foutput_ulong___0((unsigned long )link->target_object.conf, fp);
  }
#line 401
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 403
  foutput_ulong___0(link->target_object.text, fp);
  }
#line 404
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 408
  return;
}
}
#line 410 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_aux_item___0(FILE *fp , Aux_item *a_item ) 
{ 


  {
  {
#line 414
  foutput_ulong___0(a_item->aux_no, fp);
#line 415
  foutput_ulong___0(a_item->tag, fp);
#line 416
  foutput_ulong___0((unsigned long )a_item->creator, fp);
#line 417
  foutput_time___0(fp, a_item->sent_at);
#line 418
  foutput_aux_flags___0(fp, a_item->flags);
#line 419
  foutput_ulong___0(a_item->inherit_limit, fp);
#line 420
  foutput_string___0(fp, a_item->data);
#line 421
  foutput_aux_item_link___0(fp, & a_item->linked_item);
  }
#line 422
  return;
}
}
#line 424 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_aux_item_list___0(FILE *fp , Aux_item_list const   *aux ) 
{ 
  int i ;

  {
  {
#line 430
  foutput_ulong___0((unsigned long )aux->length, fp);
  }
#line 431
  if (aux->items) {
#line 431
    if ((int const   )aux->length > 0) {
      {
#line 433
      fputs((char const   */* __restrict  */)" {", (FILE */* __restrict  */)fp);
#line 434
      i = 0;
      }
      {
#line 434
      while (1) {
        while_continue: /* CIL Label */ ;
#line 434
        if (! (i < (int )aux->length)) {
#line 434
          goto while_break;
        }
        {
#line 435
        foutput_aux_item___0(fp, aux->items + i);
#line 434
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 436
      fputs((char const   */* __restrict  */)" }", (FILE */* __restrict  */)fp);
      }
    } else {
      {
#line 439
      fputs((char const   */* __restrict  */)" *", (FILE */* __restrict  */)fp);
      }
    }
  } else {
    {
#line 439
    fputs((char const   */* __restrict  */)" *", (FILE */* __restrict  */)fp);
    }
  }
#line 440
  return;
}
}
#line 443 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_membership_type___0(FILE *fp , Membership_type type ) 
{ 


  {
  {
#line 447
  _IO_putc(' ', fp);
#line 448
  _IO_putc((int )(type.invitation + 48U), fp);
#line 449
  _IO_putc((int )(type.passive + 48U), fp);
#line 450
  _IO_putc((int )(type.secret + 48U), fp);
#line 451
  _IO_putc((int )(type.passive_message_invert + 48U), fp);
#line 452
  _IO_putc((int )(type.reserved2 + 48U), fp);
#line 453
  _IO_putc((int )(type.reserved3 + 48U), fp);
#line 454
  _IO_putc((int )(type.reserved4 + 48U), fp);
#line 455
  _IO_putc((int )(type.reserved5 + 48U), fp);
  }
#line 456
  return;
}
}
#line 458 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_read_ranges_0___0(FILE *fp , Membership *mship ) 
{ 
  struct read_range *begin ;
  struct read_range *end ;
  unsigned long no_of_read ;
  struct read_range  const  *ptr ;
  Local_text_no lno ;

  {
#line 462
  if ((unsigned long )mship->read_ranges == (unsigned long )((void *)0)) {
#line 462
    if (mship->no_of_read_ranges != 0U) {
      {
#line 464
      kom_log("foutput_read_ranges_0(): no_of_read_ranges forced to 0 in a membership in %lu.\n",
              (unsigned long )mship->conf_no);
#line 466
      mship->no_of_read_ranges = 0U;
      }
    }
  }
#line 469
  if (mship->no_of_read_ranges == 0U) {
    {
#line 470
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" 0 0 *");
    }
  } else {
#line 476
    begin = mship->read_ranges + 0;
#line 477
    end = begin + mship->no_of_read_ranges;
#line 479
    if (begin->first_read == 1UL) {
      {
#line 481
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu",
              begin->last_read);
#line 482
      begin ++;
      }
    } else {
      {
#line 485
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" 0");
      }
    }
#line 487
    if ((unsigned long )begin == (unsigned long )end) {
      {
#line 488
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" 0 *");
      }
    } else {
#line 491
      no_of_read = 0UL;
#line 494
      ptr = (struct read_range  const  *)begin;
      {
#line 494
      while (1) {
        while_continue: /* CIL Label */ ;
#line 494
        if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 494
          goto while_break;
        }
#line 495
        no_of_read += (unsigned long )((ptr->last_read - ptr->first_read) + 1UL);
#line 494
        ptr ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 497
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu {",
              no_of_read);
#line 499
      ptr = (struct read_range  const  *)begin;
      }
      {
#line 499
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 499
        if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 499
          goto while_break___0;
        }
#line 503
        lno = (Local_text_no )ptr->first_read;
        {
#line 503
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 503
          if (! (lno <= (Local_text_no )ptr->last_read)) {
#line 503
            goto while_break___1;
          }
          {
#line 504
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu",
                  lno);
#line 503
          lno ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 499
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 507
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" }");
      }
    }
  }
#line 510
  return;
}
}
#line 512 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_membership_0___0(FILE *fp , Membership *mship ) 
{ 


  {
  {
#line 516
  foutput_time___0(fp, mship->last_time_read);
#line 518
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu",
          (unsigned long )mship->conf_no, (unsigned long )mship->priority);
#line 521
  foutput_read_ranges_0___0(fp, mship);
  }
#line 522
  return;
}
}
#line 524 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_membership_2___0(FILE *fp , Membership *mship ) 
{ 


  {
  {
#line 528
  foutput_time___0(fp, mship->last_time_read);
#line 530
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu",
          (unsigned long )mship->conf_no, (unsigned long )mship->priority);
#line 533
  foutput_read_ranges_0___0(fp, mship);
#line 534
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu", (unsigned long )mship->added_by);
#line 535
  foutput_time___0(fp, mship->added_at);
#line 536
  foutput_membership_type___0(fp, mship->type);
  }
#line 537
  return;
}
}
#line 561 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_string___0(FILE *fp , String str ) 
{ 


  {
  {
#line 565
  foutput_ulong___0((unsigned long )str.len, fp);
#line 566
  _IO_putc('H', fp);
  }
#line 568
  if (str.len) {
    {
#line 569
    fwrite((void const   */* __restrict  */)str.string, (size_t )str.len, (size_t )1,
           (FILE */* __restrict  */)fp);
    }
  }
#line 570
  return;
}
}
#line 572 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_priv_bits___0(FILE *fp , Priv_bits bits ) 
{ 


  {
  {
#line 576
  _IO_putc(' ', fp);
#line 577
  _IO_putc((int )(bits.wheel + 48U), fp);
#line 578
  _IO_putc((int )(bits.admin + 48U), fp);
#line 579
  _IO_putc((int )(bits.statistic + 48U), fp);
#line 580
  _IO_putc((int )(bits.create_pers + 48U), fp);
#line 581
  _IO_putc((int )(bits.create_conf + 48U), fp);
#line 582
  _IO_putc((int )(bits.change_name + 48U), fp);
#line 583
  _IO_putc((int )(bits.flg7 + 48U), fp);
#line 584
  _IO_putc((int )(bits.flg8 + 48U), fp);
#line 585
  _IO_putc((int )(bits.flg9 + 48U), fp);
#line 586
  _IO_putc((int )(bits.flg10 + 48U), fp);
#line 587
  _IO_putc((int )(bits.flg11 + 48U), fp);
#line 588
  _IO_putc((int )(bits.flg12 + 48U), fp);
#line 589
  _IO_putc((int )(bits.flg13 + 48U), fp);
#line 590
  _IO_putc((int )(bits.flg14 + 48U), fp);
#line 591
  _IO_putc((int )(bits.flg15 + 48U), fp);
#line 592
  _IO_putc((int )(bits.flg16 + 48U), fp);
  }
#line 593
  return;
}
}
#line 595 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_personal_flags___0(FILE *fp , Personal_flags flags ) 
{ 


  {
  {
#line 599
  _IO_putc(' ', fp);
#line 600
  _IO_putc((int )(flags.unread_is_secret + 48U), fp);
#line 601
  _IO_putc((int )(flags.flg2 + 48U), fp);
#line 602
  _IO_putc((int )(flags.flg3 + 48U), fp);
#line 603
  _IO_putc((int )(flags.flg4 + 48U), fp);
#line 604
  _IO_putc((int )(flags.flg5 + 48U), fp);
#line 605
  _IO_putc((int )(flags.flg6 + 48U), fp);
#line 606
  _IO_putc((int )(flags.flg7 + 48U), fp);
#line 607
  _IO_putc((int )(flags.flg8 + 48U), fp);
  }
#line 608
  return;
}
}
#line 611 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_text_list___0(FILE *fp , Local_to_global const   *text_list ) 
{ 
  Local_text_no first ;
  Local_text_no end ;
  Local_text_no tmp ;
  Text_no tmp___0 ;

  {
  {
#line 618
  first = l2g_next_key(text_list, (Local_text_no )0);
#line 619
  end = l2g_first_appendable_key(text_list);
  }
#line 621
  if (first == 0UL) {
#line 622
    first = end;
  }
  {
#line 624
  foutput_ulong___0(first, fp);
#line 625
  foutput_ulong___0(end - first, fp);
  }
#line 627
  if (first < end) {
    {
#line 629
    fputs((char const   */* __restrict  */)" {", (FILE */* __restrict  */)fp);
    }
    {
#line 630
    while (1) {
      while_continue: /* CIL Label */ ;
#line 630
      if (! (first < end)) {
#line 630
        goto while_break;
      }
      {
#line 631
      tmp = first;
#line 631
      first ++;
#line 631
      tmp___0 = l2g_lookup(text_list, tmp);
#line 631
      foutput_ulong___0(tmp___0, fp);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 632
    fputs((char const   */* __restrict  */)" }", (FILE */* __restrict  */)fp);
    }
  } else {
    {
#line 635
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
    }
  }
#line 636
  return;
}
}
#line 639 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_mark_list___0(FILE *fp , Mark_list const   mark_list ) 
{ 
  int i ;

  {
  {
#line 645
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu", (unsigned long )mark_list.no_of_marks);
  }
#line 647
  if ((unsigned long )mark_list.marks != (unsigned long )((void *)0)) {
#line 647
    if ((int const   )mark_list.no_of_marks > 0) {
      {
#line 649
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" {");
#line 650
      i = 0;
      }
      {
#line 650
      while (1) {
        while_continue: /* CIL Label */ ;
#line 650
        if (! (i < (int )mark_list.no_of_marks)) {
#line 650
          goto while_break;
        }
        {
#line 651
        foutput_mark___0(fp, *(mark_list.marks + i));
#line 650
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 652
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" }");
      }
    } else {
      {
#line 655
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
      }
    }
  } else {
    {
#line 655
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
    }
  }
#line 657
  return;
}
}
#line 660 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_mark___0(FILE *fp , Mark mark ) 
{ 


  {
  {
#line 664
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu",
          mark.text_no, (unsigned long )mark.mark_type);
  }
#line 665
  return;
}
}
#line 667 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_membership_list_0___0(FILE *fp , Membership_list mlist ) 
{ 
  int i ;

  {
  {
#line 673
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu", (unsigned long )mlist.no_of_confs);
  }
#line 675
  if ((unsigned long )mlist.confs != (unsigned long )((void *)0)) {
#line 675
    if ((int )mlist.no_of_confs > 0) {
      {
#line 677
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" {");
#line 678
      i = 0;
      }
      {
#line 678
      while (1) {
        while_continue: /* CIL Label */ ;
#line 678
        if (! (i < (int )mlist.no_of_confs)) {
#line 678
          goto while_break;
        }
        {
#line 679
        foutput_membership_0___0(fp, mlist.confs + i);
#line 678
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 680
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" }");
      }
    } else {
      {
#line 683
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
      }
    }
  } else {
    {
#line 683
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
    }
  }
#line 684
  return;
}
}
#line 686 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_membership_list_2___0(FILE *fp , Membership_list mlist ) 
{ 
  int i ;

  {
  {
#line 692
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu", (unsigned long )mlist.no_of_confs);
  }
#line 694
  if ((unsigned long )mlist.confs != (unsigned long )((void *)0)) {
#line 694
    if ((int )mlist.no_of_confs > 0) {
      {
#line 696
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" {");
#line 697
      i = 0;
      }
      {
#line 697
      while (1) {
        while_continue: /* CIL Label */ ;
#line 697
        if (! (i < (int )mlist.no_of_confs)) {
#line 697
          goto while_break;
        }
        {
#line 698
        foutput_membership_2___0(fp, mlist.confs + i);
#line 697
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 699
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" }");
      }
    } else {
      {
#line 702
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
      }
    }
  } else {
    {
#line 702
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
    }
  }
#line 703
  return;
}
}
#line 705 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_membership_list___0(FILE *fp , Membership_list mlist ) 
{ 


  {
  {
#line 712
  if (output_format___0 == 1) {
#line 712
    goto case_1;
  }
#line 712
  if (output_format___0 == 0) {
#line 712
    goto case_1;
  }
#line 715
  if (output_format___0 == 2) {
#line 715
    goto case_2;
  }
#line 718
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 713
  foutput_membership_list_0___0(fp, mlist);
  }
#line 714
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 716
  foutput_membership_list_2___0(fp, mlist);
  }
#line 717
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 719
  restart_kom("unknown database format: %d", output_format___0);
  }
#line 720
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 722
  return;
}
}
#line 724 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_time___0(FILE *fp , time_t clk ) 
{ 


  {
  {
#line 728
  foutput_ulong___0((unsigned long )clk, fp);
  }
#line 729
  return;
}
}
#line 732 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_member_list___0(FILE *fp , Member_list m_list ) 
{ 
  int i ;

  {
  {
#line 738
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu", (unsigned long )m_list.no_of_members);
  }
#line 739
  if ((unsigned long )m_list.members != (unsigned long )((void *)0)) {
#line 739
    if ((int )m_list.no_of_members > 0) {
      {
#line 741
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" {");
#line 742
      i = 0;
      }
      {
#line 742
      while (1) {
        while_continue: /* CIL Label */ ;
#line 742
        if (! (i < (int )m_list.no_of_members)) {
#line 742
          goto while_break;
        }
        {
#line 743
        foutput_member___0(fp, *(m_list.members + i));
#line 742
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 744
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" }");
      }
    } else {
      {
#line 747
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
      }
    }
  } else {
    {
#line 747
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
    }
  }
#line 748
  return;
}
}
#line 751 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_member_0___0(FILE *fp , Member member ) 
{ 


  {
  {
#line 755
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu", (unsigned long )member.member);
  }
#line 756
  return;
}
}
#line 758 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_member_2___0(FILE *fp , Member member ) 
{ 


  {
  {
#line 762
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %lu %lu",
          (unsigned long )member.member, (unsigned long )member.added_by);
#line 765
  foutput_time___0(fp, member.added_at);
#line 766
  foutput_membership_type___0(fp, member.type);
  }
#line 767
  return;
}
}
#line 769 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_member___0(FILE *fp , Member member ) 
{ 


  {
  {
#line 776
  if (output_format___0 == 1) {
#line 776
    goto case_1;
  }
#line 776
  if (output_format___0 == 0) {
#line 776
    goto case_1;
  }
#line 779
  if (output_format___0 == 2) {
#line 779
    goto case_2;
  }
#line 782
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 777
  foutput_member_0___0(fp, member);
  }
#line 778
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 780
  foutput_member_2___0(fp, member);
  }
#line 781
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 783
  restart_kom("unknown database format: %d", output_format___0);
  }
#line 784
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 786
  return;
}
}
#line 788 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_conf_type_1___0(FILE *fp , Conf_type type ) 
{ 


  {
  {
#line 792
  _IO_putc(' ', fp);
#line 793
  _IO_putc((int )(type.rd_prot + 48U), fp);
#line 794
  _IO_putc((int )(type.original + 48U), fp);
#line 795
  _IO_putc((int )(type.secret + 48U), fp);
#line 796
  _IO_putc((int )(type.letter_box + 48U), fp);
#line 797
  _IO_putc((int )(type.allow_anon + 48U), fp);
#line 798
  _IO_putc((int )(type.forbid_secret + 48U), fp);
#line 799
  _IO_putc((int )(type.reserved2 + 48U), fp);
#line 800
  _IO_putc((int )(type.reserved3 + 48U), fp);
  }
#line 801
  return;
}
}
#line 803 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_conf_type_0___0(FILE *fp , Conf_type type ) 
{ 


  {
  {
#line 807
  _IO_putc(' ', fp);
#line 808
  _IO_putc((int )(type.rd_prot + 48U), fp);
#line 809
  _IO_putc((int )(type.original + 48U), fp);
#line 810
  _IO_putc((int )(type.secret + 48U), fp);
#line 811
  _IO_putc((int )(type.letter_box + 48U), fp);
  }
#line 812
  return;
}
}
#line 814 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_conf_type___0(FILE *fp , Conf_type type ) 
{ 


  {
  {
#line 820
  if (output_format___0 == 0) {
#line 820
    goto case_0;
  }
#line 824
  if (output_format___0 == 2) {
#line 824
    goto case_2;
  }
#line 824
  if (output_format___0 == 1) {
#line 824
    goto case_2;
  }
#line 827
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 821
  foutput_conf_type_0___0(fp, type);
  }
#line 822
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 825
  foutput_conf_type_1___0(fp, type);
  }
#line 826
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 828
  restart_kom("unknown database format: %d", output_format___0);
  }
#line 829
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 831
  return;
}
}
#line 834 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_misc_info___0(FILE *fp , Misc_info misc ) 
{ 


  {
  {
#line 838
  foutput_ulong___0((unsigned long )misc.type, fp);
  }
  {
#line 844
  if ((unsigned int )misc.type == 15U) {
#line 844
    goto case_15;
  }
#line 844
  if ((unsigned int )misc.type == 1U) {
#line 844
    goto case_15;
  }
#line 844
  if ((unsigned int )misc.type == 0U) {
#line 844
    goto case_15;
  }
#line 848
  if ((unsigned int )misc.type == 6U) {
#line 848
    goto case_6;
  }
#line 852
  if ((unsigned int )misc.type == 7U) {
#line 852
    goto case_7;
  }
#line 859
  if ((unsigned int )misc.type == 5U) {
#line 859
    goto case_5;
  }
#line 859
  if ((unsigned int )misc.type == 4U) {
#line 859
    goto case_5;
  }
#line 859
  if ((unsigned int )misc.type == 3U) {
#line 859
    goto case_5;
  }
#line 859
  if ((unsigned int )misc.type == 2U) {
#line 859
    goto case_5;
  }
#line 863
  if ((unsigned int )misc.type == 8U) {
#line 863
    goto case_8;
  }
#line 867
  if ((unsigned int )misc.type == 9U) {
#line 867
    goto case_9;
  }
#line 872
  goto switch_default;
  case_15: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 845
  foutput_ulong___0((unsigned long )misc.datum.recipient, fp);
  }
#line 846
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 849
  foutput_ulong___0(misc.datum.local_no, fp);
  }
#line 850
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 853
  foutput_time___0(fp, misc.datum.received_at);
  }
#line 854
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 860
  foutput_ulong___0(misc.datum.text_link, fp);
  }
#line 861
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 864
  foutput_ulong___0((unsigned long )misc.datum.sender, fp);
  }
#line 865
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 868
  foutput_time___0(fp, misc.datum.sent_at);
  }
#line 869
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 875
  restart_kom("prot_a_output_misc_info: Illegal misc\n");
  }
  switch_break: /* CIL Label */ ;
  }
#line 877
  return;
}
}
#line 889 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static char buf___3[25UL]  ;
#line 885 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-output.c"
static void foutput_ulong___0(unsigned long l , FILE *fp ) 
{ 
  char *cp ;

  {
  {
#line 892
  _IO_putc(' ', fp);
  }
#line 893
  if (l < 10UL) {
    {
#line 894
    _IO_putc((int )*("0123456789" + l), fp);
    }
  } else {
#line 897
    cp = buf___3 + sizeof(buf___3);
    {
#line 898
    while (1) {
      while_continue: /* CIL Label */ ;
#line 898
      if (! (l > 0UL)) {
#line 898
        goto while_break;
      }
#line 900
      cp --;
#line 900
      *cp = (char )(l % 10UL + 48UL);
#line 901
      l /= 10UL;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 903
    fwrite((void const   */* __restrict  */)cp, (size_t )((buf___3 + sizeof(buf___3)) - cp),
           (size_t )1, (FILE */* __restrict  */)fp);
    }
  }
#line 905
  return;
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 695 "/usr/include/stdio.h"
extern int puts(char const   *__s ) ;
#line 31 "./getopt.h"
extern char *optarg ;
#line 45
extern int optind ;
#line 106
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 102 "./../libraries/libcommon/misc-parser.h"
extern Misc_info_group parse_next_misc(Misc_info const   **info_pointer , Misc_info const   *stop_pointer ) ;
#line 100 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/cache.h"
Pers_no traverse_person(Pers_no seed ) ;
#line 29 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.h"
void cached_flush_text(Text_no text_no , String message ) ;
#line 33
void cache_open_new_text_file(void) ;
#line 37
long oformat ;
#line 93 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static struct option longopts[18]  = 
#line 93 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
  {      {"compact-text-mass", 0, (int *)0, 'g'}, 
        {"interactive", 0, (int *)0, 'i'}, 
        {"auto-repair", 0, (int *)0, 'r'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"print-statistics", 0, (int *)0, 's'}, 
        {"list-text-no", 0, (int *)0, 't'}, 
        {"set-change-name", 0, (int *)0, 'c'}, 
        {"clear-password", 1, (int *)0, 'P'}, 
        {"grant-all", 1, (int *)0, 'G'}, 
        {"output-version", 1, (int *)0, 'o'}, 
        {"force-output", 0, (int *)0, 'F'}, 
        {"pers-pres-conf", 1, (int *)0, 1}, 
        {"conf-pres-conf", 1, (int *)0, 2}, 
        {"motd-conf", 1, (int *)0, 3}, 
        {"motd-of-kom", 1, (int *)0, 4}, 
        {"kom-news-conf", 1, (int *)0, 5}, 
        {"help", 0, (int *)0, 'h'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 122 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
Bool truncated_texts  =    (Bool )0;
#line 124 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
int vflag  =    0;
#line 125 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int iflag  =    0;
#line 126 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int rflag  =    0;
#line 127 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int gflag  =    0;
#line 128 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int sflag  =    0;
#line 129 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static Pers_no reset_pwd  =    (Pers_no )0;
#line 130 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static Pers_no grant_all  =    (Pers_no )0;
#line 134 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
long oformat  =    -1L;
#line 135 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static long force_output  =    0L;
#line 139 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
int pers_pres_conf  =    -1;
#line 140 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
int conf_pres_conf  =    -1;
#line 141 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
int motd_conf  =    -1;
#line 142 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
Text_no motd_of_lyskom  =    (Text_no )-1;
#line 143 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
int kom_news_conf  =    -1;
#line 148 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int unset_change_name_is_error  =    0;
#line 152 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int dump_text_numbers  =    0;
#line 154 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
int modifications  =    0;
#line 160 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static struct __anonstruct_Person_scratchpad_87  const  EMPTY_PERSON_SCRATCHPAD  =    {0};
#line 162 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static Person_scratchpad **person_scratchpad  =    (Person_scratchpad **)((void *)0);
#line 173 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static void delete_list_append(struct delete_list **head , Local_text_no lno ) 
{ 
  struct delete_list *item ;
  void *tmp ;

  {
  {
#line 177
  tmp = smalloc(sizeof(struct delete_list ));
#line 177
  item = (struct delete_list *)tmp;
#line 178
  item->next = *head;
#line 179
  item->lno = lno;
#line 180
  *head = item;
  }
#line 181
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static void execute_deletions(Local_to_global *l2g , struct delete_list **head ) 
{ 
  struct delete_list *item ;

  {
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! ((unsigned long )*head != (unsigned long )((void *)0))) {
#line 189
      goto while_break;
    }
    {
#line 191
    item = *head;
#line 192
    *head = item->next;
#line 193
    l2g_delete(l2g, item->lno);
#line 194
    sfree((void *)item);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return;
}
}
#line 246 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static Person_scratchpad *alloc_person_scratchpad(void) 
{ 
  Person_scratchpad *p ;
  void *tmp ;

  {
  {
#line 251
  tmp = smalloc(sizeof(Person_scratchpad ));
#line 251
  p = (Person_scratchpad *)tmp;
#line 252
  *p = (Person_scratchpad )EMPTY_PERSON_SCRATCHPAD;
  }
#line 253
  return (p);
}
}
#line 257 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static Bool is_comment_to(Text_no comment , Text_stat *parent ) 
{ 
  int i ;

  {
#line 263
  i = 0;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! (i < (int )parent->no_of_misc)) {
#line 263
      goto while_break;
    }
    {
#line 267
    if ((unsigned int )(parent->misc_items + i)->type == 3U) {
#line 267
      goto case_3;
    }
#line 271
    goto switch_default;
    case_3: /* CIL Label */ 
#line 268
    if ((parent->misc_items + i)->datum.text_link == comment) {
#line 269
      return ((Bool )1);
    }
#line 270
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 272
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 263
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  return ((Bool )0);
}
}
#line 279 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static Bool is_commented_in(Text_no parent , Text_stat *child ) 
{ 
  int i ;

  {
#line 285
  i = 0;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! (i < (int )child->no_of_misc)) {
#line 285
      goto while_break;
    }
    {
#line 289
    if ((unsigned int )(child->misc_items + i)->type == 2U) {
#line 289
      goto case_2;
    }
#line 293
    goto switch_default;
    case_2: /* CIL Label */ 
#line 290
    if ((child->misc_items + i)->datum.text_link == parent) {
#line 291
      return ((Bool )1);
    }
#line 292
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 294
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 285
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  return ((Bool )0);
}
}
#line 301 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static Bool is_footnote_to(Text_no footnote , Text_stat *parent ) 
{ 
  int i ;

  {
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! (i < (int )parent->no_of_misc)) {
#line 307
      goto while_break;
    }
    {
#line 311
    if ((unsigned int )(parent->misc_items + i)->type == 5U) {
#line 311
      goto case_5;
    }
#line 315
    goto switch_default;
    case_5: /* CIL Label */ 
#line 312
    if ((parent->misc_items + i)->datum.text_link == footnote) {
#line 313
      return ((Bool )1);
    }
#line 314
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 316
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 307
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  return ((Bool )0);
}
}
#line 323 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static Bool is_footnoted_in(Text_no parent , Text_stat *child ) 
{ 
  int i ;

  {
#line 329
  i = 0;
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! (i < (int )child->no_of_misc)) {
#line 329
      goto while_break;
    }
    {
#line 333
    if ((unsigned int )(child->misc_items + i)->type == 4U) {
#line 333
      goto case_4;
    }
#line 337
    goto switch_default;
    case_4: /* CIL Label */ 
#line 334
    if ((child->misc_items + i)->datum.text_link == parent) {
#line 335
      return ((Bool )1);
    }
#line 336
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 338
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 329
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return ((Bool )0);
}
}
#line 372 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static void delete_misc(Text_stat *tstat , Misc_info *misc ) 
{ 
  int del ;
  Bool ready ;

  {
#line 376
  del = 1;
#line 378
  ready = (Bool )0;
#line 382
  if ((unsigned long )misc < (unsigned long )tstat->misc_items) {
    {
#line 385
    restart_kom("delete_misc() - misc out of range\n");
    }
  } else
#line 382
  if ((unsigned long )misc >= (unsigned long )(tstat->misc_items + (int )tstat->no_of_misc)) {
    {
#line 385
    restart_kom("delete_misc() - misc out of range\n");
    }
  }
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if ((unsigned int )ready == 0U) {
#line 388
      if (! ((unsigned long )(misc + del) < (unsigned long )(tstat->misc_items + (int )tstat->no_of_misc))) {
#line 388
        goto while_break;
      }
    } else {
#line 388
      goto while_break;
    }
    {
#line 396
    if ((unsigned int )(misc + del)->type == 9U) {
#line 396
      goto case_9;
    }
#line 396
    if ((unsigned int )(misc + del)->type == 8U) {
#line 396
      goto case_9;
    }
#line 396
    if ((unsigned int )(misc + del)->type == 7U) {
#line 396
      goto case_9;
    }
#line 396
    if ((unsigned int )(misc + del)->type == 6U) {
#line 396
      goto case_9;
    }
#line 406
    if ((unsigned int )(misc + del)->type == 3U) {
#line 406
      goto case_3;
    }
#line 406
    if ((unsigned int )(misc + del)->type == 2U) {
#line 406
      goto case_3;
    }
#line 406
    if ((unsigned int )(misc + del)->type == 5U) {
#line 406
      goto case_3;
    }
#line 406
    if ((unsigned int )(misc + del)->type == 4U) {
#line 406
      goto case_3;
    }
#line 406
    if ((unsigned int )(misc + del)->type == 15U) {
#line 406
      goto case_3;
    }
#line 406
    if ((unsigned int )(misc + del)->type == 1U) {
#line 406
      goto case_3;
    }
#line 406
    if ((unsigned int )(misc + del)->type == 0U) {
#line 406
      goto case_3;
    }
#line 411
    goto switch_default;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 397
    del ++;
#line 398
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 407
    ready = (Bool )1;
#line 408
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 414
    restart_kom("delete_misc() - illegal misc found.\n");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  tstat->no_of_misc = (unsigned short )((int )tstat->no_of_misc - del);
  {
#line 422
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 422
    if (! ((unsigned long )misc < (unsigned long )(tstat->misc_items + (int )tstat->no_of_misc))) {
#line 422
      goto while_break___0;
    }
#line 424
    *(misc + 0) = *(misc + del);
#line 425
    misc ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 427
  return;
}
}
#line 429 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int confirm(char const   *question ) 
{ 
  int tmp ;

  {
#line 432
  if (iflag) {
    {
#line 434
    fputs((char const   */* __restrict  */)question, (FILE */* __restrict  */)stdout);
#line 435
    fputs((char const   */* __restrict  */)" (y/n) ", (FILE */* __restrict  */)stdout);
    }
    {
#line 436
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 437
      tmp = getchar();
      }
      {
#line 440
      if (tmp == 89) {
#line 440
        goto case_89;
      }
#line 440
      if (tmp == 121) {
#line 440
        goto case_89;
      }
#line 444
      if (tmp == -1) {
#line 444
        goto case_neg_1;
      }
#line 444
      if (tmp == 78) {
#line 444
        goto case_neg_1;
      }
#line 444
      if (tmp == 110) {
#line 444
        goto case_neg_1;
      }
#line 446
      goto switch_default;
      case_89: /* CIL Label */ 
      case_121: /* CIL Label */ 
#line 441
      return (1);
      case_neg_1: /* CIL Label */ 
      case_78: /* CIL Label */ 
      case_110: /* CIL Label */ 
#line 445
      return (0);
      switch_default: /* CIL Label */ 
#line 447
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 451
    return (0);
  }
}
}
#line 455 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static long check_misc_any_recipient(Text_no tno , Text_stat *tstat , char const   *pretty_type ,
                                     Conf_no rcpt , Local_text_no lno , Misc_info *previous ,
                                     Misc_info const   **misc ) 
{ 
  Conference *c ;
  long errors ;
  Local_text_no conf_min ;
  Local_text_no conf_max ;
  int tmp ;
  Text_no tmp___0 ;
  Text_no tmp___1 ;

  {
  {
#line 465
  errors = 0L;
#line 469
  c = cached_get_conf_stat(rcpt);
  }
#line 470
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 470
    if ((int )rcpt == 0) {
      {
#line 472
      kom_log("Conference 0 is a %s of text %lu.\n", pretty_type, tno);
      }
#line 474
      if (rflag) {
        {
#line 476
        delete_misc(tstat, previous);
#line 477
        kom_log("Repaired: Conference 0 is no longer a %s.\n", pretty_type);
#line 479
        mark_text_as_changed(tno);
#line 480
        modifications ++;
#line 481
        *misc = (Misc_info const   *)previous;
        }
      } else {
        {
#line 474
        tmp = confirm("Repair by deleting misc_item? ");
        }
#line 474
        if (tmp) {
          {
#line 476
          delete_misc(tstat, previous);
#line 477
          kom_log("Repaired: Conference 0 is no longer a %s.\n", pretty_type);
#line 479
          mark_text_as_changed(tno);
#line 480
          modifications ++;
#line 481
          *misc = (Misc_info const   *)previous;
          }
        } else {
#line 484
          errors ++;
        }
      }
#line 486
      return (errors);
    }
  }
#line 489
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 490
    return (errors);
  }
  {
#line 493
  conf_min = l2g_lookup((Local_to_global const   *)(& c->texts), (Local_text_no )0);
#line 494
  conf_max = l2g_first_appendable_key((Local_to_global const   *)(& c->texts));
  }
#line 496
  if (lno < conf_min) {
    {
#line 498
    kom_log("Text %lu: %s %lu<%lu>: loc_no is less than %lu\n", tno, pretty_type,
            (unsigned long )rcpt, lno, conf_min);
#line 504
    errors ++;
    }
  } else
#line 506
  if (lno >= conf_max) {
    {
#line 508
    kom_log("Text %lu: %s %lu<%lu>: loc_no is greater than %lu\n", tno, pretty_type,
            (unsigned long )rcpt, lno, conf_max);
#line 514
    errors ++;
    }
  } else {
    {
#line 516
    tmp___1 = l2g_lookup((Local_to_global const   *)(& c->texts), lno);
    }
#line 516
    if (tmp___1 != tno) {
      {
#line 518
      tmp___0 = l2g_lookup((Local_to_global const   *)(& c->texts), lno);
#line 518
      kom_log("Text %lu: %s %lu<%lu>: that local number is mapped to %lu.\n", tno,
              pretty_type, (unsigned long )rcpt, lno, tmp___0);
#line 524
      errors ++;
      }
    }
  }
#line 527
  return (errors);
}
}
#line 531 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static long check_misc_infos(Text_no tno , Text_stat *tstat ) 
{ 
  Misc_info const   *misc ;
  Misc_info *previous ;
  Misc_info_group group ;
  Text_stat *t ;
  long errors ;
  int tmp ;
  Bool tmp___0 ;
  int tmp___1 ;
  Bool tmp___2 ;
  int tmp___3 ;
  Bool tmp___4 ;
  int tmp___5 ;
  Bool tmp___6 ;
  int tmp___7 ;

  {
#line 535
  misc = (Misc_info const   *)tstat->misc_items;
#line 540
  errors = 0L;
  {
#line 542
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 542
    previous = (Misc_info *)misc;
#line 542
    group = parse_next_misc(& misc, (Misc_info const   *)(tstat->misc_items + (int )tstat->no_of_misc));
    }
#line 542
    if ((unsigned int )group.type != 7U) {
#line 542
      if ((unsigned int )group.type != 8U) {
#line 542
        tmp___7 = 1;
      } else {
#line 542
        tmp___7 = 0;
      }
    } else {
#line 542
      tmp___7 = 0;
    }
#line 542
    if (! tmp___7) {
#line 542
      goto while_break;
    }
    {
#line 549
    if ((unsigned int )group.type == 0U) {
#line 549
      goto case_0;
    }
#line 555
    if ((unsigned int )group.type == 1U) {
#line 555
      goto case_1;
    }
#line 561
    if ((unsigned int )group.type == 2U) {
#line 561
      goto case_2;
    }
#line 567
    if ((unsigned int )group.type == 3U) {
#line 567
      goto case_3;
    }
#line 597
    if ((unsigned int )group.type == 4U) {
#line 597
      goto case_4;
    }
#line 625
    if ((unsigned int )group.type == 5U) {
#line 625
      goto case_5;
    }
#line 653
    if ((unsigned int )group.type == 6U) {
#line 653
      goto case_6;
    }
#line 681
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 550
    check_misc_any_recipient(tno, tstat, "recipient", group.recipient, group.local_no,
                             previous, & misc);
    }
#line 553
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 556
    check_misc_any_recipient(tno, tstat, "cc_recipient", group.cc_recipient, group.local_no,
                             previous, & misc);
    }
#line 559
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 562
    check_misc_any_recipient(tno, tstat, "bcc_recipient", group.bcc_recipient, group.local_no,
                             previous, & misc);
    }
#line 565
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 568
    t = cached_get_text_stat(group.comment_to);
    }
#line 570
    if ((unsigned long )t == (unsigned long )((void *)0)) {
      {
#line 572
      kom_log("Text %lu is a comment to %lu, which doesn\'t exist.\n", tno, group.comment_to);
      }
#line 575
      if (rflag) {
        {
#line 577
        delete_misc(tstat, previous);
#line 578
        mark_text_as_changed(tno);
#line 579
        modifications ++;
#line 580
        kom_log("Repaired: Comment-link deleted.\n");
#line 581
        misc = (Misc_info const   *)previous;
        }
      } else {
        {
#line 575
        tmp = confirm("Repair by deleting misc_item? ");
        }
#line 575
        if (tmp) {
          {
#line 577
          delete_misc(tstat, previous);
#line 578
          mark_text_as_changed(tno);
#line 579
          modifications ++;
#line 580
          kom_log("Repaired: Comment-link deleted.\n");
#line 581
          misc = (Misc_info const   *)previous;
          }
        } else {
#line 584
          errors ++;
        }
      }
#line 586
      errors ++;
    } else {
      {
#line 588
      tmp___0 = is_comment_to(tno, t);
      }
#line 588
      if (! tmp___0) {
        {
#line 590
        kom_log("Text %lu is a comment to %lu, but not the reverse.\n", tno, group.comment_to);
#line 592
        errors ++;
        }
      }
    }
#line 595
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 598
    t = cached_get_text_stat(group.commented_in);
    }
#line 600
    if ((unsigned long )t == (unsigned long )((void *)0)) {
      {
#line 602
      kom_log("Text %lu is commented in %lu, which doesn\'t exist.\n", tno, group.commented_in);
      }
#line 605
      if (rflag) {
        {
#line 607
        delete_misc(tstat, previous);
#line 608
        mark_text_as_changed(tno);
#line 609
        modifications ++;
#line 610
        kom_log("Repaired: Comment-link deleted.\n");
#line 611
        misc = (Misc_info const   *)previous;
        }
      } else {
        {
#line 605
        tmp___1 = confirm("Repair by deleting misc_item? ");
        }
#line 605
        if (tmp___1) {
          {
#line 607
          delete_misc(tstat, previous);
#line 608
          mark_text_as_changed(tno);
#line 609
          modifications ++;
#line 610
          kom_log("Repaired: Comment-link deleted.\n");
#line 611
          misc = (Misc_info const   *)previous;
          }
        } else {
#line 614
          errors ++;
        }
      }
    } else {
      {
#line 616
      tmp___2 = is_commented_in(tno, t);
      }
#line 616
      if (! tmp___2) {
        {
#line 618
        kom_log("Text %lu is commented in %lu, but not the reverse.\n", tno, group.commented_in);
#line 620
        errors ++;
        }
      }
    }
#line 623
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 626
    t = cached_get_text_stat(group.footnote_to);
    }
#line 628
    if ((unsigned long )t == (unsigned long )((void *)0)) {
      {
#line 630
      kom_log("Text %lu is a footnote to %lu, which doesn\'t exist.\n", tno, group.footnote_to);
      }
#line 633
      if (rflag) {
        {
#line 635
        delete_misc(tstat, previous);
#line 636
        mark_text_as_changed(tno);
#line 637
        modifications ++;
#line 638
        kom_log("Repaired: Footnote-link deleted.\n");
#line 639
        misc = (Misc_info const   *)previous;
        }
      } else {
        {
#line 633
        tmp___3 = confirm("Repair by deleting misc_item? ");
        }
#line 633
        if (tmp___3) {
          {
#line 635
          delete_misc(tstat, previous);
#line 636
          mark_text_as_changed(tno);
#line 637
          modifications ++;
#line 638
          kom_log("Repaired: Footnote-link deleted.\n");
#line 639
          misc = (Misc_info const   *)previous;
          }
        } else {
#line 642
          errors ++;
        }
      }
    } else {
      {
#line 644
      tmp___4 = is_footnote_to(tno, t);
      }
#line 644
      if (! tmp___4) {
        {
#line 646
        kom_log("Text %lu is a footnote to %lu, but not the reverse.\n", tno, group.footnote_to);
#line 648
        errors ++;
        }
      }
    }
#line 651
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 654
    t = cached_get_text_stat(group.footnoted_in);
    }
#line 656
    if ((unsigned long )t == (unsigned long )((void *)0)) {
      {
#line 658
      kom_log("Text %lu is footnoted in %lu, which doesn\'t exist.\n", tno, group.footnoted_in);
      }
#line 661
      if (rflag) {
        {
#line 663
        delete_misc(tstat, previous);
#line 664
        mark_text_as_changed(tno);
#line 665
        modifications ++;
#line 666
        kom_log("Repaired: Footnote-link deleted.\n");
#line 667
        misc = (Misc_info const   *)previous;
        }
      } else {
        {
#line 661
        tmp___5 = confirm("Repair by deleting misc_item? ");
        }
#line 661
        if (tmp___5) {
          {
#line 663
          delete_misc(tstat, previous);
#line 664
          mark_text_as_changed(tno);
#line 665
          modifications ++;
#line 666
          kom_log("Repaired: Footnote-link deleted.\n");
#line 667
          misc = (Misc_info const   *)previous;
          }
        } else {
#line 670
          errors ++;
        }
      }
    } else {
      {
#line 672
      tmp___6 = is_footnoted_in(tno, t);
      }
#line 672
      if (! tmp___6) {
        {
#line 674
        kom_log("Text %lu is footnoted in %lu, but not the reverse.\n", tno, group.footnoted_in);
#line 676
        errors ++;
        }
      }
    }
#line 679
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 682
    kom_log("check_misc_infos(): parse_next_misc returned type %lu\n", (unsigned long )group.type);
    }
#line 684
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 688
  if ((unsigned int )group.type == 8U) {
    {
#line 690
    kom_log("Text %lu has a bad misc_info_list.\n", tno);
#line 691
    errors ++;
    }
  }
#line 694
  return (errors);
}
}
#line 700 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static long check_texts(void) 
{ 
  Text_no ct ;
  Text_stat *ctp ;
  long errors ;
  Text_no number_of_texts ;
  unsigned long bytes ;
  unsigned long max_bytes ;
  Text_no max_text ;
  long tmp ;

  {
#line 703
  ct = (Text_no )0;
#line 704
  ctp = (Text_stat *)((void *)0);
#line 705
  errors = 0L;
#line 706
  number_of_texts = (Text_no )0;
#line 707
  bytes = 0UL;
#line 708
  max_bytes = 0UL;
#line 709
  max_text = (Text_no )0;
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 711
    ct = traverse_text(ct);
    }
#line 711
    if (! (ct != 0UL)) {
#line 711
      goto while_break;
    }
    {
#line 713
    number_of_texts ++;
#line 715
    ctp = cached_get_text_stat(ct);
    }
#line 716
    if ((unsigned long )ctp == (unsigned long )((void *)0)) {
      {
#line 718
      kom_log("Text %lu nonexistent.\n", ct);
#line 719
      errors ++;
      }
    } else {
#line 723
      if (dump_text_numbers) {
        {
#line 724
        kom_log("Checking text_no %ld\n", ct);
        }
      }
#line 726
      bytes += (unsigned long )ctp->no_of_chars;
#line 727
      if ((unsigned long )ctp->no_of_chars > max_bytes) {
#line 729
        max_bytes = (unsigned long )ctp->no_of_chars;
#line 730
        max_text = ct;
      }
      {
#line 734
      tmp = check_misc_infos(ct, ctp);
#line 734
      errors += tmp;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 738
  if (vflag) {
#line 740
    if (number_of_texts == 0UL) {
      {
#line 741
      kom_log("WARNING: No texts found.\n");
      }
    } else {
      {
#line 744
      kom_log("Total of %lu texts (total %lu bytes, avg. %lu bytes/text).\n", number_of_texts,
              bytes, bytes / number_of_texts);
#line 748
      kom_log("Longest text is %lu (%lu bytes).\n", max_text, max_bytes);
      }
    }
  }
#line 753
  return (errors);
}
}
#line 757 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int check_created_texts(Pers_no pno , Local_to_global *created ) 
{ 
  Text_stat *t ;
  int errors ;
  L2g_iterator iter ;
  struct delete_list *del_list ;
  int tmp ;

  {
  {
#line 762
  errors = 0;
#line 764
  del_list = (struct delete_list *)((void *)0);
#line 766
  l2gi_searchall(& iter, (Local_to_global const   *)created);
  }
  {
#line 766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 766
    if (! (! iter.search_ended)) {
#line 766
      goto while_break;
    }
#line 768
    if (! (iter.tno != 0UL)) {
      {
#line 768
      __assert_fail("iter.tno != 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c",
                    768U, "check_created_texts");
      }
    }
#line 769
    if (! (iter.lno != 0UL)) {
      {
#line 769
      __assert_fail("iter.lno != 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c",
                    769U, "check_created_texts");
      }
    }
    {
#line 771
    t = cached_get_text_stat(iter.tno);
    }
#line 772
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 772
      if ((int )t->author != (int )pno) {
        {
#line 774
        kom_log("Person %lu is author of text %lu whose author is %lu.\n", (unsigned long )pno,
                iter.tno, (unsigned long )t->author);
#line 777
        errors ++;
        }
      }
    }
#line 780
    if ((unsigned long )t == (unsigned long )((void *)0)) {
      {
#line 782
      kom_log("Person %lu is author of text %lu, which doesn\'t exist.\n", (unsigned long )pno,
              iter.tno);
      }
#line 784
      if (rflag) {
        {
#line 787
        delete_list_append(& del_list, iter.lno);
#line 788
        mark_person_as_changed(pno);
#line 789
        modifications ++;
#line 790
        kom_log("Repaired: created_texts corrected.\n");
        }
      } else {
        {
#line 784
        tmp = confirm("Repair by setting to text_no to 0 in local map");
        }
#line 784
        if (tmp) {
          {
#line 787
          delete_list_append(& del_list, iter.lno);
#line 788
          mark_person_as_changed(pno);
#line 789
          modifications ++;
#line 790
          kom_log("Repaired: created_texts corrected.\n");
          }
        } else {
#line 793
          errors ++;
        }
      }
    }
    {
#line 766
    l2gi_next(& iter);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 797
  execute_deletions(created, & del_list);
  }
#line 799
  return (errors);
}
}
#line 802 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int check_membership___0(Pers_no pno , Membership *mship ) 
{ 
  int errors ;
  Conference *conf ;
  Local_text_no last___0 ;
  Member *mem ;
  struct read_range *begin ;
  struct read_range *end ;
  struct read_range *ptr ;
  Local_text_no tmp ;
  Local_text_no tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 806
  errors = 0;
#line 808
  last___0 = (Local_text_no )0;
#line 815
  conf = cached_get_conf_stat(mship->conf_no);
  }
#line 816
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
    {
#line 818
    kom_log("Person %lu is a member in the non-existing conference %lu.\n", (unsigned long )pno,
            (unsigned long )mship->conf_no);
#line 820
    errors ++;
    }
  } else {
#line 826
    last___0 = (Local_text_no )0;
#line 827
    if (mship->no_of_read_ranges > 0U) {
#line 829
      begin = mship->read_ranges + 0;
#line 830
      end = begin + mship->no_of_read_ranges;
#line 832
      ptr = begin;
      {
#line 832
      while (1) {
        while_continue: /* CIL Label */ ;
#line 832
        if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 832
          goto while_break;
        }
#line 834
        if (ptr->first_read > ptr->last_read) {
          {
#line 836
          kom_log("Person %lu\'s membership in %lu is corrupt: bad range: %lu-%lu.\n",
                  (unsigned long )pno, (unsigned long )mship->conf_no, ptr->first_read,
                  ptr->last_read);
#line 841
          errors ++;
          }
        }
#line 843
        if ((unsigned long )ptr != (unsigned long )begin) {
#line 843
          if (last___0 + 1UL == ptr->first_read) {
            {
#line 845
            kom_log("Person %lu\'s membership in %lu is corrupt: adjoining ranges not joined at around %lu.\n",
                    (unsigned long )pno, (unsigned long )mship->conf_no, ptr->first_read);
#line 849
            errors ++;
            }
          }
        }
#line 851
        if ((unsigned long )ptr != (unsigned long )begin) {
#line 851
          if (last___0 >= ptr->first_read) {
            {
#line 853
            kom_log("Person %lu\'s membership in %lu is corrupt: overlapping ranges: %lu-%lu, %lu-%lu.\n",
                    (unsigned long )pno, (unsigned long )mship->conf_no, (ptr - 1)->first_read,
                    (ptr - 1)->last_read, ptr->first_read, ptr->last_read);
#line 860
            errors ++;
            }
          }
        }
#line 862
        last___0 = ptr->last_read;
#line 832
        ptr ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 866
    tmp___0 = l2g_first_appendable_key((Local_to_global const   *)(& conf->texts));
    }
#line 866
    if (last___0 >= tmp___0) {
      {
#line 868
      tmp = l2g_first_appendable_key((Local_to_global const   *)(& conf->texts));
#line 868
      kom_log("Person %lu has read text %lu in conf %lu, which only has %lu texts.\n",
              (unsigned long )pno, last___0, (unsigned long )mship->conf_no, tmp - 1UL);
#line 874
      errors ++;
      }
    }
    {
#line 878
    mem = locate_member(pno, conf);
    }
#line 878
    if ((unsigned long )mem == (unsigned long )((void *)0)) {
      {
#line 880
      kom_log("Person %lu is a member in %lu in which he isn\'t a member.\n", (unsigned long )pno,
              (unsigned long )mship->conf_no);
#line 882
      errors ++;
      }
    } else
#line 891
    if (mem->type.invitation != mship->type.invitation) {
#line 891
      goto _L;
    } else
#line 891
    if (mem->type.passive != mship->type.passive) {
#line 891
      goto _L;
    } else
#line 891
    if (mem->type.secret != mship->type.secret) {
#line 891
      goto _L;
    } else
#line 891
    if (mem->type.passive_message_invert != mship->type.passive_message_invert) {
#line 891
      goto _L;
    } else
#line 891
    if (mem->type.reserved2 != mship->type.reserved2) {
#line 891
      goto _L;
    } else
#line 891
    if (mem->type.reserved3 != mship->type.reserved3) {
#line 891
      goto _L;
    } else
#line 891
    if (mem->type.reserved4 != mship->type.reserved4) {
#line 891
      goto _L;
    } else
#line 891
    if (mem->type.reserved5 != mship->type.reserved5) {
#line 891
      goto _L;
    } else
#line 891
    if (mem->added_at != mship->added_at) {
#line 891
      goto _L;
    } else
#line 891
    if ((int )mem->added_by != (int )mship->added_by) {
      _L: /* CIL Label */ 
      {
#line 903
      kom_log("Person %lu membership in %lu does not match member record.\n", (unsigned long )pno,
              (unsigned long )mship->conf_no);
#line 908
      errors ++;
#line 910
      fputs((char const   */* __restrict  */)"Membership:", (FILE */* __restrict  */)stdout);
      }
#line 911
      if (mship->type.reserved5) {
#line 911
        tmp___1 = "rsv5";
      } else {
#line 911
        tmp___1 = "";
      }
#line 911
      if (mship->type.reserved4) {
#line 911
        tmp___2 = "rsv4 ";
      } else {
#line 911
        tmp___2 = "";
      }
#line 911
      if (mship->type.reserved3) {
#line 911
        tmp___3 = "rsv3 ";
      } else {
#line 911
        tmp___3 = "";
      }
#line 911
      if (mship->type.reserved2) {
#line 911
        tmp___4 = "rsv2 ";
      } else {
#line 911
        tmp___4 = "";
      }
#line 911
      if (mship->type.passive_message_invert) {
#line 911
        tmp___5 = "passive_message_invert ";
      } else {
#line 911
        tmp___5 = "";
      }
#line 911
      if (mship->type.secret) {
#line 911
        tmp___6 = "secret ";
      } else {
#line 911
        tmp___6 = "";
      }
#line 911
      if (mship->type.passive) {
#line 911
        tmp___7 = "passive ";
      } else {
#line 911
        tmp___7 = "";
      }
#line 911
      if (mship->type.invitation) {
#line 911
        tmp___8 = "invitation ";
      } else {
#line 911
        tmp___8 = "";
      }
      {
#line 911
      printf((char const   */* __restrict  */)"  type:      %s%s%s%s%s%s%s%s\n", tmp___8,
             tmp___7, tmp___6, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1);
#line 921
      printf((char const   */* __restrict  */)"  added_by: %lu\n", (unsigned long )mship->added_by);
#line 922
      printf((char const   */* __restrict  */)"  added_at: %lu\n", (unsigned long )mship->added_at);
#line 923
      fputs((char const   */* __restrict  */)"Member:", (FILE */* __restrict  */)stdout);
      }
#line 924
      if (mem->type.reserved5) {
#line 924
        tmp___9 = "rsv5";
      } else {
#line 924
        tmp___9 = "";
      }
#line 924
      if (mem->type.reserved4) {
#line 924
        tmp___10 = "rsv4 ";
      } else {
#line 924
        tmp___10 = "";
      }
#line 924
      if (mem->type.reserved3) {
#line 924
        tmp___11 = "rsv3 ";
      } else {
#line 924
        tmp___11 = "";
      }
#line 924
      if (mem->type.reserved2) {
#line 924
        tmp___12 = "rsv2 ";
      } else {
#line 924
        tmp___12 = "";
      }
#line 924
      if (mem->type.passive_message_invert) {
#line 924
        tmp___13 = "passive_message_invert ";
      } else {
#line 924
        tmp___13 = "";
      }
#line 924
      if (mem->type.secret) {
#line 924
        tmp___14 = "secret ";
      } else {
#line 924
        tmp___14 = "";
      }
#line 924
      if (mem->type.passive) {
#line 924
        tmp___15 = "passive ";
      } else {
#line 924
        tmp___15 = "";
      }
#line 924
      if (mem->type.invitation) {
#line 924
        tmp___16 = "invitation ";
      } else {
#line 924
        tmp___16 = "";
      }
      {
#line 924
      printf((char const   */* __restrict  */)"  type:      %s%s%s%s%s%s%s%s\n", tmp___16,
             tmp___15, tmp___14, tmp___13, tmp___12, tmp___11, tmp___10, tmp___9);
#line 934
      printf((char const   */* __restrict  */)"  added_by: %lu\n", (unsigned long )mem->added_by);
#line 935
      printf((char const   */* __restrict  */)"  added_at: %lu\n", (unsigned long )mem->added_at);
#line 937
      tmp___18 = confirm("Copy membership to member");
      }
#line 937
      if (tmp___18) {
#line 939
        mem->added_at = mship->added_at;
#line 940
        mem->added_by = mship->added_by;
#line 941
        mem->type = mship->type;
#line 942
        modifications ++;
      } else {
        {
#line 944
        tmp___17 = confirm("Copy member to membership");
        }
#line 944
        if (tmp___17) {
#line 946
          mship->added_at = mem->added_at;
#line 947
          mship->added_by = mem->added_by;
#line 948
          mship->type = mem->type;
#line 949
          modifications ++;
        }
      }
    }
  }
#line 955
  return (errors);
}
}
#line 960 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int check_membership_list(Pers_no pno , Membership_list const   *mlist ) 
{ 
  int errors ;
  int i ;
  int tmp ;

  {
#line 964
  errors = 0;
#line 967
  i = 0;
  {
#line 967
  while (1) {
    while_continue: /* CIL Label */ ;
#line 967
    if (! (i < (int )mlist->no_of_confs)) {
#line 967
      goto while_break;
    }
    {
#line 968
    tmp = check_membership___0(pno, mlist->confs + i);
#line 968
    errors += tmp;
#line 967
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 970
  return (errors);
}
}
#line 977
static int check_persons(void) ;
#line 977 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static char crypt_seed___0[65]  = 
#line 977
  {      (char )'a',      (char )'b',      (char )'c',      (char )'d', 
        (char )'e',      (char )'f',      (char )'g',      (char )'h', 
        (char )'i',      (char )'j',      (char )'k',      (char )'l', 
        (char )'m',      (char )'n',      (char )'o',      (char )'p', 
        (char )'q',      (char )'r',      (char )'s',      (char )'t', 
        (char )'u',      (char )'v',      (char )'w',      (char )'x', 
        (char )'y',      (char )'z',      (char )'A',      (char )'B', 
        (char )'C',      (char )'D',      (char )'E',      (char )'F', 
        (char )'G',      (char )'H',      (char )'I',      (char )'J', 
        (char )'K',      (char )'L',      (char )'M',      (char )'N', 
        (char )'O',      (char )'P',      (char )'Q',      (char )'R', 
        (char )'S',      (char )'T',      (char )'U',      (char )'V', 
        (char )'W',      (char )'X',      (char )'Y',      (char )'Z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'.',      (char )'/', 
        (char )'\000'};
#line 974 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int check_persons(void) 
{ 
  Pers_no cp ;
  Person *pstat ;
  Conference *cstat ;
  long errors ;
  Pers_no number_of_persons ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char salt[3] ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 979
  cp = (Pers_no )0;
#line 980
  pstat = (Person *)((void *)0);
#line 981
  cstat = (Conference *)((void *)0);
#line 982
  errors = 0L;
#line 983
  number_of_persons = (Pers_no )0;
  {
#line 985
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 985
    cp = traverse_person(cp);
    }
#line 985
    if (! ((int )cp != 0)) {
#line 985
      goto while_break;
    }
    {
#line 987
    number_of_persons = (Pers_no )((int )number_of_persons + 1);
#line 988
    pstat = cached_get_person_stat(cp);
#line 989
    cstat = cached_get_conf_stat(cp);
    }
#line 991
    if ((unsigned long )pstat == (unsigned long )((void *)0)) {
      {
#line 993
      kom_log("Person %lu nonexistent.\n", (unsigned long )cp);
#line 994
      errors ++;
      }
    } else
#line 996
    if ((unsigned long )cstat == (unsigned long )((void *)0)) {
      {
#line 998
      kom_log("Person %lu has no conference.\n", (unsigned long )cp);
#line 999
      errors ++;
      }
    } else
#line 1001
    if (! cstat->type.letter_box) {
      {
#line 1003
      kom_log("Person %lu\'s conference is not a letter_box.\n", (unsigned long )cp);
#line 1005
      errors ++;
      }
    } else {
      {
#line 1009
      tmp = check_created_texts(cp, & pstat->created_texts);
#line 1009
      tmp___0 = check_membership_list(cp, (Membership_list const   *)(& pstat->conferences));
#line 1009
      errors += (long )(tmp + tmp___0);
      }
    }
#line 1013
    if (unset_change_name_is_error == 1) {
#line 1013
      if (pstat->privileges.change_name == 0U) {
        {
#line 1016
        kom_log("Person %lu has no change_name capability.\n", (unsigned long )cp);
        }
#line 1019
        if (rflag) {
          {
#line 1021
          pstat->privileges.change_name = 1U;
#line 1022
          mark_person_as_changed(cp);
#line 1023
          modifications ++;
          }
        } else {
          {
#line 1019
          tmp___1 = confirm("Grant him the capability");
          }
#line 1019
          if (tmp___1) {
            {
#line 1021
            pstat->privileges.change_name = 1U;
#line 1022
            mark_person_as_changed(cp);
#line 1023
            modifications ++;
            }
          } else {
#line 1026
            errors ++;
          }
        }
      }
    }
#line 1028
    if ((int )cp == (int )reset_pwd) {
      {
#line 1032
      tmp___2 = rand();
#line 1032
      salt[0] = crypt_seed___0[(unsigned long )tmp___2 % (sizeof(crypt_seed___0) - 1UL)];
#line 1033
      tmp___3 = rand();
#line 1033
      salt[1] = crypt_seed___0[(unsigned long )tmp___3 % (sizeof(crypt_seed___0) - 1UL)];
#line 1034
      salt[2] = (char )'\000';
#line 1036
      tmp___4 = crypt("", (char const   *)(salt));
#line 1036
      strcpy((char */* __restrict  */)(pstat->pwd), (char const   */* __restrict  */)((char const   *)tmp___4));
#line 1037
      mark_person_as_changed(cp);
#line 1038
      modifications ++;
      }
    }
#line 1041
    if ((int )cp == (int )grant_all) {
      {
#line 1043
      pstat->privileges.wheel = 1U;
#line 1044
      pstat->privileges.admin = 1U;
#line 1045
      pstat->privileges.statistic = 1U;
#line 1046
      pstat->privileges.create_pers = 1U;
#line 1047
      pstat->privileges.create_conf = 1U;
#line 1048
      pstat->privileges.change_name = 1U;
#line 1049
      pstat->privileges.flg7 = 1U;
#line 1050
      pstat->privileges.flg8 = 1U;
#line 1051
      pstat->privileges.flg9 = 1U;
#line 1052
      pstat->privileges.flg10 = 1U;
#line 1053
      pstat->privileges.flg11 = 1U;
#line 1054
      pstat->privileges.flg12 = 1U;
#line 1055
      pstat->privileges.flg13 = 1U;
#line 1056
      pstat->privileges.flg14 = 1U;
#line 1057
      pstat->privileges.flg15 = 1U;
#line 1058
      pstat->privileges.flg16 = 1U;
#line 1059
      mark_person_as_changed(cp);
#line 1060
      modifications ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1064
  if (vflag) {
    {
#line 1065
    kom_log("Total of %lu persons.\n", (unsigned long )number_of_persons);
    }
  }
#line 1067
  return ((int )errors);
}
}
#line 1070 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static Bool is_recipient(Conf_no conf_no , Text_stat *t_stat ) 
{ 
  int i ;

  {
#line 1076
  i = 0;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! (i < (int )t_stat->no_of_misc)) {
#line 1076
      goto while_break;
    }
    {
#line 1082
    if ((unsigned int )(t_stat->misc_items + i)->type == 15U) {
#line 1082
      goto case_15;
    }
#line 1082
    if ((unsigned int )(t_stat->misc_items + i)->type == 1U) {
#line 1082
      goto case_15;
    }
#line 1082
    if ((unsigned int )(t_stat->misc_items + i)->type == 0U) {
#line 1082
      goto case_15;
    }
#line 1096
    if ((unsigned int )(t_stat->misc_items + i)->type == 6U) {
#line 1096
      goto case_6;
    }
#line 1096
    if ((unsigned int )(t_stat->misc_items + i)->type == 9U) {
#line 1096
      goto case_6;
    }
#line 1096
    if ((unsigned int )(t_stat->misc_items + i)->type == 8U) {
#line 1096
      goto case_6;
    }
#line 1096
    if ((unsigned int )(t_stat->misc_items + i)->type == 5U) {
#line 1096
      goto case_6;
    }
#line 1096
    if ((unsigned int )(t_stat->misc_items + i)->type == 4U) {
#line 1096
      goto case_6;
    }
#line 1096
    if ((unsigned int )(t_stat->misc_items + i)->type == 3U) {
#line 1096
      goto case_6;
    }
#line 1096
    if ((unsigned int )(t_stat->misc_items + i)->type == 2U) {
#line 1096
      goto case_6;
    }
#line 1096
    if ((unsigned int )(t_stat->misc_items + i)->type == 7U) {
#line 1096
      goto case_6;
    }
#line 1100
    goto switch_default;
    case_15: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1083
    if ((int )(t_stat->misc_items + i)->datum.recipient == (int )conf_no) {
#line 1085
      return ((Bool )1);
    }
#line 1087
    goto switch_break;
    case_6: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_7: /* CIL Label */ 
#line 1097
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1103
    restart_kom("is_recipient(): illegal misc_item\n");
    }
    switch_break: /* CIL Label */ ;
    }
#line 1076
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1107
  return ((Bool )0);
}
}
#line 1110 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int check_texts_in_conf(Conf_no cc , Local_to_global *tlist ) 
{ 
  Text_stat *t ;
  int errors ;
  L2g_iterator iter ;
  struct delete_list *del_list ;
  int tmp ;
  int tmp___0 ;
  Bool tmp___1 ;

  {
  {
#line 1115
  errors = 0;
#line 1117
  del_list = (struct delete_list *)((void *)0);
#line 1119
  l2gi_searchall(& iter, (Local_to_global const   *)tlist);
  }
  {
#line 1119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1119
    if (! (! iter.search_ended)) {
#line 1119
      goto while_break;
    }
#line 1121
    if (! (iter.lno != 0UL)) {
      {
#line 1121
      __assert_fail("iter.lno != 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c",
                    1121U, "check_texts_in_conf");
      }
    }
#line 1122
    if (! (iter.tno != 0UL)) {
      {
#line 1122
      __assert_fail("iter.tno != 0", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c",
                    1122U, "check_texts_in_conf");
      }
    }
    {
#line 1123
    t = cached_get_text_stat(iter.tno);
    }
#line 1124
    if ((unsigned long )t == (unsigned long )((void *)0)) {
      {
#line 1126
      kom_log("Text %lu<%lu> in conference %lu is non-existent.\n", iter.tno, iter.lno,
              (unsigned long )cc);
      }
#line 1131
      if (rflag) {
        {
#line 1133
        delete_list_append(& del_list, iter.lno);
#line 1134
        mark_conference_as_changed(cc);
#line 1135
        modifications ++;
#line 1136
        kom_log("Repaired: %lu is no longer a recipient.\n", (unsigned long )cc);
        }
      } else {
        {
#line 1131
        tmp = confirm("Repair by deleting the Text_no in the map?");
        }
#line 1131
        if (tmp) {
          {
#line 1133
          delete_list_append(& del_list, iter.lno);
#line 1134
          mark_conference_as_changed(cc);
#line 1135
          modifications ++;
#line 1136
          kom_log("Repaired: %lu is no longer a recipient.\n", (unsigned long )cc);
          }
        } else {
#line 1140
          errors ++;
        }
      }
    } else {
      {
#line 1144
      tmp___1 = is_recipient(cc, t);
      }
#line 1144
      if (! tmp___1) {
        {
#line 1146
        kom_log("Text %lu<%lu> in conference %lu %s.\n", iter.tno, iter.lno, (unsigned long )cc,
                "doesn\'t have the conference as recipient");
#line 1152
        tmp___0 = confirm("Repair by deleting Text_no from the map?");
        }
#line 1152
        if (tmp___0) {
          {
#line 1154
          delete_list_append(& del_list, iter.lno);
#line 1155
          mark_conference_as_changed(cc);
#line 1156
          modifications ++;
#line 1157
          kom_log("Repaired: %lu is no longer a recipient.\n", (unsigned long )cc);
          }
        } else {
#line 1161
          errors ++;
        }
      }
    }
    {
#line 1119
    l2gi_next(& iter);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1165
  execute_deletions(tlist, & del_list);
  }
#line 1167
  return (errors);
}
}
#line 1189 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int check_member(Conf_no cc , Member *memb ) 
{ 
  Person *pp ;
  int errors ;
  Membership *tmp ;

  {
  {
#line 1194
  errors = 0;
#line 1196
  pp = cached_get_person_stat(memb->member);
  }
#line 1197
  if ((unsigned long )pp == (unsigned long )((void *)0)) {
    {
#line 1199
    kom_log("Person %lu, supposedly a member in conf %lu, is nonexistent.\n", (unsigned long )memb->member,
            (unsigned long )cc);
#line 1201
    errors ++;
    }
  } else {
    {
#line 1205
    tmp = locate_membership(cc, (Person const   *)pp);
    }
#line 1205
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 1207
      kom_log("Person %lu is not a member in conf %lu.\n", (unsigned long )memb->member,
              (unsigned long )cc);
#line 1210
      errors ++;
      }
    }
  }
#line 1214
  return (errors);
}
}
#line 1217 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int check_member_list(Conf_no cc , Member_list const   *mlist ) 
{ 
  int errors ;
  int i ;
  int tmp ;

  {
#line 1221
  errors = 0;
#line 1224
  i = 0;
  {
#line 1224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1224
    if (! (i < (int )mlist->no_of_members)) {
#line 1224
      goto while_break;
    }
    {
#line 1225
    tmp = check_member(cc, mlist->members + i);
#line 1225
    errors += tmp;
#line 1224
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1227
  return (errors);
}
}
#line 1231 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static int check_confs(void) 
{ 
  Conf_no cc ;
  Person *pstat ;
  Conference *cstat ;
  long errors ;
  Conf_no number_of_confs ;
  int tmp ;
  int tmp___0 ;

  {
#line 1234
  cc = (Conf_no )0;
#line 1235
  pstat = (Person *)((void *)0);
#line 1236
  cstat = (Conference *)((void *)0);
#line 1237
  errors = 0L;
#line 1238
  number_of_confs = (Conf_no )0;
  {
#line 1240
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1240
    cc = traverse_conference(cc);
    }
#line 1240
    if (! ((int )cc != 0)) {
#line 1240
      goto while_break;
    }
    {
#line 1242
    number_of_confs = (Conf_no )((int )number_of_confs + 1);
#line 1243
    cstat = cached_get_conf_stat(cc);
    }
#line 1245
    if ((unsigned long )cstat == (unsigned long )((void *)0)) {
      {
#line 1247
      kom_log("Conference %lu nonexistent.\n", (unsigned long )cc);
#line 1248
      errors ++;
      }
    } else {
#line 1252
      if (cstat->type.letter_box) {
        {
#line 1254
        pstat = cached_get_person_stat(cc);
        }
#line 1255
        if ((unsigned long )pstat == (unsigned long )((void *)0)) {
          {
#line 1257
          kom_log("Mailbox %lu has no person.\n", (unsigned long )cc);
#line 1258
          errors ++;
          }
        }
      } else
#line 1264
      if ((unsigned long )*(person_scratchpad + cstat->creator) != (unsigned long )((void *)0)) {
#line 1265
        ((*(person_scratchpad + cstat->creator))->created_confs) ++;
      }
      {
#line 1268
      tmp = check_texts_in_conf(cc, & cstat->texts);
#line 1268
      tmp___0 = check_member_list(cc, (Member_list const   *)(& cstat->members));
#line 1268
      errors += (long )(tmp + tmp___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1273
  if (vflag) {
    {
#line 1274
    kom_log("Total of %lu conferences.\n", (unsigned long )number_of_confs);
    }
  }
#line 1276
  return ((int )errors);
}
}
#line 1279 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static void init_person_scratch(void) 
{ 
  Pers_no pno ;
  Pers_no i ;
  void *tmp ;

  {
#line 1282
  pno = (Pers_no )0;
#line 1283
  i = (Pers_no )0;
#line 1285
  if ((unsigned long )person_scratchpad == (unsigned long )((void *)0)) {
    {
#line 1287
    tmp = smalloc(sizeof(*person_scratchpad) * param.max_conf);
#line 1287
    person_scratchpad = (Person_scratchpad **)tmp;
#line 1288
    i = (Pers_no )0;
    }
    {
#line 1288
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1288
      if (! ((unsigned long )i < param.max_conf)) {
#line 1288
        goto while_break;
      }
#line 1289
      *(person_scratchpad + i) = (Person_scratchpad *)((void *)0);
#line 1288
      i = (Pers_no )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1292
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1292
    pno = traverse_person(pno);
    }
#line 1292
    if (! ((int )pno != 0)) {
#line 1292
      goto while_break___0;
    }
    {
#line 1294
    *(person_scratchpad + pno) = alloc_person_scratchpad();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1296
  return;
}
}
#line 1298 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static long post_check_persons(void) 
{ 
  long errors ;
  Pers_no pers_no ;
  Person *pstat ;

  {
#line 1301
  errors = 0L;
#line 1303
  pers_no = (Pers_no )0;
  {
#line 1306
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1306
    pers_no = traverse_person(pers_no);
    }
#line 1306
    if (! ((int )pers_no != 0)) {
#line 1306
      goto while_break;
    }
    {
#line 1308
    pstat = cached_get_person_stat(pers_no);
    }
#line 1308
    if ((unsigned long )pstat == (unsigned long )((void *)0)) {
      {
#line 1310
      kom_log("%s(): can\'t cached_get_person_stat(%d).\n", "INTERNAL DBCK ERROR: post_check_persons",
              (int )pers_no);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1315
  return (errors);
}
}
#line 1322 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static long check_data_base(void) 
{ 
  long errors ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1327
  init_person_scratch();
#line 1328
  tmp = check_texts();
#line 1328
  tmp___0 = check_persons();
#line 1328
  tmp___1 = check_confs();
#line 1328
  errors = (tmp + (long )tmp___0) + (long )tmp___1;
#line 1329
  tmp___2 = post_check_persons();
  }
#line 1329
  return (errors + tmp___2);
}
}
#line 1332 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static void init_data_base___0(void) 
{ 
  Success tmp ;

  {
#line 1335
  if (vflag) {
    {
#line 1337
    kom_log("Database = %s\n", param.datafile_name);
#line 1338
    kom_log("Backup   = %s\n", param.backupfile_name);
#line 1339
    kom_log("Text     = %s\n", param.textfile_name);
#line 1340
    kom_log("Textback = %s\n", param.textbackupfile_name);
    }
  }
  {
#line 1343
  tmp = init_cache();
  }
#line 1343
  if ((unsigned long )tmp == (unsigned long )FAILURE) {
    {
#line 1344
    restart_kom("Can\'t find database.\n");
    }
  }
#line 1345
  return;
}
}
#line 1347 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static void garb_text_file(void) 
{ 
  Text_no tno ;
  String text ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1350
  tno = (Text_no )0;
#line 1353
  kom_log("Renaming %s to %s\n", param.textfile_name, param.textbackupfile_name);
#line 1354
  tmp___1 = i_rename((char const   *)param.textfile_name, (char const   *)param.textbackupfile_name);
  }
#line 1354
  if (tmp___1 < 0) {
    {
#line 1356
    tmp = __errno_location();
#line 1356
    tmp___0 = strerror(*tmp);
#line 1356
    restart_kom("rename failed: %s\n", tmp___0);
    }
  }
  {
#line 1358
  kom_log("Writing texts to (new) %s\n", param.textfile_name);
#line 1359
  fflush(stdout);
#line 1360
  fflush(stderr);
#line 1361
  cache_open_new_text_file();
  }
  {
#line 1363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1363
    tno = traverse_text(tno);
    }
#line 1363
    if (! (tno != 0UL)) {
#line 1363
      goto while_break;
    }
    {
#line 1365
    text = cached_get_text(tno);
#line 1366
    cached_flush_text(tno, text);
#line 1367
    free_tmp();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1369
  kom_log("Writing datafile with new indexes.\n");
#line 1370
  fflush(stdout);
#line 1371
  fflush(stderr);
#line 1372
  cache_sync_all();
  }
#line 1373
  return;
}
}
#line 1377 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static void print_statistics(void) 
{ 
  Text_stat *ts ;
  Text_no t ;
  int *hist ;
  int i ;
  void *tmp ;

  {
  {
#line 1385
  tmp = calloc((size_t )param.text_len, sizeof(int ));
#line 1385
  hist = (int *)tmp;
  }
#line 1387
  if ((unsigned long )hist == (unsigned long )((void *)0)) {
    {
#line 1389
    perror("dbck: print_statistics(): can\'t calloc()");
    }
#line 1390
    return;
  }
#line 1393
  t = (Text_no )0;
  {
#line 1393
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1393
    t = traverse_text(t);
    }
#line 1393
    if (! (t != 0UL)) {
#line 1393
      goto while_break;
    }
    {
#line 1395
    ts = cached_get_text_stat(t);
    }
#line 1396
    if ((unsigned long )ts == (unsigned long )((void *)0)) {
      {
#line 1398
      kom_log("print_statistics(): Can\'t get text_stat.\n");
      }
#line 1399
      return;
    }
#line 1402
    (*(hist + ts->no_of_chars)) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1405
  kom_log("Length  Frequency\n");
#line 1406
  i = 0;
  }
  {
#line 1406
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1406
    if (! (i < param.text_len)) {
#line 1406
      goto while_break___0;
    }
#line 1407
    if (*(hist + i) != 0) {
      {
#line 1408
      kom_log("%8d %d\n", i, *(hist + i));
      }
    }
#line 1406
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1409
  return;
}
}
#line 1411 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck.c"
static void give_help(char const   *default_config___4 ) 
{ 


  {
  {
#line 1414
  printf((char const   */* __restrict  */)"dbck for %s version %s\n", kom_version_info.server_name,
         kom_version_info.server_version);
#line 1417
  puts("Usage: dbck [options] [config_file]");
#line 1418
  puts("Available options:");
#line 1419
  puts("Short   Long option         Explanation");
#line 1420
  puts("  -g  --compact-text-mass   Reclaim unused space among texts.");
#line 1421
  puts("  -i  --interactive         Offer to repair some error types.");
#line 1422
  puts("  -r  --auto-repair         Repair simple errors without prompting.");
#line 1424
  puts("  -v  --verbose             Talk more.");
#line 1425
  puts("  -o  --output-version=N    File format 0, 1 or 2.");
#line 1426
  puts("  -F  --force-output        Save db even if no changes.");
#line 1427
  puts("  -s  --print-statistics    Output a lot of statistics.");
#line 1428
  puts("  -t  --list-text-no        List the text number of all existing texts.");
#line 1430
  puts("  -c  --set-change-name     Consider unset change_name capabilities an error.");
#line 1432
  puts("  -P  --clear-password=pno  Set password to empty string for a user.");
#line 1434
  puts("  -G  --grant-all=pno       Give a user all available privileges.");
#line 1435
  puts("      --pers-pres-conf=N    Set conference for user presentations.");
#line 1436
  puts("      --conf-pres-conf=N    Set conference for conference presentations.");
#line 1438
  puts("      --kom-news-conf=N     Set conference for news about KOM.");
#line 1439
  puts("      --motd-conf=N         Set conference for lapps on the doors.");
#line 1440
  puts("      --motd-of-kom=N       Set KOM login message text.");
#line 1441
  puts("  -h  --help                Display this help.");
#line 1442
  puts("Note: the -P and -G options also require a person number as argument");
#line 1444
  printf((char const   */* __restrict  */)"The config_file argument defaults to %s\n",
         default_config___4);
#line 1445
  puts("WARNING: Don\'t allow lyskomd and dbck to modify the database simultaneously!");
#line 1447
  exit(0);
  }
}
}
#line 828 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 85 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
Person **pers_arr  ;
#line 86 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
Conference **conf_arr  ;
#line 87 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
String *name_list  ;
#line 89 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
static Conf_no next_free_num___0  =    (Conf_no )1;
#line 91 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
Text_stat **text_arr  ;
#line 92 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
static Text_no next_text_num___0  =    (Text_no )1;
#line 101 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
static FILE *text_file___0  =    (FILE *)((void *)0);
#line 102 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
static FILE *new_text_file  =    (FILE *)((void *)0);
#line 407 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
void cached_flush_text(Text_no text_no , String message ) 
{ 
  size_t tmp ;

  {
#line 411
  if (text_no >= next_text_num___0) {
    {
#line 413
    kom_log("cached_flush_text(%lu, string): only text %lu exists.\n", text_no, next_text_num___0);
    }
#line 415
    return;
  }
  {
#line 418
  fseek(new_text_file, 0L, 2);
#line 419
  (*(text_arr + text_no))->file_pos = ftell(new_text_file);
#line 421
  tmp = fwrite((void const   */* __restrict  */)message.string, sizeof(char ), (size_t )message.len,
               (FILE */* __restrict  */)new_text_file);
  }
#line 421
  if (tmp != (size_t )message.len) {
    {
#line 424
    kom_log("WARNING: cached_flush_text: Couldn\'t write the text %ld\n", text_no);
    }
  }
  {
#line 428
  fflush(new_text_file);
  }
#line 429
  return;
}
}
#line 442 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
Pers_no traverse_person(Pers_no seed ) 
{ 
  int tmp ;

  {
#line 445
  seed = (Pers_no )((int )seed + 1);
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if ((int )seed < (int )next_free_num___0) {
#line 447
      if (! ((unsigned long )*(pers_arr + seed) == (unsigned long )((void *)0))) {
#line 447
        goto while_break;
      }
    } else {
#line 447
      goto while_break;
    }
#line 448
    seed = (Pers_no )((int )seed + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  if ((int )seed == (int )next_free_num___0) {
#line 450
    tmp = 0;
  } else {
#line 450
    tmp = (int )seed;
  }
#line 450
  return ((Pers_no )tmp);
}
}
#line 503 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
static long get_version___0(char const   *fn ) 
{ 
  FILE *fp ;
  char c ;
  long version ;
  int tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 510
  fp = i_fopen(fn, "rb");
  }
#line 510
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 511
    return (-1L);
  }
  {
#line 513
  fseek(fp, 5L, 0);
#line 514
  tmp = _IO_getc(fp);
#line 514
  c = (char )tmp;
  }
#line 514
  if ((int )c == 10) {
    {
#line 516
    i_fclose(fp);
    }
#line 517
    return (0L);
  }
  {
#line 519
  tmp___0 = fparse_long(fp);
#line 519
  version = (long )tmp___0;
#line 520
  i_fclose(fp);
  }
#line 522
  return (version);
}
}
#line 526 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
static Bool is_clean___1(char const   *fn ) 
{ 
  FILE *fp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 531
  fp = i_fopen(fn, "rb");
  }
#line 531
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 532
    return ((Bool )0);
  }
  {
#line 534
  tmp = _IO_getc(fp);
  }
#line 534
  if (tmp == 67) {
    {
#line 534
    tmp___0 = _IO_getc(fp);
    }
#line 534
    if (tmp___0 == 76) {
      {
#line 534
      tmp___1 = _IO_getc(fp);
      }
#line 534
      if (tmp___1 == 69) {
        {
#line 534
        tmp___2 = _IO_getc(fp);
        }
#line 534
        if (tmp___2 == 65) {
          {
#line 534
          tmp___3 = _IO_getc(fp);
          }
#line 534
          if (tmp___3 == 78) {
            {
#line 540
            i_fclose(fp);
            }
#line 541
            return ((Bool )1);
          } else {
            {
#line 545
            i_fclose(fp);
            }
#line 546
            return ((Bool )0);
          }
        } else {
          {
#line 545
          i_fclose(fp);
          }
#line 546
          return ((Bool )0);
        }
      } else {
        {
#line 545
        i_fclose(fp);
        }
#line 546
        return ((Bool )0);
      }
    } else {
      {
#line 545
      i_fclose(fp);
      }
#line 546
      return ((Bool )0);
    }
  } else {
    {
#line 545
    i_fclose(fp);
    }
#line 546
    return ((Bool )0);
  }
}
}
#line 550 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
static void sync_output_header___0(FILE *fp , char const   *state , int oformat___0 ) 
{ 
  time_t tmp ;

  {
  {
#line 555
  if (oformat___0 == 0) {
#line 555
    goto case_0;
  }
#line 558
  if (oformat___0 == 1) {
#line 558
    goto case_1;
  }
#line 561
  if (oformat___0 == 2) {
#line 561
    goto case_2;
  }
#line 565
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 556
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n", state);
  }
#line 557
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 559
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s:%05ld\n",
          state, (long )oformat___0);
  }
#line 560
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 562
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s:%05ld\n",
          state, (long )oformat___0);
#line 563
  tmp = time((time_t *)((void *)0));
#line 563
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%020lu\n",
          (unsigned long )tmp);
  }
#line 564
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 566
  restart_kom("sync_output_header(): Unknown output format %d", oformat___0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 569
  return;
}
}
#line 825 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/dbck-cache.c"
void cache_open_new_text_file(void) 
{ 


  {
  {
#line 828
  new_text_file = i_fopen((char const   *)param.textfile_name, "w");
  }
#line 828
  if ((unsigned long )new_text_file == (unsigned long )((void *)0)) {
    {
#line 830
    kom_log("Can\'t open file to save new texts. Goodbye.\n");
#line 831
    exit(1);
    }
  }
#line 833
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int no_of_allocated_blocks___9  =    0;
#line 384 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static void **tmp_alloc_table___3  =    (void **)((void *)0);
#line 385 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int tmp_alloc_table_size___3  =    0;
#line 386 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-smalloc.c"
static int tmp_alloc_table_use___3  =    0;
#line 66 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int *assignment_count___3  =    (int *)((void *)0);
#line 67 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int npar___3  =    0;
#line 69 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static void init_init___3(struct parameter  const  *par ) 
{ 
  int ix ;
  void *tmp ;

  {
#line 74
  npar___3 = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )(par + npar___3)->name != (unsigned long )((void *)0))) {
#line 74
      goto while_break;
    }
#line 74
    npar___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if (! ((unsigned long )assignment_count___3 == (unsigned long )((void *)0))) {
    {
#line 77
    __assert_fail("assignment_count == ((void *)0)", "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c",
                  77U, "init_init");
    }
  }
  {
#line 78
  tmp = smalloc((unsigned long )npar___3 * sizeof(*assignment_count___3));
#line 78
  assignment_count___3 = (int *)tmp;
#line 80
  ix = 0;
  }
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (ix < npar___3)) {
#line 80
      goto while_break___0;
    }
#line 81
    *(assignment_count___3 + ix) = 0;
#line 80
    ix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static void assign_defaults___3(struct parameter  const  *par , int *err ) 
{ 
  int ix ;
  Success tmp ;

  {
#line 93
  ix = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (ix < npar___3)) {
#line 93
      goto while_break;
    }
#line 95
    if (*(assignment_count___3 + ix) < (int )(par + ix)->min_assignments) {
      {
#line 97
      kom_log("Parameter %s only assigned %d times (%d times needed)\n", (par + ix)->name,
              *(assignment_count___3 + ix), (par + ix)->min_assignments);
#line 99
      (*err) ++;
      }
    } else
#line 101
    if (*(assignment_count___3 + ix) == 0) {
      {
#line 103
      tmp = (*((par + ix)->assigner))((char const   *)(par + ix)->default_val, par + ix);
      }
#line 103
      if ((unsigned long )tmp != (unsigned long )OK) {
        {
#line 105
        kom_log("default assigner failed for %s\n", (par + ix)->name);
#line 106
        (*err) ++;
        }
      }
    }
#line 93
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static int configure_line___3(FILE *fp , struct parameter  const  *par , int *err ) 
{ 
  char line[1001] ;
  char *start ;
  char *val ;
  char *end ;
  int found ;
  int ix ;
  char *tmp ;
  Success tmp___0 ;
  int tmp___1 ;

  {
  {
#line 128
  tmp = fgets((char */* __restrict  */)(line), 1001, (FILE */* __restrict  */)fp);
  }
#line 128
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 129
    return (-1);
  }
#line 135
  start = line;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((int )*start == 32)) {
#line 135
      if (! ((int )*start == 9)) {
#line 135
        goto while_break;
      }
    }
#line 135
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  if ((int )*start == 35) {
#line 139
    goto case_35;
  }
#line 141
  if ((int )*start == 0) {
#line 141
    goto case_0;
  }
#line 145
  if ((int )*start == 10) {
#line 145
    goto case_10;
  }
#line 137
  goto switch_break;
  case_35: /* CIL Label */ 
#line 140
  return (0);
  case_0: /* CIL Label */ 
  {
#line 142
  kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 143
  (*err) ++;
  }
#line 144
  return (0);
  case_10: /* CIL Label */ 
#line 146
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 149
  val = strchr((char const   *)(line), ':');
  }
#line 150
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    {
#line 153
    end = strchr((char const   *)(line), '\n');
    }
#line 154
    if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 155
      *end = (char )'\000';
    }
    {
#line 157
    kom_log("missing colon: %s\n", line);
#line 158
    (*err) ++;
    }
#line 159
    return (0);
  }
#line 161
  *val = (char )'\000';
#line 162
  val ++;
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (! ((int )*val == 32)) {
#line 162
      if (! ((int )*val == 9)) {
#line 162
        goto while_break___0;
      }
    }
#line 162
    val ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 166
  if ((int )*val == 0) {
#line 166
    goto case_0___0;
  }
#line 164
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 167
  kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 168
  (*err) ++;
  }
#line 169
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 172
  end = strchr((char const   *)val, '\n');
  }
#line 173
  if ((unsigned long )end == (unsigned long )((void *)0)) {
    {
#line 175
    kom_log("line too long (max %d chars allowed): %s\n", 1000, line);
#line 176
    (*err) ++;
    }
#line 177
    return (0);
  }
#line 179
  *end = (char )'\000';
#line 182
  found = 0;
#line 183
  ix = 0;
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (! (ix < npar___3)) {
#line 183
      goto while_break___1;
    }
    {
#line 185
    tmp___1 = strcmp((char const   *)start, (char const   *)(par + ix)->name);
    }
#line 185
    if (! tmp___1) {
#line 187
      found ++;
#line 188
      if (*(assignment_count___3 + ix) >= (int )(par + ix)->max_assignments) {
#line 188
        if ((par + ix)->max_assignments != -1) {
          {
#line 191
          (*err) ++;
#line 192
          kom_log("variable already assigned %d times: %s\n", *(assignment_count___3 + ix),
                  line);
          }
        } else {
#line 188
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 197
        (*(assignment_count___3 + ix)) ++;
#line 198
        tmp___0 = (*((par + ix)->assigner))((char const   *)val, par + ix);
        }
#line 198
        if ((unsigned long )tmp___0 != (unsigned long )OK) {
          {
#line 200
          kom_log("assigner for %s failed\n", (par + ix)->name);
#line 201
          (*err) ++;
          }
        }
      }
    }
#line 183
    ix ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 207
  if (found != 1) {
    {
#line 209
    kom_log("line matches %d times: %s\n", found, line);
#line 210
    (*err) ++;
    }
#line 211
    return (0);
  }
#line 213
  return (0);
}
}
#line 388 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/conf-file.c"
static struct suffix_conversion  const  suffix_table___3[27]  = 
#line 388
  {      {"seconds", 1.0}, 
        {"second", 1.0}, 
        {"sec", 1.0}, 
        {"s", 1.0}, 
        {"minutes", 60.0}, 
        {"minute", 60.0}, 
        {"min", 60.0}, 
        {"hours", 3600.0}, 
        {"hour", 3600.0}, 
        {"h", 3600.0}, 
        {"days", 86400.0}, 
        {"day", 86400.0}, 
        {"d", 86400.0}, 
        {"milliseconds", 0.001}, 
        {"millisecond", 0.001}, 
        {"milli", 0.001}, 
        {"ms", 0.001}, 
        {"microseconds", 0.000001}, 
        {"microsecond", 0.000001}, 
        {"micro", 0.000001}, 
        {"us", 0.000001}, 
        {"u", 0.000001}, 
        {"kiloseconds", 1000.0}, 
        {"megaseconds", 1000000.0}, 
        {"microfortnights", 1.2096}, 
        {"microfortnight", 1.2096}, 
        {(char const   *)((void *)0), 0.0}};
#line 53 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static int input_format___0  =    2;
#line 55
static Success fparse_text_list___0(FILE *fp , Local_to_global *result ) ;
#line 82 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static int fparse_long_errors___0  =    0;
#line 126 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_info_0___0(FILE *fp , Info *info ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 129
  tmp = fparse_long(fp);
#line 129
  info->conf_pres_conf = (Conf_no )tmp;
#line 130
  tmp___0 = fparse_long(fp);
#line 130
  info->pers_pres_conf = (Conf_no )tmp___0;
#line 131
  tmp___1 = fparse_long(fp);
#line 131
  info->motd_conf = (Conf_no )tmp___1;
#line 132
  tmp___2 = fparse_long(fp);
#line 132
  info->kom_news_conf = (Conf_no )tmp___2;
#line 133
  info->motd_of_lyskom = fparse_long(fp);
  }
#line 135
  return ((Success )OK);
}
}
#line 138 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_info_2___0(FILE *fp , Info *info ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  Success tmp___3 ;

  {
  {
#line 141
  tmp = fparse_long(fp);
#line 141
  info->conf_pres_conf = (Conf_no )tmp;
#line 142
  tmp___0 = fparse_long(fp);
#line 142
  info->pers_pres_conf = (Conf_no )tmp___0;
#line 143
  tmp___1 = fparse_long(fp);
#line 143
  info->motd_conf = (Conf_no )tmp___1;
#line 144
  tmp___2 = fparse_long(fp);
#line 144
  info->kom_news_conf = (Conf_no )tmp___2;
#line 145
  info->motd_of_lyskom = fparse_long(fp);
#line 146
  info->highest_aux_no = fparse_long(fp);
#line 147
  free_aux_item_list(& info->aux_item_list);
#line 148
  tmp___3 = fparse_aux_item_list(fp, & info->aux_item_list);
  }
#line 148
  return (tmp___3);
}
}
#line 179 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_conference_2___0(FILE *fp , Conference *result ) 
{ 
  Success tmp ;
  Success tmp___0 ;
  Success tmp___1 ;
  Success tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  Success tmp___7 ;

  {
#line 183
  if (fparse_long_errors___0 != 0) {
    {
#line 185
    kom_log("fparse_conference(): fparse_long_errors == %d on entry. Reset.\n", fparse_long_errors___0);
#line 187
    fparse_long_errors___0 = 0;
    }
  }
  {
#line 190
  tmp = fparse_string(fp, & result->name);
  }
#line 190
  if ((unsigned long )tmp != (unsigned long )OK) {
    {
#line 192
    kom_log("fparse_conference(): Can\'t parse name.\n");
    }
#line 193
    return ((Success )FAILURE);
  }
  {
#line 196
  tmp___0 = fparse_member_list(fp, & result->members);
  }
#line 196
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 200
    kom_log("fparse_conference: file is corrupt.\n");
    }
#line 201
    return ((Success )FAILURE);
  } else {
    {
#line 196
    tmp___1 = l2g_read(fp, & result->texts);
    }
#line 196
    if ((unsigned long )tmp___1 != (unsigned long )OK) {
      {
#line 200
      kom_log("fparse_conference: file is corrupt.\n");
      }
#line 201
      return ((Success )FAILURE);
    } else {
      {
#line 196
      tmp___2 = fparse_conf_type(fp, & result->type);
      }
#line 196
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
        {
#line 200
        kom_log("fparse_conference: file is corrupt.\n");
        }
#line 201
        return ((Success )FAILURE);
      }
    }
  }
  {
#line 204
  result->creation_time = fparse_time(fp);
#line 205
  result->last_written = fparse_time(fp);
#line 207
  tmp___3 = fparse_long(fp);
#line 207
  result->creator = (Pers_no )tmp___3;
#line 208
  result->presentation = fparse_long(fp);
#line 209
  tmp___4 = fparse_long(fp);
#line 209
  result->supervisor = (Conf_no )tmp___4;
#line 210
  tmp___5 = fparse_long(fp);
#line 210
  result->permitted_submitters = (Conf_no )tmp___5;
#line 211
  tmp___6 = fparse_long(fp);
#line 211
  result->super_conf = (Conf_no )tmp___6;
#line 212
  result->msg_of_day = fparse_long(fp);
  }
#line 214
  if (fparse_long_errors___0 != 0) {
    {
#line 216
    kom_log("fparse_conference(): %d %s before \'nice\'. Reset.\n", fparse_long_errors___0,
            "fparse_long_errors");
#line 218
    fparse_long_errors___0 = 0;
    }
#line 219
    return ((Success )FAILURE);
  }
  {
#line 222
  result->nice = fparse_long(fp);
#line 224
  result->keep_commented = fparse_long(fp);
#line 225
  result->expire = fparse_long(fp);
#line 226
  result->highest_aux = fparse_long(fp);
#line 227
  tmp___7 = fparse_aux_item_list(fp, & result->aux_item_list);
  }
#line 227
  if ((unsigned long )tmp___7 != (unsigned long )OK) {
#line 228
    return ((Success )FAILURE);
  }
  {
#line 229
  fskipwhite(fp);
  }
#line 231
  return ((Success )OK);
}
}
#line 235 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_conference_0___0(FILE *fp , Conference *result ) 
{ 
  Success tmp ;
  Success tmp___0 ;
  Success tmp___1 ;
  Success tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;

  {
#line 239
  if (fparse_long_errors___0 != 0) {
    {
#line 241
    kom_log("fparse_conference(): fparse_long_errors == %d on entry. Reset.\n", fparse_long_errors___0);
#line 243
    fparse_long_errors___0 = 0;
    }
  }
  {
#line 246
  tmp = fparse_string(fp, & result->name);
  }
#line 246
  if ((unsigned long )tmp != (unsigned long )OK) {
    {
#line 248
    kom_log("fparse_conference(): Can\'t parse name.\n");
    }
#line 249
    return ((Success )FAILURE);
  }
  {
#line 252
  tmp___0 = fparse_member_list(fp, & result->members);
  }
#line 252
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 256
    kom_log("fparse_conference: file is corrupt.\n");
    }
#line 257
    return ((Success )FAILURE);
  } else {
    {
#line 252
    tmp___1 = fparse_text_list___0(fp, & result->texts);
    }
#line 252
    if ((unsigned long )tmp___1 != (unsigned long )OK) {
      {
#line 256
      kom_log("fparse_conference: file is corrupt.\n");
      }
#line 257
      return ((Success )FAILURE);
    } else {
      {
#line 252
      tmp___2 = fparse_conf_type(fp, & result->type);
      }
#line 252
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
        {
#line 256
        kom_log("fparse_conference: file is corrupt.\n");
        }
#line 257
        return ((Success )FAILURE);
      }
    }
  }
  {
#line 260
  result->creation_time = fparse_time(fp);
#line 261
  result->last_written = fparse_time(fp);
#line 263
  tmp___3 = fparse_long(fp);
#line 263
  result->creator = (Pers_no )tmp___3;
#line 264
  result->presentation = fparse_long(fp);
#line 265
  tmp___4 = fparse_long(fp);
#line 265
  result->supervisor = (Conf_no )tmp___4;
#line 266
  tmp___5 = fparse_long(fp);
#line 266
  result->permitted_submitters = (Conf_no )tmp___5;
#line 267
  tmp___6 = fparse_long(fp);
#line 267
  result->super_conf = (Conf_no )tmp___6;
#line 268
  result->msg_of_day = fparse_long(fp);
  }
#line 270
  if (fparse_long_errors___0 != 0) {
    {
#line 272
    kom_log("fparse_conference(): %d %s before \'nice\'. Reset.\n", fparse_long_errors___0,
            "fparse_long_errors");
#line 274
    fparse_long_errors___0 = 0;
    }
#line 275
    return ((Success )FAILURE);
  }
  {
#line 278
  result->nice = fparse_long(fp);
#line 279
  result->highest_aux = 0UL;
#line 280
  result->aux_item_list.length = (unsigned short)0;
#line 281
  result->aux_item_list.items = (Aux_item *)0;
#line 283
  fskipwhite(fp);
  }
#line 284
  return ((Success )OK);
}
}
#line 308 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_person_0___0(FILE *fp , Person *person ) 
{ 
  String pwd ;
  Success tmp ;
  Success tmp___0 ;
  Success tmp___1 ;
  Success tmp___2 ;
  Success tmp___3 ;
  Success tmp___4 ;
  Success tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;

  {
#line 312
  pwd = EMPTY_STRING;
#line 314
  if (fparse_long_errors___0 != 0) {
    {
#line 316
    kom_log("fparse_person(): fparse_long_errors == %d on entry. Reset.\n", fparse_long_errors___0);
#line 318
    fparse_long_errors___0 = 0;
    }
  }
  {
#line 321
  tmp = fparse_string(fp, & pwd);
  }
#line 321
  if ((unsigned long )tmp != (unsigned long )OK) {
    {
#line 323
    kom_log("fparse_person(): Failed to parse password.\n");
    }
#line 324
    return ((Success )FAILURE);
  }
  {
#line 327
  memcpy((void */* __restrict  */)(person->pwd), (void const   */* __restrict  */)pwd.string,
         (size_t )64);
#line 328
  s_clear(& pwd);
#line 330
  tmp___0 = fparse_string(fp, & person->username);
  }
#line 330
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 337
    kom_log("fparse_person(): parse error.\n");
    }
#line 338
    return ((Success )FAILURE);
  } else {
    {
#line 330
    tmp___1 = fparse_priv_bits(fp, & person->privileges);
    }
#line 330
    if ((unsigned long )tmp___1 != (unsigned long )OK) {
      {
#line 337
      kom_log("fparse_person(): parse error.\n");
      }
#line 338
      return ((Success )FAILURE);
    } else {
      {
#line 330
      tmp___2 = fparse_personal_flags(fp, & person->flags);
      }
#line 330
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
        {
#line 337
        kom_log("fparse_person(): parse error.\n");
        }
#line 338
        return ((Success )FAILURE);
      } else {
        {
#line 330
        tmp___3 = fparse_text_list___0(fp, & person->created_texts);
        }
#line 330
        if ((unsigned long )tmp___3 != (unsigned long )OK) {
          {
#line 337
          kom_log("fparse_person(): parse error.\n");
          }
#line 338
          return ((Success )FAILURE);
        } else {
          {
#line 330
          tmp___4 = fparse_mark_list(fp, & person->marks);
          }
#line 330
          if ((unsigned long )tmp___4 != (unsigned long )OK) {
            {
#line 337
            kom_log("fparse_person(): parse error.\n");
            }
#line 338
            return ((Success )FAILURE);
          } else {
            {
#line 330
            tmp___5 = fparse_membership_list(fp, & person->conferences);
            }
#line 330
            if ((unsigned long )tmp___5 != (unsigned long )OK) {
              {
#line 337
              kom_log("fparse_person(): parse error.\n");
              }
#line 338
              return ((Success )FAILURE);
            }
          }
        }
      }
    }
  }
  {
#line 341
  person->last_login = fparse_time(fp);
#line 343
  person->user_area = fparse_long(fp);
#line 344
  person->total_time_present = fparse_long(fp);
#line 345
  person->sessions = fparse_long(fp);
#line 346
  person->created_lines = fparse_long(fp);
#line 347
  person->created_bytes = fparse_long(fp);
#line 348
  person->read_texts = fparse_long(fp);
#line 349
  person->no_of_text_fetches = fparse_long(fp);
#line 350
  tmp___6 = fparse_long(fp);
#line 350
  person->created_persons = (unsigned short )tmp___6;
  }
#line 352
  if (fparse_long_errors___0 != 0) {
    {
#line 354
    kom_log("fparse_person(): %d %s before \'created_confs\'. Reset.\n", fparse_long_errors___0,
            "fparse_long_errors");
#line 356
    fparse_long_errors___0 = 0;
    }
#line 357
    return ((Success )FAILURE);
  }
  {
#line 360
  tmp___7 = fparse_long(fp);
#line 360
  person->created_confs = (unsigned short )tmp___7;
#line 362
  fskipwhite(fp);
  }
#line 363
  return ((Success )OK);
}
}
#line 366 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_person_2___0(FILE *fp , Person *person ) 
{ 
  String pwd ;
  Success tmp ;
  Success tmp___0 ;
  Success tmp___1 ;
  Success tmp___2 ;
  Success tmp___3 ;
  Success tmp___4 ;
  Success tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;

  {
#line 370
  pwd = EMPTY_STRING;
#line 372
  if (fparse_long_errors___0 != 0) {
    {
#line 374
    kom_log("fparse_person(): fparse_long_errors == %d on entry. Reset.\n", fparse_long_errors___0);
#line 376
    fparse_long_errors___0 = 0;
    }
  }
  {
#line 379
  tmp = fparse_string(fp, & pwd);
  }
#line 379
  if ((unsigned long )tmp != (unsigned long )OK) {
    {
#line 381
    kom_log("fparse_person(): Failed to parse password.\n");
    }
#line 382
    return ((Success )FAILURE);
  }
  {
#line 385
  memcpy((void */* __restrict  */)(person->pwd), (void const   */* __restrict  */)pwd.string,
         (size_t )64);
#line 386
  s_clear(& pwd);
#line 388
  tmp___0 = fparse_string(fp, & person->username);
  }
#line 388
  if ((unsigned long )tmp___0 != (unsigned long )OK) {
    {
#line 395
    kom_log("fparse_person(): parse error.\n");
    }
#line 396
    return ((Success )FAILURE);
  } else {
    {
#line 388
    tmp___1 = fparse_priv_bits(fp, & person->privileges);
    }
#line 388
    if ((unsigned long )tmp___1 != (unsigned long )OK) {
      {
#line 395
      kom_log("fparse_person(): parse error.\n");
      }
#line 396
      return ((Success )FAILURE);
    } else {
      {
#line 388
      tmp___2 = fparse_personal_flags(fp, & person->flags);
      }
#line 388
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
        {
#line 395
        kom_log("fparse_person(): parse error.\n");
        }
#line 396
        return ((Success )FAILURE);
      } else {
        {
#line 388
        tmp___3 = l2g_read(fp, & person->created_texts);
        }
#line 388
        if ((unsigned long )tmp___3 != (unsigned long )OK) {
          {
#line 395
          kom_log("fparse_person(): parse error.\n");
          }
#line 396
          return ((Success )FAILURE);
        } else {
          {
#line 388
          tmp___4 = fparse_mark_list(fp, & person->marks);
          }
#line 388
          if ((unsigned long )tmp___4 != (unsigned long )OK) {
            {
#line 395
            kom_log("fparse_person(): parse error.\n");
            }
#line 396
            return ((Success )FAILURE);
          } else {
            {
#line 388
            tmp___5 = fparse_membership_list(fp, & person->conferences);
            }
#line 388
            if ((unsigned long )tmp___5 != (unsigned long )OK) {
              {
#line 395
              kom_log("fparse_person(): parse error.\n");
              }
#line 396
              return ((Success )FAILURE);
            }
          }
        }
      }
    }
  }
  {
#line 399
  person->last_login = fparse_time(fp);
#line 401
  person->user_area = fparse_long(fp);
#line 402
  person->total_time_present = fparse_long(fp);
#line 403
  person->sessions = fparse_long(fp);
#line 404
  person->created_lines = fparse_long(fp);
#line 405
  person->created_bytes = fparse_long(fp);
#line 406
  person->read_texts = fparse_long(fp);
#line 407
  person->no_of_text_fetches = fparse_long(fp);
#line 408
  tmp___6 = fparse_long(fp);
#line 408
  person->created_persons = (unsigned short )tmp___6;
  }
#line 410
  if (fparse_long_errors___0 != 0) {
    {
#line 412
    kom_log("fparse_person(): %d %s before \'created_confs\'. Reset.\n", fparse_long_errors___0,
            "fparse_long_errors");
#line 414
    fparse_long_errors___0 = 0;
    }
#line 415
    return ((Success )FAILURE);
  }
  {
#line 418
  tmp___7 = fparse_long(fp);
#line 418
  person->created_confs = (unsigned short )tmp___7;
#line 420
  fskipwhite(fp);
  }
#line 422
  return ((Success )OK);
}
}
#line 445 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_membership_type___0(FILE *fp , Membership_type *result ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 449
  fskipwhite(fp);
#line 451
  tmp = _IO_getc(fp);
#line 451
  result->invitation = (unsigned int )(tmp != 48);
#line 452
  tmp___0 = _IO_getc(fp);
#line 452
  result->passive = (unsigned int )(tmp___0 != 48);
#line 453
  tmp___1 = _IO_getc(fp);
#line 453
  result->secret = (unsigned int )(tmp___1 != 48);
#line 454
  tmp___2 = _IO_getc(fp);
#line 454
  result->passive_message_invert = (unsigned int )(tmp___2 != 48);
#line 455
  tmp___3 = _IO_getc(fp);
#line 455
  result->reserved2 = (unsigned int )(tmp___3 != 48);
#line 456
  tmp___4 = _IO_getc(fp);
#line 456
  result->reserved3 = (unsigned int )(tmp___4 != 48);
#line 457
  tmp___5 = _IO_getc(fp);
#line 457
  result->reserved4 = (unsigned int )(tmp___5 != 48);
#line 458
  tmp___6 = _IO_getc(fp);
#line 458
  result->reserved5 = (unsigned int )(tmp___6 != 48);
  }
#line 460
  return ((Success )OK);
}
}
#line 464 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_read_range_0___0(FILE *fp , Membership *mship ) 
{ 
  Local_text_no last_text_read___0 ;
  unsigned int no_of_read ;
  unsigned int i ;
  unsigned int n ;
  struct read_range *res ;
  struct read_range *tail ;
  Local_text_no tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  Local_text_no tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
  {
#line 478
  last_text_read___0 = fparse_long(fp);
#line 479
  tmp___0 = fparse_long(fp);
#line 479
  no_of_read = (unsigned int )tmp___0;
#line 481
  sfree((void *)mship->read_ranges);
  }
#line 482
  if (last_text_read___0 == 0UL) {
#line 484
    mship->read_ranges = (struct read_range *)((void *)0);
#line 485
    mship->no_of_read_ranges = 0U;
  } else {
    {
#line 489
    mship->no_of_read_ranges = 1U;
#line 490
    tmp___1 = smalloc(sizeof(*(mship->read_ranges + 0)));
#line 490
    mship->read_ranges = (struct read_range *)tmp___1;
#line 491
    (mship->read_ranges)->first_read = (Local_text_no )1;
#line 492
    (mship->read_ranges)->last_read = last_text_read___0;
    }
  }
#line 495
  if (no_of_read > 0U) {
    {
#line 497
    fskipwhite(fp);
#line 498
    tmp___2 = _IO_getc(fp);
    }
    {
#line 500
    if (tmp___2 == 123) {
#line 500
      goto case_123;
    }
#line 537
    if (tmp___2 == 42) {
#line 537
      goto case_42;
    }
#line 543
    goto switch_default;
    case_123: /* CIL Label */ 
#line 501
    n = mship->no_of_read_ranges;
#line 502
    res = mship->read_ranges;
#line 502
    tail = res;
#line 504
    i = 0U;
    {
#line 504
    while (1) {
      while_continue: /* CIL Label */ ;
#line 504
      if (! (i < no_of_read)) {
#line 504
        goto while_break;
      }
      {
#line 506
      tmp = fparse_long(fp);
      }
#line 507
      if ((unsigned long )tail != (unsigned long )((void *)0)) {
#line 507
        if (tmp <= tail->last_read) {
          {
#line 509
          kom_log("fparse_read_range_0: discarded out-of-order local number %lu probably introduced by bug 1121\n",
                  tmp);
          }
        } else {
#line 507
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 513
      if ((unsigned long )tail != (unsigned long )((void *)0)) {
#line 513
        if (tmp == tail->last_read + 1UL) {
#line 514
          tail->last_read = tmp;
        } else {
#line 513
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 517
        n ++;
#line 517
        tmp___3 = srealloc((void *)res, (unsigned long )n * sizeof(*res));
#line 517
        res = (struct read_range *)tmp___3;
#line 518
        tail = res + (n - 1U);
#line 519
        tmp___4 = tmp;
#line 519
        tail->last_read = tmp___4;
#line 519
        tail->first_read = tmp___4;
        }
      }
#line 504
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 523
    mship->no_of_read_ranges = n;
#line 524
    mship->read_ranges = res;
#line 526
    fskipwhite(fp);
#line 527
    tmp___6 = _IO_getc(fp);
    }
#line 527
    if (tmp___6 != 125) {
      {
#line 529
      err_stat = 1UL;
#line 530
      kom_errno = (enum kom_err )24;
#line 531
      tmp___5 = ftell(fp);
#line 531
      kom_log("fparse_read_range_0(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___5);
      }
#line 533
      return ((Success )FAILURE);
    }
#line 535
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 538
    kom_log("fparse_read_range_0(): empty read_ranges with %lu elements (corrected)\n",
            (unsigned long )no_of_read);
#line 541
    mship->no_of_read_ranges = 0U;
    }
#line 542
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 544
    tmp___7 = ftell(fp);
#line 544
    kom_log("fparse_read_range_0(): expected \'*\' or \'{\' at pos %lu.\n", (unsigned long )tmp___7);
#line 546
    err_stat = 2UL;
#line 547
    kom_errno = (enum kom_err )24;
    }
#line 548
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 553
    fskipwhite(fp);
#line 554
    tmp___9 = _IO_getc(fp);
    }
#line 554
    if (tmp___9 != 42) {
      {
#line 556
      tmp___8 = ftell(fp);
#line 556
      kom_log("fparse_read_range_0(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___8);
#line 558
      err_stat = 3UL;
#line 559
      kom_errno = (enum kom_err )24;
      }
#line 560
      return ((Success )FAILURE);
    }
  }
#line 563
  return ((Success )OK);
}
}
#line 566 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_membership_2___0(FILE *fp , Membership *mship ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  Success tmp___1 ;
  unsigned long tmp___2 ;
  Success tmp___3 ;

  {
  {
#line 570
  mship->last_time_read = fparse_time(fp);
#line 572
  tmp = fparse_long(fp);
#line 572
  mship->conf_no = (Conf_no )tmp;
#line 573
  tmp___0 = fparse_long(fp);
#line 573
  mship->priority = (unsigned char )tmp___0;
#line 574
  tmp___1 = fparse_read_range_0___0(fp, mship);
  }
#line 574
  if ((unsigned long )tmp___1 != (unsigned long )OK) {
#line 575
    return ((Success )FAILURE);
  }
  {
#line 576
  tmp___2 = fparse_long(fp);
#line 576
  mship->added_by = (Pers_no )tmp___2;
#line 577
  mship->added_at = fparse_time(fp);
#line 578
  tmp___3 = fparse_membership_type___0(fp, & mship->type);
  }
#line 578
  if ((unsigned long )tmp___3 != (unsigned long )OK) {
#line 579
    return ((Success )FAILURE);
  }
#line 581
  return ((Success )OK);
}
}
#line 584 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_membership_0___0(FILE *fp , Membership *mship ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  Success tmp___1 ;

  {
  {
#line 588
  mship->last_time_read = fparse_time(fp);
#line 590
  tmp = fparse_long(fp);
#line 590
  mship->conf_no = (Conf_no )tmp;
#line 591
  tmp___0 = fparse_long(fp);
#line 591
  mship->priority = (unsigned char )tmp___0;
#line 592
  tmp___1 = fparse_read_range_0___0(fp, mship);
  }
#line 592
  if ((unsigned long )tmp___1 != (unsigned long )OK) {
#line 593
    return ((Success )FAILURE);
  }
#line 595
  return ((Success )OK);
}
}
#line 598 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_membership___0(FILE *fp , Membership *mship ) 
{ 
  Success tmp ;
  Success tmp___0 ;

  {
  {
#line 605
  if (input_format___0 == 1) {
#line 605
    goto case_1;
  }
#line 605
  if (input_format___0 == 0) {
#line 605
    goto case_1;
  }
#line 608
  if (input_format___0 == 2) {
#line 608
    goto case_2;
  }
#line 611
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 606
  tmp = fparse_membership_0___0(fp, mship);
  }
#line 606
  return (tmp);
#line 607
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 609
  tmp___0 = fparse_membership_2___0(fp, mship);
  }
#line 609
  return (tmp___0);
#line 610
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 612
  restart_kom("unknown input format: %d\n", input_format___0);
  }
#line 613
  return ((Success )FAILURE);
#line 614
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 616
  return ((struct success  const  *)0);
}
}
#line 620 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_membership_list_0___0(FILE *fp , Membership_list *result ) 
{ 
  int i ;
  unsigned long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  Success tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
#line 628
  if ((unsigned long )result->confs != (unsigned long )((void *)0)) {
#line 630
    i = 0;
    {
#line 630
    while (1) {
      while_continue: /* CIL Label */ ;
#line 630
      if (! (i < (int )result->no_of_confs)) {
#line 630
        goto while_break;
      }
      {
#line 631
      sfree((void *)(result->confs + i)->read_ranges);
#line 630
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 634
  tmp = fparse_long(fp);
#line 634
  result->no_of_confs = (unsigned short )tmp;
  }
#line 636
  if ((int )result->no_of_confs > 0) {
    {
#line 638
    fskipwhite(fp);
#line 639
    tmp___0 = _IO_getc(fp);
    }
    {
#line 641
    if (tmp___0 == 123) {
#line 641
      goto case_123;
    }
#line 670
    if (tmp___0 == 42) {
#line 670
      goto case_42;
    }
#line 682
    goto switch_default;
    case_123: /* CIL Label */ 
    {
#line 642
    tmp___1 = srealloc((void *)result->confs, (unsigned long )result->no_of_confs * sizeof(Membership ));
#line 642
    result->confs = (Membership *)tmp___1;
    }
#line 645
    if ((unsigned long )result->confs == (unsigned long )((void *)0)) {
#line 645
      if ((int )result->no_of_confs > 0) {
#line 647
        err_stat = 0UL;
#line 648
        kom_errno = (enum kom_err )39;
#line 649
        return ((Success )FAILURE);
      }
    }
#line 652
    i = 0;
    {
#line 652
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 652
      if (! (i < (int )result->no_of_confs)) {
#line 652
        goto while_break___0;
      }
      {
#line 654
      init_membership(result->confs + i);
#line 655
      tmp___2 = fparse_membership_0___0(fp, result->confs + i);
      }
#line 655
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
#line 656
        return ((Success )FAILURE);
      }
#line 652
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 659
    fskipwhite(fp);
#line 660
    tmp___4 = _IO_getc(fp);
    }
#line 660
    if (tmp___4 != 125) {
      {
#line 662
      tmp___3 = ftell(fp);
#line 662
      kom_log("fparse_membership_list(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___3);
#line 664
      err_stat = 4UL;
#line 665
      kom_errno = (enum kom_err )24;
      }
#line 666
      return ((Success )FAILURE);
    }
#line 669
    goto switch_break;
    case_42: /* CIL Label */ 
#line 671
    if ((unsigned long )result->confs != (unsigned long )((void *)0)) {
      {
#line 673
      sfree((void *)result->confs);
#line 674
      result->confs = (Membership *)((void *)0);
      }
    }
    {
#line 676
    kom_log("%s empty list with %lu elements (corrected).\n", "fparse_membership_list():",
            (unsigned long )result->no_of_confs);
#line 680
    result->no_of_confs = (unsigned short)0;
    }
#line 681
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 683
    tmp___5 = ftell(fp);
#line 683
    kom_log("fparse_membership_list(): expected \'*\' or \'{\' at pos %lu.\n", (unsigned long )tmp___5);
#line 685
    err_stat = 5UL;
#line 686
    kom_errno = (enum kom_err )24;
    }
#line 687
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 692
    fskipwhite(fp);
#line 693
    tmp___7 = _IO_getc(fp);
    }
#line 693
    if (tmp___7 != 42) {
      {
#line 695
      tmp___6 = ftell(fp);
#line 695
      kom_log("fparse_membership_list(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___6);
#line 697
      err_stat = 6UL;
#line 698
      kom_errno = (enum kom_err )24;
      }
#line 699
      return ((Success )FAILURE);
    }
#line 701
    if ((unsigned long )result->confs != (unsigned long )((void *)0)) {
      {
#line 703
      sfree((void *)result->confs);
#line 704
      result->confs = (Membership *)((void *)0);
      }
    }
  }
#line 707
  return ((Success )OK);
}
}
#line 710 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_membership_list_2___0(FILE *fp , Membership_list *result ) 
{ 
  int i ;
  unsigned long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  Success tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
#line 718
  if ((unsigned long )result->confs != (unsigned long )((void *)0)) {
#line 720
    i = 0;
    {
#line 720
    while (1) {
      while_continue: /* CIL Label */ ;
#line 720
      if (! (i < (int )result->no_of_confs)) {
#line 720
        goto while_break;
      }
      {
#line 721
      sfree((void *)(result->confs + i)->read_ranges);
#line 720
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 724
  tmp = fparse_long(fp);
#line 724
  result->no_of_confs = (unsigned short )tmp;
  }
#line 726
  if ((int )result->no_of_confs > 0) {
    {
#line 728
    fskipwhite(fp);
#line 729
    tmp___0 = _IO_getc(fp);
    }
    {
#line 731
    if (tmp___0 == 123) {
#line 731
      goto case_123;
    }
#line 760
    if (tmp___0 == 42) {
#line 760
      goto case_42;
    }
#line 772
    goto switch_default;
    case_123: /* CIL Label */ 
    {
#line 732
    tmp___1 = srealloc((void *)result->confs, (unsigned long )result->no_of_confs * sizeof(Membership ));
#line 732
    result->confs = (Membership *)tmp___1;
    }
#line 735
    if ((unsigned long )result->confs == (unsigned long )((void *)0)) {
#line 735
      if ((int )result->no_of_confs > 0) {
#line 737
        err_stat = 0UL;
#line 738
        kom_errno = (enum kom_err )39;
#line 739
        return ((Success )FAILURE);
      }
    }
#line 742
    i = 0;
    {
#line 742
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 742
      if (! (i < (int )result->no_of_confs)) {
#line 742
        goto while_break___0;
      }
      {
#line 744
      init_membership(result->confs + i);
#line 745
      tmp___2 = fparse_membership___0(fp, result->confs + i);
      }
#line 745
      if ((unsigned long )tmp___2 != (unsigned long )OK) {
#line 746
        return ((Success )FAILURE);
      }
#line 742
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 749
    fskipwhite(fp);
#line 750
    tmp___4 = _IO_getc(fp);
    }
#line 750
    if (tmp___4 != 125) {
      {
#line 752
      tmp___3 = ftell(fp);
#line 752
      kom_log("fparse_membership_list(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___3);
#line 754
      err_stat = 4UL;
#line 755
      kom_errno = (enum kom_err )24;
      }
#line 756
      return ((Success )FAILURE);
    }
#line 759
    goto switch_break;
    case_42: /* CIL Label */ 
#line 761
    if ((unsigned long )result->confs != (unsigned long )((void *)0)) {
      {
#line 763
      sfree((void *)result->confs);
#line 764
      result->confs = (Membership *)((void *)0);
      }
    }
    {
#line 766
    kom_log("%s empty list with %lu elements (corrected).\n", "fparse_membership_list():",
            (unsigned long )result->no_of_confs);
#line 770
    result->no_of_confs = (unsigned short)0;
    }
#line 771
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 773
    tmp___5 = ftell(fp);
#line 773
    kom_log("fparse_membership_list(): expected \'*\' or \'{\' at pos %lu.\n", (unsigned long )tmp___5);
#line 775
    err_stat = 5UL;
#line 776
    kom_errno = (enum kom_err )24;
    }
#line 777
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 782
    fskipwhite(fp);
#line 783
    tmp___7 = _IO_getc(fp);
    }
#line 783
    if (tmp___7 != 42) {
      {
#line 785
      tmp___6 = ftell(fp);
#line 785
      kom_log("fparse_membership_list(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___6);
#line 787
      err_stat = 6UL;
#line 788
      kom_errno = (enum kom_err )24;
      }
#line 789
      return ((Success )FAILURE);
    }
#line 791
    if ((unsigned long )result->confs != (unsigned long )((void *)0)) {
      {
#line 793
      sfree((void *)result->confs);
#line 794
      result->confs = (Membership *)((void *)0);
      }
    }
  }
#line 797
  return ((Success )OK);
}
}
#line 1043 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_text_stat_2___0(FILE *fp , Text_stat *result ) 
{ 
  int i ;
  int c ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  void *tmp___5 ;
  Success tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  Success tmp___11 ;

  {
#line 1050
  if (fparse_long_errors___0 != 0) {
    {
#line 1052
    kom_log("fparse_text_stat(): fparse_long_errors == %d on entry. Reset.\n", fparse_long_errors___0);
#line 1054
    fparse_long_errors___0 = 0;
    }
  }
  {
#line 1057
  result->creation_time = fparse_time(fp);
#line 1059
  tmp = fparse_long(fp);
#line 1059
  result->author = (Pers_no )tmp;
#line 1060
  tmp___0 = fparse_long(fp);
#line 1060
  result->file_pos = (long )tmp___0;
#line 1061
  tmp___1 = fparse_long(fp);
#line 1061
  result->no_of_lines = (unsigned short )tmp___1;
#line 1062
  tmp___2 = fparse_long(fp);
#line 1062
  result->no_of_chars = (String_size )tmp___2;
#line 1063
  tmp___3 = fparse_long(fp);
#line 1063
  result->no_of_marks = (unsigned short )tmp___3;
#line 1064
  tmp___4 = fparse_long(fp);
#line 1064
  result->no_of_misc = (unsigned short )tmp___4;
  }
#line 1066
  if (fparse_long_errors___0 != 0) {
    {
#line 1068
    kom_log("%s(): %d fparse_long_errors before \'misc_items\'. Reset.\n", "fparse_text_stat",
            fparse_long_errors___0);
#line 1071
    fparse_long_errors___0 = 0;
    }
#line 1072
    return ((Success )FAILURE);
  }
#line 1075
  if ((int )result->no_of_misc > 0) {
    {
#line 1077
    fskipwhite(fp);
#line 1078
    c = _IO_getc(fp);
    }
    {
#line 1080
    if (c == 123) {
#line 1080
      goto case_123;
    }
#line 1109
    if (c == 43) {
#line 1109
      goto case_43;
    }
#line 1109
    if (c == 64) {
#line 1109
      goto case_43;
    }
#line 1115
    if (c == 42) {
#line 1115
      goto case_42;
    }
#line 1123
    goto switch_default;
    case_123: /* CIL Label */ 
    {
#line 1081
    tmp___5 = srealloc((void *)result->misc_items, (unsigned long )result->no_of_misc * sizeof(Misc_info ));
#line 1081
    result->misc_items = (Misc_info *)tmp___5;
    }
#line 1085
    if ((unsigned long )result->misc_items == (unsigned long )((void *)0)) {
#line 1087
      err_stat = 0UL;
#line 1088
      kom_errno = (enum kom_err )39;
#line 1089
      return ((Success )FAILURE);
    }
#line 1092
    i = 0;
    {
#line 1092
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1092
      if (! (i < (int )result->no_of_misc)) {
#line 1092
        goto while_break;
      }
      {
#line 1093
      tmp___6 = fparse_misc_info(fp, result->misc_items + i);
      }
#line 1093
      if ((unsigned long )tmp___6 != (unsigned long )OK) {
#line 1094
        return ((Success )FAILURE);
      }
#line 1092
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1096
    fskipwhite(fp);
#line 1097
    c = _IO_getc(fp);
    }
#line 1097
    if (c != 125) {
      {
#line 1099
      tmp___7 = ftell(fp);
#line 1099
      kom_log("fparse_text_stat(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___7);
#line 1101
      err_stat = 16UL;
#line 1102
      kom_errno = (enum kom_err )24;
      }
#line 1103
      return ((Success )FAILURE);
    }
#line 1106
    goto switch_break;
    case_43: /* CIL Label */ 
    case_64: /* CIL Label */ 
    {
#line 1110
    ungetc(c, fp);
#line 1111
    kom_log("fparse_text_stat(): got \'%c\'; expected \'{\' or \'*\'\n.", c);
#line 1112
    tmp___8 = ftell(fp);
#line 1112
    kom_log("Character ungetc\'d and interpreted as a \'*\'. (pos %lu).\n", (unsigned long )tmp___8);
    }
    case_42: /* CIL Label */ 
#line 1116
    if ((unsigned long )result->misc_items != (unsigned long )((void *)0)) {
      {
#line 1118
      sfree((void *)result->misc_items);
#line 1119
      result->misc_items = (Misc_info *)((void *)0);
      }
    }
#line 1121
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1124
    tmp___9 = ftell(fp);
#line 1124
    kom_log("fparse_text_stat(): expected \'*\' or \'}\' at pos %lu.\n", (unsigned long )tmp___9);
#line 1126
    err_stat = 17UL;
#line 1127
    kom_errno = (enum kom_err )24;
    }
#line 1128
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1133
    fskipwhite(fp);
#line 1134
    c = _IO_getc(fp);
    }
#line 1134
    if (c != 42) {
      {
#line 1136
      tmp___10 = ftell(fp);
#line 1136
      kom_log("fparse_text_stat(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___10);
#line 1138
      err_stat = 18UL;
#line 1139
      kom_errno = (enum kom_err )24;
      }
#line 1140
      return ((Success )FAILURE);
    }
#line 1143
    if ((unsigned long )result->misc_items != (unsigned long )((void *)0)) {
      {
#line 1145
      sfree((void *)result->misc_items);
#line 1146
      result->misc_items = (Misc_info *)((void *)0);
      }
    }
  }
  {
#line 1150
  result->highest_aux = fparse_long(fp);
#line 1151
  tmp___11 = fparse_aux_item_list(fp, & result->aux_item_list);
  }
#line 1151
  if ((unsigned long )tmp___11 != (unsigned long )OK) {
#line 1152
    return ((Success )FAILURE);
  }
  {
#line 1154
  fskipwhite(fp);
  }
#line 1156
  return ((Success )OK);
}
}
#line 1159 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_text_stat_0___0(FILE *fp , Text_stat *result ) 
{ 
  int i ;
  int c ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  void *tmp___5 ;
  Success tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
#line 1166
  if (fparse_long_errors___0 != 0) {
    {
#line 1168
    kom_log("fparse_text_stat(): fparse_long_errors == %d on entry. Reset.\n", fparse_long_errors___0);
#line 1170
    fparse_long_errors___0 = 0;
    }
  }
  {
#line 1173
  result->creation_time = fparse_time(fp);
#line 1175
  tmp = fparse_long(fp);
#line 1175
  result->author = (Pers_no )tmp;
#line 1176
  tmp___0 = fparse_long(fp);
#line 1176
  result->file_pos = (long )tmp___0;
#line 1177
  tmp___1 = fparse_long(fp);
#line 1177
  result->no_of_lines = (unsigned short )tmp___1;
#line 1178
  tmp___2 = fparse_long(fp);
#line 1178
  result->no_of_chars = (String_size )tmp___2;
#line 1179
  tmp___3 = fparse_long(fp);
#line 1179
  result->no_of_marks = (unsigned short )tmp___3;
#line 1180
  tmp___4 = fparse_long(fp);
#line 1180
  result->no_of_misc = (unsigned short )tmp___4;
  }
#line 1182
  if (fparse_long_errors___0 != 0) {
    {
#line 1184
    kom_log("%s(): %d fparse_long_errors before \'misc_items\'. Reset.\n", "fparse_text_stat",
            fparse_long_errors___0);
#line 1187
    fparse_long_errors___0 = 0;
    }
#line 1188
    return ((Success )FAILURE);
  }
#line 1191
  if ((int )result->no_of_misc > 0) {
    {
#line 1193
    fskipwhite(fp);
#line 1194
    c = _IO_getc(fp);
    }
    {
#line 1196
    if (c == 123) {
#line 1196
      goto case_123;
    }
#line 1225
    if (c == 43) {
#line 1225
      goto case_43;
    }
#line 1225
    if (c == 64) {
#line 1225
      goto case_43;
    }
#line 1231
    if (c == 42) {
#line 1231
      goto case_42;
    }
#line 1239
    goto switch_default;
    case_123: /* CIL Label */ 
    {
#line 1197
    tmp___5 = srealloc((void *)result->misc_items, (unsigned long )result->no_of_misc * sizeof(Misc_info ));
#line 1197
    result->misc_items = (Misc_info *)tmp___5;
    }
#line 1201
    if ((unsigned long )result->misc_items == (unsigned long )((void *)0)) {
#line 1203
      err_stat = 0UL;
#line 1204
      kom_errno = (enum kom_err )39;
#line 1205
      return ((Success )FAILURE);
    }
#line 1208
    i = 0;
    {
#line 1208
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1208
      if (! (i < (int )result->no_of_misc)) {
#line 1208
        goto while_break;
      }
      {
#line 1209
      tmp___6 = fparse_misc_info(fp, result->misc_items + i);
      }
#line 1209
      if ((unsigned long )tmp___6 != (unsigned long )OK) {
#line 1210
        return ((Success )FAILURE);
      }
#line 1208
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1212
    fskipwhite(fp);
#line 1213
    c = _IO_getc(fp);
    }
#line 1213
    if (c != 125) {
      {
#line 1215
      tmp___7 = ftell(fp);
#line 1215
      kom_log("fparse_text_stat(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___7);
#line 1217
      err_stat = 19UL;
#line 1218
      kom_errno = (enum kom_err )24;
      }
#line 1219
      return ((Success )FAILURE);
    }
#line 1222
    goto switch_break;
    case_43: /* CIL Label */ 
    case_64: /* CIL Label */ 
    {
#line 1226
    ungetc(c, fp);
#line 1227
    kom_log("fparse_text_stat(): got \'%c\'; expected \'{\' or \'*\'\n.", c);
#line 1228
    tmp___8 = ftell(fp);
#line 1228
    kom_log("Character ungetc\'d and interpreted as a \'*\'. (pos %lu).\n", (unsigned long )tmp___8);
    }
    case_42: /* CIL Label */ 
#line 1232
    if ((unsigned long )result->misc_items != (unsigned long )((void *)0)) {
      {
#line 1234
      sfree((void *)result->misc_items);
#line 1235
      result->misc_items = (Misc_info *)((void *)0);
      }
    }
#line 1237
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1240
    tmp___9 = ftell(fp);
#line 1240
    kom_log("fparse_text_stat(): expected \'*\' or \'}\' at pos %lu.\n", (unsigned long )tmp___9);
#line 1242
    err_stat = 20UL;
#line 1243
    kom_errno = (enum kom_err )24;
    }
#line 1244
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1249
    fskipwhite(fp);
#line 1250
    c = _IO_getc(fp);
    }
#line 1250
    if (c != 42) {
      {
#line 1252
      tmp___10 = ftell(fp);
#line 1252
      kom_log("fparse_text_stat(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___10);
#line 1254
      err_stat = 21UL;
#line 1255
      kom_errno = (enum kom_err )24;
      }
#line 1256
      return ((Success )FAILURE);
    }
#line 1259
    if ((unsigned long )result->misc_items != (unsigned long )((void *)0)) {
      {
#line 1261
      sfree((void *)result->misc_items);
#line 1262
      result->misc_items = (Misc_info *)((void *)0);
      }
    }
  }
  {
#line 1266
  result->highest_aux = 0UL;
#line 1267
  result->aux_item_list.length = (unsigned short)0;
#line 1268
  result->aux_item_list.items = (Aux_item *)((void *)0);
#line 1270
  fskipwhite(fp);
  }
#line 1271
  return ((Success )OK);
}
}
#line 1295 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_text_list___0(FILE *fp , Local_to_global *result ) 
{ 
  unsigned long i ;
  Local_text_no lno ;
  Local_text_no no_of_texts ;
  int tmp ;
  unsigned long tmp___0 ;
  Local_text_no tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1303
  lno = fparse_long(fp);
#line 1304
  no_of_texts = fparse_long(fp);
#line 1305
  l2g_clear(result);
  }
#line 1307
  if (no_of_texts > 0UL) {
    {
#line 1309
    fskipwhite(fp);
#line 1310
    tmp = _IO_getc(fp);
    }
    {
#line 1312
    if (tmp == 123) {
#line 1312
      goto case_123;
    }
#line 1328
    goto switch_default;
    case_123: /* CIL Label */ 
#line 1313
    i = 0UL;
    {
#line 1313
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1313
      if (! (i < no_of_texts)) {
#line 1313
        goto while_break;
      }
      {
#line 1314
      tmp___0 = fparse_long(fp);
#line 1314
      tmp___1 = lno;
#line 1314
      lno ++;
#line 1314
      l2g_append(result, tmp___1, tmp___0);
#line 1313
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1316
    fskipwhite(fp);
#line 1317
    tmp___3 = _IO_getc(fp);
    }
#line 1317
    if (tmp___3 != 125) {
      {
#line 1319
      tmp___2 = ftell(fp);
#line 1319
      kom_log("fparse_text_list(): expected \'}\' at pos %lu.\n", (unsigned long )tmp___2);
#line 1321
      err_stat = 22UL;
#line 1322
      kom_errno = (enum kom_err )24;
      }
#line 1323
      return ((Success )FAILURE);
    }
#line 1326
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1329
    tmp___4 = ftell(fp);
#line 1329
    kom_log("fparse_text_list(): expected \'{\' at pos %lu.\n", (unsigned long )tmp___4);
#line 1331
    err_stat = 23UL;
#line 1332
    kom_errno = (enum kom_err )24;
    }
#line 1333
    return ((Success )FAILURE);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1338
    fskipwhite(fp);
#line 1339
    tmp___6 = _IO_getc(fp);
    }
#line 1339
    if (tmp___6 != 42) {
      {
#line 1341
      tmp___5 = ftell(fp);
#line 1341
      kom_log("fparse_text_list(): expected \'*\' at pos %lu.\n", (unsigned long )tmp___5);
#line 1343
      err_stat = 24UL;
#line 1344
      kom_errno = (enum kom_err )24;
      }
#line 1345
      return ((Success )FAILURE);
    }
    {
#line 1347
    l2g_set_first_appendable_key(result, lno);
    }
  }
#line 1349
  return ((Success )OK);
}
}
#line 1475 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_member_0___0(FILE *fp , Member *result ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1479
  tmp = fparse_long(fp);
#line 1479
  result->member = (Pers_no )tmp;
  }
#line 1480
  return ((Success )OK);
}
}
#line 1483 "/home/wheatley/newnew/temp/lyskom-server-2.1.2/src/server/ram-parse.c"
static Success fparse_member_2___0(FILE *fp , Member *result ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  Success tmp___1 ;

  {
  {
#line 1487
  tmp = fparse_long(fp);
#line 1487
  result->member = (Pers_no )tmp;
#line 1488
  tmp___0 = fparse_long(fp);
#line 1488
  result->added_by = (Pers_no )tmp___0;
#line 1489
  result->added_at = fparse_time(fp);
#line 1490
  tmp___1 = fparse_membership_type___0(fp, & result->type);
  }
#line 1490
  return (tmp___1);
}
}
