/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_19 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_20 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_19 ifr_ifrn ;
   union __anonunion_ifr_ifru_20 ifr_ifru ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 40 "/usr/include/linux/capability.h"
struct __user_cap_header_struct {
   __u32 version ;
   int pid ;
};
#line 40 "/usr/include/linux/capability.h"
typedef struct __user_cap_header_struct *cap_user_header_t;
#line 45 "/usr/include/linux/capability.h"
struct __user_cap_data_struct {
   __u32 effective ;
   __u32 permitted ;
   __u32 inheritable ;
};
#line 45 "/usr/include/linux/capability.h"
typedef struct __user_cap_data_struct *cap_user_data_t;
#line 138 "/usr/include/net/if_arp.h"
struct arpreq {
   struct sockaddr arp_pa ;
   struct sockaddr arp_ha ;
   int arp_flags ;
   struct sockaddr arp_netmask ;
   char arp_dev[16] ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/dhcp-helper-1.1/dhcp-helper.c"
struct namelist {
   char name[16] ;
   struct in_addr addr ;
   struct namelist *next ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/dhcp-helper-1.1/dhcp-helper.c"
struct interface {
   int index ;
   struct in_addr addr ;
   struct interface *next ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/dhcp-helper-1.1/dhcp-helper.c"
struct dhcp_packet {
   unsigned char op ;
   unsigned char htype ;
   unsigned char hlen ;
   unsigned char hops ;
   unsigned int xid ;
   unsigned short secs ;
   unsigned short flags ;
   struct in_addr ciaddr ;
   struct in_addr yiaddr ;
   struct in_addr siaddr ;
   struct in_addr giaddr ;
   unsigned char chaddr[16] ;
   unsigned char sname[64] ;
   unsigned char file[128] ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/dhcp-helper-1.1/dhcp-helper.c"
struct dhcp_packet_with_opts {
   struct dhcp_packet header ;
   unsigned char options[312] ;
};
#line 355 "/home/june/repo/benchmarks/collector/temp/dhcp-helper-1.1/dhcp-helper.c"
union __anonunion_control_u_43 {
   struct cmsghdr align ;
   char control[(((sizeof(struct in_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
};
#line 395 "/home/june/repo/benchmarks/collector/temp/dhcp-helper-1.1/dhcp-helper.c"
union __anonunion_p_44 {
   unsigned char *c ;
   struct in_pktinfo *p ;
};
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                struct cmsghdr *__cmsg ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 184
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 105 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/dhcp-helper-1.1/dhcp-helper.c"
extern int capset(cap_user_header_t header , cap_user_data_t data ) ;
#line 45
extern int capget(cap_user_header_t header , cap_user_data_t data ) ;
#line 27 "/usr/include/x86_64-linux-gnu/sys/prctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) prctl)(int __option 
                                                                            , ...) ;
#line 88 "/home/june/repo/benchmarks/collector/temp/dhcp-helper-1.1/dhcp-helper.c"
int main(int argc , char **argv ) 
{ 
  int fd ;
  int oneopt ;
  int mtuopt ;
  struct ifreq ifr ;
  struct sockaddr_in saddr ;
  size_t buf_size ;
  struct dhcp_packet *packet ;
  struct namelist *interfaces ;
  struct namelist *except ;
  struct interface *ifaces ;
  struct namelist *servers ;
  char *runfile ;
  char *user ;
  int debug ;
  int altports ;
  int option ;
  int tmp ;
  struct namelist *new ;
  void *tmp___0 ;
  struct hostent *e ;
  struct hostent *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  FILE *pidfile ;
  int i ;
  struct passwd *ent_pw ;
  struct passwd *tmp___16 ;
  gid_t dummy ;
  struct group *gp ;
  cap_user_header_t hdr ;
  void *tmp___17 ;
  cap_user_data_t data ;
  int capsize ;
  void *tmp___18 ;
  __u32 tmp___19 ;
  __u32 tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  __uid_t tmp___23 ;
  __pid_t tmp___24 ;
  __pid_t tmp___25 ;
  __pid_t tmp___26 ;
  __u32 tmp___27 ;
  __uid_t tmp___28 ;
  int iface_index ;
  struct in_addr iface_addr ;
  struct interface *iface ;
  ssize_t sz ;
  struct msghdr msg ;
  struct iovec iov ;
  struct cmsghdr *cmptr ;
  struct in_pktinfo *pkt ;
  union __anonunion_control_u_43 control_u ;
  struct dhcp_packet *newbuf ;
  size_t newsz ;
  int *tmp___29 ;
  void *tmp___30 ;
  int *tmp___31 ;
  union __anonunion_p_44 p ;
  int tmp___32 ;
  int tmp___33 ;
  unsigned char tmp___34 ;
  struct namelist *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  ssize_t tmp___41 ;
  int *tmp___42 ;
  void *tmp___43 ;
  int tmp___44 ;
  size_t tmp___45 ;
  struct arpreq req ;
  struct sockaddr *pa ;
  int tmp___46 ;
  uint16_t tmp___47 ;
  ssize_t tmp___48 ;
  int *tmp___49 ;

  {
#line 90
  fd = -1;
#line 90
  oneopt = 1;
#line 90
  mtuopt = 0;
#line 93
  buf_size = sizeof(struct dhcp_packet_with_opts );
#line 95
  interfaces = (struct namelist *)((void *)0);
#line 95
  except = (struct namelist *)((void *)0);
#line 96
  ifaces = (struct interface *)((void *)0);
#line 97
  servers = (struct namelist *)((void *)0);
#line 98
  runfile = (char *)"/var/run/dhcp-helper.pid";
#line 99
  user = (char *)"nobody";
#line 100
  debug = 0;
#line 100
  altports = 0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    tmp = getopt(argc, (char * const  *)argv, "b:e:i:s:u:r:dvp");
#line 104
    option = tmp;
    }
#line 106
    if (option == -1) {
#line 107
      goto while_break;
    }
    {
#line 111
    if (option == 101) {
#line 111
      goto case_101;
    }
#line 111
    if (option == 105) {
#line 111
      goto case_101;
    }
#line 111
    if (option == 98) {
#line 111
      goto case_101;
    }
#line 111
    if (option == 115) {
#line 111
      goto case_101;
    }
#line 171
    if (option == 117) {
#line 171
      goto case_117;
    }
#line 176
    if (option == 114) {
#line 176
      goto case_114;
    }
#line 181
    if (option == 100) {
#line 181
      goto case_100;
    }
#line 185
    if (option == 112) {
#line 185
      goto case_112;
    }
#line 189
    if (option == 118) {
#line 189
      goto case_118;
    }
#line 193
    goto switch_default;
    case_101: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_115: /* CIL Label */ 
    {
#line 113
    tmp___0 = malloc(sizeof(struct namelist ));
#line 113
    new = (struct namelist *)tmp___0;
    }
#line 115
    if (! new) {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dhcp-helper: cannot get memory\n");
#line 118
      exit(1);
      }
    }
    {
#line 121
    strncpy((char */* __restrict  */)(new->name), (char const   */* __restrict  */)optarg,
            (size_t )16);
#line 122
    strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)optarg,
            (size_t )16);
#line 123
    new->addr.s_addr = (in_addr_t )0;
    }
#line 125
    if (option == 115) {
      {
#line 127
      tmp___1 = gethostbyname((char const   *)optarg);
#line 127
      e = tmp___1;
      }
#line 129
      if (! e) {
        {
#line 131
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dhcp-helper: cannot resolve server name %s\n",
                optarg);
#line 132
        exit(1);
        }
      }
#line 134
      new->addr = *((struct in_addr *)*(e->h_addr_list + 0));
    } else {
      {
#line 136
      tmp___5 = strlen((char const   *)optarg);
      }
#line 136
      if (tmp___5 > 16UL) {
        {
#line 138
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dhcp-helper: interface name too long: %s\n",
                optarg);
#line 139
        exit(1);
        }
      } else
#line 141
      if (fd == -1) {
        {
#line 141
        fd = socket(2, 2, 0);
        }
#line 141
        if (fd == -1) {
          {
#line 144
          tmp___2 = __errno_location();
#line 144
          tmp___3 = strerror(*tmp___2);
#line 144
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dhcp-helper: bad interface %s: %s\n",
                  optarg, tmp___3);
#line 145
          exit(1);
          }
        } else {
#line 141
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 141
        tmp___4 = ioctl(fd, 35091UL, & ifr);
        }
#line 141
        if (tmp___4 == -1) {
          {
#line 144
          tmp___2 = __errno_location();
#line 144
          tmp___3 = strerror(*tmp___2);
#line 144
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dhcp-helper: bad interface %s: %s\n",
                  optarg, tmp___3);
#line 145
          exit(1);
          }
        } else
#line 147
        if (option == 98) {
#line 147
          if (! ((int )ifr.ifr_ifru.ifru_flags & 2)) {
            {
#line 149
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dhcp-helper: interface %s cannot broadcast\n",
                    optarg);
#line 150
            exit(1);
            }
          }
        }
      }
    }
#line 153
    if (option == 105) {
#line 155
      new->next = interfaces;
#line 156
      interfaces = new;
    } else
#line 158
    if (option == 101) {
#line 160
      new->next = except;
#line 161
      except = new;
    } else {
#line 165
      new->next = servers;
#line 166
      servers = new;
    }
#line 169
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 172
    tmp___6 = strlen((char const   *)optarg);
#line 172
    tmp___7 = malloc(tmp___6 + 1UL);
#line 172
    user = (char *)tmp___7;
    }
#line 172
    if (user) {
      {
#line 173
      strcpy((char */* __restrict  */)user, (char const   */* __restrict  */)optarg);
      }
    }
#line 174
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 177
    tmp___8 = strlen((char const   *)optarg);
#line 177
    tmp___9 = malloc(tmp___8 + 1UL);
#line 177
    runfile = (char *)tmp___9;
    }
#line 177
    if (runfile) {
      {
#line 178
      strcpy((char */* __restrict  */)runfile, (char const   */* __restrict  */)optarg);
      }
    }
#line 179
    goto switch_break;
    case_100: /* CIL Label */ 
#line 182
    debug = 1;
#line 183
    goto switch_break;
    case_112: /* CIL Label */ 
#line 186
    altports = 1;
#line 187
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 190
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dhcp-helper version %s, %s\n",
            "1.1", "Copyright (C) 2004-2012 Simon Kelley");
#line 191
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 194
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: dhcp-helper [OPTIONS]\nOptions are:\n-s <server>      Forward DHCP requests to <server>\n-b <interface>   Forward DHCP requests as broadcasts via <interface>\n-i <interface>   Listen for DHCP requests on <interface>\n-e <interface>   Do not listen for DHCP requests on <interface>\n-u <user>        Change to user <user> (defaults to %s)\n-r <file>        Write daemon PID to this file (default %s)\n-p               Use alternative ports (1067/1068)\n-d               Debug mode\n-v               Give version and copyright info and then exit\n",
            "nobody", "/var/run/dhcp-helper.pid");
#line 207
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  if (! servers) {
    {
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dhcp-helper: no destination specifed; give at least -s or -b option.\n");
#line 215
    exit(1);
    }
  }
  {
#line 218
  tmp___10 = malloc(buf_size);
#line 218
  packet = (struct dhcp_packet *)tmp___10;
  }
#line 218
  if (! packet) {
    {
#line 220
    perror("dhcp-helper: cannot allocate buffer");
#line 221
    exit(1);
    }
  }
#line 224
  if (fd == -1) {
    {
#line 224
    fd = socket(2, 2, 0);
    }
#line 224
    if (fd == -1) {
      {
#line 226
      perror("dhcp-helper: cannot create socket");
#line 227
      exit(1);
      }
    }
  }
  {
#line 230
  tmp___11 = setsockopt(fd, 0, 8, (void const   *)(& oneopt), (socklen_t )sizeof(oneopt));
  }
#line 230
  if (tmp___11 == -1) {
    {
#line 234
    perror("dhcp-helper: cannot set options on DHCP socket");
#line 235
    exit(1);
    }
  } else {
    {
#line 230
    tmp___12 = setsockopt(fd, 1, 6, (void const   *)(& oneopt), (socklen_t )sizeof(oneopt));
    }
#line 230
    if (tmp___12 == -1) {
      {
#line 234
      perror("dhcp-helper: cannot set options on DHCP socket");
#line 235
      exit(1);
      }
    } else {
      {
#line 230
      tmp___13 = setsockopt(fd, 0, 10, (void const   *)(& mtuopt), (socklen_t )sizeof(mtuopt));
      }
#line 230
      if (tmp___13 == -1) {
        {
#line 234
        perror("dhcp-helper: cannot set options on DHCP socket");
#line 235
        exit(1);
        }
      }
    }
  }
#line 238
  saddr.sin_family = (sa_family_t )2;
#line 239
  if (altports) {
#line 239
    tmp___14 = 1067;
  } else {
#line 239
    tmp___14 = 67;
  }
  {
#line 239
  saddr.sin_port = htons((uint16_t )tmp___14);
#line 240
  saddr.sin_addr.s_addr = (in_addr_t )0;
#line 241
  tmp___15 = bind(fd, (struct sockaddr  const  *)((struct sockaddr *)(& saddr)), (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 241
  if (tmp___15) {
    {
#line 243
    perror("dhcp-helper: cannot bind DHCP server socket");
#line 244
    exit(1);
    }
  }
#line 247
  if (! debug) {
    {
#line 251
    tmp___16 = getpwnam((char const   *)user);
#line 251
    ent_pw = tmp___16;
#line 254
    tmp___17 = malloc(sizeof(*hdr));
#line 254
    hdr = (cap_user_header_t )tmp___17;
#line 255
    data = (cap_user_data_t )((void *)0);
#line 257
    tmp___23 = getuid();
    }
#line 257
    if (tmp___23 == 0U) {
#line 259
      if (hdr) {
        {
#line 261
        capsize = 1;
#line 264
        memset((void *)hdr, 0, sizeof(*hdr));
#line 265
        capget(hdr, (cap_user_data_t )((void *)0));
        }
#line 267
        if (hdr->version != 429392688U) {
#line 270
          if (hdr->version != 537333798U) {
#line 271
            hdr->version = (__u32 )537396514;
          }
#line 272
          capsize = 2;
        }
        {
#line 275
        tmp___18 = malloc(sizeof(*data) * (unsigned long )capsize);
#line 275
        data = (cap_user_data_t )tmp___18;
        }
#line 275
        if (data) {
          {
#line 276
          memset((void *)data, 0, sizeof(*data) * (unsigned long )capsize);
          }
        }
      }
#line 279
      if (! hdr) {
        {
#line 281
        perror("dhcp-helper: cannot allocate memory");
#line 282
        exit(1);
        }
      } else
#line 279
      if (! data) {
        {
#line 281
        perror("dhcp-helper: cannot allocate memory");
#line 282
        exit(1);
        }
      }
      {
#line 285
      hdr->pid = 0;
#line 286
      tmp___20 = (__u32 )(((1 << 12) | (1 << 6)) | (1 << 7));
#line 286
      data->inheritable = tmp___20;
#line 286
      tmp___19 = tmp___20;
#line 286
      data->permitted = tmp___19;
#line 286
      data->effective = tmp___19;
#line 290
      tmp___21 = capset(hdr, data);
      }
#line 290
      if (tmp___21 == -1) {
        {
#line 292
        perror("dhcp-helper: cannot set kernel capabilities");
#line 293
        exit(1);
        }
      } else {
        {
#line 290
        tmp___22 = prctl(8, 1);
        }
#line 290
        if (tmp___22 == -1) {
          {
#line 292
          perror("dhcp-helper: cannot set kernel capabilities");
#line 293
          exit(1);
          }
        }
      }
#line 296
      if (! ent_pw) {
        {
#line 298
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dhcp-helper: cannot find user %s\n",
                user);
#line 299
        exit(1);
        }
      }
    }
    {
#line 306
    tmp___24 = fork();
    }
#line 306
    if (tmp___24 != 0) {
      {
#line 307
      _exit(0);
      }
    }
    {
#line 309
    setsid();
#line 311
    tmp___25 = fork();
    }
#line 311
    if (tmp___25 != 0) {
      {
#line 312
      _exit(0);
      }
    }
    {
#line 314
    chdir("/");
#line 315
    umask((__mode_t )18);
#line 318
    pidfile = fopen((char const   */* __restrict  */)runfile, (char const   */* __restrict  */)"w");
    }
#line 318
    if (pidfile) {
      {
#line 320
      tmp___26 = getpid();
#line 320
      fprintf((FILE */* __restrict  */)pidfile, (char const   */* __restrict  */)"%d\n",
              tmp___26);
#line 321
      fclose(pidfile);
      }
    }
    {
#line 324
    umask((__mode_t )0);
#line 326
    i = 0;
    }
    {
#line 326
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 326
      if (! (i < 64)) {
#line 326
        goto while_break___0;
      }
#line 327
      if (i != fd) {
        {
#line 328
        close(i);
        }
      }
#line 326
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 330
    tmp___28 = getuid();
    }
#line 330
    if (tmp___28 == 0U) {
      {
#line 332
      setgroups((size_t )0, (__gid_t const   *)(& dummy));
#line 334
      gp = getgrgid(ent_pw->pw_gid);
      }
#line 334
      if (gp) {
        {
#line 335
        setgid(gp->gr_gid);
        }
      }
      {
#line 336
      setuid(ent_pw->pw_uid);
#line 338
      tmp___27 = (__u32 )(1 << 12);
#line 338
      data->permitted = tmp___27;
#line 338
      data->effective = tmp___27;
#line 339
      data->inheritable = (__u32 )0;
#line 342
      capset(hdr, data);
      }
    }
  }
  {
#line 346
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 360
    msg.msg_control = (void *)(control_u.control);
#line 361
    msg.msg_controllen = sizeof(control_u);
#line 362
    msg.msg_name = (void *)(& saddr);
#line 363
    msg.msg_namelen = (socklen_t )0;
#line 364
    msg.msg_iov = & iov;
#line 365
    msg.msg_iovlen = (size_t )1;
#line 366
    iov.iov_base = (void *)packet;
#line 367
    iov.iov_len = buf_size;
    {
#line 369
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 373
      msg.msg_flags = 0;
      {
#line 374
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 374
        sz = recvmsg(fd, & msg, 2);
        }
#line 374
        if (sz == -1L) {
          {
#line 374
          tmp___29 = __errno_location();
          }
#line 374
          if (! (*tmp___29 == 4)) {
#line 374
            goto while_break___3;
          }
        } else {
#line 374
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 376
      if (sz == -1L) {
#line 378
        goto while_break___2;
      } else
#line 376
      if (! (msg.msg_flags & 32)) {
#line 378
        goto while_break___2;
      } else {
        {
#line 376
        newsz = buf_size + 100UL;
#line 376
        tmp___30 = realloc((void *)packet, newsz);
#line 376
        newbuf = (struct dhcp_packet *)tmp___30;
        }
#line 376
        if (! newbuf) {
#line 378
          goto while_break___2;
        }
      }
#line 380
      packet = newbuf;
#line 380
      iov.iov_base = (void *)packet;
#line 381
      buf_size = newsz;
#line 381
      iov.iov_len = buf_size;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 384
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 384
      sz = recvmsg(fd, & msg, 0);
      }
#line 384
      if (sz == -1L) {
        {
#line 384
        tmp___31 = __errno_location();
        }
#line 384
        if (! (*tmp___31 == 4)) {
#line 384
          goto while_break___4;
        }
      } else {
#line 384
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 386
    if (msg.msg_flags & 32) {
#line 389
      goto while_continue___1;
    } else
#line 386
    if (sz < (ssize_t )sizeof(struct dhcp_packet )) {
#line 389
      goto while_continue___1;
    } else
#line 386
    if (msg.msg_controllen < sizeof(struct cmsghdr )) {
#line 389
      goto while_continue___1;
    }
#line 391
    iface_index = 0;
#line 392
    if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 392
      cmptr = (struct cmsghdr *)msg.msg_control;
    } else {
#line 392
      cmptr = (struct cmsghdr *)0;
    }
    {
#line 392
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 392
      if (! cmptr) {
#line 392
        goto while_break___5;
      }
#line 393
      if (cmptr->cmsg_level == 0) {
#line 393
        if (cmptr->cmsg_type == 8) {
#line 399
          p.c = cmptr->__cmsg_data;
#line 400
          iface_index = (p.p)->ipi_ifindex;
        }
      }
      {
#line 392
      cmptr = __cmsg_nxthdr(& msg, cmptr);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 403
    ifr.ifr_ifru.ifru_ivalue = iface_index;
#line 403
    if (ifr.ifr_ifru.ifru_ivalue) {
      {
#line 403
      tmp___32 = ioctl(fd, 35088UL, & ifr);
      }
#line 403
      if (tmp___32 == -1) {
#line 404
        goto while_continue___1;
      }
    } else {
#line 404
      goto while_continue___1;
    }
    {
#line 406
    ifr.ifr_ifru.ifru_addr.sa_family = (sa_family_t )2;
#line 407
    tmp___33 = ioctl(fd, 35093UL, & ifr);
    }
#line 407
    if (tmp___33 == -1) {
#line 408
      goto while_continue___1;
    } else {
#line 410
      iface_addr = ((struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr))->sin_addr;
    }
#line 413
    tmp___34 = packet->hops;
#line 413
    packet->hops = (unsigned char )((int )packet->hops + 1);
#line 413
    if ((int )tmp___34 > 20) {
#line 414
      goto while_continue___1;
    }
#line 416
    if ((int )packet->hlen > 16) {
#line 417
      goto while_continue___1;
    }
#line 419
    if ((int )packet->op == 1) {
#line 426
      tmp___35 = servers;
      {
#line 426
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 426
        if (! tmp___35) {
#line 426
          goto while_break___6;
        }
#line 427
        if (tmp___35->addr.s_addr == 0U) {
          {
#line 427
          tmp___36 = strncmp((char const   *)(tmp___35->name), (char const   *)(ifr.ifr_ifrn.ifrn_name),
                             (size_t )16);
          }
#line 427
          if (tmp___36 == 0) {
#line 428
            goto while_break___6;
          }
        }
#line 426
        tmp___35 = tmp___35->next;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 429
      if (tmp___35) {
#line 430
        goto while_continue___1;
      }
#line 433
      tmp___35 = except;
      {
#line 433
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 433
        if (! tmp___35) {
#line 433
          goto while_break___7;
        }
        {
#line 434
        tmp___37 = strncmp((char const   *)(tmp___35->name), (char const   *)(ifr.ifr_ifrn.ifrn_name),
                           (size_t )16);
        }
#line 434
        if (tmp___37 == 0) {
#line 435
          goto while_break___7;
        }
#line 433
        tmp___35 = tmp___35->next;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 436
      if (tmp___35) {
#line 437
        goto while_continue___1;
      }
#line 439
      if (interfaces) {
#line 441
        tmp___35 = interfaces;
        {
#line 441
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 441
          if (! tmp___35) {
#line 441
            goto while_break___8;
          }
          {
#line 442
          tmp___38 = strncmp((char const   *)(tmp___35->name), (char const   *)(ifr.ifr_ifrn.ifrn_name),
                             (size_t )16);
          }
#line 442
          if (tmp___38 == 0) {
#line 443
            goto while_break___8;
          }
#line 441
          tmp___35 = tmp___35->next;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 444
        if (! tmp___35) {
#line 445
          goto while_continue___1;
        }
      }
#line 449
      if (packet->giaddr.s_addr) {
#line 452
        iface = ifaces;
        {
#line 452
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 452
          if (! iface) {
#line 452
            goto while_break___9;
          }
#line 453
          if (iface->addr.s_addr == packet->giaddr.s_addr) {
#line 454
            goto while_break___9;
          }
#line 452
          iface = iface->next;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 455
        if (iface) {
#line 456
          goto while_continue___1;
        }
      } else {
#line 461
        packet->giaddr = iface_addr;
      }
#line 465
      tmp___35 = servers;
      {
#line 465
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 465
        if (! tmp___35) {
#line 465
          goto while_break___10;
        }
#line 468
        if (tmp___35->addr.s_addr == 0U) {
          {
#line 470
          strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)(tmp___35->name),
                  (size_t )16);
#line 471
          tmp___39 = ioctl(fd, 35097UL, & ifr);
          }
#line 471
          if (tmp___39 == -1) {
#line 472
            goto __Cont;
          }
#line 473
          saddr.sin_addr = ((struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr))->sin_addr;
        } else {
#line 476
          saddr.sin_addr = tmp___35->addr;
        }
#line 478
        if (altports) {
#line 478
          tmp___40 = 1067;
        } else {
#line 478
          tmp___40 = 67;
        }
        {
#line 478
        saddr.sin_port = htons((uint16_t )tmp___40);
        }
        {
#line 479
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 479
          tmp___41 = sendto(fd, (void const   *)packet, (size_t )sz, 0, (struct sockaddr  const  *)((struct sockaddr *)(& saddr)),
                            (socklen_t )sizeof(saddr));
          }
#line 479
          if (tmp___41 == -1L) {
            {
#line 479
            tmp___42 = __errno_location();
            }
#line 479
            if (! (*tmp___42 == 4)) {
#line 479
              goto while_break___11;
            }
          } else {
#line 479
            goto while_break___11;
          }
        }
        while_break___11: /* CIL Label */ ;
        }
        __Cont: /* CIL Label */ 
#line 465
        tmp___35 = tmp___35->next;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 484
      iface = ifaces;
      {
#line 484
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 484
        if (! iface) {
#line 484
          goto while_break___12;
        }
#line 485
        if (iface->addr.s_addr == iface_addr.s_addr) {
#line 487
          iface->index = iface_index;
#line 488
          goto while_break___12;
        }
#line 484
        iface = iface->next;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 492
      if (! iface) {
        {
#line 492
        tmp___43 = malloc(sizeof(struct interface ));
#line 492
        iface = (struct interface *)tmp___43;
        }
#line 492
        if (iface) {
#line 494
          iface->next = ifaces;
#line 495
          ifaces = iface;
#line 496
          iface->addr = iface_addr;
#line 497
          iface->index = iface_index;
        }
      }
    } else
#line 500
    if ((int )packet->op == 2) {
#line 503
      if (altports) {
#line 503
        tmp___44 = 1068;
      } else {
#line 503
        tmp___44 = 68;
      }
      {
#line 503
      saddr.sin_port = htons((uint16_t )tmp___44);
#line 504
      msg.msg_control = (void *)0;
#line 505
      msg.msg_controllen = (size_t )0;
#line 506
      msg.msg_namelen = (socklen_t )sizeof(saddr);
#line 507
      iov.iov_len = (size_t )sz;
#line 510
      iface = ifaces;
      }
      {
#line 510
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 510
        if (! iface) {
#line 510
          goto while_break___13;
        }
#line 511
        if (iface->addr.s_addr == packet->giaddr.s_addr) {
#line 512
          goto while_break___13;
        }
#line 510
        iface = iface->next;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 514
      if (! iface) {
#line 515
        goto while_continue___1;
      }
#line 517
      if (packet->ciaddr.s_addr) {
#line 518
        saddr.sin_addr = packet->ciaddr;
      } else {
        {
#line 519
        tmp___47 = ntohs(packet->flags);
        }
#line 519
        if ((int )tmp___47 & 32768) {
#line 519
          goto _L___0;
        } else
#line 519
        if (! packet->yiaddr.s_addr) {
#line 519
          goto _L___0;
        } else
#line 519
        if ((int )packet->hlen > 14) {
          _L___0: /* CIL Label */ 
#line 522
          msg.msg_controllen = sizeof(control_u);
#line 523
          msg.msg_control = (void *)(control_u.control);
#line 524
          if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 524
            cmptr = (struct cmsghdr *)msg.msg_control;
          } else {
#line 524
            cmptr = (struct cmsghdr *)0;
          }
#line 525
          saddr.sin_addr.s_addr = 4294967295U;
#line 526
          pkt = (struct in_pktinfo *)(cmptr->__cmsg_data);
#line 527
          pkt->ipi_ifindex = iface->index;
#line 528
          pkt->ipi_spec_dst.s_addr = (in_addr_t )0;
#line 529
          tmp___45 = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(struct in_pktinfo );
#line 529
          cmptr->cmsg_len = tmp___45;
#line 529
          msg.msg_controllen = tmp___45;
#line 530
          cmptr->cmsg_level = 0;
#line 531
          cmptr->cmsg_type = 8;
        } else {
          {
#line 537
          saddr.sin_addr = packet->yiaddr;
#line 538
          ifr.ifr_ifru.ifru_ivalue = iface->index;
#line 539
          tmp___46 = ioctl(fd, 35088UL, & ifr);
          }
#line 539
          if (tmp___46 != -1) {
            {
#line 542
            pa = & req.arp_pa;
#line 543
            memcpy((void */* __restrict  */)pa, (void const   */* __restrict  */)(& saddr),
                   sizeof(struct sockaddr_in ));
#line 544
            req.arp_ha.sa_family = (sa_family_t )packet->htype;
#line 545
            memcpy((void */* __restrict  */)(req.arp_ha.sa_data), (void const   */* __restrict  */)(packet->chaddr),
                   (size_t )packet->hlen);
#line 546
            strncpy((char */* __restrict  */)(req.arp_dev), (char const   */* __restrict  */)(ifr.ifr_ifrn.ifrn_name),
                    (size_t )16);
#line 547
            req.arp_flags = 2;
#line 548
            ioctl(fd, 35157UL, & req);
            }
          }
        }
      }
      {
#line 552
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 552
        tmp___48 = sendmsg(fd, (struct msghdr  const  *)(& msg), 0);
        }
#line 552
        if (tmp___48 == -1L) {
          {
#line 552
          tmp___49 = __errno_location();
          }
#line 552
          if (! (*tmp___49 == 4)) {
#line 552
            goto while_break___14;
          }
        } else {
#line 552
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
