/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 154 "/usr/include/linux/fb.h"
struct fb_fix_screeninfo {
   char id[16] ;
   unsigned long smem_start ;
   __u32 smem_len ;
   __u32 type ;
   __u32 type_aux ;
   __u32 visual ;
   __u16 xpanstep ;
   __u16 ypanstep ;
   __u16 ywrapstep ;
   __u32 line_length ;
   unsigned long mmio_start ;
   __u32 mmio_len ;
   __u32 accel ;
   __u16 capabilities ;
   __u16 reserved[2] ;
};
#line 185 "/usr/include/linux/fb.h"
struct fb_bitfield {
   __u32 offset ;
   __u32 length ;
   __u32 msb_right ;
};
#line 238 "/usr/include/linux/fb.h"
struct fb_var_screeninfo {
   __u32 xres ;
   __u32 yres ;
   __u32 xres_virtual ;
   __u32 yres_virtual ;
   __u32 xoffset ;
   __u32 yoffset ;
   __u32 bits_per_pixel ;
   __u32 grayscale ;
   struct fb_bitfield red ;
   struct fb_bitfield green ;
   struct fb_bitfield blue ;
   struct fb_bitfield transp ;
   __u32 nonstd ;
   __u32 activate ;
   __u32 height ;
   __u32 width ;
   __u32 accel_flags ;
   __u32 pixclock ;
   __u32 left_margin ;
   __u32 right_margin ;
   __u32 upper_margin ;
   __u32 lower_margin ;
   __u32 hsync_len ;
   __u32 vsync_len ;
   __u32 sync ;
   __u32 vmode ;
   __u32 rotate ;
   __u32 colorspace ;
   __u32 reserved[4] ;
};
#line 278 "/usr/include/linux/fb.h"
struct fb_cmap {
   __u32 start ;
   __u32 len ;
   __u16 *red ;
   __u16 *green ;
   __u16 *blue ;
   __u16 *transp ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/fbcat-0.3/fbcat.c"
static void posix_error(char const   *s  , ...) 
{ 
  va_list argv ;

  {
  {
#line 40
  __builtin_va_start(argv, s);
#line 41
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)s, argv);
#line 42
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": ");
#line 43
  perror((char const   *)((void *)0));
#line 44
  __builtin_va_end(argv);
#line 45
  exit(2);
  }
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/fbcat-0.3/fbcat.c"
static void not_supported(char const   *s ) 
{ 


  {
  {
#line 50
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Framebuffer device is not supported: %s\nPlease file a bug at http://code.google.com/p/fbcat/issues/\n",
          s);
#line 54
  exit(3);
  }
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/fbcat-0.3/fbcat.c"
__inline static unsigned char get_color(unsigned int pixel , struct fb_bitfield  const  *bitfield ,
                                        uint16_t *colormap ) 
{ 


  {
#line 59
  return ((unsigned char )((int )*(colormap + ((pixel >> bitfield->offset) & (unsigned int )((1 << bitfield->length) - 1))) >> 8));
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/fbcat-0.3/fbcat.c"
static void dump_video_memory(unsigned char const   *video_memory , struct fb_var_screeninfo  const  *info ,
                              struct fb_cmap  const  *colormap , size_t line_length ,
                              FILE *fp ) 
{ 
  unsigned int x ;
  unsigned int y ;
  size_t bytes_per_pixel ;
  unsigned char *row ;
  void *tmp ;
  unsigned char const   *current ;
  unsigned int i ;
  unsigned int pixel ;
  size_t tmp___0 ;

  {
  {
#line 71
  bytes_per_pixel = (size_t )((info->bits_per_pixel + 7U) / 8U);
#line 72
  tmp = malloc((size_t )(info->xres * 3U));
#line 72
  row = (unsigned char *)tmp;
  }
#line 73
  if ((unsigned long )row == (unsigned long )((void *)0)) {
    {
#line 74
    posix_error("malloc failed");
    }
  }
  {
#line 76
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"P6 %u %u 255\n",
          info->xres, info->yres);
#line 77
  y = 0U;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (y < (unsigned int )info->yres)) {
#line 77
      goto while_break;
    }
#line 80
    current = (video_memory + (size_t )(y + (unsigned int )info->yoffset) * line_length) + (size_t )info->xoffset * bytes_per_pixel;
#line 81
    x = 0U;
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 81
      if (! (x < (unsigned int )info->xres)) {
#line 81
        goto while_break___0;
      }
#line 84
      pixel = 0U;
      {
#line 89
      if (bytes_per_pixel == 4UL) {
#line 89
        goto case_4;
      }
#line 93
      if (bytes_per_pixel == 2UL) {
#line 93
        goto case_2;
      }
#line 97
      goto switch_default;
      case_4: /* CIL Label */ 
#line 90
      pixel = *((uint32_t *)current);
#line 91
      current += 4;
#line 92
      goto switch_break;
      case_2: /* CIL Label */ 
#line 94
      pixel = (unsigned int )*((uint16_t *)current);
#line 95
      current += 2;
#line 96
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 98
      i = 0U;
      {
#line 98
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 98
        if (! ((size_t )i < bytes_per_pixel)) {
#line 98
          goto while_break___1;
        }
#line 100
        pixel |= (unsigned int )((int const   )*(current + 0) << i * 8U);
#line 101
        current ++;
#line 98
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 103
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 105
      *(row + x * 3U) = get_color(pixel, & info->red, (uint16_t *)colormap->red);
#line 106
      *(row + (x * 3U + 1U)) = get_color(pixel, & info->green, (uint16_t *)colormap->green);
#line 107
      *(row + (x * 3U + 2U)) = get_color(pixel, & info->blue, (uint16_t *)colormap->blue);
#line 81
      x ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 109
    tmp___0 = fwrite((void const   */* __restrict  */)row, (size_t )1, (size_t )(info->xres * 3U),
                     (FILE */* __restrict  */)fp);
    }
#line 109
    if (tmp___0 != (size_t )(info->xres * 3U)) {
      {
#line 110
      posix_error("Write error");
      }
    }
#line 77
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  free((void *)row);
  }
#line 114
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/fbcat-0.3/fbcat.c"
int main(int argc , char const   **argv ) 
{ 
  char const   *fbdev_name ;
  int fd ;
  _Bool show_usage ;
  int tmp ;
  char *tmp___0 ;
  struct fb_fix_screeninfo fix_info ;
  struct fb_var_screeninfo var_info ;
  uint16_t colormap_data[4][1 << 8] ;
  struct fb_cmap colormap ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int i ;
  int tmp___3 ;
  size_t mapped_length ;
  unsigned char *video_memory ;
  void *tmp___4 ;

  {
  {
#line 121
  show_usage = (_Bool)0;
#line 122
  tmp = isatty(1);
  }
#line 122
  if (tmp) {
    {
#line 124
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"I won\'t write binary data to a terminal.\n");
#line 125
    show_usage = (_Bool)1;
    }
  }
#line 127
  if (argc > 2) {
#line 128
    show_usage = (_Bool)1;
  }
#line 129
  if (show_usage) {
    {
#line 131
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [fbdev]\n",
            *(argv + 0));
    }
#line 132
    return (1);
  }
#line 135
  if (argc == 2) {
#line 136
    fbdev_name = *(argv + 1);
  } else {
    {
#line 139
    tmp___0 = getenv("FRAMEBUFFER");
#line 139
    fbdev_name = (char const   *)tmp___0;
    }
#line 140
    if ((unsigned long )fbdev_name == (unsigned long )((void *)0)) {
#line 141
      fbdev_name = "/dev/fb0";
    } else
#line 140
    if ((int const   )*(fbdev_name + 0) == 0) {
#line 141
      fbdev_name = "/dev/fb0";
    }
  }
  {
#line 144
  fd = open(fbdev_name, 0);
  }
#line 145
  if (fd == -1) {
    {
#line 146
    posix_error("Could not open %s", fbdev_name);
    }
  }
  {
#line 151
  colormap.start = (__u32 )0;
#line 151
  colormap.len = (__u32 )(1 << 8);
#line 151
  colormap.red = colormap_data[0];
#line 151
  colormap.green = colormap_data[1];
#line 151
  colormap.blue = colormap_data[2];
#line 151
  colormap.transp = colormap_data[3];
#line 161
  tmp___1 = ioctl(fd, 17922UL, & fix_info);
  }
#line 161
  if (tmp___1) {
    {
#line 162
    posix_error("FBIOGET_FSCREENINFO failed");
    }
  }
#line 164
  if (fix_info.type != 0U) {
    {
#line 165
    not_supported("framebuffer type is not PACKED_PIXELS");
    }
  }
  {
#line 167
  tmp___2 = ioctl(fd, 17920UL, & var_info);
  }
#line 167
  if (tmp___2) {
    {
#line 168
    posix_error("FBIOGET_VSCREENINFO failed");
    }
  }
#line 170
  if (var_info.red.length > 8U) {
    {
#line 171
    not_supported("color depth > 8 bits per component");
    }
  } else
#line 170
  if (var_info.green.length > 8U) {
    {
#line 171
    not_supported("color depth > 8 bits per component");
    }
  } else
#line 170
  if (var_info.blue.length > 8U) {
    {
#line 171
    not_supported("color depth > 8 bits per component");
    }
  }
  {
#line 175
  if (fix_info.visual == 2U) {
#line 175
    goto case_2;
  }
#line 189
  if (fix_info.visual == 5U) {
#line 189
    goto case_5;
  }
#line 189
  if (fix_info.visual == 3U) {
#line 189
    goto case_5;
  }
#line 189
  if (fix_info.visual == 4U) {
#line 189
    goto case_5;
  }
#line 193
  goto switch_default;
  case_2: /* CIL Label */ 
#line 179
  i = 0U;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < (unsigned int )(1 << var_info.red.length))) {
#line 179
      goto while_break;
    }
#line 180
    *(colormap.red + i) = (__u16 )((i * 65535U) / (unsigned int )((1 << var_info.red.length) - 1));
#line 179
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  i = 0U;
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 181
    if (! (i < (unsigned int )(1 << var_info.green.length))) {
#line 181
      goto while_break___0;
    }
#line 182
    *(colormap.green + i) = (__u16 )((i * 65535U) / (unsigned int )((1 << var_info.green.length) - 1));
#line 181
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 183
  i = 0U;
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (! (i < (unsigned int )(1 << var_info.blue.length))) {
#line 183
      goto while_break___1;
    }
#line 184
    *(colormap.blue + i) = (__u16 )((i * 65535U) / (unsigned int )((1 << var_info.blue.length) - 1));
#line 183
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 185
  goto switch_break;
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 190
  tmp___3 = ioctl(fd, 17924UL, & colormap);
  }
#line 190
  if (tmp___3 != 0) {
    {
#line 191
    posix_error("FBIOGETCMAP failed");
    }
  }
#line 192
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 194
  not_supported("unsupported visual");
  }
  switch_break: /* CIL Label */ ;
  }
#line 197
  if (var_info.bits_per_pixel < 8U) {
    {
#line 198
    not_supported("< 8 bpp");
    }
  }
  {
#line 199
  mapped_length = (size_t )(fix_info.line_length * (var_info.yres + var_info.yoffset));
#line 200
  tmp___4 = mmap((void *)0, mapped_length, 1, 1, fd, (__off_t )0);
#line 200
  video_memory = (unsigned char *)tmp___4;
  }
#line 201
  if ((unsigned long )video_memory == (unsigned long )((void *)-1)) {
    {
#line 202
    posix_error("mmap failed");
    }
  }
  {
#line 204
  dump_video_memory((unsigned char const   *)video_memory, (struct fb_var_screeninfo  const  *)(& var_info),
                    (struct fb_cmap  const  *)(& colormap), (size_t )fix_info.line_length,
                    stdout);
#line 207
  munmap((void *)video_memory, mapped_length);
#line 208
  close(fd);
  }
#line 209
  return (0);
}
}
