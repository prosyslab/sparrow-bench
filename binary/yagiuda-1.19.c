/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 71 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
struct performance_data {
   double r ;
   double x ;
   double gain ;
   double fb ;
   double swr ;
   double sidelobe ;
};
#line 73 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
struct flags {
   int aflg ;
   int bflg ;
   int cflg ;
   int dflg ;
   int eflg ;
   int errflg ;
   int fflg ;
   int gflg ;
   int hflg ;
   int iflg ;
   int jflg ;
   int kflg ;
   int lflg ;
   int mflg ;
   int nflg ;
   int oflg ;
   int pflg ;
   int qflg ;
   int rflg ;
   int sflg ;
   int tflg ;
   int uflg ;
   int vflg ;
   int wflg ;
   int xflg ;
   int yflg ;
   int zflg ;
   int Aflg ;
   int Bflg ;
   int Cflg ;
   int Dflg ;
   int Eflg ;
   int Fflg ;
   int Gflg ;
   int Hflg ;
   int Iflg ;
   int Jflg ;
   int Kflg ;
   int Lflg ;
   int Mflg ;
   int Nflg ;
   int Oflg ;
   int Pflg ;
   int Qflg ;
   int Rflg ;
   int Sflg ;
   int Tflg ;
   int Uflg ;
   int Vflg ;
   int Wflg ;
   int Xflg ;
   int Yflg ;
   int Zoflg ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/com_hack.h"
struct FCOMPLEX {
   double r ;
   double i ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
struct element_data {
   double x ;
   double y ;
   double length ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 23 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/com_hack.h"
typedef struct FCOMPLEX fcomplex;
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
struct __anonstruct_GeneRecord_27 {
   int parent1 ;
   int parent2 ;
   char *gene ;
   double fitness ;
};
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
typedef struct __anonstruct_GeneRecord_27 GeneRecord;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 80 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
struct pattern {
   double three_dB_E ;
   double three_dB_H ;
   double first_null_E ;
   double first_null_level_E ;
   double first_null_H ;
   double first_null_level_H ;
   double first_sidelobe_E ;
   double first_sidelobe_level_E ;
   double first_sidelobe_H ;
   double first_sidelobe_level_H ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log10)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 181
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
double performance(struct flags flag , struct performance_data data , struct performance_data max___0 ,
                   struct performance_data weight___0 , struct performance_data start ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/perform.c"
double Zo ;
#line 16 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/perform.c"
double performance(struct flags flag , struct performance_data data , struct performance_data max___0 ,
                   struct performance_data weight___0 , struct performance_data start ) 
{ 
  double a ;
  double x_err ;
  double fb ;
  double swr ;
  double product_of_weights ;
  struct performance_data perform ;
  double max_fb ;
  int items ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  {
#line 21
  items = 0;
#line 22
  memset((void *)((char *)(& perform)), 1, sizeof(perform));
#line 26
  product_of_weights = 1.0;
#line 27
  weight___0.sidelobe /= 100.0;
  }
#line 30
  if (weight___0.gain != 0.0) {
#line 31
    product_of_weights = weight___0.gain;
  }
#line 32
  if (weight___0.fb != 0.0) {
#line 33
    product_of_weights *= weight___0.fb;
  }
#line 34
  if (weight___0.r != 0.0) {
#line 35
    product_of_weights *= weight___0.r;
  }
#line 36
  if (weight___0.x != 0.0) {
#line 37
    product_of_weights *= weight___0.x;
  }
#line 38
  if (weight___0.swr != 0.0) {
#line 39
    product_of_weights *= weight___0.swr;
  }
#line 40
  if (weight___0.sidelobe != 0.0) {
#line 41
    product_of_weights *= weight___0.sidelobe;
  }
#line 42
  if ((flag.Wflg & 1) == 1) {
#line 42
    goto _L;
  } else
#line 42
  if ((flag.gflg & 1) == 1) {
    _L: /* CIL Label */ 
#line 50
    perform.gain = (weight___0.gain * (data.gain - (double )5)) / (max___0.gain - (double )5);
#line 52
    if (perform.gain < (double )0) {
#line 53
      perform.gain = 0.0;
    }
#line 54
    items ++;
  }
#line 56
  if ((flag.Wflg & 2) == 2) {
#line 56
    goto _L___0;
  } else
#line 56
  if ((flag.gflg & 2) == 2) {
    _L___0: /* CIL Label */ 
    {
#line 58
    fb = pow(10.0, data.fb / 10.0);
#line 59
    max_fb = pow(10.0, max___0.fb / 10.0);
    }
#line 60
    if ((fb > max_fb) & ! flag.Oflg) {
#line 61
      fb = max_fb;
    }
#line 62
    perform.fb = (weight___0.fb * fb) / max_fb;
#line 63
    items ++;
  }
#line 65
  if ((flag.Wflg & 4) == 4) {
#line 65
    goto _L___1;
  } else
#line 65
  if ((flag.gflg & 4) == 4) {
    _L___1: /* CIL Label */ 
    {
#line 67
    tmp = fabs(Zo - data.r);
#line 67
    tmp___0 = pow(tmp / Zo, 0.25);
#line 67
    perform.r = (double )1 - tmp___0;
    }
#line 68
    if (data.r < 0.7 * Zo) {
#line 69
      perform.r /= 10.0;
    } else
#line 68
    if (data.r > 1.4 * Zo) {
#line 69
      perform.r /= 10.0;
    }
#line 70
    items ++;
  }
#line 72
  if ((flag.Wflg & 8) == 8) {
#line 72
    goto _L___2;
  } else
#line 72
  if ((flag.gflg & 8) == 8) {
    _L___2: /* CIL Label */ 
    {
#line 74
    tmp___1 = fabs(data.x);
#line 74
    x_err = tmp___1 / Zo;
    }
#line 75
    if (x_err > 1.0) {
#line 76
      x_err = 1.0;
    }
    {
#line 77
    tmp___2 = pow(x_err, 0.28);
#line 77
    perform.x = (double )1 - tmp___2;
#line 78
    items ++;
    }
  }
#line 80
  if ((flag.Wflg & 16) == 16) {
    {
#line 82
    swr = data.swr;
#line 103
    tmp___3 = log10(swr);
#line 103
    perform.swr = 1.0 - tmp___3;
#line 110
    items ++;
    }
  } else
#line 80
  if ((flag.gflg & 16) == 16) {
    {
#line 82
    swr = data.swr;
#line 103
    tmp___3 = log10(swr);
#line 103
    perform.swr = 1.0 - tmp___3;
#line 110
    items ++;
    }
  }
#line 112
  if ((flag.Wflg & 32) == 32) {
#line 119
    perform.sidelobe = (weight___0.sidelobe * data.sidelobe) / max___0.sidelobe;
#line 120
    items ++;
  } else
#line 112
  if ((flag.gflg & 32) == 32) {
#line 119
    perform.sidelobe = (weight___0.sidelobe * data.sidelobe) / max___0.sidelobe;
#line 120
    items ++;
  }
#line 123
  a = (((((perform.gain + perform.fb) + perform.r) + perform.x) + perform.swr) + perform.sidelobe) / (double )items;
#line 131
  return (a);
}
}
#line 63 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 109
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nr_hack.h"
void cisi(double x , double *ci___0 , double *si ) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
double ci(double x ) ;
#line 198
void self(double r , double length___0 , double lambda___0 , double *Rin , double *Xin ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/self2.c"
void self(double r , double length___0 , double lambda___0 , double *Rin , double *Xin ) 
{ 
  double beta ;
  double mu ;
  double epsilon ;
  double eta ;
  double sin_bl ;
  double cos_bl ;
  double current_scale_factor ;
  double bl ;
  double ci_bl ;
  double si_bl ;
  double ci_2bl ;
  double si_2bl ;
  double Xm ;
  double Rr ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  {
#line 27
  beta = ((double )2 * 3.14159265358979323846) / lambda___0;
#line 28
  mu = ((double )4 * 3.14159265358979323846) * 1e-7;
#line 29
  epsilon = 8.854187818e-12;
#line 30
  eta = sqrt(mu / epsilon);
#line 31
  bl = beta * length___0;
#line 38
  cisi(bl, & ci_bl, & si_bl);
#line 39
  cisi((double )2 * bl, & ci_2bl, & si_2bl);
#line 40
  sin_bl = sin(bl);
#line 41
  cos_bl = cos(bl);
#line 43
  tmp = ci(((((double )2 * beta) * r) * r) / length___0);
#line 43
  Xm = (eta / ((double )4 * 3.14159265358979323846)) * (((double )2 * si_bl + cos_bl * ((double )2 * si_bl - si_2bl)) - sin_bl * (((double )2 * ci_bl - ci_2bl) - tmp));
#line 46
  tmp___0 = sin(bl / (double )2);
#line 46
  tmp___1 = sin(bl / (double )2);
#line 46
  current_scale_factor = tmp___0 * tmp___1;
#line 47
  *Xin = Xm / current_scale_factor;
#line 54
  tmp___2 = log(bl);
#line 54
  tmp___3 = log(bl / 2.0);
#line 54
  Rr = (eta / (2.0 * 3.14159265358979323846)) * ((((0.57721566 + tmp___2) - ci_bl) + (0.5 * sin_bl) * (si_2bl - 2.0 * si_bl)) + (0.5 * cos_bl) * (((0.57721566 + tmp___3) + ci_2bl) - (double )2 * ci_bl));
#line 55
  *Rin = Rr / current_scale_factor;
  }
#line 70
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void set_performance_structures(struct performance_data *weight___0 , struct performance_data *max___0 ,
                                struct performance_data *best , struct performance_data *worst ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/set_performance_structures.c"
void set_performance_structures(struct performance_data *weight___0 , struct performance_data *max___0 ,
                                struct performance_data *best , struct performance_data *worst ) 
{ 


  {
#line 11
  weight___0->swr = 1.0;
#line 12
  weight___0->fb = 1.0;
#line 13
  weight___0->sidelobe = 1.0;
#line 14
  weight___0->gain = 1.0;
#line 16
  max___0->fb = (double )27;
#line 17
  max___0->swr = 1.1;
#line 18
  max___0->r = (double )5;
#line 19
  max___0->x = (double )5;
#line 20
  max___0->sidelobe = (double )23;
#line 22
  best->swr = 99.0;
#line 23
  best->gain = - 1000.0;
#line 24
  best->fb = - 1000.0;
#line 25
  best->r = 1000.0;
#line 26
  best->x = 1e19;
#line 27
  best->sidelobe = - 1000.0;
#line 29
  worst->gain = 1000.0;
#line 30
  worst->sidelobe = 1000.0;
#line 31
  worst->fb = 1000.0;
#line 32
  worst->swr = 1.00;
#line 34
  return;
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 108 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
char *string(long nl , long nh ) ;
#line 109
void free_string(char *v , long nl , long nh ) ;
#line 111
void read_yagi_data(char *one_line , char *input_filename , double *frequency , double *min_frequency ,
                    double *max_frequency , double *step_frequency , int driven ,
                    double **d , int parasitic , double **p , double *angular_step ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/read_yagi_data.c"
void read_yagi_data(char *one_line , char *input_filename , double *frequency , double *min_frequency ,
                    double *max_frequency , double *step_frequency , int driven ,
                    double **d , int parasitic , double **p , double *angular_step ) 
{ 
  FILE *ifp ;
  char *null ;
  char *tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 14
  null = string(0L, 100L);
#line 16
  tmp = string(0L, 100L);
#line 17
  ifp = fopen((char const   */* __restrict  */)input_filename, (char const   */* __restrict  */)"rt");
  }
#line 18
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
    {
#line 20
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry, cant find file:  %s\n",
            input_filename);
#line 21
    exit(2);
    }
  }
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 24
    tmp___7 = feof(ifp);
    }
#line 24
    if (tmp___7) {
#line 24
      goto while_break;
    }
    {
#line 26
    fgets((char */* __restrict  */)one_line, 99, (FILE */* __restrict  */)ifp);
#line 28
    tmp___0 = strncmp((char const   *)one_line, "STEP_FREQUENCY", (size_t )14);
    }
#line 28
    if (tmp___0 == 0) {
      {
#line 30
      sscanf((char const   */* __restrict  */)one_line, (char const   */* __restrict  */)"%s %lf",
             null, step_frequency);
#line 31
      *step_frequency *= 1e6;
      }
    }
    {
#line 33
    tmp___1 = strncmp((char const   *)one_line, "MIN_FREQUENCY", (size_t )13);
    }
#line 33
    if (tmp___1 == 0) {
      {
#line 35
      sscanf((char const   */* __restrict  */)one_line, (char const   */* __restrict  */)"%s %lf",
             null, min_frequency);
#line 36
      *min_frequency *= 1e6;
      }
    }
    {
#line 38
    tmp___2 = strncmp((char const   *)one_line, "MAX_FREQUENCY", (size_t )13);
    }
#line 38
    if (tmp___2 == 0) {
      {
#line 40
      sscanf((char const   */* __restrict  */)one_line, (char const   */* __restrict  */)"%s %lf",
             null, max_frequency);
#line 41
      *max_frequency *= 1e6;
      }
    }
    {
#line 43
    tmp___3 = strncmp((char const   *)one_line, "ANGULAR_STEP", (size_t )12);
    }
#line 43
    if (tmp___3 == 0) {
      {
#line 45
      sscanf((char const   */* __restrict  */)one_line, (char const   */* __restrict  */)"%s %lf",
             null, angular_step);
      }
    }
    {
#line 47
    tmp___4 = strncmp((char const   *)one_line, "FREQUENCY", (size_t )9);
    }
#line 47
    if (tmp___4 == 0) {
      {
#line 49
      sscanf((char const   */* __restrict  */)one_line, (char const   */* __restrict  */)"%s %lf",
             null, frequency);
#line 50
      *frequency *= 1e6;
      }
    }
    {
#line 52
    tmp___5 = strncmp((char const   *)one_line, "DATA_PARASITIC", (size_t )14);
    }
#line 52
    if (tmp___5 == 0) {
#line 54
      one_line += 14;
#line 55
      i = 1;
      {
#line 55
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 55
        if (! (i <= parasitic)) {
#line 55
          goto while_break___0;
        }
        {
#line 57
        fgets((char */* __restrict  */)one_line, 99, (FILE */* __restrict  */)ifp);
#line 58
        sscanf((char const   */* __restrict  */)one_line, (char const   */* __restrict  */)"\n%lf %lf %lf %lf",
               *(p + i) + 1, *(p + i) + 2, *(p + i) + 3, *(p + i) + 4);
#line 55
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 61
    tmp___6 = strncmp((char const   *)one_line, "DATA_DRIVEN", (size_t )11);
    }
#line 61
    if (tmp___6 == 0) {
#line 63
      one_line += 11;
#line 64
      i = 1;
      {
#line 64
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 64
        if (! (i <= driven)) {
#line 64
          goto while_break___1;
        }
        {
#line 65
        sscanf((char const   */* __restrict  */)one_line, (char const   */* __restrict  */)"%lf %lf %lf %lf %lf %lf\n",
               *(d + i) + 1, *(d + i) + 2, *(d + i) + 3, *(d + i) + 4, *(d + i) + 5,
               *(d + i) + 6);
#line 64
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  fclose(ifp);
  }
#line 69
  if (*min_frequency > *max_frequency) {
    {
#line 71
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in input file %s. Please check:\n",
            input_filename);
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FREQUENCY, MIN_FREQUENCY, MAX_FREQUENCY, STEP_FREQUENCY and ANGULAR_STEP\n");
#line 73
    exit(1);
    }
  } else
#line 69
  if (*angular_step <= (double )0) {
    {
#line 71
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in input file %s. Please check:\n",
            input_filename);
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FREQUENCY, MIN_FREQUENCY, MAX_FREQUENCY, STEP_FREQUENCY and ANGULAR_STEP\n");
#line 73
    exit(1);
    }
  } else
#line 69
  if (*step_frequency <= 0.0) {
    {
#line 71
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in input file %s. Please check:\n",
            input_filename);
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FREQUENCY, MIN_FREQUENCY, MAX_FREQUENCY, STEP_FREQUENCY and ANGULAR_STEP\n");
#line 73
    exit(1);
    }
  } else
#line 69
  if (*frequency <= 0.0) {
    {
#line 71
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in input file %s. Please check:\n",
            input_filename);
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FREQUENCY, MIN_FREQUENCY, MAX_FREQUENCY, STEP_FREQUENCY and ANGULAR_STEP\n");
#line 73
    exit(1);
    }
  }
  {
#line 76
  free_string(null, 0L, 100L);
#line 77
  free_string(tmp, 0L, 100L);
  }
#line 78
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
double calculate_vswr(double magnitude___0 ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/vswr.c"
double calculate_vswr(double magnitude___0 ) 
{ 
  double swr ;

  {
#line 16
  if (magnitude___0 > 0.98) {
#line 17
    magnitude___0 = 0.98;
  }
#line 18
  swr = ((double )1 + magnitude___0) / ((double )1 - magnitude___0);
#line 26
  return (swr);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.h"
int *ivector(long nl , long nh ) ;
#line 51
double *dvector(long nl , long nh ) ;
#line 53
double **dmatrix(long nrl , long nrh , long ncl , long nch ) ;
#line 60
void free_ivector(int *v , long nl , long nh ) ;
#line 63
void free_dvector(double *v , long nl , long nh ) ;
#line 65
void free_dmatrix(double **m , long nrl , long nrh , long ncl , long nch ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
int main(int argc , char **argv ) ;
#line 88
int linear_current_optimisation_test(struct FCOMPLEX *cur , double *old_sd , int elements___0 ,
                                     int parasites , struct flags flag ) ;
#line 90
void dynamic_changing_of_weights(int i , int divisor , struct performance_data *weight___0 ) ;
#line 94
void end_if_stop_exists(int *i , int iterations___0 , int divisor ) ;
#line 95
struct performance_data subtract_structures(struct performance_data a , struct performance_data b ) ;
#line 96
void print_relavent_performance_data(FILE *fp , char *s , int i , struct flags flag ,
                                     struct performance_data data , double fitness ,
                                     int Z_Q , int fitness_Q ) ;
#line 99
void set_mean_structure(struct FCOMPLEX input_impedance , double E_fwd , double E_back ,
                        struct flags flag , double pin___0 , struct element_data *coordinates___0 ,
                        struct FCOMPLEX *current___0 , int elements___0 , double frequency ,
                        double design_frequency , struct performance_data *mean_performance ) ;
#line 100
void test_for_stop_file(void) ;
#line 102
void optimising_for(struct flags flag ) ;
#line 106
void copy_matrix(int length___0 , int width , double **to , double **from ) ;
#line 110
int get_number_of_elements(char *input_filename , int *driven , int *parasitic ) ;
#line 130
void gain(double theta , double phi , double pin___0 , double F , struct element_data *coordinates___0 ,
          struct FCOMPLEX *current___0 , int elements___0 , double *gain_E_plane___0 ,
          double *gain_H_plane___0 , double actual_frequency , double design_frequency ) ;
#line 135
void free_FCOMPLEXvector(struct FCOMPLEX *v , long nl , long nh ) ;
#line 136
void free_element_data_vector(struct element_data *v , long nl , long nh ) ;
#line 137
double change_max_percentage_changes(int i , int iterations___0 , double original_percent___0 ) ;
#line 138
struct FCOMPLEX *FCOMPLEXvector(long nl , long nh ) ;
#line 139
struct element_data *element_data_vector(long nl , long nh ) ;
#line 144
void randomise(int randomisation_method , double frequency , double max_percent ,
               double **driven_data , double **parasitic_data , int driven , int parasites ) ;
#line 145
void automatic_enhancement(struct flags flag , double frequency , double **driven_data ,
                           double **parasitic_data , int driven , int parasites ,
                           struct FCOMPLEX *voltage , struct FCOMPLEX *current___0 ,
                           struct FCOMPLEX *input_impedance , double *v , double **z ,
                           double **A , double *b , int *indx , struct element_data *coordinates___0 ) ;
#line 148
int is_it_better(int criteria , struct performance_data n , struct performance_data o ) ;
#line 150
void get_command_line_options(int argc , char **argv , struct flags *flag ) ;
#line 167
void solve_equations(double frequency , int driven , int parasitic , double **driven_data ,
                     double **parasitic_data , double *v , double **z , double *pin___0 ,
                     struct FCOMPLEX *voltage , struct FCOMPLEX *current___0 , struct FCOMPLEX *input_impedance ,
                     struct element_data *coordinates___0 , double **A , double *b ,
                     int *indx ) ;
#line 168
void genetic_algorithm(char *output_filename , char *update_filename , struct flags flag ,
                       double design_frequency , double min_frequency , double max_frequency ,
                       double step_frequency , double angular_step , int driven ,
                       int parasitic , double **data_driven , double **data_parasitic ,
                       double *v , double **z , double *pin___0 , struct FCOMPLEX *voltage ,
                       struct FCOMPLEX *current___0 , struct FCOMPLEX *input_impedance ,
                       struct element_data *coordinates___0 , double **A , double *b ,
                       int *indx , struct performance_data *mean_performance ) ;
#line 175
void check_flags(struct flags flag , int argc , int optind___0 , char *exefilename ) ;
#line 178
double determine_maximum_gain2(int elements___0 ) ;
#line 181
void do_since_better(int i , char *output_filename , char *update_filename , struct FCOMPLEX input_impedance ,
                     struct performance_data n , struct flags flag , char *notes ,
                     double frequency , double min_frequency , double max_frequency ,
                     double step_frequency , int elements___0 , int driven , int parasitic ,
                     double angular_step , double **driven_data , double **parasitic_data ,
                     double scale_factor , double new_perf ) ;
#line 183
void sensitivity(double boom_sd___0 , double length_sd___0 , double **driven_data ,
                 double **parasitic_data , int driven , int parasites ) ;
#line 186
void seedRNG(void) ;
#line 2 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
int optind ;
#line 2
int opterr ;
#line 4 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
double original_percent  =    (double )10;
#line 5 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
double percent  ;
#line 6 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
double magnitude  ;
#line 6 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
double phase  ;
#line 7 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
double Zo  =    (double )50;
#line 8 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
struct performance_data weight  ;
#line 8 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
struct performance_data max  ;
#line 9 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
double max_gain  =    (double )1;
#line 9 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
double boom_factor  =    (double )1000;
#line 9 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
double diameter  ;
#line 9 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
double best_perf  ;
#line 10 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
int popsize  =    0;
#line 11 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
int iterations  ;
#line 11 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
int fitness_method  =    0;
#line 12 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
double vswr  =    1.0;
#line 13 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
double boom_sd  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
double length_sd  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
int K_times  =    1;
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/globals.h"
int K_times_max  =    10;
#line 15 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/optimise.c"
int main(int argc , char **argv ) 
{ 
  FILE *fp ;
  FILE *update_fp ;
  FILE *fp_out ;
  char *input_filename ;
  char notes[1000] ;
  char *output_filename ;
  char *update_filename ;
  char *line ;
  char *ofile ;
  int elements___0 ;
  int driven ;
  int parasitic ;
  int ii ;
  int *indx ;
  int i ;
  int better ;
  double **A ;
  double *x ;
  double *v ;
  double *b ;
  double **z ;
  double pin___0 ;
  double old_perf ;
  double new_perf ;
  double **driven_data ;
  double **parasitic_data ;
  double angular_step ;
  double scale_factor ;
  double **driven_data_tmp ;
  double **parasitic_data_tmp ;
  double **driven_data_global_best ;
  double **parasitic_data_global_best ;
  double design_frequency ;
  double min_frequency ;
  double max_frequency ;
  double step_frequency ;
  double E_fwd ;
  double E_back ;
  double H_fwd ;
  double H_back ;
  double frequency ;
  double old_SD_of_currents ;
  struct flags flag ;
  struct FCOMPLEX *voltage ;
  struct FCOMPLEX *current___0 ;
  struct FCOMPLEX input_impedance ;
  struct FCOMPLEX z_centre ;
  struct element_data *coordinates___0 ;
  struct performance_data mean ;
  struct performance_data best_performance ;
  struct performance_data start ;
  struct performance_data changes ;
  struct performance_data worst ;
  int *tmp ;

  {
  {
#line 23
  better = 0;
#line 24
  old_perf = - 10000.0;
#line 24
  new_perf = - 1000.0;
#line 25
  scale_factor = 1.0;
#line 29
  old_SD_of_currents = 1e100;
#line 37
  memset((void *)((char *)(& flag)), 0, sizeof(flag));
#line 39
  set_performance_structures(& weight, & max, & best_performance, & worst);
#line 40
  opterr = 0;
#line 41
  ofile = string(0L, 100L);
#line 45
  test_for_stop_file();
#line 46
  get_command_line_options(argc, argv, & flag);
  }
#line 47
  if (! flag.Tflg) {
#line 47
    if (! flag.tflg) {
      {
#line 48
      optimising_for(flag);
      }
    }
  }
  {
#line 51
  check_flags(flag, argc, optind, *(argv + 0));
#line 53
  flag.eflg = 31;
#line 54
  flag.oflg = 32805;
#line 55
  iterations = atoi((char const   *)*(argv + (optind + 1)));
  }
#line 56
  if (flag.Aflg) {
#line 57
    iterations = 2;
  }
  {
#line 59
  input_filename = string(0L, 100L);
#line 60
  line = string(0L, 100L);
#line 61
  output_filename = string(0L, 100L);
#line 62
  update_filename = string(0L, 100L);
#line 63
  seedRNG();
#line 66
  strcpy((char */* __restrict  */)update_filename, (char const   */* __restrict  */)*(argv + optind));
#line 67
  strcat((char */* __restrict  */)update_filename, (char const   */* __restrict  */)".up");
#line 68
  update_fp = fopen((char const   */* __restrict  */)update_filename, (char const   */* __restrict  */)"wt");
#line 69
  fclose(update_fp);
#line 70
  strcpy((char */* __restrict  */)input_filename, (char const   */* __restrict  */)*(argv + optind));
#line 71
  fp = fopen((char const   */* __restrict  */)input_filename, (char const   */* __restrict  */)"rt");
  }
#line 72
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cant open %s\n",
            input_filename);
#line 75
    exit(10);
    }
  } else {
    {
#line 78
    fclose(fp);
    }
  }
  {
#line 79
  strcpy((char */* __restrict  */)output_filename, (char const   */* __restrict  */)input_filename);
#line 80
  strcat((char */* __restrict  */)output_filename, (char const   */* __restrict  */)".bes");
#line 81
  fp_out = fopen((char const   */* __restrict  */)output_filename, (char const   */* __restrict  */)"wb");
#line 82
  fclose(fp_out);
#line 87
  elements___0 = get_number_of_elements(input_filename, & driven, & parasitic);
#line 89
  driven_data = dmatrix(1L, (long )driven, 1L, 6L);
#line 90
  parasitic_data = dmatrix(1L, (long )parasitic, 1L, 4L);
#line 91
  driven_data_global_best = dmatrix(1L, (long )driven, 1L, 6L);
#line 92
  parasitic_data_global_best = dmatrix(1L, (long )parasitic, 1L, 4L);
#line 93
  driven_data_tmp = dmatrix(1L, (long )driven, 1L, 6L);
#line 94
  parasitic_data_tmp = dmatrix(1L, (long )parasitic, 1L, 4L);
#line 95
  z = dmatrix(1L, (long )elements___0, 1L, (long )elements___0 * 2L);
#line 96
  A = dmatrix(1L, 2L * (long )elements___0, 1L, 2L * (long )elements___0);
#line 97
  x = dvector(1L, 2L * (long )elements___0);
#line 98
  b = dvector(1L, 2L * (long )elements___0);
#line 100
  current___0 = FCOMPLEXvector(1L, (long )elements___0);
#line 101
  voltage = FCOMPLEXvector(1L, (long )elements___0);
#line 103
  coordinates___0 = element_data_vector(1L, (long )elements___0);
#line 104
  v = dvector(1L, 2L * (long )elements___0);
#line 105
  indx = ivector(1L, 2L * (long )elements___0);
#line 107
  read_yagi_data(line, input_filename, & design_frequency, & min_frequency, & max_frequency,
                 & step_frequency, driven, driven_data, parasitic, parasitic_data,
                 & angular_step);
#line 111
  tmp = __errno_location();
#line 111
  *tmp = 0;
#line 113
  copy_matrix(driven, 6, driven_data_global_best, driven_data);
#line 114
  copy_matrix(parasitic, 4, parasitic_data_global_best, parasitic_data);
#line 116
  copy_matrix(driven, 6, driven_data_tmp, driven_data);
#line 117
  copy_matrix(parasitic, 4, parasitic_data_tmp, parasitic_data);
#line 119
  max.gain = determine_maximum_gain2(elements___0);
  }
#line 120
  if (flag.Kflg == 0) {
#line 121
    K_times_max = 1;
  }
#line 124
  if (flag.gflg) {
    {
#line 126
    genetic_algorithm(output_filename, update_filename, flag, design_frequency, min_frequency,
                      max_frequency, step_frequency, angular_step, driven, parasitic,
                      driven_data, parasitic_data, v, z, & pin___0, voltage, current___0,
                      & input_impedance, coordinates___0, A, b, indx, & mean);
#line 131
    printf((char const   */* __restrict  */)"The best design is in a file \"%s\". You should check it thoroughly\n",
           output_filename);
#line 132
    printf((char const   */* __restrict  */)"and if its better than %s, copy %s to %s\n",
           input_filename, output_filename, input_filename);
#line 134
    exit(0);
    }
  }
#line 136
  if (flag.wflg) {
    {
#line 137
    sprintf((char */* __restrict  */)(notes), (char const   */* __restrict  */)"This has been run through optimise and optimised for \t\t wide-band use over the frequency range %.3f MHz to %.3fMHz. \n",
            min_frequency / 1e6, max_frequency / 1e6);
    }
  }
#line 140
  i = 1;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i <= iterations)) {
#line 140
      goto while_break;
    }
    {
#line 142
    percent = change_max_percentage_changes(i, iterations, original_percent);
#line 146
    ii = -1;
    }
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 146
      if (! (ii < flag.wflg)) {
#line 146
        goto while_break___0;
      }
#line 148
      if (ii == -1) {
        {
#line 150
        frequency = design_frequency;
#line 152
        memset((void *)((char *)(& mean)), 0, sizeof(mean));
        }
      }
#line 154
      if (ii == 0) {
#line 155
        frequency = min_frequency;
      }
#line 156
      if (ii == 1) {
#line 157
        frequency = max_frequency;
      }
      {
#line 158
      solve_equations(frequency, driven, parasitic, driven_data, parasitic_data, v,
                      z, & pin___0, voltage, current___0, & input_impedance, coordinates___0,
                      A, b, indx);
      }
#line 159
      if (ii == -1) {
#line 160
        z_centre = input_impedance;
      }
      {
#line 162
      gain((double )90, (double )0, pin___0, frequency / design_frequency, coordinates___0,
           current___0, elements___0, & E_fwd, & H_fwd, frequency, design_frequency);
#line 164
      gain((double )270, (double )0, pin___0, frequency / design_frequency, coordinates___0,
           current___0, elements___0, & E_back, & H_back, frequency, design_frequency);
#line 167
      set_mean_structure(input_impedance, E_fwd, E_back, flag, pin___0, coordinates___0,
                         current___0, elements___0, frequency, design_frequency, & mean);
      }
#line 169
      if (i == 1) {
#line 170
        start = mean;
      }
#line 146
      ii ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 172
    if (flag.wflg) {
#line 174
      mean.gain /= 3.0;
#line 174
      mean.fb /= 3.0;
#line 174
      mean.swr /= 3.0;
    }
#line 176
    if (flag.Wflg) {
#line 176
      goto _L;
    } else
#line 176
    if (flag.gflg) {
      _L: /* CIL Label */ 
      {
#line 178
      old_perf = performance(flag, best_performance, max, weight, start);
#line 179
      new_perf = performance(flag, mean, max, weight, start);
      }
#line 180
      if (new_perf > old_perf) {
#line 181
        better = 1;
      } else {
#line 183
        better = 0;
      }
#line 184
      if (better == 1) {
#line 184
        if (flag.Cflg) {
          {
#line 185
          better = linear_current_optimisation_test(current___0, & old_SD_of_currents,
                                                    elements___0, parasitic, flag);
          }
        }
      }
    } else
#line 187
    if (flag.Aflg) {
#line 188
      better = 1;
    } else {
      {
#line 191
      better = is_it_better(flag.oflg, mean, best_performance);
      }
#line 192
      if (better == 1) {
#line 192
        if (flag.Cflg) {
          {
#line 193
          better = linear_current_optimisation_test(current___0, & old_SD_of_currents,
                                                    elements___0, parasitic, flag);
          }
        }
      }
    }
#line 195
    if (better == 1) {
#line 195
      if (! flag.Tflg) {
        {
#line 205
        do_since_better(i, output_filename, update_filename, z_centre, mean, flag,
                        notes, design_frequency, min_frequency, max_frequency, step_frequency,
                        elements___0, driven, parasitic, angular_step, driven_data,
                        parasitic_data, scale_factor, new_perf);
#line 211
        best_performance = mean;
#line 215
        copy_matrix(driven, 6, driven_data_global_best, driven_data);
#line 216
        copy_matrix(parasitic, 4, parasitic_data_global_best, parasitic_data);
#line 217
        K_times = 0;
        }
      } else {
#line 195
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 219
    if (better == 0) {
#line 219
      goto _L___0;
    } else
#line 219
    if (flag.Tflg) {
      _L___0: /* CIL Label */ 
#line 222
      K_times ++;
#line 223
      if (K_times < K_times_max) {
        {
#line 226
        copy_matrix(driven, 6, driven_data, driven_data_tmp);
#line 227
        copy_matrix(parasitic, 4, parasitic_data, parasitic_data_tmp);
        }
      } else {
        {
#line 233
        copy_matrix(driven, 6, driven_data, driven_data_global_best);
#line 234
        copy_matrix(parasitic, 4, parasitic_data, parasitic_data_global_best);
#line 235
        copy_matrix(driven, 6, driven_data_tmp, driven_data);
#line 236
        copy_matrix(parasitic, 4, parasitic_data_tmp, parasitic_data);
#line 237
        K_times = 0;
        }
      }
#line 239
      if (flag.Tflg) {
#line 241
        if (mean.gain < worst.gain) {
#line 242
          worst.gain = mean.gain;
        }
#line 243
        if (mean.fb < worst.fb) {
#line 244
          worst.fb = mean.fb;
        }
#line 245
        if (mean.swr > worst.swr) {
#line 246
          worst.swr = mean.swr;
        }
#line 247
        if (mean.sidelobe < worst.sidelobe) {
#line 248
          worst.sidelobe = mean.sidelobe;
        }
      }
    }
    {
#line 256
    end_if_stop_exists(& i, iterations, 100);
#line 257
    dynamic_changing_of_weights(i, 1, & weight);
    }
#line 258
    if (! flag.Tflg) {
#line 258
      if (! flag.Aflg) {
        {
#line 259
        randomise(flag.eflg, design_frequency / 1e6, percent, driven_data, parasitic_data,
                  driven, parasitic);
        }
      } else {
#line 258
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 260
    if (flag.Aflg) {
      {
#line 261
      automatic_enhancement(flag, design_frequency, driven_data, parasitic_data, driven,
                            parasitic, voltage, current___0, & input_impedance, v,
                            z, A, b, indx, coordinates___0);
      }
    } else
#line 262
    if (flag.Tflg) {
      {
#line 263
      sensitivity(boom_sd, length_sd, driven_data, parasitic_data, driven, parasitic);
      }
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  if (! flag.Tflg) {
    {
#line 268
    printf((char const   */* __restrict  */)"The best design is in a file \"%s\". You should check it thoroughly\n",
           output_filename);
#line 269
    printf((char const   */* __restrict  */)"and if its better than %s, copy %s to %s\n",
           input_filename, output_filename, input_filename);
#line 270
    printf((char const   */* __restrict  */)"For your information, the original data on the antenna was:\n");
#line 271
    print_relavent_performance_data(stdout, (char *)"Start data:", 0, flag, start,
                                    0.0, 0, 0);
#line 272
    print_relavent_performance_data(stdout, (char *)"Final data:", 0, flag, best_performance,
                                    0.0, 0, 0);
#line 273
    changes = subtract_structures(best_performance, start);
#line 274
    print_relavent_performance_data(stdout, (char *)"Changes:   ", 0, flag, changes,
                                    0.0, 0, 0);
    }
  } else
#line 276
  if (flag.Tflg) {
    {
#line 278
    printf((char const   */* __restrict  */)"For your inforation, the original data on the antenna was:\n");
#line 279
    print_relavent_performance_data(stdout, (char *)"Start data:", 0, flag, start,
                                    0.0, 0, 0);
#line 280
    print_relavent_performance_data(stdout, (char *)"Worst data:", 0, flag, worst,
                                    0.0, 0, 0);
#line 281
    changes = subtract_structures(worst, start);
#line 282
    print_relavent_performance_data(stdout, (char *)"Changes:   ", 0, flag, changes,
                                    0.0, 0, 0);
#line 283
    printf((char const   */* __restrict  */)"\nTolerance parameters were: Length_SD(t)=%.3fmm Boom_SD(T) = %.3fmm\n",
           length_sd, boom_sd);
    }
  }
  {
#line 287
  free_string(input_filename, 0L, 100L);
#line 288
  free_string(line, 0L, 100L);
#line 289
  free_string(update_filename, 0L, 100L);
#line 290
  free_string(output_filename, 0L, 100L);
#line 291
  free_string(ofile, 0L, 100L);
#line 293
  free_dvector(x, 1L, 2L * (long )elements___0);
#line 294
  free_dvector(b, 1L, 2L * (long )elements___0);
#line 295
  free_dvector(v, 1L, 2L * (long )elements___0);
#line 296
  free_ivector(indx, 1L, 2L * (long )elements___0);
#line 298
  free_dmatrix(z, 1L, (long )elements___0, 1L, (long )elements___0 * 2L);
#line 299
  free_dmatrix(A, 1L, 2L * (long )elements___0, 1L, 2L * (long )elements___0);
#line 300
  free_dmatrix(driven_data, 1L, (long )driven, 1L, 6L);
#line 301
  free_dmatrix(parasitic_data, 1L, (long )parasitic, 1L, 4L);
#line 302
  free_dmatrix(parasitic_data_global_best, 1L, (long )parasitic, 1L, 4L);
#line 303
  free_dmatrix(driven_data_global_best, 1L, (long )parasitic, 1L, 6L);
#line 304
  free_dmatrix(driven_data_tmp, 1L, (long )driven, 1L, 6L);
#line 305
  free_dmatrix(parasitic_data_tmp, 1L, (long )parasitic, 1L, 4L);
#line 307
  free_FCOMPLEXvector(current___0, 1L, (long )elements___0);
#line 308
  free_FCOMPLEXvector(voltage, 1L, (long )elements___0);
#line 309
  free_element_data_vector(coordinates___0, 1L, (long )elements___0);
#line 310
  exit(0);
  }
}
}
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 717
extern int system(char const   *__command ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 431
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
#line 638
extern char *gets(char *__s )  __attribute__((__deprecated__)) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/dynamic.c"
void dynamic_changing_of_weights(int i , int divisor , struct performance_data *weight___0 ) 
{ 
  char c ;
  char *str ;
  int tmp ;
  FILE *tmp___0 ;

  {
#line 14
  if (i % divisor == 0) {
    {
#line 16
    str = string(0L, 100L);
#line 17
    tmp___0 = fopen((char const   */* __restrict  */)"change", (char const   */* __restrict  */)"rt");
    }
#line 17
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {
#line 19
      system("rm change");
#line 20
      printf((char const   */* __restrict  */)"Enter a letter - G, F, P, R, S or X\n");
#line 21
      tmp = _IO_getc(stdin);
#line 21
      c = (char )tmp;
      }
      {
#line 24
      if ((int )c == 71) {
#line 24
        goto case_71;
      }
#line 31
      if ((int )c == 70) {
#line 31
        goto case_70;
      }
#line 37
      if ((int )c == 80) {
#line 37
        goto case_80;
      }
#line 22
      goto switch_break;
      case_71: /* CIL Label */ 
      {
#line 25
      printf((char const   */* __restrict  */)"Enter new weight for gain -current weight=%f\n",
             weight___0->gain);
#line 26
      scanf((char const   */* __restrict  */)"%s", str);
#line 27
      weight___0->gain = atof((char const   *)str);
#line 28
      fflush(stdin);
      }
#line 29
      goto switch_break;
      case_70: /* CIL Label */ 
      {
#line 32
      printf((char const   */* __restrict  */)"Enter new weight for FB -current weight=%f\n",
             weight___0->fb);
#line 33
      gets(str);
#line 34
      weight___0->fb = atof((char const   *)str);
      }
#line 35
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 38
      printf((char const   */* __restrict  */)"Enter new weight for sidelobe -current weight=%f\n",
             weight___0->sidelobe);
#line 39
      gets(str);
#line 40
      weight___0->sidelobe = atof((char const   *)str);
      }
#line 41
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 44
    free_string(str, 0L, 100L);
    }
  }
#line 46
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/print_relavent_performance_data.c"
void print_relavent_performance_data(FILE *fp , char *s , int i , struct flags flag ,
                                     struct performance_data data , double fitness ,
                                     int Z_Q , int fitness_Q ) 
{ 


  {
#line 9
  if (i != 0) {
    {
#line 10
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%5d ",
            i);
    }
  }
  {
#line 13
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%sG=%5.2fdBi,FB=%6.2fdB,",
          s, data.gain, data.fb);
#line 14
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"SL=%5.2fdB,",
          data.sidelobe);
#line 15
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"SWR=%5.2f",
          data.swr);
  }
#line 16
  if (Z_Q == 1) {
    {
#line 18
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)",Z=%6.2f",
            data.r);
    }
#line 19
    if (data.x < 0.0) {
      {
#line 20
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-j%6.2f",
              - data.x);
      }
    } else {
      {
#line 22
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"+j%6.2f",
              data.x);
      }
    }
  }
#line 24
  if (fitness_Q == 1) {
    {
#line 25
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)",%.3f",
            fitness);
    }
  }
  {
#line 26
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
#line 27
  return;
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 149 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
double version(void) ;
#line 160
int getoptions(int argc , char **argv , char *opts ) ;
#line 176
void error_message(char *str ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/get_command_line_options.c"
char *optarg ;
#line 23 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/get_command_line_options.c"
double min_offset_from_peak  =    0.0;
#line 24 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/get_command_line_options.c"
double angular_stepsize_2  =    0.0;
#line 26 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/get_command_line_options.c"
void get_command_line_options(int argc , char **argv , struct flags *flag ) 
{ 
  int c ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  unsigned short const   **tmp___16 ;
  double tmp___17 ;
  unsigned short const   **tmp___18 ;
  unsigned short const   **tmp___19 ;
  unsigned short const   **tmp___20 ;

  {
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 32
    c = getoptions(argc, argv, (char *)"A:c:kwW:hvdg:Or:P:m:C:b:x:f:s:S:G:R:X:F:l:o:e:Z:p:t:T:K:");
    }
#line 32
    if (! (c != -1)) {
#line 32
      goto while_break;
    }
    {
#line 35
    if (c == 107) {
#line 35
      goto case_107;
    }
#line 38
    if (c == 67) {
#line 38
      goto case_67;
    }
#line 41
    if (c == 65) {
#line 41
      goto case_65;
    }
#line 49
    if (c == 87) {
#line 49
      goto case_87;
    }
#line 58
    if (c == 97) {
#line 58
      goto case_97;
    }
#line 72
    if (c == 80) {
#line 72
      goto case_80;
    }
#line 86
    if (c == 99) {
#line 86
      goto case_99;
    }
#line 99
    if (c == 109) {
#line 99
      goto case_109;
    }
#line 113
    if (c == 119) {
#line 113
      goto case_119;
    }
#line 116
    if (c == 114) {
#line 116
      goto case_114;
    }
#line 130
    if (c == 120) {
#line 130
      goto case_120;
    }
#line 144
    if (c == 115) {
#line 144
      goto case_115;
    }
#line 158
    if (c == 102) {
#line 158
      goto case_102;
    }
#line 172
    if (c == 70) {
#line 172
      goto case_70;
    }
#line 186
    if (c == 71) {
#line 186
      goto case_71;
    }
#line 200
    if (c == 83) {
#line 200
      goto case_83;
    }
#line 214
    if (c == 108) {
#line 214
      goto case_108;
    }
#line 223
    if (c == 111) {
#line 223
      goto case_111;
    }
#line 236
    if (c == 79) {
#line 236
      goto case_79;
    }
#line 239
    if (c == 75) {
#line 239
      goto case_75;
    }
#line 253
    if (c == 98) {
#line 253
      goto case_98;
    }
#line 267
    if (c == 90) {
#line 267
      goto case_90;
    }
#line 281
    if (c == 101) {
#line 281
      goto case_101;
    }
#line 296
    if (c == 104) {
#line 296
      goto case_104;
    }
#line 299
    if (c == 118) {
#line 299
      goto case_118;
    }
#line 302
    if (c == 100) {
#line 302
      goto case_100;
    }
#line 305
    if (c == 103) {
#line 305
      goto case_103;
    }
#line 313
    if (c == 112) {
#line 313
      goto case_112;
    }
#line 327
    if (c == 116) {
#line 327
      goto case_116;
    }
#line 341
    if (c == 84) {
#line 341
      goto case_84;
    }
#line 355
    if (c == 63) {
#line 355
      goto case_63;
    }
#line 33
    goto switch_break;
    case_107: /* CIL Label */ 
#line 36
    flag->kflg = 1;
#line 37
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 39
    flag->Cflg = atoi((char const   *)optarg);
    }
#line 40
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 42
    tmp = atoi((char const   *)optarg);
#line 42
    flag->Aflg = tmp + 1000;
    }
#line 43
    if (flag->Aflg < -1) {
      {
#line 45
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aflg x, where (-1<= x<= directors)\n");
#line 46
      exit(1);
      }
    }
#line 48
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 50
    flag->Wflg = atoi((char const   *)optarg);
    }
#line 51
    if (flag->Wflg < 1) {
      {
#line 53
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-Wx, where x=1(gain),2() etc AND\n");
#line 54
      exit(1);
      }
    } else
#line 51
    if (flag->Wflg > 64) {
      {
#line 53
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-Wx, where x=1(gain),2() etc AND\n");
#line 54
      exit(1);
      }
    }
#line 56
    flag->Wflg += 32768;
#line 57
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 59
    flag->aflg = 1;
#line 60
    tmp___0 = __ctype_b_loc();
    }
#line 60
    if (! ((int const   )*(*tmp___0 + (int )*optarg) & 2048)) {
#line 60
      if ((int )*optarg != 46) {
        {
#line 62
        error_message((char *)"Non numeric data entered for option -a which requires numeric data.\n");
#line 63
        exit(1);
        }
      }
    }
    {
#line 65
    angular_stepsize_2 = atof((char const   *)optarg);
    }
#line 66
    if (angular_stepsize_2 < 0.0) {
      {
#line 68
      error_message((char *)"The \'-a\' requires a posistive float, signifying the angular stepsize to use when finding sidelobes.\n");
#line 69
      exit(1);
      }
    }
#line 71
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 73
    flag->Pflg = 1;
#line 74
    tmp___1 = __ctype_b_loc();
    }
#line 74
    if (! ((int const   )*(*tmp___1 + (int )*optarg) & 2048)) {
#line 74
      if ((int )*optarg != 46) {
        {
#line 76
        error_message((char *)"Non numeric data entered for option -P which requires numeric data.\n");
#line 77
        exit(1);
        }
      }
    }
    {
#line 79
    weight.sidelobe = atof((char const   *)optarg);
    }
#line 80
    if (weight.sidelobe < 0.0) {
      {
#line 82
      error_message((char *)"The \'-P\' requires a posistive float, signifying the weight on the sidelobe level (default=1.0).\n");
#line 83
      exit(1);
      }
    }
#line 85
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 87
    tmp___2 = __ctype_b_loc();
    }
#line 87
    if (! ((int const   )*(*tmp___2 + (int )*optarg) & 2048)) {
#line 87
      if ((int )*optarg != 46) {
        {
#line 89
        error_message((char *)"Non numeric data entered for option -P which requires numeric data.\n");
#line 90
        exit(1);
        }
      }
    }
    {
#line 92
    max.sidelobe = atof((char const   *)optarg);
    }
#line 93
    if (max.sidelobe < 0.0) {
      {
#line 95
      error_message((char *)"The \'-P\' requires a posistive float, signifying the sidelobe level down to aim for in dB (20 is reasonable).\n");
#line 96
      exit(1);
      }
    }
#line 98
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 100
    flag->mflg = 1;
#line 101
    tmp___3 = __ctype_b_loc();
    }
#line 101
    if (! ((int const   )*(*tmp___3 + (int )*optarg) & 2048)) {
#line 101
      if ((int )*optarg != 46) {
        {
#line 103
        error_message((char *)"Non numeric data entered for option -m which requires numeric data.\n");
#line 104
        exit(1);
        }
      }
    }
    {
#line 106
    min_offset_from_peak = atof((char const   *)optarg);
    }
#line 107
    if (min_offset_from_peak < 0.0) {
      {
#line 109
      error_message((char *)"The \'-m\' requires a posistive float, signifying the minimum offset in degrees from theta =90, to start considering a sidelobe, rather than the main beam.\n");
#line 110
      exit(1);
      }
    } else
#line 107
    if (min_offset_from_peak > (double )90) {
      {
#line 109
      error_message((char *)"The \'-m\' requires a posistive float, signifying the minimum offset in degrees from theta =90, to start considering a sidelobe, rather than the main beam.\n");
#line 110
      exit(1);
      }
    }
#line 112
    goto switch_break;
    case_119: /* CIL Label */ 
#line 114
    flag->wflg = 2;
#line 115
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 117
    flag->rflg = 1;
#line 118
    tmp___4 = __ctype_b_loc();
    }
#line 118
    if (! ((int const   )*(*tmp___4 + (int )*optarg) & 2048)) {
#line 118
      if ((int )*optarg != 46) {
        {
#line 120
        error_message((char *)"Non numeric data entered for option -r which requires numeric data.\n");
#line 121
        exit(1);
        }
      }
    }
    {
#line 123
    max.r = atof((char const   *)optarg);
    }
#line 124
    if (max.r < 0.0) {
      {
#line 126
      error_message((char *)"The \'-r\' option setting an acceptable vswr must >=0.0\n");
#line 127
      exit(1);
      }
    }
#line 129
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 131
    flag->xflg = 1;
#line 132
    tmp___5 = __ctype_b_loc();
    }
#line 132
    if (! ((int const   )*(*tmp___5 + (int )*optarg) & 2048)) {
#line 132
      if ((int )*optarg != 46) {
        {
#line 134
        error_message((char *)"Non numeric data entered for option -x which requires numeric data.\n");
#line 135
        exit(1);
        }
      }
    }
    {
#line 137
    max.x = atof((char const   *)optarg);
    }
#line 138
    if (max.x < 0.0) {
      {
#line 140
      error_message((char *)"The \'-x\' option setting an acceptable reactance must >=0.0\n");
#line 141
      exit(1);
      }
    }
#line 143
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 145
    flag->sflg = 1;
#line 146
    tmp___6 = __ctype_b_loc();
    }
#line 146
    if (! ((int const   )*(*tmp___6 + (int )*optarg) & 2048)) {
#line 146
      if ((int )*optarg != 46) {
        {
#line 148
        error_message((char *)"Non numeric data entered for option -s which requires numeric data.\n");
#line 149
        exit(1);
        }
      }
    }
    {
#line 151
    max.swr = atof((char const   *)optarg);
    }
#line 152
    if (max.swr < 1.0) {
      {
#line 154
      error_message((char *)"The \'-s\' option setting an acceptable vswr must >= 1.\n");
#line 155
      exit(1);
      }
    }
#line 157
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 159
    flag->fflg = 1;
#line 160
    tmp___7 = __ctype_b_loc();
    }
#line 160
    if (! ((int const   )*(*tmp___7 + (int )*optarg) & 2048)) {
#line 160
      if ((int )*optarg != 46) {
        {
#line 162
        error_message((char *)"Non numeric data entered for option -f which requires numeric data.\n");
#line 163
        exit(1);
        }
      }
    }
    {
#line 165
    max.fb = atof((char const   *)optarg);
    }
#line 166
    if (max.fb < 0.0) {
      {
#line 168
      error_message((char *)"The \'-f\' option setting an acceptable FB ratio must >=0.0\n");
#line 169
      exit(1);
      }
    }
#line 171
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 173
    flag->Fflg = 1;
#line 174
    tmp___8 = __ctype_b_loc();
    }
#line 174
    if (! ((int const   )*(*tmp___8 + (int )*optarg) & 2048)) {
#line 174
      if ((int )*optarg != 46) {
        {
#line 176
        error_message((char *)"Non numeric data entered for option -F which requires numeric data.\n");
#line 177
        exit(1);
        }
      }
    }
    {
#line 179
    weight.fb = atof((char const   *)optarg);
    }
#line 180
    if (weight.fb < 0.0) {
      {
#line 182
      error_message((char *)"The \'-F\' option setting the weight for FB ratio must >=0.0\n");
#line 183
      exit(1);
      }
    }
#line 185
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 187
    flag->Gflg = 1;
#line 188
    tmp___9 = __ctype_b_loc();
    }
#line 188
    if (! ((int const   )*(*tmp___9 + (int )*optarg) & 2048)) {
#line 188
      if ((int )*optarg != 46) {
        {
#line 190
        error_message((char *)"Non numeric data entered for option -G which requires numeric data.\n");
#line 191
        exit(1);
        }
      }
    }
    {
#line 193
    weight.gain = atof((char const   *)optarg);
    }
#line 194
    if (weight.gain < 0.0) {
      {
#line 196
      error_message((char *)"The \'-G\' option setting the weight for gain must >=0.0\n");
#line 197
      exit(1);
      }
    }
#line 199
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 201
    flag->Sflg = 1;
#line 202
    tmp___10 = __ctype_b_loc();
    }
#line 202
    if (! ((int const   )*(*tmp___10 + (int )*optarg) & 2048)) {
#line 202
      if ((int )*optarg != 46) {
        {
#line 204
        error_message((char *)"Non numeric data entered for option -S which requires numeric data.\n");
#line 205
        exit(1);
        }
      }
    }
    {
#line 207
    weight.swr = atof((char const   *)optarg);
    }
#line 208
    if (weight.swr < 0.0) {
      {
#line 210
      error_message((char *)"The \'-S\' option setting the weight for swr must >=0.0\n");
#line 211
      exit(1);
      }
    }
#line 213
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 215
    flag->lflg = 1;
#line 216
    tmp___11 = __ctype_b_loc();
    }
#line 216
    if (! ((int const   )*(*tmp___11 + (int )*optarg) & 2048)) {
#line 216
      if ((int )*optarg != 46) {
#line 216
        if ((int )*optarg != 45) {
          {
#line 218
          error_message((char *)"Non numeric data entered for option -l which requires numeric data.\n");
#line 219
          exit(1);
          }
        }
      }
    }
    {
#line 221
    original_percent = atof((char const   *)optarg);
    }
#line 222
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 224
    tmp___12 = __ctype_b_loc();
    }
#line 224
    if (! ((int const   )*(*tmp___12 + (int )*optarg) & 2048)) {
      {
#line 226
      error_message((char *)"Non numeric data entered for option -o which requires numeric data.\n");
#line 227
      exit(1);
      }
    }
    {
#line 229
    flag->oflg = atoi((char const   *)optarg);
    }
#line 230
    if (flag->oflg < 0) {
      {
#line 232
      error_message((char *)"The \'-o\' option setting the parameter(s) to optimise for must be in the range 0 to 128.\n");
#line 233
      exit(1);
      }
    } else
#line 230
    if (flag->oflg > 128) {
      {
#line 232
      error_message((char *)"The \'-o\' option setting the parameter(s) to optimise for must be in the range 0 to 128.\n");
#line 233
      exit(1);
      }
    }
#line 235
    goto switch_break;
    case_79: /* CIL Label */ 
#line 237
    flag->Oflg = 1;
#line 238
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 240
    flag->Kflg = 1;
#line 241
    tmp___13 = __ctype_b_loc();
    }
#line 241
    if (! ((int const   )*(*tmp___13 + (int )*optarg) & 2048)) {
      {
#line 243
      error_message((char *)"Non numeric data entered for option -K which requires an integer.\n");
#line 244
      exit(1);
      }
    }
    {
#line 246
    K_times_max = atoi((char const   *)optarg);
    }
#line 247
    if (K_times_max < 1) {
      {
#line 249
      error_message((char *)"The \'-K\' option setting the number of attemps to stay with hte original data after a good one found, to avoid local optimums, must be an integer > 1.\n");
#line 250
      exit(1);
      }
    }
#line 252
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 254
    flag->bflg = 1;
#line 255
    tmp___14 = __ctype_b_loc();
    }
#line 255
    if (! ((int const   )*(*tmp___14 + (int )*optarg) & 2048)) {
#line 255
      if ((int )*optarg != 46) {
        {
#line 257
        error_message((char *)"Non numeric data entered for option -b which requires numeric data.\n");
#line 258
        exit(1);
        }
      }
    }
    {
#line 260
    boom_factor = atof((char const   *)optarg);
    }
#line 261
    if (boom_factor < 0.0) {
      {
#line 263
      error_message((char *)"The \'-b\' option setting the maximum permissable change in the boom length (in %%) must be >=0.0\n");
#line 264
      exit(1);
      }
    }
#line 266
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 268
    flag->Zoflg = 1;
#line 269
    tmp___15 = __ctype_b_loc();
    }
#line 269
    if (! ((int const   )*(*tmp___15 + (int )*optarg) & 2048)) {
#line 269
      if ((int )*optarg != 46) {
        {
#line 271
        error_message((char *)"Non numeric data entered for option -Z which requires numeric data.\n");
#line 272
        exit(1);
        }
      }
    }
    {
#line 274
    Zo = atof((char const   *)optarg);
    }
#line 275
    if (Zo <= 0.0) {
      {
#line 277
      error_message((char *)"The \'-Z\' option setting Zo must be > 0.0\n");
#line 278
      exit(1);
      }
    }
#line 280
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 282
    tmp___16 = __ctype_b_loc();
    }
#line 282
    if (! ((int const   )*(*tmp___16 + (int )*optarg) & 2048)) {
      {
#line 284
      error_message((char *)"Non numeric data entered for option -e which requires numeric data.\n");
#line 285
      exit(1);
      }
    }
    {
#line 287
    flag->eflg = atoi((char const   *)optarg);
    }
#line 288
    if (flag->eflg < 0) {
      {
#line 290
      error_message((char *)"The \'-e\' option setting the type of elements moved must be an integer between 1 and 127\n");
#line 291
      exit(1);
      }
    } else
#line 288
    if (flag->eflg > 1024) {
      {
#line 290
      error_message((char *)"The \'-e\' option setting the type of elements moved must be an integer between 1 and 127\n");
#line 291
      exit(1);
      }
    }
#line 293
    if (flag->eflg == 0) {
      {
#line 294
      printf((char const   */* __restrict  */)"Thats odd, you dont want to move any elements (-e0 option)\n");
      }
    }
#line 295
    goto switch_break;
    case_104: /* CIL Label */ 
#line 297
    flag->hflg = 1;
#line 298
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 300
    tmp___17 = version();
#line 300
    printf((char const   */* __restrict  */)"version = %f\n", tmp___17);
    }
#line 301
    goto switch_break;
    case_100: /* CIL Label */ 
#line 303
    flag->dflg = 1;
#line 304
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 306
    flag->gflg = atoi((char const   *)optarg);
    }
#line 307
    if (flag->gflg < 1) {
      {
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-gx, where x=1 to 64\n");
#line 310
      exit(1);
      }
    } else
#line 307
    if (flag->gflg > 64) {
      {
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-gx, where x=1 to 64\n");
#line 310
      exit(1);
      }
    }
#line 312
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 314
    flag->pflg = 1;
#line 315
    tmp___18 = __ctype_b_loc();
    }
#line 315
    if (! ((int const   )*(*tmp___18 + (int )*optarg) & 2048)) {
#line 315
      if ((int )*optarg != 46) {
        {
#line 317
        error_message((char *)"Non numeric data entered for option -p which requires numeric data.\n");
#line 318
        exit(1);
        }
      }
    }
    {
#line 320
    popsize = atoi((char const   *)optarg);
    }
#line 321
    if (popsize < 2) {
      {
#line 323
      error_message((char *)"The \'-p\' option setting the population size of the genetric algorithm, mush be between 2 amd 1000000\n");
#line 324
      exit(1);
      }
    } else
#line 321
    if (popsize > 10000000) {
      {
#line 323
      error_message((char *)"The \'-p\' option setting the population size of the genetric algorithm, mush be between 2 amd 1000000\n");
#line 324
      exit(1);
      }
    }
#line 326
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 328
    flag->tflg = 1;
#line 329
    tmp___19 = __ctype_b_loc();
    }
#line 329
    if (! ((int const   )*(*tmp___19 + (int )*optarg) & 2048)) {
#line 329
      if ((int )*optarg != 46) {
        {
#line 331
        error_message((char *)"Non numeric data entered for option -t which requires numeric data.\n");
#line 332
        exit(1);
        }
      }
    }
    {
#line 334
    length_sd = atof((char const   *)optarg);
    }
#line 335
    if (length_sd < (double )0) {
      {
#line 337
      error_message((char *)"The \'-t\' option setting the standard deviation of the element lengths must be > 0\n");
#line 338
      exit(1);
      }
    }
#line 340
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 342
    flag->Tflg = 1;
#line 343
    tmp___20 = __ctype_b_loc();
    }
#line 343
    if (! ((int const   )*(*tmp___20 + (int )*optarg) & 2048)) {
#line 343
      if ((int )*optarg != 46) {
        {
#line 345
        error_message((char *)"Non numeric data entered for option -T which requires numeric data.\n");
#line 346
        exit(1);
        }
      }
    }
    {
#line 348
    boom_sd = atof((char const   *)optarg);
    }
#line 349
    if (boom_sd < (double )0) {
      {
#line 351
      error_message((char *)"The \'-T\' option setting the standard deviation of the boom postions must be > 0\n");
#line 352
      exit(1);
      }
    }
#line 354
    goto switch_break;
    case_63: /* CIL Label */ 
#line 356
    (flag->errflg) ++;
#line 357
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  if (flag->Oflg) {
#line 361
    flag->oflg -= 32768;
  }
#line 363
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
void nrerror(char *error_text ) 
{ 


  {
  {
#line 17
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Numerical Recipes run-time error...\n");
#line 18
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          error_text);
#line 19
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"...now exiting to system...\n");
#line 20
  exit(1);
  }
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
float *vector(long nl , long nh ) 
{ 
  float *v ;
  void *tmp ;

  {
  {
#line 28
  tmp = malloc((unsigned long )(((nh - nl) + 1L) + 1L) * sizeof(float ));
#line 28
  v = (float *)tmp;
  }
#line 29
  if (! v) {
    {
#line 29
    nrerror((char *)"allocation failure in vector()");
    }
  }
#line 30
  return ((v - nl) + 1);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
int *ivector(long nl , long nh ) 
{ 
  int *v ;
  void *tmp ;

  {
  {
#line 38
  tmp = malloc((unsigned long )(((nh - nl) + 1L) + 1L) * sizeof(int ));
#line 38
  v = (int *)tmp;
  }
#line 39
  if (! v) {
    {
#line 39
    nrerror((char *)"allocation failure in ivector()");
    }
  }
#line 40
  return ((v - nl) + 1);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
unsigned char *cvector(long nl , long nh ) 
{ 
  unsigned char *v ;
  void *tmp ;

  {
  {
#line 48
  tmp = malloc((unsigned long )(((nh - nl) + 1L) + 1L) * sizeof(unsigned char ));
#line 48
  v = (unsigned char *)tmp;
  }
#line 49
  if (! v) {
    {
#line 49
    nrerror((char *)"allocation failure in cvector()");
    }
  }
#line 50
  return ((v - nl) + 1);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
unsigned long *lvector(long nl , long nh ) 
{ 
  unsigned long *v ;
  void *tmp ;

  {
  {
#line 58
  tmp = malloc((unsigned long )(((nh - nl) + 1L) + 1L) * sizeof(long ));
#line 58
  v = (unsigned long *)tmp;
  }
#line 59
  if (! v) {
    {
#line 59
    nrerror((char *)"allocation failure in lvector()");
    }
  }
#line 60
  return ((v - nl) + 1);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
double *dvector(long nl , long nh ) 
{ 
  double *v ;
  void *tmp ;

  {
  {
#line 67
  tmp = malloc((unsigned long )(((nh - nl) + 1L) + 1L) * sizeof(double ));
#line 67
  v = (double *)tmp;
  }
#line 68
  if (! v) {
    {
#line 68
    nrerror((char *)"allocation failure in dvector()");
    }
  }
#line 69
  return ((v - nl) + 1);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
float **matrix(long nrl , long nrh , long ncl , long nch ) 
{ 
  long i ;
  long nrow ;
  long ncol ;
  float **m ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 75
  nrow = (nrh - nrl) + 1L;
#line 75
  ncol = (nch - ncl) + 1L;
#line 79
  tmp = malloc((unsigned long )(nrow + 1L) * sizeof(float *));
#line 79
  m = (float **)tmp;
  }
#line 80
  if (! m) {
    {
#line 80
    nrerror((char *)"allocation failure 1 in matrix()");
    }
  }
  {
#line 81
  m ++;
#line 82
  m -= nrl;
#line 85
  tmp___0 = malloc((unsigned long )(nrow * ncol + 1L) * sizeof(float ));
#line 85
  *(m + nrl) = (float *)tmp___0;
  }
#line 86
  if (! *(m + nrl)) {
    {
#line 86
    nrerror((char *)"allocation failure 2 in matrix()");
    }
  }
#line 87
  (*(m + nrl)) ++;
#line 88
  *(m + nrl) -= ncl;
#line 90
  i = nrl + 1L;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (i <= nrh)) {
#line 90
      goto while_break;
    }
#line 90
    *(m + i) = *(m + (i - 1L)) + ncol;
#line 90
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return (m);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
double **dmatrix(long nrl , long nrh , long ncl , long nch ) 
{ 
  long i ;
  long nrow ;
  long ncol ;
  double **m ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 99
  nrow = (nrh - nrl) + 1L;
#line 99
  ncol = (nch - ncl) + 1L;
#line 103
  tmp = malloc((unsigned long )(nrow + 1L) * sizeof(double *));
#line 103
  m = (double **)tmp;
  }
#line 104
  if (! m) {
    {
#line 104
    nrerror((char *)"allocation failure 1 in matrix()");
    }
  }
  {
#line 105
  m ++;
#line 106
  m -= nrl;
#line 109
  tmp___0 = malloc((unsigned long )(nrow * ncol + 1L) * sizeof(double ));
#line 109
  *(m + nrl) = (double *)tmp___0;
  }
#line 110
  if (! *(m + nrl)) {
    {
#line 110
    nrerror((char *)"allocation failure 2 in matrix()");
    }
  }
#line 111
  (*(m + nrl)) ++;
#line 112
  *(m + nrl) -= ncl;
#line 114
  i = nrl + 1L;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i <= nrh)) {
#line 114
      goto while_break;
    }
#line 114
    *(m + i) = *(m + (i - 1L)) + ncol;
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return (m);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
int **imatrix(long nrl , long nrh , long ncl , long nch ) 
{ 
  long i ;
  long nrow ;
  long ncol ;
  int **m ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 123
  nrow = (nrh - nrl) + 1L;
#line 123
  ncol = (nch - ncl) + 1L;
#line 127
  tmp = malloc((unsigned long )(nrow + 1L) * sizeof(int *));
#line 127
  m = (int **)tmp;
  }
#line 128
  if (! m) {
    {
#line 128
    nrerror((char *)"allocation failure 1 in matrix()");
    }
  }
  {
#line 129
  m ++;
#line 130
  m -= nrl;
#line 134
  tmp___0 = malloc((unsigned long )(nrow * ncol + 1L) * sizeof(int ));
#line 134
  *(m + nrl) = (int *)tmp___0;
  }
#line 135
  if (! *(m + nrl)) {
    {
#line 135
    nrerror((char *)"allocation failure 2 in matrix()");
    }
  }
#line 136
  (*(m + nrl)) ++;
#line 137
  *(m + nrl) -= ncl;
#line 139
  i = nrl + 1L;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (i <= nrh)) {
#line 139
      goto while_break;
    }
#line 139
    *(m + i) = *(m + (i - 1L)) + ncol;
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return (m);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
float **submatrix(float **a , long oldrl , long oldrh , long oldcl , long oldch ,
                  long newrl , long newcl ) 
{ 
  long i ;
  long j ;
  long nrow ;
  long ncol ;
  float **m ;
  void *tmp ;

  {
  {
#line 149
  nrow = (oldrh - oldrl) + 1L;
#line 149
  ncol = oldcl - newcl;
#line 153
  tmp = malloc((unsigned long )(nrow + 1L) * sizeof(float *));
#line 153
  m = (float **)tmp;
  }
#line 154
  if (! m) {
    {
#line 154
    nrerror((char *)"allocation failure in submatrix()");
    }
  }
#line 155
  m ++;
#line 156
  m -= newrl;
#line 159
  i = oldrl;
#line 159
  j = newrl;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! (i <= oldrh)) {
#line 159
      goto while_break;
    }
#line 159
    *(m + j) = *(a + i) + ncol;
#line 159
    i ++;
#line 159
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (m);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
float **convert_matrix(float *a , long nrl , long nrh , long ncl , long nch ) 
{ 
  long i ;
  long j ;
  long nrow ;
  long ncol ;
  float **m ;
  void *tmp ;

  {
  {
#line 171
  nrow = (nrh - nrl) + 1L;
#line 171
  ncol = (nch - ncl) + 1L;
#line 175
  tmp = malloc((unsigned long )(nrow + 1L) * sizeof(float *));
#line 175
  m = (float **)tmp;
  }
#line 176
  if (! m) {
    {
#line 176
    nrerror((char *)"allocation failure in convert_matrix()");
    }
  }
#line 177
  m ++;
#line 178
  m -= nrl;
#line 181
  *(m + nrl) = a - ncl;
#line 182
  i = 1L;
#line 182
  j = nrl + 1L;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < nrow)) {
#line 182
      goto while_break;
    }
#line 182
    *(m + j) = *(m + (j - 1L)) + ncol;
#line 182
    i ++;
#line 182
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (m);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
float ***f3tensor(long nrl , long nrh , long ncl , long nch , long ndl , long ndh ) 
{ 
  long i ;
  long j ;
  long nrow ;
  long ncol ;
  long ndep ;
  float ***t ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 190
  nrow = (nrh - nrl) + 1L;
#line 190
  ncol = (nch - ncl) + 1L;
#line 190
  ndep = (ndh - ndl) + 1L;
#line 194
  tmp = malloc((unsigned long )(nrow + 1L) * sizeof(float **));
#line 194
  t = (float ***)tmp;
  }
#line 195
  if (! t) {
    {
#line 195
    nrerror((char *)"allocation failure 1 in f3tensor()");
    }
  }
  {
#line 196
  t ++;
#line 197
  t -= nrl;
#line 200
  tmp___0 = malloc((unsigned long )(nrow * ncol + 1L) * sizeof(float *));
#line 200
  *(t + nrl) = (float **)tmp___0;
  }
#line 201
  if (! *(t + nrl)) {
    {
#line 201
    nrerror((char *)"allocation failure 2 in f3tensor()");
    }
  }
  {
#line 202
  (*(t + nrl)) ++;
#line 203
  *(t + nrl) -= ncl;
#line 206
  tmp___1 = malloc((unsigned long )((nrow * ncol) * ndep + 1L) * sizeof(float ));
#line 206
  *(*(t + nrl) + ncl) = (float *)tmp___1;
  }
#line 207
  if (! *(*(t + nrl) + ncl)) {
    {
#line 207
    nrerror((char *)"allocation failure 3 in f3tensor()");
    }
  }
#line 208
  (*(*(t + nrl) + ncl)) ++;
#line 209
  *(*(t + nrl) + ncl) -= ndl;
#line 211
  j = ncl + 1L;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (j <= nch)) {
#line 211
      goto while_break;
    }
#line 211
    *(*(t + nrl) + j) = *(*(t + nrl) + (j - 1L)) + ndep;
#line 211
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  i = nrl + 1L;
  {
#line 212
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 212
    if (! (i <= nrh)) {
#line 212
      goto while_break___0;
    }
#line 213
    *(t + i) = *(t + (i - 1L)) + ncol;
#line 214
    *(*(t + i) + ncl) = *(*(t + (i - 1L)) + ncl) + ncol * ndep;
#line 215
    j = ncl + 1L;
    {
#line 215
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 215
      if (! (j <= nch)) {
#line 215
        goto while_break___1;
      }
#line 215
      *(*(t + i) + j) = *(*(t + i) + (j - 1L)) + ndep;
#line 215
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 212
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 219
  return (t);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
void free_vector(float *v , long nl , long nh ) 
{ 


  {
  {
#line 225
  free((void *)((char *)((v + nl) - 1)));
  }
#line 226
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
void free_ivector(int *v , long nl , long nh ) 
{ 


  {
  {
#line 231
  free((void *)((char *)((v + nl) - 1)));
  }
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
void free_cvector(unsigned char *v , long nl , long nh ) 
{ 


  {
  {
#line 237
  free((void *)((char *)((v + nl) - 1)));
  }
#line 238
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
void free_lvector(unsigned long *v , long nl , long nh ) 
{ 


  {
  {
#line 243
  free((void *)((char *)((v + nl) - 1)));
  }
#line 244
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
void free_dvector(double *v , long nl , long nh ) 
{ 


  {
  {
#line 249
  free((void *)((char *)((v + nl) - 1)));
  }
#line 250
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
void free_matrix(float **m , long nrl , long nrh , long ncl , long nch ) 
{ 


  {
  {
#line 255
  free((void *)((char *)((*(m + nrl) + ncl) - 1)));
#line 256
  free((void *)((char *)((m + nrl) - 1)));
  }
#line 257
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
void free_dmatrix(double **m , long nrl , long nrh , long ncl , long nch ) 
{ 


  {
  {
#line 262
  free((void *)((char *)((*(m + nrl) + ncl) - 1)));
#line 263
  free((void *)((char *)((m + nrl) - 1)));
  }
#line 264
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
void free_imatrix(int **m , long nrl , long nrh , long ncl , long nch ) 
{ 


  {
  {
#line 269
  free((void *)((char *)((*(m + nrl) + ncl) - 1)));
#line 270
  free((void *)((char *)((m + nrl) - 1)));
  }
#line 271
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
void free_submatrix(float **b , long nrl , long nrh , long ncl , long nch ) 
{ 


  {
  {
#line 276
  free((void *)((char *)((b + nrl) - 1)));
  }
#line 277
  return;
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
void free_convert_matrix(float **b , long nrl , long nrh , long ncl , long nch ) 
{ 


  {
  {
#line 282
  free((void *)((char *)((b + nrl) - 1)));
  }
#line 283
  return;
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nrutil.c"
void free_f3tensor(float ***t , long nrl , long nrh , long ncl , long nch , long ndl ,
                   long ndh ) 
{ 


  {
  {
#line 289
  free((void *)((char *)((*(*(t + nrl) + ncl) + ndl) - 1)));
#line 290
  free((void *)((char *)((*(t + nrl) + ncl) - 1)));
#line 291
  free((void *)((char *)((t + nrl) - 1)));
  }
#line 292
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void usage_optimise(char *str ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/usage_optimise.c"
void usage_optimise(char *str ) 
{ 
  double tmp ;

  {
  {
#line 15
  tmp = version();
#line 15
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nYagi-Uda antenna analysis programs, version %.2f\n",
          tmp);
#line 16
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Written by Dr. David Kirkby Ph.D. G8WRB (email:david.kirkby@onetel.net)\n");
#line 17
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUSAGE: %s  [options] filename iterations.\n\n",
          str);
#line 18
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The default behaviour of \'optimise\' is to optimise the Yagi description \ncontained in the file \'filename\', adjusting the lengths and positions of just \nthe parasitic elements upto %.2f%% each time, to achieve a better gain, vswr and F/B ratio, but not bothering to go beyond reasonable limits currently set at:\n",
          percent);
#line 19
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  F/B ratio > %.1f dB\n",
          max.fb);
#line 20
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %f < Rin < %f \n",
          Zo - max.r, Zo + max.r);
#line 21
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  | Xin | < %.2f Ohms\n",
          max.x);
#line 22
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  VSWR < %.2f:1\n",
          max.swr);
#line 23
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This will continue for the number of iterations specified in \'iterations\' or \nuntil a file called \'stop\' is created in the current directory.\n");
#line 24
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"These are a number of options for \'optimise\' which can adjust such things as:\n");
#line 25
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -gx=GA, -ox = improve all, -Wx = weighted\n");
#line 26
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -gx or ox or -Wx where x=1(G),2(FB),4(R),8(X),16(VSWR),32 (SL)\n");
#line 27
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -f, -p, -r, -s, -x Set reasonable values of F/B, pattern cleanliness, R, VSWR and X\n");
#line 28
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -F, -G, P, -R -S and -X Set weights of F/B, gain , pattern cleanliness, resistance, VSWR and reactance, (all need -W or -g flags)\n");
#line 29
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"There are many many more options. See man page, optimise.doc, or optimise.ps. Sensible use of these options will give you a decent Yagi.\n");
#line 30
  exit(1);
  }
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void self_impedance(int i , double frequency , int driven , int parasitic , double **data ,
                    double **impedance ) ;
#line 165
double randreal(void) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/randomise.c"
static int run_first_time  =    0;
#line 20 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/randomise.c"
static double max_boom_length  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/randomise.c"
void randomise(int randomisation_method , double frequency , double max_percent ,
               double **driven_data , double **parasitic_data , int driven , int parasites ) 
{ 
  int i ;
  int elements___0 ;
  double y ;
  double old_boom_length ;
  double new_boom_length ;
  double a ;
  double lambda___0 ;
  double **z ;
  double l ;
  double x ;
  double taper ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;

  {
#line 21
  lambda___0 = (double )300 / frequency;
#line 22
  if (run_first_time == 0) {
#line 24
    max_boom_length = ((double )1 + boom_factor / (double )100) * *(*(parasitic_data + parasites) + 1);
  }
#line 26
  run_first_time ++;
#line 27
  if ((randomisation_method & 1) == 1) {
#line 29
    i = 1;
    {
#line 29
    while (1) {
      while_continue: /* CIL Label */ ;
#line 29
      if (! (i <= driven)) {
#line 29
        goto while_break;
      }
      {
#line 31
      tmp = randreal();
#line 31
      y = (double )1 + (0.02 * max_percent) * (tmp - 0.5);
#line 32
      *(*(driven_data + i) + 3) *= y;
#line 29
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 35
  if ((randomisation_method & 2) == 2) {
#line 37
    i = 1;
    {
#line 37
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 37
      if (! (i <= driven)) {
#line 37
        goto while_break___0;
      }
      {
#line 39
      tmp___0 = randreal();
#line 39
      y = (double )1 + (0.02 * max_percent) * (tmp___0 - 0.5);
#line 40
      *(*(driven_data + i) + 1) *= y;
#line 37
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 43
  if ((randomisation_method & 4) == 4) {
    {
#line 47
    tmp___1 = randreal();
#line 47
    y = (double )1 + (0.02 * max_percent) * (tmp___1 - 0.5);
#line 48
    *(*(parasitic_data + 1) + 3) *= y;
    }
  }
#line 51
  if ((randomisation_method & 8) == 8) {
#line 53
    i = 2;
    {
#line 53
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 53
      if (! (i <= parasites)) {
#line 53
        goto while_break___1;
      }
      {
#line 55
      tmp___2 = randreal();
#line 55
      y = (double )1 + (0.02 * max_percent) * (tmp___2 - 0.5);
#line 56
      *(*(parasitic_data + i) + 3) *= y;
      }
#line 58
      if (*(*(parasitic_data + i) + 3) > *(*(parasitic_data + (i - 1)) + 3)) {
#line 58
        if (i > 2) {
#line 59
          *(*(parasitic_data + i) + 3) = *(*(parasitic_data + (i - 1)) + 3);
        }
      }
#line 53
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 63
  if ((randomisation_method & 16) == 16) {
    {
#line 65
    old_boom_length = *(*(parasitic_data + parasites) + 1);
#line 66
    tmp___3 = randreal();
#line 66
    y = (double )1 + (0.02 * max_percent) * (tmp___3 - 0.5);
#line 67
    new_boom_length = old_boom_length * y;
    }
#line 68
    if (new_boom_length > max_boom_length) {
#line 69
      new_boom_length = max_boom_length;
    }
#line 71
    i = 2;
    {
#line 71
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 71
      if (! (i <= parasites)) {
#line 71
        goto while_break___2;
      }
      {
#line 73
      tmp___4 = randreal();
#line 73
      y = (double )1 + (0.02 * max_percent) * (tmp___4 - 0.5);
#line 74
      *(*(parasitic_data + i) + 1) *= y * (new_boom_length / old_boom_length);
#line 71
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 77
  if ((randomisation_method & 32) == 32) {
    {
#line 79
    tmp___5 = randreal();
#line 79
    y = (double )1 + (0.02 * max_percent) * (tmp___5 - 0.5);
#line 80
    i = 1;
    }
    {
#line 80
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 80
      if (! (i <= driven)) {
#line 80
        goto while_break___3;
      }
#line 81
      *(*(driven_data + i) + 3) *= y;
#line 80
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 82
    i = 1;
    {
#line 82
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 82
      if (! (i <= parasites)) {
#line 82
        goto while_break___4;
      }
#line 83
      *(*(parasitic_data + i) + 3) = *(*(driven_data + 1) + 3);
#line 82
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 85
  if ((randomisation_method & 64) == 64) {
    {
#line 87
    tmp___6 = randreal();
#line 87
    a = (double )1 + 0.1 * tmp___6;
#line 88
    taper = (a - (double )1) / *(*(driven_data + 1) + 1);
#line 89
    *(*(parasitic_data + 1) + 3) = a * *(*(driven_data + 1) + 3);
#line 90
    i = 2;
    }
    {
#line 90
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 90
      if (! (i <= parasites)) {
#line 90
        goto while_break___5;
      }
#line 91
      *(*(parasitic_data + i) + 3) = *(*(parasitic_data + 1) + 3) - taper * (*(*(parasitic_data + i) + 1) - *(*(driven_data + 1) + 1));
#line 90
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 94
  if ((randomisation_method & 128) == 128) {
#line 96
    if (run_first_time == 1) {
      {
#line 98
      elements___0 = driven + parasites;
#line 99
      z = dmatrix(1L, (long )elements___0, 2L, 2L * (long )elements___0);
#line 100
      l = 0.44 * lambda___0;
      }
      {
#line 101
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 103
        *(*(driven_data + 1) + 3) = l;
#line 104
        self_impedance(1, frequency * 1e6, driven, parasites, driven_data, z);
#line 105
        l += 0.00005 * lambda___0;
#line 106
        *(*(driven_data + 1) + 3) = l;
#line 107
        x = *(*(z + 1) + 2);
        }
#line 101
        if (! (*(*(z + 1) + 2) < 0.0)) {
#line 101
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 109
      printf((char const   */* __restrict  */)"Driven element set to :l=%f m = %f wavlengths\n",
             l, l / lambda___0);
#line 110
      free_dmatrix(z, 1L, (long )elements___0, 1L, 2L * (long )elements___0);
      }
    }
  }
#line 120
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/com_hack.h"
fcomplex Cdiv(fcomplex a , fcomplex b ) ;
#line 124 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void z_input(struct FCOMPLEX v , struct FCOMPLEX i , struct FCOMPLEX *impedance ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/z_input.c"
void z_input(struct FCOMPLEX v , struct FCOMPLEX i , struct FCOMPLEX *impedance ) 
{ 


  {
  {
#line 13
  *impedance = Cdiv(v, i);
  }
#line 25
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
struct FCOMPLEX **FCOMPLEXmatrix(long nrl , long nrh , long ncl , long nch ) ;
#line 134
void free_FCOMPLEXmatrix(struct FCOMPLEX **m , long nrl , long nrh , long ncl , long nch ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/string.c"
char *string(long nl , long nh ) 
{ 
  char *v ;
  void *tmp ;

  {
  {
#line 25
  tmp = malloc((unsigned long )((unsigned int )((nh - nl) + 1L)) * sizeof(char ));
#line 25
  v = (char *)tmp;
  }
#line 26
  if (! v) {
    {
#line 26
    nrerror((char *)"allocation failure in string()");
    }
  }
#line 27
  return (v - nl);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/string.c"
void free_string(char *v , long nl , long nh ) 
{ 


  {
  {
#line 34
  free((void *)(v + nl));
  }
#line 35
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/string.c"
struct FCOMPLEX **FCOMPLEXmatrix(long nrl , long nrh , long ncl , long nch ) 
{ 
  long i ;
  long nrow ;
  long ncol ;
  struct FCOMPLEX **m ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 40
  nrow = (nrh - nrl) + 1L;
#line 40
  ncol = (nch - ncl) + 1L;
#line 44
  tmp = malloc((size_t )((int )((unsigned long )(nrow + 1L) * sizeof(struct FCOMPLEX *))));
#line 44
  m = (struct FCOMPLEX **)tmp;
  }
#line 46
  if (! m) {
    {
#line 46
    nrerror((char *)"allocation failure 1 in matrix()");
    }
  }
  {
#line 47
  m ++;
#line 48
  m -= nrl;
#line 51
  tmp___0 = malloc((size_t )((int )((unsigned long )(nrow * ncol + 1L) * sizeof(struct FCOMPLEX ))));
#line 51
  *(m + nrl) = (struct FCOMPLEX *)tmp___0;
  }
#line 52
  if (! *(m + nrl)) {
    {
#line 52
    nrerror((char *)"allocation failure 2 in matrix()");
    }
  }
#line 53
  (*(m + nrl)) ++;
#line 54
  *(m + nrl) -= ncl;
#line 56
  i = nrl + 1L;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i <= nrh)) {
#line 56
      goto while_break;
    }
#line 56
    *(m + i) = *(m + (i - 1L)) + ncol;
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return (m);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/string.c"
struct element_data *element_data_vector(long nl , long nh ) 
{ 
  struct element_data *v ;
  void *tmp ;

  {
  {
#line 67
  tmp = malloc((size_t )((int )((unsigned long )(((nh - nl) + 1L) + 1L) * sizeof(struct element_data ))));
#line 67
  v = (struct element_data *)tmp;
  }
#line 68
  if (! v) {
    {
#line 68
    nrerror((char *)"allocation failure in element_data_vector()");
    }
  }
#line 69
  return ((v - nl) + 1);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/string.c"
struct FCOMPLEX *FCOMPLEXvector(long nl , long nh ) 
{ 
  struct FCOMPLEX *v ;
  void *tmp ;

  {
  {
#line 77
  tmp = malloc((size_t )((int )((unsigned long )(((nh - nl) + 1L) + 1L) * sizeof(struct FCOMPLEX ))));
#line 77
  v = (struct FCOMPLEX *)tmp;
  }
#line 78
  if (! v) {
    {
#line 78
    nrerror((char *)"allocation failure in FCOMPLEXvector()");
    }
  }
#line 79
  return ((v - nl) + 1);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/string.c"
void free_FCOMPLEXmatrix(struct FCOMPLEX **m , long nrl , long nrh , long ncl , long nch ) 
{ 


  {
  {
#line 84
  free((void *)((char *)((*(m + nrl) + ncl) - 1)));
#line 85
  free((void *)((char *)((m + nrl) - 1)));
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/string.c"
void free_FCOMPLEXvector(struct FCOMPLEX *v , long nl , long nh ) 
{ 


  {
  {
#line 90
  free((void *)((char *)((v + nl) - 1)));
  }
#line 92
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/string.c"
void free_element_data_vector(struct element_data *v , long nl , long nh ) 
{ 


  {
  {
#line 96
  free((void *)((char *)((v + nl) - 1)));
  }
#line 98
  return;
}
}
#line 144 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
 __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log2)(double x ) ;
#line 177 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
double determine_maximum_gain(double f___0 , double boom_length_in_m ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/max_gain.c"
double determine_maximum_gain(double f___0 , double boom_length_in_m ) 
{ 
  double lambda___0 ;
  double wavelengths ;
  double max_gain___0 ;
  double tmp ;

  {
#line 18
  lambda___0 = 3e8 / f___0;
#line 20
  wavelengths = boom_length_in_m / lambda___0;
#line 21
  if (wavelengths < (double )1) {
#line 22
    max_gain___0 = 8.0;
  } else {
    {
#line 24
    tmp = log2(wavelengths);
#line 24
    max_gain___0 = 12.0 + 2.6 * tmp;
    }
  }
#line 32
  return (max_gain___0);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/max_gain.c"
double determine_maximum_gain2(int elements___0 ) 
{ 
  double wavelengths ;
  double max_gain___0 ;
  double tmp ;

  {
  {
#line 43
  wavelengths = (double )(elements___0 - 1) * 0.25;
#line 44
  tmp = log2(wavelengths);
#line 44
  max_gain___0 = 12.0 + 2.6 * tmp;
  }
#line 52
  return (max_gain___0);
}
}
#line 55
 __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log2)(double x ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/max_gain.c"
double ( __attribute__((__leaf__)) log2)(double x ) 
{ 
  double tmp ;

  {
  {
#line 57
  tmp = log(x);
  }
#line 57
  return (tmp / 0.6931471);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 166 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
int randint(void) ;
#line 190
double Objective(char *gene ) ;
#line 191
int GA_Free(void) ;
#line 192
int GA_Error(char *ErrorMsg ) ;
#line 193
void SetPrint(int a ) ;
#line 194
int Initialise(int PopSize , int GeneSize ) ;
#line 195
int Selection(FILE *fd , int gen ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
int population_size  =    0;
#line 22 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
int gene_length  =    0;
#line 23 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
int elite  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
int ramp  =    0;
#line 25 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
int PRINT  =    1;
#line 26 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
double MX  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
double pmutate  =    0.1;
#line 32 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
double pcross  =    0.9;
#line 33 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
double psimplex  =    0.5;
#line 34 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
double ptrans  =    0.03;
#line 36 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
GeneRecord *Pop1  =    (GeneRecord *)((void *)0);
#line 36 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
GeneRecord *Pop2  =    (GeneRecord *)((void *)0);
#line 38 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
void setprobs(double pm , double pc , double ps , double pt ) 
{ 


  {
#line 40
  pmutate = pm;
#line 41
  pcross = pc;
#line 42
  psimplex = ps;
#line 43
  ptrans = pt;
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
int GA_Free(void) 
{ 
  int a ;

  {
#line 49
  if ((unsigned long )Pop1 != (unsigned long )((void *)0)) {
#line 50
    a = 0;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (a < population_size)) {
#line 50
        goto while_break;
      }
#line 51
      if ((unsigned long )(Pop1 + a)->gene != (unsigned long )((void *)0)) {
        {
#line 51
        free((void *)(Pop1 + a)->gene);
        }
      }
#line 50
      a ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 52
    free((void *)((char *)Pop1));
    }
  }
#line 54
  if ((unsigned long )Pop2 != (unsigned long )((void *)0)) {
#line 55
    a = 0;
    {
#line 55
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 55
      if (! (a < population_size)) {
#line 55
        goto while_break___0;
      }
#line 56
      if ((unsigned long )(Pop2 + a)->gene != (unsigned long )((void *)0)) {
        {
#line 56
        free((void *)(Pop2 + a)->gene);
        }
      }
#line 55
      a ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 57
    free((void *)((char *)Pop2));
    }
  }
#line 59
  return (0);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
int GA_Error(char *ErrorMsg ) 
{ 
  int a ;

  {
#line 65
  if ((unsigned long )Pop1 != (unsigned long )((void *)0)) {
#line 66
    a = 0;
    {
#line 66
    while (1) {
      while_continue: /* CIL Label */ ;
#line 66
      if (! (a < population_size)) {
#line 66
        goto while_break;
      }
#line 67
      if ((unsigned long )(Pop1 + a)->gene != (unsigned long )((void *)0)) {
        {
#line 67
        free((void *)(Pop1 + a)->gene);
        }
      }
#line 66
      a ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 68
    free((void *)Pop1);
    }
  }
#line 70
  if ((unsigned long )Pop2 != (unsigned long )((void *)0)) {
#line 71
    a = 0;
    {
#line 71
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 71
      if (! (a < population_size)) {
#line 71
        goto while_break___0;
      }
#line 72
      if ((unsigned long )(Pop2 + a)->gene != (unsigned long )((void *)0)) {
        {
#line 72
        free((void *)(Pop2 + a)->gene);
        }
      }
#line 71
      a ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 73
    free((void *)Pop2);
    }
  }
  {
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"GA_LIB Error : %s \n\n",
          ErrorMsg);
#line 76
  exit(1);
  }
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
double GetMax(void) 
{ 


  {
#line 81
  return (MX);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
void SetPrint(int a ) 
{ 


  {
#line 86
  PRINT = a;
#line 87
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
void dump_pop1(FILE *fd , int generation , double max___0 , double aver ) 
{ 
  int a ;

  {
#line 92
  if (PRINT == 0) {
#line 92
    return;
  }
  {
#line 93
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"Current contents of population: generation %d\n",
          generation);
#line 94
  a = 0;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (a < gene_length)) {
#line 94
      goto while_break;
    }
    {
#line 94
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"-");
#line 94
    a ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"------------------\n");
#line 96
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"Par1 Par2 Fitness   Code\n");
#line 97
  a = 0;
  }
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (! (a < population_size)) {
#line 97
      goto while_break___0;
    }
    {
#line 98
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%4d %4d %9.4f %s\n",
            (Pop1 + a)->parent1, (Pop1 + a)->parent2, (Pop1 + a)->fitness, (Pop1 + a)->gene);
#line 97
    a ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n Maximum %9.4f Average %9.4f\n",
          max___0, aver);
#line 100
  a = 0;
  }
  {
#line 100
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 100
    if (! (a < gene_length)) {
#line 100
      goto while_break___1;
    }
    {
#line 100
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"-");
#line 100
    a ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 101
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"------------------\n\n");
  }
#line 102
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
int Initialise(int PopSize , int GeneSize ) 
{ 
  int a ;
  int b ;
  char c[2] ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 109
  c[1] = (char)0;
#line 112
  ramp = 0;
#line 113
  population_size = PopSize;
#line 114
  gene_length = GeneSize + 1;
#line 116
  if (PopSize < 20) {
    {
#line 116
    GA_Error((char *)"Bad parameters to Initialise");
    }
  } else
#line 116
  if (PopSize > 1000) {
    {
#line 116
    GA_Error((char *)"Bad parameters to Initialise");
    }
  }
  {
#line 118
  tmp = calloc((size_t )PopSize, sizeof(GeneRecord ));
#line 118
  Pop1 = (GeneRecord *)tmp;
  }
#line 120
  if ((unsigned long )Pop1 == (unsigned long )((void *)0)) {
    {
#line 120
    GA_Error((char *)"Memory allocation for population 1");
    }
  }
#line 122
  a = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (a < population_size)) {
#line 122
      goto while_break;
    }
#line 123
    (Pop1 + a)->gene = (char *)((void *)0);
#line 124
    (Pop1 + a)->parent1 = 0;
#line 125
    (Pop1 + a)->parent2 = 0;
#line 126
    (Pop1 + a)->fitness = 0.0;
#line 122
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  a = 0;
  {
#line 129
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 129
    if (! (a < population_size)) {
#line 129
      goto while_break___0;
    }
    {
#line 130
    tmp___1 = malloc((size_t )gene_length);
#line 130
    tmp___0 = (char *)tmp___1;
#line 130
    (Pop1 + a)->gene = tmp___0;
    }
#line 130
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 131
      GA_Error((char *)"Cannot allocate gene in population 1");
      }
    }
#line 129
    a ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 133
  tmp___2 = calloc((size_t )PopSize, sizeof(GeneRecord ));
#line 133
  Pop2 = (GeneRecord *)tmp___2;
  }
#line 135
  if ((unsigned long )Pop2 == (unsigned long )((void *)0)) {
    {
#line 135
    GA_Error((char *)"Memory allocation for population 1");
    }
  }
#line 137
  a = 0;
  {
#line 137
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 137
    if (! (a < population_size)) {
#line 137
      goto while_break___1;
    }
#line 138
    (Pop2 + a)->gene = (char *)((void *)0);
#line 139
    (Pop2 + a)->parent1 = 0;
#line 140
    (Pop2 + a)->parent2 = 0;
#line 141
    (Pop2 + a)->fitness = 0.0;
#line 137
    a ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 144
  a = 0;
  {
#line 144
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 144
    if (! (a < population_size)) {
#line 144
      goto while_break___2;
    }
    {
#line 145
    tmp___4 = malloc((size_t )gene_length);
#line 145
    tmp___3 = (char *)tmp___4;
#line 145
    (Pop2 + a)->gene = tmp___3;
    }
#line 145
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      {
#line 146
      GA_Error((char *)"Cannot allocate gene in population 2");
      }
    }
#line 144
    a ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 148
  a = 0;
  {
#line 148
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 148
    if (! (a < population_size)) {
#line 148
      goto while_break___3;
    }
#line 149
    b = 0;
    {
#line 149
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 149
      if (! (b < GeneSize)) {
#line 149
        goto while_break___4;
      }
      {
#line 151
      tmp___5 = randint();
#line 151
      *((Pop1 + a)->gene + b) = (char )(48 + (tmp___5 & 1));
#line 149
      b ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 152
    *((Pop1 + a)->gene + GeneSize) = (char)0;
#line 148
    a ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 162
  return (0);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
void crossover(char *s1 , char *s2 ) 
{ 
  int point ;
  char duplic ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 171
  tmp = strlen((char const   *)s1);
#line 171
  tmp___0 = strlen((char const   *)s2);
  }
#line 171
  if (tmp != tmp___0) {
    {
#line 171
    GA_Error((char *)"Gene length mismatch for crossover");
    }
  }
  {
#line 173
  tmp___1 = randint();
#line 173
  tmp___2 = strlen((char const   *)s1);
#line 173
  point = (int )((unsigned long )tmp___1 % (tmp___2 - 2UL) + 1UL);
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 173
    tmp___3 = strlen((char const   *)s1);
    }
#line 173
    if (! ((size_t )point < tmp___3)) {
#line 173
      goto while_break;
    }
#line 175
    duplic = *(s1 + point);
#line 176
    *(s1 + point) = *(s2 + point);
#line 177
    *(s2 + point) = duplic;
#line 173
    point ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
void mutate(char *s1 ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 184
  tmp = randint();
#line 184
  tmp___0 = strlen((char const   *)s1);
#line 184
  *(s1 + (unsigned long )tmp % tmp___0) = (char )((int )*(s1 + (unsigned long )tmp % tmp___0) ^ 1);
  }
#line 185
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
int ga_simplex(char *s1 , char *s2 , char *s3 ) 
{ 
  int point ;
  size_t tmp ;

  {
#line 190
  point = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 190
    tmp = strlen((char const   *)s1);
    }
#line 190
    if (! ((size_t )point < tmp - 1UL)) {
#line 190
      goto while_break;
    }
#line 191
    if ((int )*(s1 + point) == (int )*(s2 + point)) {
#line 192
      *(s3 + point) = *(s1 + point);
    } else {
#line 194
      *(s3 + point) = (char )((int )*(s3 + point) ^ 1);
    }
#line 190
    point ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return (0);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
void swap(int *x , int *y ) 
{ 
  int t ;

  {
#line 201
  t = *x;
#line 202
  *x = *y;
#line 203
  *y = t;
#line 204
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
void Sort(void) 
{ 
  GeneRecord T ;
  int outer ;
  int inner ;
  int moved ;

  {
#line 211
  outer = population_size - 1;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (outer > 0)) {
#line 211
      goto while_break;
    }
#line 213
    moved = 0;
#line 214
    inner = 0;
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 214
      if (! (inner < outer)) {
#line 214
        goto while_break___0;
      }
#line 216
      if ((Pop1 + inner)->fitness < (Pop1 + (inner + 1))->fitness) {
        {
#line 218
        memcpy((void */* __restrict  */)((char *)(& T)), (void const   */* __restrict  */)((char *)(Pop1 + inner)),
               sizeof(GeneRecord ));
#line 219
        memcpy((void */* __restrict  */)((char *)(Pop1 + inner)), (void const   */* __restrict  */)((char *)(Pop1 + (inner + 1))),
               sizeof(GeneRecord ));
#line 220
        memcpy((void */* __restrict  */)((char *)(Pop1 + (inner + 1))), (void const   */* __restrict  */)((char *)(& T)),
               sizeof(GeneRecord ));
#line 221
        moved = 1;
        }
      }
#line 214
      inner ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 224
    if (moved == 0) {
#line 224
      goto while_break;
    }
#line 211
    outer --;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
void transloc(char *gene ) 
{ 
  int a ;
  int point ;
  int gene_size ;
  char *dup ;
  int tmp ;

  {
  {
#line 233
  gene_size = gene_length - 1;
#line 234
  tmp = randint();
#line 234
  point = tmp % gene_size;
#line 235
  dup = strdup((char const   *)gene);
#line 236
  a = 0;
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (a < gene_size)) {
#line 236
      goto while_break;
    }
#line 236
    *(gene + a) = *(dup + (a + point) % gene_size);
#line 236
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  free((void *)dup);
  }
#line 238
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic_algorithm_lib.c"
int Selection(FILE *fd , int gen ) 
{ 
  int a ;
  int b ;
  int c ;
  int d ;
  double sigma ;
  GeneRecord *temp ;
  double minfit ;
  double maxfit ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;

  {
#line 246
  sigma = 0.0;
#line 247
  minfit = (double )1.79769313486231570815e+308L;
#line 248
  maxfit = - minfit;
#line 250
  a = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (a < population_size)) {
#line 250
      goto while_break;
    }
    {
#line 252
    (Pop1 + a)->fitness = Objective((Pop1 + a)->gene);
    }
#line 253
    if ((Pop1 + a)->fitness < minfit) {
#line 253
      minfit = (Pop1 + a)->fitness;
    }
#line 254
    if ((Pop1 + a)->fitness > maxfit) {
#line 254
      maxfit = (Pop1 + a)->fitness;
    }
#line 255
    sigma += (Pop1 + a)->fitness;
#line 250
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  MX = maxfit;
#line 258
  Sort();
#line 259
  dump_pop1(fd, gen, maxfit, sigma / (double )population_size);
#line 260
  a = 0;
  }
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 260
    if (! (a < population_size)) {
#line 260
      goto while_break___0;
    }
#line 262
    if (minfit != maxfit) {
#line 264
      (Pop1 + a)->fitness = (((Pop1 + a)->fitness - minfit) * 99.0) / (maxfit - minfit) + 1.0;
    }
#line 260
    a ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 267
  ramp ++;
#line 268
  sigma = 0.0;
#line 269
  a = 0;
  {
#line 269
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 269
    if (! (a < population_size)) {
#line 269
      goto while_break___1;
    }
#line 270
    sigma += (Pop1 + a)->fitness;
#line 269
    a ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 271
  c = 0;
#line 272
  a = 0;
  {
#line 272
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 272
    if (! (a < population_size)) {
#line 272
      goto while_break___2;
    }
#line 274
    b = (int )(((Pop1 + a)->fitness * (double )population_size) / sigma);
#line 275
    d = 0;
    {
#line 275
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 275
      if (! (d < b)) {
#line 275
        goto while_break___3;
      }
      {
#line 276
      tmp = c;
#line 276
      c ++;
#line 276
      strcpy((char */* __restrict  */)(Pop2 + tmp)->gene, (char const   */* __restrict  */)(Pop1 + a)->gene);
#line 275
      d ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 272
    a ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 278
  d = c;
  {
#line 278
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 278
    if (! (d < population_size)) {
#line 278
      goto while_break___4;
    }
    {
#line 280
    tmp___0 = randint();
#line 280
    b = tmp___0 % population_size;
#line 281
    strcpy((char */* __restrict  */)(Pop2 + d)->gene, (char const   */* __restrict  */)(Pop1 + b)->gene);
#line 278
    d ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 283
  a = 0;
  {
#line 283
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 283
    if (! (a < population_size)) {
#line 283
      goto while_break___5;
    }
    {
#line 285
    tmp___1 = randreal();
    }
#line 285
    if (tmp___1 < pmutate) {
      {
#line 285
      mutate((Pop2 + a)->gene);
      }
    }
    {
#line 286
    tmp___2 = randreal();
    }
#line 286
    if (tmp___2 < ptrans) {
      {
#line 286
      transloc((Pop2 + a)->gene);
      }
    }
#line 283
    a ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 288
  temp = Pop1;
#line 289
  Pop1 = Pop2;
#line 290
  Pop2 = temp;
#line 291
  a = 2;
  {
#line 291
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 291
    if (! (a < population_size)) {
#line 291
      goto while_break___6;
    }
    {
#line 293
    tmp___3 = randint();
#line 293
    b = tmp___3 % population_size;
#line 294
    tmp___4 = randint();
#line 294
    c = tmp___4 % population_size;
#line 295
    strcpy((char */* __restrict  */)(Pop2 + a)->gene, (char const   */* __restrict  */)(Pop1 + b)->gene);
#line 296
    strcpy((char */* __restrict  */)(Pop2 + (a + 1))->gene, (char const   */* __restrict  */)(Pop1 + c)->gene);
#line 297
    tmp___5 = randreal();
    }
#line 297
    if (tmp___5 < pcross) {
      {
#line 299
      crossover((Pop2 + a)->gene, (Pop2 + (a + 1))->gene);
#line 300
      (Pop2 + a)->parent2 = (Pop2 + (a + 1))->parent1;
#line 301
      (Pop2 + (a + 1))->parent2 = (Pop2 + a)->parent1;
      }
    } else {
#line 303
      (Pop2 + a)->parent2 = (Pop2 + a)->parent1;
#line 304
      (Pop2 + (a + 1))->parent2 = (Pop2 + (a + 1))->parent1;
    }
#line 291
    a += 2;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 307
  tmp___9 = randreal();
  }
#line 307
  if (tmp___9 < psimplex) {
    {
#line 308
    tmp___6 = randint();
#line 308
    a = tmp___6 % population_size;
#line 309
    tmp___7 = randint();
#line 309
    b = tmp___7 % population_size;
#line 310
    tmp___8 = randint();
#line 310
    c = tmp___8 % population_size;
    }
#line 311
    if ((Pop1 + a)->fitness < (Pop1 + b)->fitness) {
      {
#line 312
      swap(& a, & b);
      }
    }
#line 313
    if ((Pop1 + b)->fitness < (Pop1 + c)->fitness) {
      {
#line 314
      swap(& b, & c);
      }
    }
#line 315
    if ((Pop1 + a)->fitness < (Pop1 + b)->fitness) {
      {
#line 316
      swap(& a, & b);
      }
    }
    {
#line 317
    ga_simplex((Pop1 + a)->gene, (Pop1 + b)->gene, (Pop2 + c)->gene);
    }
  }
#line 319
  temp = Pop1;
#line 320
  Pop1 = Pop2;
#line 321
  Pop2 = temp;
#line 322
  return (0);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/com_hack.h"
fcomplex Cadd(fcomplex a , fcomplex b ) ;
#line 26
fcomplex Csub(fcomplex a , fcomplex b ) ;
#line 27
fcomplex Cmul(fcomplex a , fcomplex b ) ;
#line 28
fcomplex Complex(double re , double im ) ;
#line 30
double Cabs(fcomplex z ) ;
#line 32
fcomplex RCmul(double x , fcomplex a ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/com_hack.c"
fcomplex Cadd(fcomplex a , fcomplex b ) 
{ 
  fcomplex c ;

  {
#line 14
  c.r = a.r + b.r;
#line 15
  c.i = a.i + b.i;
#line 16
  return (c);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/com_hack.c"
fcomplex Csub(fcomplex a , fcomplex b ) 
{ 
  fcomplex c ;

  {
#line 22
  c.r = a.r - b.r;
#line 23
  c.i = a.i - b.i;
#line 24
  return (c);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/com_hack.c"
fcomplex Cmul(fcomplex a , fcomplex b ) 
{ 
  fcomplex c ;

  {
#line 31
  c.r = a.r * b.r - a.i * b.i;
#line 32
  c.i = a.i * b.r + a.r * b.i;
#line 33
  return (c);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/com_hack.c"
fcomplex Complex(double re , double im ) 
{ 
  fcomplex c ;

  {
#line 39
  c.r = re;
#line 40
  c.i = im;
#line 41
  return (c);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/com_hack.c"
fcomplex Conjg(fcomplex z ) 
{ 
  fcomplex c ;

  {
#line 47
  c.r = z.r;
#line 48
  c.i = - z.i;
#line 49
  return (c);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/com_hack.c"
fcomplex Cdiv(fcomplex a , fcomplex b ) 
{ 
  fcomplex c ;
  double r ;
  double den ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 56
  tmp = fabs(b.r);
#line 56
  tmp___0 = fabs(b.i);
  }
#line 56
  if (tmp >= tmp___0) {
#line 57
    r = b.i / b.r;
#line 58
    den = b.r + r * b.i;
#line 59
    c.r = (a.r + r * a.i) / den;
#line 60
    c.i = (a.i - r * a.r) / den;
  } else {
#line 62
    r = b.r / b.i;
#line 63
    den = b.i + r * b.r;
#line 64
    c.r = (a.r * r + a.i) / den;
#line 65
    c.i = (a.i * r - a.r) / den;
  }
#line 67
  return (c);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/com_hack.c"
double Cabs(fcomplex z ) 
{ 
  double x ;
  double y ;
  double ans ;
  double temp ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 73
  x = fabs(z.r);
#line 74
  y = fabs(z.i);
  }
#line 75
  if (x == 0.0) {
#line 76
    ans = y;
  } else
#line 77
  if (y == 0.0) {
#line 78
    ans = x;
  } else
#line 79
  if (x > y) {
    {
#line 80
    temp = y / x;
#line 81
    tmp = sqrt(1.0 + temp * temp);
#line 81
    ans = x * tmp;
    }
  } else {
    {
#line 83
    temp = x / y;
#line 84
    tmp___0 = sqrt(1.0 + temp * temp);
#line 84
    ans = y * tmp___0;
    }
  }
#line 86
  return (ans);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/com_hack.c"
fcomplex Csqrt(fcomplex z ) 
{ 
  fcomplex c ;
  double x ;
  double y ;
  double w ;
  double r ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 93
  if (z.r == 0.0) {
#line 93
    if (z.i == 0.0) {
#line 94
      c.r = 0.0;
#line 95
      c.i = 0.0;
#line 96
      return (c);
    } else {
#line 93
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 98
    x = fabs(z.r);
#line 99
    y = fabs(z.i);
    }
#line 100
    if (x >= y) {
      {
#line 101
      r = y / x;
#line 102
      tmp = sqrt(x);
#line 102
      tmp___0 = sqrt(1.0 + r * r);
#line 102
      tmp___1 = sqrt(0.5 * (1.0 + tmp___0));
#line 102
      w = tmp * tmp___1;
      }
    } else {
      {
#line 104
      r = x / y;
#line 105
      tmp___2 = sqrt(y);
#line 105
      tmp___3 = sqrt(1.0 + r * r);
#line 105
      tmp___4 = sqrt(0.5 * (r + tmp___3));
#line 105
      w = tmp___2 * tmp___4;
      }
    }
#line 107
    if (z.r >= 0.0) {
#line 108
      c.r = w;
#line 109
      c.i = z.i / (2.0 * w);
    } else {
#line 111
      if (z.i >= (double )0) {
#line 111
        c.i = w;
      } else {
#line 111
        c.i = - w;
      }
#line 112
      c.r = z.i / (2.0 * c.i);
    }
#line 114
    return (c);
  }
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/com_hack.c"
fcomplex RCmul(double x , fcomplex a ) 
{ 
  fcomplex c ;

  {
#line 121
  c.r = x * a.r;
#line 122
  c.i = x * a.i;
#line 123
  return (c);
}
}
#line 389 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) drand48)(void) ;
#line 393
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) lrand48)(void) ;
#line 403
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand48)(long __seedval ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/random.c"
double randreal(void) 
{ 
  double tmp ;

  {
  {
#line 50
  tmp = drand48();
  }
#line 50
  return (tmp);
}
}
#line 54
double randnorm(void) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/random.c"
static short paired  =    (short)0;
#line 55 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/random.c"
static double second  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/random.c"
double randnorm(void) 
{ 
  double x ;
  double y ;
  double rad ;
  double fac ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 58
  paired = (short )(! paired);
#line 58
  if (paired) {
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 61
      tmp = randreal();
#line 61
      x = 2.0 * tmp - 1.0;
#line 62
      tmp___0 = randreal();
#line 62
      y = 2.0 * tmp___0 - 1.0;
#line 63
      rad = x * x + y * y;
      }
#line 60
      if (! (rad > 1.0)) {
#line 60
        rad = 0.0;
#line 60
        if (! rad) {
#line 60
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 65
    tmp___1 = log(rad);
#line 65
    fac = sqrt((2.0 * tmp___1) / rad);
#line 66
    second = x * fac;
#line 67
    paired = (short )(! paired);
    }
#line 68
    return (y * fac);
  } else {
#line 69
    return (second);
  }
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/random.c"
int randint(void) 
{ 
  long tmp ;

  {
  {
#line 75
  tmp = lrand48();
  }
#line 75
  return ((int )tmp / 65535);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/random.c"
void seedRNG(void) 
{ 
  long seed_time ;

  {
  {
#line 84
  time(& seed_time);
#line 86
  srand48(seed_time);
  }
#line 88
  return;
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/optimising_for.c"
void optimising_for(struct flags flag ) 
{ 
  int choice ;

  {
#line 15
  if (flag.gflg) {
    {
#line 17
    printf((char const   */* __restrict  */)"Will optimise using a genetic algorithm\n");
#line 18
    choice = flag.gflg;
    }
  } else
#line 20
  if (flag.Wflg) {
    {
#line 22
    printf((char const   */* __restrict  */)"Will optimise using a weighted combination of parameters\n");
#line 23
    choice = flag.Wflg;
    }
  } else
#line 25
  if (flag.wflg) {
    {
#line 27
    printf((char const   */* __restrict  */)"Will optimise over a wide band\n");
#line 28
    choice = flag.wflg;
    }
  } else {
    {
#line 32
    printf((char const   */* __restrict  */)"Will optimise insisting all selected parameters improve.\n");
#line 33
    choice = flag.oflg;
    }
  }
#line 35
  if ((choice & 1) == 1) {
    {
#line 36
    printf((char const   */* __restrict  */)"Optimising for maximum possible gain.\n");
    }
  }
#line 37
  if ((choice & 2) == 2) {
#line 37
    if ((choice & 32768) == 0) {
      {
#line 38
      printf((char const   */* __restrict  */)"Optimising for maximum possible FB ratio.\n");
      }
    }
  }
#line 39
  if ((choice & 2) == 2) {
#line 39
    if ((choice & 32768) == 32768) {
      {
#line 40
      printf((char const   */* __restrict  */)"Optimising for FB ratio to a maximum of %.3fdB.\n",
             max.fb);
      }
    }
  }
#line 41
  if ((choice & 4) == 4) {
#line 41
    if ((choice & 32768) == 0) {
      {
#line 42
      printf((char const   */* __restrict  */)"Optimising for an input resistance as close as possible to Z0.\n");
      }
    }
  }
#line 43
  if ((choice & 4) == 4) {
#line 43
    if ((choice & 32768) == 32768) {
      {
#line 44
      printf((char const   */* __restrict  */)"Optimising for an input resistance of Z0 +/- %.3f Ohms\n",
             max.r);
      }
    }
  }
#line 45
  if ((choice & 8) == 8) {
#line 45
    if ((choice & 32768) == 0) {
      {
#line 46
      printf((char const   */* __restrict  */)"Optimising for an input reactance as close as possible to zero.\n");
      }
    }
  }
#line 47
  if ((choice & 8) == 8) {
#line 47
    if ((choice & 32768) == 32768) {
      {
#line 48
      printf((char const   */* __restrict  */)"Optimising for an input reactance of 0 +/- %.3f Ohms\n",
             max.x);
      }
    }
  }
#line 49
  if ((choice & 16) == 16) {
#line 49
    if ((choice & 32768) == 32768) {
      {
#line 50
      printf((char const   */* __restrict  */)"Optimising for an input VSWR of less than %.3f:1\n",
             max.swr);
      }
    }
  }
#line 52
  if ((choice & 16) == 16) {
#line 52
    if ((choice & 32768) == 0) {
      {
#line 53
      printf((char const   */* __restrict  */)"Optimising for an input VSWR as low as possible\n");
      }
    }
  }
#line 55
  if ((choice & 32) == 32) {
#line 55
    if ((choice & 32768) == 0) {
      {
#line 56
      printf((char const   */* __restrict  */)"Optimising for the most significant side to be as small as possible.\n");
      }
    }
  }
#line 57
  if ((choice & 32) == 32) {
#line 57
    if ((choice & 32768) == 32768) {
      {
#line 58
      printf((char const   */* __restrict  */)"Optimising for the most significant sidelobe to be at least %.3f dB down\n",
             max.sidelobe);
      }
    }
  }
#line 59
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/better.c"
int is_it_better(int criteria , struct performance_data n , struct performance_data o ) 
{ 
  double resistance_error ;
  struct FCOMPLEX zi_new ;
  struct FCOMPLEX zi_old ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;

  {
  {
#line 18
  tmp = fabs(n.r - Zo);
#line 18
  tmp___0 = fabs(o.r - Zo);
#line 18
  resistance_error = tmp - tmp___0;
#line 19
  zi_new.r = n.r;
#line 20
  zi_old.r = o.r;
#line 21
  zi_new.i = n.x;
#line 22
  zi_old.i = o.x;
  }
#line 32
  if ((criteria & 32768) == 32768) {
#line 34
    if (n.fb > max.fb) {
#line 34
      if (n.fb < o.fb) {
#line 35
        n.fb = o.fb;
      }
    }
    {
#line 37
    tmp___1 = fabs(n.r - Zo);
    }
#line 37
    if (tmp___1 < max.r) {
      {
#line 37
      tmp___2 = fabs(n.r - Zo);
#line 37
      tmp___3 = fabs(o.r - Zo);
      }
#line 37
      if (tmp___2 > tmp___3) {
#line 40
        n.r = o.r;
      }
    }
#line 43
    if (n.swr < max.swr) {
#line 43
      if (n.swr > o.swr) {
#line 44
        n.swr = o.swr;
      }
    }
    {
#line 46
    tmp___4 = fabs(n.x);
    }
#line 46
    if (tmp___4 < max.x) {
      {
#line 46
      tmp___5 = fabs(n.x);
#line 46
      tmp___6 = fabs(o.x);
      }
#line 46
      if (tmp___5 > tmp___6) {
#line 48
        n.x = o.x;
      }
    }
#line 50
    if (n.sidelobe > max.sidelobe) {
#line 50
      if (n.sidelobe < o.sidelobe) {
#line 51
        n.sidelobe = o.sidelobe;
      }
    }
  }
#line 53
  if ((criteria & 1) == 1) {
#line 55
    if (n.gain < o.gain) {
#line 56
      return (0);
    }
  }
#line 58
  if ((criteria & 2) == 2) {
#line 60
    if (n.fb < o.fb) {
#line 61
      return (0);
    }
  }
#line 63
  if ((criteria & 4) == 4) {
    {
#line 65
    tmp___7 = fabs(n.r - Zo);
#line 65
    tmp___8 = fabs(o.r - Zo);
#line 65
    resistance_error = tmp___7 - tmp___8;
    }
#line 66
    if (resistance_error > 0.0) {
#line 67
      return (0);
    }
  }
#line 69
  if ((criteria & 8) == 8) {
    {
#line 71
    tmp___9 = fabs(n.x);
#line 71
    tmp___10 = fabs(o.x);
    }
#line 71
    if (tmp___9 > tmp___10) {
#line 72
      return (0);
    }
  }
#line 74
  if ((criteria & 16) == 16) {
#line 76
    if (n.swr > o.swr) {
#line 77
      return (0);
    }
  }
#line 79
  if ((criteria & 32) == 32) {
#line 81
    if (n.sidelobe < o.sidelobe) {
#line 82
      return (0);
    }
  }
#line 91
  return (1);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
double find_max_sidelobe_fast(double gain___0 , double pin___0 , struct element_data *coordinates___0 ,
                              struct FCOMPLEX *current___0 , int elements___0 , double frequency ,
                              double design_f___0 ) ;
#line 125
void reflection_coefficient(struct FCOMPLEX zi , double *magnitude___0 , double *phase___0 ) ;
#line 173
double get_genetic_algorithm_fitness(struct flags flag , double frequency , int driven ,
                                     int parasitic , double **driven_data , double **parasitic_data ,
                                     double *v , double **z , double *pin___0 , struct FCOMPLEX *voltage ,
                                     struct FCOMPLEX *current___0 , struct FCOMPLEX *input_impedance ,
                                     struct element_data *coordinates___0 , double **A ,
                                     double *b , int *indx , struct performance_data *data2 ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/fitness.c"
double get_genetic_algorithm_fitness(struct flags flag , double frequency , int driven ,
                                     int parasitic , double **driven_data , double **parasitic_data ,
                                     double *v , double **z , double *pin___0 , struct FCOMPLEX *voltage ,
                                     struct FCOMPLEX *current___0 , struct FCOMPLEX *input_impedance ,
                                     struct element_data *coordinates___0 , double **A ,
                                     double *b , int *indx , struct performance_data *data2 ) 
{ 
  double result ;
  double E_fwd ;
  double E_back ;
  double H_fwd ;
  double H_back ;
  double mag ;
  double phase___0 ;
  int elements___0 ;
  struct performance_data data ;
  struct performance_data start ;

  {
  {
#line 21
  start.gain = 0.0;
#line 22
  elements___0 = driven + parasitic;
#line 23
  solve_equations(frequency, driven, parasitic, driven_data, parasitic_data, v, z,
                  pin___0, voltage, current___0, input_impedance, coordinates___0,
                  A, b, indx);
#line 25
  gain((double )90, (double )0, *pin___0, 1.0, coordinates___0, current___0, elements___0,
       & E_fwd, & H_fwd, frequency, frequency);
#line 27
  gain((double )270, (double )0, *pin___0, 1.0, coordinates___0, current___0, elements___0,
       & E_back, & H_back, frequency, frequency);
#line 28
  data.gain = E_fwd;
#line 29
  data.fb = E_fwd - E_back;
#line 30
  data.r = input_impedance->r;
#line 31
  data.x = input_impedance->i;
#line 32
  reflection_coefficient(*input_impedance, & mag, & phase___0);
#line 33
  data.swr = calculate_vswr(mag);
  }
#line 34
  if ((flag.gflg & 32) == 32) {
    {
#line 35
    data.sidelobe = find_max_sidelobe_fast(E_fwd, *pin___0, coordinates___0, current___0,
                                           elements___0, frequency, frequency);
    }
  } else {
#line 38
    data.sidelobe = 0.0;
  }
  {
#line 39
  *data2 = data;
#line 40
  result = performance(flag, data, max, weight, start);
  }
#line 49
  return (result);
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/test_stop.c"
void test_for_stop_file(void) 
{ 
  int *tmp ;
  FILE *tmp___0 ;

  {
  {
#line 10
  tmp___0 = fopen((char const   */* __restrict  */)"stop", (char const   */* __restrict  */)"r");
  }
#line 10
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 12
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Remove the file \"stop\" first\n");
#line 13
    exit(1);
    }
  } else {
    {
#line 16
    tmp = __errno_location();
#line 16
    *tmp = 0;
    }
  }
#line 17
  return;
}
}
#line 60 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan2)(double __y ,
                                                                               double __x ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/reflection_coefficient.c"
void reflection_coefficient(struct FCOMPLEX zi , double *magnitude___0 , double *phase___0 ) 
{ 
  struct FCOMPLEX zo ;
  struct FCOMPLEX rho ;
  fcomplex tmp ;
  fcomplex tmp___0 ;

  {
  {
#line 15
  zo.r = Zo;
#line 16
  zo.i = (double )0;
#line 17
  tmp = Cadd(zi, zo);
#line 17
  tmp___0 = Csub(zi, zo);
#line 17
  rho = Cdiv(tmp___0, tmp);
#line 18
  *magnitude___0 = Cabs(rho);
#line 19
  *phase___0 = atan2(rho.i, rho.r);
  }
#line 27
  return;
}
}
#line 715 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
int opterr  =    1;
#line 37 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
int optind  =    1;
#line 38 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
static int optopt  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
char *optarg  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
void ERR(char *s , char c , char **argv ) 
{ 
  char errbuf[2] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 43
  if (opterr) {
    {
#line 46
    errbuf[0] = c;
#line 47
    errbuf[1] = (char )'\n';
#line 51
    tmp = strlen((char const   *)*(argv + 0));
#line 51
    fwrite((void const   */* __restrict  */)*(argv + 0), (size_t )((unsigned int )tmp),
           (size_t )1, (FILE */* __restrict  */)stderr);
#line 52
    tmp___0 = strlen((char const   *)s);
#line 52
    fwrite((void const   */* __restrict  */)s, (size_t )((unsigned int )tmp___0),
           (size_t )1, (FILE */* __restrict  */)stderr);
#line 53
    fwrite((void const   */* __restrict  */)(errbuf), (size_t )2, (size_t )1, (FILE */* __restrict  */)stderr);
    }
  }
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
char *index2(char *str , char c ) 
{ 
  char *ret ;

  {
  {
#line 60
  ret = strchr((char const   *)str, (int )c);
  }
#line 61
  return (ret);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
static int sp  =    1;
#line 65 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
int getoptions(int argc , char **argv , char *opts ) 
{ 
  register int c ;
  register char *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 71
  if (sp == 1) {
#line 72
    if (optind >= argc) {
#line 74
      return (-1);
    } else
#line 72
    if ((int )*(*(argv + optind) + 0) != 45) {
#line 74
      return (-1);
    } else
#line 72
    if ((int )*(*(argv + optind) + 1) == 0) {
#line 74
      return (-1);
    } else {
      {
#line 75
      tmp = strcmp((char const   *)*(argv + optind), "--");
      }
#line 75
      if (tmp == 0) {
#line 76
        optind ++;
#line 77
        return (-1);
      }
    }
  }
#line 79
  c = (int )*(*(argv + optind) + sp);
#line 79
  optopt = c;
#line 80
  if (c == 58) {
#line 80
    goto _L;
  } else {
    {
#line 80
    cp = index2(opts, (char )c);
    }
#line 80
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 81
      ERR((char *)": illegal option -- ", (char )c, argv);
#line 82
      sp ++;
      }
#line 82
      if ((int )*(*(argv + optind) + sp) == 0) {
#line 83
        optind ++;
#line 84
        sp = 1;
      }
#line 86
      return ('?');
    }
  }
#line 88
  cp ++;
#line 88
  if ((int )*cp == 58) {
#line 89
    if ((int )*(*(argv + optind) + (sp + 1)) != 0) {
#line 90
      tmp___0 = optind;
#line 90
      optind ++;
#line 90
      optarg = *(argv + tmp___0) + (sp + 1);
    } else {
#line 91
      optind ++;
#line 91
      if (optind >= argc) {
        {
#line 92
        ERR((char *)": option requires an argument -- ", (char )c, argv);
#line 93
        sp = 1;
        }
#line 94
        return ('?');
      } else {
#line 96
        tmp___1 = optind;
#line 96
        optind ++;
#line 96
        optarg = *(argv + tmp___1);
      }
    }
#line 97
    sp = 1;
  } else {
#line 99
    sp ++;
#line 99
    if ((int )*(*(argv + optind) + sp) == 0) {
#line 100
      sp = 1;
#line 101
      optind ++;
    }
#line 103
    optarg = (char *)((void *)0);
  }
#line 105
  return (c);
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/cis_hack.c"
void cisi(double x , double *ci___0 , double *si ) 
{ 
  int i ;
  int k___0 ;
  int odd ;
  double a ;
  double err ;
  double fact ;
  double sign ;
  double sum ;
  double sumc ;
  double sums ;
  double t ;
  double term ;
  fcomplex h ;
  fcomplex b ;
  fcomplex c ;
  fcomplex d ;
  fcomplex del ;
  fcomplex tmp ;
  fcomplex tmp___0 ;
  fcomplex tmp___1 ;
  fcomplex tmp___2 ;
  fcomplex tmp___3 ;
  fcomplex tmp___4 ;
  fcomplex tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  fcomplex tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;

  {
  {
#line 23
  t = fabs(x);
  }
#line 24
  if (t == 0.0) {
#line 25
    *si = 0.0;
#line 26
    *ci___0 = - 1.0 / 1.0e-30;
#line 27
    return;
  }
#line 29
  if (t > 2.0) {
    {
#line 30
    b = Complex(1.0, t);
#line 31
    c = Complex(1.0 / 1.0e-30, 0.0);
#line 32
    tmp = Complex(1.0, 0.0);
#line 32
    h = Cdiv(tmp, b);
#line 32
    d = h;
#line 33
    i = 2;
    }
    {
#line 33
    while (1) {
      while_continue: /* CIL Label */ ;
#line 33
      if (! (i <= 100)) {
#line 33
        goto while_break;
      }
      {
#line 34
      a = (double )(- (i - 1) * (i - 1));
#line 35
      tmp___0 = Complex(2.0, 0.0);
#line 35
      b = Cadd(b, tmp___0);
#line 36
      tmp___1 = RCmul(a, d);
#line 36
      tmp___2 = Cadd(tmp___1, b);
#line 36
      tmp___3 = Complex(1.0, 0.0);
#line 36
      d = Cdiv(tmp___3, tmp___2);
#line 37
      tmp___4 = Complex(a, 0.0);
#line 37
      tmp___5 = Cdiv(tmp___4, c);
#line 37
      c = Cadd(b, tmp___5);
#line 38
      del = Cmul(c, d);
#line 39
      h = Cmul(h, del);
#line 40
      tmp___6 = fabs(del.r - 1.0);
#line 40
      tmp___7 = fabs(del.i);
      }
#line 40
      if (tmp___6 + tmp___7 < 6.0e-8) {
#line 40
        goto while_break;
      }
#line 33
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 42
    if (i > 100) {
      {
#line 42
      nrerror((char *)"cf failed in cisi_hack.c");
      }
    }
    {
#line 43
    tmp___8 = sin(t);
#line 43
    tmp___9 = cos(t);
#line 43
    tmp___10 = Complex(tmp___9, - tmp___8);
#line 43
    h = Cmul(tmp___10, h);
#line 44
    *ci___0 = - h.r;
#line 45
    *si = 1.5707963 + h.i;
    }
  } else {
    {
#line 47
    tmp___12 = sqrt(1.0e-30);
    }
#line 47
    if (t < tmp___12) {
#line 48
      sumc = 0.0;
#line 49
      sums = t;
    } else {
#line 51
      sumc = 0.0;
#line 51
      sums = sumc;
#line 51
      sum = sums;
#line 52
      fact = 1.0;
#line 52
      sign = fact;
#line 53
      odd = 1;
#line 54
      k___0 = 1;
      {
#line 54
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 54
        if (! (k___0 <= 100)) {
#line 54
          goto while_break___0;
        }
        {
#line 55
        fact *= t / (double )k___0;
#line 56
        term = fact / (double )k___0;
#line 57
        sum += sign * term;
#line 58
        tmp___11 = fabs(sum);
#line 58
        err = term / tmp___11;
        }
#line 59
        if (odd) {
#line 60
          sign = - sign;
#line 61
          sums = sum;
#line 62
          sum = sumc;
        } else {
#line 64
          sumc = sum;
#line 65
          sum = sums;
        }
#line 67
        if (err < 6.0e-8) {
#line 67
          goto while_break___0;
        }
#line 68
        odd = ! odd;
#line 54
        k___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 70
      if (k___0 > 100) {
        {
#line 70
        nrerror((char *)"maxits exceeded in cisi");
        }
      }
    }
    {
#line 72
    *si = sums;
#line 73
    tmp___13 = log(t);
#line 73
    *ci___0 = (sumc + tmp___13) + 0.57721566;
    }
  }
#line 75
  if (x < 0.0) {
#line 75
    *si = - *si;
  }
#line 76
  return;
}
}
#line 100 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 115
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) modf)(double __x ,
                                                                              double *__iptr ) ;
#line 132 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
struct FCOMPLEX E_to_complex_power(struct FCOMPLEX x ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/gain.c"
void gain(double theta , double phi , double pin___0 , double F , struct element_data *coordinates___0 ,
          struct FCOMPLEX *current___0 , int elements___0 , double *gain_E_plane___0 ,
          double *gain_H_plane___0 , double actual_frequency , double design_frequency ) 
{ 
  int i ;
  double *r_E ;
  double *r_H ;
  double *g_E ;
  double *g_H ;
  double integer_bit ;
  double length___0 ;
  double x ;
  double y ;
  double lamda_design ;
  double lamda ;
  double tmp ;
  struct FCOMPLEX temp_E ;
  struct FCOMPLEX temp_H ;
  struct FCOMPLEX e_gain ;
  struct FCOMPLEX h_gain ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  fcomplex tmp___9 ;
  fcomplex tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;

  {
  {
#line 25
  r_E = dvector(1L, (long )elements___0);
#line 26
  r_H = dvector(1L, (long )elements___0);
#line 27
  g_E = dvector(1L, (long )elements___0);
#line 28
  g_H = dvector(1L, (long )elements___0);
#line 29
  e_gain.r = (double )0;
#line 30
  e_gain.i = (double )0;
#line 31
  h_gain.r = (double )0;
#line 32
  h_gain.i = (double )0;
#line 34
  theta = (theta * 3.14159265358979323846) / (double )180;
#line 35
  phi = (phi * 3.14159265358979323846) / (double )180;
#line 36
  lamda_design = 3e8 / design_frequency;
#line 37
  lamda = 3e8 / actual_frequency;
#line 38
  i = 1;
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! (i <= elements___0)) {
#line 38
      goto while_break;
    }
    {
#line 40
    length___0 = (coordinates___0 + i)->length / lamda;
#line 41
    x = (coordinates___0 + i)->x / lamda_design;
#line 42
    y = (coordinates___0 + i)->y / lamda_design;
#line 45
    tmp___0 = sin(theta);
#line 45
    *(r_E + i) = tmp___0 * x;
#line 46
    tmp___5 = fabs(theta);
    }
#line 46
    if (tmp___5 < 1e-10) {
#line 47
      *(g_E + i) = (double )0;
    } else {
      {
#line 49
      tmp___1 = cos(theta);
#line 49
      tmp___2 = cos((3.14159265358979323846 * length___0) * tmp___1);
#line 49
      tmp___3 = cos(3.14159265358979323846 * length___0);
#line 49
      tmp___4 = sin(theta);
#line 49
      *(g_E + i) = (tmp___2 - tmp___3) / tmp___4;
      }
    }
    {
#line 52
    tmp___6 = cos(phi);
#line 52
    tmp___7 = sin(phi);
#line 52
    *(r_H + i) = x * tmp___6 + y * tmp___7;
#line 53
    tmp___8 = cos(3.14159265358979323846 * length___0);
#line 53
    *(g_H + i) = (double )1 - tmp___8;
#line 55
    temp_E.r = (double )0;
#line 56
    temp_E.i = (((double )2 * 3.14159265358979323846) * *(r_E + i)) * F;
#line 57
    temp_E = E_to_complex_power(temp_E);
#line 59
    temp_H.r = (double )0;
#line 60
    temp_H.i = (((double )2 * 3.14159265358979323846) * *(r_H + i)) * F;
#line 61
    temp_H = E_to_complex_power(temp_H);
#line 64
    temp_E = Cmul(temp_E, *(current___0 + i));
#line 65
    temp_H = Cmul(temp_H, *(current___0 + i));
#line 68
    tmp___9 = RCmul(*(g_E + i), temp_E);
#line 68
    e_gain = Cadd(e_gain, tmp___9);
#line 69
    tmp___10 = RCmul(*(g_H + i), temp_H);
#line 69
    h_gain = Cadd(h_gain, tmp___10);
#line 38
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  tmp___14 = modf(theta / 3.14159265358979323846, & integer_bit);
  }
#line 77
  if (tmp___14 < 1e-10) {
#line 79
    *gain_E_plane___0 = - 150.0;
  } else {
    {
#line 77
    tmp___15 = fabs(theta - 3.14159265358979323846);
    }
#line 77
    if (tmp___15 < 1e-10) {
#line 79
      *gain_E_plane___0 = - 150.0;
    } else {
      {
#line 83
      tmp___11 = Cabs(e_gain);
#line 83
      tmp___12 = Cabs(e_gain);
#line 83
      tmp = ((tmp___11 * tmp___12) * (double )60) / pin___0;
#line 84
      tmp___13 = log10(tmp);
#line 84
      *gain_E_plane___0 = (double )10 * tmp___13;
      }
    }
  }
  {
#line 94
  tmp___16 = Cabs(h_gain);
#line 94
  tmp___17 = Cabs(h_gain);
#line 94
  tmp = ((tmp___16 * tmp___17) * (double )60) / pin___0;
#line 95
  tmp___18 = log10(tmp);
#line 95
  *gain_H_plane___0 = (double )10 * tmp___18;
#line 105
  free_dvector(r_E, 1L, (long )elements___0);
#line 106
  free_dvector(r_H, 1L, (long )elements___0);
#line 107
  free_dvector(g_E, 1L, (long )elements___0);
#line 108
  free_dvector(g_H, 1L, (long )elements___0);
  }
#line 117
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/gain.c"
struct FCOMPLEX E_to_complex_power(struct FCOMPLEX x ) 
{ 
  struct FCOMPLEX a ;
  struct FCOMPLEX answer ;
  double real ;

  {
  {
#line 125
  real = exp(x.r);
#line 128
  a.r = cos(x.i);
#line 129
  a.i = sin(x.i);
#line 130
  answer = RCmul(real, a);
  }
#line 131
  return (answer);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/auto.c"
void automatic_enhancement(struct flags flag , double frequency , double **driven_data ,
                           double **parasitic_data , int driven , int parasites ,
                           struct FCOMPLEX *voltage , struct FCOMPLEX *current___0 ,
                           struct FCOMPLEX *input_impedance , double *v , double **z ,
                           double **A , double *b , int *indx , struct element_data *coordinates___0 ) 
{ 
  int elements___0 ;
  int element ;
  double pin___0 ;
  double E_fwd ;
  double H_fwd ;
  double max_gain___0 ;
  double old_max ;

  {
#line 17
  E_fwd = (double )0;
#line 17
  max_gain___0 = 0.0;
#line 17
  old_max = 0.0;
#line 18
  elements___0 = driven + parasites;
#line 19
  element = flag.Aflg - 1000;
#line 20
  if (element > parasites - 1) {
    {
#line 22
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You have set the option \'-A%d\', which will maximise gain using director number %d, but there are only %d directors\n",
            element, element, parasites - 1);
#line 23
    exit(1);
    }
  }
#line 25
  if (element > 0) {
#line 27
    *(*(parasitic_data + (element + 1)) + 3) *= 0.90;
#line 28
    max_gain___0 = 0.0;
#line 29
    old_max = 0.0;
    {
#line 30
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 31
      *(*(parasitic_data + (element + 1)) + 3) *= 1.001;
#line 32
      solve_equations(frequency, driven, parasites, driven_data, parasitic_data, v,
                      z, & pin___0, voltage, current___0, input_impedance, coordinates___0,
                      A, b, indx);
#line 33
      gain(90.0, 0.0, pin___0, 1.0, coordinates___0, current___0, elements___0, & E_fwd,
           & H_fwd, frequency, frequency);
      }
#line 34
      if (E_fwd > max_gain___0) {
#line 36
        old_max = max_gain___0;
#line 37
        max_gain___0 = E_fwd;
      }
#line 30
      if (! (E_fwd > old_max)) {
#line 30
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 41
  if (element == -1) {
#line 43
    *(*(parasitic_data + 1) + 3) *= 0.90;
#line 44
    max_gain___0 = 0.0;
#line 45
    old_max = 0.0;
    {
#line 46
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 47
      *(*(parasitic_data + 1) + 3) *= 1.001;
#line 48
      solve_equations(frequency, driven, parasites, driven_data, parasitic_data, v,
                      z, & pin___0, voltage, current___0, input_impedance, coordinates___0,
                      A, b, indx);
#line 49
      gain(90.0, 0.0, pin___0, 1.0, coordinates___0, current___0, elements___0, & E_fwd,
           & H_fwd, frequency, frequency);
      }
#line 50
      if (E_fwd > max_gain___0) {
#line 52
        old_max = max_gain___0;
#line 53
        max_gain___0 = E_fwd;
      }
#line 46
      if (! (E_fwd > old_max)) {
#line 46
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 57
  if (element == 0) {
#line 59
    *(*(driven_data + 1) + 3) *= 0.90;
#line 60
    max_gain___0 = 0.0;
#line 61
    old_max = 0.0;
    {
#line 62
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 63
      *(*(driven_data + 1) + 3) *= 1.001;
#line 64
      solve_equations(frequency, driven, parasites, driven_data, parasitic_data, v,
                      z, & pin___0, voltage, current___0, input_impedance, coordinates___0,
                      A, b, indx);
#line 65
      gain(90.0, 0.0, pin___0, 1.0, coordinates___0, current___0, elements___0, & E_fwd,
           & H_fwd, frequency, frequency);
      }
#line 66
      if (E_fwd > max_gain___0) {
#line 68
        old_max = max_gain___0;
#line 69
        max_gain___0 = E_fwd;
      }
#line 62
      if (! (E_fwd > old_max)) {
#line 62
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 73
  return;
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/lud_hack.c"
void ludcmp(double **a , int n , int *indx , double *d ) 
{ 
  int i ;
  int imax ;
  int j ;
  int k___0 ;
  double big ;
  double dum ;
  double sum ;
  double temp ;
  double *vv ;
  double tmp ;

  {
  {
#line 16
  vv = dvector(1L, (long )n);
#line 17
  *d = 1.0;
#line 18
  i = 1;
  }
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! (i <= n)) {
#line 18
      goto while_break;
    }
#line 19
    big = 0.0;
#line 20
    j = 1;
    {
#line 20
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 20
      if (! (j <= n)) {
#line 20
        goto while_break___0;
      }
      {
#line 21
      temp = fabs(*(*(a + i) + j));
      }
#line 21
      if (temp > big) {
#line 21
        big = temp;
      }
#line 20
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 22
    if (big == 0.0) {
      {
#line 22
      nrerror((char *)"Singular matrix in routine ludcmp");
      }
    }
#line 23
    *(vv + i) = 1.0 / big;
#line 18
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 25
  j = 1;
  {
#line 25
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 25
    if (! (j <= n)) {
#line 25
      goto while_break___1;
    }
#line 26
    i = 1;
    {
#line 26
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 26
      if (! (i < j)) {
#line 26
        goto while_break___2;
      }
#line 27
      sum = *(*(a + i) + j);
#line 28
      k___0 = 1;
      {
#line 28
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 28
        if (! (k___0 < i)) {
#line 28
          goto while_break___3;
        }
#line 28
        sum -= *(*(a + i) + k___0) * *(*(a + k___0) + j);
#line 28
        k___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 29
      *(*(a + i) + j) = sum;
#line 26
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 31
    big = 0.0;
#line 32
    i = j;
    {
#line 32
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 32
      if (! (i <= n)) {
#line 32
        goto while_break___4;
      }
#line 33
      sum = *(*(a + i) + j);
#line 34
      k___0 = 1;
      {
#line 34
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 34
        if (! (k___0 < j)) {
#line 34
          goto while_break___5;
        }
#line 35
        sum -= *(*(a + i) + k___0) * *(*(a + k___0) + j);
#line 34
        k___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 36
      *(*(a + i) + j) = sum;
#line 37
      tmp = fabs(sum);
#line 37
      dum = *(vv + i) * tmp;
      }
#line 37
      if (dum >= big) {
#line 38
        big = dum;
#line 39
        imax = i;
      }
#line 32
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 42
    if (j != imax) {
#line 43
      k___0 = 1;
      {
#line 43
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 43
        if (! (k___0 <= n)) {
#line 43
          goto while_break___6;
        }
#line 44
        dum = *(*(a + imax) + k___0);
#line 45
        *(*(a + imax) + k___0) = *(*(a + j) + k___0);
#line 46
        *(*(a + j) + k___0) = dum;
#line 43
        k___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 48
      *d = - *d;
#line 49
      *(vv + imax) = *(vv + j);
    }
#line 51
    *(indx + j) = imax;
#line 52
    if (*(*(a + j) + j) == 0.0) {
#line 52
      *(*(a + j) + j) = 1.0e-20;
    }
#line 53
    if (j != n) {
#line 54
      dum = 1.0 / *(*(a + j) + j);
#line 55
      i = j + 1;
      {
#line 55
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 55
        if (! (i <= n)) {
#line 55
          goto while_break___7;
        }
#line 55
        *(*(a + i) + j) *= dum;
#line 55
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 25
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 58
  free_dvector(vv, 1L, (long )n);
  }
#line 59
  return;
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/nr_hack.h"
void lubksb(double **a , int n , int *indx , double *b ) ;
#line 185 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void mprove(double **a , double **alud , int n , int *indx , double *b , double *x ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/mpr_hack.c"
void mprove(double **a , double **alud , int n , int *indx , double *b , double *x ) 
{ 
  int j ;
  int i ;
  double sdp ;
  double *r ;

  {
  {
#line 12
  r = dvector(1L, (long )n);
#line 13
  i = 1;
  }
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13
    if (! (i <= n)) {
#line 13
      goto while_break;
    }
#line 14
    sdp = - *(b + i);
#line 15
    j = 1;
    {
#line 15
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 15
      if (! (j <= n)) {
#line 15
        goto while_break___0;
      }
#line 15
      sdp += *(*(a + i) + j) * *(x + j);
#line 15
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 16
    *(r + i) = sdp;
#line 13
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 18
  lubksb(alud, n, indx, r);
#line 19
  i = 1;
  }
  {
#line 19
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 19
    if (! (i <= n)) {
#line 19
      goto while_break___1;
    }
#line 19
    *(x + i) -= *(r + i);
#line 19
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 20
  free_dvector(r, 1L, (long )n);
  }
#line 21
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void print_z_matrix(double frequency , int elements___0 , double **z ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/print_z_matrix.c"
void print_z_matrix(double frequency , int elements___0 , double **z ) 
{ 
  int i ;
  int j ;

  {
  {
#line 10
  printf((char const   */* __restrict  */)"Z - Matrix at frequency = %f\n", frequency);
#line 11
  i = 1;
  }
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11
    if (! (i <= elements___0)) {
#line 11
      goto while_break;
    }
#line 13
    j = 1;
    {
#line 13
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 13
      if (! (j <= 2 * elements___0)) {
#line 13
        goto while_break___0;
      }
      {
#line 14
      printf((char const   */* __restrict  */)"% 7.2f ", *(*(z + i) + j));
#line 13
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 15
    printf((char const   */* __restrict  */)"\n");
#line 11
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 17
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void show_all_optimise_parameters(char *exefile , struct flags flag ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/show_all_optimise_parameters.c"
void show_all_optimise_parameters(char *exefile , struct flags flag ) 
{ 
  int choice ;
  double tmp ;

  {
  {
#line 19
  choice = flag.oflg;
#line 20
  tmp = version();
#line 20
  printf((char const   */* __restrict  */)"%s version %.2f\n", exefile, tmp);
#line 21
  printf((char const   */* __restrict  */)"Zo=%f Ohms \n", Zo);
#line 22
  printf((char const   */* __restrict  */)"Acceptable VSWR < %.3f:1\n", max.swr);
#line 23
  printf((char const   */* __restrict  */)"Acceptable FB > %.3f dB\n", max.fb);
#line 24
  printf((char const   */* __restrict  */)"Acceptable reactance < %.3f Ohms\n", max.x);
#line 25
  printf((char const   */* __restrict  */)"Acceptable resistance %.3f < R < %.3f Ohms\n",
         Zo - max.r, Zo + max.r);
#line 26
  printf((char const   */* __restrict  */)"Maximum percentage change between each iteration is %.6f%%\n",
         percent);
#line 27
  printf((char const   */* __restrict  */)"weight_gain=%.4f weight_fb=%.5f weight_swr=%.4f\n",
         weight.gain, weight.fb, weight.swr);
#line 28
  printf((char const   */* __restrict  */)"Type of elements moved/adjusted is %d\n",
         flag.eflg);
#line 29
  printf((char const   */* __restrict  */)"Default choice of optimisation method is %d\n",
         choice);
#line 30
  printf((char const   */* __restrict  */)"Boom will not extend by more than %.3f%%\n",
         boom_factor);
  }
#line 39
  return;
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/version.c"
double version(void) 
{ 
  double ver ;
  double tmp ;

  {
  {
#line 9
  tmp = atof("1.19");
#line 9
  ver = tmp;
  }
#line 10
  return (ver);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void mutual_impedance(int i , int j , double frequency , int driven , int parasitic ,
                      double **d , double **p , double **impedance ) ;
#line 116
void z21(double lamda , double d , double l , double *r21 , double *x21 ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/mutual.c"
void mutual_impedance(int i , int j , double frequency , int driven , int parasitic ,
                      double **d , double **p , double **impedance ) 
{ 
  double xi ;
  double yi ;
  double xj ;
  double yj ;
  double li ;
  double lj ;
  double s ;
  double lamda ;
  double real ;
  double imag ;
  double mean_length ;
  int col ;

  {
#line 15
  if (i <= driven) {
#line 17
    xi = *(*(d + i) + 1);
#line 18
    yi = *(*(d + i) + 2);
#line 19
    li = *(*(d + i) + 3);
  } else
#line 21
  if (i > driven) {
#line 23
    xi = *(*(p + (i - driven)) + 1);
#line 24
    yi = *(*(p + (i - driven)) + 2);
#line 25
    li = *(*(p + (i - driven)) + 3);
  }
#line 27
  if (j <= driven) {
#line 29
    xj = *(*(d + j) + 1);
#line 30
    yj = *(*(d + j) + 2);
#line 31
    lj = *(*(d + j) + 3);
  } else
#line 33
  if (j > driven) {
#line 35
    col = j - driven;
#line 36
    xj = *(*(p + col) + 1);
#line 37
    yj = *(*(p + col) + 2);
#line 38
    lj = *(*(p + col) + 3);
  }
  {
#line 41
  s = sqrt((xi - xj) * (xi - xj) + (yi - yj) * (yi - yj));
#line 42
  mean_length = (li + lj) / 2.0;
#line 43
  lamda = 3e8 / frequency;
#line 44
  z21(lamda, s, mean_length, & real, & imag);
#line 46
  *(*(impedance + i) + (2 * j - 1)) = real;
#line 47
  *(*(impedance + i) + 2 * j) = imag;
#line 48
  *(*(impedance + j) + (2 * i - 1)) = real;
#line 49
  *(*(impedance + j) + 2 * i) = imag;
  }
#line 58
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/mutual.c"
void z21(double lamda , double d , double l , double *r21 , double *x21 ) 
{ 
  double b ;
  double cos_bl ;
  double sin_bl ;
  double sin_bl_over_2 ;
  double cos_bl_over_2 ;
  double c ;
  double s ;
  double t1 ;
  double t2 ;
  double t3 ;
  double t4 ;
  double si_t1 ;
  double ci_t1 ;
  double si_t4 ;
  double ci_t4 ;
  double ci_bd ;
  double si_bd ;
  double ci_t2 ;
  double si_t2 ;
  double ci_t3 ;
  double si_t3 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 72
  b = (3.14159265358979323846 * (double )2) / lamda;
#line 73
  tmp = sqrt(d * d + l * l);
#line 73
  t1 = b * (tmp + l);
#line 74
  tmp___0 = sqrt(((double )4 * d) * d + l * l);
#line 74
  t2 = (0.5 * b) * (tmp___0 - l);
#line 75
  tmp___1 = sqrt(((double )4 * d) * d + l * l);
#line 75
  t3 = (0.5 * b) * (tmp___1 + l);
#line 76
  tmp___2 = sqrt(d * d + l * l);
#line 76
  t4 = b * (tmp___2 - l);
#line 79
  cos_bl = cos(b * l);
#line 80
  sin_bl = sin(b * l);
#line 81
  sin_bl_over_2 = sin((b * l) / (double )2);
#line 82
  cos_bl_over_2 = cos((b * l) / (double )2);
#line 83
  s = sin_bl_over_2 * sin_bl_over_2;
#line 84
  c = cos_bl_over_2 * cos_bl_over_2;
#line 86
  cisi(t1, & ci_t1, & si_t1);
#line 87
  cisi(t2, & ci_t2, & si_t2);
#line 88
  cisi(t3, & ci_t3, & si_t3);
#line 89
  cisi(t4, & ci_t4, & si_t4);
#line 90
  cisi(b * d, & ci_bd, & si_bd);
#line 93
  *r21 = ((double )30 / s) * (((((double )2 * ((double )2 + cos_bl)) * ci_bd - ((double )4 * c) * (ci_t2 + ci_t3)) + cos_bl * (ci_t4 + ci_t1)) + sin_bl * (((si_t1 - si_t4) - (double )2 * si_t3) + (double )2 * si_t2));
#line 100
  *x21 = ((double )30 / s) * (((((double )-2 * ((double )2 + cos_bl)) * si_bd + ((double )4 * c) * (si_t2 + si_t3)) - cos_bl * (si_t4 + si_t1)) + sin_bl * (((ci_t1 - ci_t4) - (double )2 * ci_t3) + (double )2 * ci_t2));
  }
#line 111
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void copy_complex_data_to_real_matrix(int elements___0 , double **z , double **A ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/copy_matrix.c"
void copy_matrix(int length___0 , int width , double **to , double **from ) 
{ 
  int i ;
  int j ;

  {
#line 11
  i = 1;
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11
    if (! (i <= length___0)) {
#line 11
      goto while_break;
    }
#line 13
    j = 1;
    {
#line 13
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 13
      if (! (j <= width)) {
#line 13
        goto while_break___0;
      }
#line 15
      *(*(to + i) + j) = *(*(from + i) + j);
#line 13
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 26
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/copy_matrix.c"
void copy_complex_data_to_real_matrix(int elements___0 , double **z , double **A ) 
{ 
  int i ;
  int j ;

  {
#line 43
  i = 1;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (i <= elements___0)) {
#line 43
      goto while_break;
    }
#line 45
    j = 1;
    {
#line 45
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 45
      if (! (j <= elements___0)) {
#line 45
        goto while_break___0;
      }
#line 47
      *(*(A + i) + j) = *(*(z + i) + (2 * j - 1));
#line 48
      *(*(A + (i + elements___0)) + (j + elements___0)) = *(*(z + i) + (2 * j - 1));
#line 49
      *(*(A + i) + (j + elements___0)) = - *(*(z + i) + 2 * j);
#line 50
      *(*(A + (i + elements___0)) + j) = *(*(z + i) + 2 * j);
#line 45
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 43
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
double ss2r(char *string___0 , int pos , int len ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double **data_driveng  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double **data_parasiticg  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double *vg  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double **zg  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double **Ag  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double *bg  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double *ping  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double design_frequencyg  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
int driveng  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
int parasiticg  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
int *indxg  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
int elementsg  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
struct FCOMPLEX *voltageg  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
struct FCOMPLEX *currentg  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
struct FCOMPLEX *input_impedanceg  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
struct element_data *coordinatesg  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double lambda  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
struct performance_data *mean_performanceg  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
struct flags flagg  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
char *output_filenameg  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
char *update_filenameg  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double min_frequencyg  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double max_frequencyg  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double step_frequencyg  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double angular_stepg  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
int k  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
void genetic_algorithm(char *output_filename , char *update_filename , struct flags flag ,
                       double design_frequency , double min_frequency , double max_frequency ,
                       double step_frequency , double angular_step , int driven ,
                       int parasitic , double **data_driven , double **data_parasitic ,
                       double *v , double **z , double *pin___0 , struct FCOMPLEX *voltage ,
                       struct FCOMPLEX *current___0 , struct FCOMPLEX *input_impedance ,
                       struct element_data *coordinates___0 , double **A , double *b ,
                       int *indx , struct performance_data *mean_performance ) 
{ 
  int elements___0 ;

  {
#line 44
  elements___0 = driven + parasitic;
#line 46
  data_driveng = data_driven;
#line 47
  data_parasiticg = data_parasitic;
#line 48
  ping = pin___0;
#line 49
  mean_performanceg = mean_performance;
#line 50
  vg = v;
#line 51
  zg = z;
#line 52
  Ag = A;
#line 53
  bg = b;
#line 54
  voltageg = voltage;
#line 55
  currentg = current___0;
#line 56
  elementsg = elements___0;
#line 57
  input_impedanceg = input_impedance;
#line 58
  coordinatesg = coordinates___0;
#line 59
  indxg = indx;
#line 60
  driveng = driven;
#line 61
  flagg = flag;
#line 62
  parasiticg = parasitic;
#line 63
  design_frequencyg = design_frequency;
#line 64
  min_frequencyg = min_frequency;
#line 65
  max_frequencyg = max_frequency;
#line 66
  step_frequencyg = step_frequency;
#line 67
  angular_stepg = angular_step;
#line 68
  output_filenameg = output_filename;
#line 69
  update_filenameg = update_filename;
#line 70
  if (popsize == 0) {
#line 71
    popsize = 40;
  }
  {
#line 73
  lambda = 3e8 / design_frequency;
#line 79
  Initialise(popsize, 16 * elements___0 - 8);
#line 80
  SetPrint(0);
#line 81
  k = 1;
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (k <= iterations)) {
#line 81
      goto while_break;
    }
    {
#line 84
    SetPrint(0);
#line 87
    end_if_stop_exists(& k, iterations, 5);
#line 88
    Selection(stdout, k);
#line 81
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  GA_Free();
  }
#line 91
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
static double max_fitness  =    (double )0;
#line 98 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
static int run_first_time___0  =    1;
#line 93 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double Objective(char *gene ) 
{ 
  int i ;
  double fitness ;
  double lmax ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 99
  if (run_first_time___0 == 1) {
    {
#line 101
    max_fitness = get_genetic_algorithm_fitness(flagg, design_frequencyg, driveng,
                                                parasiticg, data_driveng, data_parasiticg,
                                                vg, zg, ping, voltageg, currentg,
                                                input_impedanceg, coordinatesg, Ag,
                                                bg, indxg, mean_performanceg);
#line 102
    do_since_better(0, output_filenameg, update_filenameg, *input_impedanceg, *mean_performanceg,
                    flagg, (char *)"Optimised with the genetic algorithm", design_frequencyg,
                    min_frequencyg, max_frequencyg, step_frequencyg, elementsg, driveng,
                    parasiticg, angular_stepg, data_driveng, data_parasiticg, 1.0,
                    max_fitness);
#line 103
    run_first_time___0 = 0;
    }
  }
  {
#line 105
  *(*(data_parasiticg + 1) + 1) = 0.0;
#line 107
  tmp = ss2r(gene, 0, 8);
#line 107
  *(*(data_parasiticg + 1) + 3) = (tmp * (0.50 - 0.45) + 0.45) * lambda;
#line 108
  i = 1;
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (i <= driveng)) {
#line 108
      goto while_break;
    }
    {
#line 110
    tmp___0 = ss2r(gene, 8, 8);
#line 110
    *(*(data_driveng + i) + 1) = (tmp___0 * (0.42 - 0.05) + 0.05) * lambda;
#line 111
    tmp___1 = ss2r(gene, 16, 8);
#line 111
    *(*(data_driveng + i) + 3) = (tmp___1 * (0.50 - 0.40) + 0.40) * lambda;
#line 108
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  lmax = 0.50;
#line 117
  i = 2;
  {
#line 117
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 117
    if (! (i <= parasiticg)) {
#line 117
      goto while_break___0;
    }
#line 119
    if (i == 2) {
      {
#line 120
      tmp___2 = ss2r(gene, 16 * i - 8, 8);
#line 120
      *(*(data_parasiticg + i) + 1) = *(*(data_driveng + 1) + 1) + (tmp___2 * (0.42 - 0.05) + 0.05) * lambda;
      }
    } else {
      {
#line 122
      tmp___3 = ss2r(gene, 16 * i - 8, 8);
#line 122
      *(*(data_parasiticg + i) + 1) = *(*(data_parasiticg + (i - 1)) + 1) + (tmp___3 * (0.42 - 0.05) + 0.05) * lambda;
      }
    }
    {
#line 123
    tmp___4 = ss2r(gene, 16 * i - 8, 8);
#line 123
    *(*(data_parasiticg + i) + 3) = (tmp___4 * (lmax - 0.35) + 0.35) * lambda;
#line 125
    lmax = *(*(data_parasiticg + i) + 3) / lambda;
    }
#line 126
    if (lmax > 0.50) {
#line 127
      lmax = 0.50;
    }
#line 117
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 130
  fitness = get_genetic_algorithm_fitness(flagg, design_frequencyg, driveng, parasiticg,
                                          data_driveng, data_parasiticg, vg, zg, ping,
                                          voltageg, currentg, input_impedanceg, coordinatesg,
                                          Ag, bg, indxg, mean_performanceg);
  }
#line 131
  if (fitness > max_fitness) {
    {
#line 133
    max_fitness = fitness;
#line 134
    do_since_better(k, output_filenameg, update_filenameg, *input_impedanceg, *mean_performanceg,
                    flagg, (char *)"Optimised with the genetic algorithm", design_frequencyg,
                    min_frequencyg, max_frequencyg, step_frequencyg, elementsg, driveng,
                    parasiticg, angular_stepg, data_driveng, data_parasiticg, 1.0,
                    fitness);
    }
  }
#line 144
  return (fitness);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/genetic.c"
double ss2r(char *string___0 , int pos , int len ) 
{ 
  double result ;
  double x ;
  int loop ;

  {
#line 152
  result = (double )0;
#line 153
  loop = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (loop < len)) {
#line 153
      goto while_break;
    }
#line 154
    result = ((result + result) + (double )*(string___0 + (pos + loop))) - (double )48;
#line 153
    loop ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  x = (result + (double )1) / (double )(1 << 8);
#line 157
  return (x);
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/subtract_structures.c"
struct performance_data subtract_structures(struct performance_data a , struct performance_data b ) 
{ 
  struct performance_data ans ;

  {
#line 12
  ans.gain = a.gain - b.gain;
#line 13
  ans.fb = a.fb - b.fb;
#line 14
  ans.swr = a.swr - b.swr;
#line 15
  ans.r = a.r - b.r;
#line 16
  ans.x = a.x - b.x;
#line 17
  ans.sidelobe = a.sidelobe - b.sidelobe;
#line 18
  return (ans);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void write_input_data_to_disk(FILE *fp , char *notes , double frequency , double min_f ,
                              double max_f , double step_f , int elements___0 , int driven ,
                              int parasitic , double angular_step , double **d , double **p ,
                              double scale_factor ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/write_input_data.c"
void write_input_data_to_disk(FILE *fp , char *notes , double frequency , double min_f ,
                              double max_f , double step_f , int elements___0 , int driven ,
                              int parasitic , double angular_step , double **d , double **p ,
                              double scale_factor ) 
{ 
  int i ;

  {
  {
#line 10
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"NOTES %s\n",
          notes);
#line 11
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"FREQUENCY %f\n",
          frequency);
#line 12
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"MIN_FREQUENCY %f\n",
          min_f);
#line 13
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"MAX_FREQUENCY %f\n",
          max_f);
#line 14
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"STEP_FREQUENCY %f\n",
          step_f);
#line 15
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"ELEMENTS %d\n",
          elements___0);
#line 16
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"DRIVEN %d\n",
          driven);
#line 17
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"PARASITIC %d\n",
          elements___0 - driven);
#line 18
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"ANGULAR_STEP   %f\n",
          angular_step);
#line 19
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#DATA_DRIVEN        x         y       length     diameter voltage(r) voltage(i)\n");
#line 20
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"DATA_DRIVEN ");
#line 21
  i = 1;
  }
  {
#line 21
  while (1) {
    while_continue: /* CIL Label */ ;
#line 21
    if (! (i <= driven)) {
#line 21
      goto while_break;
    }
    {
#line 22
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %10.5f %10.5f %10.5f %10.5f %10.5f %10.5f",
            *(*(d + i) + 1) / scale_factor, *(*(d + i) + 2) / scale_factor, *(*(d + i) + 3) / scale_factor,
            *(*(d + i) + 4) / scale_factor, *(*(d + i) + 5), *(*(d + i) + 6));
#line 21
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 23
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n#DATA_PARASITIC     x         y       length     diameter\n");
#line 24
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"DATA_PARASITIC\n");
#line 25
  i = 1;
  }
  {
#line 25
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 25
    if (! (i <= elements___0 - driven)) {
#line 25
      goto while_break___0;
    }
#line 27
    if (i == 1) {
      {
#line 28
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"             %10.5f %10.5f %10.5f %10.5f reflector\n",
              *(*(p + i) + 1) / scale_factor, *(*(p + i) + 2) / scale_factor, *(*(p + i) + 3) / scale_factor,
              *(*(p + i) + 4) / scale_factor);
      }
    } else {
      {
#line 30
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"             %10.5f %10.5f %10.5f %10.5f D%d\n",
              *(*(p + i) + 1) / scale_factor, *(*(p + i) + 2) / scale_factor, *(*(p + i) + 3) / scale_factor,
              *(*(p + i) + 4) / scale_factor, i - 1);
      }
    }
#line 25
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 32
  return;
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/self.c"
void self_impedance(int i , double frequency , int driven , int parasitic , double **data ,
                    double **impedance ) 
{ 
  int j ;
  int row ;
  int column_real ;
  int column_imag ;
  int max_data ;
  int ii ;
  double lambda___0 ;
  double x ;
  double length___0 ;
  double diameter___0 ;
  double radius ;
  double real ;

  {
#line 18
  ii = i;
#line 24
  lambda___0 = 3e8 / frequency;
#line 26
  row = i;
#line 27
  column_real = 2 * i - 1;
#line 28
  column_imag = 2 * i;
#line 29
  if (i <= driven) {
#line 31
    max_data = 6;
  } else
#line 33
  if (i > driven) {
#line 35
    max_data = 4;
#line 36
    i -= driven;
  }
  {
#line 38
  diameter___0 = *(*(data + i) + 4);
#line 39
  length___0 = *(*(data + i) + 3);
#line 40
  j = 2 * ii - 1;
#line 42
  radius = diameter___0 / 2.0;
#line 43
  self(radius, length___0, lambda___0, & real, & x);
#line 44
  *(*(impedance + row) + column_imag) = x;
#line 45
  *(*(impedance + ii) + j) = real;
  }
#line 46
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/dobetter.c"
static int run_first_time___1  =    1;
#line 11 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/dobetter.c"
void do_since_better(int i , char *output_filename , char *update_filename , struct FCOMPLEX input_impedance ,
                     struct performance_data n , struct flags flag , char *notes ,
                     double frequency , double min_frequency , double max_frequency ,
                     double step_frequency , int elements___0 , int driven , int parasitic ,
                     double angular_step , double **driven_data , double **parasitic_data ,
                     double scale_factor , double new_perf ) 
{ 
  FILE *fp_out ;
  FILE *update_fp ;
  int print_fitnessQ ;

  {
#line 17
  n.r = input_impedance.r;
#line 17
  n.x = input_impedance.i;
#line 18
  if (flag.Wflg) {
#line 19
    print_fitnessQ = 1;
  } else
#line 18
  if (flag.gflg) {
#line 19
    print_fitnessQ = 1;
  } else {
#line 21
    print_fitnessQ = 0;
  }
  {
#line 22
  print_relavent_performance_data(stdout, (char *)"", i, flag, n, new_perf, 1, print_fitnessQ);
#line 23
  update_fp = fopen((char const   */* __restrict  */)update_filename, (char const   */* __restrict  */)"a");
  }
#line 24
  if (run_first_time___1 == 1) {
#line 24
    if (flag.wflg) {
      {
#line 25
      fprintf((FILE */* __restrict  */)update_fp, (char const   */* __restrict  */)"Optimised for wide-band use\n");
      }
    }
  }
#line 26
  if (run_first_time___1 == 1) {
#line 26
    if (flag.gflg) {
      {
#line 27
      fprintf((FILE */* __restrict  */)update_fp, (char const   */* __restrict  */)"Optimised With the genetic algoritm\n");
      }
    }
  }
  {
#line 28
  run_first_time___1 = 0;
#line 30
  print_relavent_performance_data(update_fp, (char *)"", i, flag, n, new_perf, 1,
                                  print_fitnessQ);
#line 31
  fclose(update_fp);
#line 34
  fp_out = fopen((char const   */* __restrict  */)output_filename, (char const   */* __restrict  */)"wt");
#line 35
  write_input_data_to_disk(fp_out, notes, frequency / 1e6, min_frequency / 1e6, max_frequency / 1e6,
                           step_frequency / 1e6, elements___0, driven, parasitic,
                           angular_step, driven_data, parasitic_data, scale_factor);
#line 36
  fclose(fp_out);
  }
#line 45
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/error_message.c"
void error_message(char *str ) 
{ 


  {
  {
#line 9
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)str);
  }
#line 10
  return;
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/linear.c"
int linear_current_optimisation_test(struct FCOMPLEX *cur , double *old_sd , int elements___0 ,
                                     int parasites , struct flags flag ) 
{ 
  double mean ;
  double SD ;
  double current_on_this_element ;
  double sum_of_squares ;
  double total_I ;
  int total_elements_tested ;
  int k___0 ;
  double tmp ;
  double tmp___0 ;

  {
#line 16
  sum_of_squares = 0.0;
#line 16
  total_I = 0.0;
#line 18
  total_elements_tested = flag.Cflg;
#line 19
  if (total_elements_tested > elements___0 - 1) {
    {
#line 21
    printf((char const   */* __restrict  */)"We can only try to get the currents similar on the %d elements, and we dont have the %d elements that you requsted via the -C option\n",
           elements___0 - 1, flag.Cflg);
#line 22
    exit(1);
    }
  }
#line 24
  k___0 = elements___0;
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if (! (k___0 > elements___0 - total_elements_tested)) {
#line 24
      goto while_break;
    }
    {
#line 26
    current_on_this_element = sqrt((cur + k___0)->r * (cur + k___0)->r + (cur + k___0)->i * (cur + k___0)->i);
#line 27
    total_I += current_on_this_element;
#line 24
    k___0 --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  mean = total_I / (double )total_elements_tested;
#line 32
  k___0 = elements___0;
  {
#line 32
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 32
    if (! (k___0 >= elements___0 - total_elements_tested)) {
#line 32
      goto while_break___0;
    }
    {
#line 34
    tmp = sqrt((cur + k___0)->r * (cur + k___0)->r + (cur + k___0)->i * (cur + k___0)->i);
#line 34
    tmp___0 = pow(tmp - mean, 2.0);
#line 34
    sum_of_squares += tmp___0;
#line 32
    k___0 --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 36
  SD = sum_of_squares / (double )(elements___0 - 1);
#line 37
  if (SD < *old_sd) {
#line 39
    *old_sd = SD;
#line 40
    return (1);
  } else {
#line 43
    return (0);
  }
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
double gaussian(void) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/sens.c"
void sensitivity(double boom_sd___0 , double length_sd___0 , double **driven_data ,
                 double **parasitic_data , int driven , int parasites ) 
{ 
  int i ;
  double x ;
  double y ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  {
#line 23
  x = *(*(parasitic_data + 1) + 3);
#line 24
  tmp = gaussian();
#line 24
  *(*(parasitic_data + 1) + 3) += (length_sd___0 * 0.001) * tmp;
#line 25
  y = *(*(parasitic_data + 1) + 3);
#line 27
  i = 2;
  }
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    if (! (i <= parasites)) {
#line 27
      goto while_break;
    }
    {
#line 29
    tmp___0 = gaussian();
#line 29
    *(*(parasitic_data + i) + 1) += (boom_sd___0 * 0.001) * tmp___0;
#line 30
    tmp___1 = gaussian();
#line 30
    *(*(parasitic_data + i) + 3) += (length_sd___0 * 0.001) * tmp___1;
#line 27
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 32
  i = 1;
  {
#line 32
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 32
    if (! (i <= driven)) {
#line 32
      goto while_break___0;
    }
    {
#line 34
    tmp___2 = gaussian();
#line 34
    *(*(driven_data + i) + 1) += (boom_sd___0 * 0.001) * tmp___2;
#line 35
    tmp___3 = gaussian();
#line 35
    *(*(driven_data + i) + 3) += (length_sd___0 * 0.001) * tmp___3;
#line 32
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 46
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/ci.c"
double ci(double x ) 
{ 
  double null ;
  double result ;

  {
  {
#line 11
  cisi(x, & result, & null);
  }
#line 12
  return (result);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/check_flags.c"
void check_flags(struct flags flag , int argc , int optind___0 , char *exefilename ) 
{ 


  {
#line 14
  if (flag.errflg == 1) {
    {
#line 15
    usage_optimise(exefilename);
    }
  }
#line 16
  if (flag.hflg == 1) {
    {
#line 17
    usage_optimise(exefilename);
    }
  }
#line 18
  if (flag.dflg == 1) {
    {
#line 19
    show_all_optimise_parameters(exefilename, flag);
    }
  }
#line 21
  if (flag.gflg == 1) {
#line 21
    if (flag.Wflg == 1) {
      {
#line 23
      error_message((char *)"\nThe genetic algorithm invoked with the \'-g\' option must, due to the very nature of genetic algorithms, use a weighted combination of parameters. You need not (nor are you allowed too) specify the \'-W\' and \'-g\' options together.\n");
#line 24
      exit(1);
      }
    }
  }
#line 26
  if (flag.gflg) {
#line 26
    if (flag.rflg) {
      {
#line 28
      error_message((char *)"\nYou can not specify the genetic algorithm flag \'-g\' and also specify the resistance flag \'-r\' at the same time.\n");
#line 29
      exit(1);
      }
    }
  }
#line 31
  if (flag.gflg) {
#line 31
    if (flag.sflg) {
      {
#line 33
      error_message((char *)"\nYou can not specify the genetic algorithm flag \'-g\' and also specify the swr flag \'-s\' at the same time. To alter the genetic algorithms behaviour with reguard to swr, change the swr weight with the \'-S\' flag.\n");
#line 34
      exit(1);
      }
    }
  }
#line 36
  if (flag.gflg) {
#line 36
    if (flag.lflg) {
      {
#line 38
      error_message((char *)"\nYou can not specify the genetic algorithm flag \'-g\' and also specify the flag \'-l\' at the same time.\n");
#line 39
      exit(1);
      }
    }
  }
#line 41
  if (flag.tflg) {
#line 41
    if (! flag.Tflg) {
      {
#line 43
      error_message((char *)"\nThe options \'-t\' and \'-T\' must both be used together. They can not be used with any other options\n");
#line 44
      exit(1);
      }
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 41
  if (flag.Tflg) {
#line 41
    if (! flag.tflg) {
      {
#line 43
      error_message((char *)"\nThe options \'-t\' and \'-T\' must both be used together. They can not be used with any other options\n");
#line 44
      exit(1);
      }
    }
  }
#line 46
  if (flag.tflg) {
#line 46
    if (flag.bflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.cflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.fflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.gflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.hflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.oflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.pflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.lflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.rflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.sflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.xflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.Fflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.Gflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.Rflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.Cflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.Sflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    } else
#line 46
    if (flag.Wflg) {
      {
#line 52
      error_message((char *)"The flags \'-t\' and \'-T\' can not be used with one of the other options specified. The only option allowed with them is \'-Z\' to fix the charaterisitc impedance, \'-d\'  or \'-v\'\n");
#line 53
      exit(1);
      }
    }
  }
#line 55
  if (flag.cflg) {
#line 55
    if (! flag.gflg) {
#line 55
      if (! flag.Wflg) {
        {
#line 57
        error_message((char *)"The flag \'-c\' can only be used with the \'-W\' or \'-g\' flags\n");
#line 58
        exit(1);
        }
      }
    }
  }
#line 60
  if (flag.Fflg) {
#line 60
    goto _L___0;
  } else
#line 60
  if (flag.Gflg) {
#line 60
    goto _L___0;
  } else
#line 60
  if (flag.Rflg) {
#line 60
    goto _L___0;
  } else
#line 60
  if (flag.Pflg) {
#line 60
    goto _L___0;
  } else
#line 60
  if (flag.Sflg) {
#line 60
    goto _L___0;
  } else
#line 60
  if (flag.Xflg) {
    _L___0: /* CIL Label */ 
#line 60
    if (! flag.gflg) {
#line 60
      if (! flag.Wflg) {
        {
#line 62
        error_message((char *)"The weight flags (F, G, R, P, S and X) must be used either with the genetic algorithm flag (-g) or the the weithted performance flag (-W)\n");
#line 63
        exit(1);
        }
      }
    }
  }
#line 65
  if (flag.gflg) {
#line 65
    if (flag.wflg) {
      {
#line 67
      error_message((char *)"Sorry, the genetic algorithm can\'t optimise over a wide band yet, so you cant use the -w option\n");
#line 68
      exit(1);
      }
    }
  }
#line 70
  if (flag.pflg) {
#line 70
    if (! flag.gflg) {
      {
#line 72
      error_message((char *)"The \'-p\' population size option is only used with the genetic algorithm \'-g\' option\n");
#line 73
      exit(1);
      }
    }
  }
#line 75
  if (argc - optind___0 != 3) {
#line 75
    if (argc - optind___0 != 2) {
      {
#line 76
      usage_optimise(exefilename);
      }
    }
  }
#line 85
  return;
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/change_max_percentage_changes.c"
double change_max_percentage_changes(int i , int iterations___0 , double original_percent___0 ) 
{ 
  double pcent ;

  {
#line 10
  pcent = 0.0;
#line 11
  if (original_percent___0 > 0.0) {
#line 13
    if (i < iterations___0 / 4) {
#line 14
      pcent = original_percent___0;
    } else
#line 15
    if (i >= iterations___0 / 4) {
#line 15
      if (i < iterations___0 / 2) {
#line 16
        pcent = original_percent___0 / 10.0;
      } else {
#line 15
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 17
    if (i >= iterations___0 / 2) {
#line 17
      if (i < (3 * iterations___0) / 4) {
#line 18
        pcent = original_percent___0 / 100.0;
      } else {
#line 17
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 19
    if (i >= (3 * iterations___0) / 4) {
#line 20
      pcent = original_percent___0 / 1000.0;
    }
  } else
#line 22
  if (original_percent___0 < 0.0) {
#line 23
    pcent = - original_percent___0;
  }
#line 24
  return (pcent);
}
}
#line 9 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/end_stop.c"
void end_if_stop_exists(int *i , int iterations___0 , int divisor ) 
{ 
  FILE *tmp ;
  int *tmp___0 ;

  {
#line 11
  if (*i % divisor == 0) {
    {
#line 13
    tmp = fopen((char const   */* __restrict  */)"stop", (char const   */* __restrict  */)"rt");
    }
#line 13
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 14
      *i = iterations___0;
    }
    {
#line 15
    tmp___0 = __errno_location();
#line 15
    *tmp___0 = 0;
#line 16
    printf((char const   */* __restrict  */)"%d\r", *i);
    }
  }
#line 18
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
double calculate_power_input(double real_z , struct FCOMPLEX current___0 ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/power_input.c"
double calculate_power_input(double real_z , struct FCOMPLEX current___0 ) 
{ 
  double power_input ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 16
  tmp = Cabs(current___0);
#line 16
  tmp___0 = Cabs(current___0);
#line 16
  power_input = ((0.5 * tmp) * tmp___0) * real_z;
  }
#line 25
  return (power_input);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
double dB_down_from_peak(double x , double pin___0 , struct element_data *coordinates___0 ,
                         struct FCOMPLEX *current___0 , int elements___0 , double f___0 ,
                         double design_f___0 ) ;
#line 105
double find_max_sidelobe_slow(double gain___0 , double pin___0 , struct element_data *coordinates___0 ,
                              struct FCOMPLEX *current___0 , int elements___0 , double frequency ,
                              double design_f___0 ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/max_side.c"
double dB_down_from_peak(double x , double pin___0 , struct element_data *coordinates___0 ,
                         struct FCOMPLEX *current___0 , int elements___0 , double f___0 ,
                         double design_f___0 ) 
{ 
  double ans ;
  double gain_H_plane___0 ;
  double peak_gain___0 ;
  double gain_at_x ;

  {
  {
#line 29
  gain(90.0, 0.0, pin___0, f___0 / design_f___0, coordinates___0, current___0, elements___0,
       & peak_gain___0, & gain_H_plane___0, f___0, design_f___0);
#line 30
  gain(x, 0.000, pin___0, f___0 / design_f___0, coordinates___0, current___0, elements___0,
       & gain_at_x, & gain_H_plane___0, f___0, design_f___0);
#line 31
  ans = peak_gain___0 - gain_at_x;
  }
#line 32
  return (ans);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/max_side.c"
double find_max_sidelobe_slow(double gain___0 , double pin___0 , struct element_data *coordinates___0 ,
                              struct FCOMPLEX *current___0 , int elements___0 , double frequency ,
                              double design_f___0 ) 
{ 
  double level ;
  double best ;
  double a ;
  double theta ;
  double max___0 ;
  int k___0 ;

  {
#line 38
  best = - 1000.0;
#line 38
  a = 90.0;
#line 38
  max___0 = 1e8;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    a += (double )1;
#line 42
    level = dB_down_from_peak(a, pin___0, coordinates___0, current___0, elements___0,
                              frequency, design_f___0);
    }
#line 43
    if (level > best) {
#line 45
      k___0 = 1;
#line 46
      best = level;
    } else {
#line 49
      k___0 = 2;
    }
#line 40
    if (k___0 == 1) {
#line 40
      if (! (a <= 270.0)) {
#line 40
        goto while_break;
      }
    } else {
#line 40
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  a -= (double )1;
#line 52
  theta = a;
  {
#line 52
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 52
    if (! (theta < 270.01)) {
#line 52
      goto while_break___0;
    }
    {
#line 54
    level = dB_down_from_peak(theta, pin___0, coordinates___0, current___0, elements___0,
                              frequency, design_f___0);
    }
#line 55
    if (level < max___0) {
#line 57
      max___0 = level;
#line 58
      a = theta;
    }
#line 52
    theta += (double )1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 61
  return (max___0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/max_side.c"
double find_max_sidelobe_fast(double gain___0 , double pin___0 , struct element_data *coordinates___0 ,
                              struct FCOMPLEX *current___0 , int elements___0 , double frequency ,
                              double design_f___0 ) 
{ 
  double angle ;
  double min_angle ;
  double min ;
  double max___0 ;
  double three_dB_point ;
  double min_level ;
  double level ;
  double min_times ;
  int N ;
  double tmp ;

  {
#line 67
  angle = 90.0;
#line 67
  max___0 = (double )270;
#line 67
  min_level = 1000000.0;
#line 71
  if (min_offset_from_peak == 0.0) {
    {
#line 73
    tmp = pow(10.0, gain___0 / 10.0);
#line 73
    three_dB_point = sqrt(41000.0 / tmp);
    }
#line 74
    if (three_dB_point > 90.0) {
#line 75
      min = 180.0;
    } else {
#line 77
      min = 90.0 + three_dB_point;
    }
  } else {
#line 80
    min = 90.0 + min_offset_from_peak;
  }
#line 81
  if (angular_stepsize_2 == 0.0) {
#line 82
    angular_stepsize_2 = three_dB_point / 30.0;
  }
#line 90
  min_times = (max___0 - min) / angular_stepsize_2;
#line 91
  N = (int )(min_times + 1.0);
#line 93
  angle = min;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (angle <= max___0)) {
#line 93
      goto while_break;
    }
    {
#line 95
    level = dB_down_from_peak(angle, pin___0, coordinates___0, current___0, elements___0,
                              frequency, design_f___0);
    }
#line 96
    if (level < min_level) {
#line 98
      min_level = level;
#line 99
      min_angle = angle;
    }
#line 93
    angle += (max___0 - min) / (double )N;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (min_level);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/get_number_of_elements.c"
int get_number_of_elements(char *input_filename , int *driven , int *parasitic ) 
{ 
  FILE *ifp ;
  char *null ;
  char *line ;
  int num_elements ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 16
  null = string(0L, 12L);
#line 17
  line = string(0L, 81L);
#line 18
  ifp = fopen((char const   */* __restrict  */)input_filename, (char const   */* __restrict  */)"rt");
#line 19
  *driven = -1;
#line 20
  *parasitic = -1;
  }
#line 21
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
    {
#line 23
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry, cant find file:  %s\n",
            input_filename);
#line 24
    exit(2);
    }
  }
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 27
    tmp___2 = feof(ifp);
    }
#line 27
    if (tmp___2) {
#line 27
      goto while_break;
    }
    {
#line 29
    fgets((char */* __restrict  */)line, 80, (FILE */* __restrict  */)ifp);
#line 30
    tmp = strncmp((char const   *)line, "ELEMENTS", (size_t )8);
    }
#line 30
    if (tmp == 0) {
      {
#line 32
      sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%s %d\n",
             null, & num_elements);
      }
    }
    {
#line 34
    tmp___0 = strncmp((char const   *)line, "DRIVEN", (size_t )6);
    }
#line 34
    if (tmp___0 == 0) {
      {
#line 36
      sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%s %d\n",
             null, driven);
      }
    }
    {
#line 38
    tmp___1 = strncmp((char const   *)line, "PARASITIC", (size_t )8);
    }
#line 38
    if (tmp___1 == 0) {
      {
#line 40
      sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%s %d\n",
             null, parasitic);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 46
  fclose(ifp);
  }
#line 47
  if (num_elements == -1) {
    {
#line 48
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in data file %s: ELEMENTS undefined\n",
            input_filename);
    }
  }
#line 49
  if (*driven == -1) {
    {
#line 50
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in data file %s : DRIVEN undefined\n",
            input_filename);
    }
  }
#line 51
  if (*parasitic == -1) {
    {
#line 52
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in data file %s: PARASITIC undefined\n",
            input_filename);
    }
  }
#line 53
  if (num_elements != *driven + *parasitic) {
    {
#line 55
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Check ELEMENTS, DRIVEN & PARASITIC in data file %s\n",
            input_filename);
#line 56
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ELEMENTS = %d DRIVEN = %d PARASITIC = %d\n",
            num_elements, *driven, *parasitic);
#line 57
    exit(3);
    }
  }
  {
#line 59
  free_string(line, 0L, 81L);
#line 60
  free_string(null, 0L, 12L);
  }
#line 69
  return (num_elements);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/gaussian.c"
double gaussian(void) 
{ 
  double fac ;
  double r ;
  double x ;
  double y ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 19
    tmp = randreal();
#line 19
    x = 2.0 * tmp - 1.0;
#line 20
    tmp___0 = randreal();
#line 20
    y = 2.0 * tmp___0 - 1.0;
#line 21
    r = x * x + y * y;
    }
#line 18
    if (! (r >= 1.0)) {
#line 18
      if (! (r == 0.0)) {
#line 18
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 23
  tmp___1 = log(r);
#line 23
  fac = sqrt((- 2.0 * tmp___1) / r);
  }
#line 32
  return (y * fac);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/set_mean_structure.c"
void set_mean_structure(struct FCOMPLEX input_impedance , double E_fwd , double E_back ,
                        struct flags flag , double pin___0 , struct element_data *coordinates___0 ,
                        struct FCOMPLEX *current___0 , int elements___0 , double frequency ,
                        double design_frequency , struct performance_data *mean_performance ) 
{ 
  double magnitude___0 ;
  double phase___0 ;
  double vswr___0 ;
  int choice ;
  double tmp ;

  {
  {
#line 13
  choice = flag.oflg;
#line 14
  reflection_coefficient(input_impedance, & magnitude___0, & phase___0);
#line 15
  vswr___0 = calculate_vswr(magnitude___0);
#line 16
  mean_performance->gain = E_fwd;
#line 17
  mean_performance->fb = E_fwd - E_back;
#line 18
  mean_performance->swr = vswr___0;
#line 19
  mean_performance->r = input_impedance.r;
#line 20
  mean_performance->x = input_impedance.i;
  }
#line 21
  if ((choice & 32) == 32) {
    {
#line 22
    tmp = find_max_sidelobe_fast(E_fwd, pin___0, coordinates___0, current___0, elements___0,
                                 frequency, design_frequency);
#line 22
    mean_performance->sidelobe += tmp;
    }
  } else
#line 21
  if (flag.Tflg) {
    {
#line 22
    tmp = find_max_sidelobe_fast(E_fwd, pin___0, coordinates___0, current___0, elements___0,
                                 frequency, design_frequency);
#line 22
    mean_performance->sidelobe += tmp;
    }
  } else
#line 21
  if ((flag.Wflg & 32) == 32) {
    {
#line 22
    tmp = find_max_sidelobe_fast(E_fwd, pin___0, coordinates___0, current___0, elements___0,
                                 frequency, design_frequency);
#line 22
    mean_performance->sidelobe += tmp;
    }
  } else {
#line 24
    mean_performance->sidelobe = 0.0;
  }
#line 25
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void fill_z_matrix(double frequency , int driven , int parasitic , double **d , double **p ,
                   double **impedance ) ;
#line 118
void fill_v_vector(int driven , int parasitic , double **driven_data , double *v ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/solve.c"
void solve_equations(double frequency , int driven , int parasitic , double **driven_data ,
                     double **parasitic_data , double *v , double **z , double *pin___0 ,
                     struct FCOMPLEX *voltage , struct FCOMPLEX *current___0 , struct FCOMPLEX *input_impedance ,
                     struct element_data *coordinates___0 , double **A , double *b ,
                     int *indx ) 
{ 
  int elements___0 ;
  int element_number ;
  int i ;
  int j ;
  double d ;
  double **A_pre_LUdcmp ;
  double *b_copy ;
  double t1 ;
  double t2 ;

  {
  {
#line 15
  elements___0 = driven + parasitic;
#line 16
  fill_z_matrix(frequency, driven, parasitic, driven_data, parasitic_data, z);
#line 20
  fill_v_vector(driven, parasitic, driven_data, v);
#line 38
  copy_complex_data_to_real_matrix(elements___0, z, A);
#line 44
  i = 1;
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i <= elements___0)) {
#line 44
      goto while_break;
    }
#line 46
    *(b + i) = *(v + (2 * i - 1));
#line 47
    *(b + (i + elements___0)) = *(v + 2 * i);
#line 48
    (voltage + i)->r = *(v + (2 * i - 1));
#line 49
    (voltage + i)->i = *(v + 2 * i);
#line 44
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  if (elements___0 > 100000) {
    {
#line 58
    A_pre_LUdcmp = dmatrix(1L, 2L * (long )elements___0, 1L, 2L * (long )elements___0);
#line 59
    b_copy = dvector(1L, 2L * (long )elements___0);
#line 62
    copy_matrix(2 * elements___0, 2 * elements___0, A_pre_LUdcmp, A);
#line 64
    j = 1;
    }
    {
#line 64
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 64
      if (! (j <= 2 * elements___0)) {
#line 64
        goto while_break___0;
      }
#line 65
      *(b_copy + j) = *(b + j);
#line 64
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 68
  ludcmp(A, elements___0 * 2, indx, & d);
#line 71
  lubksb(A, 2 * elements___0, indx, b);
  }
#line 72
  if (elements___0 > 100000) {
    {
#line 74
    t1 = *(b + 1);
#line 75
    mprove(A_pre_LUdcmp, A, 2 * elements___0, indx, b_copy, v);
#line 76
    free_dmatrix(A_pre_LUdcmp, 1L, 2L * (long )elements___0, 1L, 2L * (long )elements___0);
#line 78
    t2 = *(b + 1);
    }
#line 79
    if (t1 != t2) {
      {
#line 81
      printf((char const   */* __restrict  */)"b[1]\'s differ before and after mprove: before = %.16f after =%.16f\n",
             t1, t2);
#line 82
      exit(1);
      }
    }
  }
#line 87
  element_number = 1;
  {
#line 87
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 87
    if (! (element_number <= elements___0)) {
#line 87
      goto while_break___1;
    }
#line 89
    (current___0 + element_number)->r = *(b + element_number);
#line 90
    (current___0 + element_number)->i = *(b + (element_number + elements___0));
#line 87
    element_number ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 92
  z_input(*(voltage + 1), *(current___0 + 1), input_impedance);
#line 93
  *pin___0 = calculate_power_input(input_impedance->r, *(current___0 + 1));
  }
#line 100
  if (*pin___0 <= 0.0) {
#line 103
    *pin___0 = 1e20;
  }
#line 109
  i = 1;
  {
#line 109
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 109
    if (! (i <= driven)) {
#line 109
      goto while_break___2;
    }
#line 111
    (coordinates___0 + i)->x = *(*(driven_data + i) + 1);
#line 112
    (coordinates___0 + i)->y = *(*(driven_data + i) + 2);
#line 113
    (coordinates___0 + i)->length = *(*(driven_data + i) + 3);
#line 109
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 115
  i = driven + 1;
  {
#line 115
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 115
    if (! (i <= elements___0)) {
#line 115
      goto while_break___3;
    }
#line 117
    (coordinates___0 + i)->x = *(*(parasitic_data + (i - driven)) + 1);
#line 118
    (coordinates___0 + i)->y = *(*(parasitic_data + (i - driven)) + 2);
#line 119
    (coordinates___0 + i)->length = *(*(parasitic_data + (i - driven)) + 3);
#line 115
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/fill_z_matrix.c"
void fill_z_matrix(double frequency , int driven , int parasitic , double **d , double **p ,
                   double **impedance ) 
{ 
  int i ;
  int j ;
  int elements___0 ;

  {
#line 14
  elements___0 = driven + parasitic;
#line 15
  i = 1;
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 15
    if (! (i <= elements___0)) {
#line 15
      goto while_break;
    }
#line 17
    j = 1;
    {
#line 17
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 17
      if (! (j <= i)) {
#line 17
        goto while_break___0;
      }
#line 19
      if (i == j) {
#line 21
        if (i <= driven) {
          {
#line 23
          self_impedance(i, frequency, driven, parasitic, d, impedance);
          }
        } else
#line 25
        if (i > driven) {
          {
#line 27
          self_impedance(i, frequency, driven, parasitic, p, impedance);
          }
        }
      } else
#line 30
      if (i != j) {
        {
#line 32
        mutual_impedance(i, j, frequency, driven, parasitic, d, p, impedance);
        }
      }
#line 17
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 15
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  return;
}
}
#line 9 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/fill_v_vector.c"
void fill_v_vector(int driven , int parasitic , double **driven_data , double *v ) 
{ 
  double real ;
  double imaginary ;
  int i ;
  int elements___0 ;

  {
#line 12
  elements___0 = driven + parasitic;
#line 14
  i = 1;
  {
#line 14
  while (1) {
    while_continue: /* CIL Label */ ;
#line 14
    if (! (i <= elements___0)) {
#line 14
      goto while_break;
    }
#line 16
    if (i <= driven) {
#line 18
      real = *(*(driven_data + i) + 5);
#line 19
      imaginary = *(*(driven_data + i) + 6);
#line 20
      *(v + (2 * i - 1)) = real;
#line 21
      *(v + 2 * i) = imaginary;
    } else {
#line 25
      *(v + (2 * i - 1)) = 0.0;
#line 26
      *(v + 2 * i) = 0.0;
    }
#line 14
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return;
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/lub_hack.c"
void lubksb(double **a , int n , int *indx , double *b ) 
{ 
  int i ;
  int ii ;
  int ip ;
  int j ;
  double sum ;

  {
#line 8
  ii = 0;
#line 11
  i = 1;
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11
    if (! (i <= n)) {
#line 11
      goto while_break;
    }
#line 12
    ip = *(indx + i);
#line 13
    sum = *(b + ip);
#line 14
    *(b + ip) = *(b + i);
#line 15
    if (ii) {
#line 16
      j = ii;
      {
#line 16
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 16
        if (! (j <= i - 1)) {
#line 16
          goto while_break___0;
        }
#line 16
        sum -= *(*(a + i) + j) * *(b + j);
#line 16
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 17
    if (sum) {
#line 17
      ii = i;
    }
#line 18
    *(b + i) = sum;
#line 11
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  i = n;
  {
#line 20
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 20
    if (! (i >= 1)) {
#line 20
      goto while_break___1;
    }
#line 21
    sum = *(b + i);
#line 22
    j = i + 1;
    {
#line 22
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 22
      if (! (j <= n)) {
#line 22
        goto while_break___2;
      }
#line 22
      sum -= *(*(a + i) + j) * *(b + j);
#line 22
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 23
    *(b + i) = sum / *(*(a + i) + i);
#line 20
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 25
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
double Cin(double x ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/cin.c"
double Cin(double x ) 
{ 
  double cix ;
  double temp ;
  double ans ;
  double tmp ;

  {
  {
#line 10
  cisi(x, & cix, & temp);
#line 11
  tmp = log(x);
#line 11
  ans = (0.57721566 + tmp) - cix;
  }
#line 12
  return (ans);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
static int optopt___0  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
static int sp___0  =    1;
#line 93 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
double new_length(double old_l , double old_dia , double lambda___0 , double new_dia ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/new_length.c"
double new_length(double old_l , double old_dia , double lambda___0 , double new_dia ) 
{ 
  double old_r ;
  double old_x ;
  double r ;
  double x ;
  double l ;

  {
  {
#line 13
  self(old_dia / 2.0, old_l, lambda___0, & old_r, & old_x);
  }
#line 15
  if (old_dia > new_dia) {
#line 16
    l = 0.50001 * lambda___0;
  } else {
#line 18
    l = old_l;
  }
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 20
    l -= 0.1 * lambda___0;
#line 21
    self(new_dia / 2.0, l, lambda___0, & r, & x);
    }
#line 19
    if (! (x > old_x)) {
#line 19
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  l += 0.1 * lambda___0;
  {
#line 24
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 25
    l -= 0.01 * lambda___0;
#line 26
    self(new_dia / 2.0, l, lambda___0, & r, & x);
    }
#line 24
    if (! (x > old_x)) {
#line 24
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 28
  l += 0.01 * lambda___0;
  {
#line 29
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 30
    l -= 0.001 * lambda___0;
#line 31
    self(new_dia / 2.0, l, lambda___0, & r, & x);
    }
#line 29
    if (! (x > old_x)) {
#line 29
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 33
  l += 0.001 * lambda___0;
  {
#line 34
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 35
    l -= 0.0001 * lambda___0;
#line 36
    self(new_dia / 2.0, l, lambda___0, & r, & x);
    }
#line 34
    if (! (x > old_x)) {
#line 34
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 38
  l += 0.0001 * lambda___0;
  {
#line 39
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 40
    l -= 0.00001 * lambda___0;
#line 41
    self(new_dia / 2.0, l, lambda___0, & r, & x);
    }
#line 39
    if (! (x > old_x)) {
#line 39
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 43
  l += 0.00001 * lambda___0;
  {
#line 44
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 45
    l -= 0.00001 * lambda___0;
#line 46
    self(new_dia / 2.0, l, lambda___0, & r, & x);
    }
#line 44
    if (! (x > old_x)) {
#line 44
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 49
  return (l);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void usage_first(char *exefile ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/first.c"
double space[35]  = 
#line 25 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/first.c"
  {      0.000,      0.200,      0.075,      0.180, 
        0.215,      0.250,      0.280,      0.300, 
        0.315,      0.330,      0.345,      0.360, 
        0.375,      0.390,      0.400,      0.400, 
        0.400,      0.4,      0.4,      0.4, 
        0.4,      0.4,      0.4,      0.4, 
        0.4,      0.4,      0.4,      0.4, 
        0.4,      0.4,      0.4,      0.4, 
        0.4,      0.4,      0.4};
#line 27 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/first.c"
double length[30]  = 
#line 27
  {      0.480,      0.456,      0.425,      0.42, 
        0.414,      0.408,      0.404,      0.399, 
        0.396,      0.392,      0.390,      0.388, 
        0.385,      0.383,      0.381,      0.379, 
        0.377,      0.376,      0.375,      0.374, 
        0.372,      0.371,      0.370,      0.369, 
        0.368,      0.367,      0.366,      0.365, 
        0.364,      0.363};
#line 7 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/usage_first.c"
void usage_first(char *exefile ) 
{ 
  double tmp ;

  {
  {
#line 9
  tmp = version();
#line 9
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nYagi-Uda antenna analysis programs, version %.2f\n",
          tmp);
#line 10
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Written by Dr. David Kirkby Ph.D. G8WRB (email:david.kirkby@onetel.net)\n");
#line 11
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s filename elements min_f f max_f step_f diameter\n",
          exefile);
#line 12
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       where frequencies are in MHz and diameter is in mm\n");
#line 13
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'first\' is used to define an antenna quickly, according to DL6WU designs.\n");
#line 14
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"It is much faster in use than \'input\'\n");
#line 15
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Example: first 145e20 20 144 145 146 .1 6.3\n\n");
#line 16
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"will make a file \'145e20\' containing a description of a 20 element DL6WU yagi, \nfor 144-146 MHz, designed at 145MHz, which \'yagi\' will calculate in steps of \n0.1MHz. The antenna uses 6.3mm diameter elements.\n");
  }
#line 18
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void usage_input(char *exefile ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/usage_input.c"
void usage_input(char *exefile ) 
{ 
  double tmp ;

  {
  {
#line 10
  tmp = version();
#line 10
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nYagi-Uda antenna analysis programs, version %.2f\n",
          tmp);
#line 11
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Written by David Kirkby BSc MSc G8WRB (email:david.kirkby@onetel.net)\n");
#line 12
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUSAGE: %s  [-h] \n\n",
          exefile);
#line 14
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Where the only option is:\n");
#line 15
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -h     Print this help screen\n\n\n");
#line 17
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'input\' is an interactive program, that asks the user for formation  about  \n");
#line 18
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"a  Yagi  design,  such as position of elements, spacing between elements,\n");
#line 19
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"frequency span of interest and a  filename to  save the data to. It then \n");
#line 20
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"writes this information into an ASCII file, which can be read by \'yagi\' or \n");
#line 21
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'optimise\'. The file is  ASCII  and  it\'s format  is  easily  understood\n");
#line 22
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"by inspection (there are comments printed in it), so it can if necessary\n");
#line 23
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"be edited manually. After running \'input\' and specifying a filename \n");
#line 24
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(for example 144e10) you should then type \'yagi 144e10\' then \'output 144e10\'\n");
#line 25
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"and then and optionally \'optimise 144e10\'.\n");
  }
#line 26
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
static int optopt___1  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
static int sp___1  =    1;
#line 38 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
static int optopt___2  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
static int sp___2  =    1;
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 123 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
int read_header(FILE *ifp , FILE *ofp , double *min_f , double *max_f , double *step_f ,
                double *f___0 , double *angular_step ) ;
#line 141
void write_gain_at_various_angles(FILE *gain_fp , double angular_step , double pin___0 ,
                                  double normalised_f___0 , double f___0 , struct element_data *coordinates___0 ,
                                  struct FCOMPLEX *current___0 , int elements___0 ,
                                  double design_f___0 ) ;
#line 155
void usage_output(char *exefile ) ;
#line 187
double error_3dB_E(double x ) ;
#line 188
double error_3dB_H(double x ) ;
#line 189
double zbrent(double (*error_3dB)(double x ) , double x1 , double x2 , double tol ) ;
#line 197
void write_gnuplot_header(FILE *fp , double f___0 , char *filename , int step , int lin_or_log ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
double pin  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
double design_f  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
double normalised_f  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
double f  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
double gain_E_plane  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
double gain_H_plane  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
double peak_gain  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
struct element_data *coordinates  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
struct FCOMPLEX *current  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
int elements  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
double rrange_min  =    - 50.0;
#line 32 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
double rrange_max  =    20.0;
#line 280 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
double error_3dB_E(double x ) 
{ 
  double ans ;

  {
  {
#line 284
  gain(x, (double )0, pin, normalised_f, coordinates, current, elements, & gain_E_plane,
       & gain_H_plane, f, design_f);
#line 285
  ans = (peak_gain - gain_E_plane) - 3.01;
  }
#line 286
  return (ans);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/output.c"
double error_3dB_H(double x ) 
{ 
  double ans ;

  {
  {
#line 293
  gain((double )0, x, pin, normalised_f, coordinates, current, elements, & gain_E_plane,
       & gain_H_plane, f, design_f);
#line 294
  ans = (peak_gain - gain_H_plane) - 3.01;
  }
#line 295
  return (ans);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/usage_output.c"
void usage_output(char *exefile ) 
{ 
  double Zo___0 ;
  double H_max ;
  double E_max ;
  double tmp ;

  {
  {
#line 16
  Zo___0 = (double )50;
#line 17
  H_max = 60.0;
#line 18
  E_max = 179.0;
#line 20
  tmp = version();
#line 20
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nYagi-Uda antenna analysi program output, version %.2f\n",
          tmp);
#line 21
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Written by Dr. David Kirkby Ph.D. G8WRB (email:david.kirkby@onetel.net)\n");
#line 22
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUSAGE: %s [-cehps] [-E E_max -H H_max -r min -R max -Z Zo] filename \n\n",
          exefile);
#line 23
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Where options are:\n");
#line 24
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n -c  Calculate sidelobe levels (slows program considerably).\n");
#line 25
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -e  Suppress calculation of 3dB E-plane BW.\n");
#line 26
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -h  Suppress calculation of 3dB H-plane BW.\n");
#line 27
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -p  Put data into filename.freq, filename.glog and filename.glin for gnuplot\n");
#line 28
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -s  Suppress diagnostic output.\n");
#line 29
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -E  Max angle to find the 3dB point. Min=90, max=180  (default = %.0f degrees)\n",
          E_max);
#line 30
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -H  Max angle to find the 3dB point. Min=0, max=90    (default = %.0f degrees)\n",
          H_max);
#line 31
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -r  Set minimum range on the radial gnuplot log graph (default = %.0f dB)\n",
          rrange_min);
#line 32
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -R  Set maximum range on the radial gnuplot lin graph (default = %.0f dB)\n",
          rrange_max);
#line 33
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -Z  Set characteristic impedance                      (default = %.0f Ohms)\n\n",
          Zo___0);
  }
#line 34
  return;
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/write_gnuplot_header.c"
void write_gnuplot_header(FILE *fp , double f___0 , char *filename , int step , int lin_or_log ) 
{ 


  {
  {
#line 12
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#\n");
#line 13
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# $Id: %s,v 1.4 1993/09/27 17:10:59 alex Exp $\n",
          filename);
#line 14
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#\n");
#line 15
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#\n");
#line 16
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# Analsed from %s with Yagi-Uda \n",
          filename);
#line 17
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set angles degrees\n");
#line 18
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set size square\n");
#line 19
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set polar\n");
#line 20
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set grid polar 15.\n");
#line 21
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set noborder\n");
#line 22
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set noparam\n");
#line 23
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set lines\n");
  }
#line 24
  if (! (lin_or_log == 0)) {
#line 28
    if (lin_or_log == 1) {
      {
#line 30
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set xrange [%f:%f]\n",
              - (rrange_max - rrange_min), rrange_max - rrange_min);
#line 31
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set yrange [%f:%f]\n",
              - (rrange_max - rrange_min), rrange_max - rrange_min);
#line 32
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set rrange [%f:%f]\n",
              rrange_min, rrange_max);
#line 33
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set trange [-pi:pi]\n");
      }
    }
  }
  {
#line 35
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set xtics 0, 10, %f\n",
          - rrange_min + rrange_max);
#line 36
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set ytics 0, 10, %f\n",
          - rrange_min + rrange_max);
#line 37
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set xtics axis mirror\n");
#line 38
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set ytics axis mirror\n");
#line 39
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"set data style line\n");
  }
#line 40
  return;
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/zbr_hack.c"
double zbrent(double (*error_3dB)(double x ) , double x1 , double x2 , double tol ) 
{ 
  int iter ;
  double a ;
  double b ;
  double c ;
  double d ;
  double e ;
  double min1 ;
  double min2 ;
  double fa ;
  double tmp ;
  double fb ;
  double tmp___0 ;
  double fc ;
  double p ;
  double q ;
  double r ;
  double s ;
  double tol1 ;
  double xm ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;

  {
  {
#line 13
  a = x1;
#line 13
  b = x2;
#line 14
  tmp = (*error_3dB)(a);
#line 14
  fa = tmp;
#line 14
  tmp___0 = (*error_3dB)(b);
#line 14
  fb = tmp___0;
  }
#line 17
  if (fb * fa > 0.0) {
    {
#line 17
    nrerror((char *)"Root must be bracketed in ZBRENT - try the -e or -h options to output");
    }
  }
#line 18
  fc = fb;
#line 19
  iter = 1;
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19
    if (! (iter <= 100)) {
#line 19
      goto while_break;
    }
#line 20
    if (fb * fc > 0.0) {
#line 21
      c = a;
#line 22
      fc = fa;
#line 23
      d = b - a;
#line 23
      e = d;
    }
    {
#line 25
    tmp___1 = fabs(fc);
#line 25
    tmp___2 = fabs(fb);
    }
#line 25
    if (tmp___1 < tmp___2) {
#line 26
      a = b;
#line 27
      b = c;
#line 28
      c = a;
#line 29
      fa = fb;
#line 30
      fb = fc;
#line 31
      fc = fa;
    }
    {
#line 33
    tmp___3 = fabs(b);
#line 33
    tol1 = (2.0 * 3.0e-8) * tmp___3 + 0.5 * tol;
#line 34
    xm = 0.5 * (c - b);
#line 35
    tmp___4 = fabs(xm);
    }
#line 35
    if (tmp___4 <= tol1) {
#line 35
      return (b);
    } else
#line 35
    if (fb == 0.0) {
#line 35
      return (b);
    }
    {
#line 36
    tmp___7 = fabs(e);
    }
#line 36
    if (tmp___7 >= tol1) {
      {
#line 36
      tmp___8 = fabs(fa);
#line 36
      tmp___9 = fabs(fb);
      }
#line 36
      if (tmp___8 > tmp___9) {
#line 37
        s = fb / fa;
#line 38
        if (a == c) {
#line 39
          p = (2.0 * xm) * s;
#line 40
          q = 1.0 - s;
        } else {
#line 42
          q = fa / fc;
#line 43
          r = fb / fc;
#line 44
          p = s * (((2.0 * xm) * q) * (q - r) - (b - a) * (r - 1.0));
#line 45
          q = ((q - 1.0) * (r - 1.0)) * (s - 1.0);
        }
#line 47
        if (p > 0.0) {
#line 47
          q = - q;
        }
        {
#line 48
        p = fabs(p);
#line 49
        tmp___5 = fabs(tol1 * q);
#line 49
        min1 = (3.0 * xm) * q - tmp___5;
#line 50
        min2 = fabs(e * q);
        }
#line 51
        if (min1 < min2) {
#line 51
          tmp___6 = min1;
        } else {
#line 51
          tmp___6 = min2;
        }
#line 51
        if (2.0 * p < tmp___6) {
#line 52
          e = d;
#line 53
          d = p / q;
        } else {
#line 55
          d = xm;
#line 56
          e = d;
        }
      } else {
#line 59
        d = xm;
#line 60
        e = d;
      }
    } else {
#line 59
      d = xm;
#line 60
      e = d;
    }
    {
#line 62
    a = b;
#line 63
    fa = fb;
#line 64
    tmp___13 = fabs(d);
    }
#line 64
    if (tmp___13 > tol1) {
#line 65
      b += d;
    } else {
#line 67
      if (xm > 0.0) {
        {
#line 67
        tmp___10 = fabs(tol1);
#line 67
        tmp___12 = tmp___10;
        }
      } else {
        {
#line 67
        tmp___11 = fabs(tol1);
#line 67
        tmp___12 = - tmp___11;
        }
      }
#line 67
      b += tmp___12;
    }
    {
#line 68
    fb = (*error_3dB)(b);
#line 19
    iter ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  nrerror((char *)"Maximum number of iterations exceeded in ZBRENT");
  }
#line 71
  return ((double )0);
}
}
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/read_header.c"
int read_header(FILE *ifp , FILE *ofp , double *min_f , double *max_f , double *step_f ,
                double *f___0 , double *angular_step ) 
{ 
  int elements___0 ;
  int driven ;
  int parasitic ;

  {
  {
#line 15
  fread((void */* __restrict  */)((char *)(& elements___0)), sizeof(elements___0),
        (size_t )1, (FILE */* __restrict  */)ifp);
#line 16
  fread((void */* __restrict  */)((char *)(& driven)), sizeof(driven), (size_t )1,
        (FILE */* __restrict  */)ifp);
#line 17
  fread((void */* __restrict  */)((char *)(& parasitic)), sizeof(parasitic), (size_t )1,
        (FILE */* __restrict  */)ifp);
#line 18
  fread((void */* __restrict  */)((char *)min_f), sizeof(*min_f), (size_t )1, (FILE */* __restrict  */)ifp);
#line 19
  fread((void */* __restrict  */)((char *)max_f), sizeof(*max_f), (size_t )1, (FILE */* __restrict  */)ifp);
#line 20
  fread((void */* __restrict  */)((char *)f___0), sizeof(*f___0), (size_t )1, (FILE */* __restrict  */)ifp);
#line 21
  fread((void */* __restrict  */)((char *)step_f), sizeof(*step_f), (size_t )1, (FILE */* __restrict  */)ifp);
#line 22
  fread((void */* __restrict  */)((char *)angular_step), sizeof(*angular_step), (size_t )1,
        (FILE */* __restrict  */)ifp);
#line 23
  fseek(ifp, 100L, 0);
  }
#line 26
  if (*max_f < *min_f) {
    {
#line 28
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in input file\n");
#line 29
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"driven=%d parasitic=%d elements=%d\n",
            driven, parasitic, elements___0);
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"min_f=%f max_f=%f step_f=%f\n",
            *min_f, *max_f, *step_f);
#line 31
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"angular_step=%f \n",
            *angular_step);
#line 32
    exit(19);
    }
  } else
#line 26
  if (*angular_step == (double )0) {
    {
#line 28
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in input file\n");
#line 29
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"driven=%d parasitic=%d elements=%d\n",
            driven, parasitic, elements___0);
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"min_f=%f max_f=%f step_f=%f\n",
            *min_f, *max_f, *step_f);
#line 31
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"angular_step=%f \n",
            *angular_step);
#line 32
    exit(19);
    }
  } else
#line 26
  if (driven + parasitic != elements___0) {
    {
#line 28
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in input file\n");
#line 29
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"driven=%d parasitic=%d elements=%d\n",
            driven, parasitic, elements___0);
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"min_f=%f max_f=%f step_f=%f\n",
            *min_f, *max_f, *step_f);
#line 31
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"angular_step=%f \n",
            *angular_step);
#line 32
    exit(19);
    }
  } else
#line 26
  if (*step_f > *max_f) {
    {
#line 28
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in input file\n");
#line 29
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"driven=%d parasitic=%d elements=%d\n",
            driven, parasitic, elements___0);
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"min_f=%f max_f=%f step_f=%f\n",
            *min_f, *max_f, *step_f);
#line 31
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"angular_step=%f \n",
            *angular_step);
#line 32
    exit(19);
    }
  }
  {
#line 34
  fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"# Driven=%d parasitic=%d total-elements=%d design=%.3fMHz\n",
          driven, parasitic, elements___0, *f___0 / 1e6);
#line 35
  fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"# Checked from %.3fMHz to %.3fMHz.\n",
          *min_f / 1e6, *max_f / 1e6);
  }
#line 44
  return (elements___0);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/write_gain.c"
static int run_first_time___2  =    0;
#line 10 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/write_gain.c"
void write_gain_at_various_angles(FILE *gain_fp , double angular_step , double pin___0 ,
                                  double normalised_f___0 , double f___0 , struct element_data *coordinates___0 ,
                                  struct FCOMPLEX *current___0 , int elements___0 ,
                                  double design_f___0 ) 
{ 
  double theta ;
  double phi ;
  double gain_E_plane___0 ;
  double gain_H_plane___0 ;
  double E_plane_gain ;
  double H_plane_gain ;
  double peak_gain___0 ;

  {
  {
#line 15
  fprintf((FILE */* __restrict  */)gain_fp, (char const   */* __restrict  */)"#  f(MHz)     theta   gain-E(dBi)   G(E)-peak   phi    gain-H(dBi)  G(H)-peak\n");
#line 16
  run_first_time___2 = 1;
#line 17
  gain(90.0, (double )0, pin___0, normalised_f___0, coordinates___0, current___0,
       elements___0, & gain_E_plane___0, & peak_gain___0, f___0, design_f___0);
#line 18
  phi = (double )-180;
  }
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! (phi <= 180.0)) {
#line 18
      goto while_break;
    }
    {
#line 20
    theta = (double )90 + phi;
#line 23
    gain(90.0, phi + (double )360, pin___0, normalised_f___0, coordinates___0, current___0,
         elements___0, & gain_E_plane___0, & gain_H_plane___0, f___0, design_f___0);
#line 25
    H_plane_gain = gain_H_plane___0;
#line 27
    theta = (double )90 + phi;
#line 29
    gain(theta + (double )360, (double )0, pin___0, normalised_f___0, coordinates___0,
         current___0, elements___0, & gain_E_plane___0, & gain_H_plane___0, f___0,
         design_f___0);
#line 30
    E_plane_gain = gain_E_plane___0;
#line 31
    fprintf((FILE */* __restrict  */)gain_fp, (char const   */* __restrict  */)"%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n",
            f___0 / 1e6, theta, E_plane_gain, E_plane_gain - peak_gain___0, phi, H_plane_gain,
            H_plane_gain - peak_gain___0);
#line 18
    phi += angular_step;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/random.c"
static short paired___0  =    (short)0;
#line 55 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/random.c"
static double second___0  ;
#line 119 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
void write_header_to_disk(FILE *ofp , int elements___0 , int driven , int parasitic ,
                          double min_frequency , double max_frequency , double frequency ,
                          double step_frequency , double angular_step ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/write_header_to_disk.c"
void write_header_to_disk(FILE *ofp , int elements___0 , int driven , int parasitic ,
                          double min_frequency , double max_frequency , double frequency ,
                          double step_frequency , double angular_step ) 
{ 


  {
  {
#line 15
  fwrite((void const   */* __restrict  */)((char *)(& elements___0)), sizeof(elements___0),
         (size_t )1, (FILE */* __restrict  */)ofp);
#line 16
  fwrite((void const   */* __restrict  */)((char *)(& driven)), sizeof(driven), (size_t )1,
         (FILE */* __restrict  */)ofp);
#line 17
  fwrite((void const   */* __restrict  */)((char *)(& parasitic)), sizeof(parasitic),
         (size_t )1, (FILE */* __restrict  */)ofp);
#line 18
  fwrite((void const   */* __restrict  */)((char *)(& min_frequency)), sizeof(min_frequency),
         (size_t )1, (FILE */* __restrict  */)ofp);
#line 19
  fwrite((void const   */* __restrict  */)((char *)(& max_frequency)), sizeof(max_frequency),
         (size_t )1, (FILE */* __restrict  */)ofp);
#line 20
  fwrite((void const   */* __restrict  */)((char *)(& frequency)), sizeof(frequency),
         (size_t )1, (FILE */* __restrict  */)ofp);
#line 21
  fwrite((void const   */* __restrict  */)((char *)(& step_frequency)), sizeof(step_frequency),
         (size_t )1, (FILE */* __restrict  */)ofp);
#line 22
  fwrite((void const   */* __restrict  */)((char *)(& angular_step)), sizeof(angular_step),
         (size_t )1, (FILE */* __restrict  */)ofp);
#line 23
  fseek(ofp, 100L, 0);
  }
#line 32
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/yagi.h"
char *get_data_filenames(int optind___0 , char **argv , char *input ) ;
#line 128
void write_coordinates_of_elements_to_disk(FILE *ofp , int driven , int parasitic ,
                                           double **d , double **p ) ;
#line 154
void usage_yagi(char *exefile ) ;
#line 199
void display_antenna_currents(struct FCOMPLEX *current___0 , int elements___0 ) ;
#line 754 "/usr/include/stdio.h"
extern long ftell(FILE *__stream ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/write_coordinates.c"
void write_coordinates_of_elements_to_disk(FILE *ofp , int driven , int parasitic ,
                                           double **d , double **p ) 
{ 
  int element_number ;
  int before ;
  long tmp ;

  {
  {
#line 16
  tmp = ftell(ofp);
#line 16
  before = (int )tmp;
#line 17
  element_number = 1;
  }
  {
#line 17
  while (1) {
    while_continue: /* CIL Label */ ;
#line 17
    if (! (element_number <= driven)) {
#line 17
      goto while_break;
    }
    {
#line 18
    fwrite((void const   */* __restrict  */)((char *)(*(d + element_number) + 1)),
           sizeof(double ), (size_t )3, (FILE */* __restrict  */)ofp);
#line 17
    element_number ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 19
  element_number = 1;
  {
#line 19
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 19
    if (! (element_number <= parasitic)) {
#line 19
      goto while_break___0;
    }
    {
#line 20
    fwrite((void const   */* __restrict  */)((char *)(*(p + element_number) + 1)),
           sizeof(double ), (size_t )3, (FILE */* __restrict  */)ofp);
#line 19
    element_number ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 29
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/usage_yagi.c"
void usage_yagi(char *exefile ) 
{ 
  double tmp ;

  {
  {
#line 10
  tmp = version();
#line 10
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nYagi-Uda antenna analysis programs, version %.2f\n",
          tmp);
#line 11
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Written by Dr. David Kirkby Ph.D. G8WRB (email:david.kirkby@onetel.net)\n");
#line 12
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUSAGE: %s  [-dhps] filename \n\n",
          exefile);
#line 13
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Where options are:\n");
#line 14
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -d     Display  bar-graphs, proportional to element currents\n");
#line 15
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -h     Print this help screen\n");
#line 16
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -p     Print Z matrix to screen.\n");
#line 17
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -s     Suppress diagnostic output\n");
#line 18
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'yagi\' computes the currents at the centre of of each element of an antenna \ndescribed in \'filename\', where \'filename\' was created by \'input\' or \'first\'.\n");
#line 19
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"After running \'yagi filename\' type \'output filename\'\n");
  }
#line 20
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
static int optopt___3  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getopt.c"
static int sp___3  =    1;
#line 13 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/getfiles.c"
char *get_data_filenames(int optind___0 , char **argv , char *input ) 
{ 
  char *output ;

  {
  {
#line 16
  output = string(0L, 100L);
#line 17
  strcpy((char */* __restrict  */)input, (char const   */* __restrict  */)*(argv + optind___0));
#line 18
  strcpy((char */* __restrict  */)output, (char const   */* __restrict  */)*(argv + optind___0));
#line 19
  strcat((char */* __restrict  */)output, (char const   */* __restrict  */)".out");
  }
#line 28
  return (output);
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/yagiuda-1.19/src/display_antenna_currents.c"
void display_antenna_currents(struct FCOMPLEX *current___0 , int elements___0 ) 
{ 
  int j ;
  int stars ;
  int k___0 ;
  double magnitude___0 ;
  double max___0 ;

  {
#line 11
  max___0 = 0.0;
#line 12
  j = 1;
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    if (! (j <= elements___0)) {
#line 12
      goto while_break;
    }
    {
#line 14
    magnitude___0 = sqrt((current___0 + j)->r * (current___0 + j)->r + (current___0 + j)->i * (current___0 + j)->i);
    }
#line 15
    if (magnitude___0 > max___0) {
#line 16
      max___0 = magnitude___0;
    }
#line 12
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 19
  magnitude___0 = sqrt((current___0 + 2)->r * (current___0 + 2)->r + (current___0 + 2)->i * (current___0 + 2)->i);
#line 20
  stars = (int )((68.0 * magnitude___0) / max___0 + 0.5);
#line 21
  printf((char const   */* __restrict  */)"REF ");
#line 22
  k___0 = 1;
  }
  {
#line 22
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 22
    if (! (k___0 <= stars)) {
#line 22
      goto while_break___0;
    }
    {
#line 23
    printf((char const   */* __restrict  */)"*");
#line 22
    k___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 24
  k___0 = k___0;
  {
#line 24
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 24
    if (! (k___0 <= 68)) {
#line 24
      goto while_break___1;
    }
    {
#line 25
    printf((char const   */* __restrict  */)" ");
#line 24
    k___0 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 26
  printf((char const   */* __restrict  */)" %.3f\n", magnitude___0 / max___0);
#line 28
  printf((char const   */* __restrict  */)"DR  ");
#line 29
  magnitude___0 = sqrt((current___0 + 1)->r * (current___0 + 1)->r + (current___0 + 1)->i * (current___0 + 1)->i);
#line 30
  stars = (int )((68.0 * magnitude___0) / max___0 + 0.5);
#line 31
  k___0 = 1;
  }
  {
#line 31
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 31
    if (! (k___0 <= stars)) {
#line 31
      goto while_break___2;
    }
    {
#line 32
    printf((char const   */* __restrict  */)"*");
#line 31
    k___0 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 33
  k___0 = k___0;
  {
#line 33
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 33
    if (! (k___0 <= 68)) {
#line 33
      goto while_break___3;
    }
    {
#line 34
    printf((char const   */* __restrict  */)" ");
#line 33
    k___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 35
  printf((char const   */* __restrict  */)" %.3f\n", magnitude___0 / max___0);
#line 36
  j = 3;
  }
  {
#line 36
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 36
    if (! (j <= elements___0)) {
#line 36
      goto while_break___4;
    }
    {
#line 38
    magnitude___0 = sqrt((current___0 + j)->r * (current___0 + j)->r + (current___0 + j)->i * (current___0 + j)->i);
#line 39
    stars = (int )((68.0 * magnitude___0) / max___0 + 0.5);
#line 40
    printf((char const   */* __restrict  */)"D%02d ", j - 2);
#line 41
    k___0 = 1;
    }
    {
#line 41
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 41
      if (! (k___0 <= stars)) {
#line 41
        goto while_break___5;
      }
      {
#line 42
      printf((char const   */* __restrict  */)"*");
#line 41
      k___0 ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 43
    k___0 = k___0;
    {
#line 43
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 43
      if (! (k___0 <= 68)) {
#line 43
        goto while_break___6;
      }
      {
#line 44
      printf((char const   */* __restrict  */)" ");
#line 43
      k___0 ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 45
    printf((char const   */* __restrict  */)" %.3f\n", magnitude___0 / max___0);
#line 36
    j ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 47
  return;
}
}
