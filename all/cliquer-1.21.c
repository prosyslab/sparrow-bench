/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 34 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
typedef unsigned long setelement;
#line 45 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
typedef setelement *set_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.h"
struct _graph_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.h"
typedef struct _graph_t graph_t;
#line 8 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.h"
struct _graph_t {
   int n ;
   set_t *edges ;
   int *weights ;
};
#line 11 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.h"
struct _clique_options;
#line 11 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.h"
typedef struct _clique_options clique_options;
#line 12 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.h"
struct _clique_options {
   int *(*reorder_function)(graph_t * , int  ) ;
   int *reorder_map ;
   int (*time_function)(int  , int  , int  , int  , double  , double  , clique_options * ) ;
   FILE *output ;
   int (*user_function)(set_t  , graph_t * , clique_options * ) ;
   void *user_data ;
   set_t *clique_list ;
   int clique_list_length ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 619 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 48 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) times)(struct tms *__buffer ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static int set_bit_count[256]  = 
#line 51 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
  {      0,      1,      1,      2, 
        1,      2,      2,      3, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        5,      6,      6,      7, 
        6,      7,      7,      8};
#line 144
static set_t set_new(int size )  __attribute__((__unused__)) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static set_t set_new(int size ) 
{ 
  int n ;
  set_t s ;
  void *tmp ;

  {
#line 149
  if (! (size > 0)) {
    {
#line 149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h", 149, "size>0");
#line 149
    abort();
    }
  }
  {
#line 151
  n = (size / 64 + 1) + 1;
#line 152
  tmp = calloc((size_t )n, sizeof(setelement ));
#line 152
  s = (set_t )tmp;
#line 153
  *(s + 0) = (setelement )size;
  }
#line 155
  return (s + 1);
}
}
#line 163
__inline static void set_free(set_t s )  __attribute__((__unused__)) ;
#line 163 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static void set_free(set_t s ) 
{ 


  {
#line 165
  if (! ((unsigned long )s != (unsigned long )((void *)0))) {
    {
#line 165
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h", 165, "s!=NULL");
#line 165
    abort();
    }
  }
  {
#line 166
  free((void *)(s + -1));
  }
#line 167
  return;
}
}
#line 202
__inline static int set_size(set_t s )  __attribute__((__unused__)) ;
#line 202 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static int set_size(set_t s ) 
{ 
  int count ;
  setelement *c ;

  {
#line 204
  count = 0;
#line 207
  c = s;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )c < (unsigned long )(s + ((*(s + -1) + 64UL) - 1UL) / 64UL))) {
#line 207
      goto while_break;
    }
#line 208
    count += ((((((set_bit_count[*c >> 56] + set_bit_count[(*c >> 48) & 255UL]) + set_bit_count[(*c >> 40) & 255UL]) + set_bit_count[(*c >> 32) & 255UL]) + set_bit_count[(*c >> 24) & 255UL]) + set_bit_count[(*c >> 16) & 255UL]) + set_bit_count[(*c >> 8) & 255UL]) + set_bit_count[*c & 255UL];
#line 207
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return (count);
}
}
#line 217
__inline static set_t set_duplicate(set_t s )  __attribute__((__unused__)) ;
#line 217 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static set_t set_duplicate(set_t s ) 
{ 
  set_t new ;

  {
  {
#line 221
  new = set_new((int )*(s + -1));
#line 222
  memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)s, (((*(s + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
  }
#line 223
  return (new);
}
}
#line 233
__inline static set_t set_copy(set_t dest , set_t src )  __attribute__((__unused__)) ;
#line 233 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static set_t set_copy(set_t dest , set_t src ) 
{ 
  set_t tmp ;
  set_t tmp___0 ;

  {
#line 235
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
    {
#line 236
    tmp = set_duplicate(src);
    }
#line 236
    return (tmp);
  }
#line 237
  if (*(dest + -1) < *(src + -1)) {
    {
#line 238
    set_free(dest);
#line 239
    tmp___0 = set_duplicate(src);
    }
#line 239
    return (tmp___0);
  }
  {
#line 241
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, (((*(src + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
#line 242
  memset((void *)(dest + ((*(src + -1) + 64UL) - 1UL) / 64UL), 0, (((*(dest + -1) + 64UL) - 1UL) / 64UL - ((*(src + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
  }
#line 245
  return (dest);
}
}
#line 253
__inline static void set_empty(set_t s )  __attribute__((__unused__)) ;
#line 253 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static void set_empty(set_t s ) 
{ 


  {
  {
#line 255
  memset((void *)s, 0, (((*(s + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
  }
#line 256
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.h"
int __attribute__((__visibility__("default")))  graph_weighted(graph_t *g ) ;
#line 49
__inline static int graph_subgraph_weight(graph_t *g , set_t s )  __attribute__((__unused__)) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.h"
__inline static int graph_subgraph_weight(graph_t *g , set_t s ) 
{ 
  int i ;
  int j ;
  int count ;
  setelement e ;

  {
#line 52
  count = 0;
#line 55
  i = 0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! ((setelement )i < ((*(s + -1) + 64UL) - 1UL) / 64UL)) {
#line 55
      goto while_break;
    }
#line 56
    if (*(s + i)) {
#line 57
      e = *(s + i);
#line 58
      j = 0;
      {
#line 58
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 58
        if (! (j < 64)) {
#line 58
          goto while_break___0;
        }
#line 59
        if (e & 1UL) {
#line 60
          count += *(g->weights + (i * 64 + j));
        }
#line 61
        e >>= 1;
#line 58
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return (count);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.h"
int __attribute__((__visibility__("default")))  *reorder_duplicate(int *order , int n ) ;
#line 13
int __attribute__((__visibility__("default")))  *reorder_ident(int n ) ;
#line 14
int __attribute__((__visibility__("default")))  reorder_is_bijection(int *order ,
                                                                     int n ) ;
#line 18
int __attribute__((__visibility__("default")))  *reorder_by_greedy_coloring(graph_t *g ,
                                                                            int weighted ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.h"
clique_options __attribute__((__visibility__("default")))  *clique_default_options ;
#line 30
int __attribute__((__visibility__("default")))  clique_max_weight(graph_t *g , clique_options *opts ) ;
#line 31
set_t __attribute__((__visibility__("default")))  clique_find_single(graph_t *g ,
                                                                     int min_weight___0 ,
                                                                     int max_weight___0 ,
                                                                     int maximal___0 ,
                                                                     clique_options *opts ) ;
#line 33
int __attribute__((__visibility__("default")))  clique_find_all(graph_t *g , int min_weight___0 ,
                                                                int max_weight___0 ,
                                                                int maximal___0 ,
                                                                clique_options *opts ) ;
#line 38
int __attribute__((__visibility__("default")))  clique_unweighted_max_weight(graph_t *g ,
                                                                             clique_options *opts ) ;
#line 39
set_t __attribute__((__visibility__("default")))  clique_unweighted_find_single(graph_t *g ,
                                                                                int min_size ,
                                                                                int max_size ,
                                                                                int maximal___0 ,
                                                                                clique_options *opts ) ;
#line 42
int __attribute__((__visibility__("default")))  clique_unweighted_find_all(graph_t *g ,
                                                                           int min_size ,
                                                                           int max_size ,
                                                                           int maximal___0 ,
                                                                           clique_options *opts ) ;
#line 46
int __attribute__((__visibility__("default")))  clique_print_time(int level , int i ,
                                                                  int n , int max ,
                                                                  double cputime ,
                                                                  double realtime ,
                                                                  clique_options *opts ) ;
#line 49
int __attribute__((__visibility__("default")))  clique_print_time_always(int level ,
                                                                         int i , int n ,
                                                                         int max ,
                                                                         double cputime ,
                                                                         double realtime ,
                                                                         clique_options *opts ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static clique_options clique_default_options_struct  = 
#line 20 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
     {(int *(*)(graph_t * , int  ))(& reorder_by_greedy_coloring), (int *)((void *)0),
    (int (*)(int  , int  , int  , int  , double  , double  , clique_options * ))(& clique_print_time),
    (FILE *)((void *)0), (int (*)(set_t  , graph_t * , clique_options * ))((void *)0),
    (void *)0, (set_t *)((void *)0), 0};
#line 23 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
clique_options __attribute__((__visibility__("default")))  *clique_default_options  =    (clique_options __attribute__((__visibility__("default")))  *)(& clique_default_options_struct);
#line 33 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int *clique_size  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static set_t current_clique  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static set_t best_clique  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static struct tms cputimer  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static struct timeval realtimer  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int clique_list_count  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int weight_multiplier  =    1;
#line 43 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int **temp_list  =    (int **)((void *)0);
#line 44 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int temp_count  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int entrance_level  =    0;
#line 81 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int clocks_per_sec  =    0;
#line 87
static int sub_unweighted_single(int *table , int size , int min_size , graph_t *g ) ;
#line 89
static int sub_unweighted_all(int *table , int size , int min_size , int max_size ,
                              int maximal___0 , graph_t *g , clique_options *opts ) ;
#line 92
static int sub_weighted_all(int *table , int size , int weight , int current_weight ,
                            int prune_low , int prune_high , int min_weight___0 ,
                            int max_weight___0 , int maximal___0 , graph_t *g , clique_options *opts ) ;
#line 98
static int store_clique(set_t clique , graph_t *g , clique_options *opts ) ;
#line 99
static int is_maximal(set_t clique , graph_t *g ) ;
#line 100
static int false_function(set_t clique , graph_t *g , clique_options *opts ) ;
#line 139 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int unweighted_clique_search_single(int *table , int min_size , graph_t *g ,
                                           clique_options *opts ) 
{ 
  struct tms tms ;
  struct timeval timeval ;
  int i ;
  int j ;
  int v ;
  int w ;
  int *newtable ;
  int newsize ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 148
  v = *(table + 0);
#line 149
  *(clique_size + v) = 1;
#line 150
  set_empty(current_clique);
#line 151
  *(current_clique + v / 64) |= 1UL << v % 64;
  }
#line 152
  if (min_size == 1) {
#line 153
    return (1);
  }
#line 155
  if (temp_count) {
#line 156
    temp_count --;
#line 157
    newtable = *(temp_list + temp_count);
  } else {
    {
#line 159
    tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 159
    newtable = (int *)tmp;
    }
  }
#line 161
  i = 1;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < g->n)) {
#line 161
      goto while_break;
    }
#line 162
    w = v;
#line 163
    v = *(table + i);
#line 165
    newsize = 0;
#line 166
    j = 0;
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 166
      if (! (j < i)) {
#line 166
        goto while_break___0;
      }
#line 167
      if (v < g->n) {
#line 167
        if ((setelement )*(table + j) < *(*(g->edges + v) + -1)) {
#line 167
          tmp___0 = *(*(g->edges + v) + *(table + j) / 64) & (1UL << *(table + j) % 64);
        } else {
#line 167
          tmp___0 = 0UL;
        }
#line 167
        tmp___1 = tmp___0;
      } else {
#line 167
        tmp___1 = 0UL;
      }
#line 167
      if (tmp___1) {
#line 168
        *(newtable + newsize) = *(table + j);
#line 169
        newsize ++;
      }
#line 166
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 173
    tmp___2 = sub_unweighted_single(newtable, newsize, *(clique_size + w), g);
    }
#line 173
    if (tmp___2) {
#line 174
      *(current_clique + v / 64) |= 1UL << v % 64;
#line 175
      *(clique_size + v) = *(clique_size + w) + 1;
    } else {
#line 177
      *(clique_size + v) = *(clique_size + w);
    }
#line 180
    if (opts) {
#line 180
      if (opts->time_function) {
        {
#line 181
        gettimeofday((struct timeval */* __restrict  */)(& timeval), (__timezone_ptr_t )((void *)0));
#line 182
        times(& tms);
#line 183
        tmp___4 = (*(opts->time_function))(entrance_level, i + 1, g->n, *(clique_size + v) * weight_multiplier,
                                           (double )(tms.tms_utime - cputimer.tms_utime) / (double )clocks_per_sec,
                                           (double )(timeval.tv_sec - realtimer.tv_sec) + (double )(timeval.tv_usec - realtimer.tv_usec) / (double )1000000,
                                           opts);
        }
#line 183
        if (! tmp___4) {
#line 194
          tmp___3 = temp_count;
#line 194
          temp_count ++;
#line 194
          *(temp_list + tmp___3) = newtable;
#line 195
          return (0);
        }
      }
    }
#line 199
    if (min_size) {
#line 200
      if (*(clique_size + v) >= min_size) {
#line 201
        tmp___5 = temp_count;
#line 201
        temp_count ++;
#line 201
        *(temp_list + tmp___5) = newtable;
#line 202
        return (*(clique_size + v));
      }
#line 204
      if (((*(clique_size + v) + g->n) - i) - 1 < min_size) {
#line 205
        tmp___6 = temp_count;
#line 205
        temp_count ++;
#line 205
        *(temp_list + tmp___6) = newtable;
#line 206
        return (0);
      }
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  tmp___7 = temp_count;
#line 211
  temp_count ++;
#line 211
  *(temp_list + tmp___7) = newtable;
#line 213
  if (min_size) {
#line 214
    return (0);
  }
#line 215
  return (*(clique_size + v));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int sub_unweighted_single(int *table , int size , int min_size , graph_t *g ) 
{ 
  int i ;
  int v ;
  int *newtable ;
  int *p1 ;
  int *p2 ;
  void *tmp ;
  int w ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 243
  if (min_size <= 1) {
#line 244
    if (size > 0) {
#line 244
      if (min_size == 1) {
        {
#line 245
        set_empty(current_clique);
#line 246
        *(current_clique + *(table + 0) / 64) |= 1UL << *(table + 0) % 64;
        }
#line 247
        return (1);
      }
    }
#line 249
    if (min_size == 0) {
      {
#line 250
      set_empty(current_clique);
      }
#line 251
      return (1);
    }
#line 253
    return (0);
  }
#line 255
  if (size < min_size) {
#line 256
    return (0);
  }
#line 259
  if (temp_count) {
#line 260
    temp_count --;
#line 261
    newtable = *(temp_list + temp_count);
  } else {
    {
#line 263
    tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 263
    newtable = (int *)tmp;
    }
  }
#line 266
  i = size - 1;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if (! (i >= 0)) {
#line 266
      goto while_break;
    }
#line 267
    v = *(table + i);
#line 269
    if (*(clique_size + v) < min_size) {
#line 270
      goto while_break;
    }
#line 273
    if (i + 1 < min_size) {
#line 274
      goto while_break;
    }
#line 277
    p1 = newtable;
#line 278
    p2 = table;
    {
#line 278
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 278
      if (! ((unsigned long )p2 < (unsigned long )(table + i))) {
#line 278
        goto while_break___0;
      }
#line 279
      w = *p2;
#line 280
      if (v < g->n) {
#line 280
        if ((setelement )w < *(*(g->edges + v) + -1)) {
#line 280
          tmp___0 = *(*(g->edges + v) + w / 64) & (1UL << w % 64);
        } else {
#line 280
          tmp___0 = 0UL;
        }
#line 280
        tmp___1 = tmp___0;
      } else {
#line 280
        tmp___1 = 0UL;
      }
#line 280
      if (tmp___1) {
#line 281
        *p1 = w;
#line 282
        p1 ++;
      }
#line 278
      p2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 287
    if (p1 - newtable < (long )(min_size - 1)) {
#line 288
      goto __Cont;
    }
#line 291
    if (*(clique_size + *(newtable + ((p1 - newtable) - 1L))) < min_size - 1) {
#line 292
      goto __Cont;
    }
    {
#line 294
    tmp___3 = sub_unweighted_single(newtable, (int )(p1 - newtable), min_size - 1,
                                    g);
    }
#line 294
    if (tmp___3) {
#line 297
      *(current_clique + v / 64) |= 1UL << v % 64;
#line 298
      tmp___2 = temp_count;
#line 298
      temp_count ++;
#line 298
      *(temp_list + tmp___2) = newtable;
#line 299
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 266
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  tmp___4 = temp_count;
#line 302
  temp_count ++;
#line 302
  *(temp_list + tmp___4) = newtable;
#line 303
  return (0);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int unweighted_clique_search_all(int *table , int start , int min_size , int max_size ,
                                        int maximal___0 , graph_t *g , clique_options *opts ) 
{ 
  struct timeval timeval ;
  struct tms tms ;
  int i ;
  int j ;
  int v ;
  int *newtable ;
  int newsize ;
  int count ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 343
  count = 0;
#line 345
  if (temp_count) {
#line 346
    temp_count --;
#line 347
    newtable = *(temp_list + temp_count);
  } else {
    {
#line 349
    tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 349
    newtable = (int *)tmp;
    }
  }
  {
#line 352
  clique_list_count = 0;
#line 353
  set_empty(current_clique);
#line 354
  i = start;
  }
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! (i < g->n)) {
#line 354
      goto while_break;
    }
#line 355
    v = *(table + i);
#line 356
    *(clique_size + v) = min_size;
#line 358
    newsize = 0;
#line 359
    j = 0;
    {
#line 359
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 359
      if (! (j < i)) {
#line 359
        goto while_break___0;
      }
#line 360
      if (v < g->n) {
#line 360
        if ((setelement )*(table + j) < *(*(g->edges + v) + -1)) {
#line 360
          tmp___0 = *(*(g->edges + v) + *(table + j) / 64) & (1UL << *(table + j) % 64);
        } else {
#line 360
          tmp___0 = 0UL;
        }
#line 360
        tmp___1 = tmp___0;
      } else {
#line 360
        tmp___1 = 0UL;
      }
#line 360
      if (tmp___1) {
#line 361
        *(newtable + newsize) = *(table + j);
#line 362
        newsize ++;
      }
#line 359
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 366
    *(current_clique + v / 64) |= 1UL << v % 64;
#line 367
    j = sub_unweighted_all(newtable, newsize, min_size - 1, max_size - 1, maximal___0,
                           g, opts);
#line 369
    *(current_clique + v / 64) &= ~ (1UL << v % 64);
    }
#line 370
    if (j < 0) {
#line 372
      count -= j;
#line 373
      goto while_break;
    }
#line 375
    count += j;
#line 377
    if (opts->time_function) {
      {
#line 378
      gettimeofday((struct timeval */* __restrict  */)(& timeval), (__timezone_ptr_t )((void *)0));
#line 379
      times(& tms);
#line 380
      tmp___2 = (*(opts->time_function))(entrance_level, i + 1, g->n, min_size * weight_multiplier,
                                         (double )(tms.tms_utime - cputimer.tms_utime) / (double )clocks_per_sec,
                                         (double )(timeval.tv_sec - realtimer.tv_sec) + (double )(timeval.tv_usec - realtimer.tv_usec) / (double )1000000,
                                         opts);
      }
#line 380
      if (! tmp___2) {
#line 392
        goto while_break;
      }
    }
#line 354
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  tmp___3 = temp_count;
#line 396
  temp_count ++;
#line 396
  *(temp_list + tmp___3) = newtable;
#line 397
  return (count);
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int sub_unweighted_all(int *table , int size , int min_size , int max_size ,
                              int maximal___0 , graph_t *g , clique_options *opts ) 
{ 
  int i ;
  int v ;
  int n ;
  int *newtable ;
  int *p1 ;
  int *p2 ;
  int count ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int w ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;

  {
#line 433
  count = 0;
#line 435
  if (min_size <= 0) {
#line 436
    if (! maximal___0) {
#line 436
      goto _L;
    } else {
      {
#line 436
      tmp___0 = is_maximal(current_clique, g);
      }
#line 436
      if (tmp___0) {
        _L: /* CIL Label */ 
        {
#line 438
        count ++;
#line 439
        tmp = store_clique(current_clique, g, opts);
        }
#line 439
        if (! tmp) {
#line 440
          return (- count);
        }
      }
    }
#line 443
    if (max_size <= 0) {
#line 445
      return (count);
    }
  }
#line 449
  if (size < min_size) {
#line 450
    return (count);
  }
#line 454
  if (temp_count) {
#line 455
    temp_count --;
#line 456
    newtable = *(temp_list + temp_count);
  } else {
    {
#line 458
    tmp___1 = malloc((unsigned long )g->n * sizeof(int ));
#line 458
    newtable = (int *)tmp___1;
    }
  }
#line 461
  i = size - 1;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (i >= 0)) {
#line 461
      goto while_break;
    }
#line 462
    v = *(table + i);
#line 463
    if (*(clique_size + v) < min_size) {
#line 464
      goto while_break;
    }
#line 466
    if (i + 1 < min_size) {
#line 467
      goto while_break;
    }
#line 471
    p1 = newtable;
#line 472
    p2 = table;
    {
#line 472
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 472
      if (! ((unsigned long )p2 < (unsigned long )(table + i))) {
#line 472
        goto while_break___0;
      }
#line 473
      w = *p2;
#line 474
      if (v < g->n) {
#line 474
        if ((setelement )w < *(*(g->edges + v) + -1)) {
#line 474
          tmp___2 = *(*(g->edges + v) + w / 64) & (1UL << w % 64);
        } else {
#line 474
          tmp___2 = 0UL;
        }
#line 474
        tmp___3 = tmp___2;
      } else {
#line 474
        tmp___3 = 0UL;
      }
#line 474
      if (tmp___3) {
#line 475
        *p1 = w;
#line 476
        p1 ++;
      }
#line 472
      p2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 481
    if (p1 - newtable < (long )(min_size - 1)) {
#line 482
      goto __Cont;
    }
    {
#line 485
    *(current_clique + v / 64) |= 1UL << v % 64;
#line 486
    n = sub_unweighted_all(newtable, (int )(p1 - newtable), min_size - 1, max_size - 1,
                           maximal___0, g, opts);
#line 488
    *(current_clique + v / 64) &= ~ (1UL << v % 64);
    }
#line 489
    if (n < 0) {
#line 491
      count -= n;
#line 492
      count = - count;
#line 493
      goto while_break;
    }
#line 495
    count += n;
    __Cont: /* CIL Label */ 
#line 461
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 497
  tmp___4 = temp_count;
#line 497
  temp_count ++;
#line 497
  *(temp_list + tmp___4) = newtable;
#line 498
  return (count);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int weighted_clique_search_single(int *table , int min_weight___0 , int max_weight___0 ,
                                         graph_t *g , clique_options *opts ) 
{ 
  struct timeval timeval ;
  struct tms tms ;
  int i ;
  int j ;
  int v ;
  int *newtable ;
  int newsize ;
  int newweight ;
  int search_weight ;
  int min_w ;
  clique_options localopts ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 552
  if (min_weight___0 == 0) {
#line 553
    min_w = 2147483647;
  } else {
#line 555
    min_w = min_weight___0;
  }
#line 558
  if (min_weight___0 == 1) {
#line 562
    i = 0;
    {
#line 562
    while (1) {
      while_continue: /* CIL Label */ ;
#line 562
      if (! (i < g->n)) {
#line 562
        goto while_break;
      }
#line 563
      if (*(g->weights + *(table + i)) <= max_weight___0) {
        {
#line 564
        set_empty(best_clique);
#line 565
        *(best_clique + *(table + i) / 64) |= 1UL << *(table + i) % 64;
        }
#line 566
        return (*(g->weights + *(table + i)));
      }
#line 562
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 569
    return (0);
  }
  {
#line 572
  localopts.time_function = (int (*)(int  , int  , int  , int  , double  , double  ,
                                     clique_options * ))((void *)0);
#line 573
  localopts.reorder_function = (int *(*)(graph_t * , int  ))((void *)0);
#line 574
  localopts.reorder_map = (int *)((void *)0);
#line 575
  localopts.user_function = & false_function;
#line 576
  localopts.user_data = (void *)0;
#line 577
  localopts.clique_list = & best_clique;
#line 578
  localopts.clique_list_length = 1;
#line 579
  clique_list_count = 0;
#line 581
  v = *(table + 0);
#line 582
  set_empty(best_clique);
#line 583
  *(best_clique + v / 64) |= 1UL << v % 64;
#line 584
  search_weight = *(g->weights + v);
  }
#line 585
  if (min_weight___0) {
#line 585
    if (search_weight >= min_weight___0) {
#line 586
      if (search_weight <= max_weight___0) {
#line 588
        return (search_weight);
      }
#line 590
      search_weight = min_weight___0 - 1;
    }
  }
  {
#line 592
  *(clique_size + v) = search_weight;
#line 593
  set_empty(current_clique);
  }
#line 595
  if (temp_count) {
#line 596
    temp_count --;
#line 597
    newtable = *(temp_list + temp_count);
  } else {
    {
#line 599
    tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 599
    newtable = (int *)tmp;
    }
  }
#line 602
  i = 1;
  {
#line 602
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 602
    if (! (i < g->n)) {
#line 602
      goto while_break___0;
    }
#line 603
    v = *(table + i);
#line 605
    newsize = 0;
#line 606
    newweight = 0;
#line 607
    j = 0;
    {
#line 607
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 607
      if (! (j < i)) {
#line 607
        goto while_break___1;
      }
#line 608
      if (v < g->n) {
#line 608
        if ((setelement )*(table + j) < *(*(g->edges + v) + -1)) {
#line 608
          tmp___0 = *(*(g->edges + v) + *(table + j) / 64) & (1UL << *(table + j) % 64);
        } else {
#line 608
          tmp___0 = 0UL;
        }
#line 608
        tmp___1 = tmp___0;
      } else {
#line 608
        tmp___1 = 0UL;
      }
#line 608
      if (tmp___1) {
#line 609
        newweight += *(g->weights + *(table + j));
#line 610
        *(newtable + newsize) = *(table + j);
#line 611
        newsize ++;
      }
#line 607
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 616
    *(current_clique + v / 64) |= 1UL << v % 64;
#line 617
    search_weight = sub_weighted_all(newtable, newsize, newweight, *(g->weights + v),
                                     search_weight, *(clique_size + *(table + (i - 1))) + *(g->weights + v),
                                     min_w, max_weight___0, 0, g, & localopts);
#line 623
    *(current_clique + v / 64) &= ~ (1UL << v % 64);
    }
#line 624
    if (search_weight < 0) {
#line 625
      goto while_break___0;
    }
#line 628
    *(clique_size + v) = search_weight;
#line 630
    if (opts->time_function) {
      {
#line 631
      gettimeofday((struct timeval */* __restrict  */)(& timeval), (__timezone_ptr_t )((void *)0));
#line 632
      times(& tms);
#line 633
      tmp___2 = (*(opts->time_function))(entrance_level, i + 1, g->n, *(clique_size + v) * weight_multiplier,
                                         (double )(tms.tms_utime - cputimer.tms_utime) / (double )clocks_per_sec,
                                         (double )(timeval.tv_sec - realtimer.tv_sec) + (double )(timeval.tv_usec - realtimer.tv_usec) / (double )1000000,
                                         opts);
      }
#line 633
      if (! tmp___2) {
        {
#line 644
        set_free(current_clique);
#line 645
        current_clique = (set_t )((void *)0);
        }
#line 646
        goto while_break___0;
      }
    }
#line 602
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 650
  tmp___3 = temp_count;
#line 650
  temp_count ++;
#line 650
  *(temp_list + tmp___3) = newtable;
#line 651
  if (min_weight___0) {
#line 651
    if (search_weight > 0) {
#line 653
      return (0);
    }
  }
#line 655
  return (*(clique_size + *(table + (i - 1))));
}
}
#line 685 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int weighted_clique_search_all(int *table , int start , int min_weight___0 ,
                                      int max_weight___0 , int maximal___0 , graph_t *g ,
                                      clique_options *opts ) 
{ 
  struct timeval timeval ;
  struct tms tms ;
  int i ;
  int j ;
  int v ;
  int *newtable ;
  int newsize ;
  int newweight ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 697
  if (temp_count) {
#line 698
    temp_count --;
#line 699
    newtable = *(temp_list + temp_count);
  } else {
    {
#line 701
    tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 701
    newtable = (int *)tmp;
    }
  }
  {
#line 704
  clique_list_count = 0;
#line 705
  set_empty(current_clique);
#line 706
  i = start;
  }
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! (i < g->n)) {
#line 706
      goto while_break;
    }
#line 707
    v = *(table + i);
#line 708
    *(clique_size + v) = min_weight___0;
#line 710
    newsize = 0;
#line 711
    newweight = 0;
#line 712
    j = 0;
    {
#line 712
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 712
      if (! (j < i)) {
#line 712
        goto while_break___0;
      }
#line 713
      if (v < g->n) {
#line 713
        if ((setelement )*(table + j) < *(*(g->edges + v) + -1)) {
#line 713
          tmp___0 = *(*(g->edges + v) + *(table + j) / 64) & (1UL << *(table + j) % 64);
        } else {
#line 713
          tmp___0 = 0UL;
        }
#line 713
        tmp___1 = tmp___0;
      } else {
#line 713
        tmp___1 = 0UL;
      }
#line 713
      if (tmp___1) {
#line 714
        *(newtable + newsize) = *(table + j);
#line 715
        newweight += *(g->weights + *(table + j));
#line 716
        newsize ++;
      }
#line 712
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 720
    *(current_clique + v / 64) |= 1UL << v % 64;
#line 721
    j = sub_weighted_all(newtable, newsize, newweight, *(g->weights + v), min_weight___0 - 1,
                         2147483647, min_weight___0, max_weight___0, maximal___0,
                         g, opts);
#line 724
    *(current_clique + v / 64) &= ~ (1UL << v % 64);
    }
#line 726
    if (j < 0) {
#line 728
      goto while_break;
    }
#line 731
    if (opts->time_function) {
      {
#line 732
      gettimeofday((struct timeval */* __restrict  */)(& timeval), (__timezone_ptr_t )((void *)0));
#line 733
      times(& tms);
#line 734
      tmp___2 = (*(opts->time_function))(entrance_level, i + 1, g->n, *(clique_size + v) * weight_multiplier,
                                         (double )(tms.tms_utime - cputimer.tms_utime) / (double )clocks_per_sec,
                                         (double )(timeval.tv_sec - realtimer.tv_sec) + (double )(timeval.tv_usec - realtimer.tv_usec) / (double )1000000,
                                         opts);
      }
#line 734
      if (! tmp___2) {
        {
#line 745
        set_free(current_clique);
#line 746
        current_clique = (set_t )((void *)0);
        }
#line 747
        goto while_break;
      }
    }
#line 706
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 751
  tmp___3 = temp_count;
#line 751
  temp_count ++;
#line 751
  *(temp_list + tmp___3) = newtable;
#line 753
  return (clique_list_count);
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int sub_weighted_all(int *table , int size , int weight , int current_weight ,
                            int prune_low , int prune_high , int min_weight___0 ,
                            int max_weight___0 , int maximal___0 , graph_t *g , clique_options *opts ) 
{ 
  int i ;
  int v ;
  int w ;
  int *newtable ;
  int *p1 ;
  int *p2 ;
  int newweight ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;

  {
#line 806
  if (current_weight >= min_weight___0) {
#line 807
    if (current_weight <= max_weight___0) {
#line 807
      if (! maximal___0) {
#line 807
        goto _L;
      } else {
        {
#line 807
        tmp___0 = is_maximal(current_clique, g);
        }
#line 807
        if (tmp___0) {
          _L: /* CIL Label */ 
          {
#line 810
          tmp = store_clique(current_clique, g, opts);
          }
#line 810
          if (! tmp) {
#line 811
            return (-1);
          }
        }
      }
    }
#line 814
    if (current_weight >= max_weight___0) {
#line 816
      return (min_weight___0 - 1);
    }
  }
#line 819
  if (size <= 0) {
#line 822
    if (current_weight > prune_low) {
#line 823
      if (best_clique) {
        {
#line 824
        set_copy(best_clique, current_clique);
        }
      }
#line 825
      if (current_weight < min_weight___0) {
#line 826
        return (current_weight);
      } else {
#line 828
        return (min_weight___0 - 1);
      }
    } else {
#line 830
      return (prune_low);
    }
  }
#line 835
  if (temp_count) {
#line 836
    temp_count --;
#line 837
    newtable = *(temp_list + temp_count);
  } else {
    {
#line 839
    tmp___1 = malloc((unsigned long )g->n * sizeof(int ));
#line 839
    newtable = (int *)tmp___1;
    }
  }
#line 842
  i = size - 1;
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
#line 842
    if (! (i >= 0)) {
#line 842
      goto while_break;
    }
#line 843
    v = *(table + i);
#line 844
    if (current_weight + *(clique_size + v) <= prune_low) {
#line 846
      goto while_break;
    }
#line 848
    if (current_weight + weight <= prune_low) {
#line 850
      goto while_break;
    }
#line 854
    p1 = newtable;
#line 855
    newweight = 0;
#line 856
    p2 = table;
    {
#line 856
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 856
      if (! ((unsigned long )p2 < (unsigned long )(table + i))) {
#line 856
        goto while_break___0;
      }
#line 857
      w = *p2;
#line 858
      if (v < g->n) {
#line 858
        if ((setelement )w < *(*(g->edges + v) + -1)) {
#line 858
          tmp___2 = *(*(g->edges + v) + w / 64) & (1UL << w % 64);
        } else {
#line 858
          tmp___2 = 0UL;
        }
#line 858
        tmp___3 = tmp___2;
      } else {
#line 858
        tmp___3 = 0UL;
      }
#line 858
      if (tmp___3) {
#line 859
        *p1 = w;
#line 860
        newweight += *(g->weights + w);
#line 861
        p1 ++;
      }
#line 856
      p2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 865
    w = *(g->weights + v);
#line 866
    weight -= w;
#line 868
    if ((current_weight + w) + newweight <= prune_low) {
#line 869
      goto __Cont;
    }
    {
#line 872
    *(current_clique + v / 64) |= 1UL << v % 64;
#line 873
    prune_low = sub_weighted_all(newtable, (int )(p1 - newtable), newweight, current_weight + w,
                                 prune_low, prune_high, min_weight___0, max_weight___0,
                                 maximal___0, g, opts);
#line 879
    *(current_clique + v / 64) &= ~ (1UL << v % 64);
    }
#line 880
    if (prune_low < 0) {
#line 882
      goto while_break;
    } else
#line 880
    if (prune_low >= prune_high) {
#line 882
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 842
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 885
  tmp___4 = temp_count;
#line 885
  temp_count ++;
#line 885
  *(temp_list + tmp___4) = newtable;
#line 886
  return (prune_low);
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int store_clique(set_t clique , graph_t *g , clique_options *opts ) 
{ 
  int tmp ;

  {
#line 908
  clique_list_count ++;
#line 911
  if (opts->clique_list) {
#line 917
    if (clique_list_count <= 0) {
      {
#line 918
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CLIQUER INTERNAL ERROR: clique_list_count has negative value!\n");
#line 920
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please report as a bug.\n");
#line 921
      abort();
      }
    }
#line 923
    if (clique_list_count <= opts->clique_list_length) {
      {
#line 924
      *(opts->clique_list + (clique_list_count - 1)) = set_duplicate(clique);
      }
    }
  }
#line 929
  if (opts->user_function) {
    {
#line 930
    tmp = (*(opts->user_function))(clique, g, opts);
    }
#line 930
    if (! tmp) {
#line 932
      return (0);
    }
  }
#line 936
  return (1);
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static void maximalize_clique(set_t s , graph_t *g ) 
{ 
  int i ;
  int j ;
  int add ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 955
  i = 0;
  {
#line 955
  while (1) {
    while_continue: /* CIL Label */ ;
#line 955
    if (! (i < g->n)) {
#line 955
      goto while_break;
    }
#line 956
    add = 1;
#line 957
    j = 0;
    {
#line 957
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 957
      if (! (j < g->n)) {
#line 957
        goto while_break___0;
      }
#line 958
      if (*(s + j / 64) & (1UL << j % 64)) {
#line 958
        if (i < g->n) {
#line 958
          if ((setelement )j < *(*(g->edges + i) + -1)) {
#line 958
            tmp = *(*(g->edges + i) + j / 64) & (1UL << j % 64);
          } else {
#line 958
            tmp = 0UL;
          }
#line 958
          tmp___0 = tmp;
        } else {
#line 958
          tmp___0 = 0UL;
        }
#line 958
        if (! tmp___0) {
#line 959
          add = 0;
#line 960
          goto while_break___0;
        }
      }
#line 957
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 963
    if (add) {
#line 964
      *(s + i / 64) |= 1UL << i % 64;
    }
#line 955
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 967
  return;
}
}
#line 981 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int is_maximal(set_t clique , graph_t *g ) 
{ 
  int i ;
  int j ;
  int *table ;
  int len ;
  int addable ;
  void *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 987
  if (temp_count) {
#line 988
    temp_count --;
#line 989
    table = *(temp_list + temp_count);
  } else {
    {
#line 991
    tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 991
    table = (int *)tmp;
    }
  }
#line 994
  len = 0;
#line 995
  i = 0;
  {
#line 995
  while (1) {
    while_continue: /* CIL Label */ ;
#line 995
    if (! (i < g->n)) {
#line 995
      goto while_break;
    }
#line 996
    if (*(clique + i / 64) & (1UL << i % 64)) {
#line 997
      tmp___0 = len;
#line 997
      len ++;
#line 997
      *(table + tmp___0) = i;
    }
#line 995
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < g->n)) {
#line 999
      goto while_break___0;
    }
#line 1000
    addable = 1;
#line 1001
    j = 0;
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1001
      if (! (j < len)) {
#line 1001
        goto while_break___1;
      }
#line 1002
      if (i < g->n) {
#line 1002
        if ((setelement )*(table + j) < *(*(g->edges + i) + -1)) {
#line 1002
          tmp___1 = *(*(g->edges + i) + *(table + j) / 64) & (1UL << *(table + j) % 64);
        } else {
#line 1002
          tmp___1 = 0UL;
        }
#line 1002
        tmp___2 = tmp___1;
      } else {
#line 1002
        tmp___2 = 0UL;
      }
#line 1002
      if (! tmp___2) {
#line 1003
        addable = 0;
#line 1004
        goto while_break___1;
      }
#line 1001
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1007
    if (addable) {
#line 1008
      tmp___3 = temp_count;
#line 1008
      temp_count ++;
#line 1008
      *(temp_list + tmp___3) = table;
#line 1009
      return (0);
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1012
  tmp___4 = temp_count;
#line 1012
  temp_count ++;
#line 1012
  *(temp_list + tmp___4) = table;
#line 1013
  return (1);
}
}
#line 1022 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int false_function(set_t clique , graph_t *g , clique_options *opts ) 
{ 


  {
#line 1023
  return (0);
}
}
#line 1044 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
int __attribute__((__visibility__("default")))  clique_unweighted_max_weight(graph_t *g ,
                                                                             clique_options *opts ) 
{ 
  set_t s ;
  int size ;
  set_t __attribute__((__visibility__("default")))  tmp ;

  {
#line 1048
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 1048
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1048,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 1048
    abort();
    }
  }
#line 1049
  if (! ((unsigned long )g != (unsigned long )((void *)0))) {
    {
#line 1049
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1049,
            "g!=NULL");
#line 1049
    abort();
    }
  }
  {
#line 1051
  tmp = clique_unweighted_find_single(g, 0, 0, 0, opts);
#line 1051
  s = (set_t )tmp;
  }
#line 1052
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1054
    return ((int __attribute__((__visibility__("default")))  )0);
  }
  {
#line 1056
  size = set_size(s);
#line 1057
  set_free(s);
  }
#line 1058
  return ((int __attribute__((__visibility__("default")))  )size);
}
}
#line 1083 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
set_t __attribute__((__visibility__("default")))  clique_unweighted_find_single(graph_t *g ,
                                                                                int min_size ,
                                                                                int max_size ,
                                                                                int maximal___0 ,
                                                                                clique_options *opts ) 
{ 
  int i ;
  int *table ;
  set_t s ;
  int *old_clique_size ;
  set_t old_current_clique ;
  set_t old_best_clique ;
  int old_clique_list_count ;
  int old_weight_multiplier ;
  int **old_temp_list ;
  int old_temp_count ;
  struct tms old_cputimer ;
  struct timeval old_realtimer ;
  long tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int __attribute__((__visibility__("default")))  *tmp___2 ;
  int __attribute__((__visibility__("default")))  *tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;
  clique_options localopts ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1089
  old_clique_size = clique_size;
#line 1089
  old_current_clique = current_clique;
#line 1089
  old_best_clique = best_clique;
#line 1089
  old_clique_list_count = clique_list_count;
#line 1089
  old_weight_multiplier = weight_multiplier;
#line 1089
  old_temp_list = temp_list;
#line 1089
  old_temp_count = temp_count;
#line 1089
  memcpy((void */* __restrict  */)(& old_cputimer), (void const   */* __restrict  */)(& cputimer),
         sizeof(struct tms ));
#line 1089
  memcpy((void */* __restrict  */)(& old_realtimer), (void const   */* __restrict  */)(& realtimer),
         sizeof(struct timeval ));
#line 1090
  entrance_level ++;
  }
#line 1092
  if ((unsigned long )opts == (unsigned long )((void *)0)) {
#line 1093
    opts = (clique_options *)clique_default_options;
  }
#line 1095
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 1095
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1095,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 1095
    abort();
    }
  }
#line 1096
  if (! ((unsigned long )g != (unsigned long )((void *)0))) {
    {
#line 1096
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1096,
            "g!=NULL");
#line 1096
    abort();
    }
  }
#line 1097
  if (! (min_size >= 0)) {
    {
#line 1097
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1097,
            "min_size>=0");
#line 1097
    abort();
    }
  }
#line 1098
  if (! (max_size >= 0)) {
    {
#line 1098
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1098,
            "max_size>=0");
#line 1098
    abort();
    }
  }
#line 1099
  if (! (max_size == 0)) {
#line 1099
    if (! (min_size <= max_size)) {
      {
#line 1099
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
              "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c",
              1099, "(max_size==0) || (min_size <= max_size)");
#line 1099
      abort();
      }
    }
  }
#line 1100
  if (min_size == 0) {
#line 1100
    if (max_size > 0) {
      {
#line 1100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
              "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c",
              1100, "!((min_size==0) && (max_size>0))");
#line 1100
      abort();
      }
    }
  }
#line 1101
  if (! ((unsigned long )opts->reorder_function == (unsigned long )((void *)0))) {
#line 1101
    if (! ((unsigned long )opts->reorder_map == (unsigned long )((void *)0))) {
      {
#line 1101
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
              "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c",
              1101, "(opts->reorder_function==NULL) || (opts->reorder_map==NULL)");
#line 1101
      abort();
      }
    }
  }
#line 1103
  if (max_size > 0) {
#line 1103
    if (min_size > max_size) {
#line 1105
      entrance_level --;
#line 1106
      return ((set_t __attribute__((__visibility__("default")))  )((void *)0));
    }
  }
#line 1109
  if (clocks_per_sec == 0) {
    {
#line 1110
    tmp = sysconf(2);
#line 1110
    clocks_per_sec = (int )tmp;
    }
  }
#line 1111
  if (! (clocks_per_sec > 0)) {
    {
#line 1111
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1111,
            "clocks_per_sec>0");
#line 1111
    abort();
    }
  }
  {
#line 1114
  current_clique = set_new(g->n);
#line 1115
  tmp___0 = malloc((unsigned long )g->n * sizeof(int ));
#line 1115
  clique_size = (int *)tmp___0;
#line 1117
  tmp___1 = malloc((unsigned long )(g->n + 2) * sizeof(int *));
#line 1117
  temp_list = (int **)tmp___1;
#line 1118
  temp_count = 0;
#line 1121
  gettimeofday((struct timeval */* __restrict  */)(& realtimer), (__timezone_ptr_t )((void *)0));
#line 1122
  times(& cputimer);
  }
#line 1125
  if (opts->reorder_function) {
    {
#line 1126
    table = (*(opts->reorder_function))(g, 0);
    }
  } else
#line 1127
  if (opts->reorder_map) {
    {
#line 1128
    tmp___2 = reorder_duplicate(opts->reorder_map, g->n);
#line 1128
    table = (int *)tmp___2;
    }
  } else {
    {
#line 1130
    tmp___3 = reorder_ident(g->n);
#line 1130
    table = (int *)tmp___3;
    }
  }
  {
#line 1132
  tmp___4 = reorder_is_bijection(table, g->n);
  }
#line 1132
  if (! tmp___4) {
    {
#line 1132
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1132,
            "reorder_is_bijection(table,g->n)");
#line 1132
    abort();
    }
  }
  {
#line 1135
  tmp___5 = unweighted_clique_search_single(table, min_size, g, opts);
  }
#line 1135
  if (tmp___5 == 0) {
    {
#line 1136
    set_free(current_clique);
#line 1137
    current_clique = (set_t )((void *)0);
    }
#line 1138
    goto cleanreturn;
  }
#line 1140
  if (maximal___0) {
#line 1140
    if (min_size > 0) {
      {
#line 1141
      maximalize_clique(current_clique, g);
      }
#line 1143
      if (max_size > 0) {
        {
#line 1143
        tmp___7 = set_size(current_clique);
        }
#line 1143
        if (tmp___7 > max_size) {
          {
#line 1146
          s = set_new(g->n);
#line 1147
          localopts.time_function = opts->time_function;
#line 1148
          localopts.output = opts->output;
#line 1149
          localopts.user_function = & false_function;
#line 1150
          localopts.clique_list = & s;
#line 1151
          localopts.clique_list_length = 1;
#line 1153
          i = 0;
          }
          {
#line 1153
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1153
            if (! (i < g->n - 1)) {
#line 1153
              goto while_break;
            }
#line 1154
            if (*(clique_size + *(table + i)) >= min_size) {
#line 1155
              goto while_break;
            }
#line 1153
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 1156
          tmp___6 = unweighted_clique_search_all(table, i, min_size, max_size, maximal___0,
                                                 g, & localopts);
          }
#line 1156
          if (tmp___6) {
            {
#line 1159
            set_free(current_clique);
#line 1160
            current_clique = s;
            }
          } else {
            {
#line 1162
            set_free(current_clique);
#line 1163
            current_clique = (set_t )((void *)0);
            }
          }
        }
      }
    }
  }
  cleanreturn: 
#line 1169
  s = current_clique;
#line 1172
  i = 0;
  {
#line 1172
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1172
    if (! (i < temp_count)) {
#line 1172
      goto while_break___0;
    }
    {
#line 1173
    free((void *)*(temp_list + i));
#line 1172
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1174
  free((void *)temp_list);
#line 1175
  free((void *)table);
#line 1176
  free((void *)clique_size);
#line 1178
  clique_size = old_clique_size;
#line 1178
  current_clique = old_current_clique;
#line 1178
  best_clique = old_best_clique;
#line 1178
  clique_list_count = old_clique_list_count;
#line 1178
  weight_multiplier = old_weight_multiplier;
#line 1178
  temp_list = old_temp_list;
#line 1178
  temp_count = old_temp_count;
#line 1178
  memcpy((void */* __restrict  */)(& cputimer), (void const   */* __restrict  */)(& old_cputimer),
         sizeof(struct tms ));
#line 1178
  memcpy((void */* __restrict  */)(& realtimer), (void const   */* __restrict  */)(& old_realtimer),
         sizeof(struct timeval ));
#line 1179
  entrance_level --;
  }
#line 1181
  return ((set_t __attribute__((__visibility__("default")))  )s);
}
}
#line 1207 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
int __attribute__((__visibility__("default")))  clique_unweighted_find_all(graph_t *g ,
                                                                           int min_size ,
                                                                           int max_size ,
                                                                           int maximal___0 ,
                                                                           clique_options *opts ) 
{ 
  int i ;
  int *table ;
  int count ;
  int *old_clique_size ;
  set_t old_current_clique ;
  set_t old_best_clique ;
  int old_clique_list_count ;
  int old_weight_multiplier ;
  int **old_temp_list ;
  int old_temp_count ;
  struct tms old_cputimer ;
  struct timeval old_realtimer ;
  long tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int __attribute__((__visibility__("default")))  *tmp___2 ;
  int __attribute__((__visibility__("default")))  *tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1213
  old_clique_size = clique_size;
#line 1213
  old_current_clique = current_clique;
#line 1213
  old_best_clique = best_clique;
#line 1213
  old_clique_list_count = clique_list_count;
#line 1213
  old_weight_multiplier = weight_multiplier;
#line 1213
  old_temp_list = temp_list;
#line 1213
  old_temp_count = temp_count;
#line 1213
  memcpy((void */* __restrict  */)(& old_cputimer), (void const   */* __restrict  */)(& cputimer),
         sizeof(struct tms ));
#line 1213
  memcpy((void */* __restrict  */)(& old_realtimer), (void const   */* __restrict  */)(& realtimer),
         sizeof(struct timeval ));
#line 1214
  entrance_level ++;
  }
#line 1216
  if ((unsigned long )opts == (unsigned long )((void *)0)) {
#line 1217
    opts = (clique_options *)clique_default_options;
  }
#line 1219
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 1219
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1219,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 1219
    abort();
    }
  }
#line 1220
  if (! ((unsigned long )g != (unsigned long )((void *)0))) {
    {
#line 1220
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1220,
            "g!=NULL");
#line 1220
    abort();
    }
  }
#line 1221
  if (! (min_size >= 0)) {
    {
#line 1221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1221,
            "min_size>=0");
#line 1221
    abort();
    }
  }
#line 1222
  if (! (max_size >= 0)) {
    {
#line 1222
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1222,
            "max_size>=0");
#line 1222
    abort();
    }
  }
#line 1223
  if (! (max_size == 0)) {
#line 1223
    if (! (min_size <= max_size)) {
      {
#line 1223
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
              "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c",
              1223, "(max_size==0) || (min_size <= max_size)");
#line 1223
      abort();
      }
    }
  }
#line 1224
  if (min_size == 0) {
#line 1224
    if (max_size > 0) {
      {
#line 1224
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
              "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c",
              1224, "!((min_size==0) && (max_size>0))");
#line 1224
      abort();
      }
    }
  }
#line 1225
  if (! ((unsigned long )opts->reorder_function == (unsigned long )((void *)0))) {
#line 1225
    if (! ((unsigned long )opts->reorder_map == (unsigned long )((void *)0))) {
      {
#line 1225
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
              "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c",
              1225, "(opts->reorder_function==NULL) || (opts->reorder_map==NULL)");
#line 1225
      abort();
      }
    }
  }
#line 1227
  if (max_size > 0) {
#line 1227
    if (min_size > max_size) {
#line 1229
      entrance_level --;
#line 1230
      return ((int __attribute__((__visibility__("default")))  )0);
    }
  }
#line 1233
  if (clocks_per_sec == 0) {
    {
#line 1234
    tmp = sysconf(2);
#line 1234
    clocks_per_sec = (int )tmp;
    }
  }
#line 1235
  if (! (clocks_per_sec > 0)) {
    {
#line 1235
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1235,
            "clocks_per_sec>0");
#line 1235
    abort();
    }
  }
  {
#line 1238
  current_clique = set_new(g->n);
#line 1239
  tmp___0 = malloc((unsigned long )g->n * sizeof(int ));
#line 1239
  clique_size = (int *)tmp___0;
#line 1241
  tmp___1 = malloc((unsigned long )(g->n + 2) * sizeof(int *));
#line 1241
  temp_list = (int **)tmp___1;
#line 1242
  temp_count = 0;
#line 1244
  clique_list_count = 0;
#line 1245
  memset((void *)clique_size, 0, (unsigned long )g->n * sizeof(int ));
#line 1248
  gettimeofday((struct timeval */* __restrict  */)(& realtimer), (__timezone_ptr_t )((void *)0));
#line 1249
  times(& cputimer);
  }
#line 1252
  if (opts->reorder_function) {
    {
#line 1253
    table = (*(opts->reorder_function))(g, 0);
    }
  } else
#line 1254
  if (opts->reorder_map) {
    {
#line 1255
    tmp___2 = reorder_duplicate(opts->reorder_map, g->n);
#line 1255
    table = (int *)tmp___2;
    }
  } else {
    {
#line 1257
    tmp___3 = reorder_ident(g->n);
#line 1257
    table = (int *)tmp___3;
    }
  }
  {
#line 1259
  tmp___4 = reorder_is_bijection(table, g->n);
  }
#line 1259
  if (! tmp___4) {
    {
#line 1259
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1259,
            "reorder_is_bijection(table,g->n)");
#line 1259
    abort();
    }
  }
  {
#line 1264
  tmp___5 = unweighted_clique_search_single(table, min_size, g, opts);
  }
#line 1264
  if (tmp___5 == 0) {
#line 1265
    count = 0;
#line 1266
    goto cleanreturn;
  }
#line 1269
  if (min_size == 0) {
#line 1269
    if (max_size == 0) {
#line 1270
      max_size = *(clique_size + *(table + (g->n - 1)));
#line 1270
      min_size = max_size;
#line 1271
      maximal___0 = 0;
    }
  }
#line 1274
  if (max_size == 0) {
#line 1275
    max_size = 2147483647;
  }
#line 1278
  i = 0;
  {
#line 1278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1278
    if (! (i < g->n - 1)) {
#line 1278
      goto while_break;
    }
#line 1279
    if (*(clique_size + *(table + i)) >= min_size) {
#line 1280
      goto while_break;
    }
#line 1278
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1281
  count = unweighted_clique_search_all(table, i, min_size, max_size, maximal___0,
                                       g, opts);
  }
  cleanreturn: 
#line 1286
  i = 0;
  {
#line 1286
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1286
    if (! (i < temp_count)) {
#line 1286
      goto while_break___0;
    }
    {
#line 1287
    free((void *)*(temp_list + i));
#line 1286
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1288
  free((void *)temp_list);
#line 1289
  free((void *)table);
#line 1290
  free((void *)clique_size);
#line 1291
  set_free(current_clique);
#line 1293
  clique_size = old_clique_size;
#line 1293
  current_clique = old_current_clique;
#line 1293
  best_clique = old_best_clique;
#line 1293
  clique_list_count = old_clique_list_count;
#line 1293
  weight_multiplier = old_weight_multiplier;
#line 1293
  temp_list = old_temp_list;
#line 1293
  temp_count = old_temp_count;
#line 1293
  memcpy((void */* __restrict  */)(& cputimer), (void const   */* __restrict  */)(& old_cputimer),
         sizeof(struct tms ));
#line 1293
  memcpy((void */* __restrict  */)(& realtimer), (void const   */* __restrict  */)(& old_realtimer),
         sizeof(struct timeval ));
#line 1294
  entrance_level --;
  }
#line 1296
  return ((int __attribute__((__visibility__("default")))  )count);
}
}
#line 1315 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
int __attribute__((__visibility__("default")))  clique_max_weight(graph_t *g , clique_options *opts ) 
{ 
  set_t s ;
  int weight ;
  set_t __attribute__((__visibility__("default")))  tmp ;

  {
#line 1319
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 1319
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1319,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 1319
    abort();
    }
  }
#line 1320
  if (! ((unsigned long )g != (unsigned long )((void *)0))) {
    {
#line 1320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1320,
            "g!=NULL");
#line 1320
    abort();
    }
  }
  {
#line 1322
  tmp = clique_find_single(g, 0, 0, 0, opts);
#line 1322
  s = (set_t )tmp;
  }
#line 1323
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1325
    return ((int __attribute__((__visibility__("default")))  )0);
  }
  {
#line 1327
  weight = graph_subgraph_weight(g, s);
#line 1328
  set_free(s);
  }
#line 1329
  return ((int __attribute__((__visibility__("default")))  )weight);
}
}
#line 1357 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
set_t __attribute__((__visibility__("default")))  clique_find_single(graph_t *g ,
                                                                     int min_weight___0 ,
                                                                     int max_weight___0 ,
                                                                     int maximal___0 ,
                                                                     clique_options *opts ) 
{ 
  int i ;
  int *table ;
  set_t s ;
  int *old_clique_size ;
  set_t old_current_clique ;
  set_t old_best_clique ;
  int old_clique_list_count ;
  int old_weight_multiplier ;
  int **old_temp_list ;
  int old_temp_count ;
  struct tms old_cputimer ;
  struct timeval old_realtimer ;
  long tmp ;
  set_t __attribute__((__visibility__("default")))  tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int __attribute__((__visibility__("default")))  *tmp___4 ;
  int __attribute__((__visibility__("default")))  *tmp___5 ;
  int __attribute__((__visibility__("default")))  tmp___6 ;
  int tmp___7 ;
  clique_options localopts ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1363
  old_clique_size = clique_size;
#line 1363
  old_current_clique = current_clique;
#line 1363
  old_best_clique = best_clique;
#line 1363
  old_clique_list_count = clique_list_count;
#line 1363
  old_weight_multiplier = weight_multiplier;
#line 1363
  old_temp_list = temp_list;
#line 1363
  old_temp_count = temp_count;
#line 1363
  memcpy((void */* __restrict  */)(& old_cputimer), (void const   */* __restrict  */)(& cputimer),
         sizeof(struct tms ));
#line 1363
  memcpy((void */* __restrict  */)(& old_realtimer), (void const   */* __restrict  */)(& realtimer),
         sizeof(struct timeval ));
#line 1364
  entrance_level ++;
  }
#line 1366
  if ((unsigned long )opts == (unsigned long )((void *)0)) {
#line 1367
    opts = (clique_options *)clique_default_options;
  }
#line 1369
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 1369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1369,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 1369
    abort();
    }
  }
#line 1370
  if (! ((unsigned long )g != (unsigned long )((void *)0))) {
    {
#line 1370
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1370,
            "g!=NULL");
#line 1370
    abort();
    }
  }
#line 1371
  if (! (min_weight___0 >= 0)) {
    {
#line 1371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1371,
            "min_weight>=0");
#line 1371
    abort();
    }
  }
#line 1372
  if (! (max_weight___0 >= 0)) {
    {
#line 1372
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1372,
            "max_weight>=0");
#line 1372
    abort();
    }
  }
#line 1373
  if (! (max_weight___0 == 0)) {
#line 1373
    if (! (min_weight___0 <= max_weight___0)) {
      {
#line 1373
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
              "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c",
              1373, "(max_weight==0) || (min_weight <= max_weight)");
#line 1373
      abort();
      }
    }
  }
#line 1374
  if (min_weight___0 == 0) {
#line 1374
    if (max_weight___0 > 0) {
      {
#line 1374
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
              "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c",
              1374, "!((min_weight==0) && (max_weight>0))");
#line 1374
      abort();
      }
    }
  }
#line 1375
  if (! ((unsigned long )opts->reorder_function == (unsigned long )((void *)0))) {
#line 1375
    if (! ((unsigned long )opts->reorder_map == (unsigned long )((void *)0))) {
      {
#line 1375
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
              "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c",
              1375, "(opts->reorder_function==NULL) || (opts->reorder_map==NULL)");
#line 1375
      abort();
      }
    }
  }
#line 1377
  if (max_weight___0 > 0) {
#line 1377
    if (min_weight___0 > max_weight___0) {
#line 1379
      entrance_level --;
#line 1380
      return ((set_t __attribute__((__visibility__("default")))  )((void *)0));
    }
  }
#line 1383
  if (clocks_per_sec == 0) {
    {
#line 1384
    tmp = sysconf(2);
#line 1384
    clocks_per_sec = (int )tmp;
    }
  }
#line 1385
  if (! (clocks_per_sec > 0)) {
    {
#line 1385
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1385,
            "clocks_per_sec>0");
#line 1385
    abort();
    }
  }
  {
#line 1388
  tmp___1 = graph_weighted(g);
  }
#line 1388
  if (! tmp___1) {
#line 1389
    min_weight___0 = ((min_weight___0 + *(g->weights + 0)) - 1) / *(g->weights + 0);
#line 1390
    if (max_weight___0) {
#line 1391
      max_weight___0 /= *(g->weights + 0);
#line 1392
      if (max_weight___0 < min_weight___0) {
#line 1394
        entrance_level --;
#line 1395
        return ((set_t __attribute__((__visibility__("default")))  )((void *)0));
      }
    }
    {
#line 1399
    weight_multiplier = *(g->weights + 0);
#line 1400
    entrance_level --;
#line 1401
    tmp___0 = clique_unweighted_find_single(g, min_weight___0, max_weight___0, maximal___0,
                                            opts);
#line 1401
    s = (set_t )tmp___0;
#line 1403
    clique_size = old_clique_size;
#line 1403
    current_clique = old_current_clique;
#line 1403
    best_clique = old_best_clique;
#line 1403
    clique_list_count = old_clique_list_count;
#line 1403
    weight_multiplier = old_weight_multiplier;
#line 1403
    temp_list = old_temp_list;
#line 1403
    temp_count = old_temp_count;
#line 1403
    memcpy((void */* __restrict  */)(& cputimer), (void const   */* __restrict  */)(& old_cputimer),
           sizeof(struct tms ));
#line 1403
    memcpy((void */* __restrict  */)(& realtimer), (void const   */* __restrict  */)(& old_realtimer),
           sizeof(struct timeval ));
    }
#line 1404
    return ((set_t __attribute__((__visibility__("default")))  )s);
  }
  {
#line 1408
  current_clique = set_new(g->n);
#line 1409
  best_clique = set_new(g->n);
#line 1410
  tmp___2 = malloc((unsigned long )g->n * sizeof(int ));
#line 1410
  clique_size = (int *)tmp___2;
#line 1411
  memset((void *)clique_size, 0, (unsigned long )g->n * sizeof(int ));
#line 1413
  tmp___3 = malloc((unsigned long )(g->n + 2) * sizeof(int *));
#line 1413
  temp_list = (int **)tmp___3;
#line 1414
  temp_count = 0;
#line 1416
  clique_list_count = 0;
#line 1419
  gettimeofday((struct timeval */* __restrict  */)(& realtimer), (__timezone_ptr_t )((void *)0));
#line 1420
  times(& cputimer);
  }
#line 1423
  if (opts->reorder_function) {
    {
#line 1424
    table = (*(opts->reorder_function))(g, 1);
    }
  } else
#line 1425
  if (opts->reorder_map) {
    {
#line 1426
    tmp___4 = reorder_duplicate(opts->reorder_map, g->n);
#line 1426
    table = (int *)tmp___4;
    }
  } else {
    {
#line 1428
    tmp___5 = reorder_ident(g->n);
#line 1428
    table = (int *)tmp___5;
    }
  }
  {
#line 1430
  tmp___6 = reorder_is_bijection(table, g->n);
  }
#line 1430
  if (! tmp___6) {
    {
#line 1430
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1430,
            "reorder_is_bijection(table,g->n)");
#line 1430
    abort();
    }
  }
#line 1432
  if (max_weight___0 == 0) {
#line 1433
    max_weight___0 = 2147483647;
  }
  {
#line 1435
  tmp___7 = weighted_clique_search_single(table, min_weight___0, max_weight___0, g,
                                          opts);
  }
#line 1435
  if (tmp___7 == 0) {
    {
#line 1438
    set_free(best_clique);
#line 1439
    best_clique = (set_t )((void *)0);
    }
#line 1440
    goto cleanreturn;
  }
#line 1442
  if (maximal___0) {
#line 1442
    if (min_weight___0 > 0) {
      {
#line 1443
      maximalize_clique(best_clique, g);
#line 1444
      tmp___9 = graph_subgraph_weight(g, best_clique);
      }
#line 1444
      if (tmp___9 > max_weight___0) {
#line 1447
        localopts.time_function = opts->time_function;
#line 1448
        localopts.output = opts->output;
#line 1449
        localopts.user_function = & false_function;
#line 1450
        localopts.clique_list = & best_clique;
#line 1451
        localopts.clique_list_length = 1;
#line 1453
        i = 0;
        {
#line 1453
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1453
          if (! (i < g->n - 1)) {
#line 1453
            goto while_break;
          }
#line 1454
          if (*(clique_size + *(table + i)) >= min_weight___0) {
#line 1456
            goto while_break;
          } else
#line 1454
          if (*(clique_size + *(table + i)) == 0) {
#line 1456
            goto while_break;
          }
#line 1453
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1457
        tmp___8 = weighted_clique_search_all(table, i, min_weight___0, max_weight___0,
                                             maximal___0, g, & localopts);
        }
#line 1457
        if (! tmp___8) {
          {
#line 1460
          set_free(best_clique);
#line 1461
          best_clique = (set_t )((void *)0);
          }
        }
      }
    }
  }
  cleanreturn: 
#line 1467
  s = best_clique;
#line 1470
  i = 0;
  {
#line 1470
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1470
    if (! (i < temp_count)) {
#line 1470
      goto while_break___0;
    }
    {
#line 1471
    free((void *)*(temp_list + i));
#line 1470
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1472
  free((void *)temp_list);
#line 1473
  temp_list = (int **)((void *)0);
#line 1474
  temp_count = 0;
#line 1475
  free((void *)table);
#line 1476
  set_free(current_clique);
#line 1477
  current_clique = (set_t )((void *)0);
#line 1478
  free((void *)clique_size);
#line 1479
  clique_size = (int *)((void *)0);
#line 1481
  clique_size = old_clique_size;
#line 1481
  current_clique = old_current_clique;
#line 1481
  best_clique = old_best_clique;
#line 1481
  clique_list_count = old_clique_list_count;
#line 1481
  weight_multiplier = old_weight_multiplier;
#line 1481
  temp_list = old_temp_list;
#line 1481
  temp_count = old_temp_count;
#line 1481
  memcpy((void */* __restrict  */)(& cputimer), (void const   */* __restrict  */)(& old_cputimer),
         sizeof(struct tms ));
#line 1481
  memcpy((void */* __restrict  */)(& realtimer), (void const   */* __restrict  */)(& old_realtimer),
         sizeof(struct timeval ));
#line 1482
  entrance_level --;
  }
#line 1484
  return ((set_t __attribute__((__visibility__("default")))  )s);
}
}
#line 1517 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
int __attribute__((__visibility__("default")))  clique_find_all(graph_t *g , int min_weight___0 ,
                                                                int max_weight___0 ,
                                                                int maximal___0 ,
                                                                clique_options *opts ) 
{ 
  int i ;
  int n ;
  int *table ;
  int *old_clique_size ;
  set_t old_current_clique ;
  set_t old_best_clique ;
  int old_clique_list_count ;
  int old_weight_multiplier ;
  int **old_temp_list ;
  int old_temp_count ;
  struct tms old_cputimer ;
  struct timeval old_realtimer ;
  long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int __attribute__((__visibility__("default")))  *tmp___4 ;
  int __attribute__((__visibility__("default")))  *tmp___5 ;
  int __attribute__((__visibility__("default")))  tmp___6 ;

  {
  {
#line 1522
  old_clique_size = clique_size;
#line 1522
  old_current_clique = current_clique;
#line 1522
  old_best_clique = best_clique;
#line 1522
  old_clique_list_count = clique_list_count;
#line 1522
  old_weight_multiplier = weight_multiplier;
#line 1522
  old_temp_list = temp_list;
#line 1522
  old_temp_count = temp_count;
#line 1522
  memcpy((void */* __restrict  */)(& old_cputimer), (void const   */* __restrict  */)(& cputimer),
         sizeof(struct tms ));
#line 1522
  memcpy((void */* __restrict  */)(& old_realtimer), (void const   */* __restrict  */)(& realtimer),
         sizeof(struct timeval ));
#line 1523
  entrance_level ++;
  }
#line 1525
  if ((unsigned long )opts == (unsigned long )((void *)0)) {
#line 1526
    opts = (clique_options *)clique_default_options;
  }
#line 1528
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 1528
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1528,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 1528
    abort();
    }
  }
#line 1529
  if (! ((unsigned long )g != (unsigned long )((void *)0))) {
    {
#line 1529
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1529,
            "g!=NULL");
#line 1529
    abort();
    }
  }
#line 1530
  if (! (min_weight___0 >= 0)) {
    {
#line 1530
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1530,
            "min_weight>=0");
#line 1530
    abort();
    }
  }
#line 1531
  if (! (max_weight___0 >= 0)) {
    {
#line 1531
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1531,
            "max_weight>=0");
#line 1531
    abort();
    }
  }
#line 1532
  if (! (max_weight___0 == 0)) {
#line 1532
    if (! (min_weight___0 <= max_weight___0)) {
      {
#line 1532
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
              "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c",
              1532, "(max_weight==0) || (min_weight <= max_weight)");
#line 1532
      abort();
      }
    }
  }
#line 1533
  if (min_weight___0 == 0) {
#line 1533
    if (max_weight___0 > 0) {
      {
#line 1533
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
              "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c",
              1533, "!((min_weight==0) && (max_weight>0))");
#line 1533
      abort();
      }
    }
  }
#line 1534
  if (! ((unsigned long )opts->reorder_function == (unsigned long )((void *)0))) {
#line 1534
    if (! ((unsigned long )opts->reorder_map == (unsigned long )((void *)0))) {
      {
#line 1534
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
              "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c",
              1534, "(opts->reorder_function==NULL) || (opts->reorder_map==NULL)");
#line 1534
      abort();
      }
    }
  }
#line 1536
  if (max_weight___0 > 0) {
#line 1536
    if (min_weight___0 > max_weight___0) {
#line 1538
      entrance_level --;
#line 1539
      return ((int __attribute__((__visibility__("default")))  )0);
    }
  }
#line 1542
  if (clocks_per_sec == 0) {
    {
#line 1543
    tmp = sysconf(2);
#line 1543
    clocks_per_sec = (int )tmp;
    }
  }
#line 1544
  if (! (clocks_per_sec > 0)) {
    {
#line 1544
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1544,
            "clocks_per_sec>0");
#line 1544
    abort();
    }
  }
  {
#line 1546
  tmp___1 = graph_weighted(g);
  }
#line 1546
  if (! tmp___1) {
#line 1547
    min_weight___0 = ((min_weight___0 + *(g->weights + 0)) - 1) / *(g->weights + 0);
#line 1548
    if (max_weight___0) {
#line 1549
      max_weight___0 /= *(g->weights + 0);
#line 1550
      if (max_weight___0 < min_weight___0) {
#line 1552
        entrance_level --;
#line 1553
        return ((int __attribute__((__visibility__("default")))  )0);
      }
    }
    {
#line 1557
    weight_multiplier = *(g->weights + 0);
#line 1558
    entrance_level --;
#line 1559
    tmp___0 = clique_unweighted_find_all(g, min_weight___0, max_weight___0, maximal___0,
                                         opts);
#line 1559
    i = (int )tmp___0;
#line 1561
    clique_size = old_clique_size;
#line 1561
    current_clique = old_current_clique;
#line 1561
    best_clique = old_best_clique;
#line 1561
    clique_list_count = old_clique_list_count;
#line 1561
    weight_multiplier = old_weight_multiplier;
#line 1561
    temp_list = old_temp_list;
#line 1561
    temp_count = old_temp_count;
#line 1561
    memcpy((void */* __restrict  */)(& cputimer), (void const   */* __restrict  */)(& old_cputimer),
           sizeof(struct tms ));
#line 1561
    memcpy((void */* __restrict  */)(& realtimer), (void const   */* __restrict  */)(& old_realtimer),
           sizeof(struct timeval ));
    }
#line 1562
    return ((int __attribute__((__visibility__("default")))  )i);
  }
  {
#line 1566
  current_clique = set_new(g->n);
#line 1567
  best_clique = set_new(g->n);
#line 1568
  tmp___2 = malloc((unsigned long )g->n * sizeof(int ));
#line 1568
  clique_size = (int *)tmp___2;
#line 1569
  memset((void *)clique_size, 0, (unsigned long )g->n * sizeof(int ));
#line 1571
  tmp___3 = malloc((unsigned long )(g->n + 2) * sizeof(int *));
#line 1571
  temp_list = (int **)tmp___3;
#line 1572
  temp_count = 0;
#line 1575
  gettimeofday((struct timeval */* __restrict  */)(& realtimer), (__timezone_ptr_t )((void *)0));
#line 1576
  times(& cputimer);
  }
#line 1579
  if (opts->reorder_function) {
    {
#line 1580
    table = (*(opts->reorder_function))(g, 1);
    }
  } else
#line 1581
  if (opts->reorder_map) {
    {
#line 1582
    tmp___4 = reorder_duplicate(opts->reorder_map, g->n);
#line 1582
    table = (int *)tmp___4;
    }
  } else {
    {
#line 1584
    tmp___5 = reorder_ident(g->n);
#line 1584
    table = (int *)tmp___5;
    }
  }
  {
#line 1586
  tmp___6 = reorder_is_bijection(table, g->n);
  }
#line 1586
  if (! tmp___6) {
    {
#line 1586
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c", 1586,
            "reorder_is_bijection(table,g->n)");
#line 1586
    abort();
    }
  }
  {
#line 1589
  n = weighted_clique_search_single(table, min_weight___0, 2147483647, g, opts);
  }
#line 1590
  if (n == 0) {
#line 1592
    goto cleanreturn;
  }
#line 1595
  if (min_weight___0 == 0) {
#line 1596
    min_weight___0 = n;
#line 1597
    max_weight___0 = n;
#line 1598
    maximal___0 = 0;
  }
#line 1600
  if (max_weight___0 == 0) {
#line 1601
    max_weight___0 = 2147483647;
  }
#line 1603
  i = 0;
  {
#line 1603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1603
    if (! (i < g->n)) {
#line 1603
      goto while_break;
    }
#line 1604
    if (*(clique_size + *(table + i)) >= min_weight___0) {
#line 1606
      goto while_break;
    } else
#line 1604
    if (*(clique_size + *(table + i)) == 0) {
#line 1606
      goto while_break;
    }
#line 1603
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1609
  n = weighted_clique_search_all(table, i, min_weight___0, max_weight___0, maximal___0,
                                 g, opts);
  }
  cleanreturn: 
#line 1614
  i = 0;
  {
#line 1614
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1614
    if (! (i < temp_count)) {
#line 1614
      goto while_break___0;
    }
    {
#line 1615
    free((void *)*(temp_list + i));
#line 1614
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1616
  free((void *)temp_list);
#line 1617
  free((void *)table);
#line 1618
  set_free(current_clique);
#line 1619
  set_free(best_clique);
#line 1620
  free((void *)clique_size);
#line 1622
  clique_size = old_clique_size;
#line 1622
  current_clique = old_current_clique;
#line 1622
  best_clique = old_best_clique;
#line 1622
  clique_list_count = old_clique_list_count;
#line 1622
  weight_multiplier = old_weight_multiplier;
#line 1622
  temp_list = old_temp_list;
#line 1622
  temp_count = old_temp_count;
#line 1622
  memcpy((void */* __restrict  */)(& cputimer), (void const   */* __restrict  */)(& old_cputimer),
         sizeof(struct tms ));
#line 1622
  memcpy((void */* __restrict  */)(& realtimer), (void const   */* __restrict  */)(& old_realtimer),
         sizeof(struct timeval ));
#line 1623
  entrance_level --;
  }
#line 1625
  return ((int __attribute__((__visibility__("default")))  )n);
}
}
#line 1663 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static float prev_time  =    (float )100;
#line 1664 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int prev_i  =    100;
#line 1665 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int prev_max  =    100;
#line 1666 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int prev_level  =    0;
#line 1660 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
int __attribute__((__visibility__("default")))  clique_print_time(int level , int i ,
                                                                  int n , int max ,
                                                                  double cputime ,
                                                                  double realtime ,
                                                                  clique_options *opts ) 
{ 
  FILE *fp ;
  int j ;
  double tmp ;

  {
#line 1667
  fp = opts->output;
#line 1670
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1671
    fp = stdout;
  }
#line 1673
  if ((double )prev_time - realtime < (double )0) {
#line 1673
    tmp = - ((double )prev_time - realtime);
  } else {
#line 1673
    tmp = (double )prev_time - realtime;
  }
#line 1673
  if (tmp > 0.1) {
#line 1673
    goto _L;
  } else
#line 1673
  if (i == n) {
#line 1673
    goto _L;
  } else
#line 1673
  if (i < prev_i) {
#line 1673
    goto _L;
  } else
#line 1673
  if (max != prev_max) {
#line 1673
    goto _L;
  } else
#line 1673
  if (level != prev_level) {
    _L: /* CIL Label */ 
#line 1675
    j = 1;
    {
#line 1675
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1675
      if (! (j < level)) {
#line 1675
        goto while_break;
      }
      {
#line 1676
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  ");
#line 1675
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1677
    if (realtime - (double )prev_time < 0.01) {
      {
#line 1678
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%3d/%d (max %2d)  %2.2f s  (0.00 s/round)\n",
              i, n, max, realtime);
      }
    } else
#line 1677
    if (i <= prev_i) {
      {
#line 1678
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%3d/%d (max %2d)  %2.2f s  (0.00 s/round)\n",
              i, n, max, realtime);
      }
    } else {
      {
#line 1682
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%3d/%d (max %2d)  %2.2f s  (%2.2f s/round)\n",
              i, n, max, realtime, (realtime - (double )prev_time) / (double )(i - prev_i));
      }
    }
#line 1686
    prev_time = (float )realtime;
#line 1687
    prev_i = i;
#line 1688
    prev_max = max;
#line 1689
    prev_level = level;
  }
#line 1691
  return ((int __attribute__((__visibility__("default")))  )1);
}
}
#line 1712 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static float prev_time___0  =    (float )100;
#line 1713 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int prev_i___0  =    100;
#line 1709 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
int __attribute__((__visibility__("default")))  clique_print_time_always(int level ,
                                                                         int i , int n ,
                                                                         int max ,
                                                                         double cputime ,
                                                                         double realtime ,
                                                                         clique_options *opts ) 
{ 
  FILE *fp ;
  int j ;

  {
#line 1714
  fp = opts->output;
#line 1717
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1718
    fp = stdout;
  }
#line 1720
  j = 1;
  {
#line 1720
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1720
    if (! (j < level)) {
#line 1720
      goto while_break;
    }
    {
#line 1721
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  ");
#line 1720
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1723
  if (realtime - (double )prev_time___0 < 0.01) {
    {
#line 1724
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%3d/%d (max %2d)  %2.2f s  (0.00 s/round)\n",
            i, n, max, realtime);
    }
  } else
#line 1723
  if (i <= prev_i___0) {
    {
#line 1724
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%3d/%d (max %2d)  %2.2f s  (0.00 s/round)\n",
            i, n, max, realtime);
    }
  } else {
    {
#line 1727
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%3d/%d (max %2d)  %2.2f s  (%2.2f s/round)\n",
            i, n, max, realtime, (realtime - (double )prev_time___0) / (double )(i - prev_i___0));
    }
  }
#line 1729
  prev_time___0 = (float )realtime;
#line 1730
  prev_i___0 = i;
#line 1732
  return ((int __attribute__((__visibility__("default")))  )1);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static int set_bit_count___0[256]  = 
#line 51 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
  {      0,      1,      1,      2, 
        1,      2,      2,      3, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        5,      6,      6,      7, 
        6,      7,      7,      8};
#line 144
static set_t set_new___0(int size )  __attribute__((__unused__)) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static set_t set_new___0(int size ) 
{ 
  int n ;
  set_t s ;
  void *tmp ;

  {
#line 149
  if (! (size > 0)) {
    {
#line 149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h", 149, "size>0");
#line 149
    abort();
    }
  }
  {
#line 151
  n = (size / 64 + 1) + 1;
#line 152
  tmp = calloc((size_t )n, sizeof(setelement ));
#line 152
  s = (set_t )tmp;
#line 153
  *(s + 0) = (setelement )size;
  }
#line 155
  return (s + 1);
}
}
#line 202
__inline static int set_size___0(set_t s )  __attribute__((__unused__)) ;
#line 202 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static int set_size___0(set_t s ) 
{ 
  int count ;
  setelement *c ;

  {
#line 204
  count = 0;
#line 207
  c = s;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )c < (unsigned long )(s + ((*(s + -1) + 64UL) - 1UL) / 64UL))) {
#line 207
      goto while_break;
    }
#line 208
    count += ((((((set_bit_count___0[*c >> 56] + set_bit_count___0[(*c >> 48) & 255UL]) + set_bit_count___0[(*c >> 40) & 255UL]) + set_bit_count___0[(*c >> 32) & 255UL]) + set_bit_count___0[(*c >> 24) & 255UL]) + set_bit_count___0[(*c >> 16) & 255UL]) + set_bit_count___0[(*c >> 8) & 255UL]) + set_bit_count___0[*c & 255UL];
#line 207
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return (count);
}
}
#line 217
__inline static set_t set_duplicate___0(set_t s )  __attribute__((__unused__)) ;
#line 217 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static set_t set_duplicate___0(set_t s ) 
{ 
  set_t new ;

  {
  {
#line 221
  new = set_new___0((int )*(s + -1));
#line 222
  memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)s, (((*(s + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
  }
#line 223
  return (new);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.h"
graph_t __attribute__((__visibility__("default")))  *graph_read_dimacs(FILE *fp ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.h"
int __attribute__((__visibility__("default")))  *reorder_by_weighted_greedy_coloring(graph_t *g ,
                                                                                     int weighted ) ;
#line 20
int __attribute__((__visibility__("default")))  *reorder_by_unweighted_greedy_coloring(graph_t *g ,
                                                                                       int weighted ) ;
#line 21
int __attribute__((__visibility__("default")))  *reorder_by_degree(graph_t *g , int weighted ) ;
#line 22
int __attribute__((__visibility__("default")))  *reorder_by_random(graph_t *g , int weighted ) ;
#line 24
int __attribute__((__visibility__("default")))  *reorder_by_reverse(graph_t *g , int weighted ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static void printhelp(char *prog ) ;
#line 16
static void read_options(int argc , char **argv ) ;
#line 17
static void print_search(graph_t *g ) ;
#line 18
static int record_clique_func(set_t s , graph_t *g , clique_options *opts ) ;
#line 19
static int print_clique_func(set_t s , graph_t *g , clique_options *opts ) ;
#line 20
static void print_clique(set_t s , graph_t *g ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int find_all  =    0;
#line 25 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int min_weight  =    0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int min_weight_set  =    0;
#line 27 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int max_weight  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int max_weight_set  =    0;
#line 29 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int maximal  =    0;
#line 30 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int unweighted  =    0;
#line 31 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int number1  =    1;
#line 32 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int quiet  =    0;
#line 33 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int only_weight  =    0;
#line 34 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int *(*reorder)(graph_t * , int  )  =    (int *(*)(graph_t * , int  ))(& reorder_by_greedy_coloring);
#line 35 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static char *file  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static set_t *clique_list  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int clique_count  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int clique_list_size  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
int main(int argc , char **argv ) 
{ 
  FILE *fp ;
  graph_t *g ;
  set_t s ;
  clique_options *opts ;
  int i ;
  int j ;
  graph_t __attribute__((__visibility__("default")))  *tmp ;
  void *tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;
  int __attribute__((__visibility__("default")))  tmp___2 ;
  char const   *tmp___3 ;
  set_t __attribute__((__visibility__("default")))  tmp___4 ;
  set_t __attribute__((__visibility__("default")))  tmp___5 ;

  {
#line 50
  if (argc <= 1) {
    {
#line 51
    printhelp(*(argv + 0));
    }
  }
  {
#line 52
  read_options(argc, argv);
  }
#line 54
  if ((int )*(file + 0) == 45) {
#line 54
    if ((int )*(file + 1) == 0) {
#line 55
      fp = stdin;
#line 56
      if (quiet <= 1) {
        {
#line 57
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading graph from stdin...");
        }
      }
    } else {
#line 54
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 59
    fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"rb");
    }
#line 60
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 61
      perror((char const   *)file);
#line 62
      exit(2);
      }
    }
#line 64
    if (quiet <= 1) {
      {
#line 65
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading graph from %s...",
              file);
      }
    }
  }
  {
#line 67
  tmp = graph_read_dimacs(fp);
#line 67
  g = (graph_t *)tmp;
  }
#line 68
  if ((unsigned long )g == (unsigned long )((void *)0)) {
    {
#line 69
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in graph file.\n");
    }
#line 70
    return (1);
  }
#line 72
  if (quiet <= 1) {
    {
#line 73
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"OK\n");
    }
  }
  {
#line 74
  fclose(fp);
#line 77
  setvbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)((char *)((void *)0)),
          1, (size_t )0);
#line 80
  tmp___0 = malloc(sizeof(clique_options ));
#line 80
  opts = (clique_options *)tmp___0;
  }
#line 81
  if (quiet) {
#line 82
    opts->time_function = (int (*)(int  , int  , int  , int  , double  , double  ,
                                   clique_options * ))((void *)0);
  } else {
#line 84
    opts->time_function = (int (*)(int  , int  , int  , int  , double  , double  ,
                                   clique_options * ))(& clique_print_time);
  }
#line 85
  opts->output = stderr;
#line 86
  opts->reorder_function = reorder;
#line 87
  opts->reorder_map = (int *)((void *)0);
#line 88
  if (quiet) {
#line 89
    opts->user_function = & print_clique_func;
  } else {
#line 91
    opts->user_function = & record_clique_func;
  }
#line 92
  opts->user_data = (void *)0;
#line 93
  opts->clique_list = (set_t *)((void *)0);
#line 94
  opts->clique_list_length = 0;
#line 97
  if (quiet <= 1) {
    {
#line 98
    print_search(g);
    }
  }
#line 100
  if (only_weight) {
#line 101
    if (unweighted) {
      {
#line 102
      tmp___1 = clique_unweighted_max_weight(g, opts);
#line 102
      j = (int )tmp___1;
#line 103
      printf((char const   */* __restrict  */)"Largest clique: %d\n", j);
      }
    } else {
      {
#line 105
      tmp___2 = clique_max_weight(g, opts);
#line 105
      j = (int )tmp___2;
#line 106
      printf((char const   */* __restrict  */)"Heaviest clique: %d\n", j);
      }
    }
  } else
#line 108
  if (find_all) {
#line 109
    if (unweighted) {
      {
#line 110
      clique_unweighted_find_all(g, min_weight, max_weight, maximal, opts);
      }
    } else {
      {
#line 113
      clique_find_all(g, min_weight, max_weight, maximal, opts);
      }
    }
#line 115
    if (quiet <= 0) {
#line 116
      if (clique_count == 1) {
#line 116
        tmp___3 = "";
      } else {
#line 116
        tmp___3 = "s";
      }
      {
#line 116
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found %d clique%s:\n",
              clique_count, tmp___3);
#line 118
      i = 0;
      }
      {
#line 118
      while (1) {
        while_continue: /* CIL Label */ ;
#line 118
        if (! (i < clique_count)) {
#line 118
          goto while_break;
        }
        {
#line 119
        print_clique(*(clique_list + i), g);
#line 118
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
#line 123
    if (unweighted) {
      {
#line 124
      tmp___4 = clique_unweighted_find_single(g, min_weight, max_weight, maximal,
                                              opts);
#line 124
      s = (set_t )tmp___4;
      }
    } else {
      {
#line 128
      tmp___5 = clique_find_single(g, min_weight, max_weight, maximal, opts);
#line 128
      s = (set_t )tmp___5;
      }
    }
#line 131
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 132
      if (quiet <= 1) {
        {
#line 133
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No such clique found.\n");
        }
      }
#line 134
      return (0);
    }
    {
#line 136
    print_clique(s, g);
    }
  }
#line 139
  return (0);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static void printhelp(char *prog ) 
{ 


  {
  {
#line 148
  printf((char const   */* __restrict  */)"Usage:  %s [options] <dimacs-file>\n\n<dimacs-file> is the ASCII or binary DIMACS-format file from which to read\nthe graph.  Options are the following:\n\n -h    --help         This help text.\n -a    --all          Find all cliques.\n -s    --single       Find only one clique (default).\n -w    --weight       Tell only maximum weight (no faster than -s).\n -m N  --min N        Search for cliques with weight at least N.  If N=0,\n                      searches for maximum weight clique (default).\n -M N  --max N        Search for cliques with weight at most N.  If N=0,\n                      no limit is imposed (default).  N being positive is\n                      incompatible with \"--min 0\" (\"--min 1\" is assumed).\n -x    --maximal      Require cliques to be maximal.\n -u    --unweighted   Assume weight 1 for all vertices.\n -0    --from-0       Number vertices 0 to n-1 instead of 1 to n when writing.\n -r F  --reorder F    Reorder with function F.  See below for details.\n -q    --quiet        Suppresses progress output.  Specifying -q twice\n                      suppresses all output except the actual result.\n\nAvailable reordering functions are the following:\n\n      none        No ordering (same order as in the file).\n      reverse     Reverse order as in the file.\n      default     One of the two below, depending on weightedness.\n      unweighted-coloring   Coloring method efficient for unweighted graphs.\n      weighted-coloring     Coloring method efficient for weighted graphs.\n      degree      Order by ascending degree.\n      random      Random order.\n\n",
         prog);
#line 183
  exit(0);
  }
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static struct option long_options[12]  = 
#line 197
  {      {"all", 0, (int *)((void *)0), 'a'}, 
        {"single", 0, (int *)((void *)0), 's'}, 
        {"weight", 0, (int *)((void *)0), 'w'}, 
        {"min", 1, (int *)((void *)0), 'm'}, 
        {"max", 1, (int *)((void *)0), 'M'}, 
        {"maximal", 0, (int *)((void *)0), 'x'}, 
        {"unweighted", 0, (int *)((void *)0), 'u'}, 
        {"reorder", 1, (int *)((void *)0), 'r'}, 
        {"from-0", 0, (int *)((void *)0), '0'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 190 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static void read_options(int argc , char **argv ) 
{ 
  int c ;
  char *ptr ;
  int option_index ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 196
    option_index = 0;
#line 212
    c = getopt_long(argc, (char * const  *)argv, "aswm:M:xur:1qh", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 217
    if (c == -1) {
#line 218
      goto while_break;
    }
    {
#line 221
    if (c == 0) {
#line 221
      goto case_0;
    }
#line 223
    if (c == 97) {
#line 223
      goto case_97;
    }
#line 226
    if (c == 115) {
#line 226
      goto case_115;
    }
#line 229
    if (c == 119) {
#line 229
      goto case_119;
    }
#line 232
    if (c == 109) {
#line 232
      goto case_109;
    }
#line 250
    if (c == 77) {
#line 250
      goto case_77;
    }
#line 268
    if (c == 120) {
#line 268
      goto case_120;
    }
#line 271
    if (c == 117) {
#line 271
      goto case_117;
    }
#line 274
    if (c == 114) {
#line 274
      goto case_114;
    }
#line 296
    if (c == 48) {
#line 296
      goto case_48;
    }
#line 299
    if (c == 113) {
#line 299
      goto case_113;
    }
#line 302
    if (c == 104) {
#line 302
      goto case_104;
    }
#line 311
    if (c == 63) {
#line 311
      goto case_63;
    }
#line 314
    goto switch_default;
    case_0: /* CIL Label */ 
#line 222
    goto switch_break;
    case_97: /* CIL Label */ 
#line 224
    find_all = 1;
#line 225
    goto switch_break;
    case_115: /* CIL Label */ 
#line 227
    find_all = 0;
#line 228
    goto switch_break;
    case_119: /* CIL Label */ 
#line 230
    only_weight = 1;
#line 231
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 233
    tmp = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& ptr),
                 10);
#line 233
    min_weight = (int )tmp;
    }
#line 234
    if ((int )*optarg == 0) {
      {
#line 235
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad argument: %s\n",
              optarg);
#line 236
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h\' for more information.\n",
              *(argv + 0));
#line 237
      exit(1);
      }
    } else
#line 234
    if ((int )*ptr != 0) {
      {
#line 235
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad argument: %s\n",
              optarg);
#line 236
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h\' for more information.\n",
              *(argv + 0));
#line 237
      exit(1);
      }
    } else
#line 234
    if (min_weight < 0) {
      {
#line 235
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad argument: %s\n",
              optarg);
#line 236
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h\' for more information.\n",
              *(argv + 0));
#line 237
      exit(1);
      }
    }
#line 239
    if (min_weight == 0) {
#line 239
      if (max_weight > 0) {
#line 240
        if (max_weight_set) {
          {
#line 241
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: --max >0 is incompatible with --min 0\n");
#line 243
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h\' for more information.\n",
                  *(argv + 0));
#line 244
          exit(1);
          }
        }
#line 246
        max_weight = 0;
      }
    }
#line 248
    min_weight_set = 1;
#line 249
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 251
    tmp___0 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& ptr),
                     10);
#line 251
    max_weight = (int )tmp___0;
    }
#line 252
    if ((int )*optarg == 0) {
      {
#line 253
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad argument: %s\n",
              optarg);
#line 254
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h\' for more information.\n",
              *(argv + 0));
#line 255
      exit(1);
      }
    } else
#line 252
    if ((int )*ptr != 0) {
      {
#line 253
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad argument: %s\n",
              optarg);
#line 254
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h\' for more information.\n",
              *(argv + 0));
#line 255
      exit(1);
      }
    } else
#line 252
    if (max_weight < 0) {
      {
#line 253
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad argument: %s\n",
              optarg);
#line 254
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h\' for more information.\n",
              *(argv + 0));
#line 255
      exit(1);
      }
    }
#line 257
    if (max_weight > 0) {
#line 257
      if (min_weight == 0) {
#line 258
        if (min_weight_set) {
          {
#line 259
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: --max >0 is incompatible with --min 0\n");
#line 261
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h\' for more information.\n",
                  *(argv + 0));
#line 262
          exit(1);
          }
        }
#line 264
        min_weight = 1;
      }
    }
#line 266
    max_weight_set = 1;
#line 267
    goto switch_break;
    case_120: /* CIL Label */ 
#line 269
    maximal = 1;
#line 270
    goto switch_break;
    case_117: /* CIL Label */ 
#line 272
    unweighted = 1;
#line 273
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 275
    tmp___7 = strcasecmp((char const   *)optarg, "none");
    }
#line 275
    if (tmp___7 == 0) {
#line 276
      reorder = (int *(*)(graph_t * , int  ))((void *)0);
    } else {
      {
#line 277
      tmp___6 = strcasecmp((char const   *)optarg, "reverse");
      }
#line 277
      if (tmp___6 == 0) {
#line 278
        reorder = (int *(*)(graph_t * , int  ))(& reorder_by_reverse);
      } else {
        {
#line 279
        tmp___5 = strcasecmp((char const   *)optarg, "default");
        }
#line 279
        if (tmp___5 == 0) {
#line 280
          reorder = (int *(*)(graph_t * , int  ))(& reorder_by_greedy_coloring);
        } else {
          {
#line 281
          tmp___4 = strcasecmp((char const   *)optarg, "unweighted-coloring");
          }
#line 281
          if (tmp___4 == 0) {
#line 282
            reorder = (int *(*)(graph_t * , int  ))(& reorder_by_unweighted_greedy_coloring);
          } else {
            {
#line 283
            tmp___3 = strcasecmp((char const   *)optarg, "weighted-coloring");
            }
#line 283
            if (tmp___3 == 0) {
#line 284
              reorder = (int *(*)(graph_t * , int  ))(& reorder_by_weighted_greedy_coloring);
            } else {
              {
#line 285
              tmp___2 = strcasecmp((char const   *)optarg, "degree");
              }
#line 285
              if (tmp___2 == 0) {
#line 286
                reorder = (int *(*)(graph_t * , int  ))(& reorder_by_degree);
              } else {
                {
#line 287
                tmp___1 = strcasecmp((char const   *)optarg, "random");
                }
#line 287
                if (tmp___1 == 0) {
#line 288
                  reorder = (int *(*)(graph_t * , int  ))(& reorder_by_random);
                } else {
                  {
#line 290
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad reordering type: %s\n",
                          optarg);
#line 292
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h\' for more information.\n",
                          *(argv + 0));
#line 293
                  exit(1);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 295
    goto switch_break;
    case_48: /* CIL Label */ 
#line 297
    number1 = 0;
#line 298
    goto switch_break;
    case_113: /* CIL Label */ 
#line 300
    quiet ++;
#line 301
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 303
    printhelp(*(argv + 0));
    }
#line 304
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 312
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h\' for more information.\n",
            *(argv + 0));
#line 313
    exit(1);
    }
    switch_default: /* CIL Label */ 
    {
#line 315
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Internal bug: line %d should never be reached!",
            316);
#line 317
    exit(-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  if (optind >= argc) {
    {
#line 322
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing filename.\n");
#line 323
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h\' for more information.\n",
            *(argv + 0));
#line 324
    exit(1);
    }
  }
#line 326
  if (optind < argc - 1) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad command line option: %s\n",
            *(argv + (optind + 1)));
#line 328
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h\' for more information.\n",
            *(argv + 0));
#line 329
    exit(1);
    }
  }
#line 332
  file = *(argv + optind);
#line 333
  return;
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static void print_search(graph_t *g ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 341
  if (find_all) {
#line 341
    tmp = "all";
  } else {
#line 341
    tmp = "a single";
  }
  {
#line 341
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Searching for %s ",
          tmp);
  }
#line 342
  if (min_weight == 0) {
#line 343
    if (find_all) {
#line 343
      tmp___0 = "s";
    } else {
#line 343
      tmp___0 = "";
    }
#line 343
    if (unweighted) {
#line 343
      tmp___1 = "size";
    } else {
#line 343
      tmp___1 = "weight";
    }
    {
#line 343
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"maximum %s clique%s...\n",
            tmp___1, tmp___0);
    }
#line 345
    return;
  }
#line 347
  if (min_weight > 0) {
#line 347
    if (maximal) {
      {
#line 348
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"maximal ");
      }
    }
  }
#line 349
  if (unweighted) {
#line 349
    tmp___2 = "size";
  } else {
#line 349
    tmp___2 = "weight";
  }
#line 349
  if (find_all) {
#line 349
    tmp___3 = "s";
  } else {
#line 349
    tmp___3 = "";
  }
  {
#line 349
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"clique%s with %s ",
          tmp___3, tmp___2);
  }
#line 351
  if (max_weight == 0) {
    {
#line 352
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"at least %d...",
            min_weight);
    }
  } else
#line 353
  if (min_weight == max_weight) {
    {
#line 354
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"exactly %d...",
            min_weight);
    }
  } else {
    {
#line 356
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"within range %d-%d...",
            min_weight, max_weight);
    }
  }
  {
#line 358
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 359
  return;
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static void print_clique(set_t s , graph_t *g ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 368
  tmp = graph_subgraph_weight(g, s);
#line 368
  tmp___0 = set_size___0(s);
#line 368
  printf((char const   */* __restrict  */)"size=%d, weight=%d:  ", tmp___0, tmp);
#line 369
  i = 0;
  }
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! ((setelement )i < *(s + -1))) {
#line 369
      goto while_break;
    }
#line 370
    if ((setelement )i < *(s + -1)) {
#line 370
      tmp___1 = *(s + i / 64) & (1UL << i % 64);
    } else {
#line 370
      tmp___1 = 0UL;
    }
#line 370
    if (tmp___1) {
#line 371
      if (number1) {
        {
#line 372
        printf((char const   */* __restrict  */)" %d", i + 1);
        }
      } else {
        {
#line 374
        printf((char const   */* __restrict  */)" %d", i);
        }
      }
    }
#line 369
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 377
  printf((char const   */* __restrict  */)"\n");
  }
#line 378
  return;
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int record_clique_func(set_t s , graph_t *g , clique_options *opts ) 
{ 
  void *tmp ;

  {
#line 386
  if (clique_count >= clique_list_size) {
    {
#line 387
    tmp = realloc((void *)clique_list, (unsigned long )(clique_list_size + 512) * sizeof(set_t ));
#line 387
    clique_list = (set_t *)tmp;
#line 389
    clique_list_size += 512;
    }
  }
  {
#line 391
  *(clique_list + clique_count) = set_duplicate___0(s);
#line 392
  clique_count ++;
  }
#line 393
  return (1);
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cl.c"
static int print_clique_func(set_t s , graph_t *g , clique_options *opts ) 
{ 


  {
  {
#line 400
  print_clique(s, g);
  }
#line 401
  return (1);
}
}
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static set_t set_new___1(int size )  __attribute__((__unused__)) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static set_t set_new___1(int size ) 
{ 
  int n ;
  set_t s ;
  void *tmp ;

  {
#line 149
  if (! (size > 0)) {
    {
#line 149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h", 149, "size>0");
#line 149
    abort();
    }
  }
  {
#line 151
  n = (size / 64 + 1) + 1;
#line 152
  tmp = calloc((size_t )n, sizeof(setelement ));
#line 152
  s = (set_t )tmp;
#line 153
  *(s + 0) = (setelement )size;
  }
#line 155
  return (s + 1);
}
}
#line 217
__inline static set_t set_duplicate___1(set_t s )  __attribute__((__unused__)) ;
#line 217 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static set_t set_duplicate___1(set_t s ) 
{ 
  set_t new ;

  {
  {
#line 221
  new = set_new___1((int )*(s + -1));
#line 222
  memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)s, (((*(s + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
  }
#line 223
  return (new);
}
}
#line 233
__inline static set_t set_copy___0(set_t dest , set_t src )  __attribute__((__unused__)) ;
#line 233 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static set_t set_copy___0(set_t dest , set_t src ) 
{ 
  set_t tmp ;
  set_t tmp___0 ;

  {
#line 235
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
    {
#line 236
    tmp = set_duplicate___1(src);
    }
#line 236
    return (tmp);
  }
#line 237
  if (*(dest + -1) < *(src + -1)) {
    {
#line 238
    set_free(dest);
#line 239
    tmp___0 = set_duplicate___1(src);
    }
#line 239
    return (tmp___0);
  }
  {
#line 241
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, (((*(src + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
#line 242
  memset((void *)(dest + ((*(src + -1) + 64UL) - 1UL) / 64UL), 0, (((*(dest + -1) + 64UL) - 1UL) / 64UL - ((*(src + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
  }
#line 245
  return (dest);
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.h"
void __attribute__((__visibility__("default")))  reorder_set(set_t s , int *order ) ;
#line 9
void __attribute__((__visibility__("default")))  reorder_graph(graph_t *g , int *order ) ;
#line 11
void __attribute__((__visibility__("default")))  reorder_invert(int *order , int n ) ;
#line 12
void __attribute__((__visibility__("default")))  reorder_reverse(int *order , int n ) ;
#line 23
int __attribute__((__visibility__("default")))  *reorder_by_ident(graph_t *g , int weighted ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
void __attribute__((__visibility__("default")))  reorder_set(set_t s , int *order ) 
{ 
  set_t tmp ;
  int i ;
  int j ;
  setelement e ;
  int __attribute__((__visibility__("default")))  tmp___0 ;

  {
  {
#line 30
  tmp___0 = reorder_is_bijection(order, (int )*(s + -1));
  }
#line 30
  if (! tmp___0) {
    {
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c", 30,
            "reorder_is_bijection(order,SET_MAX_SIZE(s))");
#line 30
    abort();
    }
  }
  {
#line 32
  tmp = set_new___1((int )*(s + -1));
#line 34
  i = 0;
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! ((setelement )i < *(s + -1) / 64UL)) {
#line 34
      goto while_break;
    }
#line 35
    e = *(s + i);
#line 36
    if (e == 0UL) {
#line 37
      goto __Cont;
    }
#line 38
    j = 0;
    {
#line 38
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 38
      if (! (j < 64)) {
#line 38
        goto while_break___0;
      }
#line 39
      if (e & 1UL) {
#line 40
        *(tmp + *(order + (i * 64 + j)) / 64) |= 1UL << *(order + (i * 64 + j)) % 64;
      }
#line 42
      e >>= 1;
#line 38
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 34
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  if (*(s + -1) % 64UL) {
#line 46
    e = *(s + i);
#line 47
    j = 0;
    {
#line 47
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 47
      if (! ((unsigned long )j < *(s + -1) % 64UL)) {
#line 47
        goto while_break___1;
      }
#line 48
      if (e & 1UL) {
#line 49
        *(tmp + *(order + (i * 64 + j)) / 64) |= 1UL << *(order + (i * 64 + j)) % 64;
      }
#line 51
      e >>= 1;
#line 47
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 54
  set_copy___0(s, tmp);
#line 55
  set_free(tmp);
  }
#line 56
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
void __attribute__((__visibility__("default")))  reorder_graph(graph_t *g , int *order ) 
{ 
  int i ;
  set_t *tmp_e ;
  int *tmp_w ;
  int __attribute__((__visibility__("default")))  tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 72
  tmp = reorder_is_bijection(order, g->n);
  }
#line 72
  if (! tmp) {
    {
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c", 72,
            "reorder_is_bijection(order,g->n)");
#line 72
    abort();
    }
  }
  {
#line 74
  tmp___0 = malloc((unsigned long )g->n * sizeof(set_t ));
#line 74
  tmp_e = (set_t *)tmp___0;
#line 75
  tmp___1 = malloc((unsigned long )g->n * sizeof(int ));
#line 75
  tmp_w = (int *)tmp___1;
#line 76
  i = 0;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < g->n)) {
#line 76
      goto while_break;
    }
    {
#line 77
    reorder_set(*(g->edges + i), order);
#line 78
    *(tmp_e + *(order + i)) = *(g->edges + i);
#line 79
    *(tmp_w + *(order + i)) = *(g->weights + i);
#line 76
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 81
    if (! (i < g->n)) {
#line 81
      goto while_break___0;
    }
#line 82
    *(g->edges + i) = *(tmp_e + i);
#line 83
    *(g->weights + i) = *(tmp_w + i);
#line 81
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 85
  free((void *)tmp_e);
#line 86
  free((void *)tmp_w);
  }
#line 87
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
int __attribute__((__visibility__("default")))  *reorder_duplicate(int *order , int n ) 
{ 
  int *new ;
  void *tmp ;

  {
  {
#line 100
  tmp = malloc((unsigned long )n * sizeof(int ));
#line 100
  new = (int *)tmp;
#line 101
  memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)order, (unsigned long )n * sizeof(int ));
  }
#line 102
  return ((int __attribute__((__visibility__("default")))  *)new);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
void __attribute__((__visibility__("default")))  reorder_invert(int *order , int n ) 
{ 
  int *new ;
  int i ;
  int __attribute__((__visibility__("default")))  tmp ;
  void *tmp___0 ;

  {
  {
#line 116
  tmp = reorder_is_bijection(order, n);
  }
#line 116
  if (! tmp) {
    {
#line 116
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c", 116,
            "reorder_is_bijection(order,n)");
#line 116
    abort();
    }
  }
  {
#line 118
  tmp___0 = malloc((unsigned long )n * sizeof(int ));
#line 118
  new = (int *)tmp___0;
#line 119
  i = 0;
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (i < n)) {
#line 119
      goto while_break;
    }
#line 120
    *(new + *(order + i)) = i;
#line 119
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (i < n)) {
#line 121
      goto while_break___0;
    }
#line 122
    *(order + i) = *(new + i);
#line 121
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 123
  free((void *)new);
  }
#line 124
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
void __attribute__((__visibility__("default")))  reorder_reverse(int *order , int n ) 
{ 
  int i ;

  {
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i < n)) {
#line 135
      goto while_break;
    }
#line 136
    *(order + i) = (n - 1) - *(order + i);
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
int __attribute__((__visibility__("default")))  reorder_is_bijection(int *order ,
                                                                     int n ) 
{ 
  int *used ;
  int i ;
  void *tmp ;

  {
  {
#line 151
  tmp = calloc((size_t )n, sizeof(int ));
#line 151
  used = (int *)tmp;
#line 152
  i = 0;
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < n)) {
#line 152
      goto while_break;
    }
#line 153
    if (*(order + i) < 0) {
      {
#line 154
      free((void *)used);
      }
#line 155
      return ((int __attribute__((__visibility__("default")))  )0);
    } else
#line 153
    if (*(order + i) >= n) {
      {
#line 154
      free((void *)used);
      }
#line 155
      return ((int __attribute__((__visibility__("default")))  )0);
    }
#line 157
    if (*(used + *(order + i))) {
      {
#line 158
      free((void *)used);
      }
#line 159
      return ((int __attribute__((__visibility__("default")))  )0);
    }
#line 161
    *(used + *(order + i)) = 1;
#line 152
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  i = 0;
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 163
    if (! (i < n)) {
#line 163
      goto while_break___0;
    }
#line 164
    if (! *(used + i)) {
      {
#line 165
      free((void *)used);
      }
#line 166
      return ((int __attribute__((__visibility__("default")))  )0);
    }
#line 163
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 169
  free((void *)used);
  }
#line 170
  return ((int __attribute__((__visibility__("default")))  )1);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
int __attribute__((__visibility__("default")))  *reorder_ident(int n ) 
{ 
  int i ;
  int *order ;
  void *tmp ;

  {
  {
#line 182
  tmp = malloc((unsigned long )n * sizeof(int ));
#line 182
  order = (int *)tmp;
#line 183
  i = 0;
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (i < n)) {
#line 183
      goto while_break;
    }
#line 184
    *(order + i) = i;
#line 183
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return ((int __attribute__((__visibility__("default")))  *)order);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
int __attribute__((__visibility__("default")))  *reorder_by_ident(graph_t *g , int weighted ) 
{ 
  int __attribute__((__visibility__("default")))  *tmp ;

  {
  {
#line 198
  tmp = reorder_ident(g->n);
  }
#line 198
  return (tmp);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
int __attribute__((__visibility__("default")))  *reorder_by_reverse(graph_t *g , int weighted ) 
{ 
  int i ;
  int *order ;
  void *tmp ;

  {
  {
#line 210
  tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 210
  order = (int *)tmp;
#line 211
  i = 0;
  }
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i < g->n)) {
#line 211
      goto while_break;
    }
#line 212
    *(order + i) = (g->n - i) - 1;
#line 211
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return ((int __attribute__((__visibility__("default")))  *)order);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
int __attribute__((__visibility__("default")))  *reorder_by_greedy_coloring(graph_t *g ,
                                                                            int weighted ) 
{ 
  int __attribute__((__visibility__("default")))  *tmp ;
  int __attribute__((__visibility__("default")))  *tmp___0 ;

  {
#line 223
  if (weighted) {
    {
#line 224
    tmp = reorder_by_weighted_greedy_coloring(g, weighted);
    }
#line 224
    return (tmp);
  } else {
    {
#line 226
    tmp___0 = reorder_by_unweighted_greedy_coloring(g, weighted);
    }
#line 226
    return (tmp___0);
  }
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
int __attribute__((__visibility__("default")))  *reorder_by_unweighted_greedy_coloring(graph_t *g ,
                                                                                       int weighted ) 
{ 
  int i ;
  int j ;
  int v ;
  int *tmp_used ;
  int *degree ;
  int *order ;
  int maxdegree ;
  int maxvertex ;
  int samecolor ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;

  {
  {
#line 244
  maxvertex = 0;
#line 247
  tmp = calloc((size_t )g->n, sizeof(int ));
#line 247
  tmp_used = (int *)tmp;
#line 248
  tmp___0 = calloc((size_t )g->n, sizeof(int ));
#line 248
  degree = (int *)tmp___0;
#line 249
  tmp___1 = calloc((size_t )g->n, sizeof(int ));
#line 249
  order = (int *)tmp___1;
#line 251
  i = 0;
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (i < g->n)) {
#line 251
      goto while_break;
    }
#line 252
    j = 0;
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 252
      if (! (j < g->n)) {
#line 252
        goto while_break___0;
      }
#line 253
      if (i == j) {
#line 253
        if (i < g->n) {
#line 253
          if ((setelement )j < *(*(g->edges + i) + -1)) {
#line 253
            tmp___2 = *(*(g->edges + i) + j / 64) & (1UL << j % 64);
          } else {
#line 253
            tmp___2 = 0UL;
          }
#line 253
          tmp___3 = tmp___2;
        } else {
#line 253
          tmp___3 = 0UL;
        }
#line 253
        if (tmp___3) {
          {
#line 253
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
                  "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c",
                  253, "!((i==j) && GRAPH_IS_EDGE(g,i,j))");
#line 253
          abort();
          }
        }
      }
#line 254
      if (i < g->n) {
#line 254
        if ((setelement )j < *(*(g->edges + i) + -1)) {
#line 254
          tmp___4 = *(*(g->edges + i) + j / 64) & (1UL << j % 64);
        } else {
#line 254
          tmp___4 = 0UL;
        }
#line 254
        tmp___5 = tmp___4;
      } else {
#line 254
        tmp___5 = 0UL;
      }
#line 254
      if (tmp___5) {
#line 255
        (*(degree + i)) ++;
      }
#line 252
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 251
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  v = 0;
  {
#line 260
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 260
    if (! (v < g->n)) {
#line 260
      goto while_break___1;
    }
    {
#line 262
    memset((void *)tmp_used, 0, (unsigned long )g->n * sizeof(int ));
    }
    {
#line 264
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 266
      maxdegree = 0;
#line 267
      samecolor = 0;
#line 268
      i = 0;
      {
#line 268
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 268
        if (! (i < g->n)) {
#line 268
          goto while_break___3;
        }
#line 269
        if (! *(tmp_used + i)) {
#line 269
          if (*(degree + i) >= maxdegree) {
#line 270
            maxvertex = i;
#line 271
            maxdegree = *(degree + i);
#line 272
            samecolor = 1;
          }
        }
#line 268
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 275
      if (samecolor) {
#line 276
        *(order + v) = maxvertex;
#line 277
        *(degree + maxvertex) = -1;
#line 278
        v ++;
#line 282
        i = 0;
        {
#line 282
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 282
          if (! (i < g->n)) {
#line 282
            goto while_break___4;
          }
#line 283
          if (maxvertex < g->n) {
#line 283
            if ((setelement )i < *(*(g->edges + maxvertex) + -1)) {
#line 283
              tmp___6 = *(*(g->edges + maxvertex) + i / 64) & (1UL << i % 64);
            } else {
#line 283
              tmp___6 = 0UL;
            }
#line 283
            tmp___7 = tmp___6;
          } else {
#line 283
            tmp___7 = 0UL;
          }
#line 283
          if (tmp___7) {
#line 284
            *(tmp_used + i) = 1;
#line 285
            (*(degree + i)) --;
          }
#line 282
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 264
      if (! samecolor) {
#line 264
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 292
  free((void *)tmp_used);
#line 293
  free((void *)degree);
  }
#line 294
  return ((int __attribute__((__visibility__("default")))  *)order);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
int __attribute__((__visibility__("default")))  *reorder_by_weighted_greedy_coloring(graph_t *g ,
                                                                                     int weighted ) 
{ 
  int i ;
  int j ;
  int p ;
  int cnt ;
  int *nwt ;
  int min_wt ;
  int max_nwt ;
  int *used ;
  int *order ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int __attribute__((__visibility__("default")))  tmp___6 ;

  {
  {
#line 308
  p = 0;
#line 315
  tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 315
  nwt = (int *)tmp;
#line 316
  tmp___0 = malloc((unsigned long )g->n * sizeof(int ));
#line 316
  order = (int *)tmp___0;
#line 317
  tmp___1 = calloc((size_t )g->n, sizeof(int ));
#line 317
  used = (int *)tmp___1;
#line 319
  i = 0;
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! (i < g->n)) {
#line 319
      goto while_break;
    }
#line 320
    *(nwt + i) = 0;
#line 321
    j = 0;
    {
#line 321
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 321
      if (! (j < g->n)) {
#line 321
        goto while_break___0;
      }
#line 322
      if (i < g->n) {
#line 322
        if ((setelement )j < *(*(g->edges + i) + -1)) {
#line 322
          tmp___2 = *(*(g->edges + i) + j / 64) & (1UL << j % 64);
        } else {
#line 322
          tmp___2 = 0UL;
        }
#line 322
        tmp___3 = tmp___2;
      } else {
#line 322
        tmp___3 = 0UL;
      }
#line 322
      if (tmp___3) {
#line 323
        *(nwt + i) += *(g->weights + j);
      }
#line 321
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 319
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  cnt = 0;
  {
#line 326
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 326
    if (! (cnt < g->n)) {
#line 326
      goto while_break___1;
    }
#line 327
    min_wt = 2147483647;
#line 328
    max_nwt = -1;
#line 329
    i = g->n - 1;
    {
#line 329
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 329
      if (! (i >= 0)) {
#line 329
        goto while_break___2;
      }
#line 330
      if (! *(used + i)) {
#line 330
        if (*(g->weights + i) < min_wt) {
#line 331
          min_wt = *(g->weights + i);
        }
      }
#line 329
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 332
    i = g->n - 1;
    {
#line 332
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 332
      if (! (i >= 0)) {
#line 332
        goto while_break___3;
      }
#line 333
      if (*(used + i)) {
#line 334
        goto __Cont;
      } else
#line 333
      if (*(g->weights + i) > min_wt) {
#line 334
        goto __Cont;
      }
#line 335
      if (*(nwt + i) > max_nwt) {
#line 336
        max_nwt = *(nwt + i);
#line 337
        p = i;
      }
      __Cont: /* CIL Label */ 
#line 332
      i --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 340
    *(order + cnt) = p;
#line 341
    *(used + p) = 1;
#line 342
    j = 0;
    {
#line 342
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 342
      if (! (j < g->n)) {
#line 342
        goto while_break___4;
      }
#line 343
      if (! *(used + j)) {
#line 343
        if (p < g->n) {
#line 343
          if ((setelement )j < *(*(g->edges + p) + -1)) {
#line 343
            tmp___4 = *(*(g->edges + p) + j / 64) & (1UL << j % 64);
          } else {
#line 343
            tmp___4 = 0UL;
          }
#line 343
          tmp___5 = tmp___4;
        } else {
#line 343
          tmp___5 = 0UL;
        }
#line 343
        if (tmp___5) {
#line 344
          *(nwt + j) -= *(g->weights + p);
        }
      }
#line 342
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 326
    cnt ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 347
  free((void *)nwt);
#line 348
  free((void *)used);
#line 350
  tmp___6 = reorder_is_bijection(order, g->n);
  }
#line 350
  if (! tmp___6) {
    {
#line 350
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c", 350,
            "reorder_is_bijection(order,g->n)");
#line 350
    abort();
    }
  }
#line 352
  return ((int __attribute__((__visibility__("default")))  *)order);
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
int __attribute__((__visibility__("default")))  *reorder_by_degree(graph_t *g , int weighted ) 
{ 
  int i ;
  int j ;
  int v ;
  int *degree ;
  int *order ;
  int maxdegree ;
  int maxvertex ;
  void *tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
  {
#line 365
  maxvertex = 0;
#line 367
  tmp = calloc((size_t )g->n, sizeof(int ));
#line 367
  degree = (int *)tmp;
#line 368
  tmp___0 = calloc((size_t )g->n, sizeof(int ));
#line 368
  order = (int *)tmp___0;
#line 370
  i = 0;
  }
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (i < g->n)) {
#line 370
      goto while_break;
    }
#line 371
    j = 0;
    {
#line 371
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 371
      if (! (j < g->n)) {
#line 371
        goto while_break___0;
      }
#line 372
      if (i == j) {
#line 372
        if (i < g->n) {
#line 372
          if ((setelement )j < *(*(g->edges + i) + -1)) {
#line 372
            tmp___1 = *(*(g->edges + i) + j / 64) & (1UL << j % 64);
          } else {
#line 372
            tmp___1 = 0UL;
          }
#line 372
          tmp___2 = tmp___1;
        } else {
#line 372
          tmp___2 = 0UL;
        }
#line 372
        if (tmp___2) {
          {
#line 372
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
                  "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c",
                  372, "!((i==j) && GRAPH_IS_EDGE(g,i,j))");
#line 372
          abort();
          }
        }
      }
#line 373
      if (i < g->n) {
#line 373
        if ((setelement )j < *(*(g->edges + i) + -1)) {
#line 373
          tmp___3 = *(*(g->edges + i) + j / 64) & (1UL << j % 64);
        } else {
#line 373
          tmp___3 = 0UL;
        }
#line 373
        tmp___4 = tmp___3;
      } else {
#line 373
        tmp___4 = 0UL;
      }
#line 373
      if (tmp___4) {
#line 374
        (*(degree + i)) ++;
      }
#line 371
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 370
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  v = 0;
  {
#line 378
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 378
    if (! (v < g->n)) {
#line 378
      goto while_break___1;
    }
#line 379
    maxdegree = 0;
#line 380
    i = 0;
    {
#line 380
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 380
      if (! (i < g->n)) {
#line 380
        goto while_break___2;
      }
#line 381
      if (*(degree + i) >= maxdegree) {
#line 382
        maxvertex = i;
#line 383
        maxdegree = *(degree + i);
      }
#line 380
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 386
    *(order + v) = maxvertex;
#line 387
    *(degree + maxvertex) = -1;
#line 378
    v ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 396
  free((void *)degree);
  }
#line 397
  return ((int __attribute__((__visibility__("default")))  *)order);
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/reorder.c"
int __attribute__((__visibility__("default")))  *reorder_by_random(graph_t *g , int weighted ) 
{ 
  struct tms t ;
  int i ;
  int r ;
  int *new ;
  int *used ;
  clock_t tmp ;
  time_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 414
  tmp = times(& t);
#line 414
  tmp___0 = time((time_t *)((void *)0));
#line 414
  srand((unsigned int )(tmp + tmp___0));
#line 416
  tmp___1 = calloc((size_t )g->n, sizeof(int ));
#line 416
  new = (int *)tmp___1;
#line 417
  tmp___2 = calloc((size_t )g->n, sizeof(int ));
#line 417
  used = (int *)tmp___2;
#line 418
  i = 0;
  }
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (! (i < g->n)) {
#line 418
      goto while_break;
    }
    {
#line 419
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 420
      tmp___3 = rand();
#line 420
      r = tmp___3 % g->n;
      }
#line 419
      if (! *(used + r)) {
#line 419
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 422
    *(new + i) = r;
#line 423
    *(used + r) = 1;
#line 418
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 425
  free((void *)used);
  }
#line 426
  return ((int __attribute__((__visibility__("default")))  *)new);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static int set_bit_count___1[256]  = 
#line 51 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
  {      0,      1,      1,      2, 
        1,      2,      2,      3, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        5,      6,      6,      7, 
        6,      7,      7,      8};
#line 144
static set_t set_new___2(int size )  __attribute__((__unused__)) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static set_t set_new___2(int size ) 
{ 
  int n ;
  set_t s ;
  void *tmp ;

  {
#line 149
  if (! (size > 0)) {
    {
#line 149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h", 149, "size>0");
#line 149
    abort();
    }
  }
  {
#line 151
  n = (size / 64 + 1) + 1;
#line 152
  tmp = calloc((size_t )n, sizeof(setelement ));
#line 152
  s = (set_t )tmp;
#line 153
  *(s + 0) = (setelement )size;
  }
#line 155
  return (s + 1);
}
}
#line 177
__inline static set_t set_resize(set_t s , int size )  __attribute__((__unused__)) ;
#line 177 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static set_t set_resize(set_t s , int size ) 
{ 
  int n ;
  void *tmp ;

  {
#line 181
  if (! (size > 0)) {
    {
#line 181
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h", 181, "size>0");
#line 181
    abort();
    }
  }
  {
#line 183
  n = size / 64 + 1;
#line 184
  tmp = realloc((void *)(s - 1), (unsigned long )(n + 1) * sizeof(setelement ));
#line 184
  s = (setelement *)tmp + 1;
  }
#line 186
  if ((setelement )n > ((*(s + -1) + 64UL) - 1UL) / 64UL) {
    {
#line 187
    memset((void *)(s + ((*(s + -1) + 64UL) - 1UL) / 64UL), 0, ((setelement )n - ((*(s + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
    }
  }
#line 189
  if ((setelement )size < *(s + -1)) {
#line 190
    *(s + (size - 1) / 64) &= 0xffffffffffffffffUL >> (64 - size % 64);
  }
#line 192
  *(s + -1) = (setelement )size;
#line 194
  return (s);
}
}
#line 202
__inline static int set_size___1(set_t s )  __attribute__((__unused__)) ;
#line 202 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static int set_size___1(set_t s ) 
{ 
  int count ;
  setelement *c ;

  {
#line 204
  count = 0;
#line 207
  c = s;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )c < (unsigned long )(s + ((*(s + -1) + 64UL) - 1UL) / 64UL))) {
#line 207
      goto while_break;
    }
#line 208
    count += ((((((set_bit_count___1[*c >> 56] + set_bit_count___1[(*c >> 48) & 255UL]) + set_bit_count___1[(*c >> 40) & 255UL]) + set_bit_count___1[(*c >> 32) & 255UL]) + set_bit_count___1[(*c >> 24) & 255UL]) + set_bit_count___1[(*c >> 16) & 255UL]) + set_bit_count___1[(*c >> 8) & 255UL]) + set_bit_count___1[*c & 255UL];
#line 207
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return (count);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.h"
graph_t __attribute__((__visibility__("default")))  *graph_new(int n ) ;
#line 29
void __attribute__((__visibility__("default")))  graph_free(graph_t *g ) ;
#line 30
void __attribute__((__visibility__("default")))  graph_resize(graph_t *g , int size ) ;
#line 31
void __attribute__((__visibility__("default")))  graph_crop(graph_t *g ) ;
#line 34
int __attribute__((__visibility__("default")))  graph_edge_count(graph_t *g ) ;
#line 37
graph_t __attribute__((__visibility__("default")))  *graph_read_dimacs_file(char *file___0 ) ;
#line 38
int __attribute__((__visibility__("default")))  graph_write_dimacs_ascii(graph_t *g ,
                                                                         char *comment ,
                                                                         FILE *fp ) ;
#line 39
int __attribute__((__visibility__("default")))  graph_write_dimacs_ascii_file(graph_t *g ,
                                                                              char *comment ,
                                                                              char *file___0 ) ;
#line 41
int __attribute__((__visibility__("default")))  graph_write_dimacs_binary(graph_t *g ,
                                                                          char *comment ,
                                                                          FILE *fp ) ;
#line 42
int __attribute__((__visibility__("default")))  graph_write_dimacs_binary_file(graph_t *g ,
                                                                               char *comment ,
                                                                               char *file___0 ) ;
#line 45
void __attribute__((__visibility__("default")))  graph_print(graph_t *g ) ;
#line 46
int __attribute__((__visibility__("default")))  graph_test(graph_t *g , FILE *output ) ;
#line 47
int __attribute__((__visibility__("default")))  graph_test_regular(graph_t *g ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
static graph_t *graph_read_dimacs_binary(FILE *fp , char *firstline ) ;
#line 17
static graph_t *graph_read_dimacs_ascii(FILE *fp , char *firstline ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
graph_t __attribute__((__visibility__("default")))  *graph_new(int n ) 
{ 
  graph_t *g ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 30
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 30,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 30
    abort();
    }
  }
#line 31
  if (! (n > 0)) {
    {
#line 31
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 31,
            "n>0");
#line 31
    abort();
    }
  }
  {
#line 33
  tmp = malloc(sizeof(graph_t ));
#line 33
  g = (graph_t *)tmp;
#line 34
  g->n = n;
#line 35
  tmp___0 = malloc((unsigned long )g->n * sizeof(set_t ));
#line 35
  g->edges = (set_t *)tmp___0;
#line 36
  tmp___1 = malloc((unsigned long )g->n * sizeof(int ));
#line 36
  g->weights = (int *)tmp___1;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < g->n)) {
#line 37
      goto while_break;
    }
    {
#line 38
    *(g->edges + i) = set_new___2(n);
#line 39
    *(g->weights + i) = 1;
#line 37
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return ((graph_t __attribute__((__visibility__("default")))  *)g);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
void __attribute__((__visibility__("default")))  graph_free(graph_t *g ) 
{ 
  int i ;

  {
#line 52
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 52
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 52,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 52
    abort();
    }
  }
#line 53
  if (! ((unsigned long )g != (unsigned long )((void *)0))) {
    {
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 53,
            "g!=NULL");
#line 53
    abort();
    }
  }
#line 54
  if (! (g->n > 0)) {
    {
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 54,
            "g->n > 0");
#line 54
    abort();
    }
  }
#line 56
  i = 0;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i < g->n)) {
#line 56
      goto while_break;
    }
    {
#line 57
    set_free(*(g->edges + i));
#line 56
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  free((void *)g->weights);
#line 60
  free((void *)g->edges);
#line 61
  free((void *)g);
  }
#line 62
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
void __attribute__((__visibility__("default")))  graph_resize(graph_t *g , int size ) 
{ 
  int i ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 76
  if (! ((unsigned long )g != (unsigned long )((void *)0))) {
    {
#line 76
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 76,
            "g!=NULL");
#line 76
    abort();
    }
  }
#line 77
  if (! (g->n > 0)) {
    {
#line 77
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 77,
            "g->n > 0");
#line 77
    abort();
    }
  }
#line 78
  if (! (size > 0)) {
    {
#line 78
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 78,
            "size > 0");
#line 78
    abort();
    }
  }
#line 80
  if (g->n == size) {
#line 81
    return;
  }
#line 84
  i = size;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < g->n)) {
#line 84
      goto while_break;
    }
    {
#line 85
    set_free(*(g->edges + i));
#line 84
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  tmp = realloc((void *)g->edges, (unsigned long )size * sizeof(set_t ));
#line 86
  g->edges = (set_t *)tmp;
#line 87
  i = g->n;
  }
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 87
    if (! (i < size)) {
#line 87
      goto while_break___0;
    }
    {
#line 88
    *(g->edges + i) = set_new___2(size);
#line 87
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 91
    if (g->n < size) {
#line 91
      tmp___0 = g->n;
    } else {
#line 91
      tmp___0 = size;
    }
#line 91
    if (! (i < tmp___0)) {
#line 91
      goto while_break___1;
    }
    {
#line 92
    *(g->edges + i) = set_resize(*(g->edges + i), size);
#line 91
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 96
  tmp___1 = realloc((void *)g->weights, (unsigned long )size * sizeof(int ));
#line 96
  g->weights = (int *)tmp___1;
#line 97
  i = g->n;
  }
  {
#line 97
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 97
    if (! (i < size)) {
#line 97
      goto while_break___2;
    }
#line 98
    *(g->weights + i) = 1;
#line 97
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 100
  g->n = size;
#line 101
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
void __attribute__((__visibility__("default")))  graph_crop(graph_t *g ) 
{ 
  int i ;
  int tmp ;

  {
#line 112
  i = g->n - 1;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (i >= 1)) {
#line 112
      goto while_break;
    }
    {
#line 113
    tmp = set_size___1(*(g->edges + i));
    }
#line 113
    if (tmp > 0) {
#line 114
      goto while_break;
    }
#line 112
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  graph_resize(g, i + 1);
  }
#line 116
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
int __attribute__((__visibility__("default")))  graph_weighted(graph_t *g ) 
{ 
  int i ;
  int w ;

  {
#line 130
  w = *(g->weights + 0);
#line 131
  i = 1;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < g->n)) {
#line 131
      goto while_break;
    }
#line 132
    if (*(g->weights + i) != w) {
#line 133
      return ((int __attribute__((__visibility__("default")))  )1);
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
int __attribute__((__visibility__("default")))  graph_edge_count(graph_t *g ) 
{ 
  int i ;
  int count ;
  int tmp ;

  {
#line 144
  count = 0;
#line 146
  i = 0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i < g->n)) {
#line 146
      goto while_break;
    }
    {
#line 147
    tmp = set_size___1(*(g->edges + i));
#line 147
    count += tmp;
#line 146
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return ((int __attribute__((__visibility__("default")))  )(count / 2));
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
int __attribute__((__visibility__("default")))  graph_write_dimacs_ascii_file(graph_t *g ,
                                                                              char *comment ,
                                                                              char *file___0 ) 
{ 
  FILE *fp ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
#line 164
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 164,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 164
    abort();
    }
  }
#line 165
  if (! ((unsigned long )file___0 != (unsigned long )((void *)0))) {
    {
#line 165
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 165,
            "file!=NULL");
#line 165
    abort();
    }
  }
  {
#line 167
  fp = fopen((char const   */* __restrict  */)file___0, (char const   */* __restrict  */)"wb");
  }
#line 167
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 168
    return ((int __attribute__((__visibility__("default")))  )0);
  }
  {
#line 169
  tmp = graph_write_dimacs_ascii(g, comment, fp);
  }
#line 169
  if (! tmp) {
    {
#line 170
    fclose(fp);
    }
#line 171
    return ((int __attribute__((__visibility__("default")))  )0);
  }
  {
#line 173
  fclose(fp);
  }
#line 174
  return ((int __attribute__((__visibility__("default")))  )1);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
int __attribute__((__visibility__("default")))  graph_write_dimacs_ascii(graph_t *g ,
                                                                         char *comment ,
                                                                         FILE *fp ) 
{ 
  int i ;
  int j ;
  int __attribute__((__visibility__("default")))  tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;

  {
#line 188
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 188,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 188
    abort();
    }
  }
  {
#line 189
  tmp = graph_test(g, (FILE *)((void *)0));
  }
#line 189
  if (! tmp) {
    {
#line 189
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 189,
            "graph_test(g,NULL)");
#line 189
    abort();
    }
  }
#line 190
  if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
    {
#line 190
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 190,
            "fp!=NULL");
#line 190
    abort();
    }
  }
#line 192
  if (comment) {
    {
#line 193
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"c %s\n",
            comment);
    }
  }
  {
#line 194
  tmp___0 = graph_edge_count(g);
#line 194
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"p edge %d %d\n",
          g->n, tmp___0);
#line 195
  i = 0;
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < g->n)) {
#line 195
      goto while_break;
    }
#line 196
    if (*(g->weights + i) != 1) {
      {
#line 197
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"n %d %d\n",
              i + 1, *(g->weights + i));
      }
    }
#line 195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    if (! (i < g->n)) {
#line 198
      goto while_break___0;
    }
#line 199
    j = 0;
    {
#line 199
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 199
      if (! (j < i)) {
#line 199
        goto while_break___1;
      }
#line 200
      if (*(*(g->edges + i) + j / 64) & (1UL << j % 64)) {
        {
#line 201
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"e %d %d\n",
                i + 1, j + 1);
        }
      }
#line 199
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 198
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 202
  return ((int __attribute__((__visibility__("default")))  )1);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
int __attribute__((__visibility__("default")))  graph_write_dimacs_binary_file(graph_t *g ,
                                                                               char *comment ,
                                                                               char *file___0 ) 
{ 
  FILE *fp ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
#line 216
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 216,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 216
    abort();
    }
  }
#line 217
  if (! ((unsigned long )file___0 != (unsigned long )((void *)0))) {
    {
#line 217
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 217,
            "file!=NULL");
#line 217
    abort();
    }
  }
  {
#line 219
  fp = fopen((char const   */* __restrict  */)file___0, (char const   */* __restrict  */)"wb");
  }
#line 219
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 220
    return ((int __attribute__((__visibility__("default")))  )0);
  }
  {
#line 221
  tmp = graph_write_dimacs_binary(g, comment, fp);
  }
#line 221
  if (! tmp) {
    {
#line 222
    fclose(fp);
    }
#line 223
    return ((int __attribute__((__visibility__("default")))  )0);
  }
  {
#line 225
  fclose(fp);
  }
#line 226
  return ((int __attribute__((__visibility__("default")))  )1);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
int __attribute__((__visibility__("default")))  graph_write_dimacs_binary(graph_t *g ,
                                                                          char *comment ,
                                                                          FILE *fp ) 
{ 
  char *buf ;
  char *header ;
  int headersize ;
  int headerlength ;
  int i ;
  int j ;
  int __attribute__((__visibility__("default")))  tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int __attribute__((__visibility__("default")))  tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
#line 248
  header = (char *)((void *)0);
#line 249
  headersize = 0;
#line 250
  headerlength = 0;
#line 253
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 253
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 253,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 253
    abort();
    }
  }
  {
#line 254
  tmp = graph_test(g, (FILE *)((void *)0));
  }
#line 254
  if (! tmp) {
    {
#line 254
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 254,
            "graph_test(g,NULL)");
#line 254
    abort();
    }
  }
#line 255
  if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
    {
#line 255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 255,
            "fp!=NULL");
#line 255
    abort();
    }
  }
#line 257
  if (1024 > g->n / 8 + 1) {
#line 257
    tmp___0 = 1024;
  } else {
#line 257
    tmp___0 = g->n / 8 + 1;
  }
  {
#line 257
  tmp___1 = malloc((size_t )tmp___0);
#line 257
  buf = (char *)tmp___1;
#line 258
  tmp___2 = malloc((size_t )1024);
#line 258
  header = (char *)tmp___2;
#line 259
  *(header + 0) = (char)0;
#line 260
  headersize = 1024;
  }
#line 261
  if (comment) {
    {
#line 262
    strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"c ");
#line 263
    strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)comment,
            (size_t )1000);
#line 264
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"\n");
#line 265
    tmp___4 = strlen((char const   *)buf);
    }
#line 265
    if ((size_t )headerlength + tmp___4 >= (size_t )headersize) {
      {
#line 265
      headersize += 1024;
#line 265
      tmp___3 = realloc((void *)header, (size_t )headersize);
#line 265
      header = (char *)tmp___3;
      }
    }
    {
#line 265
    strncat((char */* __restrict  */)header, (char const   */* __restrict  */)buf,
            (size_t )1000);
#line 265
    tmp___5 = strlen((char const   *)buf);
#line 265
    headerlength = (int )((size_t )headerlength + tmp___5);
    }
  }
  {
#line 267
  tmp___6 = graph_edge_count(g);
#line 267
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"p edge %d %d\n",
          g->n, tmp___6);
#line 268
  tmp___8 = strlen((char const   *)buf);
  }
#line 268
  if ((size_t )headerlength + tmp___8 >= (size_t )headersize) {
    {
#line 268
    headersize += 1024;
#line 268
    tmp___7 = realloc((void *)header, (size_t )headersize);
#line 268
    header = (char *)tmp___7;
    }
  }
  {
#line 268
  strncat((char */* __restrict  */)header, (char const   */* __restrict  */)buf, (size_t )1000);
#line 268
  tmp___9 = strlen((char const   *)buf);
#line 268
  headerlength = (int )((size_t )headerlength + tmp___9);
#line 269
  i = 0;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (i < g->n)) {
#line 269
      goto while_break;
    }
#line 270
    if (*(g->weights + i) != 1) {
      {
#line 271
      sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"n %d %d\n",
              i + 1, *(g->weights + i));
#line 272
      tmp___11 = strlen((char const   *)buf);
      }
#line 272
      if ((size_t )headerlength + tmp___11 >= (size_t )headersize) {
        {
#line 272
        headersize += 1024;
#line 272
        tmp___10 = realloc((void *)header, (size_t )headersize);
#line 272
        header = (char *)tmp___10;
        }
      }
      {
#line 272
      strncat((char */* __restrict  */)header, (char const   */* __restrict  */)buf,
              (size_t )1000);
#line 272
      tmp___12 = strlen((char const   *)buf);
#line 272
      headerlength = (int )((size_t )headerlength + tmp___12);
      }
    }
#line 269
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  tmp___13 = strlen((char const   *)header);
#line 276
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d\n", (int )tmp___13);
#line 277
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", header);
#line 278
  free((void *)header);
#line 280
  i = 0;
  }
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 280
    if (! (i < g->n)) {
#line 280
      goto while_break___0;
    }
    {
#line 281
    memset((void *)buf, 0, (size_t )(i / 8 + 1));
#line 282
    j = 0;
    }
    {
#line 282
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 282
      if (! (j < i)) {
#line 282
        goto while_break___1;
      }
#line 283
      if (*(*(g->edges + i) + j / 64) & (1UL << j % 64)) {
#line 284
        *(buf + j / 8) = (char )((unsigned long )*(buf + j / 8) | (1UL << (7 - j % 8)));
      }
#line 282
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 287
    fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )(i / 8 + 1),
           (FILE */* __restrict  */)fp);
#line 280
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 289
  free((void *)buf);
  }
#line 290
  return ((int __attribute__((__visibility__("default")))  )1);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
graph_t __attribute__((__visibility__("default")))  *graph_read_dimacs_file(char *file___0 ) 
{ 
  FILE *fp ;
  graph_t *g ;
  graph_t __attribute__((__visibility__("default")))  *tmp ;

  {
#line 307
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 307
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 307,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 307
    abort();
    }
  }
#line 308
  if (! ((unsigned long )file___0 != (unsigned long )((void *)0))) {
    {
#line 308
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 308,
            "file!=NULL");
#line 308
    abort();
    }
  }
  {
#line 310
  fp = fopen((char const   */* __restrict  */)file___0, (char const   */* __restrict  */)"rb");
  }
#line 310
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 311
    perror((char const   *)file___0);
    }
#line 312
    return ((graph_t __attribute__((__visibility__("default")))  *)((void *)0));
  }
  {
#line 314
  tmp = graph_read_dimacs(fp);
#line 314
  g = (graph_t *)tmp;
#line 315
  fclose(fp);
  }
#line 316
  return ((graph_t __attribute__((__visibility__("default")))  *)g);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
graph_t __attribute__((__visibility__("default")))  *graph_read_dimacs(FILE *fp ) 
{ 
  char buffer[1024] ;
  graph_t *g ;
  char tmp[10] ;
  int n ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 334
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 334
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 334,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 334
    abort();
    }
  }
#line 335
  if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
    {
#line 335
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 335,
            "fp!=NULL");
#line 335
    abort();
    }
  }
  {
#line 337
  tmp___0 = fgets((char */* __restrict  */)(buffer), 1023, (FILE */* __restrict  */)fp);
  }
#line 337
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 338
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Input does not contain any data.\n");
    }
#line 339
    return ((graph_t __attribute__((__visibility__("default")))  *)((void *)0));
  }
  {
#line 341
  tmp___1 = sscanf((char const   */* __restrict  */)(buffer), (char const   */* __restrict  */)" %d %2s",
                   & n, tmp);
  }
#line 341
  if (tmp___1 != 1) {
    {
#line 342
    g = graph_read_dimacs_ascii(fp, buffer);
    }
  } else {
    {
#line 344
    g = graph_read_dimacs_binary(fp, buffer);
    }
  }
#line 346
  return ((graph_t __attribute__((__visibility__("default")))  *)g);
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
static int parse_input(char *str , graph_t *g ) 
{ 
  int i ;
  int j ;
  int w ;
  char tmp[16] ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 366
  i = 0;
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 366
    tmp___1 = strlen((char const   *)str);
    }
#line 366
    if (! ((size_t )i < tmp___1)) {
#line 366
      goto while_break;
    }
    {
#line 367
    tmp___0 = __ctype_b_loc();
    }
#line 367
    if (! ((int const   )*(*tmp___0 + (int )*(str + i)) & 8192)) {
#line 368
      goto while_break;
    }
#line 366
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 370
  tmp___2 = strlen((char const   *)str);
  }
#line 370
  if ((size_t )i >= tmp___2) {
#line 371
    return (1);
  }
#line 372
  if ((int )*(str + (i + 1)) != 0) {
    {
#line 372
    tmp___3 = __ctype_b_loc();
    }
#line 372
    if (! ((int const   )*(*tmp___3 + (int )*(str + (i + 1))) & 8192)) {
#line 373
      return (0);
    }
  }
  {
#line 376
  if ((int )*(str + i) == 99) {
#line 376
    goto case_99;
  }
#line 378
  if ((int )*(str + i) == 112) {
#line 378
    goto case_112;
  }
#line 392
  if ((int )*(str + i) == 110) {
#line 392
    goto case_110;
  }
#line 403
  if ((int )*(str + i) == 101) {
#line 403
    goto case_101;
  }
#line 416
  if ((int )*(str + i) == 120) {
#line 416
    goto case_120;
  }
#line 416
  if ((int )*(str + i) == 118) {
#line 416
    goto case_120;
  }
#line 416
  if ((int )*(str + i) == 100) {
#line 416
    goto case_120;
  }
#line 418
  goto switch_default;
  case_99: /* CIL Label */ 
#line 377
  return (1);
  case_112: /* CIL Label */ 
#line 379
  if (g->n != 0) {
#line 380
    return (0);
  }
  {
#line 381
  tmp___4 = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)" p %15s %d %d %2s",
                   tmp, & g->n, & i, tmp);
  }
#line 381
  if (tmp___4 != 3) {
#line 382
    return (0);
  }
#line 383
  if (g->n <= 0) {
#line 384
    return (0);
  }
  {
#line 385
  tmp___5 = calloc((size_t )g->n, sizeof(set_t ));
#line 385
  g->edges = (set_t *)tmp___5;
#line 386
  i = 0;
  }
  {
#line 386
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 386
    if (! (i < g->n)) {
#line 386
      goto while_break___0;
    }
    {
#line 387
    *(g->edges + i) = set_new___2(g->n);
#line 386
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 388
  tmp___6 = calloc((size_t )g->n, sizeof(int ));
#line 388
  g->weights = (int *)tmp___6;
#line 389
  i = 0;
  }
  {
#line 389
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 389
    if (! (i < g->n)) {
#line 389
      goto while_break___1;
    }
#line 390
    *(g->weights + i) = 1;
#line 389
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 391
  return (1);
  case_110: /* CIL Label */ 
#line 393
  if (g->n <= 0) {
#line 394
    return (0);
  } else
#line 393
  if ((unsigned long )g->weights == (unsigned long )((void *)0)) {
#line 394
    return (0);
  }
  {
#line 395
  tmp___7 = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)" n %d %d %2s",
                   & i, & w, tmp);
  }
#line 395
  if (tmp___7 != 2) {
#line 396
    return (0);
  }
#line 397
  if (i < 1) {
#line 398
    return (0);
  } else
#line 397
  if (i > g->n) {
#line 398
    return (0);
  }
#line 399
  if (w <= 0) {
#line 400
    return (0);
  }
#line 401
  *(g->weights + (i - 1)) = w;
#line 402
  return (1);
  case_101: /* CIL Label */ 
#line 404
  if (g->n <= 0) {
#line 405
    return (0);
  } else
#line 404
  if ((unsigned long )g->edges == (unsigned long )((void *)0)) {
#line 405
    return (0);
  }
  {
#line 406
  tmp___8 = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)" e %d %d %2s",
                   & i, & j, tmp);
  }
#line 406
  if (tmp___8 != 2) {
#line 407
    return (0);
  }
#line 408
  if (i < 1) {
#line 409
    return (0);
  } else
#line 408
  if (j < 1) {
#line 409
    return (0);
  } else
#line 408
  if (i > g->n) {
#line 409
    return (0);
  } else
#line 408
  if (j > g->n) {
#line 409
    return (0);
  }
#line 410
  if (i == j) {
#line 411
    return (1);
  }
  {
#line 412
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 412
    *(*(g->edges + (i - 1)) + (j - 1) / 64) |= 1UL << (j - 1) % 64;
#line 412
    *(*(g->edges + (j - 1)) + (i - 1) / 64) |= 1UL << (i - 1) % 64;
#line 412
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 413
  return (1);
  case_120: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_100: /* CIL Label */ 
#line 417
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 419
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: ignoring field \'%c\' in input.\n",
          (int )*(str + i));
  }
#line 421
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
static graph_t *graph_read_dimacs_binary(FILE *fp , char *firstline ) 
{ 
  int length ;
  graph_t *g ;
  int i ;
  int j ;
  char *buffer ;
  char *start ;
  char *end ;
  char **buf ;
  char tmp[10] ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 437
  length = 0;
#line 446
  tmp___0 = sscanf((char const   */* __restrict  */)firstline, (char const   */* __restrict  */)" %d %2s",
                   & length, tmp);
  }
#line 446
  if (tmp___0 != 1) {
#line 447
    return ((graph_t *)((void *)0));
  }
#line 448
  if (length <= 0) {
    {
#line 449
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malformed preamble: preamble size < 0.\n");
    }
#line 450
    return ((graph_t *)((void *)0));
  }
  {
#line 452
  tmp___1 = malloc((size_t )(length + 2));
#line 452
  buffer = (char *)tmp___1;
#line 453
  tmp___2 = fread((void */* __restrict  */)buffer, (size_t )1, (size_t )length, (FILE */* __restrict  */)fp);
  }
#line 453
  if (tmp___2 < (size_t )length) {
    {
#line 454
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malformed preamble: unexpected end of file.\n");
#line 456
    free((void *)buffer);
    }
#line 457
    return ((graph_t *)((void *)0));
  }
  {
#line 460
  tmp___3 = calloc((size_t )1, sizeof(graph_t ));
#line 460
  g = (graph_t *)tmp___3;
#line 461
  start = buffer;
  }
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! ((unsigned long )start < (unsigned long )(buffer + length))) {
#line 462
      goto while_break;
    }
    {
#line 463
    end = strchr((char const   *)start, '\n');
    }
#line 464
    if ((unsigned long )end == (unsigned long )((void *)0)) {
#line 465
      end = buffer + length;
    }
    {
#line 466
    *(end + 0) = (char)0;
#line 467
    tmp___4 = parse_input(start, g);
    }
#line 467
    if (! tmp___4) {
      {
#line 468
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malformed preamble: %s\n",
              start);
#line 469
      free((void *)buffer);
      }
#line 470
      return ((graph_t *)((void *)0));
    }
#line 472
    start = end + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 475
  free((void *)buffer);
  }
#line 476
  if (g->n <= 0) {
    {
#line 477
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malformed preamble: number of vertices <= 0\n");
#line 479
    free((void *)g);
    }
#line 480
    return ((graph_t *)((void *)0));
  }
  {
#line 484
  tmp___5 = calloc((size_t )g->n, sizeof(char *));
#line 484
  buf = (char **)tmp___5;
#line 485
  i = 0;
  }
  {
#line 485
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 485
    if (! (i < g->n)) {
#line 485
      goto while_break___0;
    }
    {
#line 486
    tmp___6 = calloc((size_t )g->n, (size_t )1);
#line 486
    *(buf + i) = (char *)tmp___6;
#line 487
    tmp___7 = fread((void */* __restrict  */)*(buf + i), (size_t )1, (size_t )(i / 8 + 1),
                    (FILE */* __restrict  */)fp);
    }
#line 487
    if (tmp___7 < (size_t )(i / 8 + 1)) {
      {
#line 488
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end of file when reading graph.\n");
      }
#line 490
      return ((graph_t *)((void *)0));
    }
#line 485
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 494
  i = 0;
  {
#line 494
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 494
    if (! (i < g->n)) {
#line 494
      goto while_break___1;
    }
#line 495
    j = 0;
    {
#line 495
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 495
      if (! (j < i)) {
#line 495
        goto while_break___2;
      }
#line 496
      if ((int )*(*(buf + i) + j / 8) & (1 << (7 - j % 8))) {
        {
#line 497
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 497
          *(*(g->edges + i) + j / 64) |= 1UL << j % 64;
#line 497
          *(*(g->edges + j) + i / 64) |= 1UL << i % 64;
#line 497
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 495
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 500
    free((void *)*(buf + i));
#line 494
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 502
  free((void *)buf);
  }
#line 504
  return (g);
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
static graph_t *graph_read_dimacs_ascii(FILE *fp , char *firstline ) 
{ 
  graph_t *g ;
  char buffer[1024] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 522
  tmp = calloc((size_t )1, sizeof(graph_t ));
#line 522
  g = (graph_t *)tmp;
#line 524
  tmp___0 = parse_input(firstline, g);
  }
#line 524
  if (! tmp___0) {
    {
#line 525
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malformed input: %s",
            firstline);
#line 526
    free((void *)g);
    }
#line 527
    return ((graph_t *)((void *)0));
  }
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 529
    tmp___2 = fgets((char */* __restrict  */)(buffer), 1023, (FILE */* __restrict  */)fp);
    }
#line 529
    if (! tmp___2) {
#line 529
      goto while_break;
    }
    {
#line 530
    tmp___1 = parse_input(buffer, g);
    }
#line 530
    if (! tmp___1) {
      {
#line 531
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malformed input: %s",
              buffer);
      }
#line 532
      return ((graph_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  if (g->n <= 0) {
    {
#line 536
    free((void *)g);
#line 537
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end of file when reading graph.\n");
    }
#line 538
    return ((graph_t *)((void *)0));
  }
#line 541
  return (g);
}
}
#line 557 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
void __attribute__((__visibility__("default")))  graph_print(graph_t *g ) 
{ 
  int i ;
  int j ;
  int asymm ;
  int refl ;
  int nonpos ;
  int extra ;
  unsigned int weight ;
  int weighted ;
  int __attribute__((__visibility__("default")))  tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 559
  asymm = 0;
#line 560
  refl = 0;
#line 561
  nonpos = 0;
#line 562
  extra = 0;
#line 563
  weight = 0U;
#line 566
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 566
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 566,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 566
    abort();
    }
  }
#line 568
  if ((unsigned long )g == (unsigned long )((void *)0)) {
    {
#line 569
    printf((char const   */* __restrict  */)"   WARNING: Graph pointer is NULL!\n");
    }
#line 570
    return;
  }
#line 572
  if (g->n <= 0) {
    {
#line 573
    printf((char const   */* __restrict  */)"   WARNING: Graph has %d vertices (should be positive)!\n",
           g->n);
    }
#line 575
    return;
  }
  {
#line 578
  tmp = graph_weighted(g);
#line 578
  weighted = (int )tmp;
#line 580
  tmp___0 = graph_edge_count(g);
#line 580
  tmp___1 = graph_edge_count(g);
  }
#line 580
  if (weighted) {
#line 580
    tmp___3 = "Weighted";
  } else {
#line 580
    if (*(g->weights + 0) == 1) {
#line 580
      tmp___2 = "Unweighted";
    } else {
#line 580
      tmp___2 = "Semi-weighted";
    }
#line 580
    tmp___3 = tmp___2;
  }
  {
#line 580
  printf((char const   */* __restrict  */)"%s graph has %d vertices, %d edges (density %.2f).\n",
         tmp___3, g->n, tmp___1, (double )((float )tmp___0 / (((float )(g->n - 1) * (float )g->n) / (float )2)));
#line 586
  i = 0;
  }
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (! (i < g->n)) {
#line 586
      goto while_break;
    }
    {
#line 587
    printf((char const   */* __restrict  */)"%2d", i);
    }
#line 588
    if (weighted) {
      {
#line 589
      printf((char const   */* __restrict  */)" w=%d", *(g->weights + i));
      }
#line 590
      if (*(g->weights + i) <= 0) {
        {
#line 591
        printf((char const   */* __restrict  */)"*NON-POSITIVE*");
#line 592
        nonpos ++;
        }
      }
    }
#line 595
    if (weight < 2147483647U) {
#line 596
      weight += (unsigned int )*(g->weights + i);
    }
    {
#line 597
    printf((char const   */* __restrict  */)" ->");
#line 598
    j = 0;
    }
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! (j < g->n)) {
#line 598
        goto while_break___0;
      }
#line 599
      if (*(*(g->edges + i) + j / 64) & (1UL << j % 64)) {
        {
#line 600
        printf((char const   */* __restrict  */)" %d", j);
        }
#line 601
        if (i == j) {
          {
#line 602
          printf((char const   */* __restrict  */)"*REFLEXIVE*");
#line 603
          refl ++;
          }
        }
#line 605
        if (! (*(*(g->edges + j) + i / 64) & (1UL << i % 64))) {
          {
#line 606
          printf((char const   */* __restrict  */)"*ASYMMERTIC*");
#line 607
          asymm ++;
          }
        }
      }
#line 598
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 611
    j = g->n;
    {
#line 611
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 611
      if (! ((setelement )j < (((*(*(g->edges + i) + -1) + 64UL) - 1UL) / 64UL) * 64UL)) {
#line 611
        goto while_break___1;
      }
#line 613
      if (*(*(g->edges + i) + j / 64) & (1UL << j % 64)) {
        {
#line 614
        printf((char const   */* __restrict  */)" %d*NON-EXISTENT*", j);
#line 615
        extra ++;
        }
      }
#line 611
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 618
    printf((char const   */* __restrict  */)"\n");
#line 586
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  if (asymm) {
    {
#line 622
    printf((char const   */* __restrict  */)"   WARNING: Graph contained %d asymmetric edges!\n",
           asymm);
    }
  }
#line 624
  if (refl) {
    {
#line 625
    printf((char const   */* __restrict  */)"   WARNING: Graph contained %d reflexive edges!\n",
           refl);
    }
  }
#line 627
  if (nonpos) {
    {
#line 628
    printf((char const   */* __restrict  */)"   WARNING: Graph contained %d non-positive vertex weights!\n",
           nonpos);
    }
  }
#line 630
  if (extra) {
    {
#line 631
    printf((char const   */* __restrict  */)"   WARNING: Graph contained %d edges to non-existent vertices!\n",
           extra);
    }
  }
#line 633
  if (weight >= 2147483647U) {
    {
#line 634
    printf((char const   */* __restrict  */)"   WARNING: Total graph weight >= INT_MAX!\n");
    }
  }
#line 635
  return;
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
int __attribute__((__visibility__("default")))  graph_test(graph_t *g , FILE *output ) 
{ 
  int i ;
  int j ;
  int edges ;
  int asymm ;
  int nonpos ;
  int refl ;
  int extra ;
  unsigned int weight ;
  int weighted ;
  int __attribute__((__visibility__("default")))  tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 651
  edges = 0;
#line 652
  asymm = 0;
#line 653
  nonpos = 0;
#line 654
  refl = 0;
#line 655
  extra = 0;
#line 656
  weight = 0U;
#line 659
  if (! (sizeof(setelement ) * 8UL == 64UL)) {
    {
#line 659
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c", 659,
            "(sizeof(setelement)*8)==ELEMENTSIZE");
#line 659
    abort();
    }
  }
#line 661
  if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 662
    if (output) {
      {
#line 663
      fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"   WARNING: Graph pointer is NULL!\n");
      }
    }
#line 664
    return ((int __attribute__((__visibility__("default")))  )0);
  }
  {
#line 667
  tmp = graph_weighted(g);
#line 667
  weighted = (int )tmp;
#line 669
  i = 0;
  }
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;
#line 669
    if (! (i < g->n)) {
#line 669
      goto while_break;
    }
#line 670
    if ((unsigned long )*(g->edges + i) == (unsigned long )((void *)0)) {
#line 671
      if (output) {
        {
#line 672
        fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"   WARNING: Graph edge set NULL!\n   (further warning suppressed)\n");
        }
      }
#line 675
      return ((int __attribute__((__visibility__("default")))  )0);
    }
#line 677
    if (*(*(g->edges + i) + -1) < (setelement )g->n) {
#line 678
      if (output) {
        {
#line 679
        fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"   WARNING: Graph edge set too small!\n   (further warnings suppressed)\n");
        }
      }
#line 682
      return ((int __attribute__((__visibility__("default")))  )0);
    }
#line 684
    j = 0;
    {
#line 684
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 684
      if (! (j < g->n)) {
#line 684
        goto while_break___0;
      }
#line 685
      if (*(*(g->edges + i) + j / 64) & (1UL << j % 64)) {
#line 686
        edges ++;
#line 687
        if (i == j) {
#line 688
          refl ++;
        }
#line 690
        if (! (*(*(g->edges + j) + i / 64) & (1UL << i % 64))) {
#line 691
          asymm ++;
        }
      }
#line 684
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 695
    j = g->n;
    {
#line 695
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 695
      if (! ((setelement )j < (((*(*(g->edges + i) + -1) + 64UL) - 1UL) / 64UL) * 64UL)) {
#line 695
        goto while_break___1;
      }
#line 697
      if (*(*(g->edges + i) + j / 64) & (1UL << j % 64)) {
#line 698
        extra ++;
      }
#line 695
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 700
    if (*(g->weights + i) <= 0) {
#line 701
      nonpos ++;
    }
#line 702
    if (weight < 2147483647U) {
#line 703
      weight += (unsigned int )*(g->weights + i);
    }
#line 669
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 706
  edges /= 2;
#line 708
  if (output) {
#line 710
    if (weighted) {
#line 710
      tmp___1 = "Weighted";
    } else {
#line 710
      if (*(g->weights + 0) == 1) {
#line 710
        tmp___0 = "Unweighted";
      } else {
#line 710
        tmp___0 = "Semi-weighted";
      }
#line 710
      tmp___1 = tmp___0;
    }
    {
#line 710
    fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"%s graph has %d vertices, %d edges (density %.2f).\n",
            tmp___1, g->n, edges, (double )((float )edges / (((float )(g->n - 1) * (float )g->n) / (float )2)));
    }
#line 716
    if (asymm) {
      {
#line 717
      fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"   WARNING: Graph contained %d asymmetric edges!\n",
              asymm);
      }
    }
#line 719
    if (refl) {
      {
#line 720
      fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"   WARNING: Graph contained %d reflexive edges!\n",
              refl);
      }
    }
#line 722
    if (nonpos) {
      {
#line 723
      fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"   WARNING: Graph contained %d non-positive vertex weights!\n",
              nonpos);
      }
    }
#line 725
    if (extra) {
      {
#line 726
      fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"   WARNING: Graph contained %d edges to non-existent vertices!\n",
              extra);
      }
    }
#line 728
    if (weight >= 2147483647U) {
      {
#line 729
      fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"   WARNING: Total graph weight >= INT_MAX!\n");
      }
    }
#line 731
    if (asymm == 0) {
#line 731
      if (refl == 0) {
#line 731
        if (nonpos == 0) {
#line 731
          if (extra == 0) {
#line 731
            if (weight < 2147483647U) {
              {
#line 733
              fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"Graph OK.\n");
              }
            }
          }
        }
      }
    }
  }
#line 736
  if (asymm) {
#line 737
    return ((int __attribute__((__visibility__("default")))  )0);
  } else
#line 736
  if (refl) {
#line 737
    return ((int __attribute__((__visibility__("default")))  )0);
  } else
#line 736
  if (nonpos) {
#line 737
    return ((int __attribute__((__visibility__("default")))  )0);
  } else
#line 736
  if (extra) {
#line 737
    return ((int __attribute__((__visibility__("default")))  )0);
  } else
#line 736
  if (weight >= 2147483647U) {
#line 737
    return ((int __attribute__((__visibility__("default")))  )0);
  }
#line 739
  return ((int __attribute__((__visibility__("default")))  )1);
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
int __attribute__((__visibility__("default")))  graph_test_regular(graph_t *g ) 
{ 
  int i ;
  int n ;
  int tmp ;

  {
  {
#line 752
  n = set_size___1(*(g->edges + 0));
#line 754
  i = 1;
  }
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;
#line 754
    if (! (i < g->n)) {
#line 754
      goto while_break;
    }
    {
#line 755
    tmp = set_size___1(*(g->edges + i));
    }
#line 755
    if (tmp != n) {
#line 756
      return ((int __attribute__((__visibility__("default")))  )-1);
    }
#line 754
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 758
  return ((int __attribute__((__visibility__("default")))  )n);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static int set_bit_count___2[256]  = 
#line 51 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
  {      0,      1,      1,      2, 
        1,      2,      2,      3, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        5,      6,      6,      7, 
        6,      7,      7,      8};
#line 144
static set_t set_new___3(int size )  __attribute__((__unused__)) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static set_t set_new___3(int size ) 
{ 
  int n ;
  set_t s ;
  void *tmp ;

  {
#line 149
  if (! (size > 0)) {
    {
#line 149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h", 149, "size>0");
#line 149
    abort();
    }
  }
  {
#line 151
  n = (size / 64 + 1) + 1;
#line 152
  tmp = calloc((size_t )n, sizeof(setelement ));
#line 152
  s = (set_t )tmp;
#line 153
  *(s + 0) = (setelement )size;
  }
#line 155
  return (s + 1);
}
}
#line 202
__inline static int set_size___2(set_t s )  __attribute__((__unused__)) ;
#line 202 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static int set_size___2(set_t s ) 
{ 
  int count ;
  setelement *c ;

  {
#line 204
  count = 0;
#line 207
  c = s;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )c < (unsigned long )(s + ((*(s + -1) + 64UL) - 1UL) / 64UL))) {
#line 207
      goto while_break;
    }
#line 208
    count += ((((((set_bit_count___2[*c >> 56] + set_bit_count___2[(*c >> 48) & 255UL]) + set_bit_count___2[(*c >> 40) & 255UL]) + set_bit_count___2[(*c >> 32) & 255UL]) + set_bit_count___2[(*c >> 24) & 255UL]) + set_bit_count___2[(*c >> 16) & 255UL]) + set_bit_count___2[(*c >> 8) & 255UL]) + set_bit_count___2[*c & 255UL];
#line 207
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return (count);
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
static graph_t *graph_read_dimacs_binary___0(FILE *fp , char *firstline ) ;
#line 17
static graph_t *graph_read_dimacs_ascii___0(FILE *fp , char *firstline ) ;
#line 362 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
static int parse_input___0(char *str , graph_t *g ) 
{ 
  int i ;
  int j ;
  int w ;
  char tmp[16] ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 366
  i = 0;
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 366
    tmp___1 = strlen((char const   *)str);
    }
#line 366
    if (! ((size_t )i < tmp___1)) {
#line 366
      goto while_break;
    }
    {
#line 367
    tmp___0 = __ctype_b_loc();
    }
#line 367
    if (! ((int const   )*(*tmp___0 + (int )*(str + i)) & 8192)) {
#line 368
      goto while_break;
    }
#line 366
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 370
  tmp___2 = strlen((char const   *)str);
  }
#line 370
  if ((size_t )i >= tmp___2) {
#line 371
    return (1);
  }
#line 372
  if ((int )*(str + (i + 1)) != 0) {
    {
#line 372
    tmp___3 = __ctype_b_loc();
    }
#line 372
    if (! ((int const   )*(*tmp___3 + (int )*(str + (i + 1))) & 8192)) {
#line 373
      return (0);
    }
  }
  {
#line 376
  if ((int )*(str + i) == 99) {
#line 376
    goto case_99;
  }
#line 378
  if ((int )*(str + i) == 112) {
#line 378
    goto case_112;
  }
#line 392
  if ((int )*(str + i) == 110) {
#line 392
    goto case_110;
  }
#line 403
  if ((int )*(str + i) == 101) {
#line 403
    goto case_101;
  }
#line 416
  if ((int )*(str + i) == 120) {
#line 416
    goto case_120;
  }
#line 416
  if ((int )*(str + i) == 118) {
#line 416
    goto case_120;
  }
#line 416
  if ((int )*(str + i) == 100) {
#line 416
    goto case_120;
  }
#line 418
  goto switch_default;
  case_99: /* CIL Label */ 
#line 377
  return (1);
  case_112: /* CIL Label */ 
#line 379
  if (g->n != 0) {
#line 380
    return (0);
  }
  {
#line 381
  tmp___4 = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)" p %15s %d %d %2s",
                   tmp, & g->n, & i, tmp);
  }
#line 381
  if (tmp___4 != 3) {
#line 382
    return (0);
  }
#line 383
  if (g->n <= 0) {
#line 384
    return (0);
  }
  {
#line 385
  tmp___5 = calloc((size_t )g->n, sizeof(set_t ));
#line 385
  g->edges = (set_t *)tmp___5;
#line 386
  i = 0;
  }
  {
#line 386
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 386
    if (! (i < g->n)) {
#line 386
      goto while_break___0;
    }
    {
#line 387
    *(g->edges + i) = set_new___3(g->n);
#line 386
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 388
  tmp___6 = calloc((size_t )g->n, sizeof(int ));
#line 388
  g->weights = (int *)tmp___6;
#line 389
  i = 0;
  }
  {
#line 389
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 389
    if (! (i < g->n)) {
#line 389
      goto while_break___1;
    }
#line 390
    *(g->weights + i) = 1;
#line 389
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 391
  return (1);
  case_110: /* CIL Label */ 
#line 393
  if (g->n <= 0) {
#line 394
    return (0);
  } else
#line 393
  if ((unsigned long )g->weights == (unsigned long )((void *)0)) {
#line 394
    return (0);
  }
  {
#line 395
  tmp___7 = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)" n %d %d %2s",
                   & i, & w, tmp);
  }
#line 395
  if (tmp___7 != 2) {
#line 396
    return (0);
  }
#line 397
  if (i < 1) {
#line 398
    return (0);
  } else
#line 397
  if (i > g->n) {
#line 398
    return (0);
  }
#line 399
  if (w <= 0) {
#line 400
    return (0);
  }
#line 401
  *(g->weights + (i - 1)) = w;
#line 402
  return (1);
  case_101: /* CIL Label */ 
#line 404
  if (g->n <= 0) {
#line 405
    return (0);
  } else
#line 404
  if ((unsigned long )g->edges == (unsigned long )((void *)0)) {
#line 405
    return (0);
  }
  {
#line 406
  tmp___8 = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)" e %d %d %2s",
                   & i, & j, tmp);
  }
#line 406
  if (tmp___8 != 2) {
#line 407
    return (0);
  }
#line 408
  if (i < 1) {
#line 409
    return (0);
  } else
#line 408
  if (j < 1) {
#line 409
    return (0);
  } else
#line 408
  if (i > g->n) {
#line 409
    return (0);
  } else
#line 408
  if (j > g->n) {
#line 409
    return (0);
  }
#line 410
  if (i == j) {
#line 411
    return (1);
  }
  {
#line 412
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 412
    *(*(g->edges + (i - 1)) + (j - 1) / 64) |= 1UL << (j - 1) % 64;
#line 412
    *(*(g->edges + (j - 1)) + (i - 1) / 64) |= 1UL << (i - 1) % 64;
#line 412
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 413
  return (1);
  case_120: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_100: /* CIL Label */ 
#line 417
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 419
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: ignoring field \'%c\' in input.\n",
          (int )*(str + i));
  }
#line 421
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
static graph_t *graph_read_dimacs_binary___0(FILE *fp , char *firstline ) 
{ 
  int length ;
  graph_t *g ;
  int i ;
  int j ;
  char *buffer ;
  char *start ;
  char *end ;
  char **buf ;
  char tmp[10] ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 437
  length = 0;
#line 446
  tmp___0 = sscanf((char const   */* __restrict  */)firstline, (char const   */* __restrict  */)" %d %2s",
                   & length, tmp);
  }
#line 446
  if (tmp___0 != 1) {
#line 447
    return ((graph_t *)((void *)0));
  }
#line 448
  if (length <= 0) {
    {
#line 449
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malformed preamble: preamble size < 0.\n");
    }
#line 450
    return ((graph_t *)((void *)0));
  }
  {
#line 452
  tmp___1 = malloc((size_t )(length + 2));
#line 452
  buffer = (char *)tmp___1;
#line 453
  tmp___2 = fread((void */* __restrict  */)buffer, (size_t )1, (size_t )length, (FILE */* __restrict  */)fp);
  }
#line 453
  if (tmp___2 < (size_t )length) {
    {
#line 454
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malformed preamble: unexpected end of file.\n");
#line 456
    free((void *)buffer);
    }
#line 457
    return ((graph_t *)((void *)0));
  }
  {
#line 460
  tmp___3 = calloc((size_t )1, sizeof(graph_t ));
#line 460
  g = (graph_t *)tmp___3;
#line 461
  start = buffer;
  }
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! ((unsigned long )start < (unsigned long )(buffer + length))) {
#line 462
      goto while_break;
    }
    {
#line 463
    end = strchr((char const   *)start, '\n');
    }
#line 464
    if ((unsigned long )end == (unsigned long )((void *)0)) {
#line 465
      end = buffer + length;
    }
    {
#line 466
    *(end + 0) = (char)0;
#line 467
    tmp___4 = parse_input___0(start, g);
    }
#line 467
    if (! tmp___4) {
      {
#line 468
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malformed preamble: %s\n",
              start);
#line 469
      free((void *)buffer);
      }
#line 470
      return ((graph_t *)((void *)0));
    }
#line 472
    start = end + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 475
  free((void *)buffer);
  }
#line 476
  if (g->n <= 0) {
    {
#line 477
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malformed preamble: number of vertices <= 0\n");
#line 479
    free((void *)g);
    }
#line 480
    return ((graph_t *)((void *)0));
  }
  {
#line 484
  tmp___5 = calloc((size_t )g->n, sizeof(char *));
#line 484
  buf = (char **)tmp___5;
#line 485
  i = 0;
  }
  {
#line 485
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 485
    if (! (i < g->n)) {
#line 485
      goto while_break___0;
    }
    {
#line 486
    tmp___6 = calloc((size_t )g->n, (size_t )1);
#line 486
    *(buf + i) = (char *)tmp___6;
#line 487
    tmp___7 = fread((void */* __restrict  */)*(buf + i), (size_t )1, (size_t )(i / 8 + 1),
                    (FILE */* __restrict  */)fp);
    }
#line 487
    if (tmp___7 < (size_t )(i / 8 + 1)) {
      {
#line 488
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end of file when reading graph.\n");
      }
#line 490
      return ((graph_t *)((void *)0));
    }
#line 485
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 494
  i = 0;
  {
#line 494
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 494
    if (! (i < g->n)) {
#line 494
      goto while_break___1;
    }
#line 495
    j = 0;
    {
#line 495
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 495
      if (! (j < i)) {
#line 495
        goto while_break___2;
      }
#line 496
      if ((int )*(*(buf + i) + j / 8) & (1 << (7 - j % 8))) {
        {
#line 497
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 497
          *(*(g->edges + i) + j / 64) |= 1UL << j % 64;
#line 497
          *(*(g->edges + j) + i / 64) |= 1UL << i % 64;
#line 497
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 495
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 500
    free((void *)*(buf + i));
#line 494
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 502
  free((void *)buf);
  }
#line 504
  return (g);
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/graph.c"
static graph_t *graph_read_dimacs_ascii___0(FILE *fp , char *firstline ) 
{ 
  graph_t *g ;
  char buffer[1024] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 522
  tmp = calloc((size_t )1, sizeof(graph_t ));
#line 522
  g = (graph_t *)tmp;
#line 524
  tmp___0 = parse_input___0(firstline, g);
  }
#line 524
  if (! tmp___0) {
    {
#line 525
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malformed input: %s",
            firstline);
#line 526
    free((void *)g);
    }
#line 527
    return ((graph_t *)((void *)0));
  }
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 529
    tmp___2 = fgets((char */* __restrict  */)(buffer), 1023, (FILE */* __restrict  */)fp);
    }
#line 529
    if (! tmp___2) {
#line 529
      goto while_break;
    }
    {
#line 530
    tmp___1 = parse_input___0(buffer, g);
    }
#line 530
    if (! tmp___1) {
      {
#line 531
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malformed input: %s",
              buffer);
      }
#line 532
      return ((graph_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  if (g->n <= 0) {
    {
#line 536
    free((void *)g);
#line 537
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end of file when reading graph.\n");
    }
#line 538
    return ((graph_t *)((void *)0));
  }
#line 541
  return (g);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static set_t set_new___4(int size )  __attribute__((__unused__)) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static set_t set_new___4(int size ) 
{ 
  int n ;
  set_t s ;
  void *tmp ;

  {
#line 149
  if (! (size > 0)) {
    {
#line 149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h", 149, "size>0");
#line 149
    abort();
    }
  }
  {
#line 151
  n = (size / 64 + 1) + 1;
#line 152
  tmp = calloc((size_t )n, sizeof(setelement ));
#line 152
  s = (set_t )tmp;
#line 153
  *(s + 0) = (setelement )size;
  }
#line 155
  return (s + 1);
}
}
#line 217
__inline static set_t set_duplicate___2(set_t s )  __attribute__((__unused__)) ;
#line 217 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static set_t set_duplicate___2(set_t s ) 
{ 
  set_t new ;

  {
  {
#line 221
  new = set_new___4((int )*(s + -1));
#line 222
  memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)s, (((*(s + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
  }
#line 223
  return (new);
}
}
#line 233
__inline static set_t set_copy___1(set_t dest , set_t src )  __attribute__((__unused__)) ;
#line 233 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static set_t set_copy___1(set_t dest , set_t src ) 
{ 
  set_t tmp ;
  set_t tmp___0 ;

  {
#line 235
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
    {
#line 236
    tmp = set_duplicate___2(src);
    }
#line 236
    return (tmp);
  }
#line 237
  if (*(dest + -1) < *(src + -1)) {
    {
#line 238
    set_free(dest);
#line 239
    tmp___0 = set_duplicate___2(src);
    }
#line 239
    return (tmp___0);
  }
  {
#line 241
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, (((*(src + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
#line 242
  memset((void *)(dest + ((*(src + -1) + 64UL) - 1UL) / 64UL), 0, (((*(dest + -1) + 64UL) - 1UL) / 64UL - ((*(src + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
  }
#line 245
  return (dest);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static int set_bit_count___3[256]  = 
#line 51
  {      0,      1,      1,      2, 
        1,      2,      2,      3, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        5,      6,      6,      7, 
        6,      7,      7,      8};
#line 144
static set_t set_new___5(int size )  __attribute__((__unused__)) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
static set_t set_new___5(int size ) 
{ 
  int n ;
  set_t s ;
  void *tmp ;

  {
#line 149
  if (! (size > 0)) {
    {
#line 149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cliquer file %s: line %d: assertion failed: (%s)\n",
            "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h", 149, "size>0");
#line 149
    abort();
    }
  }
  {
#line 151
  n = (size / 64 + 1) + 1;
#line 152
  tmp = calloc((size_t )n, sizeof(setelement ));
#line 152
  s = (set_t )tmp;
#line 153
  *(s + 0) = (setelement )size;
  }
#line 155
  return (s + 1);
}
}
#line 202
__inline static int set_size___3(set_t s )  __attribute__((__unused__)) ;
#line 202 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static int set_size___3(set_t s ) 
{ 
  int count ;
  setelement *c ;

  {
#line 204
  count = 0;
#line 207
  c = s;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )c < (unsigned long )(s + ((*(s + -1) + 64UL) - 1UL) / 64UL))) {
#line 207
      goto while_break;
    }
#line 208
    count += ((((((set_bit_count___3[*c >> 56] + set_bit_count___3[(*c >> 48) & 255UL]) + set_bit_count___3[(*c >> 40) & 255UL]) + set_bit_count___3[(*c >> 32) & 255UL]) + set_bit_count___3[(*c >> 24) & 255UL]) + set_bit_count___3[(*c >> 16) & 255UL]) + set_bit_count___3[(*c >> 8) & 255UL]) + set_bit_count___3[*c & 255UL];
#line 207
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return (count);
}
}
#line 217
__inline static set_t set_duplicate___3(set_t s )  __attribute__((__unused__)) ;
#line 217 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static set_t set_duplicate___3(set_t s ) 
{ 
  set_t new ;

  {
  {
#line 221
  new = set_new___5((int )*(s + -1));
#line 222
  memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)s, (((*(s + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
  }
#line 223
  return (new);
}
}
#line 233
__inline static set_t set_copy___2(set_t dest , set_t src )  __attribute__((__unused__)) ;
#line 233 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/set.h"
__inline static set_t set_copy___2(set_t dest , set_t src ) 
{ 
  set_t tmp ;
  set_t tmp___0 ;

  {
#line 235
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
    {
#line 236
    tmp = set_duplicate___3(src);
    }
#line 236
    return (tmp);
  }
#line 237
  if (*(dest + -1) < *(src + -1)) {
    {
#line 238
    set_free(dest);
#line 239
    tmp___0 = set_duplicate___3(src);
    }
#line 239
    return (tmp___0);
  }
  {
#line 241
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, (((*(src + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
#line 242
  memset((void *)(dest + ((*(src + -1) + 64UL) - 1UL) / 64UL), 0, (((*(dest + -1) + 64UL) - 1UL) / 64UL - ((*(src + -1) + 64UL) - 1UL) / 64UL) * sizeof(setelement ));
  }
#line 245
  return (dest);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static clique_options clique_default_options_struct___0  = 
#line 20 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
     {(int *(*)(graph_t * , int  ))(& reorder_by_greedy_coloring), (int *)((void *)0),
    (int (*)(int  , int  , int  , int  , double  , double  , clique_options * ))(& clique_print_time),
    (FILE *)((void *)0), (int (*)(set_t  , graph_t * , clique_options * ))((void *)0),
    (void *)0, (set_t *)((void *)0), 0};
#line 33 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int *clique_size___0  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static set_t current_clique___0  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static set_t best_clique___0  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static struct tms cputimer___0  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static struct timeval realtimer___0  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int clique_list_count___0  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int weight_multiplier___0  =    1;
#line 43 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int **temp_list___0  =    (int **)((void *)0);
#line 44 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int temp_count___0  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int entrance_level___0  =    0;
#line 81 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int clocks_per_sec___0  =    0;
#line 87
static int sub_unweighted_single___0(int *table , int size , int min_size , graph_t *g ) ;
#line 89
static int sub_unweighted_all___0(int *table , int size , int min_size , int max_size ,
                                  int maximal___0 , graph_t *g , clique_options *opts ) ;
#line 92
static int sub_weighted_all___0(int *table , int size , int weight , int current_weight ,
                                int prune_low , int prune_high , int min_weight___0 ,
                                int max_weight___0 , int maximal___0 , graph_t *g ,
                                clique_options *opts ) ;
#line 98
static int store_clique___0(set_t clique , graph_t *g , clique_options *opts ) ;
#line 99
static int is_maximal___0(set_t clique , graph_t *g ) ;
#line 100
static int false_function___0(set_t clique , graph_t *g , clique_options *opts ) ;
#line 139 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int unweighted_clique_search_single___0(int *table , int min_size , graph_t *g ,
                                               clique_options *opts ) 
{ 
  struct tms tms ;
  struct timeval timeval ;
  int i ;
  int j ;
  int v ;
  int w ;
  int *newtable ;
  int newsize ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 148
  v = *(table + 0);
#line 149
  *(clique_size___0 + v) = 1;
#line 150
  set_empty(current_clique___0);
#line 151
  *(current_clique___0 + v / 64) |= 1UL << v % 64;
  }
#line 152
  if (min_size == 1) {
#line 153
    return (1);
  }
#line 155
  if (temp_count___0) {
#line 156
    temp_count___0 --;
#line 157
    newtable = *(temp_list___0 + temp_count___0);
  } else {
    {
#line 159
    tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 159
    newtable = (int *)tmp;
    }
  }
#line 161
  i = 1;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < g->n)) {
#line 161
      goto while_break;
    }
#line 162
    w = v;
#line 163
    v = *(table + i);
#line 165
    newsize = 0;
#line 166
    j = 0;
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 166
      if (! (j < i)) {
#line 166
        goto while_break___0;
      }
#line 167
      if (v < g->n) {
#line 167
        if ((setelement )*(table + j) < *(*(g->edges + v) + -1)) {
#line 167
          tmp___0 = *(*(g->edges + v) + *(table + j) / 64) & (1UL << *(table + j) % 64);
        } else {
#line 167
          tmp___0 = 0UL;
        }
#line 167
        tmp___1 = tmp___0;
      } else {
#line 167
        tmp___1 = 0UL;
      }
#line 167
      if (tmp___1) {
#line 168
        *(newtable + newsize) = *(table + j);
#line 169
        newsize ++;
      }
#line 166
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 173
    tmp___2 = sub_unweighted_single___0(newtable, newsize, *(clique_size___0 + w),
                                        g);
    }
#line 173
    if (tmp___2) {
#line 174
      *(current_clique___0 + v / 64) |= 1UL << v % 64;
#line 175
      *(clique_size___0 + v) = *(clique_size___0 + w) + 1;
    } else {
#line 177
      *(clique_size___0 + v) = *(clique_size___0 + w);
    }
#line 180
    if (opts) {
#line 180
      if (opts->time_function) {
        {
#line 181
        gettimeofday((struct timeval */* __restrict  */)(& timeval), (__timezone_ptr_t )((void *)0));
#line 182
        times(& tms);
#line 183
        tmp___4 = (*(opts->time_function))(entrance_level___0, i + 1, g->n, *(clique_size___0 + v) * weight_multiplier___0,
                                           (double )(tms.tms_utime - cputimer___0.tms_utime) / (double )clocks_per_sec___0,
                                           (double )(timeval.tv_sec - realtimer___0.tv_sec) + (double )(timeval.tv_usec - realtimer___0.tv_usec) / (double )1000000,
                                           opts);
        }
#line 183
        if (! tmp___4) {
#line 194
          tmp___3 = temp_count___0;
#line 194
          temp_count___0 ++;
#line 194
          *(temp_list___0 + tmp___3) = newtable;
#line 195
          return (0);
        }
      }
    }
#line 199
    if (min_size) {
#line 200
      if (*(clique_size___0 + v) >= min_size) {
#line 201
        tmp___5 = temp_count___0;
#line 201
        temp_count___0 ++;
#line 201
        *(temp_list___0 + tmp___5) = newtable;
#line 202
        return (*(clique_size___0 + v));
      }
#line 204
      if (((*(clique_size___0 + v) + g->n) - i) - 1 < min_size) {
#line 205
        tmp___6 = temp_count___0;
#line 205
        temp_count___0 ++;
#line 205
        *(temp_list___0 + tmp___6) = newtable;
#line 206
        return (0);
      }
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  tmp___7 = temp_count___0;
#line 211
  temp_count___0 ++;
#line 211
  *(temp_list___0 + tmp___7) = newtable;
#line 213
  if (min_size) {
#line 214
    return (0);
  }
#line 215
  return (*(clique_size___0 + v));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int sub_unweighted_single___0(int *table , int size , int min_size , graph_t *g ) 
{ 
  int i ;
  int v ;
  int *newtable ;
  int *p1 ;
  int *p2 ;
  void *tmp ;
  int w ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 243
  if (min_size <= 1) {
#line 244
    if (size > 0) {
#line 244
      if (min_size == 1) {
        {
#line 245
        set_empty(current_clique___0);
#line 246
        *(current_clique___0 + *(table + 0) / 64) |= 1UL << *(table + 0) % 64;
        }
#line 247
        return (1);
      }
    }
#line 249
    if (min_size == 0) {
      {
#line 250
      set_empty(current_clique___0);
      }
#line 251
      return (1);
    }
#line 253
    return (0);
  }
#line 255
  if (size < min_size) {
#line 256
    return (0);
  }
#line 259
  if (temp_count___0) {
#line 260
    temp_count___0 --;
#line 261
    newtable = *(temp_list___0 + temp_count___0);
  } else {
    {
#line 263
    tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 263
    newtable = (int *)tmp;
    }
  }
#line 266
  i = size - 1;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if (! (i >= 0)) {
#line 266
      goto while_break;
    }
#line 267
    v = *(table + i);
#line 269
    if (*(clique_size___0 + v) < min_size) {
#line 270
      goto while_break;
    }
#line 273
    if (i + 1 < min_size) {
#line 274
      goto while_break;
    }
#line 277
    p1 = newtable;
#line 278
    p2 = table;
    {
#line 278
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 278
      if (! ((unsigned long )p2 < (unsigned long )(table + i))) {
#line 278
        goto while_break___0;
      }
#line 279
      w = *p2;
#line 280
      if (v < g->n) {
#line 280
        if ((setelement )w < *(*(g->edges + v) + -1)) {
#line 280
          tmp___0 = *(*(g->edges + v) + w / 64) & (1UL << w % 64);
        } else {
#line 280
          tmp___0 = 0UL;
        }
#line 280
        tmp___1 = tmp___0;
      } else {
#line 280
        tmp___1 = 0UL;
      }
#line 280
      if (tmp___1) {
#line 281
        *p1 = w;
#line 282
        p1 ++;
      }
#line 278
      p2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 287
    if (p1 - newtable < (long )(min_size - 1)) {
#line 288
      goto __Cont;
    }
#line 291
    if (*(clique_size___0 + *(newtable + ((p1 - newtable) - 1L))) < min_size - 1) {
#line 292
      goto __Cont;
    }
    {
#line 294
    tmp___3 = sub_unweighted_single___0(newtable, (int )(p1 - newtable), min_size - 1,
                                        g);
    }
#line 294
    if (tmp___3) {
#line 297
      *(current_clique___0 + v / 64) |= 1UL << v % 64;
#line 298
      tmp___2 = temp_count___0;
#line 298
      temp_count___0 ++;
#line 298
      *(temp_list___0 + tmp___2) = newtable;
#line 299
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 266
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  tmp___4 = temp_count___0;
#line 302
  temp_count___0 ++;
#line 302
  *(temp_list___0 + tmp___4) = newtable;
#line 303
  return (0);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int unweighted_clique_search_all___0(int *table , int start , int min_size ,
                                            int max_size , int maximal___0 , graph_t *g ,
                                            clique_options *opts ) 
{ 
  struct timeval timeval ;
  struct tms tms ;
  int i ;
  int j ;
  int v ;
  int *newtable ;
  int newsize ;
  int count ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 343
  count = 0;
#line 345
  if (temp_count___0) {
#line 346
    temp_count___0 --;
#line 347
    newtable = *(temp_list___0 + temp_count___0);
  } else {
    {
#line 349
    tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 349
    newtable = (int *)tmp;
    }
  }
  {
#line 352
  clique_list_count___0 = 0;
#line 353
  set_empty(current_clique___0);
#line 354
  i = start;
  }
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! (i < g->n)) {
#line 354
      goto while_break;
    }
#line 355
    v = *(table + i);
#line 356
    *(clique_size___0 + v) = min_size;
#line 358
    newsize = 0;
#line 359
    j = 0;
    {
#line 359
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 359
      if (! (j < i)) {
#line 359
        goto while_break___0;
      }
#line 360
      if (v < g->n) {
#line 360
        if ((setelement )*(table + j) < *(*(g->edges + v) + -1)) {
#line 360
          tmp___0 = *(*(g->edges + v) + *(table + j) / 64) & (1UL << *(table + j) % 64);
        } else {
#line 360
          tmp___0 = 0UL;
        }
#line 360
        tmp___1 = tmp___0;
      } else {
#line 360
        tmp___1 = 0UL;
      }
#line 360
      if (tmp___1) {
#line 361
        *(newtable + newsize) = *(table + j);
#line 362
        newsize ++;
      }
#line 359
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 366
    *(current_clique___0 + v / 64) |= 1UL << v % 64;
#line 367
    j = sub_unweighted_all___0(newtable, newsize, min_size - 1, max_size - 1, maximal___0,
                               g, opts);
#line 369
    *(current_clique___0 + v / 64) &= ~ (1UL << v % 64);
    }
#line 370
    if (j < 0) {
#line 372
      count -= j;
#line 373
      goto while_break;
    }
#line 375
    count += j;
#line 377
    if (opts->time_function) {
      {
#line 378
      gettimeofday((struct timeval */* __restrict  */)(& timeval), (__timezone_ptr_t )((void *)0));
#line 379
      times(& tms);
#line 380
      tmp___2 = (*(opts->time_function))(entrance_level___0, i + 1, g->n, min_size * weight_multiplier___0,
                                         (double )(tms.tms_utime - cputimer___0.tms_utime) / (double )clocks_per_sec___0,
                                         (double )(timeval.tv_sec - realtimer___0.tv_sec) + (double )(timeval.tv_usec - realtimer___0.tv_usec) / (double )1000000,
                                         opts);
      }
#line 380
      if (! tmp___2) {
#line 392
        goto while_break;
      }
    }
#line 354
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  tmp___3 = temp_count___0;
#line 396
  temp_count___0 ++;
#line 396
  *(temp_list___0 + tmp___3) = newtable;
#line 397
  return (count);
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int sub_unweighted_all___0(int *table , int size , int min_size , int max_size ,
                                  int maximal___0 , graph_t *g , clique_options *opts ) 
{ 
  int i ;
  int v ;
  int n ;
  int *newtable ;
  int *p1 ;
  int *p2 ;
  int count ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int w ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;

  {
#line 433
  count = 0;
#line 435
  if (min_size <= 0) {
#line 436
    if (! maximal___0) {
#line 436
      goto _L;
    } else {
      {
#line 436
      tmp___0 = is_maximal___0(current_clique___0, g);
      }
#line 436
      if (tmp___0) {
        _L: /* CIL Label */ 
        {
#line 438
        count ++;
#line 439
        tmp = store_clique___0(current_clique___0, g, opts);
        }
#line 439
        if (! tmp) {
#line 440
          return (- count);
        }
      }
    }
#line 443
    if (max_size <= 0) {
#line 445
      return (count);
    }
  }
#line 449
  if (size < min_size) {
#line 450
    return (count);
  }
#line 454
  if (temp_count___0) {
#line 455
    temp_count___0 --;
#line 456
    newtable = *(temp_list___0 + temp_count___0);
  } else {
    {
#line 458
    tmp___1 = malloc((unsigned long )g->n * sizeof(int ));
#line 458
    newtable = (int *)tmp___1;
    }
  }
#line 461
  i = size - 1;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (i >= 0)) {
#line 461
      goto while_break;
    }
#line 462
    v = *(table + i);
#line 463
    if (*(clique_size___0 + v) < min_size) {
#line 464
      goto while_break;
    }
#line 466
    if (i + 1 < min_size) {
#line 467
      goto while_break;
    }
#line 471
    p1 = newtable;
#line 472
    p2 = table;
    {
#line 472
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 472
      if (! ((unsigned long )p2 < (unsigned long )(table + i))) {
#line 472
        goto while_break___0;
      }
#line 473
      w = *p2;
#line 474
      if (v < g->n) {
#line 474
        if ((setelement )w < *(*(g->edges + v) + -1)) {
#line 474
          tmp___2 = *(*(g->edges + v) + w / 64) & (1UL << w % 64);
        } else {
#line 474
          tmp___2 = 0UL;
        }
#line 474
        tmp___3 = tmp___2;
      } else {
#line 474
        tmp___3 = 0UL;
      }
#line 474
      if (tmp___3) {
#line 475
        *p1 = w;
#line 476
        p1 ++;
      }
#line 472
      p2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 481
    if (p1 - newtable < (long )(min_size - 1)) {
#line 482
      goto __Cont;
    }
    {
#line 485
    *(current_clique___0 + v / 64) |= 1UL << v % 64;
#line 486
    n = sub_unweighted_all___0(newtable, (int )(p1 - newtable), min_size - 1, max_size - 1,
                               maximal___0, g, opts);
#line 488
    *(current_clique___0 + v / 64) &= ~ (1UL << v % 64);
    }
#line 489
    if (n < 0) {
#line 491
      count -= n;
#line 492
      count = - count;
#line 493
      goto while_break;
    }
#line 495
    count += n;
    __Cont: /* CIL Label */ 
#line 461
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 497
  tmp___4 = temp_count___0;
#line 497
  temp_count___0 ++;
#line 497
  *(temp_list___0 + tmp___4) = newtable;
#line 498
  return (count);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int weighted_clique_search_single___0(int *table , int min_weight___0 , int max_weight___0 ,
                                             graph_t *g , clique_options *opts ) 
{ 
  struct timeval timeval ;
  struct tms tms ;
  int i ;
  int j ;
  int v ;
  int *newtable ;
  int newsize ;
  int newweight ;
  int search_weight ;
  int min_w ;
  clique_options localopts ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 552
  if (min_weight___0 == 0) {
#line 553
    min_w = 2147483647;
  } else {
#line 555
    min_w = min_weight___0;
  }
#line 558
  if (min_weight___0 == 1) {
#line 562
    i = 0;
    {
#line 562
    while (1) {
      while_continue: /* CIL Label */ ;
#line 562
      if (! (i < g->n)) {
#line 562
        goto while_break;
      }
#line 563
      if (*(g->weights + *(table + i)) <= max_weight___0) {
        {
#line 564
        set_empty(best_clique___0);
#line 565
        *(best_clique___0 + *(table + i) / 64) |= 1UL << *(table + i) % 64;
        }
#line 566
        return (*(g->weights + *(table + i)));
      }
#line 562
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 569
    return (0);
  }
  {
#line 572
  localopts.time_function = (int (*)(int  , int  , int  , int  , double  , double  ,
                                     clique_options * ))((void *)0);
#line 573
  localopts.reorder_function = (int *(*)(graph_t * , int  ))((void *)0);
#line 574
  localopts.reorder_map = (int *)((void *)0);
#line 575
  localopts.user_function = & false_function___0;
#line 576
  localopts.user_data = (void *)0;
#line 577
  localopts.clique_list = & best_clique___0;
#line 578
  localopts.clique_list_length = 1;
#line 579
  clique_list_count___0 = 0;
#line 581
  v = *(table + 0);
#line 582
  set_empty(best_clique___0);
#line 583
  *(best_clique___0 + v / 64) |= 1UL << v % 64;
#line 584
  search_weight = *(g->weights + v);
  }
#line 585
  if (min_weight___0) {
#line 585
    if (search_weight >= min_weight___0) {
#line 586
      if (search_weight <= max_weight___0) {
#line 588
        return (search_weight);
      }
#line 590
      search_weight = min_weight___0 - 1;
    }
  }
  {
#line 592
  *(clique_size___0 + v) = search_weight;
#line 593
  set_empty(current_clique___0);
  }
#line 595
  if (temp_count___0) {
#line 596
    temp_count___0 --;
#line 597
    newtable = *(temp_list___0 + temp_count___0);
  } else {
    {
#line 599
    tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 599
    newtable = (int *)tmp;
    }
  }
#line 602
  i = 1;
  {
#line 602
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 602
    if (! (i < g->n)) {
#line 602
      goto while_break___0;
    }
#line 603
    v = *(table + i);
#line 605
    newsize = 0;
#line 606
    newweight = 0;
#line 607
    j = 0;
    {
#line 607
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 607
      if (! (j < i)) {
#line 607
        goto while_break___1;
      }
#line 608
      if (v < g->n) {
#line 608
        if ((setelement )*(table + j) < *(*(g->edges + v) + -1)) {
#line 608
          tmp___0 = *(*(g->edges + v) + *(table + j) / 64) & (1UL << *(table + j) % 64);
        } else {
#line 608
          tmp___0 = 0UL;
        }
#line 608
        tmp___1 = tmp___0;
      } else {
#line 608
        tmp___1 = 0UL;
      }
#line 608
      if (tmp___1) {
#line 609
        newweight += *(g->weights + *(table + j));
#line 610
        *(newtable + newsize) = *(table + j);
#line 611
        newsize ++;
      }
#line 607
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 616
    *(current_clique___0 + v / 64) |= 1UL << v % 64;
#line 617
    search_weight = sub_weighted_all___0(newtable, newsize, newweight, *(g->weights + v),
                                         search_weight, *(clique_size___0 + *(table + (i - 1))) + *(g->weights + v),
                                         min_w, max_weight___0, 0, g, & localopts);
#line 623
    *(current_clique___0 + v / 64) &= ~ (1UL << v % 64);
    }
#line 624
    if (search_weight < 0) {
#line 625
      goto while_break___0;
    }
#line 628
    *(clique_size___0 + v) = search_weight;
#line 630
    if (opts->time_function) {
      {
#line 631
      gettimeofday((struct timeval */* __restrict  */)(& timeval), (__timezone_ptr_t )((void *)0));
#line 632
      times(& tms);
#line 633
      tmp___2 = (*(opts->time_function))(entrance_level___0, i + 1, g->n, *(clique_size___0 + v) * weight_multiplier___0,
                                         (double )(tms.tms_utime - cputimer___0.tms_utime) / (double )clocks_per_sec___0,
                                         (double )(timeval.tv_sec - realtimer___0.tv_sec) + (double )(timeval.tv_usec - realtimer___0.tv_usec) / (double )1000000,
                                         opts);
      }
#line 633
      if (! tmp___2) {
        {
#line 644
        set_free(current_clique___0);
#line 645
        current_clique___0 = (set_t )((void *)0);
        }
#line 646
        goto while_break___0;
      }
    }
#line 602
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 650
  tmp___3 = temp_count___0;
#line 650
  temp_count___0 ++;
#line 650
  *(temp_list___0 + tmp___3) = newtable;
#line 651
  if (min_weight___0) {
#line 651
    if (search_weight > 0) {
#line 653
      return (0);
    }
  }
#line 655
  return (*(clique_size___0 + *(table + (i - 1))));
}
}
#line 685 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int weighted_clique_search_all___0(int *table , int start , int min_weight___0 ,
                                          int max_weight___0 , int maximal___0 , graph_t *g ,
                                          clique_options *opts ) 
{ 
  struct timeval timeval ;
  struct tms tms ;
  int i ;
  int j ;
  int v ;
  int *newtable ;
  int newsize ;
  int newweight ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 697
  if (temp_count___0) {
#line 698
    temp_count___0 --;
#line 699
    newtable = *(temp_list___0 + temp_count___0);
  } else {
    {
#line 701
    tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 701
    newtable = (int *)tmp;
    }
  }
  {
#line 704
  clique_list_count___0 = 0;
#line 705
  set_empty(current_clique___0);
#line 706
  i = start;
  }
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! (i < g->n)) {
#line 706
      goto while_break;
    }
#line 707
    v = *(table + i);
#line 708
    *(clique_size___0 + v) = min_weight___0;
#line 710
    newsize = 0;
#line 711
    newweight = 0;
#line 712
    j = 0;
    {
#line 712
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 712
      if (! (j < i)) {
#line 712
        goto while_break___0;
      }
#line 713
      if (v < g->n) {
#line 713
        if ((setelement )*(table + j) < *(*(g->edges + v) + -1)) {
#line 713
          tmp___0 = *(*(g->edges + v) + *(table + j) / 64) & (1UL << *(table + j) % 64);
        } else {
#line 713
          tmp___0 = 0UL;
        }
#line 713
        tmp___1 = tmp___0;
      } else {
#line 713
        tmp___1 = 0UL;
      }
#line 713
      if (tmp___1) {
#line 714
        *(newtable + newsize) = *(table + j);
#line 715
        newweight += *(g->weights + *(table + j));
#line 716
        newsize ++;
      }
#line 712
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 720
    *(current_clique___0 + v / 64) |= 1UL << v % 64;
#line 721
    j = sub_weighted_all___0(newtable, newsize, newweight, *(g->weights + v), min_weight___0 - 1,
                             2147483647, min_weight___0, max_weight___0, maximal___0,
                             g, opts);
#line 724
    *(current_clique___0 + v / 64) &= ~ (1UL << v % 64);
    }
#line 726
    if (j < 0) {
#line 728
      goto while_break;
    }
#line 731
    if (opts->time_function) {
      {
#line 732
      gettimeofday((struct timeval */* __restrict  */)(& timeval), (__timezone_ptr_t )((void *)0));
#line 733
      times(& tms);
#line 734
      tmp___2 = (*(opts->time_function))(entrance_level___0, i + 1, g->n, *(clique_size___0 + v) * weight_multiplier___0,
                                         (double )(tms.tms_utime - cputimer___0.tms_utime) / (double )clocks_per_sec___0,
                                         (double )(timeval.tv_sec - realtimer___0.tv_sec) + (double )(timeval.tv_usec - realtimer___0.tv_usec) / (double )1000000,
                                         opts);
      }
#line 734
      if (! tmp___2) {
        {
#line 745
        set_free(current_clique___0);
#line 746
        current_clique___0 = (set_t )((void *)0);
        }
#line 747
        goto while_break;
      }
    }
#line 706
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 751
  tmp___3 = temp_count___0;
#line 751
  temp_count___0 ++;
#line 751
  *(temp_list___0 + tmp___3) = newtable;
#line 753
  return (clique_list_count___0);
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int sub_weighted_all___0(int *table , int size , int weight , int current_weight ,
                                int prune_low , int prune_high , int min_weight___0 ,
                                int max_weight___0 , int maximal___0 , graph_t *g ,
                                clique_options *opts ) 
{ 
  int i ;
  int v ;
  int w ;
  int *newtable ;
  int *p1 ;
  int *p2 ;
  int newweight ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;

  {
#line 806
  if (current_weight >= min_weight___0) {
#line 807
    if (current_weight <= max_weight___0) {
#line 807
      if (! maximal___0) {
#line 807
        goto _L;
      } else {
        {
#line 807
        tmp___0 = is_maximal___0(current_clique___0, g);
        }
#line 807
        if (tmp___0) {
          _L: /* CIL Label */ 
          {
#line 810
          tmp = store_clique___0(current_clique___0, g, opts);
          }
#line 810
          if (! tmp) {
#line 811
            return (-1);
          }
        }
      }
    }
#line 814
    if (current_weight >= max_weight___0) {
#line 816
      return (min_weight___0 - 1);
    }
  }
#line 819
  if (size <= 0) {
#line 822
    if (current_weight > prune_low) {
#line 823
      if (best_clique___0) {
        {
#line 824
        set_copy___2(best_clique___0, current_clique___0);
        }
      }
#line 825
      if (current_weight < min_weight___0) {
#line 826
        return (current_weight);
      } else {
#line 828
        return (min_weight___0 - 1);
      }
    } else {
#line 830
      return (prune_low);
    }
  }
#line 835
  if (temp_count___0) {
#line 836
    temp_count___0 --;
#line 837
    newtable = *(temp_list___0 + temp_count___0);
  } else {
    {
#line 839
    tmp___1 = malloc((unsigned long )g->n * sizeof(int ));
#line 839
    newtable = (int *)tmp___1;
    }
  }
#line 842
  i = size - 1;
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
#line 842
    if (! (i >= 0)) {
#line 842
      goto while_break;
    }
#line 843
    v = *(table + i);
#line 844
    if (current_weight + *(clique_size___0 + v) <= prune_low) {
#line 846
      goto while_break;
    }
#line 848
    if (current_weight + weight <= prune_low) {
#line 850
      goto while_break;
    }
#line 854
    p1 = newtable;
#line 855
    newweight = 0;
#line 856
    p2 = table;
    {
#line 856
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 856
      if (! ((unsigned long )p2 < (unsigned long )(table + i))) {
#line 856
        goto while_break___0;
      }
#line 857
      w = *p2;
#line 858
      if (v < g->n) {
#line 858
        if ((setelement )w < *(*(g->edges + v) + -1)) {
#line 858
          tmp___2 = *(*(g->edges + v) + w / 64) & (1UL << w % 64);
        } else {
#line 858
          tmp___2 = 0UL;
        }
#line 858
        tmp___3 = tmp___2;
      } else {
#line 858
        tmp___3 = 0UL;
      }
#line 858
      if (tmp___3) {
#line 859
        *p1 = w;
#line 860
        newweight += *(g->weights + w);
#line 861
        p1 ++;
      }
#line 856
      p2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 865
    w = *(g->weights + v);
#line 866
    weight -= w;
#line 868
    if ((current_weight + w) + newweight <= prune_low) {
#line 869
      goto __Cont;
    }
    {
#line 872
    *(current_clique___0 + v / 64) |= 1UL << v % 64;
#line 873
    prune_low = sub_weighted_all___0(newtable, (int )(p1 - newtable), newweight, current_weight + w,
                                     prune_low, prune_high, min_weight___0, max_weight___0,
                                     maximal___0, g, opts);
#line 879
    *(current_clique___0 + v / 64) &= ~ (1UL << v % 64);
    }
#line 880
    if (prune_low < 0) {
#line 882
      goto while_break;
    } else
#line 880
    if (prune_low >= prune_high) {
#line 882
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 842
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 885
  tmp___4 = temp_count___0;
#line 885
  temp_count___0 ++;
#line 885
  *(temp_list___0 + tmp___4) = newtable;
#line 886
  return (prune_low);
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int store_clique___0(set_t clique , graph_t *g , clique_options *opts ) 
{ 
  int tmp ;

  {
#line 908
  clique_list_count___0 ++;
#line 911
  if (opts->clique_list) {
#line 917
    if (clique_list_count___0 <= 0) {
      {
#line 918
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CLIQUER INTERNAL ERROR: clique_list_count has negative value!\n");
#line 920
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please report as a bug.\n");
#line 921
      abort();
      }
    }
#line 923
    if (clique_list_count___0 <= opts->clique_list_length) {
      {
#line 924
      *(opts->clique_list + (clique_list_count___0 - 1)) = set_duplicate___3(clique);
      }
    }
  }
#line 929
  if (opts->user_function) {
    {
#line 930
    tmp = (*(opts->user_function))(clique, g, opts);
    }
#line 930
    if (! tmp) {
#line 932
      return (0);
    }
  }
#line 936
  return (1);
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static void maximalize_clique___0(set_t s , graph_t *g ) 
{ 
  int i ;
  int j ;
  int add ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 955
  i = 0;
  {
#line 955
  while (1) {
    while_continue: /* CIL Label */ ;
#line 955
    if (! (i < g->n)) {
#line 955
      goto while_break;
    }
#line 956
    add = 1;
#line 957
    j = 0;
    {
#line 957
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 957
      if (! (j < g->n)) {
#line 957
        goto while_break___0;
      }
#line 958
      if (*(s + j / 64) & (1UL << j % 64)) {
#line 958
        if (i < g->n) {
#line 958
          if ((setelement )j < *(*(g->edges + i) + -1)) {
#line 958
            tmp = *(*(g->edges + i) + j / 64) & (1UL << j % 64);
          } else {
#line 958
            tmp = 0UL;
          }
#line 958
          tmp___0 = tmp;
        } else {
#line 958
          tmp___0 = 0UL;
        }
#line 958
        if (! tmp___0) {
#line 959
          add = 0;
#line 960
          goto while_break___0;
        }
      }
#line 957
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 963
    if (add) {
#line 964
      *(s + i / 64) |= 1UL << i % 64;
    }
#line 955
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 967
  return;
}
}
#line 981 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int is_maximal___0(set_t clique , graph_t *g ) 
{ 
  int i ;
  int j ;
  int *table ;
  int len ;
  int addable ;
  void *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 987
  if (temp_count___0) {
#line 988
    temp_count___0 --;
#line 989
    table = *(temp_list___0 + temp_count___0);
  } else {
    {
#line 991
    tmp = malloc((unsigned long )g->n * sizeof(int ));
#line 991
    table = (int *)tmp;
    }
  }
#line 994
  len = 0;
#line 995
  i = 0;
  {
#line 995
  while (1) {
    while_continue: /* CIL Label */ ;
#line 995
    if (! (i < g->n)) {
#line 995
      goto while_break;
    }
#line 996
    if (*(clique + i / 64) & (1UL << i % 64)) {
#line 997
      tmp___0 = len;
#line 997
      len ++;
#line 997
      *(table + tmp___0) = i;
    }
#line 995
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < g->n)) {
#line 999
      goto while_break___0;
    }
#line 1000
    addable = 1;
#line 1001
    j = 0;
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1001
      if (! (j < len)) {
#line 1001
        goto while_break___1;
      }
#line 1002
      if (i < g->n) {
#line 1002
        if ((setelement )*(table + j) < *(*(g->edges + i) + -1)) {
#line 1002
          tmp___1 = *(*(g->edges + i) + *(table + j) / 64) & (1UL << *(table + j) % 64);
        } else {
#line 1002
          tmp___1 = 0UL;
        }
#line 1002
        tmp___2 = tmp___1;
      } else {
#line 1002
        tmp___2 = 0UL;
      }
#line 1002
      if (! tmp___2) {
#line 1003
        addable = 0;
#line 1004
        goto while_break___1;
      }
#line 1001
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1007
    if (addable) {
#line 1008
      tmp___3 = temp_count___0;
#line 1008
      temp_count___0 ++;
#line 1008
      *(temp_list___0 + tmp___3) = table;
#line 1009
      return (0);
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1012
  tmp___4 = temp_count___0;
#line 1012
  temp_count___0 ++;
#line 1012
  *(temp_list___0 + tmp___4) = table;
#line 1013
  return (1);
}
}
#line 1022 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int false_function___0(set_t clique , graph_t *g , clique_options *opts ) 
{ 


  {
#line 1023
  return (0);
}
}
#line 1663 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static float prev_time___1  =    (float )100;
#line 1664 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int prev_i___1  =    100;
#line 1665 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int prev_max___0  =    100;
#line 1666 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int prev_level___0  =    0;
#line 1712 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static float prev_time___2  =    (float )100;
#line 1713 "/home/june/repo/benchmarks/collector/temp/cliquer-1.21/cliquer.c"
static int prev_i___2  =    100;
