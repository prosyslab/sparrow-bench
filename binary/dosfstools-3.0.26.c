/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 27 "/usr/include/linux/types.h"
typedef __u16 __le16;
#line 29 "/usr/include/linux/types.h"
typedef __u32 __le32;
#line 174 "/usr/include/linux/msdos_fs.h"
struct msdos_dir_entry {
   __u8 name[11] ;
   __u8 attr ;
   __u8 lcase ;
   __u8 ctime_cs ;
   __le16 ctime ;
   __le16 cdate ;
   __le16 adate ;
   __le16 starthi ;
   __le16 time ;
   __le16 date ;
   __le16 start ;
   __le32 size ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 51 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
struct boot_sector {
   __u8 ignored[3] ;
   __u8 system_id[8] ;
   __u8 sector_size[2] ;
   __u8 cluster_size ;
   __u16 reserved ;
   __u8 fats ;
   __u8 dir_entries[2] ;
   __u8 sectors[2] ;
   __u8 media ;
   __u16 fat_length ;
   __u16 secs_track ;
   __u16 heads ;
   __u32 hidden ;
   __u32 total_sect ;
   __u32 fat32_length ;
   __u16 flags ;
   __u8 version[2] ;
   __u32 root_cluster ;
   __u16 info_sector ;
   __u16 backup_boot ;
   __u8 reserved2[12] ;
   __u8 drive_number ;
   __u8 reserved3 ;
   __u8 extended_sig ;
   __u32 serial ;
   __u8 label[11] ;
   __u8 fs_type[8] ;
   __u8 junk[422] ;
} __attribute__((__packed__)) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
struct boot_sector_16 {
   __u8 ignored[3] ;
   __u8 system_id[8] ;
   __u8 sector_size[2] ;
   __u8 cluster_size ;
   __u16 reserved ;
   __u8 fats ;
   __u8 dir_entries[2] ;
   __u8 sectors[2] ;
   __u8 media ;
   __u16 fat_length ;
   __u16 secs_track ;
   __u16 heads ;
   __u32 hidden ;
   __u32 total_sect ;
   __u8 drive_number ;
   __u8 reserved2 ;
   __u8 extended_sig ;
   __u32 serial ;
   __u8 label[11] ;
   __u8 fs_type[8] ;
   __u8 junk[450] ;
} __attribute__((__packed__)) ;
#line 118 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
struct info_sector {
   __u32 magic ;
   __u8 junk[476] ;
   __u32 reserved1 ;
   __u32 signature ;
   __u32 free_clusters ;
   __u32 next_cluster ;
   __u32 reserved2[3] ;
   __u16 reserved3 ;
   __u16 boot_sign ;
};
#line 130 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
struct __anonstruct_DIR_ENT_31 {
   __u8 name[8] ;
   __u8 ext[3] ;
   __u8 attr ;
   __u8 lcase ;
   __u8 ctime_ms ;
   __u16 ctime ;
   __u16 cdate ;
   __u16 adate ;
   __u16 starthi ;
   __u16 time ;
   __u16 date ;
   __u16 start ;
   __u32 size ;
} __attribute__((__packed__)) ;
#line 130 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
typedef struct __anonstruct_DIR_ENT_31 DIR_ENT;
#line 143 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
struct _dos_file {
   DIR_ENT dir_ent ;
   char *lfn ;
   loff_t offset ;
   loff_t lfn_offset ;
   struct _dos_file *parent ;
   struct _dos_file *next ;
   struct _dos_file *first ;
};
#line 143 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
typedef struct _dos_file DOS_FILE;
#line 158 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
struct __anonstruct_DOS_FS_33 {
   int nfats ;
   loff_t fat_start ;
   unsigned int fat_size ;
   unsigned int fat_bits ;
   unsigned int eff_fat_bits ;
   uint32_t root_cluster ;
   loff_t root_start ;
   unsigned int root_entries ;
   loff_t data_start ;
   unsigned int cluster_size ;
   uint32_t clusters ;
   loff_t fsinfo_start ;
   long free_clusters ;
   loff_t backupboot_start ;
   unsigned char *fat ;
   DOS_FILE **cluster_owner ;
   char *label ;
};
#line 158 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
typedef struct __anonstruct_DOS_FS_33 DOS_FS;
#line 47 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
struct __anonstruct_mediabytes_34 {
   __u8 media ;
   char *descr ;
};
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef int wchar_t;
#line 35 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
struct __anonstruct_LFN_ENT_35 {
   __u8 id ;
   __u8 name0_4[10] ;
   __u8 attr ;
   __u8 reserved ;
   __u8 alias_checksum ;
   __u8 name5_10[12] ;
   __u16 start ;
   __u8 name11_12[4] ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
typedef struct __anonstruct_LFN_ENT_35 LFN_ENT;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 153 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
struct __anonstruct_FAT_ENTRY_35 {
   uint32_t value ;
   uint32_t reserved ;
};
#line 153 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
typedef struct __anonstruct_FAT_ENTRY_35 FAT_ENTRY;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 35 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/common.c"
struct _link {
   void *data ;
   struct _link *next ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/common.c"
typedef struct _link LINK;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 26 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.h"
enum __anonenum_FD_TYPE_34 {
    fdt_none = 0,
    fdt_drop = 1,
    fdt_undelete = 2
} ;
#line 26 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.h"
typedef enum __anonenum_FD_TYPE_34 FD_TYPE;
#line 28 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.h"
struct _fptr {
   char name[11] ;
   FD_TYPE type ;
   struct _fptr *first ;
   struct _fptr *next ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.h"
typedef struct _fptr FDSC;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
struct _change {
   void *data ;
   loff_t pos ;
   int size ;
   struct _change *next ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
typedef struct _change CHANGE;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 313 "/usr/include/linux/hdreg.h"
struct hd_geometry {
   unsigned char heads ;
   unsigned char sectors ;
   unsigned short cylinders ;
   unsigned long start ;
};
#line 13 "/usr/include/linux/fd.h"
struct floppy_struct {
   unsigned int size ;
   unsigned int sect ;
   unsigned int head ;
   unsigned int track ;
   unsigned int stretch ;
   unsigned char gap ;
   unsigned char rate ;
   unsigned char spec1 ;
   unsigned char fmt_gap ;
   char const   *name ;
};
#line 53 "/usr/include/mntent.h"
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 150 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
struct msdos_volume_info {
   __u8 drive_number ;
   __u8 RESERVED ;
   __u8 ext_boot_sign ;
   __u8 volume_id[4] ;
   __u8 volume_label[11] ;
   __u8 fs_type[8] ;
} __attribute__((__packed__)) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
struct __anonstruct__oldfat_63 {
   struct msdos_volume_info vi ;
   __u8 boot_code[448] ;
} __attribute__((__packed__)) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
struct __anonstruct__fat32_64 {
   __u32 fat32_length ;
   __u16 flags ;
   __u8 version[2] ;
   __u32 root_cluster ;
   __u16 info_sector ;
   __u16 backup_boot ;
   __u16 reserved2[6] ;
   struct msdos_volume_info vi ;
   __u8 boot_code[420] ;
} __attribute__((__packed__)) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
union __anonunion_fstype_62 {
   struct __anonstruct__oldfat_63 _oldfat ;
   struct __anonstruct__fat32_64 _fat32 ;
} __attribute__((__packed__)) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
struct msdos_boot_sector {
   __u8 boot_jump[3] ;
   __u8 system_id[8] ;
   __u8 sector_size[2] ;
   __u8 cluster_size ;
   __u16 reserved ;
   __u8 fats ;
   __u8 dir_entries[2] ;
   __u8 sectors[2] ;
   __u8 media ;
   __u16 fat_length ;
   __u16 secs_track ;
   __u16 heads ;
   __u32 hidden ;
   __u32 total_sect ;
   union __anonunion_fstype_62 fstype ;
   __u16 boot_sign ;
} __attribute__((__packed__)) ;
#line 197 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
struct fat32_fsinfo {
   __u32 reserved1 ;
   __u32 signature ;
   __u32 free_clusters ;
   __u32 next_cluster ;
   __u32 reserved2[4] ;
};
#line 206 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
struct msdos_dir_entry___0 {
   char name[8] ;
   char ext[3] ;
   __u8 attr ;
   __u8 lcase ;
   __u8 ctime_ms ;
   __u16 ctime ;
   __u16 cdate ;
   __u16 adate ;
   __u16 starthi ;
   __u16 time ;
   __u16 date ;
   __u16 start ;
   __u32 size ;
} __attribute__((__packed__)) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
struct __anonstruct_mediabytes_34___0 {
   __u8 media ;
   char *descr ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/common.h"
 __attribute__((__noreturn__)) void die(char *msg  , ...) ;
#line 53
char get_key(char *valid , char *prompt ) ;
#line 178 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
int interactive ;
#line 178
int verbose ;
#line 179
int atari_format ;
#line 46 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.h"
uint32_t next_cluster(DOS_FS *fs , uint32_t cluster ) ;
#line 52
loff_t cluster_start(DOS_FS *fs , uint32_t cluster ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.h"
void fs_read(loff_t pos , int size , void *data ) ;
#line 46
int fs_test(loff_t pos , int size ) ;
#line 51
void fs_write(loff_t pos , int size , void *data ) ;
#line 67
unsigned int device_no ;
#line 26 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.h"
void read_boot(DOS_FS *fs ) ;
#line 27
void write_label(DOS_FS *fs , char *label ) ;
#line 28
loff_t find_volume_de(DOS_FS *fs , DIR_ENT *de ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.h"
loff_t alloc_rootdir_entry(DOS_FS *fs , DIR_ENT *de , char const   *pattern ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static struct __anonstruct_mediabytes_34 mediabytes[9]  = 
#line 47 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
  {      {(__u8 )240, (char *)"5.25\" or 3.5\" HD floppy"}, 
        {(__u8 )248, (char *)"hard disk"}, 
        {(__u8 )249, (char *)"3,5\" 720k floppy 2s/80tr/9sec or 5.25\" 1.2M floppy 2s/80tr/15sec"}, 
        {(__u8 )250,
      (char *)"5.25\" 320k floppy 1s/80tr/8sec"}, 
        {(__u8 )251, (char *)"3.5\" 640k floppy 2s/80tr/8sec"}, 
        {(__u8 )252, (char *)"5.25\" 180k floppy 1s/40tr/9sec"}, 
        {(__u8 )253, (char *)"5.25\" 360k floppy 2s/40tr/9sec"}, 
        {(__u8 )254, (char *)"5.25\" 160k floppy 1s/40tr/8sec"}, 
        {(__u8 )255, (char *)"5.25\" 320k floppy 2s/40tr/8sec"}};
#line 67 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static char *get_media_descr(unsigned char media ) 
{ 
  int i ;

  {
#line 71
  i = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! ((unsigned long )i < sizeof(mediabytes) / sizeof(mediabytes[0]))) {
#line 71
      goto while_break;
    }
#line 72
    if ((int )mediabytes[i].media == (int )media) {
#line 73
      return (mediabytes[i].descr);
    }
#line 71
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return ((char *)"undefined");
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void dump_boot(DOS_FS *fs , struct boot_sector *b , unsigned int lss ) 
{ 
  unsigned short sectors ;
  char id[9] ;
  char *tmp ;
  char const   *tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;

  {
  {
#line 82
  printf((char const   */* __restrict  */)"Boot sector contents:\n");
  }
#line 83
  if (! atari_format) {
    {
#line 85
    strncpy((char */* __restrict  */)(id), (char const   */* __restrict  */)((char const   *)(b->system_id)),
            (size_t )8);
#line 86
    id[8] = (char)0;
#line 87
    printf((char const   */* __restrict  */)"System ID \"%s\"\n", id);
    }
  } else {
    {
#line 91
    printf((char const   */* __restrict  */)"Serial number 0x%x\n", ((int )b->system_id[5] | ((int )b->system_id[6] << 8)) | ((int )b->system_id[7] << 16));
    }
  }
  {
#line 95
  tmp = get_media_descr(b->media);
#line 95
  printf((char const   */* __restrict  */)"Media byte 0x%02x (%s)\n", (int )b->media,
         tmp);
#line 96
  printf((char const   */* __restrict  */)"%10d bytes per logical sector\n", (int )((__u16 )b->sector_size[0]) | ((int )((__u16 )b->sector_size[1]) << 8));
#line 97
  printf((char const   */* __restrict  */)"%10d bytes per cluster\n", fs->cluster_size);
  }
#line 98
  if ((int )b->reserved == 1) {
#line 98
    tmp___0 = "";
  } else {
#line 98
    tmp___0 = "s";
  }
  {
#line 98
  printf((char const   */* __restrict  */)"%10d reserved sector%s\n", (int )b->reserved,
         tmp___0);
#line 100
  printf((char const   */* __restrict  */)"First FAT starts at byte %llu (sector %llu)\n",
         (unsigned long long )fs->fat_start, (unsigned long long )fs->fat_start / (unsigned long long )lss);
#line 103
  printf((char const   */* __restrict  */)"%10d FATs, %d bit entries\n", (int )b->fats,
         fs->fat_bits);
#line 104
  printf((char const   */* __restrict  */)"%10d bytes per FAT (= %u sectors)\n", fs->fat_size,
         fs->fat_size / lss);
  }
#line 106
  if (! fs->root_cluster) {
    {
#line 107
    printf((char const   */* __restrict  */)"Root directory starts at byte %llu (sector %llu)\n",
           (unsigned long long )fs->root_start, (unsigned long long )fs->root_start / (unsigned long long )lss);
#line 110
    printf((char const   */* __restrict  */)"%10d root directory entries\n", fs->root_entries);
    }
  } else {
    {
#line 112
    printf((char const   */* __restrict  */)"Root directory start at cluster %lu (arbitrary size)\n",
           (unsigned long )fs->root_cluster);
    }
  }
  {
#line 115
  printf((char const   */* __restrict  */)"Data area starts at byte %llu (sector %llu)\n",
         (unsigned long long )fs->data_start, (unsigned long long )fs->data_start / (unsigned long long )lss);
#line 118
  printf((char const   */* __restrict  */)"%10lu data clusters (%llu bytes)\n", (unsigned long )fs->clusters,
         (unsigned long long )fs->clusters * (unsigned long long )fs->cluster_size);
#line 120
  printf((char const   */* __restrict  */)"%u sectors/track, %u heads\n", (int )b->secs_track,
         (int )b->heads);
  }
#line 122
  if (atari_format) {
#line 122
    tmp___1 = (__u32 )((int )*((unsigned char *)(& b->hidden) + 0) | ((int )*((unsigned char *)(& b->hidden) + 1) << 8));
  } else {
#line 122
    tmp___1 = b->hidden;
  }
  {
#line 122
  printf((char const   */* __restrict  */)"%10u hidden sectors\n", tmp___1);
#line 126
  sectors = (unsigned short )((int )((__u16 )b->sectors[0]) | ((int )((__u16 )b->sectors[1]) << 8));
  }
#line 127
  if (sectors) {
#line 127
    tmp___2 = (__u32 )sectors;
  } else {
#line 127
    tmp___2 = b->total_sect;
  }
  {
#line 127
  printf((char const   */* __restrict  */)"%10u sectors total\n", tmp___2);
  }
#line 128
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void check_backup_boot(DOS_FS *fs , struct boot_sector *b , int lss ) 
{ 
  struct boot_sector b2 ;
  int bbs ;
  char tmp ;
  __u8 *p ;
  __u8 *q ;
  int i ;
  int pos ;
  int first ;
  char buf[20] ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 134
  if (! fs->backupboot_start) {
    {
#line 135
    printf((char const   */* __restrict  */)"There is no backup boot sector.\n");
    }
#line 136
    if ((int )b->reserved < 3) {
      {
#line 137
      printf((char const   */* __restrict  */)"And there is no space for creating one!\n");
      }
#line 138
      return;
    }
#line 140
    if (interactive) {
      {
#line 141
      printf((char const   */* __restrict  */)"1) Create one\n2) Do without a backup\n");
      }
    } else {
      {
#line 143
      printf((char const   */* __restrict  */)"  Auto-creating backup boot block.\n");
      }
    }
#line 144
    if (! interactive) {
#line 144
      goto _L___0;
    } else {
      {
#line 144
      tmp = get_key((char *)"12", (char *)"?");
      }
#line 144
      if ((int )tmp == 49) {
        _L___0: /* CIL Label */ 
#line 148
        if ((int )b->reserved >= 7) {
#line 148
          if ((int )b->info_sector != 6) {
#line 149
            bbs = 6;
          } else {
#line 148
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 151
          bbs = (int )b->reserved - 1;
#line 152
          if (bbs == (int )b->info_sector) {
#line 153
            bbs --;
          }
        }
        {
#line 155
        fs->backupboot_start = (loff_t )(bbs * lss);
#line 156
        b->backup_boot = (__u16 )bbs;
#line 157
        fs_write(fs->backupboot_start, (int )sizeof(*b), (void *)b);
#line 158
        fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->backup_boot)),
                 (int )sizeof(b->backup_boot), (void *)(& b->backup_boot));
#line 160
        printf((char const   */* __restrict  */)"Created backup of boot sector in sector %d\n",
               bbs);
        }
#line 161
        return;
      } else {
#line 163
        return;
      }
    }
  }
  {
#line 166
  fs_read(fs->backupboot_start, (int )sizeof(b2), (void *)(& b2));
#line 167
  tmp___5 = memcmp((void const   *)b, (void const   *)(& b2), sizeof(b2));
  }
#line 167
  if (tmp___5 != 0) {
    {
#line 170
    first = 1;
#line 173
    printf((char const   */* __restrict  */)"There are differences between boot sector and its backup.\n");
#line 174
    printf((char const   */* __restrict  */)"This is mostly harmless. Differences: (offset:original/backup)\n  ");
#line 175
    pos = 2;
#line 176
    p = (__u8 *)b;
#line 176
    q = (__u8 *)(& b2);
#line 176
    i = 0;
    }
    {
#line 176
    while (1) {
      while_continue: /* CIL Label */ ;
#line 176
      if (! ((unsigned long )i < sizeof(b2))) {
#line 176
        goto while_break;
      }
#line 178
      if ((int )*p != (int )*q) {
#line 179
        if (first) {
#line 179
          tmp___0 = "";
        } else {
#line 179
          tmp___0 = ", ";
        }
        {
#line 179
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s%u:%02x/%02x",
                tmp___0, (unsigned int )(p - (__u8 *)b), (int )*p, (int )*q);
#line 181
        tmp___1 = strlen((char const   *)(buf));
        }
#line 181
        if ((size_t )pos + tmp___1 > 78UL) {
          {
#line 182
          printf((char const   */* __restrict  */)"\n  ");
#line 182
          pos = 2;
          }
        }
        {
#line 183
        printf((char const   */* __restrict  */)"%s", buf);
#line 184
        tmp___2 = strlen((char const   *)(buf));
#line 184
        pos = (int )((size_t )pos + tmp___2);
#line 185
        first = 0;
        }
      }
#line 176
      p ++;
#line 176
      q ++;
#line 176
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 188
    printf((char const   */* __restrict  */)"\n");
    }
#line 190
    if (interactive) {
      {
#line 191
      printf((char const   */* __restrict  */)"1) Copy original to backup\n2) Copy backup to original\n3) No action\n");
      }
    } else {
      {
#line 194
      printf((char const   */* __restrict  */)"  Not automatically fixing this.\n");
      }
    }
#line 195
    if (interactive) {
      {
#line 195
      tmp___3 = get_key((char *)"123", (char *)"?");
#line 195
      tmp___4 = (int )tmp___3;
      }
    } else {
#line 195
      tmp___4 = '3';
    }
    {
#line 196
    if (tmp___4 == 49) {
#line 196
      goto case_49;
    }
#line 199
    if (tmp___4 == 50) {
#line 199
      goto case_50;
    }
#line 202
    goto switch_default;
    case_49: /* CIL Label */ 
    {
#line 197
    fs_write(fs->backupboot_start, (int )sizeof(*b), (void *)b);
    }
#line 198
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 200
    fs_write((loff_t )0, (int )sizeof(b2), (void *)(& b2));
    }
#line 201
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 203
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 206
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void init_fsinfo(struct info_sector *i ) 
{ 


  {
#line 210
  i->magic = (__u32 )1096897106;
#line 211
  i->signature = (__u32 )1631679090;
#line 212
  i->free_clusters = (__u32 )-1;
#line 213
  i->next_cluster = (__u32 )2;
#line 214
  i->boot_sign = (__u16 )43605;
#line 215
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void read_fsinfo(DOS_FS *fs , struct boot_sector *b , int lss ) 
{ 
  struct info_sector i ;
  __u32 s ;
  char tmp ;
  char tmp___0 ;

  {
#line 221
  if (! b->info_sector) {
    {
#line 222
    printf((char const   */* __restrict  */)"No FSINFO sector\n");
    }
#line 223
    if (interactive) {
      {
#line 224
      printf((char const   */* __restrict  */)"1) Create one\n2) Do without FSINFO\n");
      }
    } else {
      {
#line 226
      printf((char const   */* __restrict  */)"  Not automatically creating it.\n");
      }
    }
#line 227
    if (interactive) {
      {
#line 227
      tmp = get_key((char *)"12", (char *)"?");
      }
#line 227
      if ((int )tmp == 49) {
#line 231
        s = (__u32 )1;
        {
#line 231
        while (1) {
          while_continue: /* CIL Label */ ;
#line 231
          if (! (s < (__u32 )b->reserved)) {
#line 231
            goto while_break;
          }
#line 232
          if (s != (__u32 )b->backup_boot) {
#line 233
            goto while_break;
          }
#line 231
          s ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 234
        if (s > 0U) {
#line 234
          if (s < (__u32 )b->reserved) {
            {
#line 235
            init_fsinfo(& i);
#line 236
            fs_write((loff_t )s * (loff_t )lss, (int )sizeof(i), (void *)(& i));
#line 237
            b->info_sector = (__u16 )s;
#line 238
            fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->info_sector)),
                     (int )sizeof(b->info_sector), (void *)(& b->info_sector));
            }
#line 240
            if (fs->backupboot_start) {
              {
#line 241
              fs_write((loff_t )((unsigned long )fs->backupboot_start + (unsigned long )(& ((struct boot_sector *)0)->info_sector)),
                       (int )sizeof(b->info_sector), (void *)(& b->info_sector));
              }
            }
          } else {
            {
#line 245
            printf((char const   */* __restrict  */)"No free reserved sector found -- no space for FSINFO sector!\n");
            }
#line 247
            return;
          }
        } else {
          {
#line 245
          printf((char const   */* __restrict  */)"No free reserved sector found -- no space for FSINFO sector!\n");
          }
#line 247
          return;
        }
      } else {
#line 250
        return;
      }
    } else {
#line 250
      return;
    }
  }
  {
#line 253
  fs->fsinfo_start = (loff_t )((int )b->info_sector * lss);
#line 254
  fs_read(fs->fsinfo_start, (int )sizeof(i), (void *)(& i));
  }
#line 256
  if (i.magic != 1096897106U) {
#line 256
    goto _L;
  } else
#line 256
  if (i.signature != 1631679090U) {
#line 256
    goto _L;
  } else
#line 256
  if ((int )i.boot_sign != 43605) {
    _L: /* CIL Label */ 
    {
#line 258
    printf((char const   */* __restrict  */)"FSINFO sector has bad magic number(s):\n");
    }
#line 259
    if (i.magic != 1096897106U) {
      {
#line 260
      printf((char const   */* __restrict  */)"  Offset %llu: 0x%08x != expected 0x%08x\n",
             (unsigned long long )((unsigned long )(& ((struct info_sector *)0)->magic)),
             i.magic, 1096897106);
      }
    }
#line 263
    if (i.signature != 1631679090U) {
      {
#line 264
      printf((char const   */* __restrict  */)"  Offset %llu: 0x%08x != expected 0x%08x\n",
             (unsigned long long )((unsigned long )(& ((struct info_sector *)0)->signature)),
             i.signature, 1631679090);
      }
    }
#line 267
    if ((int )i.boot_sign != 43605) {
      {
#line 268
      printf((char const   */* __restrict  */)"  Offset %llu: 0x%04x != expected 0x%04x\n",
             (unsigned long long )((unsigned long )(& ((struct info_sector *)0)->boot_sign)),
             (int )i.boot_sign, 43605);
      }
    }
#line 271
    if (interactive) {
      {
#line 272
      printf((char const   */* __restrict  */)"1) Correct\n2) Don\'t correct (FSINFO invalid then)\n");
      }
    } else {
      {
#line 274
      printf((char const   */* __restrict  */)"  Auto-correcting it.\n");
      }
    }
#line 275
    if (! interactive) {
      {
#line 276
      init_fsinfo(& i);
#line 277
      fs_write(fs->fsinfo_start, (int )sizeof(i), (void *)(& i));
      }
    } else {
      {
#line 275
      tmp___0 = get_key((char *)"12", (char *)"?");
      }
#line 275
      if ((int )tmp___0 == 49) {
        {
#line 276
        init_fsinfo(& i);
#line 277
        fs_write(fs->fsinfo_start, (int )sizeof(i), (void *)(& i));
        }
      } else {
#line 279
        fs->fsinfo_start = (loff_t )0;
      }
    }
  }
#line 282
  if (fs->fsinfo_start) {
#line 283
    fs->free_clusters = (long )i.free_clusters;
  }
#line 284
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static char print_fat_dirty_state(void) 
{ 
  char tmp ;

  {
  {
#line 288
  printf((char const   */* __restrict  */)"Dirty bit is set. Fs was not properly unmounted and some data may be corrupt.\n");
  }
#line 291
  if (interactive) {
    {
#line 292
    printf((char const   */* __restrict  */)"1) Remove dirty bit\n2) No action\n");
#line 293
    tmp = get_key((char *)"12", (char *)"?");
    }
#line 293
    return (tmp);
  } else {
    {
#line 295
    printf((char const   */* __restrict  */)" Automatically removing dirty bit.\n");
    }
  }
#line 296
  return ((char )'1');
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void check_fat_state_bit(DOS_FS *fs , void *b ) 
{ 
  struct boot_sector *b32 ;
  char tmp ;
  struct boot_sector_16 *b16 ;
  char tmp___0 ;

  {
#line 301
  if (fs->fat_bits == 32U) {
#line 302
    b32 = (struct boot_sector *)b;
#line 304
    if ((int )b32->reserved3 & 1) {
      {
#line 305
      printf((char const   */* __restrict  */)"0x41: ");
#line 306
      tmp = print_fat_dirty_state();
      }
#line 306
      if ((int )tmp == 49) {
        {
#line 307
        b32->reserved3 = (__u8 )((int )b32->reserved3 & -2);
#line 308
        fs_write((loff_t )0, (int )sizeof(*b32), (void *)b32);
        }
      }
    }
  } else {
#line 312
    b16 = (struct boot_sector_16 *)b;
#line 314
    if ((int )b16->reserved2 & 1) {
      {
#line 315
      printf((char const   */* __restrict  */)"0x25: ");
#line 316
      tmp___0 = print_fat_dirty_state();
      }
#line 316
      if ((int )tmp___0 == 49) {
        {
#line 317
        b16->reserved2 = (__u8 )((int )b16->reserved2 & -2);
#line 318
        fs_write((loff_t )0, (int )sizeof(*b16), (void *)b16);
        }
      }
    }
  }
#line 322
  return;
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
void read_boot(DOS_FS *fs ) 
{ 
  struct boot_sector b ;
  unsigned int total_sectors ;
  unsigned short logical_sector_size ;
  unsigned short sectors ;
  unsigned int fat_length ;
  loff_t data_size ;
  unsigned int tmp ;
  void *tmp___0 ;
  struct boot_sector_16 *b16 ;

  {
  {
#line 332
  fs_read((loff_t )0, (int )sizeof(b), (void *)(& b));
#line 333
  logical_sector_size = (unsigned short )((int )((__u16 )b.sector_size[0]) | ((int )((__u16 )b.sector_size[1]) << 8));
  }
#line 334
  if (! logical_sector_size) {
    {
#line 335
    die((char *)"Logical sector size is zero.");
    }
  }
#line 340
  if ((int )logical_sector_size & 511) {
    {
#line 341
    die((char *)"Logical sector size (%d bytes) is not a multiple of the physical sector size.",
        (int )logical_sector_size);
    }
  }
#line 344
  fs->cluster_size = (unsigned int )((int )b.cluster_size * (int )logical_sector_size);
#line 345
  if (! fs->cluster_size) {
    {
#line 346
    die((char *)"Cluster size is zero.");
    }
  }
#line 347
  if ((int )b.fats != 2) {
#line 347
    if ((int )b.fats != 1) {
      {
#line 348
      die((char *)"Currently, only 1 or 2 FATs are supported, not %d.\n", (int )b.fats);
      }
    }
  }
#line 349
  fs->nfats = (int )b.fats;
#line 350
  sectors = (unsigned short )((int )((__u16 )b.sectors[0]) | ((int )((__u16 )b.sectors[1]) << 8));
#line 351
  if (sectors) {
#line 351
    total_sectors = (unsigned int )sectors;
  } else {
#line 351
    total_sectors = b.total_sect;
  }
#line 352
  if (verbose) {
    {
#line 353
    printf((char const   */* __restrict  */)"Checking we can access the last sector of the filesystem\n");
    }
  }
  {
#line 355
  fs_test((loff_t )((total_sectors & 4294967294U) - 1U) * (loff_t )logical_sector_size,
          (int )logical_sector_size);
  }
#line 357
  if (b.fat_length) {
#line 357
    fat_length = (unsigned int )b.fat_length;
  } else {
#line 357
    fat_length = b.fat32_length;
  }
#line 359
  fs->fat_start = (loff_t )b.reserved * (loff_t )logical_sector_size;
#line 360
  fs->root_start = ((loff_t )b.reserved + (loff_t )((unsigned int )b.fats * fat_length)) * (loff_t )logical_sector_size;
#line 362
  fs->root_entries = (unsigned int )((int )((__u16 )b.dir_entries[0]) | ((int )((__u16 )b.dir_entries[1]) << 8));
#line 363
  if (fs->root_entries << 5) {
#line 363
    if (logical_sector_size) {
#line 363
      tmp = (((fs->root_entries << 5) + (unsigned int )logical_sector_size) - 1U) - ((fs->root_entries << 5) - 1U) % (unsigned int )logical_sector_size;
    } else {
#line 363
      tmp = 0U;
    }
  } else {
#line 363
    tmp = 0U;
  }
#line 363
  fs->data_start = fs->root_start + (loff_t )tmp;
#line 366
  data_size = (loff_t )total_sectors * (loff_t )logical_sector_size - fs->data_start;
#line 367
  fs->clusters = (uint32_t )(data_size / (loff_t )fs->cluster_size);
#line 368
  fs->root_cluster = (uint32_t )0;
#line 369
  fs->fsinfo_start = (loff_t )0;
#line 370
  fs->free_clusters = -1L;
#line 371
  if (! b.fat_length) {
#line 371
    if (b.fat32_length) {
#line 372
      fs->fat_bits = 32U;
#line 373
      fs->root_cluster = b.root_cluster;
#line 374
      if (! fs->root_cluster) {
#line 374
        if (fs->root_entries) {
          {
#line 380
          printf((char const   */* __restrict  */)"Warning: FAT32 root dir not in cluster chain! Compatibility mode...\n");
          }
        } else {
#line 374
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 382
      if (! fs->root_cluster) {
#line 382
        if (! fs->root_entries) {
          {
#line 383
          die((char *)"No root directory!");
          }
        } else {
#line 382
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 384
      if (fs->root_cluster) {
#line 384
        if (fs->root_entries) {
          {
#line 385
          printf((char const   */* __restrict  */)"Warning: FAT32 root dir is in a cluster chain, but a separate root dir\n  area is defined. Cannot fix this easily.\n");
          }
        }
      }
#line 388
      if (fs->clusters < 65525U) {
        {
#line 389
        printf((char const   */* __restrict  */)"Warning: Filesystem is FAT32 according to fat_length and fat32_length fields,\n  but has only %lu clusters, less than the required minimum of %d.\n  This may lead to problems on some systems.\n",
               (unsigned long )fs->clusters, 65525);
        }
      }
      {
#line 396
      check_fat_state_bit(fs, (void *)(& b));
#line 397
      fs->backupboot_start = (loff_t )((int )b.backup_boot * (int )logical_sector_size);
#line 398
      check_backup_boot(fs, & b, (int )logical_sector_size);
#line 400
      read_fsinfo(fs, & b, (int )logical_sector_size);
      }
    } else {
#line 371
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 401
  if (! atari_format) {
#line 404
    if (fs->clusters >= 4085U) {
#line 404
      fs->fat_bits = 16U;
    } else {
#line 404
      fs->fat_bits = 12U;
    }
#line 405
    if (fs->clusters >= 65525U) {
      {
#line 406
      die((char *)"Too many clusters (%lu) for FAT16 filesystem.", fs->clusters);
      }
    }
    {
#line 407
    check_fat_state_bit(fs, (void *)(& b));
    }
  } else {
#line 411
    fs->fat_bits = 16U;
#line 414
    if (fs->clusters + 2U > ((fat_length * (unsigned int )logical_sector_size) * 8U) / 16U) {
#line 422
      fs->fat_bits = 12U;
    } else
#line 414
    if (device_no == 2U) {
#line 422
      fs->fat_bits = 12U;
    } else
#line 414
    if (device_no == 1U) {
#line 414
      goto _L___1;
    } else
#line 414
    if (device_no == 7U) {
      _L___1: /* CIL Label */ 
#line 414
      if (total_sectors == 720U) {
#line 422
        fs->fat_bits = 12U;
      } else
#line 414
      if (total_sectors == 1440U) {
#line 422
        fs->fat_bits = 12U;
      } else
#line 414
      if (total_sectors == 2880U) {
#line 422
        fs->fat_bits = 12U;
      }
    }
  }
#line 425
  if (fs->fat_bits == 32U) {
#line 425
    fs->eff_fat_bits = 28U;
  } else {
#line 425
    fs->eff_fat_bits = fs->fat_bits;
  }
  {
#line 426
  fs->fat_size = fat_length * (unsigned int )logical_sector_size;
#line 428
  tmp___0 = calloc((size_t )12, sizeof(__u8 ));
#line 428
  fs->label = (char *)tmp___0;
  }
#line 429
  if (fs->fat_bits == 12U) {
#line 429
    goto _L___3;
  } else
#line 429
  if (fs->fat_bits == 16U) {
    _L___3: /* CIL Label */ 
#line 430
    b16 = (struct boot_sector_16 *)(& b);
#line 431
    if ((int )b16->extended_sig == 41) {
      {
#line 432
      memmove((void *)fs->label, (void const   *)(b16->label), (size_t )11);
      }
    } else {
#line 434
      fs->label = (char *)((void *)0);
    }
  } else
#line 435
  if (fs->fat_bits == 32U) {
#line 436
    if ((int )b.extended_sig == 41) {
      {
#line 437
      memmove((void *)fs->label, (void const   *)(& b.label), (size_t )11);
      }
    } else {
#line 439
      fs->label = (char *)((void *)0);
    }
  }
#line 442
  if ((uint64_t )fs->clusters > ((uint64_t )fs->fat_size * 8UL) / (uint64_t )fs->fat_bits - 2UL) {
    {
#line 444
    die((char *)"Filesystem has %d clusters but only space for %d FAT entries.", fs->clusters,
        ((unsigned long long )fs->fat_size * 8ULL) / (unsigned long long )fs->fat_bits - 2ULL);
    }
  }
#line 447
  if (! fs->root_entries) {
#line 447
    if (! fs->root_cluster) {
      {
#line 448
      die((char *)"Root directory has zero size.");
      }
    }
  }
#line 449
  if ((unsigned long )fs->root_entries & (512UL / sizeof(struct msdos_dir_entry ) - 1UL)) {
    {
#line 450
    die((char *)"Root directory (%d entries) doesn\'t span an integral number of sectors.",
        fs->root_entries);
    }
  }
#line 452
  if ((int )logical_sector_size & 511) {
    {
#line 453
    die((char *)"Logical sector size (%d bytes) is not a multiple of the physical sector size.",
        (int )logical_sector_size);
    }
  }
#line 460
  if (verbose) {
    {
#line 461
    dump_boot(fs, & b, (unsigned int )logical_sector_size);
    }
  }
#line 462
  return;
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void write_boot_label(DOS_FS *fs , char *label ) 
{ 
  struct boot_sector_16 b16 ;
  char const   *tmp ;
  struct boot_sector b ;

  {
#line 466
  if (fs->fat_bits == 12U) {
#line 466
    goto _L;
  } else
#line 466
  if (fs->fat_bits == 16U) {
    _L: /* CIL Label */ 
    {
#line 469
    fs_read((loff_t )0, (int )sizeof(b16), (void *)(& b16));
    }
#line 470
    if ((int )b16.extended_sig != 41) {
#line 471
      b16.extended_sig = (__u8 )41;
#line 472
      b16.serial = (__u32 )0;
#line 473
      if (fs->fat_bits == 12U) {
#line 473
        tmp = "FAT12   ";
      } else {
#line 473
        tmp = "FAT16   ";
      }
      {
#line 473
      memmove((void *)(b16.fs_type), (void const   *)tmp, (size_t )8);
      }
    }
    {
#line 476
    memmove((void *)(b16.label), (void const   *)label, (size_t )11);
#line 477
    fs_write((loff_t )0, (int )sizeof(b16), (void *)(& b16));
    }
  } else
#line 478
  if (fs->fat_bits == 32U) {
    {
#line 481
    fs_read((loff_t )0, (int )sizeof(b), (void *)(& b));
    }
#line 482
    if ((int )b.extended_sig != 41) {
      {
#line 483
      b.extended_sig = (__u8 )41;
#line 484
      b.serial = (__u32 )0;
#line 485
      memmove((void *)(b.fs_type), (void const   *)"FAT32   ", (size_t )8);
      }
    }
    {
#line 487
    memmove((void *)(b.label), (void const   *)label, (size_t )11);
#line 488
    fs_write((loff_t )0, (int )sizeof(b), (void *)(& b));
    }
#line 489
    if (fs->backupboot_start) {
      {
#line 490
      fs_write(fs->backupboot_start, (int )sizeof(b), (void *)(& b));
      }
    }
  }
#line 492
  return;
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
loff_t find_volume_de(DOS_FS *fs , DIR_ENT *de ) 
{ 
  uint32_t cluster ;
  loff_t offset ;
  int i ;

  {
#line 500
  if (fs->root_cluster) {
#line 501
    cluster = fs->root_cluster;
    {
#line 501
    while (1) {
      while_continue: /* CIL Label */ ;
#line 501
      if (cluster != 0U) {
#line 501
        if (! (cluster != 4294967295U)) {
#line 501
          goto while_break;
        }
      } else {
#line 501
        goto while_break;
      }
      {
#line 504
      offset = cluster_start(fs, cluster);
#line 505
      i = 0;
      }
      {
#line 505
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 505
        if (! ((unsigned long )i * sizeof(DIR_ENT ) < (unsigned long )fs->cluster_size)) {
#line 505
          goto while_break___0;
        }
        {
#line 506
        fs_read(offset, (int )sizeof(DIR_ENT ), (void *)de);
        }
#line 507
        if ((int )de->attr & 8) {
#line 508
          return (offset);
        }
#line 509
        offset = (loff_t )((unsigned long )offset + sizeof(DIR_ENT ));
#line 505
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 501
      cluster = next_cluster(fs, cluster);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 513
    i = 0;
    {
#line 513
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 513
      if (! ((unsigned int )i < fs->root_entries)) {
#line 513
        goto while_break___1;
      }
      {
#line 514
      offset = (loff_t )((unsigned long )fs->root_start + (unsigned long )i * sizeof(DIR_ENT ));
#line 515
      fs_read(offset, (int )sizeof(DIR_ENT ), (void *)de);
      }
#line 516
      if ((int )de->attr & 8) {
#line 517
        return (offset);
      }
#line 513
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 521
  return ((loff_t )0);
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void write_volume_label(DOS_FS *fs , char *label ) 
{ 
  time_t now ;
  time_t tmp ;
  struct tm *mtime ;
  struct tm *tmp___0 ;
  loff_t offset ;
  int created ;
  DIR_ENT de ;

  {
  {
#line 526
  tmp = time((time_t *)((void *)0));
#line 526
  now = tmp;
#line 527
  tmp___0 = localtime((time_t const   *)(& now));
#line 527
  mtime = tmp___0;
#line 532
  created = 0;
#line 533
  offset = find_volume_de(fs, & de);
  }
#line 534
  if (offset == 0L) {
    {
#line 535
    created = 1;
#line 536
    offset = alloc_rootdir_entry(fs, & de, (char const   *)label);
    }
  }
  {
#line 538
  memcpy((void */* __restrict  */)(de.name), (void const   */* __restrict  */)label,
         (size_t )11);
#line 539
  de.time = (unsigned short )(((mtime->tm_sec >> 1) + (mtime->tm_min << 5)) + (mtime->tm_hour << 11));
#line 542
  de.date = (unsigned short )((mtime->tm_mday + ((mtime->tm_mon + 1) << 5)) + ((mtime->tm_year - 80) << 9));
  }
#line 545
  if (created) {
#line 546
    de.attr = (__u8 )8;
#line 547
    de.ctime_ms = (__u8 )0;
#line 548
    de.ctime = de.time;
#line 549
    de.cdate = de.date;
#line 550
    de.adate = de.date;
#line 551
    de.starthi = (__u16 )0;
#line 552
    de.start = (__u16 )0;
#line 553
    de.size = (__u32 )0;
  }
  {
#line 556
  fs_write(offset, (int )sizeof(DIR_ENT ), (void *)(& de));
  }
#line 557
  return;
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
void write_label(DOS_FS *fs , char *label ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 561
  tmp = strlen((char const   *)label);
#line 561
  l = (int )tmp;
  }
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (! (l < 11)) {
#line 563
      goto while_break;
    }
#line 564
    tmp___0 = l;
#line 564
    l ++;
#line 564
    *(label + tmp___0) = (char )' ';
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 566
  write_boot_label(fs, label);
#line 567
  write_volume_label(fs, label);
  }
#line 568
  return;
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 877
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcstombs)(char * __restrict  __s ,
                                                                                  wchar_t const   * __restrict  __pwcs ,
                                                                                  size_t __n ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/common.h"
void *alloc(int size ) ;
#line 41
void *qalloc(void **root___1 , int size ) ;
#line 181 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
void *mem_queue ;
#line 26 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.h"
void lfn_reset(void) ;
#line 29
void lfn_add_slot(DIR_ENT *de , loff_t dir_offset ) ;
#line 32
char *lfn_get(DIR_ENT *de , loff_t *lfn_offset ) ;
#line 35
void lfn_check_orphaned(void) ;
#line 37
void lfn_fix_checksum(loff_t from , loff_t to , char const   *short_name ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.h"
char *file_name(unsigned char *fixed ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
unsigned char *lfn_unicode  =    (unsigned char *)((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
unsigned char lfn_checksum  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
int lfn_slot  =    -1;
#line 55 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
loff_t *lfn_offsets  =    (loff_t *)((void *)0);
#line 56 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
int lfn_parts  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
static unsigned char fat_uni2esc[64]  = 
#line 58
  {      (unsigned char )'0',      (unsigned char )'1',      (unsigned char )'2',      (unsigned char )'3', 
        (unsigned char )'4',      (unsigned char )'5',      (unsigned char )'6',      (unsigned char )'7', 
        (unsigned char )'8',      (unsigned char )'9',      (unsigned char )'A',      (unsigned char )'B', 
        (unsigned char )'C',      (unsigned char )'D',      (unsigned char )'E',      (unsigned char )'F', 
        (unsigned char )'G',      (unsigned char )'H',      (unsigned char )'I',      (unsigned char )'J', 
        (unsigned char )'K',      (unsigned char )'L',      (unsigned char )'M',      (unsigned char )'N', 
        (unsigned char )'O',      (unsigned char )'P',      (unsigned char )'Q',      (unsigned char )'R', 
        (unsigned char )'S',      (unsigned char )'T',      (unsigned char )'U',      (unsigned char )'V', 
        (unsigned char )'W',      (unsigned char )'X',      (unsigned char )'Y',      (unsigned char )'Z', 
        (unsigned char )'a',      (unsigned char )'b',      (unsigned char )'c',      (unsigned char )'d', 
        (unsigned char )'e',      (unsigned char )'f',      (unsigned char )'g',      (unsigned char )'h', 
        (unsigned char )'i',      (unsigned char )'j',      (unsigned char )'k',      (unsigned char )'l', 
        (unsigned char )'m',      (unsigned char )'n',      (unsigned char )'o',      (unsigned char )'p', 
        (unsigned char )'q',      (unsigned char )'r',      (unsigned char )'s',      (unsigned char )'t', 
        (unsigned char )'u',      (unsigned char )'v',      (unsigned char )'w',      (unsigned char )'x', 
        (unsigned char )'y',      (unsigned char )'z',      (unsigned char )'+',      (unsigned char )'-'};
#line 90 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
static size_t mbslen(wchar_t x ) 
{ 
  wchar_t wstr[2] ;
  size_t tmp ;

  {
  {
#line 92
  wstr[0] = x;
#line 92
  wstr[1] = 0;
#line 93
  tmp = wcstombs((char */* __restrict  */)((void *)0), (wchar_t const   */* __restrict  */)(wstr),
                 (size_t )0);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
static size_t wctombs(char *dest , wchar_t x ) 
{ 
  wchar_t wstr[2] ;
  size_t size ;
  size_t tmp ;

  {
  {
#line 98
  wstr[0] = x;
#line 98
  wstr[1] = 0;
#line 99
  tmp = wcstombs((char */* __restrict  */)((void *)0), (wchar_t const   */* __restrict  */)(wstr),
                 (size_t )0);
#line 99
  size = tmp;
  }
#line 100
  if (size != 0xffffffffffffffffUL) {
    {
#line 101
    size = wcstombs((char */* __restrict  */)dest, (wchar_t const   */* __restrict  */)(wstr),
                    size + 1UL);
    }
  }
#line 102
  return (size);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
static char *cnv_unicode(unsigned char const   *uni , int maxlen , int use_q ) 
{ 
  unsigned char const   *up ;
  unsigned char *out ;
  unsigned char *cp ;
  int len ;
  int val ;
  size_t x ;
  void *tmp ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 115
  len = 0;
#line 115
  up = uni;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if ((up - uni) / 2L < (long )maxlen) {
#line 115
      if (! *(up + 0)) {
#line 115
        if (! *(up + 1)) {
#line 115
          goto while_break;
        }
      }
    } else {
#line 115
      goto while_break;
    }
    {
#line 117
    x = mbslen((wchar_t )((unsigned int )*(up + 0) + ((unsigned int )*(up + 1) << 8)));
    }
#line 117
    if (x != 0xffffffffffffffffUL) {
#line 118
      len = (int )((size_t )len + x);
    } else
#line 119
    if ((int const   )*(up + 1) == 0) {
#line 119
      if ((int const   )*(up + 0) < 128) {
#line 120
        len ++;
      } else
#line 119
      if ((int const   )*(up + 0) >= 160) {
#line 120
        len ++;
      } else {
#line 122
        len += 4;
      }
    } else {
#line 122
      len += 4;
    }
#line 115
    up += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  if (use_q) {
    {
#line 124
    tmp = qalloc(& mem_queue, len + 1);
#line 124
    out = (unsigned char *)tmp;
    }
  } else {
    {
#line 124
    tmp___0 = alloc(len + 1);
#line 124
    out = (unsigned char *)tmp___0;
    }
  }
#line 124
  cp = out;
#line 126
  up = uni;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 126
    if ((up - uni) / 2L < (long )maxlen) {
#line 126
      if (! *(up + 0)) {
#line 126
        if (! *(up + 1)) {
#line 126
          goto while_break___0;
        }
      }
    } else {
#line 126
      goto while_break___0;
    }
    {
#line 127
    x = wctombs((char *)cp, (wchar_t )((unsigned int )*(up + 0) + ((unsigned int )*(up + 1) << 8)));
    }
#line 127
    if (x != 0xffffffffffffffffUL) {
#line 129
      cp += x;
    } else
#line 130
    if ((int const   )*(up + 1) == 0) {
#line 130
      if ((int const   )*(up + 0) < 128) {
#line 131
        tmp___1 = cp;
#line 131
        cp ++;
#line 131
        *tmp___1 = (unsigned char )*(up + 0);
      } else
#line 130
      if ((int const   )*(up + 0) >= 160) {
#line 131
        tmp___1 = cp;
#line 131
        cp ++;
#line 131
        *tmp___1 = (unsigned char )*(up + 0);
      } else {
#line 130
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 134
      tmp___2 = cp;
#line 134
      cp ++;
#line 134
      *tmp___2 = (unsigned char )':';
#line 135
      val = (int )(((int const   )*(up + 1) << 8) + (int const   )*(up + 0));
#line 136
      *(cp + 2) = fat_uni2esc[val & 63];
#line 137
      val >>= 6;
#line 138
      *(cp + 1) = fat_uni2esc[val & 63];
#line 139
      val >>= 6;
#line 140
      *(cp + 0) = fat_uni2esc[val & 63];
#line 141
      cp += 3;
    }
#line 126
    up += 2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 144
  *cp = (unsigned char)0;
#line 146
  return ((char *)out);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
static void copy_lfn_part(unsigned char *dst , LFN_ENT *lfn ) 
{ 


  {
  {
#line 151
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(lfn->name0_4),
         (size_t )10);
#line 152
  memcpy((void */* __restrict  */)(dst + 10), (void const   */* __restrict  */)(lfn->name5_10),
         (size_t )12);
#line 153
  memcpy((void */* __restrict  */)(dst + 22), (void const   */* __restrict  */)(lfn->name11_12),
         (size_t )4);
  }
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
static void clear_lfn_slots(int start , int end ) 
{ 
  int i ;
  LFN_ENT empty ;

  {
  {
#line 165
  memset((void *)(& empty), 0, sizeof(empty));
#line 166
  empty.id = (__u8 )229;
#line 168
  i = start;
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i <= end)) {
#line 168
      goto while_break;
    }
    {
#line 169
    fs_write(*(lfn_offsets + i), (int )sizeof(LFN_ENT ), (void *)(& empty));
#line 168
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
void lfn_fix_checksum(loff_t from , loff_t to , char const   *short_name ) 
{ 
  int i ;
  __u8 sum ;

  {
#line 177
  sum = (__u8 )0;
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < 11)) {
#line 177
      goto while_break;
    }
#line 178
    sum = (__u8 )(((((int )sum & 1) << 7) | (((int )sum & 254) >> 1)) + (int )*(short_name + i));
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (from < to)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    fs_write((loff_t )((unsigned long )from + (unsigned long )(& ((LFN_ENT *)0)->alias_checksum)),
             (int )sizeof(sum), (void *)(& sum));
#line 180
    from = (loff_t )((unsigned long )from + sizeof(LFN_ENT ));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
void lfn_reset(void) 
{ 


  {
#line 187
  if (lfn_unicode) {
    {
#line 188
    free((void *)lfn_unicode);
    }
  }
#line 189
  lfn_unicode = (unsigned char *)((void *)0);
#line 190
  if (lfn_offsets) {
    {
#line 191
    free((void *)lfn_offsets);
    }
  }
#line 192
  lfn_offsets = (loff_t *)((void *)0);
#line 193
  lfn_slot = -1;
#line 194
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
void lfn_add_slot(DIR_ENT *de , loff_t dir_offset ) 
{ 
  LFN_ENT *lfn ;
  int slot ;
  unsigned int offset ;
  int can_clear ;
  char *part1 ;
  unsigned char __part_uni[26] ;
  char *tmp ;
  char *part2 ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *part ;
  unsigned char __part_uni___0[26] ;
  char *tmp___5 ;
  char tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  int can_fix ;
  char *part1___0 ;
  unsigned char __part_uni___1[26] ;
  char *tmp___11 ;
  char *part2___0 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  char tmp___18 ;
  int tmp___19 ;
  unsigned char tmp___20 ;
  int tmp___21 ;
  char tmp___22 ;
  char tmp___23 ;

  {
#line 200
  lfn = (LFN_ENT *)de;
#line 201
  slot = (int )lfn->id & 31;
#line 204
  if (lfn_slot == 0) {
    {
#line 205
    lfn_check_orphaned();
    }
  }
#line 207
  if ((int )de->attr != 15) {
    {
#line 208
    die((char *)"lfn_add_slot called with non-LFN directory entry");
    }
  }
#line 210
  if ((int )lfn->id & 64) {
#line 210
    if (slot != 0) {
#line 211
      if (lfn_slot != -1) {
        {
#line 212
        can_clear = 0;
#line 221
        printf((char const   */* __restrict  */)"A new long file name starts within an old one.\n");
        }
#line 222
        if (slot == lfn_slot) {
#line 222
          if ((int )lfn->alias_checksum == (int )lfn_checksum) {
            {
#line 223
            copy_lfn_part(__part_uni, lfn);
#line 223
            tmp = cnv_unicode((unsigned char const   *)(__part_uni), 13, 0);
#line 223
            part1 = tmp;
#line 224
            tmp___0 = cnv_unicode((unsigned char const   *)(lfn_unicode + (lfn_slot * 13) * 2),
                                  lfn_parts * 13, 0);
#line 224
            part2 = tmp___0;
#line 225
            printf((char const   */* __restrict  */)"  It could be that the LFN start bit is wrong here\n  if \"%s\" seems to match \"%s\".\n",
                   part1, part2);
#line 227
            free((void *)part1);
#line 228
            free((void *)part2);
#line 229
            can_clear = 1;
            }
          }
        }
#line 231
        if (interactive) {
          {
#line 232
          printf((char const   */* __restrict  */)"1: Delete previous LFN\n2: Leave it as it is.\n");
          }
#line 233
          if (can_clear) {
            {
#line 234
            printf((char const   */* __restrict  */)"3: Clear start bit and concatenate LFNs\n");
            }
          }
        } else {
          {
#line 236
          printf((char const   */* __restrict  */)"  Not auto-correcting this.\n");
          }
        }
#line 237
        if (interactive) {
#line 238
          if (can_clear) {
#line 238
            tmp___1 = "123";
          } else {
#line 238
            tmp___1 = "12";
          }
          {
#line 238
          tmp___2 = get_key((char *)tmp___1, (char *)"?");
          }
          {
#line 239
          if ((int )tmp___2 == 49) {
#line 239
            goto case_49;
          }
#line 243
          if ((int )tmp___2 == 50) {
#line 243
            goto case_50;
          }
#line 245
          if ((int )tmp___2 == 51) {
#line 245
            goto case_51;
          }
#line 238
          goto switch_break;
          case_49: /* CIL Label */ 
          {
#line 240
          clear_lfn_slots(0, lfn_parts - 1);
#line 241
          lfn_reset();
          }
#line 242
          goto switch_break;
          case_50: /* CIL Label */ 
#line 244
          goto switch_break;
          case_51: /* CIL Label */ 
          {
#line 246
          lfn->id = (__u8 )((int )lfn->id & -65);
#line 247
          fs_write((loff_t )((unsigned long )dir_offset + (unsigned long )(& ((LFN_ENT *)0)->id)),
                   (int )sizeof(lfn->id), (void *)(& lfn->id));
          }
#line 249
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
      {
#line 253
      lfn_slot = slot;
#line 254
      lfn_checksum = lfn->alias_checksum;
#line 255
      tmp___3 = alloc((lfn_slot * 13 + 1) * 2);
#line 255
      lfn_unicode = (unsigned char *)tmp___3;
#line 256
      tmp___4 = alloc((int )((unsigned long )lfn_slot * sizeof(loff_t )));
#line 256
      lfn_offsets = (loff_t *)tmp___4;
#line 257
      lfn_parts = 0;
      }
    } else {
#line 210
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 258
  if (lfn_slot == -1) {
#line 258
    if (slot != 0) {
      {
#line 263
      copy_lfn_part(__part_uni___0, lfn);
#line 263
      tmp___5 = cnv_unicode((unsigned char const   *)(__part_uni___0), 13, 0);
#line 263
      part = tmp___5;
#line 264
      printf((char const   */* __restrict  */)"Long filename fragment \"%s\" found outside a LFN sequence.\n  (Maybe the start bit is missing on the last fragment)\n",
             part);
      }
#line 267
      if (interactive) {
        {
#line 268
        printf((char const   */* __restrict  */)"1: Delete fragment\n2: Leave it as it is.\n3: Set start bit\n");
        }
      } else {
        {
#line 271
        printf((char const   */* __restrict  */)"  Not auto-correcting this.\n");
        }
      }
#line 272
      if (interactive) {
        {
#line 272
        tmp___6 = get_key((char *)"123", (char *)"?");
#line 272
        tmp___7 = (int )tmp___6;
        }
      } else {
#line 272
        tmp___7 = '2';
      }
      {
#line 273
      if (tmp___7 == 49) {
#line 273
        goto case_49___0;
      }
#line 280
      if (tmp___7 == 50) {
#line 280
        goto case_50___0;
      }
#line 283
      if (tmp___7 == 51) {
#line 283
        goto case_51___0;
      }
#line 272
      goto switch_break___0;
      case_49___0: /* CIL Label */ 
#line 274
      if (! lfn_offsets) {
        {
#line 275
        tmp___8 = alloc((int )sizeof(loff_t ));
#line 275
        lfn_offsets = (loff_t *)tmp___8;
        }
      }
      {
#line 276
      *(lfn_offsets + 0) = dir_offset;
#line 277
      clear_lfn_slots(0, 0);
#line 278
      lfn_reset();
      }
#line 279
      return;
      case_50___0: /* CIL Label */ 
      {
#line 281
      lfn_reset();
      }
#line 282
      return;
      case_51___0: /* CIL Label */ 
      {
#line 284
      lfn->id = (__u8 )((int )lfn->id | 64);
#line 285
      fs_write((loff_t )((unsigned long )dir_offset + (unsigned long )(& ((LFN_ENT *)0)->id)),
               (int )sizeof(lfn->id), (void *)(& lfn->id));
#line 287
      lfn_slot = slot;
#line 288
      lfn_checksum = lfn->alias_checksum;
#line 289
      tmp___9 = alloc((lfn_slot * 13 + 1) * 2);
#line 289
      lfn_unicode = (unsigned char *)tmp___9;
#line 290
      tmp___10 = alloc((int )((unsigned long )lfn_slot * sizeof(loff_t )));
#line 290
      lfn_offsets = (loff_t *)tmp___10;
#line 291
      lfn_parts = 0;
      }
#line 292
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
#line 258
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 294
  if (slot != lfn_slot) {
    {
#line 300
    can_fix = 0;
#line 301
    printf((char const   */* __restrict  */)"Unexpected long filename sequence number (%d vs. expected %d).\n",
           slot, lfn_slot);
    }
#line 303
    if ((int )lfn->alias_checksum == (int )lfn_checksum) {
#line 303
      if (lfn_slot > 0) {
        {
#line 304
        copy_lfn_part(__part_uni___1, lfn);
#line 304
        tmp___11 = cnv_unicode((unsigned char const   *)(__part_uni___1), 13, 0);
#line 304
        part1___0 = tmp___11;
#line 305
        tmp___12 = cnv_unicode((unsigned char const   *)(lfn_unicode + (lfn_slot * 13) * 2),
                               lfn_parts * 13, 0);
#line 305
        part2___0 = tmp___12;
#line 306
        printf((char const   */* __restrict  */)"  It could be that just the number is wrong\n  if \"%s\" seems to match \"%s\".\n",
               part1___0, part2___0);
#line 308
        free((void *)part1___0);
#line 309
        free((void *)part2___0);
#line 310
        can_fix = 1;
        }
      }
    }
#line 312
    if (interactive) {
      {
#line 313
      printf((char const   */* __restrict  */)"1: Delete LFN\n2: Leave it as it is (and ignore LFN so far)\n");
      }
#line 315
      if (can_fix) {
        {
#line 316
        printf((char const   */* __restrict  */)"3: Correct sequence number\n");
        }
      }
    } else {
      {
#line 318
      printf((char const   */* __restrict  */)"  Not auto-correcting this.\n");
      }
    }
#line 319
    if (interactive) {
#line 319
      if (can_fix) {
#line 319
        tmp___13 = "123";
      } else {
#line 319
        tmp___13 = "12";
      }
      {
#line 319
      tmp___14 = get_key((char *)tmp___13, (char *)"?");
#line 319
      tmp___15 = (int )tmp___14;
      }
    } else {
#line 319
      tmp___15 = '2';
    }
    {
#line 320
    if (tmp___15 == 49) {
#line 320
      goto case_49___1;
    }
#line 329
    if (tmp___15 == 50) {
#line 329
      goto case_50___1;
    }
#line 332
    if (tmp___15 == 51) {
#line 332
      goto case_51___1;
    }
#line 319
    goto switch_break___1;
    case_49___1: /* CIL Label */ 
#line 321
    if (! lfn_offsets) {
      {
#line 322
      tmp___16 = alloc((int )sizeof(loff_t ));
#line 322
      lfn_offsets = (loff_t *)tmp___16;
#line 323
      lfn_parts = 0;
      }
    }
    {
#line 325
    tmp___17 = lfn_parts;
#line 325
    lfn_parts ++;
#line 325
    *(lfn_offsets + tmp___17) = dir_offset;
#line 326
    clear_lfn_slots(0, lfn_parts - 1);
#line 327
    lfn_reset();
    }
#line 328
    return;
    case_50___1: /* CIL Label */ 
    {
#line 330
    lfn_reset();
    }
#line 331
    return;
    case_51___1: /* CIL Label */ 
    {
#line 333
    lfn->id = (__u8 )(((int )lfn->id & -32) | lfn_slot);
#line 334
    fs_write((loff_t )((unsigned long )dir_offset + (unsigned long )(& ((LFN_ENT *)0)->id)),
             (int )sizeof(lfn->id), (void *)(& lfn->id));
    }
#line 336
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 340
  if ((int )lfn->alias_checksum != (int )lfn_checksum) {
    {
#line 344
    printf((char const   */* __restrict  */)"Checksum in long filename part wrong (%02x vs. expected %02x).\n",
           (int )lfn->alias_checksum, (int )lfn_checksum);
    }
#line 347
    if (interactive) {
      {
#line 348
      printf((char const   */* __restrict  */)"1: Delete LFN\n2: Leave it as it is.\n3: Correct checksum\n");
      }
    } else {
      {
#line 351
      printf((char const   */* __restrict  */)"  Not auto-correcting this.\n");
      }
    }
#line 352
    if (interactive) {
      {
#line 353
      tmp___18 = get_key((char *)"123", (char *)"?");
      }
      {
#line 354
      if ((int )tmp___18 == 49) {
#line 354
        goto case_49___2;
      }
#line 359
      if ((int )tmp___18 == 50) {
#line 359
        goto case_50___2;
      }
#line 361
      if ((int )tmp___18 == 51) {
#line 361
        goto case_51___2;
      }
#line 353
      goto switch_break___2;
      case_49___2: /* CIL Label */ 
      {
#line 355
      tmp___19 = lfn_parts;
#line 355
      lfn_parts ++;
#line 355
      *(lfn_offsets + tmp___19) = dir_offset;
#line 356
      clear_lfn_slots(0, lfn_parts - 1);
#line 357
      lfn_reset();
      }
#line 358
      return;
      case_50___2: /* CIL Label */ 
#line 360
      goto switch_break___2;
      case_51___2: /* CIL Label */ 
      {
#line 362
      lfn->alias_checksum = lfn_checksum;
#line 363
      fs_write((loff_t )((unsigned long )dir_offset + (unsigned long )(& ((LFN_ENT *)0)->alias_checksum)),
               (int )sizeof(lfn->alias_checksum), (void *)(& lfn->alias_checksum));
      }
#line 365
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
  }
#line 370
  if (lfn_slot != -1) {
    {
#line 371
    lfn_slot --;
#line 372
    offset = (unsigned int )((lfn_slot * 13) * 2);
#line 373
    copy_lfn_part(lfn_unicode + offset, lfn);
    }
#line 374
    if ((int )lfn->id & 64) {
#line 375
      tmp___20 = (unsigned char)0;
#line 375
      *(lfn_unicode + (offset + 27U)) = tmp___20;
#line 375
      *(lfn_unicode + (offset + 26U)) = tmp___20;
    }
#line 376
    tmp___21 = lfn_parts;
#line 376
    lfn_parts ++;
#line 376
    *(lfn_offsets + tmp___21) = dir_offset;
  }
#line 379
  if ((int )lfn->reserved != 0) {
    {
#line 380
    printf((char const   */* __restrict  */)"Reserved field in VFAT long filename slot is not 0 (but 0x%02x).\n",
           (int )lfn->reserved);
    }
#line 382
    if (interactive) {
      {
#line 383
      printf((char const   */* __restrict  */)"1: Fix.\n2: Leave it.\n");
      }
    } else {
      {
#line 385
      printf((char const   */* __restrict  */)"Auto-setting to 0.\n");
      }
    }
#line 386
    if (! interactive) {
      {
#line 387
      lfn->reserved = (__u8 )0;
#line 388
      fs_write((loff_t )((unsigned long )dir_offset + (unsigned long )(& ((LFN_ENT *)0)->reserved)),
               (int )sizeof(lfn->reserved), (void *)(& lfn->reserved));
      }
    } else {
      {
#line 386
      tmp___22 = get_key((char *)"12", (char *)"?");
      }
#line 386
      if ((int )tmp___22 == 49) {
        {
#line 387
        lfn->reserved = (__u8 )0;
#line 388
        fs_write((loff_t )((unsigned long )dir_offset + (unsigned long )(& ((LFN_ENT *)0)->reserved)),
                 (int )sizeof(lfn->reserved), (void *)(& lfn->reserved));
        }
      }
    }
  }
#line 392
  if ((int )lfn->start != 0) {
    {
#line 393
    printf((char const   */* __restrict  */)"Start cluster field in VFAT long filename slot is not 0 (but 0x%04x).\n",
           (int )lfn->start);
    }
#line 395
    if (interactive) {
      {
#line 396
      printf((char const   */* __restrict  */)"1: Fix.\n2: Leave it.\n");
      }
    } else {
      {
#line 398
      printf((char const   */* __restrict  */)"Auto-setting to 0.\n");
      }
    }
#line 399
    if (! interactive) {
      {
#line 400
      lfn->start = (__u16 )0;
#line 401
      fs_write((loff_t )((unsigned long )dir_offset + (unsigned long )(& ((LFN_ENT *)0)->start)),
               (int )sizeof(lfn->start), (void *)(& lfn->start));
      }
    } else {
      {
#line 399
      tmp___23 = get_key((char *)"12", (char *)"?");
      }
#line 399
      if ((int )tmp___23 == 49) {
        {
#line 400
        lfn->start = (__u16 )0;
#line 401
        fs_write((loff_t )((unsigned long )dir_offset + (unsigned long )(& ((LFN_ENT *)0)->start)),
                 (int )sizeof(lfn->start), (void *)(& lfn->start));
        }
      }
    }
  }
#line 405
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
char *lfn_get(DIR_ENT *de , loff_t *lfn_offset ) 
{ 
  char *lfn ;
  __u8 sum ;
  int i ;
  char *long_name ;
  char *tmp ;
  char *short_name ;
  char *tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;
  __u8 id ;
  int tmp___3 ;
  char *long_name___0 ;
  char *tmp___4 ;
  char *short_name___0 ;
  char *tmp___5 ;
  char tmp___6 ;

  {
#line 415
  *lfn_offset = (loff_t )0;
#line 416
  if ((int )de->attr == 15) {
    {
#line 417
    die((char *)"lfn_get called with LFN directory entry");
    }
  }
#line 424
  if (lfn_slot == -1) {
#line 426
    return ((char *)((void *)0));
  }
#line 428
  if (lfn_slot != 0) {
    {
#line 434
    tmp = cnv_unicode((unsigned char const   *)(lfn_unicode + (lfn_slot * 13) * 2),
                      lfn_parts * 13, 0);
#line 434
    long_name = tmp;
#line 435
    tmp___0 = file_name(de->name);
#line 435
    short_name = tmp___0;
#line 436
    printf((char const   */* __restrict  */)"Unfinished long file name \"%s\".\n  (Start may have been overwritten by %s)\n",
           long_name, short_name);
#line 439
    free((void *)long_name);
    }
#line 440
    if (interactive) {
      {
#line 441
      printf((char const   */* __restrict  */)"1: Delete LFN\n2: Leave it as it is.\n3: Fix numbering (truncates long name and attaches it to short name %s)\n",
             short_name);
      }
    } else {
      {
#line 445
      printf((char const   */* __restrict  */)"  Not auto-correcting this.\n");
      }
    }
#line 446
    if (interactive) {
      {
#line 446
      tmp___1 = get_key((char *)"123", (char *)"?");
#line 446
      tmp___2 = (int )tmp___1;
      }
    } else {
#line 446
      tmp___2 = '2';
    }
    {
#line 447
    if (tmp___2 == 49) {
#line 447
      goto case_49;
    }
#line 451
    if (tmp___2 == 50) {
#line 451
      goto case_50;
    }
#line 454
    if (tmp___2 == 51) {
#line 454
      goto case_51;
    }
#line 446
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 448
    clear_lfn_slots(0, lfn_parts - 1);
#line 449
    lfn_reset();
    }
#line 450
    return ((char *)((void *)0));
    case_50: /* CIL Label */ 
    {
#line 452
    lfn_reset();
    }
#line 453
    return ((char *)((void *)0));
    case_51: /* CIL Label */ 
#line 455
    i = 0;
    {
#line 455
    while (1) {
      while_continue: /* CIL Label */ ;
#line 455
      if (! (i < lfn_parts)) {
#line 455
        goto while_break;
      }
#line 456
      if (i == 0) {
#line 456
        tmp___3 = 64;
      } else {
#line 456
        tmp___3 = 0;
      }
      {
#line 456
      id = (__u8 )((lfn_parts - i) | tmp___3);
#line 457
      fs_write((loff_t )((unsigned long )*(lfn_offsets + i) + (unsigned long )(& ((LFN_ENT *)0)->id)),
               (int )sizeof(id), (void *)(& id));
#line 455
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 460
    memmove((void *)lfn_unicode, (void const   *)(lfn_unicode + (lfn_slot * 13) * 2),
            (size_t )((lfn_parts * 13) * 2));
    }
#line 462
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 466
  sum = (__u8 )0;
#line 466
  i = 0;
  {
#line 466
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 466
    if (! (i < 8)) {
#line 466
      goto while_break___0;
    }
#line 467
    sum = (__u8 )(((((int )sum & 1) << 7) | (((int )sum & 254) >> 1)) + (int )de->name[i]);
#line 466
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 468
  i = 0;
  {
#line 468
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 468
    if (! (i < 3)) {
#line 468
      goto while_break___1;
    }
#line 469
    sum = (__u8 )(((((int )sum & 1) << 7) | (((int )sum & 254) >> 1)) + (int )de->ext[i]);
#line 468
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 470
  if ((int )sum != (int )lfn_checksum) {
    {
#line 474
    tmp___4 = cnv_unicode((unsigned char const   *)(lfn_unicode + (lfn_slot * 13) * 2),
                          lfn_parts * 13, 0);
#line 474
    long_name___0 = tmp___4;
#line 475
    tmp___5 = file_name(de->name);
#line 475
    short_name___0 = tmp___5;
#line 476
    printf((char const   */* __restrict  */)"Wrong checksum for long file name \"%s\".\n  (Short name %s may have changed without updating the long name)\n",
           long_name___0, short_name___0);
#line 479
    free((void *)long_name___0);
    }
#line 480
    if (interactive) {
      {
#line 481
      printf((char const   */* __restrict  */)"1: Delete LFN\n2: Leave it as it is.\n3: Fix checksum (attaches to short name %s)\n",
             short_name___0);
      }
    } else {
      {
#line 484
      printf((char const   */* __restrict  */)"  Not auto-correcting this.\n");
      }
    }
#line 485
    if (interactive) {
      {
#line 486
      tmp___6 = get_key((char *)"123", (char *)"?");
      }
      {
#line 487
      if ((int )tmp___6 == 49) {
#line 487
        goto case_49___0;
      }
#line 491
      if ((int )tmp___6 == 50) {
#line 491
        goto case_50___0;
      }
#line 494
      if ((int )tmp___6 == 51) {
#line 494
        goto case_51___0;
      }
#line 486
      goto switch_break___0;
      case_49___0: /* CIL Label */ 
      {
#line 488
      clear_lfn_slots(0, lfn_parts - 1);
#line 489
      lfn_reset();
      }
#line 490
      return ((char *)((void *)0));
      case_50___0: /* CIL Label */ 
      {
#line 492
      lfn_reset();
      }
#line 493
      return ((char *)((void *)0));
      case_51___0: /* CIL Label */ 
#line 495
      i = 0;
      {
#line 495
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 495
        if (! (i < lfn_parts)) {
#line 495
          goto while_break___2;
        }
        {
#line 496
        fs_write((loff_t )((unsigned long )*(lfn_offsets + i) + (unsigned long )(& ((LFN_ENT *)0)->alias_checksum)),
                 (int )sizeof(sum), (void *)(& sum));
#line 495
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 499
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 504
  *lfn_offset = *(lfn_offsets + 0);
#line 505
  lfn = cnv_unicode((unsigned char const   *)lfn_unicode, 2147483647, 1);
#line 506
  lfn_reset();
  }
#line 507
  return (lfn);
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
void lfn_check_orphaned(void) 
{ 
  char *long_name ;
  char tmp ;

  {
#line 514
  if (lfn_slot == -1) {
#line 515
    return;
  }
  {
#line 517
  long_name = cnv_unicode((unsigned char const   *)(lfn_unicode + (lfn_slot * 13) * 2),
                          lfn_parts * 13, 0);
#line 518
  printf((char const   */* __restrict  */)"Orphaned long file name part \"%s\"\n",
         long_name);
  }
#line 519
  if (interactive) {
    {
#line 520
    printf((char const   */* __restrict  */)"1: Delete.\n2: Leave it.\n");
    }
  } else {
    {
#line 522
    printf((char const   */* __restrict  */)"  Auto-deleting.\n");
    }
  }
#line 523
  if (! interactive) {
    {
#line 524
    clear_lfn_slots(0, lfn_parts - 1);
    }
  } else {
    {
#line 523
    tmp = get_key((char *)"12", (char *)"?");
    }
#line 523
    if ((int )tmp == 49) {
      {
#line 524
      clear_lfn_slots(0, lfn_parts - 1);
      }
    }
  }
  {
#line 526
  lfn_reset();
  }
#line 527
  return;
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 178 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
int rw ;
#line 26 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.h"
void read_fat(DOS_FS *fs ) ;
#line 31
void get_fat(FAT_ENTRY *entry , void *fat___0 , uint32_t cluster , DOS_FS *fs ) ;
#line 35
void set_fat(DOS_FS *fs , uint32_t cluster , int32_t new ) ;
#line 41
int bad_cluster(DOS_FS *fs , uint32_t cluster ) ;
#line 56
void set_owner(DOS_FS *fs , uint32_t cluster , DOS_FILE *owner ) ;
#line 62
DOS_FILE *get_owner(DOS_FS *fs , uint32_t cluster ) ;
#line 67
void fix_bad(DOS_FS *fs ) ;
#line 71
void reclaim_free(DOS_FS *fs ) ;
#line 75
void reclaim_file(DOS_FS *fs ) ;
#line 81
uint32_t update_free(DOS_FS *fs ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
void get_fat(FAT_ENTRY *entry , void *fat___0 , uint32_t cluster , DOS_FS *fs ) 
{ 
  unsigned char *ptr ;
  int tmp ;
  uint32_t e ;

  {
  {
#line 51
  if (fs->fat_bits == 12U) {
#line 51
    goto case_12;
  }
#line 56
  if (fs->fat_bits == 16U) {
#line 56
    goto case_16;
  }
#line 59
  if (fs->fat_bits == 32U) {
#line 59
    goto case_32;
  }
#line 68
  goto switch_default;
  case_12: /* CIL Label */ 
#line 52
  ptr = (unsigned char *)fat___0 + (cluster * 3U) / 2U;
#line 53
  if (cluster & 1U) {
#line 53
    tmp = ((int )*(ptr + 0) >> 4) | ((int )*(ptr + 1) << 4);
  } else {
#line 53
    tmp = (int )*(ptr + 0) | ((int )*(ptr + 1) << 8);
  }
#line 53
  entry->value = (uint32_t )(4095 & tmp);
#line 55
  goto switch_break;
  case_16: /* CIL Label */ 
#line 57
  entry->value = (uint32_t )*((unsigned short *)fat___0 + cluster);
#line 58
  goto switch_break;
  case_32: /* CIL Label */ 
#line 63
  e = *((unsigned int *)fat___0 + cluster);
#line 64
  entry->value = e & 268435455U;
#line 65
  entry->reserved = e >> 28;
#line 67
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 69
  die((char *)"Bad FAT entry size: %d bits.", fs->fat_bits);
  }
  switch_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
void read_fat(DOS_FS *fs ) 
{ 
  int eff_size ;
  uint32_t i ;
  void *first ;
  void *second ;
  int first_ok ;
  int second_ok ;
  uint32_t total_num_clusters ;
  FAT_ENTRY first_media ;
  FAT_ENTRY second_media ;
  char tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  FAT_ENTRY curEntry ;
  int tmp___2 ;

  {
#line 85
  second = (void *)0;
#line 90
  if (fs->fat) {
    {
#line 91
    free((void *)fs->fat);
    }
  }
#line 92
  if (fs->cluster_owner) {
    {
#line 93
    free((void *)fs->cluster_owner);
    }
  }
  {
#line 94
  fs->fat = (unsigned char *)((void *)0);
#line 95
  fs->cluster_owner = (DOS_FILE **)((void *)0);
#line 97
  total_num_clusters = (uint32_t )((unsigned long )fs->clusters + 2UL);
#line 98
  eff_size = (int )((unsigned long long )(total_num_clusters * fs->fat_bits + 7U) / 8ULL);
#line 99
  first = alloc(eff_size);
#line 100
  fs_read(fs->fat_start, eff_size, first);
  }
#line 101
  if (fs->nfats > 1) {
    {
#line 102
    second = alloc(eff_size);
#line 103
    fs_read(fs->fat_start + (loff_t )fs->fat_size, eff_size, second);
    }
  }
#line 105
  if (second) {
    {
#line 105
    tmp___0 = memcmp((void const   *)first, (void const   *)second, (size_t )eff_size);
    }
#line 105
    if (tmp___0 != 0) {
      {
#line 107
      get_fat(& first_media, first, (uint32_t )0, fs);
#line 108
      get_fat(& second_media, second, (uint32_t )0, fs);
#line 109
      first_ok = (first_media.value & (unsigned int )(((1 << fs->eff_fat_bits) - 1) & -16)) == (unsigned int )(((1 << fs->eff_fat_bits) - 1) & -16);
#line 110
      second_ok = (second_media.value & (unsigned int )(((1 << fs->eff_fat_bits) - 1) & -16)) == (unsigned int )(((1 << fs->eff_fat_bits) - 1) & -16);
      }
#line 111
      if (first_ok) {
#line 111
        if (! second_ok) {
          {
#line 112
          printf((char const   */* __restrict  */)"FATs differ - using first FAT.\n");
#line 113
          fs_write(fs->fat_start + (loff_t )fs->fat_size, eff_size, first);
          }
        }
      }
#line 115
      if (! first_ok) {
#line 115
        if (second_ok) {
          {
#line 116
          printf((char const   */* __restrict  */)"FATs differ - using second FAT.\n");
#line 117
          fs_write(fs->fat_start, eff_size, second);
#line 118
          memcpy((void */* __restrict  */)first, (void const   */* __restrict  */)second,
                 (size_t )eff_size);
          }
        }
      }
#line 120
      if (first_ok) {
#line 120
        if (second_ok) {
#line 121
          if (interactive) {
            {
#line 122
            printf((char const   */* __restrict  */)"FATs differ but appear to be intact. Use which FAT ?\n1) Use first FAT\n2) Use second FAT\n");
#line 124
            tmp = get_key((char *)"12", (char *)"?");
            }
#line 124
            if ((int )tmp == 49) {
              {
#line 125
              fs_write(fs->fat_start + (loff_t )fs->fat_size, eff_size, first);
              }
            } else {
              {
#line 127
              fs_write(fs->fat_start, eff_size, second);
#line 128
              memcpy((void */* __restrict  */)first, (void const   */* __restrict  */)second,
                     (size_t )eff_size);
              }
            }
          } else {
            {
#line 131
            printf((char const   */* __restrict  */)"FATs differ but appear to be intact. Using first FAT.\n");
#line 133
            fs_write(fs->fat_start + (loff_t )fs->fat_size, eff_size, first);
            }
          }
        }
      }
#line 136
      if (! first_ok) {
#line 136
        if (! second_ok) {
          {
#line 137
          printf((char const   */* __restrict  */)"Both FATs appear to be corrupt. Giving up.\n");
#line 138
          exit(1);
          }
        }
      }
    }
  }
#line 141
  if (second) {
    {
#line 142
    free(second);
    }
  }
  {
#line 144
  fs->fat = (unsigned char *)first;
#line 146
  tmp___1 = alloc((int )((unsigned long )total_num_clusters * sizeof(DOS_FILE *)));
#line 146
  fs->cluster_owner = (DOS_FILE **)tmp___1;
#line 147
  memset((void *)fs->cluster_owner, 0, (unsigned long )total_num_clusters * sizeof(DOS_FILE *));
#line 150
  i = (uint32_t )2;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i < fs->clusters + 2U)) {
#line 150
      goto while_break;
    }
    {
#line 152
    get_fat(& curEntry, (void *)fs->fat, i, fs);
    }
#line 153
    if (curEntry.value == 1U) {
      {
#line 154
      printf((char const   */* __restrict  */)"Cluster %ld out of range (1). Setting to EOF.\n",
             (long )(i - 2U));
#line 155
      set_fat(fs, i, -1);
      }
    }
#line 157
    if (curEntry.value >= fs->clusters + 2U) {
#line 157
      if (atari_format) {
#line 157
        tmp___2 = 4080;
      } else {
#line 157
        tmp___2 = 4087;
      }
#line 157
      if (curEntry.value < (uint32_t )(tmp___2 | (((1 << fs->eff_fat_bits) - 1) & -16))) {
        {
#line 159
        printf((char const   */* __restrict  */)"Cluster %ld out of range (%ld > %ld). Setting to EOF.\n",
               (long )(i - 2U), (long )curEntry.value, (long )((fs->clusters + 2U) - 1U));
#line 161
        set_fat(fs, i, -1);
        }
      }
    }
#line 150
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
void set_fat(DOS_FS *fs , uint32_t cluster , int32_t new ) 
{ 
  unsigned char *data ;
  int size ;
  loff_t offs ;
  int tmp ;
  FAT_ENTRY prevEntry ;
  FAT_ENTRY subseqEntry ;
  unsigned int tmp___0 ;
  FAT_ENTRY curEntry ;

  {
#line 181
  data = (unsigned char *)((void *)0);
#line 185
  if (new == -1) {
#line 186
    if (atari_format) {
#line 186
      tmp = 4095;
    } else {
#line 186
      tmp = 4088;
    }
#line 186
    new = tmp | (((1 << fs->eff_fat_bits) - 1) & -16);
  } else
#line 187
  if ((long )new == -2L) {
#line 188
    new = 4087 | (((1 << fs->eff_fat_bits) - 1) & -16);
  }
  {
#line 190
  if (fs->fat_bits == 12U) {
#line 190
    goto case_12;
  }
#line 207
  if (fs->fat_bits == 16U) {
#line 207
    goto case_16;
  }
#line 213
  if (fs->fat_bits == 32U) {
#line 213
    goto case_32;
  }
#line 227
  goto switch_default;
  case_12: /* CIL Label */ 
#line 191
  data = fs->fat + (cluster * 3U) / 2U;
#line 192
  offs = fs->fat_start + (loff_t )((cluster * 3U) / 2U);
#line 193
  if (cluster & 1U) {
    {
#line 195
    get_fat(& prevEntry, (void *)fs->fat, cluster - 1U, fs);
#line 196
    *(data + 0) = (unsigned char )((unsigned int )((new & 15) << 4) | (prevEntry.value >> 8));
#line 197
    *(data + 1) = (unsigned char )(new >> 4);
    }
  } else {
    {
#line 200
    get_fat(& subseqEntry, (void *)fs->fat, cluster + 1U, fs);
#line 201
    *(data + 0) = (unsigned char )(new & 255);
    }
#line 202
    if (cluster == fs->clusters - 1U) {
#line 202
      tmp___0 = 0U;
    } else {
#line 202
      tmp___0 = (255U & subseqEntry.value) << 4;
    }
#line 202
    *(data + 1) = (unsigned char )((unsigned int )(new >> 8) | tmp___0);
  }
#line 205
  size = 2;
#line 206
  goto switch_break;
  case_16: /* CIL Label */ 
#line 208
  data = fs->fat + cluster * 2U;
#line 209
  offs = fs->fat_start + (loff_t )(cluster * 2U);
#line 210
  *((unsigned short *)data) = (unsigned short )new;
#line 211
  size = 2;
#line 212
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 216
  get_fat(& curEntry, (void *)fs->fat, cluster, fs);
#line 218
  data = fs->fat + cluster * 4U;
#line 219
  offs = fs->fat_start + (loff_t )(cluster * 4U);
#line 222
  *((uint32_t *)data) = (unsigned int )(new & 268435455) | (curEntry.reserved << 28);
#line 224
  size = 4;
  }
#line 226
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 228
  die((char *)"Bad FAT entry size: %d bits.", fs->fat_bits);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 230
  fs_write(offs, size, (void *)data);
  }
#line 231
  if (fs->nfats > 1) {
    {
#line 232
    fs_write(offs + (loff_t )fs->fat_size, size, (void *)data);
    }
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
int bad_cluster(DOS_FS *fs , uint32_t cluster ) 
{ 
  FAT_ENTRY curEntry ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 239
  get_fat(& curEntry, (void *)fs->fat, cluster, fs);
  }
#line 241
  if (atari_format) {
#line 241
    tmp = 4080;
  } else {
#line 241
    tmp = 4087;
  }
#line 241
  if (curEntry.value >= (uint32_t )(tmp | (((1 << fs->eff_fat_bits) - 1) & -16))) {
#line 241
    if (atari_format) {
#line 241
      tmp___0 = 4087;
    } else {
#line 241
      tmp___0 = 4087;
    }
#line 241
    if (curEntry.value <= (uint32_t )(tmp___0 | (((1 << fs->eff_fat_bits) - 1) & -16))) {
#line 241
      tmp___1 = 1;
    } else {
#line 241
      tmp___1 = 0;
    }
  } else {
#line 241
    tmp___1 = 0;
  }
#line 241
  return (tmp___1);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
uint32_t next_cluster(DOS_FS *fs , uint32_t cluster ) 
{ 
  uint32_t value ;
  FAT_ENTRY curEntry ;
  int tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;

  {
  {
#line 259
  get_fat(& curEntry, (void *)fs->fat, cluster, fs);
#line 261
  value = curEntry.value;
  }
#line 262
  if (atari_format) {
#line 262
    tmp = 4080;
  } else {
#line 262
    tmp = 4087;
  }
#line 262
  if (value >= (uint32_t )(tmp | (((1 << fs->eff_fat_bits) - 1) & -16))) {
#line 262
    if (atari_format) {
#line 262
      tmp___0 = 4087;
    } else {
#line 262
      tmp___0 = 4087;
    }
#line 262
    if (value <= (uint32_t )(tmp___0 | (((1 << fs->eff_fat_bits) - 1) & -16))) {
      {
#line 263
      die((char *)"Internal error: next_cluster on bad cluster");
      }
    }
  }
#line 264
  if (value >= (uint32_t )(4088 | (((1 << fs->eff_fat_bits) - 1) & -16))) {
#line 264
    tmp___1 = (uint32_t )-1;
  } else {
#line 264
    tmp___1 = value;
  }
#line 264
  return (tmp___1);
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
loff_t cluster_start(DOS_FS *fs , uint32_t cluster ) 
{ 


  {
#line 269
  return ((loff_t )((uint64_t )fs->data_start + (uint64_t )((loff_t )cluster - 2L) * (uint64_t )fs->cluster_size));
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
void set_owner(DOS_FS *fs , uint32_t cluster , DOS_FILE *owner ) 
{ 


  {
#line 284
  if ((unsigned long )fs->cluster_owner == (unsigned long )((void *)0)) {
    {
#line 285
    die((char *)"Internal error: attempt to set owner in non-existent table");
    }
  }
#line 287
  if (owner) {
#line 287
    if (*(fs->cluster_owner + cluster)) {
#line 287
      if ((unsigned long )*(fs->cluster_owner + cluster) != (unsigned long )owner) {
        {
#line 289
        die((char *)"Internal error: attempt to change file owner");
        }
      }
    }
  }
#line 290
  *(fs->cluster_owner + cluster) = owner;
#line 291
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
DOS_FILE *get_owner(DOS_FS *fs , uint32_t cluster ) 
{ 


  {
#line 295
  if ((unsigned long )fs->cluster_owner == (unsigned long )((void *)0)) {
#line 296
    return ((DOS_FILE *)((void *)0));
  } else {
#line 298
    return (*(fs->cluster_owner + cluster));
  }
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
void fix_bad(DOS_FS *fs ) 
{ 
  uint32_t i ;
  FAT_ENTRY curEntry ;
  loff_t tmp ;
  int tmp___0 ;
  DOS_FILE *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 305
  if (verbose) {
    {
#line 306
    printf((char const   */* __restrict  */)"Checking for bad clusters.\n");
    }
  }
#line 307
  i = (uint32_t )2;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! (i < fs->clusters + 2U)) {
#line 307
      goto while_break;
    }
    {
#line 309
    get_fat(& curEntry, (void *)fs->fat, i, fs);
#line 311
    tmp___1 = get_owner(fs, i);
    }
#line 311
    if (! tmp___1) {
#line 311
      if (atari_format) {
#line 311
        tmp___2 = 4080;
      } else {
#line 311
        tmp___2 = 4087;
      }
#line 311
      if (curEntry.value >= (uint32_t )(tmp___2 | (((1 << fs->eff_fat_bits) - 1) & -16))) {
#line 311
        if (atari_format) {
#line 311
          tmp___3 = 4087;
        } else {
#line 311
          tmp___3 = 4087;
        }
#line 311
        if (! (curEntry.value <= (uint32_t )(tmp___3 | (((1 << fs->eff_fat_bits) - 1) & -16)))) {
#line 311
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 312
        tmp = cluster_start(fs, i);
#line 312
        tmp___0 = fs_test(tmp, (int )fs->cluster_size);
        }
#line 312
        if (! tmp___0) {
          {
#line 313
          printf((char const   */* __restrict  */)"Cluster %lu is unreadable.\n",
                 (unsigned long )i);
#line 314
          set_fat(fs, i, -2);
          }
        }
      }
    }
#line 307
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return;
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
void reclaim_free(DOS_FS *fs ) 
{ 
  int reclaimed ;
  uint32_t i ;
  FAT_ENTRY curEntry ;
  DOS_FILE *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 324
  if (verbose) {
    {
#line 325
    printf((char const   */* __restrict  */)"Checking for unused clusters.\n");
    }
  }
#line 326
  reclaimed = 0;
#line 327
  i = (uint32_t )2;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (i < fs->clusters + 2U)) {
#line 327
      goto while_break;
    }
    {
#line 329
    get_fat(& curEntry, (void *)fs->fat, i, fs);
#line 331
    tmp = get_owner(fs, i);
    }
#line 331
    if (! tmp) {
#line 331
      if (curEntry.value) {
#line 331
        if (atari_format) {
#line 331
          tmp___0 = 4080;
        } else {
#line 331
          tmp___0 = 4087;
        }
#line 331
        if (curEntry.value >= (uint32_t )(tmp___0 | (((1 << fs->eff_fat_bits) - 1) & -16))) {
#line 331
          if (atari_format) {
#line 331
            tmp___1 = 4087;
          } else {
#line 331
            tmp___1 = 4087;
          }
#line 331
          if (! (curEntry.value <= (uint32_t )(tmp___1 | (((1 << fs->eff_fat_bits) - 1) & -16)))) {
            {
#line 333
            set_fat(fs, i, 0);
#line 334
            reclaimed ++;
            }
          }
        } else {
          {
#line 333
          set_fat(fs, i, 0);
#line 334
          reclaimed ++;
          }
        }
      }
    }
#line 327
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  if (reclaimed) {
#line 338
    if (reclaimed == 1) {
#line 338
      tmp___2 = "";
    } else {
#line 338
      tmp___2 = "s";
    }
    {
#line 338
    printf((char const   */* __restrict  */)"Reclaimed %d unused cluster%s (%llu bytes).\n",
           reclaimed, tmp___2, (unsigned long long )reclaimed * (unsigned long long )fs->cluster_size);
    }
  }
#line 341
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
static void tag_free(DOS_FS *fs , DOS_FILE *owner , uint32_t *num_refs , uint32_t start_cluster ) 
{ 
  int prev ;
  uint32_t i ;
  uint32_t walk ;
  FAT_ENTRY curEntry ;
  DOS_FILE *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  DOS_FILE *tmp___2 ;

  {
#line 359
  if (start_cluster == 0U) {
#line 360
    start_cluster = (uint32_t )2;
  }
#line 362
  i = start_cluster;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! (i < fs->clusters + 2U)) {
#line 362
      goto while_break;
    }
    {
#line 364
    get_fat(& curEntry, (void *)fs->fat, i, fs);
    }
#line 367
    if (curEntry.value) {
#line 367
      if (atari_format) {
#line 367
        tmp___0 = 4080;
      } else {
#line 367
        tmp___0 = 4087;
      }
#line 367
      if (curEntry.value >= (uint32_t )(tmp___0 | (((1 << fs->eff_fat_bits) - 1) & -16))) {
#line 367
        if (atari_format) {
#line 367
          tmp___1 = 4087;
        } else {
#line 367
          tmp___1 = 4087;
        }
#line 367
        if (! (curEntry.value <= (uint32_t )(tmp___1 | (((1 << fs->eff_fat_bits) - 1) & -16)))) {
#line 367
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 367
        tmp___2 = get_owner(fs, i);
        }
#line 367
        if (! tmp___2) {
#line 367
          if (! *(num_refs + i)) {
#line 369
            prev = 0;
#line 371
            walk = i;
            {
#line 371
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 371
              if (! (walk != 4294967295U)) {
#line 371
                goto while_break___0;
              }
              {
#line 372
              tmp = get_owner(fs, walk);
              }
#line 372
              if (tmp) {
                {
#line 379
                set_fat(fs, (uint32_t )prev, -1);
#line 387
                (*(num_refs + walk)) --;
                }
#line 388
                goto while_break___0;
              } else {
                {
#line 373
                set_owner(fs, walk, owner);
                }
              }
              {
#line 390
              prev = (int )walk;
#line 371
              walk = next_cluster(fs, walk);
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 362
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  return;
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
void reclaim_file(DOS_FS *fs ) 
{ 
  DOS_FILE orphan ;
  int reclaimed ;
  int files ;
  int changed ;
  uint32_t i ;
  uint32_t next ;
  uint32_t walk ;
  uint32_t *num_refs ;
  uint32_t total_num_clusters ;
  void *tmp ;
  FAT_ENTRY curEntry ;
  FAT_ENTRY nextEntry ;
  DOS_FILE *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  DOS_FILE *tmp___3 ;
  FAT_ENTRY curEntry___0 ;
  uint32_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  DOS_FILE *tmp___7 ;
  DIR_ENT de ;
  loff_t offset ;
  DOS_FILE *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;

  {
#line 405
  changed = 0;
#line 407
  num_refs = (uint32_t *)((void *)0);
#line 410
  if (verbose) {
    {
#line 411
    printf((char const   */* __restrict  */)"Reclaiming unconnected clusters.\n");
    }
  }
  {
#line 413
  total_num_clusters = (uint32_t )((unsigned long )fs->clusters + 2UL);
#line 414
  tmp = alloc((int )((unsigned long )total_num_clusters * sizeof(uint32_t )));
#line 414
  num_refs = (uint32_t *)tmp;
#line 415
  memset((void *)num_refs, 0, (unsigned long )total_num_clusters * sizeof(uint32_t ));
#line 421
  i = (uint32_t )2;
  }
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (i < total_num_clusters)) {
#line 421
      goto while_break;
    }
    {
#line 423
    get_fat(& curEntry, (void *)fs->fat, i, fs);
#line 425
    next = curEntry.value;
#line 426
    tmp___3 = get_owner(fs, i);
    }
#line 426
    if (! tmp___3) {
#line 426
      if (next) {
#line 426
        if (next < fs->clusters + 2U) {
          {
#line 429
          get_fat(& nextEntry, (void *)fs->fat, next, fs);
#line 434
          tmp___0 = get_owner(fs, next);
          }
#line 434
          if (tmp___0) {
            {
#line 436
            set_fat(fs, i, -1);
            }
          } else
#line 434
          if (! nextEntry.value) {
            {
#line 436
            set_fat(fs, i, -1);
            }
          } else {
#line 434
            if (atari_format) {
#line 434
              tmp___1 = 4080;
            } else {
#line 434
              tmp___1 = 4087;
            }
#line 434
            if (nextEntry.value >= (uint32_t )(tmp___1 | (((1 << fs->eff_fat_bits) - 1) & -16))) {
#line 434
              if (atari_format) {
#line 434
                tmp___2 = 4087;
              } else {
#line 434
                tmp___2 = 4087;
              }
#line 434
              if (nextEntry.value <= (uint32_t )(tmp___2 | (((1 << fs->eff_fat_bits) - 1) & -16))) {
                {
#line 436
                set_fat(fs, i, -1);
                }
              } else {
#line 438
                (*(num_refs + next)) ++;
              }
            } else {
#line 438
              (*(num_refs + next)) ++;
            }
          }
        }
      }
    }
#line 421
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 446
    tag_free(fs, & orphan, num_refs, (uint32_t )changed);
#line 447
    changed = 0;
#line 450
    i = (uint32_t )2;
    }
    {
#line 450
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 450
      if (! (i < total_num_clusters)) {
#line 450
        goto while_break___1;
      }
      {
#line 452
      get_fat(& curEntry___0, (void *)fs->fat, i, fs);
      }
#line 454
      if (curEntry___0.value) {
#line 454
        if (atari_format) {
#line 454
          tmp___5 = 4080;
        } else {
#line 454
          tmp___5 = 4087;
        }
#line 454
        if (curEntry___0.value >= (uint32_t )(tmp___5 | (((1 << fs->eff_fat_bits) - 1) & -16))) {
#line 454
          if (atari_format) {
#line 454
            tmp___6 = 4087;
          } else {
#line 454
            tmp___6 = 4087;
          }
#line 454
          if (! (curEntry___0.value <= (uint32_t )(tmp___6 | (((1 << fs->eff_fat_bits) - 1) & -16)))) {
#line 454
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 454
          tmp___7 = get_owner(fs, i);
          }
#line 454
          if (! tmp___7) {
#line 456
            tmp___4 = *(num_refs + curEntry___0.value);
#line 456
            (*(num_refs + curEntry___0.value)) --;
#line 456
            if (! tmp___4) {
              {
#line 457
              die((char *)"Internal error: num_refs going below zero");
              }
            }
            {
#line 458
            set_fat(fs, i, -1);
#line 459
            changed = (int )curEntry___0.value;
#line 460
            printf((char const   */* __restrict  */)"Broke cycle at cluster %lu in free chain.\n",
                   (unsigned long )i);
            }
#line 465
            if (*(num_refs + curEntry___0.value) == 0U) {
#line 466
              goto while_break___1;
            }
          }
        }
      }
#line 450
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 445
    if (! changed) {
#line 445
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 473
  reclaimed = 0;
#line 473
  files = reclaimed;
#line 474
  i = (uint32_t )2;
  {
#line 474
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 474
    if (! (i < total_num_clusters)) {
#line 474
      goto while_break___2;
    }
    {
#line 476
    tmp___8 = get_owner(fs, i);
    }
#line 476
    if ((unsigned long )tmp___8 == (unsigned long )(& orphan)) {
#line 476
      if (! *(num_refs + i)) {
        {
#line 479
        files ++;
#line 480
        offset = alloc_rootdir_entry(fs, & de, "FSCK%04dREC");
#line 481
        de.start = (__u16 )(i & 65535U);
        }
#line 482
        if (fs->fat_bits == 32U) {
#line 483
          de.starthi = (__u16 )(i >> 16);
        }
#line 484
        walk = i;
        {
#line 484
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 484
          if (walk > 0U) {
#line 484
            if (! (walk != 4294967295U)) {
#line 484
              goto while_break___3;
            }
          } else {
#line 484
            goto while_break___3;
          }
          {
#line 486
          de.size += fs->cluster_size;
#line 487
          reclaimed ++;
#line 484
          walk = next_cluster(fs, walk);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 489
        fs_write(offset, (int )sizeof(DIR_ENT ), (void *)(& de));
        }
      }
    }
#line 474
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 491
  if (reclaimed) {
#line 492
    if (files == 1) {
#line 492
      tmp___9 = "";
    } else {
#line 492
      tmp___9 = "s";
    }
#line 492
    if (reclaimed == 1) {
#line 492
      tmp___10 = "";
    } else {
#line 492
      tmp___10 = "s";
    }
    {
#line 492
    printf((char const   */* __restrict  */)"Reclaimed %d unused cluster%s (%llu bytes) in %d chain%s.\n",
           reclaimed, tmp___10, (unsigned long long )reclaimed * (unsigned long long )fs->cluster_size,
           files, tmp___9);
    }
  }
  {
#line 497
  free((void *)num_refs);
  }
#line 498
  return;
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
uint32_t update_free(DOS_FS *fs ) 
{ 
  uint32_t i ;
  uint32_t free___0 ;
  int do_set ;
  FAT_ENTRY curEntry ;
  DOS_FILE *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  uint32_t le_free ;

  {
#line 503
  free___0 = (uint32_t )0;
#line 504
  do_set = 0;
#line 506
  i = (uint32_t )2;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i < fs->clusters + 2U)) {
#line 506
      goto while_break;
    }
    {
#line 508
    get_fat(& curEntry, (void *)fs->fat, i, fs);
#line 510
    tmp = get_owner(fs, i);
    }
#line 510
    if (! tmp) {
#line 510
      if (atari_format) {
#line 510
        tmp___0 = 4080;
      } else {
#line 510
        tmp___0 = 4087;
      }
#line 510
      if (curEntry.value >= (uint32_t )(tmp___0 | (((1 << fs->eff_fat_bits) - 1) & -16))) {
#line 510
        if (atari_format) {
#line 510
          tmp___1 = 4087;
        } else {
#line 510
          tmp___1 = 4087;
        }
#line 510
        if (! (curEntry.value <= (uint32_t )(tmp___1 | (((1 << fs->eff_fat_bits) - 1) & -16)))) {
#line 511
          free___0 ++;
        }
      } else {
#line 511
        free___0 ++;
      }
    }
#line 506
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 514
  if (! fs->fsinfo_start) {
#line 515
    return (free___0);
  }
#line 517
  if (verbose) {
    {
#line 518
    printf((char const   */* __restrict  */)"Checking free cluster summary.\n");
    }
  }
#line 519
  if (fs->free_clusters != 4294967295L) {
#line 520
    if ((long )free___0 != fs->free_clusters) {
      {
#line 521
      printf((char const   */* __restrict  */)"Free cluster summary wrong (%ld vs. really %ld)\n",
             fs->free_clusters, (long )free___0);
      }
#line 523
      if (interactive) {
        {
#line 524
        printf((char const   */* __restrict  */)"1) Correct\n2) Don\'t correct\n");
        }
      } else {
        {
#line 526
        printf((char const   */* __restrict  */)"  Auto-correcting.\n");
        }
      }
#line 527
      if (! interactive) {
#line 528
        do_set = 1;
      } else {
        {
#line 527
        tmp___2 = get_key((char *)"12", (char *)"?");
        }
#line 527
        if ((int )tmp___2 == 49) {
#line 528
          do_set = 1;
        }
      }
    }
  } else {
    {
#line 531
    printf((char const   */* __restrict  */)"Free cluster summary uninitialized (should be %ld)\n",
           (long )free___0);
    }
#line 532
    if (rw) {
#line 533
      if (interactive) {
        {
#line 534
        printf((char const   */* __restrict  */)"1) Set it\n2) Leave it uninitialized\n");
        }
      } else {
        {
#line 536
        printf((char const   */* __restrict  */)"  Auto-setting.\n");
        }
      }
#line 537
      if (! interactive) {
#line 538
        do_set = 1;
      } else {
        {
#line 537
        tmp___3 = get_key((char *)"12", (char *)"?");
        }
#line 537
        if ((int )tmp___3 == 49) {
#line 538
          do_set = 1;
        }
      }
    }
  }
#line 542
  if (do_set) {
    {
#line 543
    le_free = free___0;
#line 544
    fs->free_clusters = (long )free___0;
#line 545
    fs_write((loff_t )((unsigned long )fs->fsinfo_start + (unsigned long )(& ((struct info_sector *)0)->free_clusters)),
             (int )sizeof(le_free), (void *)(& le_free));
    }
  }
#line 549
  return (free___0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 538
extern int getchar(void) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/common.h"
 __attribute__((__noreturn__)) void pdie(char *msg  , ...) ;
#line 45
void qfree(void **root___1 ) ;
#line 49
int min(int a , int b ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/common.c"
 __attribute__((__noreturn__)) void die(char *msg  , ...) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/common.c"
void die(char *msg  , ...) 
{ 
  va_list args ;

  {
  {
#line 44
  __builtin_va_start(args, msg);
#line 45
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
           args);
#line 46
  __builtin_va_end(args);
#line 47
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 48
  exit(1);
  }
}
}
#line 51
 __attribute__((__noreturn__)) void pdie(char *msg  , ...) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/common.c"
void pdie(char *msg  , ...) 
{ 
  va_list args ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 55
  __builtin_va_start(args, msg);
#line 56
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
           args);
#line 57
  __builtin_va_end(args);
#line 58
  tmp = __errno_location();
#line 58
  tmp___0 = strerror(*tmp);
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)":%s\n",
          tmp___0);
#line 59
  exit(1);
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/common.c"
void *alloc(int size ) 
{ 
  void *this ;

  {
  {
#line 66
  this = malloc((size_t )size);
  }
#line 66
  if (this) {
#line 67
    return (this);
  }
  {
#line 68
  pdie((char *)"malloc");
  }
#line 69
  return ((void *)0);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/common.c"
void *qalloc(void **root___1 , int size ) 
{ 
  LINK *link ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 76
  tmp = alloc((int )sizeof(LINK ));
#line 76
  link = (LINK *)tmp;
#line 77
  link->next = (struct _link *)*root___1;
#line 78
  *root___1 = (void *)link;
#line 79
  tmp___0 = alloc(size);
#line 79
  link->data = tmp___0;
  }
#line 79
  return (tmp___0);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/common.c"
void qfree(void **root___1 ) 
{ 
  LINK *this ;

  {
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! *root___1) {
#line 86
      goto while_break;
    }
    {
#line 87
    this = (LINK *)*root___1;
#line 88
    *root___1 = (void *)this->next;
#line 89
    free(this->data);
#line 90
    free((void *)this);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/common.c"
int min(int a , int b ) 
{ 
  int tmp ;

  {
#line 96
  if (a < b) {
#line 96
    tmp = a;
  } else {
#line 96
    tmp = b;
  }
#line 96
  return (tmp);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/common.c"
char get_key(char *valid , char *prompt ) 
{ 
  int ch ;
  int okay ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (prompt) {
      {
#line 105
      printf((char const   */* __restrict  */)"%s ", prompt);
      }
    }
    {
#line 106
    fflush(stdout);
    }
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 107
      ch = getchar();
      }
#line 107
      if (ch == 32) {
#line 107
        tmp = 1;
      } else
#line 107
      if (ch == 9) {
#line 107
        tmp = 1;
      } else {
#line 107
        tmp = 0;
      }
#line 107
      if (! tmp) {
#line 107
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 108
    if (ch == -1) {
      {
#line 109
      exit(1);
      }
    }
    {
#line 110
    okay = ch;
#line 110
    tmp___0 = strchr((char const   *)valid, okay);
    }
#line 110
    if (! tmp___0) {
#line 111
      okay = 0;
    }
    {
#line 112
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 112
      ch = getchar();
      }
#line 112
      if (ch != 10) {
#line 112
        if (ch != -1) {
#line 112
          tmp___1 = 1;
        } else {
#line 112
          tmp___1 = 0;
        }
      } else {
#line 112
        tmp___1 = 0;
      }
#line 112
      if (! tmp___1) {
#line 112
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 113
    if (ch == -1) {
      {
#line 114
      exit(1);
      }
    }
#line 115
    if (okay) {
#line 116
      return ((char )okay);
    }
    {
#line 117
    printf((char const   */* __restrict  */)"Invalid input.\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/charconv.h"
int set_dos_codepage(int codepage ) ;
#line 7
int dos_char_to_printable(char **p , unsigned char c ) ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 583 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/charconv.c"
static iconv_t iconv_init_codepage(int codepage ) 
{ 
  iconv_t result ;
  char codepage_name[16] ;
  char *tmp ;

  {
  {
#line 11
  snprintf((char */* __restrict  */)(codepage_name), sizeof(codepage_name), (char const   */* __restrict  */)"CP%d",
           codepage);
#line 12
  tmp = nl_langinfo(14);
#line 12
  result = iconv_open((char const   *)tmp, (char const   *)(codepage_name));
  }
#line 13
  if ((unsigned long )result == (unsigned long )((iconv_t )-1)) {
    {
#line 14
    perror((char const   *)(codepage_name));
    }
  }
#line 15
  return (result);
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/charconv.c"
static iconv_t dos_to_local  ;
#line 27
static int init_conversion(int codepage ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/charconv.c"
static int initialized  =    -1;
#line 25 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/charconv.c"
static int init_conversion(int codepage ) 
{ 


  {
#line 28
  if (initialized < 0) {
#line 29
    initialized = 1;
#line 30
    if (codepage < 0) {
#line 31
      codepage = 437;
    }
    {
#line 32
    setlocale(6, "");
#line 33
    dos_to_local = iconv_init_codepage(codepage);
    }
#line 34
    if ((unsigned long )dos_to_local == (unsigned long )((iconv_t )-1)) {
#line 34
      if (codepage != 437) {
        {
#line 35
        printf((char const   */* __restrict  */)"Trying to set fallback DOS codepage %d\n",
               437);
#line 37
        dos_to_local = iconv_init_codepage(437);
        }
#line 38
        if ((unsigned long )dos_to_local == (unsigned long )((iconv_t )-1)) {
#line 39
          initialized = 0;
        }
      }
    }
  }
#line 42
  return (initialized);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/charconv.c"
int set_dos_codepage(int codepage ) 
{ 
  int tmp ;

  {
  {
#line 47
  tmp = init_conversion(codepage);
  }
#line 47
  return (tmp);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/charconv.c"
int dos_char_to_printable(char **p , unsigned char c ) 
{ 
  char in[1] ;
  char *pin ;
  size_t bytes_in ;
  size_t bytes_out ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 52
  in[0] = (char )c;
#line 53
  pin = in;
#line 54
  bytes_in = (size_t )1;
#line 55
  bytes_out = (size_t )4;
#line 56
  tmp = init_conversion(-1);
  }
#line 56
  if (! tmp) {
#line 57
    return (0);
  }
  {
#line 58
  tmp___0 = iconv(dos_to_local, (char **/* __restrict  */)(& pin), (size_t */* __restrict  */)(& bytes_in),
                  (char **/* __restrict  */)p, (size_t */* __restrict  */)(& bytes_out));
  }
#line 58
  return (tmp___0 != 0xffffffffffffffffUL);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 178 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
int list ;
#line 178
int test ;
#line 180
unsigned int n_files ;
#line 35 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.h"
FDSC *fp_root ;
#line 42
int file_cvt(unsigned char *name , unsigned char *fixed ) ;
#line 52
FDSC **file_cd(FDSC **curr , char *fixed ) ;
#line 57
FD_TYPE file_type(FDSC **curr , char *fixed ) ;
#line 62
void file_modify(FDSC **curr , char *fixed ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.h"
int scan_root(DOS_FS *fs ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static DOS_FILE *root  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int curr_num  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
loff_t alloc_rootdir_entry(DOS_FS *fs , DIR_ENT *de , char const   *pattern ) 
{ 
  loff_t offset ;
  DIR_ENT d2 ;
  int i ;
  int got ;
  uint32_t clu_num ;
  uint32_t prev ;
  loff_t offset2 ;
  FAT_ENTRY entry ;
  DOS_FILE *tmp ;
  char expanded[12] ;
  int tmp___0 ;
  DIR_ENT *root___1 ;
  int next_free ;
  int scan ;
  void *tmp___1 ;
  char expanded___0[12] ;
  int tmp___2 ;

  {
#line 83
  if (fs->root_cluster) {
    {
#line 85
    i = 0;
#line 85
    got = 0;
#line 86
    prev = (uint32_t )0;
#line 89
    clu_num = fs->root_cluster;
#line 90
    offset = cluster_start(fs, clu_num);
    }
    {
#line 91
    while (1) {
      while_continue: /* CIL Label */ ;
#line 91
      if (clu_num > 0U) {
#line 91
        if (! (clu_num != 4294967295U)) {
#line 91
          goto while_break;
        }
      } else {
#line 91
        goto while_break;
      }
      {
#line 92
      fs_read(offset, (int )sizeof(DIR_ENT ), (void *)(& d2));
      }
#line 93
      if (! d2.name[0]) {
#line 93
        goto _L;
      } else
#line 93
      if ((int )d2.name[0] == 229) {
        _L: /* CIL Label */ 
#line 93
        if ((int )d2.attr != 15) {
#line 94
          got = 1;
#line 95
          goto while_break;
        }
      }
#line 97
      i = (int )((unsigned long )i + sizeof(DIR_ENT ));
#line 98
      offset = (loff_t )((unsigned long )offset + sizeof(DIR_ENT ));
#line 99
      if ((unsigned int )i % fs->cluster_size == 0U) {
        {
#line 100
        prev = clu_num;
#line 101
        clu_num = next_cluster(fs, clu_num);
        }
#line 101
        if (clu_num == 0U) {
#line 102
          goto while_break;
        } else
#line 101
        if (clu_num == 4294967295U) {
#line 102
          goto while_break;
        }
        {
#line 103
        offset = cluster_start(fs, clu_num);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 106
    if (! got) {
#line 109
      if (! prev) {
        {
#line 110
        die((char *)"Root directory has no cluster allocated!");
        }
      }
#line 111
      clu_num = prev + 1U;
      {
#line 111
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 111
        if (! (clu_num != prev)) {
#line 111
          goto while_break___0;
        }
#line 114
        if (clu_num >= fs->clusters + 2U) {
#line 115
          clu_num = (uint32_t )2;
        }
        {
#line 116
        get_fat(& entry, (void *)fs->fat, clu_num, fs);
        }
#line 117
        if (! entry.value) {
#line 118
          goto while_break___0;
        }
#line 111
        clu_num ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 120
      if (clu_num == prev) {
        {
#line 121
        die((char *)"Root directory full and no free cluster");
        }
      }
      {
#line 122
      set_fat(fs, prev, (int32_t )clu_num);
#line 123
      set_fat(fs, clu_num, -1);
#line 124
      tmp = get_owner(fs, fs->root_cluster);
#line 124
      set_owner(fs, clu_num, tmp);
#line 126
      memset((void *)(& d2), 0, sizeof(d2));
#line 127
      offset = cluster_start(fs, clu_num);
#line 128
      i = 0;
      }
      {
#line 128
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 128
        if (! ((unsigned int )i < fs->cluster_size)) {
#line 128
          goto while_break___1;
        }
        {
#line 129
        fs_write(offset + (loff_t )i, (int )sizeof(d2), (void *)(& d2));
#line 128
        i = (int )((unsigned long )i + sizeof(DIR_ENT ));
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 131
    memset((void *)de, 0, sizeof(DIR_ENT ));
    }
    {
#line 132
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 134
      sprintf((char */* __restrict  */)(expanded), (char const   */* __restrict  */)pattern,
              curr_num);
#line 135
      memcpy((void */* __restrict  */)(de->name), (void const   */* __restrict  */)(expanded),
             (size_t )8);
#line 136
      memcpy((void */* __restrict  */)(de->ext), (void const   */* __restrict  */)(expanded + 8),
             (size_t )3);
#line 137
      clu_num = fs->root_cluster;
#line 138
      i = 0;
#line 139
      offset2 = cluster_start(fs, clu_num);
      }
      {
#line 140
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 140
        if (clu_num > 0U) {
#line 140
          if (! (clu_num != 4294967295U)) {
#line 140
            goto while_break___3;
          }
        } else {
#line 140
          goto while_break___3;
        }
        {
#line 141
        fs_read(offset2, (int )sizeof(DIR_ENT ), (void *)(& d2));
        }
#line 142
        if (offset2 != offset) {
          {
#line 142
          tmp___0 = strncmp((char const   *)(d2.name), (char const   *)(de->name),
                            (size_t )11);
          }
#line 142
          if (! tmp___0) {
#line 145
            goto while_break___3;
          }
        }
#line 146
        i = (int )((unsigned long )i + sizeof(DIR_ENT ));
#line 147
        offset2 = (loff_t )((unsigned long )offset2 + sizeof(DIR_ENT ));
#line 148
        if ((unsigned int )i % fs->cluster_size == 0U) {
          {
#line 149
          clu_num = next_cluster(fs, clu_num);
          }
#line 149
          if (clu_num == 0U) {
#line 151
            goto while_break___3;
          } else
#line 149
          if (clu_num == 4294967295U) {
#line 151
            goto while_break___3;
          }
          {
#line 152
          offset2 = cluster_start(fs, clu_num);
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 155
      if (clu_num == 0U) {
#line 156
        goto while_break___2;
      } else
#line 155
      if (clu_num == 4294967295U) {
#line 156
        goto while_break___2;
      }
#line 157
      curr_num ++;
#line 157
      if (curr_num >= 10000) {
        {
#line 158
        die((char *)"Unable to create unique name");
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 162
    next_free = 0;
#line 164
    tmp___1 = alloc((int )((unsigned long )fs->root_entries * sizeof(DIR_ENT )));
#line 164
    root___1 = (DIR_ENT *)tmp___1;
#line 165
    fs_read(fs->root_start, (int )((unsigned long )fs->root_entries * sizeof(DIR_ENT )),
            (void *)root___1);
    }
    {
#line 167
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 167
      if (! ((unsigned int )next_free < fs->root_entries)) {
#line 167
        goto while_break___4;
      }
#line 168
      if (! (root___1 + next_free)->name[0]) {
#line 168
        goto _L___0;
      } else
#line 168
      if ((int )(root___1 + next_free)->name[0] == 229) {
        _L___0: /* CIL Label */ 
#line 168
        if ((int )(root___1 + next_free)->attr != 15) {
#line 170
          goto while_break___4;
        } else {
#line 172
          next_free ++;
        }
      } else {
#line 172
        next_free ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 173
    if ((unsigned int )next_free == fs->root_entries) {
      {
#line 174
      die((char *)"Root directory is full.");
      }
    }
    {
#line 175
    offset = (loff_t )((unsigned long )fs->root_start + (unsigned long )next_free * sizeof(DIR_ENT ));
#line 176
    memset((void *)de, 0, sizeof(DIR_ENT ));
    }
    {
#line 177
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 179
      sprintf((char */* __restrict  */)(expanded___0), (char const   */* __restrict  */)pattern,
              curr_num);
#line 180
      memcpy((void */* __restrict  */)(de->name), (void const   */* __restrict  */)(expanded___0),
             (size_t )8);
#line 181
      memcpy((void */* __restrict  */)(de->ext), (void const   */* __restrict  */)(expanded___0 + 8),
             (size_t )3);
#line 182
      scan = 0;
      }
      {
#line 182
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 182
        if (! ((unsigned int )scan < fs->root_entries)) {
#line 182
          goto while_break___6;
        }
#line 183
        if (scan != next_free) {
          {
#line 183
          tmp___2 = strncmp((char const   *)((root___1 + scan)->name), (char const   *)(de->name),
                            (size_t )11);
          }
#line 183
          if (! tmp___2) {
#line 186
            goto while_break___6;
          }
        }
#line 182
        scan ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 187
      if ((unsigned int )scan == fs->root_entries) {
#line 188
        goto while_break___5;
      }
#line 189
      curr_num ++;
#line 189
      if (curr_num >= 10000) {
        {
#line 190
        die((char *)"Unable to create unique name");
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 192
    free((void *)root___1);
    }
  }
#line 194
  n_files ++;
#line 195
  return (offset);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static char path[8192]  ;
#line 206 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static char *path_name(DOS_FILE *file ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 210
  if (! file) {
#line 211
    path[0] = (char)0;
  } else {
    {
#line 213
    tmp = path_name(file->parent);
#line 213
    tmp___0 = strlen((char const   *)tmp);
    }
#line 213
    if (tmp___0 > 4096UL) {
      {
#line 214
      die((char *)"Path name too long.");
      }
    }
    {
#line 215
    tmp___1 = strcmp((char const   *)(path), "/");
    }
#line 215
    if (tmp___1 != 0) {
      {
#line 216
      strcat((char */* __restrict  */)(path), (char const   */* __restrict  */)"/");
      }
    }
#line 221
    if (file->lfn) {
#line 221
      tmp___3 = file->lfn;
    } else {
      {
#line 221
      tmp___2 = file_name(file->dir_ent.name);
#line 221
      tmp___3 = tmp___2;
      }
    }
    {
#line 221
    tmp___4 = strrchr((char const   *)(path), 0);
#line 221
    strcpy((char */* __restrict  */)tmp___4, (char const   */* __restrict  */)tmp___3);
    }
  }
#line 224
  return (path);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int day_n[16]  = 
#line 227
  {      0,      31,      59,      90, 
        120,      151,      181,      212, 
        243,      273,      304,      334, 
        0,      0,      0,      0};
#line 233 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static time_t date_dos2unix(unsigned short time___0 , unsigned short date ) 
{ 
  int month ;
  int year ;
  time_t secs ;
  int tmp ;

  {
#line 238
  month = (((int )date >> 5) & 15) - 1;
#line 239
  year = (int )date >> 9;
#line 240
  if ((year & 3) == 0) {
#line 240
    if (month < 2) {
#line 240
      tmp = 1;
    } else {
#line 240
      tmp = 0;
    }
  } else {
#line 240
    tmp = 0;
  }
#line 240
  secs = (time_t )(((((int )time___0 & 31) * 2 + 60 * (((int )time___0 >> 5) & 63)) + ((int )time___0 >> 11) * 3600) + 86400 * ((((((((int )date & 31) - 1) + day_n[month]) + year / 4) + year * 365) - tmp) + 3653));
#line 245
  return (secs);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static char temp[100]  ;
#line 248 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static char *file_stat(DOS_FILE *file ) 
{ 
  struct tm *tm ;
  char tmp[100] ;
  time_t date ;

  {
  {
#line 255
  date = date_dos2unix(file->dir_ent.time, file->dir_ent.date);
#line 257
  tm = localtime((time_t const   *)(& date));
#line 258
  strftime((char */* __restrict  */)(tmp), (size_t )99, (char const   */* __restrict  */)"%H:%M:%S %b %d %Y",
           (struct tm  const  */* __restrict  */)tm);
#line 259
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"  Size %u bytes, date %s",
          file->dir_ent.size, tmp);
  }
#line 260
  return (temp);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int bad_name(DOS_FILE *file ) 
{ 
  int i ;
  int spc ;
  int suspicious ;
  char const   *bad_chars ;
  char const   *tmp ;
  unsigned char const   *name ;
  unsigned char const   *ext ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 265
  suspicious = 0;
#line 266
  if (atari_format) {
#line 266
    tmp = "*?\\/:";
  } else {
#line 266
    tmp = "*?<>|\"\\/:";
  }
  {
#line 266
  bad_chars = tmp;
#line 267
  name = (unsigned char const   *)(file->dir_ent.name);
#line 268
  ext = (unsigned char const   *)(file->dir_ent.ext);
#line 272
  tmp___0 = strncmp((char const   *)name, "EA DATA  SF", (size_t )11);
  }
#line 272
  if (tmp___0 == 0) {
#line 274
    return (0);
  } else {
    {
#line 272
    tmp___1 = strncmp((char const   *)name, "WP ROOT  SF", (size_t )11);
    }
#line 272
    if (tmp___1 == 0) {
#line 274
      return (0);
    }
  }
#line 278
  if ((unsigned long )file->lfn == (unsigned long )((void *)0)) {
#line 278
    if ((int )file->dir_ent.lcase & 32) {
#line 279
      return (1);
    }
  }
#line 284
  if ((int )file->dir_ent.lcase & 32) {
#line 285
    return (0);
  }
#line 287
  i = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (i < 8)) {
#line 287
      goto while_break;
    }
#line 288
    if ((int const   )*(name + i) < 32) {
#line 289
      return (1);
    } else
#line 288
    if ((int const   )*(name + i) == 127) {
#line 289
      return (1);
    }
#line 290
    if ((int const   )*(name + i) > 127) {
#line 291
      suspicious ++;
    }
    {
#line 292
    tmp___2 = strchr(bad_chars, (int )*(name + i));
    }
#line 292
    if (tmp___2) {
#line 293
      return (1);
    }
#line 287
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  i = 0;
  {
#line 296
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 296
    if (! (i < 3)) {
#line 296
      goto while_break___0;
    }
#line 297
    if ((int const   )*(ext + i) < 32) {
#line 298
      return (1);
    } else
#line 297
    if ((int const   )*(ext + i) == 127) {
#line 298
      return (1);
    }
#line 299
    if ((int const   )*(ext + i) > 127) {
#line 300
      suspicious ++;
    }
    {
#line 301
    tmp___3 = strchr(bad_chars, (int )*(ext + i));
    }
#line 301
    if (tmp___3) {
#line 302
      return (1);
    }
#line 296
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 305
  spc = 0;
#line 306
  i = 0;
  {
#line 306
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 306
    if (! (i < 8)) {
#line 306
      goto while_break___1;
    }
#line 307
    if ((int const   )*(name + i) == 32) {
#line 308
      spc = 1;
    } else
#line 309
    if (spc) {
#line 312
      return (1);
    }
#line 306
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 315
  spc = 0;
#line 316
  i = 0;
  {
#line 316
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 316
    if (! (i < 3)) {
#line 316
      goto while_break___2;
    }
#line 317
    if ((int const   )*(ext + i) == 32) {
#line 318
      spc = 1;
    } else
#line 319
    if (spc) {
#line 322
      return (1);
    }
#line 316
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 326
  if (atari_format) {
#line 326
    if (suspicious) {
#line 327
      return (1);
    }
  }
#line 333
  return (0);
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void lfn_remove(loff_t from , loff_t to ) 
{ 
  DIR_ENT empty ;

  {
  {
#line 344
  memset((void *)(& empty), 0, sizeof(empty));
#line 345
  empty.name[0] = (__u8 )229;
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (from < to)) {
#line 347
      goto while_break;
    }
    {
#line 348
    fs_write(from, (int )sizeof(DIR_ENT ), (void *)(& empty));
#line 347
    from = (loff_t )((unsigned long )from + sizeof(empty));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void drop_file(DOS_FS *fs , DOS_FILE *file ) 
{ 
  uint32_t cluster ;
  int tmp ;

  {
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (file->offset) {
      {
#line 356
      file->dir_ent.name[0] = (__u8 )229;
#line 356
      fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->name[0])),
               (int )sizeof(file->dir_ent.name[0]), (void *)(& file->dir_ent.name[0]));
      }
    }
#line 356
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  if (file->lfn) {
    {
#line 358
    lfn_remove(file->lfn_offset, file->offset);
    }
  }
#line 359
  if (fs->fat_bits == 32U) {
#line 359
    tmp = (int )file->dir_ent.starthi << 16;
  } else {
#line 359
    tmp = 0;
  }
#line 359
  cluster = (uint32_t )file->dir_ent.start | (unsigned int )tmp;
  {
#line 359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 359
    if (cluster > 0U) {
#line 359
      if (! (cluster < fs->clusters + 2U)) {
#line 359
        goto while_break___0;
      }
    } else {
#line 359
      goto while_break___0;
    }
    {
#line 361
    set_owner(fs, cluster, (DOS_FILE *)((void *)0));
#line 359
    cluster = next_cluster(fs, cluster);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 362
  n_files --;
#line 363
  return;
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void truncate_file(DOS_FS *fs , DOS_FILE *file , uint32_t clusters ) 
{ 
  int deleting ;
  uint32_t walk ;
  uint32_t next ;
  int tmp ;
  uint32_t __v ;
  int tmp___0 ;

  {
#line 370
  if (fs->fat_bits == 32U) {
#line 370
    tmp = (int )file->dir_ent.starthi << 16;
  } else {
#line 370
    tmp = 0;
  }
#line 370
  walk = (uint32_t )file->dir_ent.start | (unsigned int )tmp;
#line 371
  deleting = ! clusters;
#line 371
  if (deleting) {
    {
#line 372
    while (1) {
      while_continue: /* CIL Label */ ;
#line 372
      __v = (uint32_t )0;
#line 372
      if (! file->offset) {
#line 372
        if (! __v) {
          {
#line 372
          die((char *)"Oops, deleting FAT32 root dir!");
          }
        }
        {
#line 372
        fs->root_cluster = __v;
#line 372
        file->dir_ent.start = (__u16 )(__v & 65535U);
#line 372
        file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 372
        __v = __v;
#line 372
        fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                 (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v));
        }
      } else {
        {
#line 372
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 372
          if (file->offset) {
            {
#line 372
            file->dir_ent.start = (__u16 )(__v & 65535U);
#line 372
            fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                     (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
            }
          }
#line 372
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 372
        if (fs->fat_bits == 32U) {
          {
#line 372
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 372
            if (file->offset) {
              {
#line 372
              file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 372
              fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                       (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
              }
            }
#line 372
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
#line 372
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 373
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 373
    if (walk > 0U) {
#line 373
      if (! (walk != 4294967295U)) {
#line 373
        goto while_break___2;
      }
    } else {
#line 373
      goto while_break___2;
    }
    {
#line 374
    next = next_cluster(fs, walk);
    }
#line 375
    if (deleting) {
      {
#line 376
      set_fat(fs, walk, 0);
      }
    } else {
#line 377
      clusters --;
#line 377
      if (clusters) {
#line 377
        tmp___0 = 0;
      } else {
#line 377
        tmp___0 = 1;
      }
#line 377
      deleting = tmp___0;
#line 377
      if (deleting) {
        {
#line 378
        set_fat(fs, walk, -1);
        }
      }
    }
#line 379
    walk = next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void auto_rename(DOS_FILE *file ) 
{ 
  DOS_FILE *first ;
  DOS_FILE *walk ;
  uint32_t number ;
  char num[8] ;
  int tmp ;

  {
#line 388
  if (! file->offset) {
#line 389
    return;
  }
#line 390
  if (file->parent) {
#line 390
    first = (file->parent)->first;
  } else {
#line 390
    first = root;
  }
#line 391
  number = (uint32_t )0;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 394
    sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)"%07lu",
            (unsigned long )number);
#line 395
    memcpy((void */* __restrict  */)(file->dir_ent.name), (void const   */* __restrict  */)"FSCK",
           (size_t )4);
#line 396
    memcpy((void */* __restrict  */)(file->dir_ent.name + 4), (void const   */* __restrict  */)(num),
           (size_t )4);
#line 397
    memcpy((void */* __restrict  */)(file->dir_ent.ext), (void const   */* __restrict  */)(num + 4),
           (size_t )3);
#line 398
    walk = first;
    }
    {
#line 398
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 398
      if (! walk) {
#line 398
        goto while_break___0;
      }
#line 399
      if ((unsigned long )walk != (unsigned long )file) {
        {
#line 399
        tmp = strncmp((char const   *)(walk->dir_ent.name), (char const   *)(file->dir_ent.name),
                      (size_t )11);
        }
#line 399
        if (! tmp) {
#line 402
          goto while_break___0;
        }
      }
#line 398
      walk = walk->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 403
    if (! walk) {
#line 405
      if ((int )file->dir_ent.lcase & 32) {
        {
#line 409
        file->dir_ent.lcase = (__u8 )((int )file->dir_ent.lcase & -33);
#line 411
        file->dir_ent.attr = (__u8 )((int )file->dir_ent.attr & -25);
#line 412
        fs_write(file->offset, 13, (void *)(file->dir_ent.name));
        }
      } else {
        {
#line 416
        fs_write(file->offset, 11, (void *)(file->dir_ent.name));
        }
      }
#line 418
      if (file->lfn) {
        {
#line 419
        lfn_fix_checksum(file->lfn_offset, file->offset, (char const   *)(file->dir_ent.name));
        }
      }
#line 421
      return;
    }
#line 423
    number ++;
#line 424
    if (number > 9999999U) {
      {
#line 425
      die((char *)"Too many files need repair.");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 428
  die((char *)"Can\'t generate a unique name.");
  }
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void rename_file(DOS_FILE *file ) 
{ 
  unsigned char name[46] ;
  unsigned char *walk ;
  unsigned char *here ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 436
  if (! file->offset) {
    {
#line 437
    printf((char const   */* __restrict  */)"Cannot rename FAT32 root dir\n");
    }
#line 438
    return;
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 441
    printf((char const   */* __restrict  */)"New name: ");
#line 442
    fflush(stdout);
#line 443
    tmp___2 = fgets((char */* __restrict  */)((char *)(name)), 45, (FILE */* __restrict  */)stdin);
    }
#line 443
    if (tmp___2) {
      {
#line 444
      tmp = strchr((char const   *)(name), '\n');
#line 444
      here = (unsigned char *)tmp;
      }
#line 444
      if (here) {
#line 445
        *here = (unsigned char)0;
      }
      {
#line 446
      tmp___0 = strrchr((char const   *)(name), 0);
#line 446
      walk = (unsigned char *)tmp___0;
      }
      {
#line 446
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 446
        if ((unsigned long )walk >= (unsigned long )(name)) {
#line 446
          if (! ((int )*walk == 32)) {
#line 446
            if (! ((int )*walk == 9)) {
#line 446
              goto while_break___0;
            }
          }
        } else {
#line 446
          goto while_break___0;
        }
#line 446
        walk --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 448
      *(walk + 1) = (unsigned char)0;
#line 449
      walk = name;
      {
#line 449
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 449
        if (! ((int )*walk == 32)) {
#line 449
          if (! ((int )*walk == 9)) {
#line 449
            goto while_break___1;
          }
        }
#line 449
        walk ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 450
      tmp___1 = file_cvt(walk, file->dir_ent.name);
      }
#line 450
      if (tmp___1) {
#line 452
        if ((int )file->dir_ent.lcase & 32) {
          {
#line 456
          file->dir_ent.lcase = (__u8 )((int )file->dir_ent.lcase & -33);
#line 458
          file->dir_ent.attr = (__u8 )((int )file->dir_ent.attr & -25);
#line 459
          fs_write(file->offset, 13, (void *)(file->dir_ent.name));
          }
        } else {
          {
#line 463
          fs_write(file->offset, 11, (void *)(file->dir_ent.name));
          }
        }
#line 465
        if (file->lfn) {
          {
#line 466
          lfn_fix_checksum(file->lfn_offset, file->offset, (char const   *)(file->dir_ent.name));
          }
        }
#line 468
        return;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int handle_dot(DOS_FS *fs , DOS_FILE *file , int dots ) 
{ 
  char *name ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 478
  tmp___0 = strncmp((char const   *)(file->dir_ent.name), ".          ", (size_t )11);
  }
#line 478
  if (tmp___0) {
#line 478
    name = (char *)"..";
  } else {
#line 478
    name = (char *)".";
  }
#line 481
  if (! ((int )file->dir_ent.attr & 16)) {
    {
#line 482
    tmp___1 = path_name(file);
#line 482
    printf((char const   */* __restrict  */)"%s\n  Is a non-directory.\n", tmp___1);
    }
#line 483
    if (interactive) {
      {
#line 484
      printf((char const   */* __restrict  */)"1) Drop it\n2) Auto-rename\n3) Rename\n4) Convert to directory\n");
      }
    } else {
      {
#line 487
      printf((char const   */* __restrict  */)"  Auto-renaming it.\n");
      }
    }
#line 488
    if (interactive) {
      {
#line 488
      tmp___2 = get_key((char *)"1234", (char *)"?");
#line 488
      tmp___3 = (int )tmp___2;
      }
    } else {
#line 488
      tmp___3 = '2';
    }
    {
#line 489
    if (tmp___3 == 49) {
#line 489
      goto case_49;
    }
#line 492
    if (tmp___3 == 50) {
#line 492
      goto case_50;
    }
#line 496
    if (tmp___3 == 51) {
#line 496
      goto case_51;
    }
#line 499
    if (tmp___3 == 52) {
#line 499
      goto case_52;
    }
#line 488
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 490
    drop_file(fs, file);
    }
#line 491
    return (1);
    case_50: /* CIL Label */ 
    {
#line 493
    auto_rename(file);
#line 494
    tmp___4 = file_name(file->dir_ent.name);
#line 494
    printf((char const   */* __restrict  */)"  Renamed to %s\n", tmp___4);
    }
#line 495
    return (0);
    case_51: /* CIL Label */ 
    {
#line 497
    rename_file(file);
    }
#line 498
    return (0);
    case_52: /* CIL Label */ 
    {
#line 500
    while (1) {
      while_continue: /* CIL Label */ ;
#line 500
      if (file->offset) {
        {
#line 500
        file->dir_ent.size = (__u32 )0;
#line 500
        fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->size)),
                 (int )sizeof(file->dir_ent.size), (void *)(& file->dir_ent.size));
        }
      }
#line 500
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 501
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 501
      if (file->offset) {
        {
#line 501
        file->dir_ent.attr = (__u8 )((int )file->dir_ent.attr | 16);
#line 501
        fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->attr)),
                 (int )sizeof(file->dir_ent.attr), (void *)(& file->dir_ent.attr));
        }
      }
#line 501
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 502
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 505
  if (! dots) {
    {
#line 506
    printf((char const   */* __restrict  */)"Root contains directory \"%s\". Dropping it.\n",
           name);
#line 507
    drop_file(fs, file);
    }
#line 508
    return (1);
  }
#line 510
  return (0);
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int check_file(DOS_FS *fs , DOS_FILE *file ) 
{ 
  DOS_FILE *owner ;
  int restart ;
  uint32_t expect ;
  uint32_t curr ;
  uint32_t this ;
  uint32_t clusters ;
  uint32_t prev ;
  uint32_t walk ;
  uint32_t clusters2 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t __v ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  uint32_t __v___0 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  uint32_t __v___1 ;
  int tmp___14 ;
  int tmp___16 ;
  int tmp___17 ;
  FAT_ENTRY curEntry ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  uint32_t __v___2 ;
  int tmp___20 ;
  char *tmp___21 ;
  int do_trunc ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char const   *tmp___25 ;
  int tmp___26 ;
  uint32_t __v___3 ;
  int tmp___27 ;
  uint32_t __v___4 ;
  char tmp___28 ;
  char *tmp___29 ;

  {
#line 519
  if ((int )file->dir_ent.attr & 16) {
#line 520
    if (file->dir_ent.size) {
      {
#line 521
      tmp = path_name(file);
#line 521
      printf((char const   */* __restrict  */)"%s\n  Directory has non-zero size. Fixing it.\n",
             tmp);
      }
      {
#line 523
      while (1) {
        while_continue: /* CIL Label */ ;
#line 523
        if (file->offset) {
          {
#line 523
          file->dir_ent.size = (__u32 )0;
#line 523
          fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->size)),
                   (int )sizeof(file->dir_ent.size), (void *)(& file->dir_ent.size));
          }
        }
#line 523
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 525
    if (file->parent) {
      {
#line 525
      tmp___4 = strncmp((char const   *)(file->dir_ent.name), ".          ", (size_t )11);
      }
#line 525
      if (! tmp___4) {
#line 528
        if (fs->fat_bits == 32U) {
#line 528
          tmp___0 = (int )(file->parent)->dir_ent.starthi << 16;
        } else {
#line 528
          tmp___0 = 0;
        }
#line 528
        expect = (uint32_t )(file->parent)->dir_ent.start | (unsigned int )tmp___0;
#line 529
        if (fs->fat_bits == 32U) {
#line 529
          tmp___3 = (int )file->dir_ent.starthi << 16;
        } else {
#line 529
          tmp___3 = 0;
        }
#line 529
        if (((uint32_t )file->dir_ent.start | (unsigned int )tmp___3) != expect) {
#line 530
          if (fs->fat_bits == 32U) {
#line 530
            tmp___1 = (int )file->dir_ent.starthi << 16;
          } else {
#line 530
            tmp___1 = 0;
          }
          {
#line 530
          tmp___2 = path_name(file);
#line 530
          printf((char const   */* __restrict  */)"%s\n  Start (%lu) does not point to parent (%lu)\n",
                 tmp___2, (unsigned long )((uint32_t )file->dir_ent.start | (unsigned int )tmp___1),
                 (long )expect);
          }
          {
#line 532
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 532
            __v = expect;
#line 532
            if (! file->offset) {
#line 532
              if (! __v) {
                {
#line 532
                die((char *)"Oops, deleting FAT32 root dir!");
                }
              }
              {
#line 532
              fs->root_cluster = __v;
#line 532
              file->dir_ent.start = (__u16 )(__v & 65535U);
#line 532
              file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 532
              __v = __v;
#line 532
              fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                       (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v));
              }
            } else {
              {
#line 532
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 532
                if (file->offset) {
                  {
#line 532
                  file->dir_ent.start = (__u16 )(__v & 65535U);
#line 532
                  fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                           (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
                  }
                }
#line 532
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 532
              if (fs->fat_bits == 32U) {
                {
#line 532
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 532
                  if (file->offset) {
                    {
#line 532
                    file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 532
                    fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                             (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
                    }
                  }
#line 532
                  goto while_break___2;
                }
                while_break___2: /* CIL Label */ ;
                }
              }
            }
#line 532
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 534
        return (0);
      }
    }
#line 536
    if (file->parent) {
      {
#line 536
      tmp___9 = strncmp((char const   *)(file->dir_ent.name), "..         ", (size_t )11);
      }
#line 536
      if (! tmp___9) {
#line 539
        if ((file->parent)->parent) {
#line 539
          if (fs->fat_bits == 32U) {
#line 539
            tmp___5 = (int )((file->parent)->parent)->dir_ent.starthi << 16;
          } else {
#line 539
            tmp___5 = 0;
          }
#line 539
          expect = (uint32_t )((file->parent)->parent)->dir_ent.start | (unsigned int )tmp___5;
        } else {
#line 539
          expect = (uint32_t )0;
        }
#line 541
        if (fs->root_cluster) {
#line 541
          if (expect == fs->root_cluster) {
#line 542
            expect = (uint32_t )0;
          }
        }
#line 543
        if (fs->fat_bits == 32U) {
#line 543
          tmp___8 = (int )file->dir_ent.starthi << 16;
        } else {
#line 543
          tmp___8 = 0;
        }
#line 543
        if (((uint32_t )file->dir_ent.start | (unsigned int )tmp___8) != expect) {
#line 544
          if (fs->fat_bits == 32U) {
#line 544
            tmp___6 = (int )file->dir_ent.starthi << 16;
          } else {
#line 544
            tmp___6 = 0;
          }
          {
#line 544
          tmp___7 = path_name(file);
#line 544
          printf((char const   */* __restrict  */)"%s\n  Start (%lu) does not point to .. (%lu)\n",
                 tmp___7, (unsigned long )((uint32_t )file->dir_ent.start | (unsigned int )tmp___6),
                 (unsigned long )expect);
          }
          {
#line 546
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 546
            __v___0 = expect;
#line 546
            if (! file->offset) {
#line 546
              if (! __v___0) {
                {
#line 546
                die((char *)"Oops, deleting FAT32 root dir!");
                }
              }
              {
#line 546
              fs->root_cluster = __v___0;
#line 546
              file->dir_ent.start = (__u16 )(__v___0 & 65535U);
#line 546
              file->dir_ent.starthi = (__u16 )(__v___0 >> 16);
#line 546
              __v___0 = __v___0;
#line 546
              fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                       (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v___0));
              }
            } else {
              {
#line 546
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 546
                if (file->offset) {
                  {
#line 546
                  file->dir_ent.start = (__u16 )(__v___0 & 65535U);
#line 546
                  fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                           (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
                  }
                }
#line 546
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 546
              if (fs->fat_bits == 32U) {
                {
#line 546
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 546
                  if (file->offset) {
                    {
#line 546
                    file->dir_ent.starthi = (__u16 )(__v___0 >> 16);
#line 546
                    fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                             (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
                    }
                  }
#line 546
                  goto while_break___5;
                }
                while_break___5: /* CIL Label */ ;
                }
              }
            }
#line 546
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 548
        return (0);
      }
    }
#line 550
    if (fs->fat_bits == 32U) {
#line 550
      tmp___11 = (int )file->dir_ent.starthi << 16;
    } else {
#line 550
      tmp___11 = 0;
    }
#line 550
    if (((uint32_t )file->dir_ent.start | (unsigned int )tmp___11) == 0U) {
      {
#line 551
      tmp___10 = path_name(file);
#line 551
      printf((char const   */* __restrict  */)"%s\n Start does point to root directory. Deleting dir. \n",
             tmp___10);
      }
      {
#line 553
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 553
        if (file->offset) {
          {
#line 553
          file->dir_ent.name[0] = (__u8 )229;
#line 553
          fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->name[0])),
                   (int )sizeof(file->dir_ent.name[0]), (void *)(& file->dir_ent.name[0]));
          }
        }
#line 553
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 554
      return (0);
    }
  }
#line 557
  if (fs->fat_bits == 32U) {
#line 557
    tmp___14 = (int )file->dir_ent.starthi << 16;
  } else {
#line 557
    tmp___14 = 0;
  }
#line 557
  if (((uint32_t )file->dir_ent.start | (unsigned int )tmp___14) >= fs->clusters + 2U) {
#line 558
    if (fs->fat_bits == 32U) {
#line 558
      tmp___12 = (int )file->dir_ent.starthi << 16;
    } else {
#line 558
      tmp___12 = 0;
    }
    {
#line 558
    tmp___13 = path_name(file);
#line 558
    printf((char const   */* __restrict  */)"%s\n  Start cluster beyond limit (%lu > %lu). Truncating file.\n",
           tmp___13, (unsigned long )((uint32_t )file->dir_ent.start | (unsigned int )tmp___12),
           (unsigned long )(fs->clusters + 1U));
    }
#line 561
    if (! file->offset) {
      {
#line 562
      die((char *)"Bad FAT32 root directory! (bad start cluster)\n");
      }
    }
    {
#line 563
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 563
      __v___1 = (uint32_t )0;
#line 563
      if (! file->offset) {
#line 563
        if (! __v___1) {
          {
#line 563
          die((char *)"Oops, deleting FAT32 root dir!");
          }
        }
        {
#line 563
        fs->root_cluster = __v___1;
#line 563
        file->dir_ent.start = (__u16 )(__v___1 & 65535U);
#line 563
        file->dir_ent.starthi = (__u16 )(__v___1 >> 16);
#line 563
        __v___1 = __v___1;
#line 563
        fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                 (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v___1));
        }
      } else {
        {
#line 563
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 563
          if (file->offset) {
            {
#line 563
            file->dir_ent.start = (__u16 )(__v___1 & 65535U);
#line 563
            fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                     (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
            }
          }
#line 563
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 563
        if (fs->fat_bits == 32U) {
          {
#line 563
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 563
            if (file->offset) {
              {
#line 563
              file->dir_ent.starthi = (__u16 )(__v___1 >> 16);
#line 563
              fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                       (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
              }
            }
#line 563
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
#line 563
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 565
  prev = (uint32_t )0;
#line 565
  clusters = prev;
#line 566
  if (fs->fat_bits == 32U) {
#line 566
    tmp___17 = (int )file->dir_ent.starthi << 16;
  } else {
#line 566
    tmp___17 = 0;
  }
#line 566
  if ((uint32_t )file->dir_ent.start | (unsigned int )tmp___17) {
#line 566
    if (fs->fat_bits == 32U) {
#line 566
      tmp___16 = (int )file->dir_ent.starthi << 16;
    } else {
#line 566
      tmp___16 = 0;
    }
#line 566
    curr = (uint32_t )file->dir_ent.start | (unsigned int )tmp___16;
  } else {
#line 566
    curr = (uint32_t )-1;
  }
  {
#line 566
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 566
    if (! (curr != 4294967295U)) {
#line 566
      goto while_break___10;
    }
    {
#line 569
    get_fat(& curEntry, (void *)fs->fat, curr, fs);
    }
#line 571
    if (! curEntry.value) {
#line 571
      goto _L;
    } else {
      {
#line 571
      tmp___20 = bad_cluster(fs, curr);
      }
#line 571
      if (tmp___20) {
        _L: /* CIL Label */ 
#line 572
        if (curEntry.value) {
#line 572
          tmp___18 = "bad";
        } else {
#line 572
          tmp___18 = "free";
        }
        {
#line 572
        tmp___19 = path_name(file);
#line 572
        printf((char const   */* __restrict  */)"%s\n  Contains a %s cluster (%lu). Assuming EOF.\n",
               tmp___19, tmp___18, (unsigned long )curr);
        }
#line 574
        if (prev) {
          {
#line 575
          set_fat(fs, prev, -1);
          }
        } else
#line 576
        if (! file->offset) {
          {
#line 577
          die((char *)"FAT32 root dir starts with a bad cluster!");
          }
        } else {
          {
#line 579
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 579
            __v___2 = (uint32_t )0;
#line 579
            if (! file->offset) {
#line 579
              if (! __v___2) {
                {
#line 579
                die((char *)"Oops, deleting FAT32 root dir!");
                }
              }
              {
#line 579
              fs->root_cluster = __v___2;
#line 579
              file->dir_ent.start = (__u16 )(__v___2 & 65535U);
#line 579
              file->dir_ent.starthi = (__u16 )(__v___2 >> 16);
#line 579
              __v___2 = __v___2;
#line 579
              fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                       (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v___2));
              }
            } else {
              {
#line 579
              while (1) {
                while_continue___12: /* CIL Label */ ;
#line 579
                if (file->offset) {
                  {
#line 579
                  file->dir_ent.start = (__u16 )(__v___2 & 65535U);
#line 579
                  fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                           (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
                  }
                }
#line 579
                goto while_break___12;
              }
              while_break___12: /* CIL Label */ ;
              }
#line 579
              if (fs->fat_bits == 32U) {
                {
#line 579
                while (1) {
                  while_continue___13: /* CIL Label */ ;
#line 579
                  if (file->offset) {
                    {
#line 579
                    file->dir_ent.starthi = (__u16 )(__v___2 >> 16);
#line 579
                    fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                             (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
                    }
                  }
#line 579
                  goto while_break___13;
                }
                while_break___13: /* CIL Label */ ;
                }
              }
            }
#line 579
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
        }
#line 580
        goto while_break___10;
      }
    }
#line 582
    if (! ((int )file->dir_ent.attr & 16)) {
#line 582
      if ((uint64_t )file->dir_ent.size <= (uint64_t )clusters * (uint64_t )fs->cluster_size) {
        {
#line 584
        tmp___21 = path_name(file);
#line 584
        printf((char const   */* __restrict  */)"%s\n  File size is %u bytes, cluster chain length is > %lu bytes.\n  Truncating file to %u bytes.\n",
               tmp___21, file->dir_ent.size, (uint64_t )clusters * (uint64_t )fs->cluster_size,
               file->dir_ent.size);
#line 590
        truncate_file(fs, file, clusters);
        }
#line 591
        goto while_break___10;
      }
    }
    {
#line 593
    owner = get_owner(fs, curr);
    }
#line 593
    if (owner) {
      {
#line 594
      do_trunc = 0;
#line 595
      tmp___22 = path_name(owner);
#line 595
      printf((char const   */* __restrict  */)"%s  and\n", tmp___22);
#line 596
      tmp___23 = path_name(file);
#line 596
      printf((char const   */* __restrict  */)"%s\n  share clusters.\n", tmp___23);
#line 597
      clusters2 = (uint32_t )0;
      }
#line 598
      if (fs->fat_bits == 32U) {
#line 598
        tmp___24 = (int )owner->dir_ent.starthi << 16;
      } else {
#line 598
        tmp___24 = 0;
      }
#line 598
      walk = (uint32_t )owner->dir_ent.start | (unsigned int )tmp___24;
      {
#line 598
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 598
        if (walk > 0U) {
#line 598
          if (! (walk != 4294967295U)) {
#line 598
            goto while_break___14;
          }
        } else {
#line 598
          goto while_break___14;
        }
#line 600
        if (walk == curr) {
#line 601
          goto while_break___14;
        } else {
#line 603
          clusters2 ++;
        }
        {
#line 598
        walk = next_cluster(fs, walk);
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 604
      restart = (int )file->dir_ent.attr & 16;
#line 605
      if (! owner->offset) {
        {
#line 606
        printf((char const   */* __restrict  */)"  Truncating second to %llu bytes because first is FAT32 root dir.\n",
               (unsigned long long )clusters2 * (unsigned long long )fs->cluster_size);
#line 609
        do_trunc = 2;
        }
      } else
#line 610
      if (! file->offset) {
        {
#line 611
        printf((char const   */* __restrict  */)"  Truncating first to %llu bytes because second is FAT32 root dir.\n",
               (unsigned long long )clusters * (unsigned long long )fs->cluster_size);
#line 614
        do_trunc = 1;
        }
      } else
#line 615
      if (interactive) {
#line 616
        if (restart) {
#line 616
          tmp___25 = " and restart";
        } else {
#line 616
          tmp___25 = "";
        }
        {
#line 616
        printf((char const   */* __restrict  */)"1) Truncate first to %llu bytes%s\n2) Truncate second to %llu bytes\n",
               (unsigned long long )clusters * (unsigned long long )fs->cluster_size,
               tmp___25, (unsigned long long )clusters2 * (unsigned long long )fs->cluster_size);
        }
      } else {
        {
#line 622
        printf((char const   */* __restrict  */)"  Truncating second to %llu bytes.\n",
               (unsigned long long )clusters2 * (unsigned long long )fs->cluster_size);
        }
      }
#line 624
      if (do_trunc != 2) {
#line 624
        if (do_trunc == 1) {
#line 624
          goto _L___1;
        } else
#line 624
        if (interactive) {
          {
#line 624
          tmp___28 = get_key((char *)"12", (char *)"?");
          }
#line 624
          if ((int )tmp___28 == 49) {
            _L___1: /* CIL Label */ 
#line 627
            prev = (uint32_t )0;
#line 628
            clusters = (uint32_t )0;
#line 629
            if (fs->fat_bits == 32U) {
#line 629
              tmp___26 = (int )owner->dir_ent.starthi << 16;
            } else {
#line 629
              tmp___26 = 0;
            }
#line 629
            this = (uint32_t )owner->dir_ent.start | (unsigned int )tmp___26;
            {
#line 629
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 629
              if (this > 0U) {
#line 629
                if (! (this != 4294967295U)) {
#line 629
                  goto while_break___15;
                }
              } else {
#line 629
                goto while_break___15;
              }
#line 631
              if (this == curr) {
#line 632
                if (prev) {
                  {
#line 633
                  set_fat(fs, prev, -1);
                  }
                } else {
                  {
#line 635
                  while (1) {
                    while_continue___16: /* CIL Label */ ;
#line 635
                    __v___3 = (uint32_t )0;
#line 635
                    if (! owner->offset) {
#line 635
                      if (! __v___3) {
                        {
#line 635
                        die((char *)"Oops, deleting FAT32 root dir!");
                        }
                      }
                      {
#line 635
                      fs->root_cluster = __v___3;
#line 635
                      owner->dir_ent.start = (__u16 )(__v___3 & 65535U);
#line 635
                      owner->dir_ent.starthi = (__u16 )(__v___3 >> 16);
#line 635
                      __v___3 = __v___3;
#line 635
                      fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                               (int )sizeof(((struct boot_sector *)0)->root_cluster),
                               (void *)(& __v___3));
                      }
                    } else {
                      {
#line 635
                      while (1) {
                        while_continue___17: /* CIL Label */ ;
#line 635
                        if (owner->offset) {
                          {
#line 635
                          owner->dir_ent.start = (__u16 )(__v___3 & 65535U);
#line 635
                          fs_write((loff_t )((unsigned long )owner->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                                   (int )sizeof(owner->dir_ent.start), (void *)(& owner->dir_ent.start));
                          }
                        }
#line 635
                        goto while_break___17;
                      }
                      while_break___17: /* CIL Label */ ;
                      }
#line 635
                      if (fs->fat_bits == 32U) {
                        {
#line 635
                        while (1) {
                          while_continue___18: /* CIL Label */ ;
#line 635
                          if (owner->offset) {
                            {
#line 635
                            owner->dir_ent.starthi = (__u16 )(__v___3 >> 16);
#line 635
                            fs_write((loff_t )((unsigned long )owner->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                                     (int )sizeof(owner->dir_ent.starthi), (void *)(& owner->dir_ent.starthi));
                            }
                          }
#line 635
                          goto while_break___18;
                        }
                        while_break___18: /* CIL Label */ ;
                        }
                      }
                    }
#line 635
                    goto while_break___16;
                  }
                  while_break___16: /* CIL Label */ ;
                  }
                }
                {
#line 636
                while (1) {
                  while_continue___19: /* CIL Label */ ;
#line 636
                  if (owner->offset) {
                    {
#line 636
                    owner->dir_ent.size = (__u32 )((uint64_t )clusters * (uint64_t )fs->cluster_size);
#line 636
                    fs_write((loff_t )((unsigned long )owner->offset + (unsigned long )(& ((DIR_ENT *)0)->size)),
                             (int )sizeof(owner->dir_ent.size), (void *)(& owner->dir_ent.size));
                    }
                  }
#line 636
                  goto while_break___19;
                }
                while_break___19: /* CIL Label */ ;
                }
#line 639
                if (restart) {
#line 640
                  return (1);
                }
                {
#line 641
                while (1) {
                  while_continue___20: /* CIL Label */ ;
#line 641
                  if (this > 0U) {
#line 641
                    if (! (this != 4294967295U)) {
#line 641
                      goto while_break___20;
                    }
                  } else {
#line 641
                    goto while_break___20;
                  }
                  {
#line 642
                  set_owner(fs, this, (DOS_FILE *)((void *)0));
#line 643
                  this = next_cluster(fs, this);
                  }
                }
                while_break___20: /* CIL Label */ ;
                }
#line 645
                this = curr;
#line 646
                goto while_break___15;
              }
              {
#line 648
              clusters ++;
#line 649
              prev = this;
#line 629
              this = next_cluster(fs, this);
              }
            }
            while_break___15: /* CIL Label */ ;
            }
#line 651
            if (this != curr) {
#line 652
              if (fs->fat_bits == 32U) {
#line 652
                tmp___27 = (int )owner->dir_ent.starthi << 16;
              } else {
#line 652
                tmp___27 = 0;
              }
              {
#line 652
              die((char *)"Internal error: didn\'t find cluster %d in chain starting at %d",
                  curr, (uint32_t )owner->dir_ent.start | (unsigned int )tmp___27);
              }
            }
          } else {
#line 624
            goto _L___0;
          }
        } else {
#line 624
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 655
        if (prev) {
          {
#line 656
          set_fat(fs, prev, -1);
          }
        } else {
          {
#line 658
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 658
            __v___4 = (uint32_t )0;
#line 658
            if (! file->offset) {
#line 658
              if (! __v___4) {
                {
#line 658
                die((char *)"Oops, deleting FAT32 root dir!");
                }
              }
              {
#line 658
              fs->root_cluster = __v___4;
#line 658
              file->dir_ent.start = (__u16 )(__v___4 & 65535U);
#line 658
              file->dir_ent.starthi = (__u16 )(__v___4 >> 16);
#line 658
              __v___4 = __v___4;
#line 658
              fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                       (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v___4));
              }
            } else {
              {
#line 658
              while (1) {
                while_continue___22: /* CIL Label */ ;
#line 658
                if (file->offset) {
                  {
#line 658
                  file->dir_ent.start = (__u16 )(__v___4 & 65535U);
#line 658
                  fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                           (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
                  }
                }
#line 658
                goto while_break___22;
              }
              while_break___22: /* CIL Label */ ;
              }
#line 658
              if (fs->fat_bits == 32U) {
                {
#line 658
                while (1) {
                  while_continue___23: /* CIL Label */ ;
#line 658
                  if (file->offset) {
                    {
#line 658
                    file->dir_ent.starthi = (__u16 )(__v___4 >> 16);
#line 658
                    fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                             (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
                    }
                  }
#line 658
                  goto while_break___23;
                }
                while_break___23: /* CIL Label */ ;
                }
              }
            }
#line 658
            goto while_break___21;
          }
          while_break___21: /* CIL Label */ ;
          }
        }
#line 659
        goto while_break___10;
      }
    }
    {
#line 662
    set_owner(fs, curr, file);
#line 663
    clusters ++;
#line 664
    prev = curr;
#line 566
    curr = next_cluster(fs, curr);
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 666
  if (! ((int )file->dir_ent.attr & 16)) {
#line 666
    if ((uint64_t )file->dir_ent.size > (uint64_t )clusters * (uint64_t )fs->cluster_size) {
      {
#line 668
      tmp___29 = path_name(file);
#line 668
      printf((char const   */* __restrict  */)"%s\n  File size is %u bytes, cluster chain length is %llu bytes.\n  Truncating file to %llu bytes.\n",
             tmp___29, file->dir_ent.size, (unsigned long long )clusters * (unsigned long long )fs->cluster_size,
             (unsigned long long )clusters * (unsigned long long )fs->cluster_size);
      }
      {
#line 674
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 674
        if (file->offset) {
          {
#line 674
          file->dir_ent.size = (__u32 )((uint64_t )clusters * (uint64_t )fs->cluster_size);
#line 674
          fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->size)),
                   (int )sizeof(file->dir_ent.size), (void *)(& file->dir_ent.size));
          }
        }
#line 674
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
    }
  }
#line 677
  return (0);
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int check_files(DOS_FS *fs , DOS_FILE *start ) 
{ 
  int tmp ;

  {
  {
#line 682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 682
    if (! start) {
#line 682
      goto while_break;
    }
    {
#line 683
    tmp = check_file(fs, start);
    }
#line 683
    if (tmp) {
#line 684
      return (1);
    }
#line 685
    start = start->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 687
  return (0);
}
}
#line 690 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int check_dir(DOS_FS *fs , DOS_FILE **root___1 , int dots ) 
{ 
  DOS_FILE *parent ;
  DOS_FILE **walk ;
  DOS_FILE **scan ;
  int dot ;
  int dotdot ;
  int skip ;
  int redo ;
  int good ;
  int bad ;
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;

  {
#line 696
  if (! *root___1) {
#line 697
    return (0);
  }
#line 698
  parent = (*root___1)->parent;
#line 699
  bad = 0;
#line 699
  good = bad;
#line 700
  walk = root___1;
  {
#line 700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 700
    if (! *walk) {
#line 700
      goto while_break;
    }
    {
#line 701
    tmp = bad_name(*walk);
    }
#line 701
    if (tmp) {
#line 702
      bad ++;
    } else {
#line 704
      good ++;
    }
#line 700
    walk = & (*walk)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 705
  if (*root___1) {
#line 705
    if (parent) {
#line 705
      if (good + bad > 4) {
#line 705
        if (bad > good / 2) {
          {
#line 706
          tmp___0 = path_name(parent);
#line 706
          printf((char const   */* __restrict  */)"%s\n  Has a large number of bad entries. (%d/%d)\n",
                 tmp___0, bad, good + bad);
          }
#line 708
          if (! dots) {
            {
#line 709
            printf((char const   */* __restrict  */)"  Not dropping root directory.\n");
            }
          } else
#line 710
          if (! interactive) {
            {
#line 711
            printf((char const   */* __restrict  */)"  Not dropping it in auto-mode.\n");
            }
          } else {
            {
#line 712
            tmp___1 = get_key((char *)"yn", (char *)"Drop directory ? (y/n)");
            }
#line 712
            if ((int )tmp___1 == 121) {
              {
#line 713
              truncate_file(fs, parent, (uint32_t )0);
              }
              {
#line 714
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 714
                if (parent->offset) {
                  {
#line 714
                  parent->dir_ent.name[0] = (__u8 )229;
#line 714
                  fs_write((loff_t )((unsigned long )parent->offset + (unsigned long )(& ((DIR_ENT *)0)->name[0])),
                           (int )sizeof(parent->dir_ent.name[0]), (void *)(& parent->dir_ent.name[0]));
                  }
                }
#line 714
                goto while_break___0;
              }
              while_break___0: /* CIL Label */ ;
              }
#line 716
              return (1);
            }
          }
        }
      }
    }
  }
#line 719
  redo = 0;
#line 719
  dotdot = redo;
#line 719
  dot = dotdot;
#line 720
  walk = root___1;
  {
#line 721
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 721
    if (! *walk) {
#line 721
      goto while_break___1;
    }
    {
#line 722
    tmp___4 = strncmp((char const   *)((*walk)->dir_ent.name), ".          ", (size_t )11);
    }
#line 722
    if (tmp___4) {
      {
#line 722
      tmp___5 = strncmp((char const   *)((*walk)->dir_ent.name), "..         ", (size_t )11);
      }
#line 722
      if (! tmp___5) {
        _L: /* CIL Label */ 
        {
#line 726
        tmp___2 = handle_dot(fs, *walk, dots);
        }
#line 726
        if (tmp___2) {
#line 727
          *walk = (*walk)->next;
#line 728
          goto while_continue___1;
        }
        {
#line 730
        tmp___3 = strncmp((char const   *)((*walk)->dir_ent.name), ".          ",
                          (size_t )11);
        }
#line 730
        if (tmp___3) {
#line 734
          dotdot ++;
        } else {
#line 732
          dot ++;
        }
      }
    } else {
#line 722
      goto _L;
    }
#line 736
    if (! ((int )(*walk)->dir_ent.attr & 8)) {
      {
#line 736
      tmp___11 = bad_name(*walk);
      }
#line 736
      if (tmp___11) {
        {
#line 737
        tmp___6 = path_name(*walk);
#line 737
        puts((char const   *)tmp___6);
#line 738
        tmp___7 = file_name((*walk)->dir_ent.name);
#line 738
        printf((char const   */* __restrict  */)"  Bad short file name (%s).\n", tmp___7);
        }
#line 740
        if (interactive) {
          {
#line 741
          printf((char const   */* __restrict  */)"1) Drop file\n2) Rename file\n3) Auto-rename\n4) Keep it\n");
          }
        } else {
          {
#line 744
          printf((char const   */* __restrict  */)"  Auto-renaming it.\n");
          }
        }
#line 745
        if (interactive) {
          {
#line 745
          tmp___8 = get_key((char *)"1234", (char *)"?");
#line 745
          tmp___9 = (int )tmp___8;
          }
        } else {
#line 745
          tmp___9 = '3';
        }
        {
#line 746
        if (tmp___9 == 49) {
#line 746
          goto case_49;
        }
#line 750
        if (tmp___9 == 50) {
#line 750
          goto case_50;
        }
#line 754
        if (tmp___9 == 51) {
#line 754
          goto case_51;
        }
#line 758
        if (tmp___9 == 52) {
#line 758
          goto case_52;
        }
#line 745
        goto switch_break;
        case_49: /* CIL Label */ 
        {
#line 747
        drop_file(fs, *walk);
#line 748
        walk = & (*walk)->next;
        }
#line 749
        goto while_continue___1;
        case_50: /* CIL Label */ 
        {
#line 751
        rename_file(*walk);
#line 752
        redo = 1;
        }
#line 753
        goto switch_break;
        case_51: /* CIL Label */ 
        {
#line 755
        auto_rename(*walk);
#line 756
        tmp___10 = file_name((*walk)->dir_ent.name);
#line 756
        printf((char const   */* __restrict  */)"  Renamed to %s\n", tmp___10);
        }
#line 757
        goto switch_break;
        case_52: /* CIL Label */ 
#line 759
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 763
    if (! ((int )(*walk)->dir_ent.attr & 8)) {
#line 764
      scan = & (*walk)->next;
#line 765
      skip = 0;
      {
#line 766
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 766
        if (*scan) {
#line 766
          if (! (! skip)) {
#line 766
            goto while_break___2;
          }
        } else {
#line 766
          goto while_break___2;
        }
#line 767
        if (! ((int )(*scan)->dir_ent.attr & 8)) {
          {
#line 767
          tmp___21 = memcmp((void const   *)((*walk)->dir_ent.name), (void const   *)((*scan)->dir_ent.name),
                            (size_t )11);
          }
#line 767
          if (! tmp___21) {
            {
#line 770
            tmp___12 = file_stat(*walk);
#line 770
            tmp___13 = path_name(*walk);
#line 770
            printf((char const   */* __restrict  */)"%s\n  Duplicate directory entry.\n  First  %s\n",
                   tmp___13, tmp___12);
#line 772
            tmp___14 = file_stat(*scan);
#line 772
            printf((char const   */* __restrict  */)"  Second %s\n", tmp___14);
            }
#line 773
            if (interactive) {
              {
#line 774
              printf((char const   */* __restrict  */)"1) Drop first\n2) Drop second\n3) Rename first\n4) Rename second\n5) Auto-rename first\n6) Auto-rename second\n");
              }
            } else {
              {
#line 779
              printf((char const   */* __restrict  */)"  Auto-renaming second.\n");
              }
            }
#line 780
            if (interactive) {
              {
#line 780
              tmp___15 = get_key((char *)"123456", (char *)"?");
#line 780
              tmp___16 = (int )tmp___15;
              }
            } else {
#line 780
              tmp___16 = '6';
            }
            {
#line 781
            if (tmp___16 == 49) {
#line 781
              goto case_49___0;
            }
#line 786
            if (tmp___16 == 50) {
#line 786
              goto case_50___0;
            }
#line 790
            if (tmp___16 == 51) {
#line 790
              goto case_51___0;
            }
#line 795
            if (tmp___16 == 52) {
#line 795
              goto case_52___0;
            }
#line 800
            if (tmp___16 == 53) {
#line 800
              goto case_53;
            }
#line 805
            if (tmp___16 == 54) {
#line 805
              goto case_54;
            }
#line 780
            goto switch_break___0;
            case_49___0: /* CIL Label */ 
            {
#line 782
            drop_file(fs, *walk);
#line 783
            *walk = (*walk)->next;
#line 784
            skip = 1;
            }
#line 785
            goto switch_break___0;
            case_50___0: /* CIL Label */ 
            {
#line 787
            drop_file(fs, *scan);
#line 788
            *scan = (*scan)->next;
            }
#line 789
            goto while_continue___2;
            case_51___0: /* CIL Label */ 
            {
#line 791
            rename_file(*walk);
#line 792
            tmp___17 = path_name(*walk);
#line 792
            printf((char const   */* __restrict  */)"  Renamed to %s\n", tmp___17);
#line 793
            redo = 1;
            }
#line 794
            goto switch_break___0;
            case_52___0: /* CIL Label */ 
            {
#line 796
            rename_file(*scan);
#line 797
            tmp___18 = path_name(*walk);
#line 797
            printf((char const   */* __restrict  */)"  Renamed to %s\n", tmp___18);
#line 798
            redo = 1;
            }
#line 799
            goto switch_break___0;
            case_53: /* CIL Label */ 
            {
#line 801
            auto_rename(*walk);
#line 802
            tmp___19 = file_name((*walk)->dir_ent.name);
#line 802
            printf((char const   */* __restrict  */)"  Renamed to %s\n", tmp___19);
            }
#line 804
            goto switch_break___0;
            case_54: /* CIL Label */ 
            {
#line 806
            auto_rename(*scan);
#line 807
            tmp___20 = file_name((*scan)->dir_ent.name);
#line 807
            printf((char const   */* __restrict  */)"  Renamed to %s\n", tmp___20);
            }
#line 809
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          }
        }
#line 812
        scan = & (*scan)->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 814
      if (skip) {
#line 815
        goto while_continue___1;
      }
    }
#line 817
    if (! redo) {
#line 818
      walk = & (*walk)->next;
    } else {
#line 820
      walk = root___1;
#line 821
      redo = 0;
#line 821
      dotdot = redo;
#line 821
      dot = dotdot;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 824
  if (dots) {
#line 824
    if (! dot) {
      {
#line 825
      tmp___22 = path_name(parent);
#line 825
      printf((char const   */* __restrict  */)"%s\n  \".\" is missing. Can\'t fix this yet.\n",
             tmp___22);
      }
    }
  }
#line 827
  if (dots) {
#line 827
    if (! dotdot) {
      {
#line 828
      tmp___23 = path_name(parent);
#line 828
      printf((char const   */* __restrict  */)"%s\n  \"..\" is missing. Can\'t fix this yet.\n",
             tmp___23);
      }
    }
  }
#line 830
  return (0);
}
}
#line 842 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void test_file(DOS_FS *fs , DOS_FILE *file , int read_test ) 
{ 
  DOS_FILE *owner ;
  uint32_t walk ;
  uint32_t prev ;
  uint32_t clusters ;
  uint32_t next_clu ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  uint32_t __v ;
  int tmp___2 ;
  char *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t __v___0 ;
  uint32_t tmp___5 ;
  loff_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  DOS_FILE *tmp___9 ;
  int tmp___10 ;

  {
#line 847
  clusters = (uint32_t )0;
#line 847
  prev = clusters;
#line 848
  if (fs->fat_bits == 32U) {
#line 848
    tmp = (int )file->dir_ent.starthi << 16;
  } else {
#line 848
    tmp = 0;
  }
#line 848
  walk = (uint32_t )file->dir_ent.start | (unsigned int )tmp;
  {
#line 848
  while (1) {
    while_continue: /* CIL Label */ ;
#line 848
    if (walk > 0U) {
#line 848
      if (! (walk < fs->clusters + 2U)) {
#line 848
        goto while_break;
      }
    } else {
#line 848
      goto while_break;
    }
    {
#line 850
    next_clu = next_cluster(fs, walk);
#line 856
    owner = get_owner(fs, walk);
    }
#line 856
    if (owner) {
#line 857
      if ((unsigned long )owner == (unsigned long )file) {
#line 858
        if (clusters == 1U) {
#line 858
          tmp___0 = "";
        } else {
#line 858
          tmp___0 = "s";
        }
        {
#line 858
        tmp___1 = path_name(file);
#line 858
        printf((char const   */* __restrict  */)"%s\n  Circular cluster chain. Truncating to %lu cluster%s.\n",
               tmp___1, (unsigned long )clusters, tmp___0);
        }
#line 861
        if (prev) {
          {
#line 862
          set_fat(fs, prev, -1);
          }
        } else
#line 863
        if (! file->offset) {
          {
#line 864
          die((char *)"Bad FAT32 root directory! (bad start cluster)\n");
          }
        } else {
          {
#line 866
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 866
            __v = (uint32_t )0;
#line 866
            if (! file->offset) {
#line 866
              if (! __v) {
                {
#line 866
                die((char *)"Oops, deleting FAT32 root dir!");
                }
              }
              {
#line 866
              fs->root_cluster = __v;
#line 866
              file->dir_ent.start = (__u16 )(__v & 65535U);
#line 866
              file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 866
              __v = __v;
#line 866
              fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                       (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v));
              }
            } else {
              {
#line 866
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 866
                if (file->offset) {
                  {
#line 866
                  file->dir_ent.start = (__u16 )(__v & 65535U);
#line 866
                  fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                           (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
                  }
                }
#line 866
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 866
              if (fs->fat_bits == 32U) {
                {
#line 866
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 866
                  if (file->offset) {
                    {
#line 866
                    file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 866
                    fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                             (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
                    }
                  }
#line 866
                  goto while_break___2;
                }
                while_break___2: /* CIL Label */ ;
                }
              }
            }
#line 866
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
#line 868
      goto while_break;
    }
    {
#line 870
    tmp___2 = bad_cluster(fs, walk);
    }
#line 870
    if (tmp___2) {
#line 871
      goto while_break;
    }
#line 872
    if (read_test) {
      {
#line 873
      tmp___6 = cluster_start(fs, walk);
#line 873
      tmp___7 = fs_test(tmp___6, (int )fs->cluster_size);
      }
#line 873
      if (tmp___7) {
#line 874
        prev = walk;
#line 875
        clusters ++;
      } else {
        {
#line 877
        tmp___3 = path_name(file);
#line 877
        printf((char const   */* __restrict  */)"%s\n  Cluster %lu (%lu) is unreadable. Skipping it.\n",
               tmp___3, (unsigned long )clusters, (unsigned long )walk);
        }
#line 879
        if (prev) {
          {
#line 880
          tmp___4 = next_cluster(fs, walk);
#line 880
          set_fat(fs, prev, (int32_t )tmp___4);
          }
        } else {
          {
#line 882
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 882
            tmp___5 = next_cluster(fs, walk);
#line 882
            __v___0 = tmp___5;
            }
#line 882
            if (! file->offset) {
#line 882
              if (! __v___0) {
                {
#line 882
                die((char *)"Oops, deleting FAT32 root dir!");
                }
              }
              {
#line 882
              fs->root_cluster = __v___0;
#line 882
              file->dir_ent.start = (__u16 )(__v___0 & 65535U);
#line 882
              file->dir_ent.starthi = (__u16 )(__v___0 >> 16);
#line 882
              __v___0 = __v___0;
#line 882
              fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                       (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v___0));
              }
            } else {
              {
#line 882
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 882
                if (file->offset) {
                  {
#line 882
                  file->dir_ent.start = (__u16 )(__v___0 & 65535U);
#line 882
                  fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                           (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
                  }
                }
#line 882
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 882
              if (fs->fat_bits == 32U) {
                {
#line 882
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 882
                  if (file->offset) {
                    {
#line 882
                    file->dir_ent.starthi = (__u16 )(__v___0 >> 16);
#line 882
                    fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                             (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
                    }
                  }
#line 882
                  goto while_break___5;
                }
                while_break___5: /* CIL Label */ ;
                }
              }
            }
#line 882
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        {
#line 883
        set_fat(fs, walk, -2);
        }
      }
    }
    {
#line 886
    set_owner(fs, walk, file);
#line 848
    walk = next_clu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 889
  if (fs->fat_bits == 32U) {
#line 889
    tmp___8 = (int )file->dir_ent.starthi << 16;
  } else {
#line 889
    tmp___8 = 0;
  }
#line 889
  walk = (uint32_t )file->dir_ent.start | (unsigned int )tmp___8;
  {
#line 889
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 889
    if (walk > 0U) {
#line 889
      if (! (walk < fs->clusters + 2U)) {
#line 889
        goto while_break___6;
      }
    } else {
#line 889
      goto while_break___6;
    }
    {
#line 891
    tmp___10 = bad_cluster(fs, walk);
    }
#line 891
    if (tmp___10) {
#line 892
      goto while_break___6;
    } else {
      {
#line 893
      tmp___9 = get_owner(fs, walk);
      }
#line 893
      if ((unsigned long )tmp___9 == (unsigned long )file) {
        {
#line 894
        set_owner(fs, walk, (DOS_FILE *)((void *)0));
        }
      } else {
#line 896
        goto while_break___6;
      }
    }
    {
#line 889
    walk = next_cluster(fs, walk);
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 897
  return;
}
}
#line 899 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void undelete(DOS_FS *fs , DOS_FILE *file ) 
{ 
  uint32_t clusters ;
  uint32_t left ;
  uint32_t prev ;
  uint32_t walk ;
  int tmp ;
  FAT_ENTRY curEntry ;
  uint32_t __v ;
  char const   *tmp___0 ;

  {
#line 903
  left = ((file->dir_ent.size + fs->cluster_size) - 1U) / fs->cluster_size;
#line 903
  clusters = left;
#line 905
  prev = (uint32_t )0;
#line 907
  if (fs->fat_bits == 32U) {
#line 907
    tmp = (int )file->dir_ent.starthi << 16;
  } else {
#line 907
    tmp = 0;
  }
#line 907
  walk = (uint32_t )file->dir_ent.start | (unsigned int )tmp;
  {
#line 909
  while (1) {
    while_continue: /* CIL Label */ ;
#line 909
    if (left) {
#line 909
      if (walk >= 2U) {
#line 909
        if (! (walk < fs->clusters + 2U)) {
#line 909
          goto while_break;
        }
      } else {
#line 909
        goto while_break;
      }
    } else {
#line 909
      goto while_break;
    }
    {
#line 912
    get_fat(& curEntry, (void *)fs->fat, walk, fs);
    }
#line 914
    if (! curEntry.value) {
#line 915
      goto while_break;
    }
#line 917
    left --;
#line 918
    if (prev) {
      {
#line 919
      set_fat(fs, prev, (int32_t )walk);
      }
    }
#line 920
    prev = walk;
#line 921
    walk ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 923
  if (prev) {
    {
#line 924
    set_fat(fs, prev, -1);
    }
  } else {
    {
#line 926
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 926
      __v = (uint32_t )0;
#line 926
      if (! file->offset) {
#line 926
        if (! __v) {
          {
#line 926
          die((char *)"Oops, deleting FAT32 root dir!");
          }
        }
        {
#line 926
        fs->root_cluster = __v;
#line 926
        file->dir_ent.start = (__u16 )(__v & 65535U);
#line 926
        file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 926
        __v = __v;
#line 926
        fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                 (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v));
        }
      } else {
        {
#line 926
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 926
          if (file->offset) {
            {
#line 926
            file->dir_ent.start = (__u16 )(__v & 65535U);
#line 926
            fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                     (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
            }
          }
#line 926
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 926
        if (fs->fat_bits == 32U) {
          {
#line 926
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 926
            if (file->offset) {
              {
#line 926
              file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 926
              fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                       (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
              }
            }
#line 926
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 926
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 927
  if (left) {
#line 928
    if (clusters == 1U) {
#line 928
      tmp___0 = "";
    } else {
#line 928
      tmp___0 = "s";
    }
    {
#line 928
    printf((char const   */* __restrict  */)"Warning: Did only undelete %lu of %lu cluster%s.\n",
           (unsigned long )clusters - (unsigned long )left, (unsigned long )clusters,
           tmp___0);
    }
  }
#line 931
  return;
}
}
#line 933 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void new_dir(void) 
{ 


  {
  {
#line 935
  lfn_reset();
  }
#line 936
  return;
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void add_file(DOS_FS *fs , DOS_FILE ***chain , DOS_FILE *parent , loff_t offset ,
                     FDSC **cp ) 
{ 
  DOS_FILE *new ;
  DIR_ENT de ;
  FD_TYPE type ;
  void *tmp ;
  struct _dos_file *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 958
  if (offset) {
    {
#line 959
    fs_read(offset, (int )sizeof(DIR_ENT ), (void *)(& de));
    }
  } else {
    {
#line 962
    memcpy((void */* __restrict  */)(de.name), (void const   */* __restrict  */)"           ",
           (size_t )11);
#line 963
    de.attr = (__u8 )16;
#line 964
    de.date = (__u16 )0;
#line 964
    de.time = de.date;
#line 964
    de.size = (__u32 )de.time;
#line 965
    de.start = (__u16 )(fs->root_cluster & 65535U);
#line 966
    de.starthi = (__u16 )((fs->root_cluster >> 16) & 65535U);
    }
  }
  {
#line 968
  type = file_type(cp, (char *)(de.name));
  }
#line 968
  if ((unsigned int )type != 0U) {
#line 969
    if ((unsigned int )type == 2U) {
#line 969
      if ((int )de.attr & 16) {
        {
#line 970
        die((char *)"Can\'t undelete directories.");
        }
      }
    }
    {
#line 971
    file_modify(cp, (char *)(de.name));
#line 972
    fs_write(offset, 1, (void *)(& de));
    }
  }
#line 974
  if (! de.name[0]) {
    {
#line 975
    lfn_check_orphaned();
    }
#line 976
    return;
  } else
#line 974
  if ((int )de.name[0] == 229) {
    {
#line 975
    lfn_check_orphaned();
    }
#line 976
    return;
  }
#line 978
  if ((int )de.attr == 15) {
    {
#line 979
    lfn_add_slot(& de, offset);
    }
#line 980
    return;
  }
  {
#line 982
  tmp = qalloc(& mem_queue, (int )sizeof(DOS_FILE ));
#line 982
  new = (DOS_FILE *)tmp;
#line 983
  new->lfn = lfn_get(& de, & new->lfn_offset);
#line 984
  new->offset = offset;
#line 985
  memcpy((void */* __restrict  */)(& new->dir_ent), (void const   */* __restrict  */)(& de),
         sizeof(de));
#line 986
  tmp___0 = (struct _dos_file *)((void *)0);
#line 986
  new->first = tmp___0;
#line 986
  new->next = tmp___0;
#line 987
  new->parent = parent;
  }
#line 988
  if ((unsigned int )type == 2U) {
    {
#line 989
    undelete(fs, new);
    }
  }
#line 990
  *(*chain) = new;
#line 991
  *chain = & new->next;
#line 992
  if (list) {
    {
#line 993
    tmp___1 = path_name(new);
#line 993
    printf((char const   */* __restrict  */)"Checking file %s", tmp___1);
    }
#line 994
    if (new->lfn) {
      {
#line 995
      tmp___2 = file_name(new->dir_ent.name);
#line 995
      printf((char const   */* __restrict  */)" (%s)", tmp___2);
      }
    }
    {
#line 996
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 999
  if (offset) {
    {
#line 999
    tmp___3 = strncmp((char const   *)(de.name), ".          ", (size_t )11);
    }
#line 999
    if (tmp___3 != 0) {
      {
#line 999
      tmp___4 = strncmp((char const   *)(de.name), "..         ", (size_t )11);
      }
#line 999
      if (tmp___4 != 0) {
#line 1002
        n_files ++;
      }
    }
  }
  {
#line 1003
  test_file(fs, new, test);
  }
#line 1004
  return;
}
}
#line 1006
static int subdirs(DOS_FS *fs , DOS_FILE *parent , FDSC **cp ) ;
#line 1008 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int scan_dir(DOS_FS *fs , DOS_FILE *this , FDSC **cp ) 
{ 
  DOS_FILE **chain ;
  int i ;
  uint32_t clu_num ;
  int tmp ;
  loff_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1014
  chain = & this->first;
#line 1015
  i = 0;
#line 1016
  if (fs->fat_bits == 32U) {
#line 1016
    tmp = (int )this->dir_ent.starthi << 16;
  } else {
#line 1016
    tmp = 0;
  }
  {
#line 1016
  clu_num = (uint32_t )this->dir_ent.start | (unsigned int )tmp;
#line 1017
  new_dir();
  }
  {
#line 1018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1018
    if (clu_num > 0U) {
#line 1018
      if (! (clu_num != 4294967295U)) {
#line 1018
        goto while_break;
      }
    } else {
#line 1018
      goto while_break;
    }
    {
#line 1019
    tmp___0 = cluster_start(fs, clu_num);
#line 1019
    add_file(fs, & chain, this, tmp___0 + (loff_t )((unsigned int )i % fs->cluster_size),
             cp);
#line 1021
    i = (int )((unsigned long )i + sizeof(DIR_ENT ));
    }
#line 1022
    if (! ((unsigned int )i % fs->cluster_size)) {
      {
#line 1023
      clu_num = next_cluster(fs, clu_num);
      }
#line 1023
      if (clu_num == 0U) {
#line 1024
        goto while_break;
      } else
#line 1023
      if (clu_num == 4294967295U) {
#line 1024
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1026
  lfn_check_orphaned();
#line 1027
  tmp___1 = check_dir(fs, & this->first, (int )this->offset);
  }
#line 1027
  if (tmp___1) {
#line 1028
    return (0);
  }
  {
#line 1029
  tmp___2 = check_files(fs, this->first);
  }
#line 1029
  if (tmp___2) {
#line 1030
    return (1);
  }
  {
#line 1031
  tmp___3 = subdirs(fs, this, cp);
  }
#line 1031
  return (tmp___3);
}
}
#line 1044 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int subdirs(DOS_FS *fs , DOS_FILE *parent , FDSC **cp ) 
{ 
  DOS_FILE *walk ;
  FDSC **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1048
  if (parent) {
#line 1048
    walk = parent->first;
  } else {
#line 1048
    walk = root;
  }
  {
#line 1048
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1048
    if (! walk) {
#line 1048
      goto while_break;
    }
#line 1049
    if ((int )walk->dir_ent.attr & 16) {
      {
#line 1050
      tmp___1 = strncmp((char const   *)(walk->dir_ent.name), ".          ", (size_t )11);
      }
#line 1050
      if (tmp___1) {
        {
#line 1050
        tmp___2 = strncmp((char const   *)(walk->dir_ent.name), "..         ", (size_t )11);
        }
#line 1050
        if (tmp___2) {
          {
#line 1053
          tmp = file_cd(cp, (char *)(walk->dir_ent.name));
#line 1053
          tmp___0 = scan_dir(fs, walk, tmp);
          }
#line 1053
          if (tmp___0) {
#line 1054
            return (1);
          }
        }
      }
    }
#line 1048
    walk = walk->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1055
  return (0);
}
}
#line 1066 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
int scan_root(DOS_FS *fs ) 
{ 
  DOS_FILE **chain ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1071
  root = (DOS_FILE *)((void *)0);
#line 1072
  chain = & root;
#line 1073
  new_dir();
  }
#line 1074
  if (fs->root_cluster) {
    {
#line 1075
    add_file(fs, & chain, (DOS_FILE *)((void *)0), (loff_t )0, & fp_root);
    }
  } else {
#line 1077
    i = 0;
    {
#line 1077
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1077
      if (! ((unsigned int )i < fs->root_entries)) {
#line 1077
        goto while_break;
      }
      {
#line 1078
      add_file(fs, & chain, (DOS_FILE *)((void *)0), (loff_t )((unsigned long )fs->root_start + (unsigned long )i * sizeof(DIR_ENT )),
               & fp_root);
#line 1077
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1081
  lfn_check_orphaned();
#line 1082
  check_dir(fs, & root, 0);
#line 1083
  tmp = check_files(fs, root);
  }
#line 1083
  if (tmp) {
#line 1084
    return (1);
  }
  {
#line 1085
  tmp___0 = subdirs(fs, (DOS_FILE *)((void *)0), & fp_root);
  }
#line 1085
  return (tmp___0);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.h"
void file_add(char *path___3 , FD_TYPE type ) ;
#line 66
void file_unused(void) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
FDSC *fp_root  =    (FDSC *)((void *)0);
#line 47 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
static void put_char(char **p , unsigned char c ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 49
  tmp = dos_char_to_printable(p, c);
  }
#line 49
  if (tmp) {
#line 50
    return;
  }
#line 51
  if ((int )c >= 32) {
#line 51
    if ((int )c < 127) {
#line 52
      tmp___0 = *p;
#line 52
      (*p) ++;
#line 52
      *tmp___0 = (char )c;
    } else {
#line 51
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 51
  if ((int )c >= 160) {
#line 52
    tmp___0 = *p;
#line 52
    (*p) ++;
#line 52
    *tmp___0 = (char )c;
  } else {
#line 54
    tmp___1 = *p;
#line 54
    (*p) ++;
#line 54
    *tmp___1 = (char )'\\';
#line 55
    tmp___2 = *p;
#line 55
    (*p) ++;
#line 55
    *tmp___2 = (char )(48 + ((int )c >> 6));
#line 56
    tmp___3 = *p;
#line 56
    (*p) ++;
#line 56
    *tmp___3 = (char )(48 + (((int )c >> 3) & 7));
#line 57
    tmp___4 = *p;
#line 57
    (*p) ++;
#line 57
    *tmp___4 = (char )(48 + ((int )c & 7));
  }
#line 59
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
static char path___0[46]  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
char *file_name(unsigned char *fixed ) 
{ 
  char *p ;
  int i ;
  int j ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 75
  p = path___0;
#line 76
  j = 0;
#line 76
  i = j;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < 8)) {
#line 76
      goto while_break;
    }
#line 77
    if ((int )*(fixed + i) != 32) {
      {
#line 78
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 78
        tmp___0 = j;
#line 78
        j ++;
#line 78
        if (! (tmp___0 < i)) {
#line 78
          goto while_break___0;
        }
#line 79
        tmp = p;
#line 79
        p ++;
#line 79
        *tmp = (char )' ';
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 80
      put_char(& p, *(fixed + i));
      }
    }
#line 76
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  tmp___4 = strncmp((char const   *)(fixed + 8), "   ", (size_t )3);
  }
#line 82
  if (tmp___4) {
#line 83
    tmp___1 = p;
#line 83
    p ++;
#line 83
    *tmp___1 = (char )'.';
#line 84
    j = 0;
#line 84
    i = j;
    {
#line 84
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 84
      if (! (i < 3)) {
#line 84
        goto while_break___1;
      }
#line 85
      if ((int )*(fixed + (i + 8)) != 32) {
        {
#line 86
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 86
          tmp___3 = j;
#line 86
          j ++;
#line 86
          if (! (tmp___3 < i)) {
#line 86
            goto while_break___2;
          }
#line 87
          tmp___2 = p;
#line 87
          p ++;
#line 87
          *tmp___2 = (char )' ';
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 88
        put_char(& p, *(fixed + (i + 8)));
        }
      }
#line 84
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 91
  *p = (char)0;
#line 92
  return (path___0);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
int file_cvt(unsigned char *name , unsigned char *fixed ) 
{ 
  unsigned char c ;
  int size ;
  int ext ;
  int cnt ;
  char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  int tmp___7 ;
  unsigned char *tmp___8 ;
  int tmp___9 ;

  {
#line 100
  size = 8;
#line 101
  ext = 0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! *name) {
#line 102
      goto while_break;
    }
#line 103
    c = *name;
#line 104
    if ((int )c < 32) {
      {
#line 105
      printf((char const   */* __restrict  */)"Invalid character in name. Use \\ooo for special characters.\n");
      }
#line 107
      return (0);
    } else
#line 104
    if ((int )c > 126) {
      {
#line 105
      printf((char const   */* __restrict  */)"Invalid character in name. Use \\ooo for special characters.\n");
      }
#line 107
      return (0);
    } else {
      {
#line 104
      tmp = strchr("*?<>|\"/", (int )c);
      }
#line 104
      if (tmp) {
        {
#line 105
        printf((char const   */* __restrict  */)"Invalid character in name. Use \\ooo for special characters.\n");
        }
#line 107
        return (0);
      }
    }
#line 109
    if ((int )c == 46) {
#line 110
      if (ext) {
        {
#line 111
        printf((char const   */* __restrict  */)"Duplicate dots in name.\n");
        }
#line 112
        return (0);
      }
      {
#line 114
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 114
        tmp___1 = size;
#line 114
        size --;
#line 114
        if (! tmp___1) {
#line 114
          goto while_break___0;
        }
#line 115
        tmp___0 = fixed;
#line 115
        fixed ++;
#line 115
        *tmp___0 = (unsigned char )' ';
      }
      while_break___0: /* CIL Label */ ;
      }
#line 116
      size = 3;
#line 117
      ext = 1;
#line 118
      name ++;
#line 119
      goto while_continue;
    }
#line 121
    if ((int )c == 92) {
#line 122
      c = (unsigned char)0;
#line 123
      cnt = 3;
      {
#line 123
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 123
        if (! cnt) {
#line 123
          goto while_break___1;
        }
#line 124
        if ((int )*name < 48) {
          {
#line 125
          printf((char const   */* __restrict  */)"Invalid octal character.\n");
          }
#line 126
          return (0);
        } else
#line 124
        if ((int )*name > 55) {
          {
#line 125
          printf((char const   */* __restrict  */)"Invalid octal character.\n");
          }
#line 126
          return (0);
        }
#line 128
        tmp___2 = name;
#line 128
        name ++;
#line 128
        c = (unsigned char )(((int )c * 8 + (int )*tmp___2) - 48);
#line 123
        cnt --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 130
      if (cnt < 4) {
        {
#line 131
        printf((char const   */* __restrict  */)"Expected three octal digits.\n");
        }
#line 132
        return (0);
      }
#line 134
      name += 3;
    }
    {
#line 136
    tmp___4 = __ctype_b_loc();
    }
#line 136
    if ((int const   )*(*tmp___4 + (int )c) & 512) {
      {
#line 137
      tmp___3 = toupper((int )c);
#line 137
      c = (unsigned char )tmp___3;
      }
    }
#line 138
    if (size) {
#line 139
      tmp___5 = fixed;
#line 139
      fixed ++;
#line 139
      *tmp___5 = c;
#line 140
      size --;
    }
#line 142
    name ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  if (*name) {
#line 145
    return (0);
  } else
#line 144
  if (size == 8) {
#line 145
    return (0);
  }
#line 146
  if (! ext) {
    {
#line 147
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 147
      tmp___7 = size;
#line 147
      size --;
#line 147
      if (! tmp___7) {
#line 147
        goto while_break___2;
      }
#line 148
      tmp___6 = fixed;
#line 148
      fixed ++;
#line 148
      *tmp___6 = (unsigned char )' ';
    }
    while_break___2: /* CIL Label */ ;
    }
#line 149
    size = 3;
  }
  {
#line 151
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 151
    tmp___9 = size;
#line 151
    size --;
#line 151
    if (! tmp___9) {
#line 151
      goto while_break___3;
    }
#line 152
    tmp___8 = fixed;
#line 152
    fixed ++;
#line 152
    *tmp___8 = (unsigned char )' ';
  }
  while_break___3: /* CIL Label */ ;
  }
#line 153
  return (1);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
void file_add(char *path___3 , FD_TYPE type ) 
{ 
  FDSC **current ;
  FDSC *walk ;
  char name[11] ;
  char *here ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 162
  current = & fp_root;
#line 163
  if ((int )*path___3 != 47) {
    {
#line 164
    die((char *)"%s: Absolute path required.", path___3);
    }
  }
#line 165
  path___3 ++;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 167
    here = strchr((char const   *)path___3, '/');
    }
#line 167
    if (here) {
#line 168
      *here = (char)0;
    }
    {
#line 169
    tmp = file_cvt((unsigned char *)path___3, (unsigned char *)(name));
    }
#line 169
    if (! tmp) {
      {
#line 170
      exit(2);
      }
    }
#line 171
    walk = *current;
    {
#line 171
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 171
      if (! walk) {
#line 171
        goto while_break___0;
      }
#line 172
      if (! here) {
        {
#line 172
        tmp___1 = strncmp((char const   *)(name), (char const   *)(walk->name), (size_t )11);
        }
#line 172
        if (tmp___1) {
#line 172
          if ((unsigned int )type == 2U) {
            {
#line 172
            tmp___2 = strncmp((char const   *)(name + 1), (char const   *)(walk->name + 1),
                              (size_t )10);
            }
#line 172
            if (tmp___2) {
#line 172
              goto _L;
            } else {
              {
#line 181
              die((char *)"Ambiguous name: \"%s\"", path___3);
              }
            }
          } else {
#line 172
            goto _L;
          }
        } else {
          {
#line 181
          die((char *)"Ambiguous name: \"%s\"", path___3);
          }
        }
      } else
      _L: /* CIL Label */ 
#line 182
      if (here) {
        {
#line 182
        tmp___0 = strncmp((char const   *)(name), (char const   *)(walk->name), (size_t )11);
        }
#line 182
        if (! tmp___0) {
#line 183
          goto while_break___0;
        }
      }
#line 171
      walk = walk->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 184
    if (! walk) {
      {
#line 185
      tmp___3 = alloc((int )sizeof(FDSC ));
#line 185
      walk = (FDSC *)tmp___3;
#line 186
      strncpy((char */* __restrict  */)(walk->name), (char const   */* __restrict  */)(name),
              (size_t )11);
      }
#line 187
      if (here) {
#line 187
        walk->type = (FD_TYPE )0;
      } else {
#line 187
        walk->type = type;
      }
#line 188
      walk->first = (struct _fptr *)((void *)0);
#line 189
      walk->next = *current;
#line 190
      *current = walk;
    }
#line 192
    current = & walk->first;
#line 193
    if (! here) {
#line 194
      goto while_break;
    }
#line 195
    *here = (char )'/';
#line 196
    path___3 = here + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
FDSC **file_cd(FDSC **curr , char *fixed ) 
{ 
  FDSC **walk ;
  int tmp ;

  {
#line 204
  if (! curr) {
#line 205
    return ((FDSC **)((void *)0));
  } else
#line 204
  if (! *curr) {
#line 205
    return ((FDSC **)((void *)0));
  }
#line 206
  walk = curr;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! *walk) {
#line 206
      goto while_break;
    }
    {
#line 207
    tmp = strncmp((char const   *)((*walk)->name), (char const   *)fixed, (size_t )11);
    }
#line 207
    if (! tmp) {
#line 207
      if ((*walk)->first) {
#line 208
        return (& (*walk)->first);
      }
    }
#line 206
    walk = & (*walk)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return ((FDSC **)((void *)0));
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
static FDSC **file_find(FDSC **dir , char *fixed ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 214
  if (! dir) {
#line 215
    return ((FDSC **)((void *)0));
  } else
#line 214
  if (! *dir) {
#line 215
    return ((FDSC **)((void *)0));
  }
#line 216
  if ((int )*((unsigned char *)fixed) == 229) {
    {
#line 217
    while (1) {
      while_continue: /* CIL Label */ ;
#line 217
      if (! *dir) {
#line 217
        goto while_break;
      }
      {
#line 218
      tmp = strncmp((char const   *)((*dir)->name + 1), (char const   *)(fixed + 1),
                    (size_t )10);
      }
#line 218
      if (! tmp) {
#line 218
        if (! (*dir)->first) {
#line 220
          return (dir);
        }
      }
#line 221
      dir = & (*dir)->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 223
    return ((FDSC **)((void *)0));
  }
  {
#line 225
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 225
    if (! *dir) {
#line 225
      goto while_break___0;
    }
    {
#line 226
    tmp___0 = strncmp((char const   *)((*dir)->name), (char const   *)fixed, (size_t )11);
    }
#line 226
    if (! tmp___0) {
#line 226
      if (! (*dir)->first) {
#line 227
        return (dir);
      }
    }
#line 228
    dir = & (*dir)->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 230
  return ((FDSC **)((void *)0));
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
FD_TYPE file_type(FDSC **curr , char *fixed ) 
{ 
  FDSC **this ;

  {
  {
#line 239
  this = file_find(curr, fixed);
  }
#line 239
  if (this) {
#line 240
    return ((*this)->type);
  }
#line 241
  return ((FD_TYPE )0);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
void file_modify(FDSC **curr , char *fixed ) 
{ 
  FDSC **this ;
  FDSC *next ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 248
  this = file_find(curr, fixed);
  }
#line 248
  if (! this) {
    {
#line 249
    die((char *)"Internal error: file_find failed");
    }
  }
  {
#line 251
  if ((unsigned int )(*this)->type == 1U) {
#line 251
    goto case_1;
  }
#line 255
  if ((unsigned int )(*this)->type == 2U) {
#line 255
    goto case_2;
  }
#line 259
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 252
  tmp = file_name((unsigned char *)fixed);
#line 252
  printf((char const   */* __restrict  */)"Dropping %s\n", tmp);
#line 253
  *((unsigned char *)fixed) = (unsigned char)229;
  }
#line 254
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 256
  *fixed = (*this)->name[0];
#line 257
  tmp___0 = file_name((unsigned char *)fixed);
#line 257
  printf((char const   */* __restrict  */)"Undeleting %s\n", tmp___0);
  }
#line 258
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 260
  die((char *)"Internal error: file_modify");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 262
  next = (*this)->next;
#line 263
  free((void *)*this);
#line 264
  *this = next;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
static void report_unused(FDSC *this ) 
{ 
  FDSC *next ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! this) {
#line 271
      goto while_break;
    }
#line 272
    next = this->next;
#line 273
    if (this->first) {
      {
#line 274
      report_unused(this->first);
      }
    } else
#line 275
    if ((unsigned int )this->type != 0U) {
      {
#line 276
      tmp = file_name((unsigned char *)(this->name));
      }
#line 276
      if ((unsigned int )this->type == 1U) {
#line 276
        tmp___0 = "drop";
      } else {
#line 276
        tmp___0 = "undelete";
      }
      {
#line 276
      printf((char const   */* __restrict  */)"Warning: did not %s file %s\n", tmp___0,
             tmp);
      }
    }
    {
#line 278
    free((void *)this);
#line 279
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
void file_unused(void) 
{ 


  {
  {
#line 285
  report_unused(fp_root);
  }
#line 286
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.h"
int write_immed ;
#line 36 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.h"
void fs_open(char *path___3 , int rw___0 ) ;
#line 57
int fs_close(int write___0 ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fatlabel.c"
int interactive  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fatlabel.c"
int rw  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fatlabel.c"
int list  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fatlabel.c"
int test  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fatlabel.c"
int verbose  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fatlabel.c"
int write_immed  =    0;
#line 44 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fatlabel.c"
int atari_format  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fatlabel.c"
unsigned int n_files  =    0U;
#line 46 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fatlabel.c"
void *mem_queue  =    (void *)0;
#line 48 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fatlabel.c"
static void usage(int error ) 
{ 
  FILE *f ;
  struct _IO_FILE *tmp ;
  int status ;
  int tmp___0 ;

  {
#line 50
  if (error) {
#line 50
    tmp = stderr;
  } else {
#line 50
    tmp = stdout;
  }
#line 50
  f = tmp;
#line 51
  if (error) {
#line 51
    tmp___0 = 1;
  } else {
#line 51
    tmp___0 = 0;
  }
  {
#line 51
  status = tmp___0;
#line 53
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"usage: fatlabel device [label]\n");
#line 54
  exit(status);
  }
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fatlabel.c"
static void check_atari(void) 
{ 


  {
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fatlabel.c"
int main(int argc , char **argv ) 
{ 
  DOS_FS fs ;
  int i ;
  char *device ;
  char label[12] ;
  unsigned int tmp ;
  loff_t offset ;
  DIR_ENT de ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 87
  fs.nfats = 0;
#line 87
  fs.fat_start = 0L;
#line 87
  fs.fat_size = 0U;
#line 87
  fs.fat_bits = 0U;
#line 87
  fs.eff_fat_bits = 0U;
#line 87
  fs.root_cluster = 0U;
#line 87
  fs.root_start = 0L;
#line 87
  fs.root_entries = 0U;
#line 87
  fs.data_start = 0L;
#line 87
  fs.cluster_size = 0U;
#line 87
  fs.clusters = 0U;
#line 87
  fs.fsinfo_start = 0L;
#line 87
  fs.free_clusters = 0L;
#line 87
  fs.backupboot_start = 0L;
#line 87
  fs.fat = (unsigned char *)0;
#line 87
  fs.cluster_owner = (DOS_FILE **)0;
#line 87
  fs.label = (char *)0;
#line 88
  rw = 0;
#line 92
  device = (char *)((void *)0);
#line 93
  label[0] = (char)0;
#line 93
  tmp = 1U;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (tmp >= 12U) {
#line 93
      goto while_break;
    }
#line 93
    label[tmp] = (char)0;
#line 93
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 98
  check_atari();
  }
#line 100
  if (argc < 2) {
    {
#line 101
    usage(1);
    }
  } else
#line 100
  if (argc > 3) {
    {
#line 101
    usage(1);
    }
  }
  {
#line 103
  tmp___2 = strcmp((char const   *)*(argv + 1), "-h");
  }
#line 103
  if (tmp___2) {
    {
#line 103
    tmp___3 = strcmp((char const   *)*(argv + 1), "--help");
    }
#line 103
    if (tmp___3) {
      {
#line 105
      tmp___0 = strcmp((char const   *)*(argv + 1), "-V");
      }
#line 105
      if (tmp___0) {
        {
#line 105
        tmp___1 = strcmp((char const   *)*(argv + 1), "--version");
        }
#line 105
        if (! tmp___1) {
          {
#line 106
          printf((char const   */* __restrict  */)"fatlabel 3.0.26 (2014-03-07)\n");
#line 107
          exit(0);
          }
        }
      } else {
        {
#line 106
        printf((char const   */* __restrict  */)"fatlabel 3.0.26 (2014-03-07)\n");
#line 107
        exit(0);
        }
      }
    } else {
      {
#line 104
      usage(0);
      }
    }
  } else {
    {
#line 104
    usage(0);
    }
  }
#line 110
  device = *(argv + 1);
#line 111
  if (argc == 3) {
    {
#line 112
    strncpy((char */* __restrict  */)(label), (char const   */* __restrict  */)*(argv + 2),
            (size_t )11);
#line 113
    tmp___4 = strlen((char const   *)*(argv + 2));
    }
#line 113
    if (tmp___4 > 11UL) {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fatlabel: labels can be no longer than 11 characters\n");
#line 116
      exit(1);
      }
    }
#line 118
    i = 0;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (label[i]) {
#line 118
        if (! (i < 11)) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
      {
#line 120
      tmp___5 = __ctype_b_loc();
      }
#line 120
      if ((int const   )*(*tmp___5 + (int )label[i]) & 512) {
        {
#line 121
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fatlabel: warning - lowercase labels might not work properly with DOS or Windows\n");
        }
#line 123
        goto while_break___0;
      }
#line 118
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 125
    rw = 1;
  }
  {
#line 128
  fs_open(device, rw);
#line 129
  read_boot(& fs);
  }
#line 130
  if (fs.fat_bits == 32U) {
    {
#line 131
    read_fat(& fs);
    }
  }
#line 132
  if (! rw) {
    {
#line 133
    offset = find_volume_de(& fs, & de);
    }
#line 134
    if (offset == 0L) {
      {
#line 135
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
              fs.label);
      }
    } else {
      {
#line 137
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%.8s%.3s\n",
              de.name, de.ext);
      }
    }
    {
#line 138
    exit(0);
    }
  }
  {
#line 141
  write_label(& fs, label);
#line 142
  fs_close(rw);
  }
#line 143
  return (0);
}
}
#line 345 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek64)(int __fd ,
                                                                                    __off64_t __offset ,
                                                                                    int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.h"
loff_t llseek(int fd___1 , loff_t offset , int whence ) ;
#line 63
int fs_changed(void) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.h"
unsigned int device_no  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
static CHANGE *changes  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
static CHANGE *last  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
static int fd  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
static int did_change  =    0;
#line 75 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
loff_t llseek(int fd___1 , loff_t offset , int whence ) 
{ 
  __off64_t tmp ;

  {
  {
#line 77
  tmp = lseek64(fd___1, offset, whence);
  }
#line 77
  return (tmp);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
void fs_open(char *path___3 , int rw___0 ) 
{ 
  struct stat stbuf ;
  int tmp ;
  int tmp___0 ;

  {
#line 85
  if (rw___0) {
#line 85
    tmp = 2;
  } else {
#line 85
    tmp = 0;
  }
  {
#line 85
  fd = open((char const   *)path___3, tmp);
  }
#line 85
  if (fd < 0) {
    {
#line 86
    perror("open");
#line 87
    exit(6);
    }
  }
  {
#line 89
  last = (CHANGE *)((void *)0);
#line 89
  changes = last;
#line 90
  did_change = 0;
#line 93
  tmp___0 = fstat(fd, & stbuf);
  }
#line 93
  if (tmp___0 < 0) {
    {
#line 94
    pdie((char *)"fstat %s", path___3);
    }
  }
#line 95
  if ((stbuf.st_mode & 61440U) == 24576U) {
#line 95
    device_no = (unsigned int )((stbuf.st_rdev >> 8) & 255UL);
  } else {
#line 95
    device_no = 0U;
  }
#line 110
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
void fs_read(loff_t pos , int size , void *data ) 
{ 
  CHANGE *walk ;
  int got ;
  loff_t tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 126
  tmp = llseek(fd, pos, 0);
  }
#line 126
  if (tmp != pos) {
    {
#line 127
    pdie((char *)"Seek to %lld", pos);
    }
  }
  {
#line 128
  tmp___0 = read(fd, data, (size_t )size);
#line 128
  got = (int )tmp___0;
  }
#line 128
  if (got < 0) {
    {
#line 129
    pdie((char *)"Read %d bytes at %lld", size, pos);
    }
  }
#line 130
  if (got != size) {
    {
#line 131
    die((char *)"Got %d bytes instead of %d at %lld", got, size, pos);
    }
  }
#line 132
  walk = changes;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! walk) {
#line 132
      goto while_break;
    }
#line 133
    if (walk->pos < pos + (loff_t )size) {
#line 133
      if (walk->pos + (loff_t )walk->size > pos) {
#line 134
        if (walk->pos < pos) {
          {
#line 135
          tmp___1 = min(size, (int )(((loff_t )walk->size - pos) + walk->pos));
#line 135
          memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)(((char *)walk->data + pos) - walk->pos),
                 (size_t )tmp___1);
          }
        } else {
          {
#line 142
          tmp___2 = min(walk->size, (int )(((loff_t )size + pos) - walk->pos));
#line 142
          memcpy((void */* __restrict  */)(((char *)data + walk->pos) - pos), (void const   */* __restrict  */)walk->data,
                 (size_t )tmp___2);
          }
        }
      }
    }
#line 132
    walk = walk->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
int fs_test(loff_t pos , int size ) 
{ 
  void *scratch ;
  int okay ;
  loff_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 153
  tmp = llseek(fd, pos, 0);
  }
#line 153
  if (tmp != pos) {
    {
#line 154
    pdie((char *)"Seek to %lld", pos);
    }
  }
  {
#line 155
  scratch = alloc(size);
#line 156
  tmp___0 = read(fd, scratch, (size_t )size);
#line 156
  okay = tmp___0 == (ssize_t )size;
#line 157
  free(scratch);
  }
#line 158
  return (okay);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
void fs_write(loff_t pos , int size , void *data ) 
{ 
  CHANGE *new ;
  int did ;
  loff_t tmp ;
  ssize_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 166
  if (write_immed) {
    {
#line 167
    did_change = 1;
#line 168
    tmp = llseek(fd, pos, 0);
    }
#line 168
    if (tmp != pos) {
      {
#line 169
      pdie((char *)"Seek to %lld", pos);
      }
    }
    {
#line 170
    tmp___0 = write(fd, (void const   *)data, (size_t )size);
#line 170
    did = (int )tmp___0;
    }
#line 170
    if (did == size) {
#line 171
      return;
    }
#line 172
    if (did < 0) {
      {
#line 173
      pdie((char *)"Write %d bytes at %lld", size, pos);
      }
    }
    {
#line 174
    die((char *)"Wrote %d bytes instead of %d at %lld", did, size, pos);
    }
  }
  {
#line 176
  tmp___1 = alloc((int )sizeof(CHANGE ));
#line 176
  new = (CHANGE *)tmp___1;
#line 177
  new->pos = pos;
#line 178
  tmp___3 = size;
#line 178
  new->size = tmp___3;
#line 178
  tmp___2 = alloc(tmp___3);
#line 178
  new->data = tmp___2;
#line 178
  memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)data,
         (size_t )size);
#line 179
  new->next = (struct _change *)((void *)0);
  }
#line 180
  if (last) {
#line 181
    last->next = new;
  } else {
#line 183
    changes = new;
  }
#line 184
  last = new;
#line 185
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
static void fs_flush(void) 
{ 
  CHANGE *this ;
  int size ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  loff_t tmp___4 ;

  {
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! changes) {
#line 192
      goto while_break;
    }
    {
#line 193
    this = changes;
#line 194
    changes = changes->next;
#line 195
    tmp___4 = llseek(fd, this->pos, 0);
    }
#line 195
    if (tmp___4 != this->pos) {
      {
#line 196
      tmp = __errno_location();
#line 196
      tmp___0 = strerror(*tmp);
#line 196
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seek to %lld failed: %s\n  Did not write %d bytes.\n",
              (long long )this->pos, tmp___0, this->size);
      }
    } else {
      {
#line 199
      tmp___3 = write(fd, (void const   *)this->data, (size_t )this->size);
#line 199
      size = (int )tmp___3;
      }
#line 199
      if (size < 0) {
        {
#line 200
        tmp___1 = __errno_location();
#line 200
        tmp___2 = strerror(*tmp___1);
#line 200
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Writing %d bytes at %lld failed: %s\n",
                this->size, (long long )this->pos, tmp___2);
        }
      } else
#line 202
      if (size != this->size) {
        {
#line 203
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrote %d bytes instead of %d bytes at %lld.\n",
                size, this->size, (long long )this->pos);
        }
      }
    }
    {
#line 205
    free(this->data);
#line 206
    free((void *)this);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
int fs_close(int write___0 ) 
{ 
  CHANGE *next ;
  int changed ;
  int tmp ;
  int tmp___0 ;

  {
#line 215
  changed = ! (! changes);
#line 216
  if (write___0) {
    {
#line 217
    fs_flush();
    }
  } else {
    {
#line 219
    while (1) {
      while_continue: /* CIL Label */ ;
#line 219
      if (! changes) {
#line 219
        goto while_break;
      }
      {
#line 220
      next = changes->next;
#line 221
      free(changes->data);
#line 222
      free((void *)changes);
#line 223
      changes = next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 225
  tmp = close(fd);
  }
#line 225
  if (tmp < 0) {
    {
#line 226
    pdie((char *)"closing filesystem");
    }
  }
#line 227
  if (changed) {
#line 227
    tmp___0 = 1;
  } else
#line 227
  if (did_change) {
#line 227
    tmp___0 = 1;
  } else {
#line 227
    tmp___0 = 0;
  }
#line 227
  return (tmp___0);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
int fs_changed(void) 
{ 
  int tmp ;

  {
#line 232
  if (! (! changes)) {
#line 232
    tmp = 1;
  } else
#line 232
  if (did_change) {
#line 232
    tmp = 1;
  } else {
#line 232
    tmp = 0;
  }
#line 232
  return (tmp);
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 66 "/usr/include/mntent.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) setmntent)(char const   *__file ,
                                                                                  char const   *__mode ) ;
#line 71
extern  __attribute__((__nothrow__)) struct mntent *( __attribute__((__leaf__)) getmntent)(FILE *__stream ) ;
#line 87
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) endmntent)(FILE *__stream ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 214
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
__inline static int cdiv(int a , int b ) 
{ 


  {
#line 102
  return (((a + b) - 1) / b);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
char dummy_boot_jump[3]  = {      (char)-21,      (char)60,      (char)-112};
#line 224 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
char dummy_boot_jump_m68k[2]  = {      (char)96,      (char)28};
#line 227 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
char dummy_boot_code[448]  = 
#line 227
  {      (char )'\016',      (char )'\037',      (char )'\276',      (char )'[', 
        (char )'|',      (char )'\254',      (char )'\"',      (char )'\300', 
        (char )'t',      (char )'\v',      (char )'V',      (char )'\264', 
        (char )'\016',      (char )'\273',      (char )'\a',      (char )'\000', 
        (char )'\315',      (char )'\020',      (char )'^',      (char )'\353', 
        (char )'\360',      (char )'2',      (char )'\344',      (char )'\315', 
        (char )'\026',      (char )'\315',      (char )'\031',      (char )'\353', 
        (char )'\376',      (char )'T',      (char )'h',      (char )'i', 
        (char )'s',      (char )' ',      (char )'i',      (char )'s', 
        (char )' ',      (char )'n',      (char )'o',      (char )'t', 
        (char )' ',      (char )'a',      (char )' ',      (char )'b', 
        (char )'o',      (char )'o',      (char )'t',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )' ', 
        (char )'d',      (char )'i',      (char )'s',      (char )'k', 
        (char )'.',      (char )' ',      (char )' ',      (char )'P', 
        (char )'l',      (char )'e',      (char )'a',      (char )'s', 
        (char )'e',      (char )' ',      (char )'i',      (char )'n', 
        (char )'s',      (char )'e',      (char )'r',      (char )'t', 
        (char )' ',      (char )'a',      (char )' ',      (char )'b', 
        (char )'o',      (char )'o',      (char )'t',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )' ', 
        (char )'f',      (char )'l',      (char )'o',      (char )'p', 
        (char )'p',      (char )'y',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )'\r',      (char )'\n', 
        (char )'p',      (char )'r',      (char )'e',      (char )'s', 
        (char )'s',      (char )' ',      (char )'a',      (char )'n', 
        (char )'y',      (char )' ',      (char )'k',      (char )'e', 
        (char )'y',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'t',      (char )'r',      (char )'y', 
        (char )' ',      (char )'a',      (char )'g',      (char )'a', 
        (char )'i',      (char )'n',      (char )' ',      (char )'.', 
        (char )'.',      (char )'.',      (char )' ',      (char )'\r', 
        (char )'\n',      (char )'\000'};
#line 253 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static char *program_name  =    (char *)"mkfs.fat";
#line 254 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static char *device_name  =    (char *)((void *)0);
#line 255 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int atari_format___0  =    0;
#line 256 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int check  =    0;
#line 257 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int verbose___0  =    0;
#line 258 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static long volume_id  ;
#line 259 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static time_t create_time  ;
#line 260 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static struct timeval create_timeval  ;
#line 261 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static char volume_name[12]  = 
#line 261
  {      (char )'N',      (char )'O',      (char )' ',      (char )'N', 
        (char )'A',      (char )'M',      (char )'E',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\000'};
#line 262 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static uint64_t blocks  ;
#line 263 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int sector_size  =    512;
#line 264 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int sector_size_set  =    0;
#line 265 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int backup_boot  =    0;
#line 266 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int reserved_sectors  =    0;
#line 267 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int badblocks  =    0;
#line 268 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int nr_fats  =    2;
#line 269 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int size_fat  =    0;
#line 270 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int size_fat_by_user  =    0;
#line 271 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int dev  =    -1;
#line 272 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int ignore_full_disk  =    0;
#line 273 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static off_t currently_testing  =    (off_t )0;
#line 274 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static struct msdos_boot_sector bs  ;
#line 275 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int start_data_sector  ;
#line 276 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int start_data_block  ;
#line 277 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static unsigned char *fat  ;
#line 278 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static unsigned int alloced_fat_length  ;
#line 279 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static unsigned char *info_sector  ;
#line 280 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static struct msdos_dir_entry___0 *root_dir  ;
#line 281 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int size_root_dir  ;
#line 282 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int sectors_per_cluster  =    0;
#line 283 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int root_dir_entries  =    0;
#line 284 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static char *blank_sector  ;
#line 285 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int hidden_sectors  =    0;
#line 286 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int hidden_sectors_by_user  =    0;
#line 287 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int drive_number_option  =    0;
#line 288 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int drive_number_by_user  =    0;
#line 289 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int fat_media_byte  =    0;
#line 290 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int malloc_entire_fat  =    0;
#line 291 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int align_structures  =    1;
#line 292 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int orphaned_sectors  =    0;
#line 296
static  __attribute__((__noreturn__)) void fatal_error(char const   *fmt_string ) ;
#line 297
static void mark_FAT_cluster(int cluster , unsigned int value ) ;
#line 298
static void mark_FAT_sector(int sector , unsigned int value ) ;
#line 299
static long do_check(char *buffer , int try , off_t current_block ) ;
#line 300
static void alarm_intr(int alnum ) ;
#line 301
static void check_blocks(void) ;
#line 302
static void get_list_blocks(char *filename ) ;
#line 303
static int valid_offset(int fd___1 , loff_t offset ) ;
#line 304
static uint64_t count_blocks(char *filename , int *remainder ) ;
#line 305
static void check_mount(char *device_name___0 ) ;
#line 306
static void establish_params(int device_num , int size ) ;
#line 307
static void setup_tables(void) ;
#line 308
static void write_tables(void) ;
#line 314
static  __attribute__((__noreturn__)) void fatal_error(char const   *fmt_string ) ;
#line 314 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static void fatal_error(char const   *fmt_string ) 
{ 


  {
  {
#line 316
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt_string,
          program_name, device_name);
#line 317
  exit(1);
  }
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static void mark_FAT_cluster(int cluster , unsigned int value ) 
{ 


  {
  {
#line 325
  if (size_fat == 12) {
#line 325
    goto case_12;
  }
#line 340
  if (size_fat == 16) {
#line 340
    goto case_16;
  }
#line 346
  if (size_fat == 32) {
#line 346
    goto case_32;
  }
#line 354
  goto switch_default;
  case_12: /* CIL Label */ 
#line 326
  value &= 4095U;
#line 327
  if ((cluster * 3 & 1) == 0) {
#line 328
    *(fat + (3 * cluster) / 2) = (unsigned char )(value & 255U);
#line 329
    *(fat + ((3 * cluster) / 2 + 1)) = (unsigned char )((unsigned int )((int )*(fat + ((3 * cluster) / 2 + 1)) & 240) | ((value & 3840U) >> 8));
  } else {
#line 333
    *(fat + (3 * cluster) / 2) = (unsigned char )((unsigned int )((int )*(fat + (3 * cluster) / 2) & 15) | ((value & 15U) << 4));
#line 336
    *(fat + ((3 * cluster) / 2 + 1)) = (unsigned char )((value & 4080U) >> 4);
  }
#line 338
  goto switch_break;
  case_16: /* CIL Label */ 
#line 341
  value &= 65535U;
#line 342
  *(fat + 2 * cluster) = (unsigned char )(value & 255U);
#line 343
  *(fat + (2 * cluster + 1)) = (unsigned char )(value >> 8);
#line 344
  goto switch_break;
  case_32: /* CIL Label */ 
#line 347
  value &= 268435455U;
#line 348
  *(fat + 4 * cluster) = (unsigned char )(value & 255U);
#line 349
  *(fat + (4 * cluster + 1)) = (unsigned char )((value & 65280U) >> 8);
#line 350
  *(fat + (4 * cluster + 2)) = (unsigned char )((value & 16711680U) >> 16);
#line 351
  *(fat + (4 * cluster + 3)) = (unsigned char )((value & 4278190080U) >> 24);
#line 352
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 355
  fatal_error("%s: Bad FAT size (not 12, 16, or 32)\n");
  }
  switch_break: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static void mark_FAT_sector(int sector , unsigned int value ) 
{ 
  int cluster ;

  {
#line 365
  cluster = ((sector - start_data_sector) / (int )bs.cluster_size) / (sector_size / 512);
#line 367
  if (cluster < 0) {
    {
#line 368
    fatal_error("%s: Invalid cluster number in mark_FAT_sector: probably bug!\n");
    }
  }
  {
#line 370
  mark_FAT_cluster(cluster, value);
  }
#line 371
  return;
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static long do_check(char *buffer , int try , off_t current_block ) 
{ 
  long got ;
  __off_t tmp ;

  {
  {
#line 379
  tmp = lseek(dev, current_block * (off_t )(1 << 10), 0);
  }
#line 379
  if (tmp != current_block * (off_t )(1 << 10)) {
    {
#line 381
    fatal_error("%s: seek failed during testing for blocks\n");
    }
  }
  {
#line 383
  got = read(dev, (void *)buffer, (size_t )(try * (1 << 10)));
  }
#line 384
  if (got < 0L) {
#line 385
    got = 0L;
  }
#line 387
  if (got & (long )((1 << 10) - 1)) {
    {
#line 388
    printf((char const   */* __restrict  */)"Unexpected values in do_check: probably bugs\n");
    }
  }
#line 389
  got /= (long )(1 << 10);
#line 391
  return (got);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static void alarm_intr(int alnum ) 
{ 


  {
#line 401
  if ((uint64_t )currently_testing >= blocks) {
#line 402
    return;
  }
  {
#line 404
  signal(14, & alarm_intr);
#line 405
  alarm(5U);
  }
#line 406
  if (! currently_testing) {
#line 407
    return;
  }
  {
#line 409
  printf((char const   */* __restrict  */)"%lld... ", (unsigned long long )currently_testing);
#line 410
  fflush(stdout);
  }
#line 411
  return;
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static char blkbuf[16384]  ;
#line 413 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static void check_blocks(void) 
{ 
  int try ;
  int got ;
  int i ;
  long tmp ;
  char const   *tmp___0 ;

  {
#line 419
  if (verbose___0) {
    {
#line 420
    printf((char const   */* __restrict  */)"Searching for bad blocks ");
#line 421
    fflush(stdout);
    }
  }
#line 423
  currently_testing = (off_t )0;
#line 424
  if (verbose___0) {
    {
#line 425
    signal(14, & alarm_intr);
#line 426
    alarm(5U);
    }
  }
#line 428
  try = 16;
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! ((uint64_t )currently_testing < blocks)) {
#line 429
      goto while_break;
    }
#line 430
    if ((uint64_t )(currently_testing + (off_t )try) > blocks) {
#line 431
      try = (int )(blocks - (uint64_t )currently_testing);
    }
    {
#line 432
    tmp = do_check(blkbuf, try, currently_testing);
#line 432
    got = (int )tmp;
#line 433
    currently_testing += (off_t )got;
    }
#line 434
    if (got == try) {
#line 435
      try = 16;
#line 436
      goto while_continue;
    } else {
#line 438
      try = 1;
    }
#line 439
    if (currently_testing < (off_t )start_data_block) {
      {
#line 440
      fatal_error("%s: bad blocks before data-area: cannot make fs\n");
      }
    }
#line 442
    i = 0;
    {
#line 442
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 442
      if (! (i < (1 << 10) / 512)) {
#line 442
        goto while_break___0;
      }
      {
#line 443
      mark_FAT_sector((int )(currently_testing * (off_t )((1 << 10) / 512) + (off_t )i),
                      268435447U);
#line 442
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 444
    badblocks ++;
#line 445
    currently_testing ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  if (verbose___0) {
    {
#line 449
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 451
  if (badblocks) {
#line 452
    if (badblocks > 1) {
#line 452
      tmp___0 = "s";
    } else {
#line 452
      tmp___0 = "";
    }
    {
#line 452
    printf((char const   */* __restrict  */)"%d bad block%s\n", badblocks, tmp___0);
    }
  }
#line 453
  return;
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static void get_list_blocks(char *filename ) 
{ 
  int i ;
  FILE *listfile ;
  long blockno ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 461
  listfile = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 462
  if ((unsigned long )listfile == (unsigned long )((FILE *)((void *)0))) {
    {
#line 463
    fatal_error("%s: Can\'t open file of bad blocks\n");
    }
  }
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 465
    tmp = feof(listfile);
    }
#line 465
    if (tmp) {
#line 465
      goto while_break;
    }
    {
#line 466
    fscanf((FILE */* __restrict  */)listfile, (char const   */* __restrict  */)"%ld\n",
           & blockno);
#line 467
    i = 0;
    }
    {
#line 467
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 467
      if (! (i < (1 << 10) / 512)) {
#line 467
        goto while_break___0;
      }
      {
#line 468
      mark_FAT_sector((int )(blockno * (long )((1 << 10) / 512) + (long )i), 268435447U);
#line 467
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 469
    badblocks ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 471
  fclose(listfile);
  }
#line 473
  if (badblocks) {
#line 474
    if (badblocks > 1) {
#line 474
      tmp___0 = "s";
    } else {
#line 474
      tmp___0 = "";
    }
    {
#line 474
    printf((char const   */* __restrict  */)"%d bad block%s\n", badblocks, tmp___0);
    }
  }
#line 475
  return;
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static int valid_offset(int fd___1 , loff_t offset ) 
{ 
  char ch ;
  __off_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 484
  tmp = lseek(fd___1, offset, 0);
  }
#line 484
  if (tmp < 0L) {
#line 485
    return (0);
  }
  {
#line 486
  tmp___0 = read(fd___1, (void *)(& ch), (size_t )1);
  }
#line 486
  if (tmp___0 < 1L) {
#line 487
    return (0);
  }
#line 488
  return (1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static uint64_t count_blocks(char *filename , int *remainder ) 
{ 
  loff_t high ;
  loff_t low ;
  int fd___1 ;
  int tmp ;
  loff_t mid ;
  int tmp___0 ;

  {
  {
#line 498
  fd___1 = open((char const   *)filename, 0);
  }
#line 498
  if (fd___1 < 0) {
    {
#line 499
    perror((char const   *)filename);
#line 500
    exit(1);
    }
  }
  {
#line 504
  low = lseek(fd___1, (__off_t )0, 2);
  }
#line 504
  if (low <= 0L) {
#line 505
    low = (loff_t )0;
#line 506
    high = (loff_t )1;
    {
#line 506
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 506
      tmp = valid_offset(fd___1, high);
      }
#line 506
      if (! tmp) {
#line 506
        goto while_break;
      }
#line 507
      low = high;
#line 506
      high *= 2L;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 508
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 508
      if (! (low < high - 1L)) {
#line 508
        goto while_break___0;
      }
      {
#line 509
      mid = (low + high) / 2L;
#line 510
      tmp___0 = valid_offset(fd___1, mid);
      }
#line 510
      if (tmp___0) {
#line 511
        low = mid;
      } else {
#line 513
        high = mid;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 515
    low ++;
  }
  {
#line 518
  close(fd___1);
#line 519
  *remainder = (int )((low % (long )(1 << 10)) / (long )sector_size);
  }
#line 520
  return ((uint64_t )(low / (loff_t )(1 << 10)));
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static void check_mount(char *device_name___0 ) 
{ 
  FILE *f ;
  struct mntent *mnt ;
  int tmp ;

  {
  {
#line 530
  f = setmntent("/etc/mtab", "r");
  }
#line 530
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 531
    return;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 532
    mnt = getmntent(f);
    }
#line 532
    if (! ((unsigned long )mnt != (unsigned long )((void *)0))) {
#line 532
      goto while_break;
    }
    {
#line 533
    tmp = strcmp((char const   *)device_name___0, (char const   *)mnt->mnt_fsname);
    }
#line 533
    if (tmp == 0) {
      {
#line 534
      fatal_error("%s: %s contains a mounted filesystem.\n");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 535
  endmntent(f);
  }
#line 536
  return;
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static void establish_params(int device_num , int size ) 
{ 
  long loop_size ;
  struct hd_geometry geometry ;
  struct floppy_struct param ;
  int def_root_dir_entries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  uint32_t sz_mb ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 545
  def_root_dir_entries = 512;
#line 547
  if (0 == device_num) {
#line 547
    goto _L;
  } else
#line 547
  if ((device_num & 65280) == 512) {
    _L: /* CIL Label */ 
#line 550
    if (0 == device_num) {
#line 551
      param.size = (unsigned int )(size / 512);
      {
#line 553
      if (param.size == 720U) {
#line 553
        goto case_720;
      }
#line 557
      if (param.size == 1440U) {
#line 557
        goto case_1440;
      }
#line 561
      if (param.size == 2400U) {
#line 561
        goto case_2400;
      }
#line 565
      if (param.size == 2880U) {
#line 565
        goto case_2880;
      }
#line 569
      if (param.size == 5760U) {
#line 569
        goto case_5760;
      }
#line 573
      goto switch_default;
      case_720: /* CIL Label */ 
#line 554
      param.sect = 9U;
#line 555
      param.head = 2U;
#line 556
      goto switch_break;
      case_1440: /* CIL Label */ 
#line 558
      param.sect = 9U;
#line 559
      param.head = 2U;
#line 560
      goto switch_break;
      case_2400: /* CIL Label */ 
#line 562
      param.sect = 15U;
#line 563
      param.head = 2U;
#line 564
      goto switch_break;
      case_2880: /* CIL Label */ 
#line 566
      param.sect = 18U;
#line 567
      param.head = 2U;
#line 568
      goto switch_break;
      case_5760: /* CIL Label */ 
#line 570
      param.sect = 36U;
#line 571
      param.head = 2U;
#line 572
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 575
      param.sect = 32U;
#line 576
      param.head = 64U;
#line 577
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 582
      tmp = ioctl(dev, (unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 4U) | (sizeof(struct floppy_struct ) << 16),
                  & param);
      }
#line 582
      if (tmp) {
        {
#line 583
        fatal_error("%s: unable to get diskette geometry for \'%s\'\n");
        }
      }
    }
#line 585
    bs.secs_track = (__u16 )param.sect;
#line 586
    bs.heads = (__u16 )param.head;
    {
#line 588
    if (param.size == 720U) {
#line 588
      goto case_720___0;
    }
#line 594
    if (param.size == 1440U) {
#line 594
      goto case_1440___0;
    }
#line 600
    if (param.size == 2400U) {
#line 600
      goto case_2400___0;
    }
#line 606
    if (param.size == 5760U) {
#line 606
      goto case_5760___0;
    }
#line 612
    if (param.size == 2880U) {
#line 612
      goto floppy_default;
    }
#line 619
    goto switch_default___0;
    case_720___0: /* CIL Label */ 
#line 589
    bs.media = (__u8 )(char)-3;
#line 590
    bs.cluster_size = (__u8 )(char)2;
#line 591
    def_root_dir_entries = 112;
#line 592
    goto switch_break___0;
    case_1440___0: /* CIL Label */ 
#line 595
    bs.media = (__u8 )(char)-7;
#line 596
    bs.cluster_size = (__u8 )(char)2;
#line 597
    def_root_dir_entries = 112;
#line 598
    goto switch_break___0;
    case_2400___0: /* CIL Label */ 
#line 601
    bs.media = (__u8 )(char)-7;
#line 602
    if (atari_format___0) {
#line 602
      tmp___0 = 2;
    } else {
#line 602
      tmp___0 = 1;
    }
#line 602
    bs.cluster_size = (__u8 )((char )tmp___0);
#line 603
    def_root_dir_entries = 224;
#line 604
    goto switch_break___0;
    case_5760___0: /* CIL Label */ 
#line 607
    bs.media = (__u8 )(char)-16;
#line 608
    bs.cluster_size = (__u8 )(char)2;
#line 609
    def_root_dir_entries = 224;
#line 610
    goto switch_break___0;
    floppy_default: 
    case_2880___0: /* CIL Label */ 
#line 614
    bs.media = (__u8 )(char)-16;
#line 615
    if (atari_format___0) {
#line 615
      tmp___1 = 2;
    } else {
#line 615
      tmp___1 = 1;
    }
#line 615
    bs.cluster_size = (__u8 )((char )tmp___1);
#line 616
    def_root_dir_entries = 224;
#line 617
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 620
    if (0 == device_num) {
#line 621
      goto def_hd_params;
    } else {
#line 623
      goto floppy_default;
    }
    switch_break___0: /* CIL Label */ ;
    }
  } else
#line 625
  if ((device_num & 65280) == 1792) {
    {
#line 626
    tmp___2 = ioctl(dev, (unsigned long )((unsigned int )(18 << 8) | 96U), & loop_size);
    }
#line 626
    if (tmp___2) {
      {
#line 627
      fatal_error("%s: unable to get loop device size\n");
      }
    }
    {
#line 630
    if (loop_size == 720L) {
#line 630
      goto case_720___1;
    }
#line 638
    if (loop_size == 1440L) {
#line 638
      goto case_1440___1;
    }
#line 646
    if (loop_size == 2400L) {
#line 646
      goto case_2400___1;
    }
#line 654
    if (loop_size == 5760L) {
#line 654
      goto case_5760___1;
    }
#line 663
    if (loop_size == 2880L) {
#line 663
      goto case_2880___1;
    }
#line 671
    goto switch_default___1;
    case_720___1: /* CIL Label */ 
#line 631
    bs.secs_track = (__u16 )9;
#line 632
    bs.heads = (__u16 )2;
#line 633
    bs.media = (__u8 )(char)-3;
#line 634
    bs.cluster_size = (__u8 )(char)2;
#line 635
    def_root_dir_entries = 112;
#line 636
    goto switch_break___1;
    case_1440___1: /* CIL Label */ 
#line 639
    bs.secs_track = (__u16 )9;
#line 640
    bs.heads = (__u16 )2;
#line 641
    bs.media = (__u8 )(char)-7;
#line 642
    bs.cluster_size = (__u8 )(char)2;
#line 643
    def_root_dir_entries = 112;
#line 644
    goto switch_break___1;
    case_2400___1: /* CIL Label */ 
#line 647
    bs.secs_track = (__u16 )15;
#line 648
    bs.heads = (__u16 )2;
#line 649
    bs.media = (__u8 )(char)-7;
#line 650
    if (atari_format___0) {
#line 650
      tmp___3 = 2;
    } else {
#line 650
      tmp___3 = 1;
    }
#line 650
    bs.cluster_size = (__u8 )((char )tmp___3);
#line 651
    def_root_dir_entries = 224;
#line 652
    goto switch_break___1;
    case_5760___1: /* CIL Label */ 
#line 655
    bs.secs_track = (__u16 )36;
#line 656
    bs.heads = (__u16 )2;
#line 657
    bs.media = (__u8 )(char)-16;
#line 658
    bs.cluster_size = (__u8 )(char)2;
#line 659
    bs.dir_entries[0] = (__u8 )(char)-32;
#line 660
    bs.dir_entries[1] = (__u8 )(char)0;
#line 661
    goto switch_break___1;
    case_2880___1: /* CIL Label */ 
#line 664
    bs.secs_track = (__u16 )18;
#line 665
    bs.heads = (__u16 )2;
#line 666
    bs.media = (__u8 )(char)-16;
#line 667
    if (atari_format___0) {
#line 667
      tmp___4 = 2;
    } else {
#line 667
      tmp___4 = 1;
    }
#line 667
    bs.cluster_size = (__u8 )((char )tmp___4);
#line 668
    def_root_dir_entries = 224;
#line 669
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 672
    printf((char const   */* __restrict  */)"Loop device does not match a floppy size, using default hd params\n");
#line 674
    bs.secs_track = (__u16 )32;
#line 675
    bs.heads = (__u16 )64;
    }
#line 676
    goto def_hd_params;
    switch_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 683
    tmp___5 = ioctl(dev, 769UL, & geometry);
    }
#line 683
    if (tmp___5) {
      {
#line 685
      printf((char const   */* __restrict  */)"unable to get drive geometry, using default 255/63\n");
#line 686
      bs.secs_track = (__u16 )63;
#line 687
      bs.heads = (__u16 )255;
      }
    } else
#line 683
    if ((int )geometry.sectors == 0) {
      {
#line 685
      printf((char const   */* __restrict  */)"unable to get drive geometry, using default 255/63\n");
#line 686
      bs.secs_track = (__u16 )63;
#line 687
      bs.heads = (__u16 )255;
      }
    } else
#line 683
    if ((int )geometry.heads == 0) {
      {
#line 685
      printf((char const   */* __restrict  */)"unable to get drive geometry, using default 255/63\n");
#line 686
      bs.secs_track = (__u16 )63;
#line 687
      bs.heads = (__u16 )255;
      }
    } else {
#line 689
      bs.secs_track = (__u16 )geometry.sectors;
#line 690
      bs.heads = (__u16 )geometry.heads;
#line 691
      if (! hidden_sectors_by_user) {
#line 692
        hidden_sectors = (int )geometry.start;
      }
    }
    def_hd_params: 
#line 695
    bs.media = (__u8 )(char)-8;
#line 696
    if (! size_fat) {
#line 696
      if (blocks * (uint64_t )((1 << 10) / 512) > 1064960UL) {
#line 697
        if (verbose___0) {
          {
#line 698
          printf((char const   */* __restrict  */)"Auto-selecting FAT32 for large filesystem\n");
          }
        }
#line 699
        size_fat = 32;
      }
    }
#line 701
    if (size_fat == 32) {
#line 709
      sz_mb = (uint32_t )(((blocks + (uint64_t )(1 << 10)) - 1UL) >> 10);
#line 712
      if (sz_mb >= 32768U) {
#line 712
        bs.cluster_size = (__u8 )64;
      } else {
#line 712
        if (sz_mb >= 16384U) {
#line 712
          tmp___8 = 32;
        } else {
#line 712
          if (sz_mb >= 8192U) {
#line 712
            tmp___7 = 16;
          } else {
#line 712
            if (sz_mb > 260U) {
#line 712
              tmp___6 = 8;
            } else {
#line 712
              tmp___6 = 1;
            }
#line 712
            tmp___7 = tmp___6;
          }
#line 712
          tmp___8 = tmp___7;
        }
#line 712
        bs.cluster_size = (__u8 )tmp___8;
      }
    } else {
#line 717
      bs.cluster_size = (__u8 )(char)4;
    }
  }
#line 721
  if (! root_dir_entries) {
#line 722
    root_dir_entries = def_root_dir_entries;
  }
#line 723
  return;
}
}
#line 729 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static unsigned int align_object(unsigned int sectors , unsigned int clustsize ) 
{ 


  {
#line 731
  if (align_structures) {
#line 732
    return (((sectors + clustsize) - 1U) & ~ (clustsize - 1U));
  } else {
#line 734
    return (sectors);
  }
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static void setup_tables(void) 
{ 
  unsigned int num_sectors ;
  unsigned int cluster_count ;
  unsigned int fat_length ;
  struct tm *ctime___0 ;
  struct msdos_volume_info *vi ;
  struct msdos_volume_info *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int offset ;
  __u16 hidden ;
  unsigned int fatdata1216 ;
  unsigned int fatdata32 ;
  unsigned int fatlength12 ;
  unsigned int fatlength16 ;
  unsigned int fatlength32 ;
  unsigned int maxclust12 ;
  unsigned int maxclust16 ;
  unsigned int maxclust32 ;
  unsigned int clust12 ;
  unsigned int clust16 ;
  unsigned int clust32 ;
  int maxclustsize ;
  unsigned int root_dir_sectors ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int clusters ;
  unsigned int maxclust ;
  unsigned int fatdata ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  unsigned int root_dir_entries___0 ;
  unsigned int root_dir_sectors___0 ;
  int tmp___23 ;
  unsigned int tmp___24 ;
  int tmp___25 ;
  void *tmp___26 ;
  int tmp___27 ;
  void *tmp___28 ;
  struct msdos_dir_entry___0 *de ;
  int tmp___29 ;
  struct fat32_fsinfo *info ;
  void *tmp___30 ;
  void *tmp___31 ;

  {
#line 742
  cluster_count = 0U;
#line 744
  if (size_fat == 32) {
#line 744
    tmp = & bs.fstype._fat32.vi;
  } else {
#line 744
    tmp = & bs.fstype._oldfat.vi;
  }
#line 744
  vi = tmp;
#line 747
  if (atari_format___0) {
    {
#line 751
    bs.boot_jump[2] = (__u8 )'m';
#line 752
    tmp___0 = strlen("kdosf");
#line 752
    memcpy((void */* __restrict  */)((char *)(bs.system_id)), (void const   */* __restrict  */)"kdosf",
           tmp___0);
    }
  } else {
    {
#line 754
    tmp___1 = strlen("mkfs.fat");
#line 754
    memcpy((void */* __restrict  */)((char *)(bs.system_id)), (void const   */* __restrict  */)"mkfs.fat",
           tmp___1);
    }
  }
#line 755
  if (sectors_per_cluster) {
#line 756
    bs.cluster_size = (__u8 )((char )sectors_per_cluster);
  }
#line 758
  if (fat_media_byte) {
#line 759
    bs.media = (__u8 )((char )fat_media_byte);
  }
#line 761
  if ((int )bs.media == 248) {
#line 762
    vi->drive_number = (__u8 )128;
  } else {
#line 764
    vi->drive_number = (__u8 )0;
  }
#line 766
  if (drive_number_by_user) {
#line 767
    vi->drive_number = (__u8 )((char )drive_number_option);
  }
#line 769
  if (size_fat == 32) {
#line 772
    root_dir_entries = 0;
  }
#line 775
  if (atari_format___0) {
#line 776
    bs.system_id[5] = (unsigned char )(volume_id & 255L);
#line 777
    bs.system_id[6] = (unsigned char )((volume_id & 65280L) >> 8);
#line 778
    bs.system_id[7] = (unsigned char )((volume_id & 16711680L) >> 16);
  } else {
#line 780
    vi->volume_id[0] = (unsigned char )(volume_id & 255L);
#line 781
    vi->volume_id[1] = (unsigned char )((volume_id & 65280L) >> 8);
#line 782
    vi->volume_id[2] = (unsigned char )((volume_id & 16711680L) >> 16);
#line 783
    vi->volume_id[3] = (unsigned char )(volume_id >> 24);
  }
#line 786
  if (! atari_format___0) {
    {
#line 787
    memcpy((void */* __restrict  */)(vi->volume_label), (void const   */* __restrict  */)(volume_name),
           (size_t )11);
#line 789
    memcpy((void */* __restrict  */)(bs.boot_jump), (void const   */* __restrict  */)(dummy_boot_jump),
           (size_t )3);
    }
#line 791
    if (size_fat == 32) {
#line 791
      tmp___2 = (char *)(& bs.fstype._fat32.boot_code);
    } else {
#line 791
      tmp___2 = (char *)(& bs.fstype._oldfat.boot_code);
    }
#line 791
    bs.boot_jump[1] = (__u8 )((tmp___2 - (char *)(& bs)) - 2L);
#line 795
    if (size_fat == 32) {
#line 796
      offset = (int )((((char *)(& bs.fstype._fat32.boot_code) - (char *)(& bs)) + 29L) + 31744L);
#line 798
      if (dummy_boot_code[419]) {
        {
#line 799
        printf((char const   */* __restrict  */)"Warning: message too long; truncated\n");
        }
      }
      {
#line 800
      dummy_boot_code[419] = (char)0;
#line 801
      memcpy((void */* __restrict  */)(bs.fstype._fat32.boot_code), (void const   */* __restrict  */)(dummy_boot_code),
             (size_t )420);
#line 802
      bs.fstype._fat32.boot_code[3] = (__u8 )(offset & 255);
#line 803
      bs.fstype._fat32.boot_code[4] = (__u8 )(offset >> 8);
      }
    } else {
      {
#line 805
      memcpy((void */* __restrict  */)(bs.fstype._oldfat.boot_code), (void const   */* __restrict  */)(dummy_boot_code),
             (size_t )448);
      }
    }
#line 807
    bs.boot_sign = (__u16 )43605;
  } else {
    {
#line 809
    memcpy((void */* __restrict  */)(bs.boot_jump), (void const   */* __restrict  */)(dummy_boot_jump_m68k),
           (size_t )2);
    }
  }
#line 811
  if (verbose___0 >= 2) {
    {
#line 812
    printf((char const   */* __restrict  */)"Boot jump code is %02x %02x\n", (int )bs.boot_jump[0],
           (int )bs.boot_jump[1]);
    }
  }
#line 815
  if (! reserved_sectors) {
#line 816
    if (size_fat == 32) {
#line 816
      reserved_sectors = 32;
    } else {
#line 816
      reserved_sectors = 1;
    }
  } else
#line 818
  if (size_fat == 32) {
#line 818
    if (reserved_sectors < 2) {
      {
#line 819
      fatal_error("%s: On FAT32 at least 2 reserved sectors are needed.\n");
      }
    }
  }
#line 821
  bs.reserved = (__u16 )reserved_sectors;
#line 822
  if (verbose___0 >= 2) {
    {
#line 823
    printf((char const   */* __restrict  */)"Using %d reserved sectors\n", reserved_sectors);
    }
  }
#line 824
  bs.fats = (__u8 )((char )nr_fats);
#line 825
  if (! atari_format___0) {
#line 826
    bs.hidden = (__u32 )hidden_sectors;
  } else
#line 825
  if (size_fat == 32) {
#line 826
    bs.hidden = (__u32 )hidden_sectors;
  } else {
#line 829
    hidden = (__u16 )hidden_sectors;
#line 830
    if (hidden_sectors & -65536) {
      {
#line 831
      fatal_error("%s: #hidden doesn\'t fit in 16bit field of Atari format\n\n");
      }
    }
    {
#line 832
    memcpy((void */* __restrict  */)(& bs.hidden), (void const   */* __restrict  */)(& hidden),
           (size_t )2);
    }
  }
#line 835
  num_sectors = (unsigned int )((long long )((blocks * (uint64_t )(1 << 10)) / (uint64_t )sector_size) + (long long )orphaned_sectors);
#line 838
  if (! atari_format___0) {
    {
#line 845
    tmp___3 = cdiv(root_dir_entries * 32, sector_size);
#line 845
    root_dir_sectors = (unsigned int )tmp___3;
    }
#line 851
    if (num_sectors <= 8192U) {
#line 852
      if (align_structures) {
#line 852
        if (verbose___0 >= 2) {
          {
#line 853
          printf((char const   */* __restrict  */)"Disabling alignment due to tiny filesystem\n");
          }
        }
      }
#line 855
      align_structures = 0;
    }
#line 858
    if (sectors_per_cluster) {
#line 859
      maxclustsize = sectors_per_cluster;
#line 859
      bs.cluster_size = (__u8 )maxclustsize;
    } else {
#line 862
      maxclustsize = 128;
    }
    {
#line 864
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 865
      fatdata32 = num_sectors - (unsigned int )reserved_sectors;
#line 866
      tmp___4 = align_object(root_dir_sectors, (unsigned int )bs.cluster_size);
#line 866
      fatdata1216 = fatdata32 - tmp___4;
      }
#line 869
      if (verbose___0 >= 2) {
        {
#line 870
        printf((char const   */* __restrict  */)"Trying with %d sectors/cluster:\n",
               (int )bs.cluster_size);
        }
      }
      {
#line 874
      clust12 = (unsigned int )((2LL * ((long long )fatdata1216 * (long long )sector_size + (long long )(nr_fats * 3))) / (long long )((2 * (int )bs.cluster_size) * sector_size + nr_fats * 3));
#line 876
      tmp___5 = cdiv((int )(((clust12 + 2U) * 3U + 1U) >> 1), sector_size);
#line 876
      fatlength12 = (unsigned int )tmp___5;
#line 877
      fatlength12 = align_object(fatlength12, (unsigned int )bs.cluster_size);
#line 881
      clust12 = (fatdata1216 - (unsigned int )nr_fats * fatlength12) / (unsigned int )bs.cluster_size;
#line 882
      maxclust12 = ((fatlength12 * 2U) * (unsigned int )sector_size) / 3U;
      }
#line 883
      if (maxclust12 > (unsigned int )((1 << 12) - 16)) {
#line 884
        maxclust12 = (unsigned int )((1 << 12) - 16);
      }
#line 885
      if (verbose___0 >= 2) {
        {
#line 886
        printf((char const   */* __restrict  */)"FAT12: #clu=%u, fatlen=%u, maxclu=%u, limit=%u\n",
               clust12, fatlength12, maxclust12, (1 << 12) - 16);
        }
      }
#line 888
      if (clust12 > maxclust12 - 2U) {
#line 889
        clust12 = 0U;
#line 890
        if (verbose___0 >= 2) {
          {
#line 891
          printf((char const   */* __restrict  */)"FAT12: too much clusters\n");
          }
        }
      }
      {
#line 894
      clust16 = (unsigned int )(((long long )fatdata1216 * (long long )sector_size + (long long )(nr_fats * 4)) / (long long )((int )bs.cluster_size * sector_size + nr_fats * 2));
#line 896
      tmp___6 = cdiv((int )((clust16 + 2U) * 2U), sector_size);
#line 896
      fatlength16 = (unsigned int )tmp___6;
#line 897
      fatlength16 = align_object(fatlength16, (unsigned int )bs.cluster_size);
#line 901
      clust16 = (fatdata1216 - (unsigned int )nr_fats * fatlength16) / (unsigned int )bs.cluster_size;
#line 902
      maxclust16 = (fatlength16 * (unsigned int )sector_size) / 2U;
      }
#line 903
      if (maxclust16 > (unsigned int )((1 << 16) - 16)) {
#line 904
        maxclust16 = (unsigned int )((1 << 16) - 16);
      }
#line 905
      if (verbose___0 >= 2) {
        {
#line 906
        printf((char const   */* __restrict  */)"FAT16: #clu=%u, fatlen=%u, maxclu=%u, limit=%u\n",
               clust16, fatlength16, maxclust16, (1 << 16) - 16);
        }
      }
#line 908
      if (clust16 > maxclust16 - 2U) {
#line 909
        if (verbose___0 >= 2) {
          {
#line 910
          printf((char const   */* __restrict  */)"FAT16: too much clusters\n");
          }
        }
#line 911
        clust16 = 0U;
      }
#line 915
      if (clust16 < 4085U) {
#line 915
        if (size_fat_by_user) {
#line 915
          if (! (size_fat == 16)) {
#line 915
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 917
          if (verbose___0 >= 2) {
#line 918
            if (clust16 < 4085U) {
#line 918
              tmp___7 = "FAT16: would be misdetected as FAT12\n";
            } else {
#line 918
              tmp___7 = "FAT16: too much clusters\n";
            }
            {
#line 918
            printf((char const   */* __restrict  */)tmp___7);
            }
          }
#line 921
          clust16 = 0U;
        }
      }
      {
#line 924
      clust32 = (unsigned int )(((long long )fatdata32 * (long long )sector_size + (long long )(nr_fats * 8)) / (long long )((int )bs.cluster_size * sector_size + nr_fats * 4));
#line 926
      tmp___8 = cdiv((int )((clust32 + 2U) * 4U), sector_size);
#line 926
      fatlength32 = (unsigned int )tmp___8;
#line 930
      clust32 = (fatdata32 - (unsigned int )nr_fats * fatlength32) / (unsigned int )bs.cluster_size;
#line 931
      maxclust32 = (fatlength32 * (unsigned int )sector_size) / 4U;
      }
#line 932
      if (maxclust32 > (unsigned int )((1 << 28) - 16)) {
#line 933
        maxclust32 = (unsigned int )((1 << 28) - 16);
      }
#line 934
      if (clust32) {
#line 934
        if (clust32 < 65529U) {
#line 934
          if (size_fat_by_user) {
#line 934
            if (! (size_fat == 32)) {
#line 934
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
#line 936
            clust32 = 0U;
#line 937
            if (verbose___0 >= 2) {
              {
#line 938
              printf((char const   */* __restrict  */)"FAT32: not enough clusters (%d)\n",
                     65529);
              }
            }
          }
        }
      }
#line 940
      if (verbose___0 >= 2) {
        {
#line 941
        printf((char const   */* __restrict  */)"FAT32: #clu=%u, fatlen=%u, maxclu=%u, limit=%u\n",
               clust32, fatlength32, maxclust32, (1 << 28) - 16);
        }
      }
#line 943
      if (clust32 > maxclust32) {
#line 944
        clust32 = 0U;
#line 945
        if (verbose___0 >= 2) {
          {
#line 946
          printf((char const   */* __restrict  */)"FAT32: too much clusters\n");
          }
        }
      }
#line 949
      if (clust12) {
#line 949
        if (size_fat == 0) {
#line 952
          goto while_break;
        } else
#line 949
        if (size_fat == 12) {
#line 952
          goto while_break;
        } else {
#line 949
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 949
      if (clust16) {
#line 949
        if (size_fat == 0) {
#line 952
          goto while_break;
        } else
#line 949
        if (size_fat == 16) {
#line 952
          goto while_break;
        } else {
#line 949
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 949
      if (clust32) {
#line 949
        if (size_fat == 32) {
#line 952
          goto while_break;
        }
      }
#line 954
      bs.cluster_size = (__u8 )((int )bs.cluster_size << 1);
#line 864
      if (bs.cluster_size) {
#line 864
        if (! ((int )bs.cluster_size <= maxclustsize)) {
#line 864
          goto while_break;
        }
      } else {
#line 864
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 959
    if (! size_fat) {
#line 960
      if (clust16 > clust12) {
#line 960
        size_fat = 16;
      } else {
#line 960
        size_fat = 12;
      }
#line 961
      if (verbose___0 >= 2) {
        {
#line 962
        printf((char const   */* __restrict  */)"Choosing %d bits for FAT\n", size_fat);
        }
      }
    }
    {
#line 966
    if (size_fat == 12) {
#line 966
      goto case_12;
    }
#line 973
    if (size_fat == 16) {
#line 973
      goto case_16;
    }
#line 997
    if (size_fat == 32) {
#line 997
      goto case_32;
    }
#line 1009
    goto switch_default;
    case_12: /* CIL Label */ 
    {
#line 967
    cluster_count = clust12;
#line 968
    fat_length = fatlength12;
#line 969
    bs.fat_length = (__u16 )fatlength12;
#line 970
    memcpy((void */* __restrict  */)(vi->fs_type), (void const   */* __restrict  */)"FAT12   ",
           (size_t )8);
    }
#line 971
    goto switch_break;
    case_16: /* CIL Label */ 
#line 974
    if (clust16 < 4085U) {
#line 975
      if (size_fat_by_user) {
        {
#line 976
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Not enough clusters for a 16 bit FAT! The filesystem will be\nmisinterpreted as having a 12 bit FAT without mount option \"fat=16\".\n");
        }
      } else {
        {
#line 981
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This filesystem has an unfortunate size. A 12 bit FAT cannot provide\nenough clusters, but a 16 bit FAT takes up a little bit more space so that\nthe total number of clusters becomes less than the threshold value for\ndistinction between 12 and 16 bit FATs.\n");
#line 988
        fatal_error("%s: Make the filesystem a bit smaller manually.\n");
        }
      }
    }
    {
#line 991
    cluster_count = clust16;
#line 992
    fat_length = fatlength16;
#line 993
    bs.fat_length = (__u16 )fatlength16;
#line 994
    memcpy((void */* __restrict  */)(vi->fs_type), (void const   */* __restrict  */)"FAT16   ",
           (size_t )8);
    }
#line 995
    goto switch_break;
    case_32: /* CIL Label */ 
#line 998
    if (clust32 < 65529U) {
      {
#line 999
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Not enough clusters for a 32 bit FAT!\n");
      }
    }
    {
#line 1001
    cluster_count = clust32;
#line 1002
    fat_length = fatlength32;
#line 1003
    bs.fat_length = (__u16 )0;
#line 1004
    bs.fstype._fat32.fat32_length = fatlength32;
#line 1005
    memcpy((void */* __restrict  */)(vi->fs_type), (void const   */* __restrict  */)"FAT32   ",
           (size_t )8);
#line 1006
    root_dir_entries = 0;
    }
#line 1007
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1010
    fatal_error("%s: FAT not 12, 16 or 32 bits\n");
    }
    switch_break: /* CIL Label */ ;
    }
#line 1014
    if (align_structures) {
      {
#line 1015
      tmp___9 = align_object(root_dir_sectors, (unsigned int )bs.cluster_size);
#line 1015
      root_dir_entries = (int )(tmp___9 * (unsigned int )(sector_size >> 5));
      }
    }
  } else {
#line 1026
    if (! size_fat) {
#line 1027
      if (num_sectors == 1440U) {
#line 1027
        size_fat = 12;
      } else
#line 1027
      if (num_sectors == 2400U) {
#line 1027
        size_fat = 12;
      } else
#line 1027
      if (num_sectors == 2880U) {
#line 1027
        size_fat = 12;
      } else
#line 1027
      if (num_sectors == 5760U) {
#line 1027
        size_fat = 12;
      } else {
#line 1027
        size_fat = 16;
      }
    }
#line 1029
    if (verbose___0 >= 2) {
      {
#line 1030
      printf((char const   */* __restrict  */)"Choosing %d bits for FAT\n", size_fat);
      }
    }
#line 1036
    if (sectors_per_cluster) {
#line 1036
      bs.cluster_size = (__u8 )sectors_per_cluster;
    } else {
#line 1036
      bs.cluster_size = (__u8 )2;
    }
#line 1037
    if (! sector_size_set) {
      {
#line 1038
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1038
        if (! (num_sectors > 65531U)) {
#line 1038
          goto while_break___0;
        }
#line 1039
        num_sectors >>= 1;
#line 1040
        sector_size <<= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1043
    if (verbose___0 >= 2) {
      {
#line 1044
      printf((char const   */* __restrict  */)"Sector size must be %d to have less than %d log. sectors\n",
             sector_size, 65531);
      }
    }
    {
#line 1048
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1049
      tmp___10 = cdiv(root_dir_entries * 32, sector_size);
#line 1049
      fatdata = (num_sectors - (unsigned int )tmp___10) - (unsigned int )reserved_sectors;
#line 1055
      clusters = (unsigned int )((2LL * ((long long )fatdata * (long long )sector_size - (long long )(((2 * nr_fats) * size_fat) / 8))) / (long long )(2 * ((int )bs.cluster_size * sector_size + (nr_fats * size_fat) / 8)));
#line 1061
      tmp___11 = cdiv((int )(((clusters + 2U) * (unsigned int )size_fat) / 8U), sector_size);
#line 1061
      fat_length = (unsigned int )tmp___11;
#line 1065
      clusters = (fatdata - (unsigned int )nr_fats * fat_length) / (unsigned int )bs.cluster_size;
#line 1066
      maxclust = ((fat_length * (unsigned int )sector_size) * 8U) / (unsigned int )size_fat;
      }
#line 1067
      if (verbose___0 >= 2) {
        {
#line 1068
        printf((char const   */* __restrict  */)"ss=%d: #clu=%d, fat_len=%d, maxclu=%d\n",
               sector_size, clusters, fat_length, maxclust);
        }
      }
#line 1073
      if (size_fat == 32) {
#line 1073
        tmp___12 = (1 << 28) - 16;
      } else {
#line 1073
        tmp___12 = (1 << size_fat) - 16;
      }
#line 1073
      if (maxclust <= (unsigned int )tmp___12) {
#line 1073
        if (clusters <= maxclust - 2U) {
#line 1076
          goto while_break___1;
        }
      }
#line 1077
      if (verbose___0 >= 2) {
#line 1078
        if (clusters > maxclust - 2U) {
#line 1078
          tmp___13 = "Too many clusters\n";
        } else {
#line 1078
          tmp___13 = "FAT too big\n";
        }
        {
#line 1078
        printf((char const   */* __restrict  */)tmp___13);
        }
      }
#line 1082
      if (sector_size_set) {
        {
#line 1083
        fatal_error("%s: With this sector size, the maximum number of FAT entries would be exceeded.\n");
        }
      }
#line 1085
      num_sectors >>= 1;
#line 1086
      sector_size <<= 1;
#line 1048
      if (! (sector_size <= 16384)) {
#line 1048
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1089
    if (sector_size > 16384) {
      {
#line 1090
      fatal_error("%s: Would need a sector size > 16k, which GEMDOS can\'t work with\n");
      }
    }
#line 1092
    cluster_count = clusters;
#line 1093
    if (size_fat != 32) {
#line 1094
      bs.fat_length = (__u16 )fat_length;
    } else {
#line 1096
      bs.fat_length = (__u16 )0;
#line 1097
      bs.fstype._fat32.fat32_length = fat_length;
    }
  }
#line 1101
  bs.sector_size[0] = (__u8 )((char )(sector_size & 255));
#line 1102
  bs.sector_size[1] = (__u8 )((char )((sector_size & 65280) >> 8));
#line 1104
  bs.dir_entries[0] = (__u8 )((char )(root_dir_entries & 255));
#line 1105
  bs.dir_entries[1] = (__u8 )((char )((root_dir_entries & 65280) >> 8));
#line 1107
  if (size_fat == 32) {
#line 1109
    bs.fstype._fat32.flags = (__u16 )0;
#line 1110
    bs.fstype._fat32.version[0] = (__u8 )0;
#line 1111
    bs.fstype._fat32.version[1] = (__u8 )0;
#line 1112
    bs.fstype._fat32.root_cluster = (__u32 )2;
#line 1113
    bs.fstype._fat32.info_sector = (__u16 )1;
#line 1114
    if (! backup_boot) {
#line 1115
      if (reserved_sectors >= 7) {
#line 1115
        backup_boot = 6;
      } else {
#line 1115
        if (reserved_sectors >= 2) {
#line 1115
          tmp___14 = reserved_sectors - 1;
        } else {
#line 1115
          tmp___14 = 0;
        }
#line 1115
        backup_boot = tmp___14;
      }
    } else
#line 1118
    if (backup_boot == 1) {
      {
#line 1119
      fatal_error("%s: Backup boot sector must be after sector 1\n");
      }
    } else
#line 1120
    if (backup_boot >= reserved_sectors) {
      {
#line 1121
      fatal_error("%s: Backup boot sector must be a reserved sector\n");
      }
    }
#line 1123
    if (verbose___0 >= 2) {
      {
#line 1124
      printf((char const   */* __restrict  */)"Using sector %d as backup boot sector (0 = none)\n",
             backup_boot);
      }
    }
    {
#line 1126
    bs.fstype._fat32.backup_boot = (__u16 )backup_boot;
#line 1127
    memset((void *)(& bs.fstype._fat32.reserved2), 0, sizeof(bs.fstype._fat32.reserved2));
    }
  }
#line 1130
  if (atari_format___0) {
#line 1132
    if (num_sectors >= 65531U) {
      {
#line 1133
      fatal_error("%s: GEMDOS can\'t handle more than 65531 sectors\n");
      }
    } else
#line 1134
    if (num_sectors >= 32765U) {
      {
#line 1135
      printf((char const   */* __restrict  */)"Warning: More than 32765 sector need TOS 1.04 or higher.\n");
      }
    }
  }
#line 1138
  if (num_sectors >= 65536U) {
#line 1139
    bs.sectors[0] = (__u8 )(char)0;
#line 1140
    bs.sectors[1] = (__u8 )(char)0;
#line 1141
    bs.total_sect = num_sectors;
  } else {
#line 1143
    bs.sectors[0] = (__u8 )((char )(num_sectors & 255U));
#line 1144
    bs.sectors[1] = (__u8 )((char )((num_sectors & 65280U) >> 8));
#line 1145
    if (! atari_format___0) {
#line 1146
      bs.total_sect = (__u32 )0;
    }
  }
#line 1149
  if (! atari_format___0) {
#line 1150
    vi->ext_boot_sign = (__u8 )41;
  }
#line 1152
  if (! cluster_count) {
#line 1153
    if (sectors_per_cluster) {
      {
#line 1154
      fatal_error("%s: Too many clusters for filesystem - try more sectors per cluster\n");
      }
    } else {
      {
#line 1156
      fatal_error("%s: Attempting to create a too large filesystem\n");
      }
    }
  }
#line 1160
  start_data_sector = (int )(((unsigned int )reserved_sectors + (unsigned int )nr_fats * fat_length) * (unsigned int )(sector_size / 512));
#line 1162
  start_data_block = ((start_data_sector + (1 << 10) / 512) - 1) / ((1 << 10) / 512);
#line 1165
  if (blocks < (uint64_t )(start_data_block + 32)) {
    {
#line 1166
    fatal_error("%s: Too few blocks for viable filesystem\n");
    }
  }
#line 1168
  if (verbose___0) {
#line 1169
    if ((int )bs.secs_track != 1) {
#line 1169
      tmp___15 = "s";
    } else {
#line 1169
      tmp___15 = "";
    }
#line 1169
    if ((int )bs.heads != 1) {
#line 1169
      tmp___16 = "s";
    } else {
#line 1169
      tmp___16 = "";
    }
    {
#line 1169
    printf((char const   */* __restrict  */)"%s has %d head%s and %d sector%s per track,\n",
           device_name, (int )bs.heads, tmp___16, (int )bs.secs_track, tmp___15);
#line 1173
    printf((char const   */* __restrict  */)"hidden sectors 0x%04x;\n", hidden_sectors);
#line 1174
    printf((char const   */* __restrict  */)"logical sector size is %d,\n", sector_size);
#line 1175
    printf((char const   */* __restrict  */)"using 0x%02x media descriptor, with %d sectors;\n",
           (int )bs.media, num_sectors);
#line 1177
    printf((char const   */* __restrict  */)"drive number 0x%02x;\n", (int )vi->drive_number);
    }
#line 1178
    if ((int )bs.cluster_size != 1) {
#line 1178
      tmp___17 = "s";
    } else {
#line 1178
      tmp___17 = "";
    }
#line 1178
    if ((int )bs.fats != 1) {
#line 1178
      tmp___18 = "s";
    } else {
#line 1178
      tmp___18 = "";
    }
    {
#line 1178
    printf((char const   */* __restrict  */)"filesystem has %d %d-bit FAT%s and %d sector%s per cluster.\n",
           (int )bs.fats, size_fat, tmp___18, (int )bs.cluster_size, tmp___17);
    }
#line 1181
    if (cluster_count != 1U) {
#line 1181
      tmp___19 = "s";
    } else {
#line 1181
      tmp___19 = "";
    }
#line 1181
    if (fat_length != 1U) {
#line 1181
      tmp___20 = "s";
    } else {
#line 1181
      tmp___20 = "";
    }
    {
#line 1181
    printf((char const   */* __restrict  */)"FAT size is %d sector%s, and provides %d cluster%s.\n",
           fat_length, tmp___20, cluster_count, tmp___19);
    }
#line 1184
    if (reserved_sectors != 1) {
#line 1184
      tmp___21 = "s";
    } else {
#line 1184
      tmp___21 = "";
    }
#line 1184
    if (reserved_sectors != 1) {
#line 1184
      tmp___22 = "are";
    } else {
#line 1184
      tmp___22 = "is";
    }
    {
#line 1184
    printf((char const   */* __restrict  */)"There %s %u reserved sector%s.\n", tmp___22,
           reserved_sectors, tmp___21);
    }
#line 1188
    if (size_fat != 32) {
      {
#line 1189
      root_dir_entries___0 = (unsigned int )((int )bs.dir_entries[0] + (int )bs.dir_entries[1] * 256);
#line 1191
      tmp___23 = cdiv((int )(root_dir_entries___0 * 32U), sector_size);
#line 1191
      root_dir_sectors___0 = (unsigned int )tmp___23;
#line 1193
      printf((char const   */* __restrict  */)"Root directory contains %u slots and uses %u sectors.\n",
             root_dir_entries___0, root_dir_sectors___0);
      }
    }
#line 1196
    if (atari_format___0) {
#line 1196
      tmp___24 = 16777215U;
    } else {
#line 1196
      tmp___24 = 4294967295U;
    }
    {
#line 1196
    printf((char const   */* __restrict  */)"Volume ID is %08lx, ", volume_id & (long )tmp___24);
#line 1198
    tmp___25 = strcmp((char const   *)(volume_name), "NO NAME    ");
    }
#line 1198
    if (tmp___25) {
      {
#line 1199
      printf((char const   */* __restrict  */)"volume label %s.\n", volume_name);
      }
    } else {
      {
#line 1201
      printf((char const   */* __restrict  */)"no volume label.\n");
      }
    }
  }
#line 1206
  if (malloc_entire_fat) {
#line 1207
    alloced_fat_length = fat_length;
  } else {
#line 1209
    alloced_fat_length = 1U;
  }
  {
#line 1211
  tmp___26 = malloc((size_t )(alloced_fat_length * (unsigned int )sector_size));
#line 1211
  fat = (unsigned char *)tmp___26;
  }
#line 1211
  if ((unsigned long )fat == (unsigned long )((void *)0)) {
    {
#line 1213
    fatal_error("%s: unable to allocate space for FAT image in memory\n");
    }
  }
  {
#line 1215
  memset((void *)fat, 0, (size_t )(alloced_fat_length * (unsigned int )sector_size));
#line 1217
  mark_FAT_cluster(0, 4294967295U);
#line 1218
  mark_FAT_cluster(1, 4294967295U);
#line 1219
  *(fat + 0) = bs.media;
  }
#line 1220
  if (size_fat == 32) {
#line 1222
    if (atari_format___0) {
#line 1222
      tmp___27 = 268435455;
    } else {
#line 1222
      tmp___27 = 268435448;
    }
    {
#line 1222
    mark_FAT_cluster(2, (unsigned int )tmp___27);
    }
  }
#line 1227
  if (size_fat == 32) {
#line 1227
    size_root_dir = (int )bs.cluster_size * sector_size;
  } else {
#line 1227
    size_root_dir = (int )((unsigned long )((int )bs.dir_entries[1] * 256 + (int )bs.dir_entries[0]) * sizeof(struct msdos_dir_entry___0 ));
  }
  {
#line 1231
  tmp___28 = malloc((size_t )size_root_dir);
#line 1231
  root_dir = (struct msdos_dir_entry___0 *)tmp___28;
  }
#line 1231
  if ((unsigned long )root_dir == (unsigned long )((void *)0)) {
    {
#line 1232
    free((void *)fat);
#line 1233
    fatal_error("%s: unable to allocate space for root directory in memory\n");
    }
  }
  {
#line 1236
  memset((void *)root_dir, 0, (size_t )size_root_dir);
#line 1237
  tmp___29 = memcmp((void const   *)(volume_name), (void const   *)"NO NAME    ",
                    (size_t )11);
  }
#line 1237
  if (tmp___29) {
    {
#line 1238
    de = root_dir + 0;
#line 1239
    memcpy((void */* __restrict  */)(de->name), (void const   */* __restrict  */)(volume_name),
           (size_t )8);
#line 1240
    memcpy((void */* __restrict  */)(de->ext), (void const   */* __restrict  */)(volume_name + 8),
           (size_t )3);
#line 1241
    de->attr = (__u8 )8;
#line 1242
    ctime___0 = localtime((time_t const   *)(& create_time));
#line 1243
    de->time = (unsigned short )(((ctime___0->tm_sec >> 1) + (ctime___0->tm_min << 5)) + (ctime___0->tm_hour << 11));
#line 1246
    de->date = (unsigned short )((ctime___0->tm_mday + ((ctime___0->tm_mon + 1) << 5)) + ((ctime___0->tm_year - 80) << 9));
#line 1250
    de->ctime_ms = (__u8 )0;
#line 1251
    de->ctime = de->time;
#line 1252
    de->cdate = de->date;
#line 1253
    de->adate = de->date;
#line 1254
    de->starthi = (__u16 )0;
#line 1255
    de->start = (__u16 )0;
#line 1256
    de->size = (__u32 )0;
    }
  }
#line 1259
  if (size_fat == 32) {
    {
#line 1263
    tmp___30 = malloc((size_t )sector_size);
#line 1263
    info_sector = (unsigned char *)tmp___30;
    }
#line 1263
    if (! info_sector) {
      {
#line 1264
      fatal_error("%s: Out of memory\n");
      }
    }
    {
#line 1265
    memset((void *)info_sector, 0, (size_t )sector_size);
#line 1267
    info = (struct fat32_fsinfo *)(info_sector + 480);
#line 1270
    *(info_sector + 0) = (unsigned char )'R';
#line 1271
    *(info_sector + 1) = (unsigned char )'R';
#line 1272
    *(info_sector + 2) = (unsigned char )'a';
#line 1273
    *(info_sector + 3) = (unsigned char )'A';
#line 1276
    info->signature = (__u32 )1631679090;
#line 1278
    info->free_clusters = cluster_count - 1U;
#line 1279
    info->next_cluster = (__u32 )2;
#line 1282
    *((__u16 *)(info_sector + 510)) = (__u16 )43605;
    }
  }
  {
#line 1285
  tmp___31 = malloc((size_t )sector_size);
#line 1285
  blank_sector = (char *)tmp___31;
  }
#line 1285
  if (! blank_sector) {
    {
#line 1286
    fatal_error("%s: Out of memory\n");
    }
  }
  {
#line 1287
  memset((void *)blank_sector, 0, (size_t )sector_size);
  }
#line 1288
  return;
}
}
#line 1314 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static void write_tables(void) 
{ 
  int x ;
  int fat_length ;
  loff_t __pos ;
  __off_t tmp ;
  int __size ;
  ssize_t tmp___0 ;
  loff_t __pos___0 ;
  __off_t tmp___1 ;
  int __size___0 ;
  ssize_t tmp___2 ;
  loff_t __pos___1 ;
  __off_t tmp___3 ;
  int __size___1 ;
  ssize_t tmp___4 ;
  loff_t __pos___2 ;
  __off_t tmp___5 ;
  int __size___2 ;
  ssize_t tmp___6 ;
  loff_t __pos___3 ;
  __off_t tmp___7 ;
  int y ;
  int blank_fat_length ;
  int __size___3 ;
  ssize_t tmp___8 ;
  int __size___4 ;
  ssize_t tmp___9 ;
  int __size___5 ;
  ssize_t tmp___10 ;

  {
#line 1319
  if (size_fat == 32) {
#line 1319
    fat_length = (int )bs.fstype._fat32.fat32_length;
  } else {
#line 1319
    fat_length = (int )bs.fat_length;
  }
  {
#line 1322
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1322
    __pos = (loff_t )0;
#line 1322
    tmp = lseek(dev, __pos, 0);
    }
#line 1322
    if (tmp != __pos) {
      {
#line 1322
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1322
        free((void *)fat);
        }
#line 1322
        if (info_sector) {
          {
#line 1322
          free((void *)info_sector);
          }
        }
        {
#line 1322
        free((void *)root_dir);
#line 1322
        fatal_error("%s: seek to start of device failed whilst writing tables\n");
        }
#line 1322
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1322
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1324
  x = 0;
  {
#line 1324
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1324
    if (! (x < reserved_sectors)) {
#line 1324
      goto while_break___1;
    }
    {
#line 1325
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1325
      __size = sector_size;
#line 1325
      tmp___0 = write(dev, (void const   *)blank_sector, (size_t )__size);
      }
#line 1325
      if (tmp___0 != (ssize_t )__size) {
        {
#line 1325
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1325
          free((void *)fat);
          }
#line 1325
          if (info_sector) {
            {
#line 1325
            free((void *)info_sector);
            }
          }
          {
#line 1325
          free((void *)root_dir);
#line 1325
          fatal_error("%s: failed whilst writing reserved sector\n");
          }
#line 1325
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1325
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1324
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1327
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 1327
    __pos___0 = (loff_t )0;
#line 1327
    tmp___1 = lseek(dev, __pos___0, 0);
    }
#line 1327
    if (tmp___1 != __pos___0) {
      {
#line 1327
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 1327
        free((void *)fat);
        }
#line 1327
        if (info_sector) {
          {
#line 1327
          free((void *)info_sector);
          }
        }
        {
#line 1327
        free((void *)root_dir);
#line 1327
        fatal_error("%s: seek to boot sector failed whilst writing tables\n");
        }
#line 1327
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1327
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1328
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 1328
    __size___0 = (int )sizeof(struct msdos_boot_sector );
#line 1328
    tmp___2 = write(dev, (void const   *)((char *)(& bs)), (size_t )__size___0);
    }
#line 1328
    if (tmp___2 != (ssize_t )__size___0) {
      {
#line 1328
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 1328
        free((void *)fat);
        }
#line 1328
        if (info_sector) {
          {
#line 1328
          free((void *)info_sector);
          }
        }
        {
#line 1328
        free((void *)root_dir);
#line 1328
        fatal_error("%s: failed whilst writing boot sector\n");
        }
#line 1328
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 1328
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1330
  if (size_fat == 32) {
    {
#line 1331
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 1331
      __pos___1 = (loff_t )((int )bs.fstype._fat32.info_sector * sector_size);
#line 1331
      tmp___3 = lseek(dev, __pos___1, 0);
      }
#line 1331
      if (tmp___3 != __pos___1) {
        {
#line 1331
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 1331
          free((void *)fat);
          }
#line 1331
          if (info_sector) {
            {
#line 1331
            free((void *)info_sector);
            }
          }
          {
#line 1331
          free((void *)root_dir);
#line 1331
          fatal_error("%s: seek to info sector failed whilst writing tables\n");
          }
#line 1331
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
#line 1331
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1332
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 1332
      __size___1 = 512;
#line 1332
      tmp___4 = write(dev, (void const   *)info_sector, (size_t )__size___1);
      }
#line 1332
      if (tmp___4 != (ssize_t )__size___1) {
        {
#line 1332
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 1332
          free((void *)fat);
          }
#line 1332
          if (info_sector) {
            {
#line 1332
            free((void *)info_sector);
            }
          }
          {
#line 1332
          free((void *)root_dir);
#line 1332
          fatal_error("%s: failed whilst writing info sector\n");
          }
#line 1332
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 1332
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 1333
    if (backup_boot != 0) {
      {
#line 1334
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 1334
        __pos___2 = (loff_t )(backup_boot * sector_size);
#line 1334
        tmp___5 = lseek(dev, __pos___2, 0);
        }
#line 1334
        if (tmp___5 != __pos___2) {
          {
#line 1334
          while (1) {
            while_continue___13: /* CIL Label */ ;
            {
#line 1334
            free((void *)fat);
            }
#line 1334
            if (info_sector) {
              {
#line 1334
              free((void *)info_sector);
              }
            }
            {
#line 1334
            free((void *)root_dir);
#line 1334
            fatal_error("%s: seek to backup boot sector failed whilst writing tables\n");
            }
#line 1334
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
#line 1334
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 1335
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 1335
        __size___2 = (int )sizeof(struct msdos_boot_sector );
#line 1335
        tmp___6 = write(dev, (void const   *)((char *)(& bs)), (size_t )__size___2);
        }
#line 1335
        if (tmp___6 != (ssize_t )__size___2) {
          {
#line 1335
          while (1) {
            while_continue___15: /* CIL Label */ ;
            {
#line 1335
            free((void *)fat);
            }
#line 1335
            if (info_sector) {
              {
#line 1335
              free((void *)info_sector);
              }
            }
            {
#line 1335
            free((void *)root_dir);
#line 1335
            fatal_error("%s: failed whilst writing backup boot sector\n");
            }
#line 1335
            goto while_break___15;
          }
          while_break___15: /* CIL Label */ ;
          }
        }
#line 1335
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
  }
  {
#line 1340
  while (1) {
    while_continue___16: /* CIL Label */ ;
    {
#line 1340
    __pos___3 = (loff_t )(reserved_sectors * sector_size);
#line 1340
    tmp___7 = lseek(dev, __pos___3, 0);
    }
#line 1340
    if (tmp___7 != __pos___3) {
      {
#line 1340
      while (1) {
        while_continue___17: /* CIL Label */ ;
        {
#line 1340
        free((void *)fat);
        }
#line 1340
        if (info_sector) {
          {
#line 1340
          free((void *)info_sector);
          }
        }
        {
#line 1340
        free((void *)root_dir);
#line 1340
        fatal_error("%s: seek to first FAT failed whilst writing tables\n");
        }
#line 1340
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
#line 1340
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 1341
  x = 1;
  {
#line 1341
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 1341
    if (! (x <= nr_fats)) {
#line 1341
      goto while_break___18;
    }
#line 1343
    blank_fat_length = (int )((unsigned int )fat_length - alloced_fat_length);
    {
#line 1344
    while (1) {
      while_continue___19: /* CIL Label */ ;
      {
#line 1344
      __size___3 = (int )(alloced_fat_length * (unsigned int )sector_size);
#line 1344
      tmp___8 = write(dev, (void const   *)fat, (size_t )__size___3);
      }
#line 1344
      if (tmp___8 != (ssize_t )__size___3) {
        {
#line 1344
        while (1) {
          while_continue___20: /* CIL Label */ ;
          {
#line 1344
          free((void *)fat);
          }
#line 1344
          if (info_sector) {
            {
#line 1344
            free((void *)info_sector);
            }
          }
          {
#line 1344
          free((void *)root_dir);
#line 1344
          fatal_error("%s: failed whilst writing FAT\n");
          }
#line 1344
          goto while_break___20;
        }
        while_break___20: /* CIL Label */ ;
        }
      }
#line 1344
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 1345
    y = 0;
    {
#line 1345
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 1345
      if (! (y < blank_fat_length)) {
#line 1345
        goto while_break___21;
      }
      {
#line 1346
      while (1) {
        while_continue___22: /* CIL Label */ ;
        {
#line 1346
        __size___4 = sector_size;
#line 1346
        tmp___9 = write(dev, (void const   *)blank_sector, (size_t )__size___4);
        }
#line 1346
        if (tmp___9 != (ssize_t )__size___4) {
          {
#line 1346
          while (1) {
            while_continue___23: /* CIL Label */ ;
            {
#line 1346
            free((void *)fat);
            }
#line 1346
            if (info_sector) {
              {
#line 1346
              free((void *)info_sector);
              }
            }
            {
#line 1346
            free((void *)root_dir);
#line 1346
            fatal_error("%s: failed whilst writing FAT\n");
            }
#line 1346
            goto while_break___23;
          }
          while_break___23: /* CIL Label */ ;
          }
        }
#line 1346
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 1345
      y ++;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 1341
    x ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 1350
  while (1) {
    while_continue___24: /* CIL Label */ ;
    {
#line 1350
    __size___5 = size_root_dir;
#line 1350
    tmp___10 = write(dev, (void const   *)((char *)root_dir), (size_t )__size___5);
    }
#line 1350
    if (tmp___10 != (ssize_t )__size___5) {
      {
#line 1350
      while (1) {
        while_continue___25: /* CIL Label */ ;
        {
#line 1350
        free((void *)fat);
        }
#line 1350
        if (info_sector) {
          {
#line 1350
          free((void *)info_sector);
          }
        }
        {
#line 1350
        free((void *)root_dir);
#line 1350
        fatal_error("%s: failed whilst writing root directory\n");
        }
#line 1350
        goto while_break___25;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
#line 1350
    goto while_break___24;
  }
  while_break___24: /* CIL Label */ ;
  }
#line 1352
  if (blank_sector) {
    {
#line 1353
    free((void *)blank_sector);
    }
  }
#line 1354
  if (info_sector) {
    {
#line 1355
    free((void *)info_sector);
    }
  }
  {
#line 1356
  free((void *)root_dir);
#line 1357
  free((void *)fat);
  }
#line 1358
  return;
}
}
#line 1362 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static void usage___0(void) 
{ 


  {
  {
#line 1364
  fatal_error("Usage: mkfs.fat [-a][-A][-c][-C][-v][-I][-l bad-block-file][-b backup-boot-sector]\n       [-m boot-msg-file][-n volume-name][-i volume-id]\n       [-s sectors-per-cluster][-S logical-sector-size][-f number-of-FATs]\n       [-h hidden-sectors][-F fat-size][-r root-dir-entries][-R reserved-sectors]\n       [-M FAT-media-byte][-D drive_number]\n       /dev/name [blocks]\n");
  }
}
}
#line 1377 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/mkfs.fat.c"
static void check_atari___0(void) 
{ 


  {
#line 1399
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static struct __anonstruct_mediabytes_34___0 mediabytes___0[9]  = 
#line 47 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
  {      {(__u8 )240, (char *)"5.25\" or 3.5\" HD floppy"}, 
        {(__u8 )248, (char *)"hard disk"}, 
        {(__u8 )249, (char *)"3,5\" 720k floppy 2s/80tr/9sec or 5.25\" 1.2M floppy 2s/80tr/15sec"}, 
        {(__u8 )250,
      (char *)"5.25\" 320k floppy 1s/80tr/8sec"}, 
        {(__u8 )251, (char *)"3.5\" 640k floppy 2s/80tr/8sec"}, 
        {(__u8 )252, (char *)"5.25\" 180k floppy 1s/40tr/9sec"}, 
        {(__u8 )253, (char *)"5.25\" 360k floppy 2s/40tr/9sec"}, 
        {(__u8 )254, (char *)"5.25\" 160k floppy 1s/40tr/8sec"}, 
        {(__u8 )255, (char *)"5.25\" 320k floppy 2s/40tr/8sec"}};
#line 67 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static char *get_media_descr___0(unsigned char media ) 
{ 
  int i ;

  {
#line 71
  i = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! ((unsigned long )i < sizeof(mediabytes___0) / sizeof(mediabytes___0[0]))) {
#line 71
      goto while_break;
    }
#line 72
    if ((int )mediabytes___0[i].media == (int )media) {
#line 73
      return (mediabytes___0[i].descr);
    }
#line 71
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return ((char *)"undefined");
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void dump_boot___0(DOS_FS *fs , struct boot_sector *b , unsigned int lss ) 
{ 
  unsigned short sectors ;
  char id[9] ;
  char *tmp ;
  char const   *tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;

  {
  {
#line 82
  printf((char const   */* __restrict  */)"Boot sector contents:\n");
  }
#line 83
  if (! atari_format) {
    {
#line 85
    strncpy((char */* __restrict  */)(id), (char const   */* __restrict  */)((char const   *)(b->system_id)),
            (size_t )8);
#line 86
    id[8] = (char)0;
#line 87
    printf((char const   */* __restrict  */)"System ID \"%s\"\n", id);
    }
  } else {
    {
#line 91
    printf((char const   */* __restrict  */)"Serial number 0x%x\n", ((int )b->system_id[5] | ((int )b->system_id[6] << 8)) | ((int )b->system_id[7] << 16));
    }
  }
  {
#line 95
  tmp = get_media_descr___0(b->media);
#line 95
  printf((char const   */* __restrict  */)"Media byte 0x%02x (%s)\n", (int )b->media,
         tmp);
#line 96
  printf((char const   */* __restrict  */)"%10d bytes per logical sector\n", (int )((__u16 )b->sector_size[0]) | ((int )((__u16 )b->sector_size[1]) << 8));
#line 97
  printf((char const   */* __restrict  */)"%10d bytes per cluster\n", fs->cluster_size);
  }
#line 98
  if ((int )b->reserved == 1) {
#line 98
    tmp___0 = "";
  } else {
#line 98
    tmp___0 = "s";
  }
  {
#line 98
  printf((char const   */* __restrict  */)"%10d reserved sector%s\n", (int )b->reserved,
         tmp___0);
#line 100
  printf((char const   */* __restrict  */)"First FAT starts at byte %llu (sector %llu)\n",
         (unsigned long long )fs->fat_start, (unsigned long long )fs->fat_start / (unsigned long long )lss);
#line 103
  printf((char const   */* __restrict  */)"%10d FATs, %d bit entries\n", (int )b->fats,
         fs->fat_bits);
#line 104
  printf((char const   */* __restrict  */)"%10d bytes per FAT (= %u sectors)\n", fs->fat_size,
         fs->fat_size / lss);
  }
#line 106
  if (! fs->root_cluster) {
    {
#line 107
    printf((char const   */* __restrict  */)"Root directory starts at byte %llu (sector %llu)\n",
           (unsigned long long )fs->root_start, (unsigned long long )fs->root_start / (unsigned long long )lss);
#line 110
    printf((char const   */* __restrict  */)"%10d root directory entries\n", fs->root_entries);
    }
  } else {
    {
#line 112
    printf((char const   */* __restrict  */)"Root directory start at cluster %lu (arbitrary size)\n",
           (unsigned long )fs->root_cluster);
    }
  }
  {
#line 115
  printf((char const   */* __restrict  */)"Data area starts at byte %llu (sector %llu)\n",
         (unsigned long long )fs->data_start, (unsigned long long )fs->data_start / (unsigned long long )lss);
#line 118
  printf((char const   */* __restrict  */)"%10lu data clusters (%llu bytes)\n", (unsigned long )fs->clusters,
         (unsigned long long )fs->clusters * (unsigned long long )fs->cluster_size);
#line 120
  printf((char const   */* __restrict  */)"%u sectors/track, %u heads\n", (int )b->secs_track,
         (int )b->heads);
  }
#line 122
  if (atari_format) {
#line 122
    tmp___1 = (__u32 )((int )*((unsigned char *)(& b->hidden) + 0) | ((int )*((unsigned char *)(& b->hidden) + 1) << 8));
  } else {
#line 122
    tmp___1 = b->hidden;
  }
  {
#line 122
  printf((char const   */* __restrict  */)"%10u hidden sectors\n", tmp___1);
#line 126
  sectors = (unsigned short )((int )((__u16 )b->sectors[0]) | ((int )((__u16 )b->sectors[1]) << 8));
  }
#line 127
  if (sectors) {
#line 127
    tmp___2 = (__u32 )sectors;
  } else {
#line 127
    tmp___2 = b->total_sect;
  }
  {
#line 127
  printf((char const   */* __restrict  */)"%10u sectors total\n", tmp___2);
  }
#line 128
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void check_backup_boot___0(DOS_FS *fs , struct boot_sector *b , int lss ) 
{ 
  struct boot_sector b2 ;
  int bbs ;
  char tmp ;
  __u8 *p ;
  __u8 *q ;
  int i ;
  int pos ;
  int first ;
  char buf[20] ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 134
  if (! fs->backupboot_start) {
    {
#line 135
    printf((char const   */* __restrict  */)"There is no backup boot sector.\n");
    }
#line 136
    if ((int )b->reserved < 3) {
      {
#line 137
      printf((char const   */* __restrict  */)"And there is no space for creating one!\n");
      }
#line 138
      return;
    }
#line 140
    if (interactive) {
      {
#line 141
      printf((char const   */* __restrict  */)"1) Create one\n2) Do without a backup\n");
      }
    } else {
      {
#line 143
      printf((char const   */* __restrict  */)"  Auto-creating backup boot block.\n");
      }
    }
#line 144
    if (! interactive) {
#line 144
      goto _L___0;
    } else {
      {
#line 144
      tmp = get_key((char *)"12", (char *)"?");
      }
#line 144
      if ((int )tmp == 49) {
        _L___0: /* CIL Label */ 
#line 148
        if ((int )b->reserved >= 7) {
#line 148
          if ((int )b->info_sector != 6) {
#line 149
            bbs = 6;
          } else {
#line 148
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 151
          bbs = (int )b->reserved - 1;
#line 152
          if (bbs == (int )b->info_sector) {
#line 153
            bbs --;
          }
        }
        {
#line 155
        fs->backupboot_start = (loff_t )(bbs * lss);
#line 156
        b->backup_boot = (__u16 )bbs;
#line 157
        fs_write(fs->backupboot_start, (int )sizeof(*b), (void *)b);
#line 158
        fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->backup_boot)),
                 (int )sizeof(b->backup_boot), (void *)(& b->backup_boot));
#line 160
        printf((char const   */* __restrict  */)"Created backup of boot sector in sector %d\n",
               bbs);
        }
#line 161
        return;
      } else {
#line 163
        return;
      }
    }
  }
  {
#line 166
  fs_read(fs->backupboot_start, (int )sizeof(b2), (void *)(& b2));
#line 167
  tmp___5 = memcmp((void const   *)b, (void const   *)(& b2), sizeof(b2));
  }
#line 167
  if (tmp___5 != 0) {
    {
#line 170
    first = 1;
#line 173
    printf((char const   */* __restrict  */)"There are differences between boot sector and its backup.\n");
#line 174
    printf((char const   */* __restrict  */)"This is mostly harmless. Differences: (offset:original/backup)\n  ");
#line 175
    pos = 2;
#line 176
    p = (__u8 *)b;
#line 176
    q = (__u8 *)(& b2);
#line 176
    i = 0;
    }
    {
#line 176
    while (1) {
      while_continue: /* CIL Label */ ;
#line 176
      if (! ((unsigned long )i < sizeof(b2))) {
#line 176
        goto while_break;
      }
#line 178
      if ((int )*p != (int )*q) {
#line 179
        if (first) {
#line 179
          tmp___0 = "";
        } else {
#line 179
          tmp___0 = ", ";
        }
        {
#line 179
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s%u:%02x/%02x",
                tmp___0, (unsigned int )(p - (__u8 *)b), (int )*p, (int )*q);
#line 181
        tmp___1 = strlen((char const   *)(buf));
        }
#line 181
        if ((size_t )pos + tmp___1 > 78UL) {
          {
#line 182
          printf((char const   */* __restrict  */)"\n  ");
#line 182
          pos = 2;
          }
        }
        {
#line 183
        printf((char const   */* __restrict  */)"%s", buf);
#line 184
        tmp___2 = strlen((char const   *)(buf));
#line 184
        pos = (int )((size_t )pos + tmp___2);
#line 185
        first = 0;
        }
      }
#line 176
      p ++;
#line 176
      q ++;
#line 176
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 188
    printf((char const   */* __restrict  */)"\n");
    }
#line 190
    if (interactive) {
      {
#line 191
      printf((char const   */* __restrict  */)"1) Copy original to backup\n2) Copy backup to original\n3) No action\n");
      }
    } else {
      {
#line 194
      printf((char const   */* __restrict  */)"  Not automatically fixing this.\n");
      }
    }
#line 195
    if (interactive) {
      {
#line 195
      tmp___3 = get_key((char *)"123", (char *)"?");
#line 195
      tmp___4 = (int )tmp___3;
      }
    } else {
#line 195
      tmp___4 = '3';
    }
    {
#line 196
    if (tmp___4 == 49) {
#line 196
      goto case_49;
    }
#line 199
    if (tmp___4 == 50) {
#line 199
      goto case_50;
    }
#line 202
    goto switch_default;
    case_49: /* CIL Label */ 
    {
#line 197
    fs_write(fs->backupboot_start, (int )sizeof(*b), (void *)b);
    }
#line 198
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 200
    fs_write((loff_t )0, (int )sizeof(b2), (void *)(& b2));
    }
#line 201
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 203
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 206
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void init_fsinfo___0(struct info_sector *i ) 
{ 


  {
#line 210
  i->magic = (__u32 )1096897106;
#line 211
  i->signature = (__u32 )1631679090;
#line 212
  i->free_clusters = (__u32 )-1;
#line 213
  i->next_cluster = (__u32 )2;
#line 214
  i->boot_sign = (__u16 )43605;
#line 215
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void read_fsinfo___0(DOS_FS *fs , struct boot_sector *b , int lss ) 
{ 
  struct info_sector i ;
  __u32 s ;
  char tmp ;
  char tmp___0 ;

  {
#line 221
  if (! b->info_sector) {
    {
#line 222
    printf((char const   */* __restrict  */)"No FSINFO sector\n");
    }
#line 223
    if (interactive) {
      {
#line 224
      printf((char const   */* __restrict  */)"1) Create one\n2) Do without FSINFO\n");
      }
    } else {
      {
#line 226
      printf((char const   */* __restrict  */)"  Not automatically creating it.\n");
      }
    }
#line 227
    if (interactive) {
      {
#line 227
      tmp = get_key((char *)"12", (char *)"?");
      }
#line 227
      if ((int )tmp == 49) {
#line 231
        s = (__u32 )1;
        {
#line 231
        while (1) {
          while_continue: /* CIL Label */ ;
#line 231
          if (! (s < (__u32 )b->reserved)) {
#line 231
            goto while_break;
          }
#line 232
          if (s != (__u32 )b->backup_boot) {
#line 233
            goto while_break;
          }
#line 231
          s ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 234
        if (s > 0U) {
#line 234
          if (s < (__u32 )b->reserved) {
            {
#line 235
            init_fsinfo___0(& i);
#line 236
            fs_write((loff_t )s * (loff_t )lss, (int )sizeof(i), (void *)(& i));
#line 237
            b->info_sector = (__u16 )s;
#line 238
            fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->info_sector)),
                     (int )sizeof(b->info_sector), (void *)(& b->info_sector));
            }
#line 240
            if (fs->backupboot_start) {
              {
#line 241
              fs_write((loff_t )((unsigned long )fs->backupboot_start + (unsigned long )(& ((struct boot_sector *)0)->info_sector)),
                       (int )sizeof(b->info_sector), (void *)(& b->info_sector));
              }
            }
          } else {
            {
#line 245
            printf((char const   */* __restrict  */)"No free reserved sector found -- no space for FSINFO sector!\n");
            }
#line 247
            return;
          }
        } else {
          {
#line 245
          printf((char const   */* __restrict  */)"No free reserved sector found -- no space for FSINFO sector!\n");
          }
#line 247
          return;
        }
      } else {
#line 250
        return;
      }
    } else {
#line 250
      return;
    }
  }
  {
#line 253
  fs->fsinfo_start = (loff_t )((int )b->info_sector * lss);
#line 254
  fs_read(fs->fsinfo_start, (int )sizeof(i), (void *)(& i));
  }
#line 256
  if (i.magic != 1096897106U) {
#line 256
    goto _L;
  } else
#line 256
  if (i.signature != 1631679090U) {
#line 256
    goto _L;
  } else
#line 256
  if ((int )i.boot_sign != 43605) {
    _L: /* CIL Label */ 
    {
#line 258
    printf((char const   */* __restrict  */)"FSINFO sector has bad magic number(s):\n");
    }
#line 259
    if (i.magic != 1096897106U) {
      {
#line 260
      printf((char const   */* __restrict  */)"  Offset %llu: 0x%08x != expected 0x%08x\n",
             (unsigned long long )((unsigned long )(& ((struct info_sector *)0)->magic)),
             i.magic, 1096897106);
      }
    }
#line 263
    if (i.signature != 1631679090U) {
      {
#line 264
      printf((char const   */* __restrict  */)"  Offset %llu: 0x%08x != expected 0x%08x\n",
             (unsigned long long )((unsigned long )(& ((struct info_sector *)0)->signature)),
             i.signature, 1631679090);
      }
    }
#line 267
    if ((int )i.boot_sign != 43605) {
      {
#line 268
      printf((char const   */* __restrict  */)"  Offset %llu: 0x%04x != expected 0x%04x\n",
             (unsigned long long )((unsigned long )(& ((struct info_sector *)0)->boot_sign)),
             (int )i.boot_sign, 43605);
      }
    }
#line 271
    if (interactive) {
      {
#line 272
      printf((char const   */* __restrict  */)"1) Correct\n2) Don\'t correct (FSINFO invalid then)\n");
      }
    } else {
      {
#line 274
      printf((char const   */* __restrict  */)"  Auto-correcting it.\n");
      }
    }
#line 275
    if (! interactive) {
      {
#line 276
      init_fsinfo___0(& i);
#line 277
      fs_write(fs->fsinfo_start, (int )sizeof(i), (void *)(& i));
      }
    } else {
      {
#line 275
      tmp___0 = get_key((char *)"12", (char *)"?");
      }
#line 275
      if ((int )tmp___0 == 49) {
        {
#line 276
        init_fsinfo___0(& i);
#line 277
        fs_write(fs->fsinfo_start, (int )sizeof(i), (void *)(& i));
        }
      } else {
#line 279
        fs->fsinfo_start = (loff_t )0;
      }
    }
  }
#line 282
  if (fs->fsinfo_start) {
#line 283
    fs->free_clusters = (long )i.free_clusters;
  }
#line 284
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static char print_fat_dirty_state___0(void) 
{ 
  char tmp ;

  {
  {
#line 288
  printf((char const   */* __restrict  */)"Dirty bit is set. Fs was not properly unmounted and some data may be corrupt.\n");
  }
#line 291
  if (interactive) {
    {
#line 292
    printf((char const   */* __restrict  */)"1) Remove dirty bit\n2) No action\n");
#line 293
    tmp = get_key((char *)"12", (char *)"?");
    }
#line 293
    return (tmp);
  } else {
    {
#line 295
    printf((char const   */* __restrict  */)" Automatically removing dirty bit.\n");
    }
  }
#line 296
  return ((char )'1');
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void check_fat_state_bit___0(DOS_FS *fs , void *b ) 
{ 
  struct boot_sector *b32 ;
  char tmp ;
  struct boot_sector_16 *b16 ;
  char tmp___0 ;

  {
#line 301
  if (fs->fat_bits == 32U) {
#line 302
    b32 = (struct boot_sector *)b;
#line 304
    if ((int )b32->reserved3 & 1) {
      {
#line 305
      printf((char const   */* __restrict  */)"0x41: ");
#line 306
      tmp = print_fat_dirty_state___0();
      }
#line 306
      if ((int )tmp == 49) {
        {
#line 307
        b32->reserved3 = (__u8 )((int )b32->reserved3 & -2);
#line 308
        fs_write((loff_t )0, (int )sizeof(*b32), (void *)b32);
        }
      }
    }
  } else {
#line 312
    b16 = (struct boot_sector_16 *)b;
#line 314
    if ((int )b16->reserved2 & 1) {
      {
#line 315
      printf((char const   */* __restrict  */)"0x25: ");
#line 316
      tmp___0 = print_fat_dirty_state___0();
      }
#line 316
      if ((int )tmp___0 == 49) {
        {
#line 317
        b16->reserved2 = (__u8 )((int )b16->reserved2 & -2);
#line 318
        fs_write((loff_t )0, (int )sizeof(*b16), (void *)b16);
        }
      }
    }
  }
#line 322
  return;
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void write_boot_label___0(DOS_FS *fs , char *label ) 
{ 
  struct boot_sector_16 b16 ;
  char const   *tmp ;
  struct boot_sector b ;

  {
#line 466
  if (fs->fat_bits == 12U) {
#line 466
    goto _L;
  } else
#line 466
  if (fs->fat_bits == 16U) {
    _L: /* CIL Label */ 
    {
#line 469
    fs_read((loff_t )0, (int )sizeof(b16), (void *)(& b16));
    }
#line 470
    if ((int )b16.extended_sig != 41) {
#line 471
      b16.extended_sig = (__u8 )41;
#line 472
      b16.serial = (__u32 )0;
#line 473
      if (fs->fat_bits == 12U) {
#line 473
        tmp = "FAT12   ";
      } else {
#line 473
        tmp = "FAT16   ";
      }
      {
#line 473
      memmove((void *)(b16.fs_type), (void const   *)tmp, (size_t )8);
      }
    }
    {
#line 476
    memmove((void *)(b16.label), (void const   *)label, (size_t )11);
#line 477
    fs_write((loff_t )0, (int )sizeof(b16), (void *)(& b16));
    }
  } else
#line 478
  if (fs->fat_bits == 32U) {
    {
#line 481
    fs_read((loff_t )0, (int )sizeof(b), (void *)(& b));
    }
#line 482
    if ((int )b.extended_sig != 41) {
      {
#line 483
      b.extended_sig = (__u8 )41;
#line 484
      b.serial = (__u32 )0;
#line 485
      memmove((void *)(b.fs_type), (void const   *)"FAT32   ", (size_t )8);
      }
    }
    {
#line 487
    memmove((void *)(b.label), (void const   *)label, (size_t )11);
#line 488
    fs_write((loff_t )0, (int )sizeof(b), (void *)(& b));
    }
#line 489
    if (fs->backupboot_start) {
      {
#line 490
      fs_write(fs->backupboot_start, (int )sizeof(b), (void *)(& b));
      }
    }
  }
#line 492
  return;
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/boot.c"
static void write_volume_label___0(DOS_FS *fs , char *label ) 
{ 
  time_t now ;
  time_t tmp ;
  struct tm *mtime ;
  struct tm *tmp___0 ;
  loff_t offset ;
  int created ;
  DIR_ENT de ;

  {
  {
#line 526
  tmp = time((time_t *)((void *)0));
#line 526
  now = tmp;
#line 527
  tmp___0 = localtime((time_t const   *)(& now));
#line 527
  mtime = tmp___0;
#line 532
  created = 0;
#line 533
  offset = find_volume_de(fs, & de);
  }
#line 534
  if (offset == 0L) {
    {
#line 535
    created = 1;
#line 536
    offset = alloc_rootdir_entry(fs, & de, (char const   *)label);
    }
  }
  {
#line 538
  memcpy((void */* __restrict  */)(de.name), (void const   */* __restrict  */)label,
         (size_t )11);
#line 539
  de.time = (unsigned short )(((mtime->tm_sec >> 1) + (mtime->tm_min << 5)) + (mtime->tm_hour << 11));
#line 542
  de.date = (unsigned short )((mtime->tm_mday + ((mtime->tm_mon + 1) << 5)) + ((mtime->tm_year - 80) << 9));
  }
#line 545
  if (created) {
#line 546
    de.attr = (__u8 )8;
#line 547
    de.ctime_ms = (__u8 )0;
#line 548
    de.ctime = de.time;
#line 549
    de.cdate = de.date;
#line 550
    de.adate = de.date;
#line 551
    de.starthi = (__u16 )0;
#line 552
    de.start = (__u16 )0;
#line 553
    de.size = (__u32 )0;
  }
  {
#line 556
  fs_write(offset, (int )sizeof(DIR_ENT ), (void *)(& de));
  }
#line 557
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
static unsigned char fat_uni2esc___0[64]  = 
#line 58 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
  {      (unsigned char )'0',      (unsigned char )'1',      (unsigned char )'2',      (unsigned char )'3', 
        (unsigned char )'4',      (unsigned char )'5',      (unsigned char )'6',      (unsigned char )'7', 
        (unsigned char )'8',      (unsigned char )'9',      (unsigned char )'A',      (unsigned char )'B', 
        (unsigned char )'C',      (unsigned char )'D',      (unsigned char )'E',      (unsigned char )'F', 
        (unsigned char )'G',      (unsigned char )'H',      (unsigned char )'I',      (unsigned char )'J', 
        (unsigned char )'K',      (unsigned char )'L',      (unsigned char )'M',      (unsigned char )'N', 
        (unsigned char )'O',      (unsigned char )'P',      (unsigned char )'Q',      (unsigned char )'R', 
        (unsigned char )'S',      (unsigned char )'T',      (unsigned char )'U',      (unsigned char )'V', 
        (unsigned char )'W',      (unsigned char )'X',      (unsigned char )'Y',      (unsigned char )'Z', 
        (unsigned char )'a',      (unsigned char )'b',      (unsigned char )'c',      (unsigned char )'d', 
        (unsigned char )'e',      (unsigned char )'f',      (unsigned char )'g',      (unsigned char )'h', 
        (unsigned char )'i',      (unsigned char )'j',      (unsigned char )'k',      (unsigned char )'l', 
        (unsigned char )'m',      (unsigned char )'n',      (unsigned char )'o',      (unsigned char )'p', 
        (unsigned char )'q',      (unsigned char )'r',      (unsigned char )'s',      (unsigned char )'t', 
        (unsigned char )'u',      (unsigned char )'v',      (unsigned char )'w',      (unsigned char )'x', 
        (unsigned char )'y',      (unsigned char )'z',      (unsigned char )'+',      (unsigned char )'-'};
#line 90 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
static size_t mbslen___0(wchar_t x ) 
{ 
  wchar_t wstr[2] ;
  size_t tmp ;

  {
  {
#line 92
  wstr[0] = x;
#line 92
  wstr[1] = 0;
#line 93
  tmp = wcstombs((char */* __restrict  */)((void *)0), (wchar_t const   */* __restrict  */)(wstr),
                 (size_t )0);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
static size_t wctombs___0(char *dest , wchar_t x ) 
{ 
  wchar_t wstr[2] ;
  size_t size ;
  size_t tmp ;

  {
  {
#line 98
  wstr[0] = x;
#line 98
  wstr[1] = 0;
#line 99
  tmp = wcstombs((char */* __restrict  */)((void *)0), (wchar_t const   */* __restrict  */)(wstr),
                 (size_t )0);
#line 99
  size = tmp;
  }
#line 100
  if (size != 0xffffffffffffffffUL) {
    {
#line 101
    size = wcstombs((char */* __restrict  */)dest, (wchar_t const   */* __restrict  */)(wstr),
                    size + 1UL);
    }
  }
#line 102
  return (size);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
static char *cnv_unicode___0(unsigned char const   *uni , int maxlen , int use_q ) 
{ 
  unsigned char const   *up ;
  unsigned char *out ;
  unsigned char *cp ;
  int len ;
  int val ;
  size_t x ;
  void *tmp ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 115
  len = 0;
#line 115
  up = uni;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if ((up - uni) / 2L < (long )maxlen) {
#line 115
      if (! *(up + 0)) {
#line 115
        if (! *(up + 1)) {
#line 115
          goto while_break;
        }
      }
    } else {
#line 115
      goto while_break;
    }
    {
#line 117
    x = mbslen___0((wchar_t )((unsigned int )*(up + 0) + ((unsigned int )*(up + 1) << 8)));
    }
#line 117
    if (x != 0xffffffffffffffffUL) {
#line 118
      len = (int )((size_t )len + x);
    } else
#line 119
    if ((int const   )*(up + 1) == 0) {
#line 119
      if ((int const   )*(up + 0) < 128) {
#line 120
        len ++;
      } else
#line 119
      if ((int const   )*(up + 0) >= 160) {
#line 120
        len ++;
      } else {
#line 122
        len += 4;
      }
    } else {
#line 122
      len += 4;
    }
#line 115
    up += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  if (use_q) {
    {
#line 124
    tmp = qalloc(& mem_queue, len + 1);
#line 124
    out = (unsigned char *)tmp;
    }
  } else {
    {
#line 124
    tmp___0 = alloc(len + 1);
#line 124
    out = (unsigned char *)tmp___0;
    }
  }
#line 124
  cp = out;
#line 126
  up = uni;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 126
    if ((up - uni) / 2L < (long )maxlen) {
#line 126
      if (! *(up + 0)) {
#line 126
        if (! *(up + 1)) {
#line 126
          goto while_break___0;
        }
      }
    } else {
#line 126
      goto while_break___0;
    }
    {
#line 127
    x = wctombs___0((char *)cp, (wchar_t )((unsigned int )*(up + 0) + ((unsigned int )*(up + 1) << 8)));
    }
#line 127
    if (x != 0xffffffffffffffffUL) {
#line 129
      cp += x;
    } else
#line 130
    if ((int const   )*(up + 1) == 0) {
#line 130
      if ((int const   )*(up + 0) < 128) {
#line 131
        tmp___1 = cp;
#line 131
        cp ++;
#line 131
        *tmp___1 = (unsigned char )*(up + 0);
      } else
#line 130
      if ((int const   )*(up + 0) >= 160) {
#line 131
        tmp___1 = cp;
#line 131
        cp ++;
#line 131
        *tmp___1 = (unsigned char )*(up + 0);
      } else {
#line 130
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 134
      tmp___2 = cp;
#line 134
      cp ++;
#line 134
      *tmp___2 = (unsigned char )':';
#line 135
      val = (int )(((int const   )*(up + 1) << 8) + (int const   )*(up + 0));
#line 136
      *(cp + 2) = fat_uni2esc___0[val & 63];
#line 137
      val >>= 6;
#line 138
      *(cp + 1) = fat_uni2esc___0[val & 63];
#line 139
      val >>= 6;
#line 140
      *(cp + 0) = fat_uni2esc___0[val & 63];
#line 141
      cp += 3;
    }
#line 126
    up += 2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 144
  *cp = (unsigned char)0;
#line 146
  return ((char *)out);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
static void copy_lfn_part___0(unsigned char *dst , LFN_ENT *lfn ) 
{ 


  {
  {
#line 151
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(lfn->name0_4),
         (size_t )10);
#line 152
  memcpy((void */* __restrict  */)(dst + 10), (void const   */* __restrict  */)(lfn->name5_10),
         (size_t )12);
#line 153
  memcpy((void */* __restrict  */)(dst + 22), (void const   */* __restrict  */)(lfn->name11_12),
         (size_t )4);
  }
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/lfn.c"
static void clear_lfn_slots___0(int start , int end ) 
{ 
  int i ;
  LFN_ENT empty ;

  {
  {
#line 165
  memset((void *)(& empty), 0, sizeof(empty));
#line 166
  empty.id = (__u8 )229;
#line 168
  i = start;
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i <= end)) {
#line 168
      goto while_break;
    }
    {
#line 169
    fs_write(*(lfn_offsets + i), (int )sizeof(LFN_ENT ), (void *)(& empty));
#line 168
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.c"
int boot_only  =    0;
#line 50 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.c"
static void usage___1(char *name ) 
{ 


  {
  {
#line 52
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-aAbflrtvVwy] [-d path -d ...] [-u path -u ...]\n%15sdevice\n",
          name, "");
#line 54
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -a       automatically repair the filesystem\n");
#line 55
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -A       toggle Atari filesystem format\n");
#line 56
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -b       make read-only boot sector check\n");
#line 57
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -c N     use DOS codepage N to decode short file names (default: %d)\n",
          437);
#line 60
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -d path  drop that file\n");
#line 61
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -f       salvage unused chains to files\n");
#line 62
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -l       list path names\n");
#line 63
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -n       no-op, check non-interactively without changing\n");
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -p       same as -a, for compat with other *fsck\n");
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -r       interactively repair the filesystem\n");
#line 67
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -t       test for bad clusters\n");
#line 68
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -u path  try to undelete that (non-directory) file\n");
#line 69
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v       verbose mode\n");
#line 70
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -V       perform a verification pass\n");
#line 71
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -w       write changes to disk immediately\n");
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -y       same as -a, for compat with other *fsck\n");
#line 73
  exit(2);
  }
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fsck.fat.c"
static void check_atari___1(void) 
{ 


  {
#line 102
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/fat.c"
static void tag_free___0(DOS_FS *fs , DOS_FILE *owner , uint32_t *num_refs , uint32_t start_cluster ) 
{ 
  int prev ;
  uint32_t i ;
  uint32_t walk ;
  FAT_ENTRY curEntry ;
  DOS_FILE *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  DOS_FILE *tmp___2 ;

  {
#line 359
  if (start_cluster == 0U) {
#line 360
    start_cluster = (uint32_t )2;
  }
#line 362
  i = start_cluster;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! (i < fs->clusters + 2U)) {
#line 362
      goto while_break;
    }
    {
#line 364
    get_fat(& curEntry, (void *)fs->fat, i, fs);
    }
#line 367
    if (curEntry.value) {
#line 367
      if (atari_format) {
#line 367
        tmp___0 = 4080;
      } else {
#line 367
        tmp___0 = 4087;
      }
#line 367
      if (curEntry.value >= (uint32_t )(tmp___0 | (((1 << fs->eff_fat_bits) - 1) & -16))) {
#line 367
        if (atari_format) {
#line 367
          tmp___1 = 4087;
        } else {
#line 367
          tmp___1 = 4087;
        }
#line 367
        if (! (curEntry.value <= (uint32_t )(tmp___1 | (((1 << fs->eff_fat_bits) - 1) & -16)))) {
#line 367
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 367
        tmp___2 = get_owner(fs, i);
        }
#line 367
        if (! tmp___2) {
#line 367
          if (! *(num_refs + i)) {
#line 369
            prev = 0;
#line 371
            walk = i;
            {
#line 371
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 371
              if (! (walk != 4294967295U)) {
#line 371
                goto while_break___0;
              }
              {
#line 372
              tmp = get_owner(fs, walk);
              }
#line 372
              if (tmp) {
                {
#line 379
                set_fat(fs, (uint32_t )prev, -1);
#line 387
                (*(num_refs + walk)) --;
                }
#line 388
                goto while_break___0;
              } else {
                {
#line 373
                set_owner(fs, walk, owner);
                }
              }
              {
#line 390
              prev = (int )walk;
#line 371
              walk = next_cluster(fs, walk);
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 362
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/charconv.c"
static iconv_t iconv_init_codepage___0(int codepage ) 
{ 
  iconv_t result ;
  char codepage_name[16] ;
  char *tmp ;

  {
  {
#line 11
  snprintf((char */* __restrict  */)(codepage_name), sizeof(codepage_name), (char const   */* __restrict  */)"CP%d",
           codepage);
#line 12
  tmp = nl_langinfo(14);
#line 12
  result = iconv_open((char const   *)tmp, (char const   *)(codepage_name));
  }
#line 13
  if ((unsigned long )result == (unsigned long )((iconv_t )-1)) {
    {
#line 14
    perror((char const   *)(codepage_name));
    }
  }
#line 15
  return (result);
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/charconv.c"
static iconv_t dos_to_local___0  ;
#line 27
static int init_conversion___0(int codepage ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/charconv.c"
static int initialized___0  =    -1;
#line 25 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/charconv.c"
static int init_conversion___0(int codepage ) 
{ 


  {
#line 28
  if (initialized___0 < 0) {
#line 29
    initialized___0 = 1;
#line 30
    if (codepage < 0) {
#line 31
      codepage = 437;
    }
    {
#line 32
    setlocale(6, "");
#line 33
    dos_to_local___0 = iconv_init_codepage___0(codepage);
    }
#line 34
    if ((unsigned long )dos_to_local___0 == (unsigned long )((iconv_t )-1)) {
#line 34
      if (codepage != 437) {
        {
#line 35
        printf((char const   */* __restrict  */)"Trying to set fallback DOS codepage %d\n",
               437);
#line 37
        dos_to_local___0 = iconv_init_codepage___0(437);
        }
#line 38
        if ((unsigned long )dos_to_local___0 == (unsigned long )((iconv_t )-1)) {
#line 39
          initialized___0 = 0;
        }
      }
    }
  }
#line 42
  return (initialized___0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static DOS_FILE *root___0  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int curr_num___0  =    0;
#line 208 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static char path___1[8192]  ;
#line 206 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static char *path_name___0(DOS_FILE *file ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 210
  if (! file) {
#line 211
    path___1[0] = (char)0;
  } else {
    {
#line 213
    tmp = path_name___0(file->parent);
#line 213
    tmp___0 = strlen((char const   *)tmp);
    }
#line 213
    if (tmp___0 > 4096UL) {
      {
#line 214
      die((char *)"Path name too long.");
      }
    }
    {
#line 215
    tmp___1 = strcmp((char const   *)(path___1), "/");
    }
#line 215
    if (tmp___1 != 0) {
      {
#line 216
      strcat((char */* __restrict  */)(path___1), (char const   */* __restrict  */)"/");
      }
    }
#line 221
    if (file->lfn) {
#line 221
      tmp___3 = file->lfn;
    } else {
      {
#line 221
      tmp___2 = file_name(file->dir_ent.name);
#line 221
      tmp___3 = tmp___2;
      }
    }
    {
#line 221
    tmp___4 = strrchr((char const   *)(path___1), 0);
#line 221
    strcpy((char */* __restrict  */)tmp___4, (char const   */* __restrict  */)tmp___3);
    }
  }
#line 224
  return (path___1);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int day_n___0[16]  = 
#line 227
  {      0,      31,      59,      90, 
        120,      151,      181,      212, 
        243,      273,      304,      334, 
        0,      0,      0,      0};
#line 233 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static time_t date_dos2unix___0(unsigned short time___0 , unsigned short date ) 
{ 
  int month ;
  int year ;
  time_t secs ;
  int tmp ;

  {
#line 238
  month = (((int )date >> 5) & 15) - 1;
#line 239
  year = (int )date >> 9;
#line 240
  if ((year & 3) == 0) {
#line 240
    if (month < 2) {
#line 240
      tmp = 1;
    } else {
#line 240
      tmp = 0;
    }
  } else {
#line 240
    tmp = 0;
  }
#line 240
  secs = (time_t )(((((int )time___0 & 31) * 2 + 60 * (((int )time___0 >> 5) & 63)) + ((int )time___0 >> 11) * 3600) + 86400 * ((((((((int )date & 31) - 1) + day_n___0[month]) + year / 4) + year * 365) - tmp) + 3653));
#line 245
  return (secs);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static char temp___0[100]  ;
#line 248 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static char *file_stat___0(DOS_FILE *file ) 
{ 
  struct tm *tm ;
  char tmp[100] ;
  time_t date ;

  {
  {
#line 255
  date = date_dos2unix___0(file->dir_ent.time, file->dir_ent.date);
#line 257
  tm = localtime((time_t const   *)(& date));
#line 258
  strftime((char */* __restrict  */)(tmp), (size_t )99, (char const   */* __restrict  */)"%H:%M:%S %b %d %Y",
           (struct tm  const  */* __restrict  */)tm);
#line 259
  sprintf((char */* __restrict  */)(temp___0), (char const   */* __restrict  */)"  Size %u bytes, date %s",
          file->dir_ent.size, tmp);
  }
#line 260
  return (temp___0);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int bad_name___0(DOS_FILE *file ) 
{ 
  int i ;
  int spc ;
  int suspicious ;
  char const   *bad_chars ;
  char const   *tmp ;
  unsigned char const   *name ;
  unsigned char const   *ext ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 265
  suspicious = 0;
#line 266
  if (atari_format) {
#line 266
    tmp = "*?\\/:";
  } else {
#line 266
    tmp = "*?<>|\"\\/:";
  }
  {
#line 266
  bad_chars = tmp;
#line 267
  name = (unsigned char const   *)(file->dir_ent.name);
#line 268
  ext = (unsigned char const   *)(file->dir_ent.ext);
#line 272
  tmp___0 = strncmp((char const   *)name, "EA DATA  SF", (size_t )11);
  }
#line 272
  if (tmp___0 == 0) {
#line 274
    return (0);
  } else {
    {
#line 272
    tmp___1 = strncmp((char const   *)name, "WP ROOT  SF", (size_t )11);
    }
#line 272
    if (tmp___1 == 0) {
#line 274
      return (0);
    }
  }
#line 278
  if ((unsigned long )file->lfn == (unsigned long )((void *)0)) {
#line 278
    if ((int )file->dir_ent.lcase & 32) {
#line 279
      return (1);
    }
  }
#line 284
  if ((int )file->dir_ent.lcase & 32) {
#line 285
    return (0);
  }
#line 287
  i = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (i < 8)) {
#line 287
      goto while_break;
    }
#line 288
    if ((int const   )*(name + i) < 32) {
#line 289
      return (1);
    } else
#line 288
    if ((int const   )*(name + i) == 127) {
#line 289
      return (1);
    }
#line 290
    if ((int const   )*(name + i) > 127) {
#line 291
      suspicious ++;
    }
    {
#line 292
    tmp___2 = strchr(bad_chars, (int )*(name + i));
    }
#line 292
    if (tmp___2) {
#line 293
      return (1);
    }
#line 287
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  i = 0;
  {
#line 296
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 296
    if (! (i < 3)) {
#line 296
      goto while_break___0;
    }
#line 297
    if ((int const   )*(ext + i) < 32) {
#line 298
      return (1);
    } else
#line 297
    if ((int const   )*(ext + i) == 127) {
#line 298
      return (1);
    }
#line 299
    if ((int const   )*(ext + i) > 127) {
#line 300
      suspicious ++;
    }
    {
#line 301
    tmp___3 = strchr(bad_chars, (int )*(ext + i));
    }
#line 301
    if (tmp___3) {
#line 302
      return (1);
    }
#line 296
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 305
  spc = 0;
#line 306
  i = 0;
  {
#line 306
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 306
    if (! (i < 8)) {
#line 306
      goto while_break___1;
    }
#line 307
    if ((int const   )*(name + i) == 32) {
#line 308
      spc = 1;
    } else
#line 309
    if (spc) {
#line 312
      return (1);
    }
#line 306
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 315
  spc = 0;
#line 316
  i = 0;
  {
#line 316
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 316
    if (! (i < 3)) {
#line 316
      goto while_break___2;
    }
#line 317
    if ((int const   )*(ext + i) == 32) {
#line 318
      spc = 1;
    } else
#line 319
    if (spc) {
#line 322
      return (1);
    }
#line 316
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 326
  if (atari_format) {
#line 326
    if (suspicious) {
#line 327
      return (1);
    }
  }
#line 333
  return (0);
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void lfn_remove___0(loff_t from , loff_t to ) 
{ 
  DIR_ENT empty ;

  {
  {
#line 344
  memset((void *)(& empty), 0, sizeof(empty));
#line 345
  empty.name[0] = (__u8 )229;
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (from < to)) {
#line 347
      goto while_break;
    }
    {
#line 348
    fs_write(from, (int )sizeof(DIR_ENT ), (void *)(& empty));
#line 347
    from = (loff_t )((unsigned long )from + sizeof(empty));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void drop_file___0(DOS_FS *fs , DOS_FILE *file ) 
{ 
  uint32_t cluster ;
  int tmp ;

  {
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (file->offset) {
      {
#line 356
      file->dir_ent.name[0] = (__u8 )229;
#line 356
      fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->name[0])),
               (int )sizeof(file->dir_ent.name[0]), (void *)(& file->dir_ent.name[0]));
      }
    }
#line 356
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  if (file->lfn) {
    {
#line 358
    lfn_remove___0(file->lfn_offset, file->offset);
    }
  }
#line 359
  if (fs->fat_bits == 32U) {
#line 359
    tmp = (int )file->dir_ent.starthi << 16;
  } else {
#line 359
    tmp = 0;
  }
#line 359
  cluster = (uint32_t )file->dir_ent.start | (unsigned int )tmp;
  {
#line 359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 359
    if (cluster > 0U) {
#line 359
      if (! (cluster < fs->clusters + 2U)) {
#line 359
        goto while_break___0;
      }
    } else {
#line 359
      goto while_break___0;
    }
    {
#line 361
    set_owner(fs, cluster, (DOS_FILE *)((void *)0));
#line 359
    cluster = next_cluster(fs, cluster);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 362
  n_files --;
#line 363
  return;
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void truncate_file___0(DOS_FS *fs , DOS_FILE *file , uint32_t clusters ) 
{ 
  int deleting ;
  uint32_t walk ;
  uint32_t next ;
  int tmp ;
  uint32_t __v ;
  int tmp___0 ;

  {
#line 370
  if (fs->fat_bits == 32U) {
#line 370
    tmp = (int )file->dir_ent.starthi << 16;
  } else {
#line 370
    tmp = 0;
  }
#line 370
  walk = (uint32_t )file->dir_ent.start | (unsigned int )tmp;
#line 371
  deleting = ! clusters;
#line 371
  if (deleting) {
    {
#line 372
    while (1) {
      while_continue: /* CIL Label */ ;
#line 372
      __v = (uint32_t )0;
#line 372
      if (! file->offset) {
#line 372
        if (! __v) {
          {
#line 372
          die((char *)"Oops, deleting FAT32 root dir!");
          }
        }
        {
#line 372
        fs->root_cluster = __v;
#line 372
        file->dir_ent.start = (__u16 )(__v & 65535U);
#line 372
        file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 372
        __v = __v;
#line 372
        fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                 (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v));
        }
      } else {
        {
#line 372
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 372
          if (file->offset) {
            {
#line 372
            file->dir_ent.start = (__u16 )(__v & 65535U);
#line 372
            fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                     (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
            }
          }
#line 372
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 372
        if (fs->fat_bits == 32U) {
          {
#line 372
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 372
            if (file->offset) {
              {
#line 372
              file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 372
              fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                       (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
              }
            }
#line 372
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
#line 372
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 373
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 373
    if (walk > 0U) {
#line 373
      if (! (walk != 4294967295U)) {
#line 373
        goto while_break___2;
      }
    } else {
#line 373
      goto while_break___2;
    }
    {
#line 374
    next = next_cluster(fs, walk);
    }
#line 375
    if (deleting) {
      {
#line 376
      set_fat(fs, walk, 0);
      }
    } else {
#line 377
      clusters --;
#line 377
      if (clusters) {
#line 377
        tmp___0 = 0;
      } else {
#line 377
        tmp___0 = 1;
      }
#line 377
      deleting = tmp___0;
#line 377
      if (deleting) {
        {
#line 378
        set_fat(fs, walk, -1);
        }
      }
    }
#line 379
    walk = next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void auto_rename___0(DOS_FILE *file ) 
{ 
  DOS_FILE *first ;
  DOS_FILE *walk ;
  uint32_t number ;
  char num[8] ;
  int tmp ;

  {
#line 388
  if (! file->offset) {
#line 389
    return;
  }
#line 390
  if (file->parent) {
#line 390
    first = (file->parent)->first;
  } else {
#line 390
    first = root___0;
  }
#line 391
  number = (uint32_t )0;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 394
    sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)"%07lu",
            (unsigned long )number);
#line 395
    memcpy((void */* __restrict  */)(file->dir_ent.name), (void const   */* __restrict  */)"FSCK",
           (size_t )4);
#line 396
    memcpy((void */* __restrict  */)(file->dir_ent.name + 4), (void const   */* __restrict  */)(num),
           (size_t )4);
#line 397
    memcpy((void */* __restrict  */)(file->dir_ent.ext), (void const   */* __restrict  */)(num + 4),
           (size_t )3);
#line 398
    walk = first;
    }
    {
#line 398
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 398
      if (! walk) {
#line 398
        goto while_break___0;
      }
#line 399
      if ((unsigned long )walk != (unsigned long )file) {
        {
#line 399
        tmp = strncmp((char const   *)(walk->dir_ent.name), (char const   *)(file->dir_ent.name),
                      (size_t )11);
        }
#line 399
        if (! tmp) {
#line 402
          goto while_break___0;
        }
      }
#line 398
      walk = walk->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 403
    if (! walk) {
#line 405
      if ((int )file->dir_ent.lcase & 32) {
        {
#line 409
        file->dir_ent.lcase = (__u8 )((int )file->dir_ent.lcase & -33);
#line 411
        file->dir_ent.attr = (__u8 )((int )file->dir_ent.attr & -25);
#line 412
        fs_write(file->offset, 13, (void *)(file->dir_ent.name));
        }
      } else {
        {
#line 416
        fs_write(file->offset, 11, (void *)(file->dir_ent.name));
        }
      }
#line 418
      if (file->lfn) {
        {
#line 419
        lfn_fix_checksum(file->lfn_offset, file->offset, (char const   *)(file->dir_ent.name));
        }
      }
#line 421
      return;
    }
#line 423
    number ++;
#line 424
    if (number > 9999999U) {
      {
#line 425
      die((char *)"Too many files need repair.");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 428
  die((char *)"Can\'t generate a unique name.");
  }
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void rename_file___0(DOS_FILE *file ) 
{ 
  unsigned char name[46] ;
  unsigned char *walk ;
  unsigned char *here ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 436
  if (! file->offset) {
    {
#line 437
    printf((char const   */* __restrict  */)"Cannot rename FAT32 root dir\n");
    }
#line 438
    return;
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 441
    printf((char const   */* __restrict  */)"New name: ");
#line 442
    fflush(stdout);
#line 443
    tmp___2 = fgets((char */* __restrict  */)((char *)(name)), 45, (FILE */* __restrict  */)stdin);
    }
#line 443
    if (tmp___2) {
      {
#line 444
      tmp = strchr((char const   *)(name), '\n');
#line 444
      here = (unsigned char *)tmp;
      }
#line 444
      if (here) {
#line 445
        *here = (unsigned char)0;
      }
      {
#line 446
      tmp___0 = strrchr((char const   *)(name), 0);
#line 446
      walk = (unsigned char *)tmp___0;
      }
      {
#line 446
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 446
        if ((unsigned long )walk >= (unsigned long )(name)) {
#line 446
          if (! ((int )*walk == 32)) {
#line 446
            if (! ((int )*walk == 9)) {
#line 446
              goto while_break___0;
            }
          }
        } else {
#line 446
          goto while_break___0;
        }
#line 446
        walk --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 448
      *(walk + 1) = (unsigned char)0;
#line 449
      walk = name;
      {
#line 449
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 449
        if (! ((int )*walk == 32)) {
#line 449
          if (! ((int )*walk == 9)) {
#line 449
            goto while_break___1;
          }
        }
#line 449
        walk ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 450
      tmp___1 = file_cvt(walk, file->dir_ent.name);
      }
#line 450
      if (tmp___1) {
#line 452
        if ((int )file->dir_ent.lcase & 32) {
          {
#line 456
          file->dir_ent.lcase = (__u8 )((int )file->dir_ent.lcase & -33);
#line 458
          file->dir_ent.attr = (__u8 )((int )file->dir_ent.attr & -25);
#line 459
          fs_write(file->offset, 13, (void *)(file->dir_ent.name));
          }
        } else {
          {
#line 463
          fs_write(file->offset, 11, (void *)(file->dir_ent.name));
          }
        }
#line 465
        if (file->lfn) {
          {
#line 466
          lfn_fix_checksum(file->lfn_offset, file->offset, (char const   *)(file->dir_ent.name));
          }
        }
#line 468
        return;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int handle_dot___0(DOS_FS *fs , DOS_FILE *file , int dots ) 
{ 
  char *name ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 478
  tmp___0 = strncmp((char const   *)(file->dir_ent.name), ".          ", (size_t )11);
  }
#line 478
  if (tmp___0) {
#line 478
    name = (char *)"..";
  } else {
#line 478
    name = (char *)".";
  }
#line 481
  if (! ((int )file->dir_ent.attr & 16)) {
    {
#line 482
    tmp___1 = path_name___0(file);
#line 482
    printf((char const   */* __restrict  */)"%s\n  Is a non-directory.\n", tmp___1);
    }
#line 483
    if (interactive) {
      {
#line 484
      printf((char const   */* __restrict  */)"1) Drop it\n2) Auto-rename\n3) Rename\n4) Convert to directory\n");
      }
    } else {
      {
#line 487
      printf((char const   */* __restrict  */)"  Auto-renaming it.\n");
      }
    }
#line 488
    if (interactive) {
      {
#line 488
      tmp___2 = get_key((char *)"1234", (char *)"?");
#line 488
      tmp___3 = (int )tmp___2;
      }
    } else {
#line 488
      tmp___3 = '2';
    }
    {
#line 489
    if (tmp___3 == 49) {
#line 489
      goto case_49;
    }
#line 492
    if (tmp___3 == 50) {
#line 492
      goto case_50;
    }
#line 496
    if (tmp___3 == 51) {
#line 496
      goto case_51;
    }
#line 499
    if (tmp___3 == 52) {
#line 499
      goto case_52;
    }
#line 488
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 490
    drop_file___0(fs, file);
    }
#line 491
    return (1);
    case_50: /* CIL Label */ 
    {
#line 493
    auto_rename___0(file);
#line 494
    tmp___4 = file_name(file->dir_ent.name);
#line 494
    printf((char const   */* __restrict  */)"  Renamed to %s\n", tmp___4);
    }
#line 495
    return (0);
    case_51: /* CIL Label */ 
    {
#line 497
    rename_file___0(file);
    }
#line 498
    return (0);
    case_52: /* CIL Label */ 
    {
#line 500
    while (1) {
      while_continue: /* CIL Label */ ;
#line 500
      if (file->offset) {
        {
#line 500
        file->dir_ent.size = (__u32 )0;
#line 500
        fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->size)),
                 (int )sizeof(file->dir_ent.size), (void *)(& file->dir_ent.size));
        }
      }
#line 500
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 501
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 501
      if (file->offset) {
        {
#line 501
        file->dir_ent.attr = (__u8 )((int )file->dir_ent.attr | 16);
#line 501
        fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->attr)),
                 (int )sizeof(file->dir_ent.attr), (void *)(& file->dir_ent.attr));
        }
      }
#line 501
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 502
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 505
  if (! dots) {
    {
#line 506
    printf((char const   */* __restrict  */)"Root contains directory \"%s\". Dropping it.\n",
           name);
#line 507
    drop_file___0(fs, file);
    }
#line 508
    return (1);
  }
#line 510
  return (0);
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int check_file___0(DOS_FS *fs , DOS_FILE *file ) 
{ 
  DOS_FILE *owner ;
  int restart ;
  uint32_t expect ;
  uint32_t curr ;
  uint32_t this ;
  uint32_t clusters ;
  uint32_t prev ;
  uint32_t walk ;
  uint32_t clusters2 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t __v ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  uint32_t __v___0 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  uint32_t __v___1 ;
  int tmp___14 ;
  int tmp___16 ;
  int tmp___17 ;
  FAT_ENTRY curEntry ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  uint32_t __v___2 ;
  int tmp___20 ;
  char *tmp___21 ;
  int do_trunc ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char const   *tmp___25 ;
  int tmp___26 ;
  uint32_t __v___3 ;
  int tmp___27 ;
  uint32_t __v___4 ;
  char tmp___28 ;
  char *tmp___29 ;

  {
#line 519
  if ((int )file->dir_ent.attr & 16) {
#line 520
    if (file->dir_ent.size) {
      {
#line 521
      tmp = path_name___0(file);
#line 521
      printf((char const   */* __restrict  */)"%s\n  Directory has non-zero size. Fixing it.\n",
             tmp);
      }
      {
#line 523
      while (1) {
        while_continue: /* CIL Label */ ;
#line 523
        if (file->offset) {
          {
#line 523
          file->dir_ent.size = (__u32 )0;
#line 523
          fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->size)),
                   (int )sizeof(file->dir_ent.size), (void *)(& file->dir_ent.size));
          }
        }
#line 523
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 525
    if (file->parent) {
      {
#line 525
      tmp___4 = strncmp((char const   *)(file->dir_ent.name), ".          ", (size_t )11);
      }
#line 525
      if (! tmp___4) {
#line 528
        if (fs->fat_bits == 32U) {
#line 528
          tmp___0 = (int )(file->parent)->dir_ent.starthi << 16;
        } else {
#line 528
          tmp___0 = 0;
        }
#line 528
        expect = (uint32_t )(file->parent)->dir_ent.start | (unsigned int )tmp___0;
#line 529
        if (fs->fat_bits == 32U) {
#line 529
          tmp___3 = (int )file->dir_ent.starthi << 16;
        } else {
#line 529
          tmp___3 = 0;
        }
#line 529
        if (((uint32_t )file->dir_ent.start | (unsigned int )tmp___3) != expect) {
#line 530
          if (fs->fat_bits == 32U) {
#line 530
            tmp___1 = (int )file->dir_ent.starthi << 16;
          } else {
#line 530
            tmp___1 = 0;
          }
          {
#line 530
          tmp___2 = path_name___0(file);
#line 530
          printf((char const   */* __restrict  */)"%s\n  Start (%lu) does not point to parent (%lu)\n",
                 tmp___2, (unsigned long )((uint32_t )file->dir_ent.start | (unsigned int )tmp___1),
                 (long )expect);
          }
          {
#line 532
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 532
            __v = expect;
#line 532
            if (! file->offset) {
#line 532
              if (! __v) {
                {
#line 532
                die((char *)"Oops, deleting FAT32 root dir!");
                }
              }
              {
#line 532
              fs->root_cluster = __v;
#line 532
              file->dir_ent.start = (__u16 )(__v & 65535U);
#line 532
              file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 532
              __v = __v;
#line 532
              fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                       (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v));
              }
            } else {
              {
#line 532
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 532
                if (file->offset) {
                  {
#line 532
                  file->dir_ent.start = (__u16 )(__v & 65535U);
#line 532
                  fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                           (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
                  }
                }
#line 532
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 532
              if (fs->fat_bits == 32U) {
                {
#line 532
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 532
                  if (file->offset) {
                    {
#line 532
                    file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 532
                    fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                             (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
                    }
                  }
#line 532
                  goto while_break___2;
                }
                while_break___2: /* CIL Label */ ;
                }
              }
            }
#line 532
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 534
        return (0);
      }
    }
#line 536
    if (file->parent) {
      {
#line 536
      tmp___9 = strncmp((char const   *)(file->dir_ent.name), "..         ", (size_t )11);
      }
#line 536
      if (! tmp___9) {
#line 539
        if ((file->parent)->parent) {
#line 539
          if (fs->fat_bits == 32U) {
#line 539
            tmp___5 = (int )((file->parent)->parent)->dir_ent.starthi << 16;
          } else {
#line 539
            tmp___5 = 0;
          }
#line 539
          expect = (uint32_t )((file->parent)->parent)->dir_ent.start | (unsigned int )tmp___5;
        } else {
#line 539
          expect = (uint32_t )0;
        }
#line 541
        if (fs->root_cluster) {
#line 541
          if (expect == fs->root_cluster) {
#line 542
            expect = (uint32_t )0;
          }
        }
#line 543
        if (fs->fat_bits == 32U) {
#line 543
          tmp___8 = (int )file->dir_ent.starthi << 16;
        } else {
#line 543
          tmp___8 = 0;
        }
#line 543
        if (((uint32_t )file->dir_ent.start | (unsigned int )tmp___8) != expect) {
#line 544
          if (fs->fat_bits == 32U) {
#line 544
            tmp___6 = (int )file->dir_ent.starthi << 16;
          } else {
#line 544
            tmp___6 = 0;
          }
          {
#line 544
          tmp___7 = path_name___0(file);
#line 544
          printf((char const   */* __restrict  */)"%s\n  Start (%lu) does not point to .. (%lu)\n",
                 tmp___7, (unsigned long )((uint32_t )file->dir_ent.start | (unsigned int )tmp___6),
                 (unsigned long )expect);
          }
          {
#line 546
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 546
            __v___0 = expect;
#line 546
            if (! file->offset) {
#line 546
              if (! __v___0) {
                {
#line 546
                die((char *)"Oops, deleting FAT32 root dir!");
                }
              }
              {
#line 546
              fs->root_cluster = __v___0;
#line 546
              file->dir_ent.start = (__u16 )(__v___0 & 65535U);
#line 546
              file->dir_ent.starthi = (__u16 )(__v___0 >> 16);
#line 546
              __v___0 = __v___0;
#line 546
              fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                       (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v___0));
              }
            } else {
              {
#line 546
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 546
                if (file->offset) {
                  {
#line 546
                  file->dir_ent.start = (__u16 )(__v___0 & 65535U);
#line 546
                  fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                           (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
                  }
                }
#line 546
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 546
              if (fs->fat_bits == 32U) {
                {
#line 546
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 546
                  if (file->offset) {
                    {
#line 546
                    file->dir_ent.starthi = (__u16 )(__v___0 >> 16);
#line 546
                    fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                             (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
                    }
                  }
#line 546
                  goto while_break___5;
                }
                while_break___5: /* CIL Label */ ;
                }
              }
            }
#line 546
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 548
        return (0);
      }
    }
#line 550
    if (fs->fat_bits == 32U) {
#line 550
      tmp___11 = (int )file->dir_ent.starthi << 16;
    } else {
#line 550
      tmp___11 = 0;
    }
#line 550
    if (((uint32_t )file->dir_ent.start | (unsigned int )tmp___11) == 0U) {
      {
#line 551
      tmp___10 = path_name___0(file);
#line 551
      printf((char const   */* __restrict  */)"%s\n Start does point to root directory. Deleting dir. \n",
             tmp___10);
      }
      {
#line 553
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 553
        if (file->offset) {
          {
#line 553
          file->dir_ent.name[0] = (__u8 )229;
#line 553
          fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->name[0])),
                   (int )sizeof(file->dir_ent.name[0]), (void *)(& file->dir_ent.name[0]));
          }
        }
#line 553
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 554
      return (0);
    }
  }
#line 557
  if (fs->fat_bits == 32U) {
#line 557
    tmp___14 = (int )file->dir_ent.starthi << 16;
  } else {
#line 557
    tmp___14 = 0;
  }
#line 557
  if (((uint32_t )file->dir_ent.start | (unsigned int )tmp___14) >= fs->clusters + 2U) {
#line 558
    if (fs->fat_bits == 32U) {
#line 558
      tmp___12 = (int )file->dir_ent.starthi << 16;
    } else {
#line 558
      tmp___12 = 0;
    }
    {
#line 558
    tmp___13 = path_name___0(file);
#line 558
    printf((char const   */* __restrict  */)"%s\n  Start cluster beyond limit (%lu > %lu). Truncating file.\n",
           tmp___13, (unsigned long )((uint32_t )file->dir_ent.start | (unsigned int )tmp___12),
           (unsigned long )(fs->clusters + 1U));
    }
#line 561
    if (! file->offset) {
      {
#line 562
      die((char *)"Bad FAT32 root directory! (bad start cluster)\n");
      }
    }
    {
#line 563
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 563
      __v___1 = (uint32_t )0;
#line 563
      if (! file->offset) {
#line 563
        if (! __v___1) {
          {
#line 563
          die((char *)"Oops, deleting FAT32 root dir!");
          }
        }
        {
#line 563
        fs->root_cluster = __v___1;
#line 563
        file->dir_ent.start = (__u16 )(__v___1 & 65535U);
#line 563
        file->dir_ent.starthi = (__u16 )(__v___1 >> 16);
#line 563
        __v___1 = __v___1;
#line 563
        fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                 (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v___1));
        }
      } else {
        {
#line 563
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 563
          if (file->offset) {
            {
#line 563
            file->dir_ent.start = (__u16 )(__v___1 & 65535U);
#line 563
            fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                     (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
            }
          }
#line 563
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 563
        if (fs->fat_bits == 32U) {
          {
#line 563
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 563
            if (file->offset) {
              {
#line 563
              file->dir_ent.starthi = (__u16 )(__v___1 >> 16);
#line 563
              fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                       (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
              }
            }
#line 563
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
#line 563
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 565
  prev = (uint32_t )0;
#line 565
  clusters = prev;
#line 566
  if (fs->fat_bits == 32U) {
#line 566
    tmp___17 = (int )file->dir_ent.starthi << 16;
  } else {
#line 566
    tmp___17 = 0;
  }
#line 566
  if ((uint32_t )file->dir_ent.start | (unsigned int )tmp___17) {
#line 566
    if (fs->fat_bits == 32U) {
#line 566
      tmp___16 = (int )file->dir_ent.starthi << 16;
    } else {
#line 566
      tmp___16 = 0;
    }
#line 566
    curr = (uint32_t )file->dir_ent.start | (unsigned int )tmp___16;
  } else {
#line 566
    curr = (uint32_t )-1;
  }
  {
#line 566
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 566
    if (! (curr != 4294967295U)) {
#line 566
      goto while_break___10;
    }
    {
#line 569
    get_fat(& curEntry, (void *)fs->fat, curr, fs);
    }
#line 571
    if (! curEntry.value) {
#line 571
      goto _L;
    } else {
      {
#line 571
      tmp___20 = bad_cluster(fs, curr);
      }
#line 571
      if (tmp___20) {
        _L: /* CIL Label */ 
#line 572
        if (curEntry.value) {
#line 572
          tmp___18 = "bad";
        } else {
#line 572
          tmp___18 = "free";
        }
        {
#line 572
        tmp___19 = path_name___0(file);
#line 572
        printf((char const   */* __restrict  */)"%s\n  Contains a %s cluster (%lu). Assuming EOF.\n",
               tmp___19, tmp___18, (unsigned long )curr);
        }
#line 574
        if (prev) {
          {
#line 575
          set_fat(fs, prev, -1);
          }
        } else
#line 576
        if (! file->offset) {
          {
#line 577
          die((char *)"FAT32 root dir starts with a bad cluster!");
          }
        } else {
          {
#line 579
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 579
            __v___2 = (uint32_t )0;
#line 579
            if (! file->offset) {
#line 579
              if (! __v___2) {
                {
#line 579
                die((char *)"Oops, deleting FAT32 root dir!");
                }
              }
              {
#line 579
              fs->root_cluster = __v___2;
#line 579
              file->dir_ent.start = (__u16 )(__v___2 & 65535U);
#line 579
              file->dir_ent.starthi = (__u16 )(__v___2 >> 16);
#line 579
              __v___2 = __v___2;
#line 579
              fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                       (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v___2));
              }
            } else {
              {
#line 579
              while (1) {
                while_continue___12: /* CIL Label */ ;
#line 579
                if (file->offset) {
                  {
#line 579
                  file->dir_ent.start = (__u16 )(__v___2 & 65535U);
#line 579
                  fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                           (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
                  }
                }
#line 579
                goto while_break___12;
              }
              while_break___12: /* CIL Label */ ;
              }
#line 579
              if (fs->fat_bits == 32U) {
                {
#line 579
                while (1) {
                  while_continue___13: /* CIL Label */ ;
#line 579
                  if (file->offset) {
                    {
#line 579
                    file->dir_ent.starthi = (__u16 )(__v___2 >> 16);
#line 579
                    fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                             (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
                    }
                  }
#line 579
                  goto while_break___13;
                }
                while_break___13: /* CIL Label */ ;
                }
              }
            }
#line 579
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
        }
#line 580
        goto while_break___10;
      }
    }
#line 582
    if (! ((int )file->dir_ent.attr & 16)) {
#line 582
      if ((uint64_t )file->dir_ent.size <= (uint64_t )clusters * (uint64_t )fs->cluster_size) {
        {
#line 584
        tmp___21 = path_name___0(file);
#line 584
        printf((char const   */* __restrict  */)"%s\n  File size is %u bytes, cluster chain length is > %lu bytes.\n  Truncating file to %u bytes.\n",
               tmp___21, file->dir_ent.size, (uint64_t )clusters * (uint64_t )fs->cluster_size,
               file->dir_ent.size);
#line 590
        truncate_file___0(fs, file, clusters);
        }
#line 591
        goto while_break___10;
      }
    }
    {
#line 593
    owner = get_owner(fs, curr);
    }
#line 593
    if (owner) {
      {
#line 594
      do_trunc = 0;
#line 595
      tmp___22 = path_name___0(owner);
#line 595
      printf((char const   */* __restrict  */)"%s  and\n", tmp___22);
#line 596
      tmp___23 = path_name___0(file);
#line 596
      printf((char const   */* __restrict  */)"%s\n  share clusters.\n", tmp___23);
#line 597
      clusters2 = (uint32_t )0;
      }
#line 598
      if (fs->fat_bits == 32U) {
#line 598
        tmp___24 = (int )owner->dir_ent.starthi << 16;
      } else {
#line 598
        tmp___24 = 0;
      }
#line 598
      walk = (uint32_t )owner->dir_ent.start | (unsigned int )tmp___24;
      {
#line 598
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 598
        if (walk > 0U) {
#line 598
          if (! (walk != 4294967295U)) {
#line 598
            goto while_break___14;
          }
        } else {
#line 598
          goto while_break___14;
        }
#line 600
        if (walk == curr) {
#line 601
          goto while_break___14;
        } else {
#line 603
          clusters2 ++;
        }
        {
#line 598
        walk = next_cluster(fs, walk);
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 604
      restart = (int )file->dir_ent.attr & 16;
#line 605
      if (! owner->offset) {
        {
#line 606
        printf((char const   */* __restrict  */)"  Truncating second to %llu bytes because first is FAT32 root dir.\n",
               (unsigned long long )clusters2 * (unsigned long long )fs->cluster_size);
#line 609
        do_trunc = 2;
        }
      } else
#line 610
      if (! file->offset) {
        {
#line 611
        printf((char const   */* __restrict  */)"  Truncating first to %llu bytes because second is FAT32 root dir.\n",
               (unsigned long long )clusters * (unsigned long long )fs->cluster_size);
#line 614
        do_trunc = 1;
        }
      } else
#line 615
      if (interactive) {
#line 616
        if (restart) {
#line 616
          tmp___25 = " and restart";
        } else {
#line 616
          tmp___25 = "";
        }
        {
#line 616
        printf((char const   */* __restrict  */)"1) Truncate first to %llu bytes%s\n2) Truncate second to %llu bytes\n",
               (unsigned long long )clusters * (unsigned long long )fs->cluster_size,
               tmp___25, (unsigned long long )clusters2 * (unsigned long long )fs->cluster_size);
        }
      } else {
        {
#line 622
        printf((char const   */* __restrict  */)"  Truncating second to %llu bytes.\n",
               (unsigned long long )clusters2 * (unsigned long long )fs->cluster_size);
        }
      }
#line 624
      if (do_trunc != 2) {
#line 624
        if (do_trunc == 1) {
#line 624
          goto _L___1;
        } else
#line 624
        if (interactive) {
          {
#line 624
          tmp___28 = get_key((char *)"12", (char *)"?");
          }
#line 624
          if ((int )tmp___28 == 49) {
            _L___1: /* CIL Label */ 
#line 627
            prev = (uint32_t )0;
#line 628
            clusters = (uint32_t )0;
#line 629
            if (fs->fat_bits == 32U) {
#line 629
              tmp___26 = (int )owner->dir_ent.starthi << 16;
            } else {
#line 629
              tmp___26 = 0;
            }
#line 629
            this = (uint32_t )owner->dir_ent.start | (unsigned int )tmp___26;
            {
#line 629
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 629
              if (this > 0U) {
#line 629
                if (! (this != 4294967295U)) {
#line 629
                  goto while_break___15;
                }
              } else {
#line 629
                goto while_break___15;
              }
#line 631
              if (this == curr) {
#line 632
                if (prev) {
                  {
#line 633
                  set_fat(fs, prev, -1);
                  }
                } else {
                  {
#line 635
                  while (1) {
                    while_continue___16: /* CIL Label */ ;
#line 635
                    __v___3 = (uint32_t )0;
#line 635
                    if (! owner->offset) {
#line 635
                      if (! __v___3) {
                        {
#line 635
                        die((char *)"Oops, deleting FAT32 root dir!");
                        }
                      }
                      {
#line 635
                      fs->root_cluster = __v___3;
#line 635
                      owner->dir_ent.start = (__u16 )(__v___3 & 65535U);
#line 635
                      owner->dir_ent.starthi = (__u16 )(__v___3 >> 16);
#line 635
                      __v___3 = __v___3;
#line 635
                      fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                               (int )sizeof(((struct boot_sector *)0)->root_cluster),
                               (void *)(& __v___3));
                      }
                    } else {
                      {
#line 635
                      while (1) {
                        while_continue___17: /* CIL Label */ ;
#line 635
                        if (owner->offset) {
                          {
#line 635
                          owner->dir_ent.start = (__u16 )(__v___3 & 65535U);
#line 635
                          fs_write((loff_t )((unsigned long )owner->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                                   (int )sizeof(owner->dir_ent.start), (void *)(& owner->dir_ent.start));
                          }
                        }
#line 635
                        goto while_break___17;
                      }
                      while_break___17: /* CIL Label */ ;
                      }
#line 635
                      if (fs->fat_bits == 32U) {
                        {
#line 635
                        while (1) {
                          while_continue___18: /* CIL Label */ ;
#line 635
                          if (owner->offset) {
                            {
#line 635
                            owner->dir_ent.starthi = (__u16 )(__v___3 >> 16);
#line 635
                            fs_write((loff_t )((unsigned long )owner->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                                     (int )sizeof(owner->dir_ent.starthi), (void *)(& owner->dir_ent.starthi));
                            }
                          }
#line 635
                          goto while_break___18;
                        }
                        while_break___18: /* CIL Label */ ;
                        }
                      }
                    }
#line 635
                    goto while_break___16;
                  }
                  while_break___16: /* CIL Label */ ;
                  }
                }
                {
#line 636
                while (1) {
                  while_continue___19: /* CIL Label */ ;
#line 636
                  if (owner->offset) {
                    {
#line 636
                    owner->dir_ent.size = (__u32 )((uint64_t )clusters * (uint64_t )fs->cluster_size);
#line 636
                    fs_write((loff_t )((unsigned long )owner->offset + (unsigned long )(& ((DIR_ENT *)0)->size)),
                             (int )sizeof(owner->dir_ent.size), (void *)(& owner->dir_ent.size));
                    }
                  }
#line 636
                  goto while_break___19;
                }
                while_break___19: /* CIL Label */ ;
                }
#line 639
                if (restart) {
#line 640
                  return (1);
                }
                {
#line 641
                while (1) {
                  while_continue___20: /* CIL Label */ ;
#line 641
                  if (this > 0U) {
#line 641
                    if (! (this != 4294967295U)) {
#line 641
                      goto while_break___20;
                    }
                  } else {
#line 641
                    goto while_break___20;
                  }
                  {
#line 642
                  set_owner(fs, this, (DOS_FILE *)((void *)0));
#line 643
                  this = next_cluster(fs, this);
                  }
                }
                while_break___20: /* CIL Label */ ;
                }
#line 645
                this = curr;
#line 646
                goto while_break___15;
              }
              {
#line 648
              clusters ++;
#line 649
              prev = this;
#line 629
              this = next_cluster(fs, this);
              }
            }
            while_break___15: /* CIL Label */ ;
            }
#line 651
            if (this != curr) {
#line 652
              if (fs->fat_bits == 32U) {
#line 652
                tmp___27 = (int )owner->dir_ent.starthi << 16;
              } else {
#line 652
                tmp___27 = 0;
              }
              {
#line 652
              die((char *)"Internal error: didn\'t find cluster %d in chain starting at %d",
                  curr, (uint32_t )owner->dir_ent.start | (unsigned int )tmp___27);
              }
            }
          } else {
#line 624
            goto _L___0;
          }
        } else {
#line 624
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 655
        if (prev) {
          {
#line 656
          set_fat(fs, prev, -1);
          }
        } else {
          {
#line 658
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 658
            __v___4 = (uint32_t )0;
#line 658
            if (! file->offset) {
#line 658
              if (! __v___4) {
                {
#line 658
                die((char *)"Oops, deleting FAT32 root dir!");
                }
              }
              {
#line 658
              fs->root_cluster = __v___4;
#line 658
              file->dir_ent.start = (__u16 )(__v___4 & 65535U);
#line 658
              file->dir_ent.starthi = (__u16 )(__v___4 >> 16);
#line 658
              __v___4 = __v___4;
#line 658
              fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                       (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v___4));
              }
            } else {
              {
#line 658
              while (1) {
                while_continue___22: /* CIL Label */ ;
#line 658
                if (file->offset) {
                  {
#line 658
                  file->dir_ent.start = (__u16 )(__v___4 & 65535U);
#line 658
                  fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                           (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
                  }
                }
#line 658
                goto while_break___22;
              }
              while_break___22: /* CIL Label */ ;
              }
#line 658
              if (fs->fat_bits == 32U) {
                {
#line 658
                while (1) {
                  while_continue___23: /* CIL Label */ ;
#line 658
                  if (file->offset) {
                    {
#line 658
                    file->dir_ent.starthi = (__u16 )(__v___4 >> 16);
#line 658
                    fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                             (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
                    }
                  }
#line 658
                  goto while_break___23;
                }
                while_break___23: /* CIL Label */ ;
                }
              }
            }
#line 658
            goto while_break___21;
          }
          while_break___21: /* CIL Label */ ;
          }
        }
#line 659
        goto while_break___10;
      }
    }
    {
#line 662
    set_owner(fs, curr, file);
#line 663
    clusters ++;
#line 664
    prev = curr;
#line 566
    curr = next_cluster(fs, curr);
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 666
  if (! ((int )file->dir_ent.attr & 16)) {
#line 666
    if ((uint64_t )file->dir_ent.size > (uint64_t )clusters * (uint64_t )fs->cluster_size) {
      {
#line 668
      tmp___29 = path_name___0(file);
#line 668
      printf((char const   */* __restrict  */)"%s\n  File size is %u bytes, cluster chain length is %llu bytes.\n  Truncating file to %llu bytes.\n",
             tmp___29, file->dir_ent.size, (unsigned long long )clusters * (unsigned long long )fs->cluster_size,
             (unsigned long long )clusters * (unsigned long long )fs->cluster_size);
      }
      {
#line 674
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 674
        if (file->offset) {
          {
#line 674
          file->dir_ent.size = (__u32 )((uint64_t )clusters * (uint64_t )fs->cluster_size);
#line 674
          fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->size)),
                   (int )sizeof(file->dir_ent.size), (void *)(& file->dir_ent.size));
          }
        }
#line 674
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
    }
  }
#line 677
  return (0);
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int check_files___0(DOS_FS *fs , DOS_FILE *start ) 
{ 
  int tmp ;

  {
  {
#line 682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 682
    if (! start) {
#line 682
      goto while_break;
    }
    {
#line 683
    tmp = check_file___0(fs, start);
    }
#line 683
    if (tmp) {
#line 684
      return (1);
    }
#line 685
    start = start->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 687
  return (0);
}
}
#line 690 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int check_dir___0(DOS_FS *fs , DOS_FILE **root___1 , int dots ) 
{ 
  DOS_FILE *parent ;
  DOS_FILE **walk ;
  DOS_FILE **scan ;
  int dot ;
  int dotdot ;
  int skip ;
  int redo ;
  int good ;
  int bad ;
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;

  {
#line 696
  if (! *root___1) {
#line 697
    return (0);
  }
#line 698
  parent = (*root___1)->parent;
#line 699
  bad = 0;
#line 699
  good = bad;
#line 700
  walk = root___1;
  {
#line 700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 700
    if (! *walk) {
#line 700
      goto while_break;
    }
    {
#line 701
    tmp = bad_name___0(*walk);
    }
#line 701
    if (tmp) {
#line 702
      bad ++;
    } else {
#line 704
      good ++;
    }
#line 700
    walk = & (*walk)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 705
  if (*root___1) {
#line 705
    if (parent) {
#line 705
      if (good + bad > 4) {
#line 705
        if (bad > good / 2) {
          {
#line 706
          tmp___0 = path_name___0(parent);
#line 706
          printf((char const   */* __restrict  */)"%s\n  Has a large number of bad entries. (%d/%d)\n",
                 tmp___0, bad, good + bad);
          }
#line 708
          if (! dots) {
            {
#line 709
            printf((char const   */* __restrict  */)"  Not dropping root directory.\n");
            }
          } else
#line 710
          if (! interactive) {
            {
#line 711
            printf((char const   */* __restrict  */)"  Not dropping it in auto-mode.\n");
            }
          } else {
            {
#line 712
            tmp___1 = get_key((char *)"yn", (char *)"Drop directory ? (y/n)");
            }
#line 712
            if ((int )tmp___1 == 121) {
              {
#line 713
              truncate_file___0(fs, parent, (uint32_t )0);
              }
              {
#line 714
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 714
                if (parent->offset) {
                  {
#line 714
                  parent->dir_ent.name[0] = (__u8 )229;
#line 714
                  fs_write((loff_t )((unsigned long )parent->offset + (unsigned long )(& ((DIR_ENT *)0)->name[0])),
                           (int )sizeof(parent->dir_ent.name[0]), (void *)(& parent->dir_ent.name[0]));
                  }
                }
#line 714
                goto while_break___0;
              }
              while_break___0: /* CIL Label */ ;
              }
#line 716
              return (1);
            }
          }
        }
      }
    }
  }
#line 719
  redo = 0;
#line 719
  dotdot = redo;
#line 719
  dot = dotdot;
#line 720
  walk = root___1;
  {
#line 721
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 721
    if (! *walk) {
#line 721
      goto while_break___1;
    }
    {
#line 722
    tmp___4 = strncmp((char const   *)((*walk)->dir_ent.name), ".          ", (size_t )11);
    }
#line 722
    if (tmp___4) {
      {
#line 722
      tmp___5 = strncmp((char const   *)((*walk)->dir_ent.name), "..         ", (size_t )11);
      }
#line 722
      if (! tmp___5) {
        _L: /* CIL Label */ 
        {
#line 726
        tmp___2 = handle_dot___0(fs, *walk, dots);
        }
#line 726
        if (tmp___2) {
#line 727
          *walk = (*walk)->next;
#line 728
          goto while_continue___1;
        }
        {
#line 730
        tmp___3 = strncmp((char const   *)((*walk)->dir_ent.name), ".          ",
                          (size_t )11);
        }
#line 730
        if (tmp___3) {
#line 734
          dotdot ++;
        } else {
#line 732
          dot ++;
        }
      }
    } else {
#line 722
      goto _L;
    }
#line 736
    if (! ((int )(*walk)->dir_ent.attr & 8)) {
      {
#line 736
      tmp___11 = bad_name___0(*walk);
      }
#line 736
      if (tmp___11) {
        {
#line 737
        tmp___6 = path_name___0(*walk);
#line 737
        puts((char const   *)tmp___6);
#line 738
        tmp___7 = file_name((*walk)->dir_ent.name);
#line 738
        printf((char const   */* __restrict  */)"  Bad short file name (%s).\n", tmp___7);
        }
#line 740
        if (interactive) {
          {
#line 741
          printf((char const   */* __restrict  */)"1) Drop file\n2) Rename file\n3) Auto-rename\n4) Keep it\n");
          }
        } else {
          {
#line 744
          printf((char const   */* __restrict  */)"  Auto-renaming it.\n");
          }
        }
#line 745
        if (interactive) {
          {
#line 745
          tmp___8 = get_key((char *)"1234", (char *)"?");
#line 745
          tmp___9 = (int )tmp___8;
          }
        } else {
#line 745
          tmp___9 = '3';
        }
        {
#line 746
        if (tmp___9 == 49) {
#line 746
          goto case_49;
        }
#line 750
        if (tmp___9 == 50) {
#line 750
          goto case_50;
        }
#line 754
        if (tmp___9 == 51) {
#line 754
          goto case_51;
        }
#line 758
        if (tmp___9 == 52) {
#line 758
          goto case_52;
        }
#line 745
        goto switch_break;
        case_49: /* CIL Label */ 
        {
#line 747
        drop_file___0(fs, *walk);
#line 748
        walk = & (*walk)->next;
        }
#line 749
        goto while_continue___1;
        case_50: /* CIL Label */ 
        {
#line 751
        rename_file___0(*walk);
#line 752
        redo = 1;
        }
#line 753
        goto switch_break;
        case_51: /* CIL Label */ 
        {
#line 755
        auto_rename___0(*walk);
#line 756
        tmp___10 = file_name((*walk)->dir_ent.name);
#line 756
        printf((char const   */* __restrict  */)"  Renamed to %s\n", tmp___10);
        }
#line 757
        goto switch_break;
        case_52: /* CIL Label */ 
#line 759
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 763
    if (! ((int )(*walk)->dir_ent.attr & 8)) {
#line 764
      scan = & (*walk)->next;
#line 765
      skip = 0;
      {
#line 766
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 766
        if (*scan) {
#line 766
          if (! (! skip)) {
#line 766
            goto while_break___2;
          }
        } else {
#line 766
          goto while_break___2;
        }
#line 767
        if (! ((int )(*scan)->dir_ent.attr & 8)) {
          {
#line 767
          tmp___21 = memcmp((void const   *)((*walk)->dir_ent.name), (void const   *)((*scan)->dir_ent.name),
                            (size_t )11);
          }
#line 767
          if (! tmp___21) {
            {
#line 770
            tmp___12 = file_stat___0(*walk);
#line 770
            tmp___13 = path_name___0(*walk);
#line 770
            printf((char const   */* __restrict  */)"%s\n  Duplicate directory entry.\n  First  %s\n",
                   tmp___13, tmp___12);
#line 772
            tmp___14 = file_stat___0(*scan);
#line 772
            printf((char const   */* __restrict  */)"  Second %s\n", tmp___14);
            }
#line 773
            if (interactive) {
              {
#line 774
              printf((char const   */* __restrict  */)"1) Drop first\n2) Drop second\n3) Rename first\n4) Rename second\n5) Auto-rename first\n6) Auto-rename second\n");
              }
            } else {
              {
#line 779
              printf((char const   */* __restrict  */)"  Auto-renaming second.\n");
              }
            }
#line 780
            if (interactive) {
              {
#line 780
              tmp___15 = get_key((char *)"123456", (char *)"?");
#line 780
              tmp___16 = (int )tmp___15;
              }
            } else {
#line 780
              tmp___16 = '6';
            }
            {
#line 781
            if (tmp___16 == 49) {
#line 781
              goto case_49___0;
            }
#line 786
            if (tmp___16 == 50) {
#line 786
              goto case_50___0;
            }
#line 790
            if (tmp___16 == 51) {
#line 790
              goto case_51___0;
            }
#line 795
            if (tmp___16 == 52) {
#line 795
              goto case_52___0;
            }
#line 800
            if (tmp___16 == 53) {
#line 800
              goto case_53;
            }
#line 805
            if (tmp___16 == 54) {
#line 805
              goto case_54;
            }
#line 780
            goto switch_break___0;
            case_49___0: /* CIL Label */ 
            {
#line 782
            drop_file___0(fs, *walk);
#line 783
            *walk = (*walk)->next;
#line 784
            skip = 1;
            }
#line 785
            goto switch_break___0;
            case_50___0: /* CIL Label */ 
            {
#line 787
            drop_file___0(fs, *scan);
#line 788
            *scan = (*scan)->next;
            }
#line 789
            goto while_continue___2;
            case_51___0: /* CIL Label */ 
            {
#line 791
            rename_file___0(*walk);
#line 792
            tmp___17 = path_name___0(*walk);
#line 792
            printf((char const   */* __restrict  */)"  Renamed to %s\n", tmp___17);
#line 793
            redo = 1;
            }
#line 794
            goto switch_break___0;
            case_52___0: /* CIL Label */ 
            {
#line 796
            rename_file___0(*scan);
#line 797
            tmp___18 = path_name___0(*walk);
#line 797
            printf((char const   */* __restrict  */)"  Renamed to %s\n", tmp___18);
#line 798
            redo = 1;
            }
#line 799
            goto switch_break___0;
            case_53: /* CIL Label */ 
            {
#line 801
            auto_rename___0(*walk);
#line 802
            tmp___19 = file_name((*walk)->dir_ent.name);
#line 802
            printf((char const   */* __restrict  */)"  Renamed to %s\n", tmp___19);
            }
#line 804
            goto switch_break___0;
            case_54: /* CIL Label */ 
            {
#line 806
            auto_rename___0(*scan);
#line 807
            tmp___20 = file_name((*scan)->dir_ent.name);
#line 807
            printf((char const   */* __restrict  */)"  Renamed to %s\n", tmp___20);
            }
#line 809
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          }
        }
#line 812
        scan = & (*scan)->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 814
      if (skip) {
#line 815
        goto while_continue___1;
      }
    }
#line 817
    if (! redo) {
#line 818
      walk = & (*walk)->next;
    } else {
#line 820
      walk = root___1;
#line 821
      redo = 0;
#line 821
      dotdot = redo;
#line 821
      dot = dotdot;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 824
  if (dots) {
#line 824
    if (! dot) {
      {
#line 825
      tmp___22 = path_name___0(parent);
#line 825
      printf((char const   */* __restrict  */)"%s\n  \".\" is missing. Can\'t fix this yet.\n",
             tmp___22);
      }
    }
  }
#line 827
  if (dots) {
#line 827
    if (! dotdot) {
      {
#line 828
      tmp___23 = path_name___0(parent);
#line 828
      printf((char const   */* __restrict  */)"%s\n  \"..\" is missing. Can\'t fix this yet.\n",
             tmp___23);
      }
    }
  }
#line 830
  return (0);
}
}
#line 842 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void test_file___0(DOS_FS *fs , DOS_FILE *file , int read_test ) 
{ 
  DOS_FILE *owner ;
  uint32_t walk ;
  uint32_t prev ;
  uint32_t clusters ;
  uint32_t next_clu ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  uint32_t __v ;
  int tmp___2 ;
  char *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t __v___0 ;
  uint32_t tmp___5 ;
  loff_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  DOS_FILE *tmp___9 ;
  int tmp___10 ;

  {
#line 847
  clusters = (uint32_t )0;
#line 847
  prev = clusters;
#line 848
  if (fs->fat_bits == 32U) {
#line 848
    tmp = (int )file->dir_ent.starthi << 16;
  } else {
#line 848
    tmp = 0;
  }
#line 848
  walk = (uint32_t )file->dir_ent.start | (unsigned int )tmp;
  {
#line 848
  while (1) {
    while_continue: /* CIL Label */ ;
#line 848
    if (walk > 0U) {
#line 848
      if (! (walk < fs->clusters + 2U)) {
#line 848
        goto while_break;
      }
    } else {
#line 848
      goto while_break;
    }
    {
#line 850
    next_clu = next_cluster(fs, walk);
#line 856
    owner = get_owner(fs, walk);
    }
#line 856
    if (owner) {
#line 857
      if ((unsigned long )owner == (unsigned long )file) {
#line 858
        if (clusters == 1U) {
#line 858
          tmp___0 = "";
        } else {
#line 858
          tmp___0 = "s";
        }
        {
#line 858
        tmp___1 = path_name___0(file);
#line 858
        printf((char const   */* __restrict  */)"%s\n  Circular cluster chain. Truncating to %lu cluster%s.\n",
               tmp___1, (unsigned long )clusters, tmp___0);
        }
#line 861
        if (prev) {
          {
#line 862
          set_fat(fs, prev, -1);
          }
        } else
#line 863
        if (! file->offset) {
          {
#line 864
          die((char *)"Bad FAT32 root directory! (bad start cluster)\n");
          }
        } else {
          {
#line 866
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 866
            __v = (uint32_t )0;
#line 866
            if (! file->offset) {
#line 866
              if (! __v) {
                {
#line 866
                die((char *)"Oops, deleting FAT32 root dir!");
                }
              }
              {
#line 866
              fs->root_cluster = __v;
#line 866
              file->dir_ent.start = (__u16 )(__v & 65535U);
#line 866
              file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 866
              __v = __v;
#line 866
              fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                       (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v));
              }
            } else {
              {
#line 866
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 866
                if (file->offset) {
                  {
#line 866
                  file->dir_ent.start = (__u16 )(__v & 65535U);
#line 866
                  fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                           (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
                  }
                }
#line 866
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 866
              if (fs->fat_bits == 32U) {
                {
#line 866
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 866
                  if (file->offset) {
                    {
#line 866
                    file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 866
                    fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                             (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
                    }
                  }
#line 866
                  goto while_break___2;
                }
                while_break___2: /* CIL Label */ ;
                }
              }
            }
#line 866
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
#line 868
      goto while_break;
    }
    {
#line 870
    tmp___2 = bad_cluster(fs, walk);
    }
#line 870
    if (tmp___2) {
#line 871
      goto while_break;
    }
#line 872
    if (read_test) {
      {
#line 873
      tmp___6 = cluster_start(fs, walk);
#line 873
      tmp___7 = fs_test(tmp___6, (int )fs->cluster_size);
      }
#line 873
      if (tmp___7) {
#line 874
        prev = walk;
#line 875
        clusters ++;
      } else {
        {
#line 877
        tmp___3 = path_name___0(file);
#line 877
        printf((char const   */* __restrict  */)"%s\n  Cluster %lu (%lu) is unreadable. Skipping it.\n",
               tmp___3, (unsigned long )clusters, (unsigned long )walk);
        }
#line 879
        if (prev) {
          {
#line 880
          tmp___4 = next_cluster(fs, walk);
#line 880
          set_fat(fs, prev, (int32_t )tmp___4);
          }
        } else {
          {
#line 882
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 882
            tmp___5 = next_cluster(fs, walk);
#line 882
            __v___0 = tmp___5;
            }
#line 882
            if (! file->offset) {
#line 882
              if (! __v___0) {
                {
#line 882
                die((char *)"Oops, deleting FAT32 root dir!");
                }
              }
              {
#line 882
              fs->root_cluster = __v___0;
#line 882
              file->dir_ent.start = (__u16 )(__v___0 & 65535U);
#line 882
              file->dir_ent.starthi = (__u16 )(__v___0 >> 16);
#line 882
              __v___0 = __v___0;
#line 882
              fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                       (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v___0));
              }
            } else {
              {
#line 882
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 882
                if (file->offset) {
                  {
#line 882
                  file->dir_ent.start = (__u16 )(__v___0 & 65535U);
#line 882
                  fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                           (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
                  }
                }
#line 882
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 882
              if (fs->fat_bits == 32U) {
                {
#line 882
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 882
                  if (file->offset) {
                    {
#line 882
                    file->dir_ent.starthi = (__u16 )(__v___0 >> 16);
#line 882
                    fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                             (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
                    }
                  }
#line 882
                  goto while_break___5;
                }
                while_break___5: /* CIL Label */ ;
                }
              }
            }
#line 882
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        {
#line 883
        set_fat(fs, walk, -2);
        }
      }
    }
    {
#line 886
    set_owner(fs, walk, file);
#line 848
    walk = next_clu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 889
  if (fs->fat_bits == 32U) {
#line 889
    tmp___8 = (int )file->dir_ent.starthi << 16;
  } else {
#line 889
    tmp___8 = 0;
  }
#line 889
  walk = (uint32_t )file->dir_ent.start | (unsigned int )tmp___8;
  {
#line 889
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 889
    if (walk > 0U) {
#line 889
      if (! (walk < fs->clusters + 2U)) {
#line 889
        goto while_break___6;
      }
    } else {
#line 889
      goto while_break___6;
    }
    {
#line 891
    tmp___10 = bad_cluster(fs, walk);
    }
#line 891
    if (tmp___10) {
#line 892
      goto while_break___6;
    } else {
      {
#line 893
      tmp___9 = get_owner(fs, walk);
      }
#line 893
      if ((unsigned long )tmp___9 == (unsigned long )file) {
        {
#line 894
        set_owner(fs, walk, (DOS_FILE *)((void *)0));
        }
      } else {
#line 896
        goto while_break___6;
      }
    }
    {
#line 889
    walk = next_cluster(fs, walk);
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 897
  return;
}
}
#line 899 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void undelete___0(DOS_FS *fs , DOS_FILE *file ) 
{ 
  uint32_t clusters ;
  uint32_t left ;
  uint32_t prev ;
  uint32_t walk ;
  int tmp ;
  FAT_ENTRY curEntry ;
  uint32_t __v ;
  char const   *tmp___0 ;

  {
#line 903
  left = ((file->dir_ent.size + fs->cluster_size) - 1U) / fs->cluster_size;
#line 903
  clusters = left;
#line 905
  prev = (uint32_t )0;
#line 907
  if (fs->fat_bits == 32U) {
#line 907
    tmp = (int )file->dir_ent.starthi << 16;
  } else {
#line 907
    tmp = 0;
  }
#line 907
  walk = (uint32_t )file->dir_ent.start | (unsigned int )tmp;
  {
#line 909
  while (1) {
    while_continue: /* CIL Label */ ;
#line 909
    if (left) {
#line 909
      if (walk >= 2U) {
#line 909
        if (! (walk < fs->clusters + 2U)) {
#line 909
          goto while_break;
        }
      } else {
#line 909
        goto while_break;
      }
    } else {
#line 909
      goto while_break;
    }
    {
#line 912
    get_fat(& curEntry, (void *)fs->fat, walk, fs);
    }
#line 914
    if (! curEntry.value) {
#line 915
      goto while_break;
    }
#line 917
    left --;
#line 918
    if (prev) {
      {
#line 919
      set_fat(fs, prev, (int32_t )walk);
      }
    }
#line 920
    prev = walk;
#line 921
    walk ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 923
  if (prev) {
    {
#line 924
    set_fat(fs, prev, -1);
    }
  } else {
    {
#line 926
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 926
      __v = (uint32_t )0;
#line 926
      if (! file->offset) {
#line 926
        if (! __v) {
          {
#line 926
          die((char *)"Oops, deleting FAT32 root dir!");
          }
        }
        {
#line 926
        fs->root_cluster = __v;
#line 926
        file->dir_ent.start = (__u16 )(__v & 65535U);
#line 926
        file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 926
        __v = __v;
#line 926
        fs_write((loff_t )((unsigned long )(& ((struct boot_sector *)0)->root_cluster)),
                 (int )sizeof(((struct boot_sector *)0)->root_cluster), (void *)(& __v));
        }
      } else {
        {
#line 926
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 926
          if (file->offset) {
            {
#line 926
            file->dir_ent.start = (__u16 )(__v & 65535U);
#line 926
            fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->start)),
                     (int )sizeof(file->dir_ent.start), (void *)(& file->dir_ent.start));
            }
          }
#line 926
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 926
        if (fs->fat_bits == 32U) {
          {
#line 926
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 926
            if (file->offset) {
              {
#line 926
              file->dir_ent.starthi = (__u16 )(__v >> 16);
#line 926
              fs_write((loff_t )((unsigned long )file->offset + (unsigned long )(& ((DIR_ENT *)0)->starthi)),
                       (int )sizeof(file->dir_ent.starthi), (void *)(& file->dir_ent.starthi));
              }
            }
#line 926
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 926
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 927
  if (left) {
#line 928
    if (clusters == 1U) {
#line 928
      tmp___0 = "";
    } else {
#line 928
      tmp___0 = "s";
    }
    {
#line 928
    printf((char const   */* __restrict  */)"Warning: Did only undelete %lu of %lu cluster%s.\n",
           (unsigned long )clusters - (unsigned long )left, (unsigned long )clusters,
           tmp___0);
    }
  }
#line 931
  return;
}
}
#line 933 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void new_dir___0(void) 
{ 


  {
  {
#line 935
  lfn_reset();
  }
#line 936
  return;
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static void add_file___0(DOS_FS *fs , DOS_FILE ***chain , DOS_FILE *parent , loff_t offset ,
                         FDSC **cp ) 
{ 
  DOS_FILE *new ;
  DIR_ENT de ;
  FD_TYPE type ;
  void *tmp ;
  struct _dos_file *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 958
  if (offset) {
    {
#line 959
    fs_read(offset, (int )sizeof(DIR_ENT ), (void *)(& de));
    }
  } else {
    {
#line 962
    memcpy((void */* __restrict  */)(de.name), (void const   */* __restrict  */)"           ",
           (size_t )11);
#line 963
    de.attr = (__u8 )16;
#line 964
    de.date = (__u16 )0;
#line 964
    de.time = de.date;
#line 964
    de.size = (__u32 )de.time;
#line 965
    de.start = (__u16 )(fs->root_cluster & 65535U);
#line 966
    de.starthi = (__u16 )((fs->root_cluster >> 16) & 65535U);
    }
  }
  {
#line 968
  type = file_type(cp, (char *)(de.name));
  }
#line 968
  if ((unsigned int )type != 0U) {
#line 969
    if ((unsigned int )type == 2U) {
#line 969
      if ((int )de.attr & 16) {
        {
#line 970
        die((char *)"Can\'t undelete directories.");
        }
      }
    }
    {
#line 971
    file_modify(cp, (char *)(de.name));
#line 972
    fs_write(offset, 1, (void *)(& de));
    }
  }
#line 974
  if (! de.name[0]) {
    {
#line 975
    lfn_check_orphaned();
    }
#line 976
    return;
  } else
#line 974
  if ((int )de.name[0] == 229) {
    {
#line 975
    lfn_check_orphaned();
    }
#line 976
    return;
  }
#line 978
  if ((int )de.attr == 15) {
    {
#line 979
    lfn_add_slot(& de, offset);
    }
#line 980
    return;
  }
  {
#line 982
  tmp = qalloc(& mem_queue, (int )sizeof(DOS_FILE ));
#line 982
  new = (DOS_FILE *)tmp;
#line 983
  new->lfn = lfn_get(& de, & new->lfn_offset);
#line 984
  new->offset = offset;
#line 985
  memcpy((void */* __restrict  */)(& new->dir_ent), (void const   */* __restrict  */)(& de),
         sizeof(de));
#line 986
  tmp___0 = (struct _dos_file *)((void *)0);
#line 986
  new->first = tmp___0;
#line 986
  new->next = tmp___0;
#line 987
  new->parent = parent;
  }
#line 988
  if ((unsigned int )type == 2U) {
    {
#line 989
    undelete___0(fs, new);
    }
  }
#line 990
  *(*chain) = new;
#line 991
  *chain = & new->next;
#line 992
  if (list) {
    {
#line 993
    tmp___1 = path_name___0(new);
#line 993
    printf((char const   */* __restrict  */)"Checking file %s", tmp___1);
    }
#line 994
    if (new->lfn) {
      {
#line 995
      tmp___2 = file_name(new->dir_ent.name);
#line 995
      printf((char const   */* __restrict  */)" (%s)", tmp___2);
      }
    }
    {
#line 996
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 999
  if (offset) {
    {
#line 999
    tmp___3 = strncmp((char const   *)(de.name), ".          ", (size_t )11);
    }
#line 999
    if (tmp___3 != 0) {
      {
#line 999
      tmp___4 = strncmp((char const   *)(de.name), "..         ", (size_t )11);
      }
#line 999
      if (tmp___4 != 0) {
#line 1002
        n_files ++;
      }
    }
  }
  {
#line 1003
  test_file___0(fs, new, test);
  }
#line 1004
  return;
}
}
#line 1006
static int subdirs___0(DOS_FS *fs , DOS_FILE *parent , FDSC **cp ) ;
#line 1008 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int scan_dir___0(DOS_FS *fs , DOS_FILE *this , FDSC **cp ) 
{ 
  DOS_FILE **chain ;
  int i ;
  uint32_t clu_num ;
  int tmp ;
  loff_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1014
  chain = & this->first;
#line 1015
  i = 0;
#line 1016
  if (fs->fat_bits == 32U) {
#line 1016
    tmp = (int )this->dir_ent.starthi << 16;
  } else {
#line 1016
    tmp = 0;
  }
  {
#line 1016
  clu_num = (uint32_t )this->dir_ent.start | (unsigned int )tmp;
#line 1017
  new_dir___0();
  }
  {
#line 1018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1018
    if (clu_num > 0U) {
#line 1018
      if (! (clu_num != 4294967295U)) {
#line 1018
        goto while_break;
      }
    } else {
#line 1018
      goto while_break;
    }
    {
#line 1019
    tmp___0 = cluster_start(fs, clu_num);
#line 1019
    add_file___0(fs, & chain, this, tmp___0 + (loff_t )((unsigned int )i % fs->cluster_size),
                 cp);
#line 1021
    i = (int )((unsigned long )i + sizeof(DIR_ENT ));
    }
#line 1022
    if (! ((unsigned int )i % fs->cluster_size)) {
      {
#line 1023
      clu_num = next_cluster(fs, clu_num);
      }
#line 1023
      if (clu_num == 0U) {
#line 1024
        goto while_break;
      } else
#line 1023
      if (clu_num == 4294967295U) {
#line 1024
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1026
  lfn_check_orphaned();
#line 1027
  tmp___1 = check_dir___0(fs, & this->first, (int )this->offset);
  }
#line 1027
  if (tmp___1) {
#line 1028
    return (0);
  }
  {
#line 1029
  tmp___2 = check_files___0(fs, this->first);
  }
#line 1029
  if (tmp___2) {
#line 1030
    return (1);
  }
  {
#line 1031
  tmp___3 = subdirs___0(fs, this, cp);
  }
#line 1031
  return (tmp___3);
}
}
#line 1044 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/check.c"
static int subdirs___0(DOS_FS *fs , DOS_FILE *parent , FDSC **cp ) 
{ 
  DOS_FILE *walk ;
  FDSC **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1048
  if (parent) {
#line 1048
    walk = parent->first;
  } else {
#line 1048
    walk = root___0;
  }
  {
#line 1048
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1048
    if (! walk) {
#line 1048
      goto while_break;
    }
#line 1049
    if ((int )walk->dir_ent.attr & 16) {
      {
#line 1050
      tmp___1 = strncmp((char const   *)(walk->dir_ent.name), ".          ", (size_t )11);
      }
#line 1050
      if (tmp___1) {
        {
#line 1050
        tmp___2 = strncmp((char const   *)(walk->dir_ent.name), "..         ", (size_t )11);
        }
#line 1050
        if (tmp___2) {
          {
#line 1053
          tmp = file_cd(cp, (char *)(walk->dir_ent.name));
#line 1053
          tmp___0 = scan_dir___0(fs, walk, tmp);
          }
#line 1053
          if (tmp___0) {
#line 1054
            return (1);
          }
        }
      }
    }
#line 1048
    walk = walk->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1055
  return (0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
static void put_char___0(char **p , unsigned char c ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 49
  tmp = dos_char_to_printable(p, c);
  }
#line 49
  if (tmp) {
#line 50
    return;
  }
#line 51
  if ((int )c >= 32) {
#line 51
    if ((int )c < 127) {
#line 52
      tmp___0 = *p;
#line 52
      (*p) ++;
#line 52
      *tmp___0 = (char )c;
    } else {
#line 51
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 51
  if ((int )c >= 160) {
#line 52
    tmp___0 = *p;
#line 52
    (*p) ++;
#line 52
    *tmp___0 = (char )c;
  } else {
#line 54
    tmp___1 = *p;
#line 54
    (*p) ++;
#line 54
    *tmp___1 = (char )'\\';
#line 55
    tmp___2 = *p;
#line 55
    (*p) ++;
#line 55
    *tmp___2 = (char )(48 + ((int )c >> 6));
#line 56
    tmp___3 = *p;
#line 56
    (*p) ++;
#line 56
    *tmp___3 = (char )(48 + (((int )c >> 3) & 7));
#line 57
    tmp___4 = *p;
#line 57
    (*p) ++;
#line 57
    *tmp___4 = (char )(48 + ((int )c & 7));
  }
#line 59
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
static char path___2[46]  ;
#line 212 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
static FDSC **file_find___0(FDSC **dir , char *fixed ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 214
  if (! dir) {
#line 215
    return ((FDSC **)((void *)0));
  } else
#line 214
  if (! *dir) {
#line 215
    return ((FDSC **)((void *)0));
  }
#line 216
  if ((int )*((unsigned char *)fixed) == 229) {
    {
#line 217
    while (1) {
      while_continue: /* CIL Label */ ;
#line 217
      if (! *dir) {
#line 217
        goto while_break;
      }
      {
#line 218
      tmp = strncmp((char const   *)((*dir)->name + 1), (char const   *)(fixed + 1),
                    (size_t )10);
      }
#line 218
      if (! tmp) {
#line 218
        if (! (*dir)->first) {
#line 220
          return (dir);
        }
      }
#line 221
      dir = & (*dir)->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 223
    return ((FDSC **)((void *)0));
  }
  {
#line 225
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 225
    if (! *dir) {
#line 225
      goto while_break___0;
    }
    {
#line 226
    tmp___0 = strncmp((char const   *)((*dir)->name), (char const   *)fixed, (size_t )11);
    }
#line 226
    if (! tmp___0) {
#line 226
      if (! (*dir)->first) {
#line 227
        return (dir);
      }
    }
#line 228
    dir = & (*dir)->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 230
  return ((FDSC **)((void *)0));
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/file.c"
static void report_unused___0(FDSC *this ) 
{ 
  FDSC *next ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! this) {
#line 271
      goto while_break;
    }
#line 272
    next = this->next;
#line 273
    if (this->first) {
      {
#line 274
      report_unused___0(this->first);
      }
    } else
#line 275
    if ((unsigned int )this->type != 0U) {
      {
#line 276
      tmp = file_name((unsigned char *)(this->name));
      }
#line 276
      if ((unsigned int )this->type == 1U) {
#line 276
        tmp___0 = "drop";
      } else {
#line 276
        tmp___0 = "undelete";
      }
      {
#line 276
      printf((char const   */* __restrict  */)"Warning: did not %s file %s\n", tmp___0,
             tmp);
      }
    }
    {
#line 278
    free((void *)this);
#line 279
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
static CHANGE *changes___0  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
static CHANGE *last___0  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
static int fd___0  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
static int did_change___0  =    0;
#line 187 "/home/june/repo/benchmarks/collector/temp/dosfstools-3.0.26/src/io.c"
static void fs_flush___0(void) 
{ 
  CHANGE *this ;
  int size ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  loff_t tmp___4 ;

  {
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! changes___0) {
#line 192
      goto while_break;
    }
    {
#line 193
    this = changes___0;
#line 194
    changes___0 = changes___0->next;
#line 195
    tmp___4 = llseek(fd___0, this->pos, 0);
    }
#line 195
    if (tmp___4 != this->pos) {
      {
#line 196
      tmp = __errno_location();
#line 196
      tmp___0 = strerror(*tmp);
#line 196
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seek to %lld failed: %s\n  Did not write %d bytes.\n",
              (long long )this->pos, tmp___0, this->size);
      }
    } else {
      {
#line 199
      tmp___3 = write(fd___0, (void const   *)this->data, (size_t )this->size);
#line 199
      size = (int )tmp___3;
      }
#line 199
      if (size < 0) {
        {
#line 200
        tmp___1 = __errno_location();
#line 200
        tmp___2 = strerror(*tmp___1);
#line 200
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Writing %d bytes at %lld failed: %s\n",
                this->size, (long long )this->pos, tmp___2);
        }
      } else
#line 202
      if (size != this->size) {
        {
#line 203
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrote %d bytes instead of %d bytes at %lld.\n",
                size, this->size, (long long )this->pos);
        }
      }
    }
    {
#line 205
    free(this->data);
#line 206
    free((void *)this);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
