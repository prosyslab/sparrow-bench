/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 16 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.h"
typedef unsigned long *set_type;
#line 96 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.h"
typedef double myfloat[1];
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef int ddf_boolean;
#line 32 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef long ddf_rowrange;
#line 33 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef long ddf_colrange;
#line 34 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef long ddf_bigrange;
#line 36 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef set_type ddf_rowset;
#line 38 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef long *ddf_rowindex;
#line 39 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef int *ddf_rowflag;
#line 40 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef long *ddf_colindex;
#line 41 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef myfloat **ddf_Amatrix;
#line 42 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef myfloat *ddf_Arow;
#line 43 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef set_type *ddf_SetVector;
#line 44 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef myfloat **ddf_Bmatrix;
#line 45 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef set_type *ddf_Aincidence;
#line 48 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef char ddf_DataFileType[255];
#line 52
struct ddf_raydata;
#line 52 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_raydata *ddf_RayPtr;
#line 54 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
struct ddf_raydata {
   myfloat *Ray ;
   ddf_rowset ZeroSet ;
   ddf_rowrange FirstInfeasIndex ;
   ddf_boolean feasible ;
   myfloat ARay ;
   ddf_RayPtr Next ;
};
#line 63
struct ddf_adjacencydata;
#line 63 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_adjacencydata *ddf_AdjacencyPtr;
#line 64 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
struct ddf_adjacencydata {
   ddf_RayPtr Ray1 ;
   ddf_RayPtr Ray2 ;
   ddf_AdjacencyPtr Next ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_adjacencydata ddf_AdjacencyType;
#line 73
enum __anonenum_ddf_RowOrderType_26 {
    ddf_MaxIndex = 0,
    ddf_MinIndex = 1,
    ddf_MinCutoff = 2,
    ddf_MaxCutoff = 3,
    ddf_MixCutoff = 4,
    ddf_LexMin = 5,
    ddf_LexMax = 6,
    ddf_RandomRow = 7
} ;
#line 73 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef enum __anonenum_ddf_RowOrderType_26 ddf_RowOrderType;
#line 78
enum __anonenum_ddf_NumberType_27 {
    ddf_Unknown = 0,
    ddf_Real = 1,
    ddf_Rational = 2,
    ddf_Integer = 3
} ;
#line 78 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef enum __anonenum_ddf_NumberType_27 ddf_NumberType;
#line 82
enum __anonenum_ddf_RepresentationType_28 {
    ddf_Unspecified = 0,
    ddf_Inequality = 1,
    ddf_Generator = 2
} ;
#line 82 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef enum __anonenum_ddf_RepresentationType_28 ddf_RepresentationType;
#line 103
enum __anonenum_ddf_ErrorType_33 {
    ddf_DimensionTooLarge = 0,
    ddf_ImproperInputFormat = 1,
    ddf_NegativeMatrixSize = 2,
    ddf_EmptyVrepresentation = 3,
    ddf_EmptyHrepresentation = 4,
    ddf_EmptyRepresentation = 5,
    ddf_IFileNotFound = 6,
    ddf_OFileNotOpen = 7,
    ddf_NoLPObjective = 8,
    ddf_NoRealNumberSupport = 9,
    ddf_NotAvailForH = 10,
    ddf_NotAvailForV = 11,
    ddf_CannotHandleLinearity = 12,
    ddf_RowIndexOutOfRange = 13,
    ddf_ColIndexOutOfRange = 14,
    ddf_LPCycling = 15,
    ddf_NumericallyInconsistent = 16,
    ddf_NoError = 17
} ;
#line 103 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef enum __anonenum_ddf_ErrorType_33 ddf_ErrorType;
#line 113
enum __anonenum_ddf_CompStatusType_34 {
    ddf_InProgress = 0,
    ddf_AllFound = 1,
    ddf_RegionEmpty = 2
} ;
#line 113 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef enum __anonenum_ddf_CompStatusType_34 ddf_CompStatusType;
#line 119
enum __anonenum_ddf_LPObjectiveType_35 {
    ddf_LPnone = 0,
    ddf_LPmax = 1,
    ddf_LPmin = 2
} ;
#line 119 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef enum __anonenum_ddf_LPObjectiveType_35 ddf_LPObjectiveType;
#line 123
enum __anonenum_ddf_LPSolverType_36 {
    ddf_CrissCross = 0,
    ddf_DualSimplex = 1
} ;
#line 123 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef enum __anonenum_ddf_LPSolverType_36 ddf_LPSolverType;
#line 127
enum __anonenum_ddf_LPStatusType_37 {
    ddf_LPSundecided = 0,
    ddf_Optimal = 1,
    ddf_Inconsistent = 2,
    ddf_DualInconsistent = 3,
    ddf_StrucInconsistent = 4,
    ddf_StrucDualInconsistent = 5,
    ddf_Unbounded = 6,
    ddf_DualUnbounded = 7
} ;
#line 127 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef enum __anonenum_ddf_LPStatusType_37 ddf_LPStatusType;
#line 156
struct ddf_lpdata;
#line 156 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_lpdata *ddf_LPPtr;
#line 157 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
struct ddf_lpdata {
   ddf_DataFileType filename ;
   ddf_LPObjectiveType objective ;
   ddf_LPSolverType solver ;
   ddf_boolean Homogeneous ;
   ddf_rowrange m ;
   ddf_colrange d ;
   ddf_Amatrix A ;
   ddf_Bmatrix B ;
   ddf_rowrange objrow ;
   ddf_colrange rhscol ;
   ddf_NumberType numbtype ;
   ddf_rowrange eqnumber ;
   ddf_rowset equalityset ;
   ddf_boolean redcheck_extensive ;
   ddf_rowrange ired ;
   ddf_rowset redset_extra ;
   ddf_rowset redset_accum ;
   ddf_rowset posset_extra ;
   ddf_boolean lexicopivot ;
   ddf_LPStatusType LPS ;
   ddf_rowrange m_alloc ;
   ddf_colrange d_alloc ;
   myfloat optvalue ;
   ddf_Arow sol ;
   ddf_Arow dsol ;
   ddf_colindex nbindex ;
   ddf_rowrange re ;
   ddf_colrange se ;
   long pivots[5] ;
   long total_pivots ;
   int use_given_basis ;
   ddf_colindex given_nbindex ;
   time_t starttime ;
   time_t endtime ;
};
#line 204
struct ddf_matrixdata;
#line 204 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_matrixdata *ddf_MatrixPtr;
#line 205 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
struct ddf_matrixdata {
   ddf_rowrange rowsize ;
   ddf_rowset linset ;
   ddf_colrange colsize ;
   ddf_RepresentationType representation ;
   ddf_NumberType numbtype ;
   ddf_Amatrix matrix ;
   ddf_LPObjectiveType objective ;
   ddf_Arow rowvec ;
};
#line 219
struct ddf_setfamily;
#line 219 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_setfamily *ddf_SetFamilyPtr;
#line 220 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
struct ddf_setfamily {
   ddf_bigrange famsize ;
   ddf_bigrange setsize ;
   ddf_SetVector set ;
};
#line 237
struct ddf_polyhedradata;
#line 237 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_polyhedradata *ddf_PolyhedraPtr;
#line 238
struct ddf_conedata;
#line 238 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_conedata *ddf_ConePtr;
#line 240 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
struct ddf_polyhedradata {
   ddf_RepresentationType representation ;
   ddf_boolean homogeneous ;
   ddf_colrange d ;
   ddf_rowrange m ;
   ddf_Amatrix A ;
   ddf_NumberType numbtype ;
   ddf_ConePtr child ;
   ddf_rowrange m_alloc ;
   ddf_colrange d_alloc ;
   ddf_Arow c ;
   ddf_rowflag EqualityIndex ;
   ddf_boolean IsEmpty ;
   ddf_boolean NondegAssumed ;
   ddf_boolean InitBasisAtBottom ;
   ddf_boolean RestrictedEnumeration ;
   ddf_boolean RelaxedEnumeration ;
   ddf_rowrange m1 ;
   ddf_boolean AincGenerated ;
   ddf_colrange ldim ;
   ddf_bigrange n ;
   ddf_Aincidence Ainc ;
   ddf_rowset Ared ;
   ddf_rowset Adom ;
};
#line 240 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_polyhedradata ddf_PolyhedraType;
#line 283 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
struct ddf_conedata {
   ddf_RepresentationType representation ;
   ddf_rowrange m ;
   ddf_colrange d ;
   ddf_Amatrix A ;
   ddf_NumberType numbtype ;
   ddf_PolyhedraPtr parent ;
   ddf_rowrange m_alloc ;
   ddf_colrange d_alloc ;
   ddf_rowrange Iteration ;
   ddf_RowOrderType HalfspaceOrder ;
   ddf_RayPtr FirstRay ;
   ddf_RayPtr LastRay ;
   ddf_RayPtr ArtificialRay ;
   ddf_RayPtr PosHead ;
   ddf_RayPtr ZeroHead ;
   ddf_RayPtr NegHead ;
   ddf_RayPtr PosLast ;
   ddf_RayPtr ZeroLast ;
   ddf_RayPtr NegLast ;
   ddf_AdjacencyType **Edges ;
   unsigned int rseed ;
   ddf_boolean ColReduced ;
   ddf_bigrange LinearityDim ;
   ddf_colrange d_orig ;
   ddf_colindex newcol ;
   ddf_colindex InitialRayIndex ;
   ddf_rowindex OrderVector ;
   ddf_boolean RecomputeRowOrder ;
   ddf_boolean PreOrderedRun ;
   ddf_rowset GroundSet ;
   ddf_rowset EqualitySet ;
   ddf_rowset NonequalitySet ;
   ddf_rowset AddedHalfspaces ;
   ddf_rowset WeaklyAddedHalfspaces ;
   ddf_rowset InitialHalfspaces ;
   long RayCount ;
   long FeasibleRayCount ;
   long WeaklyFeasibleRayCount ;
   long TotalRayCount ;
   long ZeroRayCount ;
   long EdgeCount ;
   long TotalEdgeCount ;
   long count_int ;
   long count_int_good ;
   long count_int_bad ;
   ddf_Bmatrix B ;
   ddf_Bmatrix Bsave ;
   ddf_ErrorType Error ;
   ddf_CompStatusType CompStatus ;
   time_t starttime ;
   time_t endtime ;
};
#line 283 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_conedata ddf_ConeType;
#line 140 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef unsigned long mp_limb_t;
#line 144 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef unsigned long mp_bitcnt_t;
#line 149 "/usr/include/x86_64-linux-gnu/gmp.h"
struct __anonstruct___mpz_struct_25 {
   int _mp_alloc ;
   int _mp_size ;
   mp_limb_t *_mp_d ;
};
#line 149 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef struct __anonstruct___mpz_struct_25 __mpz_struct;
#line 165 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef mp_limb_t *mp_ptr;
#line 166 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef mp_limb_t const   *mp_srcptr;
#line 174 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef long mp_size_t;
#line 178 "/usr/include/x86_64-linux-gnu/gmp.h"
struct __anonstruct___mpq_struct_26 {
   __mpz_struct _mp_num ;
   __mpz_struct _mp_den ;
};
#line 178 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef struct __anonstruct___mpq_struct_26 __mpq_struct;
#line 185 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpq_struct mpq_t[1];
#line 223 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpz_struct const   *mpz_srcptr;
#line 224 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpz_struct *mpz_ptr;
#line 227 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpq_struct const   *mpq_srcptr;
#line 228 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpq_struct *mpq_ptr;
#line 91 "../lib-src-gmp/cddmp.h"
typedef mpq_t mytype;
#line 29 "../lib-src-gmp/cddtypes.h"
typedef int dd_boolean;
#line 31 "../lib-src-gmp/cddtypes.h"
typedef long dd_rowrange;
#line 32 "../lib-src-gmp/cddtypes.h"
typedef long dd_colrange;
#line 33 "../lib-src-gmp/cddtypes.h"
typedef long dd_bigrange;
#line 35 "../lib-src-gmp/cddtypes.h"
typedef set_type dd_rowset;
#line 37 "../lib-src-gmp/cddtypes.h"
typedef long *dd_rowindex;
#line 38 "../lib-src-gmp/cddtypes.h"
typedef int *dd_rowflag;
#line 39 "../lib-src-gmp/cddtypes.h"
typedef long *dd_colindex;
#line 40 "../lib-src-gmp/cddtypes.h"
typedef mytype **dd_Amatrix;
#line 41 "../lib-src-gmp/cddtypes.h"
typedef mytype *dd_Arow;
#line 42 "../lib-src-gmp/cddtypes.h"
typedef set_type *dd_SetVector;
#line 43 "../lib-src-gmp/cddtypes.h"
typedef mytype **dd_Bmatrix;
#line 44 "../lib-src-gmp/cddtypes.h"
typedef set_type *dd_Aincidence;
#line 47 "../lib-src-gmp/cddtypes.h"
typedef char dd_DataFileType[255];
#line 51
struct dd_raydata;
#line 51 "../lib-src-gmp/cddtypes.h"
typedef struct dd_raydata *dd_RayPtr;
#line 53 "../lib-src-gmp/cddtypes.h"
struct dd_raydata {
   mytype *Ray ;
   dd_rowset ZeroSet ;
   dd_rowrange FirstInfeasIndex ;
   dd_boolean feasible ;
   mytype ARay ;
   dd_RayPtr Next ;
};
#line 62
struct dd_adjacencydata;
#line 62 "../lib-src-gmp/cddtypes.h"
typedef struct dd_adjacencydata *dd_AdjacencyPtr;
#line 63 "../lib-src-gmp/cddtypes.h"
struct dd_adjacencydata {
   dd_RayPtr Ray1 ;
   dd_RayPtr Ray2 ;
   dd_AdjacencyPtr Next ;
};
#line 63 "../lib-src-gmp/cddtypes.h"
typedef struct dd_adjacencydata dd_AdjacencyType;
#line 72
enum __anonenum_dd_RowOrderType_33 {
    dd_MaxIndex = 0,
    dd_MinIndex = 1,
    dd_MinCutoff = 2,
    dd_MaxCutoff = 3,
    dd_MixCutoff = 4,
    dd_LexMin = 5,
    dd_LexMax = 6,
    dd_RandomRow = 7
} ;
#line 72 "../lib-src-gmp/cddtypes.h"
typedef enum __anonenum_dd_RowOrderType_33 dd_RowOrderType;
#line 77
enum __anonenum_dd_NumberType_34 {
    dd_Unknown = 0,
    dd_Real = 1,
    dd_Rational = 2,
    dd_Integer = 3
} ;
#line 77 "../lib-src-gmp/cddtypes.h"
typedef enum __anonenum_dd_NumberType_34 dd_NumberType;
#line 81
enum __anonenum_dd_RepresentationType_35 {
    dd_Unspecified = 0,
    dd_Inequality = 1,
    dd_Generator = 2
} ;
#line 81 "../lib-src-gmp/cddtypes.h"
typedef enum __anonenum_dd_RepresentationType_35 dd_RepresentationType;
#line 102
enum __anonenum_dd_ErrorType_40 {
    dd_DimensionTooLarge = 0,
    dd_ImproperInputFormat = 1,
    dd_NegativeMatrixSize = 2,
    dd_EmptyVrepresentation = 3,
    dd_EmptyHrepresentation = 4,
    dd_EmptyRepresentation = 5,
    dd_IFileNotFound = 6,
    dd_OFileNotOpen = 7,
    dd_NoLPObjective = 8,
    dd_NoRealNumberSupport = 9,
    dd_NotAvailForH = 10,
    dd_NotAvailForV = 11,
    dd_CannotHandleLinearity = 12,
    dd_RowIndexOutOfRange = 13,
    dd_ColIndexOutOfRange = 14,
    dd_LPCycling = 15,
    dd_NumericallyInconsistent = 16,
    dd_NoError = 17
} ;
#line 102 "../lib-src-gmp/cddtypes.h"
typedef enum __anonenum_dd_ErrorType_40 dd_ErrorType;
#line 112
enum __anonenum_dd_CompStatusType_41 {
    dd_InProgress = 0,
    dd_AllFound = 1,
    dd_RegionEmpty = 2
} ;
#line 112 "../lib-src-gmp/cddtypes.h"
typedef enum __anonenum_dd_CompStatusType_41 dd_CompStatusType;
#line 118
enum __anonenum_dd_LPObjectiveType_42 {
    dd_LPnone = 0,
    dd_LPmax = 1,
    dd_LPmin = 2
} ;
#line 118 "../lib-src-gmp/cddtypes.h"
typedef enum __anonenum_dd_LPObjectiveType_42 dd_LPObjectiveType;
#line 203
struct dd_matrixdata;
#line 203 "../lib-src-gmp/cddtypes.h"
typedef struct dd_matrixdata *dd_MatrixPtr;
#line 204 "../lib-src-gmp/cddtypes.h"
struct dd_matrixdata {
   dd_rowrange rowsize ;
   dd_rowset linset ;
   dd_colrange colsize ;
   dd_RepresentationType representation ;
   dd_NumberType numbtype ;
   dd_Amatrix matrix ;
   dd_LPObjectiveType objective ;
   dd_Arow rowvec ;
};
#line 218
struct dd_setfamily;
#line 218 "../lib-src-gmp/cddtypes.h"
typedef struct dd_setfamily *dd_SetFamilyPtr;
#line 219 "../lib-src-gmp/cddtypes.h"
struct dd_setfamily {
   dd_bigrange famsize ;
   dd_bigrange setsize ;
   dd_SetVector set ;
};
#line 236
struct dd_polyhedradata;
#line 236 "../lib-src-gmp/cddtypes.h"
typedef struct dd_polyhedradata *dd_PolyhedraPtr;
#line 237
struct dd_conedata;
#line 237 "../lib-src-gmp/cddtypes.h"
typedef struct dd_conedata *dd_ConePtr;
#line 239 "../lib-src-gmp/cddtypes.h"
struct dd_polyhedradata {
   dd_RepresentationType representation ;
   dd_boolean homogeneous ;
   dd_colrange d ;
   dd_rowrange m ;
   dd_Amatrix A ;
   dd_NumberType numbtype ;
   dd_ConePtr child ;
   dd_rowrange m_alloc ;
   dd_colrange d_alloc ;
   dd_Arow c ;
   dd_rowflag EqualityIndex ;
   dd_boolean IsEmpty ;
   dd_boolean NondegAssumed ;
   dd_boolean InitBasisAtBottom ;
   dd_boolean RestrictedEnumeration ;
   dd_boolean RelaxedEnumeration ;
   dd_rowrange m1 ;
   dd_boolean AincGenerated ;
   dd_colrange ldim ;
   dd_bigrange n ;
   dd_Aincidence Ainc ;
   dd_rowset Ared ;
   dd_rowset Adom ;
};
#line 282 "../lib-src-gmp/cddtypes.h"
struct dd_conedata {
   dd_RepresentationType representation ;
   dd_rowrange m ;
   dd_colrange d ;
   dd_Amatrix A ;
   dd_NumberType numbtype ;
   dd_PolyhedraPtr parent ;
   dd_rowrange m_alloc ;
   dd_colrange d_alloc ;
   dd_rowrange Iteration ;
   dd_RowOrderType HalfspaceOrder ;
   dd_RayPtr FirstRay ;
   dd_RayPtr LastRay ;
   dd_RayPtr ArtificialRay ;
   dd_RayPtr PosHead ;
   dd_RayPtr ZeroHead ;
   dd_RayPtr NegHead ;
   dd_RayPtr PosLast ;
   dd_RayPtr ZeroLast ;
   dd_RayPtr NegLast ;
   dd_AdjacencyType **Edges ;
   unsigned int rseed ;
   dd_boolean ColReduced ;
   dd_bigrange LinearityDim ;
   dd_colrange d_orig ;
   dd_colindex newcol ;
   dd_colindex InitialRayIndex ;
   dd_rowindex OrderVector ;
   dd_boolean RecomputeRowOrder ;
   dd_boolean PreOrderedRun ;
   dd_rowset GroundSet ;
   dd_rowset EqualitySet ;
   dd_rowset NonequalitySet ;
   dd_rowset AddedHalfspaces ;
   dd_rowset WeaklyAddedHalfspaces ;
   dd_rowset InitialHalfspaces ;
   long RayCount ;
   long FeasibleRayCount ;
   long WeaklyFeasibleRayCount ;
   long TotalRayCount ;
   long ZeroRayCount ;
   long EdgeCount ;
   long TotalEdgeCount ;
   long count_int ;
   long count_int_good ;
   long count_int_bad ;
   dd_Bmatrix B ;
   dd_Bmatrix Bsave ;
   dd_ErrorType Error ;
   dd_CompStatusType CompStatus ;
   time_t starttime ;
   time_t endtime ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
typedef set_type dd_colset;
#line 122
enum __anonenum_dd_LPSolverType_43 {
    dd_CrissCross = 0,
    dd_DualSimplex = 1
} ;
#line 122 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
typedef enum __anonenum_dd_LPSolverType_43 dd_LPSolverType;
#line 126
enum __anonenum_dd_LPStatusType_44 {
    dd_LPSundecided = 0,
    dd_Optimal = 1,
    dd_Inconsistent = 2,
    dd_DualInconsistent = 3,
    dd_StrucInconsistent = 4,
    dd_StrucDualInconsistent = 5,
    dd_Unbounded = 6,
    dd_DualUnbounded = 7
} ;
#line 126 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
typedef enum __anonenum_dd_LPStatusType_44 dd_LPStatusType;
#line 132
struct dd_lpsolution;
#line 132 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
typedef struct dd_lpsolution *dd_LPSolutionPtr;
#line 133 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
struct dd_lpsolution {
   dd_DataFileType filename ;
   dd_LPObjectiveType objective ;
   dd_LPSolverType solver ;
   dd_rowrange m ;
   dd_colrange d ;
   dd_NumberType numbtype ;
   dd_LPStatusType LPS ;
   mytype optvalue ;
   dd_Arow sol ;
   dd_Arow dsol ;
   dd_colindex nbindex ;
   dd_rowrange re ;
   dd_colrange se ;
   long pivots[5] ;
   long total_pivots ;
};
#line 133 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
typedef struct dd_lpsolution dd_LPSolutionType;
#line 155
struct dd_lpdata;
#line 155 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
typedef struct dd_lpdata *dd_LPPtr;
#line 156 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
struct dd_lpdata {
   dd_DataFileType filename ;
   dd_LPObjectiveType objective ;
   dd_LPSolverType solver ;
   dd_boolean Homogeneous ;
   dd_rowrange m ;
   dd_colrange d ;
   dd_Amatrix A ;
   dd_Bmatrix B ;
   dd_rowrange objrow ;
   dd_colrange rhscol ;
   dd_NumberType numbtype ;
   dd_rowrange eqnumber ;
   dd_rowset equalityset ;
   dd_boolean redcheck_extensive ;
   dd_rowrange ired ;
   dd_rowset redset_extra ;
   dd_rowset redset_accum ;
   dd_rowset posset_extra ;
   dd_boolean lexicopivot ;
   dd_LPStatusType LPS ;
   dd_rowrange m_alloc ;
   dd_colrange d_alloc ;
   mytype optvalue ;
   dd_Arow sol ;
   dd_Arow dsol ;
   dd_colindex nbindex ;
   dd_rowrange re ;
   dd_colrange se ;
   long pivots[5] ;
   long total_pivots ;
   int use_given_basis ;
   dd_colindex given_nbindex ;
   time_t starttime ;
   time_t endtime ;
};
#line 156 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
typedef struct dd_lpdata dd_LPType;
#line 157 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_lpdata ddf_LPType;
#line 31 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
typedef set_type rowset;
#line 32 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
typedef set_type colset;
#line 37 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef set_type ddf_colset;
#line 54 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_raydata ddf_RayType;
#line 205 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_matrixdata ddf_MatrixType;
#line 220 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_setfamily ddf_SetFamilyType;
#line 133
struct ddf_lpsolution;
#line 133 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_lpsolution *ddf_LPSolutionPtr;
#line 134 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
struct ddf_lpsolution {
   ddf_DataFileType filename ;
   ddf_LPObjectiveType objective ;
   ddf_LPSolverType solver ;
   ddf_rowrange m ;
   ddf_colrange d ;
   ddf_NumberType numbtype ;
   ddf_LPStatusType LPS ;
   myfloat optvalue ;
   ddf_Arow sol ;
   ddf_Arow dsol ;
   ddf_colindex nbindex ;
   ddf_rowrange re ;
   ddf_colrange se ;
   long pivots[5] ;
   long total_pivots ;
};
#line 134 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
typedef struct ddf_lpsolution ddf_LPSolutionType;
#line 53 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
typedef struct dd_raydata dd_RayType;
#line 204 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
typedef struct dd_matrixdata dd_MatrixType;
#line 219 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
typedef struct dd_setfamily dd_SetFamilyType;
#line 163 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpz_struct mpz_t[1];
#line 239 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
typedef struct dd_polyhedradata dd_PolyhedraType;
#line 282 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
typedef struct dd_conedata dd_ConeType;
#line 18 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.h"
typedef unsigned char set_card_lut_t;
#line 95 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.h"
typedef double mytype___0[1];
#line 40 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef mytype___0 **dd_Amatrix___0;
#line 41 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef mytype___0 *dd_Arow___0;
#line 43 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef mytype___0 **dd_Bmatrix___0;
#line 132 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_lpsolution___0 *dd_LPSolutionPtr___0;
#line 133 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
struct dd_lpsolution___0 {
   dd_DataFileType filename ;
   dd_LPObjectiveType objective ;
   dd_LPSolverType solver ;
   dd_rowrange m ;
   dd_colrange d ;
   dd_NumberType numbtype ;
   dd_LPStatusType LPS ;
   mytype___0 optvalue ;
   dd_Arow___0 sol ;
   dd_Arow___0 dsol ;
   dd_colindex nbindex ;
   dd_rowrange re ;
   dd_colrange se ;
   long pivots[5] ;
   long total_pivots ;
};
#line 133 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_lpsolution___0 dd_LPSolutionType___0;
#line 155 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_lpdata___0 *dd_LPPtr___0;
#line 156 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
struct dd_lpdata___0 {
   dd_DataFileType filename ;
   dd_LPObjectiveType objective ;
   dd_LPSolverType solver ;
   dd_boolean Homogeneous ;
   dd_rowrange m ;
   dd_colrange d ;
   dd_Amatrix___0 A ;
   dd_Bmatrix___0 B ;
   dd_rowrange objrow ;
   dd_colrange rhscol ;
   dd_NumberType numbtype ;
   dd_rowrange eqnumber ;
   dd_rowset equalityset ;
   dd_boolean redcheck_extensive ;
   dd_rowrange ired ;
   dd_rowset redset_extra ;
   dd_rowset redset_accum ;
   dd_rowset posset_extra ;
   dd_boolean lexicopivot ;
   dd_LPStatusType LPS ;
   dd_rowrange m_alloc ;
   dd_colrange d_alloc ;
   mytype___0 optvalue ;
   dd_Arow___0 sol ;
   dd_Arow___0 dsol ;
   dd_colindex nbindex ;
   dd_rowrange re ;
   dd_colrange se ;
   long pivots[5] ;
   long total_pivots ;
   int use_given_basis ;
   dd_colindex given_nbindex ;
   time_t starttime ;
   time_t endtime ;
};
#line 156 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_lpdata___0 dd_LPType___0;
#line 203 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_matrixdata___0 *dd_MatrixPtr___0;
#line 204 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
struct dd_matrixdata___0 {
   dd_rowrange rowsize ;
   dd_rowset linset ;
   dd_colrange colsize ;
   dd_RepresentationType representation ;
   dd_NumberType numbtype ;
   dd_Amatrix___0 matrix ;
   dd_LPObjectiveType objective ;
   dd_Arow___0 rowvec ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_raydata___0 *dd_RayPtr___0;
#line 53 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
struct dd_raydata___0 {
   mytype___0 *Ray ;
   dd_rowset ZeroSet ;
   dd_rowrange FirstInfeasIndex ;
   dd_boolean feasible ;
   mytype___0 ARay ;
   dd_RayPtr___0 Next ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_adjacencydata___0 *dd_AdjacencyPtr___0;
#line 63 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
struct dd_adjacencydata___0 {
   dd_RayPtr___0 Ray1 ;
   dd_RayPtr___0 Ray2 ;
   dd_AdjacencyPtr___0 Next ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_adjacencydata___0 dd_AdjacencyType___0;
#line 236 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_polyhedradata___0 *dd_PolyhedraPtr___0;
#line 237 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_conedata___0 *dd_ConePtr___0;
#line 239 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
struct dd_polyhedradata___0 {
   dd_RepresentationType representation ;
   dd_boolean homogeneous ;
   dd_colrange d ;
   dd_rowrange m ;
   dd_Amatrix___0 A ;
   dd_NumberType numbtype ;
   dd_ConePtr___0 child ;
   dd_rowrange m_alloc ;
   dd_colrange d_alloc ;
   dd_Arow___0 c ;
   dd_rowflag EqualityIndex ;
   dd_boolean IsEmpty ;
   dd_boolean NondegAssumed ;
   dd_boolean InitBasisAtBottom ;
   dd_boolean RestrictedEnumeration ;
   dd_boolean RelaxedEnumeration ;
   dd_rowrange m1 ;
   dd_boolean AincGenerated ;
   dd_colrange ldim ;
   dd_bigrange n ;
   dd_Aincidence Ainc ;
   dd_rowset Ared ;
   dd_rowset Adom ;
};
#line 239 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_polyhedradata___0 dd_PolyhedraType___0;
#line 282 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
struct dd_conedata___0 {
   dd_RepresentationType representation ;
   dd_rowrange m ;
   dd_colrange d ;
   dd_Amatrix___0 A ;
   dd_NumberType numbtype ;
   dd_PolyhedraPtr___0 parent ;
   dd_rowrange m_alloc ;
   dd_colrange d_alloc ;
   dd_rowrange Iteration ;
   dd_RowOrderType HalfspaceOrder ;
   dd_RayPtr___0 FirstRay ;
   dd_RayPtr___0 LastRay ;
   dd_RayPtr___0 ArtificialRay ;
   dd_RayPtr___0 PosHead ;
   dd_RayPtr___0 ZeroHead ;
   dd_RayPtr___0 NegHead ;
   dd_RayPtr___0 PosLast ;
   dd_RayPtr___0 ZeroLast ;
   dd_RayPtr___0 NegLast ;
   dd_AdjacencyType___0 **Edges ;
   unsigned int rseed ;
   dd_boolean ColReduced ;
   dd_bigrange LinearityDim ;
   dd_colrange d_orig ;
   dd_colindex newcol ;
   dd_colindex InitialRayIndex ;
   dd_rowindex OrderVector ;
   dd_boolean RecomputeRowOrder ;
   dd_boolean PreOrderedRun ;
   dd_rowset GroundSet ;
   dd_rowset EqualitySet ;
   dd_rowset NonequalitySet ;
   dd_rowset AddedHalfspaces ;
   dd_rowset WeaklyAddedHalfspaces ;
   dd_rowset InitialHalfspaces ;
   long RayCount ;
   long FeasibleRayCount ;
   long WeaklyFeasibleRayCount ;
   long TotalRayCount ;
   long ZeroRayCount ;
   long EdgeCount ;
   long TotalEdgeCount ;
   long count_int ;
   long count_int_good ;
   long count_int_bad ;
   dd_Bmatrix___0 B ;
   dd_Bmatrix___0 Bsave ;
   dd_ErrorType Error ;
   dd_CompStatusType CompStatus ;
   time_t starttime ;
   time_t endtime ;
};
#line 282 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_conedata___0 dd_ConeType___0;
#line 53 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_raydata___0 dd_RayType___0;
#line 204 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddtypes.h"
typedef struct dd_matrixdata___0 dd_MatrixType___0;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 431
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
#line 538
extern int getchar(void) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.h"
void set_initialize(set_type *setp , long length ) ;
#line 26
void set_free(set_type set ) ;
#line 27
void set_emptyset(set_type set ) ;
#line 28
void set_copy(set_type setcopy , set_type set ) ;
#line 29
void set_addelem(set_type set , long elem ) ;
#line 30
void set_delelem(set_type set , long elem ) ;
#line 31
void set_int(set_type set , set_type set1 , set_type set2 ) ;
#line 32
void set_uni(set_type set , set_type set1 , set_type set2 ) ;
#line 34
void set_compl(set_type set , set_type set1 ) ;
#line 35
int set_subset(set_type set1 , set_type set2 ) ;
#line 36
int set_member(long elem , set_type set ) ;
#line 37
long set_card(set_type set ) ;
#line 40
void set_fwrite(FILE *f , set_type set ) ;
#line 41
void set_fwrite_compl(FILE *f , set_type set ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.h"
void dddf_init(double *a___41 ) ;
#line 105
void dddf_clear(double *a___41 ) ;
#line 106
void dddf_set(double *a___41 , double *b ) ;
#line 107
void dddf_set_d(double *a___41 , double b ) ;
#line 110
void dddf_add(double *a___41 , double *b , double *c ) ;
#line 112
void dddf_mul(double *a___41 , double *b , double *c ) ;
#line 113
void dddf_div(double *a___41 , double *b , double *c ) ;
#line 118
double dddf_get_d(double *a___41 ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 261
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) asctime)(struct tm  const  *__tp ) ;
#line 329 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
ddf_boolean ddf_debug ;
#line 34 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
myfloat ddf_one ;
#line 35
myfloat ddf_purezero ;
#line 39
time_t ddf_statStartTime ;
#line 40
long ddf_statBApivots ;
#line 41
long ddf_statCCpivots ;
#line 42
long ddf_statDS1pivots ;
#line 43
long ddf_statDS2pivots ;
#line 44
long ddf_statACpivots ;
#line 48
ddf_LPSolverType ddf_choiceLPSolverDefault ;
#line 49
ddf_LPSolverType ddf_choiceRedcheckAlgorithm ;
#line 50
ddf_boolean ddf_choiceLexicoPivotQ ;
#line 62
void ddf_InitializeArow(ddf_colrange d , ddf_Arow *a___41 ) ;
#line 63
void ddf_InitializeAmatrix(ddf_rowrange m , ddf_colrange d , ddf_Amatrix *A ) ;
#line 64
void ddf_InitializeBmatrix(ddf_colrange d , ddf_Bmatrix *B ) ;
#line 65
ddf_SetFamilyPtr ddf_CreateSetFamily(ddf_bigrange fsize , ddf_bigrange ssize ) ;
#line 66
void ddf_FreeSetFamily(ddf_SetFamilyPtr F ) ;
#line 67
ddf_MatrixPtr ddf_CreateMatrix(ddf_rowrange m_size , ddf_colrange d_size ) ;
#line 69
void ddf_FreeArow(ddf_colrange d , ddf_Arow a___41 ) ;
#line 72
void ddf_FreePolyhedra(ddf_PolyhedraPtr poly ) ;
#line 73
void ddf_FreeMatrix(ddf_MatrixPtr M ) ;
#line 79
ddf_boolean ddf_Positive(double *val ) ;
#line 81
ddf_boolean ddf_EqualToZero(double *val ) ;
#line 82
ddf_boolean ddf_Nonzero(double *val ) ;
#line 91
ddf_MatrixPtr ddf_CopyInput(ddf_PolyhedraPtr poly ) ;
#line 92
ddf_MatrixPtr ddf_CopyOutput(ddf_PolyhedraPtr poly ) ;
#line 93
ddf_MatrixPtr ddf_CopyInequalities(ddf_PolyhedraPtr poly ) ;
#line 94
ddf_MatrixPtr ddf_CopyGenerators(ddf_PolyhedraPtr poly ) ;
#line 95
ddf_SetFamilyPtr ddf_CopyIncidence(ddf_PolyhedraPtr poly ) ;
#line 96
ddf_SetFamilyPtr ddf_CopyAdjacency(ddf_PolyhedraPtr poly ) ;
#line 97
ddf_SetFamilyPtr ddf_CopyInputIncidence(ddf_PolyhedraPtr poly ) ;
#line 98
ddf_SetFamilyPtr ddf_CopyInputAdjacency(ddf_PolyhedraPtr poly ) ;
#line 101
ddf_MatrixPtr ddf_PolyFile2Matrix(FILE *f , ddf_ErrorType *Error ) ;
#line 103
ddf_PolyhedraPtr ddf_DDMatrix2Poly(ddf_MatrixPtr M , ddf_ErrorType *err ) ;
#line 104
ddf_PolyhedraPtr ddf_DDMatrix2Poly2(ddf_MatrixPtr M , ddf_RowOrderType horder , ddf_ErrorType *err ) ;
#line 127
ddf_MatrixPtr ddf_MatrixCopy(ddf_MatrixPtr M ) ;
#line 128
ddf_MatrixPtr ddf_CopyMatrix(ddf_MatrixPtr M ) ;
#line 129
ddf_MatrixPtr ddf_MatrixNormalizedCopy(ddf_MatrixPtr M ) ;
#line 130
ddf_MatrixPtr ddf_MatrixNormalizedSortedCopy(ddf_MatrixPtr M , ddf_rowindex *newpos ) ;
#line 131
ddf_MatrixPtr ddf_MatrixUniqueCopy(ddf_MatrixPtr M , ddf_rowindex *newpos ) ;
#line 132
ddf_MatrixPtr ddf_MatrixNormalizedSortedUniqueCopy(ddf_MatrixPtr M , ddf_rowindex *newpos ) ;
#line 133
ddf_MatrixPtr ddf_MatrixSortedUniqueCopy(ddf_MatrixPtr M , ddf_rowindex *newpos ) ;
#line 135
ddf_MatrixPtr ddf_MatrixAppend(ddf_MatrixPtr M1 , ddf_MatrixPtr M2 ) ;
#line 136
ddf_MatrixPtr ddf_AppendMatrix(ddf_MatrixPtr M1 , ddf_MatrixPtr M2 ) ;
#line 138
int ddf_MatrixAppendTo(ddf_MatrixPtr *M1 , ddf_MatrixPtr M2 ) ;
#line 140
ddf_MatrixPtr ddf_MatrixSubmatrix(ddf_MatrixPtr M , ddf_rowset delset ) ;
#line 141
ddf_MatrixPtr ddf_MatrixSubmatrix2(ddf_MatrixPtr M , ddf_rowset delset , ddf_rowindex *newpos ) ;
#line 142
ddf_MatrixPtr ddf_MatrixSubmatrix2L(ddf_MatrixPtr M , ddf_rowset delset , ddf_rowindex *newpos ) ;
#line 143
int ddf_MatrixShiftupLinearity(ddf_MatrixPtr *M , ddf_rowindex *newpos ) ;
#line 144
int ddf_MatrixRowRemove(ddf_MatrixPtr *M , ddf_rowrange r ) ;
#line 145
int ddf_MatrixRowRemove2(ddf_MatrixPtr *M , ddf_rowrange r , ddf_rowindex *newpos ) ;
#line 146
int ddf_MatrixRowsRemove(ddf_MatrixPtr *M , ddf_rowset delset ) ;
#line 147
int ddf_MatrixRowsRemove2(ddf_MatrixPtr *M , ddf_rowset delset , ddf_rowindex *newpos ) ;
#line 150
void ddf_SetInputFile(FILE **f , char *inputfile , ddf_ErrorType *Error ) ;
#line 151
void ddf_SetWriteFileName(char *inputfile , char *outfile , char cflag , ddf_RepresentationType rep ) ;
#line 153
void ddf_WriteAmatrix(FILE *f , ddf_Amatrix A , long rowmax , long colmax ) ;
#line 154
void ddf_WriteArow(FILE *f , ddf_Arow a___41 , ddf_colrange d ) ;
#line 155
void ddf_WriteBmatrix(FILE *f , ddf_colrange d_size , ddf_Bmatrix B ) ;
#line 156
void ddf_WriteMatrix(FILE *f , ddf_MatrixPtr M ) ;
#line 157
void ddf_MatrixIntegerFilter(ddf_MatrixPtr M ) ;
#line 158
void ddf_WriteReal(FILE *f , double *x ) ;
#line 159
void ddf_WriteNumber(FILE *f , double *x ) ;
#line 161
void ddf_WritePolyFile(FILE *f , ddf_PolyhedraPtr poly ) ;
#line 162
void ddf_WriteRunningMode(FILE *f , ddf_PolyhedraPtr poly ) ;
#line 163
void ddf_WriteErrorMessages(FILE *f , ddf_ErrorType Error ) ;
#line 164
void ddf_WriteSetFamily(FILE *f , ddf_SetFamilyPtr F ) ;
#line 165
void ddf_WriteSetFamilyCompressed(FILE *f , ddf_SetFamilyPtr F ) ;
#line 166
void ddf_WriteProgramDescription(FILE *f ) ;
#line 167
void ddf_WriteDDTimes(FILE *f , ddf_PolyhedraPtr poly ) ;
#line 168
void ddf_WriteTimes(FILE *f , time_t starttime , time_t endtime ) ;
#line 169
void ddf_WriteIncidence(FILE *f , ddf_PolyhedraPtr poly ) ;
#line 170
void ddf_WriteAdjacency(FILE *f , ddf_PolyhedraPtr poly ) ;
#line 171
void ddf_WriteInputAdjacency(FILE *f , ddf_PolyhedraPtr poly ) ;
#line 172
void ddf_WriteInputIncidence(FILE *f , ddf_PolyhedraPtr poly ) ;
#line 193
void ddf_WriteLP(FILE *f , ddf_LPPtr lp ) ;
#line 208
void ddf_WriteLPTimes(FILE *f , ddf_LPPtr lp ) ;
#line 209
void ddf_WriteLPStats(FILE *f ) ;
#line 210
void ddf_WriteLPMode(FILE *f ) ;
#line 220
void ddf_QuickSort(ddf_rowindex OV , long p , long r , ddf_Amatrix A , long dmax ) ;
#line 221
void ddf_RandomPermutation(ddf_rowindex OV , long t , unsigned int seed ) ;
#line 222
void ddf_UniqueRows(ddf_rowindex OV , long p , long r , ddf_Amatrix A , long dmax ,
                    ddf_rowset preferred , long *uniqrows ) ;
#line 224
ddf_boolean ddf_DoubleDescription(ddf_PolyhedraPtr poly , ddf_ErrorType *err ) ;
#line 225
ddf_boolean ddf_DoubleDescription2(ddf_PolyhedraPtr poly , ddf_RowOrderType horder ,
                                   ddf_ErrorType *err ) ;
#line 228
void ddf_fread_rational_value(FILE *f , double *value ) ;
#line 229
void ddf_sread_rational_value(char const   *s , double *value ) ;
#line 235
void ddf_CheckAdjacency(ddf_ConePtr cone , ddf_RayPtr *RP1 , ddf_RayPtr *RP2 , ddf_boolean *adjacent ) ;
#line 239
void ddf_CopyArow(myfloat *acopy , myfloat *a___41 , ddf_colrange d ) ;
#line 240
void ddf_CopyNormalizedAmatrix(myfloat **Acopy , myfloat **A , ddf_rowrange m , ddf_colrange d ) ;
#line 242
void ddf_CopyAmatrix(myfloat **Acopy , myfloat **A , ddf_rowrange m , ddf_colrange d ) ;
#line 243
void ddf_PermuteCopyAmatrix(myfloat **Acopy , myfloat **A , ddf_rowrange m , ddf_colrange d ,
                            ddf_rowindex roworder ) ;
#line 244
void ddf_PermutePartialCopyAmatrix(myfloat **Acopy , myfloat **A , ddf_rowrange m ,
                                   ddf_colrange d , ddf_rowindex roworder , ddf_rowrange p ,
                                   ddf_rowrange q ) ;
#line 246
void ddf_CopyRay(myfloat *a___41 , ddf_colrange d_origsize , ddf_RayPtr RR , ddf_RepresentationType rep ,
                 ddf_colindex reducedcol ) ;
#line 263
void ddf_ProcessCommandLine(FILE *f , ddf_MatrixPtr M , char const   *line ) ;
#line 270
void ddf_SnapToInteger(double *y , double *x ) ;
#line 276
void ddf_WriteRay(FILE *f , ddf_colrange d_origsize , ddf_RayPtr RR , ddf_RepresentationType rep ,
                  ddf_colindex reducedcol ) ;
#line 281
ddf_NumberType ddf_GetNumberType(char const   *line ) ;
#line 282
ddf_ConePtr ddf_ConeDataLoad(ddf_PolyhedraPtr poly ) ;
#line 283
ddf_PolyhedraPtr ddf_CreatePolyhedraData(ddf_rowrange m , ddf_colrange d ) ;
#line 284
ddf_boolean ddf_InitializeConeData(ddf_rowrange m , ddf_colrange d , ddf_ConePtr *cone ) ;
#line 285
ddf_boolean ddf_AppendMatrix2Poly(ddf_PolyhedraPtr *poly , ddf_MatrixPtr M ) ;
#line 181 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_SetLinearity(ddf_MatrixPtr M , char *line ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_SetInputFile(FILE **f , char *inputfile , ddf_ErrorType *Error ) 
{ 
  int opened ;
  int stop ;
  int quit ;
  int i ;
  int dotpos ;
  int trial ;
  char ch ;
  char *tempname ;
  int tmp ;
  void *tmp___0 ;
  FILE *tmp___1 ;

  {
#line 27
  opened = 0;
#line 27
  quit = 0;
#line 28
  dotpos = 0;
#line 28
  trial = 0;
#line 33
  *Error = (ddf_ErrorType )17;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! opened) {
#line 34
      if (! (! quit)) {
#line 34
        goto while_break;
      }
    } else {
#line 34
      goto while_break;
    }
    {
#line 35
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n>> Input file: ");
#line 36
    scanf((char const   */* __restrict  */)"%s", inputfile);
#line 37
    tmp = getchar();
#line 37
    ch = (char )tmp;
#line 38
    stop = 0;
#line 39
    i = 0;
    }
    {
#line 39
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 39
      if (i < 255) {
#line 39
        if (! (! stop)) {
#line 39
          goto while_break___0;
        }
      } else {
#line 39
        goto while_break___0;
      }
#line 40
      ch = *(inputfile + i);
      {
#line 42
      if ((int )ch == 46) {
#line 42
        goto case_46;
      }
#line 45
      if ((int )ch == 9) {
#line 45
        goto case_9;
      }
#line 45
      if ((int )ch == 10) {
#line 45
        goto case_9;
      }
#line 45
      if ((int )ch == 0) {
#line 45
        goto case_9;
      }
#line 45
      if ((int )ch == 32) {
#line 45
        goto case_9;
      }
#line 45
      if ((int )ch == 59) {
#line 45
        goto case_9;
      }
#line 41
      goto switch_break;
      case_46: /* CIL Label */ 
#line 43
      dotpos = i + 1;
#line 44
      goto switch_break;
      case_9: /* CIL Label */ 
      case_10: /* CIL Label */ 
      case_0: /* CIL Label */ 
      case_32: /* CIL Label */ 
      case_59: /* CIL Label */ 
      {
#line 46
      stop = 1;
#line 47
      tmp___0 = calloc((size_t )255, sizeof(ch));
#line 47
      tempname = (char *)tmp___0;
#line 48
      strncpy((char */* __restrict  */)tempname, (char const   */* __restrict  */)inputfile,
              (size_t )i);
#line 49
      strcpy((char */* __restrict  */)inputfile, (char const   */* __restrict  */)tempname);
#line 50
      free((void *)tempname);
      }
#line 51
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 39
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 54
    tmp___1 = fopen((char const   */* __restrict  */)inputfile, (char const   */* __restrict  */)"r");
#line 54
    *f = tmp___1;
    }
#line 54
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 55
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"input file %s is open\n",
              inputfile);
#line 56
      opened = 1;
#line 57
      *Error = (ddf_ErrorType )17;
      }
    } else {
      {
#line 60
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The file %s not found\n",
              inputfile);
#line 61
      trial ++;
      }
#line 62
      if (trial > 5) {
#line 63
        *Error = (ddf_ErrorType )6;
#line 64
        quit = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_SetWriteFileName(char *inputfile , char *outfile , char cflag , ddf_RepresentationType rep ) 
{ 
  char *extension ;
  ddf_DataFileType ifilehead ;
  unsigned int tmp ;
  int i ;
  int dotpos ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 73
  ifilehead[0] = (char )'\000';
#line 73
  tmp = 1U;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (tmp >= 255U) {
#line 73
      goto while_break;
    }
#line 73
    ifilehead[tmp] = (char)0;
#line 73
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  if ((int )cflag == 111) {
#line 77
    goto case_111;
  }
#line 88
  if ((int )cflag == 97) {
#line 88
    goto case_97;
  }
#line 94
  if ((int )cflag == 105) {
#line 94
    goto case_105;
  }
#line 100
  if ((int )cflag == 110) {
#line 100
    goto case_110;
  }
#line 106
  if ((int )cflag == 106) {
#line 106
    goto case_106;
  }
#line 112
  if ((int )cflag == 108) {
#line 112
    goto case_108;
  }
#line 114
  if ((int )cflag == 100) {
#line 114
    goto case_100;
  }
#line 116
  if ((int )cflag == 112) {
#line 116
    goto case_112;
  }
#line 118
  if ((int )cflag == 118) {
#line 118
    goto case_118;
  }
#line 120
  if ((int )cflag == 115) {
#line 120
    goto case_115;
  }
#line 122
  goto switch_default___0;
  case_111: /* CIL Label */ 
  {
#line 79
  if ((unsigned int )rep == 2U) {
#line 79
    goto case_2;
  }
#line 81
  if ((unsigned int )rep == 1U) {
#line 81
    goto case_1;
  }
#line 83
  goto switch_default;
  case_2: /* CIL Label */ 
#line 80
  extension = (char *)".ine";
#line 80
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 82
  extension = (char *)".ext";
#line 82
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 84
  extension = (char *)".xxx";
#line 84
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 86
  goto switch_break;
  case_97: /* CIL Label */ 
#line 89
  if ((unsigned int )rep == 1U) {
#line 90
    extension = (char *)".ead";
  } else {
#line 92
    extension = (char *)".iad";
  }
#line 93
  goto switch_break;
  case_105: /* CIL Label */ 
#line 95
  if ((unsigned int )rep == 1U) {
#line 96
    extension = (char *)".ecd";
  } else {
#line 98
    extension = (char *)".icd";
  }
#line 99
  goto switch_break;
  case_110: /* CIL Label */ 
#line 101
  if ((unsigned int )rep == 1U) {
#line 102
    extension = (char *)".icd";
  } else {
#line 104
    extension = (char *)".ecd";
  }
#line 105
  goto switch_break;
  case_106: /* CIL Label */ 
#line 107
  if ((unsigned int )rep == 1U) {
#line 108
    extension = (char *)".iad";
  } else {
#line 110
    extension = (char *)".ead";
  }
#line 111
  goto switch_break;
  case_108: /* CIL Label */ 
#line 113
  extension = (char *)".ddl";
#line 113
  goto switch_break;
  case_100: /* CIL Label */ 
#line 115
  extension = (char *)".dex";
#line 115
  goto switch_break;
  case_112: /* CIL Label */ 
#line 117
  extension = (char *)"sub.ine";
#line 117
  goto switch_break;
  case_118: /* CIL Label */ 
#line 119
  extension = (char *)".solved";
#line 119
  goto switch_break;
  case_115: /* CIL Label */ 
#line 121
  extension = (char *)".lps";
#line 121
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 123
  extension = (char *)".xxx";
#line 123
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 125
  dotpos = -1;
#line 126
  i = 0;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 126
    tmp___0 = strlen((char const   *)inputfile);
    }
#line 126
    if (! ((size_t )i < tmp___0)) {
#line 126
      goto while_break___0;
    }
#line 127
    if ((int )*(inputfile + i) == 46) {
#line 127
      dotpos = i;
    }
#line 126
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 129
  if (dotpos > 1) {
    {
#line 129
    strncpy((char */* __restrict  */)(ifilehead), (char const   */* __restrict  */)inputfile,
            (size_t )dotpos);
    }
  } else {
    {
#line 130
    strcpy((char */* __restrict  */)(ifilehead), (char const   */* __restrict  */)inputfile);
    }
  }
  {
#line 131
  tmp___1 = strlen((char const   *)inputfile);
  }
#line 131
  if (tmp___1 <= 0UL) {
    {
#line 131
    strcpy((char */* __restrict  */)(ifilehead), (char const   */* __restrict  */)"tempcdd");
    }
  }
  {
#line 132
  strcpy((char */* __restrict  */)outfile, (char const   */* __restrict  */)(ifilehead));
#line 133
  strcat((char */* __restrict  */)outfile, (char const   */* __restrict  */)extension);
#line 134
  tmp___2 = strcmp((char const   *)inputfile, (char const   *)outfile);
  }
#line 134
  if (tmp___2 == 0) {
    {
#line 135
    strcpy((char */* __restrict  */)outfile, (char const   */* __restrict  */)inputfile);
#line 136
    strcat((char */* __restrict  */)outfile, (char const   */* __restrict  */)extension);
    }
  }
#line 139
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_NumberType ddf_GetNumberType(char const   *line ) 
{ 
  ddf_NumberType nt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 146
  tmp___1 = strncmp(line, "integer", (size_t )7);
  }
#line 146
  if (tmp___1 == 0) {
#line 147
    nt = (ddf_NumberType )3;
  } else {
    {
#line 149
    tmp___0 = strncmp(line, "rational", (size_t )8);
    }
#line 149
    if (tmp___0 == 0) {
#line 150
      nt = (ddf_NumberType )2;
    } else {
      {
#line 152
      tmp = strncmp(line, "real", (size_t )4);
      }
#line 152
      if (tmp == 0) {
#line 153
        nt = (ddf_NumberType )1;
      } else {
#line 156
        nt = (ddf_NumberType )0;
      }
    }
  }
#line 158
  return (nt);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_ProcessCommandLine(FILE *f , ddf_MatrixPtr M , char const   *line ) 
{ 
  char newline[4096] ;
  ddf_colrange j ;
  myfloat value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double rvalue ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 167
  dddf_init((double *)(value));
#line 168
  tmp = strncmp(line, "hull", (size_t )4);
  }
#line 168
  if (tmp == 0) {
#line 169
    M->representation = (ddf_RepresentationType )2;
  }
  {
#line 171
  tmp___0 = strncmp(line, "debug", (size_t )5);
  }
#line 171
  if (tmp___0 == 0) {
#line 172
    ddf_debug = 1;
  }
  {
#line 177
  tmp___1 = strncmp(line, "partial_enum", (size_t )12);
  }
#line 177
  if (tmp___1 == 0) {
    {
#line 180
    fgets((char */* __restrict  */)(newline), 4096, (FILE */* __restrict  */)f);
#line 181
    ddf_SetLinearity(M, newline);
    }
  } else {
    {
#line 177
    tmp___2 = strncmp(line, "equality", (size_t )8);
    }
#line 177
    if (tmp___2 == 0) {
      {
#line 180
      fgets((char */* __restrict  */)(newline), 4096, (FILE */* __restrict  */)f);
#line 181
      ddf_SetLinearity(M, newline);
      }
    } else {
      {
#line 177
      tmp___3 = strncmp(line, "linearity", (size_t )9);
      }
#line 177
      if (tmp___3 == 0) {
        {
#line 180
        fgets((char */* __restrict  */)(newline), 4096, (FILE */* __restrict  */)f);
#line 181
        ddf_SetLinearity(M, newline);
        }
      }
    }
  }
  {
#line 183
  tmp___5 = strncmp(line, "maximize", (size_t )8);
  }
#line 183
  if (tmp___5 == 0) {
#line 183
    goto _L;
  } else {
    {
#line 183
    tmp___6 = strncmp(line, "minimize", (size_t )8);
    }
#line 183
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
      {
#line 185
      tmp___4 = strncmp(line, "maximize", (size_t )8);
      }
#line 185
      if (tmp___4 == 0) {
#line 185
        M->objective = (ddf_LPObjectiveType )1;
      } else {
#line 186
        M->objective = (ddf_LPObjectiveType )2;
      }
#line 187
      j = (ddf_colrange )1;
      {
#line 187
      while (1) {
        while_continue: /* CIL Label */ ;
#line 187
        if (! (j <= M->colsize)) {
#line 187
          goto while_break;
        }
#line 188
        if ((unsigned int )M->numbtype == 1U) {
          {
#line 191
          fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lf",
                 & rvalue);
#line 192
          dddf_set_d((double *)(value), rvalue);
          }
        } else {
          {
#line 195
          ddf_fread_rational_value(f, (double *)(value));
          }
        }
        {
#line 197
        dddf_set((double *)(*(M->rowvec + (j - 1L))), (double *)(value));
        }
#line 198
        if (ddf_debug) {
          {
#line 198
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cost(%5ld) =",
                  j);
#line 198
          ddf_WriteNumber(stderr, (double *)(value));
          }
        }
#line 187
        j ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 201
  dddf_clear((double *)(value));
  }
#line 202
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_boolean ddf_AppendMatrix2Poly(ddf_PolyhedraPtr *poly , ddf_MatrixPtr M ) 
{ 
  ddf_boolean success ;
  ddf_MatrixPtr Mpoly ;
  ddf_MatrixPtr Mnew ;
  ddf_ErrorType err ;

  {
#line 206
  success = 0;
#line 207
  Mnew = (ddf_MatrixPtr )((void *)0);
#line 210
  if ((unsigned long )*poly != (unsigned long )((void *)0)) {
#line 210
    if ((*poly)->m >= 0L) {
#line 210
      if ((*poly)->d >= 0L) {
#line 210
        if ((*poly)->d == M->colsize) {
#line 210
          if (M->rowsize > 0L) {
            {
#line 212
            Mpoly = ddf_CopyInput(*poly);
#line 213
            Mnew = ddf_AppendMatrix(Mpoly, M);
#line 214
            ddf_FreePolyhedra(*poly);
#line 215
            *poly = ddf_DDMatrix2Poly(Mnew, & err);
#line 216
            ddf_FreeMatrix(Mpoly);
#line 217
            ddf_FreeMatrix(Mnew);
            }
#line 218
            if ((unsigned int )err == 17U) {
#line 218
              success = 1;
            }
          }
        }
      }
    }
  }
#line 220
  return (success);
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_MatrixCopy(ddf_MatrixPtr M ) 
{ 
  ddf_MatrixPtr Mcopy ;
  ddf_rowrange m ;
  ddf_colrange d ;

  {
#line 225
  Mcopy = (ddf_MatrixPtr )((void *)0);
#line 229
  m = M->rowsize;
#line 230
  d = M->colsize;
#line 231
  if (m >= 0L) {
#line 231
    if (d >= 0L) {
      {
#line 232
      Mcopy = ddf_CreateMatrix(m, d);
#line 233
      ddf_CopyAmatrix(Mcopy->matrix, M->matrix, m, d);
#line 234
      ddf_CopyArow(Mcopy->rowvec, M->rowvec, d);
#line 235
      set_copy(Mcopy->linset, M->linset);
#line 236
      Mcopy->numbtype = M->numbtype;
#line 237
      Mcopy->representation = M->representation;
#line 238
      Mcopy->objective = M->objective;
      }
    }
  }
#line 240
  return (Mcopy);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_CopyMatrix(ddf_MatrixPtr M ) 
{ 
  ddf_MatrixPtr tmp ;

  {
  {
#line 245
  tmp = ddf_MatrixCopy(M);
  }
#line 245
  return (tmp);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_MatrixNormalizedCopy(ddf_MatrixPtr M ) 
{ 
  ddf_MatrixPtr Mcopy ;
  ddf_rowrange m ;
  ddf_colrange d ;

  {
#line 250
  Mcopy = (ddf_MatrixPtr )((void *)0);
#line 254
  m = M->rowsize;
#line 255
  d = M->colsize;
#line 256
  if (m >= 0L) {
#line 256
    if (d >= 0L) {
      {
#line 257
      Mcopy = ddf_CreateMatrix(m, d);
#line 258
      ddf_CopyNormalizedAmatrix(Mcopy->matrix, M->matrix, m, d);
#line 259
      ddf_CopyArow(Mcopy->rowvec, M->rowvec, d);
#line 260
      set_copy(Mcopy->linset, M->linset);
#line 261
      Mcopy->numbtype = M->numbtype;
#line 262
      Mcopy->representation = M->representation;
#line 263
      Mcopy->objective = M->objective;
      }
    }
  }
#line 265
  return (Mcopy);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_MatrixAppend(ddf_MatrixPtr M1 , ddf_MatrixPtr M2 ) 
{ 
  ddf_MatrixPtr M ;
  ddf_rowrange i ;
  ddf_rowrange m ;
  ddf_rowrange m1 ;
  ddf_rowrange m2 ;
  ddf_colrange j ;
  ddf_colrange d ;
  ddf_colrange d1 ;
  ddf_colrange d2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  M = (ddf_MatrixPtr )((void *)0);
#line 275
  m1 = M1->rowsize;
#line 276
  d1 = M1->colsize;
#line 277
  m2 = M2->rowsize;
#line 278
  d2 = M2->colsize;
#line 280
  m = m1 + m2;
#line 281
  d = d1;
#line 283
  if (d1 >= 0L) {
#line 283
    if (d1 == d2) {
#line 283
      if (m1 >= 0L) {
#line 283
        if (m2 >= 0L) {
          {
#line 284
          M = ddf_CreateMatrix(m, d);
#line 285
          ddf_CopyAmatrix(M->matrix, M1->matrix, m1, d);
#line 286
          ddf_CopyArow(M->rowvec, M1->rowvec, d);
#line 287
          i = (ddf_rowrange )0;
          }
          {
#line 287
          while (1) {
            while_continue: /* CIL Label */ ;
#line 287
            if (! (i < m1)) {
#line 287
              goto while_break;
            }
            {
#line 288
            tmp = set_member(i + 1L, M1->linset);
            }
#line 288
            if (tmp) {
              {
#line 288
              set_addelem(M->linset, i + 1L);
              }
            }
#line 287
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 290
          i = (ddf_rowrange )0;
          {
#line 290
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 290
            if (! (i < m2)) {
#line 290
              goto while_break___0;
            }
#line 291
            j = (ddf_colrange )0;
            {
#line 291
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 291
              if (! (j < d)) {
#line 291
                goto while_break___1;
              }
              {
#line 292
              dddf_set((double *)(*(*(M->matrix + (m1 + i)) + j)), (double *)(*(*(M2->matrix + i) + j)));
#line 291
              j ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 294
            tmp___0 = set_member(i + 1L, M2->linset);
            }
#line 294
            if (tmp___0) {
              {
#line 294
              set_addelem(M->linset, (m1 + i) + 1L);
              }
            }
#line 290
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 296
          M->numbtype = M1->numbtype;
        }
      }
    }
  }
#line 298
  return (M);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_MatrixNormalizedSortedCopy(ddf_MatrixPtr M , ddf_rowindex *newpos ) 
{ 
  ddf_MatrixPtr Mcopy ;
  ddf_MatrixPtr Mnorm ;
  ddf_rowrange m ;
  ddf_rowrange i ;
  ddf_colrange d ;
  ddf_rowindex roworder ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 306
  Mcopy = (ddf_MatrixPtr )((void *)0);
#line 306
  Mnorm = (ddf_MatrixPtr )((void *)0);
#line 312
  m = M->rowsize;
#line 313
  d = M->colsize;
#line 314
  tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 314
  roworder = (long *)tmp;
#line 315
  tmp___0 = calloc((size_t )(m + 1L), sizeof(long ));
#line 315
  *newpos = (long *)tmp___0;
  }
#line 316
  if (m >= 0L) {
#line 316
    if (d >= 0L) {
      {
#line 317
      Mnorm = ddf_MatrixNormalizedCopy(M);
#line 318
      Mcopy = ddf_CreateMatrix(m, d);
#line 319
      i = (ddf_rowrange )1;
      }
      {
#line 319
      while (1) {
        while_continue: /* CIL Label */ ;
#line 319
        if (! (i <= m)) {
#line 319
          goto while_break;
        }
#line 319
        *(roworder + i) = i;
#line 319
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 321
      ddf_RandomPermutation(roworder, m, 123U);
#line 322
      ddf_QuickSort(roworder, 1L, m, Mnorm->matrix, d);
#line 324
      ddf_PermuteCopyAmatrix(Mcopy->matrix, Mnorm->matrix, m, d, roworder);
#line 325
      ddf_CopyArow(Mcopy->rowvec, M->rowvec, d);
#line 326
      i = (ddf_rowrange )1;
      }
      {
#line 326
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 326
        if (! (i <= m)) {
#line 326
          goto while_break___0;
        }
        {
#line 327
        tmp___1 = set_member(*(roworder + i), M->linset);
        }
#line 327
        if (tmp___1) {
          {
#line 327
          set_addelem(Mcopy->linset, i);
          }
        }
#line 328
        *(*newpos + *(roworder + i)) = i;
#line 326
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 330
      Mcopy->numbtype = M->numbtype;
#line 331
      Mcopy->representation = M->representation;
#line 332
      Mcopy->objective = M->objective;
#line 333
      ddf_FreeMatrix(Mnorm);
      }
    }
  }
  {
#line 335
  free((void *)roworder);
  }
#line 336
  return (Mcopy);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_MatrixUniqueCopy(ddf_MatrixPtr M , ddf_rowindex *newpos ) 
{ 
  ddf_MatrixPtr Mcopy ;
  ddf_rowrange m ;
  ddf_rowrange i ;
  ddf_rowrange uniqrows ;
  ddf_rowset preferredrows ;
  ddf_colrange d ;
  ddf_rowindex roworder ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 348
  Mcopy = (ddf_MatrixPtr )((void *)0);
#line 355
  m = M->rowsize;
#line 356
  d = M->colsize;
#line 357
  preferredrows = M->linset;
#line 358
  tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 358
  roworder = (long *)tmp;
  }
#line 359
  if (m >= 0L) {
#line 359
    if (d >= 0L) {
#line 360
      i = (ddf_rowrange )1;
      {
#line 360
      while (1) {
        while_continue: /* CIL Label */ ;
#line 360
        if (! (i <= m)) {
#line 360
          goto while_break;
        }
#line 360
        *(roworder + i) = i;
#line 360
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 361
      ddf_UniqueRows(roworder, 1L, m, M->matrix, d, preferredrows, & uniqrows);
#line 363
      Mcopy = ddf_CreateMatrix(uniqrows, d);
#line 364
      ddf_PermutePartialCopyAmatrix(Mcopy->matrix, M->matrix, m, d, roworder, (ddf_rowrange )1,
                                    m);
#line 365
      ddf_CopyArow(Mcopy->rowvec, M->rowvec, d);
#line 366
      i = (ddf_rowrange )1;
      }
      {
#line 366
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 366
        if (! (i <= m)) {
#line 366
          goto while_break___0;
        }
#line 367
        if (*(roworder + i) > 0L) {
          {
#line 367
          tmp___0 = set_member(i, M->linset);
          }
#line 367
          if (tmp___0) {
            {
#line 367
            set_addelem(Mcopy->linset, *(roworder + i));
            }
          }
        }
#line 366
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 369
      Mcopy->numbtype = M->numbtype;
#line 370
      Mcopy->representation = M->representation;
#line 371
      Mcopy->objective = M->objective;
    }
  }
#line 373
  *newpos = roworder;
#line 374
  return (Mcopy);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_MatrixNormalizedSortedUniqueCopy(ddf_MatrixPtr M , ddf_rowindex *newpos ) 
{ 
  ddf_MatrixPtr M1 ;
  ddf_MatrixPtr M2 ;
  ddf_rowrange m ;
  ddf_rowrange i ;
  ddf_colrange d ;
  ddf_rowindex newpos1 ;
  ddf_rowindex newpos1r ;
  ddf_rowindex newpos2 ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 387
  M1 = (ddf_MatrixPtr )((void *)0);
#line 387
  M2 = (ddf_MatrixPtr )((void *)0);
#line 390
  newpos1 = (ddf_rowindex )((void *)0);
#line 390
  newpos1r = (ddf_rowindex )((void *)0);
#line 390
  newpos2 = (ddf_rowindex )((void *)0);
#line 393
  m = M->rowsize;
#line 394
  d = M->colsize;
#line 395
  tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 395
  *newpos = (long *)tmp;
#line 396
  tmp___0 = calloc((size_t )(m + 1L), sizeof(long ));
#line 396
  newpos1r = (long *)tmp___0;
  }
#line 397
  if (m >= 0L) {
#line 397
    if (d >= 0L) {
      {
#line 398
      M1 = ddf_MatrixNormalizedSortedCopy(M, & newpos1);
#line 399
      i = (ddf_rowrange )1;
      }
      {
#line 399
      while (1) {
        while_continue: /* CIL Label */ ;
#line 399
        if (! (i <= m)) {
#line 399
          goto while_break;
        }
#line 399
        *(newpos1r + *(newpos1 + i)) = i;
#line 399
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 400
      M2 = ddf_MatrixUniqueCopy(M1, & newpos2);
#line 401
      set_emptyset(M2->linset);
#line 402
      i = (ddf_rowrange )1;
      }
      {
#line 402
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 402
        if (! (i <= m)) {
#line 402
          goto while_break___0;
        }
#line 403
        if (*(newpos2 + *(newpos1 + i)) > 0L) {
          {
#line 404
          printf((char const   */* __restrict  */)"newpos1[%ld]=%ld, newpos2[newpos1[%ld]]=%ld\n",
                 i, *(newpos1 + i), i, *(newpos2 + *(newpos1 + i)));
#line 405
          tmp___1 = set_member(i, M->linset);
          }
#line 405
          if (tmp___1) {
            {
#line 405
            set_addelem(M2->linset, *(newpos2 + *(newpos1 + i)));
            }
          }
#line 406
          *(*newpos + i) = *(newpos2 + *(newpos1 + i));
        } else {
#line 408
          *(*newpos + i) = - *(newpos1r + - *(newpos2 + *(newpos1 + i)));
        }
#line 402
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 411
      ddf_FreeMatrix(M1);
#line 411
      free((void *)newpos1);
#line 411
      free((void *)newpos2);
#line 411
      free((void *)newpos1r);
      }
    }
  }
#line 414
  return (M2);
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_MatrixSortedUniqueCopy(ddf_MatrixPtr M , ddf_rowindex *newpos ) 
{ 
  ddf_MatrixPtr M1 ;
  ddf_MatrixPtr M2 ;
  ddf_rowrange m ;
  ddf_rowrange i ;
  ddf_rowrange k ;
  ddf_rowrange ii ;
  ddf_colrange d ;
  ddf_rowindex newpos1 ;
  ddf_rowindex newpos1r ;
  ddf_rowindex newpos2 ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 422
  M1 = (ddf_MatrixPtr )((void *)0);
#line 422
  M2 = (ddf_MatrixPtr )((void *)0);
#line 425
  newpos1 = (ddf_rowindex )((void *)0);
#line 425
  newpos1r = (ddf_rowindex )((void *)0);
#line 425
  newpos2 = (ddf_rowindex )((void *)0);
#line 428
  m = M->rowsize;
#line 429
  d = M->colsize;
#line 430
  tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 430
  *newpos = (long *)tmp;
#line 431
  tmp___0 = calloc((size_t )(m + 1L), sizeof(long ));
#line 431
  newpos1r = (long *)tmp___0;
  }
#line 432
  if (m >= 0L) {
#line 432
    if (d >= 0L) {
      {
#line 433
      M1 = ddf_MatrixNormalizedSortedCopy(M, & newpos1);
#line 434
      i = (ddf_rowrange )1;
      }
      {
#line 434
      while (1) {
        while_continue: /* CIL Label */ ;
#line 434
        if (! (i <= m)) {
#line 434
          goto while_break;
        }
#line 434
        *(newpos1r + *(newpos1 + i)) = i;
#line 434
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 435
      M2 = ddf_MatrixUniqueCopy(M1, & newpos2);
#line 436
      ddf_FreeMatrix(M1);
#line 437
      set_emptyset(M2->linset);
#line 438
      i = (ddf_rowrange )1;
      }
      {
#line 438
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 438
        if (! (i <= m)) {
#line 438
          goto while_break___0;
        }
#line 439
        if (*(newpos2 + *(newpos1 + i)) > 0L) {
          {
#line 440
          tmp___1 = set_member(i, M->linset);
          }
#line 440
          if (tmp___1) {
            {
#line 440
            set_addelem(M2->linset, *(newpos2 + *(newpos1 + i)));
            }
          }
#line 441
          *(*newpos + i) = *(newpos2 + *(newpos1 + i));
        } else {
#line 443
          *(*newpos + i) = - *(newpos1r + - *(newpos2 + *(newpos1 + i)));
        }
#line 438
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 447
      ii = (ddf_rowrange )0;
#line 448
      set_emptyset(M2->linset);
#line 449
      i = (ddf_rowrange )1;
      }
      {
#line 449
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 449
        if (! (i <= m)) {
#line 449
          goto while_break___1;
        }
#line 450
        k = *(*newpos + i);
#line 451
        if (k > 0L) {
          {
#line 452
          ii ++;
#line 453
          *(*newpos + i) = ii;
#line 454
          ddf_CopyArow(*(M2->matrix + (ii - 1L)), *(M->matrix + (i - 1L)), d);
#line 455
          tmp___2 = set_member(i, M->linset);
          }
#line 455
          if (tmp___2) {
            {
#line 455
            set_addelem(M2->linset, ii);
            }
          }
        }
#line 449
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 459
      free((void *)newpos1);
#line 459
      free((void *)newpos2);
#line 459
      free((void *)newpos1r);
      }
    }
  }
#line 462
  return (M2);
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_AppendMatrix(ddf_MatrixPtr M1 , ddf_MatrixPtr M2 ) 
{ 
  ddf_MatrixPtr tmp ;

  {
  {
#line 467
  tmp = ddf_MatrixAppend(M1, M2);
  }
#line 467
  return (tmp);
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
int ddf_MatrixAppendTo(ddf_MatrixPtr *M1 , ddf_MatrixPtr M2 ) 
{ 
  ddf_MatrixPtr M ;
  ddf_rowrange i ;
  ddf_rowrange m ;
  ddf_rowrange m1 ;
  ddf_rowrange m2 ;
  ddf_colrange j ;
  ddf_colrange d ;
  ddf_colrange d1 ;
  ddf_colrange d2 ;
  ddf_boolean success ;
  int tmp ;
  int tmp___0 ;

  {
#line 472
  M = (ddf_MatrixPtr )((void *)0);
#line 475
  success = 0;
#line 477
  m1 = (*M1)->rowsize;
#line 478
  d1 = (*M1)->colsize;
#line 479
  m2 = M2->rowsize;
#line 480
  d2 = M2->colsize;
#line 482
  m = m1 + m2;
#line 483
  d = d1;
#line 485
  if (d1 >= 0L) {
#line 485
    if (d1 == d2) {
#line 485
      if (m1 >= 0L) {
#line 485
        if (m2 >= 0L) {
          {
#line 486
          M = ddf_CreateMatrix(m, d);
#line 487
          ddf_CopyAmatrix(M->matrix, (*M1)->matrix, m1, d);
#line 488
          ddf_CopyArow(M->rowvec, (*M1)->rowvec, d);
#line 489
          i = (ddf_rowrange )0;
          }
          {
#line 489
          while (1) {
            while_continue: /* CIL Label */ ;
#line 489
            if (! (i < m1)) {
#line 489
              goto while_break;
            }
            {
#line 490
            tmp = set_member(i + 1L, (*M1)->linset);
            }
#line 490
            if (tmp) {
              {
#line 490
              set_addelem(M->linset, i + 1L);
              }
            }
#line 489
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 492
          i = (ddf_rowrange )0;
          {
#line 492
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 492
            if (! (i < m2)) {
#line 492
              goto while_break___0;
            }
#line 493
            j = (ddf_colrange )0;
            {
#line 493
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 493
              if (! (j < d)) {
#line 493
                goto while_break___1;
              }
              {
#line 494
              dddf_set((double *)(*(*(M->matrix + (m1 + i)) + j)), (double *)(*(*(M2->matrix + i) + j)));
#line 493
              j ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 496
            tmp___0 = set_member(i + 1L, M2->linset);
            }
#line 496
            if (tmp___0) {
              {
#line 496
              set_addelem(M->linset, (m1 + i) + 1L);
              }
            }
#line 492
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 498
          M->numbtype = (*M1)->numbtype;
#line 499
          ddf_FreeMatrix(*M1);
#line 500
          *M1 = M;
#line 501
          success = 1;
          }
        }
      }
    }
  }
#line 503
  return (success);
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
int ddf_MatrixRowRemove(ddf_MatrixPtr *M , ddf_rowrange r ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange m ;
  ddf_colrange d ;
  ddf_boolean success ;
  int tmp ;

  {
#line 510
  success = 0;
#line 512
  m = (*M)->rowsize;
#line 513
  d = (*M)->colsize;
#line 515
  if (r >= 1L) {
#line 515
    if (r <= m) {
      {
#line 516
      (*M)->rowsize = m - 1L;
#line 517
      ddf_FreeArow(d, *((*M)->matrix + (r - 1L)));
#line 518
      set_delelem((*M)->linset, r);
#line 520
      i = r;
      }
      {
#line 520
      while (1) {
        while_continue: /* CIL Label */ ;
#line 520
        if (! (i < m)) {
#line 520
          goto while_break;
        }
        {
#line 521
        *((*M)->matrix + (i - 1L)) = *((*M)->matrix + i);
#line 522
        tmp = set_member(i + 1L, (*M)->linset);
        }
#line 522
        if (tmp) {
          {
#line 523
          set_delelem((*M)->linset, i + 1L);
#line 524
          set_addelem((*M)->linset, i);
          }
        }
#line 520
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 527
      success = 1;
    }
  }
#line 529
  return (success);
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
int ddf_MatrixRowRemove2(ddf_MatrixPtr *M , ddf_rowrange r , ddf_rowindex *newpos ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange m ;
  ddf_colrange d ;
  ddf_boolean success ;
  ddf_rowindex roworder ;
  void *tmp ;
  int tmp___0 ;

  {
#line 536
  success = 0;
#line 539
  m = (*M)->rowsize;
#line 540
  d = (*M)->colsize;
#line 542
  if (r >= 1L) {
#line 542
    if (r <= m) {
      {
#line 543
      tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 543
      roworder = (long *)tmp;
#line 544
      (*M)->rowsize = m - 1L;
#line 545
      ddf_FreeArow(d, *((*M)->matrix + (r - 1L)));
#line 546
      set_delelem((*M)->linset, r);
#line 548
      i = (ddf_rowrange )1;
      }
      {
#line 548
      while (1) {
        while_continue: /* CIL Label */ ;
#line 548
        if (! (i < r)) {
#line 548
          goto while_break;
        }
#line 548
        *(roworder + i) = i;
#line 548
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 549
      *(roworder + r) = 0L;
#line 550
      i = r;
      {
#line 550
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 550
        if (! (i < m)) {
#line 550
          goto while_break___0;
        }
        {
#line 551
        *((*M)->matrix + (i - 1L)) = *((*M)->matrix + i);
#line 552
        *(roworder + (i + 1L)) = i;
#line 553
        tmp___0 = set_member(i + 1L, (*M)->linset);
        }
#line 553
        if (tmp___0) {
          {
#line 554
          set_delelem((*M)->linset, i + 1L);
#line 555
          set_addelem((*M)->linset, i);
          }
        }
#line 550
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 558
      success = 1;
    }
  }
#line 560
  return (success);
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_MatrixSubmatrix(ddf_MatrixPtr M , ddf_rowset delset ) 
{ 
  ddf_MatrixPtr Msub ;
  ddf_rowrange i ;
  ddf_rowrange isub ;
  ddf_rowrange m ;
  ddf_rowrange msub ;
  ddf_colrange d ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 565
  Msub = (ddf_MatrixPtr )((void *)0);
#line 566
  isub = (ddf_rowrange )1;
#line 569
  m = M->rowsize;
#line 570
  d = M->colsize;
#line 571
  msub = m;
#line 572
  if (m >= 0L) {
#line 572
    if (d >= 0L) {
#line 573
      i = (ddf_rowrange )1;
      {
#line 573
      while (1) {
        while_continue: /* CIL Label */ ;
#line 573
        if (! (i <= m)) {
#line 573
          goto while_break;
        }
        {
#line 574
        tmp = set_member(i, delset);
        }
#line 574
        if (tmp) {
#line 574
          msub --;
        }
#line 573
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 576
      Msub = ddf_CreateMatrix(msub, d);
#line 577
      i = (ddf_rowrange )1;
      }
      {
#line 577
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 577
        if (! (i <= m)) {
#line 577
          goto while_break___0;
        }
        {
#line 578
        tmp___1 = set_member(i, delset);
        }
#line 578
        if (! tmp___1) {
          {
#line 579
          ddf_CopyArow(*(Msub->matrix + (isub - 1L)), *(M->matrix + (i - 1L)), d);
#line 580
          tmp___0 = set_member(i, M->linset);
          }
#line 580
          if (tmp___0) {
            {
#line 581
            set_addelem(Msub->linset, isub);
            }
          }
#line 583
          isub ++;
        }
#line 577
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 586
      ddf_CopyArow(Msub->rowvec, M->rowvec, d);
#line 587
      Msub->numbtype = M->numbtype;
#line 588
      Msub->representation = M->representation;
#line 589
      Msub->objective = M->objective;
      }
    }
  }
#line 591
  return (Msub);
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_MatrixSubmatrix2(ddf_MatrixPtr M , ddf_rowset delset , ddf_rowindex *newpos ) 
{ 
  ddf_MatrixPtr Msub ;
  ddf_rowrange i ;
  ddf_rowrange isub ;
  ddf_rowrange m ;
  ddf_rowrange msub ;
  ddf_colrange d ;
  ddf_rowindex roworder ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 600
  Msub = (ddf_MatrixPtr )((void *)0);
#line 601
  isub = (ddf_rowrange )1;
#line 605
  m = M->rowsize;
#line 606
  d = M->colsize;
#line 607
  msub = m;
#line 608
  if (m >= 0L) {
#line 608
    if (d >= 0L) {
      {
#line 609
      tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 609
      roworder = (long *)tmp;
#line 610
      i = (ddf_rowrange )1;
      }
      {
#line 610
      while (1) {
        while_continue: /* CIL Label */ ;
#line 610
        if (! (i <= m)) {
#line 610
          goto while_break;
        }
        {
#line 611
        tmp___0 = set_member(i, delset);
        }
#line 611
        if (tmp___0) {
#line 611
          msub --;
        }
#line 610
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 613
      Msub = ddf_CreateMatrix(msub, d);
#line 614
      i = (ddf_rowrange )1;
      }
      {
#line 614
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 614
        if (! (i <= m)) {
#line 614
          goto while_break___0;
        }
        {
#line 615
        tmp___2 = set_member(i, delset);
        }
#line 615
        if (tmp___2) {
#line 616
          *(roworder + i) = 0L;
        } else {
          {
#line 618
          ddf_CopyArow(*(Msub->matrix + (isub - 1L)), *(M->matrix + (i - 1L)), d);
#line 619
          tmp___1 = set_member(i, M->linset);
          }
#line 619
          if (tmp___1) {
            {
#line 620
            set_addelem(Msub->linset, isub);
            }
          }
#line 622
          *(roworder + i) = isub;
#line 623
          isub ++;
        }
#line 614
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 626
      *newpos = roworder;
#line 627
      ddf_CopyArow(Msub->rowvec, M->rowvec, d);
#line 628
      Msub->numbtype = M->numbtype;
#line 629
      Msub->representation = M->representation;
#line 630
      Msub->objective = M->objective;
      }
    }
  }
#line 632
  return (Msub);
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_MatrixSubmatrix2L(ddf_MatrixPtr M , ddf_rowset delset , ddf_rowindex *newpos ) 
{ 
  ddf_MatrixPtr Msub ;
  ddf_rowrange i ;
  ddf_rowrange iL ;
  ddf_rowrange iI ;
  ddf_rowrange m ;
  ddf_rowrange msub ;
  ddf_colrange d ;
  ddf_rowindex roworder ;
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 640
  Msub = (ddf_MatrixPtr )((void *)0);
#line 645
  m = M->rowsize;
#line 646
  d = M->colsize;
#line 647
  msub = m;
#line 648
  if (m >= 0L) {
#line 648
    if (d >= 0L) {
      {
#line 649
      tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 649
      roworder = (long *)tmp;
#line 650
      i = (ddf_rowrange )1;
      }
      {
#line 650
      while (1) {
        while_continue: /* CIL Label */ ;
#line 650
        if (! (i <= m)) {
#line 650
          goto while_break;
        }
        {
#line 651
        tmp___0 = set_member(i, delset);
        }
#line 651
        if (tmp___0) {
#line 651
          msub --;
        }
#line 650
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 653
      Msub = ddf_CreateMatrix(msub, d);
#line 654
      iL = (ddf_rowrange )1;
#line 654
      tmp___1 = set_card(M->linset);
#line 654
      iI = tmp___1 + 1L;
#line 655
      i = (ddf_rowrange )1;
      }
      {
#line 655
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 655
        if (! (i <= m)) {
#line 655
          goto while_break___0;
        }
        {
#line 656
        tmp___3 = set_member(i, delset);
        }
#line 656
        if (tmp___3) {
#line 657
          *(roworder + i) = 0L;
        } else {
          {
#line 659
          tmp___2 = set_member(i, M->linset);
          }
#line 659
          if (tmp___2) {
            {
#line 660
            ddf_CopyArow(*(Msub->matrix + (iL - 1L)), *(M->matrix + (i - 1L)), d);
#line 661
            set_delelem(Msub->linset, i);
#line 662
            set_addelem(Msub->linset, iL);
#line 663
            *(roworder + i) = iL;
#line 664
            iL ++;
            }
          } else {
            {
#line 666
            ddf_CopyArow(*(Msub->matrix + (iI - 1L)), *(M->matrix + (i - 1L)), d);
#line 667
            *(roworder + i) = iI;
#line 668
            iI ++;
            }
          }
        }
#line 655
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 672
      *newpos = roworder;
#line 673
      ddf_CopyArow(Msub->rowvec, M->rowvec, d);
#line 674
      Msub->numbtype = M->numbtype;
#line 675
      Msub->representation = M->representation;
#line 676
      Msub->objective = M->objective;
      }
    }
  }
#line 678
  return (Msub);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
int ddf_MatrixRowsRemove(ddf_MatrixPtr *M , ddf_rowset delset ) 
{ 
  ddf_MatrixPtr Msub ;
  int success ;

  {
  {
#line 683
  Msub = (ddf_MatrixPtr )((void *)0);
#line 686
  Msub = ddf_MatrixSubmatrix(*M, delset);
#line 687
  ddf_FreeMatrix(*M);
#line 688
  *M = Msub;
#line 689
  success = 1;
  }
#line 690
  return (success);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
int ddf_MatrixRowsRemove2(ddf_MatrixPtr *M , ddf_rowset delset , ddf_rowindex *newpos ) 
{ 
  ddf_MatrixPtr Msub ;
  int success ;

  {
  {
#line 695
  Msub = (ddf_MatrixPtr )((void *)0);
#line 698
  Msub = ddf_MatrixSubmatrix2(*M, delset, newpos);
#line 699
  ddf_FreeMatrix(*M);
#line 700
  *M = Msub;
#line 701
  success = 1;
  }
#line 702
  return (success);
}
}
#line 705 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
int ddf_MatrixShiftupLinearity(ddf_MatrixPtr *M , ddf_rowindex *newpos ) 
{ 
  ddf_MatrixPtr Msub ;
  int success ;
  ddf_rowset delset ;

  {
  {
#line 707
  Msub = (ddf_MatrixPtr )((void *)0);
#line 711
  set_initialize(& delset, (*M)->rowsize);
#line 712
  Msub = ddf_MatrixSubmatrix2L(*M, delset, newpos);
#line 713
  ddf_FreeMatrix(*M);
#line 714
  *M = Msub;
#line 716
  set_free(delset);
#line 717
  success = 1;
  }
#line 718
  return (success);
}
}
#line 721 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_PolyhedraPtr ddf_CreatePolyhedraData(ddf_rowrange m , ddf_colrange d ) 
{ 
  ddf_rowrange i ;
  ddf_PolyhedraPtr poly ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 724
  poly = (ddf_PolyhedraPtr )((void *)0);
#line 726
  tmp = malloc(sizeof(ddf_PolyhedraType ));
#line 726
  poly = (ddf_PolyhedraPtr )tmp;
#line 727
  poly->child = (ddf_ConePtr )((void *)0);
#line 728
  poly->m = m;
#line 729
  poly->d = d;
#line 730
  poly->n = (ddf_bigrange )-1;
#line 731
  poly->m_alloc = m + 2L;
#line 732
  poly->d_alloc = d;
#line 733
  poly->ldim = (ddf_colrange )0;
#line 734
  poly->numbtype = (ddf_NumberType )1;
#line 735
  ddf_InitializeAmatrix(poly->m_alloc, poly->d_alloc, & poly->A);
#line 736
  ddf_InitializeArow(d, & poly->c);
#line 737
  poly->representation = (ddf_RepresentationType )1;
#line 738
  poly->homogeneous = 0;
#line 740
  tmp___0 = calloc((size_t )(m + 2L), sizeof(int ));
#line 740
  poly->EqualityIndex = (int *)tmp___0;
#line 744
  i = (ddf_rowrange )0;
  }
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 744
    if (! (i <= m + 1L)) {
#line 744
      goto while_break;
    }
#line 744
    *(poly->EqualityIndex + i) = 0;
#line 744
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 746
  poly->IsEmpty = -1;
#line 748
  poly->NondegAssumed = 0;
#line 749
  poly->InitBasisAtBottom = 0;
#line 750
  poly->RestrictedEnumeration = 0;
#line 751
  poly->RelaxedEnumeration = 0;
#line 753
  poly->AincGenerated = 0;
#line 755
  return (poly);
}
}
#line 758 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_boolean ddf_InitializeConeData(ddf_rowrange m , ddf_colrange d , ddf_ConePtr *cone ) 
{ 
  ddf_boolean success ;
  ddf_colrange j ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 760
  success = 1;
#line 763
  tmp = calloc((size_t )1, sizeof(ddf_ConeType ));
#line 763
  *cone = (ddf_ConePtr )tmp;
#line 766
  (*cone)->m = m;
#line 767
  (*cone)->d = d;
#line 768
  (*cone)->m_alloc = m + 2L;
#line 769
  (*cone)->d_alloc = d;
#line 770
  (*cone)->numbtype = (ddf_NumberType )1;
#line 771
  (*cone)->parent = (ddf_PolyhedraPtr )((void *)0);
#line 774
  (*cone)->Iteration = (ddf_rowrange )0;
#line 776
  (*cone)->HalfspaceOrder = (ddf_RowOrderType )5;
#line 778
  (*cone)->ArtificialRay = (ddf_RayPtr )((void *)0);
#line 779
  (*cone)->FirstRay = (ddf_RayPtr )((void *)0);
#line 780
  (*cone)->LastRay = (ddf_RayPtr )((void *)0);
#line 781
  (*cone)->PosHead = (ddf_RayPtr )((void *)0);
#line 782
  (*cone)->ZeroHead = (ddf_RayPtr )((void *)0);
#line 783
  (*cone)->NegHead = (ddf_RayPtr )((void *)0);
#line 784
  (*cone)->PosLast = (ddf_RayPtr )((void *)0);
#line 785
  (*cone)->ZeroLast = (ddf_RayPtr )((void *)0);
#line 786
  (*cone)->NegLast = (ddf_RayPtr )((void *)0);
#line 787
  (*cone)->RecomputeRowOrder = 1;
#line 788
  (*cone)->PreOrderedRun = 0;
#line 789
  set_initialize(& (*cone)->GroundSet, (*cone)->m_alloc);
#line 790
  set_initialize(& (*cone)->EqualitySet, (*cone)->m_alloc);
#line 791
  set_initialize(& (*cone)->NonequalitySet, (*cone)->m_alloc);
#line 792
  set_initialize(& (*cone)->AddedHalfspaces, (*cone)->m_alloc);
#line 793
  set_initialize(& (*cone)->WeaklyAddedHalfspaces, (*cone)->m_alloc);
#line 794
  set_initialize(& (*cone)->InitialHalfspaces, (*cone)->m_alloc);
#line 795
  (*cone)->RayCount = 0L;
#line 796
  (*cone)->FeasibleRayCount = 0L;
#line 797
  (*cone)->WeaklyFeasibleRayCount = 0L;
#line 798
  (*cone)->TotalRayCount = 0L;
#line 799
  (*cone)->ZeroRayCount = 0L;
#line 800
  (*cone)->EdgeCount = 0L;
#line 801
  (*cone)->TotalEdgeCount = 0L;
#line 802
  (*cone)->count_int = 0L;
#line 803
  (*cone)->count_int_good = 0L;
#line 804
  (*cone)->count_int_bad = 0L;
#line 805
  (*cone)->rseed = 1U;
#line 807
  ddf_InitializeBmatrix((*cone)->d_alloc, & (*cone)->B);
#line 808
  ddf_InitializeBmatrix((*cone)->d_alloc, & (*cone)->Bsave);
#line 809
  ddf_InitializeAmatrix((*cone)->m_alloc, (*cone)->d_alloc, & (*cone)->A);
#line 811
  tmp___0 = calloc((size_t )(*cone)->m_alloc, sizeof(ddf_AdjacencyType *));
#line 811
  (*cone)->Edges = (ddf_AdjacencyType **)tmp___0;
#line 813
  tmp___1 = calloc((size_t )(d + 1L), sizeof(long ));
#line 813
  (*cone)->InitialRayIndex = (long *)tmp___1;
#line 814
  tmp___2 = calloc((size_t )((*cone)->m_alloc + 1L), sizeof(long ));
#line 814
  (*cone)->OrderVector = (long *)tmp___2;
#line 816
  tmp___3 = calloc((size_t )((*cone)->d + 1L), sizeof(long ));
#line 816
  (*cone)->newcol = (long *)tmp___3;
#line 817
  j = (ddf_colrange )0;
  }
  {
#line 817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 817
    if (! (j <= (*cone)->d)) {
#line 817
      goto while_break;
    }
#line 817
    *((*cone)->newcol + j) = j;
#line 817
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 818
  (*cone)->LinearityDim = (ddf_bigrange )-2;
#line 819
  (*cone)->ColReduced = 0;
#line 820
  (*cone)->d_orig = d;
#line 829
  return (success);
}
}
#line 832 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_ConePtr ddf_ConeDataLoad(ddf_PolyhedraPtr poly ) 
{ 
  ddf_ConePtr cone ;
  ddf_colrange d ;
  ddf_colrange j ;
  ddf_rowrange m ;
  ddf_rowrange i ;

  {
#line 834
  cone = (ddf_ConePtr )((void *)0);
#line 838
  m = poly->m;
#line 839
  d = poly->d;
#line 840
  if (! poly->homogeneous) {
#line 840
    if ((unsigned int )poly->representation == 1U) {
#line 841
      m = poly->m + 1L;
    }
  }
  {
#line 843
  poly->m1 = m;
#line 845
  ddf_InitializeConeData(m, d, & cone);
#line 846
  cone->representation = poly->representation;
#line 849
  cone->parent = poly;
#line 850
  poly->child = cone;
#line 852
  i = (ddf_rowrange )1;
  }
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (! (i <= poly->m)) {
#line 852
      goto while_break;
    }
#line 853
    j = (ddf_colrange )1;
    {
#line 853
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 853
      if (! (j <= cone->d)) {
#line 853
        goto while_break___0;
      }
      {
#line 854
      dddf_set((double *)(*(*(cone->A + (i - 1L)) + (j - 1L))), (double *)(*(*(poly->A + (i - 1L)) + (j - 1L))));
#line 853
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 852
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 856
  if ((unsigned int )poly->representation == 1U) {
#line 856
    if (! poly->homogeneous) {
      {
#line 857
      dddf_set((double *)(*(*(cone->A + (m - 1L)) + 0)), (double *)(ddf_one));
#line 858
      j = (ddf_colrange )2;
      }
      {
#line 858
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 858
        if (! (j <= d)) {
#line 858
          goto while_break___1;
        }
        {
#line 858
        dddf_set((double *)(*(*(cone->A + (m - 1L)) + (j - 1L))), (double *)(ddf_purezero));
#line 858
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 861
  return (cone);
}
}
#line 864 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_SetLinearity(ddf_MatrixPtr M , char *line ) 
{ 
  int i ;
  ddf_rowrange eqsize ;
  ddf_rowrange var ;
  char *next ;
  char ct[3] ;

  {
  {
#line 866
  i = 0;
#line 869
  ct[0] = (char )',';
#line 869
  ct[1] = (char )' ';
#line 869
  ct[2] = (char )'\000';
#line 871
  next = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)(ct));
#line 872
  eqsize = atol((char const   *)next);
  }
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 873
    if ((ddf_rowrange )i < eqsize) {
      {
#line 873
      next = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)(ct));
      }
#line 873
      if (! ((unsigned long )next != (unsigned long )((void *)0))) {
#line 873
        goto while_break;
      }
    } else {
#line 873
      goto while_break;
    }
    {
#line 874
    var = atol((char const   *)next);
#line 875
    set_addelem(M->linset, var);
#line 875
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 877
  if ((ddf_rowrange )i != eqsize) {
    {
#line 878
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"* Warning: there are inconsistencies in linearity setting.\n");
    }
  }
#line 880
  return;
}
}
#line 883 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_PolyFile2Matrix(FILE *f , ddf_ErrorType *Error ) 
{ 
  ddf_MatrixPtr M ;
  ddf_rowrange m_input ;
  ddf_rowrange i ;
  ddf_colrange d_input ;
  ddf_colrange j ;
  ddf_RepresentationType rep ;
  myfloat value ;
  ddf_boolean found ;
  ddf_boolean newformat ;
  ddf_boolean successful ;
  ddf_boolean linearity ;
  char command[4096] ;
  char comsave[4096] ;
  char numbtype[1024] ;
  ddf_NumberType NT ;
  double rvalue ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 885
  M = (ddf_MatrixPtr )((void *)0);
#line 888
  rep = (ddf_RepresentationType )1;
#line 890
  found = 0;
#line 890
  newformat = 0;
#line 890
  successful = 0;
#line 890
  linearity = 0;
#line 897
  dddf_init((double *)(value));
#line 898
  *Error = (ddf_ErrorType )17;
  }
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 899
    if (! (! found)) {
#line 899
      goto while_break;
    }
    {
#line 901
    tmp___5 = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s",
                     command);
    }
#line 901
    if (tmp___5 == -1) {
#line 902
      *Error = (ddf_ErrorType )1;
#line 903
      goto _L99;
    } else {
      {
#line 906
      tmp = strncmp((char const   *)(command), "V-representation", (size_t )16);
      }
#line 906
      if (tmp == 0) {
#line 907
        rep = (ddf_RepresentationType )2;
#line 907
        newformat = 1;
      }
      {
#line 909
      tmp___0 = strncmp((char const   *)(command), "H-representation", (size_t )16);
      }
#line 909
      if (tmp___0 == 0) {
#line 910
        rep = (ddf_RepresentationType )1;
#line 910
        newformat = 1;
      }
      {
#line 912
      tmp___1 = strncmp((char const   *)(command), "partial_enum", (size_t )12);
      }
#line 912
      if (tmp___1 == 0) {
        {
#line 915
        linearity = 1;
#line 916
        fgets((char */* __restrict  */)(comsave), 4096, (FILE */* __restrict  */)f);
        }
      } else {
        {
#line 912
        tmp___2 = strncmp((char const   *)(command), "equality", (size_t )8);
        }
#line 912
        if (tmp___2 == 0) {
          {
#line 915
          linearity = 1;
#line 916
          fgets((char */* __restrict  */)(comsave), 4096, (FILE */* __restrict  */)f);
          }
        } else {
          {
#line 912
          tmp___3 = strncmp((char const   *)(command), "linearity", (size_t )9);
          }
#line 912
          if (tmp___3 == 0) {
            {
#line 915
            linearity = 1;
#line 916
            fgets((char */* __restrict  */)(comsave), 4096, (FILE */* __restrict  */)f);
            }
          }
        }
      }
      {
#line 918
      tmp___4 = strncmp((char const   *)(command), "begin", (size_t )5);
      }
#line 918
      if (tmp___4 == 0) {
#line 918
        found = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 921
  fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld %ld %s",
         & m_input, & d_input, numbtype);
#line 922
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"size = %ld x %ld\nNumber Type = %s\n",
          m_input, d_input, numbtype);
#line 923
  NT = ddf_GetNumberType((char const   *)(numbtype));
  }
#line 924
  if ((unsigned int )NT == 0U) {
#line 925
    *Error = (ddf_ErrorType )1;
#line 926
    goto _L99;
  }
  {
#line 928
  M = ddf_CreateMatrix(m_input, d_input);
#line 929
  M->representation = rep;
#line 930
  M->numbtype = NT;
#line 932
  i = (ddf_rowrange )1;
  }
  {
#line 932
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 932
    if (! (i <= m_input)) {
#line 932
      goto while_break___0;
    }
#line 933
    j = (ddf_colrange )1;
    {
#line 933
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 933
      if (! (j <= d_input)) {
#line 933
        goto while_break___1;
      }
#line 934
      if ((unsigned int )NT == 1U) {
        {
#line 939
        fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lf",
               & rvalue);
#line 940
        dddf_set_d((double *)(value), rvalue);
        }
      } else {
        {
#line 943
        ddf_fread_rational_value(f, (double *)(value));
        }
      }
      {
#line 945
      dddf_set((double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))), (double *)(value));
      }
#line 946
      if (ddf_debug) {
        {
#line 946
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"a(%3ld,%5ld) = ",
                i, j);
#line 946
        ddf_WriteNumber(stderr, (double *)(value));
        }
      }
#line 933
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 932
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 949
  tmp___7 = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s",
                   command);
  }
#line 949
  if (tmp___7 == -1) {
#line 950
    *Error = (ddf_ErrorType )1;
#line 951
    goto _L99;
  } else {
    {
#line 953
    tmp___6 = strncmp((char const   *)(command), "end", (size_t )3);
    }
#line 953
    if (tmp___6 != 0) {
#line 954
      if (ddf_debug) {
        {
#line 954
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'end\' missing or illegal extra data: %s\n",
                command);
        }
      }
#line 955
      *Error = (ddf_ErrorType )1;
#line 956
      goto _L99;
    }
  }
#line 959
  successful = 1;
#line 960
  if (linearity) {
    {
#line 961
    ddf_SetLinearity(M, comsave);
    }
  }
  {
#line 963
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 963
    tmp___8 = feof(f);
    }
#line 963
    if (tmp___8) {
#line 963
      goto while_break___2;
    }
    {
#line 964
    fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s", command);
#line 965
    ddf_ProcessCommandLine(f, M, (char const   *)(command));
#line 966
    fgets((char */* __restrict  */)(command), 4096, (FILE */* __restrict  */)f);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  _L99: 
  {
#line 970
  dddf_clear((double *)(value));
  }
#line 972
  return (M);
}
}
#line 976 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_PolyhedraPtr ddf_DDMatrix2Poly(ddf_MatrixPtr M , ddf_ErrorType *err ) 
{ 
  ddf_rowrange i ;
  ddf_colrange j ;
  ddf_PolyhedraPtr poly ;
  int tmp ;
  ddf_boolean tmp___0 ;

  {
#line 980
  poly = (ddf_PolyhedraPtr )((void *)0);
#line 982
  *err = (ddf_ErrorType )17;
#line 983
  if (M->rowsize < 0L) {
#line 984
    *err = (ddf_ErrorType )2;
#line 985
    goto _L99;
  } else
#line 983
  if (M->colsize < 0L) {
#line 984
    *err = (ddf_ErrorType )2;
#line 985
    goto _L99;
  }
  {
#line 987
  poly = ddf_CreatePolyhedraData(M->rowsize, M->colsize);
#line 988
  poly->representation = M->representation;
#line 989
  poly->homogeneous = 1;
#line 991
  i = (ddf_rowrange )1;
  }
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 991
    if (! (i <= M->rowsize)) {
#line 991
      goto while_break;
    }
    {
#line 992
    tmp = set_member(i, M->linset);
    }
#line 992
    if (tmp) {
#line 993
      *(poly->EqualityIndex + i) = 1;
    }
#line 995
    j = (ddf_colrange )1;
    {
#line 995
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 995
      if (! (j <= M->colsize)) {
#line 995
        goto while_break___0;
      }
      {
#line 996
      dddf_set((double *)(*(*(poly->A + (i - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
      }
#line 997
      if (j == 1L) {
        {
#line 997
        tmp___0 = ddf_Nonzero((double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
        }
#line 997
        if (tmp___0) {
#line 997
          poly->homogeneous = 0;
        }
      }
#line 995
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 991
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1000
  ddf_DoubleDescription(poly, err);
  }
  _L99: 
#line 1002
  return (poly);
}
}
#line 1005 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_PolyhedraPtr ddf_DDMatrix2Poly2(ddf_MatrixPtr M , ddf_RowOrderType horder , ddf_ErrorType *err ) 
{ 
  ddf_rowrange i ;
  ddf_colrange j ;
  ddf_PolyhedraPtr poly ;
  int tmp ;
  ddf_boolean tmp___0 ;

  {
#line 1009
  poly = (ddf_PolyhedraPtr )((void *)0);
#line 1011
  *err = (ddf_ErrorType )17;
#line 1012
  if (M->rowsize < 0L) {
#line 1013
    *err = (ddf_ErrorType )2;
#line 1014
    goto _L99;
  } else
#line 1012
  if (M->colsize < 0L) {
#line 1013
    *err = (ddf_ErrorType )2;
#line 1014
    goto _L99;
  }
  {
#line 1016
  poly = ddf_CreatePolyhedraData(M->rowsize, M->colsize);
#line 1017
  poly->representation = M->representation;
#line 1018
  poly->homogeneous = 1;
#line 1020
  i = (ddf_rowrange )1;
  }
  {
#line 1020
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1020
    if (! (i <= M->rowsize)) {
#line 1020
      goto while_break;
    }
    {
#line 1021
    tmp = set_member(i, M->linset);
    }
#line 1021
    if (tmp) {
#line 1022
      *(poly->EqualityIndex + i) = 1;
    }
#line 1024
    j = (ddf_colrange )1;
    {
#line 1024
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1024
      if (! (j <= M->colsize)) {
#line 1024
        goto while_break___0;
      }
      {
#line 1025
      dddf_set((double *)(*(*(poly->A + (i - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
      }
#line 1026
      if (j == 1L) {
        {
#line 1026
        tmp___0 = ddf_Nonzero((double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
        }
#line 1026
        if (tmp___0) {
#line 1026
          poly->homogeneous = 0;
        }
      }
#line 1024
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1020
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1029
  ddf_DoubleDescription2(poly, horder, err);
  }
  _L99: 
#line 1031
  return (poly);
}
}
#line 1034 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_MatrixIntegerFilter(ddf_MatrixPtr M ) 
{ 
  ddf_rowrange i ;
  ddf_colrange j ;
  myfloat x ;

  {
  {
#line 1040
  dddf_init((double *)(x));
#line 1041
  i = (ddf_rowrange )0;
  }
  {
#line 1041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1041
    if (! (i < M->rowsize)) {
#line 1041
      goto while_break;
    }
#line 1042
    j = (ddf_colrange )0;
    {
#line 1042
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1042
      if (! (j < M->colsize)) {
#line 1042
        goto while_break___0;
      }
      {
#line 1043
      ddf_SnapToInteger((double *)(x), (double *)(*(*(M->matrix + i) + j)));
#line 1044
      dddf_set((double *)(*(*(M->matrix + i) + j)), (double *)(x));
#line 1042
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1041
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1046
  dddf_clear((double *)(x));
  }
#line 1047
  return;
}
}
#line 1049 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_CopyRay(myfloat *a___41 , ddf_colrange d_origsize , ddf_RayPtr RR , ddf_RepresentationType rep ,
                 ddf_colindex reducedcol ) 
{ 
  long j ;
  long j1___0 ;
  myfloat b ;
  ddf_boolean tmp ;

  {
  {
#line 1055
  dddf_init((double *)(b));
#line 1056
  j = 1L;
  }
  {
#line 1056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1056
    if (! (j <= d_origsize)) {
#line 1056
      goto while_break;
    }
#line 1057
    j1___0 = *(reducedcol + j);
#line 1058
    if (j1___0 > 0L) {
      {
#line 1059
      dddf_set((double *)(*(a___41 + (j - 1L))), (double *)(*(RR->Ray + (j1___0 - 1L))));
      }
    } else {
      {
#line 1063
      dddf_set((double *)(*(a___41 + (j - 1L))), (double *)(ddf_purezero));
      }
    }
#line 1056
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1068
  dddf_set((double *)(b), (double *)(*(a___41 + 0)));
  }
#line 1069
  if ((unsigned int )rep == 2U) {
    {
#line 1069
    tmp = ddf_Nonzero((double *)(b));
    }
#line 1069
    if (tmp) {
      {
#line 1070
      dddf_set((double *)(*(a___41 + 0)), (double *)(ddf_one));
#line 1071
      j = 2L;
      }
      {
#line 1071
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1071
        if (! (j <= d_origsize)) {
#line 1071
          goto while_break___0;
        }
        {
#line 1072
        dddf_div((double *)(*(a___41 + (j - 1L))), (double *)(*(a___41 + (j - 1L))),
                 (double *)(b));
#line 1071
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 1074
  dddf_clear((double *)(b));
  }
#line 1075
  return;
}
}
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a  ;
#line 1077 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteRay(FILE *f , ddf_colrange d_origsize , ddf_RayPtr RR , ddf_RepresentationType rep ,
                  ddf_colindex reducedcol ) 
{ 
  ddf_colrange j ;

  {
#line 1083
  if (d_last < d_origsize) {
#line 1084
    if (d_last > 0L) {
      {
#line 1084
      free((void *)a);
      }
    }
    {
#line 1085
    ddf_InitializeArow(d_origsize + 1L, & a);
#line 1086
    d_last = d_origsize + 1L;
    }
  }
  {
#line 1089
  ddf_CopyRay(a, d_origsize, RR, rep, reducedcol);
#line 1090
  j = (ddf_colrange )0;
  }
  {
#line 1090
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1090
    if (! (j < d_origsize)) {
#line 1090
      goto while_break;
    }
    {
#line 1090
    ddf_WriteNumber(f, (double *)(*(a + j)));
#line 1090
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
  }
#line 1092
  return;
}
}
#line 1094 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteArow(FILE *f , ddf_Arow a___41 , ddf_colrange d ) 
{ 
  ddf_colrange j ;

  {
#line 1098
  j = (ddf_colrange )0;
  {
#line 1098
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1098
    if (! (j < d)) {
#line 1098
      goto while_break;
    }
    {
#line 1098
    ddf_WriteNumber(f, (double *)(*(a___41 + j)));
#line 1098
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1099
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
  }
#line 1100
  return;
}
}
#line 1102 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteAmatrix(FILE *f , ddf_Amatrix A , long rowmax , long colmax ) 
{ 
  long i ;
  long j ;

  {
#line 1106
  if ((unsigned long )A == (unsigned long )((void *)0)) {
    {
#line 1107
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"WriteAmatrix: The requested matrix is empty\n");
    }
#line 1108
    goto _L99;
  }
  {
#line 1110
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"begin\n");
#line 1114
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld %ld real\n",
          rowmax, colmax);
#line 1116
  i = 1L;
  }
  {
#line 1116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1116
    if (! (i <= rowmax)) {
#line 1116
      goto while_break;
    }
#line 1117
    j = 1L;
    {
#line 1117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1117
      if (! (j <= colmax)) {
#line 1117
        goto while_break___0;
      }
      {
#line 1118
      ddf_WriteNumber(f, (double *)(*(*(A + (i - 1L)) + (j - 1L))));
#line 1117
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1120
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 1116
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1122
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
  }
  _L99: ;
#line 1124
  return;
}
}
#line 1126 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteBmatrix(FILE *f , ddf_colrange d_size , ddf_Bmatrix B ) 
{ 
  ddf_colrange j1___0 ;
  ddf_colrange j2 ;

  {
#line 1130
  if ((unsigned long )B == (unsigned long )((void *)0)) {
    {
#line 1131
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"WriteBmatrix: The requested matrix is empty\n");
    }
#line 1132
    goto _L99;
  }
#line 1134
  j1___0 = (ddf_colrange )0;
  {
#line 1134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1134
    if (! (j1___0 < d_size)) {
#line 1134
      goto while_break;
    }
#line 1135
    j2 = (ddf_colrange )0;
    {
#line 1135
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1135
      if (! (j2 < d_size)) {
#line 1135
        goto while_break___0;
      }
      {
#line 1136
      ddf_WriteNumber(f, (double *)(*(*(B + j1___0) + j2)));
#line 1135
      j2 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1138
    _IO_putc('\n', f);
#line 1134
    j1___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1140
  _IO_putc('\n', f);
  }
  _L99: ;
#line 1142
  return;
}
}
#line 1144 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteSetFamily(FILE *f , ddf_SetFamilyPtr F ) 
{ 
  ddf_bigrange i ;
  long tmp ;

  {
#line 1148
  if ((unsigned long )F == (unsigned long )((void *)0)) {
    {
#line 1149
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"WriteSetFamily: The requested family is empty\n");
    }
#line 1150
    goto _L99;
  }
  {
#line 1152
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"begin\n");
#line 1153
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %ld    %ld\n",
          F->famsize, F->setsize);
#line 1154
  i = (ddf_bigrange )0;
  }
  {
#line 1154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1154
    if (! (i < F->famsize)) {
#line 1154
      goto while_break;
    }
    {
#line 1155
    tmp = set_card(*(F->set + i));
#line 1155
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld %ld : ",
            i + 1L, tmp);
#line 1156
    set_fwrite(f, *(F->set + i));
#line 1154
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1158
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
  }
  _L99: ;
#line 1160
  return;
}
}
#line 1162 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteSetFamilyCompressed(FILE *f , ddf_SetFamilyPtr F ) 
{ 
  ddf_bigrange i ;
  ddf_bigrange card ;

  {
#line 1166
  if ((unsigned long )F == (unsigned long )((void *)0)) {
    {
#line 1167
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"WriteSetFamily: The requested family is empty\n");
    }
#line 1168
    goto _L99;
  }
  {
#line 1170
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"begin\n");
#line 1171
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %ld    %ld\n",
          F->famsize, F->setsize);
#line 1172
  i = (ddf_bigrange )0;
  }
  {
#line 1172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1172
    if (! (i < F->famsize)) {
#line 1172
      goto while_break;
    }
    {
#line 1173
    card = set_card(*(F->set + i));
    }
#line 1174
    if (F->setsize - card >= card) {
      {
#line 1175
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld %ld : ",
              i + 1L, card);
#line 1176
      set_fwrite(f, *(F->set + i));
      }
    } else {
      {
#line 1178
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld %ld : ",
              i + 1L, - card);
#line 1179
      set_fwrite_compl(f, *(F->set + i));
      }
    }
#line 1172
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1182
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
  }
  _L99: ;
#line 1184
  return;
}
}
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteMatrix(FILE *f , ddf_MatrixPtr M ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange linsize ;
  int tmp ;

  {
#line 1190
  if ((unsigned long )M == (unsigned long )((void *)0)) {
    {
#line 1191
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"WriteMatrix: The requested matrix is empty\n");
    }
#line 1192
    goto _L99;
  }
  {
#line 1195
  if ((unsigned int )M->representation == 1U) {
#line 1195
    goto case_1;
  }
#line 1197
  if ((unsigned int )M->representation == 2U) {
#line 1197
    goto case_2;
  }
#line 1199
  if ((unsigned int )M->representation == 0U) {
#line 1199
    goto case_0;
  }
#line 1194
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1196
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"H-representation\n");
  }
#line 1196
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1198
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"V-representation\n");
  }
#line 1198
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1200
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1202
  linsize = set_card(M->linset);
  }
#line 1203
  if (linsize > 0L) {
    {
#line 1204
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"linearity %ld ",
            linsize);
#line 1205
    i = (ddf_rowrange )1;
    }
    {
#line 1205
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1205
      if (! (i <= M->rowsize)) {
#line 1205
        goto while_break;
      }
      {
#line 1206
      tmp = set_member(i, M->linset);
      }
#line 1206
      if (tmp) {
        {
#line 1206
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld",
                i);
        }
      }
#line 1205
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1207
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1209
  ddf_WriteAmatrix(f, M->matrix, M->rowsize, M->colsize);
  }
#line 1210
  if ((unsigned int )M->objective != 0U) {
#line 1211
    if ((unsigned int )M->objective == 1U) {
      {
#line 1212
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"maximize\n");
      }
    } else {
      {
#line 1214
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"minimize\n");
      }
    }
    {
#line 1215
    ddf_WriteArow(f, M->rowvec, M->colsize);
    }
  }
  _L99: ;
#line 1218
  return;
}
}
#line 1220 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteLP(FILE *f , ddf_LPPtr lp ) 
{ 


  {
#line 1222
  if ((unsigned long )lp == (unsigned long )((void *)0)) {
    {
#line 1223
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"WriteLP: The requested lp is empty\n");
    }
#line 1224
    goto _L99;
  }
  {
#line 1226
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"H-representation\n");
#line 1228
  ddf_WriteAmatrix(f, lp->A, lp->m - 1L, lp->d);
  }
#line 1229
  if ((unsigned int )lp->objective != 0U) {
#line 1230
    if ((unsigned int )lp->objective == 1U) {
      {
#line 1231
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"maximize\n");
      }
    } else {
      {
#line 1233
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"minimize\n");
      }
    }
    {
#line 1234
    ddf_WriteArow(f, *(lp->A + (lp->objrow - 1L)), lp->d);
    }
  }
  _L99: ;
#line 1237
  return;
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_SnapToInteger(double *y , double *x ) 
{ 


  {
  {
#line 1243
  dddf_set(y, x);
  }
#line 1244
  return;
}
}
#line 1247 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteReal(FILE *f , double *x ) 
{ 
  long ix1 ;
  long ix2 ;
  long ix ;
  double ax ;
  double tmp ;
  double tmp___0 ;
  ddf_boolean tmp___1 ;

  {
  {
#line 1252
  ax = dddf_get_d(x);
#line 1253
  tmp = fabs(ax);
#line 1253
  ix1 = (long )(tmp * 10000. + 0.5);
#line 1254
  tmp___0 = fabs(ax);
#line 1254
  ix2 = (long )(tmp___0 + 0.5);
#line 1255
  ix2 *= 10000L;
  }
#line 1256
  if (ix1 == ix2) {
    {
#line 1257
    tmp___1 = ddf_Positive(x);
    }
#line 1257
    if (tmp___1) {
#line 1258
      ix = (long )(ax + 0.5);
    } else {
#line 1260
      ix = (long )(- ax + 0.5);
#line 1261
      ix = - ix;
    }
    {
#line 1263
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %2ld",
            ix);
    }
  } else {
    {
#line 1265
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" % .9E",
            ax);
    }
  }
#line 1266
  return;
}
}
#line 1268 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteNumber(FILE *f , double *x ) 
{ 


  {
  {
#line 1274
  ddf_WriteReal(f, x);
  }
#line 1276
  return;
}
}
#line 1279 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteIncidence(FILE *f , ddf_PolyhedraPtr poly ) 
{ 
  ddf_SetFamilyPtr I ;

  {
  {
#line 1284
  if ((unsigned int )poly->representation == 1U) {
#line 1284
    goto case_1;
  }
#line 1287
  if ((unsigned int )poly->representation == 2U) {
#line 1287
    goto case_2;
  }
#line 1291
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1285
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"ecd_file: Incidence of generators and inequalities\n");
  }
#line 1286
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1288
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"icd_file: Incidence of inequalities and generators\n");
  }
#line 1289
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1292
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1294
  I = ddf_CopyIncidence(poly);
#line 1295
  ddf_WriteSetFamilyCompressed(f, I);
#line 1296
  ddf_FreeSetFamily(I);
  }
#line 1297
  return;
}
}
#line 1299 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteAdjacency(FILE *f , ddf_PolyhedraPtr poly ) 
{ 
  ddf_SetFamilyPtr A ;

  {
  {
#line 1304
  if ((unsigned int )poly->representation == 1U) {
#line 1304
    goto case_1;
  }
#line 1307
  if ((unsigned int )poly->representation == 2U) {
#line 1307
    goto case_2;
  }
#line 1311
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1305
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"ead_file: Adjacency of generators\n");
  }
#line 1306
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1308
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"iad_file: Adjacency of inequalities\n");
  }
#line 1309
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1312
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1314
  A = ddf_CopyAdjacency(poly);
#line 1315
  ddf_WriteSetFamilyCompressed(f, A);
#line 1316
  ddf_FreeSetFamily(A);
  }
#line 1317
  return;
}
}
#line 1320 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_ComputeAinc(ddf_PolyhedraPtr poly ) 
{ 
  ddf_bigrange k ;
  ddf_rowrange i ;
  ddf_rowrange m1 ;
  ddf_colrange j ;
  ddf_boolean redundant ;
  ddf_MatrixPtr M ;
  myfloat sum ;
  myfloat temp ;
  void *tmp ;
  ddf_boolean tmp___0 ;
  ddf_boolean tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;

  {
  {
#line 1329
  M = (ddf_MatrixPtr )((void *)0);
#line 1332
  dddf_init((double *)(sum));
#line 1332
  dddf_init((double *)(temp));
  }
#line 1333
  if (poly->AincGenerated == 1) {
#line 1333
    goto _L99;
  }
  {
#line 1335
  M = ddf_CopyOutput(poly);
#line 1336
  poly->n = M->rowsize;
#line 1337
  m1 = poly->m1;
#line 1343
  tmp = calloc((size_t )m1, sizeof(set_type ));
#line 1343
  poly->Ainc = (set_type *)tmp;
#line 1344
  i = (ddf_rowrange )1;
  }
  {
#line 1344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1344
    if (! (i <= m1)) {
#line 1344
      goto while_break;
    }
    {
#line 1344
    set_initialize(poly->Ainc + (i - 1L), poly->n);
#line 1344
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1345
  set_initialize(& poly->Ared, m1);
#line 1346
  set_initialize(& poly->Adom, m1);
#line 1348
  k = (ddf_bigrange )1;
  }
  {
#line 1348
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1348
    if (! (k <= poly->n)) {
#line 1348
      goto while_break___0;
    }
#line 1349
    i = (ddf_rowrange )1;
    {
#line 1349
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1349
      if (! (i <= poly->m)) {
#line 1349
        goto while_break___1;
      }
      {
#line 1350
      dddf_set((double *)(sum), (double *)(ddf_purezero));
#line 1351
      j = (ddf_colrange )1;
      }
      {
#line 1351
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1351
        if (! (j <= poly->d)) {
#line 1351
          goto while_break___2;
        }
        {
#line 1352
        dddf_mul((double *)(temp), (double *)(*(*(poly->A + (i - 1L)) + (j - 1L))),
                 (double *)(*(*(M->matrix + (k - 1L)) + (j - 1L))));
#line 1353
        dddf_add((double *)(sum), (double *)(sum), (double *)(temp));
#line 1351
        j ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1355
      tmp___0 = ddf_EqualToZero((double *)(sum));
      }
#line 1355
      if (tmp___0) {
        {
#line 1356
        set_addelem(*(poly->Ainc + (i - 1L)), k);
        }
      }
#line 1349
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1359
    if (! poly->homogeneous) {
#line 1359
      if ((unsigned int )poly->representation == 1U) {
        {
#line 1360
        tmp___1 = ddf_EqualToZero((double *)(*(*(M->matrix + (k - 1L)) + 0)));
        }
#line 1360
        if (tmp___1) {
          {
#line 1361
          set_addelem(*(poly->Ainc + (m1 - 1L)), k);
          }
        }
      }
    }
#line 1348
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1366
  i = (ddf_rowrange )1;
  {
#line 1366
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1366
    if (! (i <= m1)) {
#line 1366
      goto while_break___3;
    }
    {
#line 1367
    tmp___2 = set_card(*(poly->Ainc + (i - 1L)));
    }
#line 1367
    if (tmp___2 == M->rowsize) {
      {
#line 1368
      set_addelem(poly->Adom, i);
      }
    }
#line 1366
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1371
  i = m1;
  {
#line 1371
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1371
    if (! (i >= 1L)) {
#line 1371
      goto while_break___4;
    }
    {
#line 1372
    tmp___6 = set_card(*(poly->Ainc + (i - 1L)));
    }
#line 1372
    if (tmp___6 == 0L) {
      {
#line 1373
      redundant = 1;
#line 1374
      set_addelem(poly->Ared, i);
      }
    } else {
#line 1376
      redundant = 0;
#line 1377
      k = (ddf_bigrange )1;
      {
#line 1377
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1377
        if (! (k <= m1)) {
#line 1377
          goto while_break___5;
        }
#line 1378
        if (k != i) {
          {
#line 1378
          tmp___3 = set_member(k, poly->Ared);
          }
#line 1378
          if (! tmp___3) {
            {
#line 1378
            tmp___4 = set_member(k, poly->Adom);
            }
#line 1378
            if (! tmp___4) {
              {
#line 1378
              tmp___5 = set_subset(*(poly->Ainc + (i - 1L)), *(poly->Ainc + (k - 1L)));
              }
#line 1378
              if (tmp___5) {
#line 1380
                if (! redundant) {
#line 1381
                  redundant = 1;
                }
                {
#line 1383
                set_addelem(poly->Ared, i);
                }
              }
            }
          }
        }
#line 1377
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1371
    i --;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1388
  ddf_FreeMatrix(M);
#line 1389
  poly->AincGenerated = 1;
  }
  _L99: 
  {
#line 1391
  dddf_clear((double *)(sum));
#line 1391
  dddf_clear((double *)(temp));
  }
#line 1392
  return;
}
}
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common  ;
#line 1406
ddf_boolean ddf_InputAdjacentQ(ddf_PolyhedraPtr poly , ddf_rowrange i1 , ddf_rowrange i2 ) ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn  =    0L;
#line 1394 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_boolean ddf_InputAdjacentQ(ddf_PolyhedraPtr poly , ddf_rowrange i1 , ddf_rowrange i2 ) 
{ 
  ddf_boolean adj ;
  ddf_rowrange i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1403
  adj = 1;
#line 1408
  if (poly->AincGenerated == 0) {
    {
#line 1408
    ddf_ComputeAinc(poly);
    }
  }
#line 1409
  if (lastn != poly->n) {
#line 1410
    if (lastn > 0L) {
      {
#line 1410
      set_free(common);
      }
    }
    {
#line 1411
    set_initialize(& common, poly->n);
#line 1412
    lastn = poly->n;
    }
  }
  {
#line 1414
  tmp = set_member(i1, poly->Ared);
  }
#line 1414
  if (tmp) {
#line 1415
    adj = 0;
#line 1416
    goto _L99;
  } else {
    {
#line 1414
    tmp___0 = set_member(i2, poly->Ared);
    }
#line 1414
    if (tmp___0) {
#line 1415
      adj = 0;
#line 1416
      goto _L99;
    }
  }
  {
#line 1418
  tmp___1 = set_member(i1, poly->Adom);
  }
#line 1418
  if (tmp___1) {
#line 1420
    adj = 1;
#line 1421
    goto _L99;
  } else {
    {
#line 1418
    tmp___2 = set_member(i2, poly->Adom);
    }
#line 1418
    if (tmp___2) {
#line 1420
      adj = 1;
#line 1421
      goto _L99;
    }
  }
  {
#line 1423
  set_int(common, *(poly->Ainc + (i1 - 1L)), *(poly->Ainc + (i2 - 1L)));
#line 1424
  i = (ddf_rowrange )0;
  }
  {
#line 1425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1425
    if (i < poly->m1) {
#line 1425
      if (! (adj == 1)) {
#line 1425
        goto while_break;
      }
    } else {
#line 1425
      goto while_break;
    }
#line 1426
    i ++;
#line 1427
    if (i != i1) {
#line 1427
      if (i != i2) {
        {
#line 1427
        tmp___3 = set_member(i, poly->Ared);
        }
#line 1427
        if (! tmp___3) {
          {
#line 1427
          tmp___4 = set_member(i, poly->Adom);
          }
#line 1427
          if (! tmp___4) {
            {
#line 1427
            tmp___5 = set_subset(common, *(poly->Ainc + (i - 1L)));
            }
#line 1427
            if (tmp___5) {
#line 1429
              adj = 0;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 1433
  return (adj);
}
}
#line 1437 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteInputIncidence(FILE *f , ddf_PolyhedraPtr poly ) 
{ 
  ddf_SetFamilyPtr I ;

  {
#line 1441
  if (poly->AincGenerated == 0) {
    {
#line 1441
    ddf_ComputeAinc(poly);
    }
  }
  {
#line 1443
  if ((unsigned int )poly->representation == 1U) {
#line 1443
    goto case_1;
  }
#line 1447
  if ((unsigned int )poly->representation == 2U) {
#line 1447
    goto case_2;
  }
#line 1451
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1444
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"icd_file: Incidence of inequalities and generators\n");
  }
#line 1445
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1448
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"ecd_file: Incidence of generators and inequalities\n");
  }
#line 1449
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1452
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1455
  I = ddf_CopyInputIncidence(poly);
#line 1456
  ddf_WriteSetFamilyCompressed(f, I);
#line 1457
  ddf_FreeSetFamily(I);
  }
#line 1458
  return;
}
}
#line 1460 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteInputAdjacency(FILE *f , ddf_PolyhedraPtr poly ) 
{ 
  ddf_SetFamilyPtr A ;

  {
#line 1464
  if (poly->AincGenerated == 0) {
    {
#line 1465
    ddf_ComputeAinc(poly);
    }
  }
  {
#line 1468
  if ((unsigned int )poly->representation == 1U) {
#line 1468
    goto case_1;
  }
#line 1472
  if ((unsigned int )poly->representation == 2U) {
#line 1472
    goto case_2;
  }
#line 1476
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1469
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"iad_file: Adjacency of inequalities\n");
  }
#line 1470
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1473
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"ead_file: Adjacency of generators\n");
  }
#line 1474
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1477
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1479
  A = ddf_CopyInputAdjacency(poly);
#line 1480
  ddf_WriteSetFamilyCompressed(f, A);
#line 1481
  ddf_FreeSetFamily(A);
  }
#line 1482
  return;
}
}
#line 1485 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteProgramDescription(FILE *f ) 
{ 


  {
  {
#line 1487
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* cddlib: a double description library:%s\n",
          "Version 0.94g (March 23, 2012)");
#line 1488
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* compiled for %s arithmetic.\n",
          "C double");
#line 1489
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* %s\n", "Copyright (C) 1996, Komei Fukuda, fukuda@ifor.math.ethz.ch");
  }
#line 1490
  return;
}
}
#line 1492 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteTimes(FILE *f , time_t starttime , time_t endtime ) 
{ 
  long ptime ;
  long ptime_sec ;
  long ptime_minu ;
  long ptime_hour ;
  struct tm *tmp ;
  char *tmp___0 ;
  struct tm *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1500
  ptime = endtime - starttime;
#line 1503
  ptime_hour = ptime / 3600L;
#line 1504
  ptime_minu = (ptime - ptime_hour * 3600L) / 60L;
#line 1505
  ptime_sec = ptime % 60L;
#line 1506
  tmp = localtime((time_t const   *)(& starttime));
#line 1506
  tmp___0 = asctime((struct tm  const  *)tmp);
#line 1506
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Computation started at %s",
          tmp___0);
#line 1507
  tmp___1 = localtime((time_t const   *)(& endtime));
#line 1507
  tmp___2 = asctime((struct tm  const  *)tmp___1);
#line 1507
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*             ended   at %s",
          tmp___2);
#line 1508
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Total processor time = %ld seconds\n",
          ptime);
#line 1509
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*                      = %ld h %ld m %ld s\n",
          ptime_hour, ptime_minu, ptime_sec);
  }
#line 1510
  return;
}
}
#line 1512 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteDDTimes(FILE *f , ddf_PolyhedraPtr poly ) 
{ 


  {
  {
#line 1514
  ddf_WriteTimes(f, (poly->child)->starttime, (poly->child)->endtime);
  }
#line 1515
  return;
}
}
#line 1517 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteLPTimes(FILE *f , ddf_LPPtr lp ) 
{ 


  {
  {
#line 1519
  ddf_WriteTimes(f, lp->starttime, lp->endtime);
  }
#line 1520
  return;
}
}
#line 1522 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteLPStats(FILE *f ) 
{ 
  time_t currenttime ;

  {
  {
#line 1526
  time(& currenttime);
#line 1528
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n*--- Statistics of pivots ---\n");
#line 1542
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"f0 = %ld (float basis finding pivots)\n",
          ddf_statBApivots);
#line 1543
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"fc = %ld (float CC pivots)\n",
          ddf_statCCpivots);
#line 1544
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"f1 = %ld (float dual simplex phase I pivots)\n",
          ddf_statDS1pivots);
#line 1545
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"f2 = %ld (float dual simplex phase II pivots)\n",
          ddf_statDS2pivots);
#line 1546
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"f3 = %ld (float anticycling CC pivots)\n",
          ddf_statACpivots);
#line 1548
  ddf_WriteLPMode(f);
#line 1549
  ddf_WriteTimes(f, ddf_statStartTime, currenttime);
  }
#line 1550
  return;
}
}
#line 1552 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteLPMode(FILE *f ) 
{ 


  {
  {
#line 1554
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n* LP solver: ");
  }
  {
#line 1556
  if ((unsigned int )ddf_choiceLPSolverDefault == 1U) {
#line 1556
    goto case_1;
  }
#line 1559
  if ((unsigned int )ddf_choiceLPSolverDefault == 0U) {
#line 1559
    goto case_0;
  }
#line 1562
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1557
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"DualSimplex\n");
  }
#line 1558
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1560
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"Criss-Cross\n");
  }
#line 1561
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1562
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1565
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Redundancy cheking solver: ");
  }
  {
#line 1567
  if ((unsigned int )ddf_choiceRedcheckAlgorithm == 1U) {
#line 1567
    goto case_1___0;
  }
#line 1570
  if ((unsigned int )ddf_choiceRedcheckAlgorithm == 0U) {
#line 1570
    goto case_0___0;
  }
#line 1573
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 1568
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"DualSimplex\n");
  }
#line 1569
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 1571
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"Criss-Cross\n");
  }
#line 1572
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1573
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1576
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Lexicographic pivot: ");
  }
#line 1577
  if (ddf_choiceLexicoPivotQ) {
    {
#line 1577
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" on\n");
    }
  } else {
    {
#line 1578
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" off\n");
    }
  }
#line 1580
  return;
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteRunningMode(FILE *f , ddf_PolyhedraPtr poly ) 
{ 


  {
#line 1585
  if ((unsigned long )poly->child != (unsigned long )((void *)0)) {
    {
#line 1586
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* roworder: ");
    }
    {
#line 1589
    if ((unsigned int )(poly->child)->HalfspaceOrder == 1U) {
#line 1589
      goto case_1;
    }
#line 1593
    if ((unsigned int )(poly->child)->HalfspaceOrder == 0U) {
#line 1593
      goto case_0;
    }
#line 1597
    if ((unsigned int )(poly->child)->HalfspaceOrder == 2U) {
#line 1597
      goto case_2;
    }
#line 1601
    if ((unsigned int )(poly->child)->HalfspaceOrder == 3U) {
#line 1601
      goto case_3;
    }
#line 1605
    if ((unsigned int )(poly->child)->HalfspaceOrder == 4U) {
#line 1605
      goto case_4;
    }
#line 1609
    if ((unsigned int )(poly->child)->HalfspaceOrder == 5U) {
#line 1609
      goto case_5;
    }
#line 1613
    if ((unsigned int )(poly->child)->HalfspaceOrder == 6U) {
#line 1613
      goto case_6;
    }
#line 1617
    if ((unsigned int )(poly->child)->HalfspaceOrder == 7U) {
#line 1617
      goto case_7;
    }
#line 1621
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1590
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"minindex\n");
    }
#line 1591
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1594
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"maxindex\n");
    }
#line 1595
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1598
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"mincutoff\n");
    }
#line 1599
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1602
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"maxcutoff\n");
    }
#line 1603
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1606
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"mixcutoff\n");
    }
#line 1607
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1610
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"lexmin\n");
    }
#line 1611
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1614
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"lexmax\n");
    }
#line 1615
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1618
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"random  %d\n",
            (poly->child)->rseed);
    }
#line 1619
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1621
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1624
  return;
}
}
#line 1627 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteCompletionStatus(FILE *f , ddf_ConePtr cone ) 
{ 


  {
#line 1629
  if (cone->Iteration < cone->m) {
#line 1629
    if ((unsigned int )cone->CompStatus == 1U) {
      {
#line 1630
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Computation completed at Iteration %4ld.\n",
              cone->Iteration);
      }
    }
  }
#line 1632
  if ((unsigned int )cone->CompStatus == 2U) {
    {
#line 1633
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Computation completed at Iteration %4ld because the region found empty.\n",
            cone->Iteration);
    }
  }
#line 1635
  return;
}
}
#line 1637 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WritePolyFile(FILE *f , ddf_PolyhedraPtr poly ) 
{ 


  {
  {
#line 1639
  ddf_WriteAmatrix(f, poly->A, poly->m, poly->d);
  }
#line 1640
  return;
}
}
#line 1643 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_WriteErrorMessages(FILE *f , ddf_ErrorType Error ) 
{ 


  {
  {
#line 1647
  if ((unsigned int )Error == 0U) {
#line 1647
    goto case_0;
  }
#line 1652
  if ((unsigned int )Error == 6U) {
#line 1652
    goto case_6;
  }
#line 1656
  if ((unsigned int )Error == 7U) {
#line 1656
    goto case_7;
  }
#line 1660
  if ((unsigned int )Error == 2U) {
#line 1660
    goto case_2;
  }
#line 1665
  if ((unsigned int )Error == 1U) {
#line 1665
    goto case_1;
  }
#line 1674
  if ((unsigned int )Error == 3U) {
#line 1674
    goto case_3;
  }
#line 1679
  if ((unsigned int )Error == 4U) {
#line 1679
    goto case_4;
  }
#line 1683
  if ((unsigned int )Error == 5U) {
#line 1683
    goto case_5;
  }
#line 1687
  if ((unsigned int )Error == 8U) {
#line 1687
    goto case_8;
  }
#line 1691
  if ((unsigned int )Error == 9U) {
#line 1691
    goto case_9;
  }
#line 1696
  if ((unsigned int )Error == 10U) {
#line 1696
    goto case_10;
  }
#line 1700
  if ((unsigned int )Error == 11U) {
#line 1700
    goto case_11;
  }
#line 1704
  if ((unsigned int )Error == 12U) {
#line 1704
    goto case_12;
  }
#line 1708
  if ((unsigned int )Error == 13U) {
#line 1708
    goto case_13;
  }
#line 1712
  if ((unsigned int )Error == 14U) {
#line 1712
    goto case_14;
  }
#line 1716
  if ((unsigned int )Error == 15U) {
#line 1716
    goto case_15;
  }
#line 1720
  if ((unsigned int )Error == 16U) {
#line 1720
    goto case_16;
  }
#line 1724
  if ((unsigned int )Error == 17U) {
#line 1724
    goto case_17;
  }
#line 1645
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1648
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: Input matrix is too large:\n");
#line 1649
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Please increase MMAX and/or NMAX in the source code and recompile.\n");
  }
#line 1650
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1653
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: Specified input file does not exist.\n");
  }
#line 1654
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1657
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Output Error: Specified output file cannot be opened.\n");
  }
#line 1658
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1661
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: Input matrix has a negative size:\n");
#line 1662
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Please check rowsize or colsize.\n");
  }
#line 1663
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1666
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: Input format is not correct.\n");
#line 1667
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Format:\n");
#line 1668
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" begin\n");
#line 1669
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"   m   n  NumberType(real, rational or integer)\n");
#line 1670
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"   b  -A\n");
#line 1671
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" end\n");
  }
#line 1672
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1675
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: V-representation is empty:\n");
#line 1676
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*cddlib does not accept this trivial case for which output can be any inconsistent system.\n");
  }
#line 1677
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1680
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: H-representation is empty.\n");
  }
#line 1681
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1684
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: Representation is empty.\n");
  }
#line 1685
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1688
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*LP Error: No LP objective (max or min) is set.\n");
  }
#line 1689
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1692
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*LP Error: The binary (with GMP Rational) does not support Real number input.\n");
#line 1693
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"         : Use a binary compiled without -Dddf_GMPRATIONAL option.\n");
  }
#line 1694
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1697
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: A function is called with H-rep which does not support an H-representation.\n");
  }
#line 1698
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 1701
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: A function is called with V-rep which does not support an V-representation.\n");
  }
#line 1702
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1705
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: The function called cannot handle linearity.\n");
  }
#line 1706
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 1709
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: Specified row index is out of range\n");
  }
#line 1710
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 1713
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: Specified column index is out of range\n");
  }
#line 1714
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 1717
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: Possibly an LP cycling occurs.  Use the Criss-Cross method.\n");
  }
#line 1718
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 1721
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: Numerical inconsistency is found.  Use the GMP exact arithmetic.\n");
  }
#line 1722
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 1725
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*No Error found.\n");
  }
#line 1726
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1728
  return;
}
}
#line 1731 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_SetFamilyPtr ddf_CopyIncidence(ddf_PolyhedraPtr poly ) 
{ 
  ddf_SetFamilyPtr F ;
  ddf_bigrange k ;
  ddf_rowrange i ;
  int tmp ;

  {
#line 1733
  F = (ddf_SetFamilyPtr )((void *)0);
#line 1737
  if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 1737
    goto _L99;
  } else
#line 1737
  if ((unsigned int )(poly->child)->CompStatus != 1U) {
#line 1737
    goto _L99;
  }
#line 1738
  if (poly->AincGenerated == 0) {
    {
#line 1738
    ddf_ComputeAinc(poly);
    }
  }
  {
#line 1739
  F = ddf_CreateSetFamily(poly->n, poly->m1);
#line 1740
  i = (ddf_rowrange )1;
  }
  {
#line 1740
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1740
    if (! (i <= poly->m1)) {
#line 1740
      goto while_break;
    }
#line 1741
    k = (ddf_bigrange )1;
    {
#line 1741
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1741
      if (! (k <= poly->n)) {
#line 1741
        goto while_break___0;
      }
      {
#line 1742
      tmp = set_member(k, *(poly->Ainc + (i - 1L)));
      }
#line 1742
      if (tmp) {
        {
#line 1742
        set_addelem(*(F->set + (k - 1L)), i);
        }
      }
#line 1741
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1740
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 1744
  return (F);
}
}
#line 1747 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_SetFamilyPtr ddf_CopyInputIncidence(ddf_PolyhedraPtr poly ) 
{ 
  ddf_rowrange i ;
  ddf_SetFamilyPtr F ;

  {
#line 1750
  F = (ddf_SetFamilyPtr )((void *)0);
#line 1752
  if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 1752
    goto _L99;
  } else
#line 1752
  if ((unsigned int )(poly->child)->CompStatus != 1U) {
#line 1752
    goto _L99;
  }
#line 1753
  if (poly->AincGenerated == 0) {
    {
#line 1753
    ddf_ComputeAinc(poly);
    }
  }
  {
#line 1754
  F = ddf_CreateSetFamily(poly->m1, poly->n);
#line 1755
  i = (ddf_rowrange )0;
  }
  {
#line 1755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1755
    if (! (i < poly->m1)) {
#line 1755
      goto while_break;
    }
    {
#line 1756
    set_copy(*(F->set + i), *(poly->Ainc + i));
#line 1755
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 1759
  return (F);
}
}
#line 1762 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_SetFamilyPtr ddf_CopyAdjacency(ddf_PolyhedraPtr poly ) 
{ 
  ddf_RayPtr RayPtr1 ;
  ddf_RayPtr RayPtr2 ;
  ddf_SetFamilyPtr F ;
  long pos1 ;
  long pos2 ;
  ddf_bigrange lstart ;
  ddf_bigrange k ;
  ddf_bigrange n ;
  set_type linset ;
  set_type allset ;
  ddf_boolean adj ;

  {
#line 1765
  F = (ddf_SetFamilyPtr )((void *)0);
#line 1771
  if (poly->n == 0L) {
#line 1771
    if (poly->homogeneous) {
#line 1771
      if ((unsigned int )poly->representation == 1U) {
#line 1772
        n = (ddf_bigrange )1;
      } else {
#line 1773
        n = poly->n;
      }
    } else {
#line 1773
      n = poly->n;
    }
  } else {
#line 1773
    n = poly->n;
  }
  {
#line 1774
  set_initialize(& linset, n);
#line 1775
  set_initialize(& allset, n);
  }
#line 1776
  if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 1776
    goto _L99;
  } else
#line 1776
  if ((unsigned int )(poly->child)->CompStatus != 1U) {
#line 1776
    goto _L99;
  }
  {
#line 1777
  F = ddf_CreateSetFamily(n, n);
  }
#line 1778
  if (n <= 0L) {
#line 1778
    goto _L99;
  }
#line 1779
  ((poly->child)->LastRay)->Next = (ddf_RayPtr )((void *)0);
#line 1780
  RayPtr1 = (poly->child)->FirstRay;
#line 1780
  pos1 = 1L;
  {
#line 1780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1780
    if (! ((unsigned long )RayPtr1 != (unsigned long )((void *)0))) {
#line 1780
      goto while_break;
    }
#line 1782
    RayPtr2 = (poly->child)->FirstRay;
#line 1782
    pos2 = 1L;
    {
#line 1782
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1782
      if (! ((unsigned long )RayPtr2 != (unsigned long )((void *)0))) {
#line 1782
        goto while_break___0;
      }
#line 1784
      if ((unsigned long )RayPtr1 != (unsigned long )RayPtr2) {
        {
#line 1785
        ddf_CheckAdjacency(poly->child, & RayPtr1, & RayPtr2, & adj);
        }
#line 1786
        if (adj) {
          {
#line 1787
          set_addelem(*(F->set + (pos1 - 1L)), pos2);
          }
        }
      }
#line 1782
      RayPtr2 = RayPtr2->Next;
#line 1782
      pos2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1780
    RayPtr1 = RayPtr1->Next;
#line 1780
    pos1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1792
  lstart = (poly->n - poly->ldim) + 1L;
#line 1793
  set_compl(allset, allset);
#line 1794
  k = lstart;
  }
  {
#line 1794
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1794
    if (! (k <= poly->n)) {
#line 1794
      goto while_break___1;
    }
    {
#line 1795
    set_addelem(linset, k);
#line 1796
    set_copy(*(F->set + (k - 1L)), allset);
#line 1794
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1798
  k = (ddf_bigrange )1;
  {
#line 1798
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1798
    if (! (k < lstart)) {
#line 1798
      goto while_break___2;
    }
    {
#line 1799
    set_uni(*(F->set + (k - 1L)), *(F->set + (k - 1L)), linset);
#line 1798
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  _L99: 
  {
#line 1803
  set_free(allset);
#line 1803
  set_free(linset);
  }
#line 1804
  return (F);
}
}
#line 1807 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_SetFamilyPtr ddf_CopyInputAdjacency(ddf_PolyhedraPtr poly ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange j ;
  ddf_SetFamilyPtr F ;
  ddf_boolean tmp ;

  {
#line 1810
  F = (ddf_SetFamilyPtr )((void *)0);
#line 1812
  if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 1812
    goto _L99;
  } else
#line 1812
  if ((unsigned int )(poly->child)->CompStatus != 1U) {
#line 1812
    goto _L99;
  }
#line 1813
  if (poly->AincGenerated == 0) {
    {
#line 1813
    ddf_ComputeAinc(poly);
    }
  }
  {
#line 1814
  F = ddf_CreateSetFamily(poly->m1, poly->m1);
#line 1815
  i = (ddf_rowrange )1;
  }
  {
#line 1815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1815
    if (! (i <= poly->m1)) {
#line 1815
      goto while_break;
    }
#line 1816
    j = (ddf_rowrange )1;
    {
#line 1816
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1816
      if (! (j <= poly->m1)) {
#line 1816
        goto while_break___0;
      }
#line 1817
      if (i != j) {
        {
#line 1817
        tmp = ddf_InputAdjacentQ(poly, i, j);
        }
#line 1817
        if (tmp) {
          {
#line 1818
          set_addelem(*(F->set + (i - 1L)), j);
          }
        }
      }
#line 1816
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1815
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 1823
  return (F);
}
}
#line 1826 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_CopyOutput(ddf_PolyhedraPtr poly ) 
{ 
  ddf_RayPtr RayPtr ;
  ddf_MatrixPtr M ;
  ddf_rowrange i ;
  ddf_rowrange total ;
  ddf_colrange j ;
  ddf_colrange j1___0 ;
  myfloat b ;
  ddf_RepresentationType outputrep ;
  ddf_boolean outputorigin ;
  ddf_boolean tmp ;

  {
  {
#line 1829
  M = (ddf_MatrixPtr )((void *)0);
#line 1830
  i = (ddf_rowrange )0;
#line 1833
  outputrep = (ddf_RepresentationType )1;
#line 1834
  outputorigin = 0;
#line 1836
  dddf_init((double *)(b));
#line 1837
  total = (poly->child)->LinearityDim + (poly->child)->FeasibleRayCount;
  }
#line 1839
  if ((poly->child)->d <= 0L) {
#line 1839
    total --;
  } else
#line 1839
  if (*((poly->child)->newcol + 1) == 0L) {
#line 1839
    total --;
  }
#line 1840
  if ((unsigned int )poly->representation == 1U) {
#line 1840
    outputrep = (ddf_RepresentationType )2;
  }
#line 1841
  if (total == 0L) {
#line 1841
    if (poly->homogeneous) {
#line 1841
      if ((unsigned int )poly->representation == 1U) {
#line 1842
        total = (ddf_rowrange )1;
#line 1843
        outputorigin = 1;
      }
    }
  }
#line 1846
  if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 1846
    goto _L99;
  } else
#line 1846
  if ((unsigned int )(poly->child)->CompStatus != 1U) {
#line 1846
    goto _L99;
  }
  {
#line 1848
  M = ddf_CreateMatrix(total, poly->d);
#line 1849
  RayPtr = (poly->child)->FirstRay;
  }
  {
#line 1850
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1850
    if (! ((unsigned long )RayPtr != (unsigned long )((void *)0))) {
#line 1850
      goto while_break;
    }
#line 1851
    if (RayPtr->feasible) {
      {
#line 1852
      ddf_CopyRay(*(M->matrix + i), poly->d, RayPtr, outputrep, (poly->child)->newcol);
#line 1853
      i ++;
      }
    }
#line 1855
    RayPtr = RayPtr->Next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1857
  j = (ddf_colrange )2;
  {
#line 1857
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1857
    if (! (j <= poly->d)) {
#line 1857
      goto while_break___0;
    }
#line 1858
    if (*((poly->child)->newcol + j) == 0L) {
      {
#line 1860
      dddf_set((double *)(b), (double *)(*(*((poly->child)->Bsave + 0) + (j - 1L))));
      }
#line 1861
      if ((unsigned int )outputrep == 2U) {
        {
#line 1861
        tmp = ddf_Positive((double *)(b));
        }
#line 1861
        if (tmp) {
          {
#line 1862
          dddf_set((double *)(*(*(M->matrix + i) + 0)), (double *)(ddf_one));
#line 1863
          j1___0 = (ddf_colrange )1;
          }
          {
#line 1863
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1863
            if (! (j1___0 < poly->d)) {
#line 1863
              goto while_break___1;
            }
            {
#line 1864
            dddf_div((double *)(*(*(M->matrix + i) + j1___0)), (double *)(*(*((poly->child)->Bsave + j1___0) + (j - 1L))),
                     (double *)(b));
#line 1863
            j1___0 ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 1861
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1866
        j1___0 = (ddf_colrange )0;
        {
#line 1866
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1866
          if (! (j1___0 < poly->d)) {
#line 1866
            goto while_break___2;
          }
          {
#line 1867
          dddf_set((double *)(*(*(M->matrix + i) + j1___0)), (double *)(*(*((poly->child)->Bsave + j1___0) + (j - 1L))));
#line 1866
          j1___0 ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 1869
      set_addelem(M->linset, i + 1L);
#line 1870
      i ++;
      }
    }
#line 1857
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1873
  if (outputorigin) {
    {
#line 1875
    dddf_set((double *)(*(*(M->matrix + 0) + 0)), (double *)(ddf_one));
#line 1876
    j = (ddf_colrange )1;
    }
    {
#line 1876
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1876
      if (! (j < poly->d)) {
#line 1876
        goto while_break___3;
      }
      {
#line 1877
      dddf_set((double *)(*(*(M->matrix + 0) + j)), (double *)(ddf_purezero));
#line 1876
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 1880
  ddf_MatrixIntegerFilter(M);
  }
#line 1881
  if ((unsigned int )poly->representation == 1U) {
#line 1882
    M->representation = (ddf_RepresentationType )2;
  } else {
#line 1884
    M->representation = (ddf_RepresentationType )1;
  }
  _L99: 
  {
#line 1886
  dddf_clear((double *)(b));
  }
#line 1887
  return (M);
}
}
#line 1890 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_CopyInput(ddf_PolyhedraPtr poly ) 
{ 
  ddf_MatrixPtr M ;
  ddf_rowrange i ;

  {
  {
#line 1892
  M = (ddf_MatrixPtr )((void *)0);
#line 1895
  M = ddf_CreateMatrix(poly->m, poly->d);
#line 1896
  ddf_CopyAmatrix(M->matrix, poly->A, poly->m, poly->d);
#line 1897
  i = (ddf_rowrange )1;
  }
  {
#line 1897
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1897
    if (! (i <= poly->m)) {
#line 1897
      goto while_break;
    }
#line 1898
    if (*(poly->EqualityIndex + i) == 1) {
      {
#line 1898
      set_addelem(M->linset, i);
      }
    }
#line 1897
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1899
  ddf_MatrixIntegerFilter(M);
  }
#line 1900
  if ((unsigned int )poly->representation == 2U) {
#line 1901
    M->representation = (ddf_RepresentationType )2;
  } else {
#line 1903
    M->representation = (ddf_RepresentationType )1;
  }
#line 1904
  return (M);
}
}
#line 1907 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_CopyGenerators(ddf_PolyhedraPtr poly ) 
{ 
  ddf_MatrixPtr M ;

  {
#line 1909
  M = (ddf_MatrixPtr )((void *)0);
#line 1911
  if ((unsigned int )poly->representation == 2U) {
    {
#line 1912
    M = ddf_CopyInput(poly);
    }
  } else {
    {
#line 1914
    M = ddf_CopyOutput(poly);
    }
  }
#line 1916
  return (M);
}
}
#line 1919 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
ddf_MatrixPtr ddf_CopyInequalities(ddf_PolyhedraPtr poly ) 
{ 
  ddf_MatrixPtr M ;

  {
#line 1921
  M = (ddf_MatrixPtr )((void *)0);
#line 1923
  if ((unsigned int )poly->representation == 1U) {
    {
#line 1924
    M = ddf_CopyInput(poly);
    }
  } else {
    {
#line 1926
    M = ddf_CopyOutput(poly);
    }
  }
#line 1928
  return (M);
}
}
#line 1934 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_sread_rational_value(char const   *s , double *value ) 
{ 
  char *numerator_s ;
  char *denominator_s ;
  char *position ;
  int sign ;
  double numerator ;
  double denominator ;
  double rvalue ;
  long tmp ;
  long tmp___0 ;

  {
#line 1938
  numerator_s = (char *)((void *)0);
#line 1938
  denominator_s = (char *)((void *)0);
#line 1939
  sign = 1;
#line 1948
  numerator_s = (char *)s;
#line 1949
  if ((int const   )*(s + 0) == 45) {
#line 1950
    sign = -1;
#line 1951
    numerator_s ++;
  } else
#line 1953
  if ((int const   )*(s + 0) == 43) {
#line 1954
    numerator_s ++;
  }
  {
#line 1957
  position = strchr((char const   *)numerator_s, '/');
  }
#line 1958
  if ((unsigned long )position != (unsigned long )((void *)0)) {
#line 1959
    *position = (char )'\000';
#line 1960
    denominator_s = position + 1;
  }
  {
#line 1964
  tmp = atol((char const   *)numerator_s);
#line 1964
  numerator = (double )tmp;
  }
#line 1966
  if ((unsigned long )position != (unsigned long )((void *)0)) {
    {
#line 1968
    tmp___0 = atol((char const   *)denominator_s);
#line 1968
    denominator = (double )tmp___0;
    }
  } else {
#line 1970
    denominator = (double )1;
  }
  {
#line 1993
  rvalue = ((double )sign * numerator) / (double )((long )denominator);
#line 1994
  dddf_set_d(value, rvalue);
  }
#line 1996
  if (ddf_debug) {
    {
#line 1997
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rational_read: ");
#line 1998
    ddf_WriteNumber(stderr, value);
#line 1998
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 2000
  return;
}
}
#line 2003 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
void ddf_fread_rational_value(FILE *f , double *value ) 
{ 
  char number_s[1024] ;
  myfloat rational_value ;

  {
  {
#line 2010
  dddf_init((double *)(rational_value));
#line 2011
  fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s ", number_s);
#line 2012
  ddf_sread_rational_value((char const   *)(number_s), (double *)(rational_value));
#line 2013
  dddf_set(value, (double *)(rational_value));
#line 2014
  dddf_clear((double *)(rational_value));
  }
#line 2015
  return;
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 629 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpz_abs(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) ;
#line 805
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 810
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 815
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 841
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 846
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n )  __attribute__((__pure__)) ;
#line 948
__inline extern void __gmpz_neg(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) ;
#line 969
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a )  __attribute__((__pure__)) ;
#line 974
__inline extern mp_bitcnt_t __gmpz_popcount(mpz_srcptr __gmp_u )  __attribute__((__pure__)) ;
#line 1020
extern void __gmpz_set(mpz_ptr  , mpz_srcptr  ) ;
#line 1030
__inline extern void __gmpz_set_q(mpz_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1047
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1081
extern void __gmpz_tdiv_q(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 1125
__inline extern void __gmpq_abs(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1192
__inline extern void __gmpq_neg(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1201
extern void __gmpq_set(mpq_ptr  , mpq_srcptr  ) ;
#line 1447
__inline extern mp_limb_t __gmpn_add(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) ;
#line 1452
__inline extern mp_limb_t __gmpn_add_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) ;
#line 1456
extern mp_limb_t __gmpn_add_n(mp_ptr  , mp_srcptr  , mp_srcptr  , mp_size_t  ) ;
#line 1463
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size )  __attribute__((__pure__)) ;
#line 1525
__inline extern mp_limb_t __gmpn_neg(mp_ptr __gmp_rp , mp_srcptr __gmp_up , mp_size_t __gmp_n ) ;
#line 1534
extern int __gmpn_perfect_square_p(mp_srcptr  , mp_size_t  )  __attribute__((__pure__)) ;
#line 1540
extern mp_bitcnt_t __gmpn_popcount(mp_srcptr  , mp_size_t  )  __attribute__((__pure__)) ;
#line 1572
__inline extern mp_limb_t __gmpn_sub(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) ;
#line 1577
__inline extern mp_limb_t __gmpn_sub_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) ;
#line 1581
extern mp_limb_t __gmpn_sub_n(mp_ptr  , mp_srcptr  , mp_srcptr  , mp_size_t  ) ;
#line 1630 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpz_abs(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) 
{ 


  {
#line 1633
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1634
    __gmpz_set(__gmp_w, __gmp_u);
    }
  }
#line 1635
  if (__gmp_w->_mp_size >= 0) {
#line 1635
    __gmp_w->_mp_size = __gmp_w->_mp_size;
  } else {
#line 1635
    __gmp_w->_mp_size = - __gmp_w->_mp_size;
  }
#line 1636
  return;
}
}
#line 1654
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1654 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
#line 1659
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1659
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1659
  if (__gmp_n == 0L) {
#line 1659
    tmp = 1;
  } else
#line 1659
  if (__gmp_n == 1L) {
#line 1659
    if (*(__gmp_p + 0) <= 4294967295UL) {
#line 1659
      tmp = 1;
    } else {
#line 1659
      tmp = 0;
    }
  } else {
#line 1659
    tmp = 0;
  }
#line 1659
  return (tmp);
}
}
#line 1665
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1665 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
#line 1670
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1670
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1670
  if (__gmp_n == 0L) {
#line 1670
    tmp = 1;
  } else
#line 1670
  if (__gmp_n == 1L) {
#line 1670
    if (*(__gmp_p + 0) <= 0xffffffffffffffffUL) {
#line 1670
      tmp = 1;
    } else {
#line 1670
      tmp = 0;
    }
  } else {
#line 1670
    tmp = 0;
  }
#line 1670
  return (tmp);
}
}
#line 1676
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1676 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
#line 1681
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1681
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1681
  if (__gmp_n == 0L) {
#line 1681
    tmp = 1;
  } else
#line 1681
  if (__gmp_n == 1L) {
#line 1681
    if (*(__gmp_p + 0) <= 65535UL) {
#line 1681
      tmp = 1;
    } else {
#line 1681
      tmp = 0;
    }
  } else {
#line 1681
    tmp = 0;
  }
#line 1681
  return (tmp);
}
}
#line 1687
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1687 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z ) 
{ 
  mp_ptr __gmp_p ;
  mp_size_t __gmp_n ;
  mp_limb_t __gmp_l ;
  mp_limb_t tmp ;

  {
#line 1692
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1693
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1694
  __gmp_l = *(__gmp_p + 0);
#line 1701
  if (__gmp_n != 0L) {
#line 1701
    tmp = __gmp_l;
  } else {
#line 1701
    tmp = (mp_limb_t )0;
  }
#line 1701
  return (tmp);
}
}
#line 1715
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n )  __attribute__((__pure__)) ;
#line 1715 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n ) 
{ 
  mp_limb_t __gmp_result ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 1720
  __gmp_result = (mp_limb_t )0;
#line 1721
  if (__gmp_n >= 0L) {
#line 1721
    if (__gmp_z->_mp_size >= 0) {
#line 1721
      tmp = __gmp_z->_mp_size;
    } else {
#line 1721
      tmp = - __gmp_z->_mp_size;
    }
#line 1721
    if (__gmp_n < (mp_size_t )tmp) {
#line 1721
      tmp___0 = 1;
    } else {
#line 1721
      tmp___0 = 0;
    }
  } else {
#line 1721
    tmp___0 = 0;
  }
  {
#line 1721
  tmp___1 = __builtin_expect((long )(tmp___0 != 0), 1L);
  }
#line 1721
  if (tmp___1) {
#line 1722
    __gmp_result = *(__gmp_z->_mp_d + __gmp_n);
  }
#line 1723
  return (__gmp_result);
}
}
#line 1728 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpz_neg(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) 
{ 


  {
#line 1731
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1732
    __gmpz_set(__gmp_w, __gmp_u);
    }
  }
#line 1733
  __gmp_w->_mp_size = - __gmp_w->_mp_size;
#line 1734
  return;
}
}
#line 1739
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a )  __attribute__((__pure__)) ;
#line 1739 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a ) 
{ 
  mp_size_t __gmp_asize ;
  int __gmp_result ;
  long tmp ;

  {
  {
#line 1747
  __gmp_asize = (mp_size_t )__gmp_a->_mp_size;
#line 1748
  __gmp_result = __gmp_asize >= 0L;
#line 1749
  tmp = __builtin_expect((long )((__gmp_asize > 0L) != 0), 1L);
  }
#line 1749
  if (tmp) {
    {
#line 1750
    __gmp_result = __gmpn_perfect_square_p((mp_srcptr )__gmp_a->_mp_d, __gmp_asize);
    }
  }
#line 1751
  return (__gmp_result);
}
}
#line 1757
__inline extern mp_bitcnt_t __gmpz_popcount(mpz_srcptr __gmp_u )  __attribute__((__pure__)) ;
#line 1757 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_bitcnt_t __gmpz_popcount(mpz_srcptr __gmp_u ) 
{ 
  mp_size_t __gmp_usize ;
  mp_bitcnt_t __gmp_result ;
  long tmp ;

  {
#line 1765
  __gmp_usize = (mp_size_t )__gmp_u->_mp_size;
#line 1766
  if (__gmp_usize < 0L) {
#line 1766
    __gmp_result = ~ 0UL;
  } else {
#line 1766
    __gmp_result = (mp_bitcnt_t )0;
  }
  {
#line 1767
  tmp = __builtin_expect((long )((__gmp_usize > 0L) != 0), 1L);
  }
#line 1767
  if (tmp) {
    {
#line 1768
    __gmp_result = __gmpn_popcount((mp_srcptr )__gmp_u->_mp_d, __gmp_usize);
    }
  }
#line 1769
  return (__gmp_result);
}
}
#line 1775 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpz_set_q(mpz_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
  {
#line 1780
  __gmpz_tdiv_q(__gmp_w, & __gmp_u->_mp_num, & __gmp_u->_mp_den);
  }
#line 1781
  return;
}
}
#line 1786
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1786 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z ) 
{ 
  int tmp ;

  {
#line 1791
  if (__gmp_z->_mp_size >= 0) {
#line 1791
    tmp = __gmp_z->_mp_size;
  } else {
#line 1791
    tmp = - __gmp_z->_mp_size;
  }
#line 1791
  return ((size_t )tmp);
}
}
#line 1799 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpq_abs(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
#line 1802
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1803
    __gmpq_set(__gmp_w, __gmp_u);
    }
  }
#line 1804
  if (__gmp_w->_mp_num._mp_size >= 0) {
#line 1804
    __gmp_w->_mp_num._mp_size = __gmp_w->_mp_num._mp_size;
  } else {
#line 1804
    __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
  }
#line 1805
  return;
}
}
#line 1809 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpq_neg(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
#line 1812
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1813
    __gmpq_set(__gmp_w, __gmp_u);
    }
  }
#line 1814
  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
#line 1815
  return;
}
}
#line 2052 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_add(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_size_t tmp ;
  mp_limb_t tmp___0 ;
  mp_limb_t tmp___1 ;
  mp_size_t __gmp_j ;

  {
  {
#line 2058
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2058
    __gmp_i = __gmp_ysize;
#line 2058
    if (__gmp_i != 0L) {
      {
#line 2058
      tmp___1 = __gmpn_add_n(__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i);
      }
#line 2058
      if (tmp___1) {
        {
#line 2058
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2058
          if (__gmp_i >= __gmp_xsize) {
#line 2058
            __gmp_c = (mp_limb_t )1;
#line 2058
            goto __gmp_done;
          }
#line 2058
          __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2058
          tmp = __gmp_i;
#line 2058
          __gmp_i ++;
#line 2058
          tmp___0 = (__gmp_x + 1UL) & 0xffffffffffffffffUL;
#line 2058
          *(__gmp_wp + tmp) = tmp___0;
#line 2058
          if (! (tmp___0 == 0UL)) {
#line 2058
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 2058
    if ((unsigned long )__gmp_wp != (unsigned long )__gmp_xp) {
      {
#line 2058
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2058
        __gmp_j = __gmp_i;
        {
#line 2058
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2058
          if (! (__gmp_j < __gmp_xsize)) {
#line 2058
            goto while_break___2;
          }
#line 2058
          *(__gmp_wp + __gmp_j) = (mp_limb_t )*(__gmp_xp + __gmp_j);
#line 2058
          __gmp_j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2058
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2058
    __gmp_c = (mp_limb_t )0;
    __gmp_done: ;
#line 2058
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2059
  return (__gmp_c);
}
}
#line 2065 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_add_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_r ;
  mp_size_t __gmp_j ;
  mp_size_t __gmp_j___0 ;

  {
  {
#line 2071
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2071
    __gmp_x = (mp_limb_t )*(__gmp_src + 0);
#line 2071
    __gmp_r = __gmp_x + __gmp_n;
#line 2071
    *(__gmp_dst + 0) = __gmp_r;
#line 2071
    if (__gmp_r < __gmp_n) {
#line 2071
      __gmp_c = (mp_limb_t )1;
#line 2071
      __gmp_i = (mp_size_t )1;
      {
#line 2071
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2071
        if (! (__gmp_i < __gmp_size)) {
#line 2071
          goto while_break___0;
        }
#line 2071
        __gmp_x = (mp_limb_t )*(__gmp_src + __gmp_i);
#line 2071
        __gmp_r = __gmp_x + 1UL;
#line 2071
        *(__gmp_dst + __gmp_i) = __gmp_r;
#line 2071
        __gmp_i ++;
#line 2071
        if (! (__gmp_r < 1UL)) {
#line 2071
          if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
            {
#line 2071
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2071
              __gmp_j = __gmp_i;
              {
#line 2071
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 2071
                if (! (__gmp_j < __gmp_size)) {
#line 2071
                  goto while_break___2;
                }
#line 2071
                *(__gmp_dst + __gmp_j) = (mp_limb_t )*(__gmp_src + __gmp_j);
#line 2071
                __gmp_j ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 2071
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 2071
          __gmp_c = (mp_limb_t )0;
#line 2071
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 2071
      if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
        {
#line 2071
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2071
          __gmp_j___0 = (mp_size_t )1;
          {
#line 2071
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2071
            if (! (__gmp_j___0 < __gmp_size)) {
#line 2071
              goto while_break___4;
            }
#line 2071
            *(__gmp_dst + __gmp_j___0) = (mp_limb_t )*(__gmp_src + __gmp_j___0);
#line 2071
            __gmp_j___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 2071
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2071
      __gmp_c = (mp_limb_t )0;
    }
#line 2071
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2072
  return (__gmp_c);
}
}
#line 2078
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size )  __attribute__((__pure__)) ;
#line 2078 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size ) 
{ 
  int __gmp_result ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_y ;

  {
  {
#line 2084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2084
    __gmp_result = 0;
#line 2084
    __gmp_i = __gmp_size;
    {
#line 2084
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2084
      __gmp_i --;
#line 2084
      if (! (__gmp_i >= 0L)) {
#line 2084
        goto while_break___0;
      }
#line 2084
      __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2084
      __gmp_y = (mp_limb_t )*(__gmp_yp + __gmp_i);
#line 2084
      if (__gmp_x != __gmp_y) {
#line 2084
        if (__gmp_x > __gmp_y) {
#line 2084
          __gmp_result = 1;
        } else {
#line 2084
          __gmp_result = -1;
        }
#line 2084
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2084
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2085
  return (__gmp_result);
}
}
#line 2091 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_sub(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_size_t tmp ;
  mp_limb_t tmp___0 ;
  mp_size_t __gmp_j ;

  {
  {
#line 2097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2097
    __gmp_i = __gmp_ysize;
#line 2097
    if (__gmp_i != 0L) {
      {
#line 2097
      tmp___0 = __gmpn_sub_n(__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i);
      }
#line 2097
      if (tmp___0) {
        {
#line 2097
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2097
          if (__gmp_i >= __gmp_xsize) {
#line 2097
            __gmp_c = (mp_limb_t )1;
#line 2097
            goto __gmp_done;
          }
#line 2097
          __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2097
          tmp = __gmp_i;
#line 2097
          __gmp_i ++;
#line 2097
          *(__gmp_wp + tmp) = (__gmp_x - 1UL) & 0xffffffffffffffffUL;
#line 2097
          if (! (__gmp_x == 0UL)) {
#line 2097
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 2097
    if ((unsigned long )__gmp_wp != (unsigned long )__gmp_xp) {
      {
#line 2097
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2097
        __gmp_j = __gmp_i;
        {
#line 2097
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2097
          if (! (__gmp_j < __gmp_xsize)) {
#line 2097
            goto while_break___2;
          }
#line 2097
          *(__gmp_wp + __gmp_j) = (mp_limb_t )*(__gmp_xp + __gmp_j);
#line 2097
          __gmp_j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2097
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2097
    __gmp_c = (mp_limb_t )0;
    __gmp_done: ;
#line 2097
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2098
  return (__gmp_c);
}
}
#line 2104 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_sub_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_r ;
  mp_size_t __gmp_j ;
  mp_size_t __gmp_j___0 ;

  {
  {
#line 2110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2110
    __gmp_x = (mp_limb_t )*(__gmp_src + 0);
#line 2110
    __gmp_r = __gmp_x - __gmp_n;
#line 2110
    *(__gmp_dst + 0) = __gmp_r;
#line 2110
    if (__gmp_x < __gmp_n) {
#line 2110
      __gmp_c = (mp_limb_t )1;
#line 2110
      __gmp_i = (mp_size_t )1;
      {
#line 2110
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2110
        if (! (__gmp_i < __gmp_size)) {
#line 2110
          goto while_break___0;
        }
#line 2110
        __gmp_x = (mp_limb_t )*(__gmp_src + __gmp_i);
#line 2110
        __gmp_r = __gmp_x - 1UL;
#line 2110
        *(__gmp_dst + __gmp_i) = __gmp_r;
#line 2110
        __gmp_i ++;
#line 2110
        if (! (__gmp_x < 1UL)) {
#line 2110
          if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
            {
#line 2110
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2110
              __gmp_j = __gmp_i;
              {
#line 2110
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 2110
                if (! (__gmp_j < __gmp_size)) {
#line 2110
                  goto while_break___2;
                }
#line 2110
                *(__gmp_dst + __gmp_j) = (mp_limb_t )*(__gmp_src + __gmp_j);
#line 2110
                __gmp_j ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 2110
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 2110
          __gmp_c = (mp_limb_t )0;
#line 2110
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 2110
      if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
        {
#line 2110
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2110
          __gmp_j___0 = (mp_size_t )1;
          {
#line 2110
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2110
            if (! (__gmp_j___0 < __gmp_size)) {
#line 2110
              goto while_break___4;
            }
#line 2110
            *(__gmp_dst + __gmp_j___0) = (mp_limb_t )*(__gmp_src + __gmp_j___0);
#line 2110
            __gmp_j___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 2110
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2110
      __gmp_c = (mp_limb_t )0;
    }
#line 2110
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2111
  return (__gmp_c);
}
}
#line 2117 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_neg(mp_ptr __gmp_rp , mp_srcptr __gmp_up , mp_size_t __gmp_n ) 
{ 
  mp_limb_t __gmp_ul ;
  mp_limb_t __gmp_cy ;
  mp_srcptr tmp ;
  mp_ptr tmp___0 ;

  {
#line 2123
  __gmp_cy = (mp_limb_t )0;
  {
#line 2124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2125
    tmp = __gmp_up;
#line 2125
    __gmp_up ++;
#line 2125
    __gmp_ul = (mp_limb_t )*tmp;
#line 2126
    tmp___0 = __gmp_rp;
#line 2126
    __gmp_rp ++;
#line 2126
    *tmp___0 = - __gmp_ul - __gmp_cy;
#line 2127
    __gmp_cy |= (unsigned long )(__gmp_ul != 0UL);
#line 2124
    __gmp_n --;
#line 2124
    if (! (__gmp_n != 0L)) {
#line 2124
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2129
  return (__gmp_cy);
}
}
#line 120 "../lib-src-gmp/cddmp.h"
void dd_set_global_constants(void) ;
#line 121
void dd_free_global_constants(void) ;
#line 65 "../lib-src-gmp/cdd.h"
void dd_FreeSetFamily(dd_SetFamilyPtr F ) ;
#line 71
void dd_FreePolyhedra(dd_PolyhedraPtr poly ) ;
#line 72
void dd_FreeMatrix(dd_MatrixPtr M ) ;
#line 92
dd_MatrixPtr dd_CopyInequalities(dd_PolyhedraPtr poly ) ;
#line 93
dd_MatrixPtr dd_CopyGenerators(dd_PolyhedraPtr poly ) ;
#line 94
dd_SetFamilyPtr dd_CopyIncidence(dd_PolyhedraPtr poly ) ;
#line 95
dd_SetFamilyPtr dd_CopyAdjacency(dd_PolyhedraPtr poly ) ;
#line 100
dd_MatrixPtr dd_PolyFile2Matrix(FILE *f , dd_ErrorType *Error ) ;
#line 102
dd_PolyhedraPtr dd_DDMatrix2Poly(dd_MatrixPtr M , dd_ErrorType *err ) ;
#line 149
void dd_SetInputFile(FILE **f , char *inputfile , dd_ErrorType *Error ) ;
#line 155
void dd_WriteMatrix(FILE *f , dd_MatrixPtr M ) ;
#line 162
void dd_WriteErrorMessages(FILE *f , dd_ErrorType Error ) ;
#line 163
void dd_WriteSetFamily(FILE *f , dd_SetFamilyPtr F ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/src-gmp/testcdd1.c"
dd_boolean SetInputFile(FILE **f , char *fname ) 
{ 
  dd_boolean success ;
  FILE *tmp ;

  {
  {
#line 32
  success = 0;
#line 34
  tmp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
#line 34
  *f = tmp;
  }
#line 34
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    {
#line 35
    printf((char const   */* __restrict  */)"input file %s is open\n", fname);
#line 36
    success = 1;
    }
  } else {
    {
#line 39
    printf((char const   */* __restrict  */)"The input file %s not found\n", fname);
    }
  }
#line 41
  return (success);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/src-gmp/testcdd1.c"
int main(int argc , char **argv ) 
{ 
  dd_PolyhedraPtr poly ;
  dd_MatrixPtr M ;
  dd_ErrorType err ;
  dd_DataFileType inputfile ;
  FILE *reading___0 ;
  dd_MatrixPtr A ;
  dd_MatrixPtr G ;
  dd_SetFamilyPtr GI ;
  dd_SetFamilyPtr GA ;

  {
  {
#line 50
  reading___0 = (FILE *)((void *)0);
#line 54
  dd_set_global_constants();
#line 56
  dd_SetInputFile(& reading___0, (char *)(inputfile), & err);
  }
#line 57
  if ((unsigned int )err == 17U) {
    {
#line 58
    M = dd_PolyFile2Matrix(reading___0, & err);
    }
  } else {
    {
#line 61
    printf((char const   */* __restrict  */)"Input file not found\n");
    }
#line 62
    goto _L99;
  }
#line 65
  if ((unsigned int )err == 17U) {
    {
#line 66
    poly = dd_DDMatrix2Poly(M, & err);
    }
#line 67
    if ((unsigned int )err != 17U) {
      {
#line 68
      dd_WriteErrorMessages(stdout, err);
      }
#line 68
      goto _L99;
    }
    {
#line 70
    A = dd_CopyInequalities(poly);
#line 71
    G = dd_CopyGenerators(poly);
#line 72
    GI = dd_CopyIncidence(poly);
#line 73
    GA = dd_CopyAdjacency(poly);
    }
#line 75
    if ((unsigned int )poly->representation == 1U) {
      {
#line 76
      printf((char const   */* __restrict  */)"\nInput is an H-representation\n");
      }
    } else {
      {
#line 78
      printf((char const   */* __restrict  */)"\nInput is a V-representation\n");
      }
    }
    {
#line 80
    dd_WriteMatrix(stdout, A);
#line 80
    printf((char const   */* __restrict  */)"\n");
#line 81
    dd_WriteMatrix(stdout, G);
#line 83
    printf((char const   */* __restrict  */)"\nHere is the incidence list:\n");
#line 84
    dd_WriteSetFamily(stdout, GI);
#line 86
    printf((char const   */* __restrict  */)"\nHere is the adjacency list:\n");
#line 87
    dd_WriteSetFamily(stdout, GA);
#line 89
    dd_FreePolyhedra(poly);
#line 91
    dd_FreeMatrix(M);
#line 92
    dd_FreeMatrix(A);
#line 93
    dd_FreeMatrix(G);
#line 94
    dd_FreeSetFamily(GI);
#line 95
    dd_FreeSetFamily(GA);
    }
  } else {
    {
#line 97
    dd_WriteErrorMessages(stdout, err);
    }
  }
  _L99: 
  {
#line 100
  dd_free_global_constants();
  }
#line 101
  return (0);
}
}
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.h"
void set_diff(set_type set , set_type set1 , set_type set2 ) ;
#line 39
void set_write(set_type set ) ;
#line 1129 "/usr/include/x86_64-linux-gnu/gmp.h"
extern void __gmpq_add(mpq_ptr  , mpq_srcptr  , mpq_srcptr  ) ;
#line 1135
extern void __gmpq_clear(mpq_ptr  ) ;
#line 1150
extern void __gmpq_div(mpq_ptr  , mpq_srcptr  , mpq_srcptr  ) ;
#line 1165
extern double __gmpq_get_d(mpq_srcptr  )  __attribute__((__pure__)) ;
#line 1171
extern void __gmpq_init(mpq_ptr  ) ;
#line 1185
extern void __gmpq_mul(mpq_ptr  , mpq_srcptr  , mpq_srcptr  ) ;
#line 1228
extern void __gmpq_sub(mpq_ptr  , mpq_srcptr  , mpq_srcptr  ) ;
#line 102 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp.h"
void ddd_mpq_set_si(__mpq_struct *a___41 , long b ) ;
#line 328 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
dd_boolean dd_debug ;
#line 188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
void ddf_CrissCrossSolve(ddf_LPPtr lp , ddf_ErrorType *err ) ;
#line 189
void ddf_DualSimplexSolve(ddf_LPPtr lp , ddf_ErrorType *err ) ;
#line 195
ddf_LPPtr ddf_CreateLPData(ddf_LPObjectiveType obj , ddf_NumberType nt , ddf_rowrange m ,
                           ddf_colrange d ) ;
#line 203
void ddf_FreeLPData(ddf_LPPtr lp ) ;
#line 206
void ddf_WriteLPResult(FILE *f , ddf_LPPtr lp , ddf_ErrorType err ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
mytype dd_one ;
#line 34
mytype dd_purezero ;
#line 35
mytype dd_minuszero ;
#line 36
mytype dd_minusone ;
#line 39
long dd_statBApivots ;
#line 40
long dd_statCCpivots ;
#line 41
long dd_statDS1pivots ;
#line 42
long dd_statDS2pivots ;
#line 43
long dd_statACpivots ;
#line 45
long dd_statBSpivots ;
#line 47
dd_LPSolverType dd_choiceLPSolverDefault ;
#line 48
dd_LPSolverType dd_choiceRedcheckAlgorithm ;
#line 49
dd_boolean dd_choiceLexicoPivotQ ;
#line 61
void dd_InitializeArow(dd_colrange d , dd_Arow *a___41 ) ;
#line 62
void dd_InitializeAmatrix(dd_rowrange m , dd_colrange d , dd_Amatrix *A ) ;
#line 63
void dd_InitializeBmatrix(dd_colrange d , dd_Bmatrix *B ) ;
#line 64
dd_SetFamilyPtr dd_CreateSetFamily(dd_bigrange fsize , dd_bigrange ssize ) ;
#line 66
dd_MatrixPtr dd_CreateMatrix(dd_rowrange m_size , dd_colrange d_size ) ;
#line 67
void dd_FreeAmatrix(dd_rowrange m , dd_colrange d , dd_Amatrix A ) ;
#line 68
void dd_FreeArow(dd_colrange d , dd_Arow a___41 ) ;
#line 69
void dd_FreeBmatrix(dd_colrange d , dd_Bmatrix B ) ;
#line 73
void dd_SetToIdentity(dd_colrange d_size , dd_Bmatrix T ) ;
#line 76
dd_boolean dd_Nonnegative(__mpq_struct *val ) ;
#line 77
dd_boolean dd_Nonpositive(__mpq_struct *val ) ;
#line 78
dd_boolean dd_Positive(__mpq_struct *val ) ;
#line 79
dd_boolean dd_Negative(__mpq_struct *val ) ;
#line 80
dd_boolean dd_EqualToZero(__mpq_struct *val ) ;
#line 81
dd_boolean dd_Nonzero(__mpq_struct *val ) ;
#line 82
dd_boolean dd_Equal(__mpq_struct *val1 , __mpq_struct *val2 ) ;
#line 83
dd_boolean dd_Larger(__mpq_struct *val1 , __mpq_struct *val2 ) ;
#line 84
dd_boolean dd_Smaller(__mpq_struct *val1 , __mpq_struct *val2 ) ;
#line 87
void dd_InnerProduct(__mpq_struct *prod , dd_colrange d , dd_Arow v1 , dd_Arow v2 ) ;
#line 104
dd_boolean dd_Redundant(dd_MatrixPtr M , dd_rowrange itest , dd_Arow certificate ,
                        dd_ErrorType *error ) ;
#line 105
dd_rowset dd_RedundantRows(dd_MatrixPtr M , dd_ErrorType *error ) ;
#line 106
dd_boolean dd_SRedundant(dd_MatrixPtr M , dd_rowrange itest , dd_Arow certificate ,
                         dd_ErrorType *error ) ;
#line 107
dd_rowset dd_SRedundantRows(dd_MatrixPtr M , dd_ErrorType *error ) ;
#line 108
dd_rowset dd_RedundantRowsViaShooting(dd_MatrixPtr M , dd_ErrorType *error ) ;
#line 109
dd_rowrange dd_RayShooting(dd_MatrixPtr M , dd_Arow p , dd_Arow r ) ;
#line 111
dd_boolean dd_ImplicitLinearity(dd_MatrixPtr M , dd_rowrange itest , dd_Arow certificate ,
                                dd_ErrorType *error ) ;
#line 112
dd_rowset dd_ImplicitLinearityRows(dd_MatrixPtr M , dd_ErrorType *error ) ;
#line 113
int dd_FreeOfImplicitLinearity(dd_MatrixPtr M , dd_Arow certificate , dd_rowset *imp_linrows ,
                               dd_ErrorType *error ) ;
#line 114
dd_boolean dd_MatrixCanonicalizeLinearity(dd_MatrixPtr *M , dd_rowset *impl_linset ,
                                          dd_rowindex *newpos , dd_ErrorType *error ) ;
#line 115
dd_boolean dd_MatrixCanonicalize(dd_MatrixPtr *M , dd_rowset *impl_linset , dd_rowset *redset ,
                                 dd_rowindex *newpos , dd_ErrorType *error ) ;
#line 116
dd_boolean dd_MatrixRedundancyRemove(dd_MatrixPtr *M , dd_rowset *redset , dd_rowindex *newpos ,
                                     dd_ErrorType *error ) ;
#line 117
dd_boolean dd_FindRelativeInterior(dd_MatrixPtr M , dd_rowset *ImL , dd_rowset *Lbasis ,
                                   dd_LPSolutionPtr *lps , dd_ErrorType *err ) ;
#line 118
dd_boolean dd_ExistsRestrictedFace(dd_MatrixPtr M , dd_rowset R , dd_rowset S , dd_ErrorType *err ) ;
#line 119
dd_boolean dd_ExistsRestrictedFace2(dd_MatrixPtr M , dd_rowset R , dd_rowset S , dd_LPSolutionPtr *lps ,
                                    dd_ErrorType *err ) ;
#line 121
dd_SetFamilyPtr dd_Matrix2Adjacency(dd_MatrixPtr M , dd_ErrorType *error ) ;
#line 122
dd_SetFamilyPtr dd_Matrix2WeakAdjacency(dd_MatrixPtr M , dd_ErrorType *error ) ;
#line 123
long dd_MatrixRank(dd_MatrixPtr M , dd_rowset ignoredrows , dd_colset ignoredcols ,
                   dd_rowset *rowbasis , dd_colset *colbasis ) ;
#line 126
dd_MatrixPtr dd_MatrixCopy(dd_MatrixPtr M ) ;
#line 132
dd_MatrixPtr dd_MatrixSortedUniqueCopy(dd_MatrixPtr M , dd_rowindex *newpos ) ;
#line 142
int dd_MatrixShiftupLinearity(dd_MatrixPtr *M , dd_rowindex *newpos ) ;
#line 143
int dd_MatrixRowRemove(dd_MatrixPtr *M , dd_rowrange r ) ;
#line 146
int dd_MatrixRowsRemove2(dd_MatrixPtr *M , dd_rowset delset , dd_rowindex *newpos ) ;
#line 152
void dd_WriteAmatrix(FILE *f , dd_Amatrix A , long rowmax , long colmax ) ;
#line 154
void dd_WriteBmatrix(FILE *f , dd_colrange d_size , dd_Bmatrix B ) ;
#line 158
void dd_WriteNumber(FILE *f , __mpq_struct *x ) ;
#line 165
void dd_WriteProgramDescription(FILE *f ) ;
#line 175
dd_LPPtr dd_Matrix2LP(dd_MatrixPtr M , dd_ErrorType *err ) ;
#line 178
dd_LPPtr dd_Matrix2Feasibility(dd_MatrixPtr M , dd_ErrorType *err ) ;
#line 181
dd_LPPtr dd_Matrix2Feasibility2(dd_MatrixPtr M , dd_rowset R , dd_rowset S , dd_ErrorType *err ) ;
#line 185
dd_boolean dd_LPSolve(dd_LPPtr lp , dd_LPSolverType solver , dd_ErrorType *err ) ;
#line 186
dd_boolean dd_LPSolve0(dd_LPPtr lp , dd_LPSolverType solver , dd_ErrorType *err ) ;
#line 187
void dd_CrissCrossSolve(dd_LPPtr lp , dd_ErrorType *err ) ;
#line 188
void dd_DualSimplexSolve(dd_LPPtr lp , dd_ErrorType *err ) ;
#line 190
dd_LPPtr dd_MakeLPforInteriorFinding(dd_LPPtr lp ) ;
#line 191
dd_LPSolutionPtr dd_CopyLPSolution(dd_LPPtr lp ) ;
#line 192
void dd_WriteLP(FILE *f , dd_LPPtr lp ) ;
#line 194
dd_LPPtr dd_CreateLPData(dd_LPObjectiveType obj , dd_NumberType nt , dd_rowrange m ,
                         dd_colrange d ) ;
#line 195
int dd_LPReverseRow(dd_LPPtr lp , dd_rowrange i ) ;
#line 197
int dd_LPReplaceRow(dd_LPPtr lp , dd_rowrange i , dd_Arow a___41 ) ;
#line 199
dd_Arow dd_LPCopyRow(dd_LPPtr lp , dd_rowrange i ) ;
#line 202
void dd_FreeLPData(dd_LPPtr lp ) ;
#line 203
void dd_FreeLPSolution(dd_LPSolutionPtr lps ) ;
#line 205
void dd_WriteLPResult(FILE *f , dd_LPPtr lp , dd_ErrorType err ) ;
#line 207
void dd_WriteLPTimes(FILE *f , dd_LPPtr lp ) ;
#line 219
void dd_QuickSort(dd_rowindex OV , long p , long r , dd_Amatrix A , long dmax ) ;
#line 256
void dd_GaussianColumnPivot(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix X ,
                            dd_Bmatrix T , dd_rowrange r , dd_colrange s ) ;
#line 257
dd_boolean dd_LexSmaller(mytype *v1 , mytype *v2 , long dmax ) ;
#line 264
void dd_SelectPivot2(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A , dd_Bmatrix T ,
                     dd_RowOrderType roworder , dd_rowindex ordervec , unsigned long *equalityset ,
                     dd_rowrange rowmax , unsigned long *NopivotRow , unsigned long *NopivotCol ,
                     dd_rowrange *r , dd_colrange *s , dd_boolean *selected ) ;
#line 272
void dd_TableauEntry(mytype *x , dd_rowrange m_size , dd_colrange d_size , dd_Amatrix X ,
                     dd_Bmatrix T , dd_rowrange r , dd_colrange s ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_CrissCrossMinimize(dd_LPPtr lp , dd_ErrorType *err ) ;
#line 37
void dd_CrissCrossMaximize(dd_LPPtr lp , dd_ErrorType *err ) ;
#line 38
void dd_DualSimplexMinimize(dd_LPPtr lp , dd_ErrorType *err ) ;
#line 39
void dd_DualSimplexMaximize(dd_LPPtr lp , dd_ErrorType *err ) ;
#line 40
void dd_FindLPBasis(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A , dd_Bmatrix T ,
                    dd_rowindex OV , dd_rowset equalityset , dd_colindex nbindex ,
                    dd_rowindex bflag___97 , dd_rowrange objrow , dd_colrange rhscol ,
                    dd_colrange *cs , int *found , dd_LPStatusType *lps , long *pivot_no ) ;
#line 43
void dd_FindDualFeasibleBasis(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                              dd_Bmatrix T , dd_rowindex OV , dd_colindex nbindex ,
                              long *bflag___97 , dd_rowrange objrow , dd_colrange rhscol ,
                              dd_boolean lexicopivot , dd_colrange *s , dd_ErrorType *err ,
                              dd_LPStatusType *lps , long *pivot_no , long maxpivots ) ;
#line 49
void dd_BasisStatus(ddf_LPPtr lpf , dd_LPPtr lp , dd_boolean *LPScorrect ) ;
#line 50
void dd_BasisStatusMinimize(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                            dd_Bmatrix T , dd_rowset equalityset , dd_rowrange objrow ,
                            dd_colrange rhscol , ddf_LPStatusType LPS , mytype *optvalue ,
                            dd_Arow sol , dd_Arow dsol , dd_rowset posset , ddf_colindex nbindex ,
                            ddf_rowrange re , ddf_colrange se , dd_colrange *nse ,
                            long *pivots , int *found , int *LPScorrect ) ;
#line 53
void dd_BasisStatusMaximize(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                            dd_Bmatrix T , dd_rowset equalityset , dd_rowrange objrow ,
                            dd_colrange rhscol , ddf_LPStatusType LPS , mytype *optvalue ,
                            dd_Arow sol , dd_Arow dsol , dd_rowset posset , ddf_colindex nbindex ,
                            ddf_rowrange re , ddf_colrange se , dd_colrange *nse ,
                            long *pivots , int *found , int *LPScorrect ) ;
#line 59
void dd_SetNumberType(char *line , dd_NumberType *number , dd_ErrorType *Error ) ;
#line 60
void dd_ComputeRowOrderVector2(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                               dd_rowindex OV , dd_RowOrderType ho , unsigned int rseed ) ;
#line 62
void dd_SelectPreorderedNext2(dd_rowrange m_size , dd_colrange d_size , rowset excluded ,
                              dd_rowindex OV , dd_rowrange *hnext ) ;
#line 64
void dd_SetSolutions(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A , dd_Bmatrix T ,
                     dd_rowrange objrow , dd_colrange rhscol , dd_LPStatusType LPS ,
                     mytype *optvalue , dd_Arow sol , dd_Arow dsol , dd_rowset posset ,
                     dd_colindex nbindex , dd_rowrange re , dd_colrange se , dd_rowindex bflag___97 ) ;
#line 68
void dd_WriteTableau(FILE *f , dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                     dd_Bmatrix T , dd_colindex nbindex , dd_rowindex bflag___97 ) ;
#line 71
void dd_WriteSignTableau(FILE *f , dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                         dd_Bmatrix T , dd_colindex nbindex , dd_rowindex bflag___97 ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_LPSolutionPtr dd_CopyLPSolution(dd_LPPtr lp ) 
{ 
  dd_LPSolutionPtr lps ;
  dd_colrange j ;
  long i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 81
  tmp = calloc((size_t )1, sizeof(dd_LPSolutionType ));
#line 81
  lps = (dd_LPSolutionPtr )tmp;
#line 82
  i = 1L;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i <= 255L)) {
#line 82
      goto while_break;
    }
#line 82
    lps->filename[i - 1L] = lp->filename[i - 1L];
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 83
  lps->objective = lp->objective;
#line 84
  lps->solver = lp->solver;
#line 85
  lps->m = lp->m;
#line 86
  lps->d = lp->d;
#line 87
  lps->numbtype = lp->numbtype;
#line 89
  lps->LPS = lp->LPS;
#line 90
  __gmpq_init(lps->optvalue);
#line 91
  __gmpq_set(lps->optvalue, (mpq_srcptr )(lp->optvalue));
#line 92
  dd_InitializeArow(lp->d + 1L, & lps->sol);
#line 93
  dd_InitializeArow(lp->d + 1L, & lps->dsol);
#line 94
  tmp___0 = calloc((size_t )(lp->d + 1L), sizeof(long ));
#line 94
  lps->nbindex = (long *)tmp___0;
#line 95
  j = (dd_colrange )0;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if (! (j <= lp->d)) {
#line 95
      goto while_break___0;
    }
    {
#line 96
    __gmpq_set(*(lps->sol + j), (mpq_srcptr )(*(lp->sol + j)));
#line 97
    __gmpq_set(*(lps->dsol + j), (mpq_srcptr )(*(lp->dsol + j)));
#line 98
    *(lps->nbindex + j) = *(lp->nbindex + j);
#line 95
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 100
  lps->pivots[0] = lp->pivots[0];
#line 101
  lps->pivots[1] = lp->pivots[1];
#line 102
  lps->pivots[2] = lp->pivots[2];
#line 103
  lps->pivots[3] = lp->pivots[3];
#line 104
  lps->pivots[4] = lp->pivots[4];
#line 105
  lps->total_pivots = lp->total_pivots;
#line 107
  return (lps);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_LPPtr dd_CreateLPData(dd_LPObjectiveType obj , dd_NumberType nt , dd_rowrange m ,
                         dd_colrange d ) 
{ 
  dd_LPType *lp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 116
  tmp = calloc((size_t )1, sizeof(dd_LPType ));
#line 116
  lp = (dd_LPPtr )tmp;
#line 117
  lp->solver = dd_choiceLPSolverDefault;
#line 118
  lp->d = d;
#line 119
  lp->m = m;
#line 120
  lp->numbtype = nt;
#line 121
  lp->objrow = m;
#line 122
  lp->rhscol = 1L;
#line 123
  lp->objective = (dd_LPObjectiveType )0;
#line 124
  lp->LPS = (dd_LPStatusType )0;
#line 125
  lp->eqnumber = (dd_rowrange )0;
#line 127
  tmp___0 = calloc((size_t )(d + 1L), sizeof(long ));
#line 127
  lp->nbindex = (long *)tmp___0;
#line 128
  tmp___1 = calloc((size_t )(d + 1L), sizeof(long ));
#line 128
  lp->given_nbindex = (long *)tmp___1;
#line 129
  set_initialize(& lp->equalityset, m);
#line 132
  lp->redcheck_extensive = 0;
#line 133
  lp->ired = (dd_rowrange )0;
#line 134
  set_initialize(& lp->redset_extra, m);
#line 136
  set_initialize(& lp->redset_accum, m);
#line 138
  set_initialize(& lp->posset_extra, m);
#line 140
  lp->lexicopivot = dd_choiceLexicoPivotQ;
#line 142
  lp->m_alloc = lp->m + 2L;
#line 143
  lp->d_alloc = lp->d + 2L;
#line 144
  lp->objective = obj;
#line 145
  dd_InitializeBmatrix(lp->d_alloc, & lp->B);
#line 146
  dd_InitializeAmatrix(lp->m_alloc, lp->d_alloc, & lp->A);
#line 147
  dd_InitializeArow(lp->d_alloc, & lp->sol);
#line 148
  dd_InitializeArow(lp->d_alloc, & lp->dsol);
#line 149
  __gmpq_init(lp->optvalue);
  }
#line 150
  return (lp);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_LPPtr dd_Matrix2LP(dd_MatrixPtr M , dd_ErrorType *err ) 
{ 
  dd_rowrange m ;
  dd_rowrange i ;
  dd_rowrange irev ;
  dd_rowrange linc ;
  dd_colrange d ;
  dd_colrange j ;
  dd_LPType *lp ;
  dd_boolean localdebug ;
  int tmp ;
  dd_boolean tmp___0 ;

  {
  {
#line 159
  localdebug = 0;
#line 161
  *err = (dd_ErrorType )17;
#line 162
  linc = set_card(M->linset);
#line 163
  m = (M->rowsize + 1L) + linc;
#line 166
  d = M->colsize;
  }
#line 167
  if (localdebug) {
    {
#line 167
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"number of equalities = %ld\n",
            linc);
    }
  }
  {
#line 169
  lp = dd_CreateLPData(M->objective, M->numbtype, m, d);
#line 170
  lp->Homogeneous = 1;
#line 171
  lp->eqnumber = linc;
#line 173
  irev = M->rowsize;
#line 174
  i = (dd_rowrange )1;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (i <= M->rowsize)) {
#line 174
      goto while_break;
    }
    {
#line 175
    tmp = set_member(i, M->linset);
    }
#line 175
    if (tmp) {
      {
#line 176
      irev ++;
#line 177
      set_addelem(lp->equalityset, i);
#line 179
      j = (dd_colrange )1;
      }
      {
#line 179
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 179
        if (! (j <= M->colsize)) {
#line 179
          goto while_break___0;
        }
        {
#line 180
        __gmpq_neg(*(*(lp->A + (irev - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 1L))));
#line 179
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 182
      if (localdebug) {
        {
#line 182
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"equality row %ld generates the reverse row %ld.\n",
                i, irev);
        }
      }
    }
#line 184
    j = (dd_colrange )1;
    {
#line 184
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 184
      if (! (j <= M->colsize)) {
#line 184
        goto while_break___1;
      }
      {
#line 185
      __gmpq_set(*(*(lp->A + (i - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 1L))));
      }
#line 186
      if (j == 1L) {
#line 186
        if (i < M->rowsize) {
          {
#line 186
          tmp___0 = dd_Nonzero((__mpq_struct *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
          }
#line 186
          if (tmp___0) {
#line 186
            lp->Homogeneous = 0;
          }
        }
      }
#line 184
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 174
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  j = (dd_colrange )1;
  {
#line 189
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 189
    if (! (j <= M->colsize)) {
#line 189
      goto while_break___2;
    }
    {
#line 190
    __gmpq_set(*(*(lp->A + (m - 1L)) + (j - 1L)), (mpq_srcptr )(*(M->rowvec + (j - 1L))));
#line 189
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 193
  return (lp);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_LPPtr dd_Matrix2Feasibility(dd_MatrixPtr M , dd_ErrorType *err ) 
{ 
  dd_rowrange m ;
  dd_rowrange linc ;
  dd_colrange j ;
  dd_LPType *lp ;

  {
  {
#line 208
  *err = (dd_ErrorType )17;
#line 209
  linc = set_card(M->linset);
#line 210
  m = (M->rowsize + 1L) + linc;
#line 214
  lp = dd_Matrix2LP(M, err);
#line 215
  lp->objective = (dd_LPObjectiveType )1;
#line 216
  j = (dd_colrange )1;
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (j <= M->colsize)) {
#line 216
      goto while_break;
    }
    {
#line 217
    __gmpq_set(*(*(lp->A + (m - 1L)) + (j - 1L)), (mpq_srcptr )(dd_purezero));
#line 216
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (lp);
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_LPPtr dd_Matrix2Feasibility2(dd_MatrixPtr M , dd_rowset R , dd_rowset S , dd_ErrorType *err ) 
{ 
  dd_rowrange m ;
  dd_rowrange i ;
  dd_rowrange irev ;
  dd_rowrange linc ;
  dd_colrange d ;
  dd_colrange j ;
  dd_LPType *lp ;
  dd_rowset L ;
  dd_boolean localdebug ;
  int tmp ;
  int tmp___0 ;
  dd_boolean tmp___1 ;

  {
  {
#line 253
  localdebug = 0;
#line 255
  *err = (dd_ErrorType )17;
#line 256
  set_initialize(& L, M->rowsize);
#line 257
  set_uni(L, M->linset, R);
#line 258
  linc = set_card(L);
#line 259
  m = ((M->rowsize + 1L) + linc) + 1L;
#line 262
  d = M->colsize + 1L;
  }
#line 263
  if (localdebug) {
    {
#line 263
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"number of equalities = %ld\n",
            linc);
    }
  }
  {
#line 265
  lp = dd_CreateLPData((dd_LPObjectiveType )1, M->numbtype, m, d);
#line 266
  lp->Homogeneous = 1;
#line 267
  lp->eqnumber = linc;
#line 269
  irev = M->rowsize;
#line 270
  i = (dd_rowrange )1;
  }
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (! (i <= M->rowsize)) {
#line 270
      goto while_break;
    }
    {
#line 271
    tmp___0 = set_member(i, L);
    }
#line 271
    if (tmp___0) {
      {
#line 272
      irev ++;
#line 273
      set_addelem(lp->equalityset, i);
#line 275
      j = (dd_colrange )1;
      }
      {
#line 275
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 275
        if (! (j <= M->colsize)) {
#line 275
          goto while_break___0;
        }
        {
#line 276
        __gmpq_neg(*(*(lp->A + (irev - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 1L))));
#line 275
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 278
      if (localdebug) {
        {
#line 278
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"equality row %ld generates the reverse row %ld.\n",
                i, irev);
        }
      }
    } else {
      {
#line 279
      tmp = set_member(i, S);
      }
#line 279
      if (tmp) {
        {
#line 280
        __gmpq_set(*(*(lp->A + (i - 1L)) + M->colsize), (mpq_srcptr )(dd_minusone));
        }
      }
    }
#line 282
    j = (dd_colrange )1;
    {
#line 282
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 282
      if (! (j <= M->colsize)) {
#line 282
        goto while_break___1;
      }
      {
#line 283
      __gmpq_set(*(*(lp->A + (i - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 1L))));
      }
#line 284
      if (j == 1L) {
#line 284
        if (i < M->rowsize) {
          {
#line 284
          tmp___1 = dd_Nonzero((__mpq_struct *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
          }
#line 284
          if (tmp___1) {
#line 284
            lp->Homogeneous = 0;
          }
        }
      }
#line 282
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 270
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  j = (dd_colrange )1;
  {
#line 287
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 287
    if (! (j <= d)) {
#line 287
      goto while_break___2;
    }
    {
#line 288
    __gmpq_set(*(*(lp->A + (m - 2L)) + (j - 1L)), (mpq_srcptr )(dd_purezero));
#line 287
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 290
  __gmpq_set(*(*(lp->A + (m - 2L)) + 0), (mpq_srcptr )(dd_one));
#line 291
  __gmpq_set(*(*(lp->A + (m - 2L)) + M->colsize), (mpq_srcptr )(dd_minusone));
#line 292
  j = (dd_colrange )1;
  }
  {
#line 292
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 292
    if (! (j <= d)) {
#line 292
      goto while_break___3;
    }
    {
#line 293
    __gmpq_set(*(*(lp->A + (m - 1L)) + (j - 1L)), (mpq_srcptr )(dd_purezero));
#line 292
    j ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 295
  __gmpq_set(*(*(lp->A + (m - 1L)) + M->colsize), (mpq_srcptr )(dd_one));
#line 297
  set_free(L);
  }
#line 298
  return (lp);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_FreeLPData(dd_LPPtr lp ) 
{ 


  {
#line 305
  if ((unsigned long )lp != (unsigned long )((void *)0)) {
    {
#line 306
    __gmpq_clear(lp->optvalue);
#line 307
    dd_FreeArow(lp->d_alloc, lp->dsol);
#line 308
    dd_FreeArow(lp->d_alloc, lp->sol);
#line 309
    dd_FreeBmatrix(lp->d_alloc, lp->B);
#line 310
    dd_FreeAmatrix(lp->m_alloc, lp->d_alloc, lp->A);
#line 311
    set_free(lp->equalityset);
#line 312
    set_free(lp->redset_extra);
#line 313
    set_free(lp->redset_accum);
#line 314
    set_free(lp->posset_extra);
#line 315
    free((void *)lp->nbindex);
#line 316
    free((void *)lp->given_nbindex);
#line 317
    free((void *)lp);
    }
  }
#line 319
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_FreeLPSolution(dd_LPSolutionPtr lps ) 
{ 


  {
#line 323
  if ((unsigned long )lps != (unsigned long )((void *)0)) {
    {
#line 324
    free((void *)lps->nbindex);
#line 325
    dd_FreeArow(lps->d + 1L, lps->dsol);
#line 326
    dd_FreeArow(lps->d + 1L, lps->sol);
#line 327
    __gmpq_clear(lps->optvalue);
#line 329
    free((void *)lps);
    }
  }
#line 331
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
int dd_LPReverseRow(dd_LPPtr lp , dd_rowrange i ) 
{ 
  dd_colrange j ;
  int success ;

  {
#line 336
  success = 0;
#line 338
  if (i >= 1L) {
#line 338
    if (i <= lp->m) {
#line 339
      lp->LPS = (dd_LPStatusType )0;
#line 340
      j = (dd_colrange )1;
      {
#line 340
      while (1) {
        while_continue: /* CIL Label */ ;
#line 340
        if (! (j <= lp->d)) {
#line 340
          goto while_break;
        }
        {
#line 341
        __gmpq_neg(*(*(lp->A + (i - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(lp->A + (i - 1L)) + (j - 1L))));
#line 340
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 344
      success = 1;
    }
  }
#line 346
  return (success);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
int dd_LPReplaceRow(dd_LPPtr lp , dd_rowrange i , dd_Arow a___41 ) 
{ 
  dd_colrange j ;
  int success ;

  {
#line 352
  success = 0;
#line 354
  if (i >= 1L) {
#line 354
    if (i <= lp->m) {
#line 355
      lp->LPS = (dd_LPStatusType )0;
#line 356
      j = (dd_colrange )1;
      {
#line 356
      while (1) {
        while_continue: /* CIL Label */ ;
#line 356
        if (! (j <= lp->d)) {
#line 356
          goto while_break;
        }
        {
#line 357
        __gmpq_set(*(*(lp->A + (i - 1L)) + (j - 1L)), (mpq_srcptr )(*(a___41 + (j - 1L))));
#line 356
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 360
      success = 1;
    }
  }
#line 362
  return (success);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_Arow dd_LPCopyRow(dd_LPPtr lp , dd_rowrange i ) 
{ 
  dd_colrange j ;
  dd_Arow a___41 ;

  {
#line 370
  if (i >= 1L) {
#line 370
    if (i <= lp->m) {
      {
#line 371
      dd_InitializeArow(lp->d, & a___41);
#line 372
      j = (dd_colrange )1;
      }
      {
#line 372
      while (1) {
        while_continue: /* CIL Label */ ;
#line 372
        if (! (j <= lp->d)) {
#line 372
          goto while_break;
        }
        {
#line 373
        __gmpq_set(*(a___41 + (j - 1L)), (mpq_srcptr )(*(*(lp->A + (i - 1L)) + (j - 1L))));
#line 372
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 377
  return (a___41);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_SetNumberType(char *line , dd_NumberType *number , dd_ErrorType *Error ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 383
  tmp___1 = strncmp((char const   *)line, "integer", (size_t )7);
  }
#line 383
  if (tmp___1 == 0) {
#line 384
    *number = (dd_NumberType )3;
#line 385
    return;
  } else {
    {
#line 387
    tmp___0 = strncmp((char const   *)line, "rational", (size_t )8);
    }
#line 387
    if (tmp___0 == 0) {
#line 388
      *number = (dd_NumberType )2;
#line 389
      return;
    } else {
      {
#line 391
      tmp = strncmp((char const   *)line, "real", (size_t )4);
      }
#line 391
      if (tmp == 0) {
#line 392
        *number = (dd_NumberType )1;
#line 393
        return;
      } else {
#line 396
        *number = (dd_NumberType )0;
#line 397
        *Error = (dd_ErrorType )1;
      }
    }
  }
#line 399
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_WriteTableau(FILE *f , dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                     dd_Bmatrix T , dd_colindex nbindex , dd_rowindex bflag___97 ) 
{ 
  dd_colrange j ;
  dd_rowrange i ;
  mytype x ;

  {
  {
#line 410
  __gmpq_init(x);
#line 411
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld  %ld  real\n",
          m_size, d_size);
#line 412
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"          |");
#line 413
  j = (dd_colrange )1;
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! (j <= d_size)) {
#line 413
      goto while_break;
    }
    {
#line 414
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld", *(nbindex + j));
#line 413
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 416
  j = (dd_colrange )1;
  }
  {
#line 416
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 416
    if (! (j <= d_size + 1L)) {
#line 416
      goto while_break___0;
    }
    {
#line 417
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" ----");
#line 416
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 418
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 419
  i = (dd_rowrange )1;
  }
  {
#line 419
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 419
    if (! (i <= m_size)) {
#line 419
      goto while_break___1;
    }
    {
#line 420
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %3ld(%3ld) |",
            i, *(bflag___97 + i));
#line 421
    j = (dd_colrange )1;
    }
    {
#line 421
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 421
      if (! (j <= d_size)) {
#line 421
        goto while_break___2;
      }
      {
#line 422
      dd_TableauEntry(& x, m_size, d_size, A, T, i, j);
#line 423
      dd_WriteNumber(f, (__mpq_struct *)(x));
#line 421
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 425
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 419
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 427
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
#line 428
  __gmpq_clear(x);
  }
#line 429
  return;
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_WriteSignTableau(FILE *f , dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                         dd_Bmatrix T , dd_colindex nbindex , dd_rowindex bflag___97 ) 
{ 
  dd_colrange j ;
  dd_rowrange i ;
  mytype x ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;

  {
  {
#line 439
  __gmpq_init(x);
#line 440
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld  %ld  real\n",
          m_size, d_size);
#line 441
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"          |");
#line 442
  j = (dd_colrange )1;
  }
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! (j <= d_size)) {
#line 442
      goto while_break;
    }
    {
#line 443
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%3ld", *(nbindex + j));
#line 442
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n  ------- | ");
#line 445
  j = (dd_colrange )1;
  }
  {
#line 445
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 445
    if (! (j <= d_size)) {
#line 445
      goto while_break___0;
    }
    {
#line 446
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"---");
#line 445
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 447
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 448
  i = (dd_rowrange )1;
  }
  {
#line 448
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 448
    if (! (i <= m_size)) {
#line 448
      goto while_break___1;
    }
    {
#line 449
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %3ld(%3ld) |",
            i, *(bflag___97 + i));
#line 450
    j = (dd_colrange )1;
    }
    {
#line 450
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 450
      if (! (j <= d_size)) {
#line 450
        goto while_break___2;
      }
      {
#line 451
      dd_TableauEntry(& x, m_size, d_size, A, T, i, j);
#line 452
      tmp___0 = dd_Positive((__mpq_struct *)(x));
      }
#line 452
      if (tmp___0) {
        {
#line 452
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  +");
        }
      } else {
        {
#line 453
        tmp = dd_Negative((__mpq_struct *)(x));
        }
#line 453
        if (tmp) {
          {
#line 453
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -");
          }
        } else {
          {
#line 454
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  0");
          }
        }
      }
#line 450
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 456
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 448
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 458
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
#line 459
  __gmpq_clear(x);
  }
#line 460
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_WriteSignTableau2(FILE *f , dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                          dd_Bmatrix T , dd_colindex nbindex_ref___83 , dd_colindex nbindex ,
                          dd_rowindex bflag___97 ) 
{ 
  dd_colrange j ;
  dd_rowrange i ;
  mytype x ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;

  {
  {
#line 470
  __gmpq_init(x);
#line 471
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld  %ld  real\n",
          m_size, d_size);
#line 472
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"          |");
#line 473
  j = (dd_colrange )1;
  }
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if (! (j <= d_size)) {
#line 473
      goto while_break;
    }
    {
#line 473
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%3ld", *(nbindex_ref___83 + j));
#line 473
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 474
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n          |");
#line 475
  j = (dd_colrange )1;
  }
  {
#line 475
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 475
    if (! (j <= d_size)) {
#line 475
      goto while_break___0;
    }
    {
#line 476
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%3ld", *(nbindex + j));
#line 475
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 477
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n  ------- | ");
#line 478
  j = (dd_colrange )1;
  }
  {
#line 478
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 478
    if (! (j <= d_size)) {
#line 478
      goto while_break___1;
    }
    {
#line 479
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"---");
#line 478
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 480
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 481
  i = (dd_rowrange )1;
  }
  {
#line 481
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 481
    if (! (i <= m_size)) {
#line 481
      goto while_break___2;
    }
    {
#line 482
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %3ld(%3ld) |",
            i, *(bflag___97 + i));
#line 483
    j = (dd_colrange )1;
    }
    {
#line 483
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 483
      if (! (j <= d_size)) {
#line 483
        goto while_break___3;
      }
      {
#line 484
      dd_TableauEntry(& x, m_size, d_size, A, T, i, j);
#line 485
      tmp___0 = dd_Positive((__mpq_struct *)(x));
      }
#line 485
      if (tmp___0) {
        {
#line 485
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  +");
        }
      } else {
        {
#line 486
        tmp = dd_Negative((__mpq_struct *)(x));
        }
#line 486
        if (tmp) {
          {
#line 486
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -");
          }
        } else {
          {
#line 487
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  0");
          }
        }
      }
#line 483
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 489
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 481
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 491
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
#line 492
  __gmpq_clear(x);
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_GetRedundancyInformation(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                                 dd_Bmatrix T , dd_colindex nbindex , dd_rowindex bflag___97 ,
                                 dd_rowset redset ) 
{ 
  dd_colrange j ;
  dd_rowrange i ;
  mytype x ;
  dd_boolean red ;
  dd_boolean localdebug ;
  long numbred ;
  dd_boolean tmp ;

  {
  {
#line 504
  red = 0;
#line 504
  localdebug = 0;
#line 505
  numbred = 0L;
#line 507
  __gmpq_init(x);
#line 508
  i = (dd_rowrange )1;
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if (! (i <= m_size)) {
#line 508
      goto while_break;
    }
#line 509
    red = 1;
#line 510
    j = (dd_colrange )1;
    {
#line 510
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 510
      if (! (j <= d_size)) {
#line 510
        goto while_break___0;
      }
      {
#line 511
      dd_TableauEntry(& x, m_size, d_size, A, T, i, j);
      }
#line 512
      if (red) {
        {
#line 512
        tmp = dd_Negative((__mpq_struct *)(x));
        }
#line 512
        if (tmp) {
#line 512
          red = 0;
        }
      }
#line 510
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 514
    if (*(bflag___97 + i) < 0L) {
#line 514
      if (red) {
        {
#line 515
        numbred ++;
#line 516
        set_addelem(redset, i);
        }
      }
    }
#line 508
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  if (localdebug) {
    {
#line 519
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ndd_GetRedundancyInformation: %ld redundant rows over %ld\n",
            numbred, m_size);
    }
  }
  {
#line 520
  __gmpq_clear(x);
  }
#line 521
  return;
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost  ;
#line 545
void dd_SelectDualSimplexPivot(dd_rowrange m_size , dd_colrange d_size , int Phase1 ,
                               dd_Amatrix A , dd_Bmatrix T , dd_rowindex OV , dd_colindex nbindex_ref___83 ,
                               dd_colindex nbindex , dd_rowindex bflag___97 , dd_rowrange objrow ,
                               dd_colrange rhscol , dd_boolean lexicopivot , dd_rowrange *r ,
                               dd_colrange *s , int *selected , dd_LPStatusType *lps ) ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___0  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset  ;
#line 524 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_SelectDualSimplexPivot(dd_rowrange m_size , dd_colrange d_size , int Phase1 ,
                               dd_Amatrix A , dd_Bmatrix T , dd_rowindex OV , dd_colindex nbindex_ref___83 ,
                               dd_colindex nbindex , dd_rowindex bflag___97 , dd_rowrange objrow ,
                               dd_colrange rhscol , dd_boolean lexicopivot , dd_rowrange *r ,
                               dd_colrange *s , int *selected , dd_LPStatusType *lps ) 
{ 
  dd_boolean colselected ;
  dd_boolean rowselected ;
  dd_boolean dualfeasible ;
  dd_boolean localdebug ;
  dd_rowrange i ;
  dd_rowrange iref ;
  dd_colrange j ;
  dd_colrange k ;
  mytype val ;
  mytype valn ;
  mytype minval ;
  mytype rat ;
  mytype minrat ;
  void *tmp ;
  dd_boolean tmp___0 ;
  dd_boolean tmp___1 ;
  dd_boolean tmp___2 ;
  dd_boolean tmp___3 ;
  dd_boolean tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  dd_boolean tmp___7 ;
  dd_boolean tmp___8 ;
  dd_boolean tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  dd_boolean tmp___13 ;

  {
  {
#line 539
  colselected = 0;
#line 539
  rowselected = 0;
#line 539
  dualfeasible = 1;
#line 539
  localdebug = 0;
#line 548
  __gmpq_init(val);
#line 548
  __gmpq_init(valn);
#line 548
  __gmpq_init(minval);
#line 548
  __gmpq_init(rat);
#line 548
  __gmpq_init(minrat);
  }
#line 549
  if (d_last___0 < d_size) {
#line 550
    if (d_last___0 > 0L) {
#line 551
      j = (dd_colrange )1;
      {
#line 551
      while (1) {
        while_continue: /* CIL Label */ ;
#line 551
        if (! (j <= d_last___0)) {
#line 551
          goto while_break;
        }
        {
#line 551
        __gmpq_clear(*(rcost + (j - 1L)));
#line 551
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 552
      free((void *)rcost);
#line 553
      set_free(tieset);
#line 554
      set_free(stieset);
      }
    }
    {
#line 556
    tmp = calloc((size_t )d_size, sizeof(mytype ));
#line 556
    rcost = (mytype *)tmp;
#line 557
    j = (dd_colrange )1;
    }
    {
#line 557
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 557
      if (! (j <= d_size)) {
#line 557
        goto while_break___0;
      }
      {
#line 557
      __gmpq_init(*(rcost + (j - 1L)));
#line 557
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 558
    set_initialize(& tieset, d_size);
#line 559
    set_initialize(& stieset, d_size);
#line 560
    d_last___0 = d_size;
    }
  }
#line 563
  *r = (dd_rowrange )0;
#line 563
  *s = (dd_colrange )0;
#line 564
  *selected = 0;
#line 565
  *lps = (dd_LPStatusType )0;
#line 566
  j = (dd_colrange )1;
  {
#line 566
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 566
    if (! (j <= d_size)) {
#line 566
      goto while_break___1;
    }
#line 567
    if (j != rhscol) {
      {
#line 568
      dd_TableauEntry(rcost + (j - 1L), m_size, d_size, A, T, objrow, j);
#line 569
      tmp___0 = dd_Positive((__mpq_struct *)(*(rcost + (j - 1L))));
      }
#line 569
      if (tmp___0) {
#line 570
        dualfeasible = 0;
      }
    }
#line 566
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 574
  if (dualfeasible) {
    {
#line 575
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 575
      if ((unsigned int )*lps == 0U) {
#line 575
        if (! rowselected) {
#line 575
          if (! (! colselected)) {
#line 575
            goto while_break___2;
          }
        } else {
#line 575
          goto while_break___2;
        }
      } else {
#line 575
        goto while_break___2;
      }
#line 576
      i = (dd_rowrange )1;
      {
#line 576
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 576
        if (! (i <= m_size)) {
#line 576
          goto while_break___3;
        }
#line 577
        if (i != objrow) {
#line 577
          if (*(bflag___97 + i) == -1L) {
#line 578
            if (Phase1) {
              {
#line 579
              dd_TableauEntry(& val, m_size, d_size, A, T, i, *(bflag___97 + m_size));
#line 580
              __gmpq_neg(val, (mpq_srcptr )(val));
              }
            } else {
              {
#line 583
              dd_TableauEntry(& val, m_size, d_size, A, T, i, rhscol);
              }
            }
            {
#line 584
            tmp___1 = dd_Smaller((__mpq_struct *)(val), (__mpq_struct *)(minval));
            }
#line 584
            if (tmp___1) {
              {
#line 585
              *r = i;
#line 586
              __gmpq_set(minval, (mpq_srcptr )(val));
              }
            }
          }
        }
#line 576
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 590
      tmp___13 = dd_Nonnegative((__mpq_struct *)(minval));
      }
#line 590
      if (tmp___13) {
#line 591
        *lps = (dd_LPStatusType )1;
      } else {
        {
#line 594
        rowselected = 1;
#line 595
        set_emptyset(tieset);
#line 596
        j = (dd_colrange )1;
        }
        {
#line 596
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 596
          if (! (j <= d_size)) {
#line 596
            goto while_break___4;
          }
          {
#line 597
          dd_TableauEntry(& val, m_size, d_size, A, T, *r, j);
          }
#line 598
          if (j != rhscol) {
            {
#line 598
            tmp___4 = dd_Positive((__mpq_struct *)(val));
            }
#line 598
            if (tmp___4) {
              {
#line 599
              __gmpq_div(rat, (mpq_srcptr )(*(rcost + (j - 1L))), (mpq_srcptr )(val));
#line 600
              __gmpq_neg(rat, (mpq_srcptr )(rat));
              }
#line 601
              if (*s == 0L) {
                {
#line 602
                __gmpq_set(minrat, (mpq_srcptr )(rat));
#line 603
                *s = j;
#line 604
                set_emptyset(tieset);
#line 605
                set_addelem(tieset, j);
                }
              } else {
                {
#line 601
                tmp___3 = dd_Smaller((__mpq_struct *)(rat), (__mpq_struct *)(minrat));
                }
#line 601
                if (tmp___3) {
                  {
#line 602
                  __gmpq_set(minrat, (mpq_srcptr )(rat));
#line 603
                  *s = j;
#line 604
                  set_emptyset(tieset);
#line 605
                  set_addelem(tieset, j);
                  }
                } else {
                  {
#line 606
                  tmp___2 = dd_Equal((__mpq_struct *)(rat), (__mpq_struct *)(minrat));
                  }
#line 606
                  if (tmp___2) {
                    {
#line 607
                    set_addelem(tieset, j);
                    }
                  }
                }
              }
            }
          }
#line 596
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 611
        if (*s > 0L) {
#line 612
          if (! lexicopivot) {
#line 613
            colselected = 1;
#line 613
            *selected = 1;
          } else {
            {
#line 612
            tmp___12 = set_card(tieset);
            }
#line 612
            if (tmp___12 == 1L) {
#line 613
              colselected = 1;
#line 613
              *selected = 1;
            } else {
#line 615
              if (localdebug) {
                {
#line 615
                printf((char const   */* __restrict  */)"Tie occurred at:");
#line 615
                set_write(tieset);
#line 615
                printf((char const   */* __restrict  */)"\n");
#line 616
                dd_WriteTableau(stderr, m_size, d_size, A, T, nbindex, bflag___97);
                }
              }
#line 618
              *s = (dd_colrange )0;
#line 619
              k = (dd_colrange )2;
              {
#line 620
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 621
                iref = *(nbindex_ref___83 + k);
#line 622
                if (iref > 0L) {
#line 623
                  j = *(bflag___97 + iref);
#line 624
                  if (j > 0L) {
                    {
#line 625
                    tmp___5 = set_member(j, tieset);
                    }
#line 625
                    if (tmp___5) {
                      {
#line 625
                      tmp___6 = set_card(tieset);
                      }
#line 625
                      if (tmp___6 == 1L) {
#line 626
                        *s = j;
#line 627
                        colselected = 1;
                      } else {
                        {
#line 629
                        set_delelem(tieset, j);
                        }
                      }
                    } else {
                      {
#line 629
                      set_delelem(tieset, j);
                      }
                    }
                  } else {
#line 633
                    *s = (dd_colrange )0;
#line 634
                    j = (dd_colrange )1;
                    {
#line 634
                    while (1) {
                      while_continue___6: /* CIL Label */ ;
#line 634
                      if (! (j <= d_size)) {
#line 634
                        goto while_break___6;
                      }
                      {
#line 635
                      tmp___10 = set_member(j, tieset);
                      }
#line 635
                      if (tmp___10) {
                        {
#line 636
                        dd_TableauEntry(& val, m_size, d_size, A, T, *r, j);
#line 637
                        dd_TableauEntry(& valn, m_size, d_size, A, T, iref, j);
                        }
#line 638
                        if (j != rhscol) {
                          {
#line 638
                          tmp___9 = dd_Positive((__mpq_struct *)(val));
                          }
#line 638
                          if (tmp___9) {
                            {
#line 639
                            __gmpq_div(rat, (mpq_srcptr )(valn), (mpq_srcptr )(val));
                            }
#line 640
                            if (*s == 0L) {
                              {
#line 641
                              __gmpq_set(minrat, (mpq_srcptr )(rat));
#line 642
                              *s = j;
#line 643
                              set_emptyset(stieset);
#line 644
                              set_addelem(stieset, j);
                              }
                            } else {
                              {
#line 640
                              tmp___8 = dd_Smaller((__mpq_struct *)(rat), (__mpq_struct *)(minrat));
                              }
#line 640
                              if (tmp___8) {
                                {
#line 641
                                __gmpq_set(minrat, (mpq_srcptr )(rat));
#line 642
                                *s = j;
#line 643
                                set_emptyset(stieset);
#line 644
                                set_addelem(stieset, j);
                                }
                              } else {
                                {
#line 645
                                tmp___7 = dd_Equal((__mpq_struct *)(rat), (__mpq_struct *)(minrat));
                                }
#line 645
                                if (tmp___7) {
                                  {
#line 646
                                  set_addelem(stieset, j);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
#line 634
                      j ++;
                    }
                    while_break___6: /* CIL Label */ ;
                    }
                    {
#line 651
                    set_copy(tieset, stieset);
#line 652
                    tmp___11 = set_card(tieset);
                    }
#line 652
                    if (tmp___11 == 1L) {
#line 652
                      colselected = 1;
                    }
                  }
                }
#line 655
                k ++;
#line 620
                if (! colselected) {
#line 620
                  if (! (k <= d_size)) {
#line 620
                    goto while_break___5;
                  }
                } else {
#line 620
                  goto while_break___5;
                }
              }
              while_break___5: /* CIL Label */ ;
              }
#line 657
              *selected = 1;
            }
          }
        } else {
#line 659
          *lps = (dd_LPStatusType )2;
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 663
  if (localdebug) {
#line 664
    if (Phase1) {
      {
#line 664
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Phase 1 : select %ld,%ld\n",
              *r, *s);
      }
    } else {
      {
#line 665
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Phase 2 : select %ld,%ld\n",
              *r, *s);
      }
    }
  }
  {
#line 667
  __gmpq_clear(val);
#line 667
  __gmpq_clear(valn);
#line 667
  __gmpq_clear(minval);
#line 667
  __gmpq_clear(rat);
#line 667
  __gmpq_clear(minrat);
  }
#line 668
  return;
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_TableauEntry(mytype *x , dd_rowrange m_size , dd_colrange d_size , dd_Amatrix X ,
                     dd_Bmatrix T , dd_rowrange r , dd_colrange s ) 
{ 
  dd_colrange j ;
  mytype temp ;

  {
  {
#line 677
  __gmpq_init(temp);
#line 678
  __gmpq_set(*x, (mpq_srcptr )(dd_purezero));
#line 679
  j = (dd_colrange )0;
  }
  {
#line 679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 679
    if (! (j < d_size)) {
#line 679
      goto while_break;
    }
    {
#line 680
    __gmpq_mul(temp, (mpq_srcptr )(*(*(X + (r - 1L)) + j)), (mpq_srcptr )(*(*(T + j) + (s - 1L))));
#line 681
    __gmpq_add(*x, (mpq_srcptr )(*x), (mpq_srcptr )(temp));
#line 679
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 683
  __gmpq_clear(temp);
  }
#line 684
  return;
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_SelectPivot2(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A , dd_Bmatrix T ,
                     dd_RowOrderType roworder , dd_rowindex ordervec , unsigned long *equalityset ,
                     dd_rowrange rowmax , unsigned long *NopivotRow , unsigned long *NopivotCol ,
                     dd_rowrange *r , dd_colrange *s , dd_boolean *selected ) 
{ 
  int stop ;
  dd_rowrange i ;
  dd_rowrange rtemp ;
  rowset rowexcluded ;
  mytype Xtemp ;
  dd_boolean localdebug ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  dd_boolean tmp___2 ;

  {
  {
#line 700
  localdebug = 0;
#line 702
  stop = 0;
#line 703
  localdebug = dd_debug;
#line 704
  __gmpq_init(Xtemp);
#line 705
  set_initialize(& rowexcluded, m_size);
#line 706
  set_copy(rowexcluded, NopivotRow);
#line 707
  i = rowmax + 1L;
  }
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (! (i <= m_size)) {
#line 707
      goto while_break;
    }
    {
#line 708
    set_addelem(rowexcluded, i);
#line 707
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 710
  *selected = 0;
  {
#line 711
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 712
    rtemp = (dd_rowrange )0;
#line 712
    i = (dd_rowrange )1;
    {
#line 713
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 713
      if (i <= m_size) {
#line 713
        if (! (rtemp == 0L)) {
#line 713
          goto while_break___1;
        }
      } else {
#line 713
        goto while_break___1;
      }
      {
#line 714
      tmp = set_member(i, equalityset);
      }
#line 714
      if (tmp) {
        {
#line 714
        tmp___0 = set_member(i, rowexcluded);
        }
#line 714
        if (! tmp___0) {
#line 715
          if (localdebug) {
            {
#line 715
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"marked set %ld chosen as a candidate\n",
                    i);
            }
          }
#line 716
          rtemp = i;
        }
      }
#line 718
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 720
    if (rtemp == 0L) {
      {
#line 720
      dd_SelectPreorderedNext2(m_size, d_size, rowexcluded, ordervec, & rtemp);
      }
    }
#line 721
    if (rtemp >= 1L) {
#line 722
      *r = rtemp;
#line 723
      *s = (dd_colrange )1;
      {
#line 724
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 724
        if (*s <= d_size) {
#line 724
          if (! (! *selected)) {
#line 724
            goto while_break___2;
          }
        } else {
#line 724
          goto while_break___2;
        }
        {
#line 725
        dd_TableauEntry(& Xtemp, m_size, d_size, A, T, *r, *s);
#line 726
        tmp___1 = set_member(*s, NopivotCol);
        }
#line 726
        if (tmp___1) {
#line 730
          (*s) ++;
        } else {
          {
#line 726
          tmp___2 = dd_Nonzero((__mpq_struct *)(Xtemp));
          }
#line 726
          if (tmp___2) {
#line 727
            *selected = 1;
#line 728
            stop = 1;
          } else {
#line 730
            (*s) ++;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 733
      if (! *selected) {
        {
#line 734
        set_addelem(rowexcluded, rtemp);
        }
      }
    } else {
#line 738
      *r = (dd_rowrange )0;
#line 739
      *s = (dd_colrange )0;
#line 740
      stop = 1;
    }
#line 711
    if (! (! stop)) {
#line 711
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 743
  set_free(rowexcluded);
#line 743
  __gmpq_clear(Xtemp);
  }
#line 744
  return;
}
}
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d  =    (dd_colrange )0;
#line 746 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_GaussianColumnPivot(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix X ,
                            dd_Bmatrix T , dd_rowrange r , dd_colrange s ) 
{ 
  dd_colrange j ;
  dd_colrange j1___0 ;
  mytype Xtemp0 ;
  mytype Xtemp1 ;
  mytype Xtemp ;
  void *tmp ;

  {
  {
#line 758
  __gmpq_init(Xtemp0);
#line 758
  __gmpq_init(Xtemp1);
#line 758
  __gmpq_init(Xtemp);
  }
#line 759
  if (last_d != d_size) {
#line 760
    if (last_d > 0L) {
#line 761
      j = (dd_colrange )1;
      {
#line 761
      while (1) {
        while_continue: /* CIL Label */ ;
#line 761
        if (! (j <= last_d)) {
#line 761
          goto while_break;
        }
        {
#line 761
        __gmpq_clear(*(Rtemp + (j - 1L)));
#line 761
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 762
      free((void *)Rtemp);
      }
    }
    {
#line 764
    tmp = calloc((size_t )d_size, sizeof(mytype ));
#line 764
    Rtemp = (mytype *)tmp;
#line 765
    j = (dd_colrange )1;
    }
    {
#line 765
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 765
      if (! (j <= d_size)) {
#line 765
        goto while_break___0;
      }
      {
#line 765
      __gmpq_init(*(Rtemp + (j - 1L)));
#line 765
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 766
    last_d = d_size;
  }
#line 769
  j = (dd_colrange )1;
  {
#line 769
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 769
    if (! (j <= d_size)) {
#line 769
      goto while_break___1;
    }
    {
#line 770
    dd_TableauEntry(Rtemp + (j - 1L), m_size, d_size, X, T, r, j);
#line 769
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 772
  __gmpq_set(Xtemp0, (mpq_srcptr )(*(Rtemp + (s - 1L))));
#line 773
  j = (dd_colrange )1;
  }
  {
#line 773
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 773
    if (! (j <= d_size)) {
#line 773
      goto while_break___2;
    }
#line 774
    if (j != s) {
      {
#line 775
      __gmpq_div(Xtemp, (mpq_srcptr )(*(Rtemp + (j - 1L))), (mpq_srcptr )(Xtemp0));
#line 776
      __gmpq_set(Xtemp1, (mpq_srcptr )(dd_purezero));
#line 777
      j1___0 = (dd_colrange )1;
      }
      {
#line 777
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 777
        if (! (j1___0 <= d_size)) {
#line 777
          goto while_break___3;
        }
        {
#line 778
        __gmpq_mul(Xtemp1, (mpq_srcptr )(Xtemp), (mpq_srcptr )(*(*(T + (j1___0 - 1L)) + (s - 1L))));
#line 779
        __gmpq_sub(*(*(T + (j1___0 - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(T + (j1___0 - 1L)) + (j - 1L))),
                   (mpq_srcptr )(Xtemp1));
#line 777
        j1___0 ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 773
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 784
  j = (dd_colrange )1;
  {
#line 784
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 784
    if (! (j <= d_size)) {
#line 784
      goto while_break___4;
    }
    {
#line 785
    __gmpq_div(*(*(T + (j - 1L)) + (s - 1L)), (mpq_srcptr )(*(*(T + (j - 1L)) + (s - 1L))),
               (mpq_srcptr )(Xtemp0));
#line 784
    j ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 787
  __gmpq_clear(Xtemp0);
#line 787
  __gmpq_clear(Xtemp1);
#line 787
  __gmpq_clear(Xtemp);
  }
#line 788
  return;
}
}
#line 790 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_GaussianColumnPivot2(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                             dd_Bmatrix T , dd_colindex nbindex , dd_rowindex bflag___97 ,
                             dd_rowrange r , dd_colrange s ) 
{ 
  int localdebug ;
  long entering ;

  {
#line 797
  localdebug = 0;
#line 800
  if (dd_debug) {
#line 800
    localdebug = dd_debug;
  }
  {
#line 801
  dd_GaussianColumnPivot(m_size, d_size, A, T, r, s);
#line 802
  entering = *(nbindex + s);
#line 803
  *(bflag___97 + r) = s;
#line 804
  *(nbindex + s) = r;
  }
#line 806
  if (entering > 0L) {
#line 806
    *(bflag___97 + entering) = -1L;
  }
#line 809
  if (localdebug) {
    {
#line 810
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_GaussianColumnPivot2\n");
#line 811
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" pivot: (leaving, entering) = (%ld, %ld)\n",
            r, entering);
#line 812
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" bflag[%ld] is set to %ld\n",
            r, s);
    }
  }
#line 814
  return;
}
}
#line 817 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_ResetTableau(dd_rowrange m_size , dd_colrange d_size , dd_Bmatrix T , dd_colindex nbindex ,
                     dd_rowindex bflag___97 , dd_rowrange objrow , dd_colrange rhscol ) 
{ 
  dd_rowrange i ;
  dd_colrange j ;

  {
#line 824
  j = (dd_colrange )1;
  {
#line 824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 824
    if (! (j <= d_size)) {
#line 824
      goto while_break;
    }
#line 824
    *(nbindex + j) = - j;
#line 824
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 825
  *(nbindex + rhscol) = 0L;
#line 828
  dd_SetToIdentity(d_size, T);
#line 831
  i = (dd_rowrange )1;
  }
  {
#line 831
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 831
    if (! (i <= m_size)) {
#line 831
      goto while_break___0;
    }
#line 831
    *(bflag___97 + i) = -1L;
#line 831
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 833
  *(bflag___97 + objrow) = 0L;
#line 836
  j = (dd_colrange )1;
  {
#line 836
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 836
    if (! (j <= d_size)) {
#line 836
      goto while_break___1;
    }
#line 836
    if (*(nbindex + j) > 0L) {
#line 836
      *(bflag___97 + *(nbindex + j)) = j;
    }
#line 836
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 839
  return;
}
}
#line 841 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_SelectCrissCrossPivot(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                              dd_Bmatrix T , dd_rowindex bflag___97 , dd_rowrange objrow ,
                              dd_colrange rhscol , dd_rowrange *r , dd_colrange *s ,
                              int *selected , dd_LPStatusType *lps ) 
{ 
  int colselected ;
  int rowselected ;
  dd_rowrange i ;
  mytype val ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;
  dd_boolean tmp___1 ;
  dd_boolean tmp___2 ;

  {
  {
#line 846
  colselected = 0;
#line 846
  rowselected = 0;
#line 850
  __gmpq_init(val);
#line 851
  *selected = 0;
#line 852
  *lps = (dd_LPStatusType )0;
  }
  {
#line 853
  while (1) {
    while_continue: /* CIL Label */ ;
#line 853
    if ((unsigned int )*lps == 0U) {
#line 853
      if (! rowselected) {
#line 853
        if (! (! colselected)) {
#line 853
          goto while_break;
        }
      } else {
#line 853
        goto while_break;
      }
    } else {
#line 853
      goto while_break;
    }
#line 854
    i = (dd_rowrange )1;
    {
#line 854
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 854
      if (! (i <= m_size)) {
#line 854
        goto while_break___0;
      }
#line 855
      if (i != objrow) {
#line 855
        if (*(bflag___97 + i) == -1L) {
          {
#line 856
          dd_TableauEntry(& val, m_size, d_size, A, T, i, rhscol);
#line 857
          tmp = dd_Negative((__mpq_struct *)(val));
          }
#line 857
          if (tmp) {
#line 858
            rowselected = 1;
#line 859
            *r = i;
#line 860
            goto while_break___0;
          }
        } else {
#line 855
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 863
      if (*(bflag___97 + i) > 0L) {
        {
#line 864
        dd_TableauEntry(& val, m_size, d_size, A, T, objrow, *(bflag___97 + i));
#line 865
        tmp___0 = dd_Positive((__mpq_struct *)(val));
        }
#line 865
        if (tmp___0) {
#line 866
          colselected = 1;
#line 867
          *s = *(bflag___97 + i);
#line 868
          goto while_break___0;
        }
      }
#line 854
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 872
    if (! rowselected) {
#line 872
      if (! colselected) {
#line 873
        *lps = (dd_LPStatusType )1;
#line 874
        return;
      } else {
#line 872
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 876
    if (rowselected) {
#line 877
      i = (dd_rowrange )1;
      {
#line 877
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 877
        if (! (i <= m_size)) {
#line 877
          goto while_break___1;
        }
#line 878
        if (*(bflag___97 + i) > 0L) {
          {
#line 879
          dd_TableauEntry(& val, m_size, d_size, A, T, *r, *(bflag___97 + i));
#line 880
          tmp___1 = dd_Positive((__mpq_struct *)(val));
          }
#line 880
          if (tmp___1) {
#line 881
            colselected = 1;
#line 882
            *s = *(bflag___97 + i);
#line 883
            *selected = 1;
#line 884
            goto while_break___1;
          }
        }
#line 877
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 889
    if (colselected) {
#line 890
      i = (dd_rowrange )1;
      {
#line 890
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 890
        if (! (i <= m_size)) {
#line 890
          goto while_break___2;
        }
#line 891
        if (i != objrow) {
#line 891
          if (*(bflag___97 + i) == -1L) {
            {
#line 892
            dd_TableauEntry(& val, m_size, d_size, A, T, i, *s);
#line 893
            tmp___2 = dd_Negative((__mpq_struct *)(val));
            }
#line 893
            if (tmp___2) {
#line 894
              rowselected = 1;
#line 895
              *r = i;
#line 896
              *selected = 1;
#line 897
              goto while_break___2;
            }
          }
        }
#line 890
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 902
    if (! rowselected) {
#line 903
      *lps = (dd_LPStatusType )3;
    } else
#line 905
    if (! colselected) {
#line 906
      *lps = (dd_LPStatusType )2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 909
  __gmpq_clear(val);
  }
#line 910
  return;
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_CrissCrossSolve(dd_LPPtr lp , dd_ErrorType *err ) 
{ 


  {
  {
#line 915
  if ((unsigned int )lp->objective == 1U) {
#line 915
    goto case_1;
  }
#line 919
  if ((unsigned int )lp->objective == 2U) {
#line 919
    goto case_2;
  }
#line 923
  if ((unsigned int )lp->objective == 0U) {
#line 923
    goto case_0;
  }
#line 914
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 916
  dd_CrissCrossMaximize(lp, err);
  }
#line 917
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 920
  dd_CrissCrossMinimize(lp, err);
  }
#line 921
  goto switch_break;
  case_0: /* CIL Label */ 
#line 923
  *err = (dd_ErrorType )8;
#line 923
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 926
  return;
}
}
#line 928 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_DualSimplexSolve(dd_LPPtr lp , dd_ErrorType *err ) 
{ 


  {
  {
#line 931
  if ((unsigned int )lp->objective == 1U) {
#line 931
    goto case_1;
  }
#line 935
  if ((unsigned int )lp->objective == 2U) {
#line 935
    goto case_2;
  }
#line 939
  if ((unsigned int )lp->objective == 0U) {
#line 939
    goto case_0;
  }
#line 930
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 932
  dd_DualSimplexMaximize(lp, err);
  }
#line 933
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 936
  dd_DualSimplexMinimize(lp, err);
  }
#line 937
  goto switch_break;
  case_0: /* CIL Label */ 
#line 939
  *err = (dd_ErrorType )8;
#line 939
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 941
  return;
}
}
#line 945 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_LPStatusType LPSf2LPS(ddf_LPStatusType lpsf ) 
{ 
  dd_LPStatusType lps ;

  {
#line 947
  lps = (dd_LPStatusType )0;
  {
#line 950
  if ((unsigned int )lpsf == 0U) {
#line 950
    goto case_0;
  }
#line 951
  if ((unsigned int )lpsf == 1U) {
#line 951
    goto case_1;
  }
#line 952
  if ((unsigned int )lpsf == 2U) {
#line 952
    goto case_2;
  }
#line 953
  if ((unsigned int )lpsf == 3U) {
#line 953
    goto case_3;
  }
#line 954
  if ((unsigned int )lpsf == 4U) {
#line 954
    goto case_4;
  }
#line 955
  if ((unsigned int )lpsf == 5U) {
#line 955
    goto case_5;
  }
#line 956
  if ((unsigned int )lpsf == 6U) {
#line 956
    goto case_6;
  }
#line 957
  if ((unsigned int )lpsf == 7U) {
#line 957
    goto case_7;
  }
#line 949
  goto switch_break;
  case_0: /* CIL Label */ 
#line 950
  lps = (dd_LPStatusType )0;
#line 950
  goto switch_break;
  case_1: /* CIL Label */ 
#line 951
  lps = (dd_LPStatusType )1;
#line 951
  goto switch_break;
  case_2: /* CIL Label */ 
#line 952
  lps = (dd_LPStatusType )2;
#line 952
  goto switch_break;
  case_3: /* CIL Label */ 
#line 953
  lps = (dd_LPStatusType )3;
#line 953
  goto switch_break;
  case_4: /* CIL Label */ 
#line 954
  lps = (dd_LPStatusType )4;
#line 954
  goto switch_break;
  case_5: /* CIL Label */ 
#line 955
  lps = (dd_LPStatusType )5;
#line 955
  goto switch_break;
  case_6: /* CIL Label */ 
#line 956
  lps = (dd_LPStatusType )6;
#line 956
  goto switch_break;
  case_7: /* CIL Label */ 
#line 957
  lps = (dd_LPStatusType )7;
#line 957
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 959
  return (lps);
}
}
#line 963 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_BasisStatus(ddf_LPPtr lpf , dd_LPPtr lp , dd_boolean *LPScorrect ) 
{ 
  int i ;
  dd_colrange se ;
  dd_colrange j ;
  dd_boolean basisfound ;

  {
  {
#line 970
  if ((unsigned int )lp->objective == 1U) {
#line 970
    goto case_1;
  }
#line 983
  if ((unsigned int )lp->objective == 2U) {
#line 983
    goto case_2;
  }
#line 996
  if ((unsigned int )lp->objective == 0U) {
#line 996
    goto case_0;
  }
#line 969
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 971
  dd_BasisStatusMaximize(lp->m, lp->d, lp->A, lp->B, lp->equalityset, lp->objrow,
                         lp->rhscol, lpf->LPS, & lp->optvalue, lp->sol, lp->dsol,
                         lp->posset_extra, lpf->nbindex, lpf->re, lpf->se, & se, lp->pivots,
                         & basisfound, LPScorrect);
  }
#line 974
  if (*LPScorrect) {
    {
#line 976
    lp->LPS = LPSf2LPS(lpf->LPS);
#line 977
    lp->re = lpf->re;
#line 978
    lp->se = se;
#line 979
    j = (dd_colrange )1;
    }
    {
#line 979
    while (1) {
      while_continue: /* CIL Label */ ;
#line 979
      if (! (j <= lp->d)) {
#line 979
        goto while_break;
      }
#line 979
      *(lp->nbindex + j) = *(lpf->nbindex + j);
#line 979
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 981
  i = 1;
  {
#line 981
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 981
    if (! (i <= 5)) {
#line 981
      goto while_break___0;
    }
#line 981
    lp->pivots[i - 1] += lpf->pivots[i - 1];
#line 981
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 982
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 984
  dd_BasisStatusMinimize(lp->m, lp->d, lp->A, lp->B, lp->equalityset, lp->objrow,
                         lp->rhscol, lpf->LPS, & lp->optvalue, lp->sol, lp->dsol,
                         lp->posset_extra, lpf->nbindex, lpf->re, lpf->se, & se, lp->pivots,
                         & basisfound, LPScorrect);
  }
#line 987
  if (*LPScorrect) {
    {
#line 989
    lp->LPS = LPSf2LPS(lpf->LPS);
#line 990
    lp->re = lpf->re;
#line 991
    lp->se = se;
#line 992
    j = (dd_colrange )1;
    }
    {
#line 992
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 992
      if (! (j <= lp->d)) {
#line 992
        goto while_break___1;
      }
#line 992
      *(lp->nbindex + j) = *(lpf->nbindex + j);
#line 992
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 994
  i = 1;
  {
#line 994
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 994
    if (! (i <= 5)) {
#line 994
      goto while_break___2;
    }
#line 994
    lp->pivots[i - 1] += lpf->pivots[i - 1];
#line 994
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 995
  goto switch_break;
  case_0: /* CIL Label */ 
#line 996
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 998
  return;
}
}
#line 1001 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_FindLPBasis(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A , dd_Bmatrix T ,
                    dd_rowindex OV , dd_rowset equalityset , dd_colindex nbindex ,
                    dd_rowindex bflag___97 , dd_rowrange objrow , dd_colrange rhscol ,
                    dd_colrange *cs , int *found , dd_LPStatusType *lps , long *pivot_no ) 
{ 
  int chosen ;
  int stop ;
  long pivots_p0 ;
  long rank ;
  colset ColSelected ;
  rowset RowSelected ;
  mytype val ;
  dd_rowrange r ;
  dd_colrange j ;
  dd_colrange s ;
  dd_boolean tmp ;

  {
  {
#line 1019
  pivots_p0 = 0L;
#line 1027
  __gmpq_init(val);
#line 1028
  *found = 0;
#line 1028
  *cs = (dd_colrange )0;
#line 1028
  rank = 0L;
#line 1029
  stop = 0;
#line 1030
  *lps = (dd_LPStatusType )0;
#line 1032
  set_initialize(& RowSelected, m_size);
#line 1033
  set_initialize(& ColSelected, d_size);
#line 1034
  set_addelem(RowSelected, objrow);
#line 1035
  set_addelem(ColSelected, rhscol);
#line 1037
  stop = 0;
  }
  {
#line 1038
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1039
    dd_SelectPivot2(m_size, d_size, A, T, (dd_RowOrderType )1, OV, equalityset, m_size,
                    RowSelected, ColSelected, & r, & s, & chosen);
    }
#line 1041
    if (chosen) {
      {
#line 1042
      set_addelem(RowSelected, r);
#line 1043
      set_addelem(ColSelected, s);
#line 1044
      dd_GaussianColumnPivot2(m_size, d_size, A, T, nbindex, bflag___97, r, s);
#line 1045
      pivots_p0 ++;
#line 1046
      rank ++;
      }
    } else {
#line 1048
      j = (dd_colrange )1;
      {
#line 1048
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1048
        if (j <= d_size) {
#line 1048
          if (! ((unsigned int )*lps == 0U)) {
#line 1048
            goto while_break___0;
          }
        } else {
#line 1048
          goto while_break___0;
        }
#line 1049
        if (j != rhscol) {
#line 1049
          if (*(nbindex + j) < 0L) {
            {
#line 1050
            dd_TableauEntry(& val, m_size, d_size, A, T, objrow, j);
#line 1051
            tmp = dd_Nonzero((__mpq_struct *)(val));
            }
#line 1051
            if (tmp) {
#line 1052
              *lps = (dd_LPStatusType )5;
#line 1053
              *cs = j;
            }
          }
        }
#line 1048
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1058
      if ((unsigned int )*lps == 0U) {
#line 1058
        *found = 1;
      }
#line 1060
      stop = 1;
    }
#line 1063
    if (rank == d_size - 1L) {
#line 1064
      stop = 1;
#line 1065
      *found = 1;
    }
#line 1038
    if (! (! stop)) {
#line 1038
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1069
  *pivot_no = pivots_p0;
#line 1070
  dd_statBApivots += pivots_p0;
#line 1071
  set_free(RowSelected);
#line 1072
  set_free(ColSelected);
#line 1073
  __gmpq_clear(val);
  }
#line 1074
  return;
}
}
#line 1077 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_FindLPBasis2(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A , dd_Bmatrix T ,
                     dd_rowindex OV , dd_rowset equalityset , dd_colindex nbindex ,
                     dd_rowindex bflag___97 , dd_rowrange objrow , dd_colrange rhscol ,
                     dd_colrange *cs , int *found , long *pivot_no ) 
{ 
  int chosen ;
  int stop ;
  long pivots_p0 ;
  long rank ;
  dd_colset ColSelected ;
  dd_colset DependentCols ;
  dd_rowset RowSelected ;
  dd_rowset NopivotRow ;
  mytype val ;
  dd_boolean localdebug ;
  dd_rowrange r ;
  dd_rowrange negcount ;
  dd_colrange j ;
  dd_colrange s ;

  {
  {
#line 1087
  pivots_p0 = 0L;
#line 1091
  localdebug = 0;
#line 1093
  negcount = (dd_rowrange )0;
#line 1096
  __gmpq_init(val);
#line 1097
  *found = 0;
#line 1097
  *cs = (dd_colrange )0;
#line 1097
  rank = 0L;
#line 1099
  set_initialize(& RowSelected, m_size);
#line 1100
  set_initialize(& DependentCols, d_size);
#line 1101
  set_initialize(& ColSelected, d_size);
#line 1102
  set_initialize(& NopivotRow, m_size);
#line 1103
  set_addelem(RowSelected, objrow);
#line 1104
  set_addelem(ColSelected, rhscol);
#line 1105
  set_compl(NopivotRow, NopivotRow);
#line 1107
  j = (dd_colrange )2;
  }
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if (! (j <= d_size)) {
#line 1107
      goto while_break;
    }
#line 1108
    if (*(nbindex + j) > 0L) {
      {
#line 1109
      set_delelem(NopivotRow, *(nbindex + j));
      }
    } else
#line 1110
    if (*(nbindex + j) < 0L) {
      {
#line 1111
      negcount ++;
#line 1112
      set_addelem(DependentCols, - *(nbindex + j));
#line 1113
      set_addelem(ColSelected, - *(nbindex + j));
      }
    }
#line 1107
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1116
  set_uni(RowSelected, RowSelected, NopivotRow);
#line 1118
  stop = 0;
  }
  {
#line 1119
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1120
    dd_SelectPivot2(m_size, d_size, A, T, (dd_RowOrderType )1, OV, equalityset, m_size,
                    RowSelected, ColSelected, & r, & s, & chosen);
    }
#line 1121
    if (chosen) {
      {
#line 1122
      set_addelem(RowSelected, r);
#line 1123
      set_addelem(ColSelected, s);
#line 1125
      dd_GaussianColumnPivot2(m_size, d_size, A, T, nbindex, bflag___97, r, s);
      }
#line 1126
      if (localdebug) {
#line 1126
        if (m_size <= 10L) {
          {
#line 1127
          dd_WriteBmatrix(stderr, d_size, T);
#line 1128
          dd_WriteTableau(stderr, m_size, d_size, A, T, nbindex, bflag___97);
          }
        }
      }
#line 1130
      pivots_p0 ++;
#line 1131
      rank ++;
    } else {
#line 1133
      *found = 0;
#line 1134
      stop = 1;
    }
#line 1136
    if (rank == (d_size - 1L) - negcount) {
#line 1137
      if (negcount) {
        {
#line 1139
        set_diff(ColSelected, ColSelected, DependentCols);
#line 1140
        dd_SelectPivot2(m_size, d_size, A, T, (dd_RowOrderType )1, OV, equalityset,
                        m_size, RowSelected, ColSelected, & r, & s, & chosen);
        }
#line 1141
        if (chosen) {
#line 1141
          *found = 0;
        } else {
#line 1142
          *found = 1;
        }
#line 1143
        if (localdebug) {
          {
#line 1144
          printf((char const   */* __restrict  */)"Try to check the dependent cols:");
#line 1145
          set_write(DependentCols);
          }
#line 1146
          if (chosen) {
            {
#line 1146
            printf((char const   */* __restrict  */)"They are not dependent.  Can still pivot on (%ld, %ld)\n",
                   r, s);
            }
          } else {
            {
#line 1147
            printf((char const   */* __restrict  */)"They are indeed dependent.\n");
            }
          }
        }
      } else {
#line 1150
        *found = 1;
      }
#line 1152
      stop = 1;
    }
#line 1119
    if (! (! stop)) {
#line 1119
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1156
  j = (dd_colrange )1;
  {
#line 1156
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1156
    if (! (j <= d_size)) {
#line 1156
      goto while_break___1;
    }
#line 1156
    if (*(nbindex + j) > 0L) {
#line 1156
      *(bflag___97 + *(nbindex + j)) = j;
    }
#line 1156
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1157
  *pivot_no = pivots_p0;
#line 1158
  set_free(RowSelected);
#line 1159
  set_free(ColSelected);
#line 1160
  set_free(NopivotRow);
#line 1161
  set_free(DependentCols);
#line 1162
  __gmpq_clear(val);
  }
#line 1163
  return;
}
}
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___1  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___0  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref  ;
#line 1165 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_FindDualFeasibleBasis(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                              dd_Bmatrix T , dd_rowindex OV , dd_colindex nbindex ,
                              long *bflag___97 , dd_rowrange objrow , dd_colrange rhscol ,
                              dd_boolean lexicopivot , dd_colrange *s , dd_ErrorType *err ,
                              dd_LPStatusType *lps , long *pivot_no , long maxpivots ) 
{ 
  dd_boolean phase1 ;
  dd_boolean dualfeasible ;
  dd_boolean localdebug ;
  dd_boolean chosen ;
  dd_boolean stop ;
  dd_LPStatusType LPSphase1 ;
  long pivots_p1 ;
  dd_rowrange i ;
  dd_rowrange r_val ;
  dd_colrange j ;
  dd_colrange l ;
  dd_colrange ms ;
  dd_colrange s_val ;
  dd_colrange local_m_size ;
  mytype x ;
  mytype val ;
  mytype maxcost ;
  mytype axvalue ;
  mytype maxratio ;
  mytype scaling ;
  mytype svalue ;
  mytype minval ;
  void *tmp ;
  void *tmp___0 ;
  dd_boolean tmp___1 ;
  dd_boolean tmp___2 ;
  dd_boolean tmp___3 ;
  dd_boolean tmp___4 ;
  dd_boolean tmp___5 ;
  dd_boolean tmp___6 ;
  dd_boolean tmp___7 ;
  dd_boolean tmp___8 ;

  {
#line 1178
  dualfeasible = 1;
#line 1179
  localdebug = 0;
#line 1181
  pivots_p1 = 0L;
#line 1183
  ms = (dd_colrange )0;
#line 1192
  if (dd_debug) {
#line 1192
    localdebug = dd_debug;
  }
  {
#line 1193
  __gmpq_init(x);
#line 1193
  __gmpq_init(val);
#line 1193
  __gmpq_init(scaling);
#line 1193
  __gmpq_init(svalue);
#line 1193
  __gmpq_init(axvalue);
#line 1194
  __gmpq_init(maxcost);
#line 1194
  __gmpq_set(maxcost, (mpq_srcptr )(dd_minuszero));
#line 1195
  __gmpq_init(maxratio);
#line 1195
  __gmpq_set(maxratio, (mpq_srcptr )(dd_minuszero));
  }
#line 1196
  if (d_last___1 < d_size) {
#line 1197
    if (d_last___1 > 0L) {
#line 1198
      j = (dd_colrange )1;
      {
#line 1198
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1198
        if (! (j <= d_last___1)) {
#line 1198
          goto while_break;
        }
        {
#line 1198
        __gmpq_clear(*(rcost___0 + (j - 1L)));
#line 1198
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1199
      free((void *)rcost___0);
#line 1200
      free((void *)nbindex_ref);
      }
    }
    {
#line 1202
    tmp = calloc((size_t )d_size, sizeof(mytype ));
#line 1202
    rcost___0 = (mytype *)tmp;
#line 1203
    tmp___0 = calloc((size_t )(d_size + 1L), sizeof(long ));
#line 1203
    nbindex_ref = (long *)tmp___0;
#line 1204
    j = (dd_colrange )1;
    }
    {
#line 1204
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1204
      if (! (j <= d_size)) {
#line 1204
        goto while_break___0;
      }
      {
#line 1204
      __gmpq_init(*(rcost___0 + (j - 1L)));
#line 1204
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1205
    d_last___1 = d_size;
  }
#line 1208
  *err = (dd_ErrorType )17;
#line 1208
  *lps = (dd_LPStatusType )0;
#line 1208
  *s = (dd_colrange )0;
#line 1209
  local_m_size = m_size + 1L;
#line 1211
  ms = (dd_colrange )0;
#line 1212
  j = (dd_colrange )1;
  {
#line 1212
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1212
    if (! (j <= d_size)) {
#line 1212
      goto while_break___1;
    }
#line 1213
    if (j != rhscol) {
      {
#line 1214
      dd_TableauEntry(rcost___0 + (j - 1L), local_m_size, d_size, A, T, objrow, j);
#line 1215
      tmp___1 = dd_Larger((__mpq_struct *)(*(rcost___0 + (j - 1L))), (__mpq_struct *)(maxcost));
      }
#line 1215
      if (tmp___1) {
        {
#line 1215
        __gmpq_set(maxcost, (mpq_srcptr )(*(rcost___0 + (j - 1L))));
#line 1215
        ms = j;
        }
      }
    }
#line 1212
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1218
  tmp___2 = dd_Positive((__mpq_struct *)(maxcost));
  }
#line 1218
  if (tmp___2) {
#line 1218
    dualfeasible = 0;
  }
#line 1220
  if (! dualfeasible) {
#line 1221
    j = (dd_colrange )1;
    {
#line 1221
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1221
      if (! (j <= d_size)) {
#line 1221
        goto while_break___2;
      }
      {
#line 1222
      __gmpq_set(*(*(A + (local_m_size - 1L)) + (j - 1L)), (mpq_srcptr )(dd_purezero));
#line 1223
      l = (dd_colrange )1;
      }
      {
#line 1223
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1223
        if (! (l <= d_size)) {
#line 1223
          goto while_break___3;
        }
#line 1224
        if (*(nbindex + l) > 0L) {
          {
#line 1225
          ddd_mpq_set_si((__mpq_struct *)(scaling), l + 10L);
#line 1226
          __gmpq_mul(svalue, (mpq_srcptr )(*(*(A + (*(nbindex + l) - 1L)) + (j - 1L))),
                     (mpq_srcptr )(scaling));
#line 1227
          __gmpq_sub(*(*(A + (local_m_size - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(A + (local_m_size - 1L)) + (j - 1L))),
                     (mpq_srcptr )(svalue));
          }
        }
#line 1223
        l ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1221
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1235
    if (localdebug) {
      {
#line 1236
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ndd_FindDualFeasibleBasis: curruent basis is not dual feasible.\n");
#line 1237
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"because of the column %ld assoc. with var %ld   dual cost =",
              ms, *(nbindex + ms));
#line 1239
      dd_WriteNumber(stderr, (__mpq_struct *)(maxcost));
      }
#line 1240
      if (localdebug) {
#line 1241
        if (m_size <= 100L) {
#line 1241
          if (d_size <= 30L) {
            {
#line 1242
            printf((char const   */* __restrict  */)"\ndd_FindDualFeasibleBasis: the starting dictionary.\n");
#line 1243
            dd_WriteTableau(stdout, m_size + 1L, d_size, A, T, nbindex, bflag___97);
            }
          }
        }
      }
    }
#line 1248
    ms = (dd_colrange )0;
#line 1251
    j = (dd_colrange )1;
    {
#line 1251
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1251
      if (! (j <= d_size)) {
#line 1251
        goto while_break___4;
      }
#line 1252
      if (j != rhscol) {
        {
#line 1252
        tmp___5 = dd_Positive((__mpq_struct *)(*(rcost___0 + (j - 1L))));
        }
#line 1252
        if (tmp___5) {
          {
#line 1253
          dd_TableauEntry(& axvalue, local_m_size, d_size, A, T, local_m_size, j);
#line 1254
          tmp___3 = dd_Nonnegative((__mpq_struct *)(axvalue));
          }
#line 1254
          if (tmp___3) {
#line 1255
            *err = (dd_ErrorType )16;
#line 1257
            if (localdebug) {
              {
#line 1257
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_FindDualFeasibleBasis: Numerical Inconsistency detected.\n");
              }
            }
#line 1258
            goto _L99;
          }
          {
#line 1260
          __gmpq_neg(axvalue, (mpq_srcptr )(axvalue));
#line 1261
          __gmpq_div(axvalue, (mpq_srcptr )(*(rcost___0 + (j - 1L))), (mpq_srcptr )(axvalue));
#line 1262
          tmp___4 = dd_Larger((__mpq_struct *)(axvalue), (__mpq_struct *)(maxratio));
          }
#line 1262
          if (tmp___4) {
            {
#line 1263
            __gmpq_set(maxratio, (mpq_srcptr )(axvalue));
#line 1264
            ms = j;
            }
          }
        }
      }
#line 1251
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1269
    if (ms == 0L) {
#line 1270
      *err = (dd_ErrorType )16;
#line 1271
      if (localdebug) {
        {
#line 1271
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_FindDualFeasibleBasis: Numerical Inconsistency detected.\n");
        }
      }
#line 1272
      goto _L99;
    }
    {
#line 1276
    dd_GaussianColumnPivot2(local_m_size, d_size, A, T, nbindex, bflag___97, local_m_size,
                            ms);
#line 1277
    pivots_p1 ++;
    }
#line 1278
    if (localdebug) {
      {
#line 1279
      printf((char const   */* __restrict  */)"\ndd_FindDualFeasibleBasis: Pivot on %ld %ld.\n",
             local_m_size, ms);
      }
    }
#line 1282
    j = (dd_colrange )1;
    {
#line 1282
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1282
      if (! (j <= d_size)) {
#line 1282
        goto while_break___5;
      }
#line 1282
      *(nbindex_ref + j) = *(nbindex + j);
#line 1282
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1284
    if (localdebug) {
      {
#line 1285
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Store the current feasible basis:");
#line 1286
      j = (dd_colrange )1;
      }
      {
#line 1286
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1286
        if (! (j <= d_size)) {
#line 1286
          goto while_break___6;
        }
        {
#line 1286
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %ld",
                *(nbindex_ref + j));
#line 1286
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1287
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
#line 1288
      if (m_size <= 100L) {
#line 1288
        if (d_size <= 30L) {
          {
#line 1289
          dd_WriteSignTableau2(stdout, m_size + 1L, d_size, A, T, nbindex_ref, nbindex,
                               bflag___97);
          }
        }
      }
    }
#line 1292
    phase1 = 1;
#line 1292
    stop = 0;
    {
#line 1293
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1294
      chosen = 0;
#line 1294
      LPSphase1 = (dd_LPStatusType )0;
#line 1295
      if (pivots_p1 > maxpivots) {
        {
#line 1296
        *err = (dd_ErrorType )15;
#line 1297
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"max number %ld of pivots performed in Phase I. Switch to the anticycling phase.\n",
                maxpivots);
        }
#line 1298
        goto _L99;
      }
      {
#line 1300
      dd_SelectDualSimplexPivot(local_m_size, d_size, phase1, A, T, OV, nbindex_ref,
                                nbindex, bflag___97, objrow, rhscol, lexicopivot,
                                & r_val, & s_val, & chosen, & LPSphase1);
      }
#line 1302
      if (! chosen) {
        {
#line 1309
        dd_TableauEntry(& x, local_m_size, d_size, A, T, objrow, ms);
#line 1310
        tmp___6 = dd_Negative((__mpq_struct *)(x));
        }
#line 1310
        if (tmp___6) {
#line 1311
          *err = (dd_ErrorType )17;
#line 1311
          *lps = (dd_LPStatusType )3;
#line 1311
          *s = ms;
        }
#line 1313
        if (localdebug) {
          {
#line 1314
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ndd_FindDualFeasibleBasis: the auxiliary variable was forced to enter the basis (# pivots = %ld).\n",
                  pivots_p1);
#line 1315
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -- objrow %ld, ms %ld entry: ",
                  objrow, ms);
#line 1316
          dd_WriteNumber(stderr, (__mpq_struct *)(x));
#line 1316
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1317
          tmp___7 = dd_Negative((__mpq_struct *)(x));
          }
#line 1317
          if (tmp___7) {
            {
#line 1318
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"->The basis is dual inconsistent. Terminate.\n");
            }
          } else {
            {
#line 1320
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"->The basis is feasible. Go to phase II.\n");
            }
          }
        }
        {
#line 1324
        __gmpq_init(minval);
#line 1325
        r_val = (dd_rowrange )0;
#line 1326
        i = (dd_rowrange )1;
        }
        {
#line 1326
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1326
          if (! (i <= local_m_size)) {
#line 1326
            goto while_break___8;
          }
#line 1327
          if (*(bflag___97 + i) < 0L) {
            {
#line 1329
            dd_TableauEntry(& val, local_m_size, d_size, A, T, i, ms);
#line 1330
            tmp___8 = dd_Smaller((__mpq_struct *)(val), (__mpq_struct *)(minval));
            }
#line 1330
            if (tmp___8) {
              {
#line 1331
              r_val = i;
#line 1332
              __gmpq_set(minval, (mpq_srcptr )(val));
              }
            }
          }
#line 1326
          i ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 1336
        __gmpq_clear(minval);
        }
#line 1338
        if (r_val == 0L) {
#line 1339
          *err = (dd_ErrorType )16;
#line 1340
          if (localdebug) {
            {
#line 1340
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_FindDualFeasibleBasis: Numerical Inconsistency detected (r_val is 0).\n");
            }
          }
#line 1341
          goto _L99;
        }
        {
#line 1344
        dd_GaussianColumnPivot2(local_m_size, d_size, A, T, nbindex, bflag___97, r_val,
                                ms);
#line 1345
        pivots_p1 ++;
        }
#line 1346
        if (localdebug) {
          {
#line 1347
          printf((char const   */* __restrict  */)"\ndd_FindDualFeasibleBasis: make the %ld-th pivot on %ld  %ld to force the auxiliary variable to enter the basis.\n",
                 pivots_p1, r_val, ms);
          }
#line 1348
          if (m_size <= 100L) {
#line 1348
            if (d_size <= 30L) {
              {
#line 1349
              dd_WriteSignTableau2(stdout, m_size + 1L, d_size, A, T, nbindex_ref,
                                   nbindex, bflag___97);
              }
            }
          }
        }
#line 1352
        stop = 1;
      } else {
        {
#line 1355
        dd_GaussianColumnPivot2(local_m_size, d_size, A, T, nbindex, bflag___97, r_val,
                                s_val);
#line 1356
        pivots_p1 ++;
        }
#line 1357
        if (localdebug) {
          {
#line 1358
          printf((char const   */* __restrict  */)"\ndd_FindDualFeasibleBasis: make a %ld-th pivot on %ld  %ld\n",
                 pivots_p1, r_val, s_val);
          }
#line 1359
          if (m_size <= 100L) {
#line 1359
            if (d_size <= 30L) {
              {
#line 1360
              dd_WriteSignTableau2(stdout, local_m_size, d_size, A, T, nbindex_ref,
                                   nbindex, bflag___97);
              }
            }
          }
        }
#line 1364
        if (*(bflag___97 + local_m_size) < 0L) {
#line 1365
          stop = 1;
#line 1366
          if (localdebug) {
            {
#line 1367
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nDualSimplex Phase I: the auxiliary variable entered the basis (# pivots = %ld).\nGo to phase II\n",
                    pivots_p1);
            }
          }
        }
      }
#line 1293
      if (! (! stop)) {
#line 1293
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  _L99: 
  {
#line 1373
  *pivot_no = pivots_p1;
#line 1374
  dd_statDS1pivots += pivots_p1;
#line 1375
  __gmpq_clear(x);
#line 1375
  __gmpq_clear(val);
#line 1375
  __gmpq_clear(maxcost);
#line 1375
  __gmpq_clear(maxratio);
#line 1376
  __gmpq_clear(scaling);
#line 1376
  __gmpq_clear(svalue);
#line 1376
  __gmpq_clear(axvalue);
  }
#line 1377
  return;
}
}
#line 1379 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_DualSimplexMinimize(dd_LPPtr lp , dd_ErrorType *err ) 
{ 
  dd_colrange j ;

  {
#line 1383
  *err = (dd_ErrorType )17;
#line 1384
  j = (dd_colrange )1;
  {
#line 1384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1384
    if (! (j <= lp->d)) {
#line 1384
      goto while_break;
    }
    {
#line 1385
    __gmpq_neg(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L))));
#line 1384
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1386
  dd_DualSimplexMaximize(lp, err);
#line 1387
  __gmpq_neg(lp->optvalue, (mpq_srcptr )(lp->optvalue));
#line 1388
  j = (dd_colrange )1;
  }
  {
#line 1388
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1388
    if (! (j <= lp->d)) {
#line 1388
      goto while_break___0;
    }
#line 1389
    if ((unsigned int )lp->LPS != 2U) {
      {
#line 1391
      __gmpq_neg(*(lp->dsol + (j - 1L)), (mpq_srcptr )(*(lp->dsol + (j - 1L))));
      }
    }
    {
#line 1393
    __gmpq_neg(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L))));
#line 1388
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1395
  return;
}
}
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___0  ;
#line 1397 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_DualSimplexMaximize(dd_LPPtr lp , dd_ErrorType *err ) 
{ 
  int stop ;
  int chosen ;
  int phase1 ;
  int found ;
  long pivots_ds ;
  long pivots_p0 ;
  long pivots_p1 ;
  long pivots_pc ;
  long maxpivots ;
  long maxpivfactor ;
  dd_boolean localdebug ;
  dd_boolean localdebug1 ;
  dd_rowrange i ;
  dd_rowrange r ;
  dd_colrange j ;
  dd_colrange s ;
  double redpercent ;
  double redpercent_prev ;
  double redgain ;
  unsigned int rseed ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1404
  pivots_ds = 0L;
#line 1404
  pivots_p0 = 0L;
#line 1404
  pivots_p1 = 0L;
#line 1404
  pivots_pc = 0L;
#line 1404
  maxpivfactor = 20L;
#line 1405
  localdebug = 0;
#line 1405
  localdebug1 = 0;
#line 1421
  redpercent = (double )0;
#line 1421
  redpercent_prev = (double )0;
#line 1421
  redgain = (double )0;
#line 1422
  rseed = 1U;
#line 1425
  if (dd_debug) {
#line 1425
    localdebug = dd_debug;
  }
  {
#line 1426
  set_emptyset(lp->redset_extra);
#line 1427
  i = (dd_rowrange )0;
  }
  {
#line 1427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1427
    if (! (i <= 4L)) {
#line 1427
      goto while_break;
    }
#line 1427
    lp->pivots[i] = 0L;
#line 1427
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1428
  maxpivots = maxpivfactor * lp->d;
#line 1432
  if (mlast != lp->m) {
#line 1432
    goto _L;
  } else
#line 1432
  if (nlast != lp->d) {
    _L: /* CIL Label */ 
#line 1433
    if (mlast > 0L) {
      {
#line 1434
      free((void *)OrderVector);
#line 1435
      free((void *)bflag);
#line 1436
      free((void *)nbindex_ref___0);
      }
    }
    {
#line 1438
    tmp = calloc((size_t )(lp->m + 1L), sizeof(*OrderVector));
#line 1438
    OrderVector = (long *)tmp;
#line 1439
    tmp___0 = calloc((size_t )(lp->m + 2L), sizeof(*bflag));
#line 1439
    bflag = (long *)tmp___0;
#line 1440
    tmp___1 = calloc((size_t )(lp->d + 1L), sizeof(long ));
#line 1440
    nbindex_ref___0 = (long *)tmp___1;
#line 1441
    mlast = lp->m;
#line 1441
    nlast = lp->d;
    }
  }
  {
#line 1444
  dd_ComputeRowOrderVector2(lp->m, lp->d, lp->A, OrderVector, (dd_RowOrderType )1,
                            rseed);
#line 1446
  lp->re = (dd_rowrange )0;
#line 1446
  lp->se = (dd_colrange )0;
#line 1448
  dd_ResetTableau(lp->m, lp->d, lp->B, lp->nbindex, bflag, lp->objrow, lp->rhscol);
#line 1450
  dd_FindLPBasis(lp->m, lp->d, lp->A, lp->B, OrderVector, lp->equalityset, lp->nbindex,
                 bflag, lp->objrow, lp->rhscol, & s, & found, & lp->LPS, & pivots_p0);
#line 1452
  lp->pivots[0] = pivots_p0;
  }
#line 1454
  if (! found) {
#line 1455
    lp->se = s;
#line 1456
    goto _L99;
  }
  {
#line 1461
  dd_FindDualFeasibleBasis(lp->m, lp->d, lp->A, lp->B, OrderVector, lp->nbindex, bflag,
                           lp->objrow, lp->rhscol, lp->lexicopivot, & s, err, & lp->LPS,
                           & pivots_p1, maxpivots);
#line 1463
  lp->pivots[1] = pivots_p1;
#line 1465
  j = (dd_colrange )1;
  }
  {
#line 1465
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1465
    if (! (j <= lp->d)) {
#line 1465
      goto while_break___0;
    }
#line 1465
    *(nbindex_ref___0 + j) = *(lp->nbindex + j);
#line 1465
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1467
  if (localdebug) {
    {
#line 1468
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_DualSimplexMaximize: Store the current feasible basis:");
#line 1469
    j = (dd_colrange )1;
    }
    {
#line 1469
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1469
      if (! (j <= lp->d)) {
#line 1469
        goto while_break___1;
      }
      {
#line 1469
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %ld",
              *(nbindex_ref___0 + j));
#line 1469
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1470
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 1471
    if (lp->m <= 100L) {
#line 1471
      if (lp->d <= 30L) {
        {
#line 1472
        dd_WriteSignTableau2(stdout, lp->m + 1L, lp->d, lp->A, lp->B, nbindex_ref___0,
                             lp->nbindex, bflag);
        }
      }
    }
  }
#line 1475
  if ((unsigned int )*err == 15U) {
#line 1475
    goto _L___0;
  } else
#line 1475
  if ((unsigned int )*err == 16U) {
    _L___0: /* CIL Label */ 
#line 1476
    if (localdebug) {
      {
#line 1476
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Phase I failed and thus switch to the Criss-Cross method\n");
      }
    }
    {
#line 1477
    dd_CrissCrossMaximize(lp, err);
    }
#line 1478
    return;
  }
#line 1481
  if ((unsigned int )lp->LPS == 3U) {
#line 1482
    lp->se = s;
#line 1483
    goto _L99;
  }
#line 1489
  stop = 0;
  {
#line 1490
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1491
    chosen = 0;
#line 1491
    lp->LPS = (dd_LPStatusType )0;
#line 1491
    phase1 = 0;
#line 1492
    if (pivots_ds < maxpivots) {
      {
#line 1493
      dd_SelectDualSimplexPivot(lp->m, lp->d, phase1, lp->A, lp->B, OrderVector, nbindex_ref___0,
                                lp->nbindex, bflag, lp->objrow, lp->rhscol, lp->lexicopivot,
                                & r, & s, & chosen, & lp->LPS);
      }
    }
#line 1496
    if (chosen) {
#line 1497
      pivots_ds ++;
#line 1498
      if (lp->redcheck_extensive) {
        {
#line 1499
        dd_GetRedundancyInformation(lp->m, lp->d, lp->A, lp->B, lp->nbindex, bflag,
                                    lp->redset_extra);
#line 1500
        set_uni(lp->redset_accum, lp->redset_accum, lp->redset_extra);
#line 1501
        tmp___2 = set_card(lp->redset_extra);
#line 1501
        redpercent = ((double )100 * (double )tmp___2) / (double )lp->m;
#line 1502
        redgain = redpercent - redpercent_prev;
#line 1503
        redpercent_prev = redpercent;
        }
#line 1504
        if (localdebug1) {
          {
#line 1505
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ndd_DualSimplexMaximize: Phase II pivot %ld on (%ld, %ld).\n",
                  pivots_ds, r, s);
#line 1506
          tmp___3 = set_card(lp->redset_extra);
#line 1506
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  redundancy %f percent: redset size = %ld\n",
                  redpercent, tmp___3);
          }
        }
      }
    }
#line 1510
    if (! chosen) {
#line 1510
      if ((unsigned int )lp->LPS == 0U) {
#line 1511
        if (localdebug1) {
          {
#line 1512
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: an emergency CC pivot in Phase II is performed\n");
          }
#line 1517
          if (localdebug) {
#line 1517
            if (lp->m <= 100L) {
#line 1517
              if (lp->d <= 30L) {
                {
#line 1518
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ndd_DualSimplexMaximize: The current dictionary.\n");
#line 1519
                dd_WriteSignTableau2(stdout, lp->m, lp->d, lp->A, lp->B, nbindex_ref___0,
                                     lp->nbindex, bflag);
                }
              }
            }
          }
        }
        {
#line 1531
        dd_SelectCrissCrossPivot(lp->m, lp->d, lp->A, lp->B, bflag, lp->objrow, lp->rhscol,
                                 & r, & s, & chosen, & lp->LPS);
        }
#line 1533
        if (chosen) {
#line 1533
          pivots_pc ++;
        }
      }
    }
#line 1535
    if (chosen) {
      {
#line 1536
      dd_GaussianColumnPivot2(lp->m, lp->d, lp->A, lp->B, lp->nbindex, bflag, r, s);
      }
#line 1537
      if (localdebug) {
#line 1537
        if (lp->m <= 100L) {
#line 1537
          if (lp->d <= 30L) {
            {
#line 1538
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ndd_DualSimplexMaximize: The current dictionary.\n");
#line 1539
            dd_WriteSignTableau2(stdout, lp->m, lp->d, lp->A, lp->B, nbindex_ref___0,
                                 lp->nbindex, bflag);
            }
          }
        }
      }
    } else {
      {
#line 1543
      if ((unsigned int )lp->LPS == 2U) {
#line 1543
        goto case_2;
      }
#line 1544
      if ((unsigned int )lp->LPS == 3U) {
#line 1544
        goto case_3;
      }
#line 1546
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1543
      lp->re = r;
      case_3: /* CIL Label */ 
#line 1544
      lp->se = s;
      switch_default: /* CIL Label */ 
#line 1546
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1548
      stop = 1;
    }
#line 1490
    if (! (! stop)) {
#line 1490
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  _L99: 
  {
#line 1552
  lp->pivots[2] = pivots_ds;
#line 1553
  lp->pivots[3] = pivots_pc;
#line 1554
  dd_statDS2pivots += pivots_ds;
#line 1555
  dd_statACpivots += pivots_pc;
#line 1557
  dd_SetSolutions(lp->m, lp->d, lp->A, lp->B, lp->objrow, lp->rhscol, lp->LPS, & lp->optvalue,
                  lp->sol, lp->dsol, lp->posset_extra, lp->nbindex, lp->re, lp->se,
                  bflag);
  }
#line 1559
  return;
}
}
#line 1563 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_CrissCrossMinimize(dd_LPPtr lp , dd_ErrorType *err ) 
{ 
  dd_colrange j ;

  {
#line 1567
  *err = (dd_ErrorType )17;
#line 1568
  j = (dd_colrange )1;
  {
#line 1568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1568
    if (! (j <= lp->d)) {
#line 1568
      goto while_break;
    }
    {
#line 1569
    __gmpq_neg(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L))));
#line 1568
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1570
  dd_CrissCrossMaximize(lp, err);
#line 1571
  __gmpq_neg(lp->optvalue, (mpq_srcptr )(lp->optvalue));
#line 1572
  j = (dd_colrange )1;
  }
  {
#line 1572
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1572
    if (! (j <= lp->d)) {
#line 1572
      goto while_break___0;
    }
#line 1573
    if ((unsigned int )lp->LPS != 2U) {
      {
#line 1575
      __gmpq_neg(*(lp->dsol + (j - 1L)), (mpq_srcptr )(*(lp->dsol + (j - 1L))));
      }
    }
    {
#line 1577
    __gmpq_neg(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L))));
#line 1572
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1579
  return;
}
}
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___0  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___0  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___0  ;
#line 1581 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_CrissCrossMaximize(dd_LPPtr lp , dd_ErrorType *err ) 
{ 
  int stop ;
  int chosen ;
  int found ;
  long pivots0 ;
  long pivots1 ;
  dd_rowrange i ;
  dd_rowrange r ;
  dd_colrange s ;
  unsigned int rseed ;
  dd_colindex nbtemp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1601
  rseed = 1U;
#line 1604
  *err = (dd_ErrorType )17;
#line 1608
  tmp = calloc((size_t )(lp->d + 1L), sizeof(long ));
#line 1608
  nbtemp = (long *)tmp;
#line 1609
  i = (dd_rowrange )0;
  }
  {
#line 1609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1609
    if (! (i <= 4L)) {
#line 1609
      goto while_break;
    }
#line 1609
    lp->pivots[i] = 0L;
#line 1609
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1610
  if ((unsigned long )bflag___0 == (unsigned long )((void *)0)) {
#line 1610
    goto _L;
  } else
#line 1610
  if (mlast___0 != lp->m) {
    _L: /* CIL Label */ 
#line 1611
    if (mlast___0 != lp->m) {
#line 1611
      if (mlast___0 > 0L) {
        {
#line 1612
        free((void *)bflag___0);
#line 1613
        free((void *)OrderVector___0);
        }
      }
    }
    {
#line 1615
    tmp___0 = calloc((size_t )(lp->m + 1L), sizeof(long ));
#line 1615
    bflag___0 = (long *)tmp___0;
#line 1616
    tmp___1 = calloc((size_t )(lp->m + 1L), sizeof(long ));
#line 1616
    OrderVector___0 = (long *)tmp___1;
#line 1619
    mlast___0 = lp->m;
    }
  }
  {
#line 1622
  dd_ComputeRowOrderVector2(lp->m, lp->d, lp->A, OrderVector___0, (dd_RowOrderType )1,
                            rseed);
#line 1624
  lp->re = (dd_rowrange )0;
#line 1624
  lp->se = (dd_colrange )0;
#line 1624
  pivots1 = 0L;
#line 1626
  dd_ResetTableau(lp->m, lp->d, lp->B, lp->nbindex, bflag___0, lp->objrow, lp->rhscol);
#line 1628
  dd_FindLPBasis(lp->m, lp->d, lp->A, lp->B, OrderVector___0, lp->equalityset, lp->nbindex,
                 bflag___0, lp->objrow, lp->rhscol, & s, & found, & lp->LPS, & pivots0);
#line 1630
  lp->pivots[0] += pivots0;
  }
#line 1632
  if (! found) {
#line 1633
    lp->se = s;
#line 1634
    goto _L99;
  }
#line 1639
  stop = 0;
  {
#line 1640
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1649
    dd_SelectCrissCrossPivot(lp->m, lp->d, lp->A, lp->B, bflag___0, lp->objrow, lp->rhscol,
                             & r, & s, & chosen, & lp->LPS);
    }
#line 1651
    if (chosen) {
      {
#line 1652
      dd_GaussianColumnPivot2(lp->m, lp->d, lp->A, lp->B, lp->nbindex, bflag___0,
                              r, s);
#line 1653
      pivots1 ++;
      }
    } else {
      {
#line 1656
      if ((unsigned int )lp->LPS == 2U) {
#line 1656
        goto case_2;
      }
#line 1657
      if ((unsigned int )lp->LPS == 3U) {
#line 1657
        goto case_3;
      }
#line 1659
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1656
      lp->re = r;
      case_3: /* CIL Label */ 
#line 1657
      lp->se = s;
      switch_default: /* CIL Label */ 
#line 1659
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1661
      stop = 1;
    }
#line 1640
    if (! (! stop)) {
#line 1640
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  _L99: 
  {
#line 1666
  lp->pivots[1] += pivots1;
#line 1667
  dd_statCCpivots += pivots1;
#line 1668
  dd_SetSolutions(lp->m, lp->d, lp->A, lp->B, lp->objrow, lp->rhscol, lp->LPS, & lp->optvalue,
                  lp->sol, lp->dsol, lp->posset_extra, lp->nbindex, lp->re, lp->se,
                  bflag___0);
#line 1670
  free((void *)nbtemp);
  }
#line 1671
  return;
}
}
#line 1673 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_SetSolutions(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A , dd_Bmatrix T ,
                     dd_rowrange objrow , dd_colrange rhscol , dd_LPStatusType LPS ,
                     mytype *optvalue , dd_Arow sol , dd_Arow dsol , dd_rowset posset ,
                     dd_colindex nbindex , dd_rowrange re , dd_colrange se , dd_rowindex bflag___97 ) 
{ 
  dd_rowrange i ;
  dd_colrange j ;
  mytype x ;
  mytype sw ;
  int localdebug ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;

  {
  {
#line 1686
  localdebug = 0;
#line 1688
  __gmpq_init(x);
#line 1688
  __gmpq_init(sw);
  }
#line 1689
  if (localdebug) {
    {
#line 1689
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SetSolutions:\n");
    }
  }
  {
#line 1691
  if ((unsigned int )LPS == 1U) {
#line 1691
    goto case_1;
  }
#line 1707
  if ((unsigned int )LPS == 2U) {
#line 1707
    goto case_2;
  }
#line 1720
  if ((unsigned int )LPS == 3U) {
#line 1720
    goto case_3;
  }
#line 1733
  if ((unsigned int )LPS == 5U) {
#line 1733
    goto case_5;
  }
#line 1746
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1692
  j = (dd_colrange )1;
  {
#line 1692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1692
    if (! (j <= d_size)) {
#line 1692
      goto while_break;
    }
    {
#line 1693
    __gmpq_set(*(sol + (j - 1L)), (mpq_srcptr )(*(*(T + (j - 1L)) + (rhscol - 1L))));
#line 1694
    dd_TableauEntry(& x, m_size, d_size, A, T, objrow, j);
#line 1695
    __gmpq_neg(*(dsol + (j - 1L)), (mpq_srcptr )(x));
#line 1696
    dd_TableauEntry(optvalue, m_size, d_size, A, T, objrow, rhscol);
    }
#line 1697
    if (localdebug) {
      {
#line 1697
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dsol[%ld]= ",
              *(nbindex + j));
#line 1697
      dd_WriteNumber(stderr, (__mpq_struct *)(*(dsol + (j - 1L))));
      }
    }
#line 1692
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1699
  i = (dd_rowrange )1;
  {
#line 1699
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1699
    if (! (i <= m_size)) {
#line 1699
      goto while_break___0;
    }
#line 1700
    if (*(bflag___97 + i) == -1L) {
      {
#line 1701
      dd_TableauEntry(& x, m_size, d_size, A, T, i, rhscol);
#line 1702
      tmp = dd_Positive((__mpq_struct *)(x));
      }
#line 1702
      if (tmp) {
        {
#line 1702
        set_addelem(posset, i);
        }
      }
    }
#line 1699
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1706
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1708
  if (localdebug) {
    {
#line 1708
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SetSolutions: LP is inconsistent.\n");
    }
  }
#line 1709
  j = (dd_colrange )1;
  {
#line 1709
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1709
    if (! (j <= d_size)) {
#line 1709
      goto while_break___1;
    }
    {
#line 1710
    __gmpq_set(*(sol + (j - 1L)), (mpq_srcptr )(*(*(T + (j - 1L)) + (rhscol - 1L))));
#line 1711
    dd_TableauEntry(& x, m_size, d_size, A, T, re, j);
#line 1712
    __gmpq_neg(*(dsol + (j - 1L)), (mpq_srcptr )(x));
    }
#line 1713
    if (localdebug) {
      {
#line 1713
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dsol[%ld]=",
              *(nbindex + j));
#line 1714
      dd_WriteNumber(stderr, (__mpq_struct *)(*(dsol + (j - 1L))));
#line 1715
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1709
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1718
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1721
  if (localdebug) {
    {
#line 1721
    printf((char const   */* __restrict  */)"SetSolutions: LP is dual inconsistent.\n");
    }
  }
#line 1722
  j = (dd_colrange )1;
  {
#line 1722
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1722
    if (! (j <= d_size)) {
#line 1722
      goto while_break___2;
    }
    {
#line 1723
    __gmpq_set(*(sol + (j - 1L)), (mpq_srcptr )(*(*(T + (j - 1L)) + (se - 1L))));
#line 1724
    dd_TableauEntry(& x, m_size, d_size, A, T, objrow, j);
#line 1725
    __gmpq_neg(*(dsol + (j - 1L)), (mpq_srcptr )(x));
    }
#line 1726
    if (localdebug) {
      {
#line 1726
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dsol[%ld]=",
              *(nbindex + j));
#line 1727
      dd_WriteNumber(stderr, (__mpq_struct *)(*(dsol + (j - 1L))));
#line 1728
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1722
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1731
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1734
  dd_TableauEntry(& x, m_size, d_size, A, T, objrow, se);
#line 1735
  tmp___0 = dd_Positive((__mpq_struct *)(x));
  }
#line 1735
  if (tmp___0) {
    {
#line 1735
    __gmpq_set(sw, (mpq_srcptr )(dd_one));
    }
  } else {
    {
#line 1736
    __gmpq_neg(sw, (mpq_srcptr )(dd_one));
    }
  }
#line 1737
  j = (dd_colrange )1;
  {
#line 1737
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1737
    if (! (j <= d_size)) {
#line 1737
      goto while_break___3;
    }
    {
#line 1738
    __gmpq_mul(*(sol + (j - 1L)), (mpq_srcptr )(sw), (mpq_srcptr )(*(*(T + (j - 1L)) + (se - 1L))));
#line 1739
    dd_TableauEntry(& x, m_size, d_size, A, T, objrow, j);
#line 1740
    __gmpq_neg(*(dsol + (j - 1L)), (mpq_srcptr )(x));
    }
#line 1741
    if (localdebug) {
      {
#line 1741
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dsol[%ld]= ",
              *(nbindex + j));
#line 1741
      dd_WriteNumber(stderr, (__mpq_struct *)(*(dsol + (j - 1L))));
      }
    }
#line 1737
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1743
  if (localdebug) {
    {
#line 1743
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SetSolutions: LP is dual inconsistent.\n");
    }
  }
#line 1744
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1746
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1748
  __gmpq_clear(x);
#line 1748
  __gmpq_clear(sw);
  }
#line 1749
  return;
}
}
#line 1752 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_RandomPermutation2(dd_rowindex OV , long t , unsigned int seed ) 
{ 
  long k ;
  long j ;
  long ovj ;
  double u ;
  double xk ;
  double r ;
  double rand_max ;
  int localdebug ;
  int tmp ;

  {
  {
#line 1755
  rand_max = (double )2147483647;
#line 1756
  localdebug = 0;
#line 1758
  srand(seed);
#line 1759
  j = t;
  }
  {
#line 1759
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1759
    if (! (j > 1L)) {
#line 1759
      goto while_break;
    }
    {
#line 1760
    tmp = rand();
#line 1760
    r = (double )tmp;
#line 1761
    u = r / rand_max;
#line 1762
    xk = (double )j * u + (double )1;
#line 1763
    k = (long )xk;
    }
#line 1764
    if (localdebug) {
      {
#line 1764
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"u=%g, k=%ld, r=%g, randmax= %g\n",
              u, k, r, rand_max);
      }
    }
#line 1765
    ovj = *(OV + j);
#line 1766
    *(OV + j) = *(OV + k);
#line 1767
    *(OV + k) = ovj;
#line 1768
    if (localdebug) {
      {
#line 1768
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"row %ld is exchanged with %ld\n",
              j, k);
      }
    }
#line 1759
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1770
  return;
}
}
#line 1772 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_ComputeRowOrderVector2(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                               dd_rowindex OV , dd_RowOrderType ho , unsigned int rseed ) 
{ 
  long i ;
  long itemp ;

  {
#line 1777
  *(OV + 0) = 0L;
  {
#line 1779
  if ((unsigned int )ho == 0U) {
#line 1779
    goto case_0;
  }
#line 1783
  if ((unsigned int )ho == 5U) {
#line 1783
    goto case_5;
  }
#line 1788
  if ((unsigned int )ho == 6U) {
#line 1788
    goto case_6;
  }
#line 1798
  if ((unsigned int )ho == 7U) {
#line 1798
    goto case_7;
  }
#line 1804
  if ((unsigned int )ho == 1U) {
#line 1804
    goto case_1;
  }
#line 1808
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1780
  i = 1L;
  {
#line 1780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1780
    if (! (i <= m_size)) {
#line 1780
      goto while_break;
    }
#line 1780
    *(OV + i) = (m_size - i) + 1L;
#line 1780
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1781
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1784
  i = 1L;
  {
#line 1784
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1784
    if (! (i <= m_size)) {
#line 1784
      goto while_break___0;
    }
#line 1784
    *(OV + i) = i;
#line 1784
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1785
  dd_QuickSort(OV, 1L, m_size, A, d_size);
  }
#line 1786
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1789
  i = 1L;
  {
#line 1789
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1789
    if (! (i <= m_size)) {
#line 1789
      goto while_break___1;
    }
#line 1789
    *(OV + i) = i;
#line 1789
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1790
  dd_QuickSort(OV, 1L, m_size, A, d_size);
#line 1791
  i = 1L;
  }
  {
#line 1791
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1791
    if (! (i <= m_size / 2L)) {
#line 1791
      goto while_break___2;
    }
#line 1792
    itemp = *(OV + i);
#line 1793
    *(OV + i) = *(OV + ((m_size - i) + 1L));
#line 1794
    *(OV + ((m_size - i) + 1L)) = itemp;
#line 1791
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1796
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1799
  i = 1L;
  {
#line 1799
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1799
    if (! (i <= m_size)) {
#line 1799
      goto while_break___3;
    }
#line 1799
    *(OV + i) = i;
#line 1799
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1800
  if (rseed <= 0U) {
#line 1800
    rseed = 1U;
  }
  {
#line 1801
  dd_RandomPermutation2(OV, m_size, rseed);
  }
#line 1802
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1805
  i = 1L;
  {
#line 1805
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1805
    if (! (i <= m_size)) {
#line 1805
      goto while_break___4;
    }
#line 1805
    *(OV + i) = i;
#line 1805
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1806
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1809
  i = 1L;
  {
#line 1809
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1809
    if (! (i <= m_size)) {
#line 1809
      goto while_break___5;
    }
#line 1809
    *(OV + i) = i;
#line 1809
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1810
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1812
  return;
}
}
#line 1814 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_SelectPreorderedNext2(dd_rowrange m_size , dd_colrange d_size , rowset excluded ,
                              dd_rowindex OV , dd_rowrange *hnext ) 
{ 
  dd_rowrange i ;
  dd_rowrange k ;
  int tmp ;

  {
#line 1819
  *hnext = (dd_rowrange )0;
#line 1820
  i = (dd_rowrange )1;
  {
#line 1820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1820
    if (i <= m_size) {
#line 1820
      if (! (*hnext == 0L)) {
#line 1820
        goto while_break;
      }
    } else {
#line 1820
      goto while_break;
    }
    {
#line 1821
    k = *(OV + i);
#line 1822
    tmp = set_member(k, excluded);
    }
#line 1822
    if (! tmp) {
#line 1822
      *hnext = k;
    }
#line 1820
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1824
  return;
}
}
#line 1828 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
ddf_LPObjectiveType Obj2Obj(dd_LPObjectiveType obj ) 
{ 
  ddf_LPObjectiveType objf ;

  {
#line 1830
  objf = (ddf_LPObjectiveType )0;
  {
#line 1833
  if ((unsigned int )obj == 0U) {
#line 1833
    goto case_0;
  }
#line 1834
  if ((unsigned int )obj == 1U) {
#line 1834
    goto case_1;
  }
#line 1835
  if ((unsigned int )obj == 2U) {
#line 1835
    goto case_2;
  }
#line 1832
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1833
  objf = (ddf_LPObjectiveType )0;
#line 1833
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1834
  objf = (ddf_LPObjectiveType )1;
#line 1834
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1835
  objf = (ddf_LPObjectiveType )2;
#line 1835
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1837
  return (objf);
}
}
#line 1840 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
ddf_LPPtr dd_LPgmp2LPf(dd_LPPtr lp ) 
{ 
  dd_rowrange i ;
  dd_colrange j ;
  ddf_LPType *lpf ;
  double val ;
  dd_boolean localdebug ;
  ddf_LPObjectiveType tmp ;
  int tmp___0 ;

  {
#line 1846
  localdebug = 0;
#line 1848
  if (localdebug) {
    {
#line 1848
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Converting a GMP-LP to a float-LP.\n");
    }
  }
  {
#line 1850
  tmp = Obj2Obj(lp->objective);
#line 1850
  lpf = ddf_CreateLPData(tmp, (ddf_NumberType )1, lp->m, lp->d);
#line 1851
  lpf->Homogeneous = lp->Homogeneous;
#line 1852
  lpf->eqnumber = lp->eqnumber;
#line 1854
  i = (dd_rowrange )1;
  }
  {
#line 1854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1854
    if (! (i <= lp->m)) {
#line 1854
      goto while_break;
    }
    {
#line 1855
    tmp___0 = set_member(i, lp->equalityset);
    }
#line 1855
    if (tmp___0) {
      {
#line 1855
      set_addelem(lpf->equalityset, i);
      }
    }
#line 1857
    j = (dd_colrange )1;
    {
#line 1857
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1857
      if (! (j <= lp->d)) {
#line 1857
        goto while_break___0;
      }
      {
#line 1858
      val = __gmpq_get_d((mpq_srcptr )(*(*(lp->A + (i - 1L)) + (j - 1L))));
#line 1859
      dddf_set_d((double *)(*(*(lpf->A + (i - 1L)) + (j - 1L))), val);
#line 1857
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1854
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1863
  return (lpf);
}
}
#line 1870 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_boolean dd_LPSolve(dd_LPPtr lp , dd_LPSolverType solver , dd_ErrorType *err ) 
{ 
  int i ;
  dd_boolean found ;
  ddf_LPPtr lpf ;
  ddf_ErrorType errf ;
  dd_boolean LPScorrect ;
  dd_boolean localdebug ;

  {
#line 1880
  found = 0;
#line 1884
  LPScorrect = 0;
#line 1885
  localdebug = 0;
#line 1886
  if (dd_debug) {
#line 1886
    localdebug = dd_debug;
  }
  {
#line 1889
  *err = (dd_ErrorType )17;
#line 1890
  lp->solver = solver;
#line 1892
  time(& lp->starttime);
#line 1904
  lpf = dd_LPgmp2LPf(lp);
  }
  {
#line 1906
  if ((unsigned int )lp->solver == 0U) {
#line 1906
    goto case_0;
  }
#line 1918
  if ((unsigned int )lp->solver == 1U) {
#line 1918
    goto case_1;
  }
#line 1905
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1907
  ddf_CrissCrossSolve(lpf, & errf);
  }
#line 1908
  if ((unsigned int )errf == 17U) {
    {
#line 1909
    dd_BasisStatus(lpf, lp, & LPScorrect);
    }
  } else {
#line 1910
    LPScorrect = 0;
  }
#line 1911
  if (! LPScorrect) {
#line 1912
    if (localdebug) {
      {
#line 1912
      printf((char const   */* __restrict  */)"BasisStatus: the current basis is NOT verified with GMP. Rerun with GMP.\n");
      }
    }
    {
#line 1913
    dd_CrissCrossSolve(lp, err);
    }
  } else
#line 1915
  if (localdebug) {
    {
#line 1915
    printf((char const   */* __restrict  */)"BasisStatus: the current basis is verified with GMP. The LP Solved.\n");
    }
  }
#line 1917
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1919
  ddf_DualSimplexSolve(lpf, & errf);
  }
#line 1920
  if ((unsigned int )errf == 17U) {
    {
#line 1921
    dd_BasisStatus(lpf, lp, & LPScorrect);
    }
  } else {
#line 1922
    LPScorrect = 0;
  }
#line 1923
  if (! LPScorrect) {
#line 1924
    if (localdebug) {
      {
#line 1924
      printf((char const   */* __restrict  */)"BasisStatus: the current basis is NOT verified with GMP. Rerun with GMP.\n");
      }
    }
    {
#line 1925
    dd_DualSimplexSolve(lp, err);
    }
#line 1926
    if (localdebug) {
      {
#line 1927
      printf((char const   */* __restrict  */)"*total number pivots = %ld (ph0 = %ld, ph1 = %ld, ph2 = %ld, ph3 = %ld, ph4 = %ld)\n",
             lp->total_pivots, lp->pivots[0], lp->pivots[1], lp->pivots[2], lp->pivots[3],
             lp->pivots[4]);
#line 1929
      ddf_WriteLPResult(stdout, lpf, errf);
#line 1930
      dd_WriteLP(stdout, lp);
      }
    }
  } else
#line 1933
  if (localdebug) {
    {
#line 1933
    printf((char const   */* __restrict  */)"BasisStatus: the current basis is verified with GMP. The LP Solved.\n");
    }
  }
#line 1935
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1937
  ddf_FreeLPData(lpf);
#line 1940
  time(& lp->endtime);
#line 1941
  lp->total_pivots = 0L;
#line 1942
  i = 0;
  }
  {
#line 1942
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1942
    if (! (i <= 4)) {
#line 1942
      goto while_break;
    }
#line 1942
    lp->total_pivots += lp->pivots[i];
#line 1942
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1943
  if ((unsigned int )*err == 17U) {
#line 1943
    found = 1;
  }
#line 1944
  return (found);
}
}
#line 1948 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_boolean dd_LPSolve0(dd_LPPtr lp , dd_LPSolverType solver , dd_ErrorType *err ) 
{ 
  int i ;
  dd_boolean found ;

  {
  {
#line 1957
  found = 0;
#line 1959
  *err = (dd_ErrorType )17;
#line 1960
  lp->solver = solver;
#line 1961
  time(& lp->starttime);
  }
  {
#line 1964
  if ((unsigned int )lp->solver == 0U) {
#line 1964
    goto case_0;
  }
#line 1967
  if ((unsigned int )lp->solver == 1U) {
#line 1967
    goto case_1;
  }
#line 1963
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1965
  dd_CrissCrossSolve(lp, err);
  }
#line 1966
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1968
  dd_DualSimplexSolve(lp, err);
  }
#line 1969
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1972
  time(& lp->endtime);
#line 1973
  lp->total_pivots = 0L;
#line 1974
  i = 0;
  }
  {
#line 1974
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1974
    if (! (i <= 4)) {
#line 1974
      goto while_break;
    }
#line 1974
    lp->total_pivots += lp->pivots[i];
#line 1974
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1975
  if ((unsigned int )*err == 17U) {
#line 1975
    found = 1;
  }
#line 1976
  return (found);
}
}
#line 1980 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_LPPtr dd_MakeLPforInteriorFinding(dd_LPPtr lp ) 
{ 
  dd_rowrange m ;
  dd_colrange d ;
  dd_NumberType numbtype ;
  dd_LPObjectiveType obj ;
  dd_LPType *lpnew ;
  dd_rowrange i ;
  dd_colrange j ;
  mytype bm ;
  mytype bmax ;
  mytype bceil ;
  int localdebug ;
  dd_boolean tmp ;

  {
  {
#line 2002
  localdebug = 0;
#line 2004
  __gmpq_init(bm);
#line 2004
  __gmpq_init(bmax);
#line 2004
  __gmpq_init(bceil);
#line 2005
  __gmpq_add(bm, (mpq_srcptr )(dd_one), (mpq_srcptr )(dd_one));
#line 2005
  __gmpq_set(bmax, (mpq_srcptr )(dd_one));
#line 2006
  numbtype = lp->numbtype;
#line 2007
  m = lp->m + 1L;
#line 2008
  d = lp->d + 1L;
#line 2009
  obj = (dd_LPObjectiveType )1;
#line 2011
  lpnew = dd_CreateLPData(obj, numbtype, m, d);
#line 2013
  i = (dd_rowrange )1;
  }
  {
#line 2013
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2013
    if (! (i <= lp->m)) {
#line 2013
      goto while_break;
    }
    {
#line 2014
    tmp = dd_Larger((__mpq_struct *)(*(*(lp->A + (i - 1L)) + (lp->rhscol - 1L))),
                    (__mpq_struct *)(bmax));
    }
#line 2014
    if (tmp) {
      {
#line 2015
      __gmpq_set(bmax, (mpq_srcptr )(*(*(lp->A + (i - 1L)) + (lp->rhscol - 1L))));
      }
    }
#line 2013
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2017
  __gmpq_mul(bceil, (mpq_srcptr )(bm), (mpq_srcptr )(bmax));
  }
#line 2018
  if (localdebug) {
    {
#line 2018
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bceil is set to ");
#line 2018
    dd_WriteNumber(stderr, (__mpq_struct *)(bceil));
    }
  }
#line 2020
  i = (dd_rowrange )1;
  {
#line 2020
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2020
    if (! (i <= lp->m)) {
#line 2020
      goto while_break___0;
    }
#line 2021
    j = (dd_colrange )1;
    {
#line 2021
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2021
      if (! (j <= lp->d)) {
#line 2021
        goto while_break___1;
      }
      {
#line 2022
      __gmpq_set(*(*(lpnew->A + (i - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(lp->A + (i - 1L)) + (j - 1L))));
#line 2021
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2020
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2026
  i = (dd_rowrange )1;
  {
#line 2026
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2026
    if (! (i <= lp->m)) {
#line 2026
      goto while_break___2;
    }
    {
#line 2027
    __gmpq_neg(*(*(lpnew->A + (i - 1L)) + lp->d), (mpq_srcptr )(dd_one));
#line 2026
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2030
  j = (dd_colrange )1;
  {
#line 2030
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2030
    if (! (j <= lp->d)) {
#line 2030
      goto while_break___3;
    }
    {
#line 2031
    __gmpq_set(*(*(lpnew->A + (m - 2L)) + (j - 1L)), (mpq_srcptr )(dd_purezero));
#line 2030
    j ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2033
  __gmpq_set(*(*(lpnew->A + (m - 2L)) + 0), (mpq_srcptr )(bceil));
#line 2035
  j = (dd_colrange )1;
  }
  {
#line 2035
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2035
    if (! (j <= d - 1L)) {
#line 2035
      goto while_break___4;
    }
    {
#line 2036
    __gmpq_set(*(*(lpnew->A + (m - 1L)) + (j - 1L)), (mpq_srcptr )(dd_purezero));
#line 2035
    j ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 2038
  __gmpq_set(*(*(lpnew->A + (m - 1L)) + (d - 1L)), (mpq_srcptr )(dd_one));
  }
#line 2040
  if (localdebug) {
    {
#line 2040
    dd_WriteAmatrix(stderr, lp->A, lp->m, lp->d);
    }
  }
#line 2041
  if (localdebug) {
    {
#line 2041
    dd_WriteAmatrix(stderr, lpnew->A, lpnew->m, lpnew->d);
    }
  }
  {
#line 2042
  __gmpq_clear(bm);
#line 2042
  __gmpq_clear(bmax);
#line 2042
  __gmpq_clear(bceil);
  }
#line 2044
  return (lpnew);
}
}
#line 2048 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_WriteLPResult(FILE *f , dd_LPPtr lp , dd_ErrorType err ) 
{ 
  long j ;
  dd_boolean tmp ;

  {
  {
#line 2052
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* cdd LP solver result\n");
  }
#line 2054
  if ((unsigned int )err != 17U) {
    {
#line 2055
    dd_WriteErrorMessages(f, err);
    }
#line 2056
    goto _L99;
  }
  {
#line 2059
  dd_WriteProgramDescription(f);
#line 2061
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* #constraints = %ld\n",
          lp->m - 1L);
#line 2062
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* #variables   = %ld\n",
          lp->d - 1L);
  }
  {
#line 2065
  if ((unsigned int )lp->solver == 1U) {
#line 2065
    goto case_1;
  }
#line 2067
  if ((unsigned int )lp->solver == 0U) {
#line 2067
    goto case_0;
  }
#line 2064
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2066
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Algorithm: dual simplex algorithm\n");
  }
#line 2066
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 2068
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Algorithm: criss-cross method\n");
  }
#line 2068
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2072
  if ((unsigned int )lp->objective == 1U) {
#line 2072
    goto case_1___0;
  }
#line 2074
  if ((unsigned int )lp->objective == 2U) {
#line 2074
    goto case_2;
  }
#line 2076
  if ((unsigned int )lp->objective == 0U) {
#line 2076
    goto case_0___0;
  }
#line 2071
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 2073
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* maximization is chosen\n");
  }
#line 2073
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 2075
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* minimization is chosen\n");
  }
#line 2075
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 2077
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* no objective type (max or min) is chosen\n");
  }
#line 2077
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2080
  if ((unsigned int )lp->objective == 1U) {
#line 2080
    goto _L;
  } else
#line 2080
  if ((unsigned int )lp->objective == 2U) {
    _L: /* CIL Label */ 
    {
#line 2081
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Objective function is\n");
#line 2082
    j = 0L;
    }
    {
#line 2082
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2082
      if (! (j < lp->d)) {
#line 2082
        goto while_break;
      }
#line 2083
      if (j > 0L) {
        {
#line 2083
        tmp = dd_Nonnegative((__mpq_struct *)(*(*(lp->A + (lp->objrow - 1L)) + j)));
        }
#line 2083
        if (tmp) {
          {
#line 2083
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" +");
          }
        }
      }
#line 2084
      if (j > 0L) {
#line 2084
        if (j % 5L == 0L) {
          {
#line 2084
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
          }
        }
      }
      {
#line 2085
      dd_WriteNumber(f, (__mpq_struct *)(*(*(lp->A + (lp->objrow - 1L)) + j)));
      }
#line 2086
      if (j > 0L) {
        {
#line 2086
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" X[%3ld]",
                j);
        }
      }
#line 2082
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2088
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 2092
  if ((unsigned int )lp->LPS == 1U) {
#line 2092
    goto case_1___1;
  }
#line 2112
  if ((unsigned int )lp->LPS == 2U) {
#line 2112
    goto case_2___0;
  }
#line 2129
  if ((unsigned int )lp->LPS == 5U) {
#line 2129
    goto case_5;
  }
#line 2129
  if ((unsigned int )lp->LPS == 3U) {
#line 2129
    goto case_5;
  }
#line 2144
  goto switch_default;
  case_1___1: /* CIL Label */ 
  {
#line 2093
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* LP status: a dual pair (x,y) of optimal solutions found.\n");
#line 2094
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"begin\n");
#line 2095
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  primal_solution\n");
#line 2096
  j = 1L;
  }
  {
#line 2096
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2096
    if (! (j < lp->d)) {
#line 2096
      goto while_break___0;
    }
    {
#line 2097
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %3ld : ",
            j);
#line 2098
    dd_WriteNumber(f, (__mpq_struct *)(*(lp->sol + j)));
#line 2099
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 2096
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2101
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  dual_solution\n");
#line 2102
  j = 1L;
  }
  {
#line 2102
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2102
    if (! (j < lp->d)) {
#line 2102
      goto while_break___1;
    }
#line 2103
    if (*(lp->nbindex + (j + 1L)) > 0L) {
      {
#line 2104
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %3ld : ",
              *(lp->nbindex + (j + 1L)));
#line 2105
      dd_WriteNumber(f, (__mpq_struct *)(*(lp->dsol + j)));
#line 2105
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
      }
    }
#line 2102
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2108
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  optimal_value : ");
#line 2108
  dd_WriteNumber(f, (__mpq_struct *)(lp->optvalue));
#line 2109
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\nend\n");
  }
#line 2110
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  {
#line 2113
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* LP status: LP is inconsistent.\n");
#line 2114
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* The positive combination of original inequalities with\n");
#line 2115
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* the following coefficients will prove the inconsistency.\n");
#line 2116
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"begin\n");
#line 2117
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  dual_direction\n");
#line 2118
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %3ld : ",
          lp->re);
#line 2119
  dd_WriteNumber(f, (__mpq_struct *)(dd_one));
#line 2119
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 2120
  j = 1L;
  }
  {
#line 2120
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2120
    if (! (j < lp->d)) {
#line 2120
      goto while_break___2;
    }
#line 2121
    if (*(lp->nbindex + (j + 1L)) > 0L) {
      {
#line 2122
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %3ld : ",
              *(lp->nbindex + (j + 1L)));
#line 2123
      dd_WriteNumber(f, (__mpq_struct *)(*(lp->dsol + j)));
#line 2123
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
      }
    }
#line 2120
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2126
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
  }
#line 2127
  goto switch_break___1;
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 2130
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* LP status: LP is dual inconsistent.\n");
#line 2131
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* The linear combination of columns with\n");
#line 2132
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* the following coefficients will prove the dual inconsistency.\n");
#line 2133
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* (It is also an unbounded direction for the primal LP.)\n");
#line 2134
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"begin\n");
#line 2135
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  primal_direction\n");
#line 2136
  j = 1L;
  }
  {
#line 2136
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2136
    if (! (j < lp->d)) {
#line 2136
      goto while_break___3;
    }
    {
#line 2137
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %3ld : ",
            j);
#line 2138
    dd_WriteNumber(f, (__mpq_struct *)(*(lp->sol + j)));
#line 2139
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 2136
    j ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2141
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
  }
#line 2142
  goto switch_break___1;
  switch_default: /* CIL Label */ 
#line 2145
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 2147
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* number of pivot operations = %ld (ph0 = %ld, ph1 = %ld, ph2 = %ld, ph3 = %ld, ph4 = %ld)\n",
          lp->total_pivots, lp->pivots[0], lp->pivots[1], lp->pivots[2], lp->pivots[3],
          lp->pivots[4]);
#line 2148
  dd_WriteLPTimes(f, lp);
  }
  _L99: ;
#line 2150
  return;
}
}
#line 2152 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_LPPtr dd_CreateLP_H_ImplicitLinearity(dd_MatrixPtr M ) 
{ 
  dd_rowrange m ;
  dd_rowrange i ;
  dd_rowrange irev ;
  dd_rowrange linc ;
  dd_colrange d ;
  dd_colrange j ;
  dd_LPPtr lp ;
  dd_boolean localdebug ;
  int tmp ;
  dd_boolean tmp___0 ;

  {
  {
#line 2157
  localdebug = 0;
#line 2159
  linc = set_card(M->linset);
#line 2160
  m = ((M->rowsize + 1L) + linc) + 1L;
#line 2163
  d = M->colsize + 1L;
#line 2165
  lp = dd_CreateLPData(M->objective, M->numbtype, m, d);
#line 2166
  lp->Homogeneous = 1;
#line 2167
  lp->objective = (dd_LPObjectiveType )1;
#line 2168
  lp->eqnumber = linc;
#line 2169
  lp->redcheck_extensive = 0;
#line 2171
  irev = M->rowsize;
#line 2172
  i = (dd_rowrange )1;
  }
  {
#line 2172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2172
    if (! (i <= M->rowsize)) {
#line 2172
      goto while_break;
    }
    {
#line 2173
    tmp = set_member(i, M->linset);
    }
#line 2173
    if (tmp) {
      {
#line 2174
      irev ++;
#line 2175
      set_addelem(lp->equalityset, i);
#line 2177
      j = (dd_colrange )1;
      }
      {
#line 2177
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2177
        if (! (j <= M->colsize)) {
#line 2177
          goto while_break___0;
        }
        {
#line 2178
        __gmpq_neg(*(*(lp->A + (irev - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 1L))));
#line 2177
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 2181
      __gmpq_set(*(*(lp->A + (i - 1L)) + (d - 1L)), (mpq_srcptr )(dd_minusone));
      }
    }
#line 2183
    j = (dd_colrange )1;
    {
#line 2183
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2183
      if (! (j <= M->colsize)) {
#line 2183
        goto while_break___1;
      }
      {
#line 2184
      __gmpq_set(*(*(lp->A + (i - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 1L))));
      }
#line 2185
      if (j == 1L) {
#line 2185
        if (i < M->rowsize) {
          {
#line 2185
          tmp___0 = dd_Nonzero((__mpq_struct *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
          }
#line 2185
          if (tmp___0) {
#line 2185
            lp->Homogeneous = 0;
          }
        }
      }
#line 2183
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2172
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2188
  __gmpq_set(*(*(lp->A + (m - 2L)) + 0), (mpq_srcptr )(dd_one));
#line 2188
  __gmpq_set(*(*(lp->A + (m - 2L)) + (d - 1L)), (mpq_srcptr )(dd_minusone));
#line 2191
  __gmpq_set(*(*(lp->A + (m - 1L)) + (d - 1L)), (mpq_srcptr )(dd_one));
  }
#line 2194
  if (localdebug) {
    {
#line 2195
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_CreateLP_H_ImplicitLinearity: an new lp is\n");
#line 2196
    dd_WriteLP(stderr, lp);
    }
  }
#line 2199
  return (lp);
}
}
#line 2202 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_LPPtr dd_CreateLP_V_ImplicitLinearity(dd_MatrixPtr M ) 
{ 
  dd_rowrange m ;
  dd_rowrange i ;
  dd_rowrange irev ;
  dd_rowrange linc ;
  dd_colrange d ;
  dd_colrange j ;
  dd_LPPtr lp ;
  dd_boolean localdebug ;
  int tmp ;

  {
  {
#line 2207
  localdebug = 0;
#line 2209
  linc = set_card(M->linset);
#line 2210
  m = ((M->rowsize + 1L) + linc) + 1L;
#line 2213
  d = M->colsize + 2L;
#line 2218
  lp = dd_CreateLPData(M->objective, M->numbtype, m, d);
#line 2219
  lp->Homogeneous = 0;
#line 2220
  lp->objective = (dd_LPObjectiveType )1;
#line 2221
  lp->eqnumber = linc;
#line 2222
  lp->redcheck_extensive = 0;
#line 2224
  irev = M->rowsize;
#line 2225
  i = (dd_rowrange )1;
  }
  {
#line 2225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2225
    if (! (i <= M->rowsize)) {
#line 2225
      goto while_break;
    }
    {
#line 2226
    __gmpq_set(*(*(lp->A + (i - 1L)) + 0), (mpq_srcptr )(dd_purezero));
#line 2227
    tmp = set_member(i, M->linset);
    }
#line 2227
    if (tmp) {
      {
#line 2228
      irev ++;
#line 2229
      set_addelem(lp->equalityset, i);
#line 2231
      j = (dd_colrange )2;
      }
      {
#line 2231
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2231
        if (! (j <= M->colsize + 1L)) {
#line 2231
          goto while_break___0;
        }
        {
#line 2232
        __gmpq_neg(*(*(lp->A + (irev - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 2L))));
#line 2231
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2234
      if (localdebug) {
        {
#line 2234
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"equality row %ld generates the reverse row %ld.\n",
                i, irev);
        }
      }
    } else {
      {
#line 2236
      __gmpq_set(*(*(lp->A + (i - 1L)) + (d - 1L)), (mpq_srcptr )(dd_minusone));
      }
    }
#line 2238
    j = (dd_colrange )2;
    {
#line 2238
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2238
      if (! (j <= M->colsize + 1L)) {
#line 2238
        goto while_break___1;
      }
      {
#line 2239
      __gmpq_set(*(*(lp->A + (i - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 2L))));
#line 2238
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2225
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2242
  __gmpq_set(*(*(lp->A + (m - 2L)) + 0), (mpq_srcptr )(dd_one));
#line 2242
  __gmpq_set(*(*(lp->A + (m - 2L)) + (d - 1L)), (mpq_srcptr )(dd_minusone));
#line 2244
  __gmpq_set(*(*(lp->A + (m - 1L)) + (d - 1L)), (mpq_srcptr )(dd_one));
  }
#line 2247
  if (localdebug) {
    {
#line 2248
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_CreateLP_V_ImplicitLinearity: an new lp is\n");
#line 2249
    dd_WriteLP(stderr, lp);
    }
  }
#line 2252
  return (lp);
}
}
#line 2256 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_LPPtr dd_CreateLP_H_Redundancy(dd_MatrixPtr M , dd_rowrange itest ) 
{ 
  dd_rowrange m ;
  dd_rowrange i ;
  dd_rowrange irev ;
  dd_rowrange linc ;
  dd_colrange d ;
  dd_colrange j ;
  dd_LPPtr lp ;
  dd_boolean localdebug ;
  int tmp ;
  dd_boolean tmp___0 ;

  {
  {
#line 2261
  localdebug = 0;
#line 2263
  linc = set_card(M->linset);
#line 2264
  m = (M->rowsize + 1L) + linc;
#line 2267
  d = M->colsize;
#line 2269
  lp = dd_CreateLPData(M->objective, M->numbtype, m, d);
#line 2270
  lp->Homogeneous = 1;
#line 2271
  lp->objective = (dd_LPObjectiveType )2;
#line 2272
  lp->eqnumber = linc;
#line 2273
  lp->redcheck_extensive = 0;
#line 2275
  irev = M->rowsize;
#line 2276
  i = (dd_rowrange )1;
  }
  {
#line 2276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2276
    if (! (i <= M->rowsize)) {
#line 2276
      goto while_break;
    }
    {
#line 2277
    tmp = set_member(i, M->linset);
    }
#line 2277
    if (tmp) {
      {
#line 2278
      irev ++;
#line 2279
      set_addelem(lp->equalityset, i);
#line 2281
      j = (dd_colrange )1;
      }
      {
#line 2281
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2281
        if (! (j <= M->colsize)) {
#line 2281
          goto while_break___0;
        }
        {
#line 2282
        __gmpq_neg(*(*(lp->A + (irev - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 1L))));
#line 2281
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2284
      if (localdebug) {
        {
#line 2284
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"equality row %ld generates the reverse row %ld.\n",
                i, irev);
        }
      }
    }
#line 2286
    j = (dd_colrange )1;
    {
#line 2286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2286
      if (! (j <= M->colsize)) {
#line 2286
        goto while_break___1;
      }
      {
#line 2287
      __gmpq_set(*(*(lp->A + (i - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 1L))));
      }
#line 2288
      if (j == 1L) {
#line 2288
        if (i < M->rowsize) {
          {
#line 2288
          tmp___0 = dd_Nonzero((__mpq_struct *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
          }
#line 2288
          if (tmp___0) {
#line 2288
            lp->Homogeneous = 0;
          }
        }
      }
#line 2286
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2276
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2291
  j = (dd_colrange )1;
  {
#line 2291
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2291
    if (! (j <= M->colsize)) {
#line 2291
      goto while_break___2;
    }
    {
#line 2292
    __gmpq_set(*(*(lp->A + (m - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (itest - 1L)) + (j - 1L))));
#line 2291
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2295
  __gmpq_add(*(*(lp->A + (itest - 1L)) + 0), (mpq_srcptr )(*(*(lp->A + (itest - 1L)) + 0)),
             (mpq_srcptr )(dd_one));
  }
#line 2297
  return (lp);
}
}
#line 2301 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_LPPtr dd_CreateLP_V_Redundancy(dd_MatrixPtr M , dd_rowrange itest ) 
{ 
  dd_rowrange m ;
  dd_rowrange i ;
  dd_rowrange irev ;
  dd_rowrange linc ;
  dd_colrange d ;
  dd_colrange j ;
  dd_LPPtr lp ;
  dd_boolean localdebug ;
  int tmp ;

  {
  {
#line 2306
  localdebug = 0;
#line 2308
  linc = set_card(M->linset);
#line 2309
  m = (M->rowsize + 1L) + linc;
#line 2312
  d = M->colsize + 1L;
#line 2317
  lp = dd_CreateLPData(M->objective, M->numbtype, m, d);
#line 2318
  lp->Homogeneous = 0;
#line 2319
  lp->objective = (dd_LPObjectiveType )2;
#line 2320
  lp->eqnumber = linc;
#line 2321
  lp->redcheck_extensive = 0;
#line 2323
  irev = M->rowsize;
#line 2324
  i = (dd_rowrange )1;
  }
  {
#line 2324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2324
    if (! (i <= M->rowsize)) {
#line 2324
      goto while_break;
    }
#line 2325
    if (i == itest) {
      {
#line 2326
      __gmpq_set(*(*(lp->A + (i - 1L)) + 0), (mpq_srcptr )(dd_one));
      }
    } else {
      {
#line 2328
      __gmpq_set(*(*(lp->A + (i - 1L)) + 0), (mpq_srcptr )(dd_purezero));
      }
    }
    {
#line 2330
    tmp = set_member(i, M->linset);
    }
#line 2330
    if (tmp) {
      {
#line 2331
      irev ++;
#line 2332
      set_addelem(lp->equalityset, i);
#line 2334
      j = (dd_colrange )2;
      }
      {
#line 2334
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2334
        if (! (j <= M->colsize + 1L)) {
#line 2334
          goto while_break___0;
        }
        {
#line 2335
        __gmpq_neg(*(*(lp->A + (irev - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 2L))));
#line 2334
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2337
      if (localdebug) {
        {
#line 2337
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"equality row %ld generates the reverse row %ld.\n",
                i, irev);
        }
      }
    }
#line 2339
    j = (dd_colrange )2;
    {
#line 2339
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2339
      if (! (j <= M->colsize + 1L)) {
#line 2339
        goto while_break___1;
      }
      {
#line 2340
      __gmpq_set(*(*(lp->A + (i - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 2L))));
#line 2339
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2324
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2343
  j = (dd_colrange )2;
  {
#line 2343
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2343
    if (! (j <= M->colsize + 1L)) {
#line 2343
      goto while_break___2;
    }
    {
#line 2344
    __gmpq_set(*(*(lp->A + (m - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (itest - 1L)) + (j - 2L))));
#line 2343
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2347
  __gmpq_set(*(*(lp->A + (m - 1L)) + 0), (mpq_srcptr )(dd_purezero));
  }
#line 2349
  if (localdebug) {
    {
#line 2349
    dd_WriteLP(stdout, lp);
    }
  }
#line 2351
  return (lp);
}
}
#line 2355 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_LPPtr dd_CreateLP_V_SRedundancy(dd_MatrixPtr M , dd_rowrange itest ) 
{ 
  dd_rowrange m ;
  dd_rowrange i ;
  dd_rowrange irev ;
  dd_rowrange linc ;
  dd_colrange d ;
  dd_colrange j ;
  dd_LPPtr lp ;
  dd_boolean localdebug ;
  int tmp ;

  {
  {
#line 2373
  localdebug = 0;
#line 2375
  linc = set_card(M->linset);
#line 2376
  m = ((M->rowsize + 1L) + linc) + 2L;
#line 2381
  d = M->colsize + 1L;
#line 2386
  lp = dd_CreateLPData(M->objective, M->numbtype, m, d);
#line 2387
  lp->Homogeneous = 0;
#line 2388
  lp->objective = (dd_LPObjectiveType )1;
#line 2389
  lp->eqnumber = linc;
#line 2391
  irev = M->rowsize;
#line 2392
  i = (dd_rowrange )1;
  }
  {
#line 2392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2392
    if (! (i <= M->rowsize)) {
#line 2392
      goto while_break;
    }
#line 2393
    if (i == itest) {
      {
#line 2394
      __gmpq_set(*(*(lp->A + (i - 1L)) + 0), (mpq_srcptr )(dd_purezero));
      }
    } else {
      {
#line 2396
      __gmpq_set(*(*(lp->A + (i - 1L)) + 0), (mpq_srcptr )(dd_purezero));
      }
    }
    {
#line 2398
    tmp = set_member(i, M->linset);
    }
#line 2398
    if (tmp) {
#line 2398
      goto _L;
    } else
#line 2398
    if (i == itest) {
      _L: /* CIL Label */ 
      {
#line 2399
      irev ++;
#line 2400
      set_addelem(lp->equalityset, i);
#line 2402
      j = (dd_colrange )2;
      }
      {
#line 2402
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2402
        if (! (j <= M->colsize + 1L)) {
#line 2402
          goto while_break___0;
        }
        {
#line 2403
        __gmpq_neg(*(*(lp->A + (irev - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 2L))));
#line 2402
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2405
      if (localdebug) {
        {
#line 2405
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"equality row %ld generates the reverse row %ld.\n",
                i, irev);
        }
      }
    }
#line 2407
    j = (dd_colrange )2;
    {
#line 2407
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2407
      if (! (j <= M->colsize + 1L)) {
#line 2407
        goto while_break___1;
      }
      {
#line 2408
      __gmpq_set(*(*(lp->A + (i - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 2L))));
#line 2409
      __gmpq_add(*(*(lp->A + (m - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(lp->A + (m - 1L)) + (j - 1L))),
                 (mpq_srcptr )(*(*(lp->A + (i - 1L)) + (j - 1L))));
#line 2407
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2392
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2412
  j = (dd_colrange )2;
  {
#line 2412
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2412
    if (! (j <= M->colsize + 1L)) {
#line 2412
      goto while_break___2;
    }
    {
#line 2413
    __gmpq_neg(*(*(lp->A + (m - 2L)) + (j - 1L)), (mpq_srcptr )(*(*(lp->A + (m - 1L)) + (j - 1L))));
#line 2412
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2416
  __gmpq_set(*(*(lp->A + (m - 2L)) + 0), (mpq_srcptr )(dd_one));
  }
#line 2418
  if (localdebug) {
    {
#line 2418
    dd_WriteLP(stdout, lp);
    }
  }
#line 2420
  return (lp);
}
}
#line 2423 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_boolean dd_Redundant(dd_MatrixPtr M , dd_rowrange itest , dd_Arow certificate ,
                        dd_ErrorType *error ) 
{ 
  dd_colrange j ;
  dd_LPPtr lp ;
  dd_LPSolutionPtr lps ;
  dd_ErrorType err ;
  dd_boolean answer ;
  dd_boolean localdebug ;
  int tmp ;
  dd_boolean tmp___0 ;

  {
  {
#line 2458
  err = (dd_ErrorType )17;
#line 2459
  answer = 0;
#line 2459
  localdebug = 0;
#line 2461
  *error = (dd_ErrorType )17;
#line 2462
  tmp = set_member(itest, M->linset);
  }
#line 2462
  if (tmp) {
#line 2463
    if (localdebug) {
      {
#line 2463
      printf((char const   */* __restrict  */)"The %ld th row is linearity and redundancy checking is skipped.\n",
             itest);
      }
    }
#line 2464
    goto _L99;
  }
#line 2468
  if ((unsigned int )M->representation == 2U) {
    {
#line 2469
    lp = dd_CreateLP_V_Redundancy(M, itest);
    }
  } else {
    {
#line 2471
    lp = dd_CreateLP_H_Redundancy(M, itest);
    }
  }
  {
#line 2474
  dd_LPSolve(lp, dd_choiceRedcheckAlgorithm, & err);
  }
#line 2475
  if ((unsigned int )err != 17U) {
#line 2476
    *error = err;
#line 2477
    goto _L999;
  } else {
    {
#line 2479
    lps = dd_CopyLPSolution(lp);
#line 2481
    j = (dd_colrange )0;
    }
    {
#line 2481
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2481
      if (! (j < lps->d)) {
#line 2481
        goto while_break;
      }
      {
#line 2482
      __gmpq_set(*(certificate + j), (mpq_srcptr )(*(lps->sol + j)));
#line 2481
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2485
    tmp___0 = dd_Negative((__mpq_struct *)(lps->optvalue));
    }
#line 2485
    if (tmp___0) {
#line 2486
      answer = 0;
#line 2487
      if (localdebug) {
        {
#line 2487
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th row is nonredundant.\n",
                itest);
        }
      }
    } else {
#line 2489
      answer = 1;
#line 2490
      if (localdebug) {
        {
#line 2490
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th row is redundant.\n",
                itest);
        }
      }
    }
    {
#line 2492
    dd_FreeLPSolution(lps);
    }
  }
  _L999: 
  {
#line 2495
  dd_FreeLPData(lp);
  }
  _L99: 
#line 2497
  return (answer);
}
}
#line 2500 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_boolean dd_RedundantExtensive(dd_MatrixPtr M , dd_rowrange itest , dd_Arow certificate ,
                                 dd_rowset *redset , dd_ErrorType *error ) 
{ 
  dd_colrange j ;
  dd_LPPtr lp ;
  dd_LPSolutionPtr lps ;
  dd_ErrorType err ;
  dd_boolean answer ;
  dd_boolean localdebug ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  dd_boolean tmp___2 ;

  {
  {
#line 2514
  err = (dd_ErrorType )17;
#line 2515
  answer = 0;
#line 2515
  localdebug = 0;
#line 2517
  *error = (dd_ErrorType )17;
#line 2518
  tmp = set_member(itest, M->linset);
  }
#line 2518
  if (tmp) {
#line 2519
    if (localdebug) {
      {
#line 2519
      printf((char const   */* __restrict  */)"The %ld th row is linearity and redundancy checking is skipped.\n",
             itest);
      }
    }
#line 2520
    goto _L99;
  }
#line 2524
  if ((unsigned int )M->representation == 2U) {
    {
#line 2525
    lp = dd_CreateLP_V_Redundancy(M, itest);
    }
  } else {
    {
#line 2527
    lp = dd_CreateLP_H_Redundancy(M, itest);
    }
  }
  {
#line 2530
  lp->redcheck_extensive = 1;
#line 2532
  dd_LPSolve0(lp, (dd_LPSolverType )1, & err);
  }
#line 2533
  if ((unsigned int )err != 17U) {
#line 2534
    *error = err;
#line 2535
    goto _L999;
  } else {
    {
#line 2537
    set_copy(*redset, lp->redset_extra);
#line 2538
    set_delelem(*redset, itest);
    }
#line 2541
    if (localdebug) {
      {
#line 2542
      tmp___0 = set_card(lp->redset_extra);
#line 2542
      tmp___1 = set_card(*redset);
#line 2542
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_RedundantExtensive: checking for %ld, extra redset with cardinality %ld (%ld)\n",
              itest, tmp___1, tmp___0);
#line 2543
      set_fwrite(stderr, *redset);
#line 2543
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
    {
#line 2545
    lps = dd_CopyLPSolution(lp);
#line 2547
    j = (dd_colrange )0;
    }
    {
#line 2547
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2547
      if (! (j < lps->d)) {
#line 2547
        goto while_break;
      }
      {
#line 2548
      __gmpq_set(*(certificate + j), (mpq_srcptr )(*(lps->sol + j)));
#line 2547
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2551
    tmp___2 = dd_Negative((__mpq_struct *)(lps->optvalue));
    }
#line 2551
    if (tmp___2) {
#line 2552
      answer = 0;
#line 2553
      if (localdebug) {
        {
#line 2553
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th row is nonredundant.\n",
                itest);
        }
      }
    } else {
#line 2555
      answer = 1;
#line 2556
      if (localdebug) {
        {
#line 2556
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th row is redundant.\n",
                itest);
        }
      }
    }
    {
#line 2558
    dd_FreeLPSolution(lps);
    }
  }
  _L999: 
  {
#line 2561
  dd_FreeLPData(lp);
  }
  _L99: 
#line 2563
  return (answer);
}
}
#line 2566 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_rowset dd_RedundantRows(dd_MatrixPtr M , dd_ErrorType *error ) 
{ 
  dd_rowrange i ;
  dd_rowrange m ;
  dd_colrange d ;
  dd_rowset redset ;
  dd_MatrixPtr Mcopy ;
  dd_Arow cvec ;
  dd_boolean localdebug ;
  dd_boolean tmp ;

  {
#line 2573
  localdebug = 0;
#line 2575
  m = M->rowsize;
#line 2576
  if ((unsigned int )M->representation == 2U) {
#line 2577
    d = M->colsize + 1L;
  } else {
#line 2579
    d = M->colsize;
  }
  {
#line 2581
  Mcopy = dd_MatrixCopy(M);
#line 2582
  dd_InitializeArow(d, & cvec);
#line 2583
  set_initialize(& redset, m);
#line 2584
  i = m;
  }
  {
#line 2584
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2584
    if (! (i >= 1L)) {
#line 2584
      goto while_break;
    }
    {
#line 2585
    tmp = dd_Redundant(Mcopy, i, cvec, error);
    }
#line 2585
    if (tmp) {
#line 2586
      if (localdebug) {
        {
#line 2586
        printf((char const   */* __restrict  */)"dd_RedundantRows: the row %ld is redundant.\n",
               i);
        }
      }
      {
#line 2587
      set_addelem(redset, i);
#line 2588
      dd_MatrixRowRemove(& Mcopy, i);
      }
    } else
#line 2590
    if (localdebug) {
      {
#line 2590
      printf((char const   */* __restrict  */)"dd_RedundantRows: the row %ld is essential.\n",
             i);
      }
    }
#line 2592
    if ((unsigned int )*error != 17U) {
#line 2592
      goto _L99;
    }
#line 2584
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: 
  {
#line 2595
  dd_FreeMatrix(Mcopy);
#line 2596
  dd_FreeArow(d, cvec);
  }
#line 2597
  return (redset);
}
}
#line 2601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_boolean dd_MatrixRedundancyRemove(dd_MatrixPtr *M , dd_rowset *redset , dd_rowindex *newpos ,
                                     dd_ErrorType *error ) 
{ 
  dd_rowrange i ;
  dd_rowrange k ;
  dd_rowrange m ;
  dd_rowrange m1 ;
  dd_colrange d ;
  dd_rowset redset1 ;
  dd_rowindex newpos1 ;
  dd_MatrixPtr M1 ;
  dd_Arow cvec ;
  dd_boolean success ;
  dd_boolean localdebug ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  dd_boolean tmp___2 ;

  {
  {
#line 2612
  M1 = (dd_MatrixPtr )((void *)0);
#line 2614
  success = 0;
#line 2614
  localdebug = 0;
#line 2616
  m = (*M)->rowsize;
#line 2617
  set_initialize(redset, m);
#line 2618
  M1 = dd_MatrixSortedUniqueCopy(*M, newpos);
#line 2619
  i = (dd_rowrange )1;
  }
  {
#line 2619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2619
    if (! (i <= m)) {
#line 2619
      goto while_break;
    }
#line 2620
    if (*(*newpos + i) <= 0L) {
      {
#line 2620
      set_addelem(*redset, i);
      }
    }
#line 2621
    if (localdebug) {
      {
#line 2621
      printf((char const   */* __restrict  */)" %ld:%ld", i, *(*newpos + i));
      }
    }
#line 2619
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2623
  if (localdebug) {
    {
#line 2623
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 2625
  if ((unsigned int )(*M)->representation == 2U) {
#line 2626
    d = (*M)->colsize + 1L;
  } else {
#line 2628
    d = (*M)->colsize;
  }
#line 2630
  m1 = M1->rowsize;
#line 2631
  if (localdebug) {
    {
#line 2632
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_MatrixRedundancyRemove: By sorting, %ld rows have been removed.  The remaining has %ld rows.\n",
            m - m1, m1);
    }
  }
  {
#line 2635
  dd_InitializeArow(d, & cvec);
#line 2636
  set_initialize(& redset1, M1->rowsize);
#line 2637
  k = (dd_rowrange )1;
  }
  {
#line 2638
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2639
    tmp___2 = dd_RedundantExtensive(M1, k, cvec, & redset1, error);
    }
#line 2639
    if (tmp___2) {
      {
#line 2640
      set_addelem(redset1, k);
#line 2641
      dd_MatrixRowsRemove2(& M1, redset1, & newpos1);
#line 2642
      i = (dd_rowrange )1;
      }
      {
#line 2642
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2642
        if (! (i <= m)) {
#line 2642
          goto while_break___1;
        }
#line 2643
        if (*(*newpos + i) > 0L) {
          {
#line 2644
          tmp = set_member(*(*newpos + i), redset1);
          }
#line 2644
          if (tmp) {
            {
#line 2645
            set_addelem(*redset, i);
#line 2646
            *(*newpos + i) = 0L;
            }
          } else {
#line 2648
            *(*newpos + i) = *(newpos1 + *(*newpos + i));
          }
        }
#line 2642
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 2652
      set_free(redset1);
#line 2653
      set_initialize(& redset1, M1->rowsize);
      }
#line 2654
      if (localdebug) {
        {
#line 2655
        printf((char const   */* __restrict  */)"dd_MatrixRedundancyRemove: the row %ld is redundant. The new matrix has %ld rows.\n",
               k, M1->rowsize);
        }
      }
      {
#line 2658
      free((void *)newpos1);
      }
    } else {
      {
#line 2660
      tmp___1 = set_card(redset1);
      }
#line 2660
      if (tmp___1 > 0L) {
        {
#line 2661
        dd_MatrixRowsRemove2(& M1, redset1, & newpos1);
#line 2662
        i = (dd_rowrange )1;
        }
        {
#line 2662
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2662
          if (! (i <= m)) {
#line 2662
            goto while_break___2;
          }
#line 2663
          if (*(*newpos + i) > 0L) {
            {
#line 2664
            tmp___0 = set_member(*(*newpos + i), redset1);
            }
#line 2664
            if (tmp___0) {
              {
#line 2665
              set_addelem(*redset, i);
#line 2666
              *(*newpos + i) = 0L;
              }
            } else {
#line 2668
              *(*newpos + i) = *(newpos1 + *(*newpos + i));
            }
          }
#line 2662
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 2672
        set_free(redset1);
#line 2673
        set_initialize(& redset1, M1->rowsize);
#line 2674
        free((void *)newpos1);
        }
      }
#line 2676
      if (localdebug) {
        {
#line 2677
        printf((char const   */* __restrict  */)"dd_MatrixRedundancyRemove: the row %ld is essential. The new matrix has %ld rows.\n",
               k, M1->rowsize);
        }
      }
#line 2680
      k ++;
    }
#line 2682
    if ((unsigned int )*error != 17U) {
#line 2682
      goto _L99;
    }
#line 2638
    if (! (k <= M1->rowsize)) {
#line 2638
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2684
  if (localdebug) {
    {
#line 2684
    dd_WriteMatrix(stderr, M1);
    }
  }
#line 2685
  success = 1;
  _L99: 
  {
#line 2688
  dd_FreeMatrix(*M);
#line 2689
  *M = M1;
#line 2690
  dd_FreeArow(d, cvec);
#line 2691
  set_free(redset1);
  }
#line 2692
  return (success);
}
}
#line 2696 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_boolean dd_SRedundant(dd_MatrixPtr M , dd_rowrange itest , dd_Arow certificate ,
                         dd_ErrorType *error ) 
{ 
  dd_colrange j ;
  dd_LPPtr lp ;
  dd_LPSolutionPtr lps ;
  dd_ErrorType err ;
  dd_boolean answer ;
  dd_boolean localdebug ;
  int tmp ;
  dd_boolean tmp___0 ;
  dd_boolean tmp___1 ;
  dd_boolean tmp___2 ;

  {
  {
#line 2751
  err = (dd_ErrorType )17;
#line 2752
  answer = 0;
#line 2752
  localdebug = 0;
#line 2754
  *error = (dd_ErrorType )17;
#line 2755
  tmp = set_member(itest, M->linset);
  }
#line 2755
  if (tmp) {
#line 2756
    if (localdebug) {
      {
#line 2756
      printf((char const   */* __restrict  */)"The %ld th row is linearity and strong redundancy checking is skipped.\n",
             itest);
      }
    }
#line 2757
    goto _L99;
  }
#line 2761
  if ((unsigned int )M->representation == 2U) {
    {
#line 2762
    lp = dd_CreateLP_V_Redundancy(M, itest);
    }
  } else {
    {
#line 2764
    lp = dd_CreateLP_H_Redundancy(M, itest);
    }
  }
  {
#line 2767
  dd_LPSolve(lp, dd_choiceRedcheckAlgorithm, & err);
  }
#line 2768
  if ((unsigned int )err != 17U) {
#line 2769
    *error = err;
#line 2770
    goto _L999;
  } else {
    {
#line 2772
    lps = dd_CopyLPSolution(lp);
#line 2774
    j = (dd_colrange )0;
    }
    {
#line 2774
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2774
      if (! (j < lps->d)) {
#line 2774
        goto while_break;
      }
      {
#line 2775
      __gmpq_set(*(certificate + j), (mpq_srcptr )(*(lps->sol + j)));
#line 2774
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2778
    if (localdebug) {
      {
#line 2779
      printf((char const   */* __restrict  */)"Optimum value:");
#line 2780
      dd_WriteNumber(stdout, (__mpq_struct *)(lps->optvalue));
#line 2781
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 2784
    if ((unsigned int )M->representation == 1U) {
      {
#line 2785
      tmp___0 = dd_Positive((__mpq_struct *)(lps->optvalue));
      }
#line 2785
      if (tmp___0) {
#line 2786
        answer = 1;
#line 2787
        if (localdebug) {
          {
#line 2787
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th inequality is strongly redundant.\n",
                  itest);
          }
        }
      } else {
#line 2789
        answer = 0;
#line 2790
        if (localdebug) {
          {
#line 2790
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th inequality is not strongly redundant.\n",
                  itest);
          }
        }
      }
    } else {
      {
#line 2793
      tmp___2 = dd_Negative((__mpq_struct *)(lps->optvalue));
      }
#line 2793
      if (tmp___2) {
#line 2794
        answer = 0;
#line 2795
        if (localdebug) {
          {
#line 2795
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th point is not strongly redundant.\n",
                  itest);
          }
        }
      } else {
        {
#line 2798
        dd_FreeLPData(lp);
#line 2799
        dd_FreeLPSolution(lps);
#line 2800
        lp = dd_CreateLP_V_SRedundancy(M, itest);
#line 2801
        dd_LPSolve(lp, (dd_LPSolverType )1, & err);
#line 2802
        lps = dd_CopyLPSolution(lp);
        }
#line 2803
        if (localdebug) {
          {
#line 2803
          dd_WriteLPResult(stdout, lp, err);
          }
        }
        {
#line 2804
        tmp___1 = dd_Positive((__mpq_struct *)(lps->optvalue));
        }
#line 2804
        if (tmp___1) {
#line 2805
          answer = 0;
#line 2806
          if (localdebug) {
            {
#line 2806
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th point is not strongly redundant.\n",
                    itest);
            }
          }
        } else {
#line 2808
          answer = 1;
#line 2809
          if (localdebug) {
            {
#line 2809
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th point is strongly redundant.\n",
                    itest);
            }
          }
        }
      }
    }
    {
#line 2813
    dd_FreeLPSolution(lps);
    }
  }
  _L999: 
  {
#line 2816
  dd_FreeLPData(lp);
  }
  _L99: 
#line 2818
  return (answer);
}
}
#line 2821 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_rowset dd_SRedundantRows(dd_MatrixPtr M , dd_ErrorType *error ) 
{ 
  dd_rowrange i ;
  dd_rowrange m ;
  dd_colrange d ;
  dd_rowset redset ;
  dd_MatrixPtr Mcopy ;
  dd_Arow cvec ;
  dd_boolean localdebug ;
  dd_boolean tmp ;

  {
#line 2828
  localdebug = 0;
#line 2830
  m = M->rowsize;
#line 2831
  if ((unsigned int )M->representation == 2U) {
#line 2832
    d = M->colsize + 1L;
  } else {
#line 2834
    d = M->colsize;
  }
  {
#line 2836
  Mcopy = dd_MatrixCopy(M);
#line 2837
  dd_InitializeArow(d, & cvec);
#line 2838
  set_initialize(& redset, m);
#line 2839
  i = m;
  }
  {
#line 2839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2839
    if (! (i >= 1L)) {
#line 2839
      goto while_break;
    }
    {
#line 2840
    tmp = dd_SRedundant(Mcopy, i, cvec, error);
    }
#line 2840
    if (tmp) {
#line 2841
      if (localdebug) {
        {
#line 2841
        printf((char const   */* __restrict  */)"dd_SRedundantRows: the row %ld is strongly redundant.\n",
               i);
        }
      }
      {
#line 2842
      set_addelem(redset, i);
#line 2843
      dd_MatrixRowRemove(& Mcopy, i);
      }
    } else
#line 2845
    if (localdebug) {
      {
#line 2845
      printf((char const   */* __restrict  */)"dd_SRedundantRows: the row %ld is not strongly redundant.\n",
             i);
      }
    }
#line 2847
    if ((unsigned int )*error != 17U) {
#line 2847
      goto _L99;
    }
#line 2839
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: 
  {
#line 2850
  dd_FreeMatrix(Mcopy);
#line 2851
  dd_FreeArow(d, cvec);
  }
#line 2852
  return (redset);
}
}
#line 2855 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_rowset dd_RedundantRowsViaShooting(dd_MatrixPtr M , dd_ErrorType *error ) 
{ 
  dd_rowrange i ;
  dd_rowrange m ;
  dd_rowrange ired ;
  dd_rowrange irow ;
  dd_colrange j ;
  dd_colrange k ;
  dd_colrange d ;
  dd_rowset redset ;
  dd_rowindex rowflag ;
  dd_MatrixPtr M1 ;
  dd_Arow shootdir ;
  dd_Arow cvec ;
  dd_LPPtr lp0 ;
  dd_LPPtr lp ;
  dd_LPSolutionPtr lps ;
  dd_ErrorType err ;
  dd_LPSolverType solver ;
  dd_boolean localdebug ;
  void *tmp ;
  dd_boolean tmp___0 ;
  dd_boolean tmp___1 ;

  {
  {
#line 2863
  irow = (dd_rowrange )0;
#line 2872
  cvec = (dd_Arow )((void *)0);
#line 2876
  solver = (dd_LPSolverType )1;
#line 2877
  localdebug = 0;
#line 2879
  m = M->rowsize;
#line 2880
  d = M->colsize;
#line 2881
  M1 = dd_CreateMatrix(m, d);
#line 2882
  M1->rowsize = (dd_rowrange )0;
#line 2883
  set_initialize(& redset, m);
#line 2884
  dd_InitializeArow(d, & shootdir);
#line 2885
  dd_InitializeArow(d, & cvec);
#line 2887
  tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 2887
  rowflag = (long *)tmp;
#line 2890
  lp0 = dd_Matrix2LP(M, & err);
#line 2891
  lp = dd_MakeLPforInteriorFinding(lp0);
#line 2892
  dd_FreeLPData(lp0);
#line 2893
  dd_LPSolve(lp, solver, & err);
#line 2894
  lps = dd_CopyLPSolution(lp);
#line 2896
  tmp___1 = dd_Positive((__mpq_struct *)(lps->optvalue));
  }
#line 2896
  if (tmp___1) {
#line 2899
    j = (dd_colrange )1;
    {
#line 2899
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2899
      if (! (j < d)) {
#line 2899
        goto while_break;
      }
#line 2900
      k = (dd_colrange )1;
      {
#line 2900
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2900
        if (! (k <= d)) {
#line 2900
          goto while_break___0;
        }
        {
#line 2900
        __gmpq_set(*(shootdir + (k - 1L)), (mpq_srcptr )(dd_purezero));
#line 2900
        k ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2901
      __gmpq_set(*(shootdir + j), (mpq_srcptr )(dd_one));
#line 2902
      ired = dd_RayShooting(M, lps->sol, shootdir);
      }
#line 2903
      if (localdebug) {
        {
#line 2903
        printf((char const   */* __restrict  */)"nonredundant row %3ld found by shooting.\n",
               ired);
        }
      }
#line 2904
      if (ired > 0L) {
#line 2904
        if (*(rowflag + ired) <= 0L) {
#line 2905
          irow ++;
#line 2906
          *(rowflag + ired) = irow;
#line 2907
          k = (dd_colrange )1;
          {
#line 2907
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2907
            if (! (k <= d)) {
#line 2907
              goto while_break___1;
            }
            {
#line 2907
            __gmpq_set(*(*(M1->matrix + (irow - 1L)) + (k - 1L)), (mpq_srcptr )(*(*(M->matrix + (ired - 1L)) + (k - 1L))));
#line 2907
            k ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
      {
#line 2910
      __gmpq_neg(*(shootdir + j), (mpq_srcptr )(dd_one));
#line 2911
      ired = dd_RayShooting(M, lps->sol, shootdir);
      }
#line 2912
      if (localdebug) {
        {
#line 2912
        printf((char const   */* __restrict  */)"nonredundant row %3ld found by shooting.\n",
               ired);
        }
      }
#line 2913
      if (ired > 0L) {
#line 2913
        if (*(rowflag + ired) <= 0L) {
#line 2914
          irow ++;
#line 2915
          *(rowflag + ired) = irow;
#line 2916
          k = (dd_colrange )1;
          {
#line 2916
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2916
            if (! (k <= d)) {
#line 2916
              goto while_break___2;
            }
            {
#line 2916
            __gmpq_set(*(*(M1->matrix + (irow - 1L)) + (k - 1L)), (mpq_srcptr )(*(*(M->matrix + (ired - 1L)) + (k - 1L))));
#line 2916
            k ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 2899
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2920
    M1->rowsize = irow;
#line 2921
    if (localdebug) {
      {
#line 2922
      printf((char const   */* __restrict  */)"The initial nonredundant set is:");
#line 2923
      i = (dd_rowrange )1;
      }
      {
#line 2923
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2923
        if (! (i <= m)) {
#line 2923
          goto while_break___3;
        }
#line 2923
        if (*(rowflag + i) > 0L) {
          {
#line 2923
          printf((char const   */* __restrict  */)" %ld", i);
          }
        }
#line 2923
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 2924
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 2927
    i = (dd_rowrange )1;
    {
#line 2928
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2928
      if (! (i <= m)) {
#line 2928
        goto while_break___4;
      }
#line 2929
      if (*(rowflag + i) == 0L) {
#line 2930
        if (localdebug) {
          {
#line 2930
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Checking redundancy of %ld th inequality\n",
                  i);
          }
        }
#line 2931
        irow ++;
#line 2931
        M1->rowsize = irow;
#line 2932
        k = (dd_colrange )1;
        {
#line 2932
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2932
          if (! (k <= d)) {
#line 2932
            goto while_break___5;
          }
          {
#line 2932
          __gmpq_set(*(*(M1->matrix + (irow - 1L)) + (k - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (k - 1L))));
#line 2932
          k ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 2933
        tmp___0 = dd_Redundant(M1, irow, cvec, & err);
        }
#line 2933
        if (tmp___0) {
#line 2943
          if (localdebug) {
            {
#line 2943
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The %ld th inequality is redundant for the subsystem and thus for the whole.\n",
                    i);
            }
          }
          {
#line 2944
          *(rowflag + i) = -1L;
#line 2945
          set_addelem(redset, i);
#line 2946
          i ++;
          }
        } else {
#line 2934
          k = (dd_colrange )1;
          {
#line 2934
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2934
            if (! (k <= d)) {
#line 2934
              goto while_break___6;
            }
            {
#line 2934
            __gmpq_sub(*(shootdir + (k - 1L)), (mpq_srcptr )(*(cvec + (k - 1L))),
                       (mpq_srcptr )(*(lps->sol + (k - 1L))));
#line 2934
            k ++;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 2935
          ired = dd_RayShooting(M, lps->sol, shootdir);
#line 2936
          *(rowflag + ired) = irow;
#line 2937
          k = (dd_colrange )1;
          }
          {
#line 2937
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 2937
            if (! (k <= d)) {
#line 2937
              goto while_break___7;
            }
            {
#line 2937
            __gmpq_set(*(*(M1->matrix + (irow - 1L)) + (k - 1L)), (mpq_srcptr )(*(*(M->matrix + (ired - 1L)) + (k - 1L))));
#line 2937
            k ++;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 2938
          if (localdebug) {
            {
#line 2939
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The %ld th inequality is nonredundant for the subsystem\n",
                    i);
#line 2940
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The nonredundancy of %ld th inequality is found by shooting.\n",
                    ired);
            }
          }
        }
      } else {
#line 2949
        i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
    {
#line 2954
    redset = dd_RedundantRows(M, error);
    }
  }
  {
#line 2957
  dd_FreeLPData(lp);
#line 2958
  dd_FreeLPSolution(lps);
#line 2960
  M1->rowsize = m;
#line 2960
  M1->colsize = d;
#line 2961
  dd_FreeMatrix(M1);
#line 2962
  dd_FreeArow(d, shootdir);
#line 2963
  dd_FreeArow(d, cvec);
#line 2964
  free((void *)rowflag);
  }
#line 2965
  return (redset);
}
}
#line 2968 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_SetFamilyPtr dd_Matrix2Adjacency(dd_MatrixPtr M , dd_ErrorType *error ) 
{ 
  dd_rowrange i ;
  dd_rowrange m ;
  dd_colrange d ;
  dd_rowset redset ;
  dd_MatrixPtr Mcopy ;
  dd_SetFamilyPtr F ;
  int tmp ;

  {
#line 2978
  F = (dd_SetFamilyPtr )((void *)0);
#line 2980
  m = M->rowsize;
#line 2981
  d = M->colsize;
#line 2982
  if (m <= 0L) {
#line 2983
    *error = (dd_ErrorType )5;
#line 2984
    goto _L999;
  } else
#line 2982
  if (d <= 0L) {
#line 2983
    *error = (dd_ErrorType )5;
#line 2984
    goto _L999;
  }
  {
#line 2986
  Mcopy = dd_MatrixCopy(M);
#line 2987
  F = dd_CreateSetFamily(m, m);
#line 2988
  i = (dd_rowrange )1;
  }
  {
#line 2988
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2988
    if (! (i <= m)) {
#line 2988
      goto while_break;
    }
    {
#line 2989
    tmp = set_member(i, M->linset);
    }
#line 2989
    if (! tmp) {
      {
#line 2990
      set_addelem(Mcopy->linset, i);
#line 2991
      redset = dd_RedundantRows(Mcopy, error);
#line 2992
      set_uni(redset, redset, Mcopy->linset);
#line 2993
      set_compl(*(F->set + (i - 1L)), redset);
#line 2994
      set_delelem(Mcopy->linset, i);
#line 2995
      set_free(redset);
      }
#line 2996
      if ((unsigned int )*error != 17U) {
#line 2996
        goto _L99;
      }
    }
#line 2988
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: 
  {
#line 3000
  dd_FreeMatrix(Mcopy);
  }
  _L999: 
#line 3002
  return (F);
}
}
#line 3005 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_SetFamilyPtr dd_Matrix2WeakAdjacency(dd_MatrixPtr M , dd_ErrorType *error ) 
{ 
  dd_rowrange i ;
  dd_rowrange m ;
  dd_colrange d ;
  dd_rowset redset ;
  dd_MatrixPtr Mcopy ;
  dd_SetFamilyPtr F ;
  int tmp ;

  {
#line 3015
  F = (dd_SetFamilyPtr )((void *)0);
#line 3017
  m = M->rowsize;
#line 3018
  d = M->colsize;
#line 3019
  if (m <= 0L) {
#line 3020
    *error = (dd_ErrorType )5;
#line 3021
    goto _L999;
  } else
#line 3019
  if (d <= 0L) {
#line 3020
    *error = (dd_ErrorType )5;
#line 3021
    goto _L999;
  }
  {
#line 3023
  Mcopy = dd_MatrixCopy(M);
#line 3024
  F = dd_CreateSetFamily(m, m);
#line 3025
  i = (dd_rowrange )1;
  }
  {
#line 3025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3025
    if (! (i <= m)) {
#line 3025
      goto while_break;
    }
    {
#line 3026
    tmp = set_member(i, M->linset);
    }
#line 3026
    if (! tmp) {
      {
#line 3027
      set_addelem(Mcopy->linset, i);
#line 3028
      redset = dd_SRedundantRows(Mcopy, error);
#line 3029
      set_uni(redset, redset, Mcopy->linset);
#line 3030
      set_compl(*(F->set + (i - 1L)), redset);
#line 3031
      set_delelem(Mcopy->linset, i);
#line 3032
      set_free(redset);
      }
#line 3033
      if ((unsigned int )*error != 17U) {
#line 3033
        goto _L99;
      }
    }
#line 3025
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: 
  {
#line 3037
  dd_FreeMatrix(Mcopy);
  }
  _L999: 
#line 3039
  return (F);
}
}
#line 3043 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_boolean dd_ImplicitLinearity(dd_MatrixPtr M , dd_rowrange itest , dd_Arow certificate ,
                                dd_ErrorType *error ) 
{ 
  dd_colrange j ;
  dd_LPPtr lp ;
  dd_LPSolutionPtr lps ;
  dd_ErrorType err ;
  dd_boolean answer ;
  dd_boolean localdebug ;
  int tmp ;
  dd_boolean tmp___0 ;

  {
  {
#line 3079
  err = (dd_ErrorType )17;
#line 3080
  answer = 0;
#line 3080
  localdebug = 0;
#line 3082
  *error = (dd_ErrorType )17;
#line 3083
  tmp = set_member(itest, M->linset);
  }
#line 3083
  if (tmp) {
#line 3084
    if (localdebug) {
      {
#line 3084
      printf((char const   */* __restrict  */)"The %ld th row is linearity and redundancy checking is skipped.\n",
             itest);
      }
    }
#line 3085
    goto _L99;
  }
#line 3089
  if ((unsigned int )M->representation == 2U) {
    {
#line 3090
    lp = dd_CreateLP_V_Redundancy(M, itest);
    }
  } else {
    {
#line 3092
    lp = dd_CreateLP_H_Redundancy(M, itest);
    }
  }
  {
#line 3095
  lp->objective = (dd_LPObjectiveType )1;
#line 3096
  dd_LPSolve(lp, dd_choiceRedcheckAlgorithm, & err);
  }
#line 3097
  if ((unsigned int )err != 17U) {
#line 3098
    *error = err;
#line 3099
    goto _L999;
  } else {
    {
#line 3101
    lps = dd_CopyLPSolution(lp);
#line 3103
    j = (dd_colrange )0;
    }
    {
#line 3103
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3103
      if (! (j < lps->d)) {
#line 3103
        goto while_break;
      }
      {
#line 3104
      __gmpq_set(*(certificate + j), (mpq_srcptr )(*(lps->sol + j)));
#line 3103
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3107
    if ((unsigned int )lps->LPS == 1U) {
      {
#line 3107
      tmp___0 = dd_EqualToZero((__mpq_struct *)(lps->optvalue));
      }
#line 3107
      if (tmp___0) {
#line 3108
        answer = 1;
#line 3109
        if (localdebug) {
          {
#line 3109
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th data is an implicit linearity.\n",
                  itest);
          }
        }
      } else {
#line 3107
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 3111
      answer = 0;
#line 3112
      if (localdebug) {
        {
#line 3112
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th data is not an implicit linearity.\n",
                itest);
        }
      }
    }
    {
#line 3114
    dd_FreeLPSolution(lps);
    }
  }
  _L999: 
  {
#line 3117
  dd_FreeLPData(lp);
  }
  _L99: 
#line 3119
  return (answer);
}
}
#line 3123 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
int dd_FreeOfImplicitLinearity(dd_MatrixPtr M , dd_Arow certificate , dd_rowset *imp_linrows ,
                               dd_ErrorType *error ) 
{ 
  dd_LPPtr lp ;
  dd_rowrange i ;
  dd_rowrange m ;
  dd_colrange j ;
  dd_colrange d1 ;
  dd_ErrorType err ;
  dd_Arow cvec ;
  int answer ;
  int localdebug ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;
  dd_boolean tmp___1 ;
  int tmp___2 ;

  {
#line 3155
  err = (dd_ErrorType )17;
#line 3158
  answer = 0;
#line 3158
  localdebug = 0;
#line 3160
  *error = (dd_ErrorType )17;
#line 3162
  if ((unsigned int )M->representation == 2U) {
    {
#line 3163
    lp = dd_CreateLP_V_ImplicitLinearity(M);
    }
  } else {
    {
#line 3165
    lp = dd_CreateLP_H_ImplicitLinearity(M);
    }
  }
  {
#line 3168
  dd_LPSolve(lp, dd_choiceRedcheckAlgorithm, & err);
  }
#line 3169
  if ((unsigned int )err != 17U) {
#line 3170
    *error = err;
#line 3171
    goto _L999;
  } else {
#line 3174
    j = (dd_colrange )0;
    {
#line 3174
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3174
      if (! (j < lp->d)) {
#line 3174
        goto while_break;
      }
      {
#line 3175
      __gmpq_set(*(certificate + j), (mpq_srcptr )(*(lp->sol + j)));
#line 3174
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3178
    if (localdebug) {
      {
#line 3178
      dd_WriteLPResult(stderr, lp, err);
      }
    }
#line 3181
    if (localdebug) {
      {
#line 3182
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> The following variables are not implicit linearity:\n");
#line 3183
      set_fwrite(stderr, lp->posset_extra);
#line 3184
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 3187
    if ((unsigned int )M->representation == 2U) {
#line 3188
      d1 = M->colsize + 1L;
    } else {
#line 3190
      d1 = M->colsize;
    }
    {
#line 3192
    m = M->rowsize;
#line 3193
    dd_InitializeArow(d1, & cvec);
#line 3194
    set_initialize(imp_linrows, m);
    }
#line 3196
    if ((unsigned int )lp->LPS == 1U) {
      {
#line 3197
      tmp___0 = dd_Positive((__mpq_struct *)(lp->optvalue));
      }
#line 3197
      if (tmp___0) {
#line 3198
        answer = 1;
#line 3199
        if (localdebug) {
          {
#line 3199
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> The matrix has no implicit linearity.\n");
          }
        }
      } else {
        {
#line 3200
        tmp = dd_Negative((__mpq_struct *)(lp->optvalue));
        }
#line 3200
        if (tmp) {
#line 3201
          answer = -1;
#line 3202
          if (localdebug) {
            {
#line 3202
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> The matrix defines the trivial system.\n");
            }
          }
        } else {
#line 3204
          answer = 0;
#line 3205
          if (localdebug) {
            {
#line 3205
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> The matrix has some implicit linearity.\n");
            }
          }
        }
      }
    } else {
#line 3208
      answer = -2;
#line 3209
      if (localdebug) {
        {
#line 3209
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> The LP fails.\n");
        }
      }
    }
#line 3211
    if (answer == 0) {
#line 3213
      i = m;
      {
#line 3213
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3213
        if (! (i >= 1L)) {
#line 3213
          goto while_break___0;
        }
        {
#line 3214
        tmp___2 = set_member(i, lp->posset_extra);
        }
#line 3214
        if (! tmp___2) {
          {
#line 3215
          tmp___1 = dd_ImplicitLinearity(M, i, cvec, error);
          }
#line 3215
          if (tmp___1) {
            {
#line 3216
            set_addelem(*imp_linrows, i);
            }
#line 3217
            if (localdebug) {
              {
#line 3218
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" row %ld is implicit linearity\n",
                      i);
#line 3219
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
              }
            }
          }
#line 3222
          if ((unsigned int )*error != 17U) {
#line 3222
            goto _L999;
          }
        }
#line 3213
        i --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 3226
    if (answer == -1) {
#line 3227
      i = m;
      {
#line 3227
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3227
        if (! (i >= 1L)) {
#line 3227
          goto while_break___1;
        }
        {
#line 3227
        set_addelem(*imp_linrows, i);
#line 3227
        i --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 3230
    dd_FreeArow(d1, cvec);
    }
  }
  _L999: 
  {
#line 3233
  dd_FreeLPData(lp);
  }
#line 3235
  return (answer);
}
}
#line 3239 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_rowset dd_ImplicitLinearityRows(dd_MatrixPtr M , dd_ErrorType *error ) 
{ 
  dd_colrange d ;
  dd_rowset imp_linset ;
  dd_Arow cvec ;
  int foi ;
  dd_boolean localdebug ;

  {
#line 3245
  localdebug = 0;
#line 3247
  if ((unsigned int )M->representation == 2U) {
#line 3248
    d = M->colsize + 2L;
  } else {
#line 3250
    d = M->colsize + 1L;
  }
  {
#line 3253
  dd_InitializeArow(d, & cvec);
  }
#line 3254
  if (localdebug) {
    {
#line 3254
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\ndd_ImplicitLinearityRows: Check whether the system contains any implicit linearity.\n");
    }
  }
  {
#line 3255
  foi = dd_FreeOfImplicitLinearity(M, cvec, & imp_linset, error);
  }
#line 3256
  if (localdebug) {
    {
#line 3258
    if (foi == 1) {
#line 3258
      goto case_1;
    }
#line 3262
    if (foi == 0) {
#line 3262
      goto case_0;
    }
#line 3266
    if (foi == -1) {
#line 3266
      goto case_neg_1;
    }
#line 3270
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 3259
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  It is free of implicit linearity.\n");
    }
#line 3260
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 3263
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  It is not free of implicit linearity.\n");
    }
#line 3264
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 3267
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  The input system is trivial (i.e. the empty H-polytope or the V-rep of the whole space.\n");
    }
#line 3268
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3271
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  The LP was not solved correctly.\n");
    }
#line 3272
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 3277
  if (localdebug) {
    {
#line 3278
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Implicit linearity rows are:\n");
#line 3279
    set_fwrite(stderr, imp_linset);
#line 3280
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 3282
  dd_FreeArow(d, cvec);
  }
#line 3283
  return (imp_linset);
}
}
#line 3286 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_boolean dd_MatrixCanonicalizeLinearity(dd_MatrixPtr *M , dd_rowset *impl_linset ,
                                          dd_rowindex *newpos , dd_ErrorType *error ) 
{ 
  dd_rowrange rank ;
  dd_rowset linrows ;
  dd_rowset ignoredrows ;
  dd_rowset basisrows ;
  dd_colset ignoredcols ;
  dd_colset basiscols ;
  dd_rowrange i ;
  dd_rowrange k ;
  dd_rowrange m ;
  dd_rowindex newpos1 ;
  dd_boolean success ;

  {
  {
#line 3297
  success = 0;
#line 3299
  linrows = dd_ImplicitLinearityRows(*M, error);
  }
#line 3300
  if ((unsigned int )*error != 17U) {
#line 3300
    goto _L99;
  }
  {
#line 3302
  m = (*M)->rowsize;
#line 3304
  set_uni((*M)->linset, (*M)->linset, linrows);
#line 3309
  set_initialize(& ignoredrows, (*M)->rowsize);
#line 3310
  set_initialize(& ignoredcols, (*M)->colsize);
#line 3311
  set_compl(ignoredrows, (*M)->linset);
#line 3312
  rank = dd_MatrixRank(*M, ignoredrows, ignoredcols, & basisrows, & basiscols);
#line 3313
  set_diff(ignoredrows, (*M)->linset, basisrows);
#line 3314
  dd_MatrixRowsRemove2(M, ignoredrows, newpos);
#line 3316
  dd_MatrixShiftupLinearity(M, & newpos1);
#line 3318
  i = (dd_rowrange )1;
  }
  {
#line 3318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3318
    if (! (i <= m)) {
#line 3318
      goto while_break;
    }
#line 3319
    k = *(*newpos + i);
#line 3320
    if (k > 0L) {
#line 3321
      *(*newpos + i) = *(newpos1 + k);
    }
#line 3318
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3325
  *impl_linset = linrows;
#line 3326
  success = 1;
#line 3327
  free((void *)newpos1);
#line 3328
  set_free(basisrows);
#line 3329
  set_free(basiscols);
#line 3330
  set_free(ignoredrows);
#line 3331
  set_free(ignoredcols);
  }
  _L99: 
#line 3333
  return (success);
}
}
#line 3336 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_boolean dd_MatrixCanonicalize(dd_MatrixPtr *M , dd_rowset *impl_linset , dd_rowset *redset ,
                                 dd_rowindex *newpos , dd_ErrorType *error ) 
{ 
  dd_rowrange i ;
  dd_rowrange k ;
  dd_rowrange m ;
  dd_rowindex newpos1 ;
  dd_rowindex revpos ;
  dd_rowset redset1 ;
  dd_boolean success ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 3347
  success = 1;
#line 3349
  m = (*M)->rowsize;
#line 3350
  set_initialize(redset, m);
#line 3351
  tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 3351
  revpos = (long *)tmp;
#line 3353
  success = dd_MatrixCanonicalizeLinearity(M, impl_linset, newpos, error);
  }
#line 3355
  if (! success) {
#line 3355
    goto _L99;
  }
#line 3357
  i = (dd_rowrange )1;
  {
#line 3357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3357
    if (! (i <= m)) {
#line 3357
      goto while_break;
    }
#line 3358
    k = *(*newpos + i);
#line 3359
    if (k > 0L) {
#line 3359
      *(revpos + k) = i;
    }
#line 3357
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3362
  success = dd_MatrixRedundancyRemove(M, & redset1, & newpos1, error);
  }
#line 3364
  if (! success) {
#line 3364
    goto _L99;
  }
#line 3366
  i = (dd_rowrange )1;
  {
#line 3366
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3366
    if (! (i <= m)) {
#line 3366
      goto while_break___0;
    }
#line 3367
    k = *(*newpos + i);
#line 3368
    if (k > 0L) {
#line 3369
      *(*newpos + i) = *(newpos1 + k);
#line 3370
      if (*(newpos1 + k) < 0L) {
#line 3370
        *(*newpos + i) = - *(revpos + - *(newpos1 + k));
      }
      {
#line 3371
      tmp___0 = set_member(k, redset1);
      }
#line 3371
      if (tmp___0) {
        {
#line 3371
        set_addelem(*redset, i);
        }
      }
    }
#line 3366
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  _L99: 
  {
#line 3376
  set_free(redset1);
#line 3377
  free((void *)newpos1);
#line 3378
  free((void *)revpos);
  }
#line 3379
  return (success);
}
}
#line 3383 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_boolean dd_ExistsRestrictedFace(dd_MatrixPtr M , dd_rowset R , dd_rowset S , dd_ErrorType *err ) 
{ 
  dd_boolean answer ;
  dd_LPPtr lp ;
  dd_boolean tmp ;

  {
  {
#line 3392
  answer = 0;
#line 3393
  lp = (dd_LPPtr )((void *)0);
#line 3401
  lp = dd_Matrix2Feasibility2(M, R, S, err);
  }
#line 3403
  if ((unsigned int )*err != 17U) {
#line 3403
    goto _L99;
  }
  {
#line 3406
  dd_LPSolve(lp, (dd_LPSolverType )1, err);
  }
#line 3407
  if ((unsigned int )*err != 17U) {
#line 3407
    goto _L99;
  }
#line 3408
  if ((unsigned int )lp->LPS == 1U) {
    {
#line 3408
    tmp = dd_Positive((__mpq_struct *)(lp->optvalue));
    }
#line 3408
    if (tmp) {
#line 3409
      answer = 1;
    }
  }
  {
#line 3412
  dd_FreeLPData(lp);
  }
  _L99: 
#line 3414
  return (answer);
}
}
#line 3417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_boolean dd_ExistsRestrictedFace2(dd_MatrixPtr M , dd_rowset R , dd_rowset S , dd_LPSolutionPtr *lps ,
                                    dd_ErrorType *err ) 
{ 
  dd_boolean answer ;
  dd_LPPtr lp ;
  dd_boolean tmp ;

  {
  {
#line 3428
  answer = 0;
#line 3429
  lp = (dd_LPPtr )((void *)0);
#line 3437
  lp = dd_Matrix2Feasibility2(M, R, S, err);
  }
#line 3439
  if ((unsigned int )*err != 17U) {
#line 3439
    goto _L99;
  }
  {
#line 3442
  dd_LPSolve(lp, (dd_LPSolverType )1, err);
  }
#line 3443
  if ((unsigned int )*err != 17U) {
#line 3443
    goto _L99;
  }
#line 3444
  if ((unsigned int )lp->LPS == 1U) {
    {
#line 3444
    tmp = dd_Positive((__mpq_struct *)(lp->optvalue));
    }
#line 3444
    if (tmp) {
#line 3445
      answer = 1;
    }
  }
  {
#line 3449
  *lps = dd_CopyLPSolution(lp);
#line 3450
  dd_FreeLPData(lp);
  }
  _L99: 
#line 3452
  return (answer);
}
}
#line 3455 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_boolean dd_FindRelativeInterior(dd_MatrixPtr M , dd_rowset *ImL , dd_rowset *Lbasis ,
                                   dd_LPSolutionPtr *lps , dd_ErrorType *err ) 
{ 
  dd_rowset S ;
  dd_colset T ;
  dd_colset Lbasiscols ;
  dd_boolean success ;
  dd_rowrange i ;
  dd_colrange rank ;
  int tmp ;
  int tmp___0 ;
  dd_boolean tmp___1 ;

  {
  {
#line 3469
  success = 0;
#line 3474
  *ImL = dd_ImplicitLinearityRows(M, err);
  }
#line 3476
  if ((unsigned int )*err != 17U) {
#line 3476
    goto _L99;
  }
  {
#line 3478
  set_initialize(& S, M->rowsize);
#line 3479
  i = (dd_rowrange )1;
  }
  {
#line 3479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3479
    if (! (i <= M->rowsize)) {
#line 3479
      goto while_break;
    }
    {
#line 3480
    tmp = set_member(i, M->linset);
    }
#line 3480
    if (! tmp) {
      {
#line 3480
      tmp___0 = set_member(i, *ImL);
      }
#line 3480
      if (! tmp___0) {
        {
#line 3481
        set_addelem(S, i);
        }
      }
    }
#line 3479
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3484
  tmp___1 = dd_ExistsRestrictedFace2(M, *ImL, S, lps, err);
  }
#line 3484
  if (tmp___1) {
#line 3486
    success = 1;
  }
  {
#line 3489
  set_initialize(& T, M->colsize);
#line 3490
  rank = dd_MatrixRank(M, S, T, Lbasis, & Lbasiscols);
#line 3492
  set_free(S);
#line 3493
  set_free(T);
#line 3494
  set_free(Lbasiscols);
  }
  _L99: 
#line 3497
  return (success);
}
}
#line 3501 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
dd_rowrange dd_RayShooting(dd_MatrixPtr M , dd_Arow p , dd_Arow r ) 
{ 
  dd_rowrange imin ;
  dd_rowrange i ;
  dd_rowrange m ;
  dd_colrange j ;
  dd_colrange d ;
  dd_Arow vecmin ;
  dd_Arow vec ;
  mytype min ;
  mytype t1 ;
  mytype t2 ;
  mytype alpha ;
  mytype t1min ;
  dd_boolean started ;
  dd_boolean localdebug ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;
  dd_boolean tmp___1 ;
  dd_boolean tmp___2 ;
  dd_boolean tmp___3 ;
  dd_boolean tmp___4 ;

  {
  {
#line 3504
  imin = (dd_rowrange )-1;
#line 3508
  started = 0;
#line 3509
  localdebug = 0;
#line 3511
  m = M->rowsize;
#line 3512
  d = M->colsize;
#line 3513
  tmp = dd_Equal((__mpq_struct *)(dd_one), (__mpq_struct *)(*(p + 0)));
  }
#line 3513
  if (! tmp) {
    {
#line 3514
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: RayShooting is called with a point with first coordinate not 1.\n");
#line 3515
    __gmpq_set(*(p + 0), (mpq_srcptr )(dd_one));
    }
  }
  {
#line 3517
  tmp___0 = dd_EqualToZero((__mpq_struct *)(*(r + 0)));
  }
#line 3517
  if (! tmp___0) {
    {
#line 3518
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: RayShooting is called with a direction with first coordinate not 0.\n");
#line 3519
    __gmpq_set(*(r + 0), (mpq_srcptr )(dd_purezero));
    }
  }
  {
#line 3522
  __gmpq_init(alpha);
#line 3522
  __gmpq_init(min);
#line 3522
  __gmpq_init(t1);
#line 3522
  __gmpq_init(t2);
#line 3522
  __gmpq_init(t1min);
#line 3523
  dd_InitializeArow(d, & vecmin);
#line 3524
  dd_InitializeArow(d, & vec);
#line 3526
  i = (dd_rowrange )1;
  }
  {
#line 3526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3526
    if (! (i <= m)) {
#line 3526
      goto while_break;
    }
    {
#line 3527
    dd_InnerProduct((__mpq_struct *)(t1), d, *(M->matrix + (i - 1L)), p);
#line 3528
    tmp___4 = dd_Positive((__mpq_struct *)(t1));
    }
#line 3528
    if (tmp___4) {
      {
#line 3529
      dd_InnerProduct((__mpq_struct *)(t2), d, *(M->matrix + (i - 1L)), r);
#line 3530
      __gmpq_div(alpha, (mpq_srcptr )(t2), (mpq_srcptr )(t1));
      }
#line 3531
      if (! started) {
        {
#line 3532
        imin = i;
#line 3532
        __gmpq_set(min, (mpq_srcptr )(alpha));
#line 3533
        __gmpq_set(t1min, (mpq_srcptr )(t1));
#line 3534
        started = 1;
        }
#line 3535
        if (localdebug) {
          {
#line 3536
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Level 1: imin = %ld and min = ",
                  imin);
#line 3537
          dd_WriteNumber(stderr, (__mpq_struct *)(min));
#line 3538
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
          }
        }
      } else {
        {
#line 3541
        tmp___3 = dd_Smaller((__mpq_struct *)(alpha), (__mpq_struct *)(min));
        }
#line 3541
        if (tmp___3) {
          {
#line 3542
          imin = i;
#line 3542
          __gmpq_set(min, (mpq_srcptr )(alpha));
#line 3543
          __gmpq_set(t1min, (mpq_srcptr )(t1));
          }
#line 3544
          if (localdebug) {
            {
#line 3545
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Level 2: imin = %ld and min = ",
                    imin);
#line 3546
            dd_WriteNumber(stderr, (__mpq_struct *)(min));
#line 3547
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
            }
          }
        } else {
          {
#line 3550
          tmp___2 = dd_Equal((__mpq_struct *)(alpha), (__mpq_struct *)(min));
          }
#line 3550
          if (tmp___2) {
#line 3551
            j = (dd_colrange )1;
            {
#line 3551
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 3551
              if (! (j <= d)) {
#line 3551
                goto while_break___0;
              }
              {
#line 3552
              __gmpq_div(*(vecmin + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (imin - 1L)) + (j - 1L))),
                         (mpq_srcptr )(t1min));
#line 3553
              __gmpq_div(*(vec + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 1L))),
                         (mpq_srcptr )(t1));
#line 3551
              j ++;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 3555
            tmp___1 = dd_LexSmaller(vec, vecmin, d);
            }
#line 3555
            if (tmp___1) {
              {
#line 3556
              imin = i;
#line 3556
              __gmpq_set(min, (mpq_srcptr )(alpha));
#line 3557
              __gmpq_set(t1min, (mpq_srcptr )(t1));
              }
#line 3558
              if (localdebug) {
                {
#line 3559
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Level 3: imin = %ld and min = ",
                        imin);
#line 3560
                dd_WriteNumber(stderr, (__mpq_struct *)(min));
#line 3561
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
                }
              }
            }
          }
        }
      }
    }
#line 3526
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3570
  __gmpq_clear(alpha);
#line 3570
  __gmpq_clear(min);
#line 3570
  __gmpq_clear(t1);
#line 3570
  __gmpq_clear(t2);
#line 3570
  __gmpq_clear(t1min);
#line 3571
  dd_FreeArow(d, vecmin);
#line 3572
  dd_FreeArow(d, vec);
  }
#line 3573
  return (imin);
}
}
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___1  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___1  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___1  ;
#line 3577 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_BasisStatusMaximize(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                            dd_Bmatrix T , dd_rowset equalityset , dd_rowrange objrow ,
                            dd_colrange rhscol , ddf_LPStatusType LPS , mytype *optvalue ,
                            dd_Arow sol , dd_Arow dsol , dd_rowset posset , ddf_colindex nbindex ,
                            ddf_rowrange re , ddf_colrange se , dd_colrange *nse ,
                            long *pivots , int *found , int *LPScorrect ) 
{ 
  long pivots0 ;
  long pivots1 ;
  long fbasisrank ;
  dd_rowrange i ;
  dd_rowrange is ;
  dd_colrange s ;
  dd_colrange senew ;
  dd_colrange j ;
  unsigned int rseed ;
  mytype val ;
  dd_colindex nbtemp ;
  dd_LPStatusType ddlps ;
  dd_boolean localdebug ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  dd_boolean tmp___2 ;
  dd_boolean tmp___3 ;
  dd_boolean tmp___4 ;
  dd_boolean tmp___5 ;
  dd_boolean tmp___6 ;
  dd_boolean tmp___7 ;

  {
#line 3600
  rseed = 1U;
#line 3604
  localdebug = 0;
#line 3606
  if (dd_debug) {
#line 3606
    localdebug = dd_debug;
  }
#line 3607
  if (localdebug) {
    {
#line 3608
    printf((char const   */* __restrict  */)"\nEvaluating dd_BasisStatusMaximize:\n");
    }
  }
  {
#line 3610
  __gmpq_init(val);
#line 3611
  tmp = calloc((size_t )(d_size + 1L), sizeof(long ));
#line 3611
  nbtemp = (long *)tmp;
#line 3612
  i = (dd_rowrange )0;
  }
  {
#line 3612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3612
    if (! (i <= 4L)) {
#line 3612
      goto while_break;
    }
#line 3612
    *(pivots + i) = 0L;
#line 3612
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3613
  if ((unsigned long )bflag___1 == (unsigned long )((void *)0)) {
#line 3613
    goto _L;
  } else
#line 3613
  if (mlast___1 != m_size) {
    _L: /* CIL Label */ 
#line 3614
    if (mlast___1 != m_size) {
#line 3614
      if (mlast___1 > 0L) {
        {
#line 3615
        free((void *)bflag___1);
#line 3616
        free((void *)OrderVector___1);
        }
      }
    }
    {
#line 3618
    tmp___0 = calloc((size_t )(m_size + 1L), sizeof(long ));
#line 3618
    bflag___1 = (long *)tmp___0;
#line 3619
    tmp___1 = calloc((size_t )(m_size + 1L), sizeof(long ));
#line 3619
    OrderVector___1 = (long *)tmp___1;
#line 3621
    mlast___1 = m_size;
    }
  }
  {
#line 3625
  dd_ComputeRowOrderVector2(m_size, d_size, A, OrderVector___1, (dd_RowOrderType )1,
                            rseed);
#line 3627
  pivots1 = 0L;
#line 3629
  dd_ResetTableau(m_size, d_size, T, nbtemp, bflag___1, objrow, rhscol);
  }
#line 3631
  if (localdebug) {
    {
#line 3632
    printf((char const   */* __restrict  */)"\nnbindex:");
#line 3633
    j = (dd_colrange )1;
    }
    {
#line 3633
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3633
      if (! (j <= d_size)) {
#line 3633
        goto while_break___0;
      }
      {
#line 3633
      printf((char const   */* __restrict  */)" %ld", *(nbindex + j));
#line 3633
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3634
    printf((char const   */* __restrict  */)"\n");
#line 3635
    printf((char const   */* __restrict  */)"re = %ld,   se=%ld\n", re, se);
    }
  }
#line 3638
  is = *(nbindex + se);
#line 3639
  if (localdebug) {
    {
#line 3639
    printf((char const   */* __restrict  */)"se=%ld,  is=%ld\n", se, is);
    }
  }
#line 3641
  fbasisrank = d_size - 1L;
#line 3642
  j = (dd_colrange )1;
  {
#line 3642
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3642
    if (! (j <= d_size)) {
#line 3642
      goto while_break___1;
    }
#line 3643
    if (*(nbindex + j) < 0L) {
#line 3643
      fbasisrank --;
    }
#line 3642
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3647
  if (fbasisrank < d_size - 1L) {
#line 3648
    if (localdebug) {
      {
#line 3649
      printf((char const   */* __restrict  */)"d_size = %ld, the size of basis = %ld\n",
             d_size, fbasisrank);
#line 3650
      printf((char const   */* __restrict  */)"dd_BasisStatusMaximize: the size of basis is smaller than d-1.\nIt is safer to run the LP solver with GMP\n");
      }
    }
#line 3652
    *found = 0;
#line 3653
    goto _L99;
  }
  {
#line 3659
  dd_FindLPBasis2(m_size, d_size, A, T, OrderVector___1, equalityset, nbindex, bflag___1,
                  objrow, rhscol, & s, found, & pivots0);
#line 3663
  senew = *(bflag___1 + is);
#line 3664
  is = *(nbindex + senew);
  }
#line 3665
  if (localdebug) {
    {
#line 3665
    printf((char const   */* __restrict  */)"new se=%ld,  is=%ld\n", senew, is);
    }
  }
#line 3667
  *(pivots + 4) = pivots0;
#line 3668
  dd_statBSpivots += pivots0;
#line 3670
  if (! *found) {
#line 3671
    if (localdebug) {
      {
#line 3672
      printf((char const   */* __restrict  */)"dd_BasisStatusMaximize: a specified basis DOES NOT exist.\n");
      }
    }
#line 3675
    goto _L99;
  }
#line 3679
  if (localdebug) {
    {
#line 3680
    printf((char const   */* __restrict  */)"dd_BasisStatusMaximize: a specified basis exists.\n");
    }
#line 3681
    if (m_size <= 100L) {
#line 3681
      if (d_size <= 30L) {
        {
#line 3682
        dd_WriteTableau(stdout, m_size, d_size, A, T, nbindex, bflag___1);
        }
      }
    }
  }
#line 3686
  *LPScorrect = 1;
  {
#line 3688
  if ((unsigned int )LPS == 1U) {
#line 3688
    goto case_1;
  }
#line 3707
  if ((unsigned int )LPS == 2U) {
#line 3707
    goto case_2;
  }
#line 3723
  if ((unsigned int )LPS == 3U) {
#line 3723
    goto case_3;
  }
#line 3740
  goto switch_default;
  case_1: /* CIL Label */ 
#line 3689
  i = (dd_rowrange )1;
  {
#line 3689
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3689
    if (! (i <= m_size)) {
#line 3689
      goto while_break___2;
    }
#line 3690
    if (i != objrow) {
#line 3690
      if (*(bflag___1 + i) == -1L) {
        {
#line 3691
        dd_TableauEntry(& val, m_size, d_size, A, T, i, rhscol);
#line 3692
        tmp___2 = dd_Negative((__mpq_struct *)(val));
        }
#line 3692
        if (tmp___2) {
#line 3693
          if (localdebug) {
            {
#line 3693
            printf((char const   */* __restrict  */)"RHS entry for %ld is negative\n",
                   i);
            }
          }
#line 3694
          *LPScorrect = 0;
#line 3695
          goto while_break___2;
        }
      } else {
#line 3690
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 3697
    if (*(bflag___1 + i) > 0L) {
      {
#line 3698
      dd_TableauEntry(& val, m_size, d_size, A, T, objrow, *(bflag___1 + i));
#line 3699
      tmp___3 = dd_Positive((__mpq_struct *)(val));
      }
#line 3699
      if (tmp___3) {
#line 3700
        if (localdebug) {
          {
#line 3700
          printf((char const   */* __restrict  */)"Reduced cost entry for %ld is positive\n",
                 i);
          }
        }
#line 3701
        *LPScorrect = 0;
#line 3702
        goto while_break___2;
      }
    }
#line 3689
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3706
  goto switch_break;
  case_2: /* CIL Label */ 
#line 3708
  j = (dd_colrange )1;
  {
#line 3708
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3708
    if (! (j <= d_size)) {
#line 3708
      goto while_break___3;
    }
    {
#line 3709
    dd_TableauEntry(& val, m_size, d_size, A, T, re, j);
    }
#line 3710
    if (j == rhscol) {
      {
#line 3711
      tmp___4 = dd_Nonnegative((__mpq_struct *)(val));
      }
#line 3711
      if (tmp___4) {
#line 3712
        if (localdebug) {
          {
#line 3712
          printf((char const   */* __restrict  */)"RHS entry for %ld is nonnegative\n",
                 re);
          }
        }
#line 3713
        *LPScorrect = 0;
#line 3714
        goto while_break___3;
      }
    } else {
      {
#line 3716
      tmp___5 = dd_Positive((__mpq_struct *)(val));
      }
#line 3716
      if (tmp___5) {
#line 3717
        if (localdebug) {
          {
#line 3717
          printf((char const   */* __restrict  */)"the row entry for(%ld, %ld) is positive\n",
                 re, j);
          }
        }
#line 3718
        *LPScorrect = 0;
#line 3719
        goto while_break___3;
      }
    }
#line 3708
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3722
  goto switch_break;
  case_3: /* CIL Label */ 
#line 3724
  i = (dd_rowrange )1;
  {
#line 3724
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 3724
    if (! (i <= m_size)) {
#line 3724
      goto while_break___4;
    }
    {
#line 3725
    dd_TableauEntry(& val, m_size, d_size, A, T, i, *(bflag___1 + is));
    }
#line 3726
    if (i == objrow) {
      {
#line 3727
      tmp___6 = dd_Nonpositive((__mpq_struct *)(val));
      }
#line 3727
      if (tmp___6) {
#line 3728
        if (localdebug) {
          {
#line 3728
          printf((char const   */* __restrict  */)"Reduced cost entry for %ld is nonpositive\n",
                 *(bflag___1 + is));
          }
        }
#line 3729
        *LPScorrect = 0;
#line 3730
        goto while_break___4;
      }
    } else {
      {
#line 3732
      tmp___7 = dd_Negative((__mpq_struct *)(val));
      }
#line 3732
      if (tmp___7) {
#line 3733
        if (localdebug) {
          {
#line 3733
          printf((char const   */* __restrict  */)"the column entry for(%ld, %ld) is positive\n",
                 i, *(bflag___1 + is));
          }
        }
#line 3734
        *LPScorrect = 0;
#line 3735
        goto while_break___4;
      }
    }
#line 3724
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 3738
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3740
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 3743
  ddlps = LPSf2LPS(LPS);
#line 3745
  dd_SetSolutions(m_size, d_size, A, T, objrow, rhscol, ddlps, optvalue, sol, dsol,
                  posset, nbindex, re, senew, bflag___1);
#line 3747
  *nse = senew;
  }
  _L99: 
  {
#line 3751
  __gmpq_clear(val);
#line 3752
  free((void *)nbtemp);
  }
#line 3753
  return;
}
}
#line 3755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
void dd_BasisStatusMinimize(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A ,
                            dd_Bmatrix T , dd_rowset equalityset , dd_rowrange objrow ,
                            dd_colrange rhscol , ddf_LPStatusType LPS , mytype *optvalue ,
                            dd_Arow sol , dd_Arow dsol , dd_rowset posset , ddf_colindex nbindex ,
                            ddf_rowrange re , ddf_colrange se , dd_colrange *nse ,
                            long *pivots , int *found , int *LPScorrect ) 
{ 
  dd_colrange j ;

  {
#line 3763
  j = (dd_colrange )1;
  {
#line 3763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3763
    if (! (j <= d_size)) {
#line 3763
      goto while_break;
    }
    {
#line 3763
    __gmpq_neg(*(*(A + (objrow - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(A + (objrow - 1L)) + (j - 1L))));
#line 3763
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3764
  dd_BasisStatusMaximize(m_size, d_size, A, T, equalityset, objrow, rhscol, LPS, optvalue,
                         sol, dsol, posset, nbindex, re, se, nse, pivots, found, LPScorrect);
#line 3766
  __gmpq_neg(*optvalue, (mpq_srcptr )(*optvalue));
#line 3767
  j = (dd_colrange )1;
  }
  {
#line 3767
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3767
    if (! (j <= d_size)) {
#line 3767
      goto while_break___0;
    }
#line 3768
    if ((unsigned int )LPS != 2U) {
      {
#line 3770
      __gmpq_neg(*(dsol + (j - 1L)), (mpq_srcptr )(*(dsol + (j - 1L))));
      }
    }
    {
#line 3772
    __gmpq_neg(*(*(A + (objrow - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(A + (objrow - 1L)) + (j - 1L))));
#line 3767
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3774
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.h"
void dddf_neg(double *a___41 , double *b ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
ddf_boolean ddf_Negative(double *val ) ;
#line 87
void ddf_LinearComb(double *lc , double *v1 , double *c1 , double *v2 , double *c2 ) ;
#line 212
ddf_MatrixPtr ddf_FourierElimination(ddf_MatrixPtr M , ddf_ErrorType *error ) ;
#line 213
ddf_MatrixPtr ddf_BlockElimination(ddf_MatrixPtr M , ddf_colset delset , ddf_ErrorType *error ) ;
#line 261
void ddf_Normalize(ddf_colrange d_size , myfloat *V ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddproj_f.c"
ddf_MatrixPtr ddf_BlockElimination(ddf_MatrixPtr M , ddf_colset delset , ddf_ErrorType *error ) 
{ 
  ddf_MatrixPtr Mdual ;
  ddf_MatrixPtr Mproj ;
  ddf_MatrixPtr Gdual ;
  ddf_rowrange i ;
  ddf_rowrange h ;
  ddf_rowrange m ;
  ddf_rowrange mproj ;
  ddf_rowrange mdual ;
  ddf_rowrange linsize ;
  ddf_colrange j ;
  ddf_colrange k ;
  ddf_colrange d ;
  ddf_colrange dproj ;
  ddf_colrange ddual ;
  ddf_colrange delsize ;
  ddf_colindex delindex ;
  myfloat temp ;
  myfloat prod ;
  ddf_PolyhedraPtr dualpoly ;
  ddf_ErrorType err ;
  ddf_boolean localdebug ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 37
  Mdual = (ddf_MatrixPtr )((void *)0);
#line 37
  Mproj = (ddf_MatrixPtr )((void *)0);
#line 37
  Gdual = (ddf_MatrixPtr )((void *)0);
#line 43
  err = (ddf_ErrorType )17;
#line 44
  localdebug = 0;
#line 46
  *error = (ddf_ErrorType )17;
#line 47
  m = M->rowsize;
#line 48
  d = M->colsize;
#line 49
  tmp = calloc((size_t )(d + 1L), sizeof(long ));
#line 49
  delindex = (long *)tmp;
#line 50
  dddf_init((double *)(temp));
#line 51
  dddf_init((double *)(prod));
#line 53
  k = (ddf_colrange )0;
#line 53
  delsize = (ddf_colrange )0;
#line 54
  j = (ddf_colrange )1;
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (j <= d)) {
#line 54
      goto while_break;
    }
    {
#line 55
    tmp___0 = set_member(j, delset);
    }
#line 55
    if (tmp___0) {
#line 56
      k ++;
#line 56
      delsize ++;
#line 57
      *(delindex + k) = j;
    }
#line 54
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  if (localdebug) {
    {
#line 60
    ddf_WriteMatrix(stdout, M);
    }
  }
  {
#line 62
  linsize = set_card(M->linset);
#line 63
  ddual = m + 1L;
#line 64
  mdual = (delsize + m) - linsize;
#line 67
  Mdual = ddf_CreateMatrix(mdual, ddual);
#line 68
  Mdual->representation = (ddf_RepresentationType )1;
#line 69
  i = (ddf_rowrange )1;
  }
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! (i <= delsize)) {
#line 69
      goto while_break___0;
    }
    {
#line 70
    set_addelem(Mdual->linset, i);
#line 71
    j = (ddf_colrange )1;
    }
    {
#line 71
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 71
      if (! (j <= m)) {
#line 71
        goto while_break___1;
      }
      {
#line 72
      dddf_set((double *)(*(*(Mdual->matrix + (i - 1L)) + j)), (double *)(*(*(M->matrix + (j - 1L)) + (*(delindex + i) - 1L))));
#line 71
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 69
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 76
  k = (ddf_colrange )0;
#line 77
  i = (ddf_rowrange )1;
  {
#line 77
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 77
    if (! (i <= m)) {
#line 77
      goto while_break___2;
    }
    {
#line 78
    tmp___1 = set_member(i, M->linset);
    }
#line 78
    if (! tmp___1) {
      {
#line 81
      k ++;
#line 82
      dddf_set((double *)(*(*(Mdual->matrix + ((delsize + k) - 1L)) + i)), (double *)(ddf_one));
      }
    }
#line 77
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 87
  dualpoly = ddf_DDMatrix2Poly(Mdual, & err);
#line 88
  Gdual = ddf_CopyGenerators(dualpoly);
#line 91
  dproj = d - delsize;
#line 92
  mproj = Gdual->rowsize;
#line 93
  Mproj = ddf_CreateMatrix(mproj, dproj);
#line 94
  Mproj->representation = (ddf_RepresentationType )1;
#line 95
  set_copy(Mproj->linset, Gdual->linset);
#line 97
  i = (ddf_rowrange )1;
  }
  {
#line 97
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 97
    if (! (i <= mproj)) {
#line 97
      goto while_break___3;
    }
#line 98
    k = (ddf_colrange )0;
#line 99
    j = (ddf_colrange )1;
    {
#line 99
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 99
      if (! (j <= d)) {
#line 99
        goto while_break___4;
      }
      {
#line 100
      tmp___2 = set_member(j, delset);
      }
#line 100
      if (! tmp___2) {
        {
#line 101
        k ++;
#line 102
        dddf_set((double *)(prod), (double *)(ddf_purezero));
#line 103
        h = (ddf_rowrange )1;
        }
        {
#line 103
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 103
          if (! (h <= m)) {
#line 103
            goto while_break___5;
          }
          {
#line 104
          dddf_mul((double *)(temp), (double *)(*(*(M->matrix + (h - 1L)) + (j - 1L))),
                   (double *)(*(*(Gdual->matrix + (i - 1L)) + h)));
#line 105
          dddf_add((double *)(prod), (double *)(prod), (double *)(temp));
#line 103
          h ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 107
        dddf_set((double *)(*(*(Mproj->matrix + (i - 1L)) + (k - 1L))), (double *)(prod));
        }
      }
#line 99
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 97
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 111
  if (localdebug) {
    {
#line 111
    printf((char const   */* __restrict  */)"Size of the projection system: %ld x %ld\n",
           mproj, dproj);
    }
  }
  {
#line 113
  ddf_FreePolyhedra(dualpoly);
#line 114
  free((void *)delindex);
#line 115
  dddf_clear((double *)(temp));
#line 116
  dddf_clear((double *)(prod));
#line 117
  ddf_FreeMatrix(Mdual);
#line 118
  ddf_FreeMatrix(Gdual);
  }
#line 119
  return (Mproj);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddproj_f.c"
ddf_MatrixPtr ddf_FourierElimination(ddf_MatrixPtr M , ddf_ErrorType *error ) 
{ 
  ddf_MatrixPtr Mnew ;
  ddf_rowrange i ;
  ddf_rowrange inew ;
  ddf_rowrange ip ;
  ddf_rowrange in ;
  ddf_rowrange iz ;
  ddf_rowrange m ;
  ddf_rowrange mpos ;
  ddf_rowrange mneg ;
  ddf_rowrange mzero ;
  ddf_rowrange mnew ;
  ddf_colrange j ;
  ddf_colrange d ;
  ddf_colrange dnew ;
  ddf_rowindex posrowindex ;
  ddf_rowindex negrowindex ;
  ddf_rowindex zerorowindex ;
  myfloat temp1 ;
  myfloat temp2 ;
  ddf_boolean localdebug ;
  long tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  ddf_boolean tmp___3 ;
  ddf_boolean tmp___4 ;

  {
#line 128
  Mnew = (ddf_MatrixPtr )((void *)0);
#line 129
  mpos = (ddf_rowrange )0;
#line 129
  mneg = (ddf_rowrange )0;
#line 129
  mzero = (ddf_rowrange )0;
#line 133
  localdebug = 0;
#line 135
  *error = (ddf_ErrorType )17;
#line 136
  m = M->rowsize;
#line 137
  d = M->colsize;
#line 138
  if (d <= 1L) {
#line 139
    *error = (ddf_ErrorType )14;
#line 140
    if (localdebug) {
      {
#line 141
      printf((char const   */* __restrict  */)"The number of column is too small: %ld for Fourier\'s Elimination.\n",
             d);
      }
    }
#line 143
    goto _L99;
  }
#line 146
  if ((unsigned int )M->representation == 2U) {
#line 147
    *error = (ddf_ErrorType )11;
#line 148
    if (localdebug) {
      {
#line 149
      printf((char const   */* __restrict  */)"Fourier\'s Elimination cannot be applied to a V-polyhedron.\n");
      }
    }
#line 151
    goto _L99;
  }
  {
#line 154
  tmp = set_card(M->linset);
  }
#line 154
  if (tmp > 0L) {
#line 155
    *error = (ddf_ErrorType )12;
#line 156
    if (localdebug) {
      {
#line 157
      printf((char const   */* __restrict  */)"The Fourier Elimination function does not handle equality in this version.\n");
      }
    }
#line 159
    goto _L99;
  }
  {
#line 163
  tmp___0 = calloc((size_t )(m + 1L), sizeof(long ));
#line 163
  posrowindex = (long *)tmp___0;
#line 164
  tmp___1 = calloc((size_t )(m + 1L), sizeof(long ));
#line 164
  negrowindex = (long *)tmp___1;
#line 165
  tmp___2 = calloc((size_t )(m + 1L), sizeof(long ));
#line 165
  zerorowindex = (long *)tmp___2;
#line 166
  dddf_init((double *)(temp1));
#line 167
  dddf_init((double *)(temp2));
#line 169
  i = (ddf_rowrange )1;
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (i <= m)) {
#line 169
      goto while_break;
    }
    {
#line 170
    tmp___4 = ddf_Positive((double *)(*(*(M->matrix + (i - 1L)) + (d - 1L))));
    }
#line 170
    if (tmp___4) {
#line 171
      mpos ++;
#line 172
      *(posrowindex + mpos) = i;
    } else {
      {
#line 173
      tmp___3 = ddf_Negative((double *)(*(*(M->matrix + (i - 1L)) + (d - 1L))));
      }
#line 173
      if (tmp___3) {
#line 174
        mneg ++;
#line 175
        *(negrowindex + mneg) = i;
      } else {
#line 177
        mzero ++;
#line 178
        *(zerorowindex + mzero) = i;
      }
    }
#line 169
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  if (localdebug) {
    {
#line 183
    ddf_WriteMatrix(stdout, M);
#line 184
    printf((char const   */* __restrict  */)"No of  (+  -  0) rows = (%ld, %ld, %ld)\n",
           mpos, mneg, mzero);
    }
  }
  {
#line 190
  mnew = mzero + mpos * mneg;
#line 191
  dnew = d - 1L;
#line 193
  Mnew = ddf_CreateMatrix(mnew, dnew);
#line 194
  ddf_CopyArow(Mnew->rowvec, M->rowvec, dnew);
#line 196
  Mnew->numbtype = M->numbtype;
#line 197
  Mnew->representation = M->representation;
#line 198
  Mnew->objective = M->objective;
#line 202
  iz = (ddf_rowrange )1;
  }
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 202
    if (! (iz <= mzero)) {
#line 202
      goto while_break___0;
    }
#line 203
    j = (ddf_colrange )1;
    {
#line 203
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 203
      if (! (j <= dnew)) {
#line 203
        goto while_break___1;
      }
      {
#line 204
      dddf_set((double *)(*(*(Mnew->matrix + (iz - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (*(zerorowindex + iz) - 1L)) + (j - 1L))));
#line 203
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 202
    iz ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 209
  inew = mzero;
#line 210
  ip = (ddf_rowrange )1;
  {
#line 210
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 210
    if (! (ip <= mpos)) {
#line 210
      goto while_break___2;
    }
#line 211
    in = (ddf_rowrange )1;
    {
#line 211
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 211
      if (! (in <= mneg)) {
#line 211
        goto while_break___3;
      }
      {
#line 212
      inew ++;
#line 213
      dddf_neg((double *)(temp1), (double *)(*(*(M->matrix + (*(negrowindex + in) - 1L)) + (d - 1L))));
#line 214
      j = (ddf_colrange )1;
      }
      {
#line 214
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 214
        if (! (j <= dnew)) {
#line 214
          goto while_break___4;
        }
        {
#line 215
        ddf_LinearComb((double *)(temp2), (double *)(*(*(M->matrix + (*(posrowindex + ip) - 1L)) + (j - 1L))),
                       (double *)(temp1), (double *)(*(*(M->matrix + (*(negrowindex + in) - 1L)) + (j - 1L))),
                       (double *)(*(*(M->matrix + (*(posrowindex + ip) - 1L)) + (d - 1L))));
#line 218
        dddf_set((double *)(*(*(Mnew->matrix + (inew - 1L)) + (j - 1L))), (double *)(temp2));
#line 214
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 220
      ddf_Normalize(dnew, *(Mnew->matrix + (inew - 1L)));
#line 211
      in ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 210
    ip ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 225
  free((void *)posrowindex);
#line 226
  free((void *)negrowindex);
#line 227
  free((void *)zerorowindex);
#line 228
  dddf_clear((double *)(temp1));
#line 229
  dddf_clear((double *)(temp2));
  }
  _L99: 
#line 232
  return (Mnew);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.h"
void dddf_set_si(double *a___41 , long b ) ;
#line 111
void dddf_sub(double *a___41 , double *b , double *c ) ;
#line 116
int dddf_cmp(double *a___41 , double *b ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
myfloat ddf_zero ;
#line 36
myfloat ddf_minuszero ;
#line 68
void ddf_FreeAmatrix(ddf_rowrange m , ddf_colrange d , ddf_Amatrix A ) ;
#line 70
void ddf_FreeBmatrix(ddf_colrange d , ddf_Bmatrix B ) ;
#line 71
void ddf_FreeDDMemory(ddf_PolyhedraPtr poly ) ;
#line 74
void ddf_SetToIdentity(ddf_colrange d_size , ddf_Bmatrix T ) ;
#line 77
ddf_boolean ddf_Nonnegative(double *val ) ;
#line 78
ddf_boolean ddf_Nonpositive(double *val ) ;
#line 83
ddf_boolean ddf_Equal(double *val1 , double *val2 ) ;
#line 84
ddf_boolean ddf_Larger(double *val1 , double *val2 ) ;
#line 85
ddf_boolean ddf_Smaller(double *val1 , double *val2 ) ;
#line 86
void ddf_abs(double *absval , double *val ) ;
#line 88
void ddf_InnerProduct(double *prod , ddf_colrange d , ddf_Arow v1 , ddf_Arow v2 ) ;
#line 124
long ddf_MatrixRank(ddf_MatrixPtr M , ddf_rowset ignoredrows , ddf_colset ignoredcols ,
                    ddf_rowset *rowbasis , ddf_colset *colbasis ) ;
#line 227
void ddf_FreeDDMemory0(ddf_ConePtr cone ) ;
#line 230
void ddf_AddNewHalfspace1(ddf_ConePtr cone , ddf_rowrange hnew ) ;
#line 231
void ddf_AddNewHalfspace2(ddf_ConePtr cone , ddf_rowrange hnew ) ;
#line 232
void ddf_AddRay(ddf_ConePtr cone , myfloat *p ) ;
#line 233
void ddf_AddArtificialRay(ddf_ConePtr cone ) ;
#line 234
void ddf_AValue(myfloat *val , ddf_colrange d_size , ddf_Amatrix A , myfloat *p ,
                ddf_rowrange i ) ;
#line 236
void ddf_CheckEquality(ddf_colrange d_size , ddf_RayPtr *RP1 , ddf_RayPtr *RP2 , ddf_boolean *equal ) ;
#line 237
void ddf_ComputeRowOrderVector(ddf_ConePtr cone ) ;
#line 238
void ddf_ConditionalAddEdge(ddf_ConePtr cone , ddf_RayPtr Ray1 , ddf_RayPtr Ray2 ,
                            ddf_RayPtr ValidFirstRay ) ;
#line 241
void ddf_CopyNormalizedArow(myfloat *acopy , myfloat *a___41 , ddf_colrange d ) ;
#line 245
void ddf_CopyBmatrix(ddf_colrange d_size , ddf_Bmatrix T , ddf_Bmatrix TCOPY ) ;
#line 248
void ddf_CreateInitialEdges(ddf_ConePtr cone ) ;
#line 249
void ddf_CreateNewRay(ddf_ConePtr cone , ddf_RayPtr Ptr1 , ddf_RayPtr Ptr2 , ddf_rowrange ii ) ;
#line 250
void ddf_Eliminate(ddf_ConePtr cone , ddf_RayPtr *Ptr ) ;
#line 251
void ddf_EvaluateARay1(ddf_rowrange i , ddf_ConePtr cone ) ;
#line 252
void ddf_EvaluateARay2(ddf_rowrange i , ddf_ConePtr cone ) ;
#line 253
void ddf_FeasibilityIndices(long *fnum , long *infnum , ddf_rowrange i , ddf_ConePtr cone ) ;
#line 254
void ddf_FindBasis(ddf_ConePtr cone , long *rank ) ;
#line 255
void ddf_FindInitialRays(ddf_ConePtr cone , ddf_boolean *found ) ;
#line 256
void ddf_ColumnReduce(ddf_ConePtr cone ) ;
#line 257
void ddf_GaussianColumnPivot(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix X ,
                             ddf_Bmatrix T , ddf_rowrange r , ddf_colrange s ) ;
#line 258
ddf_boolean ddf_LexSmaller(myfloat *v1 , myfloat *v2 , long dmax ) ;
#line 259
ddf_boolean ddf_LexLarger(myfloat *v1 , myfloat *v2 , long dmax ) ;
#line 260
ddf_boolean ddf_LexEqual(myfloat *v1 , myfloat *v2 , long dmax ) ;
#line 264
void ddf_SelectNextHalfspace(ddf_ConePtr cone , ddf_rowset excluded , ddf_rowrange *hh ) ;
#line 265
void ddf_SelectPivot2(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                      ddf_Bmatrix T , ddf_RowOrderType roworder , ddf_rowindex ordervec ,
                      unsigned long *equalityset , ddf_rowrange rowmax , unsigned long *NopivotRow ,
                      unsigned long *NopivotCol , ddf_rowrange *r , ddf_colrange *s ,
                      ddf_boolean *selected ) ;
#line 268
void ddf_SelectPreorderedNext(ddf_ConePtr cone , ddf_rowset excluded , ddf_rowrange *hh ) ;
#line 269
void ddf_SetInequalitySets(ddf_ConePtr cone ) ;
#line 271
void ddf_StoreRay1(ddf_ConePtr cone , myfloat *p , ddf_boolean *feasible ) ;
#line 272
void ddf_StoreRay2(ddf_ConePtr cone , myfloat *p , ddf_boolean *feasible , ddf_boolean *weaklyfeasible ) ;
#line 274
void ddf_UpdateEdges(ddf_ConePtr cone , ddf_RayPtr RRbegin , ddf_RayPtr RRend ) ;
#line 275
void ddf_UpdateRowOrderVector(ddf_ConePtr cone , ddf_rowset PriorityRows ) ;
#line 278
void ddf_ZeroIndexSet(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                      myfloat *x , ddf_rowset ZS ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m  =    (ddf_rowrange )0;
#line 22 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_CheckAdjacency(ddf_ConePtr cone , ddf_RayPtr *RP1 , ddf_RayPtr *RP2 , ddf_boolean *adjacent ) 
{ 
  ddf_RayPtr TempRay ;
  ddf_boolean localdebug ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 26
  localdebug = 0;
#line 30
  if (last_m != cone->m) {
#line 31
    if (last_m > 0L) {
      {
#line 32
      set_free(Face);
#line 32
      set_free(Face1);
      }
    }
    {
#line 34
    set_initialize(& Face, cone->m);
#line 35
    set_initialize(& Face1, cone->m);
#line 36
    last_m = cone->m;
    }
  }
#line 39
  if (ddf_debug) {
#line 39
    localdebug = 1;
  }
  {
#line 40
  *adjacent = 1;
#line 41
  set_int(Face1, (*RP1)->ZeroSet, (*RP2)->ZeroSet);
#line 42
  set_int(Face, Face1, cone->AddedHalfspaces);
#line 43
  tmp___0 = set_card(Face);
  }
#line 43
  if (tmp___0 < cone->d - 2L) {
#line 44
    *adjacent = 0;
#line 45
    if (localdebug) {
      {
#line 46
      tmp = set_card(Face);
#line 46
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"non adjacent: set_card(face) %ld < %ld = cone->d.\n",
              tmp, cone->d);
      }
    }
#line 49
    return;
  } else
#line 51
  if ((cone->parent)->NondegAssumed) {
#line 52
    *adjacent = 1;
#line 53
    return;
  }
#line 55
  TempRay = cone->FirstRay;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if ((unsigned long )TempRay != (unsigned long )((void *)0)) {
#line 56
      if (! *adjacent) {
#line 56
        goto while_break;
      }
    } else {
#line 56
      goto while_break;
    }
#line 57
    if ((unsigned long )TempRay != (unsigned long )*RP1) {
#line 57
      if ((unsigned long )TempRay != (unsigned long )*RP2) {
        {
#line 58
        set_int(Face1, TempRay->ZeroSet, cone->AddedHalfspaces);
#line 59
        tmp___1 = set_subset(Face, Face1);
        }
#line 59
        if (tmp___1) {
#line 59
          *adjacent = 0;
        }
      }
    }
#line 61
    TempRay = TempRay->Next;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_Eliminate(ddf_ConePtr cone , ddf_RayPtr *Ptr ) 
{ 
  ddf_RayPtr TempPtr ;
  ddf_colrange j ;

  {
#line 71
  TempPtr = (*Ptr)->Next;
#line 72
  (*Ptr)->Next = ((*Ptr)->Next)->Next;
#line 73
  if ((unsigned long )TempPtr == (unsigned long )cone->FirstRay) {
#line 74
    cone->FirstRay = (*Ptr)->Next;
  }
#line 75
  if ((unsigned long )TempPtr == (unsigned long )cone->LastRay) {
#line 76
    cone->LastRay = *Ptr;
  }
#line 79
  j = (ddf_colrange )0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (j < cone->d)) {
#line 79
      goto while_break;
    }
    {
#line 80
    dddf_clear((double *)(*(TempPtr->Ray + j)));
#line 79
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  dddf_clear((double *)(TempPtr->ARay));
#line 83
  free((void *)TempPtr->Ray);
#line 84
  set_free(TempPtr->ZeroSet);
#line 85
  free((void *)TempPtr);
#line 86
  (cone->RayCount) --;
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_SetInequalitySets(ddf_ConePtr cone ) 
{ 
  ddf_rowrange i ;

  {
  {
#line 93
  set_emptyset(cone->GroundSet);
#line 94
  set_emptyset(cone->EqualitySet);
#line 95
  set_emptyset(cone->NonequalitySet);
#line 96
  i = (ddf_rowrange )1;
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (i <= (cone->parent)->m)) {
#line 96
      goto while_break;
    }
    {
#line 97
    set_addelem(cone->GroundSet, i);
    }
#line 98
    if (*((cone->parent)->EqualityIndex + i) == 1) {
      {
#line 98
      set_addelem(cone->EqualitySet, i);
      }
    }
#line 99
    if (*((cone->parent)->EqualityIndex + i) == -1) {
      {
#line 99
      set_addelem(cone->NonequalitySet, i);
      }
    }
#line 96
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_AValue(myfloat *val , ddf_colrange d_size , ddf_Amatrix A , myfloat *p ,
                ddf_rowrange i ) 
{ 
  ddf_colrange j ;
  myfloat x ;

  {
  {
#line 110
  dddf_init((double *)(x));
#line 111
  dddf_set((double *)(*val), (double *)(ddf_purezero));
#line 114
  j = (ddf_colrange )0;
  }
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (j < d_size)) {
#line 114
      goto while_break;
    }
    {
#line 115
    dddf_mul((double *)(x), (double *)(*(*(A + (i - 1L)) + j)), (double *)(*(p + j)));
#line 116
    dddf_add((double *)(*val), (double *)(*val), (double *)(x));
#line 114
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  dddf_clear((double *)(x));
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_StoreRay1(ddf_ConePtr cone , myfloat *p , ddf_boolean *feasible ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange k ;
  ddf_rowrange fii ;
  ddf_colrange j ;
  myfloat temp ;
  ddf_RayPtr RR ;
  ddf_boolean localdebug ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;

  {
  {
#line 123
  fii = cone->m + 1L;
#line 127
  localdebug = ddf_debug;
#line 129
  dddf_init((double *)(temp));
#line 130
  RR = cone->LastRay;
#line 131
  *feasible = 1;
#line 132
  set_initialize(& RR->ZeroSet, cone->m);
#line 133
  j = (ddf_colrange )0;
  }
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (j < cone->d)) {
#line 133
      goto while_break;
    }
    {
#line 134
    dddf_set((double *)(*(RR->Ray + j)), (double *)(*(p + j)));
#line 133
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  i = (ddf_rowrange )1;
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    if (! (i <= cone->m)) {
#line 136
      goto while_break___0;
    }
    {
#line 137
    k = *(cone->OrderVector + i);
#line 138
    ddf_AValue(& temp, cone->d, cone->A, p, k);
    }
#line 139
    if (localdebug) {
      {
#line 140
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_StoreRay1: ddf_AValue at row %ld =",
              k);
#line 141
      ddf_WriteNumber(stderr, (double *)(temp));
#line 142
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
    {
#line 144
    tmp = ddf_EqualToZero((double *)(temp));
    }
#line 144
    if (tmp) {
      {
#line 145
      set_addelem(RR->ZeroSet, k);
      }
#line 146
      if (localdebug) {
        {
#line 147
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"recognized zero!\n");
        }
      }
    }
    {
#line 150
    tmp___0 = ddf_Negative((double *)(temp));
    }
#line 150
    if (tmp___0) {
#line 151
      if (localdebug) {
        {
#line 152
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"recognized negative!\n");
        }
      }
#line 154
      *feasible = 0;
#line 155
      if (fii > cone->m) {
#line 155
        fii = i;
      }
#line 156
      if (localdebug) {
        {
#line 157
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"this ray is not feasible, neg comp = %ld\n",
                fii);
#line 158
        ddf_WriteNumber(stderr, (double *)(temp));
#line 158
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
    }
#line 136
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 162
  RR->FirstInfeasIndex = fii;
#line 163
  RR->feasible = *feasible;
#line 164
  dddf_clear((double *)(temp));
  }
#line 165
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_StoreRay2(ddf_ConePtr cone , myfloat *p , ddf_boolean *feasible , ddf_boolean *weaklyfeasible ) 
{ 
  ddf_RayPtr RR ;
  ddf_rowrange i ;
  ddf_rowrange k ;
  ddf_rowrange fii ;
  ddf_colrange j ;
  myfloat temp ;
  ddf_boolean localdebug ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;

  {
  {
#line 174
  fii = cone->m + 1L;
#line 177
  localdebug = ddf_debug;
#line 179
  dddf_init((double *)(temp));
#line 180
  RR = cone->LastRay;
  }
#line 181
  if (ddf_debug) {
#line 181
    localdebug = 1;
  }
  {
#line 182
  *feasible = 1;
#line 183
  *weaklyfeasible = 1;
#line 184
  set_initialize(& RR->ZeroSet, cone->m);
#line 185
  j = (ddf_colrange )0;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (j < cone->d)) {
#line 185
      goto while_break;
    }
    {
#line 186
    dddf_set((double *)(*(RR->Ray + j)), (double *)(*(p + j)));
#line 185
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  i = (ddf_rowrange )1;
  {
#line 188
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 188
    if (! (i <= cone->m)) {
#line 188
      goto while_break___0;
    }
    {
#line 189
    k = *(cone->OrderVector + i);
#line 190
    ddf_AValue(& temp, cone->d, cone->A, p, k);
#line 191
    tmp = ddf_EqualToZero((double *)(temp));
    }
#line 191
    if (tmp) {
      {
#line 192
      set_addelem(RR->ZeroSet, k);
      }
#line 193
      if (*((cone->parent)->EqualityIndex + k) == -1) {
#line 194
        *feasible = 0;
      }
    }
    {
#line 197
    tmp___0 = ddf_Negative((double *)(temp));
    }
#line 197
    if (tmp___0) {
#line 198
      *feasible = 0;
#line 199
      if (fii > cone->m) {
#line 199
        if (*((cone->parent)->EqualityIndex + k) >= 0) {
#line 200
          fii = i;
#line 201
          *weaklyfeasible = 0;
        }
      }
    }
#line 188
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 205
  RR->FirstInfeasIndex = fii;
#line 206
  RR->feasible = *feasible;
#line 207
  dddf_clear((double *)(temp));
  }
#line 208
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_AddRay(ddf_ConePtr cone , myfloat *p ) 
{ 
  ddf_boolean feasible ;
  ddf_boolean weaklyfeasible ;
  ddf_colrange j ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 216
  if ((unsigned long )cone->FirstRay == (unsigned long )((void *)0)) {
    {
#line 217
    tmp = malloc(sizeof(ddf_RayType ));
#line 217
    cone->FirstRay = (ddf_RayPtr )tmp;
#line 218
    tmp___0 = calloc((size_t )cone->d, sizeof(myfloat ));
#line 218
    (cone->FirstRay)->Ray = (myfloat *)tmp___0;
#line 219
    j = (ddf_colrange )0;
    }
    {
#line 219
    while (1) {
      while_continue: /* CIL Label */ ;
#line 219
      if (! (j < cone->d)) {
#line 219
        goto while_break;
      }
      {
#line 219
      dddf_init((double *)(*((cone->FirstRay)->Ray + j)));
#line 219
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 220
    dddf_init((double *)((cone->FirstRay)->ARay));
    }
#line 221
    if (ddf_debug) {
      {
#line 222
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Create the first ray pointer\n");
      }
    }
#line 223
    cone->LastRay = cone->FirstRay;
#line 224
    (cone->ArtificialRay)->Next = cone->FirstRay;
  } else {
    {
#line 226
    tmp___1 = malloc(sizeof(ddf_RayType ));
#line 226
    (cone->LastRay)->Next = (ddf_RayPtr )tmp___1;
#line 227
    tmp___2 = calloc((size_t )cone->d, sizeof(myfloat ));
#line 227
    ((cone->LastRay)->Next)->Ray = (myfloat *)tmp___2;
#line 228
    j = (ddf_colrange )0;
    }
    {
#line 228
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 228
      if (! (j < cone->d)) {
#line 228
        goto while_break___0;
      }
      {
#line 228
      dddf_init((double *)(*(((cone->LastRay)->Next)->Ray + j)));
#line 228
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 229
    dddf_init((double *)(((cone->LastRay)->Next)->ARay));
    }
#line 230
    if (ddf_debug) {
      {
#line 230
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Create a new ray pointer\n");
      }
    }
#line 231
    cone->LastRay = (cone->LastRay)->Next;
  }
#line 233
  (cone->LastRay)->Next = (ddf_RayPtr )((void *)0);
#line 234
  (cone->RayCount) ++;
#line 235
  (cone->TotalRayCount) ++;
#line 236
  if (ddf_debug) {
#line 237
    if (cone->TotalRayCount % 100L == 0L) {
      {
#line 238
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*Rays (Total, Currently Active, Feasible) =%8ld%8ld%8ld\n",
              cone->TotalRayCount, cone->RayCount, cone->FeasibleRayCount);
      }
    }
  }
#line 242
  if ((cone->parent)->RelaxedEnumeration) {
    {
#line 243
    ddf_StoreRay2(cone, p, & feasible, & weaklyfeasible);
    }
#line 244
    if (weaklyfeasible) {
#line 244
      (cone->WeaklyFeasibleRayCount) ++;
    }
  } else {
    {
#line 246
    ddf_StoreRay1(cone, p, & feasible);
    }
#line 247
    if (feasible) {
#line 247
      (cone->WeaklyFeasibleRayCount) ++;
    }
  }
#line 250
  if (! feasible) {
#line 250
    return;
  } else {
#line 252
    (cone->FeasibleRayCount) ++;
  }
#line 254
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_AddArtificialRay(ddf_ConePtr cone ) 
{ 
  ddf_Arow zerovector ;
  ddf_colrange j ;
  ddf_colrange d1 ;
  ddf_boolean feasible ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 262
  if (cone->d <= 0L) {
#line 262
    d1 = (ddf_colrange )1;
  } else {
#line 262
    d1 = cone->d;
  }
  {
#line 263
  ddf_InitializeArow(d1, & zerovector);
  }
#line 264
  if ((unsigned long )cone->ArtificialRay != (unsigned long )((void *)0)) {
    {
#line 265
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning !!!  FirstRay in not nil.  Illegal Call\n");
#line 266
    free((void *)zerovector);
    }
#line 267
    return;
  }
  {
#line 269
  tmp = malloc(sizeof(ddf_RayType ));
#line 269
  cone->ArtificialRay = (ddf_RayPtr )tmp;
#line 270
  tmp___0 = calloc((size_t )d1, sizeof(myfloat ));
#line 270
  (cone->ArtificialRay)->Ray = (myfloat *)tmp___0;
#line 271
  j = (ddf_colrange )0;
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! (j < d1)) {
#line 271
      goto while_break;
    }
    {
#line 271
    dddf_init((double *)(*((cone->ArtificialRay)->Ray + j)));
#line 271
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  dddf_init((double *)((cone->ArtificialRay)->ARay));
  }
#line 274
  if (ddf_debug) {
    {
#line 274
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Create the artificial ray pointer\n");
    }
  }
  {
#line 276
  cone->LastRay = cone->ArtificialRay;
#line 277
  ddf_StoreRay1(cone, zerovector, & feasible);
#line 279
  (cone->ArtificialRay)->Next = (ddf_RayPtr )((void *)0);
#line 280
  j = (ddf_colrange )0;
  }
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 280
    if (! (j < d1)) {
#line 280
      goto while_break___0;
    }
    {
#line 281
    dddf_clear((double *)(*(zerovector + j)));
#line 280
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 283
  free((void *)zerovector);
  }
#line 284
  return;
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___0  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___0  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___0  =    (ddf_rowrange )0;
#line 286 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_ConditionalAddEdge(ddf_ConePtr cone , ddf_RayPtr Ray1 , ddf_RayPtr Ray2 ,
                            ddf_RayPtr ValidFirstRay ) 
{ 
  long it ;
  long it_row ;
  long fii1 ;
  long fii2 ;
  long fmin___0 ;
  long fmax___0 ;
  ddf_boolean adjacent ;
  ddf_boolean lastchance ;
  ddf_RayPtr TempRay ;
  ddf_RayPtr Rmin ;
  ddf_RayPtr Rmax ;
  ddf_AdjacencyType *NewEdge ;
  ddf_boolean localdebug ;
  ddf_rowset ZSmin ;
  ddf_rowset ZSmax ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 293
  localdebug = 0;
#line 298
  if (last_m___0 != cone->m) {
#line 299
    if (last_m___0 > 0L) {
      {
#line 300
      set_free(Face___0);
#line 300
      set_free(Face1___0);
      }
    }
    {
#line 302
    set_initialize(& Face___0, cone->m);
#line 303
    set_initialize(& Face1___0, cone->m);
#line 304
    last_m___0 = cone->m;
    }
  }
#line 307
  fii1 = Ray1->FirstInfeasIndex;
#line 308
  fii2 = Ray2->FirstInfeasIndex;
#line 309
  if (fii1 < fii2) {
#line 310
    fmin___0 = fii1;
#line 310
    fmax___0 = fii2;
#line 311
    Rmin = Ray1;
#line 312
    Rmax = Ray2;
  } else {
#line 315
    fmin___0 = fii2;
#line 315
    fmax___0 = fii1;
#line 316
    Rmin = Ray2;
#line 317
    Rmax = Ray1;
  }
#line 319
  ZSmin = Rmin->ZeroSet;
#line 320
  ZSmax = Rmax->ZeroSet;
#line 321
  if (localdebug) {
    {
#line 322
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_ConditionalAddEdge: FMIN = %ld (row%ld)   FMAX=%ld\n",
            fmin___0, *(cone->OrderVector + fmin___0), fmax___0);
    }
  }
#line 325
  if (fmin___0 == fmax___0) {
#line 326
    if (localdebug) {
      {
#line 326
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_ConditionalAddEdge: equal FII value-> No edge added\n");
      }
    }
  } else {
    {
#line 328
    tmp___5 = set_member(*(cone->OrderVector + fmin___0), ZSmax);
    }
#line 328
    if (tmp___5) {
#line 329
      if (localdebug) {
        {
#line 329
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_ConditionalAddEdge: No strong separation -> No edge added\n");
        }
      }
    } else {
      {
#line 332
      lastchance = 1;
#line 334
      set_int(Face1___0, ZSmax, ZSmin);
#line 335
      (cone->count_int) ++;
      }
#line 336
      if (localdebug) {
        {
#line 337
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Face: ");
#line 338
        it = 1L;
        }
        {
#line 338
        while (1) {
          while_continue: /* CIL Label */ ;
#line 338
          if (! (it <= cone->m)) {
#line 338
            goto while_break;
          }
          {
#line 339
          it_row = *(cone->OrderVector + it);
#line 340
          tmp = set_member(it_row, Face1___0);
          }
#line 340
          if (tmp) {
            {
#line 340
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld ",
                    it_row);
            }
          }
#line 338
          it ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 342
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 344
      it = cone->Iteration + 1L;
      {
#line 344
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 344
        if (it < fmin___0) {
#line 344
          if (! lastchance) {
#line 344
            goto while_break___0;
          }
        } else {
#line 344
          goto while_break___0;
        }
#line 345
        it_row = *(cone->OrderVector + it);
#line 346
        if (*((cone->parent)->EqualityIndex + it_row) >= 0) {
          {
#line 346
          tmp___0 = set_member(it_row, Face1___0);
          }
#line 346
          if (tmp___0) {
#line 347
            lastchance = 0;
#line 348
            (cone->count_int_bad) ++;
#line 349
            if (localdebug) {
              {
#line 350
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"There will be another chance iteration %ld (row %ld) to store the pair\n",
                      it, it_row);
              }
            }
          }
        }
#line 344
        it ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 354
      if (lastchance) {
        {
#line 355
        adjacent = 1;
#line 356
        (cone->count_int_good) ++;
#line 358
        set_int(Face___0, Face1___0, cone->AddedHalfspaces);
        }
#line 359
        if (localdebug) {
          {
#line 360
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Check adjacency\n");
#line 361
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AddedHalfspaces: ");
#line 361
          set_fwrite(stderr, cone->AddedHalfspaces);
#line 362
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Face: ");
#line 363
          it = 1L;
          }
          {
#line 363
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 363
            if (! (it <= cone->m)) {
#line 363
              goto while_break___1;
            }
            {
#line 364
            it_row = *(cone->OrderVector + it);
#line 365
            tmp___1 = set_member(it_row, Face___0);
            }
#line 365
            if (tmp___1) {
              {
#line 365
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld ",
                      it_row);
              }
            }
#line 363
            it ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 367
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
          }
        }
        {
#line 369
        tmp___3 = set_card(Face___0);
        }
#line 369
        if (tmp___3 < cone->d - 2L) {
#line 370
          adjacent = 0;
        } else
#line 372
        if ((cone->parent)->NondegAssumed) {
#line 373
          adjacent = 1;
        } else {
#line 376
          TempRay = ValidFirstRay;
          {
#line 377
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 377
            if ((unsigned long )TempRay != (unsigned long )((void *)0)) {
#line 377
              if (! adjacent) {
#line 377
                goto while_break___2;
              }
            } else {
#line 377
              goto while_break___2;
            }
#line 378
            if ((unsigned long )TempRay != (unsigned long )Ray1) {
#line 378
              if ((unsigned long )TempRay != (unsigned long )Ray2) {
                {
#line 379
                set_int(Face1___0, TempRay->ZeroSet, cone->AddedHalfspaces);
#line 380
                tmp___2 = set_subset(Face___0, Face1___0);
                }
#line 380
                if (tmp___2) {
#line 381
                  if (localdebug) {
                    {
#line 381
                    set_fwrite(stderr, Face1___0);
                    }
                  }
#line 382
                  adjacent = 0;
                }
              }
            }
#line 385
            TempRay = TempRay->Next;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 388
        if (adjacent) {
#line 389
          if (localdebug) {
            {
#line 389
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The pair is adjacent and the pair must be stored for iteration %ld (row%ld)\n",
                    fmin___0, *(cone->OrderVector + fmin___0));
            }
          }
          {
#line 391
          tmp___4 = malloc(sizeof(*NewEdge));
#line 391
          NewEdge = (ddf_AdjacencyPtr )tmp___4;
#line 392
          NewEdge->Ray1 = Rmax;
#line 393
          NewEdge->Ray2 = Rmin;
#line 394
          NewEdge->Next = (ddf_AdjacencyPtr )((void *)0);
#line 395
          (cone->EdgeCount) ++;
#line 396
          (cone->TotalEdgeCount) ++;
          }
#line 397
          if ((unsigned long )*(cone->Edges + fmin___0) == (unsigned long )((void *)0)) {
#line 398
            *(cone->Edges + fmin___0) = NewEdge;
#line 399
            if (localdebug) {
              {
#line 399
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Create a new edge list of %ld\n",
                      fmin___0);
              }
            }
          } else {
#line 401
            NewEdge->Next = *(cone->Edges + fmin___0);
#line 402
            *(cone->Edges + fmin___0) = NewEdge;
          }
        }
      }
    }
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_CreateInitialEdges(ddf_ConePtr cone ) 
{ 
  ddf_RayPtr Ptr1 ;
  ddf_RayPtr Ptr2 ;
  ddf_rowrange fii1 ;
  ddf_rowrange fii2 ;
  long count ;
  ddf_boolean adj ;
  ddf_boolean localdebug ;

  {
#line 413
  count = 0L;
#line 414
  localdebug = 0;
#line 416
  cone->Iteration = cone->d;
#line 417
  if ((unsigned long )cone->FirstRay == (unsigned long )((void *)0)) {
#line 419
    goto _L99;
  } else
#line 417
  if ((unsigned long )cone->LastRay == (unsigned long )((void *)0)) {
#line 419
    goto _L99;
  }
#line 421
  Ptr1 = cone->FirstRay;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if ((unsigned long )Ptr1 != (unsigned long )cone->LastRay) {
#line 422
      if (! ((unsigned long )Ptr1 != (unsigned long )((void *)0))) {
#line 422
        goto while_break;
      }
    } else {
#line 422
      goto while_break;
    }
#line 423
    fii1 = Ptr1->FirstInfeasIndex;
#line 424
    Ptr2 = Ptr1->Next;
    {
#line 425
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 425
      if (! ((unsigned long )Ptr2 != (unsigned long )((void *)0))) {
#line 425
        goto while_break___0;
      }
#line 426
      fii2 = Ptr2->FirstInfeasIndex;
#line 427
      count ++;
#line 428
      if (localdebug) {
        {
#line 428
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_ CreateInitialEdges: edge %ld \n",
                count);
        }
      }
      {
#line 429
      ddf_CheckAdjacency(cone, & Ptr1, & Ptr2, & adj);
      }
#line 430
      if (fii1 != fii2) {
#line 430
        if (adj) {
          {
#line 431
          ddf_ConditionalAddEdge(cone, Ptr1, Ptr2, cone->FirstRay);
          }
        }
      }
#line 432
      Ptr2 = Ptr2->Next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 434
    Ptr1 = Ptr1->Next;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 437
  return;
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_UpdateEdges(ddf_ConePtr cone , ddf_RayPtr RRbegin , ddf_RayPtr RRend ) 
{ 
  ddf_RayPtr Ptr1 ;
  ddf_RayPtr Ptr2begin ;
  ddf_RayPtr Ptr2 ;
  ddf_rowrange fii1 ;
  ddf_boolean ptr2found ;
  ddf_boolean quit ;
  ddf_boolean localdebug ;
  long count ;
  long pos1 ;
  long pos2 ;
  float workleft ;
  float prevworkleft ;
  float totalpairs ;

  {
#line 448
  localdebug = 0;
#line 449
  count = 0L;
#line 450
  prevworkleft = (float )110.0;
#line 452
  totalpairs = (float )(((double )cone->ZeroRayCount - 1.0) * ((double )cone->ZeroRayCount - 2.0) + 1.0);
#line 453
  Ptr2begin = (ddf_RayPtr )((void *)0);
#line 454
  if ((unsigned long )RRbegin == (unsigned long )((void *)0)) {
    {
#line 455
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: ddf_UpdateEdges called with NULL pointer(s)\n");
    }
#line 456
    goto _L99;
  } else
#line 454
  if ((unsigned long )RRend == (unsigned long )((void *)0)) {
    {
#line 455
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: ddf_UpdateEdges called with NULL pointer(s)\n");
    }
#line 456
    goto _L99;
  }
#line 458
  Ptr1 = RRbegin;
#line 459
  pos1 = 1L;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    ptr2found = 0;
#line 462
    quit = 0;
#line 463
    fii1 = Ptr1->FirstInfeasIndex;
#line 464
    pos2 = 2L;
#line 465
    Ptr2 = Ptr1->Next;
    {
#line 465
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 465
      if (! ptr2found) {
#line 465
        if (! (! quit)) {
#line 465
          goto while_break___0;
        }
      } else {
#line 465
        goto while_break___0;
      }
#line 466
      if (Ptr2->FirstInfeasIndex > fii1) {
#line 467
        Ptr2begin = Ptr2;
#line 468
        ptr2found = 1;
      } else
#line 470
      if ((unsigned long )Ptr2 == (unsigned long )RRend) {
#line 470
        quit = 1;
      }
#line 465
      Ptr2 = Ptr2->Next;
#line 465
      pos2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 472
    if (ptr2found) {
#line 473
      quit = 0;
#line 474
      Ptr2 = Ptr2begin;
      {
#line 474
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 474
        if (! (! quit)) {
#line 474
          goto while_break___1;
        }
#line 475
        count ++;
#line 476
        if (localdebug) {
          {
#line 476
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_UpdateEdges: edge %ld \n",
                  count);
          }
        }
        {
#line 477
        ddf_ConditionalAddEdge(cone, Ptr1, Ptr2, RRbegin);
        }
#line 478
        if ((unsigned long )Ptr2 == (unsigned long )RRend) {
#line 478
          quit = 1;
        } else
#line 478
        if ((unsigned long )Ptr2->Next == (unsigned long )((void *)0)) {
#line 478
          quit = 1;
        }
#line 474
        Ptr2 = Ptr2->Next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 481
    Ptr1 = Ptr1->Next;
#line 482
    pos1 ++;
#line 483
    workleft = (float )(((100.0 * (double )(cone->ZeroRayCount - pos1)) * ((double )(cone->ZeroRayCount - pos1) - 1.0)) / (double )totalpairs);
#line 484
    if (cone->ZeroRayCount >= 500L) {
#line 484
      if (ddf_debug) {
#line 484
        if (pos1 % 10L == 0L) {
#line 484
          if (prevworkleft - workleft >= (float )10) {
            {
#line 485
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*Work of iteration %5ld(/%ld): %4ld/%4ld => %4.1f%% left\n",
                    cone->Iteration, cone->m, pos1, cone->ZeroRayCount, (double )workleft);
#line 487
            prevworkleft = workleft;
            }
          }
        }
      }
    }
#line 460
    if ((unsigned long )Ptr1 != (unsigned long )RRend) {
#line 460
      if (! ((unsigned long )Ptr1 != (unsigned long )((void *)0))) {
#line 460
        goto while_break;
      }
    } else {
#line 460
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 491
  return;
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_FreeDDMemory0(ddf_ConePtr cone ) 
{ 
  ddf_RayPtr Ptr ;
  ddf_RayPtr PrevPtr ;
  long count ;
  ddf_colrange j ;
  ddf_boolean localdebug ;

  {
#line 498
  localdebug = 0;
#line 501
  PrevPtr = cone->ArtificialRay;
#line 502
  if ((unsigned long )PrevPtr != (unsigned long )((void *)0)) {
#line 503
    count = 0L;
#line 504
    Ptr = (cone->ArtificialRay)->Next;
    {
#line 504
    while (1) {
      while_continue: /* CIL Label */ ;
#line 504
      if (! ((unsigned long )Ptr != (unsigned long )((void *)0))) {
#line 504
        goto while_break;
      }
#line 506
      j = (ddf_colrange )0;
      {
#line 506
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 506
        if (! (j < cone->d)) {
#line 506
          goto while_break___0;
        }
        {
#line 507
        dddf_clear((double *)(*(PrevPtr->Ray + j)));
#line 506
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 508
      dddf_clear((double *)(PrevPtr->ARay));
#line 510
      free((void *)PrevPtr->Ray);
#line 511
      free((void *)PrevPtr->ZeroSet);
#line 512
      free((void *)PrevPtr);
#line 513
      count ++;
#line 514
      PrevPtr = Ptr;
#line 504
      Ptr = Ptr->Next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 516
    cone->FirstRay = (ddf_RayPtr )((void *)0);
#line 518
    j = (ddf_colrange )0;
    {
#line 518
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 518
      if (! (j < cone->d)) {
#line 518
        goto while_break___1;
      }
      {
#line 519
      dddf_clear((double *)(*((cone->LastRay)->Ray + j)));
#line 518
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 520
    dddf_clear((double *)((cone->LastRay)->ARay));
#line 522
    free((void *)(cone->LastRay)->Ray);
#line 523
    (cone->LastRay)->Ray = (myfloat *)((void *)0);
#line 524
    set_free((cone->LastRay)->ZeroSet);
#line 525
    (cone->LastRay)->ZeroSet = (ddf_rowset )((void *)0);
#line 526
    free((void *)cone->LastRay);
#line 527
    cone->LastRay = (ddf_RayPtr )((void *)0);
#line 528
    cone->ArtificialRay = (ddf_RayPtr )((void *)0);
    }
#line 529
    if (localdebug) {
      {
#line 529
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld ray storage spaces freed\n",
              count);
      }
    }
  }
  {
#line 532
  free((void *)cone->Edges);
#line 534
  set_free(cone->GroundSet);
#line 535
  set_free(cone->EqualitySet);
#line 536
  set_free(cone->NonequalitySet);
#line 537
  set_free(cone->AddedHalfspaces);
#line 538
  set_free(cone->WeaklyAddedHalfspaces);
#line 539
  set_free(cone->InitialHalfspaces);
#line 540
  free((void *)cone->InitialRayIndex);
#line 541
  free((void *)cone->OrderVector);
#line 542
  free((void *)cone->newcol);
#line 545
  ddf_FreeBmatrix(cone->d_alloc, cone->B);
#line 546
  ddf_FreeBmatrix(cone->d_alloc, cone->Bsave);
#line 549
  ddf_FreeAmatrix(cone->m_alloc, cone->d_alloc, cone->A);
#line 550
  cone->A = (ddf_Amatrix )((void *)0);
#line 552
  free((void *)cone);
  }
#line 553
  return;
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_FreeDDMemory(ddf_PolyhedraPtr poly ) 
{ 


  {
  {
#line 557
  ddf_FreeDDMemory0(poly->child);
#line 558
  poly->child = (ddf_ConePtr )((void *)0);
  }
#line 559
  return;
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_FreePolyhedra(ddf_PolyhedraPtr poly ) 
{ 
  ddf_bigrange i ;

  {
#line 565
  if ((unsigned long )poly->child != (unsigned long )((void *)0)) {
    {
#line 565
    ddf_FreeDDMemory(poly);
    }
  }
  {
#line 566
  ddf_FreeAmatrix(poly->m_alloc, poly->d_alloc, poly->A);
#line 567
  ddf_FreeArow(poly->d_alloc, poly->c);
#line 568
  free((void *)poly->EqualityIndex);
  }
#line 569
  if (poly->AincGenerated) {
#line 570
    i = (ddf_bigrange )1;
    {
#line 570
    while (1) {
      while_continue: /* CIL Label */ ;
#line 570
      if (! (i <= poly->m1)) {
#line 570
        goto while_break;
      }
      {
#line 571
      set_free(*(poly->Ainc + (i - 1L)));
#line 570
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 573
    free((void *)poly->Ainc);
#line 574
    set_free(poly->Ared);
#line 575
    set_free(poly->Adom);
#line 576
    poly->Ainc = (ddf_Aincidence )((void *)0);
    }
  }
  {
#line 579
  free((void *)poly);
  }
#line 580
  return;
}
}
#line 582 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_Normalize(ddf_colrange d_size , myfloat *V ) 
{ 
  long j ;
  long jmin ;
  myfloat temp ;
  myfloat min ;
  ddf_boolean nonzerofound ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;
  ddf_boolean tmp___1 ;
  ddf_boolean tmp___2 ;

  {
#line 584
  jmin = 0L;
#line 586
  nonzerofound = 0;
#line 588
  if (d_size > 0L) {
    {
#line 589
    dddf_init((double *)(min));
#line 589
    dddf_init((double *)(temp));
#line 590
    ddf_abs((double *)(min), (double *)(*(V + 0)));
#line 590
    jmin = 0L;
#line 591
    tmp = ddf_Positive((double *)(min));
    }
#line 591
    if (tmp) {
#line 591
      nonzerofound = 1;
    }
#line 592
    j = 1L;
    {
#line 592
    while (1) {
      while_continue: /* CIL Label */ ;
#line 592
      if (! (j < d_size)) {
#line 592
        goto while_break;
      }
      {
#line 593
      ddf_abs((double *)(temp), (double *)(*(V + j)));
#line 594
      tmp___1 = ddf_Positive((double *)(temp));
      }
#line 594
      if (tmp___1) {
#line 595
        if (! nonzerofound) {
          {
#line 596
          nonzerofound = 1;
#line 597
          dddf_set((double *)(min), (double *)(temp));
#line 597
          jmin = j;
          }
        } else {
          {
#line 595
          tmp___0 = ddf_Smaller((double *)(temp), (double *)(min));
          }
#line 595
          if (tmp___0) {
            {
#line 596
            nonzerofound = 1;
#line 597
            dddf_set((double *)(min), (double *)(temp));
#line 597
            jmin = j;
            }
          }
        }
      }
#line 592
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 601
    tmp___2 = ddf_Positive((double *)(min));
    }
#line 601
    if (tmp___2) {
#line 602
      j = 0L;
      {
#line 602
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 602
        if (! (j < d_size)) {
#line 602
          goto while_break___0;
        }
        {
#line 602
        dddf_div((double *)(*(V + j)), (double *)(*(V + j)), (double *)(min));
#line 602
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 604
    dddf_clear((double *)(min));
#line 604
    dddf_clear((double *)(temp));
    }
  }
#line 606
  return;
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_ZeroIndexSet(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                      myfloat *x , ddf_rowset ZS ) 
{ 
  ddf_rowrange i ;
  myfloat temp ;
  ddf_boolean tmp ;

  {
  {
#line 615
  dddf_init((double *)(temp));
#line 616
  set_emptyset(ZS);
#line 617
  i = (ddf_rowrange )1;
  }
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! (i <= m_size)) {
#line 617
      goto while_break;
    }
    {
#line 618
    ddf_AValue(& temp, d_size, A, x, i);
#line 619
    tmp = ddf_EqualToZero((double *)(temp));
    }
#line 619
    if (tmp) {
      {
#line 619
      set_addelem(ZS, i);
      }
    }
#line 617
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 623
  dddf_clear((double *)(temp));
  }
#line 624
  return;
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_CopyBmatrix(ddf_colrange d_size , ddf_Bmatrix T , ddf_Bmatrix TCOPY ) 
{ 
  ddf_rowrange i ;
  ddf_colrange j ;

  {
#line 631
  i = (ddf_rowrange )0;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! (i < d_size)) {
#line 631
      goto while_break;
    }
#line 632
    j = (ddf_colrange )0;
    {
#line 632
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 632
      if (! (j < d_size)) {
#line 632
        goto while_break___0;
      }
      {
#line 633
      dddf_set((double *)(*(*(TCOPY + i) + j)), (double *)(*(*(T + i) + j)));
#line 632
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 631
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  return;
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_CopyArow(myfloat *acopy , myfloat *a___41 , ddf_colrange d ) 
{ 
  ddf_colrange j ;

  {
#line 643
  j = (ddf_colrange )0;
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    if (! (j < d)) {
#line 643
      goto while_break;
    }
    {
#line 644
    dddf_set((double *)(*(acopy + j)), (double *)(*(a___41 + j)));
#line 643
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 646
  return;
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_CopyNormalizedArow(myfloat *acopy , myfloat *a___41 , ddf_colrange d ) 
{ 


  {
  {
#line 650
  ddf_CopyArow(acopy, a___41, d);
#line 651
  ddf_Normalize(d, acopy);
  }
#line 652
  return;
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_CopyAmatrix(myfloat **Acopy , myfloat **A , ddf_rowrange m , ddf_colrange d ) 
{ 
  ddf_rowrange i ;

  {
#line 658
  i = (ddf_rowrange )0;
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! (i < m)) {
#line 658
      goto while_break;
    }
    {
#line 659
    ddf_CopyArow(*(Acopy + i), *(A + i), d);
#line 658
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 661
  return;
}
}
#line 663 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_CopyNormalizedAmatrix(myfloat **Acopy , myfloat **A , ddf_rowrange m , ddf_colrange d ) 
{ 
  ddf_rowrange i ;

  {
#line 667
  i = (ddf_rowrange )0;
  {
#line 667
  while (1) {
    while_continue: /* CIL Label */ ;
#line 667
    if (! (i < m)) {
#line 667
      goto while_break;
    }
    {
#line 668
    ddf_CopyNormalizedArow(*(Acopy + i), *(A + i), d);
#line 667
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 670
  return;
}
}
#line 672 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_PermuteCopyAmatrix(myfloat **Acopy , myfloat **A , ddf_rowrange m , ddf_colrange d ,
                            ddf_rowindex roworder ) 
{ 
  ddf_rowrange i ;

  {
#line 676
  i = (ddf_rowrange )1;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! (i <= m)) {
#line 676
      goto while_break;
    }
    {
#line 677
    ddf_CopyArow(*(Acopy + (i - 1L)), *(A + (*(roworder + i) - 1L)), d);
#line 676
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 679
  return;
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_PermutePartialCopyAmatrix(myfloat **Acopy , myfloat **A , ddf_rowrange m ,
                                   ddf_colrange d , ddf_rowindex roworder , ddf_rowrange p ,
                                   ddf_rowrange q ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange k ;

  {
#line 686
  k = (ddf_rowrange )0;
#line 687
  i = (ddf_rowrange )1;
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 687
    if (! (i <= m)) {
#line 687
      goto while_break;
    }
#line 688
    if (*(roworder + i) > 0L) {
      {
#line 688
      ddf_CopyArow(*(Acopy + (*(roworder + i) - 1L)), *(A + (i - 1L)), d);
      }
    }
#line 687
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 690
  return;
}
}
#line 692 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_InitializeArow(ddf_colrange d , ddf_Arow *a___41 ) 
{ 
  ddf_colrange j ;
  void *tmp ;

  {
#line 696
  if (d > 0L) {
    {
#line 696
    tmp = calloc((size_t )d, sizeof(myfloat ));
#line 696
    *a___41 = (myfloat *)tmp;
    }
  }
#line 697
  j = (ddf_colrange )0;
  {
#line 697
  while (1) {
    while_continue: /* CIL Label */ ;
#line 697
    if (! (j < d)) {
#line 697
      goto while_break;
    }
    {
#line 698
    dddf_init((double *)(*(*a___41 + j)));
#line 697
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  return;
}
}
#line 702 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_InitializeAmatrix(ddf_rowrange m , ddf_colrange d , ddf_Amatrix *A ) 
{ 
  ddf_rowrange i ;
  void *tmp ;

  {
#line 706
  if (m > 0L) {
    {
#line 706
    tmp = calloc((size_t )m, sizeof(myfloat *));
#line 706
    *A = (myfloat **)tmp;
    }
  }
#line 707
  i = (ddf_rowrange )0;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (! (i < m)) {
#line 707
      goto while_break;
    }
    {
#line 708
    ddf_InitializeArow(d, *A + i);
#line 707
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 710
  return;
}
}
#line 712 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_FreeAmatrix(ddf_rowrange m , ddf_colrange d , ddf_Amatrix A ) 
{ 
  ddf_rowrange i ;
  ddf_colrange j ;

  {
#line 717
  i = (ddf_rowrange )0;
  {
#line 717
  while (1) {
    while_continue: /* CIL Label */ ;
#line 717
    if (! (i < m)) {
#line 717
      goto while_break;
    }
#line 718
    j = (ddf_colrange )0;
    {
#line 718
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 718
      if (! (j < d)) {
#line 718
        goto while_break___0;
      }
      {
#line 719
      dddf_clear((double *)(*(*(A + i) + j)));
#line 718
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 717
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 722
  if ((unsigned long )A != (unsigned long )((void *)0)) {
#line 723
    i = (ddf_rowrange )0;
    {
#line 723
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 723
      if (! (i < m)) {
#line 723
        goto while_break___1;
      }
      {
#line 724
      free((void *)*(A + i));
#line 723
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 726
    free((void *)A);
    }
  }
#line 728
  return;
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_FreeArow(ddf_colrange d , ddf_Arow a___41 ) 
{ 
  ddf_colrange j ;

  {
#line 734
  j = (ddf_colrange )0;
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if (! (j < d)) {
#line 734
      goto while_break;
    }
    {
#line 735
    dddf_clear((double *)(*(a___41 + j)));
#line 734
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 737
  free((void *)a___41);
  }
#line 738
  return;
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_InitializeBmatrix(ddf_colrange d , ddf_Bmatrix *B ) 
{ 
  ddf_colrange i ;
  ddf_colrange j ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 745
  tmp = calloc((size_t )d, sizeof(myfloat *));
#line 745
  *B = (myfloat **)tmp;
#line 746
  j = (ddf_colrange )0;
  }
  {
#line 746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 746
    if (! (j < d)) {
#line 746
      goto while_break;
    }
    {
#line 747
    tmp___0 = calloc((size_t )d, sizeof(myfloat ));
#line 747
    *(*B + j) = (myfloat *)tmp___0;
#line 746
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 749
  i = (ddf_colrange )0;
  {
#line 749
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 749
    if (! (i < d)) {
#line 749
      goto while_break___0;
    }
#line 750
    j = (ddf_colrange )0;
    {
#line 750
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 750
      if (! (j < d)) {
#line 750
        goto while_break___1;
      }
      {
#line 751
      dddf_init((double *)(*(*(*B + i) + j)));
#line 750
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 749
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 754
  return;
}
}
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_FreeBmatrix(ddf_colrange d , ddf_Bmatrix B ) 
{ 
  ddf_colrange i ;
  ddf_colrange j ;

  {
#line 760
  i = (ddf_colrange )0;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! (i < d)) {
#line 760
      goto while_break;
    }
#line 761
    j = (ddf_colrange )0;
    {
#line 761
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 761
      if (! (j < d)) {
#line 761
        goto while_break___0;
      }
      {
#line 762
      dddf_clear((double *)(*(*(B + i) + j)));
#line 761
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 760
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 765
  if ((unsigned long )B != (unsigned long )((void *)0)) {
#line 766
    j = (ddf_colrange )0;
    {
#line 766
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 766
      if (! (j < d)) {
#line 766
        goto while_break___1;
      }
      {
#line 767
      free((void *)*(B + j));
#line 766
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 769
    free((void *)B);
    }
  }
#line 771
  return;
}
}
#line 773 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_SetFamilyPtr ddf_CreateSetFamily(ddf_bigrange fsize , ddf_bigrange ssize ) 
{ 
  ddf_SetFamilyPtr F ;
  ddf_bigrange i ;
  ddf_bigrange f0 ;
  ddf_bigrange f1 ;
  ddf_bigrange s0 ;
  ddf_bigrange s1 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 778
  if (fsize <= 0L) {
#line 779
    f0 = (ddf_bigrange )0;
#line 779
    f1 = (ddf_bigrange )1;
  } else {
#line 782
    f0 = fsize;
#line 782
    f1 = fsize;
  }
#line 784
  if (ssize <= 0L) {
#line 785
    s0 = (ddf_bigrange )0;
#line 785
    s1 = (ddf_bigrange )1;
  } else {
#line 788
    s0 = ssize;
#line 788
    s1 = ssize;
  }
  {
#line 791
  tmp = malloc(sizeof(ddf_SetFamilyType ));
#line 791
  F = (ddf_SetFamilyPtr )tmp;
#line 792
  tmp___0 = calloc((size_t )f1, sizeof(set_type ));
#line 792
  F->set = (set_type *)tmp___0;
#line 793
  i = (ddf_bigrange )0;
  }
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (! (i < f1)) {
#line 793
      goto while_break;
    }
    {
#line 794
    set_initialize(F->set + i, s1);
#line 793
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  F->famsize = f0;
#line 797
  F->setsize = s0;
#line 798
  return (F);
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_FreeSetFamily(ddf_SetFamilyPtr F ) 
{ 
  ddf_bigrange i ;
  ddf_bigrange f1 ;

  {
#line 806
  if ((unsigned long )F != (unsigned long )((void *)0)) {
#line 807
    if (F->famsize <= 0L) {
#line 807
      f1 = (ddf_bigrange )1;
    } else {
#line 807
      f1 = F->famsize;
    }
#line 809
    i = (ddf_bigrange )0;
    {
#line 809
    while (1) {
      while_continue: /* CIL Label */ ;
#line 809
      if (! (i < f1)) {
#line 809
        goto while_break;
      }
      {
#line 810
      set_free(*(F->set + i));
#line 809
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 812
    free((void *)F->set);
#line 813
    free((void *)F);
    }
  }
#line 815
  return;
}
}
#line 817 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_MatrixPtr ddf_CreateMatrix(ddf_rowrange m_size , ddf_colrange d_size ) 
{ 
  ddf_MatrixPtr M ;
  ddf_rowrange m0 ;
  ddf_rowrange m1 ;
  ddf_colrange d0 ;
  ddf_colrange d1 ;
  void *tmp ;

  {
#line 823
  if (m_size <= 0L) {
#line 824
    m0 = (ddf_rowrange )0;
#line 824
    m1 = (ddf_rowrange )1;
  } else {
#line 827
    m0 = m_size;
#line 827
    m1 = m_size;
  }
#line 829
  if (d_size <= 0L) {
#line 830
    d0 = (ddf_colrange )0;
#line 830
    d1 = (ddf_colrange )1;
  } else {
#line 833
    d0 = d_size;
#line 833
    d1 = d_size;
  }
  {
#line 835
  tmp = malloc(sizeof(ddf_MatrixType ));
#line 835
  M = (ddf_MatrixPtr )tmp;
#line 836
  ddf_InitializeAmatrix(m1, d1, & M->matrix);
#line 837
  ddf_InitializeArow(d1, & M->rowvec);
#line 838
  M->rowsize = m0;
#line 839
  set_initialize(& M->linset, m1);
#line 840
  M->colsize = d0;
#line 841
  M->objective = (ddf_LPObjectiveType )0;
#line 842
  M->numbtype = (ddf_NumberType )0;
#line 843
  M->representation = (ddf_RepresentationType )0;
  }
#line 844
  return (M);
}
}
#line 847 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_FreeMatrix(ddf_MatrixPtr M ) 
{ 
  ddf_rowrange m1 ;
  ddf_colrange d1 ;

  {
#line 852
  if ((unsigned long )M != (unsigned long )((void *)0)) {
#line 853
    if (M->rowsize <= 0L) {
#line 853
      m1 = (ddf_rowrange )1;
    } else {
#line 853
      m1 = M->rowsize;
    }
#line 854
    if (M->colsize <= 0L) {
#line 854
      d1 = (ddf_colrange )1;
    } else {
#line 854
      d1 = M->colsize;
    }
#line 855
    if ((unsigned long )M != (unsigned long )((void *)0)) {
      {
#line 856
      ddf_FreeAmatrix(m1, d1, M->matrix);
#line 857
      ddf_FreeArow(d1, M->rowvec);
#line 858
      set_free(M->linset);
#line 859
      free((void *)M);
      }
    }
  }
#line 862
  return;
}
}
#line 864 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_SetToIdentity(ddf_colrange d_size , ddf_Bmatrix T ) 
{ 
  ddf_colrange j1___0 ;
  ddf_colrange j2 ;

  {
#line 868
  j1___0 = (ddf_colrange )1;
  {
#line 868
  while (1) {
    while_continue: /* CIL Label */ ;
#line 868
    if (! (j1___0 <= d_size)) {
#line 868
      goto while_break;
    }
#line 869
    j2 = (ddf_colrange )1;
    {
#line 869
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 869
      if (! (j2 <= d_size)) {
#line 869
        goto while_break___0;
      }
#line 870
      if (j1___0 == j2) {
        {
#line 871
        dddf_set((double *)(*(*(T + (j1___0 - 1L)) + (j2 - 1L))), (double *)(ddf_one));
        }
      } else {
        {
#line 873
        dddf_set((double *)(*(*(T + (j1___0 - 1L)) + (j2 - 1L))), (double *)(ddf_purezero));
        }
      }
#line 869
      j2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 868
    j1___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  return;
}
}
#line 878 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_ColumnReduce(ddf_ConePtr cone ) 
{ 
  ddf_colrange j ;
  ddf_colrange j1___0 ;
  ddf_rowrange i ;
  ddf_boolean localdebug ;

  {
#line 880
  j1___0 = (ddf_colrange )0;
#line 882
  localdebug = 0;
#line 884
  j = (ddf_colrange )1;
  {
#line 884
  while (1) {
    while_continue: /* CIL Label */ ;
#line 884
    if (! (j <= cone->d)) {
#line 884
      goto while_break;
    }
#line 885
    if (*(cone->InitialRayIndex + j) > 0L) {
#line 886
      j1___0 ++;
#line 887
      if (j1___0 < j) {
#line 888
        i = (ddf_rowrange )1;
        {
#line 888
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 888
          if (! (i <= cone->m)) {
#line 888
            goto while_break___0;
          }
          {
#line 888
          dddf_set((double *)(*(*(cone->A + (i - 1L)) + (j1___0 - 1L))), (double *)(*(*(cone->A + (i - 1L)) + (j - 1L))));
#line 888
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 889
        *(cone->newcol + j) = j1___0;
#line 890
        if (localdebug) {
          {
#line 891
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"shifting the column %ld to column %ld\n",
                  j, j1___0);
          }
        }
      }
    } else {
#line 896
      *(cone->newcol + j) = 0L;
#line 897
      if (localdebug) {
        {
#line 898
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"a generator (or an equation) of the linearity space: ");
#line 899
        i = (ddf_rowrange )1;
        }
        {
#line 899
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 899
          if (! (i <= cone->d)) {
#line 899
            goto while_break___1;
          }
          {
#line 899
          ddf_WriteNumber(stderr, (double *)(*(*(cone->B + (i - 1L)) + (j - 1L))));
#line 899
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 900
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
    }
#line 884
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 904
  cone->d = j1___0;
#line 905
  ddf_CopyBmatrix(cone->d_orig, cone->B, cone->Bsave);
#line 907
  cone->ColReduced = 1;
  }
#line 908
  return;
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
long ddf_MatrixRank(ddf_MatrixPtr M , ddf_rowset ignoredrows , ddf_colset ignoredcols ,
                    ddf_rowset *rowbasis , ddf_colset *colbasis ) 
{ 
  ddf_boolean stop ;
  ddf_boolean chosen ;
  ddf_boolean localdebug ;
  ddf_rowset NopivotRow ;
  ddf_rowset PriorityRow ;
  ddf_colset ColSelected ;
  ddf_Bmatrix B ;
  ddf_rowindex roworder ;
  ddf_rowrange r ;
  ddf_colrange s ;
  long rank ;
  void *tmp ;

  {
  {
#line 912
  localdebug = ddf_debug;
#line 921
  rank = 0L;
#line 922
  stop = 0;
#line 923
  set_initialize(& ColSelected, M->colsize);
#line 924
  set_initialize(& NopivotRow, M->rowsize);
#line 925
  set_initialize(rowbasis, M->rowsize);
#line 926
  set_initialize(colbasis, M->colsize);
#line 927
  set_initialize(& PriorityRow, M->rowsize);
#line 928
  set_copy(NopivotRow, ignoredrows);
#line 929
  set_copy(ColSelected, ignoredcols);
#line 930
  ddf_InitializeBmatrix(M->colsize, & B);
#line 931
  ddf_SetToIdentity(M->colsize, B);
#line 932
  tmp = calloc((size_t )(M->rowsize + 1L), sizeof(long ));
#line 932
  roworder = (long *)tmp;
#line 933
  r = (ddf_rowrange )0;
  }
  {
#line 933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 933
    if (! (r < M->rowsize)) {
#line 933
      goto while_break;
    }
#line 933
    *(roworder + (r + 1L)) = r + 1L;
#line 933
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 936
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 937
    ddf_SelectPivot2(M->rowsize, M->colsize, M->matrix, B, (ddf_RowOrderType )1, roworder,
                     PriorityRow, M->rowsize, NopivotRow, ColSelected, & r, & s, & chosen);
    }
#line 939
    if (ddf_debug) {
#line 939
      if (chosen) {
        {
#line 940
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Procedure ddf_MatrixRank: pivot on (r,s) =(%ld, %ld).\n",
                r, s);
        }
      }
    }
#line 941
    if (chosen) {
      {
#line 942
      set_addelem(NopivotRow, r);
#line 943
      set_addelem(*rowbasis, r);
#line 944
      set_addelem(ColSelected, s);
#line 945
      set_addelem(*colbasis, s);
#line 946
      rank ++;
#line 947
      ddf_GaussianColumnPivot(M->rowsize, M->colsize, M->matrix, B, r, s);
      }
#line 948
      if (localdebug) {
        {
#line 948
        ddf_WriteBmatrix(stderr, M->colsize, B);
        }
      }
    } else {
#line 950
      stop = 1;
    }
#line 952
    if (rank == M->colsize) {
#line 952
      stop = 1;
    }
#line 936
    if (! (! stop)) {
#line 936
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 954
  ddf_FreeBmatrix(M->colsize, B);
#line 955
  free((void *)roworder);
#line 956
  set_free(ColSelected);
#line 957
  set_free(NopivotRow);
#line 958
  set_free(PriorityRow);
  }
#line 959
  return (rank);
}
}
#line 963 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_FindBasis(ddf_ConePtr cone , long *rank ) 
{ 
  ddf_boolean stop ;
  ddf_boolean chosen ;
  ddf_boolean localdebug ;
  ddf_rowset NopivotRow ;
  ddf_colset ColSelected ;
  ddf_rowrange r ;
  ddf_colrange j ;
  ddf_colrange s ;

  {
#line 965
  localdebug = ddf_debug;
#line 971
  *rank = 0L;
#line 972
  stop = 0;
#line 973
  j = (ddf_colrange )0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (j <= cone->d)) {
#line 973
      goto while_break;
    }
#line 973
    *(cone->InitialRayIndex + j) = 0L;
#line 973
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 974
  set_emptyset(cone->InitialHalfspaces);
#line 975
  set_initialize(& ColSelected, cone->d);
#line 976
  set_initialize(& NopivotRow, cone->m);
#line 977
  set_copy(NopivotRow, cone->NonequalitySet);
#line 978
  ddf_SetToIdentity(cone->d, cone->B);
  }
  {
#line 979
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 980
    ddf_SelectPivot2(cone->m, cone->d, cone->A, cone->B, cone->HalfspaceOrder, cone->OrderVector,
                     cone->EqualitySet, cone->m, NopivotRow, ColSelected, & r, & s,
                     & chosen);
    }
#line 982
    if (ddf_debug) {
#line 982
      if (chosen) {
        {
#line 983
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Procedure ddf_FindBasis: pivot on (r,s) =(%ld, %ld).\n",
                r, s);
        }
      }
    }
#line 984
    if (chosen) {
      {
#line 985
      set_addelem(cone->InitialHalfspaces, r);
#line 986
      set_addelem(NopivotRow, r);
#line 987
      set_addelem(ColSelected, s);
#line 988
      *(cone->InitialRayIndex + s) = r;
#line 989
      (*rank) ++;
#line 990
      ddf_GaussianColumnPivot(cone->m, cone->d, cone->A, cone->B, r, s);
      }
#line 991
      if (localdebug) {
        {
#line 991
        ddf_WriteBmatrix(stderr, cone->d, cone->B);
        }
      }
    } else {
#line 993
      stop = 1;
    }
#line 995
    if (*rank == cone->d) {
#line 995
      stop = 1;
    }
#line 979
    if (! (! stop)) {
#line 979
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 997
  set_free(ColSelected);
#line 998
  set_free(NopivotRow);
  }
#line 999
  return;
}
}
#line 1002 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_FindInitialRays(ddf_ConePtr cone , ddf_boolean *found ) 
{ 
  ddf_rowset CandidateRows ;
  ddf_rowrange i ;
  long rank ;
  ddf_RowOrderType roworder_save ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1007
  roworder_save = (ddf_RowOrderType )5;
#line 1009
  *found = 0;
#line 1010
  set_initialize(& CandidateRows, cone->m);
  }
#line 1011
  if ((cone->parent)->InitBasisAtBottom == 1) {
#line 1012
    roworder_save = cone->HalfspaceOrder;
#line 1013
    cone->HalfspaceOrder = (ddf_RowOrderType )0;
#line 1014
    cone->PreOrderedRun = 0;
  } else {
#line 1016
    cone->PreOrderedRun = 1;
  }
#line 1017
  if (ddf_debug) {
    {
#line 1017
    ddf_WriteBmatrix(stderr, cone->d, cone->B);
    }
  }
#line 1018
  i = (ddf_rowrange )1;
  {
#line 1018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1018
    if (! (i <= cone->m)) {
#line 1018
      goto while_break;
    }
    {
#line 1019
    tmp = set_member(i, cone->NonequalitySet);
    }
#line 1019
    if (! tmp) {
      {
#line 1019
      set_addelem(CandidateRows, i);
      }
    }
#line 1018
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1021
  ddf_FindBasis(cone, & rank);
  }
#line 1022
  if (ddf_debug) {
    {
#line 1022
    ddf_WriteBmatrix(stderr, cone->d, cone->B);
    }
  }
#line 1023
  if (ddf_debug) {
    {
#line 1023
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_FindInitialRays: rank of Amatrix = %ld\n",
            rank);
    }
  }
#line 1024
  cone->LinearityDim = cone->d - rank;
#line 1025
  if (ddf_debug) {
    {
#line 1025
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Linearity Dimension = %ld\n",
            cone->LinearityDim);
    }
  }
#line 1026
  if (cone->LinearityDim > 0L) {
    {
#line 1027
    ddf_ColumnReduce(cone);
#line 1028
    ddf_FindBasis(cone, & rank);
    }
  }
  {
#line 1030
  tmp___0 = set_subset(cone->EqualitySet, cone->InitialHalfspaces);
  }
#line 1030
  if (! tmp___0) {
#line 1031
    if (ddf_debug) {
      {
#line 1032
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Equality set is dependent. Equality Set and an initial basis:\n");
#line 1033
      set_fwrite(stderr, cone->EqualitySet);
#line 1034
      set_fwrite(stderr, cone->InitialHalfspaces);
      }
    }
  }
  {
#line 1037
  *found = 1;
#line 1038
  set_free(CandidateRows);
  }
#line 1039
  if ((cone->parent)->InitBasisAtBottom == 1) {
#line 1040
    cone->HalfspaceOrder = roworder_save;
  }
#line 1042
  if ((unsigned int )cone->HalfspaceOrder == 3U) {
#line 1045
    cone->PreOrderedRun = 0;
  } else
#line 1042
  if ((unsigned int )cone->HalfspaceOrder == 2U) {
#line 1045
    cone->PreOrderedRun = 0;
  } else
#line 1042
  if ((unsigned int )cone->HalfspaceOrder == 4U) {
#line 1045
    cone->PreOrderedRun = 0;
  } else {
#line 1046
    cone->PreOrderedRun = 1;
  }
#line 1047
  return;
}
}
#line 1049 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_CheckEquality(ddf_colrange d_size , ddf_RayPtr *RP1 , ddf_RayPtr *RP2 , ddf_boolean *equal ) 
{ 
  long j ;
  ddf_boolean tmp ;

  {
#line 1053
  if (ddf_debug) {
    {
#line 1054
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Check equality of two rays\n");
    }
  }
#line 1055
  *equal = 1;
#line 1056
  j = 1L;
  {
#line 1057
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1057
    if (j <= d_size) {
#line 1057
      if (! *equal) {
#line 1057
        goto while_break;
      }
    } else {
#line 1057
      goto while_break;
    }
    {
#line 1058
    tmp = ddf_Equal((double *)(*((*RP1)->Ray + (j - 1L))), (double *)(*((*RP2)->Ray + (j - 1L))));
    }
#line 1058
    if (! tmp) {
#line 1059
      *equal = 0;
    }
#line 1060
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1062
  if (*equal) {
    {
#line 1063
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Equal records found !!!!\n");
    }
  }
#line 1064
  return;
}
}
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___0  =    (ddf_colrange )0;
#line 1066 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_CreateNewRay(ddf_ConePtr cone , ddf_RayPtr Ptr1 , ddf_RayPtr Ptr2 , ddf_rowrange ii ) 
{ 
  ddf_colrange j ;
  myfloat a1 ;
  myfloat a2 ;
  myfloat v1 ;
  myfloat v2 ;
  ddf_boolean localdebug ;
  void *tmp ;

  {
  {
#line 1074
  localdebug = ddf_debug;
#line 1076
  dddf_init((double *)(a1));
#line 1076
  dddf_init((double *)(a2));
#line 1076
  dddf_init((double *)(v1));
#line 1076
  dddf_init((double *)(v2));
  }
#line 1077
  if (last_d___0 != cone->d) {
#line 1078
    if (last_d___0 > 0L) {
#line 1079
      j = (ddf_colrange )0;
      {
#line 1079
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1079
        if (! (j < last_d___0)) {
#line 1079
          goto while_break;
        }
        {
#line 1079
        dddf_clear((double *)(*(NewRay + j)));
#line 1079
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1080
      free((void *)NewRay);
      }
    }
    {
#line 1082
    tmp = calloc((size_t )cone->d, sizeof(myfloat ));
#line 1082
    NewRay = (myfloat *)tmp;
#line 1083
    j = (ddf_colrange )0;
    }
    {
#line 1083
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1083
      if (! (j < cone->d)) {
#line 1083
        goto while_break___0;
      }
      {
#line 1083
      dddf_init((double *)(*(NewRay + j)));
#line 1083
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1084
    last_d___0 = cone->d;
  }
  {
#line 1087
  ddf_AValue(& a1, cone->d, cone->A, Ptr1->Ray, ii);
#line 1088
  ddf_AValue(& a2, cone->d, cone->A, Ptr2->Ray, ii);
  }
#line 1089
  if (localdebug) {
    {
#line 1090
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CreatNewRay: Ray1 =");
#line 1090
    ddf_WriteArow(stderr, Ptr1->Ray, cone->d);
#line 1091
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CreatNewRay: Ray2 =");
#line 1091
    ddf_WriteArow(stderr, Ptr2->Ray, cone->d);
    }
  }
  {
#line 1093
  ddf_abs((double *)(v1), (double *)(a1));
#line 1094
  ddf_abs((double *)(v2), (double *)(a2));
  }
#line 1095
  if (localdebug) {
    {
#line 1096
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_AValue1 and ABS");
#line 1096
    ddf_WriteNumber(stderr, (double *)(a1));
#line 1096
    ddf_WriteNumber(stderr, (double *)(v1));
#line 1096
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1097
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_AValue2 and ABS");
#line 1097
    ddf_WriteNumber(stderr, (double *)(a2));
#line 1097
    ddf_WriteNumber(stderr, (double *)(v2));
#line 1097
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 1099
  j = (ddf_colrange )0;
  {
#line 1099
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1099
    if (! (j < cone->d)) {
#line 1099
      goto while_break___1;
    }
    {
#line 1100
    ddf_LinearComb((double *)(*(NewRay + j)), (double *)(*(Ptr1->Ray + j)), (double *)(v2),
                   (double *)(*(Ptr2->Ray + j)), (double *)(v1));
#line 1099
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1102
  if (localdebug) {
    {
#line 1103
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CreatNewRay: New ray =");
#line 1103
    ddf_WriteArow(stderr, NewRay, cone->d);
    }
  }
  {
#line 1105
  ddf_Normalize(cone->d, NewRay);
  }
#line 1106
  if (localdebug) {
    {
#line 1107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CreatNewRay: ddf_Normalized ray =");
#line 1107
    ddf_WriteArow(stderr, NewRay, cone->d);
    }
  }
  {
#line 1109
  ddf_AddRay(cone, NewRay);
#line 1110
  dddf_clear((double *)(a1));
#line 1110
  dddf_clear((double *)(a2));
#line 1110
  dddf_clear((double *)(v1));
#line 1110
  dddf_clear((double *)(v2));
  }
#line 1111
  return;
}
}
#line 1113 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_EvaluateARay1(ddf_rowrange i , ddf_ConePtr cone ) 
{ 
  ddf_colrange j ;
  myfloat temp ;
  myfloat tnext ;
  ddf_RayPtr Ptr ;
  ddf_RayPtr PrevPtr ;
  ddf_RayPtr TempPtr ;
  ddf_boolean tmp ;

  {
  {
#line 1124
  dddf_init((double *)(temp));
#line 1124
  dddf_init((double *)(tnext));
#line 1125
  Ptr = cone->FirstRay;
#line 1126
  PrevPtr = cone->ArtificialRay;
  }
#line 1127
  if ((unsigned long )PrevPtr->Next != (unsigned long )Ptr) {
    {
#line 1128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error.  Artificial Ray does not point to FirstRay!!!\n");
    }
  }
  {
#line 1130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1130
    if (! ((unsigned long )Ptr != (unsigned long )((void *)0))) {
#line 1130
      goto while_break;
    }
    {
#line 1131
    dddf_set((double *)(temp), (double *)(ddf_purezero));
#line 1132
    j = (ddf_colrange )0;
    }
    {
#line 1132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1132
      if (! (j < cone->d)) {
#line 1132
        goto while_break___0;
      }
      {
#line 1133
      dddf_mul((double *)(tnext), (double *)(*(*(cone->A + (i - 1L)) + j)), (double *)(*(Ptr->Ray + j)));
#line 1134
      dddf_add((double *)(temp), (double *)(temp), (double *)(tnext));
#line 1132
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1136
    dddf_set((double *)(Ptr->ARay), (double *)(temp));
#line 1138
    tmp = ddf_Negative((double *)(temp));
    }
#line 1138
    if (tmp) {
#line 1138
      if ((unsigned long )Ptr != (unsigned long )cone->FirstRay) {
#line 1140
        if ((unsigned long )Ptr == (unsigned long )cone->LastRay) {
#line 1140
          cone->LastRay = PrevPtr;
        }
#line 1141
        TempPtr = Ptr;
#line 1142
        Ptr = Ptr->Next;
#line 1143
        PrevPtr->Next = Ptr;
#line 1144
        (cone->ArtificialRay)->Next = TempPtr;
#line 1145
        TempPtr->Next = cone->FirstRay;
#line 1146
        cone->FirstRay = TempPtr;
      } else {
#line 1149
        PrevPtr = Ptr;
#line 1150
        Ptr = Ptr->Next;
      }
    } else {
#line 1149
      PrevPtr = Ptr;
#line 1150
      Ptr = Ptr->Next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1153
  dddf_clear((double *)(temp));
#line 1153
  dddf_clear((double *)(tnext));
  }
#line 1154
  return;
}
}
#line 1156 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_EvaluateARay2(ddf_rowrange i , ddf_ConePtr cone ) 
{ 
  ddf_colrange j ;
  myfloat temp ;
  myfloat tnext ;
  ddf_RayPtr Ptr ;
  ddf_RayPtr NextPtr ;
  ddf_boolean zerofound ;
  ddf_boolean negfound ;
  ddf_boolean posfound ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;

  {
#line 1167
  zerofound = 0;
#line 1167
  negfound = 0;
#line 1167
  posfound = 0;
#line 1169
  if ((unsigned long )cone == (unsigned long )((void *)0)) {
#line 1169
    goto _L99;
  } else
#line 1169
  if (cone->TotalRayCount <= 0L) {
#line 1169
    goto _L99;
  }
  {
#line 1170
  dddf_init((double *)(temp));
#line 1170
  dddf_init((double *)(tnext));
#line 1171
  cone->PosHead = (ddf_RayPtr )((void *)0);
#line 1171
  cone->ZeroHead = (ddf_RayPtr )((void *)0);
#line 1171
  cone->NegHead = (ddf_RayPtr )((void *)0);
#line 1172
  cone->PosLast = (ddf_RayPtr )((void *)0);
#line 1172
  cone->ZeroLast = (ddf_RayPtr )((void *)0);
#line 1172
  cone->NegLast = (ddf_RayPtr )((void *)0);
#line 1173
  Ptr = cone->FirstRay;
  }
  {
#line 1174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1174
    if (! ((unsigned long )Ptr != (unsigned long )((void *)0))) {
#line 1174
      goto while_break;
    }
    {
#line 1175
    NextPtr = Ptr->Next;
#line 1176
    Ptr->Next = (ddf_RayPtr )((void *)0);
#line 1177
    dddf_set((double *)(temp), (double *)(ddf_purezero));
#line 1178
    j = (ddf_colrange )0;
    }
    {
#line 1178
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1178
      if (! (j < cone->d)) {
#line 1178
        goto while_break___0;
      }
      {
#line 1179
      dddf_mul((double *)(tnext), (double *)(*(*(cone->A + (i - 1L)) + j)), (double *)(*(Ptr->Ray + j)));
#line 1180
      dddf_add((double *)(temp), (double *)(temp), (double *)(tnext));
#line 1178
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1182
    dddf_set((double *)(Ptr->ARay), (double *)(temp));
#line 1184
    tmp___0 = ddf_Negative((double *)(temp));
    }
#line 1184
    if (tmp___0) {
#line 1185
      if (! negfound) {
#line 1186
        negfound = 1;
#line 1187
        cone->NegHead = Ptr;
#line 1188
        cone->NegLast = Ptr;
      } else {
#line 1191
        Ptr->Next = cone->NegHead;
#line 1192
        cone->NegHead = Ptr;
      }
    } else {
      {
#line 1196
      tmp = ddf_Positive((double *)(temp));
      }
#line 1196
      if (tmp) {
#line 1197
        if (! posfound) {
#line 1198
          posfound = 1;
#line 1199
          cone->PosHead = Ptr;
#line 1200
          cone->PosLast = Ptr;
        } else {
#line 1203
          Ptr->Next = cone->PosHead;
#line 1204
          cone->PosHead = Ptr;
        }
      } else
#line 1208
      if (! zerofound) {
#line 1209
        zerofound = 1;
#line 1210
        cone->ZeroHead = Ptr;
#line 1211
        cone->ZeroLast = Ptr;
      } else {
#line 1214
        Ptr->Next = cone->ZeroHead;
#line 1215
        cone->ZeroHead = Ptr;
      }
    }
#line 1218
    Ptr = NextPtr;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  if (negfound) {
#line 1222
    cone->FirstRay = cone->NegHead;
#line 1223
    if (posfound) {
#line 1224
      (cone->NegLast)->Next = cone->PosHead;
#line 1225
      if (zerofound) {
#line 1226
        (cone->PosLast)->Next = cone->ZeroHead;
#line 1227
        cone->LastRay = cone->ZeroLast;
      } else {
#line 1230
        cone->LastRay = cone->PosLast;
      }
    } else
#line 1234
    if (zerofound) {
#line 1235
      (cone->NegLast)->Next = cone->ZeroHead;
#line 1236
      cone->LastRay = cone->ZeroLast;
    } else {
#line 1239
      cone->LastRay = cone->NegLast;
    }
  } else
#line 1243
  if (posfound) {
#line 1244
    cone->FirstRay = cone->PosHead;
#line 1245
    if (zerofound) {
#line 1246
      (cone->PosLast)->Next = cone->ZeroHead;
#line 1247
      cone->LastRay = cone->ZeroLast;
    } else {
#line 1250
      cone->LastRay = cone->PosLast;
    }
  } else {
#line 1254
    cone->FirstRay = cone->ZeroHead;
#line 1255
    cone->LastRay = cone->ZeroLast;
  }
  {
#line 1257
  (cone->ArtificialRay)->Next = cone->FirstRay;
#line 1258
  (cone->LastRay)->Next = (ddf_RayPtr )((void *)0);
#line 1259
  dddf_clear((double *)(temp));
#line 1259
  dddf_clear((double *)(tnext));
  }
  _L99: ;
#line 1261
  return;
}
}
#line 1263 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_DeleteNegativeRays(ddf_ConePtr cone ) 
{ 
  ddf_rowrange fii ;
  ddf_rowrange fiitest ;
  myfloat temp ;
  ddf_RayPtr Ptr ;
  ddf_RayPtr PrevPtr ;
  ddf_RayPtr NextPtr ;
  ddf_RayPtr ZeroPtr1 ;
  ddf_RayPtr ZeroPtr0 ;
  ddf_boolean found ;
  ddf_boolean completed ;
  ddf_boolean zerofound ;
  ddf_boolean negfound ;
  ddf_boolean posfound ;
  ddf_boolean localdebug ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;
  ddf_boolean tmp___1 ;

  {
  {
#line 1273
  zerofound = 0;
#line 1273
  negfound = 0;
#line 1273
  posfound = 0;
#line 1274
  localdebug = 0;
#line 1276
  dddf_init((double *)(temp));
#line 1277
  cone->PosHead = (ddf_RayPtr )((void *)0);
#line 1277
  cone->ZeroHead = (ddf_RayPtr )((void *)0);
#line 1277
  cone->NegHead = (ddf_RayPtr )((void *)0);
#line 1278
  cone->PosLast = (ddf_RayPtr )((void *)0);
#line 1278
  cone->ZeroLast = (ddf_RayPtr )((void *)0);
#line 1278
  cone->NegLast = (ddf_RayPtr )((void *)0);
#line 1281
  PrevPtr = cone->ArtificialRay;
#line 1282
  Ptr = cone->FirstRay;
  }
#line 1283
  if ((unsigned long )PrevPtr->Next != (unsigned long )Ptr) {
    {
#line 1284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error at ddf_DeleteNegativeRays: ArtificialRay does not point the FirstRay.\n");
    }
  }
#line 1285
  completed = 0;
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1286
    if ((unsigned long )Ptr != (unsigned long )((void *)0)) {
#line 1286
      if (! (! completed)) {
#line 1286
        goto while_break;
      }
    } else {
#line 1286
      goto while_break;
    }
    {
#line 1288
    tmp = ddf_Negative((double *)(Ptr->ARay));
    }
#line 1288
    if (tmp) {
      {
#line 1289
      ddf_Eliminate(cone, & PrevPtr);
#line 1290
      Ptr = PrevPtr->Next;
      }
    } else {
#line 1293
      completed = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1298
  Ptr = cone->FirstRay;
#line 1299
  cone->ZeroRayCount = 0L;
  {
#line 1300
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1300
    if (! ((unsigned long )Ptr != (unsigned long )((void *)0))) {
#line 1300
      goto while_break___0;
    }
    {
#line 1301
    NextPtr = Ptr->Next;
#line 1302
    dddf_set((double *)(temp), (double *)(Ptr->ARay));
    }
#line 1303
    if (localdebug) {
      {
#line 1303
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ptr->ARay :");
#line 1303
      ddf_WriteNumber(stderr, (double *)(temp));
      }
    }
    {
#line 1305
    tmp___1 = ddf_Negative((double *)(temp));
    }
#line 1305
    if (tmp___1) {
#line 1306
      if (! negfound) {
        {
#line 1307
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: An infeasible ray found after their removal\n");
#line 1308
        negfound = 1;
        }
      }
    } else {
      {
#line 1312
      tmp___0 = ddf_Positive((double *)(temp));
      }
#line 1312
      if (tmp___0) {
#line 1313
        if (! posfound) {
#line 1314
          posfound = 1;
#line 1315
          cone->PosHead = Ptr;
#line 1316
          cone->PosLast = Ptr;
        } else {
#line 1319
          cone->PosLast = Ptr;
        }
      } else {
#line 1323
        (cone->ZeroRayCount) ++;
#line 1324
        if (! zerofound) {
#line 1325
          zerofound = 1;
#line 1326
          cone->ZeroHead = Ptr;
#line 1327
          cone->ZeroLast = Ptr;
#line 1328
          (cone->ZeroLast)->Next = (ddf_RayPtr )((void *)0);
        } else {
#line 1331
          fii = Ptr->FirstInfeasIndex;
#line 1332
          found = 0;
#line 1333
          ZeroPtr1 = (ddf_RayPtr )((void *)0);
#line 1334
          ZeroPtr0 = cone->ZeroHead;
          {
#line 1334
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1334
            if (! found) {
#line 1334
              if (! ((unsigned long )ZeroPtr0 != (unsigned long )((void *)0))) {
#line 1334
                goto while_break___1;
              }
            } else {
#line 1334
              goto while_break___1;
            }
#line 1335
            fiitest = ZeroPtr0->FirstInfeasIndex;
#line 1336
            if (fiitest >= fii) {
#line 1337
              found = 1;
            } else {
#line 1339
              ZeroPtr1 = ZeroPtr0;
            }
#line 1334
            ZeroPtr0 = ZeroPtr0->Next;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1342
          if (! found) {
#line 1343
            (cone->ZeroLast)->Next = Ptr;
#line 1344
            cone->ZeroLast = Ptr;
#line 1345
            (cone->ZeroLast)->Next = (ddf_RayPtr )((void *)0);
          } else
#line 1348
          if ((unsigned long )ZeroPtr1 == (unsigned long )((void *)0)) {
#line 1350
            Ptr->Next = cone->ZeroHead;
#line 1351
            cone->ZeroHead = Ptr;
          } else {
#line 1355
            Ptr->Next = ZeroPtr1->Next;
#line 1356
            ZeroPtr1->Next = Ptr;
          }
        }
      }
    }
#line 1365
    Ptr = NextPtr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1368
  if (posfound) {
#line 1369
    cone->FirstRay = cone->PosHead;
#line 1370
    if (zerofound) {
#line 1371
      (cone->PosLast)->Next = cone->ZeroHead;
#line 1372
      cone->LastRay = cone->ZeroLast;
    } else {
#line 1375
      cone->LastRay = cone->PosLast;
    }
  } else {
#line 1379
    cone->FirstRay = cone->ZeroHead;
#line 1380
    cone->LastRay = cone->ZeroLast;
  }
  {
#line 1382
  (cone->ArtificialRay)->Next = cone->FirstRay;
#line 1383
  (cone->LastRay)->Next = (ddf_RayPtr )((void *)0);
#line 1384
  dddf_clear((double *)(temp));
  }
#line 1385
  return;
}
}
#line 1387 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_FeasibilityIndices(long *fnum , long *infnum , ddf_rowrange i , ddf_ConePtr cone ) 
{ 
  ddf_colrange j ;
  myfloat temp ;
  myfloat tnext ;
  ddf_RayPtr Ptr ;
  ddf_boolean tmp ;

  {
  {
#line 1395
  dddf_init((double *)(temp));
#line 1395
  dddf_init((double *)(tnext));
#line 1396
  *fnum = 0L;
#line 1397
  *infnum = 0L;
#line 1398
  Ptr = cone->FirstRay;
  }
  {
#line 1399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1399
    if (! ((unsigned long )Ptr != (unsigned long )((void *)0))) {
#line 1399
      goto while_break;
    }
    {
#line 1400
    dddf_set((double *)(temp), (double *)(ddf_purezero));
#line 1401
    j = (ddf_colrange )0;
    }
    {
#line 1401
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1401
      if (! (j < cone->d)) {
#line 1401
        goto while_break___0;
      }
      {
#line 1402
      dddf_mul((double *)(tnext), (double *)(*(*(cone->A + (i - 1L)) + j)), (double *)(*(Ptr->Ray + j)));
#line 1403
      dddf_add((double *)(temp), (double *)(temp), (double *)(tnext));
#line 1401
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1405
    tmp = ddf_Nonnegative((double *)(temp));
    }
#line 1405
    if (tmp) {
#line 1406
      (*fnum) ++;
    } else {
#line 1408
      (*infnum) ++;
    }
#line 1409
    Ptr = Ptr->Next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1411
  dddf_clear((double *)(temp));
#line 1411
  dddf_clear((double *)(tnext));
  }
#line 1412
  return;
}
}
#line 1414 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_boolean ddf_LexSmaller(myfloat *v1 , myfloat *v2 , long dmax ) 
{ 
  ddf_boolean determined ;
  ddf_boolean smaller ;
  ddf_colrange j ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;

  {
#line 1419
  smaller = 0;
#line 1420
  determined = 0;
#line 1421
  j = (ddf_colrange )1;
  {
#line 1422
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1423
    tmp___0 = ddf_Equal((double *)(*(v1 + (j - 1L))), (double *)(*(v2 + (j - 1L))));
    }
#line 1423
    if (tmp___0) {
#line 1429
      j ++;
    } else {
      {
#line 1424
      tmp = ddf_Smaller((double *)(*(v1 + (j - 1L))), (double *)(*(v2 + (j - 1L))));
      }
#line 1424
      if (tmp) {
#line 1425
        smaller = 1;
      }
#line 1427
      determined = 1;
    }
#line 1422
    if (! determined) {
#line 1422
      if (! (j <= dmax)) {
#line 1422
        goto while_break;
      }
    } else {
#line 1422
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1431
  return (smaller);
}
}
#line 1435 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_boolean ddf_LexLarger(myfloat *v1 , myfloat *v2 , long dmax ) 
{ 
  ddf_boolean tmp ;

  {
  {
#line 1437
  tmp = ddf_LexSmaller(v2, v1, dmax);
  }
#line 1437
  return (tmp);
}
}
#line 1440 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_boolean ddf_LexEqual(myfloat *v1 , myfloat *v2 , long dmax ) 
{ 
  ddf_boolean determined ;
  ddf_boolean equal ;
  ddf_colrange j ;
  ddf_boolean tmp ;

  {
#line 1445
  equal = 1;
#line 1446
  determined = 0;
#line 1447
  j = (ddf_colrange )1;
  {
#line 1448
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1449
    tmp = ddf_Equal((double *)(*(v1 + (j - 1L))), (double *)(*(v2 + (j - 1L))));
    }
#line 1449
    if (tmp) {
#line 1453
      j ++;
    } else {
#line 1450
      equal = 0;
#line 1451
      determined = 1;
    }
#line 1448
    if (! determined) {
#line 1448
      if (! (j <= dmax)) {
#line 1448
        goto while_break;
      }
    } else {
#line 1448
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1456
  return (equal);
}
}
#line 1459 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_AddNewHalfspace1(ddf_ConePtr cone , ddf_rowrange hnew ) 
{ 
  ddf_RayPtr RayPtr0 ;
  ddf_RayPtr RayPtr1 ;
  ddf_RayPtr RayPtr2 ;
  ddf_RayPtr RayPtr2s ;
  ddf_RayPtr RayPtr3 ;
  long pos1 ;
  long pos2 ;
  double prevprogress ;
  double progress ;
  myfloat value1 ;
  myfloat value2 ;
  ddf_boolean adj ;
  ddf_boolean equal ;
  ddf_boolean completed ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;
  ddf_boolean tmp___1 ;
  ddf_boolean tmp___2 ;
  ddf_boolean tmp___3 ;
  ddf_boolean tmp___4 ;
  ddf_boolean tmp___5 ;

  {
  {
#line 1474
  dddf_init((double *)(value1));
#line 1474
  dddf_init((double *)(value2));
#line 1475
  ddf_EvaluateARay1(hnew, cone);
#line 1479
  RayPtr0 = cone->ArtificialRay;
#line 1480
  RayPtr1 = cone->FirstRay;
#line 1481
  dddf_set((double *)(value1), (double *)((cone->FirstRay)->ARay));
#line 1482
  tmp___0 = ddf_Nonnegative((double *)(value1));
  }
#line 1482
  if (tmp___0) {
#line 1483
    if (cone->RayCount == cone->WeaklyFeasibleRayCount) {
#line 1483
      cone->CompStatus = (ddf_CompStatusType )1;
    }
#line 1484
    goto _L99;
  } else {
#line 1487
    RayPtr2s = RayPtr1->Next;
#line 1488
    pos2 = 1L;
    {
#line 1489
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1489
      if ((unsigned long )RayPtr2s != (unsigned long )((void *)0)) {
        {
#line 1489
        tmp = ddf_Negative((double *)(RayPtr2s->ARay));
        }
#line 1489
        if (! tmp) {
#line 1489
          goto while_break;
        }
      } else {
#line 1489
        goto while_break;
      }
#line 1490
      RayPtr2s = RayPtr2s->Next;
#line 1491
      pos2 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1494
  if ((unsigned long )RayPtr2s == (unsigned long )((void *)0)) {
#line 1495
    cone->FirstRay = (ddf_RayPtr )((void *)0);
#line 1496
    (cone->ArtificialRay)->Next = cone->FirstRay;
#line 1497
    cone->RayCount = 0L;
#line 1498
    cone->CompStatus = (ddf_CompStatusType )1;
#line 1499
    goto _L99;
  }
#line 1501
  RayPtr2 = RayPtr2s;
#line 1502
  RayPtr3 = cone->LastRay;
#line 1503
  prevprogress = - 10.0;
#line 1504
  pos1 = 1L;
#line 1505
  completed = 0;
  {
#line 1506
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1506
    if ((unsigned long )RayPtr1 != (unsigned long )RayPtr2s) {
#line 1506
      if (! (! completed)) {
#line 1506
        goto while_break___0;
      }
    } else {
#line 1506
      goto while_break___0;
    }
    {
#line 1507
    dddf_set((double *)(value1), (double *)(RayPtr1->ARay));
#line 1508
    dddf_set((double *)(value2), (double *)(RayPtr2->ARay));
#line 1509
    ddf_CheckEquality(cone->d, & RayPtr1, & RayPtr2, & equal);
#line 1510
    tmp___1 = ddf_Positive((double *)(value1));
    }
#line 1510
    if (tmp___1) {
      {
#line 1510
      tmp___2 = ddf_Negative((double *)(value2));
      }
#line 1510
      if (tmp___2) {
#line 1510
        goto _L;
      } else {
#line 1510
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 1510
      tmp___3 = ddf_Negative((double *)(value1));
      }
#line 1510
      if (tmp___3) {
        {
#line 1510
        tmp___4 = ddf_Positive((double *)(value2));
        }
#line 1510
        if (tmp___4) {
          _L: /* CIL Label */ 
          {
#line 1511
          ddf_CheckAdjacency(cone, & RayPtr1, & RayPtr2, & adj);
          }
#line 1512
          if (adj) {
            {
#line 1512
            ddf_CreateNewRay(cone, RayPtr1, RayPtr2, hnew);
            }
          }
        }
      }
    }
#line 1514
    if ((unsigned long )RayPtr2 != (unsigned long )RayPtr3) {
#line 1515
      RayPtr2 = RayPtr2->Next;
#line 1516
      goto while_continue___0;
    }
    {
#line 1518
    tmp___5 = ddf_Negative((double *)(value1));
    }
#line 1518
    if (tmp___5) {
      {
#line 1519
      ddf_Eliminate(cone, & RayPtr0);
#line 1520
      RayPtr1 = RayPtr0->Next;
#line 1521
      RayPtr2 = RayPtr2s;
      }
    } else
#line 1518
    if (equal) {
      {
#line 1519
      ddf_Eliminate(cone, & RayPtr0);
#line 1520
      RayPtr1 = RayPtr0->Next;
#line 1521
      RayPtr2 = RayPtr2s;
      }
    } else {
#line 1523
      completed = 1;
    }
#line 1525
    pos1 ++;
#line 1526
    progress = ((100.0 * ((double )pos1 / (double )pos2)) * (2.0 * (double )pos2 - (double )pos1)) / (double )pos2;
#line 1527
    if (progress - prevprogress >= (double )10) {
#line 1527
      if (pos1 % 10L == 0L) {
#line 1527
        if (ddf_debug) {
          {
#line 1528
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*Progress of iteration %5ld(/%ld):   %4ld/%4ld => %4.1f%% done\n",
                  cone->Iteration, cone->m, pos1, pos2, progress);
#line 1530
          prevprogress = progress;
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1533
  if (cone->RayCount == cone->WeaklyFeasibleRayCount) {
#line 1533
    cone->CompStatus = (ddf_CompStatusType )1;
  }
  _L99: 
  {
#line 1535
  dddf_clear((double *)(value1));
#line 1535
  dddf_clear((double *)(value2));
  }
#line 1536
  return;
}
}
#line 1538 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_AddNewHalfspace2(ddf_ConePtr cone , ddf_rowrange hnew ) 
{ 
  ddf_RayPtr RayPtr0 ;
  ddf_RayPtr RayPtr1 ;
  ddf_RayPtr RayPtr2 ;
  ddf_AdjacencyType *EdgePtr ;
  ddf_AdjacencyType *EdgePtr0 ;
  long pos1 ;
  ddf_rowrange fii1 ;
  ddf_rowrange fii2 ;
  ddf_boolean localdebug ;

  {
  {
#line 1545
  localdebug = 0;
#line 1547
  ddf_EvaluateARay2(hnew, cone);
  }
#line 1551
  if ((unsigned long )cone->PosHead == (unsigned long )((void *)0)) {
#line 1551
    if ((unsigned long )cone->ZeroHead == (unsigned long )((void *)0)) {
#line 1552
      cone->FirstRay = (ddf_RayPtr )((void *)0);
#line 1553
      (cone->ArtificialRay)->Next = cone->FirstRay;
#line 1554
      cone->RayCount = 0L;
#line 1555
      cone->CompStatus = (ddf_CompStatusType )1;
#line 1556
      goto _L99;
    }
  }
#line 1559
  if (localdebug) {
    {
#line 1560
    pos1 = 0L;
#line 1561
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(pos, FirstInfeasIndex, A Ray)=\n");
#line 1562
    RayPtr0 = cone->FirstRay;
    }
    {
#line 1562
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1562
      if (! ((unsigned long )RayPtr0 != (unsigned long )((void *)0))) {
#line 1562
        goto while_break;
      }
      {
#line 1563
      pos1 ++;
#line 1564
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(%ld,%ld,",
              pos1, RayPtr0->FirstInfeasIndex);
#line 1565
      ddf_WriteNumber(stderr, (double *)(RayPtr0->ARay));
#line 1566
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)") ");
#line 1562
      RayPtr0 = RayPtr0->Next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1568
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 1571
  if ((unsigned long )cone->ZeroHead == (unsigned long )((void *)0)) {
#line 1571
    cone->ZeroHead = cone->LastRay;
  }
#line 1573
  EdgePtr = *(cone->Edges + cone->Iteration);
  {
#line 1574
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1574
    if (! ((unsigned long )EdgePtr != (unsigned long )((void *)0))) {
#line 1574
      goto while_break___0;
    }
    {
#line 1575
    RayPtr1 = EdgePtr->Ray1;
#line 1576
    RayPtr2 = EdgePtr->Ray2;
#line 1577
    fii1 = RayPtr1->FirstInfeasIndex;
#line 1578
    ddf_CreateNewRay(cone, RayPtr1, RayPtr2, hnew);
#line 1579
    fii2 = (cone->LastRay)->FirstInfeasIndex;
    }
#line 1580
    if (fii1 != fii2) {
      {
#line 1581
      ddf_ConditionalAddEdge(cone, RayPtr1, cone->LastRay, cone->PosHead);
      }
    }
    {
#line 1582
    EdgePtr0 = EdgePtr;
#line 1583
    EdgePtr = EdgePtr->Next;
#line 1584
    free((void *)EdgePtr0);
#line 1585
    (cone->EdgeCount) --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1587
  *(cone->Edges + cone->Iteration) = (ddf_AdjacencyType *)((void *)0);
#line 1589
  ddf_DeleteNegativeRays(cone);
#line 1591
  set_addelem(cone->AddedHalfspaces, hnew);
  }
#line 1593
  if (cone->Iteration < cone->m) {
#line 1594
    if ((unsigned long )cone->ZeroHead != (unsigned long )((void *)0)) {
#line 1594
      if ((unsigned long )cone->ZeroHead != (unsigned long )cone->LastRay) {
#line 1595
        if (cone->ZeroRayCount > 200L) {
#line 1595
          if (ddf_debug) {
            {
#line 1595
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*New edges being scanned...\n");
            }
          }
        }
        {
#line 1596
        ddf_UpdateEdges(cone, cone->ZeroHead, cone->LastRay);
        }
      }
    }
  }
#line 1600
  if (cone->RayCount == cone->WeaklyFeasibleRayCount) {
#line 1600
    cone->CompStatus = (ddf_CompStatusType )1;
  }
  _L99: ;
#line 1602
  return;
}
}
#line 1605 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_SelectNextHalfspace0(ddf_ConePtr cone , ddf_rowset excluded , ddf_rowrange *hnext ) 
{ 
  long i ;
  ddf_boolean determined ;
  int tmp ;

  {
#line 1611
  i = cone->m;
#line 1612
  determined = 0;
  {
#line 1613
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1614
    tmp = set_member(i, excluded);
    }
#line 1614
    if (tmp) {
#line 1615
      i --;
    } else {
#line 1617
      determined = 1;
    }
#line 1613
    if (! determined) {
#line 1613
      if (! (i >= 1L)) {
#line 1613
        goto while_break;
      }
    } else {
#line 1613
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1619
  if (determined) {
#line 1620
    *hnext = i;
  } else {
#line 1622
    *hnext = (ddf_rowrange )0;
  }
#line 1623
  return;
}
}
#line 1625 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_SelectNextHalfspace1(ddf_ConePtr cone , ddf_rowset excluded , ddf_rowrange *hnext ) 
{ 
  long i ;
  ddf_boolean determined ;
  int tmp ;

  {
#line 1631
  i = 1L;
#line 1632
  determined = 0;
  {
#line 1633
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1634
    tmp = set_member(i, excluded);
    }
#line 1634
    if (tmp) {
#line 1635
      i ++;
    } else {
#line 1637
      determined = 1;
    }
#line 1633
    if (! determined) {
#line 1633
      if (! (i <= cone->m)) {
#line 1633
        goto while_break;
      }
    } else {
#line 1633
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1639
  if (determined) {
#line 1640
    *hnext = i;
  } else {
#line 1642
    *hnext = (ddf_rowrange )0;
  }
#line 1643
  return;
}
}
#line 1645 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_SelectNextHalfspace2(ddf_ConePtr cone , ddf_rowset excluded , ddf_rowrange *hnext ) 
{ 
  long i ;
  long fea ;
  long inf ;
  long infmin ;
  long fi ;
  int tmp ;

  {
#line 1648
  fi = 0L;
#line 1650
  infmin = cone->RayCount + 1L;
#line 1651
  i = 1L;
  {
#line 1651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1651
    if (! (i <= cone->m)) {
#line 1651
      goto while_break;
    }
    {
#line 1652
    tmp = set_member(i, excluded);
    }
#line 1652
    if (! tmp) {
      {
#line 1653
      ddf_FeasibilityIndices(& fea, & inf, i, cone);
      }
#line 1654
      if (inf < infmin) {
#line 1655
        infmin = inf;
#line 1656
        fi = fea;
#line 1657
        *hnext = i;
      }
    }
#line 1651
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1661
  if (ddf_debug) {
    {
#line 1662
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*infeasible rays (min) =%5ld, #feas rays =%5ld\n",
            infmin, fi);
    }
  }
#line 1664
  return;
}
}
#line 1666 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_SelectNextHalfspace3(ddf_ConePtr cone , ddf_rowset excluded , ddf_rowrange *hnext ) 
{ 
  long i ;
  long fea ;
  long inf ;
  long infmax ;
  long fi ;
  ddf_boolean localdebug ;
  int tmp ;

  {
#line 1669
  fi = 0L;
#line 1670
  localdebug = ddf_debug;
#line 1672
  infmax = -1L;
#line 1673
  i = 1L;
  {
#line 1673
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1673
    if (! (i <= cone->m)) {
#line 1673
      goto while_break;
    }
    {
#line 1674
    tmp = set_member(i, excluded);
    }
#line 1674
    if (! tmp) {
      {
#line 1675
      ddf_FeasibilityIndices(& fea, & inf, i, cone);
      }
#line 1676
      if (inf > infmax) {
#line 1677
        infmax = inf;
#line 1678
        fi = fea;
#line 1679
        *hnext = i;
      }
    }
#line 1673
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1683
  if (localdebug) {
    {
#line 1684
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*infeasible rays (max) =%5ld, #feas rays =%5ld\n",
            infmax, fi);
    }
  }
#line 1686
  return;
}
}
#line 1688 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_SelectNextHalfspace4(ddf_ConePtr cone , ddf_rowset excluded , ddf_rowrange *hnext ) 
{ 
  long i ;
  long fea ;
  long inf ;
  long max ;
  long tmax ;
  long fi ;
  long infi ;
  int tmp ;

  {
#line 1691
  fi = 0L;
#line 1691
  infi = 0L;
#line 1694
  max = -1L;
#line 1695
  i = 1L;
  {
#line 1695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1695
    if (! (i <= cone->m)) {
#line 1695
      goto while_break;
    }
    {
#line 1696
    tmp = set_member(i, excluded);
    }
#line 1696
    if (! tmp) {
      {
#line 1697
      ddf_FeasibilityIndices(& fea, & inf, i, cone);
      }
#line 1698
      if (fea <= inf) {
#line 1699
        tmax = inf;
      } else {
#line 1701
        tmax = fea;
      }
#line 1702
      if (tmax > max) {
#line 1703
        max = tmax;
#line 1704
        fi = fea;
#line 1705
        infi = inf;
#line 1706
        *hnext = i;
      }
    }
#line 1695
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1710
  if (! ddf_debug) {
#line 1711
    return;
  }
#line 1712
  if (max == fi) {
    {
#line 1713
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*infeasible rays (min) =%5ld, #feas rays =%5ld\n",
            infi, fi);
    }
  } else {
    {
#line 1715
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*infeasible rays (max) =%5ld, #feas rays =%5ld\n",
            infi, fi);
    }
  }
#line 1717
  return;
}
}
#line 1719 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_SelectNextHalfspace5(ddf_ConePtr cone , ddf_rowset excluded , ddf_rowrange *hnext ) 
{ 
  long i ;
  long minindex ;
  myfloat *v1 ;
  myfloat *v2 ;
  ddf_boolean tmp ;
  int tmp___0 ;

  {
#line 1725
  minindex = 0L;
#line 1726
  v1 = (myfloat *)((void *)0);
#line 1727
  i = 1L;
  {
#line 1727
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1727
    if (! (i <= cone->m)) {
#line 1727
      goto while_break;
    }
    {
#line 1728
    tmp___0 = set_member(i, excluded);
    }
#line 1728
    if (! tmp___0) {
#line 1729
      v2 = *(cone->A + (i - 1L));
#line 1730
      if (minindex == 0L) {
#line 1731
        minindex = i;
#line 1732
        v1 = v2;
      } else {
        {
#line 1733
        tmp = ddf_LexSmaller(v2, v1, cone->d);
        }
#line 1733
        if (tmp) {
#line 1734
          minindex = i;
#line 1735
          v1 = v2;
        }
      }
    }
#line 1727
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1739
  *hnext = minindex;
#line 1740
  return;
}
}
#line 1743 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_SelectNextHalfspace6(ddf_ConePtr cone , ddf_rowset excluded , ddf_rowrange *hnext ) 
{ 
  long i ;
  long maxindex ;
  myfloat *v1 ;
  myfloat *v2 ;
  ddf_boolean tmp ;
  int tmp___0 ;

  {
#line 1749
  maxindex = 0L;
#line 1750
  v1 = (myfloat *)((void *)0);
#line 1751
  i = 1L;
  {
#line 1751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1751
    if (! (i <= cone->m)) {
#line 1751
      goto while_break;
    }
    {
#line 1752
    tmp___0 = set_member(i, excluded);
    }
#line 1752
    if (! tmp___0) {
#line 1753
      v2 = *(cone->A + (i - 1L));
#line 1754
      if (maxindex == 0L) {
#line 1755
        maxindex = i;
#line 1756
        v1 = v2;
      } else {
        {
#line 1757
        tmp = ddf_LexLarger(v2, v1, cone->d);
        }
#line 1757
        if (tmp) {
#line 1758
          maxindex = i;
#line 1759
          v1 = v2;
        }
      }
    }
#line 1751
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1763
  *hnext = maxindex;
#line 1764
  return;
}
}
#line 1766 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_UniqueRows(ddf_rowindex OV , long p , long r , ddf_Amatrix A , long dmax ,
                    ddf_rowset preferred , long *uniqrows ) 
{ 
  long i ;
  long iuniq ;
  long j ;
  myfloat *x ;
  ddf_boolean localdebug ;
  int tmp ;
  int tmp___0 ;
  ddf_boolean tmp___1 ;

  {
#line 1778
  localdebug = 0;
#line 1780
  if (p <= 0L) {
#line 1780
    goto _L99;
  } else
#line 1780
  if (p > r) {
#line 1780
    goto _L99;
  }
#line 1781
  iuniq = p;
#line 1781
  j = 1L;
#line 1782
  x = *(A + (p - 1L));
#line 1783
  *(OV + p) = j;
#line 1784
  i = p + 1L;
  {
#line 1784
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1784
    if (! (i <= r)) {
#line 1784
      goto while_break;
    }
    {
#line 1785
    tmp___1 = ddf_LexEqual(x, *(A + (i - 1L)), dmax);
    }
#line 1785
    if (tmp___1) {
      {
#line 1793
      tmp = set_member(i, preferred);
      }
#line 1793
      if (tmp) {
        {
#line 1793
        tmp___0 = set_member(iuniq, preferred);
        }
#line 1793
        if (tmp___0) {
#line 1799
          *(OV + i) = - iuniq;
        } else {
#line 1794
          *(OV + iuniq) = - i;
#line 1795
          iuniq = i;
#line 1796
          *(OV + i) = j;
#line 1797
          x = *(A + (i - 1L));
        }
      } else {
#line 1799
        *(OV + i) = - iuniq;
      }
    } else {
#line 1787
      iuniq = i;
#line 1788
      j ++;
#line 1789
      *(OV + i) = j;
#line 1790
      x = *(A + (i - 1L));
    }
#line 1784
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1803
  *uniqrows = j;
#line 1804
  if (localdebug) {
    {
#line 1805
    printf((char const   */* __restrict  */)"The number of unique rows are %ld\n with order vector",
           *uniqrows);
#line 1806
    i = p;
    }
    {
#line 1806
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1806
      if (! (i <= r)) {
#line 1806
        goto while_break___0;
      }
      {
#line 1807
      printf((char const   */* __restrict  */)" %ld:%ld ", i, *(OV + i));
#line 1806
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1809
    printf((char const   */* __restrict  */)"\n");
    }
  }
  _L99: ;
#line 1812
  return;
}
}
#line 1814 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
long ddf_Partition(ddf_rowindex OV , long p , long r , ddf_Amatrix A , long dmax ) 
{ 
  myfloat *x ;
  long i ;
  long j ;
  long ovi ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;

  {
#line 1819
  x = *(A + (*(OV + p) - 1L));
#line 1821
  i = p - 1L;
#line 1822
  j = r + 1L;
  {
#line 1823
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1824
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1825
      j --;
#line 1824
      tmp = ddf_LexLarger(*(A + (*(OV + j) - 1L)), x, dmax);
      }
#line 1824
      if (! tmp) {
#line 1824
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1827
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1828
      i ++;
#line 1827
      tmp___0 = ddf_LexSmaller(*(A + (*(OV + i) - 1L)), x, dmax);
      }
#line 1827
      if (! tmp___0) {
#line 1827
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1830
    if (i < j) {
#line 1831
      ovi = *(OV + i);
#line 1832
      *(OV + i) = *(OV + j);
#line 1833
      *(OV + j) = ovi;
    } else {
#line 1836
      return (j);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1841 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_QuickSort(ddf_rowindex OV , long p , long r , ddf_Amatrix A , long dmax ) 
{ 
  long q ;

  {
#line 1845
  if (p < r) {
    {
#line 1846
    q = ddf_Partition(OV, p, r, A, dmax);
#line 1847
    ddf_QuickSort(OV, p, q, A, dmax);
#line 1848
    ddf_QuickSort(OV, q + 1L, r, A, dmax);
    }
  }
#line 1850
  return;
}
}
#line 1857 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_RandomPermutation(ddf_rowindex OV , long t , unsigned int seed ) 
{ 
  long k ;
  long j ;
  long ovj ;
  double u ;
  double xk ;
  double r ;
  double rand_max ;
  ddf_boolean localdebug ;
  int tmp ;

  {
  {
#line 1860
  rand_max = (double )2147483647;
#line 1861
  localdebug = 0;
#line 1863
  srand(seed);
#line 1864
  j = t;
  }
  {
#line 1864
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1864
    if (! (j > 1L)) {
#line 1864
      goto while_break;
    }
    {
#line 1865
    tmp = rand();
#line 1865
    r = (double )tmp;
#line 1866
    u = r / rand_max;
#line 1867
    xk = (double )j * u + (double )1;
#line 1868
    k = (long )xk;
    }
#line 1869
    if (localdebug) {
      {
#line 1869
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"u=%g, k=%ld, r=%g, randmax= %g\n",
              u, k, r, rand_max);
      }
    }
#line 1870
    ovj = *(OV + j);
#line 1871
    *(OV + j) = *(OV + k);
#line 1872
    *(OV + k) = ovj;
#line 1873
    if (localdebug) {
      {
#line 1873
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"row %ld is exchanged with %ld\n",
              j, k);
      }
    }
#line 1864
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1875
  return;
}
}
#line 1877 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_ComputeRowOrderVector(ddf_ConePtr cone ) 
{ 
  long i ;
  long itemp ;

  {
#line 1881
  *(cone->OrderVector + 0) = 0L;
  {
#line 1883
  if ((unsigned int )cone->HalfspaceOrder == 0U) {
#line 1883
    goto case_0;
  }
#line 1887
  if ((unsigned int )cone->HalfspaceOrder == 1U) {
#line 1887
    goto case_1;
  }
#line 1891
  if ((unsigned int )cone->HalfspaceOrder == 3U) {
#line 1891
    goto case_3;
  }
#line 1891
  if ((unsigned int )cone->HalfspaceOrder == 4U) {
#line 1891
    goto case_3;
  }
#line 1891
  if ((unsigned int )cone->HalfspaceOrder == 2U) {
#line 1891
    goto case_3;
  }
#line 1891
  if ((unsigned int )cone->HalfspaceOrder == 5U) {
#line 1891
    goto case_3;
  }
#line 1897
  if ((unsigned int )cone->HalfspaceOrder == 6U) {
#line 1897
    goto case_6;
  }
#line 1908
  if ((unsigned int )cone->HalfspaceOrder == 7U) {
#line 1908
    goto case_7;
  }
#line 1882
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1884
  i = 1L;
  {
#line 1884
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1884
    if (! (i <= cone->m)) {
#line 1884
      goto while_break;
    }
#line 1884
    *(cone->OrderVector + i) = (cone->m - i) + 1L;
#line 1884
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1885
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1888
  i = 1L;
  {
#line 1888
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1888
    if (! (i <= cone->m)) {
#line 1888
      goto while_break___0;
    }
#line 1888
    *(cone->OrderVector + i) = i;
#line 1888
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1889
  goto switch_break;
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1892
  i = 1L;
  {
#line 1892
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1892
    if (! (i <= cone->m)) {
#line 1892
      goto while_break___1;
    }
#line 1892
    *(cone->OrderVector + i) = i;
#line 1892
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1893
  ddf_RandomPermutation(cone->OrderVector, cone->m, cone->rseed);
#line 1894
  ddf_QuickSort(cone->OrderVector, 1L, cone->m, cone->A, cone->d);
  }
#line 1895
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1898
  i = 1L;
  {
#line 1898
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1898
    if (! (i <= cone->m)) {
#line 1898
      goto while_break___2;
    }
#line 1898
    *(cone->OrderVector + i) = i;
#line 1898
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1899
  ddf_RandomPermutation(cone->OrderVector, cone->m, cone->rseed);
#line 1900
  ddf_QuickSort(cone->OrderVector, 1L, cone->m, cone->A, cone->d);
#line 1901
  i = 1L;
  }
  {
#line 1901
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1901
    if (! (i <= cone->m / 2L)) {
#line 1901
      goto while_break___3;
    }
#line 1902
    itemp = *(cone->OrderVector + i);
#line 1903
    *(cone->OrderVector + i) = *(cone->OrderVector + ((cone->m - i) + 1L));
#line 1904
    *(cone->OrderVector + ((cone->m - i) + 1L)) = itemp;
#line 1901
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1906
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1909
  i = 1L;
  {
#line 1909
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1909
    if (! (i <= cone->m)) {
#line 1909
      goto while_break___4;
    }
#line 1909
    *(cone->OrderVector + i) = i;
#line 1909
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1910
  ddf_RandomPermutation(cone->OrderVector, cone->m, cone->rseed);
  }
#line 1911
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1914
  return;
}
}
#line 1916 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_UpdateRowOrderVector(ddf_ConePtr cone , ddf_rowset PriorityRows ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange j ;
  ddf_rowrange k ;
  ddf_rowrange j1___0 ;
  ddf_rowrange oj ;
  long rr ;
  ddf_boolean found ;
  ddf_boolean localdebug ;
  int tmp ;

  {
#line 1921
  j1___0 = (ddf_rowrange )0;
#line 1921
  oj = (ddf_rowrange )0;
#line 1923
  localdebug = 0;
#line 1925
  if (ddf_debug) {
#line 1925
    localdebug = 1;
  }
  {
#line 1926
  found = 1;
#line 1927
  rr = set_card(PriorityRows);
  }
#line 1928
  if (localdebug) {
    {
#line 1928
    set_fwrite(stderr, PriorityRows);
    }
  }
#line 1929
  i = (ddf_rowrange )1;
  {
#line 1929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1929
    if (! (i <= rr)) {
#line 1929
      goto while_break;
    }
#line 1930
    found = 0;
#line 1931
    j = i;
    {
#line 1931
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1931
      if (j <= cone->m) {
#line 1931
        if (! (! found)) {
#line 1931
          goto while_break___0;
        }
      } else {
#line 1931
        goto while_break___0;
      }
      {
#line 1932
      oj = *(cone->OrderVector + j);
#line 1933
      tmp = set_member(oj, PriorityRows);
      }
#line 1933
      if (tmp) {
#line 1934
        found = 1;
#line 1935
        if (localdebug) {
          {
#line 1935
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ldth in sorted list (row %ld) is in PriorityRows\n",
                  j, oj);
          }
        }
#line 1936
        j1___0 = j;
      }
#line 1931
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1939
    if (found) {
#line 1940
      if (j1___0 > i) {
#line 1942
        k = j1___0;
        {
#line 1942
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1942
          if (! (k >= i)) {
#line 1942
            goto while_break___1;
          }
#line 1942
          *(cone->OrderVector + k) = *(cone->OrderVector + (k - 1L));
#line 1942
          k --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1943
        *(cone->OrderVector + i) = oj;
#line 1944
        if (localdebug) {
          {
#line 1945
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"OrderVector updated to:\n");
#line 1946
          j = (ddf_rowrange )1;
          }
          {
#line 1946
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1946
            if (! (j <= cone->m)) {
#line 1946
              goto while_break___2;
            }
            {
#line 1946
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %2ld",
                    *(cone->OrderVector + j));
#line 1946
            j ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1947
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
          }
        }
      }
    } else {
      {
#line 1951
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"UpdateRowOrder: Error.\n");
      }
#line 1952
      goto _L99;
    }
#line 1929
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 1956
  return;
}
}
#line 1958 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_SelectPreorderedNext(ddf_ConePtr cone , ddf_rowset excluded , ddf_rowrange *hh ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange k ;
  int tmp ;

  {
#line 1962
  *hh = (ddf_rowrange )0;
#line 1963
  i = (ddf_rowrange )1;
  {
#line 1963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1963
    if (i <= cone->m) {
#line 1963
      if (! (*hh == 0L)) {
#line 1963
        goto while_break;
      }
    } else {
#line 1963
      goto while_break;
    }
    {
#line 1964
    k = *(cone->OrderVector + i);
#line 1965
    tmp = set_member(k, excluded);
    }
#line 1965
    if (! tmp) {
#line 1965
      *hh = k;
    }
#line 1963
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1967
  return;
}
}
#line 1969 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_SelectNextHalfspace(ddf_ConePtr cone , ddf_rowset excluded , ddf_rowrange *hh ) 
{ 


  {
#line 1971
  if (cone->PreOrderedRun) {
#line 1972
    if (ddf_debug) {
      {
#line 1973
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"debug ddf_SelectNextHalfspace: Use PreorderNext\n");
      }
    }
    {
#line 1975
    ddf_SelectPreorderedNext(cone, excluded, hh);
    }
  } else {
#line 1978
    if (ddf_debug) {
      {
#line 1979
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"debug ddf_SelectNextHalfspace: Use DynamicOrderedNext\n");
      }
    }
    {
#line 1984
    if ((unsigned int )cone->HalfspaceOrder == 0U) {
#line 1984
      goto case_0;
    }
#line 1988
    if ((unsigned int )cone->HalfspaceOrder == 1U) {
#line 1988
      goto case_1;
    }
#line 1992
    if ((unsigned int )cone->HalfspaceOrder == 2U) {
#line 1992
      goto case_2;
    }
#line 1996
    if ((unsigned int )cone->HalfspaceOrder == 3U) {
#line 1996
      goto case_3;
    }
#line 2000
    if ((unsigned int )cone->HalfspaceOrder == 4U) {
#line 2000
      goto case_4;
    }
#line 2004
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1985
    ddf_SelectNextHalfspace0(cone, excluded, hh);
    }
#line 1986
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1989
    ddf_SelectNextHalfspace1(cone, excluded, hh);
    }
#line 1990
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1993
    ddf_SelectNextHalfspace2(cone, excluded, hh);
    }
#line 1994
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1997
    ddf_SelectNextHalfspace3(cone, excluded, hh);
    }
#line 1998
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 2001
    ddf_SelectNextHalfspace4(cone, excluded, hh);
    }
#line 2002
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2005
    ddf_SelectNextHalfspace0(cone, excluded, hh);
    }
#line 2006
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2009
  return;
}
}
#line 2011 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_boolean ddf_Nonnegative(double *val ) 
{ 
  int tmp ;

  {
  {
#line 2014
  tmp = dddf_cmp(val, (double *)(ddf_minuszero));
  }
#line 2014
  if (tmp >= 0) {
#line 2014
    return (1);
  } else {
#line 2015
    return (0);
  }
}
}
#line 2018 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_boolean ddf_Nonpositive(double *val ) 
{ 
  int tmp ;

  {
  {
#line 2021
  tmp = dddf_cmp(val, (double *)(ddf_zero));
  }
#line 2021
  if (tmp <= 0) {
#line 2021
    return (1);
  } else {
#line 2022
    return (0);
  }
}
}
#line 2025 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_boolean ddf_Positive(double *val ) 
{ 
  ddf_boolean tmp ;
  int tmp___0 ;

  {
  {
#line 2027
  tmp = ddf_Nonpositive(val);
  }
#line 2027
  if (tmp) {
#line 2027
    tmp___0 = 0;
  } else {
#line 2027
    tmp___0 = 1;
  }
#line 2027
  return (tmp___0);
}
}
#line 2030 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_boolean ddf_Negative(double *val ) 
{ 
  ddf_boolean tmp ;
  int tmp___0 ;

  {
  {
#line 2032
  tmp = ddf_Nonnegative(val);
  }
#line 2032
  if (tmp) {
#line 2032
    tmp___0 = 0;
  } else {
#line 2032
    tmp___0 = 1;
  }
#line 2032
  return (tmp___0);
}
}
#line 2035 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_boolean ddf_EqualToZero(double *val ) 
{ 
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2037
  tmp = ddf_Nonnegative(val);
  }
#line 2037
  if (tmp) {
    {
#line 2037
    tmp___0 = ddf_Nonpositive(val);
    }
#line 2037
    if (tmp___0) {
#line 2037
      tmp___1 = 1;
    } else {
#line 2037
      tmp___1 = 0;
    }
  } else {
#line 2037
    tmp___1 = 0;
  }
#line 2037
  return (tmp___1);
}
}
#line 2040 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_boolean ddf_Nonzero(double *val ) 
{ 
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2042
  tmp = ddf_Positive(val);
  }
#line 2042
  if (tmp) {
#line 2042
    tmp___1 = 1;
  } else {
    {
#line 2042
    tmp___0 = ddf_Negative(val);
    }
#line 2042
    if (tmp___0) {
#line 2042
      tmp___1 = 1;
    } else {
#line 2042
      tmp___1 = 0;
    }
  }
#line 2042
  return (tmp___1);
}
}
#line 2045 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_boolean ddf_Equal(double *val1 , double *val2 ) 
{ 
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2047
  tmp = ddf_Larger(val1, val2);
  }
#line 2047
  if (tmp) {
#line 2047
    tmp___1 = 0;
  } else {
    {
#line 2047
    tmp___0 = ddf_Smaller(val1, val2);
    }
#line 2047
    if (tmp___0) {
#line 2047
      tmp___1 = 0;
    } else {
#line 2047
      tmp___1 = 1;
    }
  }
#line 2047
  return (tmp___1);
}
}
#line 2050 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_boolean ddf_Larger(double *val1 , double *val2 ) 
{ 
  myfloat temp ;
  ddf_boolean answer ;

  {
  {
#line 2055
  dddf_init((double *)(temp));
#line 2056
  dddf_sub((double *)(temp), val1, val2);
#line 2057
  answer = ddf_Positive((double *)(temp));
#line 2058
  dddf_clear((double *)(temp));
  }
#line 2059
  return (answer);
}
}
#line 2062 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
ddf_boolean ddf_Smaller(double *val1 , double *val2 ) 
{ 
  ddf_boolean tmp ;

  {
  {
#line 2064
  tmp = ddf_Larger(val2, val1);
  }
#line 2064
  return (tmp);
}
}
#line 2067 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_abs(double *absval , double *val ) 
{ 
  ddf_boolean tmp ;

  {
  {
#line 2069
  tmp = ddf_Negative(val);
  }
#line 2069
  if (tmp) {
    {
#line 2069
    dddf_neg(absval, val);
    }
  } else {
    {
#line 2070
    dddf_set(absval, val);
    }
  }
#line 2071
  return;
}
}
#line 2073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_LinearComb(double *lc , double *v1 , double *c1 , double *v2 , double *c2 ) 
{ 
  myfloat temp ;

  {
  {
#line 2078
  dddf_init((double *)(temp));
#line 2079
  dddf_mul(lc, v1, c1);
#line 2080
  dddf_mul((double *)(temp), v2, c2);
#line 2081
  dddf_add(lc, lc, (double *)(temp));
#line 2082
  dddf_clear((double *)(temp));
  }
#line 2083
  return;
}
}
#line 2085 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
void ddf_InnerProduct(double *prod , ddf_colrange d , ddf_Arow v1 , ddf_Arow v2 ) 
{ 
  myfloat temp ;
  ddf_colrange j ;
  ddf_boolean localdebug ;

  {
  {
#line 2089
  localdebug = 0;
#line 2091
  dddf_init((double *)(temp));
#line 2092
  dddf_set_si(prod, 0L);
#line 2093
  j = (ddf_colrange )0;
  }
  {
#line 2093
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2093
    if (! (j < d)) {
#line 2093
      goto while_break;
    }
    {
#line 2094
    dddf_mul((double *)(temp), (double *)(*(v1 + j)), (double *)(*(v2 + j)));
#line 2095
    dddf_add(prod, prod, (double *)(temp));
#line 2093
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2097
  if (localdebug) {
    {
#line 2098
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"InnerProduct:\n");
#line 2099
    ddf_WriteArow(stderr, v1, d);
#line 2100
    ddf_WriteArow(stderr, v2, d);
#line 2101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"prod =");
#line 2102
    ddf_WriteNumber(stderr, prod);
#line 2103
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 2106
  dddf_clear((double *)(temp));
  }
#line 2107
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.h"
void dddf_set_si2(double *a___41 , long b , unsigned long c ) ;
#line 115
void dddf_inv(double *a___41 , double *b ) ;
#line 117
int dddf_sgn(double *a___41 ) ;
#line 121
void ddf_set_global_constants(void) ;
#line 122
void ddf_free_global_constants(void) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
myfloat ddf_minusone ;
#line 24 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void ddf_set_global_constants(void) 
{ 


  {
  {
#line 26
  dddf_init((double *)(ddf_zero));
#line 27
  dddf_init((double *)(ddf_minuszero));
#line 28
  dddf_init((double *)(ddf_one));
#line 29
  dddf_init((double *)(ddf_minusone));
#line 30
  dddf_init((double *)(ddf_purezero));
#line 32
  time(& ddf_statStartTime);
#line 33
  ddf_statBApivots = 0L;
#line 34
  ddf_statCCpivots = 0L;
#line 35
  ddf_statDS1pivots = 0L;
#line 36
  ddf_statDS2pivots = 0L;
#line 37
  ddf_statACpivots = 0L;
#line 39
  ddf_choiceLPSolverDefault = (ddf_LPSolverType )1;
#line 40
  ddf_choiceRedcheckAlgorithm = (ddf_LPSolverType )1;
#line 41
  ddf_choiceLexicoPivotQ = 1;
#line 56
  ddf_zero[0] = 1.0E-7;
#line 57
  ddf_purezero[0] = 0.0;
#line 58
  ddf_one[0] = (double )1L;
#line 59
  ddf_minusone[0] = (double )-1L;
#line 61
  dddf_neg((double *)(ddf_minuszero), (double *)(ddf_zero));
  }
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void ddf_free_global_constants(void) 
{ 


  {
  {
#line 66
  dddf_clear((double *)(ddf_zero));
#line 67
  dddf_clear((double *)(ddf_minuszero));
#line 68
  dddf_clear((double *)(ddf_one));
#line 69
  dddf_clear((double *)(ddf_minusone));
#line 70
  dddf_clear((double *)(ddf_purezero));
#line 72
  time(& ddf_statStartTime);
#line 73
  ddf_statBApivots = 0L;
#line 74
  ddf_statCCpivots = 0L;
#line 75
  ddf_statDS1pivots = 0L;
#line 76
  ddf_statDS2pivots = 0L;
#line 77
  ddf_statACpivots = 0L;
#line 79
  ddf_choiceLPSolverDefault = (ddf_LPSolverType )1;
#line 80
  ddf_choiceRedcheckAlgorithm = (ddf_LPSolverType )1;
#line 81
  ddf_choiceLexicoPivotQ = 1;
  }
#line 87
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void dddf_init(double *a___41 ) 
{ 


  {
#line 108
  *(a___41 + 0) = (double )0L;
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void dddf_clear(double *a___41 ) 
{ 


  {
#line 114
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void dddf_set(double *a___41 , double *b ) 
{ 


  {
#line 118
  *(a___41 + 0) = *(b + 0);
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void dddf_set_d(double *a___41 , double b ) 
{ 


  {
#line 123
  *(a___41 + 0) = b;
#line 124
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void dddf_set_si(double *a___41 , long b ) 
{ 


  {
#line 128
  *(a___41 + 0) = (double )b;
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void dddf_set_si2(double *a___41 , long b , unsigned long c ) 
{ 


  {
#line 133
  *(a___41 + 0) = (double )b / (double )c;
#line 134
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void dddf_add(double *a___41 , double *b , double *c ) 
{ 


  {
#line 138
  *(a___41 + 0) = *(b + 0) + *(c + 0);
#line 139
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void dddf_sub(double *a___41 , double *b , double *c ) 
{ 


  {
#line 143
  *(a___41 + 0) = *(b + 0) - *(c + 0);
#line 144
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void dddf_mul(double *a___41 , double *b , double *c ) 
{ 


  {
#line 148
  *(a___41 + 0) = *(b + 0) * *(c + 0);
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void dddf_div(double *a___41 , double *b , double *c ) 
{ 


  {
#line 153
  *(a___41 + 0) = *(b + 0) / *(c + 0);
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void dddf_neg(double *a___41 , double *b ) 
{ 


  {
#line 158
  *(a___41 + 0) = - *(b + 0);
#line 159
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
void dddf_inv(double *a___41 , double *b ) 
{ 


  {
#line 163
  *(a___41 + 0) = (double )1 / *(b + 0);
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
int dddf_cmp(double *a___41 , double *b ) 
{ 


  {
#line 168
  if (*(a___41 + 0) - *(b + 0) > (double )0) {
#line 168
    return (1);
  } else
#line 169
  if (*(a___41 + 0) - *(b + 0) >= (double )0) {
#line 169
    return (0);
  } else {
#line 170
    return (-1);
  }
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
int dddf_sgn(double *a___41 ) 
{ 


  {
#line 175
  if (*(a___41 + 0) > (double )0) {
#line 175
    return (1);
  } else
#line 176
  if (*(a___41 + 0) >= (double )0) {
#line 176
    return (0);
  } else {
#line 177
    return (-1);
  }
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp_f.c"
double dddf_get_d(double *a___41 ) 
{ 


  {
#line 182
  return (*(a___41 + 0));
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 329 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes.h"
dd_boolean dd_log ;
#line 32 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
mytype dd_zero  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
mytype dd_one  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
mytype dd_purezero  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
mytype dd_minuszero  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
mytype dd_minusone  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
time_t dd_statStartTime  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
long dd_statBApivots  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
long dd_statCCpivots  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
long dd_statDS1pivots  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
long dd_statDS2pivots  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
long dd_statACpivots  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
long dd_statBSpivots  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
dd_LPSolverType dd_choiceLPSolverDefault  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
dd_LPSolverType dd_choiceRedcheckAlgorithm  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
dd_boolean dd_choiceLexicoPivotQ  ;
#line 70
void dd_FreeDDMemory(dd_PolyhedraPtr poly ) ;
#line 98
dd_boolean dd_DDFile2File(char *ifile , char *ofile , dd_ErrorType *err ) ;
#line 99
dd_boolean dd_DDInputAppend(dd_PolyhedraPtr *poly , dd_MatrixPtr M , dd_ErrorType *err ) ;
#line 161
void dd_WriteRunningMode(FILE *f , dd_PolyhedraPtr poly ) ;
#line 223
dd_boolean dd_DoubleDescription(dd_PolyhedraPtr poly , dd_ErrorType *err ) ;
#line 224
dd_boolean dd_DoubleDescription2(dd_PolyhedraPtr poly , dd_RowOrderType horder , dd_ErrorType *err ) ;
#line 229
void dd_AddNewHalfspace1(dd_ConePtr cone , dd_rowrange hnew ) ;
#line 230
void dd_AddNewHalfspace2(dd_ConePtr cone , dd_rowrange hnew ) ;
#line 231
void dd_AddRay(dd_ConePtr cone , mytype *p ) ;
#line 232
void dd_AddArtificialRay(dd_ConePtr cone ) ;
#line 236
void dd_ComputeRowOrderVector(dd_ConePtr cone ) ;
#line 247
void dd_CreateInitialEdges(dd_ConePtr cone ) ;
#line 254
void dd_FindInitialRays(dd_ConePtr cone , dd_boolean *found ) ;
#line 260
void dd_Normalize(dd_colrange d_size , mytype *V ) ;
#line 263
void dd_SelectNextHalfspace(dd_ConePtr cone , dd_rowset excluded , dd_rowrange *hh ) ;
#line 268
void dd_SetInequalitySets(dd_ConePtr cone ) ;
#line 274
void dd_UpdateRowOrderVector(dd_ConePtr cone , dd_rowset PriorityRows ) ;
#line 277
void dd_ZeroIndexSet(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A , mytype *x ,
                     dd_rowset ZS ) ;
#line 281
dd_ConePtr dd_ConeDataLoad(dd_PolyhedraPtr poly ) ;
#line 284
dd_boolean dd_AppendMatrix2Poly(dd_PolyhedraPtr *poly , dd_MatrixPtr M ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
dd_boolean dd_debug  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
dd_boolean dd_log  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
void dd_DDInit(dd_ConePtr cone ) 
{ 


  {
  {
#line 71
  cone->Error = (dd_ErrorType )17;
#line 72
  cone->CompStatus = (dd_CompStatusType )0;
#line 73
  cone->RayCount = 0L;
#line 74
  cone->TotalRayCount = 0L;
#line 75
  cone->FeasibleRayCount = 0L;
#line 76
  cone->WeaklyFeasibleRayCount = 0L;
#line 77
  cone->EdgeCount = 0L;
#line 78
  cone->TotalEdgeCount = 0L;
#line 79
  dd_SetInequalitySets(cone);
#line 80
  dd_ComputeRowOrderVector(cone);
#line 81
  cone->RecomputeRowOrder = 0;
  }
#line 82
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
void dd_DDMain(dd_ConePtr cone ) 
{ 
  dd_rowrange hh ;
  dd_rowrange itemp ;
  dd_rowrange otemp ;
  dd_boolean locallog ;
  int tmp ;

  {
#line 87
  locallog = dd_log;
#line 89
  if (cone->d <= 0L) {
#line 90
    cone->Iteration = cone->m;
#line 91
    cone->FeasibleRayCount = 0L;
#line 92
    cone->CompStatus = (dd_CompStatusType )1;
#line 93
    goto _L99;
  }
#line 95
  if (locallog) {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(Initially added rows ) = ");
#line 97
    set_fwrite(stderr, cone->InitialHalfspaces);
    }
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (cone->Iteration <= cone->m)) {
#line 99
      goto while_break;
    }
    {
#line 100
    dd_SelectNextHalfspace(cone, cone->WeaklyAddedHalfspaces, & hh);
#line 101
    tmp = set_member(hh, cone->NonequalitySet);
    }
#line 101
    if (tmp) {
#line 102
      if (dd_debug) {
        {
#line 103
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*The row # %3ld should be inactive and thus skipped.\n",
                hh);
        }
      }
      {
#line 105
      set_addelem(cone->WeaklyAddedHalfspaces, hh);
      }
    } else {
#line 107
      if (cone->PreOrderedRun) {
        {
#line 108
        dd_AddNewHalfspace2(cone, hh);
        }
      } else {
        {
#line 110
        dd_AddNewHalfspace1(cone, hh);
        }
      }
      {
#line 112
      set_addelem(cone->AddedHalfspaces, hh);
#line 113
      set_addelem(cone->WeaklyAddedHalfspaces, hh);
      }
    }
#line 115
    if (! cone->PreOrderedRun) {
#line 116
      itemp = (dd_rowrange )1;
      {
#line 116
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 116
        if (! (*(cone->OrderVector + itemp) != hh)) {
#line 116
          goto while_break___0;
        }
#line 116
        itemp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 117
      otemp = *(cone->OrderVector + cone->Iteration);
#line 118
      *(cone->OrderVector + cone->Iteration) = hh;
#line 120
      *(cone->OrderVector + itemp) = otemp;
    }
#line 123
    if (locallog) {
      {
#line 124
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(Iter, Row, #Total, #Curr, #Feas)= %5ld %5ld %9ld %6ld %6ld\n",
              cone->Iteration, hh, cone->TotalRayCount, cone->RayCount, cone->FeasibleRayCount);
      }
    }
#line 128
    if ((unsigned int )cone->CompStatus == 1U) {
      {
#line 129
      set_addelem(cone->AddedHalfspaces, hh);
      }
#line 130
      goto _L99;
    } else
#line 128
    if ((unsigned int )cone->CompStatus == 2U) {
      {
#line 129
      set_addelem(cone->AddedHalfspaces, hh);
      }
#line 130
      goto _L99;
    }
#line 132
    (cone->Iteration) ++;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 135
  if (cone->d <= 0L) {
#line 136
    (cone->parent)->n = (cone->LinearityDim + cone->FeasibleRayCount) - 1L;
#line 137
    (cone->parent)->ldim = cone->LinearityDim - 1L;
  } else
#line 135
  if (*(cone->newcol + 1) == 0L) {
#line 136
    (cone->parent)->n = (cone->LinearityDim + cone->FeasibleRayCount) - 1L;
#line 137
    (cone->parent)->ldim = cone->LinearityDim - 1L;
  } else {
#line 139
    (cone->parent)->n = cone->LinearityDim + cone->FeasibleRayCount;
#line 140
    (cone->parent)->ldim = cone->LinearityDim;
  }
#line 142
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2  ;
#line 150
void dd_InitialDataSetup(dd_ConePtr cone ) ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___1  =    (dd_colrange )0;
#line 145 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
void dd_InitialDataSetup(dd_ConePtr cone ) 
{ 
  long j ;
  long r ;
  dd_rowset ZSet ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 152
  if (last_d___1 < cone->d) {
#line 153
    if (last_d___1 > 0L) {
#line 154
      j = 0L;
      {
#line 154
      while (1) {
        while_continue: /* CIL Label */ ;
#line 154
        if (! (j < last_d___1)) {
#line 154
          goto while_break;
        }
        {
#line 155
        __gmpq_clear(*(Vector1 + j));
#line 156
        __gmpq_clear(*(Vector2 + j));
#line 154
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 158
      free((void *)Vector1);
#line 158
      free((void *)Vector2);
      }
    }
    {
#line 160
    tmp = calloc((size_t )cone->d, sizeof(mytype ));
#line 160
    Vector1 = (mytype *)tmp;
#line 161
    tmp___0 = calloc((size_t )cone->d, sizeof(mytype ));
#line 161
    Vector2 = (mytype *)tmp___0;
#line 162
    j = 0L;
    }
    {
#line 162
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 162
      if (! (j < cone->d)) {
#line 162
        goto while_break___0;
      }
      {
#line 163
      __gmpq_init(*(Vector1 + j));
#line 164
      __gmpq_init(*(Vector2 + j));
#line 162
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 166
    last_d___1 = cone->d;
  }
  {
#line 169
  cone->RecomputeRowOrder = 0;
#line 170
  cone->ArtificialRay = (dd_RayPtr )((void *)0);
#line 171
  cone->FirstRay = (dd_RayPtr )((void *)0);
#line 172
  cone->LastRay = (dd_RayPtr )((void *)0);
#line 173
  set_initialize(& ZSet, cone->m);
#line 174
  dd_AddArtificialRay(cone);
#line 175
  set_copy(cone->AddedHalfspaces, cone->InitialHalfspaces);
#line 176
  set_copy(cone->WeaklyAddedHalfspaces, cone->InitialHalfspaces);
#line 177
  dd_UpdateRowOrderVector(cone, cone->InitialHalfspaces);
#line 178
  r = 1L;
  }
  {
#line 178
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 178
    if (! (r <= cone->d)) {
#line 178
      goto while_break___1;
    }
#line 179
    j = 0L;
    {
#line 179
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 179
      if (! (j < cone->d)) {
#line 179
        goto while_break___2;
      }
      {
#line 180
      __gmpq_set(*(Vector1 + j), (mpq_srcptr )(*(*(cone->B + j) + (r - 1L))));
#line 181
      __gmpq_neg(*(Vector2 + j), (mpq_srcptr )(*(*(cone->B + j) + (r - 1L))));
#line 179
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 183
    dd_Normalize(cone->d, Vector1);
#line 184
    dd_Normalize(cone->d, Vector2);
#line 185
    dd_ZeroIndexSet(cone->m, cone->d, cone->A, Vector1, ZSet);
#line 186
    tmp___1 = set_subset(cone->EqualitySet, ZSet);
    }
#line 186
    if (tmp___1) {
#line 187
      if (dd_debug) {
        {
#line 188
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"add an initial ray with zero set:");
#line 189
        set_fwrite(stderr, ZSet);
        }
      }
      {
#line 191
      dd_AddRay(cone, Vector1);
      }
#line 192
      if (*(cone->InitialRayIndex + r) == 0L) {
        {
#line 193
        dd_AddRay(cone, Vector2);
        }
#line 194
        if (dd_debug) {
          {
#line 195
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"and add its negative also.\n");
          }
        }
      }
    }
#line 178
    r ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 200
  dd_CreateInitialEdges(cone);
#line 201
  cone->Iteration = cone->d + 1L;
  }
#line 202
  if (cone->Iteration > cone->m) {
#line 202
    cone->CompStatus = (dd_CompStatusType )1;
  }
  {
#line 203
  set_free(ZSet);
  }
#line 204
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
dd_boolean dd_CheckEmptiness(dd_PolyhedraPtr poly , dd_ErrorType *err ) 
{ 
  dd_rowset R ;
  dd_rowset S ;
  dd_MatrixPtr M ;
  dd_boolean answer ;
  dd_boolean tmp ;

  {
#line 209
  M = (dd_MatrixPtr )((void *)0);
#line 210
  answer = 0;
#line 212
  *err = (dd_ErrorType )17;
#line 214
  if ((unsigned int )poly->representation == 1U) {
    {
#line 215
    M = dd_CopyInequalities(poly);
#line 216
    set_initialize(& R, M->rowsize);
#line 217
    set_initialize(& S, M->rowsize);
#line 218
    tmp = dd_ExistsRestrictedFace(M, R, S, err);
    }
#line 218
    if (! tmp) {
#line 219
      (poly->child)->CompStatus = (dd_CompStatusType )1;
#line 220
      poly->IsEmpty = 1;
#line 221
      poly->n = (dd_bigrange )0;
#line 222
      answer = 1;
    }
    {
#line 224
    set_free(R);
#line 225
    set_free(S);
#line 226
    dd_FreeMatrix(M);
    }
  } else
#line 227
  if ((unsigned int )poly->representation == 2U) {
#line 227
    if (poly->m <= 0L) {
#line 228
      *err = (dd_ErrorType )3;
#line 229
      poly->IsEmpty = 1;
#line 230
      (poly->child)->CompStatus = (dd_CompStatusType )1;
#line 231
      answer = 1;
#line 232
      (poly->child)->Error = *err;
    }
  }
#line 235
  return (answer);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
dd_boolean dd_DoubleDescription(dd_PolyhedraPtr poly , dd_ErrorType *err ) 
{ 
  dd_ConePtr cone ;
  dd_boolean found ;

  {
#line 241
  cone = (dd_ConePtr )((void *)0);
#line 242
  found = 0;
#line 244
  *err = (dd_ErrorType )17;
#line 246
  if ((unsigned long )poly != (unsigned long )((void *)0)) {
#line 246
    if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 246
      goto _L;
    } else
#line 246
    if ((unsigned int )(poly->child)->CompStatus != 1U) {
      _L: /* CIL Label */ 
      {
#line 247
      cone = dd_ConeDataLoad(poly);
#line 249
      time(& cone->starttime);
#line 250
      dd_DDInit(cone);
      }
#line 251
      if ((unsigned int )poly->representation == 2U) {
#line 251
        if (poly->m <= 0L) {
#line 252
          *err = (dd_ErrorType )3;
#line 253
          cone->Error = *err;
#line 254
          goto _L99;
        }
      }
      {
#line 257
      dd_CheckEmptiness(poly, err);
      }
#line 259
      if ((unsigned int )cone->CompStatus != 1U) {
        {
#line 260
        dd_FindInitialRays(cone, & found);
        }
#line 261
        if (found) {
          {
#line 262
          dd_InitialDataSetup(cone);
          }
#line 263
          if ((unsigned int )cone->CompStatus == 1U) {
#line 263
            goto _L99;
          }
          {
#line 264
          dd_DDMain(cone);
          }
#line 265
          if (cone->FeasibleRayCount != cone->RayCount) {
#line 265
            *err = (dd_ErrorType )16;
          }
        }
      }
      {
#line 268
      time(& cone->endtime);
      }
    }
  }
  _L99: ;
#line 273
  return (found);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
dd_boolean dd_DoubleDescription2(dd_PolyhedraPtr poly , dd_RowOrderType horder , dd_ErrorType *err ) 
{ 
  dd_ConePtr cone ;
  dd_boolean found ;

  {
#line 278
  cone = (dd_ConePtr )((void *)0);
#line 279
  found = 0;
#line 281
  *err = (dd_ErrorType )17;
#line 283
  if ((unsigned long )poly != (unsigned long )((void *)0)) {
#line 283
    if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 283
      goto _L;
    } else
#line 283
    if ((unsigned int )(poly->child)->CompStatus != 1U) {
      _L: /* CIL Label */ 
      {
#line 284
      cone = dd_ConeDataLoad(poly);
#line 286
      cone->HalfspaceOrder = horder;
#line 287
      time(& cone->starttime);
#line 288
      dd_DDInit(cone);
      }
#line 289
      if ((unsigned int )poly->representation == 2U) {
#line 289
        if (poly->m <= 0L) {
#line 290
          *err = (dd_ErrorType )3;
#line 291
          cone->Error = *err;
#line 292
          goto _L99;
        }
      }
      {
#line 295
      dd_CheckEmptiness(poly, err);
      }
#line 297
      if ((unsigned int )cone->CompStatus != 1U) {
        {
#line 298
        dd_FindInitialRays(cone, & found);
        }
#line 299
        if (found) {
          {
#line 300
          dd_InitialDataSetup(cone);
          }
#line 301
          if ((unsigned int )cone->CompStatus == 1U) {
#line 301
            goto _L99;
          }
          {
#line 302
          dd_DDMain(cone);
          }
#line 303
          if (cone->FeasibleRayCount != cone->RayCount) {
#line 303
            *err = (dd_ErrorType )16;
          }
        }
      }
      {
#line 306
      time(& cone->endtime);
      }
    }
  }
  _L99: ;
#line 311
  return (found);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
dd_boolean dd_DDInputAppend(dd_PolyhedraPtr *poly , dd_MatrixPtr M , dd_ErrorType *err ) 
{ 
  dd_boolean found ;
  dd_ErrorType error ;

  {
#line 321
  if ((unsigned long )(*poly)->child != (unsigned long )((void *)0)) {
    {
#line 321
    dd_FreeDDMemory(*poly);
    }
  }
  {
#line 322
  dd_AppendMatrix2Poly(poly, M);
#line 323
  (*poly)->representation = (dd_RepresentationType )1;
#line 324
  found = dd_DoubleDescription(*poly, & error);
#line 325
  *err = error;
  }
#line 326
  return (found);
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
dd_boolean dd_DDFile2File(char *ifile , char *ofile , dd_ErrorType *err ) 
{ 
  dd_boolean found ;
  FILE *reading___0 ;
  FILE *writing___0 ;
  dd_PolyhedraPtr poly ;
  dd_MatrixPtr M ;
  dd_MatrixPtr A ;
  dd_MatrixPtr G ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 333
  found = 1;
#line 334
  reading___0 = (FILE *)((void *)0);
#line 334
  writing___0 = (FILE *)((void *)0);
#line 338
  tmp = strcmp((char const   *)ifile, "**stdin");
  }
#line 338
  if (tmp == 0) {
#line 339
    reading___0 = stdin;
  } else {
    {
#line 340
    reading___0 = fopen((char const   */* __restrict  */)ifile, (char const   */* __restrict  */)"r");
    }
#line 340
    if ((unsigned long )reading___0 != (unsigned long )((void *)0)) {
      {
#line 341
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"input file %s is open\n",
              ifile);
      }
    } else {
      {
#line 344
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The input file %s not found\n",
              ifile);
#line 345
      found = 0;
#line 346
      *err = (dd_ErrorType )6;
      }
#line 347
      goto _L99;
    }
  }
#line 350
  if (found) {
    {
#line 351
    tmp___0 = strcmp((char const   *)ofile, "**stdout");
    }
#line 351
    if (tmp___0 == 0) {
#line 352
      writing___0 = stdout;
    } else {
      {
#line 353
      writing___0 = fopen((char const   */* __restrict  */)ofile, (char const   */* __restrict  */)"w");
      }
#line 353
      if ((unsigned long )writing___0 != (unsigned long )((void *)0)) {
        {
#line 354
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output file %s is open\n",
                ofile);
#line 355
        found = 1;
        }
      } else {
        {
#line 357
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The output file %s cannot be opened\n",
                ofile);
#line 358
        found = 0;
#line 359
        *err = (dd_ErrorType )7;
        }
#line 360
        goto _L99;
      }
    }
  }
  {
#line 364
  M = dd_PolyFile2Matrix(reading___0, err);
  }
#line 365
  if ((unsigned int )*err != 17U) {
#line 366
    goto _L99;
  }
  {
#line 367
  poly = dd_DDMatrix2Poly(M, err);
#line 367
  dd_FreeMatrix(M);
  }
#line 369
  if ((unsigned int )*err == 17U) {
    {
#line 370
    dd_WriteRunningMode(writing___0, poly);
#line 371
    A = dd_CopyInequalities(poly);
#line 372
    G = dd_CopyGenerators(poly);
    }
#line 374
    if ((unsigned int )poly->representation == 1U) {
      {
#line 375
      dd_WriteMatrix(writing___0, G);
      }
    } else {
      {
#line 377
      dd_WriteMatrix(writing___0, A);
      }
    }
    {
#line 380
    dd_FreePolyhedra(poly);
#line 381
    dd_FreeMatrix(A);
#line 382
    dd_FreeMatrix(G);
    }
  }
  _L99: ;
#line 386
  if ((unsigned int )*err != 17U) {
    {
#line 386
    dd_WriteErrorMessages(stderr, *err);
    }
  }
#line 387
  if ((unsigned long )reading___0 != (unsigned long )((void *)0)) {
    {
#line 387
    fclose(reading___0);
    }
  }
#line 388
  if ((unsigned long )writing___0 != (unsigned long )((void *)0)) {
    {
#line 388
    fclose(writing___0);
    }
  }
#line 389
  return (found);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
ddf_boolean ddf_Redundant(ddf_MatrixPtr M , ddf_rowrange itest , ddf_Arow certificate ,
                          ddf_ErrorType *error ) ;
#line 106
ddf_rowset ddf_RedundantRows(ddf_MatrixPtr M , ddf_ErrorType *error ) ;
#line 107
ddf_boolean ddf_SRedundant(ddf_MatrixPtr M , ddf_rowrange itest , ddf_Arow certificate ,
                           ddf_ErrorType *error ) ;
#line 108
ddf_rowset ddf_SRedundantRows(ddf_MatrixPtr M , ddf_ErrorType *error ) ;
#line 109
ddf_rowset ddf_RedundantRowsViaShooting(ddf_MatrixPtr M , ddf_ErrorType *error ) ;
#line 110
ddf_rowrange ddf_RayShooting(ddf_MatrixPtr M , ddf_Arow p , ddf_Arow r ) ;
#line 112
ddf_boolean ddf_ImplicitLinearity(ddf_MatrixPtr M , ddf_rowrange itest , ddf_Arow certificate ,
                                  ddf_ErrorType *error ) ;
#line 113
ddf_rowset ddf_ImplicitLinearityRows(ddf_MatrixPtr M , ddf_ErrorType *error ) ;
#line 114
int ddf_FreeOfImplicitLinearity(ddf_MatrixPtr M , ddf_Arow certificate , ddf_rowset *imp_linrows ,
                                ddf_ErrorType *error ) ;
#line 115
ddf_boolean ddf_MatrixCanonicalizeLinearity(ddf_MatrixPtr *M , ddf_rowset *impl_linset ,
                                            ddf_rowindex *newpos , ddf_ErrorType *error ) ;
#line 116
ddf_boolean ddf_MatrixCanonicalize(ddf_MatrixPtr *M , ddf_rowset *impl_linset , ddf_rowset *redset ,
                                   ddf_rowindex *newpos , ddf_ErrorType *error ) ;
#line 117
ddf_boolean ddf_MatrixRedundancyRemove(ddf_MatrixPtr *M , ddf_rowset *redset , ddf_rowindex *newpos ,
                                       ddf_ErrorType *error ) ;
#line 118
ddf_boolean ddf_FindRelativeInterior(ddf_MatrixPtr M , ddf_rowset *ImL , ddf_rowset *Lbasis ,
                                     ddf_LPSolutionPtr *lps , ddf_ErrorType *err ) ;
#line 119
ddf_boolean ddf_ExistsRestrictedFace(ddf_MatrixPtr M , ddf_rowset R , ddf_rowset S ,
                                     ddf_ErrorType *err ) ;
#line 120
ddf_boolean ddf_ExistsRestrictedFace2(ddf_MatrixPtr M , ddf_rowset R , ddf_rowset S ,
                                      ddf_LPSolutionPtr *lps , ddf_ErrorType *err ) ;
#line 122
ddf_SetFamilyPtr ddf_Matrix2Adjacency(ddf_MatrixPtr M , ddf_ErrorType *error ) ;
#line 123
ddf_SetFamilyPtr ddf_Matrix2WeakAdjacency(ddf_MatrixPtr M , ddf_ErrorType *error ) ;
#line 176
ddf_LPPtr ddf_Matrix2LP(ddf_MatrixPtr M , ddf_ErrorType *err ) ;
#line 179
ddf_LPPtr ddf_Matrix2Feasibility(ddf_MatrixPtr M , ddf_ErrorType *err ) ;
#line 182
ddf_LPPtr ddf_Matrix2Feasibility2(ddf_MatrixPtr M , ddf_rowset R , ddf_rowset S ,
                                  ddf_ErrorType *err ) ;
#line 186
ddf_boolean ddf_LPSolve(ddf_LPPtr lp , ddf_LPSolverType solver , ddf_ErrorType *err ) ;
#line 187
ddf_boolean ddf_LPSolve0(ddf_LPPtr lp , ddf_LPSolverType solver , ddf_ErrorType *err ) ;
#line 191
ddf_LPPtr ddf_MakeLPforInteriorFinding(ddf_LPPtr lp ) ;
#line 192
ddf_LPSolutionPtr ddf_CopyLPSolution(ddf_LPPtr lp ) ;
#line 196
int ddf_LPReverseRow(ddf_LPPtr lp , ddf_rowrange i ) ;
#line 198
int ddf_LPReplaceRow(ddf_LPPtr lp , ddf_rowrange i , ddf_Arow a___41 ) ;
#line 200
ddf_Arow ddf_LPCopyRow(ddf_LPPtr lp , ddf_rowrange i ) ;
#line 204
void ddf_FreeLPSolution(ddf_LPSolutionPtr lps ) ;
#line 273
void ddf_TableauEntry(myfloat *x , ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix X ,
                      ddf_Bmatrix T , ddf_rowrange r , ddf_colrange s ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_CrissCrossMinimize(ddf_LPPtr lp , ddf_ErrorType *err ) ;
#line 38
void ddf_CrissCrossMaximize(ddf_LPPtr lp , ddf_ErrorType *err ) ;
#line 39
void ddf_DualSimplexMinimize(ddf_LPPtr lp , ddf_ErrorType *err ) ;
#line 40
void ddf_DualSimplexMaximize(ddf_LPPtr lp , ddf_ErrorType *err ) ;
#line 41
void ddf_FindLPBasis(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A , ddf_Bmatrix T ,
                     ddf_rowindex OV , ddf_rowset equalityset , ddf_colindex nbindex ,
                     ddf_rowindex bflag___97 , ddf_rowrange objrow , ddf_colrange rhscol ,
                     ddf_colrange *cs , int *found , ddf_LPStatusType *lps , long *pivot_no ) ;
#line 44
void ddf_FindDualFeasibleBasis(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                               ddf_Bmatrix T , ddf_rowindex OV , ddf_colindex nbindex ,
                               long *bflag___97 , ddf_rowrange objrow , ddf_colrange rhscol ,
                               ddf_boolean lexicopivot , ddf_colrange *s , ddf_ErrorType *err ,
                               ddf_LPStatusType *lps , long *pivot_no , long maxpivots ) ;
#line 60
void ddf_SetNumberType(char *line , ddf_NumberType *number , ddf_ErrorType *Error ) ;
#line 61
void ddf_ComputeRowOrderVector2(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                                ddf_rowindex OV , ddf_RowOrderType ho , unsigned int rseed ) ;
#line 63
void ddf_SelectPreorderedNext2(ddf_rowrange m_size , ddf_colrange d_size , rowset excluded ,
                               ddf_rowindex OV , ddf_rowrange *hnext ) ;
#line 65
void ddf_SetSolutions(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                      ddf_Bmatrix T , ddf_rowrange objrow , ddf_colrange rhscol ,
                      ddf_LPStatusType LPS , myfloat *optvalue , ddf_Arow sol , ddf_Arow dsol ,
                      ddf_rowset posset , ddf_colindex nbindex , ddf_rowrange re ,
                      ddf_colrange se , ddf_rowindex bflag___97 ) ;
#line 69
void ddf_WriteTableau(FILE *f , ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                      ddf_Bmatrix T , ddf_colindex nbindex , ddf_rowindex bflag___97 ) ;
#line 72
void ddf_WriteSignTableau(FILE *f , ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                          ddf_Bmatrix T , ddf_colindex nbindex , ddf_rowindex bflag___97 ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_LPSolutionPtr ddf_CopyLPSolution(ddf_LPPtr lp ) 
{ 
  ddf_LPSolutionPtr lps ;
  ddf_colrange j ;
  long i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 82
  tmp = calloc((size_t )1, sizeof(ddf_LPSolutionType ));
#line 82
  lps = (ddf_LPSolutionPtr )tmp;
#line 83
  i = 1L;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i <= 255L)) {
#line 83
      goto while_break;
    }
#line 83
    lps->filename[i - 1L] = lp->filename[i - 1L];
#line 83
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  lps->objective = lp->objective;
#line 85
  lps->solver = lp->solver;
#line 86
  lps->m = lp->m;
#line 87
  lps->d = lp->d;
#line 88
  lps->numbtype = lp->numbtype;
#line 90
  lps->LPS = lp->LPS;
#line 91
  dddf_init((double *)(lps->optvalue));
#line 92
  dddf_set((double *)(lps->optvalue), (double *)(lp->optvalue));
#line 93
  ddf_InitializeArow(lp->d + 1L, & lps->sol);
#line 94
  ddf_InitializeArow(lp->d + 1L, & lps->dsol);
#line 95
  tmp___0 = calloc((size_t )(lp->d + 1L), sizeof(long ));
#line 95
  lps->nbindex = (long *)tmp___0;
#line 96
  j = (ddf_colrange )0;
  }
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! (j <= lp->d)) {
#line 96
      goto while_break___0;
    }
    {
#line 97
    dddf_set((double *)(*(lps->sol + j)), (double *)(*(lp->sol + j)));
#line 98
    dddf_set((double *)(*(lps->dsol + j)), (double *)(*(lp->dsol + j)));
#line 99
    *(lps->nbindex + j) = *(lp->nbindex + j);
#line 96
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  lps->pivots[0] = lp->pivots[0];
#line 102
  lps->pivots[1] = lp->pivots[1];
#line 103
  lps->pivots[2] = lp->pivots[2];
#line 104
  lps->pivots[3] = lp->pivots[3];
#line 105
  lps->pivots[4] = lp->pivots[4];
#line 106
  lps->total_pivots = lp->total_pivots;
#line 108
  return (lps);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_LPPtr ddf_CreateLPData(ddf_LPObjectiveType obj , ddf_NumberType nt , ddf_rowrange m ,
                           ddf_colrange d ) 
{ 
  ddf_LPType *lp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 117
  tmp = calloc((size_t )1, sizeof(ddf_LPType ));
#line 117
  lp = (ddf_LPPtr )tmp;
#line 118
  lp->solver = ddf_choiceLPSolverDefault;
#line 119
  lp->d = d;
#line 120
  lp->m = m;
#line 121
  lp->numbtype = nt;
#line 122
  lp->objrow = m;
#line 123
  lp->rhscol = 1L;
#line 124
  lp->objective = (ddf_LPObjectiveType )0;
#line 125
  lp->LPS = (ddf_LPStatusType )0;
#line 126
  lp->eqnumber = (ddf_rowrange )0;
#line 128
  tmp___0 = calloc((size_t )(d + 1L), sizeof(long ));
#line 128
  lp->nbindex = (long *)tmp___0;
#line 129
  tmp___1 = calloc((size_t )(d + 1L), sizeof(long ));
#line 129
  lp->given_nbindex = (long *)tmp___1;
#line 130
  set_initialize(& lp->equalityset, m);
#line 133
  lp->redcheck_extensive = 0;
#line 134
  lp->ired = (ddf_rowrange )0;
#line 135
  set_initialize(& lp->redset_extra, m);
#line 137
  set_initialize(& lp->redset_accum, m);
#line 139
  set_initialize(& lp->posset_extra, m);
#line 141
  lp->lexicopivot = ddf_choiceLexicoPivotQ;
#line 143
  lp->m_alloc = lp->m + 2L;
#line 144
  lp->d_alloc = lp->d + 2L;
#line 145
  lp->objective = obj;
#line 146
  ddf_InitializeBmatrix(lp->d_alloc, & lp->B);
#line 147
  ddf_InitializeAmatrix(lp->m_alloc, lp->d_alloc, & lp->A);
#line 148
  ddf_InitializeArow(lp->d_alloc, & lp->sol);
#line 149
  ddf_InitializeArow(lp->d_alloc, & lp->dsol);
#line 150
  dddf_init((double *)(lp->optvalue));
  }
#line 151
  return (lp);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_LPPtr ddf_Matrix2LP(ddf_MatrixPtr M , ddf_ErrorType *err ) 
{ 
  ddf_rowrange m ;
  ddf_rowrange i ;
  ddf_rowrange irev ;
  ddf_rowrange linc ;
  ddf_colrange d ;
  ddf_colrange j ;
  ddf_LPType *lp ;
  ddf_boolean localdebug ;
  int tmp ;
  ddf_boolean tmp___0 ;

  {
  {
#line 160
  localdebug = 0;
#line 162
  *err = (ddf_ErrorType )17;
#line 163
  linc = set_card(M->linset);
#line 164
  m = (M->rowsize + 1L) + linc;
#line 167
  d = M->colsize;
  }
#line 168
  if (localdebug) {
    {
#line 168
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"number of equalities = %ld\n",
            linc);
    }
  }
  {
#line 170
  lp = ddf_CreateLPData(M->objective, M->numbtype, m, d);
#line 171
  lp->Homogeneous = 1;
#line 172
  lp->eqnumber = linc;
#line 174
  irev = M->rowsize;
#line 175
  i = (ddf_rowrange )1;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i <= M->rowsize)) {
#line 175
      goto while_break;
    }
    {
#line 176
    tmp = set_member(i, M->linset);
    }
#line 176
    if (tmp) {
      {
#line 177
      irev ++;
#line 178
      set_addelem(lp->equalityset, i);
#line 180
      j = (ddf_colrange )1;
      }
      {
#line 180
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 180
        if (! (j <= M->colsize)) {
#line 180
          goto while_break___0;
        }
        {
#line 181
        dddf_neg((double *)(*(*(lp->A + (irev - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
#line 180
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 183
      if (localdebug) {
        {
#line 183
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"equality row %ld generates the reverse row %ld.\n",
                i, irev);
        }
      }
    }
#line 185
    j = (ddf_colrange )1;
    {
#line 185
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 185
      if (! (j <= M->colsize)) {
#line 185
        goto while_break___1;
      }
      {
#line 186
      dddf_set((double *)(*(*(lp->A + (i - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
      }
#line 187
      if (j == 1L) {
#line 187
        if (i < M->rowsize) {
          {
#line 187
          tmp___0 = ddf_Nonzero((double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
          }
#line 187
          if (tmp___0) {
#line 187
            lp->Homogeneous = 0;
          }
        }
      }
#line 185
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 175
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  j = (ddf_colrange )1;
  {
#line 190
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 190
    if (! (j <= M->colsize)) {
#line 190
      goto while_break___2;
    }
    {
#line 191
    dddf_set((double *)(*(*(lp->A + (m - 1L)) + (j - 1L))), (double *)(*(M->rowvec + (j - 1L))));
#line 190
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 194
  return (lp);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_LPPtr ddf_Matrix2Feasibility(ddf_MatrixPtr M , ddf_ErrorType *err ) 
{ 
  ddf_rowrange m ;
  ddf_rowrange linc ;
  ddf_colrange j ;
  ddf_LPType *lp ;

  {
  {
#line 209
  *err = (ddf_ErrorType )17;
#line 210
  linc = set_card(M->linset);
#line 211
  m = (M->rowsize + 1L) + linc;
#line 215
  lp = ddf_Matrix2LP(M, err);
#line 216
  lp->objective = (ddf_LPObjectiveType )1;
#line 217
  j = (ddf_colrange )1;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (j <= M->colsize)) {
#line 217
      goto while_break;
    }
    {
#line 218
    dddf_set((double *)(*(*(lp->A + (m - 1L)) + (j - 1L))), (double *)(ddf_purezero));
#line 217
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return (lp);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_LPPtr ddf_Matrix2Feasibility2(ddf_MatrixPtr M , ddf_rowset R , ddf_rowset S ,
                                  ddf_ErrorType *err ) 
{ 
  ddf_rowrange m ;
  ddf_rowrange i ;
  ddf_rowrange irev ;
  ddf_rowrange linc ;
  ddf_colrange d ;
  ddf_colrange j ;
  ddf_LPType *lp ;
  ddf_rowset L ;
  ddf_boolean localdebug ;
  int tmp ;
  int tmp___0 ;
  ddf_boolean tmp___1 ;

  {
  {
#line 254
  localdebug = 0;
#line 256
  *err = (ddf_ErrorType )17;
#line 257
  set_initialize(& L, M->rowsize);
#line 258
  set_uni(L, M->linset, R);
#line 259
  linc = set_card(L);
#line 260
  m = ((M->rowsize + 1L) + linc) + 1L;
#line 263
  d = M->colsize + 1L;
  }
#line 264
  if (localdebug) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"number of equalities = %ld\n",
            linc);
    }
  }
  {
#line 266
  lp = ddf_CreateLPData((ddf_LPObjectiveType )1, M->numbtype, m, d);
#line 267
  lp->Homogeneous = 1;
#line 268
  lp->eqnumber = linc;
#line 270
  irev = M->rowsize;
#line 271
  i = (ddf_rowrange )1;
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! (i <= M->rowsize)) {
#line 271
      goto while_break;
    }
    {
#line 272
    tmp___0 = set_member(i, L);
    }
#line 272
    if (tmp___0) {
      {
#line 273
      irev ++;
#line 274
      set_addelem(lp->equalityset, i);
#line 276
      j = (ddf_colrange )1;
      }
      {
#line 276
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 276
        if (! (j <= M->colsize)) {
#line 276
          goto while_break___0;
        }
        {
#line 277
        dddf_neg((double *)(*(*(lp->A + (irev - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
#line 276
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 279
      if (localdebug) {
        {
#line 279
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"equality row %ld generates the reverse row %ld.\n",
                i, irev);
        }
      }
    } else {
      {
#line 280
      tmp = set_member(i, S);
      }
#line 280
      if (tmp) {
        {
#line 281
        dddf_set((double *)(*(*(lp->A + (i - 1L)) + M->colsize)), (double *)(ddf_minusone));
        }
      }
    }
#line 283
    j = (ddf_colrange )1;
    {
#line 283
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 283
      if (! (j <= M->colsize)) {
#line 283
        goto while_break___1;
      }
      {
#line 284
      dddf_set((double *)(*(*(lp->A + (i - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
      }
#line 285
      if (j == 1L) {
#line 285
        if (i < M->rowsize) {
          {
#line 285
          tmp___1 = ddf_Nonzero((double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
          }
#line 285
          if (tmp___1) {
#line 285
            lp->Homogeneous = 0;
          }
        }
      }
#line 283
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 271
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  j = (ddf_colrange )1;
  {
#line 288
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 288
    if (! (j <= d)) {
#line 288
      goto while_break___2;
    }
    {
#line 289
    dddf_set((double *)(*(*(lp->A + (m - 2L)) + (j - 1L))), (double *)(ddf_purezero));
#line 288
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 291
  dddf_set((double *)(*(*(lp->A + (m - 2L)) + 0)), (double *)(ddf_one));
#line 292
  dddf_set((double *)(*(*(lp->A + (m - 2L)) + M->colsize)), (double *)(ddf_minusone));
#line 293
  j = (ddf_colrange )1;
  }
  {
#line 293
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 293
    if (! (j <= d)) {
#line 293
      goto while_break___3;
    }
    {
#line 294
    dddf_set((double *)(*(*(lp->A + (m - 1L)) + (j - 1L))), (double *)(ddf_purezero));
#line 293
    j ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 296
  dddf_set((double *)(*(*(lp->A + (m - 1L)) + M->colsize)), (double *)(ddf_one));
#line 298
  set_free(L);
  }
#line 299
  return (lp);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_FreeLPData(ddf_LPPtr lp ) 
{ 


  {
#line 306
  if ((unsigned long )lp != (unsigned long )((void *)0)) {
    {
#line 307
    dddf_clear((double *)(lp->optvalue));
#line 308
    ddf_FreeArow(lp->d_alloc, lp->dsol);
#line 309
    ddf_FreeArow(lp->d_alloc, lp->sol);
#line 310
    ddf_FreeBmatrix(lp->d_alloc, lp->B);
#line 311
    ddf_FreeAmatrix(lp->m_alloc, lp->d_alloc, lp->A);
#line 312
    set_free(lp->equalityset);
#line 313
    set_free(lp->redset_extra);
#line 314
    set_free(lp->redset_accum);
#line 315
    set_free(lp->posset_extra);
#line 316
    free((void *)lp->nbindex);
#line 317
    free((void *)lp->given_nbindex);
#line 318
    free((void *)lp);
    }
  }
#line 320
  return;
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_FreeLPSolution(ddf_LPSolutionPtr lps ) 
{ 


  {
#line 324
  if ((unsigned long )lps != (unsigned long )((void *)0)) {
    {
#line 325
    free((void *)lps->nbindex);
#line 326
    ddf_FreeArow(lps->d + 1L, lps->dsol);
#line 327
    ddf_FreeArow(lps->d + 1L, lps->sol);
#line 328
    dddf_clear((double *)(lps->optvalue));
#line 330
    free((void *)lps);
    }
  }
#line 332
  return;
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
int ddf_LPReverseRow(ddf_LPPtr lp , ddf_rowrange i ) 
{ 
  ddf_colrange j ;
  int success ;

  {
#line 337
  success = 0;
#line 339
  if (i >= 1L) {
#line 339
    if (i <= lp->m) {
#line 340
      lp->LPS = (ddf_LPStatusType )0;
#line 341
      j = (ddf_colrange )1;
      {
#line 341
      while (1) {
        while_continue: /* CIL Label */ ;
#line 341
        if (! (j <= lp->d)) {
#line 341
          goto while_break;
        }
        {
#line 342
        dddf_neg((double *)(*(*(lp->A + (i - 1L)) + (j - 1L))), (double *)(*(*(lp->A + (i - 1L)) + (j - 1L))));
#line 341
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 345
      success = 1;
    }
  }
#line 347
  return (success);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
int ddf_LPReplaceRow(ddf_LPPtr lp , ddf_rowrange i , ddf_Arow a___41 ) 
{ 
  ddf_colrange j ;
  int success ;

  {
#line 353
  success = 0;
#line 355
  if (i >= 1L) {
#line 355
    if (i <= lp->m) {
#line 356
      lp->LPS = (ddf_LPStatusType )0;
#line 357
      j = (ddf_colrange )1;
      {
#line 357
      while (1) {
        while_continue: /* CIL Label */ ;
#line 357
        if (! (j <= lp->d)) {
#line 357
          goto while_break;
        }
        {
#line 358
        dddf_set((double *)(*(*(lp->A + (i - 1L)) + (j - 1L))), (double *)(*(a___41 + (j - 1L))));
#line 357
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 361
      success = 1;
    }
  }
#line 363
  return (success);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_Arow ddf_LPCopyRow(ddf_LPPtr lp , ddf_rowrange i ) 
{ 
  ddf_colrange j ;
  ddf_Arow a___41 ;

  {
#line 371
  if (i >= 1L) {
#line 371
    if (i <= lp->m) {
      {
#line 372
      ddf_InitializeArow(lp->d, & a___41);
#line 373
      j = (ddf_colrange )1;
      }
      {
#line 373
      while (1) {
        while_continue: /* CIL Label */ ;
#line 373
        if (! (j <= lp->d)) {
#line 373
          goto while_break;
        }
        {
#line 374
        dddf_set((double *)(*(a___41 + (j - 1L))), (double *)(*(*(lp->A + (i - 1L)) + (j - 1L))));
#line 373
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 378
  return (a___41);
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_SetNumberType(char *line , ddf_NumberType *number , ddf_ErrorType *Error ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 384
  tmp___1 = strncmp((char const   *)line, "integer", (size_t )7);
  }
#line 384
  if (tmp___1 == 0) {
#line 385
    *number = (ddf_NumberType )3;
#line 386
    return;
  } else {
    {
#line 388
    tmp___0 = strncmp((char const   *)line, "rational", (size_t )8);
    }
#line 388
    if (tmp___0 == 0) {
#line 389
      *number = (ddf_NumberType )2;
#line 390
      return;
    } else {
      {
#line 392
      tmp = strncmp((char const   *)line, "real", (size_t )4);
      }
#line 392
      if (tmp == 0) {
#line 393
        *number = (ddf_NumberType )1;
#line 394
        return;
      } else {
#line 397
        *number = (ddf_NumberType )0;
#line 398
        *Error = (ddf_ErrorType )1;
      }
    }
  }
#line 400
  return;
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_WriteTableau(FILE *f , ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                      ddf_Bmatrix T , ddf_colindex nbindex , ddf_rowindex bflag___97 ) 
{ 
  ddf_colrange j ;
  ddf_rowrange i ;
  myfloat x ;

  {
  {
#line 411
  dddf_init((double *)(x));
#line 412
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld  %ld  real\n",
          m_size, d_size);
#line 413
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"          |");
#line 414
  j = (ddf_colrange )1;
  }
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (j <= d_size)) {
#line 414
      goto while_break;
    }
    {
#line 415
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld", *(nbindex + j));
#line 414
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 416
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 417
  j = (ddf_colrange )1;
  }
  {
#line 417
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 417
    if (! (j <= d_size + 1L)) {
#line 417
      goto while_break___0;
    }
    {
#line 418
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" ----");
#line 417
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 419
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 420
  i = (ddf_rowrange )1;
  }
  {
#line 420
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 420
    if (! (i <= m_size)) {
#line 420
      goto while_break___1;
    }
    {
#line 421
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %3ld(%3ld) |",
            i, *(bflag___97 + i));
#line 422
    j = (ddf_colrange )1;
    }
    {
#line 422
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 422
      if (! (j <= d_size)) {
#line 422
        goto while_break___2;
      }
      {
#line 423
      ddf_TableauEntry(& x, m_size, d_size, A, T, i, j);
#line 424
      ddf_WriteNumber(f, (double *)(x));
#line 422
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 426
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 420
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 428
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
#line 429
  dddf_clear((double *)(x));
  }
#line 430
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_WriteSignTableau(FILE *f , ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                          ddf_Bmatrix T , ddf_colindex nbindex , ddf_rowindex bflag___97 ) 
{ 
  ddf_colrange j ;
  ddf_rowrange i ;
  myfloat x ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;

  {
  {
#line 440
  dddf_init((double *)(x));
#line 441
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld  %ld  real\n",
          m_size, d_size);
#line 442
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"          |");
#line 443
  j = (ddf_colrange )1;
  }
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (! (j <= d_size)) {
#line 443
      goto while_break;
    }
    {
#line 444
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%3ld", *(nbindex + j));
#line 443
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n  ------- | ");
#line 446
  j = (ddf_colrange )1;
  }
  {
#line 446
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 446
    if (! (j <= d_size)) {
#line 446
      goto while_break___0;
    }
    {
#line 447
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"---");
#line 446
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 448
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 449
  i = (ddf_rowrange )1;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! (i <= m_size)) {
#line 449
      goto while_break___1;
    }
    {
#line 450
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %3ld(%3ld) |",
            i, *(bflag___97 + i));
#line 451
    j = (ddf_colrange )1;
    }
    {
#line 451
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 451
      if (! (j <= d_size)) {
#line 451
        goto while_break___2;
      }
      {
#line 452
      ddf_TableauEntry(& x, m_size, d_size, A, T, i, j);
#line 453
      tmp___0 = ddf_Positive((double *)(x));
      }
#line 453
      if (tmp___0) {
        {
#line 453
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  +");
        }
      } else {
        {
#line 454
        tmp = ddf_Negative((double *)(x));
        }
#line 454
        if (tmp) {
          {
#line 454
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -");
          }
        } else {
          {
#line 455
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  0");
          }
        }
      }
#line 451
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 457
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 449
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 459
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
#line 460
  dddf_clear((double *)(x));
  }
#line 461
  return;
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_WriteSignTableau2(FILE *f , ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                           ddf_Bmatrix T , ddf_colindex nbindex_ref___83 , ddf_colindex nbindex ,
                           ddf_rowindex bflag___97 ) 
{ 
  ddf_colrange j ;
  ddf_rowrange i ;
  myfloat x ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;

  {
  {
#line 471
  dddf_init((double *)(x));
#line 472
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld  %ld  real\n",
          m_size, d_size);
#line 473
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"          |");
#line 474
  j = (ddf_colrange )1;
  }
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! (j <= d_size)) {
#line 474
      goto while_break;
    }
    {
#line 474
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%3ld", *(nbindex_ref___83 + j));
#line 474
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 475
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n          |");
#line 476
  j = (ddf_colrange )1;
  }
  {
#line 476
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 476
    if (! (j <= d_size)) {
#line 476
      goto while_break___0;
    }
    {
#line 477
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%3ld", *(nbindex + j));
#line 476
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 478
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n  ------- | ");
#line 479
  j = (ddf_colrange )1;
  }
  {
#line 479
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 479
    if (! (j <= d_size)) {
#line 479
      goto while_break___1;
    }
    {
#line 480
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"---");
#line 479
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 481
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 482
  i = (ddf_rowrange )1;
  }
  {
#line 482
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 482
    if (! (i <= m_size)) {
#line 482
      goto while_break___2;
    }
    {
#line 483
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %3ld(%3ld) |",
            i, *(bflag___97 + i));
#line 484
    j = (ddf_colrange )1;
    }
    {
#line 484
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 484
      if (! (j <= d_size)) {
#line 484
        goto while_break___3;
      }
      {
#line 485
      ddf_TableauEntry(& x, m_size, d_size, A, T, i, j);
#line 486
      tmp___0 = ddf_Positive((double *)(x));
      }
#line 486
      if (tmp___0) {
        {
#line 486
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  +");
        }
      } else {
        {
#line 487
        tmp = ddf_Negative((double *)(x));
        }
#line 487
        if (tmp) {
          {
#line 487
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -");
          }
        } else {
          {
#line 488
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  0");
          }
        }
      }
#line 484
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 490
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 482
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 492
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
#line 493
  dddf_clear((double *)(x));
  }
#line 494
  return;
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_GetRedundancyInformation(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                                  ddf_Bmatrix T , ddf_colindex nbindex , ddf_rowindex bflag___97 ,
                                  ddf_rowset redset ) 
{ 
  ddf_colrange j ;
  ddf_rowrange i ;
  myfloat x ;
  ddf_boolean red ;
  ddf_boolean localdebug ;
  long numbred ;
  ddf_boolean tmp ;

  {
  {
#line 505
  red = 0;
#line 505
  localdebug = 0;
#line 506
  numbred = 0L;
#line 508
  dddf_init((double *)(x));
#line 509
  i = (ddf_rowrange )1;
  }
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! (i <= m_size)) {
#line 509
      goto while_break;
    }
#line 510
    red = 1;
#line 511
    j = (ddf_colrange )1;
    {
#line 511
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 511
      if (! (j <= d_size)) {
#line 511
        goto while_break___0;
      }
      {
#line 512
      ddf_TableauEntry(& x, m_size, d_size, A, T, i, j);
      }
#line 513
      if (red) {
        {
#line 513
        tmp = ddf_Negative((double *)(x));
        }
#line 513
        if (tmp) {
#line 513
          red = 0;
        }
      }
#line 511
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 515
    if (*(bflag___97 + i) < 0L) {
#line 515
      if (red) {
        {
#line 516
        numbred ++;
#line 517
        set_addelem(redset, i);
        }
      }
    }
#line 509
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  if (localdebug) {
    {
#line 520
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nddf_GetRedundancyInformation: %ld redundant rows over %ld\n",
            numbred, m_size);
    }
  }
  {
#line 521
  dddf_clear((double *)(x));
  }
#line 522
  return;
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___1  ;
#line 546
void ddf_SelectDualSimplexPivot(ddf_rowrange m_size , ddf_colrange d_size , int Phase1 ,
                                ddf_Amatrix A , ddf_Bmatrix T , ddf_rowindex OV ,
                                ddf_colindex nbindex_ref___83 , ddf_colindex nbindex ,
                                ddf_rowindex bflag___97 , ddf_rowrange objrow , ddf_colrange rhscol ,
                                ddf_boolean lexicopivot , ddf_rowrange *r , ddf_colrange *s ,
                                int *selected , ddf_LPStatusType *lps ) ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___2  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___0  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___0  ;
#line 525 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_SelectDualSimplexPivot(ddf_rowrange m_size , ddf_colrange d_size , int Phase1 ,
                                ddf_Amatrix A , ddf_Bmatrix T , ddf_rowindex OV ,
                                ddf_colindex nbindex_ref___83 , ddf_colindex nbindex ,
                                ddf_rowindex bflag___97 , ddf_rowrange objrow , ddf_colrange rhscol ,
                                ddf_boolean lexicopivot , ddf_rowrange *r , ddf_colrange *s ,
                                int *selected , ddf_LPStatusType *lps ) 
{ 
  ddf_boolean colselected ;
  ddf_boolean rowselected ;
  ddf_boolean dualfeasible ;
  ddf_boolean localdebug ;
  ddf_rowrange i ;
  ddf_rowrange iref ;
  ddf_colrange j ;
  ddf_colrange k ;
  myfloat val ;
  myfloat valn ;
  myfloat minval ;
  myfloat rat ;
  myfloat minrat ;
  void *tmp ;
  ddf_boolean tmp___0 ;
  ddf_boolean tmp___1 ;
  ddf_boolean tmp___2 ;
  ddf_boolean tmp___3 ;
  ddf_boolean tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  ddf_boolean tmp___7 ;
  ddf_boolean tmp___8 ;
  ddf_boolean tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  ddf_boolean tmp___13 ;

  {
  {
#line 540
  colselected = 0;
#line 540
  rowselected = 0;
#line 540
  dualfeasible = 1;
#line 540
  localdebug = 0;
#line 549
  dddf_init((double *)(val));
#line 549
  dddf_init((double *)(valn));
#line 549
  dddf_init((double *)(minval));
#line 549
  dddf_init((double *)(rat));
#line 549
  dddf_init((double *)(minrat));
  }
#line 550
  if (d_last___2 < d_size) {
#line 551
    if (d_last___2 > 0L) {
#line 552
      j = (ddf_colrange )1;
      {
#line 552
      while (1) {
        while_continue: /* CIL Label */ ;
#line 552
        if (! (j <= d_last___2)) {
#line 552
          goto while_break;
        }
        {
#line 552
        dddf_clear((double *)(*(rcost___1 + (j - 1L))));
#line 552
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 553
      free((void *)rcost___1);
#line 554
      set_free(tieset___0);
#line 555
      set_free(stieset___0);
      }
    }
    {
#line 557
    tmp = calloc((size_t )d_size, sizeof(myfloat ));
#line 557
    rcost___1 = (myfloat *)tmp;
#line 558
    j = (ddf_colrange )1;
    }
    {
#line 558
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 558
      if (! (j <= d_size)) {
#line 558
        goto while_break___0;
      }
      {
#line 558
      dddf_init((double *)(*(rcost___1 + (j - 1L))));
#line 558
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 559
    set_initialize(& tieset___0, d_size);
#line 560
    set_initialize(& stieset___0, d_size);
#line 561
    d_last___2 = d_size;
    }
  }
#line 564
  *r = (ddf_rowrange )0;
#line 564
  *s = (ddf_colrange )0;
#line 565
  *selected = 0;
#line 566
  *lps = (ddf_LPStatusType )0;
#line 567
  j = (ddf_colrange )1;
  {
#line 567
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 567
    if (! (j <= d_size)) {
#line 567
      goto while_break___1;
    }
#line 568
    if (j != rhscol) {
      {
#line 569
      ddf_TableauEntry(rcost___1 + (j - 1L), m_size, d_size, A, T, objrow, j);
#line 570
      tmp___0 = ddf_Positive((double *)(*(rcost___1 + (j - 1L))));
      }
#line 570
      if (tmp___0) {
#line 571
        dualfeasible = 0;
      }
    }
#line 567
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 575
  if (dualfeasible) {
    {
#line 576
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 576
      if ((unsigned int )*lps == 0U) {
#line 576
        if (! rowselected) {
#line 576
          if (! (! colselected)) {
#line 576
            goto while_break___2;
          }
        } else {
#line 576
          goto while_break___2;
        }
      } else {
#line 576
        goto while_break___2;
      }
#line 577
      i = (ddf_rowrange )1;
      {
#line 577
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 577
        if (! (i <= m_size)) {
#line 577
          goto while_break___3;
        }
#line 578
        if (i != objrow) {
#line 578
          if (*(bflag___97 + i) == -1L) {
#line 579
            if (Phase1) {
              {
#line 580
              ddf_TableauEntry(& val, m_size, d_size, A, T, i, *(bflag___97 + m_size));
#line 581
              dddf_neg((double *)(val), (double *)(val));
              }
            } else {
              {
#line 584
              ddf_TableauEntry(& val, m_size, d_size, A, T, i, rhscol);
              }
            }
            {
#line 585
            tmp___1 = ddf_Smaller((double *)(val), (double *)(minval));
            }
#line 585
            if (tmp___1) {
              {
#line 586
              *r = i;
#line 587
              dddf_set((double *)(minval), (double *)(val));
              }
            }
          }
        }
#line 577
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 591
      tmp___13 = ddf_Nonnegative((double *)(minval));
      }
#line 591
      if (tmp___13) {
#line 592
        *lps = (ddf_LPStatusType )1;
      } else {
        {
#line 595
        rowselected = 1;
#line 596
        set_emptyset(tieset___0);
#line 597
        j = (ddf_colrange )1;
        }
        {
#line 597
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 597
          if (! (j <= d_size)) {
#line 597
            goto while_break___4;
          }
          {
#line 598
          ddf_TableauEntry(& val, m_size, d_size, A, T, *r, j);
          }
#line 599
          if (j != rhscol) {
            {
#line 599
            tmp___4 = ddf_Positive((double *)(val));
            }
#line 599
            if (tmp___4) {
              {
#line 600
              dddf_div((double *)(rat), (double *)(*(rcost___1 + (j - 1L))), (double *)(val));
#line 601
              dddf_neg((double *)(rat), (double *)(rat));
              }
#line 602
              if (*s == 0L) {
                {
#line 603
                dddf_set((double *)(minrat), (double *)(rat));
#line 604
                *s = j;
#line 605
                set_emptyset(tieset___0);
#line 606
                set_addelem(tieset___0, j);
                }
              } else {
                {
#line 602
                tmp___3 = ddf_Smaller((double *)(rat), (double *)(minrat));
                }
#line 602
                if (tmp___3) {
                  {
#line 603
                  dddf_set((double *)(minrat), (double *)(rat));
#line 604
                  *s = j;
#line 605
                  set_emptyset(tieset___0);
#line 606
                  set_addelem(tieset___0, j);
                  }
                } else {
                  {
#line 607
                  tmp___2 = ddf_Equal((double *)(rat), (double *)(minrat));
                  }
#line 607
                  if (tmp___2) {
                    {
#line 608
                    set_addelem(tieset___0, j);
                    }
                  }
                }
              }
            }
          }
#line 597
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 612
        if (*s > 0L) {
#line 613
          if (! lexicopivot) {
#line 614
            colselected = 1;
#line 614
            *selected = 1;
          } else {
            {
#line 613
            tmp___12 = set_card(tieset___0);
            }
#line 613
            if (tmp___12 == 1L) {
#line 614
              colselected = 1;
#line 614
              *selected = 1;
            } else {
#line 616
              if (localdebug) {
                {
#line 616
                printf((char const   */* __restrict  */)"Tie occurred at:");
#line 616
                set_write(tieset___0);
#line 616
                printf((char const   */* __restrict  */)"\n");
#line 617
                ddf_WriteTableau(stderr, m_size, d_size, A, T, nbindex, bflag___97);
                }
              }
#line 619
              *s = (ddf_colrange )0;
#line 620
              k = (ddf_colrange )2;
              {
#line 621
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 622
                iref = *(nbindex_ref___83 + k);
#line 623
                if (iref > 0L) {
#line 624
                  j = *(bflag___97 + iref);
#line 625
                  if (j > 0L) {
                    {
#line 626
                    tmp___5 = set_member(j, tieset___0);
                    }
#line 626
                    if (tmp___5) {
                      {
#line 626
                      tmp___6 = set_card(tieset___0);
                      }
#line 626
                      if (tmp___6 == 1L) {
#line 627
                        *s = j;
#line 628
                        colselected = 1;
                      } else {
                        {
#line 630
                        set_delelem(tieset___0, j);
                        }
                      }
                    } else {
                      {
#line 630
                      set_delelem(tieset___0, j);
                      }
                    }
                  } else {
#line 634
                    *s = (ddf_colrange )0;
#line 635
                    j = (ddf_colrange )1;
                    {
#line 635
                    while (1) {
                      while_continue___6: /* CIL Label */ ;
#line 635
                      if (! (j <= d_size)) {
#line 635
                        goto while_break___6;
                      }
                      {
#line 636
                      tmp___10 = set_member(j, tieset___0);
                      }
#line 636
                      if (tmp___10) {
                        {
#line 637
                        ddf_TableauEntry(& val, m_size, d_size, A, T, *r, j);
#line 638
                        ddf_TableauEntry(& valn, m_size, d_size, A, T, iref, j);
                        }
#line 639
                        if (j != rhscol) {
                          {
#line 639
                          tmp___9 = ddf_Positive((double *)(val));
                          }
#line 639
                          if (tmp___9) {
                            {
#line 640
                            dddf_div((double *)(rat), (double *)(valn), (double *)(val));
                            }
#line 641
                            if (*s == 0L) {
                              {
#line 642
                              dddf_set((double *)(minrat), (double *)(rat));
#line 643
                              *s = j;
#line 644
                              set_emptyset(stieset___0);
#line 645
                              set_addelem(stieset___0, j);
                              }
                            } else {
                              {
#line 641
                              tmp___8 = ddf_Smaller((double *)(rat), (double *)(minrat));
                              }
#line 641
                              if (tmp___8) {
                                {
#line 642
                                dddf_set((double *)(minrat), (double *)(rat));
#line 643
                                *s = j;
#line 644
                                set_emptyset(stieset___0);
#line 645
                                set_addelem(stieset___0, j);
                                }
                              } else {
                                {
#line 646
                                tmp___7 = ddf_Equal((double *)(rat), (double *)(minrat));
                                }
#line 646
                                if (tmp___7) {
                                  {
#line 647
                                  set_addelem(stieset___0, j);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
#line 635
                      j ++;
                    }
                    while_break___6: /* CIL Label */ ;
                    }
                    {
#line 652
                    set_copy(tieset___0, stieset___0);
#line 653
                    tmp___11 = set_card(tieset___0);
                    }
#line 653
                    if (tmp___11 == 1L) {
#line 653
                      colselected = 1;
                    }
                  }
                }
#line 656
                k ++;
#line 621
                if (! colselected) {
#line 621
                  if (! (k <= d_size)) {
#line 621
                    goto while_break___5;
                  }
                } else {
#line 621
                  goto while_break___5;
                }
              }
              while_break___5: /* CIL Label */ ;
              }
#line 658
              *selected = 1;
            }
          }
        } else {
#line 660
          *lps = (ddf_LPStatusType )2;
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 664
  if (localdebug) {
#line 665
    if (Phase1) {
      {
#line 665
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Phase 1 : select %ld,%ld\n",
              *r, *s);
      }
    } else {
      {
#line 666
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Phase 2 : select %ld,%ld\n",
              *r, *s);
      }
    }
  }
  {
#line 668
  dddf_clear((double *)(val));
#line 668
  dddf_clear((double *)(valn));
#line 668
  dddf_clear((double *)(minval));
#line 668
  dddf_clear((double *)(rat));
#line 668
  dddf_clear((double *)(minrat));
  }
#line 669
  return;
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_TableauEntry(myfloat *x , ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix X ,
                      ddf_Bmatrix T , ddf_rowrange r , ddf_colrange s ) 
{ 
  ddf_colrange j ;
  myfloat temp ;

  {
  {
#line 678
  dddf_init((double *)(temp));
#line 679
  dddf_set((double *)(*x), (double *)(ddf_purezero));
#line 680
  j = (ddf_colrange )0;
  }
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 680
    if (! (j < d_size)) {
#line 680
      goto while_break;
    }
    {
#line 681
    dddf_mul((double *)(temp), (double *)(*(*(X + (r - 1L)) + j)), (double *)(*(*(T + j) + (s - 1L))));
#line 682
    dddf_add((double *)(*x), (double *)(*x), (double *)(temp));
#line 680
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 684
  dddf_clear((double *)(temp));
  }
#line 685
  return;
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_SelectPivot2(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                      ddf_Bmatrix T , ddf_RowOrderType roworder , ddf_rowindex ordervec ,
                      unsigned long *equalityset , ddf_rowrange rowmax , unsigned long *NopivotRow ,
                      unsigned long *NopivotCol , ddf_rowrange *r , ddf_colrange *s ,
                      ddf_boolean *selected ) 
{ 
  int stop ;
  ddf_rowrange i ;
  ddf_rowrange rtemp ;
  rowset rowexcluded ;
  myfloat Xtemp ;
  ddf_boolean localdebug ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ddf_boolean tmp___2 ;

  {
  {
#line 701
  localdebug = 0;
#line 703
  stop = 0;
#line 704
  localdebug = ddf_debug;
#line 705
  dddf_init((double *)(Xtemp));
#line 706
  set_initialize(& rowexcluded, m_size);
#line 707
  set_copy(rowexcluded, NopivotRow);
#line 708
  i = rowmax + 1L;
  }
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (! (i <= m_size)) {
#line 708
      goto while_break;
    }
    {
#line 709
    set_addelem(rowexcluded, i);
#line 708
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 711
  *selected = 0;
  {
#line 712
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 713
    rtemp = (ddf_rowrange )0;
#line 713
    i = (ddf_rowrange )1;
    {
#line 714
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 714
      if (i <= m_size) {
#line 714
        if (! (rtemp == 0L)) {
#line 714
          goto while_break___1;
        }
      } else {
#line 714
        goto while_break___1;
      }
      {
#line 715
      tmp = set_member(i, equalityset);
      }
#line 715
      if (tmp) {
        {
#line 715
        tmp___0 = set_member(i, rowexcluded);
        }
#line 715
        if (! tmp___0) {
#line 716
          if (localdebug) {
            {
#line 716
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"marked set %ld chosen as a candidate\n",
                    i);
            }
          }
#line 717
          rtemp = i;
        }
      }
#line 719
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 721
    if (rtemp == 0L) {
      {
#line 721
      ddf_SelectPreorderedNext2(m_size, d_size, rowexcluded, ordervec, & rtemp);
      }
    }
#line 722
    if (rtemp >= 1L) {
#line 723
      *r = rtemp;
#line 724
      *s = (ddf_colrange )1;
      {
#line 725
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 725
        if (*s <= d_size) {
#line 725
          if (! (! *selected)) {
#line 725
            goto while_break___2;
          }
        } else {
#line 725
          goto while_break___2;
        }
        {
#line 726
        ddf_TableauEntry(& Xtemp, m_size, d_size, A, T, *r, *s);
#line 727
        tmp___1 = set_member(*s, NopivotCol);
        }
#line 727
        if (tmp___1) {
#line 731
          (*s) ++;
        } else {
          {
#line 727
          tmp___2 = ddf_Nonzero((double *)(Xtemp));
          }
#line 727
          if (tmp___2) {
#line 728
            *selected = 1;
#line 729
            stop = 1;
          } else {
#line 731
            (*s) ++;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 734
      if (! *selected) {
        {
#line 735
        set_addelem(rowexcluded, rtemp);
        }
      }
    } else {
#line 739
      *r = (ddf_rowrange )0;
#line 740
      *s = (ddf_colrange )0;
#line 741
      stop = 1;
    }
#line 712
    if (! (! stop)) {
#line 712
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 744
  set_free(rowexcluded);
#line 744
  dddf_clear((double *)(Xtemp));
  }
#line 745
  return;
}
}
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___0  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___2  =    (ddf_colrange )0;
#line 747 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_GaussianColumnPivot(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix X ,
                             ddf_Bmatrix T , ddf_rowrange r , ddf_colrange s ) 
{ 
  ddf_colrange j ;
  ddf_colrange j1___0 ;
  myfloat Xtemp0 ;
  myfloat Xtemp1 ;
  myfloat Xtemp ;
  void *tmp ;

  {
  {
#line 759
  dddf_init((double *)(Xtemp0));
#line 759
  dddf_init((double *)(Xtemp1));
#line 759
  dddf_init((double *)(Xtemp));
  }
#line 760
  if (last_d___2 != d_size) {
#line 761
    if (last_d___2 > 0L) {
#line 762
      j = (ddf_colrange )1;
      {
#line 762
      while (1) {
        while_continue: /* CIL Label */ ;
#line 762
        if (! (j <= last_d___2)) {
#line 762
          goto while_break;
        }
        {
#line 762
        dddf_clear((double *)(*(Rtemp___0 + (j - 1L))));
#line 762
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 763
      free((void *)Rtemp___0);
      }
    }
    {
#line 765
    tmp = calloc((size_t )d_size, sizeof(myfloat ));
#line 765
    Rtemp___0 = (myfloat *)tmp;
#line 766
    j = (ddf_colrange )1;
    }
    {
#line 766
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 766
      if (! (j <= d_size)) {
#line 766
        goto while_break___0;
      }
      {
#line 766
      dddf_init((double *)(*(Rtemp___0 + (j - 1L))));
#line 766
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 767
    last_d___2 = d_size;
  }
#line 770
  j = (ddf_colrange )1;
  {
#line 770
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 770
    if (! (j <= d_size)) {
#line 770
      goto while_break___1;
    }
    {
#line 771
    ddf_TableauEntry(Rtemp___0 + (j - 1L), m_size, d_size, X, T, r, j);
#line 770
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 773
  dddf_set((double *)(Xtemp0), (double *)(*(Rtemp___0 + (s - 1L))));
#line 774
  j = (ddf_colrange )1;
  }
  {
#line 774
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 774
    if (! (j <= d_size)) {
#line 774
      goto while_break___2;
    }
#line 775
    if (j != s) {
      {
#line 776
      dddf_div((double *)(Xtemp), (double *)(*(Rtemp___0 + (j - 1L))), (double *)(Xtemp0));
#line 777
      dddf_set((double *)(Xtemp1), (double *)(ddf_purezero));
#line 778
      j1___0 = (ddf_colrange )1;
      }
      {
#line 778
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 778
        if (! (j1___0 <= d_size)) {
#line 778
          goto while_break___3;
        }
        {
#line 779
        dddf_mul((double *)(Xtemp1), (double *)(Xtemp), (double *)(*(*(T + (j1___0 - 1L)) + (s - 1L))));
#line 780
        dddf_sub((double *)(*(*(T + (j1___0 - 1L)) + (j - 1L))), (double *)(*(*(T + (j1___0 - 1L)) + (j - 1L))),
                 (double *)(Xtemp1));
#line 778
        j1___0 ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 774
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 785
  j = (ddf_colrange )1;
  {
#line 785
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 785
    if (! (j <= d_size)) {
#line 785
      goto while_break___4;
    }
    {
#line 786
    dddf_div((double *)(*(*(T + (j - 1L)) + (s - 1L))), (double *)(*(*(T + (j - 1L)) + (s - 1L))),
             (double *)(Xtemp0));
#line 785
    j ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 788
  dddf_clear((double *)(Xtemp0));
#line 788
  dddf_clear((double *)(Xtemp1));
#line 788
  dddf_clear((double *)(Xtemp));
  }
#line 789
  return;
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_GaussianColumnPivot2(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                              ddf_Bmatrix T , ddf_colindex nbindex , ddf_rowindex bflag___97 ,
                              ddf_rowrange r , ddf_colrange s ) 
{ 
  int localdebug ;
  long entering ;

  {
#line 798
  localdebug = 0;
#line 801
  if (ddf_debug) {
#line 801
    localdebug = ddf_debug;
  }
  {
#line 802
  ddf_GaussianColumnPivot(m_size, d_size, A, T, r, s);
#line 803
  entering = *(nbindex + s);
#line 804
  *(bflag___97 + r) = s;
#line 805
  *(nbindex + s) = r;
  }
#line 807
  if (entering > 0L) {
#line 807
    *(bflag___97 + entering) = -1L;
  }
#line 810
  if (localdebug) {
    {
#line 811
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_GaussianColumnPivot2\n");
#line 812
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" pivot: (leaving, entering) = (%ld, %ld)\n",
            r, entering);
#line 813
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" bflag[%ld] is set to %ld\n",
            r, s);
    }
  }
#line 815
  return;
}
}
#line 818 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_ResetTableau(ddf_rowrange m_size , ddf_colrange d_size , ddf_Bmatrix T ,
                      ddf_colindex nbindex , ddf_rowindex bflag___97 , ddf_rowrange objrow ,
                      ddf_colrange rhscol ) 
{ 
  ddf_rowrange i ;
  ddf_colrange j ;

  {
#line 825
  j = (ddf_colrange )1;
  {
#line 825
  while (1) {
    while_continue: /* CIL Label */ ;
#line 825
    if (! (j <= d_size)) {
#line 825
      goto while_break;
    }
#line 825
    *(nbindex + j) = - j;
#line 825
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 826
  *(nbindex + rhscol) = 0L;
#line 829
  ddf_SetToIdentity(d_size, T);
#line 832
  i = (ddf_rowrange )1;
  }
  {
#line 832
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 832
    if (! (i <= m_size)) {
#line 832
      goto while_break___0;
    }
#line 832
    *(bflag___97 + i) = -1L;
#line 832
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 834
  *(bflag___97 + objrow) = 0L;
#line 837
  j = (ddf_colrange )1;
  {
#line 837
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 837
    if (! (j <= d_size)) {
#line 837
      goto while_break___1;
    }
#line 837
    if (*(nbindex + j) > 0L) {
#line 837
      *(bflag___97 + *(nbindex + j)) = j;
    }
#line 837
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 840
  return;
}
}
#line 842 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_SelectCrissCrossPivot(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                               ddf_Bmatrix T , ddf_rowindex bflag___97 , ddf_rowrange objrow ,
                               ddf_colrange rhscol , ddf_rowrange *r , ddf_colrange *s ,
                               int *selected , ddf_LPStatusType *lps ) 
{ 
  int colselected ;
  int rowselected ;
  ddf_rowrange i ;
  myfloat val ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;
  ddf_boolean tmp___1 ;
  ddf_boolean tmp___2 ;

  {
  {
#line 847
  colselected = 0;
#line 847
  rowselected = 0;
#line 851
  dddf_init((double *)(val));
#line 852
  *selected = 0;
#line 853
  *lps = (ddf_LPStatusType )0;
  }
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if ((unsigned int )*lps == 0U) {
#line 854
      if (! rowselected) {
#line 854
        if (! (! colselected)) {
#line 854
          goto while_break;
        }
      } else {
#line 854
        goto while_break;
      }
    } else {
#line 854
      goto while_break;
    }
#line 855
    i = (ddf_rowrange )1;
    {
#line 855
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 855
      if (! (i <= m_size)) {
#line 855
        goto while_break___0;
      }
#line 856
      if (i != objrow) {
#line 856
        if (*(bflag___97 + i) == -1L) {
          {
#line 857
          ddf_TableauEntry(& val, m_size, d_size, A, T, i, rhscol);
#line 858
          tmp = ddf_Negative((double *)(val));
          }
#line 858
          if (tmp) {
#line 859
            rowselected = 1;
#line 860
            *r = i;
#line 861
            goto while_break___0;
          }
        } else {
#line 856
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 864
      if (*(bflag___97 + i) > 0L) {
        {
#line 865
        ddf_TableauEntry(& val, m_size, d_size, A, T, objrow, *(bflag___97 + i));
#line 866
        tmp___0 = ddf_Positive((double *)(val));
        }
#line 866
        if (tmp___0) {
#line 867
          colselected = 1;
#line 868
          *s = *(bflag___97 + i);
#line 869
          goto while_break___0;
        }
      }
#line 855
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 873
    if (! rowselected) {
#line 873
      if (! colselected) {
#line 874
        *lps = (ddf_LPStatusType )1;
#line 875
        return;
      } else {
#line 873
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 877
    if (rowselected) {
#line 878
      i = (ddf_rowrange )1;
      {
#line 878
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 878
        if (! (i <= m_size)) {
#line 878
          goto while_break___1;
        }
#line 879
        if (*(bflag___97 + i) > 0L) {
          {
#line 880
          ddf_TableauEntry(& val, m_size, d_size, A, T, *r, *(bflag___97 + i));
#line 881
          tmp___1 = ddf_Positive((double *)(val));
          }
#line 881
          if (tmp___1) {
#line 882
            colselected = 1;
#line 883
            *s = *(bflag___97 + i);
#line 884
            *selected = 1;
#line 885
            goto while_break___1;
          }
        }
#line 878
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 890
    if (colselected) {
#line 891
      i = (ddf_rowrange )1;
      {
#line 891
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 891
        if (! (i <= m_size)) {
#line 891
          goto while_break___2;
        }
#line 892
        if (i != objrow) {
#line 892
          if (*(bflag___97 + i) == -1L) {
            {
#line 893
            ddf_TableauEntry(& val, m_size, d_size, A, T, i, *s);
#line 894
            tmp___2 = ddf_Negative((double *)(val));
            }
#line 894
            if (tmp___2) {
#line 895
              rowselected = 1;
#line 896
              *r = i;
#line 897
              *selected = 1;
#line 898
              goto while_break___2;
            }
          }
        }
#line 891
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 903
    if (! rowselected) {
#line 904
      *lps = (ddf_LPStatusType )3;
    } else
#line 906
    if (! colselected) {
#line 907
      *lps = (ddf_LPStatusType )2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 910
  dddf_clear((double *)(val));
  }
#line 911
  return;
}
}
#line 913 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_CrissCrossSolve(ddf_LPPtr lp , ddf_ErrorType *err ) 
{ 


  {
  {
#line 916
  if ((unsigned int )lp->objective == 1U) {
#line 916
    goto case_1;
  }
#line 920
  if ((unsigned int )lp->objective == 2U) {
#line 920
    goto case_2;
  }
#line 924
  if ((unsigned int )lp->objective == 0U) {
#line 924
    goto case_0;
  }
#line 915
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 917
  ddf_CrissCrossMaximize(lp, err);
  }
#line 918
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 921
  ddf_CrissCrossMinimize(lp, err);
  }
#line 922
  goto switch_break;
  case_0: /* CIL Label */ 
#line 924
  *err = (ddf_ErrorType )8;
#line 924
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 927
  return;
}
}
#line 929 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_DualSimplexSolve(ddf_LPPtr lp , ddf_ErrorType *err ) 
{ 


  {
  {
#line 932
  if ((unsigned int )lp->objective == 1U) {
#line 932
    goto case_1;
  }
#line 936
  if ((unsigned int )lp->objective == 2U) {
#line 936
    goto case_2;
  }
#line 940
  if ((unsigned int )lp->objective == 0U) {
#line 940
    goto case_0;
  }
#line 931
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 933
  ddf_DualSimplexMaximize(lp, err);
  }
#line 934
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 937
  ddf_DualSimplexMinimize(lp, err);
  }
#line 938
  goto switch_break;
  case_0: /* CIL Label */ 
#line 940
  *err = (ddf_ErrorType )8;
#line 940
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 942
  return;
}
}
#line 1002 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_FindLPBasis(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A , ddf_Bmatrix T ,
                     ddf_rowindex OV , ddf_rowset equalityset , ddf_colindex nbindex ,
                     ddf_rowindex bflag___97 , ddf_rowrange objrow , ddf_colrange rhscol ,
                     ddf_colrange *cs , int *found , ddf_LPStatusType *lps , long *pivot_no ) 
{ 
  int chosen ;
  int stop ;
  long pivots_p0 ;
  long rank ;
  colset ColSelected ;
  rowset RowSelected ;
  myfloat val ;
  ddf_rowrange r ;
  ddf_colrange j ;
  ddf_colrange s ;
  ddf_boolean tmp ;

  {
  {
#line 1020
  pivots_p0 = 0L;
#line 1028
  dddf_init((double *)(val));
#line 1029
  *found = 0;
#line 1029
  *cs = (ddf_colrange )0;
#line 1029
  rank = 0L;
#line 1030
  stop = 0;
#line 1031
  *lps = (ddf_LPStatusType )0;
#line 1033
  set_initialize(& RowSelected, m_size);
#line 1034
  set_initialize(& ColSelected, d_size);
#line 1035
  set_addelem(RowSelected, objrow);
#line 1036
  set_addelem(ColSelected, rhscol);
#line 1038
  stop = 0;
  }
  {
#line 1039
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1040
    ddf_SelectPivot2(m_size, d_size, A, T, (ddf_RowOrderType )1, OV, equalityset,
                     m_size, RowSelected, ColSelected, & r, & s, & chosen);
    }
#line 1042
    if (chosen) {
      {
#line 1043
      set_addelem(RowSelected, r);
#line 1044
      set_addelem(ColSelected, s);
#line 1045
      ddf_GaussianColumnPivot2(m_size, d_size, A, T, nbindex, bflag___97, r, s);
#line 1046
      pivots_p0 ++;
#line 1047
      rank ++;
      }
    } else {
#line 1049
      j = (ddf_colrange )1;
      {
#line 1049
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1049
        if (j <= d_size) {
#line 1049
          if (! ((unsigned int )*lps == 0U)) {
#line 1049
            goto while_break___0;
          }
        } else {
#line 1049
          goto while_break___0;
        }
#line 1050
        if (j != rhscol) {
#line 1050
          if (*(nbindex + j) < 0L) {
            {
#line 1051
            ddf_TableauEntry(& val, m_size, d_size, A, T, objrow, j);
#line 1052
            tmp = ddf_Nonzero((double *)(val));
            }
#line 1052
            if (tmp) {
#line 1053
              *lps = (ddf_LPStatusType )5;
#line 1054
              *cs = j;
            }
          }
        }
#line 1049
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1059
      if ((unsigned int )*lps == 0U) {
#line 1059
        *found = 1;
      }
#line 1061
      stop = 1;
    }
#line 1064
    if (rank == d_size - 1L) {
#line 1065
      stop = 1;
#line 1066
      *found = 1;
    }
#line 1039
    if (! (! stop)) {
#line 1039
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1070
  *pivot_no = pivots_p0;
#line 1071
  ddf_statBApivots += pivots_p0;
#line 1072
  set_free(RowSelected);
#line 1073
  set_free(ColSelected);
#line 1074
  dddf_clear((double *)(val));
  }
#line 1075
  return;
}
}
#line 1078 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_FindLPBasis2(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                      ddf_Bmatrix T , ddf_rowindex OV , ddf_rowset equalityset , ddf_colindex nbindex ,
                      ddf_rowindex bflag___97 , ddf_rowrange objrow , ddf_colrange rhscol ,
                      ddf_colrange *cs , int *found , long *pivot_no ) 
{ 
  int chosen ;
  int stop ;
  long pivots_p0 ;
  long rank ;
  ddf_colset ColSelected ;
  ddf_colset DependentCols ;
  ddf_rowset RowSelected ;
  ddf_rowset NopivotRow ;
  myfloat val ;
  ddf_boolean localdebug ;
  ddf_rowrange r ;
  ddf_rowrange negcount ;
  ddf_colrange j ;
  ddf_colrange s ;

  {
  {
#line 1088
  pivots_p0 = 0L;
#line 1092
  localdebug = 0;
#line 1094
  negcount = (ddf_rowrange )0;
#line 1097
  dddf_init((double *)(val));
#line 1098
  *found = 0;
#line 1098
  *cs = (ddf_colrange )0;
#line 1098
  rank = 0L;
#line 1100
  set_initialize(& RowSelected, m_size);
#line 1101
  set_initialize(& DependentCols, d_size);
#line 1102
  set_initialize(& ColSelected, d_size);
#line 1103
  set_initialize(& NopivotRow, m_size);
#line 1104
  set_addelem(RowSelected, objrow);
#line 1105
  set_addelem(ColSelected, rhscol);
#line 1106
  set_compl(NopivotRow, NopivotRow);
#line 1108
  j = (ddf_colrange )2;
  }
  {
#line 1108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1108
    if (! (j <= d_size)) {
#line 1108
      goto while_break;
    }
#line 1109
    if (*(nbindex + j) > 0L) {
      {
#line 1110
      set_delelem(NopivotRow, *(nbindex + j));
      }
    } else
#line 1111
    if (*(nbindex + j) < 0L) {
      {
#line 1112
      negcount ++;
#line 1113
      set_addelem(DependentCols, - *(nbindex + j));
#line 1114
      set_addelem(ColSelected, - *(nbindex + j));
      }
    }
#line 1108
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1117
  set_uni(RowSelected, RowSelected, NopivotRow);
#line 1119
  stop = 0;
  }
  {
#line 1120
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1121
    ddf_SelectPivot2(m_size, d_size, A, T, (ddf_RowOrderType )1, OV, equalityset,
                     m_size, RowSelected, ColSelected, & r, & s, & chosen);
    }
#line 1122
    if (chosen) {
      {
#line 1123
      set_addelem(RowSelected, r);
#line 1124
      set_addelem(ColSelected, s);
#line 1126
      ddf_GaussianColumnPivot2(m_size, d_size, A, T, nbindex, bflag___97, r, s);
      }
#line 1127
      if (localdebug) {
#line 1127
        if (m_size <= 10L) {
          {
#line 1128
          ddf_WriteBmatrix(stderr, d_size, T);
#line 1129
          ddf_WriteTableau(stderr, m_size, d_size, A, T, nbindex, bflag___97);
          }
        }
      }
#line 1131
      pivots_p0 ++;
#line 1132
      rank ++;
    } else {
#line 1134
      *found = 0;
#line 1135
      stop = 1;
    }
#line 1137
    if (rank == (d_size - 1L) - negcount) {
#line 1138
      if (negcount) {
        {
#line 1140
        set_diff(ColSelected, ColSelected, DependentCols);
#line 1141
        ddf_SelectPivot2(m_size, d_size, A, T, (ddf_RowOrderType )1, OV, equalityset,
                         m_size, RowSelected, ColSelected, & r, & s, & chosen);
        }
#line 1142
        if (chosen) {
#line 1142
          *found = 0;
        } else {
#line 1143
          *found = 1;
        }
#line 1144
        if (localdebug) {
          {
#line 1145
          printf((char const   */* __restrict  */)"Try to check the dependent cols:");
#line 1146
          set_write(DependentCols);
          }
#line 1147
          if (chosen) {
            {
#line 1147
            printf((char const   */* __restrict  */)"They are not dependent.  Can still pivot on (%ld, %ld)\n",
                   r, s);
            }
          } else {
            {
#line 1148
            printf((char const   */* __restrict  */)"They are indeed dependent.\n");
            }
          }
        }
      } else {
#line 1151
        *found = 1;
      }
#line 1153
      stop = 1;
    }
#line 1120
    if (! (! stop)) {
#line 1120
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1157
  j = (ddf_colrange )1;
  {
#line 1157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1157
    if (! (j <= d_size)) {
#line 1157
      goto while_break___1;
    }
#line 1157
    if (*(nbindex + j) > 0L) {
#line 1157
      *(bflag___97 + *(nbindex + j)) = j;
    }
#line 1157
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1158
  *pivot_no = pivots_p0;
#line 1159
  set_free(RowSelected);
#line 1160
  set_free(ColSelected);
#line 1161
  set_free(NopivotRow);
#line 1162
  set_free(DependentCols);
#line 1163
  dddf_clear((double *)(val));
  }
#line 1164
  return;
}
}
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___3  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___2  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___1  ;
#line 1166 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_FindDualFeasibleBasis(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                               ddf_Bmatrix T , ddf_rowindex OV , ddf_colindex nbindex ,
                               long *bflag___97 , ddf_rowrange objrow , ddf_colrange rhscol ,
                               ddf_boolean lexicopivot , ddf_colrange *s , ddf_ErrorType *err ,
                               ddf_LPStatusType *lps , long *pivot_no , long maxpivots ) 
{ 
  ddf_boolean phase1 ;
  ddf_boolean dualfeasible ;
  ddf_boolean localdebug ;
  ddf_boolean chosen ;
  ddf_boolean stop ;
  ddf_LPStatusType LPSphase1 ;
  long pivots_p1 ;
  ddf_rowrange i ;
  ddf_rowrange r_val ;
  ddf_colrange j ;
  ddf_colrange l ;
  ddf_colrange ms ;
  ddf_colrange s_val ;
  ddf_colrange local_m_size ;
  myfloat x ;
  myfloat val ;
  myfloat maxcost ;
  myfloat axvalue ;
  myfloat maxratio ;
  myfloat scaling ;
  myfloat svalue ;
  myfloat minval ;
  void *tmp ;
  void *tmp___0 ;
  ddf_boolean tmp___1 ;
  ddf_boolean tmp___2 ;
  ddf_boolean tmp___3 ;
  ddf_boolean tmp___4 ;
  ddf_boolean tmp___5 ;
  ddf_boolean tmp___6 ;
  ddf_boolean tmp___7 ;
  ddf_boolean tmp___8 ;

  {
#line 1179
  dualfeasible = 1;
#line 1180
  localdebug = 0;
#line 1182
  pivots_p1 = 0L;
#line 1184
  ms = (ddf_colrange )0;
#line 1193
  if (ddf_debug) {
#line 1193
    localdebug = ddf_debug;
  }
  {
#line 1194
  dddf_init((double *)(x));
#line 1194
  dddf_init((double *)(val));
#line 1194
  dddf_init((double *)(scaling));
#line 1194
  dddf_init((double *)(svalue));
#line 1194
  dddf_init((double *)(axvalue));
#line 1195
  dddf_init((double *)(maxcost));
#line 1195
  dddf_set((double *)(maxcost), (double *)(ddf_minuszero));
#line 1196
  dddf_init((double *)(maxratio));
#line 1196
  dddf_set((double *)(maxratio), (double *)(ddf_minuszero));
  }
#line 1197
  if (d_last___3 < d_size) {
#line 1198
    if (d_last___3 > 0L) {
#line 1199
      j = (ddf_colrange )1;
      {
#line 1199
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1199
        if (! (j <= d_last___3)) {
#line 1199
          goto while_break;
        }
        {
#line 1199
        dddf_clear((double *)(*(rcost___2 + (j - 1L))));
#line 1199
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1200
      free((void *)rcost___2);
#line 1201
      free((void *)nbindex_ref___1);
      }
    }
    {
#line 1203
    tmp = calloc((size_t )d_size, sizeof(myfloat ));
#line 1203
    rcost___2 = (myfloat *)tmp;
#line 1204
    tmp___0 = calloc((size_t )(d_size + 1L), sizeof(long ));
#line 1204
    nbindex_ref___1 = (long *)tmp___0;
#line 1205
    j = (ddf_colrange )1;
    }
    {
#line 1205
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1205
      if (! (j <= d_size)) {
#line 1205
        goto while_break___0;
      }
      {
#line 1205
      dddf_init((double *)(*(rcost___2 + (j - 1L))));
#line 1205
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1206
    d_last___3 = d_size;
  }
#line 1209
  *err = (ddf_ErrorType )17;
#line 1209
  *lps = (ddf_LPStatusType )0;
#line 1209
  *s = (ddf_colrange )0;
#line 1210
  local_m_size = m_size + 1L;
#line 1212
  ms = (ddf_colrange )0;
#line 1213
  j = (ddf_colrange )1;
  {
#line 1213
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1213
    if (! (j <= d_size)) {
#line 1213
      goto while_break___1;
    }
#line 1214
    if (j != rhscol) {
      {
#line 1215
      ddf_TableauEntry(rcost___2 + (j - 1L), local_m_size, d_size, A, T, objrow, j);
#line 1216
      tmp___1 = ddf_Larger((double *)(*(rcost___2 + (j - 1L))), (double *)(maxcost));
      }
#line 1216
      if (tmp___1) {
        {
#line 1216
        dddf_set((double *)(maxcost), (double *)(*(rcost___2 + (j - 1L))));
#line 1216
        ms = j;
        }
      }
    }
#line 1213
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1219
  tmp___2 = ddf_Positive((double *)(maxcost));
  }
#line 1219
  if (tmp___2) {
#line 1219
    dualfeasible = 0;
  }
#line 1221
  if (! dualfeasible) {
#line 1222
    j = (ddf_colrange )1;
    {
#line 1222
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1222
      if (! (j <= d_size)) {
#line 1222
        goto while_break___2;
      }
      {
#line 1223
      dddf_set((double *)(*(*(A + (local_m_size - 1L)) + (j - 1L))), (double *)(ddf_purezero));
#line 1224
      l = (ddf_colrange )1;
      }
      {
#line 1224
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1224
        if (! (l <= d_size)) {
#line 1224
          goto while_break___3;
        }
#line 1225
        if (*(nbindex + l) > 0L) {
          {
#line 1226
          dddf_set_si((double *)(scaling), l + 10L);
#line 1227
          dddf_mul((double *)(svalue), (double *)(*(*(A + (*(nbindex + l) - 1L)) + (j - 1L))),
                   (double *)(scaling));
#line 1228
          dddf_sub((double *)(*(*(A + (local_m_size - 1L)) + (j - 1L))), (double *)(*(*(A + (local_m_size - 1L)) + (j - 1L))),
                   (double *)(svalue));
          }
        }
#line 1224
        l ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1222
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1236
    if (localdebug) {
      {
#line 1237
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nddf_FindDualFeasibleBasis: curruent basis is not dual feasible.\n");
#line 1238
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"because of the column %ld assoc. with var %ld   dual cost =",
              ms, *(nbindex + ms));
#line 1240
      ddf_WriteNumber(stderr, (double *)(maxcost));
      }
#line 1241
      if (localdebug) {
#line 1242
        if (m_size <= 100L) {
#line 1242
          if (d_size <= 30L) {
            {
#line 1243
            printf((char const   */* __restrict  */)"\nddf_FindDualFeasibleBasis: the starting dictionary.\n");
#line 1244
            ddf_WriteTableau(stdout, m_size + 1L, d_size, A, T, nbindex, bflag___97);
            }
          }
        }
      }
    }
#line 1249
    ms = (ddf_colrange )0;
#line 1252
    j = (ddf_colrange )1;
    {
#line 1252
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1252
      if (! (j <= d_size)) {
#line 1252
        goto while_break___4;
      }
#line 1253
      if (j != rhscol) {
        {
#line 1253
        tmp___5 = ddf_Positive((double *)(*(rcost___2 + (j - 1L))));
        }
#line 1253
        if (tmp___5) {
          {
#line 1254
          ddf_TableauEntry(& axvalue, local_m_size, d_size, A, T, local_m_size, j);
#line 1255
          tmp___3 = ddf_Nonnegative((double *)(axvalue));
          }
#line 1255
          if (tmp___3) {
#line 1256
            *err = (ddf_ErrorType )16;
#line 1258
            if (localdebug) {
              {
#line 1258
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_FindDualFeasibleBasis: Numerical Inconsistency detected.\n");
              }
            }
#line 1259
            goto _L99;
          }
          {
#line 1261
          dddf_neg((double *)(axvalue), (double *)(axvalue));
#line 1262
          dddf_div((double *)(axvalue), (double *)(*(rcost___2 + (j - 1L))), (double *)(axvalue));
#line 1263
          tmp___4 = ddf_Larger((double *)(axvalue), (double *)(maxratio));
          }
#line 1263
          if (tmp___4) {
            {
#line 1264
            dddf_set((double *)(maxratio), (double *)(axvalue));
#line 1265
            ms = j;
            }
          }
        }
      }
#line 1252
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1270
    if (ms == 0L) {
#line 1271
      *err = (ddf_ErrorType )16;
#line 1272
      if (localdebug) {
        {
#line 1272
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_FindDualFeasibleBasis: Numerical Inconsistency detected.\n");
        }
      }
#line 1273
      goto _L99;
    }
    {
#line 1277
    ddf_GaussianColumnPivot2(local_m_size, d_size, A, T, nbindex, bflag___97, local_m_size,
                             ms);
#line 1278
    pivots_p1 ++;
    }
#line 1279
    if (localdebug) {
      {
#line 1280
      printf((char const   */* __restrict  */)"\nddf_FindDualFeasibleBasis: Pivot on %ld %ld.\n",
             local_m_size, ms);
      }
    }
#line 1283
    j = (ddf_colrange )1;
    {
#line 1283
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1283
      if (! (j <= d_size)) {
#line 1283
        goto while_break___5;
      }
#line 1283
      *(nbindex_ref___1 + j) = *(nbindex + j);
#line 1283
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1285
    if (localdebug) {
      {
#line 1286
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Store the current feasible basis:");
#line 1287
      j = (ddf_colrange )1;
      }
      {
#line 1287
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1287
        if (! (j <= d_size)) {
#line 1287
          goto while_break___6;
        }
        {
#line 1287
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %ld",
                *(nbindex_ref___1 + j));
#line 1287
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1288
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
#line 1289
      if (m_size <= 100L) {
#line 1289
        if (d_size <= 30L) {
          {
#line 1290
          ddf_WriteSignTableau2(stdout, m_size + 1L, d_size, A, T, nbindex_ref___1,
                                nbindex, bflag___97);
          }
        }
      }
    }
#line 1293
    phase1 = 1;
#line 1293
    stop = 0;
    {
#line 1294
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1295
      chosen = 0;
#line 1295
      LPSphase1 = (ddf_LPStatusType )0;
#line 1296
      if (pivots_p1 > maxpivots) {
        {
#line 1297
        *err = (ddf_ErrorType )15;
#line 1298
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"max number %ld of pivots performed in Phase I. Switch to the anticycling phase.\n",
                maxpivots);
        }
#line 1299
        goto _L99;
      }
      {
#line 1301
      ddf_SelectDualSimplexPivot(local_m_size, d_size, phase1, A, T, OV, nbindex_ref___1,
                                 nbindex, bflag___97, objrow, rhscol, lexicopivot,
                                 & r_val, & s_val, & chosen, & LPSphase1);
      }
#line 1303
      if (! chosen) {
        {
#line 1310
        ddf_TableauEntry(& x, local_m_size, d_size, A, T, objrow, ms);
#line 1311
        tmp___6 = ddf_Negative((double *)(x));
        }
#line 1311
        if (tmp___6) {
#line 1312
          *err = (ddf_ErrorType )17;
#line 1312
          *lps = (ddf_LPStatusType )3;
#line 1312
          *s = ms;
        }
#line 1314
        if (localdebug) {
          {
#line 1315
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nddf_FindDualFeasibleBasis: the auxiliary variable was forced to enter the basis (# pivots = %ld).\n",
                  pivots_p1);
#line 1316
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -- objrow %ld, ms %ld entry: ",
                  objrow, ms);
#line 1317
          ddf_WriteNumber(stderr, (double *)(x));
#line 1317
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1318
          tmp___7 = ddf_Negative((double *)(x));
          }
#line 1318
          if (tmp___7) {
            {
#line 1319
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"->The basis is dual inconsistent. Terminate.\n");
            }
          } else {
            {
#line 1321
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"->The basis is feasible. Go to phase II.\n");
            }
          }
        }
        {
#line 1325
        dddf_init((double *)(minval));
#line 1326
        r_val = (ddf_rowrange )0;
#line 1327
        i = (ddf_rowrange )1;
        }
        {
#line 1327
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1327
          if (! (i <= local_m_size)) {
#line 1327
            goto while_break___8;
          }
#line 1328
          if (*(bflag___97 + i) < 0L) {
            {
#line 1330
            ddf_TableauEntry(& val, local_m_size, d_size, A, T, i, ms);
#line 1331
            tmp___8 = ddf_Smaller((double *)(val), (double *)(minval));
            }
#line 1331
            if (tmp___8) {
              {
#line 1332
              r_val = i;
#line 1333
              dddf_set((double *)(minval), (double *)(val));
              }
            }
          }
#line 1327
          i ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 1337
        dddf_clear((double *)(minval));
        }
#line 1339
        if (r_val == 0L) {
#line 1340
          *err = (ddf_ErrorType )16;
#line 1341
          if (localdebug) {
            {
#line 1341
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_FindDualFeasibleBasis: Numerical Inconsistency detected (r_val is 0).\n");
            }
          }
#line 1342
          goto _L99;
        }
        {
#line 1345
        ddf_GaussianColumnPivot2(local_m_size, d_size, A, T, nbindex, bflag___97,
                                 r_val, ms);
#line 1346
        pivots_p1 ++;
        }
#line 1347
        if (localdebug) {
          {
#line 1348
          printf((char const   */* __restrict  */)"\nddf_FindDualFeasibleBasis: make the %ld-th pivot on %ld  %ld to force the auxiliary variable to enter the basis.\n",
                 pivots_p1, r_val, ms);
          }
#line 1349
          if (m_size <= 100L) {
#line 1349
            if (d_size <= 30L) {
              {
#line 1350
              ddf_WriteSignTableau2(stdout, m_size + 1L, d_size, A, T, nbindex_ref___1,
                                    nbindex, bflag___97);
              }
            }
          }
        }
#line 1353
        stop = 1;
      } else {
        {
#line 1356
        ddf_GaussianColumnPivot2(local_m_size, d_size, A, T, nbindex, bflag___97,
                                 r_val, s_val);
#line 1357
        pivots_p1 ++;
        }
#line 1358
        if (localdebug) {
          {
#line 1359
          printf((char const   */* __restrict  */)"\nddf_FindDualFeasibleBasis: make a %ld-th pivot on %ld  %ld\n",
                 pivots_p1, r_val, s_val);
          }
#line 1360
          if (m_size <= 100L) {
#line 1360
            if (d_size <= 30L) {
              {
#line 1361
              ddf_WriteSignTableau2(stdout, local_m_size, d_size, A, T, nbindex_ref___1,
                                    nbindex, bflag___97);
              }
            }
          }
        }
#line 1365
        if (*(bflag___97 + local_m_size) < 0L) {
#line 1366
          stop = 1;
#line 1367
          if (localdebug) {
            {
#line 1368
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nDualSimplex Phase I: the auxiliary variable entered the basis (# pivots = %ld).\nGo to phase II\n",
                    pivots_p1);
            }
          }
        }
      }
#line 1294
      if (! (! stop)) {
#line 1294
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  _L99: 
  {
#line 1374
  *pivot_no = pivots_p1;
#line 1375
  ddf_statDS1pivots += pivots_p1;
#line 1376
  dddf_clear((double *)(x));
#line 1376
  dddf_clear((double *)(val));
#line 1376
  dddf_clear((double *)(maxcost));
#line 1376
  dddf_clear((double *)(maxratio));
#line 1377
  dddf_clear((double *)(scaling));
#line 1377
  dddf_clear((double *)(svalue));
#line 1377
  dddf_clear((double *)(axvalue));
  }
#line 1378
  return;
}
}
#line 1380 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_DualSimplexMinimize(ddf_LPPtr lp , ddf_ErrorType *err ) 
{ 
  ddf_colrange j ;

  {
#line 1384
  *err = (ddf_ErrorType )17;
#line 1385
  j = (ddf_colrange )1;
  {
#line 1385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1385
    if (! (j <= lp->d)) {
#line 1385
      goto while_break;
    }
    {
#line 1386
    dddf_neg((double *)(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L))), (double *)(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L))));
#line 1385
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1387
  ddf_DualSimplexMaximize(lp, err);
#line 1388
  dddf_neg((double *)(lp->optvalue), (double *)(lp->optvalue));
#line 1389
  j = (ddf_colrange )1;
  }
  {
#line 1389
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1389
    if (! (j <= lp->d)) {
#line 1389
      goto while_break___0;
    }
#line 1390
    if ((unsigned int )lp->LPS != 2U) {
      {
#line 1392
      dddf_neg((double *)(*(lp->dsol + (j - 1L))), (double *)(*(lp->dsol + (j - 1L))));
      }
    }
    {
#line 1394
    dddf_neg((double *)(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L))), (double *)(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L))));
#line 1389
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1396
  return;
}
}
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___2  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___2  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___0  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___2  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___2  ;
#line 1398 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_DualSimplexMaximize(ddf_LPPtr lp , ddf_ErrorType *err ) 
{ 
  int stop ;
  int chosen ;
  int phase1 ;
  int found ;
  long pivots_ds ;
  long pivots_p0 ;
  long pivots_p1 ;
  long pivots_pc ;
  long maxpivots ;
  long maxpivfactor ;
  ddf_boolean localdebug ;
  ddf_boolean localdebug1 ;
  long maxccpivots ;
  long maxccpivfactor ;
  ddf_rowrange i ;
  ddf_rowrange r ;
  ddf_colrange j ;
  ddf_colrange s ;
  double redpercent ;
  double redpercent_prev ;
  double redgain ;
  unsigned int rseed ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1405
  pivots_ds = 0L;
#line 1405
  pivots_p0 = 0L;
#line 1405
  pivots_p1 = 0L;
#line 1405
  pivots_pc = 0L;
#line 1405
  maxpivfactor = 20L;
#line 1406
  localdebug = 0;
#line 1406
  localdebug1 = 0;
#line 1409
  maxccpivfactor = 100L;
#line 1422
  redpercent = (double )0;
#line 1422
  redpercent_prev = (double )0;
#line 1422
  redgain = (double )0;
#line 1423
  rseed = 1U;
#line 1426
  if (ddf_debug) {
#line 1426
    localdebug = ddf_debug;
  }
  {
#line 1427
  set_emptyset(lp->redset_extra);
#line 1428
  i = (ddf_rowrange )0;
  }
  {
#line 1428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1428
    if (! (i <= 4L)) {
#line 1428
      goto while_break;
    }
#line 1428
    lp->pivots[i] = 0L;
#line 1428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1429
  maxpivots = maxpivfactor * lp->d;
#line 1431
  maxccpivots = maxccpivfactor * lp->d;
#line 1433
  if (mlast___2 != lp->m) {
#line 1433
    goto _L;
  } else
#line 1433
  if (nlast___0 != lp->d) {
    _L: /* CIL Label */ 
#line 1434
    if (mlast___2 > 0L) {
      {
#line 1435
      free((void *)OrderVector___2);
#line 1436
      free((void *)bflag___2);
#line 1437
      free((void *)nbindex_ref___2);
      }
    }
    {
#line 1439
    tmp = calloc((size_t )(lp->m + 1L), sizeof(*OrderVector___2));
#line 1439
    OrderVector___2 = (long *)tmp;
#line 1440
    tmp___0 = calloc((size_t )(lp->m + 2L), sizeof(*bflag___2));
#line 1440
    bflag___2 = (long *)tmp___0;
#line 1441
    tmp___1 = calloc((size_t )(lp->d + 1L), sizeof(long ));
#line 1441
    nbindex_ref___2 = (long *)tmp___1;
#line 1442
    mlast___2 = lp->m;
#line 1442
    nlast___0 = lp->d;
    }
  }
  {
#line 1445
  ddf_ComputeRowOrderVector2(lp->m, lp->d, lp->A, OrderVector___2, (ddf_RowOrderType )1,
                             rseed);
#line 1447
  lp->re = (ddf_rowrange )0;
#line 1447
  lp->se = (ddf_colrange )0;
#line 1449
  ddf_ResetTableau(lp->m, lp->d, lp->B, lp->nbindex, bflag___2, lp->objrow, lp->rhscol);
#line 1451
  ddf_FindLPBasis(lp->m, lp->d, lp->A, lp->B, OrderVector___2, lp->equalityset, lp->nbindex,
                  bflag___2, lp->objrow, lp->rhscol, & s, & found, & lp->LPS, & pivots_p0);
#line 1453
  lp->pivots[0] = pivots_p0;
  }
#line 1455
  if (! found) {
#line 1456
    lp->se = s;
#line 1457
    goto _L99;
  }
  {
#line 1462
  ddf_FindDualFeasibleBasis(lp->m, lp->d, lp->A, lp->B, OrderVector___2, lp->nbindex,
                            bflag___2, lp->objrow, lp->rhscol, lp->lexicopivot, & s,
                            err, & lp->LPS, & pivots_p1, maxpivots);
#line 1464
  lp->pivots[1] = pivots_p1;
#line 1466
  j = (ddf_colrange )1;
  }
  {
#line 1466
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1466
    if (! (j <= lp->d)) {
#line 1466
      goto while_break___0;
    }
#line 1466
    *(nbindex_ref___2 + j) = *(lp->nbindex + j);
#line 1466
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1468
  if (localdebug) {
    {
#line 1469
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_DualSimplexMaximize: Store the current feasible basis:");
#line 1470
    j = (ddf_colrange )1;
    }
    {
#line 1470
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1470
      if (! (j <= lp->d)) {
#line 1470
        goto while_break___1;
      }
      {
#line 1470
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %ld",
              *(nbindex_ref___2 + j));
#line 1470
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1471
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 1472
    if (lp->m <= 100L) {
#line 1472
      if (lp->d <= 30L) {
        {
#line 1473
        ddf_WriteSignTableau2(stdout, lp->m + 1L, lp->d, lp->A, lp->B, nbindex_ref___2,
                              lp->nbindex, bflag___2);
        }
      }
    }
  }
#line 1476
  if ((unsigned int )*err == 15U) {
#line 1476
    goto _L___0;
  } else
#line 1476
  if ((unsigned int )*err == 16U) {
    _L___0: /* CIL Label */ 
#line 1477
    if (localdebug) {
      {
#line 1477
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Phase I failed and thus switch to the Criss-Cross method\n");
      }
    }
    {
#line 1478
    ddf_CrissCrossMaximize(lp, err);
    }
#line 1479
    return;
  }
#line 1482
  if ((unsigned int )lp->LPS == 3U) {
#line 1483
    lp->se = s;
#line 1484
    goto _L99;
  }
#line 1490
  stop = 0;
  {
#line 1491
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1492
    chosen = 0;
#line 1492
    lp->LPS = (ddf_LPStatusType )0;
#line 1492
    phase1 = 0;
#line 1493
    if (pivots_ds < maxpivots) {
      {
#line 1494
      ddf_SelectDualSimplexPivot(lp->m, lp->d, phase1, lp->A, lp->B, OrderVector___2,
                                 nbindex_ref___2, lp->nbindex, bflag___2, lp->objrow,
                                 lp->rhscol, lp->lexicopivot, & r, & s, & chosen,
                                 & lp->LPS);
      }
    }
#line 1497
    if (chosen) {
#line 1498
      pivots_ds ++;
#line 1499
      if (lp->redcheck_extensive) {
        {
#line 1500
        ddf_GetRedundancyInformation(lp->m, lp->d, lp->A, lp->B, lp->nbindex, bflag___2,
                                     lp->redset_extra);
#line 1501
        set_uni(lp->redset_accum, lp->redset_accum, lp->redset_extra);
#line 1502
        tmp___2 = set_card(lp->redset_extra);
#line 1502
        redpercent = ((double )100 * (double )tmp___2) / (double )lp->m;
#line 1503
        redgain = redpercent - redpercent_prev;
#line 1504
        redpercent_prev = redpercent;
        }
#line 1505
        if (localdebug1) {
          {
#line 1506
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nddf_DualSimplexMaximize: Phase II pivot %ld on (%ld, %ld).\n",
                  pivots_ds, r, s);
#line 1507
          tmp___3 = set_card(lp->redset_extra);
#line 1507
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  redundancy %f percent: redset size = %ld\n",
                  redpercent, tmp___3);
          }
        }
      }
    }
#line 1511
    if (! chosen) {
#line 1511
      if ((unsigned int )lp->LPS == 0U) {
#line 1512
        if (localdebug1) {
          {
#line 1513
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: an emergency CC pivot in Phase II is performed\n");
          }
#line 1518
          if (localdebug) {
#line 1518
            if (lp->m <= 100L) {
#line 1518
              if (lp->d <= 30L) {
                {
#line 1519
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nddf_DualSimplexMaximize: The current dictionary.\n");
#line 1520
                ddf_WriteSignTableau2(stdout, lp->m, lp->d, lp->A, lp->B, nbindex_ref___2,
                                      lp->nbindex, bflag___2);
                }
              }
            }
          }
        }
#line 1525
        if (pivots_pc > maxccpivots) {
#line 1526
          *err = (ddf_ErrorType )15;
#line 1527
          stop = 1;
#line 1528
          goto _L99;
        }
        {
#line 1532
        ddf_SelectCrissCrossPivot(lp->m, lp->d, lp->A, lp->B, bflag___2, lp->objrow,
                                  lp->rhscol, & r, & s, & chosen, & lp->LPS);
        }
#line 1534
        if (chosen) {
#line 1534
          pivots_pc ++;
        }
      }
    }
#line 1536
    if (chosen) {
      {
#line 1537
      ddf_GaussianColumnPivot2(lp->m, lp->d, lp->A, lp->B, lp->nbindex, bflag___2,
                               r, s);
      }
#line 1538
      if (localdebug) {
#line 1538
        if (lp->m <= 100L) {
#line 1538
          if (lp->d <= 30L) {
            {
#line 1539
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nddf_DualSimplexMaximize: The current dictionary.\n");
#line 1540
            ddf_WriteSignTableau2(stdout, lp->m, lp->d, lp->A, lp->B, nbindex_ref___2,
                                  lp->nbindex, bflag___2);
            }
          }
        }
      }
    } else {
      {
#line 1544
      if ((unsigned int )lp->LPS == 2U) {
#line 1544
        goto case_2;
      }
#line 1545
      if ((unsigned int )lp->LPS == 3U) {
#line 1545
        goto case_3;
      }
#line 1547
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1544
      lp->re = r;
      case_3: /* CIL Label */ 
#line 1545
      lp->se = s;
      switch_default: /* CIL Label */ 
#line 1547
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1549
      stop = 1;
    }
#line 1491
    if (! (! stop)) {
#line 1491
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  _L99: 
  {
#line 1553
  lp->pivots[2] = pivots_ds;
#line 1554
  lp->pivots[3] = pivots_pc;
#line 1555
  ddf_statDS2pivots += pivots_ds;
#line 1556
  ddf_statACpivots += pivots_pc;
#line 1558
  ddf_SetSolutions(lp->m, lp->d, lp->A, lp->B, lp->objrow, lp->rhscol, lp->LPS, & lp->optvalue,
                   lp->sol, lp->dsol, lp->posset_extra, lp->nbindex, lp->re, lp->se,
                   bflag___2);
  }
#line 1560
  return;
}
}
#line 1564 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_CrissCrossMinimize(ddf_LPPtr lp , ddf_ErrorType *err ) 
{ 
  ddf_colrange j ;

  {
#line 1568
  *err = (ddf_ErrorType )17;
#line 1569
  j = (ddf_colrange )1;
  {
#line 1569
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1569
    if (! (j <= lp->d)) {
#line 1569
      goto while_break;
    }
    {
#line 1570
    dddf_neg((double *)(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L))), (double *)(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L))));
#line 1569
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1571
  ddf_CrissCrossMaximize(lp, err);
#line 1572
  dddf_neg((double *)(lp->optvalue), (double *)(lp->optvalue));
#line 1573
  j = (ddf_colrange )1;
  }
  {
#line 1573
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1573
    if (! (j <= lp->d)) {
#line 1573
      goto while_break___0;
    }
#line 1574
    if ((unsigned int )lp->LPS != 2U) {
      {
#line 1576
      dddf_neg((double *)(*(lp->dsol + (j - 1L))), (double *)(*(lp->dsol + (j - 1L))));
      }
    }
    {
#line 1578
    dddf_neg((double *)(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L))), (double *)(*(*(lp->A + (lp->objrow - 1L)) + (j - 1L))));
#line 1573
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1580
  return;
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___3  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___3  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___3  ;
#line 1582 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_CrissCrossMaximize(ddf_LPPtr lp , ddf_ErrorType *err ) 
{ 
  int stop ;
  int chosen ;
  int found ;
  long pivots0 ;
  long pivots1 ;
  long maxpivots ;
  long maxpivfactor ;
  ddf_rowrange i ;
  ddf_rowrange r ;
  ddf_colrange s ;
  unsigned int rseed ;
  ddf_colindex nbtemp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1591
  maxpivfactor = 1000L;
#line 1602
  rseed = 1U;
#line 1605
  *err = (ddf_ErrorType )17;
#line 1607
  maxpivots = maxpivfactor * lp->d;
#line 1609
  tmp = calloc((size_t )(lp->d + 1L), sizeof(long ));
#line 1609
  nbtemp = (long *)tmp;
#line 1610
  i = (ddf_rowrange )0;
  }
  {
#line 1610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1610
    if (! (i <= 4L)) {
#line 1610
      goto while_break;
    }
#line 1610
    lp->pivots[i] = 0L;
#line 1610
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1611
  if ((unsigned long )bflag___3 == (unsigned long )((void *)0)) {
#line 1611
    goto _L;
  } else
#line 1611
  if (mlast___3 != lp->m) {
    _L: /* CIL Label */ 
#line 1612
    if (mlast___3 != lp->m) {
#line 1612
      if (mlast___3 > 0L) {
        {
#line 1613
        free((void *)bflag___3);
#line 1614
        free((void *)OrderVector___3);
        }
      }
    }
    {
#line 1616
    tmp___0 = calloc((size_t )(lp->m + 1L), sizeof(long ));
#line 1616
    bflag___3 = (long *)tmp___0;
#line 1617
    tmp___1 = calloc((size_t )(lp->m + 1L), sizeof(long ));
#line 1617
    OrderVector___3 = (long *)tmp___1;
#line 1620
    mlast___3 = lp->m;
    }
  }
  {
#line 1623
  ddf_ComputeRowOrderVector2(lp->m, lp->d, lp->A, OrderVector___3, (ddf_RowOrderType )1,
                             rseed);
#line 1625
  lp->re = (ddf_rowrange )0;
#line 1625
  lp->se = (ddf_colrange )0;
#line 1625
  pivots1 = 0L;
#line 1627
  ddf_ResetTableau(lp->m, lp->d, lp->B, lp->nbindex, bflag___3, lp->objrow, lp->rhscol);
#line 1629
  ddf_FindLPBasis(lp->m, lp->d, lp->A, lp->B, OrderVector___3, lp->equalityset, lp->nbindex,
                  bflag___3, lp->objrow, lp->rhscol, & s, & found, & lp->LPS, & pivots0);
#line 1631
  lp->pivots[0] += pivots0;
  }
#line 1633
  if (! found) {
#line 1634
    lp->se = s;
#line 1635
    goto _L99;
  }
#line 1640
  stop = 0;
  {
#line 1641
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1643
    if (pivots1 > maxpivots) {
      {
#line 1644
      *err = (ddf_ErrorType )15;
#line 1645
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"max number %ld of pivots performed by the criss-cross method. Most likely due to the floating-point arithmetics error.\n",
              maxpivots);
      }
#line 1646
      goto _L99;
    }
    {
#line 1650
    ddf_SelectCrissCrossPivot(lp->m, lp->d, lp->A, lp->B, bflag___3, lp->objrow, lp->rhscol,
                              & r, & s, & chosen, & lp->LPS);
    }
#line 1652
    if (chosen) {
      {
#line 1653
      ddf_GaussianColumnPivot2(lp->m, lp->d, lp->A, lp->B, lp->nbindex, bflag___3,
                               r, s);
#line 1654
      pivots1 ++;
      }
    } else {
      {
#line 1657
      if ((unsigned int )lp->LPS == 2U) {
#line 1657
        goto case_2;
      }
#line 1658
      if ((unsigned int )lp->LPS == 3U) {
#line 1658
        goto case_3;
      }
#line 1660
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1657
      lp->re = r;
      case_3: /* CIL Label */ 
#line 1658
      lp->se = s;
      switch_default: /* CIL Label */ 
#line 1660
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1662
      stop = 1;
    }
#line 1641
    if (! (! stop)) {
#line 1641
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  _L99: 
  {
#line 1667
  lp->pivots[1] += pivots1;
#line 1668
  ddf_statCCpivots += pivots1;
#line 1669
  ddf_SetSolutions(lp->m, lp->d, lp->A, lp->B, lp->objrow, lp->rhscol, lp->LPS, & lp->optvalue,
                   lp->sol, lp->dsol, lp->posset_extra, lp->nbindex, lp->re, lp->se,
                   bflag___3);
#line 1671
  free((void *)nbtemp);
  }
#line 1672
  return;
}
}
#line 1674 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_SetSolutions(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                      ddf_Bmatrix T , ddf_rowrange objrow , ddf_colrange rhscol ,
                      ddf_LPStatusType LPS , myfloat *optvalue , ddf_Arow sol , ddf_Arow dsol ,
                      ddf_rowset posset , ddf_colindex nbindex , ddf_rowrange re ,
                      ddf_colrange se , ddf_rowindex bflag___97 ) 
{ 
  ddf_rowrange i ;
  ddf_colrange j ;
  myfloat x ;
  myfloat sw ;
  int localdebug ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;

  {
  {
#line 1687
  localdebug = 0;
#line 1689
  dddf_init((double *)(x));
#line 1689
  dddf_init((double *)(sw));
  }
#line 1690
  if (localdebug) {
    {
#line 1690
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SetSolutions:\n");
    }
  }
  {
#line 1692
  if ((unsigned int )LPS == 1U) {
#line 1692
    goto case_1;
  }
#line 1708
  if ((unsigned int )LPS == 2U) {
#line 1708
    goto case_2;
  }
#line 1721
  if ((unsigned int )LPS == 3U) {
#line 1721
    goto case_3;
  }
#line 1734
  if ((unsigned int )LPS == 5U) {
#line 1734
    goto case_5;
  }
#line 1747
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1693
  j = (ddf_colrange )1;
  {
#line 1693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1693
    if (! (j <= d_size)) {
#line 1693
      goto while_break;
    }
    {
#line 1694
    dddf_set((double *)(*(sol + (j - 1L))), (double *)(*(*(T + (j - 1L)) + (rhscol - 1L))));
#line 1695
    ddf_TableauEntry(& x, m_size, d_size, A, T, objrow, j);
#line 1696
    dddf_neg((double *)(*(dsol + (j - 1L))), (double *)(x));
#line 1697
    ddf_TableauEntry(optvalue, m_size, d_size, A, T, objrow, rhscol);
    }
#line 1698
    if (localdebug) {
      {
#line 1698
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dsol[%ld]= ",
              *(nbindex + j));
#line 1698
      ddf_WriteNumber(stderr, (double *)(*(dsol + (j - 1L))));
      }
    }
#line 1693
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1700
  i = (ddf_rowrange )1;
  {
#line 1700
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1700
    if (! (i <= m_size)) {
#line 1700
      goto while_break___0;
    }
#line 1701
    if (*(bflag___97 + i) == -1L) {
      {
#line 1702
      ddf_TableauEntry(& x, m_size, d_size, A, T, i, rhscol);
#line 1703
      tmp = ddf_Positive((double *)(x));
      }
#line 1703
      if (tmp) {
        {
#line 1703
        set_addelem(posset, i);
        }
      }
    }
#line 1700
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1707
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1709
  if (localdebug) {
    {
#line 1709
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SetSolutions: LP is inconsistent.\n");
    }
  }
#line 1710
  j = (ddf_colrange )1;
  {
#line 1710
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1710
    if (! (j <= d_size)) {
#line 1710
      goto while_break___1;
    }
    {
#line 1711
    dddf_set((double *)(*(sol + (j - 1L))), (double *)(*(*(T + (j - 1L)) + (rhscol - 1L))));
#line 1712
    ddf_TableauEntry(& x, m_size, d_size, A, T, re, j);
#line 1713
    dddf_neg((double *)(*(dsol + (j - 1L))), (double *)(x));
    }
#line 1714
    if (localdebug) {
      {
#line 1714
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dsol[%ld]=",
              *(nbindex + j));
#line 1715
      ddf_WriteNumber(stderr, (double *)(*(dsol + (j - 1L))));
#line 1716
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1710
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1719
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1722
  if (localdebug) {
    {
#line 1722
    printf((char const   */* __restrict  */)"SetSolutions: LP is dual inconsistent.\n");
    }
  }
#line 1723
  j = (ddf_colrange )1;
  {
#line 1723
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1723
    if (! (j <= d_size)) {
#line 1723
      goto while_break___2;
    }
    {
#line 1724
    dddf_set((double *)(*(sol + (j - 1L))), (double *)(*(*(T + (j - 1L)) + (se - 1L))));
#line 1725
    ddf_TableauEntry(& x, m_size, d_size, A, T, objrow, j);
#line 1726
    dddf_neg((double *)(*(dsol + (j - 1L))), (double *)(x));
    }
#line 1727
    if (localdebug) {
      {
#line 1727
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dsol[%ld]=",
              *(nbindex + j));
#line 1728
      ddf_WriteNumber(stderr, (double *)(*(dsol + (j - 1L))));
#line 1729
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1723
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1732
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1735
  ddf_TableauEntry(& x, m_size, d_size, A, T, objrow, se);
#line 1736
  tmp___0 = ddf_Positive((double *)(x));
  }
#line 1736
  if (tmp___0) {
    {
#line 1736
    dddf_set((double *)(sw), (double *)(ddf_one));
    }
  } else {
    {
#line 1737
    dddf_neg((double *)(sw), (double *)(ddf_one));
    }
  }
#line 1738
  j = (ddf_colrange )1;
  {
#line 1738
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1738
    if (! (j <= d_size)) {
#line 1738
      goto while_break___3;
    }
    {
#line 1739
    dddf_mul((double *)(*(sol + (j - 1L))), (double *)(sw), (double *)(*(*(T + (j - 1L)) + (se - 1L))));
#line 1740
    ddf_TableauEntry(& x, m_size, d_size, A, T, objrow, j);
#line 1741
    dddf_neg((double *)(*(dsol + (j - 1L))), (double *)(x));
    }
#line 1742
    if (localdebug) {
      {
#line 1742
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dsol[%ld]= ",
              *(nbindex + j));
#line 1742
      ddf_WriteNumber(stderr, (double *)(*(dsol + (j - 1L))));
      }
    }
#line 1738
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1744
  if (localdebug) {
    {
#line 1744
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SetSolutions: LP is dual inconsistent.\n");
    }
  }
#line 1745
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1747
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1749
  dddf_clear((double *)(x));
#line 1749
  dddf_clear((double *)(sw));
  }
#line 1750
  return;
}
}
#line 1753 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_RandomPermutation2(ddf_rowindex OV , long t , unsigned int seed ) 
{ 
  long k ;
  long j ;
  long ovj ;
  double u ;
  double xk ;
  double r ;
  double rand_max ;
  int localdebug ;
  int tmp ;

  {
  {
#line 1756
  rand_max = (double )2147483647;
#line 1757
  localdebug = 0;
#line 1759
  srand(seed);
#line 1760
  j = t;
  }
  {
#line 1760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1760
    if (! (j > 1L)) {
#line 1760
      goto while_break;
    }
    {
#line 1761
    tmp = rand();
#line 1761
    r = (double )tmp;
#line 1762
    u = r / rand_max;
#line 1763
    xk = (double )j * u + (double )1;
#line 1764
    k = (long )xk;
    }
#line 1765
    if (localdebug) {
      {
#line 1765
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"u=%g, k=%ld, r=%g, randmax= %g\n",
              u, k, r, rand_max);
      }
    }
#line 1766
    ovj = *(OV + j);
#line 1767
    *(OV + j) = *(OV + k);
#line 1768
    *(OV + k) = ovj;
#line 1769
    if (localdebug) {
      {
#line 1769
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"row %ld is exchanged with %ld\n",
              j, k);
      }
    }
#line 1760
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1771
  return;
}
}
#line 1773 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_ComputeRowOrderVector2(ddf_rowrange m_size , ddf_colrange d_size , ddf_Amatrix A ,
                                ddf_rowindex OV , ddf_RowOrderType ho , unsigned int rseed ) 
{ 
  long i ;
  long itemp ;

  {
#line 1778
  *(OV + 0) = 0L;
  {
#line 1780
  if ((unsigned int )ho == 0U) {
#line 1780
    goto case_0;
  }
#line 1784
  if ((unsigned int )ho == 5U) {
#line 1784
    goto case_5;
  }
#line 1789
  if ((unsigned int )ho == 6U) {
#line 1789
    goto case_6;
  }
#line 1799
  if ((unsigned int )ho == 7U) {
#line 1799
    goto case_7;
  }
#line 1805
  if ((unsigned int )ho == 1U) {
#line 1805
    goto case_1;
  }
#line 1809
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1781
  i = 1L;
  {
#line 1781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1781
    if (! (i <= m_size)) {
#line 1781
      goto while_break;
    }
#line 1781
    *(OV + i) = (m_size - i) + 1L;
#line 1781
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1782
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1785
  i = 1L;
  {
#line 1785
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1785
    if (! (i <= m_size)) {
#line 1785
      goto while_break___0;
    }
#line 1785
    *(OV + i) = i;
#line 1785
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1786
  ddf_QuickSort(OV, 1L, m_size, A, d_size);
  }
#line 1787
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1790
  i = 1L;
  {
#line 1790
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1790
    if (! (i <= m_size)) {
#line 1790
      goto while_break___1;
    }
#line 1790
    *(OV + i) = i;
#line 1790
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1791
  ddf_QuickSort(OV, 1L, m_size, A, d_size);
#line 1792
  i = 1L;
  }
  {
#line 1792
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1792
    if (! (i <= m_size / 2L)) {
#line 1792
      goto while_break___2;
    }
#line 1793
    itemp = *(OV + i);
#line 1794
    *(OV + i) = *(OV + ((m_size - i) + 1L));
#line 1795
    *(OV + ((m_size - i) + 1L)) = itemp;
#line 1792
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1797
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1800
  i = 1L;
  {
#line 1800
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1800
    if (! (i <= m_size)) {
#line 1800
      goto while_break___3;
    }
#line 1800
    *(OV + i) = i;
#line 1800
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1801
  if (rseed <= 0U) {
#line 1801
    rseed = 1U;
  }
  {
#line 1802
  ddf_RandomPermutation2(OV, m_size, rseed);
  }
#line 1803
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1806
  i = 1L;
  {
#line 1806
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1806
    if (! (i <= m_size)) {
#line 1806
      goto while_break___4;
    }
#line 1806
    *(OV + i) = i;
#line 1806
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1807
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1810
  i = 1L;
  {
#line 1810
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1810
    if (! (i <= m_size)) {
#line 1810
      goto while_break___5;
    }
#line 1810
    *(OV + i) = i;
#line 1810
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1811
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1813
  return;
}
}
#line 1815 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_SelectPreorderedNext2(ddf_rowrange m_size , ddf_colrange d_size , rowset excluded ,
                               ddf_rowindex OV , ddf_rowrange *hnext ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange k ;
  int tmp ;

  {
#line 1820
  *hnext = (ddf_rowrange )0;
#line 1821
  i = (ddf_rowrange )1;
  {
#line 1821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1821
    if (i <= m_size) {
#line 1821
      if (! (*hnext == 0L)) {
#line 1821
        goto while_break;
      }
    } else {
#line 1821
      goto while_break;
    }
    {
#line 1822
    k = *(OV + i);
#line 1823
    tmp = set_member(k, excluded);
    }
#line 1823
    if (! tmp) {
#line 1823
      *hnext = k;
    }
#line 1821
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1825
  return;
}
}
#line 1871 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_boolean ddf_LPSolve(ddf_LPPtr lp , ddf_LPSolverType solver , ddf_ErrorType *err ) 
{ 
  int i ;
  ddf_boolean found ;

  {
  {
#line 1881
  found = 0;
#line 1890
  *err = (ddf_ErrorType )17;
#line 1891
  lp->solver = solver;
#line 1893
  time(& lp->starttime);
  }
  {
#line 1897
  if ((unsigned int )lp->solver == 0U) {
#line 1897
    goto case_0;
  }
#line 1900
  if ((unsigned int )lp->solver == 1U) {
#line 1900
    goto case_1;
  }
#line 1896
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1898
  ddf_CrissCrossSolve(lp, err);
  }
#line 1899
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1901
  ddf_DualSimplexSolve(lp, err);
  }
#line 1902
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1941
  time(& lp->endtime);
#line 1942
  lp->total_pivots = 0L;
#line 1943
  i = 0;
  }
  {
#line 1943
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1943
    if (! (i <= 4)) {
#line 1943
      goto while_break;
    }
#line 1943
    lp->total_pivots += lp->pivots[i];
#line 1943
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1944
  if ((unsigned int )*err == 17U) {
#line 1944
    found = 1;
  }
#line 1945
  return (found);
}
}
#line 1949 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_boolean ddf_LPSolve0(ddf_LPPtr lp , ddf_LPSolverType solver , ddf_ErrorType *err ) 
{ 
  int i ;
  ddf_boolean found ;

  {
  {
#line 1958
  found = 0;
#line 1960
  *err = (ddf_ErrorType )17;
#line 1961
  lp->solver = solver;
#line 1962
  time(& lp->starttime);
  }
  {
#line 1965
  if ((unsigned int )lp->solver == 0U) {
#line 1965
    goto case_0;
  }
#line 1968
  if ((unsigned int )lp->solver == 1U) {
#line 1968
    goto case_1;
  }
#line 1964
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1966
  ddf_CrissCrossSolve(lp, err);
  }
#line 1967
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1969
  ddf_DualSimplexSolve(lp, err);
  }
#line 1970
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1973
  time(& lp->endtime);
#line 1974
  lp->total_pivots = 0L;
#line 1975
  i = 0;
  }
  {
#line 1975
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1975
    if (! (i <= 4)) {
#line 1975
      goto while_break;
    }
#line 1975
    lp->total_pivots += lp->pivots[i];
#line 1975
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1976
  if ((unsigned int )*err == 17U) {
#line 1976
    found = 1;
  }
#line 1977
  return (found);
}
}
#line 1981 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_LPPtr ddf_MakeLPforInteriorFinding(ddf_LPPtr lp ) 
{ 
  ddf_rowrange m ;
  ddf_colrange d ;
  ddf_NumberType numbtype ;
  ddf_LPObjectiveType obj ;
  ddf_LPType *lpnew ;
  ddf_rowrange i ;
  ddf_colrange j ;
  myfloat bm ;
  myfloat bmax ;
  myfloat bceil ;
  int localdebug ;
  ddf_boolean tmp ;

  {
  {
#line 2003
  localdebug = 0;
#line 2005
  dddf_init((double *)(bm));
#line 2005
  dddf_init((double *)(bmax));
#line 2005
  dddf_init((double *)(bceil));
#line 2006
  dddf_add((double *)(bm), (double *)(ddf_one), (double *)(ddf_one));
#line 2006
  dddf_set((double *)(bmax), (double *)(ddf_one));
#line 2007
  numbtype = lp->numbtype;
#line 2008
  m = lp->m + 1L;
#line 2009
  d = lp->d + 1L;
#line 2010
  obj = (ddf_LPObjectiveType )1;
#line 2012
  lpnew = ddf_CreateLPData(obj, numbtype, m, d);
#line 2014
  i = (ddf_rowrange )1;
  }
  {
#line 2014
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2014
    if (! (i <= lp->m)) {
#line 2014
      goto while_break;
    }
    {
#line 2015
    tmp = ddf_Larger((double *)(*(*(lp->A + (i - 1L)) + (lp->rhscol - 1L))), (double *)(bmax));
    }
#line 2015
    if (tmp) {
      {
#line 2016
      dddf_set((double *)(bmax), (double *)(*(*(lp->A + (i - 1L)) + (lp->rhscol - 1L))));
      }
    }
#line 2014
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2018
  dddf_mul((double *)(bceil), (double *)(bm), (double *)(bmax));
  }
#line 2019
  if (localdebug) {
    {
#line 2019
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bceil is set to ");
#line 2019
    ddf_WriteNumber(stderr, (double *)(bceil));
    }
  }
#line 2021
  i = (ddf_rowrange )1;
  {
#line 2021
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2021
    if (! (i <= lp->m)) {
#line 2021
      goto while_break___0;
    }
#line 2022
    j = (ddf_colrange )1;
    {
#line 2022
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2022
      if (! (j <= lp->d)) {
#line 2022
        goto while_break___1;
      }
      {
#line 2023
      dddf_set((double *)(*(*(lpnew->A + (i - 1L)) + (j - 1L))), (double *)(*(*(lp->A + (i - 1L)) + (j - 1L))));
#line 2022
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2021
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2027
  i = (ddf_rowrange )1;
  {
#line 2027
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2027
    if (! (i <= lp->m)) {
#line 2027
      goto while_break___2;
    }
    {
#line 2028
    dddf_neg((double *)(*(*(lpnew->A + (i - 1L)) + lp->d)), (double *)(ddf_one));
#line 2027
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2031
  j = (ddf_colrange )1;
  {
#line 2031
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2031
    if (! (j <= lp->d)) {
#line 2031
      goto while_break___3;
    }
    {
#line 2032
    dddf_set((double *)(*(*(lpnew->A + (m - 2L)) + (j - 1L))), (double *)(ddf_purezero));
#line 2031
    j ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2034
  dddf_set((double *)(*(*(lpnew->A + (m - 2L)) + 0)), (double *)(bceil));
#line 2036
  j = (ddf_colrange )1;
  }
  {
#line 2036
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2036
    if (! (j <= d - 1L)) {
#line 2036
      goto while_break___4;
    }
    {
#line 2037
    dddf_set((double *)(*(*(lpnew->A + (m - 1L)) + (j - 1L))), (double *)(ddf_purezero));
#line 2036
    j ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 2039
  dddf_set((double *)(*(*(lpnew->A + (m - 1L)) + (d - 1L))), (double *)(ddf_one));
  }
#line 2041
  if (localdebug) {
    {
#line 2041
    ddf_WriteAmatrix(stderr, lp->A, lp->m, lp->d);
    }
  }
#line 2042
  if (localdebug) {
    {
#line 2042
    ddf_WriteAmatrix(stderr, lpnew->A, lpnew->m, lpnew->d);
    }
  }
  {
#line 2043
  dddf_clear((double *)(bm));
#line 2043
  dddf_clear((double *)(bmax));
#line 2043
  dddf_clear((double *)(bceil));
  }
#line 2045
  return (lpnew);
}
}
#line 2049 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
void ddf_WriteLPResult(FILE *f , ddf_LPPtr lp , ddf_ErrorType err ) 
{ 
  long j ;
  ddf_boolean tmp ;

  {
  {
#line 2053
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* cdd LP solver result\n");
  }
#line 2055
  if ((unsigned int )err != 17U) {
    {
#line 2056
    ddf_WriteErrorMessages(f, err);
    }
#line 2057
    goto _L99;
  }
  {
#line 2060
  ddf_WriteProgramDescription(f);
#line 2062
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* #constraints = %ld\n",
          lp->m - 1L);
#line 2063
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* #variables   = %ld\n",
          lp->d - 1L);
  }
  {
#line 2066
  if ((unsigned int )lp->solver == 1U) {
#line 2066
    goto case_1;
  }
#line 2068
  if ((unsigned int )lp->solver == 0U) {
#line 2068
    goto case_0;
  }
#line 2065
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2067
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Algorithm: dual simplex algorithm\n");
  }
#line 2067
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 2069
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Algorithm: criss-cross method\n");
  }
#line 2069
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2073
  if ((unsigned int )lp->objective == 1U) {
#line 2073
    goto case_1___0;
  }
#line 2075
  if ((unsigned int )lp->objective == 2U) {
#line 2075
    goto case_2;
  }
#line 2077
  if ((unsigned int )lp->objective == 0U) {
#line 2077
    goto case_0___0;
  }
#line 2072
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 2074
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* maximization is chosen\n");
  }
#line 2074
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 2076
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* minimization is chosen\n");
  }
#line 2076
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 2078
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* no objective type (max or min) is chosen\n");
  }
#line 2078
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2081
  if ((unsigned int )lp->objective == 1U) {
#line 2081
    goto _L;
  } else
#line 2081
  if ((unsigned int )lp->objective == 2U) {
    _L: /* CIL Label */ 
    {
#line 2082
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Objective function is\n");
#line 2083
    j = 0L;
    }
    {
#line 2083
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2083
      if (! (j < lp->d)) {
#line 2083
        goto while_break;
      }
#line 2084
      if (j > 0L) {
        {
#line 2084
        tmp = ddf_Nonnegative((double *)(*(*(lp->A + (lp->objrow - 1L)) + j)));
        }
#line 2084
        if (tmp) {
          {
#line 2084
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" +");
          }
        }
      }
#line 2085
      if (j > 0L) {
#line 2085
        if (j % 5L == 0L) {
          {
#line 2085
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
          }
        }
      }
      {
#line 2086
      ddf_WriteNumber(f, (double *)(*(*(lp->A + (lp->objrow - 1L)) + j)));
      }
#line 2087
      if (j > 0L) {
        {
#line 2087
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" X[%3ld]",
                j);
        }
      }
#line 2083
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2089
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 2093
  if ((unsigned int )lp->LPS == 1U) {
#line 2093
    goto case_1___1;
  }
#line 2113
  if ((unsigned int )lp->LPS == 2U) {
#line 2113
    goto case_2___0;
  }
#line 2130
  if ((unsigned int )lp->LPS == 5U) {
#line 2130
    goto case_5;
  }
#line 2130
  if ((unsigned int )lp->LPS == 3U) {
#line 2130
    goto case_5;
  }
#line 2145
  goto switch_default;
  case_1___1: /* CIL Label */ 
  {
#line 2094
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* LP status: a dual pair (x,y) of optimal solutions found.\n");
#line 2095
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"begin\n");
#line 2096
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  primal_solution\n");
#line 2097
  j = 1L;
  }
  {
#line 2097
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2097
    if (! (j < lp->d)) {
#line 2097
      goto while_break___0;
    }
    {
#line 2098
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %3ld : ",
            j);
#line 2099
    ddf_WriteNumber(f, (double *)(*(lp->sol + j)));
#line 2100
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 2097
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2102
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  dual_solution\n");
#line 2103
  j = 1L;
  }
  {
#line 2103
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2103
    if (! (j < lp->d)) {
#line 2103
      goto while_break___1;
    }
#line 2104
    if (*(lp->nbindex + (j + 1L)) > 0L) {
      {
#line 2105
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %3ld : ",
              *(lp->nbindex + (j + 1L)));
#line 2106
      ddf_WriteNumber(f, (double *)(*(lp->dsol + j)));
#line 2106
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
      }
    }
#line 2103
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2109
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  optimal_value : ");
#line 2109
  ddf_WriteNumber(f, (double *)(lp->optvalue));
#line 2110
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\nend\n");
  }
#line 2111
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  {
#line 2114
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* LP status: LP is inconsistent.\n");
#line 2115
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* The positive combination of original inequalities with\n");
#line 2116
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* the following coefficients will prove the inconsistency.\n");
#line 2117
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"begin\n");
#line 2118
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  dual_direction\n");
#line 2119
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %3ld : ",
          lp->re);
#line 2120
  ddf_WriteNumber(f, (double *)(ddf_one));
#line 2120
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 2121
  j = 1L;
  }
  {
#line 2121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2121
    if (! (j < lp->d)) {
#line 2121
      goto while_break___2;
    }
#line 2122
    if (*(lp->nbindex + (j + 1L)) > 0L) {
      {
#line 2123
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %3ld : ",
              *(lp->nbindex + (j + 1L)));
#line 2124
      ddf_WriteNumber(f, (double *)(*(lp->dsol + j)));
#line 2124
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
      }
    }
#line 2121
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2127
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
  }
#line 2128
  goto switch_break___1;
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 2131
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* LP status: LP is dual inconsistent.\n");
#line 2132
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* The linear combination of columns with\n");
#line 2133
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* the following coefficients will prove the dual inconsistency.\n");
#line 2134
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* (It is also an unbounded direction for the primal LP.)\n");
#line 2135
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"begin\n");
#line 2136
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  primal_direction\n");
#line 2137
  j = 1L;
  }
  {
#line 2137
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2137
    if (! (j < lp->d)) {
#line 2137
      goto while_break___3;
    }
    {
#line 2138
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %3ld : ",
            j);
#line 2139
    ddf_WriteNumber(f, (double *)(*(lp->sol + j)));
#line 2140
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 2137
    j ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2142
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
  }
#line 2143
  goto switch_break___1;
  switch_default: /* CIL Label */ 
#line 2146
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 2148
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* number of pivot operations = %ld (ph0 = %ld, ph1 = %ld, ph2 = %ld, ph3 = %ld, ph4 = %ld)\n",
          lp->total_pivots, lp->pivots[0], lp->pivots[1], lp->pivots[2], lp->pivots[3],
          lp->pivots[4]);
#line 2149
  ddf_WriteLPTimes(f, lp);
  }
  _L99: ;
#line 2151
  return;
}
}
#line 2153 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_LPPtr ddf_CreateLP_H_ImplicitLinearity(ddf_MatrixPtr M ) 
{ 
  ddf_rowrange m ;
  ddf_rowrange i ;
  ddf_rowrange irev ;
  ddf_rowrange linc ;
  ddf_colrange d ;
  ddf_colrange j ;
  ddf_LPPtr lp ;
  ddf_boolean localdebug ;
  int tmp ;
  ddf_boolean tmp___0 ;

  {
  {
#line 2158
  localdebug = 0;
#line 2160
  linc = set_card(M->linset);
#line 2161
  m = ((M->rowsize + 1L) + linc) + 1L;
#line 2164
  d = M->colsize + 1L;
#line 2166
  lp = ddf_CreateLPData(M->objective, M->numbtype, m, d);
#line 2167
  lp->Homogeneous = 1;
#line 2168
  lp->objective = (ddf_LPObjectiveType )1;
#line 2169
  lp->eqnumber = linc;
#line 2170
  lp->redcheck_extensive = 0;
#line 2172
  irev = M->rowsize;
#line 2173
  i = (ddf_rowrange )1;
  }
  {
#line 2173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2173
    if (! (i <= M->rowsize)) {
#line 2173
      goto while_break;
    }
    {
#line 2174
    tmp = set_member(i, M->linset);
    }
#line 2174
    if (tmp) {
      {
#line 2175
      irev ++;
#line 2176
      set_addelem(lp->equalityset, i);
#line 2178
      j = (ddf_colrange )1;
      }
      {
#line 2178
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2178
        if (! (j <= M->colsize)) {
#line 2178
          goto while_break___0;
        }
        {
#line 2179
        dddf_neg((double *)(*(*(lp->A + (irev - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
#line 2178
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 2182
      dddf_set((double *)(*(*(lp->A + (i - 1L)) + (d - 1L))), (double *)(ddf_minusone));
      }
    }
#line 2184
    j = (ddf_colrange )1;
    {
#line 2184
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2184
      if (! (j <= M->colsize)) {
#line 2184
        goto while_break___1;
      }
      {
#line 2185
      dddf_set((double *)(*(*(lp->A + (i - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
      }
#line 2186
      if (j == 1L) {
#line 2186
        if (i < M->rowsize) {
          {
#line 2186
          tmp___0 = ddf_Nonzero((double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
          }
#line 2186
          if (tmp___0) {
#line 2186
            lp->Homogeneous = 0;
          }
        }
      }
#line 2184
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2189
  dddf_set((double *)(*(*(lp->A + (m - 2L)) + 0)), (double *)(ddf_one));
#line 2189
  dddf_set((double *)(*(*(lp->A + (m - 2L)) + (d - 1L))), (double *)(ddf_minusone));
#line 2192
  dddf_set((double *)(*(*(lp->A + (m - 1L)) + (d - 1L))), (double *)(ddf_one));
  }
#line 2195
  if (localdebug) {
    {
#line 2196
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_CreateLP_H_ImplicitLinearity: an new lp is\n");
#line 2197
    ddf_WriteLP(stderr, lp);
    }
  }
#line 2200
  return (lp);
}
}
#line 2203 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_LPPtr ddf_CreateLP_V_ImplicitLinearity(ddf_MatrixPtr M ) 
{ 
  ddf_rowrange m ;
  ddf_rowrange i ;
  ddf_rowrange irev ;
  ddf_rowrange linc ;
  ddf_colrange d ;
  ddf_colrange j ;
  ddf_LPPtr lp ;
  ddf_boolean localdebug ;
  int tmp ;

  {
  {
#line 2208
  localdebug = 0;
#line 2210
  linc = set_card(M->linset);
#line 2211
  m = ((M->rowsize + 1L) + linc) + 1L;
#line 2214
  d = M->colsize + 2L;
#line 2219
  lp = ddf_CreateLPData(M->objective, M->numbtype, m, d);
#line 2220
  lp->Homogeneous = 0;
#line 2221
  lp->objective = (ddf_LPObjectiveType )1;
#line 2222
  lp->eqnumber = linc;
#line 2223
  lp->redcheck_extensive = 0;
#line 2225
  irev = M->rowsize;
#line 2226
  i = (ddf_rowrange )1;
  }
  {
#line 2226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2226
    if (! (i <= M->rowsize)) {
#line 2226
      goto while_break;
    }
    {
#line 2227
    dddf_set((double *)(*(*(lp->A + (i - 1L)) + 0)), (double *)(ddf_purezero));
#line 2228
    tmp = set_member(i, M->linset);
    }
#line 2228
    if (tmp) {
      {
#line 2229
      irev ++;
#line 2230
      set_addelem(lp->equalityset, i);
#line 2232
      j = (ddf_colrange )2;
      }
      {
#line 2232
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2232
        if (! (j <= M->colsize + 1L)) {
#line 2232
          goto while_break___0;
        }
        {
#line 2233
        dddf_neg((double *)(*(*(lp->A + (irev - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 2L))));
#line 2232
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2235
      if (localdebug) {
        {
#line 2235
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"equality row %ld generates the reverse row %ld.\n",
                i, irev);
        }
      }
    } else {
      {
#line 2237
      dddf_set((double *)(*(*(lp->A + (i - 1L)) + (d - 1L))), (double *)(ddf_minusone));
      }
    }
#line 2239
    j = (ddf_colrange )2;
    {
#line 2239
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2239
      if (! (j <= M->colsize + 1L)) {
#line 2239
        goto while_break___1;
      }
      {
#line 2240
      dddf_set((double *)(*(*(lp->A + (i - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 2L))));
#line 2239
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2243
  dddf_set((double *)(*(*(lp->A + (m - 2L)) + 0)), (double *)(ddf_one));
#line 2243
  dddf_set((double *)(*(*(lp->A + (m - 2L)) + (d - 1L))), (double *)(ddf_minusone));
#line 2245
  dddf_set((double *)(*(*(lp->A + (m - 1L)) + (d - 1L))), (double *)(ddf_one));
  }
#line 2248
  if (localdebug) {
    {
#line 2249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_CreateLP_V_ImplicitLinearity: an new lp is\n");
#line 2250
    ddf_WriteLP(stderr, lp);
    }
  }
#line 2253
  return (lp);
}
}
#line 2257 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_LPPtr ddf_CreateLP_H_Redundancy(ddf_MatrixPtr M , ddf_rowrange itest ) 
{ 
  ddf_rowrange m ;
  ddf_rowrange i ;
  ddf_rowrange irev ;
  ddf_rowrange linc ;
  ddf_colrange d ;
  ddf_colrange j ;
  ddf_LPPtr lp ;
  ddf_boolean localdebug ;
  int tmp ;
  ddf_boolean tmp___0 ;

  {
  {
#line 2262
  localdebug = 0;
#line 2264
  linc = set_card(M->linset);
#line 2265
  m = (M->rowsize + 1L) + linc;
#line 2268
  d = M->colsize;
#line 2270
  lp = ddf_CreateLPData(M->objective, M->numbtype, m, d);
#line 2271
  lp->Homogeneous = 1;
#line 2272
  lp->objective = (ddf_LPObjectiveType )2;
#line 2273
  lp->eqnumber = linc;
#line 2274
  lp->redcheck_extensive = 0;
#line 2276
  irev = M->rowsize;
#line 2277
  i = (ddf_rowrange )1;
  }
  {
#line 2277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2277
    if (! (i <= M->rowsize)) {
#line 2277
      goto while_break;
    }
    {
#line 2278
    tmp = set_member(i, M->linset);
    }
#line 2278
    if (tmp) {
      {
#line 2279
      irev ++;
#line 2280
      set_addelem(lp->equalityset, i);
#line 2282
      j = (ddf_colrange )1;
      }
      {
#line 2282
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2282
        if (! (j <= M->colsize)) {
#line 2282
          goto while_break___0;
        }
        {
#line 2283
        dddf_neg((double *)(*(*(lp->A + (irev - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
#line 2282
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2285
      if (localdebug) {
        {
#line 2285
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"equality row %ld generates the reverse row %ld.\n",
                i, irev);
        }
      }
    }
#line 2287
    j = (ddf_colrange )1;
    {
#line 2287
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2287
      if (! (j <= M->colsize)) {
#line 2287
        goto while_break___1;
      }
      {
#line 2288
      dddf_set((double *)(*(*(lp->A + (i - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
      }
#line 2289
      if (j == 1L) {
#line 2289
        if (i < M->rowsize) {
          {
#line 2289
          tmp___0 = ddf_Nonzero((double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
          }
#line 2289
          if (tmp___0) {
#line 2289
            lp->Homogeneous = 0;
          }
        }
      }
#line 2287
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2277
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2292
  j = (ddf_colrange )1;
  {
#line 2292
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2292
    if (! (j <= M->colsize)) {
#line 2292
      goto while_break___2;
    }
    {
#line 2293
    dddf_set((double *)(*(*(lp->A + (m - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (itest - 1L)) + (j - 1L))));
#line 2292
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2296
  dddf_add((double *)(*(*(lp->A + (itest - 1L)) + 0)), (double *)(*(*(lp->A + (itest - 1L)) + 0)),
           (double *)(ddf_one));
  }
#line 2298
  return (lp);
}
}
#line 2302 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_LPPtr ddf_CreateLP_V_Redundancy(ddf_MatrixPtr M , ddf_rowrange itest ) 
{ 
  ddf_rowrange m ;
  ddf_rowrange i ;
  ddf_rowrange irev ;
  ddf_rowrange linc ;
  ddf_colrange d ;
  ddf_colrange j ;
  ddf_LPPtr lp ;
  ddf_boolean localdebug ;
  int tmp ;

  {
  {
#line 2307
  localdebug = 0;
#line 2309
  linc = set_card(M->linset);
#line 2310
  m = (M->rowsize + 1L) + linc;
#line 2313
  d = M->colsize + 1L;
#line 2318
  lp = ddf_CreateLPData(M->objective, M->numbtype, m, d);
#line 2319
  lp->Homogeneous = 0;
#line 2320
  lp->objective = (ddf_LPObjectiveType )2;
#line 2321
  lp->eqnumber = linc;
#line 2322
  lp->redcheck_extensive = 0;
#line 2324
  irev = M->rowsize;
#line 2325
  i = (ddf_rowrange )1;
  }
  {
#line 2325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2325
    if (! (i <= M->rowsize)) {
#line 2325
      goto while_break;
    }
#line 2326
    if (i == itest) {
      {
#line 2327
      dddf_set((double *)(*(*(lp->A + (i - 1L)) + 0)), (double *)(ddf_one));
      }
    } else {
      {
#line 2329
      dddf_set((double *)(*(*(lp->A + (i - 1L)) + 0)), (double *)(ddf_purezero));
      }
    }
    {
#line 2331
    tmp = set_member(i, M->linset);
    }
#line 2331
    if (tmp) {
      {
#line 2332
      irev ++;
#line 2333
      set_addelem(lp->equalityset, i);
#line 2335
      j = (ddf_colrange )2;
      }
      {
#line 2335
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2335
        if (! (j <= M->colsize + 1L)) {
#line 2335
          goto while_break___0;
        }
        {
#line 2336
        dddf_neg((double *)(*(*(lp->A + (irev - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 2L))));
#line 2335
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2338
      if (localdebug) {
        {
#line 2338
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"equality row %ld generates the reverse row %ld.\n",
                i, irev);
        }
      }
    }
#line 2340
    j = (ddf_colrange )2;
    {
#line 2340
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2340
      if (! (j <= M->colsize + 1L)) {
#line 2340
        goto while_break___1;
      }
      {
#line 2341
      dddf_set((double *)(*(*(lp->A + (i - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 2L))));
#line 2340
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2325
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2344
  j = (ddf_colrange )2;
  {
#line 2344
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2344
    if (! (j <= M->colsize + 1L)) {
#line 2344
      goto while_break___2;
    }
    {
#line 2345
    dddf_set((double *)(*(*(lp->A + (m - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (itest - 1L)) + (j - 2L))));
#line 2344
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2348
  dddf_set((double *)(*(*(lp->A + (m - 1L)) + 0)), (double *)(ddf_purezero));
  }
#line 2350
  if (localdebug) {
    {
#line 2350
    ddf_WriteLP(stdout, lp);
    }
  }
#line 2352
  return (lp);
}
}
#line 2356 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_LPPtr ddf_CreateLP_V_SRedundancy(ddf_MatrixPtr M , ddf_rowrange itest ) 
{ 
  ddf_rowrange m ;
  ddf_rowrange i ;
  ddf_rowrange irev ;
  ddf_rowrange linc ;
  ddf_colrange d ;
  ddf_colrange j ;
  ddf_LPPtr lp ;
  ddf_boolean localdebug ;
  int tmp ;

  {
  {
#line 2374
  localdebug = 0;
#line 2376
  linc = set_card(M->linset);
#line 2377
  m = ((M->rowsize + 1L) + linc) + 2L;
#line 2382
  d = M->colsize + 1L;
#line 2387
  lp = ddf_CreateLPData(M->objective, M->numbtype, m, d);
#line 2388
  lp->Homogeneous = 0;
#line 2389
  lp->objective = (ddf_LPObjectiveType )1;
#line 2390
  lp->eqnumber = linc;
#line 2392
  irev = M->rowsize;
#line 2393
  i = (ddf_rowrange )1;
  }
  {
#line 2393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2393
    if (! (i <= M->rowsize)) {
#line 2393
      goto while_break;
    }
#line 2394
    if (i == itest) {
      {
#line 2395
      dddf_set((double *)(*(*(lp->A + (i - 1L)) + 0)), (double *)(ddf_purezero));
      }
    } else {
      {
#line 2397
      dddf_set((double *)(*(*(lp->A + (i - 1L)) + 0)), (double *)(ddf_purezero));
      }
    }
    {
#line 2399
    tmp = set_member(i, M->linset);
    }
#line 2399
    if (tmp) {
#line 2399
      goto _L;
    } else
#line 2399
    if (i == itest) {
      _L: /* CIL Label */ 
      {
#line 2400
      irev ++;
#line 2401
      set_addelem(lp->equalityset, i);
#line 2403
      j = (ddf_colrange )2;
      }
      {
#line 2403
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2403
        if (! (j <= M->colsize + 1L)) {
#line 2403
          goto while_break___0;
        }
        {
#line 2404
        dddf_neg((double *)(*(*(lp->A + (irev - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 2L))));
#line 2403
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2406
      if (localdebug) {
        {
#line 2406
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"equality row %ld generates the reverse row %ld.\n",
                i, irev);
        }
      }
    }
#line 2408
    j = (ddf_colrange )2;
    {
#line 2408
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2408
      if (! (j <= M->colsize + 1L)) {
#line 2408
        goto while_break___1;
      }
      {
#line 2409
      dddf_set((double *)(*(*(lp->A + (i - 1L)) + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 2L))));
#line 2410
      dddf_add((double *)(*(*(lp->A + (m - 1L)) + (j - 1L))), (double *)(*(*(lp->A + (m - 1L)) + (j - 1L))),
               (double *)(*(*(lp->A + (i - 1L)) + (j - 1L))));
#line 2408
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2393
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2413
  j = (ddf_colrange )2;
  {
#line 2413
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2413
    if (! (j <= M->colsize + 1L)) {
#line 2413
      goto while_break___2;
    }
    {
#line 2414
    dddf_neg((double *)(*(*(lp->A + (m - 2L)) + (j - 1L))), (double *)(*(*(lp->A + (m - 1L)) + (j - 1L))));
#line 2413
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2417
  dddf_set((double *)(*(*(lp->A + (m - 2L)) + 0)), (double *)(ddf_one));
  }
#line 2419
  if (localdebug) {
    {
#line 2419
    ddf_WriteLP(stdout, lp);
    }
  }
#line 2421
  return (lp);
}
}
#line 2424 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_boolean ddf_Redundant(ddf_MatrixPtr M , ddf_rowrange itest , ddf_Arow certificate ,
                          ddf_ErrorType *error ) 
{ 
  ddf_colrange j ;
  ddf_LPPtr lp ;
  ddf_LPSolutionPtr lps ;
  ddf_ErrorType err ;
  ddf_boolean answer ;
  ddf_boolean localdebug ;
  int tmp ;
  ddf_boolean tmp___0 ;

  {
  {
#line 2459
  err = (ddf_ErrorType )17;
#line 2460
  answer = 0;
#line 2460
  localdebug = 0;
#line 2462
  *error = (ddf_ErrorType )17;
#line 2463
  tmp = set_member(itest, M->linset);
  }
#line 2463
  if (tmp) {
#line 2464
    if (localdebug) {
      {
#line 2464
      printf((char const   */* __restrict  */)"The %ld th row is linearity and redundancy checking is skipped.\n",
             itest);
      }
    }
#line 2465
    goto _L99;
  }
#line 2469
  if ((unsigned int )M->representation == 2U) {
    {
#line 2470
    lp = ddf_CreateLP_V_Redundancy(M, itest);
    }
  } else {
    {
#line 2472
    lp = ddf_CreateLP_H_Redundancy(M, itest);
    }
  }
  {
#line 2475
  ddf_LPSolve(lp, ddf_choiceRedcheckAlgorithm, & err);
  }
#line 2476
  if ((unsigned int )err != 17U) {
#line 2477
    *error = err;
#line 2478
    goto _L999;
  } else {
    {
#line 2480
    lps = ddf_CopyLPSolution(lp);
#line 2482
    j = (ddf_colrange )0;
    }
    {
#line 2482
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2482
      if (! (j < lps->d)) {
#line 2482
        goto while_break;
      }
      {
#line 2483
      dddf_set((double *)(*(certificate + j)), (double *)(*(lps->sol + j)));
#line 2482
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2486
    tmp___0 = ddf_Negative((double *)(lps->optvalue));
    }
#line 2486
    if (tmp___0) {
#line 2487
      answer = 0;
#line 2488
      if (localdebug) {
        {
#line 2488
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th row is nonredundant.\n",
                itest);
        }
      }
    } else {
#line 2490
      answer = 1;
#line 2491
      if (localdebug) {
        {
#line 2491
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th row is redundant.\n",
                itest);
        }
      }
    }
    {
#line 2493
    ddf_FreeLPSolution(lps);
    }
  }
  _L999: 
  {
#line 2496
  ddf_FreeLPData(lp);
  }
  _L99: 
#line 2498
  return (answer);
}
}
#line 2501 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_boolean ddf_RedundantExtensive(ddf_MatrixPtr M , ddf_rowrange itest , ddf_Arow certificate ,
                                   ddf_rowset *redset , ddf_ErrorType *error ) 
{ 
  ddf_colrange j ;
  ddf_LPPtr lp ;
  ddf_LPSolutionPtr lps ;
  ddf_ErrorType err ;
  ddf_boolean answer ;
  ddf_boolean localdebug ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  ddf_boolean tmp___2 ;

  {
  {
#line 2515
  err = (ddf_ErrorType )17;
#line 2516
  answer = 0;
#line 2516
  localdebug = 0;
#line 2518
  *error = (ddf_ErrorType )17;
#line 2519
  tmp = set_member(itest, M->linset);
  }
#line 2519
  if (tmp) {
#line 2520
    if (localdebug) {
      {
#line 2520
      printf((char const   */* __restrict  */)"The %ld th row is linearity and redundancy checking is skipped.\n",
             itest);
      }
    }
#line 2521
    goto _L99;
  }
#line 2525
  if ((unsigned int )M->representation == 2U) {
    {
#line 2526
    lp = ddf_CreateLP_V_Redundancy(M, itest);
    }
  } else {
    {
#line 2528
    lp = ddf_CreateLP_H_Redundancy(M, itest);
    }
  }
  {
#line 2531
  lp->redcheck_extensive = 1;
#line 2533
  ddf_LPSolve0(lp, (ddf_LPSolverType )1, & err);
  }
#line 2534
  if ((unsigned int )err != 17U) {
#line 2535
    *error = err;
#line 2536
    goto _L999;
  } else {
    {
#line 2538
    set_copy(*redset, lp->redset_extra);
#line 2539
    set_delelem(*redset, itest);
    }
#line 2542
    if (localdebug) {
      {
#line 2543
      tmp___0 = set_card(lp->redset_extra);
#line 2543
      tmp___1 = set_card(*redset);
#line 2543
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_RedundantExtensive: checking for %ld, extra redset with cardinality %ld (%ld)\n",
              itest, tmp___1, tmp___0);
#line 2544
      set_fwrite(stderr, *redset);
#line 2544
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
    {
#line 2546
    lps = ddf_CopyLPSolution(lp);
#line 2548
    j = (ddf_colrange )0;
    }
    {
#line 2548
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2548
      if (! (j < lps->d)) {
#line 2548
        goto while_break;
      }
      {
#line 2549
      dddf_set((double *)(*(certificate + j)), (double *)(*(lps->sol + j)));
#line 2548
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2552
    tmp___2 = ddf_Negative((double *)(lps->optvalue));
    }
#line 2552
    if (tmp___2) {
#line 2553
      answer = 0;
#line 2554
      if (localdebug) {
        {
#line 2554
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th row is nonredundant.\n",
                itest);
        }
      }
    } else {
#line 2556
      answer = 1;
#line 2557
      if (localdebug) {
        {
#line 2557
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th row is redundant.\n",
                itest);
        }
      }
    }
    {
#line 2559
    ddf_FreeLPSolution(lps);
    }
  }
  _L999: 
  {
#line 2562
  ddf_FreeLPData(lp);
  }
  _L99: 
#line 2564
  return (answer);
}
}
#line 2567 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_rowset ddf_RedundantRows(ddf_MatrixPtr M , ddf_ErrorType *error ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange m ;
  ddf_colrange d ;
  ddf_rowset redset ;
  ddf_MatrixPtr Mcopy ;
  ddf_Arow cvec ;
  ddf_boolean localdebug ;
  ddf_boolean tmp ;

  {
#line 2574
  localdebug = 0;
#line 2576
  m = M->rowsize;
#line 2577
  if ((unsigned int )M->representation == 2U) {
#line 2578
    d = M->colsize + 1L;
  } else {
#line 2580
    d = M->colsize;
  }
  {
#line 2582
  Mcopy = ddf_MatrixCopy(M);
#line 2583
  ddf_InitializeArow(d, & cvec);
#line 2584
  set_initialize(& redset, m);
#line 2585
  i = m;
  }
  {
#line 2585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2585
    if (! (i >= 1L)) {
#line 2585
      goto while_break;
    }
    {
#line 2586
    tmp = ddf_Redundant(Mcopy, i, cvec, error);
    }
#line 2586
    if (tmp) {
#line 2587
      if (localdebug) {
        {
#line 2587
        printf((char const   */* __restrict  */)"ddf_RedundantRows: the row %ld is redundant.\n",
               i);
        }
      }
      {
#line 2588
      set_addelem(redset, i);
#line 2589
      ddf_MatrixRowRemove(& Mcopy, i);
      }
    } else
#line 2591
    if (localdebug) {
      {
#line 2591
      printf((char const   */* __restrict  */)"ddf_RedundantRows: the row %ld is essential.\n",
             i);
      }
    }
#line 2593
    if ((unsigned int )*error != 17U) {
#line 2593
      goto _L99;
    }
#line 2585
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: 
  {
#line 2596
  ddf_FreeMatrix(Mcopy);
#line 2597
  ddf_FreeArow(d, cvec);
  }
#line 2598
  return (redset);
}
}
#line 2602 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_boolean ddf_MatrixRedundancyRemove(ddf_MatrixPtr *M , ddf_rowset *redset , ddf_rowindex *newpos ,
                                       ddf_ErrorType *error ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange k ;
  ddf_rowrange m ;
  ddf_rowrange m1 ;
  ddf_colrange d ;
  ddf_rowset redset1 ;
  ddf_rowindex newpos1 ;
  ddf_MatrixPtr M1 ;
  ddf_Arow cvec ;
  ddf_boolean success ;
  ddf_boolean localdebug ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  ddf_boolean tmp___2 ;

  {
  {
#line 2613
  M1 = (ddf_MatrixPtr )((void *)0);
#line 2615
  success = 0;
#line 2615
  localdebug = 0;
#line 2617
  m = (*M)->rowsize;
#line 2618
  set_initialize(redset, m);
#line 2619
  M1 = ddf_MatrixSortedUniqueCopy(*M, newpos);
#line 2620
  i = (ddf_rowrange )1;
  }
  {
#line 2620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2620
    if (! (i <= m)) {
#line 2620
      goto while_break;
    }
#line 2621
    if (*(*newpos + i) <= 0L) {
      {
#line 2621
      set_addelem(*redset, i);
      }
    }
#line 2622
    if (localdebug) {
      {
#line 2622
      printf((char const   */* __restrict  */)" %ld:%ld", i, *(*newpos + i));
      }
    }
#line 2620
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2624
  if (localdebug) {
    {
#line 2624
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 2626
  if ((unsigned int )(*M)->representation == 2U) {
#line 2627
    d = (*M)->colsize + 1L;
  } else {
#line 2629
    d = (*M)->colsize;
  }
#line 2631
  m1 = M1->rowsize;
#line 2632
  if (localdebug) {
    {
#line 2633
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ddf_MatrixRedundancyRemove: By sorting, %ld rows have been removed.  The remaining has %ld rows.\n",
            m - m1, m1);
    }
  }
  {
#line 2636
  ddf_InitializeArow(d, & cvec);
#line 2637
  set_initialize(& redset1, M1->rowsize);
#line 2638
  k = (ddf_rowrange )1;
  }
  {
#line 2639
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2640
    tmp___2 = ddf_RedundantExtensive(M1, k, cvec, & redset1, error);
    }
#line 2640
    if (tmp___2) {
      {
#line 2641
      set_addelem(redset1, k);
#line 2642
      ddf_MatrixRowsRemove2(& M1, redset1, & newpos1);
#line 2643
      i = (ddf_rowrange )1;
      }
      {
#line 2643
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2643
        if (! (i <= m)) {
#line 2643
          goto while_break___1;
        }
#line 2644
        if (*(*newpos + i) > 0L) {
          {
#line 2645
          tmp = set_member(*(*newpos + i), redset1);
          }
#line 2645
          if (tmp) {
            {
#line 2646
            set_addelem(*redset, i);
#line 2647
            *(*newpos + i) = 0L;
            }
          } else {
#line 2649
            *(*newpos + i) = *(newpos1 + *(*newpos + i));
          }
        }
#line 2643
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 2653
      set_free(redset1);
#line 2654
      set_initialize(& redset1, M1->rowsize);
      }
#line 2655
      if (localdebug) {
        {
#line 2656
        printf((char const   */* __restrict  */)"ddf_MatrixRedundancyRemove: the row %ld is redundant. The new matrix has %ld rows.\n",
               k, M1->rowsize);
        }
      }
      {
#line 2659
      free((void *)newpos1);
      }
    } else {
      {
#line 2661
      tmp___1 = set_card(redset1);
      }
#line 2661
      if (tmp___1 > 0L) {
        {
#line 2662
        ddf_MatrixRowsRemove2(& M1, redset1, & newpos1);
#line 2663
        i = (ddf_rowrange )1;
        }
        {
#line 2663
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2663
          if (! (i <= m)) {
#line 2663
            goto while_break___2;
          }
#line 2664
          if (*(*newpos + i) > 0L) {
            {
#line 2665
            tmp___0 = set_member(*(*newpos + i), redset1);
            }
#line 2665
            if (tmp___0) {
              {
#line 2666
              set_addelem(*redset, i);
#line 2667
              *(*newpos + i) = 0L;
              }
            } else {
#line 2669
              *(*newpos + i) = *(newpos1 + *(*newpos + i));
            }
          }
#line 2663
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 2673
        set_free(redset1);
#line 2674
        set_initialize(& redset1, M1->rowsize);
#line 2675
        free((void *)newpos1);
        }
      }
#line 2677
      if (localdebug) {
        {
#line 2678
        printf((char const   */* __restrict  */)"ddf_MatrixRedundancyRemove: the row %ld is essential. The new matrix has %ld rows.\n",
               k, M1->rowsize);
        }
      }
#line 2681
      k ++;
    }
#line 2683
    if ((unsigned int )*error != 17U) {
#line 2683
      goto _L99;
    }
#line 2639
    if (! (k <= M1->rowsize)) {
#line 2639
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2685
  if (localdebug) {
    {
#line 2685
    ddf_WriteMatrix(stderr, M1);
    }
  }
#line 2686
  success = 1;
  _L99: 
  {
#line 2689
  ddf_FreeMatrix(*M);
#line 2690
  *M = M1;
#line 2691
  ddf_FreeArow(d, cvec);
#line 2692
  set_free(redset1);
  }
#line 2693
  return (success);
}
}
#line 2697 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_boolean ddf_SRedundant(ddf_MatrixPtr M , ddf_rowrange itest , ddf_Arow certificate ,
                           ddf_ErrorType *error ) 
{ 
  ddf_colrange j ;
  ddf_LPPtr lp ;
  ddf_LPSolutionPtr lps ;
  ddf_ErrorType err ;
  ddf_boolean answer ;
  ddf_boolean localdebug ;
  int tmp ;
  ddf_boolean tmp___0 ;
  ddf_boolean tmp___1 ;
  ddf_boolean tmp___2 ;

  {
  {
#line 2752
  err = (ddf_ErrorType )17;
#line 2753
  answer = 0;
#line 2753
  localdebug = 0;
#line 2755
  *error = (ddf_ErrorType )17;
#line 2756
  tmp = set_member(itest, M->linset);
  }
#line 2756
  if (tmp) {
#line 2757
    if (localdebug) {
      {
#line 2757
      printf((char const   */* __restrict  */)"The %ld th row is linearity and strong redundancy checking is skipped.\n",
             itest);
      }
    }
#line 2758
    goto _L99;
  }
#line 2762
  if ((unsigned int )M->representation == 2U) {
    {
#line 2763
    lp = ddf_CreateLP_V_Redundancy(M, itest);
    }
  } else {
    {
#line 2765
    lp = ddf_CreateLP_H_Redundancy(M, itest);
    }
  }
  {
#line 2768
  ddf_LPSolve(lp, ddf_choiceRedcheckAlgorithm, & err);
  }
#line 2769
  if ((unsigned int )err != 17U) {
#line 2770
    *error = err;
#line 2771
    goto _L999;
  } else {
    {
#line 2773
    lps = ddf_CopyLPSolution(lp);
#line 2775
    j = (ddf_colrange )0;
    }
    {
#line 2775
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2775
      if (! (j < lps->d)) {
#line 2775
        goto while_break;
      }
      {
#line 2776
      dddf_set((double *)(*(certificate + j)), (double *)(*(lps->sol + j)));
#line 2775
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2779
    if (localdebug) {
      {
#line 2780
      printf((char const   */* __restrict  */)"Optimum value:");
#line 2781
      ddf_WriteNumber(stdout, (double *)(lps->optvalue));
#line 2782
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 2785
    if ((unsigned int )M->representation == 1U) {
      {
#line 2786
      tmp___0 = ddf_Positive((double *)(lps->optvalue));
      }
#line 2786
      if (tmp___0) {
#line 2787
        answer = 1;
#line 2788
        if (localdebug) {
          {
#line 2788
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th inequality is strongly redundant.\n",
                  itest);
          }
        }
      } else {
#line 2790
        answer = 0;
#line 2791
        if (localdebug) {
          {
#line 2791
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th inequality is not strongly redundant.\n",
                  itest);
          }
        }
      }
    } else {
      {
#line 2794
      tmp___2 = ddf_Negative((double *)(lps->optvalue));
      }
#line 2794
      if (tmp___2) {
#line 2795
        answer = 0;
#line 2796
        if (localdebug) {
          {
#line 2796
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th point is not strongly redundant.\n",
                  itest);
          }
        }
      } else {
        {
#line 2799
        ddf_FreeLPData(lp);
#line 2800
        ddf_FreeLPSolution(lps);
#line 2801
        lp = ddf_CreateLP_V_SRedundancy(M, itest);
#line 2802
        ddf_LPSolve(lp, (ddf_LPSolverType )1, & err);
#line 2803
        lps = ddf_CopyLPSolution(lp);
        }
#line 2804
        if (localdebug) {
          {
#line 2804
          ddf_WriteLPResult(stdout, lp, err);
          }
        }
        {
#line 2805
        tmp___1 = ddf_Positive((double *)(lps->optvalue));
        }
#line 2805
        if (tmp___1) {
#line 2806
          answer = 0;
#line 2807
          if (localdebug) {
            {
#line 2807
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th point is not strongly redundant.\n",
                    itest);
            }
          }
        } else {
#line 2809
          answer = 1;
#line 2810
          if (localdebug) {
            {
#line 2810
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th point is strongly redundant.\n",
                    itest);
            }
          }
        }
      }
    }
    {
#line 2814
    ddf_FreeLPSolution(lps);
    }
  }
  _L999: 
  {
#line 2817
  ddf_FreeLPData(lp);
  }
  _L99: 
#line 2819
  return (answer);
}
}
#line 2822 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_rowset ddf_SRedundantRows(ddf_MatrixPtr M , ddf_ErrorType *error ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange m ;
  ddf_colrange d ;
  ddf_rowset redset ;
  ddf_MatrixPtr Mcopy ;
  ddf_Arow cvec ;
  ddf_boolean localdebug ;
  ddf_boolean tmp ;

  {
#line 2829
  localdebug = 0;
#line 2831
  m = M->rowsize;
#line 2832
  if ((unsigned int )M->representation == 2U) {
#line 2833
    d = M->colsize + 1L;
  } else {
#line 2835
    d = M->colsize;
  }
  {
#line 2837
  Mcopy = ddf_MatrixCopy(M);
#line 2838
  ddf_InitializeArow(d, & cvec);
#line 2839
  set_initialize(& redset, m);
#line 2840
  i = m;
  }
  {
#line 2840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2840
    if (! (i >= 1L)) {
#line 2840
      goto while_break;
    }
    {
#line 2841
    tmp = ddf_SRedundant(Mcopy, i, cvec, error);
    }
#line 2841
    if (tmp) {
#line 2842
      if (localdebug) {
        {
#line 2842
        printf((char const   */* __restrict  */)"ddf_SRedundantRows: the row %ld is strongly redundant.\n",
               i);
        }
      }
      {
#line 2843
      set_addelem(redset, i);
#line 2844
      ddf_MatrixRowRemove(& Mcopy, i);
      }
    } else
#line 2846
    if (localdebug) {
      {
#line 2846
      printf((char const   */* __restrict  */)"ddf_SRedundantRows: the row %ld is not strongly redundant.\n",
             i);
      }
    }
#line 2848
    if ((unsigned int )*error != 17U) {
#line 2848
      goto _L99;
    }
#line 2840
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: 
  {
#line 2851
  ddf_FreeMatrix(Mcopy);
#line 2852
  ddf_FreeArow(d, cvec);
  }
#line 2853
  return (redset);
}
}
#line 2856 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_rowset ddf_RedundantRowsViaShooting(ddf_MatrixPtr M , ddf_ErrorType *error ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange m ;
  ddf_rowrange ired ;
  ddf_rowrange irow ;
  ddf_colrange j ;
  ddf_colrange k ;
  ddf_colrange d ;
  ddf_rowset redset ;
  ddf_rowindex rowflag ;
  ddf_MatrixPtr M1 ;
  ddf_Arow shootdir ;
  ddf_Arow cvec ;
  ddf_LPPtr lp0 ;
  ddf_LPPtr lp ;
  ddf_LPSolutionPtr lps ;
  ddf_ErrorType err ;
  ddf_LPSolverType solver ;
  ddf_boolean localdebug ;
  void *tmp ;
  ddf_boolean tmp___0 ;
  ddf_boolean tmp___1 ;

  {
  {
#line 2864
  irow = (ddf_rowrange )0;
#line 2873
  cvec = (ddf_Arow )((void *)0);
#line 2877
  solver = (ddf_LPSolverType )1;
#line 2878
  localdebug = 0;
#line 2880
  m = M->rowsize;
#line 2881
  d = M->colsize;
#line 2882
  M1 = ddf_CreateMatrix(m, d);
#line 2883
  M1->rowsize = (ddf_rowrange )0;
#line 2884
  set_initialize(& redset, m);
#line 2885
  ddf_InitializeArow(d, & shootdir);
#line 2886
  ddf_InitializeArow(d, & cvec);
#line 2888
  tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 2888
  rowflag = (long *)tmp;
#line 2891
  lp0 = ddf_Matrix2LP(M, & err);
#line 2892
  lp = ddf_MakeLPforInteriorFinding(lp0);
#line 2893
  ddf_FreeLPData(lp0);
#line 2894
  ddf_LPSolve(lp, solver, & err);
#line 2895
  lps = ddf_CopyLPSolution(lp);
#line 2897
  tmp___1 = ddf_Positive((double *)(lps->optvalue));
  }
#line 2897
  if (tmp___1) {
#line 2900
    j = (ddf_colrange )1;
    {
#line 2900
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2900
      if (! (j < d)) {
#line 2900
        goto while_break;
      }
#line 2901
      k = (ddf_colrange )1;
      {
#line 2901
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2901
        if (! (k <= d)) {
#line 2901
          goto while_break___0;
        }
        {
#line 2901
        dddf_set((double *)(*(shootdir + (k - 1L))), (double *)(ddf_purezero));
#line 2901
        k ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2902
      dddf_set((double *)(*(shootdir + j)), (double *)(ddf_one));
#line 2903
      ired = ddf_RayShooting(M, lps->sol, shootdir);
      }
#line 2904
      if (localdebug) {
        {
#line 2904
        printf((char const   */* __restrict  */)"nonredundant row %3ld found by shooting.\n",
               ired);
        }
      }
#line 2905
      if (ired > 0L) {
#line 2905
        if (*(rowflag + ired) <= 0L) {
#line 2906
          irow ++;
#line 2907
          *(rowflag + ired) = irow;
#line 2908
          k = (ddf_colrange )1;
          {
#line 2908
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2908
            if (! (k <= d)) {
#line 2908
              goto while_break___1;
            }
            {
#line 2908
            dddf_set((double *)(*(*(M1->matrix + (irow - 1L)) + (k - 1L))), (double *)(*(*(M->matrix + (ired - 1L)) + (k - 1L))));
#line 2908
            k ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
      {
#line 2911
      dddf_neg((double *)(*(shootdir + j)), (double *)(ddf_one));
#line 2912
      ired = ddf_RayShooting(M, lps->sol, shootdir);
      }
#line 2913
      if (localdebug) {
        {
#line 2913
        printf((char const   */* __restrict  */)"nonredundant row %3ld found by shooting.\n",
               ired);
        }
      }
#line 2914
      if (ired > 0L) {
#line 2914
        if (*(rowflag + ired) <= 0L) {
#line 2915
          irow ++;
#line 2916
          *(rowflag + ired) = irow;
#line 2917
          k = (ddf_colrange )1;
          {
#line 2917
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2917
            if (! (k <= d)) {
#line 2917
              goto while_break___2;
            }
            {
#line 2917
            dddf_set((double *)(*(*(M1->matrix + (irow - 1L)) + (k - 1L))), (double *)(*(*(M->matrix + (ired - 1L)) + (k - 1L))));
#line 2917
            k ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 2900
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2921
    M1->rowsize = irow;
#line 2922
    if (localdebug) {
      {
#line 2923
      printf((char const   */* __restrict  */)"The initial nonredundant set is:");
#line 2924
      i = (ddf_rowrange )1;
      }
      {
#line 2924
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2924
        if (! (i <= m)) {
#line 2924
          goto while_break___3;
        }
#line 2924
        if (*(rowflag + i) > 0L) {
          {
#line 2924
          printf((char const   */* __restrict  */)" %ld", i);
          }
        }
#line 2924
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 2925
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 2928
    i = (ddf_rowrange )1;
    {
#line 2929
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2929
      if (! (i <= m)) {
#line 2929
        goto while_break___4;
      }
#line 2930
      if (*(rowflag + i) == 0L) {
#line 2931
        if (localdebug) {
          {
#line 2931
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Checking redundancy of %ld th inequality\n",
                  i);
          }
        }
#line 2932
        irow ++;
#line 2932
        M1->rowsize = irow;
#line 2933
        k = (ddf_colrange )1;
        {
#line 2933
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2933
          if (! (k <= d)) {
#line 2933
            goto while_break___5;
          }
          {
#line 2933
          dddf_set((double *)(*(*(M1->matrix + (irow - 1L)) + (k - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (k - 1L))));
#line 2933
          k ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 2934
        tmp___0 = ddf_Redundant(M1, irow, cvec, & err);
        }
#line 2934
        if (tmp___0) {
#line 2944
          if (localdebug) {
            {
#line 2944
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The %ld th inequality is redundant for the subsystem and thus for the whole.\n",
                    i);
            }
          }
          {
#line 2945
          *(rowflag + i) = -1L;
#line 2946
          set_addelem(redset, i);
#line 2947
          i ++;
          }
        } else {
#line 2935
          k = (ddf_colrange )1;
          {
#line 2935
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2935
            if (! (k <= d)) {
#line 2935
              goto while_break___6;
            }
            {
#line 2935
            dddf_sub((double *)(*(shootdir + (k - 1L))), (double *)(*(cvec + (k - 1L))),
                     (double *)(*(lps->sol + (k - 1L))));
#line 2935
            k ++;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 2936
          ired = ddf_RayShooting(M, lps->sol, shootdir);
#line 2937
          *(rowflag + ired) = irow;
#line 2938
          k = (ddf_colrange )1;
          }
          {
#line 2938
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 2938
            if (! (k <= d)) {
#line 2938
              goto while_break___7;
            }
            {
#line 2938
            dddf_set((double *)(*(*(M1->matrix + (irow - 1L)) + (k - 1L))), (double *)(*(*(M->matrix + (ired - 1L)) + (k - 1L))));
#line 2938
            k ++;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 2939
          if (localdebug) {
            {
#line 2940
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The %ld th inequality is nonredundant for the subsystem\n",
                    i);
#line 2941
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The nonredundancy of %ld th inequality is found by shooting.\n",
                    ired);
            }
          }
        }
      } else {
#line 2950
        i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
    {
#line 2955
    redset = ddf_RedundantRows(M, error);
    }
  }
  {
#line 2958
  ddf_FreeLPData(lp);
#line 2959
  ddf_FreeLPSolution(lps);
#line 2961
  M1->rowsize = m;
#line 2961
  M1->colsize = d;
#line 2962
  ddf_FreeMatrix(M1);
#line 2963
  ddf_FreeArow(d, shootdir);
#line 2964
  ddf_FreeArow(d, cvec);
#line 2965
  free((void *)rowflag);
  }
#line 2966
  return (redset);
}
}
#line 2969 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_SetFamilyPtr ddf_Matrix2Adjacency(ddf_MatrixPtr M , ddf_ErrorType *error ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange m ;
  ddf_colrange d ;
  ddf_rowset redset ;
  ddf_MatrixPtr Mcopy ;
  ddf_SetFamilyPtr F ;
  int tmp ;

  {
#line 2979
  F = (ddf_SetFamilyPtr )((void *)0);
#line 2981
  m = M->rowsize;
#line 2982
  d = M->colsize;
#line 2983
  if (m <= 0L) {
#line 2984
    *error = (ddf_ErrorType )5;
#line 2985
    goto _L999;
  } else
#line 2983
  if (d <= 0L) {
#line 2984
    *error = (ddf_ErrorType )5;
#line 2985
    goto _L999;
  }
  {
#line 2987
  Mcopy = ddf_MatrixCopy(M);
#line 2988
  F = ddf_CreateSetFamily(m, m);
#line 2989
  i = (ddf_rowrange )1;
  }
  {
#line 2989
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2989
    if (! (i <= m)) {
#line 2989
      goto while_break;
    }
    {
#line 2990
    tmp = set_member(i, M->linset);
    }
#line 2990
    if (! tmp) {
      {
#line 2991
      set_addelem(Mcopy->linset, i);
#line 2992
      redset = ddf_RedundantRows(Mcopy, error);
#line 2993
      set_uni(redset, redset, Mcopy->linset);
#line 2994
      set_compl(*(F->set + (i - 1L)), redset);
#line 2995
      set_delelem(Mcopy->linset, i);
#line 2996
      set_free(redset);
      }
#line 2997
      if ((unsigned int )*error != 17U) {
#line 2997
        goto _L99;
      }
    }
#line 2989
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: 
  {
#line 3001
  ddf_FreeMatrix(Mcopy);
  }
  _L999: 
#line 3003
  return (F);
}
}
#line 3006 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_SetFamilyPtr ddf_Matrix2WeakAdjacency(ddf_MatrixPtr M , ddf_ErrorType *error ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange m ;
  ddf_colrange d ;
  ddf_rowset redset ;
  ddf_MatrixPtr Mcopy ;
  ddf_SetFamilyPtr F ;
  int tmp ;

  {
#line 3016
  F = (ddf_SetFamilyPtr )((void *)0);
#line 3018
  m = M->rowsize;
#line 3019
  d = M->colsize;
#line 3020
  if (m <= 0L) {
#line 3021
    *error = (ddf_ErrorType )5;
#line 3022
    goto _L999;
  } else
#line 3020
  if (d <= 0L) {
#line 3021
    *error = (ddf_ErrorType )5;
#line 3022
    goto _L999;
  }
  {
#line 3024
  Mcopy = ddf_MatrixCopy(M);
#line 3025
  F = ddf_CreateSetFamily(m, m);
#line 3026
  i = (ddf_rowrange )1;
  }
  {
#line 3026
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3026
    if (! (i <= m)) {
#line 3026
      goto while_break;
    }
    {
#line 3027
    tmp = set_member(i, M->linset);
    }
#line 3027
    if (! tmp) {
      {
#line 3028
      set_addelem(Mcopy->linset, i);
#line 3029
      redset = ddf_SRedundantRows(Mcopy, error);
#line 3030
      set_uni(redset, redset, Mcopy->linset);
#line 3031
      set_compl(*(F->set + (i - 1L)), redset);
#line 3032
      set_delelem(Mcopy->linset, i);
#line 3033
      set_free(redset);
      }
#line 3034
      if ((unsigned int )*error != 17U) {
#line 3034
        goto _L99;
      }
    }
#line 3026
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: 
  {
#line 3038
  ddf_FreeMatrix(Mcopy);
  }
  _L999: 
#line 3040
  return (F);
}
}
#line 3044 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_boolean ddf_ImplicitLinearity(ddf_MatrixPtr M , ddf_rowrange itest , ddf_Arow certificate ,
                                  ddf_ErrorType *error ) 
{ 
  ddf_colrange j ;
  ddf_LPPtr lp ;
  ddf_LPSolutionPtr lps ;
  ddf_ErrorType err ;
  ddf_boolean answer ;
  ddf_boolean localdebug ;
  int tmp ;
  ddf_boolean tmp___0 ;

  {
  {
#line 3080
  err = (ddf_ErrorType )17;
#line 3081
  answer = 0;
#line 3081
  localdebug = 0;
#line 3083
  *error = (ddf_ErrorType )17;
#line 3084
  tmp = set_member(itest, M->linset);
  }
#line 3084
  if (tmp) {
#line 3085
    if (localdebug) {
      {
#line 3085
      printf((char const   */* __restrict  */)"The %ld th row is linearity and redundancy checking is skipped.\n",
             itest);
      }
    }
#line 3086
    goto _L99;
  }
#line 3090
  if ((unsigned int )M->representation == 2U) {
    {
#line 3091
    lp = ddf_CreateLP_V_Redundancy(M, itest);
    }
  } else {
    {
#line 3093
    lp = ddf_CreateLP_H_Redundancy(M, itest);
    }
  }
  {
#line 3096
  lp->objective = (ddf_LPObjectiveType )1;
#line 3097
  ddf_LPSolve(lp, ddf_choiceRedcheckAlgorithm, & err);
  }
#line 3098
  if ((unsigned int )err != 17U) {
#line 3099
    *error = err;
#line 3100
    goto _L999;
  } else {
    {
#line 3102
    lps = ddf_CopyLPSolution(lp);
#line 3104
    j = (ddf_colrange )0;
    }
    {
#line 3104
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3104
      if (! (j < lps->d)) {
#line 3104
        goto while_break;
      }
      {
#line 3105
      dddf_set((double *)(*(certificate + j)), (double *)(*(lps->sol + j)));
#line 3104
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3108
    if ((unsigned int )lps->LPS == 1U) {
      {
#line 3108
      tmp___0 = ddf_EqualToZero((double *)(lps->optvalue));
      }
#line 3108
      if (tmp___0) {
#line 3109
        answer = 1;
#line 3110
        if (localdebug) {
          {
#line 3110
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th data is an implicit linearity.\n",
                  itest);
          }
        }
      } else {
#line 3108
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 3112
      answer = 0;
#line 3113
      if (localdebug) {
        {
#line 3113
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> %ld th data is not an implicit linearity.\n",
                itest);
        }
      }
    }
    {
#line 3115
    ddf_FreeLPSolution(lps);
    }
  }
  _L999: 
  {
#line 3118
  ddf_FreeLPData(lp);
  }
  _L99: 
#line 3120
  return (answer);
}
}
#line 3124 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
int ddf_FreeOfImplicitLinearity(ddf_MatrixPtr M , ddf_Arow certificate , ddf_rowset *imp_linrows ,
                                ddf_ErrorType *error ) 
{ 
  ddf_LPPtr lp ;
  ddf_rowrange i ;
  ddf_rowrange m ;
  ddf_colrange j ;
  ddf_colrange d1 ;
  ddf_ErrorType err ;
  ddf_Arow cvec ;
  int answer ;
  int localdebug ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;
  ddf_boolean tmp___1 ;
  int tmp___2 ;

  {
#line 3156
  err = (ddf_ErrorType )17;
#line 3159
  answer = 0;
#line 3159
  localdebug = 0;
#line 3161
  *error = (ddf_ErrorType )17;
#line 3163
  if ((unsigned int )M->representation == 2U) {
    {
#line 3164
    lp = ddf_CreateLP_V_ImplicitLinearity(M);
    }
  } else {
    {
#line 3166
    lp = ddf_CreateLP_H_ImplicitLinearity(M);
    }
  }
  {
#line 3169
  ddf_LPSolve(lp, ddf_choiceRedcheckAlgorithm, & err);
  }
#line 3170
  if ((unsigned int )err != 17U) {
#line 3171
    *error = err;
#line 3172
    goto _L999;
  } else {
#line 3175
    j = (ddf_colrange )0;
    {
#line 3175
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3175
      if (! (j < lp->d)) {
#line 3175
        goto while_break;
      }
      {
#line 3176
      dddf_set((double *)(*(certificate + j)), (double *)(*(lp->sol + j)));
#line 3175
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3179
    if (localdebug) {
      {
#line 3179
      ddf_WriteLPResult(stderr, lp, err);
      }
    }
#line 3182
    if (localdebug) {
      {
#line 3183
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> The following variables are not implicit linearity:\n");
#line 3184
      set_fwrite(stderr, lp->posset_extra);
#line 3185
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 3188
    if ((unsigned int )M->representation == 2U) {
#line 3189
      d1 = M->colsize + 1L;
    } else {
#line 3191
      d1 = M->colsize;
    }
    {
#line 3193
    m = M->rowsize;
#line 3194
    ddf_InitializeArow(d1, & cvec);
#line 3195
    set_initialize(imp_linrows, m);
    }
#line 3197
    if ((unsigned int )lp->LPS == 1U) {
      {
#line 3198
      tmp___0 = ddf_Positive((double *)(lp->optvalue));
      }
#line 3198
      if (tmp___0) {
#line 3199
        answer = 1;
#line 3200
        if (localdebug) {
          {
#line 3200
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> The matrix has no implicit linearity.\n");
          }
        }
      } else {
        {
#line 3201
        tmp = ddf_Negative((double *)(lp->optvalue));
        }
#line 3201
        if (tmp) {
#line 3202
          answer = -1;
#line 3203
          if (localdebug) {
            {
#line 3203
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> The matrix defines the trivial system.\n");
            }
          }
        } else {
#line 3205
          answer = 0;
#line 3206
          if (localdebug) {
            {
#line 3206
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> The matrix has some implicit linearity.\n");
            }
          }
        }
      }
    } else {
#line 3209
      answer = -2;
#line 3210
      if (localdebug) {
        {
#line 3210
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==> The LP fails.\n");
        }
      }
    }
#line 3212
    if (answer == 0) {
#line 3214
      i = m;
      {
#line 3214
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3214
        if (! (i >= 1L)) {
#line 3214
          goto while_break___0;
        }
        {
#line 3215
        tmp___2 = set_member(i, lp->posset_extra);
        }
#line 3215
        if (! tmp___2) {
          {
#line 3216
          tmp___1 = ddf_ImplicitLinearity(M, i, cvec, error);
          }
#line 3216
          if (tmp___1) {
            {
#line 3217
            set_addelem(*imp_linrows, i);
            }
#line 3218
            if (localdebug) {
              {
#line 3219
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" row %ld is implicit linearity\n",
                      i);
#line 3220
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
              }
            }
          }
#line 3223
          if ((unsigned int )*error != 17U) {
#line 3223
            goto _L999;
          }
        }
#line 3214
        i --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 3227
    if (answer == -1) {
#line 3228
      i = m;
      {
#line 3228
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3228
        if (! (i >= 1L)) {
#line 3228
          goto while_break___1;
        }
        {
#line 3228
        set_addelem(*imp_linrows, i);
#line 3228
        i --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 3231
    ddf_FreeArow(d1, cvec);
    }
  }
  _L999: 
  {
#line 3234
  ddf_FreeLPData(lp);
  }
#line 3236
  return (answer);
}
}
#line 3240 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_rowset ddf_ImplicitLinearityRows(ddf_MatrixPtr M , ddf_ErrorType *error ) 
{ 
  ddf_colrange d ;
  ddf_rowset imp_linset ;
  ddf_Arow cvec ;
  int foi ;
  ddf_boolean localdebug ;

  {
#line 3246
  localdebug = 0;
#line 3248
  if ((unsigned int )M->representation == 2U) {
#line 3249
    d = M->colsize + 2L;
  } else {
#line 3251
    d = M->colsize + 1L;
  }
  {
#line 3254
  ddf_InitializeArow(d, & cvec);
  }
#line 3255
  if (localdebug) {
    {
#line 3255
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\nddf_ImplicitLinearityRows: Check whether the system contains any implicit linearity.\n");
    }
  }
  {
#line 3256
  foi = ddf_FreeOfImplicitLinearity(M, cvec, & imp_linset, error);
  }
#line 3257
  if (localdebug) {
    {
#line 3259
    if (foi == 1) {
#line 3259
      goto case_1;
    }
#line 3263
    if (foi == 0) {
#line 3263
      goto case_0;
    }
#line 3267
    if (foi == -1) {
#line 3267
      goto case_neg_1;
    }
#line 3271
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 3260
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  It is free of implicit linearity.\n");
    }
#line 3261
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 3264
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  It is not free of implicit linearity.\n");
    }
#line 3265
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 3268
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  The input system is trivial (i.e. the empty H-polytope or the V-rep of the whole space.\n");
    }
#line 3269
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3272
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  The LP was not solved correctly.\n");
    }
#line 3273
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 3278
  if (localdebug) {
    {
#line 3279
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Implicit linearity rows are:\n");
#line 3280
    set_fwrite(stderr, imp_linset);
#line 3281
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 3283
  ddf_FreeArow(d, cvec);
  }
#line 3284
  return (imp_linset);
}
}
#line 3287 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_boolean ddf_MatrixCanonicalizeLinearity(ddf_MatrixPtr *M , ddf_rowset *impl_linset ,
                                            ddf_rowindex *newpos , ddf_ErrorType *error ) 
{ 
  ddf_rowrange rank ;
  ddf_rowset linrows ;
  ddf_rowset ignoredrows ;
  ddf_rowset basisrows ;
  ddf_colset ignoredcols ;
  ddf_colset basiscols ;
  ddf_rowrange i ;
  ddf_rowrange k ;
  ddf_rowrange m ;
  ddf_rowindex newpos1 ;
  ddf_boolean success ;

  {
  {
#line 3298
  success = 0;
#line 3300
  linrows = ddf_ImplicitLinearityRows(*M, error);
  }
#line 3301
  if ((unsigned int )*error != 17U) {
#line 3301
    goto _L99;
  }
  {
#line 3303
  m = (*M)->rowsize;
#line 3305
  set_uni((*M)->linset, (*M)->linset, linrows);
#line 3310
  set_initialize(& ignoredrows, (*M)->rowsize);
#line 3311
  set_initialize(& ignoredcols, (*M)->colsize);
#line 3312
  set_compl(ignoredrows, (*M)->linset);
#line 3313
  rank = ddf_MatrixRank(*M, ignoredrows, ignoredcols, & basisrows, & basiscols);
#line 3314
  set_diff(ignoredrows, (*M)->linset, basisrows);
#line 3315
  ddf_MatrixRowsRemove2(M, ignoredrows, newpos);
#line 3317
  ddf_MatrixShiftupLinearity(M, & newpos1);
#line 3319
  i = (ddf_rowrange )1;
  }
  {
#line 3319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3319
    if (! (i <= m)) {
#line 3319
      goto while_break;
    }
#line 3320
    k = *(*newpos + i);
#line 3321
    if (k > 0L) {
#line 3322
      *(*newpos + i) = *(newpos1 + k);
    }
#line 3319
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3326
  *impl_linset = linrows;
#line 3327
  success = 1;
#line 3328
  free((void *)newpos1);
#line 3329
  set_free(basisrows);
#line 3330
  set_free(basiscols);
#line 3331
  set_free(ignoredrows);
#line 3332
  set_free(ignoredcols);
  }
  _L99: 
#line 3334
  return (success);
}
}
#line 3337 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_boolean ddf_MatrixCanonicalize(ddf_MatrixPtr *M , ddf_rowset *impl_linset , ddf_rowset *redset ,
                                   ddf_rowindex *newpos , ddf_ErrorType *error ) 
{ 
  ddf_rowrange i ;
  ddf_rowrange k ;
  ddf_rowrange m ;
  ddf_rowindex newpos1 ;
  ddf_rowindex revpos ;
  ddf_rowset redset1 ;
  ddf_boolean success ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 3348
  success = 1;
#line 3350
  m = (*M)->rowsize;
#line 3351
  set_initialize(redset, m);
#line 3352
  tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 3352
  revpos = (long *)tmp;
#line 3354
  success = ddf_MatrixCanonicalizeLinearity(M, impl_linset, newpos, error);
  }
#line 3356
  if (! success) {
#line 3356
    goto _L99;
  }
#line 3358
  i = (ddf_rowrange )1;
  {
#line 3358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3358
    if (! (i <= m)) {
#line 3358
      goto while_break;
    }
#line 3359
    k = *(*newpos + i);
#line 3360
    if (k > 0L) {
#line 3360
      *(revpos + k) = i;
    }
#line 3358
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3363
  success = ddf_MatrixRedundancyRemove(M, & redset1, & newpos1, error);
  }
#line 3365
  if (! success) {
#line 3365
    goto _L99;
  }
#line 3367
  i = (ddf_rowrange )1;
  {
#line 3367
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3367
    if (! (i <= m)) {
#line 3367
      goto while_break___0;
    }
#line 3368
    k = *(*newpos + i);
#line 3369
    if (k > 0L) {
#line 3370
      *(*newpos + i) = *(newpos1 + k);
#line 3371
      if (*(newpos1 + k) < 0L) {
#line 3371
        *(*newpos + i) = - *(revpos + - *(newpos1 + k));
      }
      {
#line 3372
      tmp___0 = set_member(k, redset1);
      }
#line 3372
      if (tmp___0) {
        {
#line 3372
        set_addelem(*redset, i);
        }
      }
    }
#line 3367
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  _L99: 
  {
#line 3377
  set_free(redset1);
#line 3378
  free((void *)newpos1);
#line 3379
  free((void *)revpos);
  }
#line 3380
  return (success);
}
}
#line 3384 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_boolean ddf_ExistsRestrictedFace(ddf_MatrixPtr M , ddf_rowset R , ddf_rowset S ,
                                     ddf_ErrorType *err ) 
{ 
  ddf_boolean answer ;
  ddf_LPPtr lp ;
  ddf_boolean tmp ;

  {
  {
#line 3393
  answer = 0;
#line 3394
  lp = (ddf_LPPtr )((void *)0);
#line 3402
  lp = ddf_Matrix2Feasibility2(M, R, S, err);
  }
#line 3404
  if ((unsigned int )*err != 17U) {
#line 3404
    goto _L99;
  }
  {
#line 3407
  ddf_LPSolve(lp, (ddf_LPSolverType )1, err);
  }
#line 3408
  if ((unsigned int )*err != 17U) {
#line 3408
    goto _L99;
  }
#line 3409
  if ((unsigned int )lp->LPS == 1U) {
    {
#line 3409
    tmp = ddf_Positive((double *)(lp->optvalue));
    }
#line 3409
    if (tmp) {
#line 3410
      answer = 1;
    }
  }
  {
#line 3413
  ddf_FreeLPData(lp);
  }
  _L99: 
#line 3415
  return (answer);
}
}
#line 3418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_boolean ddf_ExistsRestrictedFace2(ddf_MatrixPtr M , ddf_rowset R , ddf_rowset S ,
                                      ddf_LPSolutionPtr *lps , ddf_ErrorType *err ) 
{ 
  ddf_boolean answer ;
  ddf_LPPtr lp ;
  ddf_boolean tmp ;

  {
  {
#line 3429
  answer = 0;
#line 3430
  lp = (ddf_LPPtr )((void *)0);
#line 3438
  lp = ddf_Matrix2Feasibility2(M, R, S, err);
  }
#line 3440
  if ((unsigned int )*err != 17U) {
#line 3440
    goto _L99;
  }
  {
#line 3443
  ddf_LPSolve(lp, (ddf_LPSolverType )1, err);
  }
#line 3444
  if ((unsigned int )*err != 17U) {
#line 3444
    goto _L99;
  }
#line 3445
  if ((unsigned int )lp->LPS == 1U) {
    {
#line 3445
    tmp = ddf_Positive((double *)(lp->optvalue));
    }
#line 3445
    if (tmp) {
#line 3446
      answer = 1;
    }
  }
  {
#line 3450
  *lps = ddf_CopyLPSolution(lp);
#line 3451
  ddf_FreeLPData(lp);
  }
  _L99: 
#line 3453
  return (answer);
}
}
#line 3456 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_boolean ddf_FindRelativeInterior(ddf_MatrixPtr M , ddf_rowset *ImL , ddf_rowset *Lbasis ,
                                     ddf_LPSolutionPtr *lps , ddf_ErrorType *err ) 
{ 
  ddf_rowset S ;
  ddf_colset T ;
  ddf_colset Lbasiscols ;
  ddf_boolean success ;
  ddf_rowrange i ;
  ddf_colrange rank ;
  int tmp ;
  int tmp___0 ;
  ddf_boolean tmp___1 ;

  {
  {
#line 3470
  success = 0;
#line 3475
  *ImL = ddf_ImplicitLinearityRows(M, err);
  }
#line 3477
  if ((unsigned int )*err != 17U) {
#line 3477
    goto _L99;
  }
  {
#line 3479
  set_initialize(& S, M->rowsize);
#line 3480
  i = (ddf_rowrange )1;
  }
  {
#line 3480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3480
    if (! (i <= M->rowsize)) {
#line 3480
      goto while_break;
    }
    {
#line 3481
    tmp = set_member(i, M->linset);
    }
#line 3481
    if (! tmp) {
      {
#line 3481
      tmp___0 = set_member(i, *ImL);
      }
#line 3481
      if (! tmp___0) {
        {
#line 3482
        set_addelem(S, i);
        }
      }
    }
#line 3480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3485
  tmp___1 = ddf_ExistsRestrictedFace2(M, *ImL, S, lps, err);
  }
#line 3485
  if (tmp___1) {
#line 3487
    success = 1;
  }
  {
#line 3490
  set_initialize(& T, M->colsize);
#line 3491
  rank = ddf_MatrixRank(M, S, T, Lbasis, & Lbasiscols);
#line 3493
  set_free(S);
#line 3494
  set_free(T);
#line 3495
  set_free(Lbasiscols);
  }
  _L99: 
#line 3498
  return (success);
}
}
#line 3502 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
ddf_rowrange ddf_RayShooting(ddf_MatrixPtr M , ddf_Arow p , ddf_Arow r ) 
{ 
  ddf_rowrange imin ;
  ddf_rowrange i ;
  ddf_rowrange m ;
  ddf_colrange j ;
  ddf_colrange d ;
  ddf_Arow vecmin ;
  ddf_Arow vec ;
  myfloat min ;
  myfloat t1 ;
  myfloat t2 ;
  myfloat alpha ;
  myfloat t1min ;
  ddf_boolean started ;
  ddf_boolean localdebug ;
  ddf_boolean tmp ;
  ddf_boolean tmp___0 ;
  ddf_boolean tmp___1 ;
  ddf_boolean tmp___2 ;
  ddf_boolean tmp___3 ;
  ddf_boolean tmp___4 ;

  {
  {
#line 3505
  imin = (ddf_rowrange )-1;
#line 3509
  started = 0;
#line 3510
  localdebug = 0;
#line 3512
  m = M->rowsize;
#line 3513
  d = M->colsize;
#line 3514
  tmp = ddf_Equal((double *)(ddf_one), (double *)(*(p + 0)));
  }
#line 3514
  if (! tmp) {
    {
#line 3515
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: RayShooting is called with a point with first coordinate not 1.\n");
#line 3516
    dddf_set((double *)(*(p + 0)), (double *)(ddf_one));
    }
  }
  {
#line 3518
  tmp___0 = ddf_EqualToZero((double *)(*(r + 0)));
  }
#line 3518
  if (! tmp___0) {
    {
#line 3519
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: RayShooting is called with a direction with first coordinate not 0.\n");
#line 3520
    dddf_set((double *)(*(r + 0)), (double *)(ddf_purezero));
    }
  }
  {
#line 3523
  dddf_init((double *)(alpha));
#line 3523
  dddf_init((double *)(min));
#line 3523
  dddf_init((double *)(t1));
#line 3523
  dddf_init((double *)(t2));
#line 3523
  dddf_init((double *)(t1min));
#line 3524
  ddf_InitializeArow(d, & vecmin);
#line 3525
  ddf_InitializeArow(d, & vec);
#line 3527
  i = (ddf_rowrange )1;
  }
  {
#line 3527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3527
    if (! (i <= m)) {
#line 3527
      goto while_break;
    }
    {
#line 3528
    ddf_InnerProduct((double *)(t1), d, *(M->matrix + (i - 1L)), p);
#line 3529
    tmp___4 = ddf_Positive((double *)(t1));
    }
#line 3529
    if (tmp___4) {
      {
#line 3530
      ddf_InnerProduct((double *)(t2), d, *(M->matrix + (i - 1L)), r);
#line 3531
      dddf_div((double *)(alpha), (double *)(t2), (double *)(t1));
      }
#line 3532
      if (! started) {
        {
#line 3533
        imin = i;
#line 3533
        dddf_set((double *)(min), (double *)(alpha));
#line 3534
        dddf_set((double *)(t1min), (double *)(t1));
#line 3535
        started = 1;
        }
#line 3536
        if (localdebug) {
          {
#line 3537
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Level 1: imin = %ld and min = ",
                  imin);
#line 3538
          ddf_WriteNumber(stderr, (double *)(min));
#line 3539
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
          }
        }
      } else {
        {
#line 3542
        tmp___3 = ddf_Smaller((double *)(alpha), (double *)(min));
        }
#line 3542
        if (tmp___3) {
          {
#line 3543
          imin = i;
#line 3543
          dddf_set((double *)(min), (double *)(alpha));
#line 3544
          dddf_set((double *)(t1min), (double *)(t1));
          }
#line 3545
          if (localdebug) {
            {
#line 3546
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Level 2: imin = %ld and min = ",
                    imin);
#line 3547
            ddf_WriteNumber(stderr, (double *)(min));
#line 3548
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
            }
          }
        } else {
          {
#line 3551
          tmp___2 = ddf_Equal((double *)(alpha), (double *)(min));
          }
#line 3551
          if (tmp___2) {
#line 3552
            j = (ddf_colrange )1;
            {
#line 3552
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 3552
              if (! (j <= d)) {
#line 3552
                goto while_break___0;
              }
              {
#line 3553
              dddf_div((double *)(*(vecmin + (j - 1L))), (double *)(*(*(M->matrix + (imin - 1L)) + (j - 1L))),
                       (double *)(t1min));
#line 3554
              dddf_div((double *)(*(vec + (j - 1L))), (double *)(*(*(M->matrix + (i - 1L)) + (j - 1L))),
                       (double *)(t1));
#line 3552
              j ++;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 3556
            tmp___1 = ddf_LexSmaller(vec, vecmin, d);
            }
#line 3556
            if (tmp___1) {
              {
#line 3557
              imin = i;
#line 3557
              dddf_set((double *)(min), (double *)(alpha));
#line 3558
              dddf_set((double *)(t1min), (double *)(t1));
              }
#line 3559
              if (localdebug) {
                {
#line 3560
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Level 3: imin = %ld and min = ",
                        imin);
#line 3561
                ddf_WriteNumber(stderr, (double *)(min));
#line 3562
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
                }
              }
            }
          }
        }
      }
    }
#line 3527
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3571
  dddf_clear((double *)(alpha));
#line 3571
  dddf_clear((double *)(min));
#line 3571
  dddf_clear((double *)(t1));
#line 3571
  dddf_clear((double *)(t2));
#line 3571
  dddf_clear((double *)(t1min));
#line 3572
  ddf_FreeArow(d, vecmin);
#line 3573
  ddf_FreeArow(d, vec);
  }
#line 3574
  return (imin);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
void dd_LinearComb(__mpq_struct *lc , __mpq_struct *v1 , __mpq_struct *c1 , __mpq_struct *v2 ,
                   __mpq_struct *c2 ) ;
#line 211
dd_MatrixPtr dd_FourierElimination(dd_MatrixPtr M , dd_ErrorType *error ) ;
#line 212
dd_MatrixPtr dd_BlockElimination(dd_MatrixPtr M , dd_colset delset , dd_ErrorType *error ) ;
#line 238
void dd_CopyArow(mytype *acopy , mytype *a___41 , dd_colrange d ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddproj.c"
dd_MatrixPtr dd_BlockElimination(dd_MatrixPtr M , dd_colset delset , dd_ErrorType *error ) 
{ 
  dd_MatrixPtr Mdual ;
  dd_MatrixPtr Mproj ;
  dd_MatrixPtr Gdual ;
  dd_rowrange i ;
  dd_rowrange h ;
  dd_rowrange m ;
  dd_rowrange mproj ;
  dd_rowrange mdual ;
  dd_rowrange linsize ;
  dd_colrange j ;
  dd_colrange k ;
  dd_colrange d ;
  dd_colrange dproj ;
  dd_colrange ddual ;
  dd_colrange delsize ;
  dd_colindex delindex ;
  mytype temp ;
  mytype prod ;
  dd_PolyhedraPtr dualpoly ;
  dd_ErrorType err ;
  dd_boolean localdebug ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 36
  Mdual = (dd_MatrixPtr )((void *)0);
#line 36
  Mproj = (dd_MatrixPtr )((void *)0);
#line 36
  Gdual = (dd_MatrixPtr )((void *)0);
#line 42
  err = (dd_ErrorType )17;
#line 43
  localdebug = 0;
#line 45
  *error = (dd_ErrorType )17;
#line 46
  m = M->rowsize;
#line 47
  d = M->colsize;
#line 48
  tmp = calloc((size_t )(d + 1L), sizeof(long ));
#line 48
  delindex = (long *)tmp;
#line 49
  __gmpq_init(temp);
#line 50
  __gmpq_init(prod);
#line 52
  k = (dd_colrange )0;
#line 52
  delsize = (dd_colrange )0;
#line 53
  j = (dd_colrange )1;
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (j <= d)) {
#line 53
      goto while_break;
    }
    {
#line 54
    tmp___0 = set_member(j, delset);
    }
#line 54
    if (tmp___0) {
#line 55
      k ++;
#line 55
      delsize ++;
#line 56
      *(delindex + k) = j;
    }
#line 53
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  if (localdebug) {
    {
#line 59
    dd_WriteMatrix(stdout, M);
    }
  }
  {
#line 61
  linsize = set_card(M->linset);
#line 62
  ddual = m + 1L;
#line 63
  mdual = (delsize + m) - linsize;
#line 66
  Mdual = dd_CreateMatrix(mdual, ddual);
#line 67
  Mdual->representation = (dd_RepresentationType )1;
#line 68
  i = (dd_rowrange )1;
  }
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! (i <= delsize)) {
#line 68
      goto while_break___0;
    }
    {
#line 69
    set_addelem(Mdual->linset, i);
#line 70
    j = (dd_colrange )1;
    }
    {
#line 70
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 70
      if (! (j <= m)) {
#line 70
        goto while_break___1;
      }
      {
#line 71
      __gmpq_set(*(*(Mdual->matrix + (i - 1L)) + j), (mpq_srcptr )(*(*(M->matrix + (j - 1L)) + (*(delindex + i) - 1L))));
#line 70
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 68
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 75
  k = (dd_colrange )0;
#line 76
  i = (dd_rowrange )1;
  {
#line 76
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 76
    if (! (i <= m)) {
#line 76
      goto while_break___2;
    }
    {
#line 77
    tmp___1 = set_member(i, M->linset);
    }
#line 77
    if (! tmp___1) {
      {
#line 80
      k ++;
#line 81
      __gmpq_set(*(*(Mdual->matrix + ((delsize + k) - 1L)) + i), (mpq_srcptr )(dd_one));
      }
    }
#line 76
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 86
  dualpoly = dd_DDMatrix2Poly(Mdual, & err);
#line 87
  Gdual = dd_CopyGenerators(dualpoly);
#line 90
  dproj = d - delsize;
#line 91
  mproj = Gdual->rowsize;
#line 92
  Mproj = dd_CreateMatrix(mproj, dproj);
#line 93
  Mproj->representation = (dd_RepresentationType )1;
#line 94
  set_copy(Mproj->linset, Gdual->linset);
#line 96
  i = (dd_rowrange )1;
  }
  {
#line 96
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 96
    if (! (i <= mproj)) {
#line 96
      goto while_break___3;
    }
#line 97
    k = (dd_colrange )0;
#line 98
    j = (dd_colrange )1;
    {
#line 98
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 98
      if (! (j <= d)) {
#line 98
        goto while_break___4;
      }
      {
#line 99
      tmp___2 = set_member(j, delset);
      }
#line 99
      if (! tmp___2) {
        {
#line 100
        k ++;
#line 101
        __gmpq_set(prod, (mpq_srcptr )(dd_purezero));
#line 102
        h = (dd_rowrange )1;
        }
        {
#line 102
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 102
          if (! (h <= m)) {
#line 102
            goto while_break___5;
          }
          {
#line 103
          __gmpq_mul(temp, (mpq_srcptr )(*(*(M->matrix + (h - 1L)) + (j - 1L))), (mpq_srcptr )(*(*(Gdual->matrix + (i - 1L)) + h)));
#line 104
          __gmpq_add(prod, (mpq_srcptr )(prod), (mpq_srcptr )(temp));
#line 102
          h ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 106
        __gmpq_set(*(*(Mproj->matrix + (i - 1L)) + (k - 1L)), (mpq_srcptr )(prod));
        }
      }
#line 98
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 96
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 110
  if (localdebug) {
    {
#line 110
    printf((char const   */* __restrict  */)"Size of the projection system: %ld x %ld\n",
           mproj, dproj);
    }
  }
  {
#line 112
  dd_FreePolyhedra(dualpoly);
#line 113
  free((void *)delindex);
#line 114
  __gmpq_clear(temp);
#line 115
  __gmpq_clear(prod);
#line 116
  dd_FreeMatrix(Mdual);
#line 117
  dd_FreeMatrix(Gdual);
  }
#line 118
  return (Mproj);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddproj.c"
dd_MatrixPtr dd_FourierElimination(dd_MatrixPtr M , dd_ErrorType *error ) 
{ 
  dd_MatrixPtr Mnew ;
  dd_rowrange i ;
  dd_rowrange inew ;
  dd_rowrange ip ;
  dd_rowrange in ;
  dd_rowrange iz ;
  dd_rowrange m ;
  dd_rowrange mpos ;
  dd_rowrange mneg ;
  dd_rowrange mzero ;
  dd_rowrange mnew ;
  dd_colrange j ;
  dd_colrange d ;
  dd_colrange dnew ;
  dd_rowindex posrowindex ;
  dd_rowindex negrowindex ;
  dd_rowindex zerorowindex ;
  mytype temp1 ;
  mytype temp2 ;
  dd_boolean localdebug ;
  long tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  dd_boolean tmp___3 ;
  dd_boolean tmp___4 ;

  {
#line 127
  Mnew = (dd_MatrixPtr )((void *)0);
#line 128
  mpos = (dd_rowrange )0;
#line 128
  mneg = (dd_rowrange )0;
#line 128
  mzero = (dd_rowrange )0;
#line 132
  localdebug = 0;
#line 134
  *error = (dd_ErrorType )17;
#line 135
  m = M->rowsize;
#line 136
  d = M->colsize;
#line 137
  if (d <= 1L) {
#line 138
    *error = (dd_ErrorType )14;
#line 139
    if (localdebug) {
      {
#line 140
      printf((char const   */* __restrict  */)"The number of column is too small: %ld for Fourier\'s Elimination.\n",
             d);
      }
    }
#line 142
    goto _L99;
  }
#line 145
  if ((unsigned int )M->representation == 2U) {
#line 146
    *error = (dd_ErrorType )11;
#line 147
    if (localdebug) {
      {
#line 148
      printf((char const   */* __restrict  */)"Fourier\'s Elimination cannot be applied to a V-polyhedron.\n");
      }
    }
#line 150
    goto _L99;
  }
  {
#line 153
  tmp = set_card(M->linset);
  }
#line 153
  if (tmp > 0L) {
#line 154
    *error = (dd_ErrorType )12;
#line 155
    if (localdebug) {
      {
#line 156
      printf((char const   */* __restrict  */)"The Fourier Elimination function does not handle equality in this version.\n");
      }
    }
#line 158
    goto _L99;
  }
  {
#line 162
  tmp___0 = calloc((size_t )(m + 1L), sizeof(long ));
#line 162
  posrowindex = (long *)tmp___0;
#line 163
  tmp___1 = calloc((size_t )(m + 1L), sizeof(long ));
#line 163
  negrowindex = (long *)tmp___1;
#line 164
  tmp___2 = calloc((size_t )(m + 1L), sizeof(long ));
#line 164
  zerorowindex = (long *)tmp___2;
#line 165
  __gmpq_init(temp1);
#line 166
  __gmpq_init(temp2);
#line 168
  i = (dd_rowrange )1;
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i <= m)) {
#line 168
      goto while_break;
    }
    {
#line 169
    tmp___4 = dd_Positive((__mpq_struct *)(*(*(M->matrix + (i - 1L)) + (d - 1L))));
    }
#line 169
    if (tmp___4) {
#line 170
      mpos ++;
#line 171
      *(posrowindex + mpos) = i;
    } else {
      {
#line 172
      tmp___3 = dd_Negative((__mpq_struct *)(*(*(M->matrix + (i - 1L)) + (d - 1L))));
      }
#line 172
      if (tmp___3) {
#line 173
        mneg ++;
#line 174
        *(negrowindex + mneg) = i;
      } else {
#line 176
        mzero ++;
#line 177
        *(zerorowindex + mzero) = i;
      }
    }
#line 168
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  if (localdebug) {
    {
#line 182
    dd_WriteMatrix(stdout, M);
#line 183
    printf((char const   */* __restrict  */)"No of  (+  -  0) rows = (%ld, %ld, %ld)\n",
           mpos, mneg, mzero);
    }
  }
  {
#line 189
  mnew = mzero + mpos * mneg;
#line 190
  dnew = d - 1L;
#line 192
  Mnew = dd_CreateMatrix(mnew, dnew);
#line 193
  dd_CopyArow(Mnew->rowvec, M->rowvec, dnew);
#line 195
  Mnew->numbtype = M->numbtype;
#line 196
  Mnew->representation = M->representation;
#line 197
  Mnew->objective = M->objective;
#line 201
  iz = (dd_rowrange )1;
  }
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (iz <= mzero)) {
#line 201
      goto while_break___0;
    }
#line 202
    j = (dd_colrange )1;
    {
#line 202
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 202
      if (! (j <= dnew)) {
#line 202
        goto while_break___1;
      }
      {
#line 203
      __gmpq_set(*(*(Mnew->matrix + (iz - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (*(zerorowindex + iz) - 1L)) + (j - 1L))));
#line 202
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 201
    iz ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 208
  inew = mzero;
#line 209
  ip = (dd_rowrange )1;
  {
#line 209
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 209
    if (! (ip <= mpos)) {
#line 209
      goto while_break___2;
    }
#line 210
    in = (dd_rowrange )1;
    {
#line 210
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 210
      if (! (in <= mneg)) {
#line 210
        goto while_break___3;
      }
      {
#line 211
      inew ++;
#line 212
      __gmpq_neg(temp1, (mpq_srcptr )(*(*(M->matrix + (*(negrowindex + in) - 1L)) + (d - 1L))));
#line 213
      j = (dd_colrange )1;
      }
      {
#line 213
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 213
        if (! (j <= dnew)) {
#line 213
          goto while_break___4;
        }
        {
#line 214
        dd_LinearComb((__mpq_struct *)(temp2), (__mpq_struct *)(*(*(M->matrix + (*(posrowindex + ip) - 1L)) + (j - 1L))),
                      (__mpq_struct *)(temp1), (__mpq_struct *)(*(*(M->matrix + (*(negrowindex + in) - 1L)) + (j - 1L))),
                      (__mpq_struct *)(*(*(M->matrix + (*(posrowindex + ip) - 1L)) + (d - 1L))));
#line 217
        __gmpq_set(*(*(Mnew->matrix + (inew - 1L)) + (j - 1L)), (mpq_srcptr )(temp2));
#line 213
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 219
      dd_Normalize(dnew, *(Mnew->matrix + (inew - 1L)));
#line 210
      in ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 209
    ip ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 224
  free((void *)posrowindex);
#line 225
  free((void *)negrowindex);
#line 226
  free((void *)zerorowindex);
#line 227
  __gmpq_clear(temp1);
#line 228
  __gmpq_clear(temp2);
  }
  _L99: 
#line 231
  return (Mnew);
}
}
#line 1141 "/usr/include/x86_64-linux-gnu/gmp.h"
extern int __gmpq_cmp(mpq_srcptr  , mpq_srcptr  )  __attribute__((__pure__)) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
void dd_abs(__mpq_struct *absval , __mpq_struct *val ) ;
#line 153
void dd_WriteArow(FILE *f , dd_Arow a___41 , dd_colrange d ) ;
#line 220
void dd_RandomPermutation(dd_rowindex OV , long t , unsigned int seed ) ;
#line 221
void dd_UniqueRows(dd_rowindex OV , long p , long r , dd_Amatrix A , long dmax , dd_rowset preferred ,
                   long *uniqrows ) ;
#line 226
void dd_FreeDDMemory0(dd_ConePtr cone ) ;
#line 233
void dd_AValue(mytype *val , dd_colrange d_size , dd_Amatrix A , mytype *p , dd_rowrange i ) ;
#line 234
void dd_CheckAdjacency(dd_ConePtr cone , dd_RayPtr *RP1 , dd_RayPtr *RP2 , dd_boolean *adjacent ) ;
#line 235
void dd_CheckEquality(dd_colrange d_size , dd_RayPtr *RP1 , dd_RayPtr *RP2 , dd_boolean *equal ) ;
#line 237
void dd_ConditionalAddEdge(dd_ConePtr cone , dd_RayPtr Ray1 , dd_RayPtr Ray2 , dd_RayPtr ValidFirstRay ) ;
#line 239
void dd_CopyNormalizedAmatrix(mytype **Acopy , mytype **A , dd_rowrange m , dd_colrange d ) ;
#line 240
void dd_CopyNormalizedArow(mytype *acopy , mytype *a___41 , dd_colrange d ) ;
#line 241
void dd_CopyAmatrix(mytype **Acopy , mytype **A , dd_rowrange m , dd_colrange d ) ;
#line 242
void dd_PermuteCopyAmatrix(mytype **Acopy , mytype **A , dd_rowrange m , dd_colrange d ,
                           dd_rowindex roworder ) ;
#line 243
void dd_PermutePartialCopyAmatrix(mytype **Acopy , mytype **A , dd_rowrange m , dd_colrange d ,
                                  dd_rowindex roworder , dd_rowrange p , dd_rowrange q ) ;
#line 244
void dd_CopyBmatrix(dd_colrange d_size , dd_Bmatrix T , dd_Bmatrix TCOPY ) ;
#line 248
void dd_CreateNewRay(dd_ConePtr cone , dd_RayPtr Ptr1 , dd_RayPtr Ptr2 , dd_rowrange ii ) ;
#line 249
void dd_Eliminate(dd_ConePtr cone , dd_RayPtr *Ptr ) ;
#line 250
void dd_EvaluateARay1(dd_rowrange i , dd_ConePtr cone ) ;
#line 251
void dd_EvaluateARay2(dd_rowrange i , dd_ConePtr cone ) ;
#line 252
void dd_FeasibilityIndices(long *fnum , long *infnum , dd_rowrange i , dd_ConePtr cone ) ;
#line 253
void dd_FindBasis(dd_ConePtr cone , long *rank ) ;
#line 255
void dd_ColumnReduce(dd_ConePtr cone ) ;
#line 258
dd_boolean dd_LexLarger(mytype *v1 , mytype *v2 , long dmax ) ;
#line 259
dd_boolean dd_LexEqual(mytype *v1 , mytype *v2 , long dmax ) ;
#line 267
void dd_SelectPreorderedNext(dd_ConePtr cone , dd_rowset excluded , dd_rowrange *hh ) ;
#line 270
void dd_StoreRay1(dd_ConePtr cone , mytype *p , dd_boolean *feasible ) ;
#line 271
void dd_StoreRay2(dd_ConePtr cone , mytype *p , dd_boolean *feasible , dd_boolean *weaklyfeasible ) ;
#line 273
void dd_UpdateEdges(dd_ConePtr cone , dd_RayPtr RRbegin , dd_RayPtr RRend ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___1  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___1  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___1  =    (dd_rowrange )0;
#line 21 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_CheckAdjacency(dd_ConePtr cone , dd_RayPtr *RP1 , dd_RayPtr *RP2 , dd_boolean *adjacent ) 
{ 
  dd_RayPtr TempRay ;
  dd_boolean localdebug ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 25
  localdebug = 0;
#line 29
  if (last_m___1 != cone->m) {
#line 30
    if (last_m___1 > 0L) {
      {
#line 31
      set_free(Face___1);
#line 31
      set_free(Face1___1);
      }
    }
    {
#line 33
    set_initialize(& Face___1, cone->m);
#line 34
    set_initialize(& Face1___1, cone->m);
#line 35
    last_m___1 = cone->m;
    }
  }
#line 38
  if (dd_debug) {
#line 38
    localdebug = 1;
  }
  {
#line 39
  *adjacent = 1;
#line 40
  set_int(Face1___1, (*RP1)->ZeroSet, (*RP2)->ZeroSet);
#line 41
  set_int(Face___1, Face1___1, cone->AddedHalfspaces);
#line 42
  tmp___0 = set_card(Face___1);
  }
#line 42
  if (tmp___0 < cone->d - 2L) {
#line 43
    *adjacent = 0;
#line 44
    if (localdebug) {
      {
#line 45
      tmp = set_card(Face___1);
#line 45
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"non adjacent: set_card(face) %ld < %ld = cone->d.\n",
              tmp, cone->d);
      }
    }
#line 48
    return;
  } else
#line 50
  if ((cone->parent)->NondegAssumed) {
#line 51
    *adjacent = 1;
#line 52
    return;
  }
#line 54
  TempRay = cone->FirstRay;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if ((unsigned long )TempRay != (unsigned long )((void *)0)) {
#line 55
      if (! *adjacent) {
#line 55
        goto while_break;
      }
    } else {
#line 55
      goto while_break;
    }
#line 56
    if ((unsigned long )TempRay != (unsigned long )*RP1) {
#line 56
      if ((unsigned long )TempRay != (unsigned long )*RP2) {
        {
#line 57
        set_int(Face1___1, TempRay->ZeroSet, cone->AddedHalfspaces);
#line 58
        tmp___1 = set_subset(Face___1, Face1___1);
        }
#line 58
        if (tmp___1) {
#line 58
          *adjacent = 0;
        }
      }
    }
#line 60
    TempRay = TempRay->Next;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_Eliminate(dd_ConePtr cone , dd_RayPtr *Ptr ) 
{ 
  dd_RayPtr TempPtr ;
  dd_colrange j ;

  {
#line 70
  TempPtr = (*Ptr)->Next;
#line 71
  (*Ptr)->Next = ((*Ptr)->Next)->Next;
#line 72
  if ((unsigned long )TempPtr == (unsigned long )cone->FirstRay) {
#line 73
    cone->FirstRay = (*Ptr)->Next;
  }
#line 74
  if ((unsigned long )TempPtr == (unsigned long )cone->LastRay) {
#line 75
    cone->LastRay = *Ptr;
  }
#line 78
  j = (dd_colrange )0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (j < cone->d)) {
#line 78
      goto while_break;
    }
    {
#line 79
    __gmpq_clear(*(TempPtr->Ray + j));
#line 78
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  __gmpq_clear(TempPtr->ARay);
#line 82
  free((void *)TempPtr->Ray);
#line 83
  set_free(TempPtr->ZeroSet);
#line 84
  free((void *)TempPtr);
#line 85
  (cone->RayCount) --;
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_SetInequalitySets(dd_ConePtr cone ) 
{ 
  dd_rowrange i ;

  {
  {
#line 92
  set_emptyset(cone->GroundSet);
#line 93
  set_emptyset(cone->EqualitySet);
#line 94
  set_emptyset(cone->NonequalitySet);
#line 95
  i = (dd_rowrange )1;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i <= (cone->parent)->m)) {
#line 95
      goto while_break;
    }
    {
#line 96
    set_addelem(cone->GroundSet, i);
    }
#line 97
    if (*((cone->parent)->EqualityIndex + i) == 1) {
      {
#line 97
      set_addelem(cone->EqualitySet, i);
      }
    }
#line 98
    if (*((cone->parent)->EqualityIndex + i) == -1) {
      {
#line 98
      set_addelem(cone->NonequalitySet, i);
      }
    }
#line 95
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_AValue(mytype *val , dd_colrange d_size , dd_Amatrix A , mytype *p , dd_rowrange i ) 
{ 
  dd_colrange j ;
  mytype x ;

  {
  {
#line 109
  __gmpq_init(x);
#line 110
  __gmpq_set(*val, (mpq_srcptr )(dd_purezero));
#line 113
  j = (dd_colrange )0;
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (j < d_size)) {
#line 113
      goto while_break;
    }
    {
#line 114
    __gmpq_mul(x, (mpq_srcptr )(*(*(A + (i - 1L)) + j)), (mpq_srcptr )(*(p + j)));
#line 115
    __gmpq_add(*val, (mpq_srcptr )(*val), (mpq_srcptr )(x));
#line 113
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  __gmpq_clear(x);
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_StoreRay1(dd_ConePtr cone , mytype *p , dd_boolean *feasible ) 
{ 
  dd_rowrange i ;
  dd_rowrange k ;
  dd_rowrange fii ;
  dd_colrange j ;
  mytype temp ;
  dd_RayPtr RR ;
  dd_boolean localdebug ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;

  {
  {
#line 122
  fii = cone->m + 1L;
#line 126
  localdebug = dd_debug;
#line 128
  __gmpq_init(temp);
#line 129
  RR = cone->LastRay;
#line 130
  *feasible = 1;
#line 131
  set_initialize(& RR->ZeroSet, cone->m);
#line 132
  j = (dd_colrange )0;
  }
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (j < cone->d)) {
#line 132
      goto while_break;
    }
    {
#line 133
    __gmpq_set(*(RR->Ray + j), (mpq_srcptr )(*(p + j)));
#line 132
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  i = (dd_rowrange )1;
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! (i <= cone->m)) {
#line 135
      goto while_break___0;
    }
    {
#line 136
    k = *(cone->OrderVector + i);
#line 137
    dd_AValue(& temp, cone->d, cone->A, p, k);
    }
#line 138
    if (localdebug) {
      {
#line 139
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_StoreRay1: dd_AValue at row %ld =",
              k);
#line 140
      dd_WriteNumber(stderr, (__mpq_struct *)(temp));
#line 141
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
    {
#line 143
    tmp = dd_EqualToZero((__mpq_struct *)(temp));
    }
#line 143
    if (tmp) {
      {
#line 144
      set_addelem(RR->ZeroSet, k);
      }
#line 145
      if (localdebug) {
        {
#line 146
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"recognized zero!\n");
        }
      }
    }
    {
#line 149
    tmp___0 = dd_Negative((__mpq_struct *)(temp));
    }
#line 149
    if (tmp___0) {
#line 150
      if (localdebug) {
        {
#line 151
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"recognized negative!\n");
        }
      }
#line 153
      *feasible = 0;
#line 154
      if (fii > cone->m) {
#line 154
        fii = i;
      }
#line 155
      if (localdebug) {
        {
#line 156
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"this ray is not feasible, neg comp = %ld\n",
                fii);
#line 157
        dd_WriteNumber(stderr, (__mpq_struct *)(temp));
#line 157
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
    }
#line 135
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 161
  RR->FirstInfeasIndex = fii;
#line 162
  RR->feasible = *feasible;
#line 163
  __gmpq_clear(temp);
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_StoreRay2(dd_ConePtr cone , mytype *p , dd_boolean *feasible , dd_boolean *weaklyfeasible ) 
{ 
  dd_RayPtr RR ;
  dd_rowrange i ;
  dd_rowrange k ;
  dd_rowrange fii ;
  dd_colrange j ;
  mytype temp ;
  dd_boolean localdebug ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;

  {
  {
#line 173
  fii = cone->m + 1L;
#line 176
  localdebug = dd_debug;
#line 178
  __gmpq_init(temp);
#line 179
  RR = cone->LastRay;
  }
#line 180
  if (dd_debug) {
#line 180
    localdebug = 1;
  }
  {
#line 181
  *feasible = 1;
#line 182
  *weaklyfeasible = 1;
#line 183
  set_initialize(& RR->ZeroSet, cone->m);
#line 184
  j = (dd_colrange )0;
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (j < cone->d)) {
#line 184
      goto while_break;
    }
    {
#line 185
    __gmpq_set(*(RR->Ray + j), (mpq_srcptr )(*(p + j)));
#line 184
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  i = (dd_rowrange )1;
  {
#line 187
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 187
    if (! (i <= cone->m)) {
#line 187
      goto while_break___0;
    }
    {
#line 188
    k = *(cone->OrderVector + i);
#line 189
    dd_AValue(& temp, cone->d, cone->A, p, k);
#line 190
    tmp = dd_EqualToZero((__mpq_struct *)(temp));
    }
#line 190
    if (tmp) {
      {
#line 191
      set_addelem(RR->ZeroSet, k);
      }
#line 192
      if (*((cone->parent)->EqualityIndex + k) == -1) {
#line 193
        *feasible = 0;
      }
    }
    {
#line 196
    tmp___0 = dd_Negative((__mpq_struct *)(temp));
    }
#line 196
    if (tmp___0) {
#line 197
      *feasible = 0;
#line 198
      if (fii > cone->m) {
#line 198
        if (*((cone->parent)->EqualityIndex + k) >= 0) {
#line 199
          fii = i;
#line 200
          *weaklyfeasible = 0;
        }
      }
    }
#line 187
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 204
  RR->FirstInfeasIndex = fii;
#line 205
  RR->feasible = *feasible;
#line 206
  __gmpq_clear(temp);
  }
#line 207
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_AddRay(dd_ConePtr cone , mytype *p ) 
{ 
  dd_boolean feasible ;
  dd_boolean weaklyfeasible ;
  dd_colrange j ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 215
  if ((unsigned long )cone->FirstRay == (unsigned long )((void *)0)) {
    {
#line 216
    tmp = malloc(sizeof(dd_RayType ));
#line 216
    cone->FirstRay = (dd_RayPtr )tmp;
#line 217
    tmp___0 = calloc((size_t )cone->d, sizeof(mytype ));
#line 217
    (cone->FirstRay)->Ray = (mytype *)tmp___0;
#line 218
    j = (dd_colrange )0;
    }
    {
#line 218
    while (1) {
      while_continue: /* CIL Label */ ;
#line 218
      if (! (j < cone->d)) {
#line 218
        goto while_break;
      }
      {
#line 218
      __gmpq_init(*((cone->FirstRay)->Ray + j));
#line 218
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 219
    __gmpq_init((cone->FirstRay)->ARay);
    }
#line 220
    if (dd_debug) {
      {
#line 221
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Create the first ray pointer\n");
      }
    }
#line 222
    cone->LastRay = cone->FirstRay;
#line 223
    (cone->ArtificialRay)->Next = cone->FirstRay;
  } else {
    {
#line 225
    tmp___1 = malloc(sizeof(dd_RayType ));
#line 225
    (cone->LastRay)->Next = (dd_RayPtr )tmp___1;
#line 226
    tmp___2 = calloc((size_t )cone->d, sizeof(mytype ));
#line 226
    ((cone->LastRay)->Next)->Ray = (mytype *)tmp___2;
#line 227
    j = (dd_colrange )0;
    }
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (j < cone->d)) {
#line 227
        goto while_break___0;
      }
      {
#line 227
      __gmpq_init(*(((cone->LastRay)->Next)->Ray + j));
#line 227
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 228
    __gmpq_init(((cone->LastRay)->Next)->ARay);
    }
#line 229
    if (dd_debug) {
      {
#line 229
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Create a new ray pointer\n");
      }
    }
#line 230
    cone->LastRay = (cone->LastRay)->Next;
  }
#line 232
  (cone->LastRay)->Next = (dd_RayPtr )((void *)0);
#line 233
  (cone->RayCount) ++;
#line 234
  (cone->TotalRayCount) ++;
#line 235
  if (dd_debug) {
#line 236
    if (cone->TotalRayCount % 100L == 0L) {
      {
#line 237
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*Rays (Total, Currently Active, Feasible) =%8ld%8ld%8ld\n",
              cone->TotalRayCount, cone->RayCount, cone->FeasibleRayCount);
      }
    }
  }
#line 241
  if ((cone->parent)->RelaxedEnumeration) {
    {
#line 242
    dd_StoreRay2(cone, p, & feasible, & weaklyfeasible);
    }
#line 243
    if (weaklyfeasible) {
#line 243
      (cone->WeaklyFeasibleRayCount) ++;
    }
  } else {
    {
#line 245
    dd_StoreRay1(cone, p, & feasible);
    }
#line 246
    if (feasible) {
#line 246
      (cone->WeaklyFeasibleRayCount) ++;
    }
  }
#line 249
  if (! feasible) {
#line 249
    return;
  } else {
#line 251
    (cone->FeasibleRayCount) ++;
  }
#line 253
  return;
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_AddArtificialRay(dd_ConePtr cone ) 
{ 
  dd_Arow zerovector ;
  dd_colrange j ;
  dd_colrange d1 ;
  dd_boolean feasible ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 261
  if (cone->d <= 0L) {
#line 261
    d1 = (dd_colrange )1;
  } else {
#line 261
    d1 = cone->d;
  }
  {
#line 262
  dd_InitializeArow(d1, & zerovector);
  }
#line 263
  if ((unsigned long )cone->ArtificialRay != (unsigned long )((void *)0)) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning !!!  FirstRay in not nil.  Illegal Call\n");
#line 265
    free((void *)zerovector);
    }
#line 266
    return;
  }
  {
#line 268
  tmp = malloc(sizeof(dd_RayType ));
#line 268
  cone->ArtificialRay = (dd_RayPtr )tmp;
#line 269
  tmp___0 = calloc((size_t )d1, sizeof(mytype ));
#line 269
  (cone->ArtificialRay)->Ray = (mytype *)tmp___0;
#line 270
  j = (dd_colrange )0;
  }
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (! (j < d1)) {
#line 270
      goto while_break;
    }
    {
#line 270
    __gmpq_init(*((cone->ArtificialRay)->Ray + j));
#line 270
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 271
  __gmpq_init((cone->ArtificialRay)->ARay);
  }
#line 273
  if (dd_debug) {
    {
#line 273
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Create the artificial ray pointer\n");
    }
  }
  {
#line 275
  cone->LastRay = cone->ArtificialRay;
#line 276
  dd_StoreRay1(cone, zerovector, & feasible);
#line 278
  (cone->ArtificialRay)->Next = (dd_RayPtr )((void *)0);
#line 279
  j = (dd_colrange )0;
  }
  {
#line 279
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 279
    if (! (j < d1)) {
#line 279
      goto while_break___0;
    }
    {
#line 280
    __gmpq_clear(*(zerovector + j));
#line 279
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 282
  free((void *)zerovector);
  }
#line 283
  return;
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___2  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___2  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___2  =    (dd_rowrange )0;
#line 285 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_ConditionalAddEdge(dd_ConePtr cone , dd_RayPtr Ray1 , dd_RayPtr Ray2 , dd_RayPtr ValidFirstRay ) 
{ 
  long it ;
  long it_row ;
  long fii1 ;
  long fii2 ;
  long fmin___0 ;
  long fmax___0 ;
  dd_boolean adjacent ;
  dd_boolean lastchance ;
  dd_RayPtr TempRay ;
  dd_RayPtr Rmin ;
  dd_RayPtr Rmax ;
  dd_AdjacencyType *NewEdge ;
  dd_boolean localdebug ;
  dd_rowset ZSmin ;
  dd_rowset ZSmax ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 292
  localdebug = 0;
#line 297
  if (last_m___2 != cone->m) {
#line 298
    if (last_m___2 > 0L) {
      {
#line 299
      set_free(Face___2);
#line 299
      set_free(Face1___2);
      }
    }
    {
#line 301
    set_initialize(& Face___2, cone->m);
#line 302
    set_initialize(& Face1___2, cone->m);
#line 303
    last_m___2 = cone->m;
    }
  }
#line 306
  fii1 = Ray1->FirstInfeasIndex;
#line 307
  fii2 = Ray2->FirstInfeasIndex;
#line 308
  if (fii1 < fii2) {
#line 309
    fmin___0 = fii1;
#line 309
    fmax___0 = fii2;
#line 310
    Rmin = Ray1;
#line 311
    Rmax = Ray2;
  } else {
#line 314
    fmin___0 = fii2;
#line 314
    fmax___0 = fii1;
#line 315
    Rmin = Ray2;
#line 316
    Rmax = Ray1;
  }
#line 318
  ZSmin = Rmin->ZeroSet;
#line 319
  ZSmax = Rmax->ZeroSet;
#line 320
  if (localdebug) {
    {
#line 321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_ConditionalAddEdge: FMIN = %ld (row%ld)   FMAX=%ld\n",
            fmin___0, *(cone->OrderVector + fmin___0), fmax___0);
    }
  }
#line 324
  if (fmin___0 == fmax___0) {
#line 325
    if (localdebug) {
      {
#line 325
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_ConditionalAddEdge: equal FII value-> No edge added\n");
      }
    }
  } else {
    {
#line 327
    tmp___5 = set_member(*(cone->OrderVector + fmin___0), ZSmax);
    }
#line 327
    if (tmp___5) {
#line 328
      if (localdebug) {
        {
#line 328
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_ConditionalAddEdge: No strong separation -> No edge added\n");
        }
      }
    } else {
      {
#line 331
      lastchance = 1;
#line 333
      set_int(Face1___2, ZSmax, ZSmin);
#line 334
      (cone->count_int) ++;
      }
#line 335
      if (localdebug) {
        {
#line 336
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Face: ");
#line 337
        it = 1L;
        }
        {
#line 337
        while (1) {
          while_continue: /* CIL Label */ ;
#line 337
          if (! (it <= cone->m)) {
#line 337
            goto while_break;
          }
          {
#line 338
          it_row = *(cone->OrderVector + it);
#line 339
          tmp = set_member(it_row, Face1___2);
          }
#line 339
          if (tmp) {
            {
#line 339
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld ",
                    it_row);
            }
          }
#line 337
          it ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 341
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 343
      it = cone->Iteration + 1L;
      {
#line 343
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 343
        if (it < fmin___0) {
#line 343
          if (! lastchance) {
#line 343
            goto while_break___0;
          }
        } else {
#line 343
          goto while_break___0;
        }
#line 344
        it_row = *(cone->OrderVector + it);
#line 345
        if (*((cone->parent)->EqualityIndex + it_row) >= 0) {
          {
#line 345
          tmp___0 = set_member(it_row, Face1___2);
          }
#line 345
          if (tmp___0) {
#line 346
            lastchance = 0;
#line 347
            (cone->count_int_bad) ++;
#line 348
            if (localdebug) {
              {
#line 349
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"There will be another chance iteration %ld (row %ld) to store the pair\n",
                      it, it_row);
              }
            }
          }
        }
#line 343
        it ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 353
      if (lastchance) {
        {
#line 354
        adjacent = 1;
#line 355
        (cone->count_int_good) ++;
#line 357
        set_int(Face___2, Face1___2, cone->AddedHalfspaces);
        }
#line 358
        if (localdebug) {
          {
#line 359
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Check adjacency\n");
#line 360
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AddedHalfspaces: ");
#line 360
          set_fwrite(stderr, cone->AddedHalfspaces);
#line 361
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Face: ");
#line 362
          it = 1L;
          }
          {
#line 362
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 362
            if (! (it <= cone->m)) {
#line 362
              goto while_break___1;
            }
            {
#line 363
            it_row = *(cone->OrderVector + it);
#line 364
            tmp___1 = set_member(it_row, Face___2);
            }
#line 364
            if (tmp___1) {
              {
#line 364
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld ",
                      it_row);
              }
            }
#line 362
            it ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 366
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
          }
        }
        {
#line 368
        tmp___3 = set_card(Face___2);
        }
#line 368
        if (tmp___3 < cone->d - 2L) {
#line 369
          adjacent = 0;
        } else
#line 371
        if ((cone->parent)->NondegAssumed) {
#line 372
          adjacent = 1;
        } else {
#line 375
          TempRay = ValidFirstRay;
          {
#line 376
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 376
            if ((unsigned long )TempRay != (unsigned long )((void *)0)) {
#line 376
              if (! adjacent) {
#line 376
                goto while_break___2;
              }
            } else {
#line 376
              goto while_break___2;
            }
#line 377
            if ((unsigned long )TempRay != (unsigned long )Ray1) {
#line 377
              if ((unsigned long )TempRay != (unsigned long )Ray2) {
                {
#line 378
                set_int(Face1___2, TempRay->ZeroSet, cone->AddedHalfspaces);
#line 379
                tmp___2 = set_subset(Face___2, Face1___2);
                }
#line 379
                if (tmp___2) {
#line 380
                  if (localdebug) {
                    {
#line 380
                    set_fwrite(stderr, Face1___2);
                    }
                  }
#line 381
                  adjacent = 0;
                }
              }
            }
#line 384
            TempRay = TempRay->Next;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 387
        if (adjacent) {
#line 388
          if (localdebug) {
            {
#line 388
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The pair is adjacent and the pair must be stored for iteration %ld (row%ld)\n",
                    fmin___0, *(cone->OrderVector + fmin___0));
            }
          }
          {
#line 390
          tmp___4 = malloc(sizeof(*NewEdge));
#line 390
          NewEdge = (dd_AdjacencyPtr )tmp___4;
#line 391
          NewEdge->Ray1 = Rmax;
#line 392
          NewEdge->Ray2 = Rmin;
#line 393
          NewEdge->Next = (dd_AdjacencyPtr )((void *)0);
#line 394
          (cone->EdgeCount) ++;
#line 395
          (cone->TotalEdgeCount) ++;
          }
#line 396
          if ((unsigned long )*(cone->Edges + fmin___0) == (unsigned long )((void *)0)) {
#line 397
            *(cone->Edges + fmin___0) = NewEdge;
#line 398
            if (localdebug) {
              {
#line 398
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Create a new edge list of %ld\n",
                      fmin___0);
              }
            }
          } else {
#line 400
            NewEdge->Next = *(cone->Edges + fmin___0);
#line 401
            *(cone->Edges + fmin___0) = NewEdge;
          }
        }
      }
    }
  }
#line 406
  return;
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_CreateInitialEdges(dd_ConePtr cone ) 
{ 
  dd_RayPtr Ptr1 ;
  dd_RayPtr Ptr2 ;
  dd_rowrange fii1 ;
  dd_rowrange fii2 ;
  long count ;
  dd_boolean adj ;
  dd_boolean localdebug ;

  {
#line 412
  count = 0L;
#line 413
  localdebug = 0;
#line 415
  cone->Iteration = cone->d;
#line 416
  if ((unsigned long )cone->FirstRay == (unsigned long )((void *)0)) {
#line 418
    goto _L99;
  } else
#line 416
  if ((unsigned long )cone->LastRay == (unsigned long )((void *)0)) {
#line 418
    goto _L99;
  }
#line 420
  Ptr1 = cone->FirstRay;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if ((unsigned long )Ptr1 != (unsigned long )cone->LastRay) {
#line 421
      if (! ((unsigned long )Ptr1 != (unsigned long )((void *)0))) {
#line 421
        goto while_break;
      }
    } else {
#line 421
      goto while_break;
    }
#line 422
    fii1 = Ptr1->FirstInfeasIndex;
#line 423
    Ptr2 = Ptr1->Next;
    {
#line 424
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 424
      if (! ((unsigned long )Ptr2 != (unsigned long )((void *)0))) {
#line 424
        goto while_break___0;
      }
#line 425
      fii2 = Ptr2->FirstInfeasIndex;
#line 426
      count ++;
#line 427
      if (localdebug) {
        {
#line 427
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_ CreateInitialEdges: edge %ld \n",
                count);
        }
      }
      {
#line 428
      dd_CheckAdjacency(cone, & Ptr1, & Ptr2, & adj);
      }
#line 429
      if (fii1 != fii2) {
#line 429
        if (adj) {
          {
#line 430
          dd_ConditionalAddEdge(cone, Ptr1, Ptr2, cone->FirstRay);
          }
        }
      }
#line 431
      Ptr2 = Ptr2->Next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 433
    Ptr1 = Ptr1->Next;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 436
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_UpdateEdges(dd_ConePtr cone , dd_RayPtr RRbegin , dd_RayPtr RRend ) 
{ 
  dd_RayPtr Ptr1 ;
  dd_RayPtr Ptr2begin ;
  dd_RayPtr Ptr2 ;
  dd_rowrange fii1 ;
  dd_boolean ptr2found ;
  dd_boolean quit ;
  dd_boolean localdebug ;
  long count ;
  long pos1 ;
  long pos2 ;
  float workleft ;
  float prevworkleft ;
  float totalpairs ;

  {
#line 447
  localdebug = 0;
#line 448
  count = 0L;
#line 449
  prevworkleft = (float )110.0;
#line 451
  totalpairs = (float )(((double )cone->ZeroRayCount - 1.0) * ((double )cone->ZeroRayCount - 2.0) + 1.0);
#line 452
  Ptr2begin = (dd_RayPtr )((void *)0);
#line 453
  if ((unsigned long )RRbegin == (unsigned long )((void *)0)) {
    {
#line 454
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: dd_UpdateEdges called with NULL pointer(s)\n");
    }
#line 455
    goto _L99;
  } else
#line 453
  if ((unsigned long )RRend == (unsigned long )((void *)0)) {
    {
#line 454
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: dd_UpdateEdges called with NULL pointer(s)\n");
    }
#line 455
    goto _L99;
  }
#line 457
  Ptr1 = RRbegin;
#line 458
  pos1 = 1L;
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    ptr2found = 0;
#line 461
    quit = 0;
#line 462
    fii1 = Ptr1->FirstInfeasIndex;
#line 463
    pos2 = 2L;
#line 464
    Ptr2 = Ptr1->Next;
    {
#line 464
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 464
      if (! ptr2found) {
#line 464
        if (! (! quit)) {
#line 464
          goto while_break___0;
        }
      } else {
#line 464
        goto while_break___0;
      }
#line 465
      if (Ptr2->FirstInfeasIndex > fii1) {
#line 466
        Ptr2begin = Ptr2;
#line 467
        ptr2found = 1;
      } else
#line 469
      if ((unsigned long )Ptr2 == (unsigned long )RRend) {
#line 469
        quit = 1;
      }
#line 464
      Ptr2 = Ptr2->Next;
#line 464
      pos2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 471
    if (ptr2found) {
#line 472
      quit = 0;
#line 473
      Ptr2 = Ptr2begin;
      {
#line 473
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 473
        if (! (! quit)) {
#line 473
          goto while_break___1;
        }
#line 474
        count ++;
#line 475
        if (localdebug) {
          {
#line 475
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_UpdateEdges: edge %ld \n",
                  count);
          }
        }
        {
#line 476
        dd_ConditionalAddEdge(cone, Ptr1, Ptr2, RRbegin);
        }
#line 477
        if ((unsigned long )Ptr2 == (unsigned long )RRend) {
#line 477
          quit = 1;
        } else
#line 477
        if ((unsigned long )Ptr2->Next == (unsigned long )((void *)0)) {
#line 477
          quit = 1;
        }
#line 473
        Ptr2 = Ptr2->Next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 480
    Ptr1 = Ptr1->Next;
#line 481
    pos1 ++;
#line 482
    workleft = (float )(((100.0 * (double )(cone->ZeroRayCount - pos1)) * ((double )(cone->ZeroRayCount - pos1) - 1.0)) / (double )totalpairs);
#line 483
    if (cone->ZeroRayCount >= 500L) {
#line 483
      if (dd_debug) {
#line 483
        if (pos1 % 10L == 0L) {
#line 483
          if (prevworkleft - workleft >= (float )10) {
            {
#line 484
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*Work of iteration %5ld(/%ld): %4ld/%4ld => %4.1f%% left\n",
                    cone->Iteration, cone->m, pos1, cone->ZeroRayCount, (double )workleft);
#line 486
            prevworkleft = workleft;
            }
          }
        }
      }
    }
#line 459
    if ((unsigned long )Ptr1 != (unsigned long )RRend) {
#line 459
      if (! ((unsigned long )Ptr1 != (unsigned long )((void *)0))) {
#line 459
        goto while_break;
      }
    } else {
#line 459
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 490
  return;
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_FreeDDMemory0(dd_ConePtr cone ) 
{ 
  dd_RayPtr Ptr ;
  dd_RayPtr PrevPtr ;
  long count ;
  dd_colrange j ;
  dd_boolean localdebug ;

  {
#line 497
  localdebug = 0;
#line 500
  PrevPtr = cone->ArtificialRay;
#line 501
  if ((unsigned long )PrevPtr != (unsigned long )((void *)0)) {
#line 502
    count = 0L;
#line 503
    Ptr = (cone->ArtificialRay)->Next;
    {
#line 503
    while (1) {
      while_continue: /* CIL Label */ ;
#line 503
      if (! ((unsigned long )Ptr != (unsigned long )((void *)0))) {
#line 503
        goto while_break;
      }
#line 505
      j = (dd_colrange )0;
      {
#line 505
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 505
        if (! (j < cone->d)) {
#line 505
          goto while_break___0;
        }
        {
#line 506
        __gmpq_clear(*(PrevPtr->Ray + j));
#line 505
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 507
      __gmpq_clear(PrevPtr->ARay);
#line 509
      free((void *)PrevPtr->Ray);
#line 510
      free((void *)PrevPtr->ZeroSet);
#line 511
      free((void *)PrevPtr);
#line 512
      count ++;
#line 513
      PrevPtr = Ptr;
#line 503
      Ptr = Ptr->Next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 515
    cone->FirstRay = (dd_RayPtr )((void *)0);
#line 517
    j = (dd_colrange )0;
    {
#line 517
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 517
      if (! (j < cone->d)) {
#line 517
        goto while_break___1;
      }
      {
#line 518
      __gmpq_clear(*((cone->LastRay)->Ray + j));
#line 517
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 519
    __gmpq_clear((cone->LastRay)->ARay);
#line 521
    free((void *)(cone->LastRay)->Ray);
#line 522
    (cone->LastRay)->Ray = (mytype *)((void *)0);
#line 523
    set_free((cone->LastRay)->ZeroSet);
#line 524
    (cone->LastRay)->ZeroSet = (dd_rowset )((void *)0);
#line 525
    free((void *)cone->LastRay);
#line 526
    cone->LastRay = (dd_RayPtr )((void *)0);
#line 527
    cone->ArtificialRay = (dd_RayPtr )((void *)0);
    }
#line 528
    if (localdebug) {
      {
#line 528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld ray storage spaces freed\n",
              count);
      }
    }
  }
  {
#line 531
  free((void *)cone->Edges);
#line 533
  set_free(cone->GroundSet);
#line 534
  set_free(cone->EqualitySet);
#line 535
  set_free(cone->NonequalitySet);
#line 536
  set_free(cone->AddedHalfspaces);
#line 537
  set_free(cone->WeaklyAddedHalfspaces);
#line 538
  set_free(cone->InitialHalfspaces);
#line 539
  free((void *)cone->InitialRayIndex);
#line 540
  free((void *)cone->OrderVector);
#line 541
  free((void *)cone->newcol);
#line 544
  dd_FreeBmatrix(cone->d_alloc, cone->B);
#line 545
  dd_FreeBmatrix(cone->d_alloc, cone->Bsave);
#line 548
  dd_FreeAmatrix(cone->m_alloc, cone->d_alloc, cone->A);
#line 549
  cone->A = (dd_Amatrix )((void *)0);
#line 551
  free((void *)cone);
  }
#line 552
  return;
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_FreeDDMemory(dd_PolyhedraPtr poly ) 
{ 


  {
  {
#line 556
  dd_FreeDDMemory0(poly->child);
#line 557
  poly->child = (dd_ConePtr )((void *)0);
  }
#line 558
  return;
}
}
#line 560 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_FreePolyhedra(dd_PolyhedraPtr poly ) 
{ 
  dd_bigrange i ;

  {
#line 564
  if ((unsigned long )poly->child != (unsigned long )((void *)0)) {
    {
#line 564
    dd_FreeDDMemory(poly);
    }
  }
  {
#line 565
  dd_FreeAmatrix(poly->m_alloc, poly->d_alloc, poly->A);
#line 566
  dd_FreeArow(poly->d_alloc, poly->c);
#line 567
  free((void *)poly->EqualityIndex);
  }
#line 568
  if (poly->AincGenerated) {
#line 569
    i = (dd_bigrange )1;
    {
#line 569
    while (1) {
      while_continue: /* CIL Label */ ;
#line 569
      if (! (i <= poly->m1)) {
#line 569
        goto while_break;
      }
      {
#line 570
      set_free(*(poly->Ainc + (i - 1L)));
#line 569
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 572
    free((void *)poly->Ainc);
#line 573
    set_free(poly->Ared);
#line 574
    set_free(poly->Adom);
#line 575
    poly->Ainc = (dd_Aincidence )((void *)0);
    }
  }
  {
#line 578
  free((void *)poly);
  }
#line 579
  return;
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_Normalize(dd_colrange d_size , mytype *V ) 
{ 
  long j ;
  long jmin ;
  mytype temp ;
  mytype min ;
  dd_boolean nonzerofound ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;
  dd_boolean tmp___1 ;
  dd_boolean tmp___2 ;

  {
#line 583
  jmin = 0L;
#line 585
  nonzerofound = 0;
#line 587
  if (d_size > 0L) {
    {
#line 588
    __gmpq_init(min);
#line 588
    __gmpq_init(temp);
#line 589
    dd_abs((__mpq_struct *)(min), (__mpq_struct *)(*(V + 0)));
#line 589
    jmin = 0L;
#line 590
    tmp = dd_Positive((__mpq_struct *)(min));
    }
#line 590
    if (tmp) {
#line 590
      nonzerofound = 1;
    }
#line 591
    j = 1L;
    {
#line 591
    while (1) {
      while_continue: /* CIL Label */ ;
#line 591
      if (! (j < d_size)) {
#line 591
        goto while_break;
      }
      {
#line 592
      dd_abs((__mpq_struct *)(temp), (__mpq_struct *)(*(V + j)));
#line 593
      tmp___1 = dd_Positive((__mpq_struct *)(temp));
      }
#line 593
      if (tmp___1) {
#line 594
        if (! nonzerofound) {
          {
#line 595
          nonzerofound = 1;
#line 596
          __gmpq_set(min, (mpq_srcptr )(temp));
#line 596
          jmin = j;
          }
        } else {
          {
#line 594
          tmp___0 = dd_Smaller((__mpq_struct *)(temp), (__mpq_struct *)(min));
          }
#line 594
          if (tmp___0) {
            {
#line 595
            nonzerofound = 1;
#line 596
            __gmpq_set(min, (mpq_srcptr )(temp));
#line 596
            jmin = j;
            }
          }
        }
      }
#line 591
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 600
    tmp___2 = dd_Positive((__mpq_struct *)(min));
    }
#line 600
    if (tmp___2) {
#line 601
      j = 0L;
      {
#line 601
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 601
        if (! (j < d_size)) {
#line 601
          goto while_break___0;
        }
        {
#line 601
        __gmpq_div(*(V + j), (mpq_srcptr )(*(V + j)), (mpq_srcptr )(min));
#line 601
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 603
    __gmpq_clear(min);
#line 603
    __gmpq_clear(temp);
    }
  }
#line 605
  return;
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_ZeroIndexSet(dd_rowrange m_size , dd_colrange d_size , dd_Amatrix A , mytype *x ,
                     dd_rowset ZS ) 
{ 
  dd_rowrange i ;
  mytype temp ;
  dd_boolean tmp ;

  {
  {
#line 614
  __gmpq_init(temp);
#line 615
  set_emptyset(ZS);
#line 616
  i = (dd_rowrange )1;
  }
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;
#line 616
    if (! (i <= m_size)) {
#line 616
      goto while_break;
    }
    {
#line 617
    dd_AValue(& temp, d_size, A, x, i);
#line 618
    tmp = dd_EqualToZero((__mpq_struct *)(temp));
    }
#line 618
    if (tmp) {
      {
#line 618
      set_addelem(ZS, i);
      }
    }
#line 616
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 622
  __gmpq_clear(temp);
  }
#line 623
  return;
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_CopyBmatrix(dd_colrange d_size , dd_Bmatrix T , dd_Bmatrix TCOPY ) 
{ 
  dd_rowrange i ;
  dd_colrange j ;

  {
#line 630
  i = (dd_rowrange )0;
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 630
    if (! (i < d_size)) {
#line 630
      goto while_break;
    }
#line 631
    j = (dd_colrange )0;
    {
#line 631
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 631
      if (! (j < d_size)) {
#line 631
        goto while_break___0;
      }
      {
#line 632
      __gmpq_set(*(*(TCOPY + i) + j), (mpq_srcptr )(*(*(T + i) + j)));
#line 631
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 630
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 635
  return;
}
}
#line 638 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_CopyArow(mytype *acopy , mytype *a___41 , dd_colrange d ) 
{ 
  dd_colrange j ;

  {
#line 642
  j = (dd_colrange )0;
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    if (! (j < d)) {
#line 642
      goto while_break;
    }
    {
#line 643
    __gmpq_set(*(acopy + j), (mpq_srcptr )(*(a___41 + j)));
#line 642
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 645
  return;
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_CopyNormalizedArow(mytype *acopy , mytype *a___41 , dd_colrange d ) 
{ 


  {
  {
#line 649
  dd_CopyArow(acopy, a___41, d);
#line 650
  dd_Normalize(d, acopy);
  }
#line 651
  return;
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_CopyAmatrix(mytype **Acopy , mytype **A , dd_rowrange m , dd_colrange d ) 
{ 
  dd_rowrange i ;

  {
#line 657
  i = (dd_rowrange )0;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! (i < m)) {
#line 657
      goto while_break;
    }
    {
#line 658
    dd_CopyArow(*(Acopy + i), *(A + i), d);
#line 657
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 660
  return;
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_CopyNormalizedAmatrix(mytype **Acopy , mytype **A , dd_rowrange m , dd_colrange d ) 
{ 
  dd_rowrange i ;

  {
#line 666
  i = (dd_rowrange )0;
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 666
    if (! (i < m)) {
#line 666
      goto while_break;
    }
    {
#line 667
    dd_CopyNormalizedArow(*(Acopy + i), *(A + i), d);
#line 666
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 669
  return;
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_PermuteCopyAmatrix(mytype **Acopy , mytype **A , dd_rowrange m , dd_colrange d ,
                           dd_rowindex roworder ) 
{ 
  dd_rowrange i ;

  {
#line 675
  i = (dd_rowrange )1;
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (! (i <= m)) {
#line 675
      goto while_break;
    }
    {
#line 676
    dd_CopyArow(*(Acopy + (i - 1L)), *(A + (*(roworder + i) - 1L)), d);
#line 675
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  return;
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_PermutePartialCopyAmatrix(mytype **Acopy , mytype **A , dd_rowrange m , dd_colrange d ,
                                  dd_rowindex roworder , dd_rowrange p , dd_rowrange q ) 
{ 
  dd_rowrange i ;
  dd_rowrange k ;

  {
#line 685
  k = (dd_rowrange )0;
#line 686
  i = (dd_rowrange )1;
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 686
    if (! (i <= m)) {
#line 686
      goto while_break;
    }
#line 687
    if (*(roworder + i) > 0L) {
      {
#line 687
      dd_CopyArow(*(Acopy + (*(roworder + i) - 1L)), *(A + (i - 1L)), d);
      }
    }
#line 686
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 689
  return;
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_InitializeArow(dd_colrange d , dd_Arow *a___41 ) 
{ 
  dd_colrange j ;
  void *tmp ;

  {
#line 695
  if (d > 0L) {
    {
#line 695
    tmp = calloc((size_t )d, sizeof(mytype ));
#line 695
    *a___41 = (mytype *)tmp;
    }
  }
#line 696
  j = (dd_colrange )0;
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    if (! (j < d)) {
#line 696
      goto while_break;
    }
    {
#line 697
    __gmpq_init(*(*a___41 + j));
#line 696
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 699
  return;
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_InitializeAmatrix(dd_rowrange m , dd_colrange d , dd_Amatrix *A ) 
{ 
  dd_rowrange i ;
  void *tmp ;

  {
#line 705
  if (m > 0L) {
    {
#line 705
    tmp = calloc((size_t )m, sizeof(mytype *));
#line 705
    *A = (mytype **)tmp;
    }
  }
#line 706
  i = (dd_rowrange )0;
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! (i < m)) {
#line 706
      goto while_break;
    }
    {
#line 707
    dd_InitializeArow(d, *A + i);
#line 706
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  return;
}
}
#line 711 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_FreeAmatrix(dd_rowrange m , dd_colrange d , dd_Amatrix A ) 
{ 
  dd_rowrange i ;
  dd_colrange j ;

  {
#line 716
  i = (dd_rowrange )0;
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! (i < m)) {
#line 716
      goto while_break;
    }
#line 717
    j = (dd_colrange )0;
    {
#line 717
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 717
      if (! (j < d)) {
#line 717
        goto while_break___0;
      }
      {
#line 718
      __gmpq_clear(*(*(A + i) + j));
#line 717
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 716
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 721
  if ((unsigned long )A != (unsigned long )((void *)0)) {
#line 722
    i = (dd_rowrange )0;
    {
#line 722
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 722
      if (! (i < m)) {
#line 722
        goto while_break___1;
      }
      {
#line 723
      free((void *)*(A + i));
#line 722
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 725
    free((void *)A);
    }
  }
#line 727
  return;
}
}
#line 729 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_FreeArow(dd_colrange d , dd_Arow a___41 ) 
{ 
  dd_colrange j ;

  {
#line 733
  j = (dd_colrange )0;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    if (! (j < d)) {
#line 733
      goto while_break;
    }
    {
#line 734
    __gmpq_clear(*(a___41 + j));
#line 733
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 736
  free((void *)a___41);
  }
#line 737
  return;
}
}
#line 740 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_InitializeBmatrix(dd_colrange d , dd_Bmatrix *B ) 
{ 
  dd_colrange i ;
  dd_colrange j ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 744
  tmp = calloc((size_t )d, sizeof(mytype *));
#line 744
  *B = (mytype **)tmp;
#line 745
  j = (dd_colrange )0;
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 745
    if (! (j < d)) {
#line 745
      goto while_break;
    }
    {
#line 746
    tmp___0 = calloc((size_t )d, sizeof(mytype ));
#line 746
    *(*B + j) = (mytype *)tmp___0;
#line 745
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  i = (dd_colrange )0;
  {
#line 748
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 748
    if (! (i < d)) {
#line 748
      goto while_break___0;
    }
#line 749
    j = (dd_colrange )0;
    {
#line 749
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 749
      if (! (j < d)) {
#line 749
        goto while_break___1;
      }
      {
#line 750
      __gmpq_init(*(*(*B + i) + j));
#line 749
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 748
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 753
  return;
}
}
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_FreeBmatrix(dd_colrange d , dd_Bmatrix B ) 
{ 
  dd_colrange i ;
  dd_colrange j ;

  {
#line 759
  i = (dd_colrange )0;
  {
#line 759
  while (1) {
    while_continue: /* CIL Label */ ;
#line 759
    if (! (i < d)) {
#line 759
      goto while_break;
    }
#line 760
    j = (dd_colrange )0;
    {
#line 760
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 760
      if (! (j < d)) {
#line 760
        goto while_break___0;
      }
      {
#line 761
      __gmpq_clear(*(*(B + i) + j));
#line 760
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 759
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 764
  if ((unsigned long )B != (unsigned long )((void *)0)) {
#line 765
    j = (dd_colrange )0;
    {
#line 765
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 765
      if (! (j < d)) {
#line 765
        goto while_break___1;
      }
      {
#line 766
      free((void *)*(B + j));
#line 765
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 768
    free((void *)B);
    }
  }
#line 770
  return;
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_SetFamilyPtr dd_CreateSetFamily(dd_bigrange fsize , dd_bigrange ssize ) 
{ 
  dd_SetFamilyPtr F ;
  dd_bigrange i ;
  dd_bigrange f0 ;
  dd_bigrange f1 ;
  dd_bigrange s0 ;
  dd_bigrange s1 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 777
  if (fsize <= 0L) {
#line 778
    f0 = (dd_bigrange )0;
#line 778
    f1 = (dd_bigrange )1;
  } else {
#line 781
    f0 = fsize;
#line 781
    f1 = fsize;
  }
#line 783
  if (ssize <= 0L) {
#line 784
    s0 = (dd_bigrange )0;
#line 784
    s1 = (dd_bigrange )1;
  } else {
#line 787
    s0 = ssize;
#line 787
    s1 = ssize;
  }
  {
#line 790
  tmp = malloc(sizeof(dd_SetFamilyType ));
#line 790
  F = (dd_SetFamilyPtr )tmp;
#line 791
  tmp___0 = calloc((size_t )f1, sizeof(set_type ));
#line 791
  F->set = (set_type *)tmp___0;
#line 792
  i = (dd_bigrange )0;
  }
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 792
    if (! (i < f1)) {
#line 792
      goto while_break;
    }
    {
#line 793
    set_initialize(F->set + i, s1);
#line 792
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 795
  F->famsize = f0;
#line 796
  F->setsize = s0;
#line 797
  return (F);
}
}
#line 801 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_FreeSetFamily(dd_SetFamilyPtr F ) 
{ 
  dd_bigrange i ;
  dd_bigrange f1 ;

  {
#line 805
  if ((unsigned long )F != (unsigned long )((void *)0)) {
#line 806
    if (F->famsize <= 0L) {
#line 806
      f1 = (dd_bigrange )1;
    } else {
#line 806
      f1 = F->famsize;
    }
#line 808
    i = (dd_bigrange )0;
    {
#line 808
    while (1) {
      while_continue: /* CIL Label */ ;
#line 808
      if (! (i < f1)) {
#line 808
        goto while_break;
      }
      {
#line 809
      set_free(*(F->set + i));
#line 808
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 811
    free((void *)F->set);
#line 812
    free((void *)F);
    }
  }
#line 814
  return;
}
}
#line 816 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_MatrixPtr dd_CreateMatrix(dd_rowrange m_size , dd_colrange d_size ) 
{ 
  dd_MatrixPtr M ;
  dd_rowrange m0 ;
  dd_rowrange m1 ;
  dd_colrange d0 ;
  dd_colrange d1 ;
  void *tmp ;

  {
#line 822
  if (m_size <= 0L) {
#line 823
    m0 = (dd_rowrange )0;
#line 823
    m1 = (dd_rowrange )1;
  } else {
#line 826
    m0 = m_size;
#line 826
    m1 = m_size;
  }
#line 828
  if (d_size <= 0L) {
#line 829
    d0 = (dd_colrange )0;
#line 829
    d1 = (dd_colrange )1;
  } else {
#line 832
    d0 = d_size;
#line 832
    d1 = d_size;
  }
  {
#line 834
  tmp = malloc(sizeof(dd_MatrixType ));
#line 834
  M = (dd_MatrixPtr )tmp;
#line 835
  dd_InitializeAmatrix(m1, d1, & M->matrix);
#line 836
  dd_InitializeArow(d1, & M->rowvec);
#line 837
  M->rowsize = m0;
#line 838
  set_initialize(& M->linset, m1);
#line 839
  M->colsize = d0;
#line 840
  M->objective = (dd_LPObjectiveType )0;
#line 841
  M->numbtype = (dd_NumberType )0;
#line 842
  M->representation = (dd_RepresentationType )0;
  }
#line 843
  return (M);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_FreeMatrix(dd_MatrixPtr M ) 
{ 
  dd_rowrange m1 ;
  dd_colrange d1 ;

  {
#line 851
  if ((unsigned long )M != (unsigned long )((void *)0)) {
#line 852
    if (M->rowsize <= 0L) {
#line 852
      m1 = (dd_rowrange )1;
    } else {
#line 852
      m1 = M->rowsize;
    }
#line 853
    if (M->colsize <= 0L) {
#line 853
      d1 = (dd_colrange )1;
    } else {
#line 853
      d1 = M->colsize;
    }
#line 854
    if ((unsigned long )M != (unsigned long )((void *)0)) {
      {
#line 855
      dd_FreeAmatrix(m1, d1, M->matrix);
#line 856
      dd_FreeArow(d1, M->rowvec);
#line 857
      set_free(M->linset);
#line 858
      free((void *)M);
      }
    }
  }
#line 861
  return;
}
}
#line 863 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_SetToIdentity(dd_colrange d_size , dd_Bmatrix T ) 
{ 
  dd_colrange j1___0 ;
  dd_colrange j2 ;

  {
#line 867
  j1___0 = (dd_colrange )1;
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 867
    if (! (j1___0 <= d_size)) {
#line 867
      goto while_break;
    }
#line 868
    j2 = (dd_colrange )1;
    {
#line 868
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 868
      if (! (j2 <= d_size)) {
#line 868
        goto while_break___0;
      }
#line 869
      if (j1___0 == j2) {
        {
#line 870
        __gmpq_set(*(*(T + (j1___0 - 1L)) + (j2 - 1L)), (mpq_srcptr )(dd_one));
        }
      } else {
        {
#line 872
        __gmpq_set(*(*(T + (j1___0 - 1L)) + (j2 - 1L)), (mpq_srcptr )(dd_purezero));
        }
      }
#line 868
      j2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 867
    j1___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 875
  return;
}
}
#line 877 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_ColumnReduce(dd_ConePtr cone ) 
{ 
  dd_colrange j ;
  dd_colrange j1___0 ;
  dd_rowrange i ;
  dd_boolean localdebug ;

  {
#line 879
  j1___0 = (dd_colrange )0;
#line 881
  localdebug = 0;
#line 883
  j = (dd_colrange )1;
  {
#line 883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 883
    if (! (j <= cone->d)) {
#line 883
      goto while_break;
    }
#line 884
    if (*(cone->InitialRayIndex + j) > 0L) {
#line 885
      j1___0 ++;
#line 886
      if (j1___0 < j) {
#line 887
        i = (dd_rowrange )1;
        {
#line 887
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 887
          if (! (i <= cone->m)) {
#line 887
            goto while_break___0;
          }
          {
#line 887
          __gmpq_set(*(*(cone->A + (i - 1L)) + (j1___0 - 1L)), (mpq_srcptr )(*(*(cone->A + (i - 1L)) + (j - 1L))));
#line 887
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 888
        *(cone->newcol + j) = j1___0;
#line 889
        if (localdebug) {
          {
#line 890
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"shifting the column %ld to column %ld\n",
                  j, j1___0);
          }
        }
      }
    } else {
#line 895
      *(cone->newcol + j) = 0L;
#line 896
      if (localdebug) {
        {
#line 897
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"a generator (or an equation) of the linearity space: ");
#line 898
        i = (dd_rowrange )1;
        }
        {
#line 898
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 898
          if (! (i <= cone->d)) {
#line 898
            goto while_break___1;
          }
          {
#line 898
          dd_WriteNumber(stderr, (__mpq_struct *)(*(*(cone->B + (i - 1L)) + (j - 1L))));
#line 898
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 899
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
    }
#line 883
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 903
  cone->d = j1___0;
#line 904
  dd_CopyBmatrix(cone->d_orig, cone->B, cone->Bsave);
#line 906
  cone->ColReduced = 1;
  }
#line 907
  return;
}
}
#line 909 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
long dd_MatrixRank(dd_MatrixPtr M , dd_rowset ignoredrows , dd_colset ignoredcols ,
                   dd_rowset *rowbasis , dd_colset *colbasis ) 
{ 
  dd_boolean stop ;
  dd_boolean chosen ;
  dd_boolean localdebug ;
  dd_rowset NopivotRow ;
  dd_rowset PriorityRow ;
  dd_colset ColSelected ;
  dd_Bmatrix B ;
  dd_rowindex roworder ;
  dd_rowrange r ;
  dd_colrange s ;
  long rank ;
  void *tmp ;

  {
  {
#line 911
  localdebug = dd_debug;
#line 920
  rank = 0L;
#line 921
  stop = 0;
#line 922
  set_initialize(& ColSelected, M->colsize);
#line 923
  set_initialize(& NopivotRow, M->rowsize);
#line 924
  set_initialize(rowbasis, M->rowsize);
#line 925
  set_initialize(colbasis, M->colsize);
#line 926
  set_initialize(& PriorityRow, M->rowsize);
#line 927
  set_copy(NopivotRow, ignoredrows);
#line 928
  set_copy(ColSelected, ignoredcols);
#line 929
  dd_InitializeBmatrix(M->colsize, & B);
#line 930
  dd_SetToIdentity(M->colsize, B);
#line 931
  tmp = calloc((size_t )(M->rowsize + 1L), sizeof(long ));
#line 931
  roworder = (long *)tmp;
#line 932
  r = (dd_rowrange )0;
  }
  {
#line 932
  while (1) {
    while_continue: /* CIL Label */ ;
#line 932
    if (! (r < M->rowsize)) {
#line 932
      goto while_break;
    }
#line 932
    *(roworder + (r + 1L)) = r + 1L;
#line 932
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 935
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 936
    dd_SelectPivot2(M->rowsize, M->colsize, M->matrix, B, (dd_RowOrderType )1, roworder,
                    PriorityRow, M->rowsize, NopivotRow, ColSelected, & r, & s, & chosen);
    }
#line 938
    if (dd_debug) {
#line 938
      if (chosen) {
        {
#line 939
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Procedure dd_MatrixRank: pivot on (r,s) =(%ld, %ld).\n",
                r, s);
        }
      }
    }
#line 940
    if (chosen) {
      {
#line 941
      set_addelem(NopivotRow, r);
#line 942
      set_addelem(*rowbasis, r);
#line 943
      set_addelem(ColSelected, s);
#line 944
      set_addelem(*colbasis, s);
#line 945
      rank ++;
#line 946
      dd_GaussianColumnPivot(M->rowsize, M->colsize, M->matrix, B, r, s);
      }
#line 947
      if (localdebug) {
        {
#line 947
        dd_WriteBmatrix(stderr, M->colsize, B);
        }
      }
    } else {
#line 949
      stop = 1;
    }
#line 951
    if (rank == M->colsize) {
#line 951
      stop = 1;
    }
#line 935
    if (! (! stop)) {
#line 935
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 953
  dd_FreeBmatrix(M->colsize, B);
#line 954
  free((void *)roworder);
#line 955
  set_free(ColSelected);
#line 956
  set_free(NopivotRow);
#line 957
  set_free(PriorityRow);
  }
#line 958
  return (rank);
}
}
#line 962 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_FindBasis(dd_ConePtr cone , long *rank ) 
{ 
  dd_boolean stop ;
  dd_boolean chosen ;
  dd_boolean localdebug ;
  dd_rowset NopivotRow ;
  dd_colset ColSelected ;
  dd_rowrange r ;
  dd_colrange j ;
  dd_colrange s ;

  {
#line 964
  localdebug = dd_debug;
#line 970
  *rank = 0L;
#line 971
  stop = 0;
#line 972
  j = (dd_colrange )0;
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 972
    if (! (j <= cone->d)) {
#line 972
      goto while_break;
    }
#line 972
    *(cone->InitialRayIndex + j) = 0L;
#line 972
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 973
  set_emptyset(cone->InitialHalfspaces);
#line 974
  set_initialize(& ColSelected, cone->d);
#line 975
  set_initialize(& NopivotRow, cone->m);
#line 976
  set_copy(NopivotRow, cone->NonequalitySet);
#line 977
  dd_SetToIdentity(cone->d, cone->B);
  }
  {
#line 978
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 979
    dd_SelectPivot2(cone->m, cone->d, cone->A, cone->B, cone->HalfspaceOrder, cone->OrderVector,
                    cone->EqualitySet, cone->m, NopivotRow, ColSelected, & r, & s,
                    & chosen);
    }
#line 981
    if (dd_debug) {
#line 981
      if (chosen) {
        {
#line 982
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Procedure dd_FindBasis: pivot on (r,s) =(%ld, %ld).\n",
                r, s);
        }
      }
    }
#line 983
    if (chosen) {
      {
#line 984
      set_addelem(cone->InitialHalfspaces, r);
#line 985
      set_addelem(NopivotRow, r);
#line 986
      set_addelem(ColSelected, s);
#line 987
      *(cone->InitialRayIndex + s) = r;
#line 988
      (*rank) ++;
#line 989
      dd_GaussianColumnPivot(cone->m, cone->d, cone->A, cone->B, r, s);
      }
#line 990
      if (localdebug) {
        {
#line 990
        dd_WriteBmatrix(stderr, cone->d, cone->B);
        }
      }
    } else {
#line 992
      stop = 1;
    }
#line 994
    if (*rank == cone->d) {
#line 994
      stop = 1;
    }
#line 978
    if (! (! stop)) {
#line 978
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 996
  set_free(ColSelected);
#line 997
  set_free(NopivotRow);
  }
#line 998
  return;
}
}
#line 1001 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_FindInitialRays(dd_ConePtr cone , dd_boolean *found ) 
{ 
  dd_rowset CandidateRows ;
  dd_rowrange i ;
  long rank ;
  dd_RowOrderType roworder_save ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1006
  roworder_save = (dd_RowOrderType )5;
#line 1008
  *found = 0;
#line 1009
  set_initialize(& CandidateRows, cone->m);
  }
#line 1010
  if ((cone->parent)->InitBasisAtBottom == 1) {
#line 1011
    roworder_save = cone->HalfspaceOrder;
#line 1012
    cone->HalfspaceOrder = (dd_RowOrderType )0;
#line 1013
    cone->PreOrderedRun = 0;
  } else {
#line 1015
    cone->PreOrderedRun = 1;
  }
#line 1016
  if (dd_debug) {
    {
#line 1016
    dd_WriteBmatrix(stderr, cone->d, cone->B);
    }
  }
#line 1017
  i = (dd_rowrange )1;
  {
#line 1017
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1017
    if (! (i <= cone->m)) {
#line 1017
      goto while_break;
    }
    {
#line 1018
    tmp = set_member(i, cone->NonequalitySet);
    }
#line 1018
    if (! tmp) {
      {
#line 1018
      set_addelem(CandidateRows, i);
      }
    }
#line 1017
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1020
  dd_FindBasis(cone, & rank);
  }
#line 1021
  if (dd_debug) {
    {
#line 1021
    dd_WriteBmatrix(stderr, cone->d, cone->B);
    }
  }
#line 1022
  if (dd_debug) {
    {
#line 1022
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_FindInitialRays: rank of Amatrix = %ld\n",
            rank);
    }
  }
#line 1023
  cone->LinearityDim = cone->d - rank;
#line 1024
  if (dd_debug) {
    {
#line 1024
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Linearity Dimension = %ld\n",
            cone->LinearityDim);
    }
  }
#line 1025
  if (cone->LinearityDim > 0L) {
    {
#line 1026
    dd_ColumnReduce(cone);
#line 1027
    dd_FindBasis(cone, & rank);
    }
  }
  {
#line 1029
  tmp___0 = set_subset(cone->EqualitySet, cone->InitialHalfspaces);
  }
#line 1029
  if (! tmp___0) {
#line 1030
    if (dd_debug) {
      {
#line 1031
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Equality set is dependent. Equality Set and an initial basis:\n");
#line 1032
      set_fwrite(stderr, cone->EqualitySet);
#line 1033
      set_fwrite(stderr, cone->InitialHalfspaces);
      }
    }
  }
  {
#line 1036
  *found = 1;
#line 1037
  set_free(CandidateRows);
  }
#line 1038
  if ((cone->parent)->InitBasisAtBottom == 1) {
#line 1039
    cone->HalfspaceOrder = roworder_save;
  }
#line 1041
  if ((unsigned int )cone->HalfspaceOrder == 3U) {
#line 1044
    cone->PreOrderedRun = 0;
  } else
#line 1041
  if ((unsigned int )cone->HalfspaceOrder == 2U) {
#line 1044
    cone->PreOrderedRun = 0;
  } else
#line 1041
  if ((unsigned int )cone->HalfspaceOrder == 4U) {
#line 1044
    cone->PreOrderedRun = 0;
  } else {
#line 1045
    cone->PreOrderedRun = 1;
  }
#line 1046
  return;
}
}
#line 1048 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_CheckEquality(dd_colrange d_size , dd_RayPtr *RP1 , dd_RayPtr *RP2 , dd_boolean *equal ) 
{ 
  long j ;
  dd_boolean tmp ;

  {
#line 1052
  if (dd_debug) {
    {
#line 1053
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Check equality of two rays\n");
    }
  }
#line 1054
  *equal = 1;
#line 1055
  j = 1L;
  {
#line 1056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1056
    if (j <= d_size) {
#line 1056
      if (! *equal) {
#line 1056
        goto while_break;
      }
    } else {
#line 1056
      goto while_break;
    }
    {
#line 1057
    tmp = dd_Equal((__mpq_struct *)(*((*RP1)->Ray + (j - 1L))), (__mpq_struct *)(*((*RP2)->Ray + (j - 1L))));
    }
#line 1057
    if (! tmp) {
#line 1058
      *equal = 0;
    }
#line 1059
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1061
  if (*equal) {
    {
#line 1062
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Equal records found !!!!\n");
    }
  }
#line 1063
  return;
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___0  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___3  =    (dd_colrange )0;
#line 1065 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_CreateNewRay(dd_ConePtr cone , dd_RayPtr Ptr1 , dd_RayPtr Ptr2 , dd_rowrange ii ) 
{ 
  dd_colrange j ;
  mytype a1 ;
  mytype a2 ;
  mytype v1 ;
  mytype v2 ;
  dd_boolean localdebug ;
  void *tmp ;

  {
  {
#line 1073
  localdebug = dd_debug;
#line 1075
  __gmpq_init(a1);
#line 1075
  __gmpq_init(a2);
#line 1075
  __gmpq_init(v1);
#line 1075
  __gmpq_init(v2);
  }
#line 1076
  if (last_d___3 != cone->d) {
#line 1077
    if (last_d___3 > 0L) {
#line 1078
      j = (dd_colrange )0;
      {
#line 1078
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1078
        if (! (j < last_d___3)) {
#line 1078
          goto while_break;
        }
        {
#line 1078
        __gmpq_clear(*(NewRay___0 + j));
#line 1078
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1079
      free((void *)NewRay___0);
      }
    }
    {
#line 1081
    tmp = calloc((size_t )cone->d, sizeof(mytype ));
#line 1081
    NewRay___0 = (mytype *)tmp;
#line 1082
    j = (dd_colrange )0;
    }
    {
#line 1082
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1082
      if (! (j < cone->d)) {
#line 1082
        goto while_break___0;
      }
      {
#line 1082
      __gmpq_init(*(NewRay___0 + j));
#line 1082
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1083
    last_d___3 = cone->d;
  }
  {
#line 1086
  dd_AValue(& a1, cone->d, cone->A, Ptr1->Ray, ii);
#line 1087
  dd_AValue(& a2, cone->d, cone->A, Ptr2->Ray, ii);
  }
#line 1088
  if (localdebug) {
    {
#line 1089
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CreatNewRay: Ray1 =");
#line 1089
    dd_WriteArow(stderr, Ptr1->Ray, cone->d);
#line 1090
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CreatNewRay: Ray2 =");
#line 1090
    dd_WriteArow(stderr, Ptr2->Ray, cone->d);
    }
  }
  {
#line 1092
  dd_abs((__mpq_struct *)(v1), (__mpq_struct *)(a1));
#line 1093
  dd_abs((__mpq_struct *)(v2), (__mpq_struct *)(a2));
  }
#line 1094
  if (localdebug) {
    {
#line 1095
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_AValue1 and ABS");
#line 1095
    dd_WriteNumber(stderr, (__mpq_struct *)(a1));
#line 1095
    dd_WriteNumber(stderr, (__mpq_struct *)(v1));
#line 1095
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1096
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dd_AValue2 and ABS");
#line 1096
    dd_WriteNumber(stderr, (__mpq_struct *)(a2));
#line 1096
    dd_WriteNumber(stderr, (__mpq_struct *)(v2));
#line 1096
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 1098
  j = (dd_colrange )0;
  {
#line 1098
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1098
    if (! (j < cone->d)) {
#line 1098
      goto while_break___1;
    }
    {
#line 1099
    dd_LinearComb((__mpq_struct *)(*(NewRay___0 + j)), (__mpq_struct *)(*(Ptr1->Ray + j)),
                  (__mpq_struct *)(v2), (__mpq_struct *)(*(Ptr2->Ray + j)), (__mpq_struct *)(v1));
#line 1098
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1101
  if (localdebug) {
    {
#line 1102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CreatNewRay: New ray =");
#line 1102
    dd_WriteArow(stderr, NewRay___0, cone->d);
    }
  }
  {
#line 1104
  dd_Normalize(cone->d, NewRay___0);
  }
#line 1105
  if (localdebug) {
    {
#line 1106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CreatNewRay: dd_Normalized ray =");
#line 1106
    dd_WriteArow(stderr, NewRay___0, cone->d);
    }
  }
  {
#line 1108
  dd_AddRay(cone, NewRay___0);
#line 1109
  __gmpq_clear(a1);
#line 1109
  __gmpq_clear(a2);
#line 1109
  __gmpq_clear(v1);
#line 1109
  __gmpq_clear(v2);
  }
#line 1110
  return;
}
}
#line 1112 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_EvaluateARay1(dd_rowrange i , dd_ConePtr cone ) 
{ 
  dd_colrange j ;
  mytype temp ;
  mytype tnext ;
  dd_RayPtr Ptr ;
  dd_RayPtr PrevPtr ;
  dd_RayPtr TempPtr ;
  dd_boolean tmp ;

  {
  {
#line 1123
  __gmpq_init(temp);
#line 1123
  __gmpq_init(tnext);
#line 1124
  Ptr = cone->FirstRay;
#line 1125
  PrevPtr = cone->ArtificialRay;
  }
#line 1126
  if ((unsigned long )PrevPtr->Next != (unsigned long )Ptr) {
    {
#line 1127
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error.  Artificial Ray does not point to FirstRay!!!\n");
    }
  }
  {
#line 1129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1129
    if (! ((unsigned long )Ptr != (unsigned long )((void *)0))) {
#line 1129
      goto while_break;
    }
    {
#line 1130
    __gmpq_set(temp, (mpq_srcptr )(dd_purezero));
#line 1131
    j = (dd_colrange )0;
    }
    {
#line 1131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1131
      if (! (j < cone->d)) {
#line 1131
        goto while_break___0;
      }
      {
#line 1132
      __gmpq_mul(tnext, (mpq_srcptr )(*(*(cone->A + (i - 1L)) + j)), (mpq_srcptr )(*(Ptr->Ray + j)));
#line 1133
      __gmpq_add(temp, (mpq_srcptr )(temp), (mpq_srcptr )(tnext));
#line 1131
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1135
    __gmpq_set(Ptr->ARay, (mpq_srcptr )(temp));
#line 1137
    tmp = dd_Negative((__mpq_struct *)(temp));
    }
#line 1137
    if (tmp) {
#line 1137
      if ((unsigned long )Ptr != (unsigned long )cone->FirstRay) {
#line 1139
        if ((unsigned long )Ptr == (unsigned long )cone->LastRay) {
#line 1139
          cone->LastRay = PrevPtr;
        }
#line 1140
        TempPtr = Ptr;
#line 1141
        Ptr = Ptr->Next;
#line 1142
        PrevPtr->Next = Ptr;
#line 1143
        (cone->ArtificialRay)->Next = TempPtr;
#line 1144
        TempPtr->Next = cone->FirstRay;
#line 1145
        cone->FirstRay = TempPtr;
      } else {
#line 1148
        PrevPtr = Ptr;
#line 1149
        Ptr = Ptr->Next;
      }
    } else {
#line 1148
      PrevPtr = Ptr;
#line 1149
      Ptr = Ptr->Next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1152
  __gmpq_clear(temp);
#line 1152
  __gmpq_clear(tnext);
  }
#line 1153
  return;
}
}
#line 1155 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_EvaluateARay2(dd_rowrange i , dd_ConePtr cone ) 
{ 
  dd_colrange j ;
  mytype temp ;
  mytype tnext ;
  dd_RayPtr Ptr ;
  dd_RayPtr NextPtr ;
  dd_boolean zerofound ;
  dd_boolean negfound ;
  dd_boolean posfound ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;

  {
#line 1166
  zerofound = 0;
#line 1166
  negfound = 0;
#line 1166
  posfound = 0;
#line 1168
  if ((unsigned long )cone == (unsigned long )((void *)0)) {
#line 1168
    goto _L99;
  } else
#line 1168
  if (cone->TotalRayCount <= 0L) {
#line 1168
    goto _L99;
  }
  {
#line 1169
  __gmpq_init(temp);
#line 1169
  __gmpq_init(tnext);
#line 1170
  cone->PosHead = (dd_RayPtr )((void *)0);
#line 1170
  cone->ZeroHead = (dd_RayPtr )((void *)0);
#line 1170
  cone->NegHead = (dd_RayPtr )((void *)0);
#line 1171
  cone->PosLast = (dd_RayPtr )((void *)0);
#line 1171
  cone->ZeroLast = (dd_RayPtr )((void *)0);
#line 1171
  cone->NegLast = (dd_RayPtr )((void *)0);
#line 1172
  Ptr = cone->FirstRay;
  }
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    if (! ((unsigned long )Ptr != (unsigned long )((void *)0))) {
#line 1173
      goto while_break;
    }
    {
#line 1174
    NextPtr = Ptr->Next;
#line 1175
    Ptr->Next = (dd_RayPtr )((void *)0);
#line 1176
    __gmpq_set(temp, (mpq_srcptr )(dd_purezero));
#line 1177
    j = (dd_colrange )0;
    }
    {
#line 1177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1177
      if (! (j < cone->d)) {
#line 1177
        goto while_break___0;
      }
      {
#line 1178
      __gmpq_mul(tnext, (mpq_srcptr )(*(*(cone->A + (i - 1L)) + j)), (mpq_srcptr )(*(Ptr->Ray + j)));
#line 1179
      __gmpq_add(temp, (mpq_srcptr )(temp), (mpq_srcptr )(tnext));
#line 1177
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1181
    __gmpq_set(Ptr->ARay, (mpq_srcptr )(temp));
#line 1183
    tmp___0 = dd_Negative((__mpq_struct *)(temp));
    }
#line 1183
    if (tmp___0) {
#line 1184
      if (! negfound) {
#line 1185
        negfound = 1;
#line 1186
        cone->NegHead = Ptr;
#line 1187
        cone->NegLast = Ptr;
      } else {
#line 1190
        Ptr->Next = cone->NegHead;
#line 1191
        cone->NegHead = Ptr;
      }
    } else {
      {
#line 1195
      tmp = dd_Positive((__mpq_struct *)(temp));
      }
#line 1195
      if (tmp) {
#line 1196
        if (! posfound) {
#line 1197
          posfound = 1;
#line 1198
          cone->PosHead = Ptr;
#line 1199
          cone->PosLast = Ptr;
        } else {
#line 1202
          Ptr->Next = cone->PosHead;
#line 1203
          cone->PosHead = Ptr;
        }
      } else
#line 1207
      if (! zerofound) {
#line 1208
        zerofound = 1;
#line 1209
        cone->ZeroHead = Ptr;
#line 1210
        cone->ZeroLast = Ptr;
      } else {
#line 1213
        Ptr->Next = cone->ZeroHead;
#line 1214
        cone->ZeroHead = Ptr;
      }
    }
#line 1217
    Ptr = NextPtr;
  }
  while_break: /* CIL Label */ ;
  }
#line 1220
  if (negfound) {
#line 1221
    cone->FirstRay = cone->NegHead;
#line 1222
    if (posfound) {
#line 1223
      (cone->NegLast)->Next = cone->PosHead;
#line 1224
      if (zerofound) {
#line 1225
        (cone->PosLast)->Next = cone->ZeroHead;
#line 1226
        cone->LastRay = cone->ZeroLast;
      } else {
#line 1229
        cone->LastRay = cone->PosLast;
      }
    } else
#line 1233
    if (zerofound) {
#line 1234
      (cone->NegLast)->Next = cone->ZeroHead;
#line 1235
      cone->LastRay = cone->ZeroLast;
    } else {
#line 1238
      cone->LastRay = cone->NegLast;
    }
  } else
#line 1242
  if (posfound) {
#line 1243
    cone->FirstRay = cone->PosHead;
#line 1244
    if (zerofound) {
#line 1245
      (cone->PosLast)->Next = cone->ZeroHead;
#line 1246
      cone->LastRay = cone->ZeroLast;
    } else {
#line 1249
      cone->LastRay = cone->PosLast;
    }
  } else {
#line 1253
    cone->FirstRay = cone->ZeroHead;
#line 1254
    cone->LastRay = cone->ZeroLast;
  }
  {
#line 1256
  (cone->ArtificialRay)->Next = cone->FirstRay;
#line 1257
  (cone->LastRay)->Next = (dd_RayPtr )((void *)0);
#line 1258
  __gmpq_clear(temp);
#line 1258
  __gmpq_clear(tnext);
  }
  _L99: ;
#line 1260
  return;
}
}
#line 1262 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_DeleteNegativeRays(dd_ConePtr cone ) 
{ 
  dd_rowrange fii ;
  dd_rowrange fiitest ;
  mytype temp ;
  dd_RayPtr Ptr ;
  dd_RayPtr PrevPtr ;
  dd_RayPtr NextPtr ;
  dd_RayPtr ZeroPtr1 ;
  dd_RayPtr ZeroPtr0 ;
  dd_boolean found ;
  dd_boolean completed ;
  dd_boolean zerofound ;
  dd_boolean negfound ;
  dd_boolean posfound ;
  dd_boolean localdebug ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;
  dd_boolean tmp___1 ;

  {
  {
#line 1272
  zerofound = 0;
#line 1272
  negfound = 0;
#line 1272
  posfound = 0;
#line 1273
  localdebug = 0;
#line 1275
  __gmpq_init(temp);
#line 1276
  cone->PosHead = (dd_RayPtr )((void *)0);
#line 1276
  cone->ZeroHead = (dd_RayPtr )((void *)0);
#line 1276
  cone->NegHead = (dd_RayPtr )((void *)0);
#line 1277
  cone->PosLast = (dd_RayPtr )((void *)0);
#line 1277
  cone->ZeroLast = (dd_RayPtr )((void *)0);
#line 1277
  cone->NegLast = (dd_RayPtr )((void *)0);
#line 1280
  PrevPtr = cone->ArtificialRay;
#line 1281
  Ptr = cone->FirstRay;
  }
#line 1282
  if ((unsigned long )PrevPtr->Next != (unsigned long )Ptr) {
    {
#line 1283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error at dd_DeleteNegativeRays: ArtificialRay does not point the FirstRay.\n");
    }
  }
#line 1284
  completed = 0;
  {
#line 1285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1285
    if ((unsigned long )Ptr != (unsigned long )((void *)0)) {
#line 1285
      if (! (! completed)) {
#line 1285
        goto while_break;
      }
    } else {
#line 1285
      goto while_break;
    }
    {
#line 1287
    tmp = dd_Negative((__mpq_struct *)(Ptr->ARay));
    }
#line 1287
    if (tmp) {
      {
#line 1288
      dd_Eliminate(cone, & PrevPtr);
#line 1289
      Ptr = PrevPtr->Next;
      }
    } else {
#line 1292
      completed = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1297
  Ptr = cone->FirstRay;
#line 1298
  cone->ZeroRayCount = 0L;
  {
#line 1299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1299
    if (! ((unsigned long )Ptr != (unsigned long )((void *)0))) {
#line 1299
      goto while_break___0;
    }
    {
#line 1300
    NextPtr = Ptr->Next;
#line 1301
    __gmpq_set(temp, (mpq_srcptr )(Ptr->ARay));
    }
#line 1302
    if (localdebug) {
      {
#line 1302
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ptr->ARay :");
#line 1302
      dd_WriteNumber(stderr, (__mpq_struct *)(temp));
      }
    }
    {
#line 1304
    tmp___1 = dd_Negative((__mpq_struct *)(temp));
    }
#line 1304
    if (tmp___1) {
#line 1305
      if (! negfound) {
        {
#line 1306
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: An infeasible ray found after their removal\n");
#line 1307
        negfound = 1;
        }
      }
    } else {
      {
#line 1311
      tmp___0 = dd_Positive((__mpq_struct *)(temp));
      }
#line 1311
      if (tmp___0) {
#line 1312
        if (! posfound) {
#line 1313
          posfound = 1;
#line 1314
          cone->PosHead = Ptr;
#line 1315
          cone->PosLast = Ptr;
        } else {
#line 1318
          cone->PosLast = Ptr;
        }
      } else {
#line 1322
        (cone->ZeroRayCount) ++;
#line 1323
        if (! zerofound) {
#line 1324
          zerofound = 1;
#line 1325
          cone->ZeroHead = Ptr;
#line 1326
          cone->ZeroLast = Ptr;
#line 1327
          (cone->ZeroLast)->Next = (dd_RayPtr )((void *)0);
        } else {
#line 1330
          fii = Ptr->FirstInfeasIndex;
#line 1331
          found = 0;
#line 1332
          ZeroPtr1 = (dd_RayPtr )((void *)0);
#line 1333
          ZeroPtr0 = cone->ZeroHead;
          {
#line 1333
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1333
            if (! found) {
#line 1333
              if (! ((unsigned long )ZeroPtr0 != (unsigned long )((void *)0))) {
#line 1333
                goto while_break___1;
              }
            } else {
#line 1333
              goto while_break___1;
            }
#line 1334
            fiitest = ZeroPtr0->FirstInfeasIndex;
#line 1335
            if (fiitest >= fii) {
#line 1336
              found = 1;
            } else {
#line 1338
              ZeroPtr1 = ZeroPtr0;
            }
#line 1333
            ZeroPtr0 = ZeroPtr0->Next;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1341
          if (! found) {
#line 1342
            (cone->ZeroLast)->Next = Ptr;
#line 1343
            cone->ZeroLast = Ptr;
#line 1344
            (cone->ZeroLast)->Next = (dd_RayPtr )((void *)0);
          } else
#line 1347
          if ((unsigned long )ZeroPtr1 == (unsigned long )((void *)0)) {
#line 1349
            Ptr->Next = cone->ZeroHead;
#line 1350
            cone->ZeroHead = Ptr;
          } else {
#line 1354
            Ptr->Next = ZeroPtr1->Next;
#line 1355
            ZeroPtr1->Next = Ptr;
          }
        }
      }
    }
#line 1364
    Ptr = NextPtr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1367
  if (posfound) {
#line 1368
    cone->FirstRay = cone->PosHead;
#line 1369
    if (zerofound) {
#line 1370
      (cone->PosLast)->Next = cone->ZeroHead;
#line 1371
      cone->LastRay = cone->ZeroLast;
    } else {
#line 1374
      cone->LastRay = cone->PosLast;
    }
  } else {
#line 1378
    cone->FirstRay = cone->ZeroHead;
#line 1379
    cone->LastRay = cone->ZeroLast;
  }
  {
#line 1381
  (cone->ArtificialRay)->Next = cone->FirstRay;
#line 1382
  (cone->LastRay)->Next = (dd_RayPtr )((void *)0);
#line 1383
  __gmpq_clear(temp);
  }
#line 1384
  return;
}
}
#line 1386 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_FeasibilityIndices(long *fnum , long *infnum , dd_rowrange i , dd_ConePtr cone ) 
{ 
  dd_colrange j ;
  mytype temp ;
  mytype tnext ;
  dd_RayPtr Ptr ;
  dd_boolean tmp ;

  {
  {
#line 1394
  __gmpq_init(temp);
#line 1394
  __gmpq_init(tnext);
#line 1395
  *fnum = 0L;
#line 1396
  *infnum = 0L;
#line 1397
  Ptr = cone->FirstRay;
  }
  {
#line 1398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1398
    if (! ((unsigned long )Ptr != (unsigned long )((void *)0))) {
#line 1398
      goto while_break;
    }
    {
#line 1399
    __gmpq_set(temp, (mpq_srcptr )(dd_purezero));
#line 1400
    j = (dd_colrange )0;
    }
    {
#line 1400
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1400
      if (! (j < cone->d)) {
#line 1400
        goto while_break___0;
      }
      {
#line 1401
      __gmpq_mul(tnext, (mpq_srcptr )(*(*(cone->A + (i - 1L)) + j)), (mpq_srcptr )(*(Ptr->Ray + j)));
#line 1402
      __gmpq_add(temp, (mpq_srcptr )(temp), (mpq_srcptr )(tnext));
#line 1400
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1404
    tmp = dd_Nonnegative((__mpq_struct *)(temp));
    }
#line 1404
    if (tmp) {
#line 1405
      (*fnum) ++;
    } else {
#line 1407
      (*infnum) ++;
    }
#line 1408
    Ptr = Ptr->Next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1410
  __gmpq_clear(temp);
#line 1410
  __gmpq_clear(tnext);
  }
#line 1411
  return;
}
}
#line 1413 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_boolean dd_LexSmaller(mytype *v1 , mytype *v2 , long dmax ) 
{ 
  dd_boolean determined ;
  dd_boolean smaller ;
  dd_colrange j ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;

  {
#line 1418
  smaller = 0;
#line 1419
  determined = 0;
#line 1420
  j = (dd_colrange )1;
  {
#line 1421
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1422
    tmp___0 = dd_Equal((__mpq_struct *)(*(v1 + (j - 1L))), (__mpq_struct *)(*(v2 + (j - 1L))));
    }
#line 1422
    if (tmp___0) {
#line 1428
      j ++;
    } else {
      {
#line 1423
      tmp = dd_Smaller((__mpq_struct *)(*(v1 + (j - 1L))), (__mpq_struct *)(*(v2 + (j - 1L))));
      }
#line 1423
      if (tmp) {
#line 1424
        smaller = 1;
      }
#line 1426
      determined = 1;
    }
#line 1421
    if (! determined) {
#line 1421
      if (! (j <= dmax)) {
#line 1421
        goto while_break;
      }
    } else {
#line 1421
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1430
  return (smaller);
}
}
#line 1434 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_boolean dd_LexLarger(mytype *v1 , mytype *v2 , long dmax ) 
{ 
  dd_boolean tmp ;

  {
  {
#line 1436
  tmp = dd_LexSmaller(v2, v1, dmax);
  }
#line 1436
  return (tmp);
}
}
#line 1439 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_boolean dd_LexEqual(mytype *v1 , mytype *v2 , long dmax ) 
{ 
  dd_boolean determined ;
  dd_boolean equal ;
  dd_colrange j ;
  dd_boolean tmp ;

  {
#line 1444
  equal = 1;
#line 1445
  determined = 0;
#line 1446
  j = (dd_colrange )1;
  {
#line 1447
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1448
    tmp = dd_Equal((__mpq_struct *)(*(v1 + (j - 1L))), (__mpq_struct *)(*(v2 + (j - 1L))));
    }
#line 1448
    if (tmp) {
#line 1452
      j ++;
    } else {
#line 1449
      equal = 0;
#line 1450
      determined = 1;
    }
#line 1447
    if (! determined) {
#line 1447
      if (! (j <= dmax)) {
#line 1447
        goto while_break;
      }
    } else {
#line 1447
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1455
  return (equal);
}
}
#line 1458 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_AddNewHalfspace1(dd_ConePtr cone , dd_rowrange hnew ) 
{ 
  dd_RayPtr RayPtr0 ;
  dd_RayPtr RayPtr1 ;
  dd_RayPtr RayPtr2 ;
  dd_RayPtr RayPtr2s ;
  dd_RayPtr RayPtr3 ;
  long pos1 ;
  long pos2 ;
  double prevprogress ;
  double progress ;
  mytype value1 ;
  mytype value2 ;
  dd_boolean adj ;
  dd_boolean equal ;
  dd_boolean completed ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;
  dd_boolean tmp___1 ;
  dd_boolean tmp___2 ;
  dd_boolean tmp___3 ;
  dd_boolean tmp___4 ;
  dd_boolean tmp___5 ;

  {
  {
#line 1473
  __gmpq_init(value1);
#line 1473
  __gmpq_init(value2);
#line 1474
  dd_EvaluateARay1(hnew, cone);
#line 1478
  RayPtr0 = cone->ArtificialRay;
#line 1479
  RayPtr1 = cone->FirstRay;
#line 1480
  __gmpq_set(value1, (mpq_srcptr )((cone->FirstRay)->ARay));
#line 1481
  tmp___0 = dd_Nonnegative((__mpq_struct *)(value1));
  }
#line 1481
  if (tmp___0) {
#line 1482
    if (cone->RayCount == cone->WeaklyFeasibleRayCount) {
#line 1482
      cone->CompStatus = (dd_CompStatusType )1;
    }
#line 1483
    goto _L99;
  } else {
#line 1486
    RayPtr2s = RayPtr1->Next;
#line 1487
    pos2 = 1L;
    {
#line 1488
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1488
      if ((unsigned long )RayPtr2s != (unsigned long )((void *)0)) {
        {
#line 1488
        tmp = dd_Negative((__mpq_struct *)(RayPtr2s->ARay));
        }
#line 1488
        if (! tmp) {
#line 1488
          goto while_break;
        }
      } else {
#line 1488
        goto while_break;
      }
#line 1489
      RayPtr2s = RayPtr2s->Next;
#line 1490
      pos2 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1493
  if ((unsigned long )RayPtr2s == (unsigned long )((void *)0)) {
#line 1494
    cone->FirstRay = (dd_RayPtr )((void *)0);
#line 1495
    (cone->ArtificialRay)->Next = cone->FirstRay;
#line 1496
    cone->RayCount = 0L;
#line 1497
    cone->CompStatus = (dd_CompStatusType )1;
#line 1498
    goto _L99;
  }
#line 1500
  RayPtr2 = RayPtr2s;
#line 1501
  RayPtr3 = cone->LastRay;
#line 1502
  prevprogress = - 10.0;
#line 1503
  pos1 = 1L;
#line 1504
  completed = 0;
  {
#line 1505
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1505
    if ((unsigned long )RayPtr1 != (unsigned long )RayPtr2s) {
#line 1505
      if (! (! completed)) {
#line 1505
        goto while_break___0;
      }
    } else {
#line 1505
      goto while_break___0;
    }
    {
#line 1506
    __gmpq_set(value1, (mpq_srcptr )(RayPtr1->ARay));
#line 1507
    __gmpq_set(value2, (mpq_srcptr )(RayPtr2->ARay));
#line 1508
    dd_CheckEquality(cone->d, & RayPtr1, & RayPtr2, & equal);
#line 1509
    tmp___1 = dd_Positive((__mpq_struct *)(value1));
    }
#line 1509
    if (tmp___1) {
      {
#line 1509
      tmp___2 = dd_Negative((__mpq_struct *)(value2));
      }
#line 1509
      if (tmp___2) {
#line 1509
        goto _L;
      } else {
#line 1509
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 1509
      tmp___3 = dd_Negative((__mpq_struct *)(value1));
      }
#line 1509
      if (tmp___3) {
        {
#line 1509
        tmp___4 = dd_Positive((__mpq_struct *)(value2));
        }
#line 1509
        if (tmp___4) {
          _L: /* CIL Label */ 
          {
#line 1510
          dd_CheckAdjacency(cone, & RayPtr1, & RayPtr2, & adj);
          }
#line 1511
          if (adj) {
            {
#line 1511
            dd_CreateNewRay(cone, RayPtr1, RayPtr2, hnew);
            }
          }
        }
      }
    }
#line 1513
    if ((unsigned long )RayPtr2 != (unsigned long )RayPtr3) {
#line 1514
      RayPtr2 = RayPtr2->Next;
#line 1515
      goto while_continue___0;
    }
    {
#line 1517
    tmp___5 = dd_Negative((__mpq_struct *)(value1));
    }
#line 1517
    if (tmp___5) {
      {
#line 1518
      dd_Eliminate(cone, & RayPtr0);
#line 1519
      RayPtr1 = RayPtr0->Next;
#line 1520
      RayPtr2 = RayPtr2s;
      }
    } else
#line 1517
    if (equal) {
      {
#line 1518
      dd_Eliminate(cone, & RayPtr0);
#line 1519
      RayPtr1 = RayPtr0->Next;
#line 1520
      RayPtr2 = RayPtr2s;
      }
    } else {
#line 1522
      completed = 1;
    }
#line 1524
    pos1 ++;
#line 1525
    progress = ((100.0 * ((double )pos1 / (double )pos2)) * (2.0 * (double )pos2 - (double )pos1)) / (double )pos2;
#line 1526
    if (progress - prevprogress >= (double )10) {
#line 1526
      if (pos1 % 10L == 0L) {
#line 1526
        if (dd_debug) {
          {
#line 1527
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*Progress of iteration %5ld(/%ld):   %4ld/%4ld => %4.1f%% done\n",
                  cone->Iteration, cone->m, pos1, pos2, progress);
#line 1529
          prevprogress = progress;
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1532
  if (cone->RayCount == cone->WeaklyFeasibleRayCount) {
#line 1532
    cone->CompStatus = (dd_CompStatusType )1;
  }
  _L99: 
  {
#line 1534
  __gmpq_clear(value1);
#line 1534
  __gmpq_clear(value2);
  }
#line 1535
  return;
}
}
#line 1537 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_AddNewHalfspace2(dd_ConePtr cone , dd_rowrange hnew ) 
{ 
  dd_RayPtr RayPtr0 ;
  dd_RayPtr RayPtr1 ;
  dd_RayPtr RayPtr2 ;
  dd_AdjacencyType *EdgePtr ;
  dd_AdjacencyType *EdgePtr0 ;
  long pos1 ;
  dd_rowrange fii1 ;
  dd_rowrange fii2 ;
  dd_boolean localdebug ;

  {
  {
#line 1544
  localdebug = 0;
#line 1546
  dd_EvaluateARay2(hnew, cone);
  }
#line 1550
  if ((unsigned long )cone->PosHead == (unsigned long )((void *)0)) {
#line 1550
    if ((unsigned long )cone->ZeroHead == (unsigned long )((void *)0)) {
#line 1551
      cone->FirstRay = (dd_RayPtr )((void *)0);
#line 1552
      (cone->ArtificialRay)->Next = cone->FirstRay;
#line 1553
      cone->RayCount = 0L;
#line 1554
      cone->CompStatus = (dd_CompStatusType )1;
#line 1555
      goto _L99;
    }
  }
#line 1558
  if (localdebug) {
    {
#line 1559
    pos1 = 0L;
#line 1560
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(pos, FirstInfeasIndex, A Ray)=\n");
#line 1561
    RayPtr0 = cone->FirstRay;
    }
    {
#line 1561
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1561
      if (! ((unsigned long )RayPtr0 != (unsigned long )((void *)0))) {
#line 1561
        goto while_break;
      }
      {
#line 1562
      pos1 ++;
#line 1563
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(%ld,%ld,",
              pos1, RayPtr0->FirstInfeasIndex);
#line 1564
      dd_WriteNumber(stderr, (__mpq_struct *)(RayPtr0->ARay));
#line 1565
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)") ");
#line 1561
      RayPtr0 = RayPtr0->Next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1567
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 1570
  if ((unsigned long )cone->ZeroHead == (unsigned long )((void *)0)) {
#line 1570
    cone->ZeroHead = cone->LastRay;
  }
#line 1572
  EdgePtr = *(cone->Edges + cone->Iteration);
  {
#line 1573
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1573
    if (! ((unsigned long )EdgePtr != (unsigned long )((void *)0))) {
#line 1573
      goto while_break___0;
    }
    {
#line 1574
    RayPtr1 = EdgePtr->Ray1;
#line 1575
    RayPtr2 = EdgePtr->Ray2;
#line 1576
    fii1 = RayPtr1->FirstInfeasIndex;
#line 1577
    dd_CreateNewRay(cone, RayPtr1, RayPtr2, hnew);
#line 1578
    fii2 = (cone->LastRay)->FirstInfeasIndex;
    }
#line 1579
    if (fii1 != fii2) {
      {
#line 1580
      dd_ConditionalAddEdge(cone, RayPtr1, cone->LastRay, cone->PosHead);
      }
    }
    {
#line 1581
    EdgePtr0 = EdgePtr;
#line 1582
    EdgePtr = EdgePtr->Next;
#line 1583
    free((void *)EdgePtr0);
#line 1584
    (cone->EdgeCount) --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1586
  *(cone->Edges + cone->Iteration) = (dd_AdjacencyType *)((void *)0);
#line 1588
  dd_DeleteNegativeRays(cone);
#line 1590
  set_addelem(cone->AddedHalfspaces, hnew);
  }
#line 1592
  if (cone->Iteration < cone->m) {
#line 1593
    if ((unsigned long )cone->ZeroHead != (unsigned long )((void *)0)) {
#line 1593
      if ((unsigned long )cone->ZeroHead != (unsigned long )cone->LastRay) {
#line 1594
        if (cone->ZeroRayCount > 200L) {
#line 1594
          if (dd_debug) {
            {
#line 1594
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*New edges being scanned...\n");
            }
          }
        }
        {
#line 1595
        dd_UpdateEdges(cone, cone->ZeroHead, cone->LastRay);
        }
      }
    }
  }
#line 1599
  if (cone->RayCount == cone->WeaklyFeasibleRayCount) {
#line 1599
    cone->CompStatus = (dd_CompStatusType )1;
  }
  _L99: ;
#line 1601
  return;
}
}
#line 1604 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_SelectNextHalfspace0(dd_ConePtr cone , dd_rowset excluded , dd_rowrange *hnext ) 
{ 
  long i ;
  dd_boolean determined ;
  int tmp ;

  {
#line 1610
  i = cone->m;
#line 1611
  determined = 0;
  {
#line 1612
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1613
    tmp = set_member(i, excluded);
    }
#line 1613
    if (tmp) {
#line 1614
      i --;
    } else {
#line 1616
      determined = 1;
    }
#line 1612
    if (! determined) {
#line 1612
      if (! (i >= 1L)) {
#line 1612
        goto while_break;
      }
    } else {
#line 1612
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1618
  if (determined) {
#line 1619
    *hnext = i;
  } else {
#line 1621
    *hnext = (dd_rowrange )0;
  }
#line 1622
  return;
}
}
#line 1624 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_SelectNextHalfspace1(dd_ConePtr cone , dd_rowset excluded , dd_rowrange *hnext ) 
{ 
  long i ;
  dd_boolean determined ;
  int tmp ;

  {
#line 1630
  i = 1L;
#line 1631
  determined = 0;
  {
#line 1632
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1633
    tmp = set_member(i, excluded);
    }
#line 1633
    if (tmp) {
#line 1634
      i ++;
    } else {
#line 1636
      determined = 1;
    }
#line 1632
    if (! determined) {
#line 1632
      if (! (i <= cone->m)) {
#line 1632
        goto while_break;
      }
    } else {
#line 1632
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1638
  if (determined) {
#line 1639
    *hnext = i;
  } else {
#line 1641
    *hnext = (dd_rowrange )0;
  }
#line 1642
  return;
}
}
#line 1644 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_SelectNextHalfspace2(dd_ConePtr cone , dd_rowset excluded , dd_rowrange *hnext ) 
{ 
  long i ;
  long fea ;
  long inf ;
  long infmin ;
  long fi ;
  int tmp ;

  {
#line 1647
  fi = 0L;
#line 1649
  infmin = cone->RayCount + 1L;
#line 1650
  i = 1L;
  {
#line 1650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1650
    if (! (i <= cone->m)) {
#line 1650
      goto while_break;
    }
    {
#line 1651
    tmp = set_member(i, excluded);
    }
#line 1651
    if (! tmp) {
      {
#line 1652
      dd_FeasibilityIndices(& fea, & inf, i, cone);
      }
#line 1653
      if (inf < infmin) {
#line 1654
        infmin = inf;
#line 1655
        fi = fea;
#line 1656
        *hnext = i;
      }
    }
#line 1650
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1660
  if (dd_debug) {
    {
#line 1661
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*infeasible rays (min) =%5ld, #feas rays =%5ld\n",
            infmin, fi);
    }
  }
#line 1663
  return;
}
}
#line 1665 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_SelectNextHalfspace3(dd_ConePtr cone , dd_rowset excluded , dd_rowrange *hnext ) 
{ 
  long i ;
  long fea ;
  long inf ;
  long infmax ;
  long fi ;
  dd_boolean localdebug ;
  int tmp ;

  {
#line 1668
  fi = 0L;
#line 1669
  localdebug = dd_debug;
#line 1671
  infmax = -1L;
#line 1672
  i = 1L;
  {
#line 1672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1672
    if (! (i <= cone->m)) {
#line 1672
      goto while_break;
    }
    {
#line 1673
    tmp = set_member(i, excluded);
    }
#line 1673
    if (! tmp) {
      {
#line 1674
      dd_FeasibilityIndices(& fea, & inf, i, cone);
      }
#line 1675
      if (inf > infmax) {
#line 1676
        infmax = inf;
#line 1677
        fi = fea;
#line 1678
        *hnext = i;
      }
    }
#line 1672
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1682
  if (localdebug) {
    {
#line 1683
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*infeasible rays (max) =%5ld, #feas rays =%5ld\n",
            infmax, fi);
    }
  }
#line 1685
  return;
}
}
#line 1687 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_SelectNextHalfspace4(dd_ConePtr cone , dd_rowset excluded , dd_rowrange *hnext ) 
{ 
  long i ;
  long fea ;
  long inf ;
  long max ;
  long tmax ;
  long fi ;
  long infi ;
  int tmp ;

  {
#line 1690
  fi = 0L;
#line 1690
  infi = 0L;
#line 1693
  max = -1L;
#line 1694
  i = 1L;
  {
#line 1694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1694
    if (! (i <= cone->m)) {
#line 1694
      goto while_break;
    }
    {
#line 1695
    tmp = set_member(i, excluded);
    }
#line 1695
    if (! tmp) {
      {
#line 1696
      dd_FeasibilityIndices(& fea, & inf, i, cone);
      }
#line 1697
      if (fea <= inf) {
#line 1698
        tmax = inf;
      } else {
#line 1700
        tmax = fea;
      }
#line 1701
      if (tmax > max) {
#line 1702
        max = tmax;
#line 1703
        fi = fea;
#line 1704
        infi = inf;
#line 1705
        *hnext = i;
      }
    }
#line 1694
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1709
  if (! dd_debug) {
#line 1710
    return;
  }
#line 1711
  if (max == fi) {
    {
#line 1712
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*infeasible rays (min) =%5ld, #feas rays =%5ld\n",
            infi, fi);
    }
  } else {
    {
#line 1714
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*infeasible rays (max) =%5ld, #feas rays =%5ld\n",
            infi, fi);
    }
  }
#line 1716
  return;
}
}
#line 1718 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_SelectNextHalfspace5(dd_ConePtr cone , dd_rowset excluded , dd_rowrange *hnext ) 
{ 
  long i ;
  long minindex ;
  mytype *v1 ;
  mytype *v2 ;
  dd_boolean tmp ;
  int tmp___0 ;

  {
#line 1724
  minindex = 0L;
#line 1725
  v1 = (mytype *)((void *)0);
#line 1726
  i = 1L;
  {
#line 1726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1726
    if (! (i <= cone->m)) {
#line 1726
      goto while_break;
    }
    {
#line 1727
    tmp___0 = set_member(i, excluded);
    }
#line 1727
    if (! tmp___0) {
#line 1728
      v2 = *(cone->A + (i - 1L));
#line 1729
      if (minindex == 0L) {
#line 1730
        minindex = i;
#line 1731
        v1 = v2;
      } else {
        {
#line 1732
        tmp = dd_LexSmaller(v2, v1, cone->d);
        }
#line 1732
        if (tmp) {
#line 1733
          minindex = i;
#line 1734
          v1 = v2;
        }
      }
    }
#line 1726
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1738
  *hnext = minindex;
#line 1739
  return;
}
}
#line 1742 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_SelectNextHalfspace6(dd_ConePtr cone , dd_rowset excluded , dd_rowrange *hnext ) 
{ 
  long i ;
  long maxindex ;
  mytype *v1 ;
  mytype *v2 ;
  dd_boolean tmp ;
  int tmp___0 ;

  {
#line 1748
  maxindex = 0L;
#line 1749
  v1 = (mytype *)((void *)0);
#line 1750
  i = 1L;
  {
#line 1750
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1750
    if (! (i <= cone->m)) {
#line 1750
      goto while_break;
    }
    {
#line 1751
    tmp___0 = set_member(i, excluded);
    }
#line 1751
    if (! tmp___0) {
#line 1752
      v2 = *(cone->A + (i - 1L));
#line 1753
      if (maxindex == 0L) {
#line 1754
        maxindex = i;
#line 1755
        v1 = v2;
      } else {
        {
#line 1756
        tmp = dd_LexLarger(v2, v1, cone->d);
        }
#line 1756
        if (tmp) {
#line 1757
          maxindex = i;
#line 1758
          v1 = v2;
        }
      }
    }
#line 1750
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1762
  *hnext = maxindex;
#line 1763
  return;
}
}
#line 1765 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_UniqueRows(dd_rowindex OV , long p , long r , dd_Amatrix A , long dmax , dd_rowset preferred ,
                   long *uniqrows ) 
{ 
  long i ;
  long iuniq ;
  long j ;
  mytype *x ;
  dd_boolean localdebug ;
  int tmp ;
  int tmp___0 ;
  dd_boolean tmp___1 ;

  {
#line 1777
  localdebug = 0;
#line 1779
  if (p <= 0L) {
#line 1779
    goto _L99;
  } else
#line 1779
  if (p > r) {
#line 1779
    goto _L99;
  }
#line 1780
  iuniq = p;
#line 1780
  j = 1L;
#line 1781
  x = *(A + (p - 1L));
#line 1782
  *(OV + p) = j;
#line 1783
  i = p + 1L;
  {
#line 1783
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1783
    if (! (i <= r)) {
#line 1783
      goto while_break;
    }
    {
#line 1784
    tmp___1 = dd_LexEqual(x, *(A + (i - 1L)), dmax);
    }
#line 1784
    if (tmp___1) {
      {
#line 1792
      tmp = set_member(i, preferred);
      }
#line 1792
      if (tmp) {
        {
#line 1792
        tmp___0 = set_member(iuniq, preferred);
        }
#line 1792
        if (tmp___0) {
#line 1798
          *(OV + i) = - iuniq;
        } else {
#line 1793
          *(OV + iuniq) = - i;
#line 1794
          iuniq = i;
#line 1795
          *(OV + i) = j;
#line 1796
          x = *(A + (i - 1L));
        }
      } else {
#line 1798
        *(OV + i) = - iuniq;
      }
    } else {
#line 1786
      iuniq = i;
#line 1787
      j ++;
#line 1788
      *(OV + i) = j;
#line 1789
      x = *(A + (i - 1L));
    }
#line 1783
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1802
  *uniqrows = j;
#line 1803
  if (localdebug) {
    {
#line 1804
    printf((char const   */* __restrict  */)"The number of unique rows are %ld\n with order vector",
           *uniqrows);
#line 1805
    i = p;
    }
    {
#line 1805
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1805
      if (! (i <= r)) {
#line 1805
        goto while_break___0;
      }
      {
#line 1806
      printf((char const   */* __restrict  */)" %ld:%ld ", i, *(OV + i));
#line 1805
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1808
    printf((char const   */* __restrict  */)"\n");
    }
  }
  _L99: ;
#line 1811
  return;
}
}
#line 1813 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
long dd_Partition(dd_rowindex OV , long p , long r , dd_Amatrix A , long dmax ) 
{ 
  mytype *x ;
  long i ;
  long j ;
  long ovi ;
  dd_boolean tmp ;
  dd_boolean tmp___0 ;

  {
#line 1818
  x = *(A + (*(OV + p) - 1L));
#line 1820
  i = p - 1L;
#line 1821
  j = r + 1L;
  {
#line 1822
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1823
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1824
      j --;
#line 1823
      tmp = dd_LexLarger(*(A + (*(OV + j) - 1L)), x, dmax);
      }
#line 1823
      if (! tmp) {
#line 1823
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1826
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1827
      i ++;
#line 1826
      tmp___0 = dd_LexSmaller(*(A + (*(OV + i) - 1L)), x, dmax);
      }
#line 1826
      if (! tmp___0) {
#line 1826
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1829
    if (i < j) {
#line 1830
      ovi = *(OV + i);
#line 1831
      *(OV + i) = *(OV + j);
#line 1832
      *(OV + j) = ovi;
    } else {
#line 1835
      return (j);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1840 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_QuickSort(dd_rowindex OV , long p , long r , dd_Amatrix A , long dmax ) 
{ 
  long q ;

  {
#line 1844
  if (p < r) {
    {
#line 1845
    q = dd_Partition(OV, p, r, A, dmax);
#line 1846
    dd_QuickSort(OV, p, q, A, dmax);
#line 1847
    dd_QuickSort(OV, q + 1L, r, A, dmax);
    }
  }
#line 1849
  return;
}
}
#line 1856 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_RandomPermutation(dd_rowindex OV , long t , unsigned int seed ) 
{ 
  long k ;
  long j ;
  long ovj ;
  double u ;
  double xk ;
  double r ;
  double rand_max ;
  dd_boolean localdebug ;
  int tmp ;

  {
  {
#line 1859
  rand_max = (double )2147483647;
#line 1860
  localdebug = 0;
#line 1862
  srand(seed);
#line 1863
  j = t;
  }
  {
#line 1863
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1863
    if (! (j > 1L)) {
#line 1863
      goto while_break;
    }
    {
#line 1864
    tmp = rand();
#line 1864
    r = (double )tmp;
#line 1865
    u = r / rand_max;
#line 1866
    xk = (double )j * u + (double )1;
#line 1867
    k = (long )xk;
    }
#line 1868
    if (localdebug) {
      {
#line 1868
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"u=%g, k=%ld, r=%g, randmax= %g\n",
              u, k, r, rand_max);
      }
    }
#line 1869
    ovj = *(OV + j);
#line 1870
    *(OV + j) = *(OV + k);
#line 1871
    *(OV + k) = ovj;
#line 1872
    if (localdebug) {
      {
#line 1872
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"row %ld is exchanged with %ld\n",
              j, k);
      }
    }
#line 1863
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1874
  return;
}
}
#line 1876 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_ComputeRowOrderVector(dd_ConePtr cone ) 
{ 
  long i ;
  long itemp ;

  {
#line 1880
  *(cone->OrderVector + 0) = 0L;
  {
#line 1882
  if ((unsigned int )cone->HalfspaceOrder == 0U) {
#line 1882
    goto case_0;
  }
#line 1886
  if ((unsigned int )cone->HalfspaceOrder == 1U) {
#line 1886
    goto case_1;
  }
#line 1890
  if ((unsigned int )cone->HalfspaceOrder == 3U) {
#line 1890
    goto case_3;
  }
#line 1890
  if ((unsigned int )cone->HalfspaceOrder == 4U) {
#line 1890
    goto case_3;
  }
#line 1890
  if ((unsigned int )cone->HalfspaceOrder == 2U) {
#line 1890
    goto case_3;
  }
#line 1890
  if ((unsigned int )cone->HalfspaceOrder == 5U) {
#line 1890
    goto case_3;
  }
#line 1896
  if ((unsigned int )cone->HalfspaceOrder == 6U) {
#line 1896
    goto case_6;
  }
#line 1907
  if ((unsigned int )cone->HalfspaceOrder == 7U) {
#line 1907
    goto case_7;
  }
#line 1881
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1883
  i = 1L;
  {
#line 1883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1883
    if (! (i <= cone->m)) {
#line 1883
      goto while_break;
    }
#line 1883
    *(cone->OrderVector + i) = (cone->m - i) + 1L;
#line 1883
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1884
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1887
  i = 1L;
  {
#line 1887
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1887
    if (! (i <= cone->m)) {
#line 1887
      goto while_break___0;
    }
#line 1887
    *(cone->OrderVector + i) = i;
#line 1887
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1888
  goto switch_break;
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1891
  i = 1L;
  {
#line 1891
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1891
    if (! (i <= cone->m)) {
#line 1891
      goto while_break___1;
    }
#line 1891
    *(cone->OrderVector + i) = i;
#line 1891
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1892
  dd_RandomPermutation(cone->OrderVector, cone->m, cone->rseed);
#line 1893
  dd_QuickSort(cone->OrderVector, 1L, cone->m, cone->A, cone->d);
  }
#line 1894
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1897
  i = 1L;
  {
#line 1897
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1897
    if (! (i <= cone->m)) {
#line 1897
      goto while_break___2;
    }
#line 1897
    *(cone->OrderVector + i) = i;
#line 1897
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1898
  dd_RandomPermutation(cone->OrderVector, cone->m, cone->rseed);
#line 1899
  dd_QuickSort(cone->OrderVector, 1L, cone->m, cone->A, cone->d);
#line 1900
  i = 1L;
  }
  {
#line 1900
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1900
    if (! (i <= cone->m / 2L)) {
#line 1900
      goto while_break___3;
    }
#line 1901
    itemp = *(cone->OrderVector + i);
#line 1902
    *(cone->OrderVector + i) = *(cone->OrderVector + ((cone->m - i) + 1L));
#line 1903
    *(cone->OrderVector + ((cone->m - i) + 1L)) = itemp;
#line 1900
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1905
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1908
  i = 1L;
  {
#line 1908
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1908
    if (! (i <= cone->m)) {
#line 1908
      goto while_break___4;
    }
#line 1908
    *(cone->OrderVector + i) = i;
#line 1908
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1909
  dd_RandomPermutation(cone->OrderVector, cone->m, cone->rseed);
  }
#line 1910
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1913
  return;
}
}
#line 1915 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_UpdateRowOrderVector(dd_ConePtr cone , dd_rowset PriorityRows ) 
{ 
  dd_rowrange i ;
  dd_rowrange j ;
  dd_rowrange k ;
  dd_rowrange j1___0 ;
  dd_rowrange oj ;
  long rr ;
  dd_boolean found ;
  dd_boolean localdebug ;
  int tmp ;

  {
#line 1920
  j1___0 = (dd_rowrange )0;
#line 1920
  oj = (dd_rowrange )0;
#line 1922
  localdebug = 0;
#line 1924
  if (dd_debug) {
#line 1924
    localdebug = 1;
  }
  {
#line 1925
  found = 1;
#line 1926
  rr = set_card(PriorityRows);
  }
#line 1927
  if (localdebug) {
    {
#line 1927
    set_fwrite(stderr, PriorityRows);
    }
  }
#line 1928
  i = (dd_rowrange )1;
  {
#line 1928
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1928
    if (! (i <= rr)) {
#line 1928
      goto while_break;
    }
#line 1929
    found = 0;
#line 1930
    j = i;
    {
#line 1930
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1930
      if (j <= cone->m) {
#line 1930
        if (! (! found)) {
#line 1930
          goto while_break___0;
        }
      } else {
#line 1930
        goto while_break___0;
      }
      {
#line 1931
      oj = *(cone->OrderVector + j);
#line 1932
      tmp = set_member(oj, PriorityRows);
      }
#line 1932
      if (tmp) {
#line 1933
        found = 1;
#line 1934
        if (localdebug) {
          {
#line 1934
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ldth in sorted list (row %ld) is in PriorityRows\n",
                  j, oj);
          }
        }
#line 1935
        j1___0 = j;
      }
#line 1930
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1938
    if (found) {
#line 1939
      if (j1___0 > i) {
#line 1941
        k = j1___0;
        {
#line 1941
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1941
          if (! (k >= i)) {
#line 1941
            goto while_break___1;
          }
#line 1941
          *(cone->OrderVector + k) = *(cone->OrderVector + (k - 1L));
#line 1941
          k --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1942
        *(cone->OrderVector + i) = oj;
#line 1943
        if (localdebug) {
          {
#line 1944
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"OrderVector updated to:\n");
#line 1945
          j = (dd_rowrange )1;
          }
          {
#line 1945
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1945
            if (! (j <= cone->m)) {
#line 1945
              goto while_break___2;
            }
            {
#line 1945
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %2ld",
                    *(cone->OrderVector + j));
#line 1945
            j ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1946
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
          }
        }
      }
    } else {
      {
#line 1950
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"UpdateRowOrder: Error.\n");
      }
#line 1951
      goto _L99;
    }
#line 1928
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 1955
  return;
}
}
#line 1957 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_SelectPreorderedNext(dd_ConePtr cone , dd_rowset excluded , dd_rowrange *hh ) 
{ 
  dd_rowrange i ;
  dd_rowrange k ;
  int tmp ;

  {
#line 1961
  *hh = (dd_rowrange )0;
#line 1962
  i = (dd_rowrange )1;
  {
#line 1962
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1962
    if (i <= cone->m) {
#line 1962
      if (! (*hh == 0L)) {
#line 1962
        goto while_break;
      }
    } else {
#line 1962
      goto while_break;
    }
    {
#line 1963
    k = *(cone->OrderVector + i);
#line 1964
    tmp = set_member(k, excluded);
    }
#line 1964
    if (! tmp) {
#line 1964
      *hh = k;
    }
#line 1962
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1966
  return;
}
}
#line 1968 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_SelectNextHalfspace(dd_ConePtr cone , dd_rowset excluded , dd_rowrange *hh ) 
{ 


  {
#line 1970
  if (cone->PreOrderedRun) {
#line 1971
    if (dd_debug) {
      {
#line 1972
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"debug dd_SelectNextHalfspace: Use PreorderNext\n");
      }
    }
    {
#line 1974
    dd_SelectPreorderedNext(cone, excluded, hh);
    }
  } else {
#line 1977
    if (dd_debug) {
      {
#line 1978
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"debug dd_SelectNextHalfspace: Use DynamicOrderedNext\n");
      }
    }
    {
#line 1983
    if ((unsigned int )cone->HalfspaceOrder == 0U) {
#line 1983
      goto case_0;
    }
#line 1987
    if ((unsigned int )cone->HalfspaceOrder == 1U) {
#line 1987
      goto case_1;
    }
#line 1991
    if ((unsigned int )cone->HalfspaceOrder == 2U) {
#line 1991
      goto case_2;
    }
#line 1995
    if ((unsigned int )cone->HalfspaceOrder == 3U) {
#line 1995
      goto case_3;
    }
#line 1999
    if ((unsigned int )cone->HalfspaceOrder == 4U) {
#line 1999
      goto case_4;
    }
#line 2003
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1984
    dd_SelectNextHalfspace0(cone, excluded, hh);
    }
#line 1985
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1988
    dd_SelectNextHalfspace1(cone, excluded, hh);
    }
#line 1989
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1992
    dd_SelectNextHalfspace2(cone, excluded, hh);
    }
#line 1993
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1996
    dd_SelectNextHalfspace3(cone, excluded, hh);
    }
#line 1997
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 2000
    dd_SelectNextHalfspace4(cone, excluded, hh);
    }
#line 2001
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2004
    dd_SelectNextHalfspace0(cone, excluded, hh);
    }
#line 2005
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2008
  return;
}
}
#line 2010 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_boolean dd_Nonnegative(__mpq_struct *val ) 
{ 
  int tmp ;

  {
  {
#line 2013
  tmp = __gmpq_cmp((mpq_srcptr )val, (mpq_srcptr )(dd_minuszero));
  }
#line 2013
  if (tmp >= 0) {
#line 2013
    return (1);
  } else {
#line 2014
    return (0);
  }
}
}
#line 2017 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_boolean dd_Nonpositive(__mpq_struct *val ) 
{ 
  int tmp ;

  {
  {
#line 2020
  tmp = __gmpq_cmp((mpq_srcptr )val, (mpq_srcptr )(dd_zero));
  }
#line 2020
  if (tmp <= 0) {
#line 2020
    return (1);
  } else {
#line 2021
    return (0);
  }
}
}
#line 2024 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_boolean dd_Positive(__mpq_struct *val ) 
{ 
  dd_boolean tmp ;
  int tmp___0 ;

  {
  {
#line 2026
  tmp = dd_Nonpositive(val);
  }
#line 2026
  if (tmp) {
#line 2026
    tmp___0 = 0;
  } else {
#line 2026
    tmp___0 = 1;
  }
#line 2026
  return (tmp___0);
}
}
#line 2029 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_boolean dd_Negative(__mpq_struct *val ) 
{ 
  dd_boolean tmp ;
  int tmp___0 ;

  {
  {
#line 2031
  tmp = dd_Nonnegative(val);
  }
#line 2031
  if (tmp) {
#line 2031
    tmp___0 = 0;
  } else {
#line 2031
    tmp___0 = 1;
  }
#line 2031
  return (tmp___0);
}
}
#line 2034 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_boolean dd_EqualToZero(__mpq_struct *val ) 
{ 
  dd_boolean tmp ;
  dd_boolean tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2036
  tmp = dd_Nonnegative(val);
  }
#line 2036
  if (tmp) {
    {
#line 2036
    tmp___0 = dd_Nonpositive(val);
    }
#line 2036
    if (tmp___0) {
#line 2036
      tmp___1 = 1;
    } else {
#line 2036
      tmp___1 = 0;
    }
  } else {
#line 2036
    tmp___1 = 0;
  }
#line 2036
  return (tmp___1);
}
}
#line 2039 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_boolean dd_Nonzero(__mpq_struct *val ) 
{ 
  dd_boolean tmp ;
  dd_boolean tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2041
  tmp = dd_Positive(val);
  }
#line 2041
  if (tmp) {
#line 2041
    tmp___1 = 1;
  } else {
    {
#line 2041
    tmp___0 = dd_Negative(val);
    }
#line 2041
    if (tmp___0) {
#line 2041
      tmp___1 = 1;
    } else {
#line 2041
      tmp___1 = 0;
    }
  }
#line 2041
  return (tmp___1);
}
}
#line 2044 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_boolean dd_Equal(__mpq_struct *val1 , __mpq_struct *val2 ) 
{ 
  dd_boolean tmp ;
  dd_boolean tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2046
  tmp = dd_Larger(val1, val2);
  }
#line 2046
  if (tmp) {
#line 2046
    tmp___1 = 0;
  } else {
    {
#line 2046
    tmp___0 = dd_Smaller(val1, val2);
    }
#line 2046
    if (tmp___0) {
#line 2046
      tmp___1 = 0;
    } else {
#line 2046
      tmp___1 = 1;
    }
  }
#line 2046
  return (tmp___1);
}
}
#line 2049 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_boolean dd_Larger(__mpq_struct *val1 , __mpq_struct *val2 ) 
{ 
  mytype temp ;
  dd_boolean answer ;

  {
  {
#line 2054
  __gmpq_init(temp);
#line 2055
  __gmpq_sub(temp, (mpq_srcptr )val1, (mpq_srcptr )val2);
#line 2056
  answer = dd_Positive((__mpq_struct *)(temp));
#line 2057
  __gmpq_clear(temp);
  }
#line 2058
  return (answer);
}
}
#line 2061 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
dd_boolean dd_Smaller(__mpq_struct *val1 , __mpq_struct *val2 ) 
{ 
  dd_boolean tmp ;

  {
  {
#line 2063
  tmp = dd_Larger(val2, val1);
  }
#line 2063
  return (tmp);
}
}
#line 2066 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_abs(__mpq_struct *absval , __mpq_struct *val ) 
{ 
  dd_boolean tmp ;

  {
  {
#line 2068
  tmp = dd_Negative(val);
  }
#line 2068
  if (tmp) {
    {
#line 2068
    __gmpq_neg((mpq_ptr )absval, (mpq_srcptr )val);
    }
  } else {
    {
#line 2069
    __gmpq_set((mpq_ptr )absval, (mpq_srcptr )val);
    }
  }
#line 2070
  return;
}
}
#line 2072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_LinearComb(__mpq_struct *lc , __mpq_struct *v1 , __mpq_struct *c1 , __mpq_struct *v2 ,
                   __mpq_struct *c2 ) 
{ 
  mytype temp ;

  {
  {
#line 2077
  __gmpq_init(temp);
#line 2078
  __gmpq_mul((mpq_ptr )lc, (mpq_srcptr )v1, (mpq_srcptr )c1);
#line 2079
  __gmpq_mul(temp, (mpq_srcptr )v2, (mpq_srcptr )c2);
#line 2080
  __gmpq_add((mpq_ptr )lc, (mpq_srcptr )lc, (mpq_srcptr )(temp));
#line 2081
  __gmpq_clear(temp);
  }
#line 2082
  return;
}
}
#line 2084 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
void dd_InnerProduct(__mpq_struct *prod , dd_colrange d , dd_Arow v1 , dd_Arow v2 ) 
{ 
  mytype temp ;
  dd_colrange j ;
  dd_boolean localdebug ;

  {
  {
#line 2088
  localdebug = 0;
#line 2090
  __gmpq_init(temp);
#line 2091
  ddd_mpq_set_si(prod, 0L);
#line 2092
  j = (dd_colrange )0;
  }
  {
#line 2092
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2092
    if (! (j < d)) {
#line 2092
      goto while_break;
    }
    {
#line 2093
    __gmpq_mul(temp, (mpq_srcptr )(*(v1 + j)), (mpq_srcptr )(*(v2 + j)));
#line 2094
    __gmpq_add((mpq_ptr )prod, (mpq_srcptr )prod, (mpq_srcptr )(temp));
#line 2092
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2096
  if (localdebug) {
    {
#line 2097
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"InnerProduct:\n");
#line 2098
    dd_WriteArow(stderr, v1, d);
#line 2099
    dd_WriteArow(stderr, v2, d);
#line 2100
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"prod =");
#line 2101
    dd_WriteNumber(stderr, prod);
#line 2102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 2105
  __gmpq_clear(temp);
  }
#line 2106
  return;
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddtypes_f.h"
ddf_boolean ddf_log ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
myfloat ddf_zero  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
myfloat ddf_one  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
myfloat ddf_purezero  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
myfloat ddf_minuszero  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
myfloat ddf_minusone  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
time_t ddf_statStartTime  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
long ddf_statBApivots  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
long ddf_statCCpivots  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
long ddf_statDS1pivots  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
long ddf_statDS2pivots  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
long ddf_statACpivots  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
ddf_LPSolverType ddf_choiceLPSolverDefault  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
ddf_LPSolverType ddf_choiceRedcheckAlgorithm  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd_f.h"
ddf_boolean ddf_choiceLexicoPivotQ  ;
#line 99
ddf_boolean ddf_DDFile2File(char *ifile , char *ofile , ddf_ErrorType *err ) ;
#line 100
ddf_boolean ddf_DDInputAppend(ddf_PolyhedraPtr *poly , ddf_MatrixPtr M , ddf_ErrorType *err ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
ddf_boolean ddf_debug  =    0;
#line 46 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
ddf_boolean ddf_log  =    0;
#line 70 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
void ddf_DDInit(ddf_ConePtr cone ) 
{ 


  {
  {
#line 72
  cone->Error = (ddf_ErrorType )17;
#line 73
  cone->CompStatus = (ddf_CompStatusType )0;
#line 74
  cone->RayCount = 0L;
#line 75
  cone->TotalRayCount = 0L;
#line 76
  cone->FeasibleRayCount = 0L;
#line 77
  cone->WeaklyFeasibleRayCount = 0L;
#line 78
  cone->EdgeCount = 0L;
#line 79
  cone->TotalEdgeCount = 0L;
#line 80
  ddf_SetInequalitySets(cone);
#line 81
  ddf_ComputeRowOrderVector(cone);
#line 82
  cone->RecomputeRowOrder = 0;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
void ddf_DDMain(ddf_ConePtr cone ) 
{ 
  ddf_rowrange hh ;
  ddf_rowrange itemp ;
  ddf_rowrange otemp ;
  ddf_boolean locallog ;
  int tmp ;

  {
#line 88
  locallog = ddf_log;
#line 90
  if (cone->d <= 0L) {
#line 91
    cone->Iteration = cone->m;
#line 92
    cone->FeasibleRayCount = 0L;
#line 93
    cone->CompStatus = (ddf_CompStatusType )1;
#line 94
    goto _L99;
  }
#line 96
  if (locallog) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(Initially added rows ) = ");
#line 98
    set_fwrite(stderr, cone->InitialHalfspaces);
    }
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (cone->Iteration <= cone->m)) {
#line 100
      goto while_break;
    }
    {
#line 101
    ddf_SelectNextHalfspace(cone, cone->WeaklyAddedHalfspaces, & hh);
#line 102
    tmp = set_member(hh, cone->NonequalitySet);
    }
#line 102
    if (tmp) {
#line 103
      if (ddf_debug) {
        {
#line 104
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*The row # %3ld should be inactive and thus skipped.\n",
                hh);
        }
      }
      {
#line 106
      set_addelem(cone->WeaklyAddedHalfspaces, hh);
      }
    } else {
#line 108
      if (cone->PreOrderedRun) {
        {
#line 109
        ddf_AddNewHalfspace2(cone, hh);
        }
      } else {
        {
#line 111
        ddf_AddNewHalfspace1(cone, hh);
        }
      }
      {
#line 113
      set_addelem(cone->AddedHalfspaces, hh);
#line 114
      set_addelem(cone->WeaklyAddedHalfspaces, hh);
      }
    }
#line 116
    if (! cone->PreOrderedRun) {
#line 117
      itemp = (ddf_rowrange )1;
      {
#line 117
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 117
        if (! (*(cone->OrderVector + itemp) != hh)) {
#line 117
          goto while_break___0;
        }
#line 117
        itemp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 118
      otemp = *(cone->OrderVector + cone->Iteration);
#line 119
      *(cone->OrderVector + cone->Iteration) = hh;
#line 121
      *(cone->OrderVector + itemp) = otemp;
    }
#line 124
    if (locallog) {
      {
#line 125
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(Iter, Row, #Total, #Curr, #Feas)= %5ld %5ld %9ld %6ld %6ld\n",
              cone->Iteration, hh, cone->TotalRayCount, cone->RayCount, cone->FeasibleRayCount);
      }
    }
#line 129
    if ((unsigned int )cone->CompStatus == 1U) {
      {
#line 130
      set_addelem(cone->AddedHalfspaces, hh);
      }
#line 131
      goto _L99;
    } else
#line 129
    if ((unsigned int )cone->CompStatus == 2U) {
      {
#line 130
      set_addelem(cone->AddedHalfspaces, hh);
      }
#line 131
      goto _L99;
    }
#line 133
    (cone->Iteration) ++;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 136
  if (cone->d <= 0L) {
#line 137
    (cone->parent)->n = (cone->LinearityDim + cone->FeasibleRayCount) - 1L;
#line 138
    (cone->parent)->ldim = cone->LinearityDim - 1L;
  } else
#line 136
  if (*(cone->newcol + 1) == 0L) {
#line 137
    (cone->parent)->n = (cone->LinearityDim + cone->FeasibleRayCount) - 1L;
#line 138
    (cone->parent)->ldim = cone->LinearityDim - 1L;
  } else {
#line 140
    (cone->parent)->n = cone->LinearityDim + cone->FeasibleRayCount;
#line 141
    (cone->parent)->ldim = cone->LinearityDim;
  }
#line 143
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___0  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___0  ;
#line 151
void ddf_InitialDataSetup(ddf_ConePtr cone ) ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___4  =    (ddf_colrange )0;
#line 146 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
void ddf_InitialDataSetup(ddf_ConePtr cone ) 
{ 
  long j ;
  long r ;
  ddf_rowset ZSet ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 153
  if (last_d___4 < cone->d) {
#line 154
    if (last_d___4 > 0L) {
#line 155
      j = 0L;
      {
#line 155
      while (1) {
        while_continue: /* CIL Label */ ;
#line 155
        if (! (j < last_d___4)) {
#line 155
          goto while_break;
        }
        {
#line 156
        dddf_clear((double *)(*(Vector1___0 + j)));
#line 157
        dddf_clear((double *)(*(Vector2___0 + j)));
#line 155
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 159
      free((void *)Vector1___0);
#line 159
      free((void *)Vector2___0);
      }
    }
    {
#line 161
    tmp = calloc((size_t )cone->d, sizeof(myfloat ));
#line 161
    Vector1___0 = (myfloat *)tmp;
#line 162
    tmp___0 = calloc((size_t )cone->d, sizeof(myfloat ));
#line 162
    Vector2___0 = (myfloat *)tmp___0;
#line 163
    j = 0L;
    }
    {
#line 163
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 163
      if (! (j < cone->d)) {
#line 163
        goto while_break___0;
      }
      {
#line 164
      dddf_init((double *)(*(Vector1___0 + j)));
#line 165
      dddf_init((double *)(*(Vector2___0 + j)));
#line 163
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 167
    last_d___4 = cone->d;
  }
  {
#line 170
  cone->RecomputeRowOrder = 0;
#line 171
  cone->ArtificialRay = (ddf_RayPtr )((void *)0);
#line 172
  cone->FirstRay = (ddf_RayPtr )((void *)0);
#line 173
  cone->LastRay = (ddf_RayPtr )((void *)0);
#line 174
  set_initialize(& ZSet, cone->m);
#line 175
  ddf_AddArtificialRay(cone);
#line 176
  set_copy(cone->AddedHalfspaces, cone->InitialHalfspaces);
#line 177
  set_copy(cone->WeaklyAddedHalfspaces, cone->InitialHalfspaces);
#line 178
  ddf_UpdateRowOrderVector(cone, cone->InitialHalfspaces);
#line 179
  r = 1L;
  }
  {
#line 179
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 179
    if (! (r <= cone->d)) {
#line 179
      goto while_break___1;
    }
#line 180
    j = 0L;
    {
#line 180
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 180
      if (! (j < cone->d)) {
#line 180
        goto while_break___2;
      }
      {
#line 181
      dddf_set((double *)(*(Vector1___0 + j)), (double *)(*(*(cone->B + j) + (r - 1L))));
#line 182
      dddf_neg((double *)(*(Vector2___0 + j)), (double *)(*(*(cone->B + j) + (r - 1L))));
#line 180
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 184
    ddf_Normalize(cone->d, Vector1___0);
#line 185
    ddf_Normalize(cone->d, Vector2___0);
#line 186
    ddf_ZeroIndexSet(cone->m, cone->d, cone->A, Vector1___0, ZSet);
#line 187
    tmp___1 = set_subset(cone->EqualitySet, ZSet);
    }
#line 187
    if (tmp___1) {
#line 188
      if (ddf_debug) {
        {
#line 189
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"add an initial ray with zero set:");
#line 190
        set_fwrite(stderr, ZSet);
        }
      }
      {
#line 192
      ddf_AddRay(cone, Vector1___0);
      }
#line 193
      if (*(cone->InitialRayIndex + r) == 0L) {
        {
#line 194
        ddf_AddRay(cone, Vector2___0);
        }
#line 195
        if (ddf_debug) {
          {
#line 196
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"and add its negative also.\n");
          }
        }
      }
    }
#line 179
    r ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 201
  ddf_CreateInitialEdges(cone);
#line 202
  cone->Iteration = cone->d + 1L;
  }
#line 203
  if (cone->Iteration > cone->m) {
#line 203
    cone->CompStatus = (ddf_CompStatusType )1;
  }
  {
#line 204
  set_free(ZSet);
  }
#line 205
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
ddf_boolean ddf_CheckEmptiness(ddf_PolyhedraPtr poly , ddf_ErrorType *err ) 
{ 
  ddf_rowset R ;
  ddf_rowset S ;
  ddf_MatrixPtr M ;
  ddf_boolean answer ;
  ddf_boolean tmp ;

  {
#line 210
  M = (ddf_MatrixPtr )((void *)0);
#line 211
  answer = 0;
#line 213
  *err = (ddf_ErrorType )17;
#line 215
  if ((unsigned int )poly->representation == 1U) {
    {
#line 216
    M = ddf_CopyInequalities(poly);
#line 217
    set_initialize(& R, M->rowsize);
#line 218
    set_initialize(& S, M->rowsize);
#line 219
    tmp = ddf_ExistsRestrictedFace(M, R, S, err);
    }
#line 219
    if (! tmp) {
#line 220
      (poly->child)->CompStatus = (ddf_CompStatusType )1;
#line 221
      poly->IsEmpty = 1;
#line 222
      poly->n = (ddf_bigrange )0;
#line 223
      answer = 1;
    }
    {
#line 225
    set_free(R);
#line 226
    set_free(S);
#line 227
    ddf_FreeMatrix(M);
    }
  } else
#line 228
  if ((unsigned int )poly->representation == 2U) {
#line 228
    if (poly->m <= 0L) {
#line 229
      *err = (ddf_ErrorType )3;
#line 230
      poly->IsEmpty = 1;
#line 231
      (poly->child)->CompStatus = (ddf_CompStatusType )1;
#line 232
      answer = 1;
#line 233
      (poly->child)->Error = *err;
    }
  }
#line 236
  return (answer);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
ddf_boolean ddf_DoubleDescription(ddf_PolyhedraPtr poly , ddf_ErrorType *err ) 
{ 
  ddf_ConePtr cone ;
  ddf_boolean found ;

  {
#line 242
  cone = (ddf_ConePtr )((void *)0);
#line 243
  found = 0;
#line 245
  *err = (ddf_ErrorType )17;
#line 247
  if ((unsigned long )poly != (unsigned long )((void *)0)) {
#line 247
    if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 247
      goto _L;
    } else
#line 247
    if ((unsigned int )(poly->child)->CompStatus != 1U) {
      _L: /* CIL Label */ 
      {
#line 248
      cone = ddf_ConeDataLoad(poly);
#line 250
      time(& cone->starttime);
#line 251
      ddf_DDInit(cone);
      }
#line 252
      if ((unsigned int )poly->representation == 2U) {
#line 252
        if (poly->m <= 0L) {
#line 253
          *err = (ddf_ErrorType )3;
#line 254
          cone->Error = *err;
#line 255
          goto _L99;
        }
      }
      {
#line 258
      ddf_CheckEmptiness(poly, err);
      }
#line 260
      if ((unsigned int )cone->CompStatus != 1U) {
        {
#line 261
        ddf_FindInitialRays(cone, & found);
        }
#line 262
        if (found) {
          {
#line 263
          ddf_InitialDataSetup(cone);
          }
#line 264
          if ((unsigned int )cone->CompStatus == 1U) {
#line 264
            goto _L99;
          }
          {
#line 265
          ddf_DDMain(cone);
          }
#line 266
          if (cone->FeasibleRayCount != cone->RayCount) {
#line 266
            *err = (ddf_ErrorType )16;
          }
        }
      }
      {
#line 269
      time(& cone->endtime);
      }
    }
  }
  _L99: ;
#line 274
  return (found);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
ddf_boolean ddf_DoubleDescription2(ddf_PolyhedraPtr poly , ddf_RowOrderType horder ,
                                   ddf_ErrorType *err ) 
{ 
  ddf_ConePtr cone ;
  ddf_boolean found ;

  {
#line 279
  cone = (ddf_ConePtr )((void *)0);
#line 280
  found = 0;
#line 282
  *err = (ddf_ErrorType )17;
#line 284
  if ((unsigned long )poly != (unsigned long )((void *)0)) {
#line 284
    if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 284
      goto _L;
    } else
#line 284
    if ((unsigned int )(poly->child)->CompStatus != 1U) {
      _L: /* CIL Label */ 
      {
#line 285
      cone = ddf_ConeDataLoad(poly);
#line 287
      cone->HalfspaceOrder = horder;
#line 288
      time(& cone->starttime);
#line 289
      ddf_DDInit(cone);
      }
#line 290
      if ((unsigned int )poly->representation == 2U) {
#line 290
        if (poly->m <= 0L) {
#line 291
          *err = (ddf_ErrorType )3;
#line 292
          cone->Error = *err;
#line 293
          goto _L99;
        }
      }
      {
#line 296
      ddf_CheckEmptiness(poly, err);
      }
#line 298
      if ((unsigned int )cone->CompStatus != 1U) {
        {
#line 299
        ddf_FindInitialRays(cone, & found);
        }
#line 300
        if (found) {
          {
#line 301
          ddf_InitialDataSetup(cone);
          }
#line 302
          if ((unsigned int )cone->CompStatus == 1U) {
#line 302
            goto _L99;
          }
          {
#line 303
          ddf_DDMain(cone);
          }
#line 304
          if (cone->FeasibleRayCount != cone->RayCount) {
#line 304
            *err = (ddf_ErrorType )16;
          }
        }
      }
      {
#line 307
      time(& cone->endtime);
      }
    }
  }
  _L99: ;
#line 312
  return (found);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
ddf_boolean ddf_DDInputAppend(ddf_PolyhedraPtr *poly , ddf_MatrixPtr M , ddf_ErrorType *err ) 
{ 
  ddf_boolean found ;
  ddf_ErrorType error ;

  {
#line 322
  if ((unsigned long )(*poly)->child != (unsigned long )((void *)0)) {
    {
#line 322
    ddf_FreeDDMemory(*poly);
    }
  }
  {
#line 323
  ddf_AppendMatrix2Poly(poly, M);
#line 324
  (*poly)->representation = (ddf_RepresentationType )1;
#line 325
  found = ddf_DoubleDescription(*poly, & error);
#line 326
  *err = error;
  }
#line 327
  return (found);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
ddf_boolean ddf_DDFile2File(char *ifile , char *ofile , ddf_ErrorType *err ) 
{ 
  ddf_boolean found ;
  FILE *reading___0 ;
  FILE *writing___0 ;
  ddf_PolyhedraPtr poly ;
  ddf_MatrixPtr M ;
  ddf_MatrixPtr A ;
  ddf_MatrixPtr G ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 334
  found = 1;
#line 335
  reading___0 = (FILE *)((void *)0);
#line 335
  writing___0 = (FILE *)((void *)0);
#line 339
  tmp = strcmp((char const   *)ifile, "**stdin");
  }
#line 339
  if (tmp == 0) {
#line 340
    reading___0 = stdin;
  } else {
    {
#line 341
    reading___0 = fopen((char const   */* __restrict  */)ifile, (char const   */* __restrict  */)"r");
    }
#line 341
    if ((unsigned long )reading___0 != (unsigned long )((void *)0)) {
      {
#line 342
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"input file %s is open\n",
              ifile);
      }
    } else {
      {
#line 345
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The input file %s not found\n",
              ifile);
#line 346
      found = 0;
#line 347
      *err = (ddf_ErrorType )6;
      }
#line 348
      goto _L99;
    }
  }
#line 351
  if (found) {
    {
#line 352
    tmp___0 = strcmp((char const   *)ofile, "**stdout");
    }
#line 352
    if (tmp___0 == 0) {
#line 353
      writing___0 = stdout;
    } else {
      {
#line 354
      writing___0 = fopen((char const   */* __restrict  */)ofile, (char const   */* __restrict  */)"w");
      }
#line 354
      if ((unsigned long )writing___0 != (unsigned long )((void *)0)) {
        {
#line 355
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output file %s is open\n",
                ofile);
#line 356
        found = 1;
        }
      } else {
        {
#line 358
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The output file %s cannot be opened\n",
                ofile);
#line 359
        found = 0;
#line 360
        *err = (ddf_ErrorType )7;
        }
#line 361
        goto _L99;
      }
    }
  }
  {
#line 365
  M = ddf_PolyFile2Matrix(reading___0, err);
  }
#line 366
  if ((unsigned int )*err != 17U) {
#line 367
    goto _L99;
  }
  {
#line 368
  poly = ddf_DDMatrix2Poly(M, err);
#line 368
  ddf_FreeMatrix(M);
  }
#line 370
  if ((unsigned int )*err == 17U) {
    {
#line 371
    ddf_WriteRunningMode(writing___0, poly);
#line 372
    A = ddf_CopyInequalities(poly);
#line 373
    G = ddf_CopyGenerators(poly);
    }
#line 375
    if ((unsigned int )poly->representation == 1U) {
      {
#line 376
      ddf_WriteMatrix(writing___0, G);
      }
    } else {
      {
#line 378
      ddf_WriteMatrix(writing___0, A);
      }
    }
    {
#line 381
    ddf_FreePolyhedra(poly);
#line 382
    ddf_FreeMatrix(A);
#line 383
    ddf_FreeMatrix(G);
    }
  }
  _L99: ;
#line 387
  if ((unsigned int )*err != 17U) {
    {
#line 387
    ddf_WriteErrorMessages(stderr, *err);
    }
  }
#line 388
  if ((unsigned long )reading___0 != (unsigned long )((void *)0)) {
    {
#line 388
    fclose(reading___0);
    }
  }
#line 389
  if ((unsigned long )writing___0 != (unsigned long )((void *)0)) {
    {
#line 389
    fclose(writing___0);
    }
  }
#line 390
  return (found);
}
}
#line 684 "/usr/include/x86_64-linux-gnu/gmp.h"
extern void __gmpz_clear(mpz_ptr  ) ;
#line 856
extern void __gmpz_init(mpz_ptr  ) ;
#line 874
extern int __gmpz_init_set_str(mpz_ptr  , char const   * , int  ) ;
#line 1040
extern void __gmpz_set_ui(mpz_ptr  , unsigned long  ) ;
#line 1132
extern void __gmpq_canonicalize(mpq_ptr  ) ;
#line 1197
extern size_t __gmpq_out_str(FILE * , int  , mpq_srcptr  ) ;
#line 1207
extern void __gmpq_set_den(mpq_ptr  , mpz_srcptr  ) ;
#line 1213
extern void __gmpq_set_num(mpq_ptr  , mpz_srcptr  ) ;
#line 90 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cdd.h"
dd_MatrixPtr dd_CopyInput(dd_PolyhedraPtr poly ) ;
#line 91
dd_MatrixPtr dd_CopyOutput(dd_PolyhedraPtr poly ) ;
#line 96
dd_SetFamilyPtr dd_CopyInputIncidence(dd_PolyhedraPtr poly ) ;
#line 97
dd_SetFamilyPtr dd_CopyInputAdjacency(dd_PolyhedraPtr poly ) ;
#line 103
dd_PolyhedraPtr dd_DDMatrix2Poly2(dd_MatrixPtr M , dd_RowOrderType horder , dd_ErrorType *err ) ;
#line 127
dd_MatrixPtr dd_CopyMatrix(dd_MatrixPtr M ) ;
#line 128
dd_MatrixPtr dd_MatrixNormalizedCopy(dd_MatrixPtr M ) ;
#line 129
dd_MatrixPtr dd_MatrixNormalizedSortedCopy(dd_MatrixPtr M , dd_rowindex *newpos ) ;
#line 130
dd_MatrixPtr dd_MatrixUniqueCopy(dd_MatrixPtr M , dd_rowindex *newpos ) ;
#line 131
dd_MatrixPtr dd_MatrixNormalizedSortedUniqueCopy(dd_MatrixPtr M , dd_rowindex *newpos ) ;
#line 134
dd_MatrixPtr dd_MatrixAppend(dd_MatrixPtr M1 , dd_MatrixPtr M2 ) ;
#line 135
dd_MatrixPtr dd_AppendMatrix(dd_MatrixPtr M1 , dd_MatrixPtr M2 ) ;
#line 137
int dd_MatrixAppendTo(dd_MatrixPtr *M1 , dd_MatrixPtr M2 ) ;
#line 139
dd_MatrixPtr dd_MatrixSubmatrix(dd_MatrixPtr M , dd_rowset delset ) ;
#line 140
dd_MatrixPtr dd_MatrixSubmatrix2(dd_MatrixPtr M , dd_rowset delset , dd_rowindex *newpos ) ;
#line 141
dd_MatrixPtr dd_MatrixSubmatrix2L(dd_MatrixPtr M , dd_rowset delset , dd_rowindex *newpos ) ;
#line 144
int dd_MatrixRowRemove2(dd_MatrixPtr *M , dd_rowrange r , dd_rowindex *newpos ) ;
#line 145
int dd_MatrixRowsRemove(dd_MatrixPtr *M , dd_rowset delset ) ;
#line 150
void dd_SetWriteFileName(char *inputfile , char *outfile , char cflag , dd_RepresentationType rep ) ;
#line 156
void dd_MatrixIntegerFilter(dd_MatrixPtr M ) ;
#line 157
void dd_WriteReal(FILE *f , __mpq_struct *x ) ;
#line 160
void dd_WritePolyFile(FILE *f , dd_PolyhedraPtr poly ) ;
#line 164
void dd_WriteSetFamilyCompressed(FILE *f , dd_SetFamilyPtr F ) ;
#line 166
void dd_WriteDDTimes(FILE *f , dd_PolyhedraPtr poly ) ;
#line 167
void dd_WriteTimes(FILE *f , time_t starttime , time_t endtime ) ;
#line 168
void dd_WriteIncidence(FILE *f , dd_PolyhedraPtr poly ) ;
#line 169
void dd_WriteAdjacency(FILE *f , dd_PolyhedraPtr poly ) ;
#line 170
void dd_WriteInputAdjacency(FILE *f , dd_PolyhedraPtr poly ) ;
#line 171
void dd_WriteInputIncidence(FILE *f , dd_PolyhedraPtr poly ) ;
#line 208
void dd_WriteLPStats(FILE *f ) ;
#line 209
void dd_WriteLPMode(FILE *f ) ;
#line 227
void dd_fread_rational_value(FILE *f , __mpq_struct *value ) ;
#line 228
void dd_sread_rational_value(char const   *s , __mpq_struct *value ) ;
#line 245
void dd_CopyRay(mytype *a___41 , dd_colrange d_origsize , dd_RayPtr RR , dd_RepresentationType rep ,
                dd_colindex reducedcol ) ;
#line 262
void dd_ProcessCommandLine(FILE *f , dd_MatrixPtr M , char const   *line ) ;
#line 269
void dd_SnapToInteger(__mpq_struct *y , __mpq_struct *x ) ;
#line 275
void dd_WriteRay(FILE *f , dd_colrange d_origsize , dd_RayPtr RR , dd_RepresentationType rep ,
                 dd_colindex reducedcol ) ;
#line 280
dd_NumberType dd_GetNumberType(char const   *line ) ;
#line 282
dd_PolyhedraPtr dd_CreatePolyhedraData(dd_rowrange m , dd_colrange d ) ;
#line 283
dd_boolean dd_InitializeConeData(dd_rowrange m , dd_colrange d , dd_ConePtr *cone ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_SetLinearity(dd_MatrixPtr M , char *line ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_SetInputFile(FILE **f , char *inputfile , dd_ErrorType *Error ) 
{ 
  int opened ;
  int stop ;
  int quit ;
  int i ;
  int dotpos ;
  int trial ;
  char ch ;
  char *tempname ;
  int tmp ;
  void *tmp___0 ;
  FILE *tmp___1 ;

  {
#line 26
  opened = 0;
#line 26
  quit = 0;
#line 27
  dotpos = 0;
#line 27
  trial = 0;
#line 32
  *Error = (dd_ErrorType )17;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! opened) {
#line 33
      if (! (! quit)) {
#line 33
        goto while_break;
      }
    } else {
#line 33
      goto while_break;
    }
    {
#line 34
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n>> Input file: ");
#line 35
    scanf((char const   */* __restrict  */)"%s", inputfile);
#line 36
    tmp = getchar();
#line 36
    ch = (char )tmp;
#line 37
    stop = 0;
#line 38
    i = 0;
    }
    {
#line 38
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 38
      if (i < 255) {
#line 38
        if (! (! stop)) {
#line 38
          goto while_break___0;
        }
      } else {
#line 38
        goto while_break___0;
      }
#line 39
      ch = *(inputfile + i);
      {
#line 41
      if ((int )ch == 46) {
#line 41
        goto case_46;
      }
#line 44
      if ((int )ch == 9) {
#line 44
        goto case_9;
      }
#line 44
      if ((int )ch == 10) {
#line 44
        goto case_9;
      }
#line 44
      if ((int )ch == 0) {
#line 44
        goto case_9;
      }
#line 44
      if ((int )ch == 32) {
#line 44
        goto case_9;
      }
#line 44
      if ((int )ch == 59) {
#line 44
        goto case_9;
      }
#line 40
      goto switch_break;
      case_46: /* CIL Label */ 
#line 42
      dotpos = i + 1;
#line 43
      goto switch_break;
      case_9: /* CIL Label */ 
      case_10: /* CIL Label */ 
      case_0: /* CIL Label */ 
      case_32: /* CIL Label */ 
      case_59: /* CIL Label */ 
      {
#line 45
      stop = 1;
#line 46
      tmp___0 = calloc((size_t )255, sizeof(ch));
#line 46
      tempname = (char *)tmp___0;
#line 47
      strncpy((char */* __restrict  */)tempname, (char const   */* __restrict  */)inputfile,
              (size_t )i);
#line 48
      strcpy((char */* __restrict  */)inputfile, (char const   */* __restrict  */)tempname);
#line 49
      free((void *)tempname);
      }
#line 50
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 38
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 53
    tmp___1 = fopen((char const   */* __restrict  */)inputfile, (char const   */* __restrict  */)"r");
#line 53
    *f = tmp___1;
    }
#line 53
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 54
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"input file %s is open\n",
              inputfile);
#line 55
      opened = 1;
#line 56
      *Error = (dd_ErrorType )17;
      }
    } else {
      {
#line 59
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The file %s not found\n",
              inputfile);
#line 60
      trial ++;
      }
#line 61
      if (trial > 5) {
#line 62
        *Error = (dd_ErrorType )6;
#line 63
        quit = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_SetWriteFileName(char *inputfile , char *outfile , char cflag , dd_RepresentationType rep ) 
{ 
  char *extension ;
  dd_DataFileType ifilehead ;
  unsigned int tmp ;
  int i ;
  int dotpos ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 72
  ifilehead[0] = (char )'\000';
#line 72
  tmp = 1U;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (tmp >= 255U) {
#line 72
      goto while_break;
    }
#line 72
    ifilehead[tmp] = (char)0;
#line 72
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 76
  if ((int )cflag == 111) {
#line 76
    goto case_111;
  }
#line 87
  if ((int )cflag == 97) {
#line 87
    goto case_97;
  }
#line 93
  if ((int )cflag == 105) {
#line 93
    goto case_105;
  }
#line 99
  if ((int )cflag == 110) {
#line 99
    goto case_110;
  }
#line 105
  if ((int )cflag == 106) {
#line 105
    goto case_106;
  }
#line 111
  if ((int )cflag == 108) {
#line 111
    goto case_108;
  }
#line 113
  if ((int )cflag == 100) {
#line 113
    goto case_100;
  }
#line 115
  if ((int )cflag == 112) {
#line 115
    goto case_112;
  }
#line 117
  if ((int )cflag == 118) {
#line 117
    goto case_118;
  }
#line 119
  if ((int )cflag == 115) {
#line 119
    goto case_115;
  }
#line 121
  goto switch_default___0;
  case_111: /* CIL Label */ 
  {
#line 78
  if ((unsigned int )rep == 2U) {
#line 78
    goto case_2;
  }
#line 80
  if ((unsigned int )rep == 1U) {
#line 80
    goto case_1;
  }
#line 82
  goto switch_default;
  case_2: /* CIL Label */ 
#line 79
  extension = (char *)".ine";
#line 79
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 81
  extension = (char *)".ext";
#line 81
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 83
  extension = (char *)".xxx";
#line 83
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 85
  goto switch_break;
  case_97: /* CIL Label */ 
#line 88
  if ((unsigned int )rep == 1U) {
#line 89
    extension = (char *)".ead";
  } else {
#line 91
    extension = (char *)".iad";
  }
#line 92
  goto switch_break;
  case_105: /* CIL Label */ 
#line 94
  if ((unsigned int )rep == 1U) {
#line 95
    extension = (char *)".ecd";
  } else {
#line 97
    extension = (char *)".icd";
  }
#line 98
  goto switch_break;
  case_110: /* CIL Label */ 
#line 100
  if ((unsigned int )rep == 1U) {
#line 101
    extension = (char *)".icd";
  } else {
#line 103
    extension = (char *)".ecd";
  }
#line 104
  goto switch_break;
  case_106: /* CIL Label */ 
#line 106
  if ((unsigned int )rep == 1U) {
#line 107
    extension = (char *)".iad";
  } else {
#line 109
    extension = (char *)".ead";
  }
#line 110
  goto switch_break;
  case_108: /* CIL Label */ 
#line 112
  extension = (char *)".ddl";
#line 112
  goto switch_break;
  case_100: /* CIL Label */ 
#line 114
  extension = (char *)".dex";
#line 114
  goto switch_break;
  case_112: /* CIL Label */ 
#line 116
  extension = (char *)"sub.ine";
#line 116
  goto switch_break;
  case_118: /* CIL Label */ 
#line 118
  extension = (char *)".solved";
#line 118
  goto switch_break;
  case_115: /* CIL Label */ 
#line 120
  extension = (char *)".lps";
#line 120
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 122
  extension = (char *)".xxx";
#line 122
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 124
  dotpos = -1;
#line 125
  i = 0;
  {
#line 125
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 125
    tmp___0 = strlen((char const   *)inputfile);
    }
#line 125
    if (! ((size_t )i < tmp___0)) {
#line 125
      goto while_break___0;
    }
#line 126
    if ((int )*(inputfile + i) == 46) {
#line 126
      dotpos = i;
    }
#line 125
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 128
  if (dotpos > 1) {
    {
#line 128
    strncpy((char */* __restrict  */)(ifilehead), (char const   */* __restrict  */)inputfile,
            (size_t )dotpos);
    }
  } else {
    {
#line 129
    strcpy((char */* __restrict  */)(ifilehead), (char const   */* __restrict  */)inputfile);
    }
  }
  {
#line 130
  tmp___1 = strlen((char const   *)inputfile);
  }
#line 130
  if (tmp___1 <= 0UL) {
    {
#line 130
    strcpy((char */* __restrict  */)(ifilehead), (char const   */* __restrict  */)"tempcdd");
    }
  }
  {
#line 131
  strcpy((char */* __restrict  */)outfile, (char const   */* __restrict  */)(ifilehead));
#line 132
  strcat((char */* __restrict  */)outfile, (char const   */* __restrict  */)extension);
#line 133
  tmp___2 = strcmp((char const   *)inputfile, (char const   *)outfile);
  }
#line 133
  if (tmp___2 == 0) {
    {
#line 134
    strcpy((char */* __restrict  */)outfile, (char const   */* __restrict  */)inputfile);
#line 135
    strcat((char */* __restrict  */)outfile, (char const   */* __restrict  */)extension);
    }
  }
#line 138
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_NumberType dd_GetNumberType(char const   *line ) 
{ 
  dd_NumberType nt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 145
  tmp___1 = strncmp(line, "integer", (size_t )7);
  }
#line 145
  if (tmp___1 == 0) {
#line 146
    nt = (dd_NumberType )3;
  } else {
    {
#line 148
    tmp___0 = strncmp(line, "rational", (size_t )8);
    }
#line 148
    if (tmp___0 == 0) {
#line 149
      nt = (dd_NumberType )2;
    } else {
      {
#line 151
      tmp = strncmp(line, "real", (size_t )4);
      }
#line 151
      if (tmp == 0) {
#line 152
        nt = (dd_NumberType )1;
      } else {
#line 155
        nt = (dd_NumberType )0;
      }
    }
  }
#line 157
  return (nt);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_ProcessCommandLine(FILE *f , dd_MatrixPtr M , char const   *line ) 
{ 
  char newline[4096] ;
  dd_colrange j ;
  mytype value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 166
  __gmpq_init(value);
#line 167
  tmp = strncmp(line, "hull", (size_t )4);
  }
#line 167
  if (tmp == 0) {
#line 168
    M->representation = (dd_RepresentationType )2;
  }
  {
#line 170
  tmp___0 = strncmp(line, "debug", (size_t )5);
  }
#line 170
  if (tmp___0 == 0) {
#line 171
    dd_debug = 1;
#line 173
    ddf_debug = 1;
  }
  {
#line 176
  tmp___1 = strncmp(line, "partial_enum", (size_t )12);
  }
#line 176
  if (tmp___1 == 0) {
    {
#line 179
    fgets((char */* __restrict  */)(newline), 4096, (FILE */* __restrict  */)f);
#line 180
    dd_SetLinearity(M, newline);
    }
  } else {
    {
#line 176
    tmp___2 = strncmp(line, "equality", (size_t )8);
    }
#line 176
    if (tmp___2 == 0) {
      {
#line 179
      fgets((char */* __restrict  */)(newline), 4096, (FILE */* __restrict  */)f);
#line 180
      dd_SetLinearity(M, newline);
      }
    } else {
      {
#line 176
      tmp___3 = strncmp(line, "linearity", (size_t )9);
      }
#line 176
      if (tmp___3 == 0) {
        {
#line 179
        fgets((char */* __restrict  */)(newline), 4096, (FILE */* __restrict  */)f);
#line 180
        dd_SetLinearity(M, newline);
        }
      }
    }
  }
  {
#line 182
  tmp___5 = strncmp(line, "maximize", (size_t )8);
  }
#line 182
  if (tmp___5 == 0) {
#line 182
    goto _L;
  } else {
    {
#line 182
    tmp___6 = strncmp(line, "minimize", (size_t )8);
    }
#line 182
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
      {
#line 184
      tmp___4 = strncmp(line, "maximize", (size_t )8);
      }
#line 184
      if (tmp___4 == 0) {
#line 184
        M->objective = (dd_LPObjectiveType )1;
      } else {
#line 185
        M->objective = (dd_LPObjectiveType )2;
      }
#line 186
      j = (dd_colrange )1;
      {
#line 186
      while (1) {
        while_continue: /* CIL Label */ ;
#line 186
        if (! (j <= M->colsize)) {
#line 186
          goto while_break;
        }
#line 187
        if (! ((unsigned int )M->numbtype == 1U)) {
          {
#line 194
          dd_fread_rational_value(f, (__mpq_struct *)(value));
          }
        }
        {
#line 196
        __gmpq_set(*(M->rowvec + (j - 1L)), (mpq_srcptr )(value));
        }
#line 197
        if (dd_debug) {
          {
#line 197
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cost(%5ld) =",
                  j);
#line 197
          dd_WriteNumber(stderr, (__mpq_struct *)(value));
          }
        }
#line 186
        j ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 200
  __gmpq_clear(value);
  }
#line 201
  return;
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_boolean dd_AppendMatrix2Poly(dd_PolyhedraPtr *poly , dd_MatrixPtr M ) 
{ 
  dd_boolean success ;
  dd_MatrixPtr Mpoly ;
  dd_MatrixPtr Mnew ;
  dd_ErrorType err ;

  {
#line 205
  success = 0;
#line 206
  Mnew = (dd_MatrixPtr )((void *)0);
#line 209
  if ((unsigned long )*poly != (unsigned long )((void *)0)) {
#line 209
    if ((*poly)->m >= 0L) {
#line 209
      if ((*poly)->d >= 0L) {
#line 209
        if ((*poly)->d == M->colsize) {
#line 209
          if (M->rowsize > 0L) {
            {
#line 211
            Mpoly = dd_CopyInput(*poly);
#line 212
            Mnew = dd_AppendMatrix(Mpoly, M);
#line 213
            dd_FreePolyhedra(*poly);
#line 214
            *poly = dd_DDMatrix2Poly(Mnew, & err);
#line 215
            dd_FreeMatrix(Mpoly);
#line 216
            dd_FreeMatrix(Mnew);
            }
#line 217
            if ((unsigned int )err == 17U) {
#line 217
              success = 1;
            }
          }
        }
      }
    }
  }
#line 219
  return (success);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_MatrixCopy(dd_MatrixPtr M ) 
{ 
  dd_MatrixPtr Mcopy ;
  dd_rowrange m ;
  dd_colrange d ;

  {
#line 224
  Mcopy = (dd_MatrixPtr )((void *)0);
#line 228
  m = M->rowsize;
#line 229
  d = M->colsize;
#line 230
  if (m >= 0L) {
#line 230
    if (d >= 0L) {
      {
#line 231
      Mcopy = dd_CreateMatrix(m, d);
#line 232
      dd_CopyAmatrix(Mcopy->matrix, M->matrix, m, d);
#line 233
      dd_CopyArow(Mcopy->rowvec, M->rowvec, d);
#line 234
      set_copy(Mcopy->linset, M->linset);
#line 235
      Mcopy->numbtype = M->numbtype;
#line 236
      Mcopy->representation = M->representation;
#line 237
      Mcopy->objective = M->objective;
      }
    }
  }
#line 239
  return (Mcopy);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_CopyMatrix(dd_MatrixPtr M ) 
{ 
  dd_MatrixPtr tmp ;

  {
  {
#line 244
  tmp = dd_MatrixCopy(M);
  }
#line 244
  return (tmp);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_MatrixNormalizedCopy(dd_MatrixPtr M ) 
{ 
  dd_MatrixPtr Mcopy ;
  dd_rowrange m ;
  dd_colrange d ;

  {
#line 249
  Mcopy = (dd_MatrixPtr )((void *)0);
#line 253
  m = M->rowsize;
#line 254
  d = M->colsize;
#line 255
  if (m >= 0L) {
#line 255
    if (d >= 0L) {
      {
#line 256
      Mcopy = dd_CreateMatrix(m, d);
#line 257
      dd_CopyNormalizedAmatrix(Mcopy->matrix, M->matrix, m, d);
#line 258
      dd_CopyArow(Mcopy->rowvec, M->rowvec, d);
#line 259
      set_copy(Mcopy->linset, M->linset);
#line 260
      Mcopy->numbtype = M->numbtype;
#line 261
      Mcopy->representation = M->representation;
#line 262
      Mcopy->objective = M->objective;
      }
    }
  }
#line 264
  return (Mcopy);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_MatrixAppend(dd_MatrixPtr M1 , dd_MatrixPtr M2 ) 
{ 
  dd_MatrixPtr M ;
  dd_rowrange i ;
  dd_rowrange m ;
  dd_rowrange m1 ;
  dd_rowrange m2 ;
  dd_colrange j ;
  dd_colrange d ;
  dd_colrange d1 ;
  dd_colrange d2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 270
  M = (dd_MatrixPtr )((void *)0);
#line 274
  m1 = M1->rowsize;
#line 275
  d1 = M1->colsize;
#line 276
  m2 = M2->rowsize;
#line 277
  d2 = M2->colsize;
#line 279
  m = m1 + m2;
#line 280
  d = d1;
#line 282
  if (d1 >= 0L) {
#line 282
    if (d1 == d2) {
#line 282
      if (m1 >= 0L) {
#line 282
        if (m2 >= 0L) {
          {
#line 283
          M = dd_CreateMatrix(m, d);
#line 284
          dd_CopyAmatrix(M->matrix, M1->matrix, m1, d);
#line 285
          dd_CopyArow(M->rowvec, M1->rowvec, d);
#line 286
          i = (dd_rowrange )0;
          }
          {
#line 286
          while (1) {
            while_continue: /* CIL Label */ ;
#line 286
            if (! (i < m1)) {
#line 286
              goto while_break;
            }
            {
#line 287
            tmp = set_member(i + 1L, M1->linset);
            }
#line 287
            if (tmp) {
              {
#line 287
              set_addelem(M->linset, i + 1L);
              }
            }
#line 286
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 289
          i = (dd_rowrange )0;
          {
#line 289
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 289
            if (! (i < m2)) {
#line 289
              goto while_break___0;
            }
#line 290
            j = (dd_colrange )0;
            {
#line 290
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 290
              if (! (j < d)) {
#line 290
                goto while_break___1;
              }
              {
#line 291
              __gmpq_set(*(*(M->matrix + (m1 + i)) + j), (mpq_srcptr )(*(*(M2->matrix + i) + j)));
#line 290
              j ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 293
            tmp___0 = set_member(i + 1L, M2->linset);
            }
#line 293
            if (tmp___0) {
              {
#line 293
              set_addelem(M->linset, (m1 + i) + 1L);
              }
            }
#line 289
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 295
          M->numbtype = M1->numbtype;
        }
      }
    }
  }
#line 297
  return (M);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_MatrixNormalizedSortedCopy(dd_MatrixPtr M , dd_rowindex *newpos ) 
{ 
  dd_MatrixPtr Mcopy ;
  dd_MatrixPtr Mnorm ;
  dd_rowrange m ;
  dd_rowrange i ;
  dd_colrange d ;
  dd_rowindex roworder ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 305
  Mcopy = (dd_MatrixPtr )((void *)0);
#line 305
  Mnorm = (dd_MatrixPtr )((void *)0);
#line 311
  m = M->rowsize;
#line 312
  d = M->colsize;
#line 313
  tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 313
  roworder = (long *)tmp;
#line 314
  tmp___0 = calloc((size_t )(m + 1L), sizeof(long ));
#line 314
  *newpos = (long *)tmp___0;
  }
#line 315
  if (m >= 0L) {
#line 315
    if (d >= 0L) {
      {
#line 316
      Mnorm = dd_MatrixNormalizedCopy(M);
#line 317
      Mcopy = dd_CreateMatrix(m, d);
#line 318
      i = (dd_rowrange )1;
      }
      {
#line 318
      while (1) {
        while_continue: /* CIL Label */ ;
#line 318
        if (! (i <= m)) {
#line 318
          goto while_break;
        }
#line 318
        *(roworder + i) = i;
#line 318
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 320
      dd_RandomPermutation(roworder, m, 123U);
#line 321
      dd_QuickSort(roworder, 1L, m, Mnorm->matrix, d);
#line 323
      dd_PermuteCopyAmatrix(Mcopy->matrix, Mnorm->matrix, m, d, roworder);
#line 324
      dd_CopyArow(Mcopy->rowvec, M->rowvec, d);
#line 325
      i = (dd_rowrange )1;
      }
      {
#line 325
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 325
        if (! (i <= m)) {
#line 325
          goto while_break___0;
        }
        {
#line 326
        tmp___1 = set_member(*(roworder + i), M->linset);
        }
#line 326
        if (tmp___1) {
          {
#line 326
          set_addelem(Mcopy->linset, i);
          }
        }
#line 327
        *(*newpos + *(roworder + i)) = i;
#line 325
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 329
      Mcopy->numbtype = M->numbtype;
#line 330
      Mcopy->representation = M->representation;
#line 331
      Mcopy->objective = M->objective;
#line 332
      dd_FreeMatrix(Mnorm);
      }
    }
  }
  {
#line 334
  free((void *)roworder);
  }
#line 335
  return (Mcopy);
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_MatrixUniqueCopy(dd_MatrixPtr M , dd_rowindex *newpos ) 
{ 
  dd_MatrixPtr Mcopy ;
  dd_rowrange m ;
  dd_rowrange i ;
  dd_rowrange uniqrows ;
  dd_rowset preferredrows ;
  dd_colrange d ;
  dd_rowindex roworder ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 347
  Mcopy = (dd_MatrixPtr )((void *)0);
#line 354
  m = M->rowsize;
#line 355
  d = M->colsize;
#line 356
  preferredrows = M->linset;
#line 357
  tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 357
  roworder = (long *)tmp;
  }
#line 358
  if (m >= 0L) {
#line 358
    if (d >= 0L) {
#line 359
      i = (dd_rowrange )1;
      {
#line 359
      while (1) {
        while_continue: /* CIL Label */ ;
#line 359
        if (! (i <= m)) {
#line 359
          goto while_break;
        }
#line 359
        *(roworder + i) = i;
#line 359
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 360
      dd_UniqueRows(roworder, 1L, m, M->matrix, d, preferredrows, & uniqrows);
#line 362
      Mcopy = dd_CreateMatrix(uniqrows, d);
#line 363
      dd_PermutePartialCopyAmatrix(Mcopy->matrix, M->matrix, m, d, roworder, (dd_rowrange )1,
                                   m);
#line 364
      dd_CopyArow(Mcopy->rowvec, M->rowvec, d);
#line 365
      i = (dd_rowrange )1;
      }
      {
#line 365
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 365
        if (! (i <= m)) {
#line 365
          goto while_break___0;
        }
#line 366
        if (*(roworder + i) > 0L) {
          {
#line 366
          tmp___0 = set_member(i, M->linset);
          }
#line 366
          if (tmp___0) {
            {
#line 366
            set_addelem(Mcopy->linset, *(roworder + i));
            }
          }
        }
#line 365
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 368
      Mcopy->numbtype = M->numbtype;
#line 369
      Mcopy->representation = M->representation;
#line 370
      Mcopy->objective = M->objective;
    }
  }
#line 372
  *newpos = roworder;
#line 373
  return (Mcopy);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_MatrixNormalizedSortedUniqueCopy(dd_MatrixPtr M , dd_rowindex *newpos ) 
{ 
  dd_MatrixPtr M1 ;
  dd_MatrixPtr M2 ;
  dd_rowrange m ;
  dd_rowrange i ;
  dd_colrange d ;
  dd_rowindex newpos1 ;
  dd_rowindex newpos1r ;
  dd_rowindex newpos2 ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 386
  M1 = (dd_MatrixPtr )((void *)0);
#line 386
  M2 = (dd_MatrixPtr )((void *)0);
#line 389
  newpos1 = (dd_rowindex )((void *)0);
#line 389
  newpos1r = (dd_rowindex )((void *)0);
#line 389
  newpos2 = (dd_rowindex )((void *)0);
#line 392
  m = M->rowsize;
#line 393
  d = M->colsize;
#line 394
  tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 394
  *newpos = (long *)tmp;
#line 395
  tmp___0 = calloc((size_t )(m + 1L), sizeof(long ));
#line 395
  newpos1r = (long *)tmp___0;
  }
#line 396
  if (m >= 0L) {
#line 396
    if (d >= 0L) {
      {
#line 397
      M1 = dd_MatrixNormalizedSortedCopy(M, & newpos1);
#line 398
      i = (dd_rowrange )1;
      }
      {
#line 398
      while (1) {
        while_continue: /* CIL Label */ ;
#line 398
        if (! (i <= m)) {
#line 398
          goto while_break;
        }
#line 398
        *(newpos1r + *(newpos1 + i)) = i;
#line 398
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 399
      M2 = dd_MatrixUniqueCopy(M1, & newpos2);
#line 400
      set_emptyset(M2->linset);
#line 401
      i = (dd_rowrange )1;
      }
      {
#line 401
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 401
        if (! (i <= m)) {
#line 401
          goto while_break___0;
        }
#line 402
        if (*(newpos2 + *(newpos1 + i)) > 0L) {
          {
#line 403
          printf((char const   */* __restrict  */)"newpos1[%ld]=%ld, newpos2[newpos1[%ld]]=%ld\n",
                 i, *(newpos1 + i), i, *(newpos2 + *(newpos1 + i)));
#line 404
          tmp___1 = set_member(i, M->linset);
          }
#line 404
          if (tmp___1) {
            {
#line 404
            set_addelem(M2->linset, *(newpos2 + *(newpos1 + i)));
            }
          }
#line 405
          *(*newpos + i) = *(newpos2 + *(newpos1 + i));
        } else {
#line 407
          *(*newpos + i) = - *(newpos1r + - *(newpos2 + *(newpos1 + i)));
        }
#line 401
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 410
      dd_FreeMatrix(M1);
#line 410
      free((void *)newpos1);
#line 410
      free((void *)newpos2);
#line 410
      free((void *)newpos1r);
      }
    }
  }
#line 413
  return (M2);
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_MatrixSortedUniqueCopy(dd_MatrixPtr M , dd_rowindex *newpos ) 
{ 
  dd_MatrixPtr M1 ;
  dd_MatrixPtr M2 ;
  dd_rowrange m ;
  dd_rowrange i ;
  dd_rowrange k ;
  dd_rowrange ii ;
  dd_colrange d ;
  dd_rowindex newpos1 ;
  dd_rowindex newpos1r ;
  dd_rowindex newpos2 ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 421
  M1 = (dd_MatrixPtr )((void *)0);
#line 421
  M2 = (dd_MatrixPtr )((void *)0);
#line 424
  newpos1 = (dd_rowindex )((void *)0);
#line 424
  newpos1r = (dd_rowindex )((void *)0);
#line 424
  newpos2 = (dd_rowindex )((void *)0);
#line 427
  m = M->rowsize;
#line 428
  d = M->colsize;
#line 429
  tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 429
  *newpos = (long *)tmp;
#line 430
  tmp___0 = calloc((size_t )(m + 1L), sizeof(long ));
#line 430
  newpos1r = (long *)tmp___0;
  }
#line 431
  if (m >= 0L) {
#line 431
    if (d >= 0L) {
      {
#line 432
      M1 = dd_MatrixNormalizedSortedCopy(M, & newpos1);
#line 433
      i = (dd_rowrange )1;
      }
      {
#line 433
      while (1) {
        while_continue: /* CIL Label */ ;
#line 433
        if (! (i <= m)) {
#line 433
          goto while_break;
        }
#line 433
        *(newpos1r + *(newpos1 + i)) = i;
#line 433
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 434
      M2 = dd_MatrixUniqueCopy(M1, & newpos2);
#line 435
      dd_FreeMatrix(M1);
#line 436
      set_emptyset(M2->linset);
#line 437
      i = (dd_rowrange )1;
      }
      {
#line 437
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 437
        if (! (i <= m)) {
#line 437
          goto while_break___0;
        }
#line 438
        if (*(newpos2 + *(newpos1 + i)) > 0L) {
          {
#line 439
          tmp___1 = set_member(i, M->linset);
          }
#line 439
          if (tmp___1) {
            {
#line 439
            set_addelem(M2->linset, *(newpos2 + *(newpos1 + i)));
            }
          }
#line 440
          *(*newpos + i) = *(newpos2 + *(newpos1 + i));
        } else {
#line 442
          *(*newpos + i) = - *(newpos1r + - *(newpos2 + *(newpos1 + i)));
        }
#line 437
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 446
      ii = (dd_rowrange )0;
#line 447
      set_emptyset(M2->linset);
#line 448
      i = (dd_rowrange )1;
      }
      {
#line 448
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 448
        if (! (i <= m)) {
#line 448
          goto while_break___1;
        }
#line 449
        k = *(*newpos + i);
#line 450
        if (k > 0L) {
          {
#line 451
          ii ++;
#line 452
          *(*newpos + i) = ii;
#line 453
          dd_CopyArow(*(M2->matrix + (ii - 1L)), *(M->matrix + (i - 1L)), d);
#line 454
          tmp___2 = set_member(i, M->linset);
          }
#line 454
          if (tmp___2) {
            {
#line 454
            set_addelem(M2->linset, ii);
            }
          }
        }
#line 448
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 458
      free((void *)newpos1);
#line 458
      free((void *)newpos2);
#line 458
      free((void *)newpos1r);
      }
    }
  }
#line 461
  return (M2);
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_AppendMatrix(dd_MatrixPtr M1 , dd_MatrixPtr M2 ) 
{ 
  dd_MatrixPtr tmp ;

  {
  {
#line 466
  tmp = dd_MatrixAppend(M1, M2);
  }
#line 466
  return (tmp);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
int dd_MatrixAppendTo(dd_MatrixPtr *M1 , dd_MatrixPtr M2 ) 
{ 
  dd_MatrixPtr M ;
  dd_rowrange i ;
  dd_rowrange m ;
  dd_rowrange m1 ;
  dd_rowrange m2 ;
  dd_colrange j ;
  dd_colrange d ;
  dd_colrange d1 ;
  dd_colrange d2 ;
  dd_boolean success ;
  int tmp ;
  int tmp___0 ;

  {
#line 471
  M = (dd_MatrixPtr )((void *)0);
#line 474
  success = 0;
#line 476
  m1 = (*M1)->rowsize;
#line 477
  d1 = (*M1)->colsize;
#line 478
  m2 = M2->rowsize;
#line 479
  d2 = M2->colsize;
#line 481
  m = m1 + m2;
#line 482
  d = d1;
#line 484
  if (d1 >= 0L) {
#line 484
    if (d1 == d2) {
#line 484
      if (m1 >= 0L) {
#line 484
        if (m2 >= 0L) {
          {
#line 485
          M = dd_CreateMatrix(m, d);
#line 486
          dd_CopyAmatrix(M->matrix, (*M1)->matrix, m1, d);
#line 487
          dd_CopyArow(M->rowvec, (*M1)->rowvec, d);
#line 488
          i = (dd_rowrange )0;
          }
          {
#line 488
          while (1) {
            while_continue: /* CIL Label */ ;
#line 488
            if (! (i < m1)) {
#line 488
              goto while_break;
            }
            {
#line 489
            tmp = set_member(i + 1L, (*M1)->linset);
            }
#line 489
            if (tmp) {
              {
#line 489
              set_addelem(M->linset, i + 1L);
              }
            }
#line 488
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 491
          i = (dd_rowrange )0;
          {
#line 491
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 491
            if (! (i < m2)) {
#line 491
              goto while_break___0;
            }
#line 492
            j = (dd_colrange )0;
            {
#line 492
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 492
              if (! (j < d)) {
#line 492
                goto while_break___1;
              }
              {
#line 493
              __gmpq_set(*(*(M->matrix + (m1 + i)) + j), (mpq_srcptr )(*(*(M2->matrix + i) + j)));
#line 492
              j ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 495
            tmp___0 = set_member(i + 1L, M2->linset);
            }
#line 495
            if (tmp___0) {
              {
#line 495
              set_addelem(M->linset, (m1 + i) + 1L);
              }
            }
#line 491
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 497
          M->numbtype = (*M1)->numbtype;
#line 498
          dd_FreeMatrix(*M1);
#line 499
          *M1 = M;
#line 500
          success = 1;
          }
        }
      }
    }
  }
#line 502
  return (success);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
int dd_MatrixRowRemove(dd_MatrixPtr *M , dd_rowrange r ) 
{ 
  dd_rowrange i ;
  dd_rowrange m ;
  dd_colrange d ;
  dd_boolean success ;
  int tmp ;

  {
#line 509
  success = 0;
#line 511
  m = (*M)->rowsize;
#line 512
  d = (*M)->colsize;
#line 514
  if (r >= 1L) {
#line 514
    if (r <= m) {
      {
#line 515
      (*M)->rowsize = m - 1L;
#line 516
      dd_FreeArow(d, *((*M)->matrix + (r - 1L)));
#line 517
      set_delelem((*M)->linset, r);
#line 519
      i = r;
      }
      {
#line 519
      while (1) {
        while_continue: /* CIL Label */ ;
#line 519
        if (! (i < m)) {
#line 519
          goto while_break;
        }
        {
#line 520
        *((*M)->matrix + (i - 1L)) = *((*M)->matrix + i);
#line 521
        tmp = set_member(i + 1L, (*M)->linset);
        }
#line 521
        if (tmp) {
          {
#line 522
          set_delelem((*M)->linset, i + 1L);
#line 523
          set_addelem((*M)->linset, i);
          }
        }
#line 519
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 526
      success = 1;
    }
  }
#line 528
  return (success);
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
int dd_MatrixRowRemove2(dd_MatrixPtr *M , dd_rowrange r , dd_rowindex *newpos ) 
{ 
  dd_rowrange i ;
  dd_rowrange m ;
  dd_colrange d ;
  dd_boolean success ;
  dd_rowindex roworder ;
  void *tmp ;
  int tmp___0 ;

  {
#line 535
  success = 0;
#line 538
  m = (*M)->rowsize;
#line 539
  d = (*M)->colsize;
#line 541
  if (r >= 1L) {
#line 541
    if (r <= m) {
      {
#line 542
      tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 542
      roworder = (long *)tmp;
#line 543
      (*M)->rowsize = m - 1L;
#line 544
      dd_FreeArow(d, *((*M)->matrix + (r - 1L)));
#line 545
      set_delelem((*M)->linset, r);
#line 547
      i = (dd_rowrange )1;
      }
      {
#line 547
      while (1) {
        while_continue: /* CIL Label */ ;
#line 547
        if (! (i < r)) {
#line 547
          goto while_break;
        }
#line 547
        *(roworder + i) = i;
#line 547
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 548
      *(roworder + r) = 0L;
#line 549
      i = r;
      {
#line 549
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 549
        if (! (i < m)) {
#line 549
          goto while_break___0;
        }
        {
#line 550
        *((*M)->matrix + (i - 1L)) = *((*M)->matrix + i);
#line 551
        *(roworder + (i + 1L)) = i;
#line 552
        tmp___0 = set_member(i + 1L, (*M)->linset);
        }
#line 552
        if (tmp___0) {
          {
#line 553
          set_delelem((*M)->linset, i + 1L);
#line 554
          set_addelem((*M)->linset, i);
          }
        }
#line 549
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 557
      success = 1;
    }
  }
#line 559
  return (success);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_MatrixSubmatrix(dd_MatrixPtr M , dd_rowset delset ) 
{ 
  dd_MatrixPtr Msub ;
  dd_rowrange i ;
  dd_rowrange isub ;
  dd_rowrange m ;
  dd_rowrange msub ;
  dd_colrange d ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 564
  Msub = (dd_MatrixPtr )((void *)0);
#line 565
  isub = (dd_rowrange )1;
#line 568
  m = M->rowsize;
#line 569
  d = M->colsize;
#line 570
  msub = m;
#line 571
  if (m >= 0L) {
#line 571
    if (d >= 0L) {
#line 572
      i = (dd_rowrange )1;
      {
#line 572
      while (1) {
        while_continue: /* CIL Label */ ;
#line 572
        if (! (i <= m)) {
#line 572
          goto while_break;
        }
        {
#line 573
        tmp = set_member(i, delset);
        }
#line 573
        if (tmp) {
#line 573
          msub --;
        }
#line 572
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 575
      Msub = dd_CreateMatrix(msub, d);
#line 576
      i = (dd_rowrange )1;
      }
      {
#line 576
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 576
        if (! (i <= m)) {
#line 576
          goto while_break___0;
        }
        {
#line 577
        tmp___1 = set_member(i, delset);
        }
#line 577
        if (! tmp___1) {
          {
#line 578
          dd_CopyArow(*(Msub->matrix + (isub - 1L)), *(M->matrix + (i - 1L)), d);
#line 579
          tmp___0 = set_member(i, M->linset);
          }
#line 579
          if (tmp___0) {
            {
#line 580
            set_addelem(Msub->linset, isub);
            }
          }
#line 582
          isub ++;
        }
#line 576
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 585
      dd_CopyArow(Msub->rowvec, M->rowvec, d);
#line 586
      Msub->numbtype = M->numbtype;
#line 587
      Msub->representation = M->representation;
#line 588
      Msub->objective = M->objective;
      }
    }
  }
#line 590
  return (Msub);
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_MatrixSubmatrix2(dd_MatrixPtr M , dd_rowset delset , dd_rowindex *newpos ) 
{ 
  dd_MatrixPtr Msub ;
  dd_rowrange i ;
  dd_rowrange isub ;
  dd_rowrange m ;
  dd_rowrange msub ;
  dd_colrange d ;
  dd_rowindex roworder ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 599
  Msub = (dd_MatrixPtr )((void *)0);
#line 600
  isub = (dd_rowrange )1;
#line 604
  m = M->rowsize;
#line 605
  d = M->colsize;
#line 606
  msub = m;
#line 607
  if (m >= 0L) {
#line 607
    if (d >= 0L) {
      {
#line 608
      tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 608
      roworder = (long *)tmp;
#line 609
      i = (dd_rowrange )1;
      }
      {
#line 609
      while (1) {
        while_continue: /* CIL Label */ ;
#line 609
        if (! (i <= m)) {
#line 609
          goto while_break;
        }
        {
#line 610
        tmp___0 = set_member(i, delset);
        }
#line 610
        if (tmp___0) {
#line 610
          msub --;
        }
#line 609
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 612
      Msub = dd_CreateMatrix(msub, d);
#line 613
      i = (dd_rowrange )1;
      }
      {
#line 613
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 613
        if (! (i <= m)) {
#line 613
          goto while_break___0;
        }
        {
#line 614
        tmp___2 = set_member(i, delset);
        }
#line 614
        if (tmp___2) {
#line 615
          *(roworder + i) = 0L;
        } else {
          {
#line 617
          dd_CopyArow(*(Msub->matrix + (isub - 1L)), *(M->matrix + (i - 1L)), d);
#line 618
          tmp___1 = set_member(i, M->linset);
          }
#line 618
          if (tmp___1) {
            {
#line 619
            set_addelem(Msub->linset, isub);
            }
          }
#line 621
          *(roworder + i) = isub;
#line 622
          isub ++;
        }
#line 613
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 625
      *newpos = roworder;
#line 626
      dd_CopyArow(Msub->rowvec, M->rowvec, d);
#line 627
      Msub->numbtype = M->numbtype;
#line 628
      Msub->representation = M->representation;
#line 629
      Msub->objective = M->objective;
      }
    }
  }
#line 631
  return (Msub);
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_MatrixSubmatrix2L(dd_MatrixPtr M , dd_rowset delset , dd_rowindex *newpos ) 
{ 
  dd_MatrixPtr Msub ;
  dd_rowrange i ;
  dd_rowrange iL ;
  dd_rowrange iI ;
  dd_rowrange m ;
  dd_rowrange msub ;
  dd_colrange d ;
  dd_rowindex roworder ;
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 639
  Msub = (dd_MatrixPtr )((void *)0);
#line 644
  m = M->rowsize;
#line 645
  d = M->colsize;
#line 646
  msub = m;
#line 647
  if (m >= 0L) {
#line 647
    if (d >= 0L) {
      {
#line 648
      tmp = calloc((size_t )(m + 1L), sizeof(long ));
#line 648
      roworder = (long *)tmp;
#line 649
      i = (dd_rowrange )1;
      }
      {
#line 649
      while (1) {
        while_continue: /* CIL Label */ ;
#line 649
        if (! (i <= m)) {
#line 649
          goto while_break;
        }
        {
#line 650
        tmp___0 = set_member(i, delset);
        }
#line 650
        if (tmp___0) {
#line 650
          msub --;
        }
#line 649
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 652
      Msub = dd_CreateMatrix(msub, d);
#line 653
      iL = (dd_rowrange )1;
#line 653
      tmp___1 = set_card(M->linset);
#line 653
      iI = tmp___1 + 1L;
#line 654
      i = (dd_rowrange )1;
      }
      {
#line 654
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 654
        if (! (i <= m)) {
#line 654
          goto while_break___0;
        }
        {
#line 655
        tmp___3 = set_member(i, delset);
        }
#line 655
        if (tmp___3) {
#line 656
          *(roworder + i) = 0L;
        } else {
          {
#line 658
          tmp___2 = set_member(i, M->linset);
          }
#line 658
          if (tmp___2) {
            {
#line 659
            dd_CopyArow(*(Msub->matrix + (iL - 1L)), *(M->matrix + (i - 1L)), d);
#line 660
            set_delelem(Msub->linset, i);
#line 661
            set_addelem(Msub->linset, iL);
#line 662
            *(roworder + i) = iL;
#line 663
            iL ++;
            }
          } else {
            {
#line 665
            dd_CopyArow(*(Msub->matrix + (iI - 1L)), *(M->matrix + (i - 1L)), d);
#line 666
            *(roworder + i) = iI;
#line 667
            iI ++;
            }
          }
        }
#line 654
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 671
      *newpos = roworder;
#line 672
      dd_CopyArow(Msub->rowvec, M->rowvec, d);
#line 673
      Msub->numbtype = M->numbtype;
#line 674
      Msub->representation = M->representation;
#line 675
      Msub->objective = M->objective;
      }
    }
  }
#line 677
  return (Msub);
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
int dd_MatrixRowsRemove(dd_MatrixPtr *M , dd_rowset delset ) 
{ 
  dd_MatrixPtr Msub ;
  int success ;

  {
  {
#line 682
  Msub = (dd_MatrixPtr )((void *)0);
#line 685
  Msub = dd_MatrixSubmatrix(*M, delset);
#line 686
  dd_FreeMatrix(*M);
#line 687
  *M = Msub;
#line 688
  success = 1;
  }
#line 689
  return (success);
}
}
#line 692 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
int dd_MatrixRowsRemove2(dd_MatrixPtr *M , dd_rowset delset , dd_rowindex *newpos ) 
{ 
  dd_MatrixPtr Msub ;
  int success ;

  {
  {
#line 694
  Msub = (dd_MatrixPtr )((void *)0);
#line 697
  Msub = dd_MatrixSubmatrix2(*M, delset, newpos);
#line 698
  dd_FreeMatrix(*M);
#line 699
  *M = Msub;
#line 700
  success = 1;
  }
#line 701
  return (success);
}
}
#line 704 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
int dd_MatrixShiftupLinearity(dd_MatrixPtr *M , dd_rowindex *newpos ) 
{ 
  dd_MatrixPtr Msub ;
  int success ;
  dd_rowset delset ;

  {
  {
#line 706
  Msub = (dd_MatrixPtr )((void *)0);
#line 710
  set_initialize(& delset, (*M)->rowsize);
#line 711
  Msub = dd_MatrixSubmatrix2L(*M, delset, newpos);
#line 712
  dd_FreeMatrix(*M);
#line 713
  *M = Msub;
#line 715
  set_free(delset);
#line 716
  success = 1;
  }
#line 717
  return (success);
}
}
#line 720 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_PolyhedraPtr dd_CreatePolyhedraData(dd_rowrange m , dd_colrange d ) 
{ 
  dd_rowrange i ;
  dd_PolyhedraPtr poly ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 723
  poly = (dd_PolyhedraPtr )((void *)0);
#line 725
  tmp = malloc(sizeof(dd_PolyhedraType ));
#line 725
  poly = (dd_PolyhedraPtr )tmp;
#line 726
  poly->child = (dd_ConePtr )((void *)0);
#line 727
  poly->m = m;
#line 728
  poly->d = d;
#line 729
  poly->n = (dd_bigrange )-1;
#line 730
  poly->m_alloc = m + 2L;
#line 731
  poly->d_alloc = d;
#line 732
  poly->ldim = (dd_colrange )0;
#line 733
  poly->numbtype = (dd_NumberType )1;
#line 734
  dd_InitializeAmatrix(poly->m_alloc, poly->d_alloc, & poly->A);
#line 735
  dd_InitializeArow(d, & poly->c);
#line 736
  poly->representation = (dd_RepresentationType )1;
#line 737
  poly->homogeneous = 0;
#line 739
  tmp___0 = calloc((size_t )(m + 2L), sizeof(int ));
#line 739
  poly->EqualityIndex = (int *)tmp___0;
#line 743
  i = (dd_rowrange )0;
  }
  {
#line 743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 743
    if (! (i <= m + 1L)) {
#line 743
      goto while_break;
    }
#line 743
    *(poly->EqualityIndex + i) = 0;
#line 743
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 745
  poly->IsEmpty = -1;
#line 747
  poly->NondegAssumed = 0;
#line 748
  poly->InitBasisAtBottom = 0;
#line 749
  poly->RestrictedEnumeration = 0;
#line 750
  poly->RelaxedEnumeration = 0;
#line 752
  poly->AincGenerated = 0;
#line 754
  return (poly);
}
}
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_boolean dd_InitializeConeData(dd_rowrange m , dd_colrange d , dd_ConePtr *cone ) 
{ 
  dd_boolean success ;
  dd_colrange j ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 759
  success = 1;
#line 762
  tmp = calloc((size_t )1, sizeof(dd_ConeType ));
#line 762
  *cone = (dd_ConePtr )tmp;
#line 765
  (*cone)->m = m;
#line 766
  (*cone)->d = d;
#line 767
  (*cone)->m_alloc = m + 2L;
#line 768
  (*cone)->d_alloc = d;
#line 769
  (*cone)->numbtype = (dd_NumberType )1;
#line 770
  (*cone)->parent = (dd_PolyhedraPtr )((void *)0);
#line 773
  (*cone)->Iteration = (dd_rowrange )0;
#line 775
  (*cone)->HalfspaceOrder = (dd_RowOrderType )5;
#line 777
  (*cone)->ArtificialRay = (dd_RayPtr )((void *)0);
#line 778
  (*cone)->FirstRay = (dd_RayPtr )((void *)0);
#line 779
  (*cone)->LastRay = (dd_RayPtr )((void *)0);
#line 780
  (*cone)->PosHead = (dd_RayPtr )((void *)0);
#line 781
  (*cone)->ZeroHead = (dd_RayPtr )((void *)0);
#line 782
  (*cone)->NegHead = (dd_RayPtr )((void *)0);
#line 783
  (*cone)->PosLast = (dd_RayPtr )((void *)0);
#line 784
  (*cone)->ZeroLast = (dd_RayPtr )((void *)0);
#line 785
  (*cone)->NegLast = (dd_RayPtr )((void *)0);
#line 786
  (*cone)->RecomputeRowOrder = 1;
#line 787
  (*cone)->PreOrderedRun = 0;
#line 788
  set_initialize(& (*cone)->GroundSet, (*cone)->m_alloc);
#line 789
  set_initialize(& (*cone)->EqualitySet, (*cone)->m_alloc);
#line 790
  set_initialize(& (*cone)->NonequalitySet, (*cone)->m_alloc);
#line 791
  set_initialize(& (*cone)->AddedHalfspaces, (*cone)->m_alloc);
#line 792
  set_initialize(& (*cone)->WeaklyAddedHalfspaces, (*cone)->m_alloc);
#line 793
  set_initialize(& (*cone)->InitialHalfspaces, (*cone)->m_alloc);
#line 794
  (*cone)->RayCount = 0L;
#line 795
  (*cone)->FeasibleRayCount = 0L;
#line 796
  (*cone)->WeaklyFeasibleRayCount = 0L;
#line 797
  (*cone)->TotalRayCount = 0L;
#line 798
  (*cone)->ZeroRayCount = 0L;
#line 799
  (*cone)->EdgeCount = 0L;
#line 800
  (*cone)->TotalEdgeCount = 0L;
#line 801
  (*cone)->count_int = 0L;
#line 802
  (*cone)->count_int_good = 0L;
#line 803
  (*cone)->count_int_bad = 0L;
#line 804
  (*cone)->rseed = 1U;
#line 806
  dd_InitializeBmatrix((*cone)->d_alloc, & (*cone)->B);
#line 807
  dd_InitializeBmatrix((*cone)->d_alloc, & (*cone)->Bsave);
#line 808
  dd_InitializeAmatrix((*cone)->m_alloc, (*cone)->d_alloc, & (*cone)->A);
#line 810
  tmp___0 = calloc((size_t )(*cone)->m_alloc, sizeof(dd_AdjacencyType *));
#line 810
  (*cone)->Edges = (dd_AdjacencyType **)tmp___0;
#line 812
  tmp___1 = calloc((size_t )(d + 1L), sizeof(long ));
#line 812
  (*cone)->InitialRayIndex = (long *)tmp___1;
#line 813
  tmp___2 = calloc((size_t )((*cone)->m_alloc + 1L), sizeof(long ));
#line 813
  (*cone)->OrderVector = (long *)tmp___2;
#line 815
  tmp___3 = calloc((size_t )((*cone)->d + 1L), sizeof(long ));
#line 815
  (*cone)->newcol = (long *)tmp___3;
#line 816
  j = (dd_colrange )0;
  }
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 816
    if (! (j <= (*cone)->d)) {
#line 816
      goto while_break;
    }
#line 816
    *((*cone)->newcol + j) = j;
#line 816
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 817
  (*cone)->LinearityDim = (dd_bigrange )-2;
#line 818
  (*cone)->ColReduced = 0;
#line 819
  (*cone)->d_orig = d;
#line 828
  return (success);
}
}
#line 831 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_ConePtr dd_ConeDataLoad(dd_PolyhedraPtr poly ) 
{ 
  dd_ConePtr cone ;
  dd_colrange d ;
  dd_colrange j ;
  dd_rowrange m ;
  dd_rowrange i ;

  {
#line 833
  cone = (dd_ConePtr )((void *)0);
#line 837
  m = poly->m;
#line 838
  d = poly->d;
#line 839
  if (! poly->homogeneous) {
#line 839
    if ((unsigned int )poly->representation == 1U) {
#line 840
      m = poly->m + 1L;
    }
  }
  {
#line 842
  poly->m1 = m;
#line 844
  dd_InitializeConeData(m, d, & cone);
#line 845
  cone->representation = poly->representation;
#line 848
  cone->parent = poly;
#line 849
  poly->child = cone;
#line 851
  i = (dd_rowrange )1;
  }
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;
#line 851
    if (! (i <= poly->m)) {
#line 851
      goto while_break;
    }
#line 852
    j = (dd_colrange )1;
    {
#line 852
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 852
      if (! (j <= cone->d)) {
#line 852
        goto while_break___0;
      }
      {
#line 853
      __gmpq_set(*(*(cone->A + (i - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(poly->A + (i - 1L)) + (j - 1L))));
#line 852
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 851
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 855
  if ((unsigned int )poly->representation == 1U) {
#line 855
    if (! poly->homogeneous) {
      {
#line 856
      __gmpq_set(*(*(cone->A + (m - 1L)) + 0), (mpq_srcptr )(dd_one));
#line 857
      j = (dd_colrange )2;
      }
      {
#line 857
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 857
        if (! (j <= d)) {
#line 857
          goto while_break___1;
        }
        {
#line 857
        __gmpq_set(*(*(cone->A + (m - 1L)) + (j - 1L)), (mpq_srcptr )(dd_purezero));
#line 857
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 860
  return (cone);
}
}
#line 863 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_SetLinearity(dd_MatrixPtr M , char *line ) 
{ 
  int i ;
  dd_rowrange eqsize ;
  dd_rowrange var ;
  char *next ;
  char ct[3] ;

  {
  {
#line 865
  i = 0;
#line 868
  ct[0] = (char )',';
#line 868
  ct[1] = (char )' ';
#line 868
  ct[2] = (char )'\000';
#line 870
  next = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)(ct));
#line 871
  eqsize = atol((char const   *)next);
  }
  {
#line 872
  while (1) {
    while_continue: /* CIL Label */ ;
#line 872
    if ((dd_rowrange )i < eqsize) {
      {
#line 872
      next = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)(ct));
      }
#line 872
      if (! ((unsigned long )next != (unsigned long )((void *)0))) {
#line 872
        goto while_break;
      }
    } else {
#line 872
      goto while_break;
    }
    {
#line 873
    var = atol((char const   *)next);
#line 874
    set_addelem(M->linset, var);
#line 874
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  if ((dd_rowrange )i != eqsize) {
    {
#line 877
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"* Warning: there are inconsistencies in linearity setting.\n");
    }
  }
#line 879
  return;
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_PolyFile2Matrix(FILE *f , dd_ErrorType *Error ) 
{ 
  dd_MatrixPtr M ;
  dd_rowrange m_input ;
  dd_rowrange i ;
  dd_colrange d_input ;
  dd_colrange j ;
  dd_RepresentationType rep ;
  mytype value ;
  dd_boolean found ;
  dd_boolean newformat ;
  dd_boolean successful ;
  dd_boolean linearity ;
  char command[4096] ;
  char comsave[4096] ;
  char numbtype[1024] ;
  dd_NumberType NT ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 884
  M = (dd_MatrixPtr )((void *)0);
#line 887
  rep = (dd_RepresentationType )1;
#line 889
  found = 0;
#line 889
  newformat = 0;
#line 889
  successful = 0;
#line 889
  linearity = 0;
#line 896
  __gmpq_init(value);
#line 897
  *Error = (dd_ErrorType )17;
  }
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if (! (! found)) {
#line 898
      goto while_break;
    }
    {
#line 900
    tmp___5 = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s",
                     command);
    }
#line 900
    if (tmp___5 == -1) {
#line 901
      *Error = (dd_ErrorType )1;
#line 902
      goto _L99;
    } else {
      {
#line 905
      tmp = strncmp((char const   *)(command), "V-representation", (size_t )16);
      }
#line 905
      if (tmp == 0) {
#line 906
        rep = (dd_RepresentationType )2;
#line 906
        newformat = 1;
      }
      {
#line 908
      tmp___0 = strncmp((char const   *)(command), "H-representation", (size_t )16);
      }
#line 908
      if (tmp___0 == 0) {
#line 909
        rep = (dd_RepresentationType )1;
#line 909
        newformat = 1;
      }
      {
#line 911
      tmp___1 = strncmp((char const   *)(command), "partial_enum", (size_t )12);
      }
#line 911
      if (tmp___1 == 0) {
        {
#line 914
        linearity = 1;
#line 915
        fgets((char */* __restrict  */)(comsave), 4096, (FILE */* __restrict  */)f);
        }
      } else {
        {
#line 911
        tmp___2 = strncmp((char const   *)(command), "equality", (size_t )8);
        }
#line 911
        if (tmp___2 == 0) {
          {
#line 914
          linearity = 1;
#line 915
          fgets((char */* __restrict  */)(comsave), 4096, (FILE */* __restrict  */)f);
          }
        } else {
          {
#line 911
          tmp___3 = strncmp((char const   *)(command), "linearity", (size_t )9);
          }
#line 911
          if (tmp___3 == 0) {
            {
#line 914
            linearity = 1;
#line 915
            fgets((char */* __restrict  */)(comsave), 4096, (FILE */* __restrict  */)f);
            }
          }
        }
      }
      {
#line 917
      tmp___4 = strncmp((char const   *)(command), "begin", (size_t )5);
      }
#line 917
      if (tmp___4 == 0) {
#line 917
        found = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 920
  fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld %ld %s",
         & m_input, & d_input, numbtype);
#line 921
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"size = %ld x %ld\nNumber Type = %s\n",
          m_input, d_input, numbtype);
#line 922
  NT = dd_GetNumberType((char const   *)(numbtype));
  }
#line 923
  if ((unsigned int )NT == 0U) {
#line 924
    *Error = (dd_ErrorType )1;
#line 925
    goto _L99;
  }
  {
#line 927
  M = dd_CreateMatrix(m_input, d_input);
#line 928
  M->representation = rep;
#line 929
  M->numbtype = NT;
#line 931
  i = (dd_rowrange )1;
  }
  {
#line 931
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 931
    if (! (i <= m_input)) {
#line 931
      goto while_break___0;
    }
#line 932
    j = (dd_colrange )1;
    {
#line 932
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 932
      if (! (j <= d_input)) {
#line 932
        goto while_break___1;
      }
#line 933
      if ((unsigned int )NT == 1U) {
#line 935
        *Error = (dd_ErrorType )9;
#line 936
        goto _L99;
      } else {
        {
#line 942
        dd_fread_rational_value(f, (__mpq_struct *)(value));
        }
      }
      {
#line 944
      __gmpq_set(*(*(M->matrix + (i - 1L)) + (j - 1L)), (mpq_srcptr )(value));
      }
#line 945
      if (dd_debug) {
        {
#line 945
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"a(%3ld,%5ld) = ",
                i, j);
#line 945
        dd_WriteNumber(stderr, (__mpq_struct *)(value));
        }
      }
#line 932
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 931
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 948
  tmp___7 = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s",
                   command);
  }
#line 948
  if (tmp___7 == -1) {
#line 949
    *Error = (dd_ErrorType )1;
#line 950
    goto _L99;
  } else {
    {
#line 952
    tmp___6 = strncmp((char const   *)(command), "end", (size_t )3);
    }
#line 952
    if (tmp___6 != 0) {
#line 953
      if (dd_debug) {
        {
#line 953
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'end\' missing or illegal extra data: %s\n",
                command);
        }
      }
#line 954
      *Error = (dd_ErrorType )1;
#line 955
      goto _L99;
    }
  }
#line 958
  successful = 1;
#line 959
  if (linearity) {
    {
#line 960
    dd_SetLinearity(M, comsave);
    }
  }
  {
#line 962
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 962
    tmp___8 = feof(f);
    }
#line 962
    if (tmp___8) {
#line 962
      goto while_break___2;
    }
    {
#line 963
    fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s", command);
#line 964
    dd_ProcessCommandLine(f, M, (char const   *)(command));
#line 965
    fgets((char */* __restrict  */)(command), 4096, (FILE */* __restrict  */)f);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  _L99: 
  {
#line 969
  __gmpq_clear(value);
  }
#line 971
  return (M);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_PolyhedraPtr dd_DDMatrix2Poly(dd_MatrixPtr M , dd_ErrorType *err ) 
{ 
  dd_rowrange i ;
  dd_colrange j ;
  dd_PolyhedraPtr poly ;
  int tmp ;
  dd_boolean tmp___0 ;

  {
#line 979
  poly = (dd_PolyhedraPtr )((void *)0);
#line 981
  *err = (dd_ErrorType )17;
#line 982
  if (M->rowsize < 0L) {
#line 983
    *err = (dd_ErrorType )2;
#line 984
    goto _L99;
  } else
#line 982
  if (M->colsize < 0L) {
#line 983
    *err = (dd_ErrorType )2;
#line 984
    goto _L99;
  }
  {
#line 986
  poly = dd_CreatePolyhedraData(M->rowsize, M->colsize);
#line 987
  poly->representation = M->representation;
#line 988
  poly->homogeneous = 1;
#line 990
  i = (dd_rowrange )1;
  }
  {
#line 990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 990
    if (! (i <= M->rowsize)) {
#line 990
      goto while_break;
    }
    {
#line 991
    tmp = set_member(i, M->linset);
    }
#line 991
    if (tmp) {
#line 992
      *(poly->EqualityIndex + i) = 1;
    }
#line 994
    j = (dd_colrange )1;
    {
#line 994
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 994
      if (! (j <= M->colsize)) {
#line 994
        goto while_break___0;
      }
      {
#line 995
      __gmpq_set(*(*(poly->A + (i - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 1L))));
      }
#line 996
      if (j == 1L) {
        {
#line 996
        tmp___0 = dd_Nonzero((__mpq_struct *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
        }
#line 996
        if (tmp___0) {
#line 996
          poly->homogeneous = 0;
        }
      }
#line 994
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 990
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 999
  dd_DoubleDescription(poly, err);
  }
  _L99: 
#line 1001
  return (poly);
}
}
#line 1004 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_PolyhedraPtr dd_DDMatrix2Poly2(dd_MatrixPtr M , dd_RowOrderType horder , dd_ErrorType *err ) 
{ 
  dd_rowrange i ;
  dd_colrange j ;
  dd_PolyhedraPtr poly ;
  int tmp ;
  dd_boolean tmp___0 ;

  {
#line 1008
  poly = (dd_PolyhedraPtr )((void *)0);
#line 1010
  *err = (dd_ErrorType )17;
#line 1011
  if (M->rowsize < 0L) {
#line 1012
    *err = (dd_ErrorType )2;
#line 1013
    goto _L99;
  } else
#line 1011
  if (M->colsize < 0L) {
#line 1012
    *err = (dd_ErrorType )2;
#line 1013
    goto _L99;
  }
  {
#line 1015
  poly = dd_CreatePolyhedraData(M->rowsize, M->colsize);
#line 1016
  poly->representation = M->representation;
#line 1017
  poly->homogeneous = 1;
#line 1019
  i = (dd_rowrange )1;
  }
  {
#line 1019
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1019
    if (! (i <= M->rowsize)) {
#line 1019
      goto while_break;
    }
    {
#line 1020
    tmp = set_member(i, M->linset);
    }
#line 1020
    if (tmp) {
#line 1021
      *(poly->EqualityIndex + i) = 1;
    }
#line 1023
    j = (dd_colrange )1;
    {
#line 1023
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1023
      if (! (j <= M->colsize)) {
#line 1023
        goto while_break___0;
      }
      {
#line 1024
      __gmpq_set(*(*(poly->A + (i - 1L)) + (j - 1L)), (mpq_srcptr )(*(*(M->matrix + (i - 1L)) + (j - 1L))));
      }
#line 1025
      if (j == 1L) {
        {
#line 1025
        tmp___0 = dd_Nonzero((__mpq_struct *)(*(*(M->matrix + (i - 1L)) + (j - 1L))));
        }
#line 1025
        if (tmp___0) {
#line 1025
          poly->homogeneous = 0;
        }
      }
#line 1023
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1019
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1028
  dd_DoubleDescription2(poly, horder, err);
  }
  _L99: 
#line 1030
  return (poly);
}
}
#line 1033 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_MatrixIntegerFilter(dd_MatrixPtr M ) 
{ 
  dd_rowrange i ;
  dd_colrange j ;
  mytype x ;

  {
  {
#line 1039
  __gmpq_init(x);
#line 1040
  i = (dd_rowrange )0;
  }
  {
#line 1040
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1040
    if (! (i < M->rowsize)) {
#line 1040
      goto while_break;
    }
#line 1041
    j = (dd_colrange )0;
    {
#line 1041
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1041
      if (! (j < M->colsize)) {
#line 1041
        goto while_break___0;
      }
      {
#line 1042
      dd_SnapToInteger((__mpq_struct *)(x), (__mpq_struct *)(*(*(M->matrix + i) + j)));
#line 1043
      __gmpq_set(*(*(M->matrix + i) + j), (mpq_srcptr )(x));
#line 1041
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1040
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1045
  __gmpq_clear(x);
  }
#line 1046
  return;
}
}
#line 1048 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_CopyRay(mytype *a___41 , dd_colrange d_origsize , dd_RayPtr RR , dd_RepresentationType rep ,
                dd_colindex reducedcol ) 
{ 
  long j ;
  long j1___0 ;
  mytype b ;
  dd_boolean tmp ;

  {
  {
#line 1054
  __gmpq_init(b);
#line 1055
  j = 1L;
  }
  {
#line 1055
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1055
    if (! (j <= d_origsize)) {
#line 1055
      goto while_break;
    }
#line 1056
    j1___0 = *(reducedcol + j);
#line 1057
    if (j1___0 > 0L) {
      {
#line 1058
      __gmpq_set(*(a___41 + (j - 1L)), (mpq_srcptr )(*(RR->Ray + (j1___0 - 1L))));
      }
    } else {
      {
#line 1062
      __gmpq_set(*(a___41 + (j - 1L)), (mpq_srcptr )(dd_purezero));
      }
    }
#line 1055
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1067
  __gmpq_set(b, (mpq_srcptr )(*(a___41 + 0)));
  }
#line 1068
  if ((unsigned int )rep == 2U) {
    {
#line 1068
    tmp = dd_Nonzero((__mpq_struct *)(b));
    }
#line 1068
    if (tmp) {
      {
#line 1069
      __gmpq_set(*(a___41 + 0), (mpq_srcptr )(dd_one));
#line 1070
      j = 2L;
      }
      {
#line 1070
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1070
        if (! (j <= d_origsize)) {
#line 1070
          goto while_break___0;
        }
        {
#line 1071
        __gmpq_div(*(a___41 + (j - 1L)), (mpq_srcptr )(*(a___41 + (j - 1L))), (mpq_srcptr )(b));
#line 1070
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 1073
  __gmpq_clear(b);
  }
#line 1074
  return;
}
}
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___4  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___0  ;
#line 1076 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteRay(FILE *f , dd_colrange d_origsize , dd_RayPtr RR , dd_RepresentationType rep ,
                 dd_colindex reducedcol ) 
{ 
  dd_colrange j ;

  {
#line 1082
  if (d_last___4 < d_origsize) {
#line 1083
    if (d_last___4 > 0L) {
      {
#line 1083
      free((void *)a___0);
      }
    }
    {
#line 1084
    dd_InitializeArow(d_origsize + 1L, & a___0);
#line 1085
    d_last___4 = d_origsize + 1L;
    }
  }
  {
#line 1088
  dd_CopyRay(a___0, d_origsize, RR, rep, reducedcol);
#line 1089
  j = (dd_colrange )0;
  }
  {
#line 1089
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1089
    if (! (j < d_origsize)) {
#line 1089
      goto while_break;
    }
    {
#line 1089
    dd_WriteNumber(f, (__mpq_struct *)(*(a___0 + j)));
#line 1089
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1090
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
  }
#line 1091
  return;
}
}
#line 1093 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteArow(FILE *f , dd_Arow a___41 , dd_colrange d ) 
{ 
  dd_colrange j ;

  {
#line 1097
  j = (dd_colrange )0;
  {
#line 1097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1097
    if (! (j < d)) {
#line 1097
      goto while_break;
    }
    {
#line 1097
    dd_WriteNumber(f, (__mpq_struct *)(*(a___41 + j)));
#line 1097
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1098
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
  }
#line 1099
  return;
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteAmatrix(FILE *f , dd_Amatrix A , long rowmax , long colmax ) 
{ 
  long i ;
  long j ;

  {
#line 1105
  if ((unsigned long )A == (unsigned long )((void *)0)) {
    {
#line 1106
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"WriteAmatrix: The requested matrix is empty\n");
    }
#line 1107
    goto _L99;
  }
  {
#line 1109
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"begin\n");
#line 1111
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld %ld rational\n",
          rowmax, colmax);
#line 1115
  i = 1L;
  }
  {
#line 1115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1115
    if (! (i <= rowmax)) {
#line 1115
      goto while_break;
    }
#line 1116
    j = 1L;
    {
#line 1116
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1116
      if (! (j <= colmax)) {
#line 1116
        goto while_break___0;
      }
      {
#line 1117
      dd_WriteNumber(f, (__mpq_struct *)(*(*(A + (i - 1L)) + (j - 1L))));
#line 1116
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1119
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 1115
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1121
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
  }
  _L99: ;
#line 1123
  return;
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteBmatrix(FILE *f , dd_colrange d_size , dd_Bmatrix B ) 
{ 
  dd_colrange j1___0 ;
  dd_colrange j2 ;

  {
#line 1129
  if ((unsigned long )B == (unsigned long )((void *)0)) {
    {
#line 1130
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"WriteBmatrix: The requested matrix is empty\n");
    }
#line 1131
    goto _L99;
  }
#line 1133
  j1___0 = (dd_colrange )0;
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1133
    if (! (j1___0 < d_size)) {
#line 1133
      goto while_break;
    }
#line 1134
    j2 = (dd_colrange )0;
    {
#line 1134
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1134
      if (! (j2 < d_size)) {
#line 1134
        goto while_break___0;
      }
      {
#line 1135
      dd_WriteNumber(f, (__mpq_struct *)(*(*(B + j1___0) + j2)));
#line 1134
      j2 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1137
    _IO_putc('\n', f);
#line 1133
    j1___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1139
  _IO_putc('\n', f);
  }
  _L99: ;
#line 1141
  return;
}
}
#line 1143 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteSetFamily(FILE *f , dd_SetFamilyPtr F ) 
{ 
  dd_bigrange i ;
  long tmp ;

  {
#line 1147
  if ((unsigned long )F == (unsigned long )((void *)0)) {
    {
#line 1148
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"WriteSetFamily: The requested family is empty\n");
    }
#line 1149
    goto _L99;
  }
  {
#line 1151
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"begin\n");
#line 1152
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %ld    %ld\n",
          F->famsize, F->setsize);
#line 1153
  i = (dd_bigrange )0;
  }
  {
#line 1153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1153
    if (! (i < F->famsize)) {
#line 1153
      goto while_break;
    }
    {
#line 1154
    tmp = set_card(*(F->set + i));
#line 1154
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld %ld : ",
            i + 1L, tmp);
#line 1155
    set_fwrite(f, *(F->set + i));
#line 1153
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1157
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
  }
  _L99: ;
#line 1159
  return;
}
}
#line 1161 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteSetFamilyCompressed(FILE *f , dd_SetFamilyPtr F ) 
{ 
  dd_bigrange i ;
  dd_bigrange card ;

  {
#line 1165
  if ((unsigned long )F == (unsigned long )((void *)0)) {
    {
#line 1166
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"WriteSetFamily: The requested family is empty\n");
    }
#line 1167
    goto _L99;
  }
  {
#line 1169
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"begin\n");
#line 1170
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  %ld    %ld\n",
          F->famsize, F->setsize);
#line 1171
  i = (dd_bigrange )0;
  }
  {
#line 1171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1171
    if (! (i < F->famsize)) {
#line 1171
      goto while_break;
    }
    {
#line 1172
    card = set_card(*(F->set + i));
    }
#line 1173
    if (F->setsize - card >= card) {
      {
#line 1174
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld %ld : ",
              i + 1L, card);
#line 1175
      set_fwrite(f, *(F->set + i));
      }
    } else {
      {
#line 1177
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld %ld : ",
              i + 1L, - card);
#line 1178
      set_fwrite_compl(f, *(F->set + i));
      }
    }
#line 1171
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1181
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"end\n");
  }
  _L99: ;
#line 1183
  return;
}
}
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteMatrix(FILE *f , dd_MatrixPtr M ) 
{ 
  dd_rowrange i ;
  dd_rowrange linsize ;
  int tmp ;

  {
#line 1189
  if ((unsigned long )M == (unsigned long )((void *)0)) {
    {
#line 1190
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"WriteMatrix: The requested matrix is empty\n");
    }
#line 1191
    goto _L99;
  }
  {
#line 1194
  if ((unsigned int )M->representation == 1U) {
#line 1194
    goto case_1;
  }
#line 1196
  if ((unsigned int )M->representation == 2U) {
#line 1196
    goto case_2;
  }
#line 1198
  if ((unsigned int )M->representation == 0U) {
#line 1198
    goto case_0;
  }
#line 1193
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1195
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"H-representation\n");
  }
#line 1195
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1197
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"V-representation\n");
  }
#line 1197
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1199
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1201
  linsize = set_card(M->linset);
  }
#line 1202
  if (linsize > 0L) {
    {
#line 1203
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"linearity %ld ",
            linsize);
#line 1204
    i = (dd_rowrange )1;
    }
    {
#line 1204
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1204
      if (! (i <= M->rowsize)) {
#line 1204
        goto while_break;
      }
      {
#line 1205
      tmp = set_member(i, M->linset);
      }
#line 1205
      if (tmp) {
        {
#line 1205
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %ld",
                i);
        }
      }
#line 1204
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1206
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1208
  dd_WriteAmatrix(f, M->matrix, M->rowsize, M->colsize);
  }
#line 1209
  if ((unsigned int )M->objective != 0U) {
#line 1210
    if ((unsigned int )M->objective == 1U) {
      {
#line 1211
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"maximize\n");
      }
    } else {
      {
#line 1213
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"minimize\n");
      }
    }
    {
#line 1214
    dd_WriteArow(f, M->rowvec, M->colsize);
    }
  }
  _L99: ;
#line 1217
  return;
}
}
#line 1219 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteLP(FILE *f , dd_LPPtr lp ) 
{ 


  {
#line 1221
  if ((unsigned long )lp == (unsigned long )((void *)0)) {
    {
#line 1222
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"WriteLP: The requested lp is empty\n");
    }
#line 1223
    goto _L99;
  }
  {
#line 1225
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"H-representation\n");
#line 1227
  dd_WriteAmatrix(f, lp->A, lp->m - 1L, lp->d);
  }
#line 1228
  if ((unsigned int )lp->objective != 0U) {
#line 1229
    if ((unsigned int )lp->objective == 1U) {
      {
#line 1230
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"maximize\n");
      }
    } else {
      {
#line 1232
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"minimize\n");
      }
    }
    {
#line 1233
    dd_WriteArow(f, *(lp->A + (lp->objrow - 1L)), lp->d);
    }
  }
  _L99: ;
#line 1236
  return;
}
}
#line 1239 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_SnapToInteger(__mpq_struct *y , __mpq_struct *x ) 
{ 


  {
  {
#line 1242
  __gmpq_set((mpq_ptr )y, (mpq_srcptr )x);
  }
#line 1243
  return;
}
}
#line 1246 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteReal(FILE *f , __mpq_struct *x ) 
{ 
  long ix1 ;
  long ix2 ;
  long ix ;
  double ax ;
  double tmp ;
  double tmp___0 ;
  dd_boolean tmp___1 ;

  {
  {
#line 1251
  ax = __gmpq_get_d((mpq_srcptr )x);
#line 1252
  tmp = fabs(ax);
#line 1252
  ix1 = (long )(tmp * 10000. + 0.5);
#line 1253
  tmp___0 = fabs(ax);
#line 1253
  ix2 = (long )(tmp___0 + 0.5);
#line 1254
  ix2 *= 10000L;
  }
#line 1255
  if (ix1 == ix2) {
    {
#line 1256
    tmp___1 = dd_Positive(x);
    }
#line 1256
    if (tmp___1) {
#line 1257
      ix = (long )(ax + 0.5);
    } else {
#line 1259
      ix = (long )(- ax + 0.5);
#line 1260
      ix = - ix;
    }
    {
#line 1262
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %2ld",
            ix);
    }
  } else {
    {
#line 1264
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" % .9E",
            ax);
    }
  }
#line 1265
  return;
}
}
#line 1267 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteNumber(FILE *f , __mpq_struct *x ) 
{ 


  {
  {
#line 1270
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" ");
#line 1271
  __gmpq_out_str(f, 10, (mpq_srcptr )x);
  }
#line 1275
  return;
}
}
#line 1278 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteIncidence(FILE *f , dd_PolyhedraPtr poly ) 
{ 
  dd_SetFamilyPtr I ;

  {
  {
#line 1283
  if ((unsigned int )poly->representation == 1U) {
#line 1283
    goto case_1;
  }
#line 1286
  if ((unsigned int )poly->representation == 2U) {
#line 1286
    goto case_2;
  }
#line 1290
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1284
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"ecd_file: Incidence of generators and inequalities\n");
  }
#line 1285
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1287
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"icd_file: Incidence of inequalities and generators\n");
  }
#line 1288
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1291
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1293
  I = dd_CopyIncidence(poly);
#line 1294
  dd_WriteSetFamilyCompressed(f, I);
#line 1295
  dd_FreeSetFamily(I);
  }
#line 1296
  return;
}
}
#line 1298 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteAdjacency(FILE *f , dd_PolyhedraPtr poly ) 
{ 
  dd_SetFamilyPtr A ;

  {
  {
#line 1303
  if ((unsigned int )poly->representation == 1U) {
#line 1303
    goto case_1;
  }
#line 1306
  if ((unsigned int )poly->representation == 2U) {
#line 1306
    goto case_2;
  }
#line 1310
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1304
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"ead_file: Adjacency of generators\n");
  }
#line 1305
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1307
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"iad_file: Adjacency of inequalities\n");
  }
#line 1308
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1311
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1313
  A = dd_CopyAdjacency(poly);
#line 1314
  dd_WriteSetFamilyCompressed(f, A);
#line 1315
  dd_FreeSetFamily(A);
  }
#line 1316
  return;
}
}
#line 1319 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_ComputeAinc(dd_PolyhedraPtr poly ) 
{ 
  dd_bigrange k ;
  dd_rowrange i ;
  dd_rowrange m1 ;
  dd_colrange j ;
  dd_boolean redundant ;
  dd_MatrixPtr M ;
  mytype sum ;
  mytype temp ;
  void *tmp ;
  dd_boolean tmp___0 ;
  dd_boolean tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;

  {
  {
#line 1328
  M = (dd_MatrixPtr )((void *)0);
#line 1331
  __gmpq_init(sum);
#line 1331
  __gmpq_init(temp);
  }
#line 1332
  if (poly->AincGenerated == 1) {
#line 1332
    goto _L99;
  }
  {
#line 1334
  M = dd_CopyOutput(poly);
#line 1335
  poly->n = M->rowsize;
#line 1336
  m1 = poly->m1;
#line 1342
  tmp = calloc((size_t )m1, sizeof(set_type ));
#line 1342
  poly->Ainc = (set_type *)tmp;
#line 1343
  i = (dd_rowrange )1;
  }
  {
#line 1343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1343
    if (! (i <= m1)) {
#line 1343
      goto while_break;
    }
    {
#line 1343
    set_initialize(poly->Ainc + (i - 1L), poly->n);
#line 1343
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1344
  set_initialize(& poly->Ared, m1);
#line 1345
  set_initialize(& poly->Adom, m1);
#line 1347
  k = (dd_bigrange )1;
  }
  {
#line 1347
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1347
    if (! (k <= poly->n)) {
#line 1347
      goto while_break___0;
    }
#line 1348
    i = (dd_rowrange )1;
    {
#line 1348
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1348
      if (! (i <= poly->m)) {
#line 1348
        goto while_break___1;
      }
      {
#line 1349
      __gmpq_set(sum, (mpq_srcptr )(dd_purezero));
#line 1350
      j = (dd_colrange )1;
      }
      {
#line 1350
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1350
        if (! (j <= poly->d)) {
#line 1350
          goto while_break___2;
        }
        {
#line 1351
        __gmpq_mul(temp, (mpq_srcptr )(*(*(poly->A + (i - 1L)) + (j - 1L))), (mpq_srcptr )(*(*(M->matrix + (k - 1L)) + (j - 1L))));
#line 1352
        __gmpq_add(sum, (mpq_srcptr )(sum), (mpq_srcptr )(temp));
#line 1350
        j ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1354
      tmp___0 = dd_EqualToZero((__mpq_struct *)(sum));
      }
#line 1354
      if (tmp___0) {
        {
#line 1355
        set_addelem(*(poly->Ainc + (i - 1L)), k);
        }
      }
#line 1348
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1358
    if (! poly->homogeneous) {
#line 1358
      if ((unsigned int )poly->representation == 1U) {
        {
#line 1359
        tmp___1 = dd_EqualToZero((__mpq_struct *)(*(*(M->matrix + (k - 1L)) + 0)));
        }
#line 1359
        if (tmp___1) {
          {
#line 1360
          set_addelem(*(poly->Ainc + (m1 - 1L)), k);
          }
        }
      }
    }
#line 1347
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1365
  i = (dd_rowrange )1;
  {
#line 1365
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1365
    if (! (i <= m1)) {
#line 1365
      goto while_break___3;
    }
    {
#line 1366
    tmp___2 = set_card(*(poly->Ainc + (i - 1L)));
    }
#line 1366
    if (tmp___2 == M->rowsize) {
      {
#line 1367
      set_addelem(poly->Adom, i);
      }
    }
#line 1365
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1370
  i = m1;
  {
#line 1370
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1370
    if (! (i >= 1L)) {
#line 1370
      goto while_break___4;
    }
    {
#line 1371
    tmp___6 = set_card(*(poly->Ainc + (i - 1L)));
    }
#line 1371
    if (tmp___6 == 0L) {
      {
#line 1372
      redundant = 1;
#line 1373
      set_addelem(poly->Ared, i);
      }
    } else {
#line 1375
      redundant = 0;
#line 1376
      k = (dd_bigrange )1;
      {
#line 1376
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1376
        if (! (k <= m1)) {
#line 1376
          goto while_break___5;
        }
#line 1377
        if (k != i) {
          {
#line 1377
          tmp___3 = set_member(k, poly->Ared);
          }
#line 1377
          if (! tmp___3) {
            {
#line 1377
            tmp___4 = set_member(k, poly->Adom);
            }
#line 1377
            if (! tmp___4) {
              {
#line 1377
              tmp___5 = set_subset(*(poly->Ainc + (i - 1L)), *(poly->Ainc + (k - 1L)));
              }
#line 1377
              if (tmp___5) {
#line 1379
                if (! redundant) {
#line 1380
                  redundant = 1;
                }
                {
#line 1382
                set_addelem(poly->Ared, i);
                }
              }
            }
          }
        }
#line 1376
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1370
    i --;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1387
  dd_FreeMatrix(M);
#line 1388
  poly->AincGenerated = 1;
  }
  _L99: 
  {
#line 1390
  __gmpq_clear(sum);
#line 1390
  __gmpq_clear(temp);
  }
#line 1391
  return;
}
}
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___0  ;
#line 1405
dd_boolean dd_InputAdjacentQ(dd_PolyhedraPtr poly , dd_rowrange i1 , dd_rowrange i2 ) ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___0  =    0L;
#line 1393 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_boolean dd_InputAdjacentQ(dd_PolyhedraPtr poly , dd_rowrange i1 , dd_rowrange i2 ) 
{ 
  dd_boolean adj ;
  dd_rowrange i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1402
  adj = 1;
#line 1407
  if (poly->AincGenerated == 0) {
    {
#line 1407
    dd_ComputeAinc(poly);
    }
  }
#line 1408
  if (lastn___0 != poly->n) {
#line 1409
    if (lastn___0 > 0L) {
      {
#line 1409
      set_free(common___0);
      }
    }
    {
#line 1410
    set_initialize(& common___0, poly->n);
#line 1411
    lastn___0 = poly->n;
    }
  }
  {
#line 1413
  tmp = set_member(i1, poly->Ared);
  }
#line 1413
  if (tmp) {
#line 1414
    adj = 0;
#line 1415
    goto _L99;
  } else {
    {
#line 1413
    tmp___0 = set_member(i2, poly->Ared);
    }
#line 1413
    if (tmp___0) {
#line 1414
      adj = 0;
#line 1415
      goto _L99;
    }
  }
  {
#line 1417
  tmp___1 = set_member(i1, poly->Adom);
  }
#line 1417
  if (tmp___1) {
#line 1419
    adj = 1;
#line 1420
    goto _L99;
  } else {
    {
#line 1417
    tmp___2 = set_member(i2, poly->Adom);
    }
#line 1417
    if (tmp___2) {
#line 1419
      adj = 1;
#line 1420
      goto _L99;
    }
  }
  {
#line 1422
  set_int(common___0, *(poly->Ainc + (i1 - 1L)), *(poly->Ainc + (i2 - 1L)));
#line 1423
  i = (dd_rowrange )0;
  }
  {
#line 1424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1424
    if (i < poly->m1) {
#line 1424
      if (! (adj == 1)) {
#line 1424
        goto while_break;
      }
    } else {
#line 1424
      goto while_break;
    }
#line 1425
    i ++;
#line 1426
    if (i != i1) {
#line 1426
      if (i != i2) {
        {
#line 1426
        tmp___3 = set_member(i, poly->Ared);
        }
#line 1426
        if (! tmp___3) {
          {
#line 1426
          tmp___4 = set_member(i, poly->Adom);
          }
#line 1426
          if (! tmp___4) {
            {
#line 1426
            tmp___5 = set_subset(common___0, *(poly->Ainc + (i - 1L)));
            }
#line 1426
            if (tmp___5) {
#line 1428
              adj = 0;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 1432
  return (adj);
}
}
#line 1436 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteInputIncidence(FILE *f , dd_PolyhedraPtr poly ) 
{ 
  dd_SetFamilyPtr I ;

  {
#line 1440
  if (poly->AincGenerated == 0) {
    {
#line 1440
    dd_ComputeAinc(poly);
    }
  }
  {
#line 1442
  if ((unsigned int )poly->representation == 1U) {
#line 1442
    goto case_1;
  }
#line 1446
  if ((unsigned int )poly->representation == 2U) {
#line 1446
    goto case_2;
  }
#line 1450
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1443
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"icd_file: Incidence of inequalities and generators\n");
  }
#line 1444
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1447
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"ecd_file: Incidence of generators and inequalities\n");
  }
#line 1448
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1451
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1454
  I = dd_CopyInputIncidence(poly);
#line 1455
  dd_WriteSetFamilyCompressed(f, I);
#line 1456
  dd_FreeSetFamily(I);
  }
#line 1457
  return;
}
}
#line 1459 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteInputAdjacency(FILE *f , dd_PolyhedraPtr poly ) 
{ 
  dd_SetFamilyPtr A ;

  {
#line 1463
  if (poly->AincGenerated == 0) {
    {
#line 1464
    dd_ComputeAinc(poly);
    }
  }
  {
#line 1467
  if ((unsigned int )poly->representation == 1U) {
#line 1467
    goto case_1;
  }
#line 1471
  if ((unsigned int )poly->representation == 2U) {
#line 1471
    goto case_2;
  }
#line 1475
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1468
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"iad_file: Adjacency of inequalities\n");
  }
#line 1469
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1472
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"ead_file: Adjacency of generators\n");
  }
#line 1473
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1476
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1478
  A = dd_CopyInputAdjacency(poly);
#line 1479
  dd_WriteSetFamilyCompressed(f, A);
#line 1480
  dd_FreeSetFamily(A);
  }
#line 1481
  return;
}
}
#line 1484 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteProgramDescription(FILE *f ) 
{ 


  {
  {
#line 1486
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* cddlib: a double description library:%s\n",
          "Version 0.94g (March 23, 2012)");
#line 1487
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* compiled for %s arithmetic.\n",
          "GMP rational");
#line 1488
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* %s\n", "Copyright (C) 1996, Komei Fukuda, fukuda@ifor.math.ethz.ch");
  }
#line 1489
  return;
}
}
#line 1491 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteTimes(FILE *f , time_t starttime , time_t endtime ) 
{ 
  long ptime ;
  long ptime_sec ;
  long ptime_minu ;
  long ptime_hour ;
  struct tm *tmp ;
  char *tmp___0 ;
  struct tm *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1499
  ptime = endtime - starttime;
#line 1502
  ptime_hour = ptime / 3600L;
#line 1503
  ptime_minu = (ptime - ptime_hour * 3600L) / 60L;
#line 1504
  ptime_sec = ptime % 60L;
#line 1505
  tmp = localtime((time_t const   *)(& starttime));
#line 1505
  tmp___0 = asctime((struct tm  const  *)tmp);
#line 1505
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Computation started at %s",
          tmp___0);
#line 1506
  tmp___1 = localtime((time_t const   *)(& endtime));
#line 1506
  tmp___2 = asctime((struct tm  const  *)tmp___1);
#line 1506
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*             ended   at %s",
          tmp___2);
#line 1507
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Total processor time = %ld seconds\n",
          ptime);
#line 1508
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*                      = %ld h %ld m %ld s\n",
          ptime_hour, ptime_minu, ptime_sec);
  }
#line 1509
  return;
}
}
#line 1511 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteDDTimes(FILE *f , dd_PolyhedraPtr poly ) 
{ 


  {
  {
#line 1513
  dd_WriteTimes(f, (poly->child)->starttime, (poly->child)->endtime);
  }
#line 1514
  return;
}
}
#line 1516 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteLPTimes(FILE *f , dd_LPPtr lp ) 
{ 


  {
  {
#line 1518
  dd_WriteTimes(f, lp->starttime, lp->endtime);
  }
#line 1519
  return;
}
}
#line 1521 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteLPStats(FILE *f ) 
{ 
  time_t currenttime ;

  {
  {
#line 1525
  time(& currenttime);
#line 1527
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n*--- Statistics of pivots ---\n");
#line 1529
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* f0 = %ld (float basis finding pivots)\n",
          ddf_statBApivots);
#line 1530
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* fc = %ld (float CC pivots)\n",
          ddf_statCCpivots);
#line 1531
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* f1 = %ld (float dual simplex phase I pivots)\n",
          ddf_statDS1pivots);
#line 1532
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* f2 = %ld (float dual simplex phase II pivots)\n",
          ddf_statDS2pivots);
#line 1533
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* f3 = %ld (float anticycling CC pivots)\n",
          ddf_statACpivots);
#line 1534
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* e0 = %ld (exact basis finding pivots)\n",
          dd_statBApivots);
#line 1535
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* ec = %ld (exact CC pivots)\n",
          dd_statCCpivots);
#line 1536
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* e1 = %ld (exact dual simplex phase I pivots)\n",
          dd_statDS1pivots);
#line 1537
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* e2 = %ld (exact dual simplex phase II pivots)\n",
          dd_statDS2pivots);
#line 1538
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* e3 = %ld (exact anticycling CC pivots)\n",
          dd_statACpivots);
#line 1539
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* e4 = %ld (exact basis verification pivots)\n",
          dd_statBSpivots);
#line 1547
  dd_WriteLPMode(f);
#line 1548
  dd_WriteTimes(f, dd_statStartTime, currenttime);
  }
#line 1549
  return;
}
}
#line 1551 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteLPMode(FILE *f ) 
{ 


  {
  {
#line 1553
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n* LP solver: ");
  }
  {
#line 1555
  if ((unsigned int )dd_choiceLPSolverDefault == 1U) {
#line 1555
    goto case_1;
  }
#line 1558
  if ((unsigned int )dd_choiceLPSolverDefault == 0U) {
#line 1558
    goto case_0;
  }
#line 1561
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1556
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"DualSimplex\n");
  }
#line 1557
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1559
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"Criss-Cross\n");
  }
#line 1560
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1561
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1564
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Redundancy cheking solver: ");
  }
  {
#line 1566
  if ((unsigned int )dd_choiceRedcheckAlgorithm == 1U) {
#line 1566
    goto case_1___0;
  }
#line 1569
  if ((unsigned int )dd_choiceRedcheckAlgorithm == 0U) {
#line 1569
    goto case_0___0;
  }
#line 1572
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 1567
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"DualSimplex\n");
  }
#line 1568
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 1570
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"Criss-Cross\n");
  }
#line 1571
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1572
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1575
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* Lexicographic pivot: ");
  }
#line 1576
  if (dd_choiceLexicoPivotQ) {
    {
#line 1576
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" on\n");
    }
  } else {
    {
#line 1577
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" off\n");
    }
  }
#line 1579
  return;
}
}
#line 1582 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteRunningMode(FILE *f , dd_PolyhedraPtr poly ) 
{ 


  {
#line 1584
  if ((unsigned long )poly->child != (unsigned long )((void *)0)) {
    {
#line 1585
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* roworder: ");
    }
    {
#line 1588
    if ((unsigned int )(poly->child)->HalfspaceOrder == 1U) {
#line 1588
      goto case_1;
    }
#line 1592
    if ((unsigned int )(poly->child)->HalfspaceOrder == 0U) {
#line 1592
      goto case_0;
    }
#line 1596
    if ((unsigned int )(poly->child)->HalfspaceOrder == 2U) {
#line 1596
      goto case_2;
    }
#line 1600
    if ((unsigned int )(poly->child)->HalfspaceOrder == 3U) {
#line 1600
      goto case_3;
    }
#line 1604
    if ((unsigned int )(poly->child)->HalfspaceOrder == 4U) {
#line 1604
      goto case_4;
    }
#line 1608
    if ((unsigned int )(poly->child)->HalfspaceOrder == 5U) {
#line 1608
      goto case_5;
    }
#line 1612
    if ((unsigned int )(poly->child)->HalfspaceOrder == 6U) {
#line 1612
      goto case_6;
    }
#line 1616
    if ((unsigned int )(poly->child)->HalfspaceOrder == 7U) {
#line 1616
      goto case_7;
    }
#line 1620
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1589
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"minindex\n");
    }
#line 1590
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1593
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"maxindex\n");
    }
#line 1594
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1597
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"mincutoff\n");
    }
#line 1598
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1601
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"maxcutoff\n");
    }
#line 1602
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1605
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"mixcutoff\n");
    }
#line 1606
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1609
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"lexmin\n");
    }
#line 1610
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1613
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"lexmax\n");
    }
#line 1614
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1617
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"random  %d\n",
            (poly->child)->rseed);
    }
#line 1618
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1620
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1623
  return;
}
}
#line 1626 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteCompletionStatus(FILE *f , dd_ConePtr cone ) 
{ 


  {
#line 1628
  if (cone->Iteration < cone->m) {
#line 1628
    if ((unsigned int )cone->CompStatus == 1U) {
      {
#line 1629
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Computation completed at Iteration %4ld.\n",
              cone->Iteration);
      }
    }
  }
#line 1631
  if ((unsigned int )cone->CompStatus == 2U) {
    {
#line 1632
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Computation completed at Iteration %4ld because the region found empty.\n",
            cone->Iteration);
    }
  }
#line 1634
  return;
}
}
#line 1636 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WritePolyFile(FILE *f , dd_PolyhedraPtr poly ) 
{ 


  {
  {
#line 1638
  dd_WriteAmatrix(f, poly->A, poly->m, poly->d);
  }
#line 1639
  return;
}
}
#line 1642 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_WriteErrorMessages(FILE *f , dd_ErrorType Error ) 
{ 


  {
  {
#line 1646
  if ((unsigned int )Error == 0U) {
#line 1646
    goto case_0;
  }
#line 1651
  if ((unsigned int )Error == 6U) {
#line 1651
    goto case_6;
  }
#line 1655
  if ((unsigned int )Error == 7U) {
#line 1655
    goto case_7;
  }
#line 1659
  if ((unsigned int )Error == 2U) {
#line 1659
    goto case_2;
  }
#line 1664
  if ((unsigned int )Error == 1U) {
#line 1664
    goto case_1;
  }
#line 1673
  if ((unsigned int )Error == 3U) {
#line 1673
    goto case_3;
  }
#line 1678
  if ((unsigned int )Error == 4U) {
#line 1678
    goto case_4;
  }
#line 1682
  if ((unsigned int )Error == 5U) {
#line 1682
    goto case_5;
  }
#line 1686
  if ((unsigned int )Error == 8U) {
#line 1686
    goto case_8;
  }
#line 1690
  if ((unsigned int )Error == 9U) {
#line 1690
    goto case_9;
  }
#line 1695
  if ((unsigned int )Error == 10U) {
#line 1695
    goto case_10;
  }
#line 1699
  if ((unsigned int )Error == 11U) {
#line 1699
    goto case_11;
  }
#line 1703
  if ((unsigned int )Error == 12U) {
#line 1703
    goto case_12;
  }
#line 1707
  if ((unsigned int )Error == 13U) {
#line 1707
    goto case_13;
  }
#line 1711
  if ((unsigned int )Error == 14U) {
#line 1711
    goto case_14;
  }
#line 1715
  if ((unsigned int )Error == 15U) {
#line 1715
    goto case_15;
  }
#line 1719
  if ((unsigned int )Error == 16U) {
#line 1719
    goto case_16;
  }
#line 1723
  if ((unsigned int )Error == 17U) {
#line 1723
    goto case_17;
  }
#line 1644
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1647
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: Input matrix is too large:\n");
#line 1648
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Please increase MMAX and/or NMAX in the source code and recompile.\n");
  }
#line 1649
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1652
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: Specified input file does not exist.\n");
  }
#line 1653
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1656
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Output Error: Specified output file cannot be opened.\n");
  }
#line 1657
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1660
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: Input matrix has a negative size:\n");
#line 1661
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Please check rowsize or colsize.\n");
  }
#line 1662
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1665
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: Input format is not correct.\n");
#line 1666
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Format:\n");
#line 1667
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" begin\n");
#line 1668
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"   m   n  NumberType(real, rational or integer)\n");
#line 1669
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"   b  -A\n");
#line 1670
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" end\n");
  }
#line 1671
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1674
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: V-representation is empty:\n");
#line 1675
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*cddlib does not accept this trivial case for which output can be any inconsistent system.\n");
  }
#line 1676
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1679
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: H-representation is empty.\n");
  }
#line 1680
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1683
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Input Error: Representation is empty.\n");
  }
#line 1684
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1687
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*LP Error: No LP objective (max or min) is set.\n");
  }
#line 1688
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1691
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*LP Error: The binary (with GMP Rational) does not support Real number input.\n");
#line 1692
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"         : Use a binary compiled without -DGMPRATIONAL option.\n");
  }
#line 1693
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1696
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: A function is called with H-rep which does not support an H-representation.\n");
  }
#line 1697
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 1700
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: A function is called with V-rep which does not support an V-representation.\n");
  }
#line 1701
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1704
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: The function called cannot handle linearity.\n");
  }
#line 1705
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 1708
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: Specified row index is out of range\n");
  }
#line 1709
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 1712
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: Specified column index is out of range\n");
  }
#line 1713
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 1716
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: Possibly an LP cycling occurs.  Use the Criss-Cross method.\n");
  }
#line 1717
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 1720
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*Error: Numerical inconsistency is found.  Use the GMP exact arithmetic.\n");
  }
#line 1721
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 1724
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*No Error found.\n");
  }
#line 1725
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1727
  return;
}
}
#line 1730 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_SetFamilyPtr dd_CopyIncidence(dd_PolyhedraPtr poly ) 
{ 
  dd_SetFamilyPtr F ;
  dd_bigrange k ;
  dd_rowrange i ;
  int tmp ;

  {
#line 1732
  F = (dd_SetFamilyPtr )((void *)0);
#line 1736
  if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 1736
    goto _L99;
  } else
#line 1736
  if ((unsigned int )(poly->child)->CompStatus != 1U) {
#line 1736
    goto _L99;
  }
#line 1737
  if (poly->AincGenerated == 0) {
    {
#line 1737
    dd_ComputeAinc(poly);
    }
  }
  {
#line 1738
  F = dd_CreateSetFamily(poly->n, poly->m1);
#line 1739
  i = (dd_rowrange )1;
  }
  {
#line 1739
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1739
    if (! (i <= poly->m1)) {
#line 1739
      goto while_break;
    }
#line 1740
    k = (dd_bigrange )1;
    {
#line 1740
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1740
      if (! (k <= poly->n)) {
#line 1740
        goto while_break___0;
      }
      {
#line 1741
      tmp = set_member(k, *(poly->Ainc + (i - 1L)));
      }
#line 1741
      if (tmp) {
        {
#line 1741
        set_addelem(*(F->set + (k - 1L)), i);
        }
      }
#line 1740
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1739
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 1743
  return (F);
}
}
#line 1746 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_SetFamilyPtr dd_CopyInputIncidence(dd_PolyhedraPtr poly ) 
{ 
  dd_rowrange i ;
  dd_SetFamilyPtr F ;

  {
#line 1749
  F = (dd_SetFamilyPtr )((void *)0);
#line 1751
  if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 1751
    goto _L99;
  } else
#line 1751
  if ((unsigned int )(poly->child)->CompStatus != 1U) {
#line 1751
    goto _L99;
  }
#line 1752
  if (poly->AincGenerated == 0) {
    {
#line 1752
    dd_ComputeAinc(poly);
    }
  }
  {
#line 1753
  F = dd_CreateSetFamily(poly->m1, poly->n);
#line 1754
  i = (dd_rowrange )0;
  }
  {
#line 1754
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1754
    if (! (i < poly->m1)) {
#line 1754
      goto while_break;
    }
    {
#line 1755
    set_copy(*(F->set + i), *(poly->Ainc + i));
#line 1754
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 1758
  return (F);
}
}
#line 1761 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_SetFamilyPtr dd_CopyAdjacency(dd_PolyhedraPtr poly ) 
{ 
  dd_RayPtr RayPtr1 ;
  dd_RayPtr RayPtr2 ;
  dd_SetFamilyPtr F ;
  long pos1 ;
  long pos2 ;
  dd_bigrange lstart ;
  dd_bigrange k ;
  dd_bigrange n ;
  set_type linset ;
  set_type allset ;
  dd_boolean adj ;

  {
#line 1764
  F = (dd_SetFamilyPtr )((void *)0);
#line 1770
  if (poly->n == 0L) {
#line 1770
    if (poly->homogeneous) {
#line 1770
      if ((unsigned int )poly->representation == 1U) {
#line 1771
        n = (dd_bigrange )1;
      } else {
#line 1772
        n = poly->n;
      }
    } else {
#line 1772
      n = poly->n;
    }
  } else {
#line 1772
    n = poly->n;
  }
  {
#line 1773
  set_initialize(& linset, n);
#line 1774
  set_initialize(& allset, n);
  }
#line 1775
  if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 1775
    goto _L99;
  } else
#line 1775
  if ((unsigned int )(poly->child)->CompStatus != 1U) {
#line 1775
    goto _L99;
  }
  {
#line 1776
  F = dd_CreateSetFamily(n, n);
  }
#line 1777
  if (n <= 0L) {
#line 1777
    goto _L99;
  }
#line 1778
  ((poly->child)->LastRay)->Next = (dd_RayPtr )((void *)0);
#line 1779
  RayPtr1 = (poly->child)->FirstRay;
#line 1779
  pos1 = 1L;
  {
#line 1779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1779
    if (! ((unsigned long )RayPtr1 != (unsigned long )((void *)0))) {
#line 1779
      goto while_break;
    }
#line 1781
    RayPtr2 = (poly->child)->FirstRay;
#line 1781
    pos2 = 1L;
    {
#line 1781
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1781
      if (! ((unsigned long )RayPtr2 != (unsigned long )((void *)0))) {
#line 1781
        goto while_break___0;
      }
#line 1783
      if ((unsigned long )RayPtr1 != (unsigned long )RayPtr2) {
        {
#line 1784
        dd_CheckAdjacency(poly->child, & RayPtr1, & RayPtr2, & adj);
        }
#line 1785
        if (adj) {
          {
#line 1786
          set_addelem(*(F->set + (pos1 - 1L)), pos2);
          }
        }
      }
#line 1781
      RayPtr2 = RayPtr2->Next;
#line 1781
      pos2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1779
    RayPtr1 = RayPtr1->Next;
#line 1779
    pos1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1791
  lstart = (poly->n - poly->ldim) + 1L;
#line 1792
  set_compl(allset, allset);
#line 1793
  k = lstart;
  }
  {
#line 1793
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1793
    if (! (k <= poly->n)) {
#line 1793
      goto while_break___1;
    }
    {
#line 1794
    set_addelem(linset, k);
#line 1795
    set_copy(*(F->set + (k - 1L)), allset);
#line 1793
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1797
  k = (dd_bigrange )1;
  {
#line 1797
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1797
    if (! (k < lstart)) {
#line 1797
      goto while_break___2;
    }
    {
#line 1798
    set_uni(*(F->set + (k - 1L)), *(F->set + (k - 1L)), linset);
#line 1797
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  _L99: 
  {
#line 1802
  set_free(allset);
#line 1802
  set_free(linset);
  }
#line 1803
  return (F);
}
}
#line 1806 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_SetFamilyPtr dd_CopyInputAdjacency(dd_PolyhedraPtr poly ) 
{ 
  dd_rowrange i ;
  dd_rowrange j ;
  dd_SetFamilyPtr F ;
  dd_boolean tmp ;

  {
#line 1809
  F = (dd_SetFamilyPtr )((void *)0);
#line 1811
  if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 1811
    goto _L99;
  } else
#line 1811
  if ((unsigned int )(poly->child)->CompStatus != 1U) {
#line 1811
    goto _L99;
  }
#line 1812
  if (poly->AincGenerated == 0) {
    {
#line 1812
    dd_ComputeAinc(poly);
    }
  }
  {
#line 1813
  F = dd_CreateSetFamily(poly->m1, poly->m1);
#line 1814
  i = (dd_rowrange )1;
  }
  {
#line 1814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1814
    if (! (i <= poly->m1)) {
#line 1814
      goto while_break;
    }
#line 1815
    j = (dd_rowrange )1;
    {
#line 1815
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1815
      if (! (j <= poly->m1)) {
#line 1815
        goto while_break___0;
      }
#line 1816
      if (i != j) {
        {
#line 1816
        tmp = dd_InputAdjacentQ(poly, i, j);
        }
#line 1816
        if (tmp) {
          {
#line 1817
          set_addelem(*(F->set + (i - 1L)), j);
          }
        }
      }
#line 1815
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1814
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  _L99: ;
#line 1822
  return (F);
}
}
#line 1825 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_CopyOutput(dd_PolyhedraPtr poly ) 
{ 
  dd_RayPtr RayPtr ;
  dd_MatrixPtr M ;
  dd_rowrange i ;
  dd_rowrange total ;
  dd_colrange j ;
  dd_colrange j1___0 ;
  mytype b ;
  dd_RepresentationType outputrep ;
  dd_boolean outputorigin ;
  dd_boolean tmp ;

  {
  {
#line 1828
  M = (dd_MatrixPtr )((void *)0);
#line 1829
  i = (dd_rowrange )0;
#line 1832
  outputrep = (dd_RepresentationType )1;
#line 1833
  outputorigin = 0;
#line 1835
  __gmpq_init(b);
#line 1836
  total = (poly->child)->LinearityDim + (poly->child)->FeasibleRayCount;
  }
#line 1838
  if ((poly->child)->d <= 0L) {
#line 1838
    total --;
  } else
#line 1838
  if (*((poly->child)->newcol + 1) == 0L) {
#line 1838
    total --;
  }
#line 1839
  if ((unsigned int )poly->representation == 1U) {
#line 1839
    outputrep = (dd_RepresentationType )2;
  }
#line 1840
  if (total == 0L) {
#line 1840
    if (poly->homogeneous) {
#line 1840
      if ((unsigned int )poly->representation == 1U) {
#line 1841
        total = (dd_rowrange )1;
#line 1842
        outputorigin = 1;
      }
    }
  }
#line 1845
  if ((unsigned long )poly->child == (unsigned long )((void *)0)) {
#line 1845
    goto _L99;
  } else
#line 1845
  if ((unsigned int )(poly->child)->CompStatus != 1U) {
#line 1845
    goto _L99;
  }
  {
#line 1847
  M = dd_CreateMatrix(total, poly->d);
#line 1848
  RayPtr = (poly->child)->FirstRay;
  }
  {
#line 1849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1849
    if (! ((unsigned long )RayPtr != (unsigned long )((void *)0))) {
#line 1849
      goto while_break;
    }
#line 1850
    if (RayPtr->feasible) {
      {
#line 1851
      dd_CopyRay(*(M->matrix + i), poly->d, RayPtr, outputrep, (poly->child)->newcol);
#line 1852
      i ++;
      }
    }
#line 1854
    RayPtr = RayPtr->Next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1856
  j = (dd_colrange )2;
  {
#line 1856
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1856
    if (! (j <= poly->d)) {
#line 1856
      goto while_break___0;
    }
#line 1857
    if (*((poly->child)->newcol + j) == 0L) {
      {
#line 1859
      __gmpq_set(b, (mpq_srcptr )(*(*((poly->child)->Bsave + 0) + (j - 1L))));
      }
#line 1860
      if ((unsigned int )outputrep == 2U) {
        {
#line 1860
        tmp = dd_Positive((__mpq_struct *)(b));
        }
#line 1860
        if (tmp) {
          {
#line 1861
          __gmpq_set(*(*(M->matrix + i) + 0), (mpq_srcptr )(dd_one));
#line 1862
          j1___0 = (dd_colrange )1;
          }
          {
#line 1862
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1862
            if (! (j1___0 < poly->d)) {
#line 1862
              goto while_break___1;
            }
            {
#line 1863
            __gmpq_div(*(*(M->matrix + i) + j1___0), (mpq_srcptr )(*(*((poly->child)->Bsave + j1___0) + (j - 1L))),
                       (mpq_srcptr )(b));
#line 1862
            j1___0 ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 1860
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1865
        j1___0 = (dd_colrange )0;
        {
#line 1865
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1865
          if (! (j1___0 < poly->d)) {
#line 1865
            goto while_break___2;
          }
          {
#line 1866
          __gmpq_set(*(*(M->matrix + i) + j1___0), (mpq_srcptr )(*(*((poly->child)->Bsave + j1___0) + (j - 1L))));
#line 1865
          j1___0 ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 1868
      set_addelem(M->linset, i + 1L);
#line 1869
      i ++;
      }
    }
#line 1856
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1872
  if (outputorigin) {
    {
#line 1874
    __gmpq_set(*(*(M->matrix + 0) + 0), (mpq_srcptr )(dd_one));
#line 1875
    j = (dd_colrange )1;
    }
    {
#line 1875
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1875
      if (! (j < poly->d)) {
#line 1875
        goto while_break___3;
      }
      {
#line 1876
      __gmpq_set(*(*(M->matrix + 0) + j), (mpq_srcptr )(dd_purezero));
#line 1875
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 1879
  dd_MatrixIntegerFilter(M);
  }
#line 1880
  if ((unsigned int )poly->representation == 1U) {
#line 1881
    M->representation = (dd_RepresentationType )2;
  } else {
#line 1883
    M->representation = (dd_RepresentationType )1;
  }
  _L99: 
  {
#line 1885
  __gmpq_clear(b);
  }
#line 1886
  return (M);
}
}
#line 1889 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_CopyInput(dd_PolyhedraPtr poly ) 
{ 
  dd_MatrixPtr M ;
  dd_rowrange i ;

  {
  {
#line 1891
  M = (dd_MatrixPtr )((void *)0);
#line 1894
  M = dd_CreateMatrix(poly->m, poly->d);
#line 1895
  dd_CopyAmatrix(M->matrix, poly->A, poly->m, poly->d);
#line 1896
  i = (dd_rowrange )1;
  }
  {
#line 1896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1896
    if (! (i <= poly->m)) {
#line 1896
      goto while_break;
    }
#line 1897
    if (*(poly->EqualityIndex + i) == 1) {
      {
#line 1897
      set_addelem(M->linset, i);
      }
    }
#line 1896
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1898
  dd_MatrixIntegerFilter(M);
  }
#line 1899
  if ((unsigned int )poly->representation == 2U) {
#line 1900
    M->representation = (dd_RepresentationType )2;
  } else {
#line 1902
    M->representation = (dd_RepresentationType )1;
  }
#line 1903
  return (M);
}
}
#line 1906 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_CopyGenerators(dd_PolyhedraPtr poly ) 
{ 
  dd_MatrixPtr M ;

  {
#line 1908
  M = (dd_MatrixPtr )((void *)0);
#line 1910
  if ((unsigned int )poly->representation == 2U) {
    {
#line 1911
    M = dd_CopyInput(poly);
    }
  } else {
    {
#line 1913
    M = dd_CopyOutput(poly);
    }
  }
#line 1915
  return (M);
}
}
#line 1918 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
dd_MatrixPtr dd_CopyInequalities(dd_PolyhedraPtr poly ) 
{ 
  dd_MatrixPtr M ;

  {
#line 1920
  M = (dd_MatrixPtr )((void *)0);
#line 1922
  if ((unsigned int )poly->representation == 1U) {
    {
#line 1923
    M = dd_CopyInput(poly);
    }
  } else {
    {
#line 1925
    M = dd_CopyOutput(poly);
    }
  }
#line 1927
  return (M);
}
}
#line 1933 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_sread_rational_value(char const   *s , __mpq_struct *value ) 
{ 
  char *numerator_s ;
  char *denominator_s ;
  char *position ;
  int sign ;
  double numerator ;
  double denominator ;
  mpz_t znum ;
  mpz_t zden ;
  long tmp ;
  long tmp___0 ;

  {
#line 1937
  numerator_s = (char *)((void *)0);
#line 1937
  denominator_s = (char *)((void *)0);
#line 1938
  sign = 1;
#line 1947
  numerator_s = (char *)s;
#line 1948
  if ((int const   )*(s + 0) == 45) {
#line 1949
    sign = -1;
#line 1950
    numerator_s ++;
  } else
#line 1952
  if ((int const   )*(s + 0) == 43) {
#line 1953
    numerator_s ++;
  }
  {
#line 1956
  position = strchr((char const   *)numerator_s, '/');
  }
#line 1957
  if ((unsigned long )position != (unsigned long )((void *)0)) {
#line 1958
    *position = (char )'\000';
#line 1959
    denominator_s = position + 1;
  }
  {
#line 1963
  tmp = atol((char const   *)numerator_s);
#line 1963
  numerator = (double )tmp;
  }
#line 1965
  if ((unsigned long )position != (unsigned long )((void *)0)) {
    {
#line 1967
    tmp___0 = atol((char const   *)denominator_s);
#line 1967
    denominator = (double )tmp___0;
    }
  } else {
#line 1969
    denominator = (double )1;
  }
  {
#line 1978
  __gmpz_init_set_str(znum, (char const   *)numerator_s, 10);
  }
#line 1979
  if (sign < 0) {
    {
#line 1979
    __gmpz_neg(znum, (mpz_srcptr )(znum));
    }
  }
  {
#line 1980
  __gmpz_init(zden);
#line 1980
  __gmpz_set_ui(zden, 1UL);
  }
#line 1981
  if ((unsigned long )denominator_s != (unsigned long )((void *)0)) {
    {
#line 1981
    __gmpz_init_set_str(zden, (char const   *)denominator_s, 10);
    }
  }
  {
#line 1982
  __gmpq_set_num((mpq_ptr )value, (mpz_srcptr )(znum));
#line 1982
  __gmpq_set_den((mpq_ptr )value, (mpz_srcptr )(zden));
#line 1983
  __gmpq_canonicalize((mpq_ptr )value);
#line 1984
  __gmpz_clear(znum);
#line 1984
  __gmpz_clear(zden);
  }
#line 1995
  if (dd_debug) {
    {
#line 1996
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rational_read: ");
#line 1997
    dd_WriteNumber(stderr, value);
#line 1997
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 1999
  return;
}
}
#line 2002 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
void dd_fread_rational_value(FILE *f , __mpq_struct *value ) 
{ 
  char number_s[1024] ;
  mytype rational_value ;

  {
  {
#line 2009
  __gmpq_init(rational_value);
#line 2010
  fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s ", number_s);
#line 2011
  dd_sread_rational_value((char const   *)(number_s), (__mpq_struct *)(rational_value));
#line 2012
  __gmpq_set((mpq_ptr )value, (mpq_srcptr )(rational_value));
#line 2013
  __gmpq_clear(rational_value);
  }
#line 2014
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.h"
unsigned long set_blocks(long len ) ;
#line 38
long set_groundsize(set_type set ) ;
#line 42
void set_binwrite(set_type set ) ;
#line 43
void set_fbinwrite(FILE *f , set_type set ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 37 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
unsigned long set_blocks(long len ) 
{ 
  long blocks ;

  {
#line 39
  blocks = 1L;
#line 41
  if (len > 0L) {
#line 41
    blocks = (long )((unsigned long )(len - 1L) / (sizeof(long ) * 8UL) + 2UL);
  }
#line 42
  return ((unsigned long )blocks);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_initialize(set_type *setp , long length ) 
{ 
  long i ;
  long forlim1 ;
  long len ;
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 50
  if (length <= 0L) {
#line 50
    len = 1L;
  } else {
#line 50
    len = length;
  }
  {
#line 53
  tmp = set_blocks(len);
#line 53
  forlim1 = (long )tmp;
#line 54
  tmp___0 = calloc((size_t )forlim1, sizeof(i));
#line 54
  *setp = (unsigned long *)tmp___0;
#line 55
  *(*setp + 0) = (unsigned long )len;
#line 56
  i = 1L;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i < forlim1)) {
#line 56
      goto while_break;
    }
#line 57
    *(*setp + i) = 0UL;
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_free(set_type set ) 
{ 


  {
  {
#line 63
  free((void *)set);
  }
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_emptyset(set_type set ) 
{ 
  long i ;
  long forlim ;
  unsigned long tmp ;

  {
  {
#line 71
  tmp = set_blocks((long )*(set + 0));
#line 71
  forlim = (long )(tmp - 1UL);
#line 72
  i = 1L;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! (i <= forlim)) {
#line 72
      goto while_break;
    }
#line 73
    *(set + i) = 0UL;
#line 72
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_copy(set_type setcopy , set_type set ) 
{ 
  long i ;
  long forlim ;
  unsigned long tmp ;

  {
  {
#line 81
  tmp = set_blocks((long )*(setcopy + 0));
#line 81
  forlim = (long )(tmp - 1UL);
#line 82
  i = 1L;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i <= forlim)) {
#line 82
      goto while_break;
    }
#line 83
    *(setcopy + i) = *(set + i);
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_addelem(set_type set , long elem ) 
{ 
  long i ;
  long j ;
  unsigned long change ;
  unsigned long one ;

  {
#line 91
  one = 1UL;
#line 93
  if ((unsigned long )elem <= *(set + 0)) {
#line 95
    i = (long )((unsigned long )(elem - 1L) / (sizeof(long ) * 8UL) + 1UL);
#line 96
    j = (long )((unsigned long )(elem - 1L) % (sizeof(long ) * 8UL));
#line 97
    change = one << j;
#line 98
    *(set + i) |= change;
  }
#line 100
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_delelem(set_type set , long elem ) 
{ 
  long i ;
  long j ;
  unsigned long change ;
  unsigned long one ;

  {
#line 107
  one = 1UL;
#line 109
  if ((unsigned long )elem <= *(set + 0)) {
#line 111
    i = (long )((unsigned long )(elem - 1L) / (sizeof(long ) * 8UL) + 1UL);
#line 112
    j = (long )((unsigned long )(elem - 1L) % (sizeof(long ) * 8UL));
#line 113
    change = one << j;
#line 114
    *(set + i) = (*(set + i) | change) ^ change;
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_int(set_type set , set_type set1 , set_type set2 ) 
{ 
  long i ;
  long forlim ;
  unsigned long tmp ;

  {
  {
#line 123
  tmp = set_blocks((long )*(set + 0));
#line 123
  forlim = (long )(tmp - 1UL);
#line 124
  i = 1L;
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i <= forlim)) {
#line 124
      goto while_break;
    }
#line 125
    *(set + i) = *(set1 + i) & *(set2 + i);
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_uni(set_type set , set_type set1 , set_type set2 ) 
{ 
  long i ;
  long forlim ;
  unsigned long tmp ;

  {
  {
#line 133
  tmp = set_blocks((long )*(set + 0));
#line 133
  forlim = (long )(tmp - 1UL);
#line 134
  i = 1L;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (i <= forlim)) {
#line 134
      goto while_break;
    }
#line 135
    *(set + i) = *(set1 + i) | *(set2 + i);
#line 134
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_diff(set_type set , set_type set1 , set_type set2 ) 
{ 
  long i ;
  long forlim ;
  unsigned long tmp ;

  {
  {
#line 143
  tmp = set_blocks((long )*(set + 0));
#line 143
  forlim = (long )(tmp - 1UL);
#line 144
  i = 1L;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i <= forlim)) {
#line 144
      goto while_break;
    }
#line 145
    *(set + i) = *(set1 + i) & ~ *(set2 + i);
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_compl(set_type set , set_type set1 ) 
{ 
  long i ;
  long j ;
  long l ;
  long forlim ;
  unsigned long change ;
  unsigned long one ;
  unsigned long tmp ;

  {
  {
#line 153
  one = 1UL;
#line 155
  tmp = set_blocks((long )*(set + 0));
#line 155
  forlim = (long )(tmp - 1UL);
#line 156
  i = 1L;
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i <= forlim)) {
#line 156
      goto while_break;
    }
#line 157
    *(set + i) = ~ *(set1 + i);
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  l = (long )((*(set + 0) - 1UL) % (sizeof(long ) * 8UL));
#line 163
  j = l + 1L;
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 163
    if (! ((unsigned long )j <= sizeof(long ) * 8UL - 1UL)) {
#line 163
      goto while_break___0;
    }
#line 164
    change = one << j;
#line 165
    *(set + forlim) = (*(set + forlim) | change) ^ change;
#line 163
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 167
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
int set_subset(set_type set1 , set_type set2 ) 
{ 
  int yes ;
  long i ;
  long forlim ;
  unsigned long tmp ;

  {
  {
#line 172
  yes = 1;
#line 175
  tmp = set_blocks((long )*(set2 + 0));
#line 175
  forlim = (long )(tmp - 1UL);
#line 176
  i = 1L;
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (i <= forlim) {
#line 176
      if (! yes) {
#line 176
        goto while_break;
      }
    } else {
#line 176
      goto while_break;
    }
#line 177
    if ((*(set1 + i) | *(set2 + i)) != *(set2 + i)) {
#line 178
      yes = 0;
    }
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return (yes);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
int set_member(long elem , set_type set ) 
{ 
  int yes ;
  long i ;
  long j ;
  unsigned long testset ;
  unsigned long one ;

  {
#line 185
  yes = 0;
#line 188
  one = 1UL;
#line 190
  if ((unsigned long )elem <= *(set + 0)) {
#line 192
    i = (long )((unsigned long )(elem - 1L) / (sizeof(long ) * 8UL) + 1UL);
#line 193
    j = (long )((unsigned long )(elem - 1L) % (sizeof(long ) * 8UL));
#line 194
    testset = *(set + i) | (one << j);
#line 195
    if (testset == *(set + i)) {
#line 196
      yes = 1;
    }
  }
#line 198
  return (yes);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
long set_card(set_type set ) 
{ 
  unsigned long block ;
  long car ;
  set_card_lut_t *p ;

  {
#line 206
  car = 0L;
#line 209
  p = (set_card_lut_t *)(set + 1);
#line 210
  block = 0UL;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (block < ((*(set + 0) - 1UL) / (sizeof(long ) * 8UL) + 1UL) * (sizeof(long ) / sizeof(set_card_lut_t )))) {
#line 210
      goto while_break;
    }
#line 211
    car += (long )set_card_lut[*(p + block)];
#line 210
    block ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return (car);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
long set_groundsize(set_type set ) 
{ 


  {
#line 230
  return ((long )*(set + 0));
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_write(set_type set ) 
{ 
  long elem ;
  int tmp ;

  {
#line 237
  elem = 1L;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! ((unsigned long )elem <= *(set + 0))) {
#line 237
      goto while_break;
    }
    {
#line 239
    tmp = set_member(elem, set);
    }
#line 239
    if (tmp) {
      {
#line 240
      printf((char const   */* __restrict  */)"%ld ", elem);
      }
    }
#line 237
    elem ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  printf((char const   */* __restrict  */)"\n");
  }
#line 243
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_fwrite(FILE *f , set_type set ) 
{ 
  long elem ;
  int tmp ;

  {
#line 249
  elem = 1L;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )elem <= *(set + 0))) {
#line 249
      goto while_break;
    }
    {
#line 251
    tmp = set_member(elem, set);
    }
#line 251
    if (tmp) {
      {
#line 252
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld ",
              elem);
      }
    }
#line 249
    elem ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 254
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
  }
#line 255
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_fwrite_compl(FILE *f , set_type set ) 
{ 
  long elem ;
  int tmp ;

  {
#line 261
  elem = 1L;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! ((unsigned long )elem <= *(set + 0))) {
#line 261
      goto while_break;
    }
    {
#line 263
    tmp = set_member(elem, set);
    }
#line 263
    if (! tmp) {
      {
#line 264
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld ",
              elem);
      }
    }
#line 261
    elem ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 266
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
  }
#line 267
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_binwrite(set_type set ) 
{ 
  int i ;
  int j ;
  long forlim ;
  unsigned long e1 ;
  unsigned long e2 ;
  unsigned long tmp ;

  {
  {
#line 275
  printf((char const   */* __restrict  */)"max element = %ld,\n", *(set + 0));
#line 276
  tmp = set_blocks((long )*(set + 0));
#line 276
  forlim = (long )(tmp - 1UL);
#line 277
  i = (int )forlim;
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (i >= 1)) {
#line 277
      goto while_break;
    }
#line 279
    e2 = *(set + i);
#line 279
    e1 = e2;
#line 280
    j = (int )(sizeof(long ) * 8UL - 1UL);
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 280
      if (! (j >= 0)) {
#line 280
        goto while_break___0;
      }
      {
#line 282
      e1 >>= j;
#line 283
      printf((char const   */* __restrict  */)"%1ld", e1);
#line 284
      e1 = e2 - (e1 << j);
#line 285
      e2 = e1;
#line 280
      j --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 287
    printf((char const   */* __restrict  */)" ");
#line 277
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 289
  printf((char const   */* __restrict  */)"\n");
  }
#line 290
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
void set_fbinwrite(FILE *f , set_type set ) 
{ 
  int i ;
  int j ;
  long forlim ;
  long e1 ;
  long e2 ;
  unsigned long tmp ;

  {
  {
#line 299
  printf((char const   */* __restrict  */)"max element = %ld,\n", *(set + 0));
#line 300
  tmp = set_blocks((long )*(set + 0));
#line 300
  forlim = (long )(tmp - 1UL);
#line 301
  i = (int )forlim;
  }
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! (i >= 1)) {
#line 301
      goto while_break;
    }
#line 303
    e2 = (long )*(set + i);
#line 303
    e1 = e2;
#line 304
    j = (int )(sizeof(long ) * 8UL - 1UL);
    {
#line 304
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 304
      if (! (j >= 0)) {
#line 304
        goto while_break___0;
      }
      {
#line 306
      e1 >>= j;
#line 307
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%1ld",
              e1);
#line 308
      e1 = e2 - (e1 << j);
#line 309
      e2 = e1;
#line 304
      j --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 311
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" ");
#line 301
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 313
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
  }
#line 314
  return;
}
}
#line 1034 "/usr/include/x86_64-linux-gnu/gmp.h"
extern void __gmpz_set_si(mpz_ptr  , long  ) ;
#line 1216
extern void __gmpq_set_si(mpq_ptr  , long  , unsigned long  ) ;
#line 1222
extern void __gmpq_set_ui(mpq_ptr  , unsigned long  , unsigned long  ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp.c"
void dd_set_global_constants(void) 
{ 


  {
  {
#line 25
  __gmpq_init(dd_zero);
#line 26
  __gmpq_init(dd_minuszero);
#line 27
  __gmpq_init(dd_one);
#line 28
  __gmpq_init(dd_minusone);
#line 29
  __gmpq_init(dd_purezero);
#line 31
  time(& dd_statStartTime);
#line 32
  dd_statBApivots = 0L;
#line 33
  dd_statCCpivots = 0L;
#line 34
  dd_statDS1pivots = 0L;
#line 35
  dd_statDS2pivots = 0L;
#line 36
  dd_statACpivots = 0L;
#line 38
  dd_choiceLPSolverDefault = (dd_LPSolverType )1;
#line 39
  dd_choiceRedcheckAlgorithm = (dd_LPSolverType )1;
#line 40
  dd_choiceLexicoPivotQ = 1;
#line 43
  dd_statBSpivots = 0L;
#line 44
  __gmpq_set_ui(dd_zero, 0UL, 1UL);
#line 45
  __gmpq_set_ui(dd_purezero, 0UL, 1UL);
#line 46
  __gmpq_set_ui(dd_one, 1UL, 1UL);
#line 47
  __gmpq_set_si(dd_minusone, -1L, 1UL);
#line 48
  ddf_set_global_constants();
#line 60
  __gmpq_neg(dd_minuszero, (mpq_srcptr )(dd_zero));
  }
#line 61
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp.c"
void dd_free_global_constants(void) 
{ 


  {
  {
#line 65
  __gmpq_clear(dd_zero);
#line 66
  __gmpq_clear(dd_minuszero);
#line 67
  __gmpq_clear(dd_one);
#line 68
  __gmpq_clear(dd_minusone);
#line 69
  __gmpq_clear(dd_purezero);
#line 71
  time(& dd_statStartTime);
#line 72
  dd_statBApivots = 0L;
#line 73
  dd_statCCpivots = 0L;
#line 74
  dd_statDS1pivots = 0L;
#line 75
  dd_statDS2pivots = 0L;
#line 76
  dd_statACpivots = 0L;
#line 78
  dd_choiceLPSolverDefault = (dd_LPSolverType )1;
#line 79
  dd_choiceRedcheckAlgorithm = (dd_LPSolverType )1;
#line 80
  dd_choiceLexicoPivotQ = 1;
#line 83
  dd_statBSpivots = 0L;
#line 84
  ddf_free_global_constants();
  }
#line 86
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddmp.c"
void ddd_mpq_set_si(__mpq_struct *a___41 , long b ) 
{ 
  mpz_t nz ;
  mpz_t dz ;

  {
  {
#line 94
  __gmpz_init(nz);
#line 94
  __gmpz_init(dz);
#line 96
  __gmpz_set_si(nz, b);
#line 97
  __gmpz_set_ui(dz, 1UL);
#line 98
  __gmpq_set_num((mpq_ptr )a___41, (mpz_srcptr )(nz));
#line 99
  __gmpq_set_den((mpq_ptr )a___41, (mpz_srcptr )(dz));
#line 100
  __gmpz_clear(nz);
#line 100
  __gmpz_clear(dz);
  }
#line 101
  return;
}
}
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last___5  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a___1  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common___1  ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn___1  =    0L;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___3  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___6  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset___1  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset___1  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp___1  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d___5  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___7  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___4  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___3  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___4  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___4  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast___1  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___4  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___4  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___5  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___5  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___5  ;
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___6  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___6  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___6  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___3  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___3  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___3  =    (ddf_rowrange )0;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___4  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___4  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___4  =    (ddf_rowrange )0;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay___1  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___6  =    (ddf_colrange )0;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1___1  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2___1  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___7  =    (dd_colrange )0;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___5  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___8  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___2  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___2  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___2  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___8  =    (ddf_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___9  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___6  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___5  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___7  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___7  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___2  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___7  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___6  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___8  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___8  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___8  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___5  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___5  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___5  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___6  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___6  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___6  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___2  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___9  =    (dd_colrange )0;
#line 30 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/src-gmp/testlp3.c"
FILE *reading  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/src-gmp/testlp3.c"
FILE *writing  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/src-gmp/testlp3.c"
void SetWriteFile(FILE **f ) 
{ 
  char *fname ;

  {
  {
#line 36
  fname = (char *)"testlp.out";
#line 37
  *f = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
#line 38
  printf((char const   */* __restrict  */)"file %s is open\n", fname);
  }
#line 39
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___2  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___2  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___10  =    (ddf_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___10  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___2  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___2  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___2  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut___0[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last___11  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a___3  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common___3  ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn___3  =    0L;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___7  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___12  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset___3  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset___3  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp___3  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d___11  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___13  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___8  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___7  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___9  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___9  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast___3  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___9  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___8  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___10  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___10  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___10  ;
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___11  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___11  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___11  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___7  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___7  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___7  =    (ddf_rowrange )0;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___8  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___8  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___8  =    (ddf_rowrange )0;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay___3  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___12  =    (ddf_colrange )0;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1___3  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2___3  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___13  =    (dd_colrange )0;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___9  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___14  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___4  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___4  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___4  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___14  =    (ddf_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___15  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___10  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___9  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___12  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___12  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___4  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___12  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___10  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___13  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___13  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___13  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___9  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___9  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___9  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___10  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___10  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___10  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___4  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___15  =    (dd_colrange )0;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___4  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___4  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___16  =    (ddf_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___16  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___4  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___4  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___4  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut___1[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 59 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/src-gmp/allfaces.c"
dd_boolean FaceEnum(dd_MatrixPtr M , dd_rowset R , dd_rowset S , dd_boolean rip ,
                    dd_colrange mindim ) 
{ 
  dd_ErrorType err ;
  dd_rowset LL ;
  dd_rowset ImL ;
  dd_rowset RR ;
  dd_rowset SS ;
  dd_rowset Lbasis ;
  dd_rowrange i ;
  dd_rowrange iprev ;
  dd_colrange j ;
  dd_colrange dim ;
  dd_LPSolutionPtr lps ;
  dd_boolean success ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  dd_boolean tmp___2 ;

  {
  {
#line 63
  iprev = (dd_rowrange )0;
#line 65
  lps = (dd_LPSolutionPtr )((void *)0);
#line 66
  success = 0;
#line 68
  set_initialize(& LL, M->rowsize);
#line 69
  set_initialize(& RR, M->rowsize);
#line 70
  set_initialize(& SS, M->rowsize);
#line 71
  set_copy(LL, M->linset);
#line 72
  set_copy(RR, R);
#line 73
  set_copy(SS, S);
#line 74
  tmp___2 = dd_ExistsRestrictedFace(M, R, S, & err);
  }
#line 74
  if (tmp___2) {
    {
#line 75
    set_uni(M->linset, M->linset, R);
#line 76
    dd_FindRelativeInterior(M, & ImL, & Lbasis, & lps, & err);
#line 77
    tmp = set_card(Lbasis);
#line 77
    dim = (M->colsize - tmp) - 1L;
#line 78
    set_uni(M->linset, M->linset, ImL);
#line 79
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%ld: ",
            dim);
#line 79
    set_fwrite(stdout, M->linset);
    }
#line 80
    if (rip) {
      {
#line 82
      printf((char const   */* __restrict  */)"RIP: (");
#line 83
      j = (dd_colrange )1;
      }
      {
#line 83
      while (1) {
        while_continue: /* CIL Label */ ;
#line 83
        if (! (j < lps->d - 1L)) {
#line 83
          goto while_break;
        }
        {
#line 84
        dd_WriteNumber(stdout, (__mpq_struct *)(*(lps->sol + j)));
#line 83
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 86
      printf((char const   */* __restrict  */)")\n");
      }
    }
    {
#line 88
    dd_FreeLPSolution(lps);
#line 89
    set_free(ImL);
#line 90
    set_free(Lbasis);
    }
#line 92
    if (dim > mindim) {
#line 93
      i = (dd_rowrange )1;
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (! (i <= M->rowsize)) {
#line 93
          goto while_break___0;
        }
        {
#line 94
        tmp___0 = set_member(i, M->linset);
        }
#line 94
        if (! tmp___0) {
          {
#line 94
          tmp___1 = set_member(i, S);
          }
#line 94
          if (! tmp___1) {
            {
#line 95
            set_addelem(RR, i);
            }
#line 96
            if (iprev) {
              {
#line 97
              set_delelem(RR, iprev);
#line 98
              set_delelem(M->linset, iprev);
#line 99
              set_addelem(SS, iprev);
              }
            }
            {
#line 101
            iprev = i;
#line 102
            FaceEnum(M, RR, SS, rip, mindim);
            }
          }
        }
#line 93
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 106
  if ((unsigned int )err != 17U) {
#line 106
    goto _L99;
  }
#line 107
  success = 1;
  _L99: 
  {
#line 110
  set_copy(M->linset, LL);
#line 111
  set_free(LL);
#line 112
  set_free(RR);
#line 113
  set_free(SS);
  }
#line 114
  return (success);
}
}
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last___17  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a___5  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common___5  ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn___5  =    0L;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___11  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___18  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset___5  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset___5  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp___5  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d___17  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___19  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___12  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___11  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___14  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___14  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast___5  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___14  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___12  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___15  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___15  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___15  ;
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___16  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___16  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___16  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___11  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___11  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___11  =    (ddf_rowrange )0;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___12  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___12  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___12  =    (ddf_rowrange )0;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay___5  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___18  =    (ddf_colrange )0;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1___5  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2___5  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___19  =    (dd_colrange )0;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___13  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___20  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___6  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___6  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___6  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___20  =    (ddf_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___21  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___14  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___13  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___17  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___17  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___6  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___17  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___14  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___18  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___18  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___18  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___13  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___13  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___13  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___14  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___14  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___14  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___6  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___21  =    (dd_colrange )0;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___6  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___6  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___22  =    (ddf_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___22  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___6  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___6  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___6  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut___2[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last___23  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a___7  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common___7  ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn___7  =    0L;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___15  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___24  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset___7  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset___7  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp___7  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d___23  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___25  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___16  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___15  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___19  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___19  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast___7  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___19  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___16  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___20  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___20  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___20  ;
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___21  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___21  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___21  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___15  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___15  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___15  =    (ddf_rowrange )0;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___16  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___16  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___16  =    (ddf_rowrange )0;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay___7  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___24  =    (ddf_colrange )0;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1___7  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2___7  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___25  =    (dd_colrange )0;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___17  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___26  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___8  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___8  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___8  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___26  =    (ddf_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___27  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___18  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___17  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___22  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___22  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___8  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___22  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___18  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___23  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___23  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___23  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___17  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___17  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___17  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___18  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___18  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___18  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___8  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___27  =    (dd_colrange )0;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___8  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___8  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___28  =    (ddf_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___28  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___8  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___8  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___8  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut___3[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last___29  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a___9  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common___9  ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn___9  =    0L;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___19  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___30  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset___9  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset___9  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp___9  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d___29  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___31  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___20  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___19  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___24  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___24  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast___9  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___24  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___20  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___25  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___25  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___25  ;
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___26  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___26  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___26  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___19  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___19  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___19  =    (ddf_rowrange )0;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___20  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___20  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___20  =    (ddf_rowrange )0;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay___9  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___30  =    (ddf_colrange )0;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1___9  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2___9  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___31  =    (dd_colrange )0;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___21  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___32  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___10  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___10  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___10  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___32  =    (ddf_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___33  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___22  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___21  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___27  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___27  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___10  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___27  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___22  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___28  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___28  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___28  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___21  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___21  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___21  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___22  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___22  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___22  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___10  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___33  =    (dd_colrange )0;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___10  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___10  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___34  =    (ddf_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___34  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___10  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___10  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___10  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut___4[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last___35  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a___11  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common___11  ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn___11  =    0L;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___23  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___36  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset___11  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset___11  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp___11  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d___35  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___37  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___24  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___23  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___29  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___29  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast___11  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___29  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___24  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___30  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___30  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___30  ;
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___31  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___31  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___31  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___23  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___23  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___23  =    (ddf_rowrange )0;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___24  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___24  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___24  =    (ddf_rowrange )0;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay___11  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___36  =    (ddf_colrange )0;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1___11  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2___11  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___37  =    (dd_colrange )0;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___25  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___38  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___12  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___12  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___12  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___38  =    (ddf_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___39  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___26  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___25  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___32  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___32  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___12  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___32  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___26  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___33  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___33  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___33  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___25  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___25  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___25  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___26  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___26  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___26  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___12  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___39  =    (dd_colrange )0;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___12  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___12  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___40  =    (ddf_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___40  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___12  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___12  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___12  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut___5[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last___41  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a___13  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common___13  ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn___13  =    0L;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___27  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___42  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset___13  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset___13  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp___13  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d___41  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___43  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___28  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___27  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___34  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___34  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast___13  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___34  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___28  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___35  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___35  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___35  ;
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___36  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___36  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___36  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___27  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___27  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___27  =    (ddf_rowrange )0;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___28  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___28  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___28  =    (ddf_rowrange )0;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay___13  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___42  =    (ddf_colrange )0;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1___13  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2___13  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___43  =    (dd_colrange )0;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___29  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___44  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___14  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___14  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___14  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___44  =    (ddf_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___45  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___30  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___29  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___37  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___37  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___14  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___37  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___30  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___38  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___38  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___38  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___29  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___29  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___29  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___30  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___30  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___30  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___14  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___45  =    (dd_colrange )0;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___14  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___14  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___46  =    (ddf_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___46  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___14  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___14  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___14  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut___6[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last___47  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a___15  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common___15  ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn___15  =    0L;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___31  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___48  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset___15  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset___15  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp___15  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d___47  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___49  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___32  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___31  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___39  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___39  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast___15  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___39  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___32  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___40  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___40  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___40  ;
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___41  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___41  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___41  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___31  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___31  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___31  =    (ddf_rowrange )0;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___32  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___32  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___32  =    (ddf_rowrange )0;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay___15  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___48  =    (ddf_colrange )0;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1___15  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2___15  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___49  =    (dd_colrange )0;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___33  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___50  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___16  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___16  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___16  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___50  =    (ddf_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___51  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___34  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___33  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___42  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___42  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___16  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___42  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___34  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___43  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___43  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___43  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___33  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___33  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___33  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___34  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___34  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___34  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___16  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___51  =    (dd_colrange )0;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___16  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___16  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___52  =    (ddf_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___52  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___16  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___16  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___16  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut___7[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last___53  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a___17  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common___17  ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn___17  =    0L;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___35  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___54  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset___17  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset___17  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp___17  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d___53  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___55  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___36  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___35  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___44  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___44  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast___17  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___44  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___36  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___45  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___45  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___45  ;
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___46  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___46  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___46  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___35  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___35  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___35  =    (ddf_rowrange )0;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___36  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___36  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___36  =    (ddf_rowrange )0;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay___17  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___54  =    (ddf_colrange )0;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1___17  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2___17  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___55  =    (dd_colrange )0;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___37  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___56  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___18  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___18  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___18  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___56  =    (ddf_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___57  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___38  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___37  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___47  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___47  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___18  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___47  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___38  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___48  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___48  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___48  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___37  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___37  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___37  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___38  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___38  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___38  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___18  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___57  =    (dd_colrange )0;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___18  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___18  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___58  =    (ddf_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___58  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___18  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___18  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___18  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut___8[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last___59  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a___19  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common___19  ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn___19  =    0L;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___39  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___60  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset___19  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset___19  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp___19  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d___59  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___61  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___40  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___39  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___49  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___49  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast___19  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___49  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___40  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___50  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___50  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___50  ;
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___51  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___51  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___51  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___39  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___39  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___39  =    (ddf_rowrange )0;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___40  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___40  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___40  =    (ddf_rowrange )0;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay___19  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___60  =    (ddf_colrange )0;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1___19  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2___19  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___61  =    (dd_colrange )0;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___41  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___62  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___20  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___20  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___20  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___62  =    (ddf_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___63  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___42  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___41  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___52  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___52  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___20  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___52  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___42  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___53  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___53  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___53  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___41  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___41  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___41  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___42  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___42  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___42  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___20  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___63  =    (dd_colrange )0;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___20  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___20  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___64  =    (ddf_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___64  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___20  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___20  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___20  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut___9[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last___65  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a___21  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common___21  ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn___21  =    0L;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___43  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___66  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset___21  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset___21  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp___21  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d___65  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___67  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___44  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___43  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___54  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___54  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast___21  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___54  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___44  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___55  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___55  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___55  ;
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___56  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___56  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___56  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___43  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___43  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___43  =    (ddf_rowrange )0;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___44  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___44  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___44  =    (ddf_rowrange )0;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay___21  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___66  =    (ddf_colrange )0;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1___21  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2___21  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___67  =    (dd_colrange )0;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___45  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___68  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___22  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___22  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___22  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___68  =    (ddf_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___69  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___46  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___45  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___57  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___57  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___22  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___57  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___46  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___58  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___58  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___58  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___45  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___45  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___45  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___46  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___46  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___46  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___22  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___69  =    (dd_colrange )0;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___22  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___22  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___70  =    (ddf_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___70  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___22  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___22  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___22  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut___10[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last___71  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a___23  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common___23  ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn___23  =    0L;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___47  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___72  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset___23  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset___23  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp___23  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d___71  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___73  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___48  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___47  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___59  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___59  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast___23  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___59  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___48  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___60  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___60  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___60  ;
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___61  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___61  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___61  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___47  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___47  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___47  =    (ddf_rowrange )0;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___48  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___48  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___48  =    (ddf_rowrange )0;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay___23  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___72  =    (ddf_colrange )0;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1___23  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2___23  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___73  =    (dd_colrange )0;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___49  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___74  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___24  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___24  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___24  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___74  =    (ddf_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___75  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___50  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___49  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___62  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___62  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___24  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___62  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___50  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___63  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___63  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___63  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___49  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___49  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___49  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___50  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___50  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___50  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___24  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___75  =    (dd_colrange )0;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___24  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___24  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___76  =    (ddf_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___76  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___24  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___24  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___24  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut___11[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___51  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___51  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___51  =    (ddf_rowrange )0;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face___52  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowset Face1___52  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_rowrange last_m___52  =    (ddf_rowrange )0;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_Arow NewRay___25  ;
#line 1073 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore_f.c"
static ddf_colrange last_d___77  =    (ddf_colrange )0;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___51  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___77  =    (ddf_colrange )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset tieset___25  ;
#line 547 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colset stieset___25  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow Rtemp___25  ;
#line 757 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange last_d___78  =    (ddf_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colrange d_last___78  =    (ddf_colrange )0;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_Arow rcost___52  ;
#line 1188 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___51  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___64  ;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___64  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long nlast___25  =    0L;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___64  ;
#line 1420 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_colindex nbindex_ref___52  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex bflag___65  ;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static long mlast___65  =    0L;
#line 1601 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp_f.c"
static ddf_rowindex OrderVector___65  ;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___53  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___79  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset tieset___26  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colset stieset___26  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow Rtemp___26  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange last_d___79  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colrange d_last___80  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_Arow rcost___54  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___53  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___66  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___66  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long nlast___26  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___66  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_colindex nbindex_ref___54  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___67  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___67  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___67  ;
#line 3597 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex bflag___68  ;
#line 3598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static long mlast___68  =    0L;
#line 3599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlp.c"
static dd_rowindex OrderVector___68  ;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_colrange d_last___81  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static dd_Arow a___25  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static set_type common___25  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio.c"
static long lastn___25  =    0L;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector1___25  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_Arow Vector2___25  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib.c"
static dd_colrange last_d___80  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_colrange d_last___82  =    (ddf_colrange )0;
#line 1081 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static ddf_Arow a___26  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static set_type common___26  ;
#line 1406 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddio_f.c"
static long lastn___26  =    0L;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector1___26  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_Arow Vector2___26  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddlib_f.c"
static ddf_colrange last_d___81  =    (ddf_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___53  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___53  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___53  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face___54  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowset Face1___54  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_rowrange last_m___54  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_Arow NewRay___26  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/cddcore.c"
static dd_colrange last_d___82  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
static unsigned char set_card_lut___12[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src-gmp/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 103 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.h"
void ddd_init(double *a___41 ) ;
#line 104
void ddd_clear(double *a___41 ) ;
#line 105
void ddd_set(double *a___41 , double *b ) ;
#line 106
void ddd_set_d(double *a___41 , double b ) ;
#line 107
void ddd_set_si(double *a___41 , long b ) ;
#line 108
void ddd_set_si2(double *a___41 , long b , unsigned long c ) ;
#line 109
void ddd_add(double *a___41 , double *b , double *c ) ;
#line 110
void ddd_sub(double *a___41 , double *b , double *c ) ;
#line 111
void ddd_mul(double *a___41 , double *b , double *c ) ;
#line 112
void ddd_div(double *a___41 , double *b , double *c ) ;
#line 113
void ddd_neg(double *a___41 , double *b ) ;
#line 114
void ddd_inv(double *a___41 , double *b ) ;
#line 115
int ddd_cmp(double *a___41 , double *b ) ;
#line 116
int ddd_sgn(double *a___41 ) ;
#line 117
double ddd_get_d(double *a___41 ) ;
#line 105 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
void ddd_init(double *a___41 ) 
{ 


  {
#line 107
  *(a___41 + 0) = (double )0L;
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
void ddd_clear(double *a___41 ) 
{ 


  {
#line 113
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
void ddd_set(double *a___41 , double *b ) 
{ 


  {
#line 117
  *(a___41 + 0) = *(b + 0);
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
void ddd_set_d(double *a___41 , double b ) 
{ 


  {
#line 122
  *(a___41 + 0) = b;
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
void ddd_set_si(double *a___41 , long b ) 
{ 


  {
#line 127
  *(a___41 + 0) = (double )b;
#line 128
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
void ddd_set_si2(double *a___41 , long b , unsigned long c ) 
{ 


  {
#line 132
  *(a___41 + 0) = (double )b / (double )c;
#line 133
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
void ddd_add(double *a___41 , double *b , double *c ) 
{ 


  {
#line 137
  *(a___41 + 0) = *(b + 0) + *(c + 0);
#line 138
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
void ddd_sub(double *a___41 , double *b , double *c ) 
{ 


  {
#line 142
  *(a___41 + 0) = *(b + 0) - *(c + 0);
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
void ddd_mul(double *a___41 , double *b , double *c ) 
{ 


  {
#line 147
  *(a___41 + 0) = *(b + 0) * *(c + 0);
#line 148
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
void ddd_div(double *a___41 , double *b , double *c ) 
{ 


  {
#line 152
  *(a___41 + 0) = *(b + 0) / *(c + 0);
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
void ddd_neg(double *a___41 , double *b ) 
{ 


  {
#line 157
  *(a___41 + 0) = - *(b + 0);
#line 158
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
void ddd_inv(double *a___41 , double *b ) 
{ 


  {
#line 162
  *(a___41 + 0) = (double )1 / *(b + 0);
#line 163
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
int ddd_cmp(double *a___41 , double *b ) 
{ 


  {
#line 167
  if (*(a___41 + 0) - *(b + 0) > (double )0) {
#line 167
    return (1);
  } else
#line 168
  if (*(a___41 + 0) - *(b + 0) >= (double )0) {
#line 168
    return (0);
  } else {
#line 169
    return (-1);
  }
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
int ddd_sgn(double *a___41 ) 
{ 


  {
#line 174
  if (*(a___41 + 0) > (double )0) {
#line 174
    return (1);
  } else
#line 175
  if (*(a___41 + 0) >= (double )0) {
#line 175
    return (0);
  } else {
#line 176
    return (-1);
  }
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddmp.c"
double ddd_get_d(double *a___41 ) 
{ 


  {
#line 181
  return (*(a___41 + 0));
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___55  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___83  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___27  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___27  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___27  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___83  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___84  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___56  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___55  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___69  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___69  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___27  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___69  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___56  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___70  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___70  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___70  ;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___85  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___27  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___27  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___27  =    0L;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___27  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___27  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___84  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___13[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___55  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___55  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___55  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___56  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___56  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___56  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___27  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___85  =    (dd_colrange )0;
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___57  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___86  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___28  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___28  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___28  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___86  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___87  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___58  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___57  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___71  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___71  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___28  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___71  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___58  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___72  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___72  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___72  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___28  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___28  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___87  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___57  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___57  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___57  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___58  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___58  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___58  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___28  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___88  =    (dd_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___88  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___28  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___28  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___28  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___14[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___59  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___89  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___29  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___29  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___29  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___89  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___90  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___60  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___59  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___73  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___73  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___29  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___73  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___60  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___74  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___74  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___74  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___29  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___29  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___90  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___59  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___59  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___59  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___60  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___60  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___60  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___29  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___91  =    (dd_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___91  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___29  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___29  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___29  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___15[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___61  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___92  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___30  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___30  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___30  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___92  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___93  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___62  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___61  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___75  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___75  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___30  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___75  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___62  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___76  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___76  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___76  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___30  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___30  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___93  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___61  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___61  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___61  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___62  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___62  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___62  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___30  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___94  =    (dd_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___94  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___30  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___30  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___30  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___16[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___63  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___95  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___31  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___31  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___31  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___95  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___96  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___64  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___63  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___77  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___77  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___31  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___77  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___64  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___78  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___78  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___78  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___31  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___31  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___96  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___63  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___63  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___63  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___64  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___64  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___64  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___31  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___97  =    (dd_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___97  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___31  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___31  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___31  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___17[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___65  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___98  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___32  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___32  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___32  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___98  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___99  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___66  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___65  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___79  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___79  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___32  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___79  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___66  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___80  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___80  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___80  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___32  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___32  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___99  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___65  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___65  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___65  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___66  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___66  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___66  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___32  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___100  =    (dd_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___100  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___32  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___32  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___32  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___18[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___67  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___101  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___33  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___33  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___33  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___101  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___102  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___68  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___67  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___81  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___81  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___33  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___81  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___68  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___82  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___82  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___82  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___33  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___33  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___102  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___67  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___67  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___67  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___68  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___68  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___68  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___33  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___103  =    (dd_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___103  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___33  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___33  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___33  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___19[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___69  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___104  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___34  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___34  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___34  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___104  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___105  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___70  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___69  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___83  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___83  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___34  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___83  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___70  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___84  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___84  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___84  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___34  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___34  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___105  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___69  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___69  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___69  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___70  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___70  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___70  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___34  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___106  =    (dd_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___106  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___34  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___34  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___34  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___20[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___71  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___107  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___35  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___35  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___35  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___107  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___108  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___72  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___71  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___85  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___85  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___35  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___85  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___72  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___86  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___86  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___86  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___35  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___35  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___108  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___71  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___71  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___71  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___72  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___72  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___72  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___35  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___109  =    (dd_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___109  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___35  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___35  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___35  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___21[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___73  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___110  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___36  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___36  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___36  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___110  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___111  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___74  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___73  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___87  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___87  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___36  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___87  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___74  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___88  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___88  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___88  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___36  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___36  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___111  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___73  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___73  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___73  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___74  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___74  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___74  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___36  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___112  =    (dd_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___112  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___36  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___36  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___36  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___22[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___75  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___113  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___37  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___37  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___37  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___113  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___114  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___76  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___75  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___89  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___89  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___37  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___89  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___76  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___90  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___90  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___90  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___37  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___37  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___114  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___75  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___75  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___75  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___76  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___76  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___76  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___37  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___115  =    (dd_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___115  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___37  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___37  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___37  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___23[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___77  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___116  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___38  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___38  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___38  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___116  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___117  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___78  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___77  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___91  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___91  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___38  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___91  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___78  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___92  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___92  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___92  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___38  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___38  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___117  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___77  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___77  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___77  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___78  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___78  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___78  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___38  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___118  =    (dd_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___118  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___38  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___38  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___38  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___24[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___79  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___119  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___39  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___39  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___39  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___119  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___120  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___80  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___79  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___93  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___93  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___39  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___93  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___80  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___94  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___94  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___94  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___39  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___39  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___120  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___79  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___79  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___79  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___80  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___80  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___80  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___39  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___121  =    (dd_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___121  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___39  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___39  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___39  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___25[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
#line 544 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___81  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___122  =    (dd_colrange )0;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset tieset___40  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colset stieset___40  ;
#line 755 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 Rtemp___40  ;
#line 756 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange last_d___122  =    (dd_colrange )0;
#line 1185 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colrange d_last___123  =    (dd_colrange )0;
#line 1186 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_Arow___0 rcost___82  ;
#line 1187 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___81  ;
#line 1416 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___95  ;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___95  =    0L;
#line 1417 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long nlast___40  =    0L;
#line 1418 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___95  ;
#line 1419 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_colindex nbindex_ref___82  ;
#line 1598 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex bflag___96  ;
#line 1599 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static long mlast___96  =    0L;
#line 1600 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlp.c"
static dd_rowindex OrderVector___96  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector1___40  ;
#line 149 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_Arow___0 Vector2___40  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddlib.c"
static dd_colrange last_d___123  =    (dd_colrange )0;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___81  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___81  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___81  =    (dd_rowrange )0;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face___82  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowset Face1___82  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_rowrange last_m___82  =    (dd_rowrange )0;
#line 1071 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_Arow___0 NewRay___40  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddcore.c"
static dd_colrange last_d___124  =    (dd_colrange )0;
#line 1079 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_colrange d_last___124  =    (dd_colrange )0;
#line 1080 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static dd_Arow___0 a___40  ;
#line 1404 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static set_type common___40  ;
#line 1405 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/cddio.c"
static long lastn___40  =    0L;
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
static unsigned char set_card_lut___26[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cddlib-094g/lib-src/setoper.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)2,      (unsigned char)3,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)7,      (unsigned char)8};
