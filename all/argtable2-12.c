/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 82 "./getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
typedef void arg_resetfn(void *parent );
#line 42 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
typedef int arg_scanfn(void *parent , char const   *argval );
#line 43 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
typedef int arg_checkfn(void *parent );
#line 44 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
typedef void arg_errorfn(void *parent , FILE *fp , int error , char const   *argval ,
                         char const   *progname );
#line 64 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_hdr {
   char flag ;
   char const   *shortopts ;
   char const   *longopts ;
   char const   *datatype ;
   char const   *glossary ;
   int mincount ;
   int maxcount ;
   void *parent ;
   arg_resetfn *resetfn ;
   arg_scanfn *scanfn ;
   arg_checkfn *checkfn ;
   arg_errorfn *errorfn ;
   void *priv ;
};
#line 138 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_end {
   struct arg_hdr hdr ;
   int count ;
   int *error ;
   void **parent ;
   char const   **argval ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
struct longoptions {
   int getoptval ;
   int noptions ;
   struct option *options ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_lit {
   struct arg_hdr hdr ;
   int count ;
};
#line 92 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_int {
   struct arg_hdr hdr ;
   int count ;
   int *ival ;
};
#line 120 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_file {
   struct arg_hdr hdr ;
   int count ;
   char const   **filename ;
   char const   **basename ;
   char const   **extension ;
};
#line 99 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_dbl {
   struct arg_hdr hdr ;
   int count ;
   double *dval ;
};
#line 113 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_rex {
   struct arg_hdr hdr ;
   int count ;
   char const   **sval ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_28 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_28 regmatch_t;
#line 39 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_rex.c"
struct privhdr {
   char const   *pattern ;
   int flags ;
   regex_t regex ;
};
#line 106 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_str {
   struct arg_hdr hdr ;
   int count ;
   char const   **sval ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long __tm_gmtoff ;
   char const   *__tm_zone ;
};
#line 129 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_date {
   struct arg_hdr hdr ;
   char const   *format ;
   int count ;
   struct tm *tmval ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_rem {
   struct arg_hdr hdr ;
};
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 36 "./getopt.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 111
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 279 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
int arg_nullcheck(void **argtable ) ;
#line 280
int arg_parse(int argc , char **argv , void **argtable ) ;
#line 281
void arg_print_option(FILE *fp , char const   *shortopts , char const   *longopts ,
                      char const   *datatype , char const   *suffix ) ;
#line 282
void arg_print_syntax(FILE *fp , void **argtable , char const   *suffix ) ;
#line 283
void arg_print_syntaxv(FILE *fp , void **argtable , char const   *suffix ) ;
#line 284
void arg_print_glossary(FILE *fp , void **argtable , char const   *format ) ;
#line 285
void arg_print_glossary_gnu(FILE *fp , void **argtable ) ;
#line 287
void arg_freetable(void **argtable , size_t n ) ;
#line 290
void arg_free(void **argtable ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static void arg_register_error(struct arg_end *end , void *parent , int error , char const   *argval ) 
{ 


  {
#line 55
  if (end->count < end->hdr.maxcount) {
#line 57
    *(end->error + end->count) = error;
#line 58
    *(end->parent + end->count) = parent;
#line 59
    *(end->argval + end->count) = argval;
#line 60
    (end->count) ++;
  } else {
#line 64
    *(end->error + (end->hdr.maxcount - 1)) = 1;
#line 65
    *(end->parent + (end->hdr.maxcount - 1)) = (void *)end;
#line 66
    *(end->argval + (end->hdr.maxcount - 1)) = (char const   *)((void *)0);
  }
#line 68
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static int find_shortoption(struct arg_hdr **table , char shortopt ) 
{ 
  int tabindex ;
  char *tmp ;

  {
#line 79
  tabindex = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (! ((int )(*(table + tabindex))->flag & 1))) {
#line 79
      goto while_break;
    }
#line 81
    if ((*(table + tabindex))->shortopts) {
      {
#line 81
      tmp = strchr((*(table + tabindex))->shortopts, (int )shortopt);
      }
#line 81
      if (tmp) {
#line 82
        return (tabindex);
      }
    }
#line 79
    tabindex ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (-1);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static struct longoptions *alloc_longoptions(struct arg_hdr **table ) 
{ 
  struct longoptions *result ;
  size_t nbytes ;
  int noptions ;
  size_t longoptlen ;
  int tabindex ;
  char const   *longopts ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int option_index ;
  char *store ;
  char const   *longopts___0 ;
  char *storestart ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;

  {
#line 117
  noptions = 1;
#line 118
  longoptlen = (size_t )0;
#line 131
  tabindex = 0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    longopts = (*(table + tabindex))->longopts;
#line 135
    if (longopts) {
      {
#line 135
      tmp = strlen(longopts);
#line 135
      tmp___0 = tmp;
      }
    } else {
#line 135
      tmp___0 = (size_t )0;
    }
#line 135
    longoptlen += tmp___0 + 1UL;
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! longopts) {
#line 136
        goto while_break___0;
      }
      {
#line 138
      noptions ++;
#line 139
      tmp___1 = strchr(longopts + 1, ',');
#line 139
      longopts = (char const   *)tmp___1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 132
    tmp___2 = tabindex;
#line 132
    tabindex ++;
#line 132
    if ((int )(*(table + tmp___2))->flag & 1) {
#line 132
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  nbytes = (sizeof(struct longoptions ) + sizeof(struct option ) * (unsigned long )noptions) + longoptlen;
#line 150
  tmp___3 = malloc(nbytes);
#line 150
  result = (struct longoptions *)tmp___3;
  }
#line 151
  if (result) {
#line 153
    option_index = 0;
#line 156
    result->getoptval = 0;
#line 157
    result->noptions = noptions;
#line 158
    result->options = (struct option *)(result + 1);
#line 159
    store = (char *)(result->options + noptions);
#line 161
    tabindex = 0;
    {
#line 161
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 161
      if (! (! ((int )(*(table + tabindex))->flag & 1))) {
#line 161
        goto while_break___1;
      }
#line 163
      longopts___0 = (*(table + tabindex))->longopts;
      {
#line 165
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 165
        if (longopts___0) {
#line 165
          if (! *longopts___0) {
#line 165
            goto while_break___2;
          }
        } else {
#line 165
          goto while_break___2;
        }
#line 167
        storestart = store;
        {
#line 170
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 170
          if ((int const   )*longopts___0 != 0) {
#line 170
            if (! ((int const   )*longopts___0 != 44)) {
#line 170
              goto while_break___3;
            }
          } else {
#line 170
            goto while_break___3;
          }
#line 171
          tmp___4 = store;
#line 171
          store ++;
#line 171
          tmp___5 = longopts___0;
#line 171
          longopts___0 ++;
#line 171
          *tmp___4 = (char )*tmp___5;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 172
        tmp___6 = store;
#line 172
        store ++;
#line 172
        *tmp___6 = (char)0;
#line 173
        if ((int const   )*longopts___0 == 44) {
#line 174
          longopts___0 ++;
        }
#line 177
        (result->options + option_index)->name = (char const   *)storestart;
#line 178
        (result->options + option_index)->flag = & result->getoptval;
#line 179
        (result->options + option_index)->val = tabindex;
#line 180
        if ((int )(*(table + tabindex))->flag & 4) {
#line 181
          (result->options + option_index)->has_arg = 2;
        } else
#line 182
        if ((int )(*(table + tabindex))->flag & 2) {
#line 183
          (result->options + option_index)->has_arg = 1;
        } else {
#line 185
          (result->options + option_index)->has_arg = 0;
        }
#line 187
        option_index ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 161
      tabindex ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 191
    (result->options + option_index)->name = (char const   *)0;
#line 192
    (result->options + option_index)->has_arg = 0;
#line 193
    (result->options + option_index)->flag = (int *)0;
#line 194
    (result->options + option_index)->val = 0;
  }
#line 198
  return (result);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static char *alloc_shortoptions(struct arg_hdr **table ) 
{ 
  char *result ;
  size_t len ;
  int tabindex ;
  struct arg_hdr *hdr ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *res ;
  char *tmp___2 ;
  struct arg_hdr *hdr___0 ;
  char const   *shortopts ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 205
  len = (size_t )2;
#line 209
  tabindex = 0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (! ((int )(*(table + tabindex))->flag & 1))) {
#line 209
      goto while_break;
    }
#line 211
    hdr = *(table + tabindex);
#line 212
    if (hdr->shortopts) {
      {
#line 212
      tmp = strlen(hdr->shortopts);
#line 212
      tmp___0 = tmp;
      }
    } else {
#line 212
      tmp___0 = (size_t )0;
    }
#line 212
    len += 3UL * tmp___0;
#line 209
    tabindex ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 215
  tmp___1 = malloc(len);
#line 215
  result = (char *)tmp___1;
  }
#line 216
  if (result) {
#line 218
    res = result;
#line 222
    tmp___2 = res;
#line 222
    res ++;
#line 222
    *tmp___2 = (char )':';
#line 224
    tabindex = 0;
    {
#line 224
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 224
      if (! (! ((int )(*(table + tabindex))->flag & 1))) {
#line 224
        goto while_break___0;
      }
#line 226
      hdr___0 = *(table + tabindex);
#line 227
      shortopts = hdr___0->shortopts;
      {
#line 228
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 228
        if (shortopts) {
#line 228
          if (! *shortopts) {
#line 228
            goto while_break___1;
          }
        } else {
#line 228
          goto while_break___1;
        }
#line 230
        tmp___3 = res;
#line 230
        res ++;
#line 230
        tmp___4 = shortopts;
#line 230
        shortopts ++;
#line 230
        *tmp___3 = (char )*tmp___4;
#line 231
        if ((int )hdr___0->flag & 2) {
#line 232
          tmp___5 = res;
#line 232
          res ++;
#line 232
          *tmp___5 = (char )':';
        }
#line 233
        if ((int )hdr___0->flag & 4) {
#line 234
          tmp___6 = res;
#line 234
          res ++;
#line 234
          *tmp___6 = (char )':';
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 224
      tabindex ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 238
    *res = (char)0;
  }
#line 242
  return (result);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static int arg_endindex(struct arg_hdr **table ) 
{ 
  int tabindex ;

  {
#line 250
  tabindex = 0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (! ((int )(*(table + tabindex))->flag & 1))) {
#line 251
      goto while_break;
    }
#line 252
    tabindex ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (tabindex);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static void arg_parse_tagged(int argc , char **argv , struct arg_hdr **table , struct arg_end *endtable ) 
{ 
  struct longoptions *longoptions ;
  char *shortoptions ;
  int copt ;
  int tabindex ;
  void *parent ;
  int errorcode ;
  int tmp ;
  int tabindex___0 ;
  int tmp___0 ;
  void *parent___0 ;
  int errorcode___0 ;
  int tmp___1 ;

  {
  {
#line 268
  longoptions = alloc_longoptions(table);
#line 269
  shortoptions = alloc_shortoptions(table);
  }
#line 270
  if (! longoptions) {
    {
#line 273
    arg_register_error(endtable, (void *)endtable, 2, (char const   *)((void *)0));
#line 275
    free((void *)shortoptions);
#line 276
    free((void *)longoptions);
    }
#line 277
    return;
  } else
#line 270
  if (! shortoptions) {
    {
#line 273
    arg_register_error(endtable, (void *)endtable, 2, (char const   *)((void *)0));
#line 275
    free((void *)shortoptions);
#line 276
    free((void *)longoptions);
    }
#line 277
    return;
  }
#line 283
  optind = 0;
#line 284
  opterr = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    copt = getopt_long(argc, (char * const  *)argv, (char const   *)shortoptions,
                       (struct option  const  *)longoptions->options, (int *)((void *)0));
    }
#line 287
    if (! (copt != -1)) {
#line 287
      goto while_break;
    }
    {
#line 297
    if (copt == 0) {
#line 297
      goto case_0;
    }
#line 317
    if (copt == 63) {
#line 317
      goto case_63;
    }
#line 336
    if (copt == 58) {
#line 336
      goto case_58;
    }
#line 344
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 299
    tabindex = longoptions->getoptval;
#line 300
    parent = (*(table + tabindex))->parent;
#line 302
    if (optarg) {
#line 302
      if ((int )*(optarg + 0) == 0) {
#line 302
        if ((int )(*(table + tabindex))->flag & 2) {
          {
#line 305
          arg_register_error(endtable, (void *)endtable, 5, (char const   *)*(argv + (optind - 1)));
          }
        }
      }
    }
#line 308
    if ((*(table + tabindex))->scanfn) {
      {
#line 310
      tmp = (*((*(table + tabindex))->scanfn))(parent, (char const   *)optarg);
#line 310
      errorcode = tmp;
      }
#line 311
      if (errorcode != 0) {
        {
#line 312
        arg_register_error(endtable, parent, errorcode, (char const   *)optarg);
        }
      }
    }
#line 315
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 325
    if (optopt == 0) {
#line 325
      goto case_0___0;
    }
#line 329
    goto switch_default;
    case_0___0: /* CIL Label */ 
    {
#line 327
    arg_register_error(endtable, (void *)endtable, 4, (char const   *)*(argv + (optind - 1)));
    }
#line 328
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 331
    arg_register_error(endtable, (void *)endtable, optopt, (char const   *)((void *)0));
    }
#line 332
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 334
    goto switch_break;
    case_58: /* CIL Label */ 
    {
#line 341
    arg_register_error(endtable, (void *)endtable, 5, (char const   *)*(argv + (optind - 1)));
    }
#line 342
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 347
    tmp___0 = find_shortoption(table, (char )copt);
#line 347
    tabindex___0 = tmp___0;
    }
#line 349
    if (tabindex___0 == -1) {
      {
#line 353
      arg_register_error(endtable, (void *)endtable, copt, (char const   *)((void *)0));
      }
    } else
#line 357
    if ((*(table + tabindex___0))->scanfn) {
      {
#line 359
      parent___0 = (*(table + tabindex___0))->parent;
#line 360
      tmp___1 = (*((*(table + tabindex___0))->scanfn))(parent___0, (char const   *)optarg);
#line 360
      errorcode___0 = tmp___1;
      }
#line 361
      if (errorcode___0 != 0) {
        {
#line 362
        arg_register_error(endtable, parent___0, errorcode___0, (char const   *)optarg);
        }
      }
    }
#line 365
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 370
  free((void *)shortoptions);
#line 371
  free((void *)longoptions);
  }
#line 372
  return;
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static void arg_parse_untagged(int argc , char **argv , struct arg_hdr **table , struct arg_end *endtable ) 
{ 
  int tabindex ;
  int errorlast ;
  char const   *optarglast ;
  void *parentlast ;
  void *parent ;
  int errorcode ;
  int tmp ;

  {
#line 378
  tabindex = 0;
#line 379
  errorlast = 0;
#line 380
  optarglast = (char const   *)((void *)0);
#line 381
  parentlast = (void *)0;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (! (! ((int )(*(table + tabindex))->flag & 1))) {
#line 384
      goto while_break;
    }
#line 390
    if (optind >= argc) {
#line 393
      return;
    }
#line 397
    if ((*(table + tabindex))->longopts) {
#line 400
      tabindex ++;
#line 401
      goto while_continue;
    } else
#line 397
    if ((*(table + tabindex))->shortopts) {
#line 400
      tabindex ++;
#line 401
      goto while_continue;
    }
#line 405
    if (! (*(table + tabindex))->scanfn) {
#line 408
      tabindex ++;
#line 409
      goto while_continue;
    }
    {
#line 415
    parent = (*(table + tabindex))->parent;
#line 416
    errorcode = (*((*(table + tabindex))->scanfn))(parent, (char const   *)*(argv + optind));
    }
#line 417
    if (errorcode == 0) {
#line 421
      optind ++;
#line 424
      errorlast = 0;
    } else {
#line 430
      tabindex ++;
#line 433
      errorlast = errorcode;
#line 434
      optarglast = (char const   *)*(argv + optind);
#line 435
      parentlast = parent;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (errorlast) {
    {
#line 443
    arg_register_error(endtable, parentlast, errorlast, optarglast);
#line 444
    optind ++;
    }
  }
  {
#line 449
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 449
    if (! (optind < argc)) {
#line 449
      goto while_break___0;
    }
    {
#line 452
    tmp = optind;
#line 452
    optind ++;
#line 452
    arg_register_error(endtable, (void *)endtable, 3, (char const   *)*(argv + tmp));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 455
  return;
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static void arg_parse_check(struct arg_hdr **table , struct arg_end *endtable ) 
{ 
  int tabindex ;
  void *parent ;
  int errorcode ;
  int tmp ;
  int tmp___0 ;

  {
#line 462
  tabindex = 0;
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    if ((*(table + tabindex))->checkfn) {
      {
#line 468
      parent = (*(table + tabindex))->parent;
#line 469
      tmp = (*((*(table + tabindex))->checkfn))(parent);
#line 469
      errorcode = tmp;
      }
#line 470
      if (errorcode != 0) {
        {
#line 471
        arg_register_error(endtable, parent, errorcode, (char const   *)((void *)0));
        }
      }
    }
#line 464
    tmp___0 = tabindex;
#line 464
    tabindex ++;
#line 464
    if ((int )(*(table + tmp___0))->flag & 1) {
#line 464
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static void arg_reset(void **argtable ) 
{ 
  struct arg_hdr **table ;
  int tabindex ;
  int tmp ;

  {
#line 480
  table = (struct arg_hdr **)argtable;
#line 481
  tabindex = 0;
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if ((*(table + tabindex))->resetfn) {
      {
#line 486
      (*((*(table + tabindex))->resetfn))((*(table + tabindex))->parent);
      }
    }
#line 483
    tmp = tabindex;
#line 483
    tabindex ++;
#line 483
    if ((int )(*(table + tmp))->flag & 1) {
#line 483
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 488
  return;
}
}
#line 491 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
int arg_parse(int argc , char **argv , void **argtable ) 
{ 
  struct arg_hdr **table ;
  struct arg_end *endtable ;
  int endindex ;
  char **argvcopy ;
  void *tmp ;
  int i ;

  {
  {
#line 493
  table = (struct arg_hdr **)argtable;
#line 496
  argvcopy = (char **)((void *)0);
#line 501
  arg_reset(argtable);
#line 504
  endindex = arg_endindex(table);
#line 505
  endtable = (struct arg_end *)*(table + endindex);
  }
#line 510
  if (argc == 0) {
    {
#line 513
    arg_parse_check(table, endtable);
    }
#line 516
    return (endtable->count);
  }
  {
#line 519
  tmp = malloc(sizeof(char *) * (unsigned long )argc);
#line 519
  argvcopy = (char **)tmp;
  }
#line 520
  if (argvcopy) {
#line 529
    i = 0;
    {
#line 529
    while (1) {
      while_continue: /* CIL Label */ ;
#line 529
      if (! (i < argc)) {
#line 529
        goto while_break;
      }
#line 530
      *(argvcopy + i) = *(argv + i);
#line 529
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 533
    arg_parse_tagged(argc, argvcopy, table, endtable);
#line 536
    arg_parse_untagged(argc, argvcopy, table, endtable);
    }
#line 539
    if (endtable->count == 0) {
      {
#line 540
      arg_parse_check(table, endtable);
      }
    }
    {
#line 543
    free((void *)argvcopy);
    }
  } else {
    {
#line 548
    arg_register_error(endtable, (void *)endtable, 2, (char const   *)((void *)0));
    }
  }
#line 551
  return (endtable->count);
}
}
#line 575 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static void arg_cat(char **pdest , char const   *src , size_t *pndest ) 
{ 
  char *dest ;
  char *end ;
  char *tmp ;
  char const   *tmp___0 ;

  {
#line 578
  dest = *pdest;
#line 579
  end = dest + *pndest;
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    if ((unsigned long )dest < (unsigned long )end) {
#line 582
      if (! ((int )*dest != 0)) {
#line 582
        goto while_break;
      }
    } else {
#line 582
      goto while_break;
    }
#line 583
    dest ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 586
    if ((unsigned long )dest < (unsigned long )end) {
#line 586
      if (! ((int const   )*src != 0)) {
#line 586
        goto while_break___0;
      }
    } else {
#line 586
      goto while_break___0;
    }
#line 587
    tmp = dest;
#line 587
    dest ++;
#line 587
    tmp___0 = src;
#line 587
    src ++;
#line 587
    *tmp = (char )*tmp___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 590
  *dest = (char)0;
#line 593
  *pndest = (size_t )(end - dest);
#line 594
  *pdest = dest;
#line 595
  return;
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static void arg_cat_option(char *dest , size_t ndest , char const   *shortopts , char const   *longopts ,
                           char const   *datatype , int optvalue ) 
{ 
  char option[3] ;
  size_t ncspn ;
  size_t tmp ;

  {
#line 601
  if (shortopts) {
    {
#line 607
    option[0] = (char )'-';
#line 608
    option[1] = (char )*(shortopts + 0);
#line 609
    option[2] = (char)0;
#line 611
    arg_cat(& dest, (char const   *)(option), & ndest);
    }
#line 612
    if (datatype) {
      {
#line 614
      arg_cat(& dest, " ", & ndest);
      }
#line 615
      if (optvalue) {
        {
#line 617
        arg_cat(& dest, "[", & ndest);
#line 618
        arg_cat(& dest, datatype, & ndest);
#line 619
        arg_cat(& dest, "]", & ndest);
        }
      } else {
        {
#line 622
        arg_cat(& dest, datatype, & ndest);
        }
      }
    }
  } else
#line 625
  if (longopts) {
    {
#line 630
    arg_cat(& dest, "--", & ndest);
#line 633
    ncspn = strcspn(longopts, ",");
    }
#line 634
    if (ncspn < ndest) {
#line 634
      tmp = ncspn;
    } else {
#line 634
      tmp = ndest;
    }
    {
#line 634
    strncat((char */* __restrict  */)dest, (char const   */* __restrict  */)longopts,
            tmp);
    }
#line 636
    if (datatype) {
      {
#line 638
      arg_cat(& dest, "=", & ndest);
      }
#line 639
      if (optvalue) {
        {
#line 641
        arg_cat(& dest, "[", & ndest);
#line 642
        arg_cat(& dest, datatype, & ndest);
#line 643
        arg_cat(& dest, "]", & ndest);
        }
      } else {
        {
#line 646
        arg_cat(& dest, datatype, & ndest);
        }
      }
    }
  } else
#line 649
  if (datatype) {
#line 651
    if (optvalue) {
      {
#line 653
      arg_cat(& dest, "[", & ndest);
#line 654
      arg_cat(& dest, datatype, & ndest);
#line 655
      arg_cat(& dest, "]", & ndest);
      }
    } else {
      {
#line 658
      arg_cat(& dest, datatype, & ndest);
      }
    }
  }
#line 660
  return;
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static void arg_cat_optionv(char *dest , size_t ndest , char const   *shortopts ,
                            char const   *longopts , char const   *datatype , int optvalue ,
                            char const   *separator ) 
{ 
  char const   *c ;
  char shortopt[3] ;
  char const   *c___0 ;
  size_t ncspn ;
  size_t tmp ;

  {
#line 665
  if (separator) {
#line 665
    separator = separator;
  } else {
#line 665
    separator = "";
  }
#line 667
  if (shortopts) {
#line 669
    c = shortopts;
    {
#line 670
    while (1) {
      while_continue: /* CIL Label */ ;
#line 670
      if (! *c) {
#line 670
        goto while_break;
      }
      {
#line 677
      shortopt[0] = (char )'-';
#line 678
      shortopt[1] = (char )*c;
#line 679
      shortopt[2] = (char)0;
#line 681
      arg_cat(& dest, (char const   *)(shortopt), & ndest);
#line 682
      c ++;
      }
#line 682
      if (*c) {
        {
#line 683
        arg_cat(& dest, separator, & ndest);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 688
  if (shortopts) {
#line 688
    if (longopts) {
      {
#line 689
      arg_cat(& dest, separator, & ndest);
      }
    }
  }
#line 691
  if (longopts) {
#line 693
    c___0 = longopts;
    {
#line 694
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 694
      if (! *c___0) {
#line 694
        goto while_break___0;
      }
      {
#line 699
      arg_cat(& dest, "--", & ndest);
#line 702
      ncspn = strcspn(c___0, ",");
      }
#line 703
      if (ncspn < ndest) {
#line 703
        tmp = ncspn;
      } else {
#line 703
        tmp = ndest;
      }
      {
#line 703
      strncat((char */* __restrict  */)dest, (char const   */* __restrict  */)c___0,
              tmp);
#line 704
      c___0 += ncspn;
      }
#line 707
      if ((int const   )*c___0 == 44) {
        {
#line 709
        arg_cat(& dest, separator, & ndest);
#line 710
        c___0 ++;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 715
  if (datatype) {
#line 717
    if (longopts) {
      {
#line 718
      arg_cat(& dest, "=", & ndest);
      }
    } else
#line 719
    if (shortopts) {
      {
#line 720
      arg_cat(& dest, " ", & ndest);
      }
    }
#line 722
    if (optvalue) {
      {
#line 724
      arg_cat(& dest, "[", & ndest);
#line 725
      arg_cat(& dest, datatype, & ndest);
#line 726
      arg_cat(& dest, "]", & ndest);
      }
    } else {
      {
#line 729
      arg_cat(& dest, datatype, & ndest);
      }
    }
  }
#line 731
  return;
}
}
#line 735 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
void arg_print_option(FILE *fp , char const   *shortopts , char const   *longopts ,
                      char const   *datatype , char const   *suffix ) 
{ 
  char syntax[200] ;
  unsigned int tmp ;

  {
#line 737
  syntax[0] = (char )'\000';
#line 737
  tmp = 1U;
  {
#line 737
  while (1) {
    while_continue: /* CIL Label */ ;
#line 737
    if (tmp >= 200U) {
#line 737
      goto while_break;
    }
#line 737
    syntax[tmp] = (char)0;
#line 737
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 738
  if (suffix) {
#line 738
    suffix = suffix;
  } else {
#line 738
    suffix = "";
  }
  {
#line 741
  arg_cat_optionv(syntax, sizeof(syntax), shortopts, longopts, datatype, 0, "|");
#line 743
  fputs((char const   */* __restrict  */)(syntax), (FILE */* __restrict  */)fp);
#line 744
  fputs((char const   */* __restrict  */)suffix, (FILE */* __restrict  */)fp);
  }
#line 745
  return;
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static void arg_print_gnuswitch(FILE *fp , struct arg_hdr **table ) 
{ 
  int tabindex ;
  char *format1 ;
  char *format2 ;
  char *suffix ;

  {
#line 757
  format1 = (char *)" -%c";
#line 758
  format2 = (char *)" [-%c";
#line 759
  suffix = (char *)"";
#line 762
  tabindex = 0;
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;
#line 762
    if (*(table + tabindex)) {
#line 762
      if (! (! ((int )(*(table + tabindex))->flag & 1))) {
#line 762
        goto while_break;
      }
    } else {
#line 762
      goto while_break;
    }
#line 765
    if ((*(table + tabindex))->mincount < 1) {
#line 766
      goto __Cont;
    }
#line 769
    if ((unsigned long )(*(table + tabindex))->shortopts == (unsigned long )((void *)0)) {
#line 770
      goto __Cont;
    }
#line 773
    if ((int )(*(table + tabindex))->flag & 2) {
#line 774
      goto __Cont;
    }
    {
#line 777
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)format1,
            (int const   )*((*(table + tabindex))->shortopts + 0));
#line 778
    format1 = (char *)"%c";
#line 779
    format2 = (char *)"[%c";
    }
    __Cont: /* CIL Label */ 
#line 762
    tabindex ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 783
  tabindex = 0;
  {
#line 783
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 783
    if (*(table + tabindex)) {
#line 783
      if (! (! ((int )(*(table + tabindex))->flag & 1))) {
#line 783
        goto while_break___0;
      }
    } else {
#line 783
      goto while_break___0;
    }
#line 786
    if ((*(table + tabindex))->mincount > 0) {
#line 787
      goto __Cont___0;
    }
#line 790
    if ((unsigned long )(*(table + tabindex))->shortopts == (unsigned long )((void *)0)) {
#line 791
      goto __Cont___0;
    }
#line 794
    if ((int )(*(table + tabindex))->flag & 2) {
#line 795
      goto __Cont___0;
    }
    {
#line 798
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)format2,
            (int const   )*((*(table + tabindex))->shortopts + 0));
#line 799
    format2 = (char *)"%c";
#line 800
    suffix = (char *)"]";
    }
    __Cont___0: /* CIL Label */ 
#line 783
    tabindex ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 803
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)suffix);
  }
#line 804
  return;
}
}
#line 807 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
void arg_print_syntax(FILE *fp , void **argtable , char const   *suffix ) 
{ 
  struct arg_hdr **table ;
  int i ;
  int tabindex ;
  char syntax[200] ;
  unsigned int tmp ;
  char const   *shortopts ;
  char const   *longopts ;
  char const   *datatype ;
  size_t tmp___0 ;

  {
  {
#line 809
  table = (struct arg_hdr **)argtable;
#line 813
  arg_print_gnuswitch(fp, table);
#line 816
  tabindex = 0;
  }
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 816
    if (*(table + tabindex)) {
#line 816
      if (! (! ((int )(*(table + tabindex))->flag & 1))) {
#line 816
        goto while_break;
      }
    } else {
#line 816
      goto while_break;
    }
#line 818
    syntax[0] = (char )'\000';
#line 818
    tmp = 1U;
    {
#line 818
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 818
      if (tmp >= 200U) {
#line 818
        goto while_break___0;
      }
#line 818
      syntax[tmp] = (char)0;
#line 818
      tmp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 822
    if ((*(table + tabindex))->shortopts) {
#line 822
      if (! ((int )(*(table + tabindex))->flag & 2)) {
#line 823
        goto __Cont;
      }
    }
    {
#line 825
    shortopts = (*(table + tabindex))->shortopts;
#line 826
    longopts = (*(table + tabindex))->longopts;
#line 827
    datatype = (*(table + tabindex))->datatype;
#line 828
    arg_cat_option(syntax, sizeof(syntax), shortopts, longopts, datatype, (int )(*(table + tabindex))->flag & 4);
#line 830
    tmp___0 = strlen((char const   *)(syntax));
    }
#line 830
    if (tmp___0 > 0UL) {
#line 833
      i = 0;
      {
#line 833
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 833
        if (! (i < (*(table + tabindex))->mincount)) {
#line 833
          goto while_break___1;
        }
        {
#line 834
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s",
                syntax);
#line 833
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 839
      if ((*(table + tabindex))->maxcount - (*(table + tabindex))->mincount == 0) {
#line 839
        goto case_0;
      }
#line 841
      if ((*(table + tabindex))->maxcount - (*(table + tabindex))->mincount == 1) {
#line 841
        goto case_1;
      }
#line 844
      if ((*(table + tabindex))->maxcount - (*(table + tabindex))->mincount == 2) {
#line 844
        goto case_2;
      }
#line 847
      goto switch_default;
      case_0: /* CIL Label */ 
#line 840
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 842
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" [%s]",
              syntax);
      }
#line 843
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 845
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" [%s] [%s]",
              syntax, syntax);
      }
#line 846
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 848
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" [%s]...",
              syntax);
      }
#line 849
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 816
    tabindex ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  if (suffix) {
    {
#line 855
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", suffix);
    }
  }
#line 856
  return;
}
}
#line 859 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
void arg_print_syntaxv(FILE *fp , void **argtable , char const   *suffix ) 
{ 
  struct arg_hdr **table ;
  int i ;
  int tabindex ;
  char syntax[200] ;
  unsigned int tmp ;
  char const   *shortopts ;
  char const   *longopts ;
  char const   *datatype ;

  {
#line 861
  table = (struct arg_hdr **)argtable;
#line 865
  tabindex = 0;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (*(table + tabindex)) {
#line 865
      if (! (! ((int )(*(table + tabindex))->flag & 1))) {
#line 865
        goto while_break;
      }
    } else {
#line 865
      goto while_break;
    }
#line 867
    syntax[0] = (char )'\000';
#line 867
    tmp = 1U;
    {
#line 867
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 867
      if (tmp >= 200U) {
#line 867
        goto while_break___0;
      }
#line 867
      syntax[tmp] = (char)0;
#line 867
      tmp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 870
    shortopts = (*(table + tabindex))->shortopts;
#line 871
    longopts = (*(table + tabindex))->longopts;
#line 872
    datatype = (*(table + tabindex))->datatype;
#line 873
    arg_cat_optionv(syntax, sizeof(syntax), shortopts, longopts, datatype, (int )(*(table + tabindex))->flag & 4,
                    "|");
#line 876
    i = 0;
    }
    {
#line 876
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 876
      if (! (i < (*(table + tabindex))->mincount)) {
#line 876
        goto while_break___1;
      }
      {
#line 877
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s",
              syntax);
#line 876
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 882
    if ((*(table + tabindex))->maxcount - (*(table + tabindex))->mincount == 0) {
#line 882
      goto case_0;
    }
#line 884
    if ((*(table + tabindex))->maxcount - (*(table + tabindex))->mincount == 1) {
#line 884
      goto case_1;
    }
#line 887
    if ((*(table + tabindex))->maxcount - (*(table + tabindex))->mincount == 2) {
#line 887
      goto case_2;
    }
#line 890
    goto switch_default;
    case_0: /* CIL Label */ 
#line 883
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 885
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" [%s]",
            syntax);
    }
#line 886
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 888
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" [%s] [%s]",
            syntax, syntax);
    }
#line 889
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 891
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" [%s]...",
            syntax);
    }
#line 892
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 865
    tabindex ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 896
  if (suffix) {
    {
#line 897
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", suffix);
    }
  }
#line 898
  return;
}
}
#line 901 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
void arg_print_glossary(FILE *fp , void **argtable , char const   *format ) 
{ 
  struct arg_hdr **table ;
  int tabindex ;
  char syntax[200] ;
  unsigned int tmp ;
  char const   *shortopts ;
  char const   *longopts ;
  char const   *datatype ;
  char const   *glossary ;

  {
#line 903
  table = (struct arg_hdr **)argtable;
#line 906
  if (format) {
#line 906
    format = format;
  } else {
#line 906
    format = "  %-20s %s\n";
  }
#line 907
  tabindex = 0;
  {
#line 907
  while (1) {
    while_continue: /* CIL Label */ ;
#line 907
    if (! (! ((int )(*(table + tabindex))->flag & 1))) {
#line 907
      goto while_break;
    }
#line 909
    if ((*(table + tabindex))->glossary) {
#line 911
      syntax[0] = (char )'\000';
#line 911
      tmp = 1U;
      {
#line 911
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 911
        if (tmp >= 200U) {
#line 911
          goto while_break___0;
        }
#line 911
        syntax[tmp] = (char)0;
#line 911
        tmp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 912
      shortopts = (*(table + tabindex))->shortopts;
#line 913
      longopts = (*(table + tabindex))->longopts;
#line 914
      datatype = (*(table + tabindex))->datatype;
#line 915
      glossary = (*(table + tabindex))->glossary;
#line 916
      arg_cat_optionv(syntax, sizeof(syntax), shortopts, longopts, datatype, (int )(*(table + tabindex))->flag & 4,
                      ", ");
#line 917
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)format,
              syntax, glossary);
      }
    }
#line 907
    tabindex ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return;
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
static void arg_print_formatted(FILE *fp , unsigned int const   lmargin , unsigned int const   rmargin ,
                                char const   *text ) 
{ 
  unsigned int textlen ;
  size_t tmp ;
  unsigned int line_start ;
  unsigned int line_end ;
  unsigned int colwidth ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned int i ;

  {
  {
#line 958
  tmp = strlen(text);
#line 958
  textlen = (unsigned int )tmp;
#line 959
  line_start = 0U;
#line 960
  line_end = textlen + 1U;
#line 961
  colwidth = (unsigned int )((rmargin - lmargin) + 1U);
  }
#line 964
  if (line_end < line_start) {
    {
#line 965
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
            text);
    }
  }
  {
#line 967
  while (1) {
    while_continue: /* CIL Label */ ;
#line 967
    if (! (line_end - 1U > line_start)) {
#line 967
      goto while_break;
    }
    {
#line 972
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 972
      tmp___0 = __ctype_b_loc();
      }
#line 972
      if (! ((int const   )*(*tmp___0 + (int )*(text + line_start)) & 8192)) {
#line 972
        goto while_break___0;
      }
#line 973
      line_start ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 975
    if (line_end - line_start > colwidth) {
#line 976
      line_end = line_start + colwidth;
    }
    {
#line 979
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 979
      if (line_end > line_start) {
#line 979
        if (line_end - line_start > colwidth) {
          {
#line 979
          tmp___1 = __ctype_b_loc();
          }
#line 979
          if ((int const   )*(*tmp___1 + (int )*(text + line_end)) & 8192) {
#line 979
            goto while_break___1;
          }
        } else {
#line 979
          goto while_break___1;
        }
      } else {
#line 979
        goto while_break___1;
      }
#line 982
      line_end --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 987
    line_end --;
    {
#line 990
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 990
      if (! (line_start < line_end)) {
#line 990
        goto while_break___2;
      }
      {
#line 992
      fputc((int )*(text + line_start), fp);
#line 993
      line_start ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 995
    fputc('\n', fp);
    }
#line 998
    if (line_end + 1U < textlen) {
#line 1002
      i = 0U;
      {
#line 1002
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1002
        if (! (i < (unsigned int )lmargin)) {
#line 1002
          goto while_break___3;
        }
        {
#line 1003
        fputc(' ', fp);
#line 1002
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1005
      line_end = textlen;
    }
#line 1009
    line_end ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1012
  return;
}
}
#line 1023 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
void arg_print_glossary_gnu(FILE *fp , void **argtable ) 
{ 
  struct arg_hdr **table ;
  int tabindex ;
  char syntax[200] ;
  unsigned int tmp ;
  char const   *shortopts ;
  char const   *longopts ;
  char const   *datatype ;
  char const   *glossary ;
  size_t tmp___0 ;

  {
#line 1025
  table = (struct arg_hdr **)argtable;
#line 1028
  tabindex = 0;
  {
#line 1028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1028
    if (! (! ((int )(*(table + tabindex))->flag & 1))) {
#line 1028
      goto while_break;
    }
#line 1030
    if ((*(table + tabindex))->glossary) {
#line 1032
      syntax[0] = (char )'\000';
#line 1032
      tmp = 1U;
      {
#line 1032
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1032
        if (tmp >= 200U) {
#line 1032
          goto while_break___0;
        }
#line 1032
        syntax[tmp] = (char)0;
#line 1032
        tmp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1033
      shortopts = (*(table + tabindex))->shortopts;
#line 1034
      longopts = (*(table + tabindex))->longopts;
#line 1035
      datatype = (*(table + tabindex))->datatype;
#line 1036
      glossary = (*(table + tabindex))->glossary;
#line 1038
      if (! shortopts) {
#line 1038
        if (longopts) {
          {
#line 1041
          memset((void *)(syntax), ' ', (size_t )4);
#line 1042
          *(syntax + 4) = (char )'\000';
          }
        }
      }
      {
#line 1045
      arg_cat_optionv(syntax, sizeof(syntax), shortopts, longopts, datatype, (int )(*(table + tabindex))->flag & 4,
                      ", ");
#line 1048
      tmp___0 = strlen((char const   *)(syntax));
      }
#line 1048
      if (tmp___0 > 25UL) {
        {
#line 1050
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  %-25s %s\n",
                syntax, "");
#line 1051
        syntax[0] = (char )'\000';
        }
      }
      {
#line 1054
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  %-25s ",
              syntax);
#line 1055
      arg_print_formatted(fp, (unsigned int const   )28, (unsigned int const   )79,
                          glossary);
      }
    }
#line 1028
    tabindex ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1059
  fputc('\n', fp);
  }
#line 1060
  return;
}
}
#line 1067 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
int arg_nullcheck(void **argtable ) 
{ 
  struct arg_hdr **table ;
  int tabindex ;
  int tmp ;

  {
#line 1069
  table = (struct arg_hdr **)argtable;
#line 1073
  if (! table) {
#line 1074
    return (1);
  }
#line 1076
  tabindex = 0;
  {
#line 1077
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1080
    if (! *(table + tabindex)) {
#line 1081
      return (1);
    }
#line 1077
    tmp = tabindex;
#line 1077
    tabindex ++;
#line 1077
    if ((int )(*(table + tmp))->flag & 1) {
#line 1077
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1084
  return (0);
}
}
#line 1099 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
void arg_free(void **argtable ) 
{ 
  struct arg_hdr **table ;
  int tabindex ;
  int flag ;
  int tmp ;

  {
#line 1101
  table = (struct arg_hdr **)argtable;
#line 1102
  tabindex = 0;
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1113
    if ((unsigned long )*(table + tabindex) == (unsigned long )((void *)0)) {
#line 1114
      goto while_break;
    }
    {
#line 1116
    flag = (int )(*(table + tabindex))->flag;
#line 1117
    free((void *)*(table + tabindex));
#line 1118
    tmp = tabindex;
#line 1118
    tabindex ++;
#line 1118
    *(table + tmp) = (struct arg_hdr *)((void *)0);
    }
#line 1105
    if (! (! (flag & 1))) {
#line 1105
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1121
  return;
}
}
#line 1124 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.c"
void arg_freetable(void **argtable , size_t n ) 
{ 
  struct arg_hdr **table ;
  int tabindex ;

  {
#line 1126
  table = (struct arg_hdr **)argtable;
#line 1127
  tabindex = 0;
#line 1129
  tabindex = 0;
  {
#line 1129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1129
    if (! ((size_t )tabindex < n)) {
#line 1129
      goto while_break;
    }
#line 1131
    if ((unsigned long )*(table + tabindex) == (unsigned long )((void *)0)) {
#line 1132
      goto __Cont;
    }
    {
#line 1134
    free((void *)*(table + tabindex));
#line 1135
    *(table + tabindex) = (struct arg_hdr *)((void *)0);
    }
    __Cont: /* CIL Label */ 
#line 1129
    tabindex ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1137
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_lit *arg_lit0(char const   *shortopts , char const   *longopts , char const   *glossary ) ;
#line 155
struct arg_lit *arg_lit1(char const   *shortopts , char const   *longopts , char const   *glossary ) ;
#line 158
struct arg_lit *arg_litn(char const   *shortopts , char const   *longopts , int mincount ,
                         int maxcount , char const   *glossary ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_lit.c"
static void resetfn(struct arg_lit *parent ) 
{ 


  {
#line 39
  parent->count = 0;
#line 40
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_lit.c"
static int scanfn(struct arg_lit *parent , char const   *argval ) 
{ 
  int errorcode ;

  {
#line 44
  errorcode = 0;
#line 45
  if (parent->count < parent->hdr.maxcount) {
#line 46
    (parent->count) ++;
  } else {
#line 48
    errorcode = 2;
  }
#line 50
  return (errorcode);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_lit.c"
static int checkfn(struct arg_lit *parent ) 
{ 
  int errorcode ;
  int tmp ;

  {
#line 55
  if (parent->count < parent->hdr.mincount) {
#line 55
    tmp = 1;
  } else {
#line 55
    tmp = 0;
  }
#line 55
  errorcode = tmp;
#line 57
  return (errorcode);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_lit.c"
static void errorfn(struct arg_lit *parent , FILE *fp , int errorcode , char const   *argval ,
                    char const   *progname ) 
{ 
  char const   *shortopts ;
  char const   *longopts ;
  char const   *datatype ;

  {
#line 62
  shortopts = parent->hdr.shortopts;
#line 63
  longopts = parent->hdr.longopts;
#line 64
  datatype = parent->hdr.datatype;
  {
#line 68
  if (errorcode == 1) {
#line 68
    goto case_1;
  }
#line 74
  if (errorcode == 2) {
#line 74
    goto case_2;
  }
#line 66
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 69
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s: missing option ",
          progname);
#line 70
  arg_print_option(fp, shortopts, longopts, datatype, "\n");
#line 71
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
#line 72
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 75
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s: extraneous option ",
          progname);
#line 76
  arg_print_option(fp, shortopts, longopts, datatype, "\n");
  }
#line 77
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_lit.c"
struct arg_lit *arg_lit0(char const   *shortopts , char const   *longopts , char const   *glossary ) 
{ 
  struct arg_lit *tmp ;

  {
  {
#line 84
  tmp = arg_litn(shortopts, longopts, 0, 1, glossary);
  }
#line 84
  return (tmp);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_lit.c"
struct arg_lit *arg_lit1(char const   *shortopts , char const   *longopts , char const   *glossary ) 
{ 
  struct arg_lit *tmp ;

  {
  {
#line 89
  tmp = arg_litn(shortopts, longopts, 1, 1, glossary);
  }
#line 89
  return (tmp);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_lit.c"
struct arg_lit *arg_litn(char const   *shortopts , char const   *longopts , int mincount ,
                         int maxcount , char const   *glossary ) 
{ 
  struct arg_lit *result ;
  void *tmp ;

  {
#line 101
  if (maxcount < mincount) {
#line 101
    maxcount = mincount;
  } else {
#line 101
    maxcount = maxcount;
  }
  {
#line 103
  tmp = malloc(sizeof(struct arg_lit ));
#line 103
  result = (struct arg_lit *)tmp;
  }
#line 104
  if (result) {
#line 107
    result->hdr.flag = (char)0;
#line 108
    result->hdr.shortopts = shortopts;
#line 109
    result->hdr.longopts = longopts;
#line 110
    result->hdr.datatype = (char const   *)((void *)0);
#line 111
    result->hdr.glossary = glossary;
#line 112
    result->hdr.mincount = mincount;
#line 113
    result->hdr.maxcount = maxcount;
#line 114
    result->hdr.parent = (void *)result;
#line 115
    result->hdr.resetfn = (arg_resetfn *)(& resetfn);
#line 116
    result->hdr.scanfn = (arg_scanfn *)(& scanfn);
#line 117
    result->hdr.checkfn = (arg_checkfn *)(& checkfn);
#line 118
    result->hdr.errorfn = (arg_errorfn *)(& errorfn);
#line 121
    result->count = 0;
  }
#line 124
  return (result);
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 176 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_int *arg_int0(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         char const   *glossary ) ;
#line 180
struct arg_int *arg_int1(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         char const   *glossary ) ;
#line 184
struct arg_int *arg_intn(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         int mincount , int maxcount , char const   *glossary ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_int.c"
static void resetfn___0(struct arg_int *parent ) 
{ 


  {
#line 40
  parent->count = 0;
#line 41
  return;
}
}
#line 60
extern int ( /* missing proto */  isspace)() ;
#line 89
extern int ( /* missing proto */  toupper)() ;
#line 53 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_int.c"
static long strtol0X(char const   *str , char const   **endptr , char X , int base ) 
{ 
  long val ;
  int s ;
  char const   *ptr ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 56
  s = 1;
#line 57
  ptr = str;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 60
    tmp = isspace((int const   )*ptr);
    }
#line 60
    if (! tmp) {
#line 60
      goto while_break;
    }
#line 61
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  if ((int const   )*ptr == 43) {
#line 67
    goto case_43;
  }
#line 71
  if ((int const   )*ptr == 45) {
#line 71
    goto case_45;
  }
#line 75
  goto switch_default;
  case_43: /* CIL Label */ 
#line 68
  ptr ++;
#line 69
  s = 1;
#line 70
  goto switch_break;
  case_45: /* CIL Label */ 
#line 72
  ptr ++;
#line 73
  s = -1;
#line 74
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 76
  s = 1;
#line 77
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 82
  tmp___0 = ptr;
#line 82
  ptr ++;
#line 82
  if ((int const   )*tmp___0 != 48) {
#line 85
    *endptr = str;
#line 86
    return (0L);
  }
  {
#line 89
  tmp___1 = ptr;
#line 89
  ptr ++;
#line 89
  tmp___2 = toupper((int const   )*tmp___1);
#line 89
  tmp___3 = toupper((int )X);
  }
#line 89
  if (tmp___2 != tmp___3) {
#line 92
    *endptr = str;
#line 93
    return (0L);
  }
  {
#line 98
  val = strtol((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((char **)endptr),
               base);
  }
#line 99
  if ((unsigned long )*endptr == (unsigned long )ptr) {
#line 102
    *endptr = str;
#line 103
    return (0L);
  }
#line 107
  return ((long )s * val);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_int.c"
static int detectsuffix(char const   *str , char const   *suffix ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    tmp = toupper((int const   )*str);
#line 116
    tmp___0 = toupper((int const   )*suffix);
    }
#line 116
    if (! (tmp == tmp___0)) {
#line 116
      goto while_break;
    }
#line 121
    if ((int const   )*str == 0) {
#line 122
      return (1);
    }
#line 125
    str ++;
#line 126
    suffix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  if ((int const   )*suffix != 0) {
#line 132
    return (0);
  }
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 135
    tmp___1 = isspace((int const   )*str);
    }
#line 135
    if (! tmp___1) {
#line 135
      goto while_break___0;
    }
#line 136
    str ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 139
  if ((int const   )*str == 0) {
#line 139
    tmp___2 = 1;
  } else {
#line 139
    tmp___2 = 0;
  }
#line 139
  return (tmp___2);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_int.c"
static int scanfn___0(struct arg_int *parent , char const   *argval ) 
{ 
  int errorcode ;
  long val ;
  char const   *end ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 145
  errorcode = 0;
#line 147
  if (parent->count == parent->hdr.maxcount) {
#line 150
    errorcode = 2;
  } else
#line 152
  if (! argval) {
#line 157
    (parent->count) ++;
  } else {
    {
#line 165
    val = strtol0X(argval, & end, (char )'X', 16);
    }
#line 166
    if ((unsigned long )end == (unsigned long )argval) {
      {
#line 169
      val = strtol0X(argval, & end, (char )'O', 8);
      }
#line 170
      if ((unsigned long )end == (unsigned long )argval) {
        {
#line 173
        val = strtol0X(argval, & end, (char )'B', 2);
        }
#line 174
        if ((unsigned long )end == (unsigned long )argval) {
          {
#line 177
          val = strtol((char const   */* __restrict  */)argval, (char **/* __restrict  */)((char **)(& end)),
                       10);
          }
#line 178
          if ((unsigned long )end == (unsigned long )argval) {
#line 181
            return (3);
          }
        }
      }
    }
#line 189
    if (val > 2147483647L) {
#line 190
      errorcode = 4;
    } else
#line 189
    if (val < (-0x7FFFFFFF-1)) {
#line 190
      errorcode = 4;
    }
    {
#line 194
    tmp___2 = detectsuffix(end, "KB");
    }
#line 194
    if (tmp___2) {
#line 196
      if (val > 2097151L) {
#line 197
        errorcode = 4;
      } else
#line 196
      if (val < -2097152L) {
#line 197
        errorcode = 4;
      } else {
#line 199
        val *= 1024L;
      }
    } else {
      {
#line 201
      tmp___1 = detectsuffix(end, "MB");
      }
#line 201
      if (tmp___1) {
#line 203
        if (val > 2047L) {
#line 204
          errorcode = 4;
        } else
#line 203
        if (val < -2048L) {
#line 204
          errorcode = 4;
        } else {
#line 206
          val *= 1048576L;
        }
      } else {
        {
#line 208
        tmp___0 = detectsuffix(end, "GB");
        }
#line 208
        if (tmp___0) {
#line 210
          if (val > 1L) {
#line 211
            errorcode = 4;
          } else
#line 210
          if (val < -2L) {
#line 211
            errorcode = 4;
          } else {
#line 213
            val *= 1073741824L;
          }
        } else {
          {
#line 215
          tmp = detectsuffix(end, "");
          }
#line 215
          if (! tmp) {
#line 216
            errorcode = 3;
          }
        }
      }
    }
#line 219
    if (errorcode == 0) {
#line 220
      tmp___3 = parent->count;
#line 220
      (parent->count) ++;
#line 220
      *(parent->ival + tmp___3) = (int )val;
    }
  }
#line 224
  return (errorcode);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_int.c"
static int checkfn___0(struct arg_int *parent ) 
{ 
  int errorcode ;
  int tmp ;

  {
#line 229
  if (parent->count < parent->hdr.mincount) {
#line 229
    tmp = 1;
  } else {
#line 229
    tmp = 0;
  }
#line 229
  errorcode = tmp;
#line 231
  return (errorcode);
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_int.c"
static void errorfn___0(struct arg_int *parent , FILE *fp , int errorcode , char const   *argval ,
                        char const   *progname ) 
{ 
  char const   *shortopts ;
  char const   *longopts ;
  char const   *datatype ;

  {
#line 236
  shortopts = parent->hdr.shortopts;
#line 237
  longopts = parent->hdr.longopts;
#line 238
  datatype = parent->hdr.datatype;
#line 241
  if (argval) {
#line 241
    argval = argval;
  } else {
#line 241
    argval = "";
  }
  {
#line 243
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s: ", progname);
  }
  {
#line 246
  if (errorcode == 1) {
#line 246
    goto case_1;
  }
#line 251
  if (errorcode == 2) {
#line 251
    goto case_2;
  }
#line 256
  if (errorcode == 3) {
#line 256
    goto case_3;
  }
#line 261
  if (errorcode == 4) {
#line 261
    goto case_4;
  }
#line 244
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 247
  fputs((char const   */* __restrict  */)"missing option ", (FILE */* __restrict  */)fp);
#line 248
  arg_print_option(fp, shortopts, longopts, datatype, "\n");
  }
#line 249
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 252
  fputs((char const   */* __restrict  */)"excess option ", (FILE */* __restrict  */)fp);
#line 253
  arg_print_option(fp, shortopts, longopts, argval, "\n");
  }
#line 254
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 257
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"invalid argument \"%s\" to option ",
          argval);
#line 258
  arg_print_option(fp, shortopts, longopts, datatype, "\n");
  }
#line 259
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 262
  fputs((char const   */* __restrict  */)"integer overflow at option ", (FILE */* __restrict  */)fp);
#line 263
  arg_print_option(fp, shortopts, longopts, datatype, " ");
#line 264
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"(%s is too large)\n",
          argval);
  }
#line 265
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 267
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_int.c"
struct arg_int *arg_int0(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         char const   *glossary ) 
{ 
  struct arg_int *tmp ;

  {
  {
#line 275
  tmp = arg_intn(shortopts, longopts, datatype, 0, 1, glossary);
  }
#line 275
  return (tmp);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_int.c"
struct arg_int *arg_int1(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         char const   *glossary ) 
{ 
  struct arg_int *tmp ;

  {
  {
#line 283
  tmp = arg_intn(shortopts, longopts, datatype, 1, 1, glossary);
  }
#line 283
  return (tmp);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_int.c"
struct arg_int *arg_intn(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         int mincount , int maxcount , char const   *glossary ) 
{ 
  size_t nbytes ;
  struct arg_int *result ;
  void *tmp ;

  {
#line 298
  if (maxcount < mincount) {
#line 298
    maxcount = mincount;
  } else {
#line 298
    maxcount = maxcount;
  }
  {
#line 300
  nbytes = sizeof(struct arg_int ) + (unsigned long )maxcount * sizeof(int );
#line 303
  tmp = malloc(nbytes);
#line 303
  result = (struct arg_int *)tmp;
  }
#line 304
  if (result) {
#line 307
    result->hdr.flag = (char)2;
#line 308
    result->hdr.shortopts = shortopts;
#line 309
    result->hdr.longopts = longopts;
#line 310
    if (datatype) {
#line 310
      result->hdr.datatype = datatype;
    } else {
#line 310
      result->hdr.datatype = "<int>";
    }
#line 311
    result->hdr.glossary = glossary;
#line 312
    result->hdr.mincount = mincount;
#line 313
    result->hdr.maxcount = maxcount;
#line 314
    result->hdr.parent = (void *)result;
#line 315
    result->hdr.resetfn = (arg_resetfn *)(& resetfn___0);
#line 316
    result->hdr.scanfn = (arg_scanfn *)(& scanfn___0);
#line 317
    result->hdr.checkfn = (arg_checkfn *)(& checkfn___0);
#line 318
    result->hdr.errorfn = (arg_errorfn *)(& errorfn___0);
#line 321
    result->ival = (int *)(result + 1);
#line 322
    result->count = 0;
  }
#line 325
  return (result);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_end *arg_end(int maxcount ) ;
#line 286
void arg_print_errors(FILE *fp , struct arg_end *end , char const   *progname ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_end.c"
static void resetfn___1(struct arg_end *parent ) 
{ 


  {
#line 36
  parent->count = 0;
#line 37
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_end.c"
static void errorfn___1(void *parent , FILE *fp , int error , char const   *argval ,
                        char const   *progname ) 
{ 


  {
#line 41
  if (progname) {
#line 41
    progname = progname;
  } else {
#line 41
    progname = "";
  }
#line 42
  if (argval) {
#line 42
    argval = argval;
  } else {
#line 42
    argval = "";
  }
  {
#line 44
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s: ", progname);
  }
  {
#line 47
  if (error == 1) {
#line 47
    goto case_1;
  }
#line 50
  if (error == 2) {
#line 50
    goto case_2;
  }
#line 53
  if (error == 3) {
#line 53
    goto case_3;
  }
#line 56
  if (error == 5) {
#line 56
    goto case_5;
  }
#line 59
  if (error == 4) {
#line 59
    goto case_4;
  }
#line 62
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 48
  fputs((char const   */* __restrict  */)"too many errors to display", (FILE */* __restrict  */)fp);
  }
#line 49
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 51
  fputs((char const   */* __restrict  */)"insufficent memory", (FILE */* __restrict  */)fp);
  }
#line 52
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 54
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"unexpected argument \"%s\"",
          argval);
  }
#line 55
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 57
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"option \"%s\" requires an argument",
          argval);
  }
#line 58
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 60
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"invalid option \"%s\"",
          argval);
  }
#line 61
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 63
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"invalid option \"-%c\"",
          error);
  }
#line 64
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 66
  fputc('\n', fp);
  }
#line 67
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_end.c"
struct arg_end *arg_end(int maxcount ) 
{ 
  size_t nbytes ;
  struct arg_end *result ;
  void *tmp ;

  {
  {
#line 75
  nbytes = ((sizeof(struct arg_end ) + (unsigned long )maxcount * sizeof(int )) + (unsigned long )maxcount * sizeof(void *)) + (unsigned long )maxcount * sizeof(char *);
#line 80
  tmp = malloc(nbytes);
#line 80
  result = (struct arg_end *)tmp;
  }
#line 81
  if (result) {
#line 84
    result->hdr.flag = (char)1;
#line 85
    result->hdr.shortopts = (char const   *)((void *)0);
#line 86
    result->hdr.longopts = (char const   *)((void *)0);
#line 87
    result->hdr.datatype = (char const   *)((void *)0);
#line 88
    result->hdr.glossary = (char const   *)((void *)0);
#line 89
    result->hdr.mincount = 1;
#line 90
    result->hdr.maxcount = maxcount;
#line 91
    result->hdr.parent = (void *)result;
#line 92
    result->hdr.resetfn = (arg_resetfn *)(& resetfn___1);
#line 93
    result->hdr.scanfn = (arg_scanfn *)((void *)0);
#line 94
    result->hdr.checkfn = (arg_checkfn *)((void *)0);
#line 95
    result->hdr.errorfn = & errorfn___1;
#line 98
    result->error = (int *)(result + 1);
#line 101
    result->parent = (void **)(result->error + maxcount);
#line 104
    result->argval = (char const   **)(result->parent + maxcount);
  }
#line 108
  return (result);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_end.c"
void arg_print_errors(FILE *fp , struct arg_end *end , char const   *progname ) 
{ 
  int i ;
  struct arg_hdr *errorparent ;

  {
#line 116
  i = 0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < end->count)) {
#line 116
      goto while_break;
    }
#line 118
    errorparent = (struct arg_hdr *)*(end->parent + i);
#line 119
    if (errorparent->errorfn) {
      {
#line 120
      (*(errorparent->errorfn))(*(end->parent + i), fp, *(end->error + i), *(end->argval + i),
                                progname);
      }
    }
#line 116
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 242 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_file *arg_file0(char const   *shortopts , char const   *longopts , char const   *datatype ,
                           char const   *glossary ) ;
#line 246
struct arg_file *arg_file1(char const   *shortopts , char const   *longopts , char const   *datatype ,
                           char const   *glossary ) ;
#line 250
struct arg_file *arg_filen(char const   *shortopts , char const   *longopts , char const   *datatype ,
                           int mincount , int maxcount , char const   *glossary ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_file.c"
static void resetfn___2(struct arg_file *parent ) 
{ 


  {
#line 50
  parent->count = 0;
#line 51
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_file.c"
static char const   *arg_basename(char const   *filename ) 
{ 
  char const   *result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 57
  if (filename) {
    {
#line 57
    tmp = strrchr(filename, '/');
#line 57
    tmp___0 = tmp;
    }
  } else {
#line 57
    tmp___0 = (char *)((void *)0);
  }
#line 57
  result = (char const   *)tmp___0;
#line 58
  if (result) {
#line 59
    result ++;
  } else {
#line 61
    result = filename;
  }
#line 62
  return (result);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_file.c"
static char const   *arg_extension(char const   *filename ) 
{ 
  char const   *result ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 69
  if (filename) {
    {
#line 69
    tmp = strrchr(filename, '.');
#line 69
    tmp___0 = tmp;
    }
  } else {
#line 69
    tmp___0 = (char *)((void *)0);
  }
#line 69
  result = (char const   *)tmp___0;
#line 70
  if (filename) {
#line 70
    if (! result) {
      {
#line 71
      tmp___1 = strlen(filename);
#line 71
      result = filename + tmp___1;
      }
    }
  }
#line 72
  return (result);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_file.c"
static int scanfn___1(struct arg_file *parent , char const   *argval ) 
{ 
  int errorcode ;

  {
#line 78
  errorcode = 0;
#line 80
  if (parent->count == parent->hdr.maxcount) {
#line 83
    errorcode = 2;
  } else
#line 85
  if (! argval) {
#line 90
    (parent->count) ++;
  } else {
    {
#line 94
    *(parent->filename + parent->count) = argval;
#line 95
    *(parent->basename + parent->count) = arg_basename(argval);
#line 96
    *(parent->extension + parent->count) = arg_extension(argval);
#line 97
    (parent->count) ++;
    }
  }
#line 101
  return (errorcode);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_file.c"
static int checkfn___1(struct arg_file *parent ) 
{ 
  int errorcode ;
  int tmp ;

  {
#line 107
  if (parent->count < parent->hdr.mincount) {
#line 107
    tmp = 1;
  } else {
#line 107
    tmp = 0;
  }
#line 107
  errorcode = tmp;
#line 109
  return (errorcode);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_file.c"
static void errorfn___2(struct arg_file *parent , FILE *fp , int errorcode , char const   *argval ,
                        char const   *progname ) 
{ 
  char const   *shortopts ;
  char const   *longopts ;
  char const   *datatype ;

  {
#line 115
  shortopts = parent->hdr.shortopts;
#line 116
  longopts = parent->hdr.longopts;
#line 117
  datatype = parent->hdr.datatype;
#line 120
  if (argval) {
#line 120
    argval = argval;
  } else {
#line 120
    argval = "";
  }
  {
#line 122
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s: ", progname);
  }
  {
#line 125
  if (errorcode == 1) {
#line 125
    goto case_1;
  }
#line 130
  if (errorcode == 2) {
#line 130
    goto case_2;
  }
#line 135
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 126
  fputs((char const   */* __restrict  */)"missing option ", (FILE */* __restrict  */)fp);
#line 127
  arg_print_option(fp, shortopts, longopts, datatype, "\n");
  }
#line 128
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 131
  fputs((char const   */* __restrict  */)"excess option ", (FILE */* __restrict  */)fp);
#line 132
  arg_print_option(fp, shortopts, longopts, argval, "\n");
  }
#line 133
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 136
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"unknown error at \"%s\"\n",
          argval);
  }
  switch_break: /* CIL Label */ ;
  }
#line 138
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_file.c"
struct arg_file *arg_file0(char const   *shortopts , char const   *longopts , char const   *datatype ,
                           char const   *glossary ) 
{ 
  struct arg_file *tmp ;

  {
  {
#line 146
  tmp = arg_filen(shortopts, longopts, datatype, 0, 1, glossary);
  }
#line 146
  return (tmp);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_file.c"
struct arg_file *arg_file1(char const   *shortopts , char const   *longopts , char const   *datatype ,
                           char const   *glossary ) 
{ 
  struct arg_file *tmp ;

  {
  {
#line 155
  tmp = arg_filen(shortopts, longopts, datatype, 1, 1, glossary);
  }
#line 155
  return (tmp);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_file.c"
struct arg_file *arg_filen(char const   *shortopts , char const   *longopts , char const   *datatype ,
                           int mincount , int maxcount , char const   *glossary ) 
{ 
  size_t nbytes ;
  struct arg_file *result ;
  void *tmp ;
  int i ;

  {
#line 170
  if (maxcount < mincount) {
#line 170
    maxcount = mincount;
  } else {
#line 170
    maxcount = maxcount;
  }
  {
#line 172
  nbytes = ((sizeof(struct arg_file ) + sizeof(char *) * (unsigned long )maxcount) + sizeof(char *) * (unsigned long )maxcount) + sizeof(char *) * (unsigned long )maxcount;
#line 177
  tmp = malloc(nbytes);
#line 177
  result = (struct arg_file *)tmp;
  }
#line 178
  if (result) {
#line 183
    result->hdr.flag = (char)2;
#line 184
    result->hdr.shortopts = shortopts;
#line 185
    result->hdr.longopts = longopts;
#line 186
    result->hdr.glossary = glossary;
#line 187
    if (datatype) {
#line 187
      result->hdr.datatype = datatype;
    } else {
#line 187
      result->hdr.datatype = "<file>";
    }
#line 188
    result->hdr.mincount = mincount;
#line 189
    result->hdr.maxcount = maxcount;
#line 190
    result->hdr.parent = (void *)result;
#line 191
    result->hdr.resetfn = (arg_resetfn *)(& resetfn___2);
#line 192
    result->hdr.scanfn = (arg_scanfn *)(& scanfn___1);
#line 193
    result->hdr.checkfn = (arg_checkfn *)(& checkfn___1);
#line 194
    result->hdr.errorfn = (arg_errorfn *)(& errorfn___2);
#line 197
    result->filename = (char const   **)(result + 1);
#line 198
    result->basename = result->filename + maxcount;
#line 199
    result->extension = result->basename + maxcount;
#line 200
    result->count = 0;
#line 203
    i = 0;
    {
#line 203
    while (1) {
      while_continue: /* CIL Label */ ;
#line 203
      if (! (i < maxcount)) {
#line 203
        goto while_break;
      }
#line 205
      *(result->filename + i) = "";
#line 206
      *(result->basename + i) = "";
#line 207
      *(result->extension + i) = "";
#line 203
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 211
  return (result);
}
}
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 191 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_dbl *arg_dbl0(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         char const   *glossary ) ;
#line 195
struct arg_dbl *arg_dbl1(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         char const   *glossary ) ;
#line 199
struct arg_dbl *arg_dbln(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         int mincount , int maxcount , char const   *glossary ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_dbl.c"
static void resetfn___3(struct arg_dbl *parent ) 
{ 


  {
#line 39
  parent->count = 0;
#line 40
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_dbl.c"
static int scanfn___2(struct arg_dbl *parent , char const   *argval ) 
{ 
  int errorcode ;
  double val ;
  char *end ;
  int tmp ;

  {
#line 44
  errorcode = 0;
#line 46
  if (parent->count == parent->hdr.maxcount) {
#line 49
    errorcode = 2;
  } else
#line 51
  if (! argval) {
#line 56
    (parent->count) ++;
  } else {
    {
#line 64
    val = strtod((char const   */* __restrict  */)argval, (char **/* __restrict  */)(& end));
    }
#line 67
    if ((int )*end == 0) {
#line 68
      tmp = parent->count;
#line 68
      (parent->count) ++;
#line 68
      *(parent->dval + tmp) = val;
    } else {
#line 70
      errorcode = 3;
    }
  }
#line 74
  return (errorcode);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_dbl.c"
static int checkfn___2(struct arg_dbl *parent ) 
{ 
  int errorcode ;
  int tmp ;

  {
#line 79
  if (parent->count < parent->hdr.mincount) {
#line 79
    tmp = 1;
  } else {
#line 79
    tmp = 0;
  }
#line 79
  errorcode = tmp;
#line 81
  return (errorcode);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_dbl.c"
static void errorfn___3(struct arg_dbl *parent , FILE *fp , int errorcode , char const   *argval ,
                        char const   *progname ) 
{ 
  char const   *shortopts ;
  char const   *longopts ;
  char const   *datatype ;

  {
#line 86
  shortopts = parent->hdr.shortopts;
#line 87
  longopts = parent->hdr.longopts;
#line 88
  datatype = parent->hdr.datatype;
#line 91
  if (argval) {
#line 91
    argval = argval;
  } else {
#line 91
    argval = "";
  }
  {
#line 93
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s: ", progname);
  }
  {
#line 96
  if (errorcode == 1) {
#line 96
    goto case_1;
  }
#line 101
  if (errorcode == 2) {
#line 101
    goto case_2;
  }
#line 106
  if (errorcode == 3) {
#line 106
    goto case_3;
  }
#line 94
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 97
  fputs((char const   */* __restrict  */)"missing option ", (FILE */* __restrict  */)fp);
#line 98
  arg_print_option(fp, shortopts, longopts, datatype, "\n");
  }
#line 99
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 102
  fputs((char const   */* __restrict  */)"excess option ", (FILE */* __restrict  */)fp);
#line 103
  arg_print_option(fp, shortopts, longopts, argval, "\n");
  }
#line 104
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 107
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"invalid argument \"%s\" to option ",
          argval);
#line 108
  arg_print_option(fp, shortopts, longopts, datatype, "\n");
  }
#line 109
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_dbl.c"
struct arg_dbl *arg_dbl0(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         char const   *glossary ) 
{ 
  struct arg_dbl *tmp ;

  {
  {
#line 119
  tmp = arg_dbln(shortopts, longopts, datatype, 0, 1, glossary);
  }
#line 119
  return (tmp);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_dbl.c"
struct arg_dbl *arg_dbl1(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         char const   *glossary ) 
{ 
  struct arg_dbl *tmp ;

  {
  {
#line 127
  tmp = arg_dbln(shortopts, longopts, datatype, 1, 1, glossary);
  }
#line 127
  return (tmp);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_dbl.c"
struct arg_dbl *arg_dbln(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         int mincount , int maxcount , char const   *glossary ) 
{ 
  size_t nbytes ;
  struct arg_dbl *result ;
  void *tmp ;
  size_t addr ;
  size_t rem ;

  {
#line 142
  if (maxcount < mincount) {
#line 142
    maxcount = mincount;
  } else {
#line 142
    maxcount = maxcount;
  }
  {
#line 144
  nbytes = sizeof(struct arg_dbl ) + (unsigned long )(maxcount + 1) * sizeof(double );
#line 147
  tmp = malloc(nbytes);
#line 147
  result = (struct arg_dbl *)tmp;
  }
#line 148
  if (result) {
#line 154
    result->hdr.flag = (char)2;
#line 155
    result->hdr.shortopts = shortopts;
#line 156
    result->hdr.longopts = longopts;
#line 157
    if (datatype) {
#line 157
      result->hdr.datatype = datatype;
    } else {
#line 157
      result->hdr.datatype = "<double>";
    }
#line 158
    result->hdr.glossary = glossary;
#line 159
    result->hdr.mincount = mincount;
#line 160
    result->hdr.maxcount = maxcount;
#line 161
    result->hdr.parent = (void *)result;
#line 162
    result->hdr.resetfn = (arg_resetfn *)(& resetfn___3);
#line 163
    result->hdr.scanfn = (arg_scanfn *)(& scanfn___2);
#line 164
    result->hdr.checkfn = (arg_checkfn *)(& checkfn___2);
#line 165
    result->hdr.errorfn = (arg_errorfn *)(& errorfn___3);
#line 170
    addr = (size_t )(result + 1);
#line 171
    rem = addr % sizeof(double );
#line 172
    result->dval = (double *)((addr + sizeof(double )) - rem);
#line 175
    result->count = 0;
  }
#line 178
  return (result);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 221 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_rex *arg_rex0(char const   *shortopts , char const   *longopts , char const   *pattern ,
                         char const   *datatype , int flags , char const   *glossary ) ;
#line 227
struct arg_rex *arg_rex1(char const   *shortopts , char const   *longopts , char const   *pattern ,
                         char const   *datatype , int flags , char const   *glossary ) ;
#line 233
struct arg_rex *arg_rexn(char const   *shortopts , char const   *longopts , char const   *pattern ,
                         char const   *datatype , int mincount , int maxcount , int flags ,
                         char const   *glossary ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_rex.c"
static void resetfn___4(struct arg_rex *parent ) 
{ 
  struct privhdr *priv ;

  {
  {
#line 49
  priv = (struct privhdr *)parent->hdr.priv;
#line 52
  parent->count = 0;
#line 56
  regcomp((regex_t */* __restrict  */)(& priv->regex), (char const   */* __restrict  */)priv->pattern,
          priv->flags);
  }
#line 57
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_rex.c"
static int scanfn___3(struct arg_rex *parent , char const   *argval ) 
{ 
  int errorcode ;
  struct privhdr *priv ;
  int tmp ;

  {
#line 61
  errorcode = 0;
#line 63
  if (parent->count == parent->hdr.maxcount) {
#line 66
    errorcode = 201;
  } else
#line 68
  if (! argval) {
#line 73
    (parent->count) ++;
  } else {
    {
#line 77
    priv = (struct privhdr *)parent->hdr.priv;
#line 81
    errorcode = regexec((regex_t const   */* __restrict  */)(& priv->regex), (char const   */* __restrict  */)argval,
                        (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 82
    if (errorcode == 0) {
#line 83
      tmp = parent->count;
#line 83
      (parent->count) ++;
#line 83
      *(parent->sval + tmp) = argval;
    }
  }
#line 87
  return (errorcode);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_rex.c"
static int checkfn___3(struct arg_rex *parent ) 
{ 
  int errorcode ;
  int tmp ;
  struct privhdr *priv ;

  {
#line 92
  if (parent->count < parent->hdr.mincount) {
#line 92
    tmp = 200;
  } else {
#line 92
    tmp = 0;
  }
  {
#line 92
  errorcode = tmp;
#line 93
  priv = (struct privhdr *)parent->hdr.priv;
#line 96
  regfree(& priv->regex);
  }
#line 99
  return (errorcode);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_rex.c"
static void errorfn___4(struct arg_rex *parent , FILE *fp , int errorcode , char const   *argval ,
                        char const   *progname ) 
{ 
  char const   *shortopts ;
  char const   *longopts ;
  char const   *datatype ;
  char errbuff[256] ;

  {
#line 104
  shortopts = parent->hdr.shortopts;
#line 105
  longopts = parent->hdr.longopts;
#line 106
  datatype = parent->hdr.datatype;
#line 109
  if (argval) {
#line 109
    argval = argval;
  } else {
#line 109
    argval = "";
  }
  {
#line 111
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s: ", progname);
  }
  {
#line 114
  if (errorcode == 200) {
#line 114
    goto case_200;
  }
#line 119
  if (errorcode == 201) {
#line 119
    goto case_201;
  }
#line 124
  if (errorcode == 1) {
#line 124
    goto case_1;
  }
#line 129
  goto switch_default;
  case_200: /* CIL Label */ 
  {
#line 115
  fputs((char const   */* __restrict  */)"missing option ", (FILE */* __restrict  */)fp);
#line 116
  arg_print_option(fp, shortopts, longopts, datatype, "\n");
  }
#line 117
  goto switch_break;
  case_201: /* CIL Label */ 
  {
#line 120
  fputs((char const   */* __restrict  */)"excess option ", (FILE */* __restrict  */)fp);
#line 121
  arg_print_option(fp, shortopts, longopts, argval, "\n");
  }
#line 122
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 125
  fputs((char const   */* __restrict  */)"illegal value  ", (FILE */* __restrict  */)fp);
#line 126
  arg_print_option(fp, shortopts, longopts, argval, "\n");
  }
#line 127
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 132
  regerror(errorcode, (regex_t const   */* __restrict  */)((void *)0), (char */* __restrict  */)(errbuff),
           sizeof(errbuff));
#line 133
  printf((char const   */* __restrict  */)"%s\n", errbuff);
  }
#line 135
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 137
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_rex.c"
struct arg_rex *arg_rex0(char const   *shortopts , char const   *longopts , char const   *pattern ,
                         char const   *datatype , int flags , char const   *glossary ) 
{ 
  struct arg_rex *tmp ;

  {
  {
#line 147
  tmp = arg_rexn(shortopts, longopts, pattern, datatype, 0, 1, flags, glossary);
  }
#line 147
  return (tmp);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_rex.c"
struct arg_rex *arg_rex1(char const   *shortopts , char const   *longopts , char const   *pattern ,
                         char const   *datatype , int flags , char const   *glossary ) 
{ 
  struct arg_rex *tmp ;

  {
  {
#line 157
  tmp = arg_rexn(shortopts, longopts, pattern, datatype, 1, 1, flags, glossary);
  }
#line 157
  return (tmp);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_rex.c"
struct arg_rex *arg_rexn(char const   *shortopts , char const   *longopts , char const   *pattern ,
                         char const   *datatype , int mincount , int maxcount , int flags ,
                         char const   *glossary ) 
{ 
  size_t nbytes ;
  struct arg_rex *result ;
  struct privhdr *priv ;
  void *tmp ;
  int errorcode ;
  int i ;
  char errbuff[256] ;

  {
#line 174
  if (! pattern) {
    {
#line 176
    printf((char const   */* __restrict  */)"argtable: ERROR - illegal regular expression pattern \"(NULL)\"\n");
#line 177
    printf((char const   */* __restrict  */)"argtable: Bad argument table.\n");
    }
#line 178
    return ((struct arg_rex *)((void *)0));
  }
#line 182
  if (maxcount < mincount) {
#line 182
    maxcount = mincount;
  } else {
#line 182
    maxcount = maxcount;
  }
  {
#line 184
  nbytes = (sizeof(struct arg_rex ) + sizeof(struct privhdr )) + (unsigned long )maxcount * sizeof(char *);
#line 188
  tmp = malloc(nbytes);
#line 188
  result = (struct arg_rex *)tmp;
  }
#line 189
  if (result) {
#line 194
    result->hdr.flag = (char)2;
#line 195
    result->hdr.shortopts = shortopts;
#line 196
    result->hdr.longopts = longopts;
#line 197
    if (datatype) {
#line 197
      result->hdr.datatype = datatype;
    } else {
#line 197
      result->hdr.datatype = pattern;
    }
#line 198
    result->hdr.glossary = glossary;
#line 199
    result->hdr.mincount = mincount;
#line 200
    result->hdr.maxcount = maxcount;
#line 201
    result->hdr.parent = (void *)result;
#line 202
    result->hdr.resetfn = (arg_resetfn *)(& resetfn___4);
#line 203
    result->hdr.scanfn = (arg_scanfn *)(& scanfn___3);
#line 204
    result->hdr.checkfn = (arg_checkfn *)(& checkfn___3);
#line 205
    result->hdr.errorfn = (arg_errorfn *)(& errorfn___4);
#line 208
    result->hdr.priv = (void *)((char const   **)(result + 1));
#line 209
    priv = (struct privhdr *)result->hdr.priv;
#line 210
    priv->pattern = pattern;
#line 211
    priv->flags = flags | (((1 << 1) << 1) << 1);
#line 214
    result->sval = (char const   **)(priv + 1);
#line 215
    result->count = 0;
#line 218
    i = 0;
    {
#line 218
    while (1) {
      while_continue: /* CIL Label */ ;
#line 218
      if (! (i < maxcount)) {
#line 218
        goto while_break;
      }
#line 219
      *(result->sval + i) = "";
#line 218
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 225
    errorcode = regcomp((regex_t */* __restrict  */)(& priv->regex), (char const   */* __restrict  */)priv->pattern,
                        priv->flags);
    }
#line 226
    if (errorcode) {
      {
#line 229
      regerror(errorcode, (regex_t const   */* __restrict  */)(& priv->regex), (char */* __restrict  */)(errbuff),
               sizeof(errbuff));
#line 230
      printf((char const   */* __restrict  */)"argtable: %s \"%s\"\n", errbuff, priv->pattern);
#line 231
      printf((char const   */* __restrict  */)"argtable: Bad argument table.\n");
      }
    } else {
      {
#line 234
      regfree(& priv->regex);
      }
    }
  }
#line 238
  return (result);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_str *arg_str0(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         char const   *glossary ) ;
#line 210
struct arg_str *arg_str1(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         char const   *glossary ) ;
#line 214
struct arg_str *arg_strn(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         int mincount , int maxcount , char const   *glossary ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_str.c"
static void resetfn___5(struct arg_str *parent ) 
{ 


  {
#line 39
  parent->count = 0;
#line 40
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_str.c"
static int scanfn___4(struct arg_str *parent , char const   *argval ) 
{ 
  int errorcode ;
  int tmp ;

  {
#line 44
  errorcode = 0;
#line 46
  if (parent->count == parent->hdr.maxcount) {
#line 49
    errorcode = 2;
  } else
#line 51
  if (! argval) {
#line 56
    (parent->count) ++;
  } else {
#line 60
    tmp = parent->count;
#line 60
    (parent->count) ++;
#line 60
    *(parent->sval + tmp) = argval;
  }
#line 64
  return (errorcode);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_str.c"
static int checkfn___4(struct arg_str *parent ) 
{ 
  int errorcode ;
  int tmp ;

  {
#line 69
  if (parent->count < parent->hdr.mincount) {
#line 69
    tmp = 1;
  } else {
#line 69
    tmp = 0;
  }
#line 69
  errorcode = tmp;
#line 71
  return (errorcode);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_str.c"
static void errorfn___5(struct arg_str *parent , FILE *fp , int errorcode , char const   *argval ,
                        char const   *progname ) 
{ 
  char const   *shortopts ;
  char const   *longopts ;
  char const   *datatype ;

  {
#line 76
  shortopts = parent->hdr.shortopts;
#line 77
  longopts = parent->hdr.longopts;
#line 78
  datatype = parent->hdr.datatype;
#line 81
  if (argval) {
#line 81
    argval = argval;
  } else {
#line 81
    argval = "";
  }
  {
#line 83
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s: ", progname);
  }
  {
#line 86
  if (errorcode == 1) {
#line 86
    goto case_1;
  }
#line 91
  if (errorcode == 2) {
#line 91
    goto case_2;
  }
#line 84
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 87
  fputs((char const   */* __restrict  */)"missing option ", (FILE */* __restrict  */)fp);
#line 88
  arg_print_option(fp, shortopts, longopts, datatype, "\n");
  }
#line 89
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 92
  fputs((char const   */* __restrict  */)"excess option ", (FILE */* __restrict  */)fp);
#line 93
  arg_print_option(fp, shortopts, longopts, argval, "\n");
  }
#line 94
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 96
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_str.c"
struct arg_str *arg_str0(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         char const   *glossary ) 
{ 
  struct arg_str *tmp ;

  {
  {
#line 104
  tmp = arg_strn(shortopts, longopts, datatype, 0, 1, glossary);
  }
#line 104
  return (tmp);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_str.c"
struct arg_str *arg_str1(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         char const   *glossary ) 
{ 
  struct arg_str *tmp ;

  {
  {
#line 112
  tmp = arg_strn(shortopts, longopts, datatype, 1, 1, glossary);
  }
#line 112
  return (tmp);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_str.c"
struct arg_str *arg_strn(char const   *shortopts , char const   *longopts , char const   *datatype ,
                         int mincount , int maxcount , char const   *glossary ) 
{ 
  size_t nbytes ;
  struct arg_str *result ;
  void *tmp ;
  int i ;

  {
#line 127
  if (maxcount < mincount) {
#line 127
    maxcount = mincount;
  } else {
#line 127
    maxcount = maxcount;
  }
  {
#line 129
  nbytes = sizeof(struct arg_str ) + (unsigned long )maxcount * sizeof(char *);
#line 132
  tmp = malloc(nbytes);
#line 132
  result = (struct arg_str *)tmp;
  }
#line 133
  if (result) {
#line 138
    result->hdr.flag = (char)2;
#line 139
    result->hdr.shortopts = shortopts;
#line 140
    result->hdr.longopts = longopts;
#line 141
    if (datatype) {
#line 141
      result->hdr.datatype = datatype;
    } else {
#line 141
      result->hdr.datatype = "<string>";
    }
#line 142
    result->hdr.glossary = glossary;
#line 143
    result->hdr.mincount = mincount;
#line 144
    result->hdr.maxcount = maxcount;
#line 145
    result->hdr.parent = (void *)result;
#line 146
    result->hdr.resetfn = (arg_resetfn *)(& resetfn___5);
#line 147
    result->hdr.scanfn = (arg_scanfn *)(& scanfn___4);
#line 148
    result->hdr.checkfn = (arg_checkfn *)(& checkfn___4);
#line 149
    result->hdr.errorfn = (arg_errorfn *)(& errorfn___5);
#line 152
    result->sval = (char const   **)(result + 1);
#line 153
    result->count = 0;
#line 156
    i = 0;
    {
#line 156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 156
      if (! (i < maxcount)) {
#line 156
        goto while_break;
      }
#line 157
      *(result->sval + i) = "";
#line 156
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 160
  return (result);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 50 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) bzero)(void *__s ,
                                                                             size_t __n ) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 213
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strptime)(char const   * __restrict  __s ,
                                                                                 char const   * __restrict  __fmt ,
                                                                                 struct tm *__tp ) ;
#line 257 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_date *arg_date0(char const   *shortopts , char const   *longopts , char const   *format ,
                           char const   *datatype , char const   *glossary ) ;
#line 262
struct arg_date *arg_date1(char const   *shortopts , char const   *longopts , char const   *format ,
                           char const   *datatype , char const   *glossary ) ;
#line 267
struct arg_date *arg_daten(char const   *shortopts , char const   *longopts , char const   *format ,
                           char const   *datatype , int mincount , int maxcount ,
                           char const   *glossary ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_date.c"
static void resetfn___6(struct arg_date *parent ) 
{ 


  {
#line 48
  parent->count = 0;
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_date.c"
static int scanfn___5(struct arg_date *parent , char const   *argval ) 
{ 
  int errorcode ;
  char const   *pend ;
  struct tm tm ;
  char *tmp ;
  int tmp___0 ;

  {
#line 53
  errorcode = 0;
#line 55
  if (parent->count == parent->hdr.maxcount) {
#line 56
    errorcode = 2;
  } else
#line 57
  if (! argval) {
#line 60
    (parent->count) ++;
  } else {
    {
#line 65
    tm = *(parent->tmval + parent->count);
#line 68
    tmp = strptime((char const   */* __restrict  */)argval, (char const   */* __restrict  */)parent->format,
                   & tm);
#line 68
    pend = (char const   *)tmp;
    }
#line 69
    if (pend) {
#line 69
      if ((int const   )*(pend + 0) == 0) {
#line 70
        tmp___0 = parent->count;
#line 70
        (parent->count) ++;
#line 70
        *(parent->tmval + tmp___0) = tm;
      } else {
#line 72
        errorcode = 3;
      }
    } else {
#line 72
      errorcode = 3;
    }
  }
#line 76
  return (errorcode);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_date.c"
static int checkfn___5(struct arg_date *parent ) 
{ 
  int errorcode ;
  int tmp ;

  {
#line 81
  if (parent->count < parent->hdr.mincount) {
#line 81
    tmp = 1;
  } else {
#line 81
    tmp = 0;
  }
#line 81
  errorcode = tmp;
#line 84
  return (errorcode);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_date.c"
static void errorfn___6(struct arg_date *parent , FILE *fp , int errorcode , char const   *argval ,
                        char const   *progname ) 
{ 
  char const   *shortopts ;
  char const   *longopts ;
  char const   *datatype ;
  struct tm tm ;
  char buff[200] ;

  {
#line 89
  shortopts = parent->hdr.shortopts;
#line 90
  longopts = parent->hdr.longopts;
#line 91
  datatype = parent->hdr.datatype;
#line 94
  if (argval) {
#line 94
    argval = argval;
  } else {
#line 94
    argval = "";
  }
  {
#line 96
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s: ", progname);
  }
  {
#line 99
  if (errorcode == 1) {
#line 99
    goto case_1;
  }
#line 104
  if (errorcode == 2) {
#line 104
    goto case_2;
  }
#line 109
  if (errorcode == 3) {
#line 109
    goto case_3;
  }
#line 97
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 100
  fputs((char const   */* __restrict  */)"missing option ", (FILE */* __restrict  */)fp);
#line 101
  arg_print_option(fp, shortopts, longopts, datatype, "\n");
  }
#line 102
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 105
  fputs((char const   */* __restrict  */)"excess option ", (FILE */* __restrict  */)fp);
#line 106
  arg_print_option(fp, shortopts, longopts, argval, "\n");
  }
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 114
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"illegal timestamp format \"%s\"\n",
          argval);
#line 115
  bzero((void *)(& tm), sizeof(tm));
#line 116
  strptime((char const   */* __restrict  */)"1999-12-31 23:59:59", (char const   */* __restrict  */)"%F %H:%M:%S",
           & tm);
#line 117
  strftime((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)parent->format,
           (struct tm  const  */* __restrict  */)(& tm));
#line 118
  printf((char const   */* __restrict  */)"correct format is \"%s\"\n", buff);
  }
#line 119
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_date.c"
struct arg_date *arg_date0(char const   *shortopts , char const   *longopts , char const   *format ,
                           char const   *datatype , char const   *glossary ) 
{ 
  struct arg_date *tmp ;

  {
  {
#line 131
  tmp = arg_daten(shortopts, longopts, format, datatype, 0, 1, glossary);
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_date.c"
struct arg_date *arg_date1(char const   *shortopts , char const   *longopts , char const   *format ,
                           char const   *datatype , char const   *glossary ) 
{ 
  struct arg_date *tmp ;

  {
  {
#line 140
  tmp = arg_daten(shortopts, longopts, format, datatype, 1, 1, glossary);
  }
#line 140
  return (tmp);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_date.c"
struct arg_date *arg_daten(char const   *shortopts , char const   *longopts , char const   *format ,
                           char const   *datatype , int mincount , int maxcount ,
                           char const   *glossary ) 
{ 
  size_t nbytes ;
  struct arg_date *result ;
  void *tmp ;

  {
#line 156
  if (maxcount < mincount) {
#line 156
    maxcount = mincount;
  } else {
#line 156
    maxcount = maxcount;
  }
#line 159
  if (! format) {
#line 160
    format = "%x";
  }
  {
#line 162
  nbytes = sizeof(struct arg_date ) + (unsigned long )maxcount * sizeof(struct tm );
#line 167
  tmp = calloc((size_t )1, nbytes);
#line 167
  result = (struct arg_date *)tmp;
  }
#line 168
  if (result) {
#line 171
    result->hdr.flag = (char)2;
#line 172
    result->hdr.shortopts = shortopts;
#line 173
    result->hdr.longopts = longopts;
#line 174
    if (datatype) {
#line 174
      result->hdr.datatype = datatype;
    } else {
#line 174
      result->hdr.datatype = format;
    }
#line 175
    result->hdr.glossary = glossary;
#line 176
    result->hdr.mincount = mincount;
#line 177
    result->hdr.maxcount = maxcount;
#line 178
    result->hdr.parent = (void *)result;
#line 179
    result->hdr.resetfn = (arg_resetfn *)(& resetfn___6);
#line 180
    result->hdr.scanfn = (arg_scanfn *)(& scanfn___5);
#line 181
    result->hdr.checkfn = (arg_checkfn *)(& checkfn___5);
#line 182
    result->hdr.errorfn = (arg_errorfn *)(& errorfn___6);
#line 185
    result->tmval = (struct tm *)(result + 1);
#line 188
    result->count = 0;
#line 189
    result->format = format;
  }
#line 193
  return (result);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/argtable2.h"
struct arg_rem *arg_rem(char const   *datatype , char const   *glossary ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/argtable2-12/src/arg_rem.c"
struct arg_rem *arg_rem(char const   *datatype , char const   *glossary ) 
{ 
  struct arg_rem *result ;
  void *tmp ;

  {
  {
#line 36
  tmp = malloc(sizeof(struct arg_rem ));
#line 36
  result = (struct arg_rem *)tmp;
  }
#line 37
  if (result) {
#line 40
    result->hdr.flag = (char)0;
#line 41
    result->hdr.shortopts = (char const   *)((void *)0);
#line 42
    result->hdr.longopts = (char const   *)((void *)0);
#line 43
    result->hdr.datatype = datatype;
#line 44
    result->hdr.glossary = glossary;
#line 45
    result->hdr.mincount = 1;
#line 46
    result->hdr.maxcount = 1;
#line 47
    result->hdr.parent = (void *)result;
#line 48
    result->hdr.resetfn = (arg_resetfn *)((void *)0);
#line 49
    result->hdr.scanfn = (arg_scanfn *)((void *)0);
#line 50
    result->hdr.checkfn = (arg_checkfn *)((void *)0);
#line 51
    result->hdr.errorfn = (arg_errorfn *)((void *)0);
  }
#line 54
  return (result);
}
}
