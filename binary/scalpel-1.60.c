/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 248 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.h"
struct SearchSpecOffsets {
   unsigned long long *headers ;
   unsigned long long headerstorage ;
   unsigned long long numheaders ;
   unsigned long long *footers ;
   unsigned long long footerstorage ;
   unsigned long long numfooters ;
};
#line 266 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.h"
struct SearchSpecLine {
   char *suffix ;
   int casesensitive ;
   unsigned long long length ;
   char *begin ;
   int beginlength ;
   size_t begin_bm_table[256] ;
   char *end ;
   int endlength ;
   size_t end_bm_table[256] ;
   int searchtype ;
   struct SearchSpecOffsets offsets ;
   unsigned long long numfilestocarve ;
   unsigned long organizeDirNum ;
};
#line 284 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.h"
struct scalpelState {
   char *imagefile ;
   char *conffile ;
   char *outputdirectory ;
   int specLines ;
   struct SearchSpecLine *SearchSpec ;
   unsigned long long fileswritten ;
   int modeVerbose ;
   int modeNoSuffix ;
   FILE *auditFile ;
   char *invocation ;
   unsigned long long skip ;
   char *coveragedirectory ;
   unsigned int coverageblocksize ;
   FILE *coverageblockmap ;
   unsigned char *coveragebitmap ;
   unsigned long long coveragenumblocks ;
   int useInputFileList ;
   char *inputFileList ;
   int carveWithMissingFooters ;
   int noSearchOverlap ;
   int ignoreEmbedded ;
   int generateHeaderFooterDatabase ;
   int updateCoverageBlockmap ;
   int useCoverageBlockmap ;
   int organizeSubdirectories ;
   unsigned long long organizeMaxFilesPerSub ;
   int blockAlignedOnly ;
   unsigned int alignedblocksize ;
   int previewMode ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_15 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_15 pthread_mutex_t;
#line 32 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.h"
struct _Queue_element {
   void *info ;
   int priority ;
   struct _Queue_element *next ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.h"
typedef struct _Queue_element *Queue_element;
#line 40 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.h"
struct Queue {
   Queue_element queue ;
   Queue_element current ;
   Queue_element previous ;
   int queuelength ;
   int elementsize ;
   int duplicates ;
   int (*compare)(void *e1 , void *e2 ) ;
   pthread_mutex_t lock ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.h"
typedef struct Queue Queue;
#line 51 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.h"
struct Context {
   Queue_element current ;
   Queue_element previous ;
   Queue *queue ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.h"
typedef struct Context Context;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 93 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off64_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 229 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.h"
struct CarveInfo {
   char *filename ;
   FILE *fp ;
   unsigned long long start ;
   unsigned long long stop ;
   char chopped ;
};
#line 321 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.h"
struct Fragment {
   unsigned long long start ;
   unsigned long long stop ;
};
#line 321 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.h"
typedef struct Fragment Fragment;
#line 105 "/usr/include/stdlib.h"
struct __anonstruct_ldiv_t_7 {
   long quot ;
   long rem ;
};
#line 105 "/usr/include/stdlib.h"
typedef struct __anonstruct_ldiv_t_7 ldiv_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 781
extern int fseeko(FILE *__stream , __off64_t __off , int __whence )  __asm__("fseeko64")  ;
#line 784
extern __off64_t ftello(FILE *__stream )  __asm__("ftello64")  ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 220 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 31 "/usr/include/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error)(int __status ,
                                                                                                                         int __errnum ,
                                                                                                                         char const   *__format 
                                                                                                                         , ...) ;
#line 34
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error_at_line)(int __status ,
                                                                                                                                 int __errnum ,
                                                                                                                                 char const   *__fname ,
                                                                                                                                 unsigned int __line ,
                                                                                                                                 char const   *__format 
                                                                                                                                 , ...) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/error.h"
extern void ( /* format attribute */  __error_alias)(int __status , int __errnum ,
                                                     char const   *__format  , ...)  __asm__("error")  ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error)(int __status ,
                                                                                                                         int __errnum ,
                                                                                                                         char const   *__format 
                                                                                                                         , ...) 
{ 


  {
  {
#line 42
  __error_alias(__status, __errnum, __format, __builtin_va_arg_pack());
  }
#line 43
  return;
}
}
#line 46
extern void ( /* format attribute */  __error_at_line_alias)(int __status , int __errnum ,
                                                             char const   *__fname ,
                                                             unsigned int __line ,
                                                             char const   *__format 
                                                             , ...)  __asm__("error_at_line")  ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error_at_line)(int __status ,
                                                                                                                                 int __errnum ,
                                                                                                                                 char const   *__fname ,
                                                                                                                                 unsigned int __line ,
                                                                                                                                 char const   *__format 
                                                                                                                                 , ...) 
{ 


  {
  {
#line 71
  __error_at_line_alias(__status, __errnum, __fname, __line, __format, __builtin_va_arg_pack());
  }
#line 73
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.h"
char *__progname  ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 176 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.h"
int signal_caught  ;
#line 179 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.h"
char wildcard  ;
#line 182 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.h"
int ttywidth  ;
#line 353
unsigned long long measureOpenFile(FILE *f , struct scalpelState *state ) ;
#line 354
int openAuditFile(struct scalpelState *state ) ;
#line 355
int closeFile(FILE *f ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/files.c"
int outputDirectoryOK(char *dir ) 
{ 
  DIR *temp ;
  struct dirent *entry ;
  int i ;
  mode_t newDirectoryMode ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 38
  temp = opendir((char const   *)dir);
  }
#line 38
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 40
    tmp___6 = __errno_location();
    }
#line 40
    if (*tmp___6 == 2) {
      {
#line 46
      newDirectoryMode = (mode_t )(((((448 | (256 >> 3)) | (128 >> 3)) | (64 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
#line 49
      tmp___1 = mkdir((char const   *)dir, newDirectoryMode);
      }
#line 49
      if (tmp___1) {
        {
#line 52
        tmp = __errno_location();
#line 52
        tmp___0 = strerror(*tmp);
#line 52
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"An error occured while trying to create %s - %s\n",
                dir, tmp___0);
        }
#line 54
        return (0);
      }
      {
#line 58
      temp = opendir((char const   *)dir);
      }
#line 58
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
        {
#line 59
        tmp___2 = __errno_location();
#line 59
        tmp___3 = strerror(*tmp___2);
#line 59
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"An error occured while trying to open %s - %s\n",
                dir, tmp___3);
        }
#line 61
        return (0);
      }
    } else {
      {
#line 65
      tmp___4 = __errno_location();
#line 65
      tmp___5 = strerror(*tmp___4);
#line 65
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"An error occured while trying to open %s - %s\n",
              dir, tmp___5);
      }
#line 67
      return (0);
    }
  }
#line 73
  i = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    entry = readdir(temp);
    }
#line 74
    if (! entry) {
#line 74
      goto while_break;
    }
#line 75
    if (i > 1) {
      {
#line 76
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: You have attempted to use a non-empty output directory. In order\n       to maintain forensic soundness, this is not allowed.\n");
      }
#line 77
      return (0);
    }
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  closedir(temp);
  }
#line 82
  return (1);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/files.c"
int openAuditFile(struct scalpelState *state ) 
{ 
  time_t now ;
  time_t tmp ;
  char *timestring ;
  char *tmp___0 ;
  char fn[4096] ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  FILE *tmp___4 ;

  {
  {
#line 87
  tmp = time((time_t *)((void *)0));
#line 87
  now = tmp;
#line 88
  tmp___0 = ctime((time_t const   *)(& now));
#line 88
  timestring = tmp___0;
#line 91
  tmp___1 = outputDirectoryOK(state->outputdirectory);
  }
#line 91
  if (! tmp___1) {
#line 92
    return (2);
  }
  {
#line 95
  snprintf((char */* __restrict  */)(fn), (size_t )4096, (char const   */* __restrict  */)"%s/audit.txt",
           state->outputdirectory);
#line 98
  tmp___4 = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"w");
#line 98
  state->auditFile = tmp___4;
  }
#line 98
  if (! tmp___4) {
    {
#line 99
    tmp___2 = __errno_location();
#line 99
    tmp___3 = strerror(*tmp___2);
#line 99
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t open %s -- %s\n",
            fn, tmp___3);
    }
#line 100
    return (2);
  }
  {
#line 103
  fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"\nScalpel version %s audit file\nStarted at %sCommand line:\n%s\n\nOutput directory: %s\nConfiguration file: %s\n",
          "1.60", timestring, state->invocation, state->outputdirectory, state->conffile);
  }
#line 111
  return (0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/files.c"
int closeFile(FILE *f ) 
{ 
  time_t now ;
  time_t tmp ;
  char *timestring ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 117
  tmp = time((time_t *)((void *)0));
#line 117
  now = tmp;
#line 118
  tmp___0 = ctime((time_t const   *)(& now));
#line 118
  timestring = tmp___0;
#line 120
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n\nCompleted at %s",
          timestring);
#line 122
  tmp___1 = fclose(f);
  }
#line 122
  if (tmp___1) {
#line 123
    return (5);
  }
#line 126
  return (0);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/files.c"
unsigned long long measureOpenFile(FILE *f , struct scalpelState *state ) 
{ 
  unsigned long long total ;
  unsigned long long original ;
  __off64_t tmp ;
  int descriptor ;
  struct stat *info ;
  unsigned long long numsectors ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  __off64_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 152
  total = 0ULL;
#line 152
  tmp = ftello(f);
#line 152
  original = (unsigned long long )tmp;
#line 153
  descriptor = 0;
#line 155
  numsectors = 0ULL;
#line 157
  tmp___2 = fseeko(f, (__off64_t )0, 2);
  }
#line 157
  if (tmp___2) {
#line 158
    if (state->modeVerbose) {
      {
#line 159
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"fseeko() call failed on image file.\n");
#line 160
      tmp___0 = __errno_location();
#line 160
      tmp___1 = strerror(*tmp___0);
#line 160
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Diagnosis: %s\n",
              tmp___1);
      }
    }
#line 162
    return (0xffffffffffffffffULL);
  }
  {
#line 164
  tmp___3 = ftello(f);
#line 164
  total = (unsigned long long )tmp___3;
#line 171
  descriptor = fileno(f);
#line 172
  tmp___4 = malloc(sizeof(struct stat ));
#line 172
  info = (struct stat *)tmp___4;
#line 173
  fstat(descriptor, info);
  }
#line 174
  if ((info->st_mode & 61440U) == 24576U) {
    {
#line 177
    tmp___5 = ioctl(descriptor, (unsigned long )((unsigned int )(18 << 8) | 96U),
                    & numsectors);
    }
#line 177
    if (tmp___5 < 0) {
#line 178
      if (state->modeVerbose) {
        {
#line 179
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Using ioctl() call to measure block device size.\n");
        }
      }
    }
    {
#line 210
    total = numsectors * 512ULL;
#line 212
    free((void *)info);
    }
  }
  {
#line 218
  tmp___6 = fseeko(f, (__off64_t )original, 0);
  }
#line 218
  if (tmp___6) {
#line 219
    if (state->modeVerbose) {
      {
#line 220
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"fseeko() call to restore file position failed on image file.\n");
      }
    }
#line 222
    return (0xffffffffffffffffULL);
  }
#line 225
  return (total - original);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 773 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.h"
void init_queue(Queue *q , int elementsize , int duplicates , int (*compare)(void *e1 ,
                                                                             void *e2 ) ) ;
#line 95
void destroy_queue(Queue *q ) ;
#line 105
void add_to_queue(Queue *q , void *element , int priority ) ;
#line 112
void remove_from_front(Queue *q , void *element ) ;
#line 122
int element_in_queue(Queue *q , void *element ) ;
#line 127
int empty_queue(Queue *q ) ;
#line 132
int queue_length(Queue *q ) ;
#line 137
void copy_queue(Queue *q1 , Queue *q2 ) ;
#line 145
int equal_queues(Queue *q1 , Queue *q2 ) ;
#line 150
void merge_queues(Queue *q1 , Queue *q2 ) ;
#line 169
void rewind_queue(Queue *q ) ;
#line 173
void next_element(Queue *q ) ;
#line 180
void update_current(Queue *q , void *element ) ;
#line 184
void peek_at_current(Queue *q , void *element ) ;
#line 188
void *pointer_to_current(Queue *q ) ;
#line 192
int current_priority(Queue *q ) ;
#line 196
void delete_current(Queue *q ) ;
#line 203
int end_of_queue(Queue *q ) ;
#line 217
void local_init_context(Queue *q , Context *ctx ) ;
#line 221
void local_rewind_queue(Context *ctx ) ;
#line 225
void local_next_element(Context *ctx ) ;
#line 232
void local_update_current(Context *ctx , void *element ) ;
#line 236
void local_peek_at_current(Context *ctx , void *element ) ;
#line 241
void *local_pointer_to_current(Context *ctx ) ;
#line 245
int local_current_priority(Context *ctx ) ;
#line 249
void local_delete_current(Context *ctx ) ;
#line 255
int local_end_of_queue(Context *ctx ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
pthread_mutex_t global_lock  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 17 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
pthread_mutex_t initial_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 20
void nolock_next_element(Queue *q ) ;
#line 21
void nolock_rewind_queue(Queue *q ) ;
#line 22
int nolock_element_in_queue(Queue *q , void *element ) ;
#line 23
void nolock_destroy_queue(Queue *q ) ;
#line 24
void local_nolock_next_element(Context *ctx ) ;
#line 25
void local_nolock_rewind_queue(Context *ctx ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void init_queue(Queue *q , int elementsize , int duplicates , int (*compare)(void *e1 ,
                                                                             void *e2 ) ) 
{ 


  {
  {
#line 31
  q->queuelength = 0;
#line 32
  q->elementsize = elementsize;
#line 33
  q->queue = (Queue_element )0;
#line 34
  q->duplicates = duplicates;
#line 35
  q->compare = compare;
#line 36
  nolock_rewind_queue(q);
#line 37
  q->lock = initial_mutex;
  }
#line 38
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void destroy_queue(Queue *q ) 
{ 


  {
  {
#line 44
  pthread_mutex_lock(& q->lock);
#line 46
  nolock_destroy_queue(q);
#line 49
  pthread_mutex_unlock(& q->lock);
  }
#line 50
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void nolock_destroy_queue(Queue *q ) 
{ 
  Queue_element temp ;

  {
#line 57
  if ((unsigned long )q != (unsigned long )((Queue *)0)) {
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! ((unsigned long )q->queue != (unsigned long )((Queue_element )0))) {
#line 58
        goto while_break;
      }
      {
#line 59
      free((q->queue)->info);
#line 60
      temp = q->queue;
#line 61
      q->queue = (q->queue)->next;
#line 62
      free((void *)temp);
#line 63
      (q->queuelength) --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 67
  nolock_rewind_queue(q);
  }
#line 68
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
int element_in_queue(Queue *q , void *element ) 
{ 
  int found ;

  {
  {
#line 77
  pthread_mutex_lock(& q->lock);
#line 79
  found = nolock_element_in_queue(q, element);
#line 82
  pthread_mutex_unlock(& q->lock);
  }
#line 84
  return (found);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
int nolock_element_in_queue(Queue *q , void *element ) 
{ 
  int found ;
  int tmp ;
  int tmp___0 ;

  {
#line 89
  found = 0;
#line 91
  if ((unsigned long )q->queue != (unsigned long )((Queue_element )0)) {
    {
#line 92
    nolock_rewind_queue(q);
    }
    {
#line 93
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 93
      tmp___0 = end_of_queue(q);
      }
#line 93
      if (tmp___0) {
#line 93
        goto while_break;
      } else
#line 93
      if (! (! found)) {
#line 93
        goto while_break;
      }
      {
#line 94
      tmp = (*(q->compare))(element, (q->current)->info);
      }
#line 94
      if (tmp == 0) {
#line 95
        found = 1;
      } else {
        {
#line 98
        nolock_next_element(q);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 102
  if (! found) {
    {
#line 103
    nolock_rewind_queue(q);
    }
  }
#line 106
  return (found);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void nolock_add_to_queue(Queue *q , void *element , int priority ) 
{ 
  Queue_element new_element ;
  Queue_element ptr ;
  Queue_element prev ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 113
  prev = (Queue_element )0;
#line 115
  if (! q->queue) {
#line 115
    goto _L___0;
  } else
#line 115
  if (q->queue) {
#line 115
    if (q->duplicates) {
#line 115
      goto _L___0;
    } else {
      {
#line 115
      tmp___1 = nolock_element_in_queue(q, element);
      }
#line 115
      if (! tmp___1) {
        _L___0: /* CIL Label */ 
        {
#line 119
        tmp = malloc(sizeof(struct _Queue_element ));
#line 119
        new_element = (Queue_element )tmp;
        }
#line 120
        if ((unsigned long )new_element == (unsigned long )((Queue_element )0)) {
          {
#line 121
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malloc failed in function add_to_queue()\n");
#line 122
          exit(1);
          }
        }
        {
#line 124
        tmp___0 = malloc((size_t )q->elementsize);
#line 124
        new_element->info = tmp___0;
        }
#line 125
        if ((unsigned long )new_element->info == (unsigned long )((void *)0)) {
          {
#line 126
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malloc failed in function add_to_queue()\n");
#line 127
          exit(1);
          }
        }
        {
#line 130
        memcpy((void */* __restrict  */)new_element->info, (void const   */* __restrict  */)element,
               (size_t )q->elementsize);
#line 132
        new_element->priority = priority;
#line 134
        (q->queuelength) ++;
        }
#line 136
        if ((unsigned long )q->queue == (unsigned long )((Queue_element )0)) {
#line 137
          new_element->next = (struct _Queue_element *)0;
#line 138
          q->queue = new_element;
        } else
#line 140
        if ((q->queue)->priority >= priority) {
#line 141
          new_element->next = q->queue;
#line 142
          q->queue = new_element;
        } else {
#line 145
          ptr = q->queue;
          {
#line 146
          while (1) {
            while_continue: /* CIL Label */ ;
#line 146
            if ((unsigned long )ptr != (unsigned long )((Queue_element )0)) {
#line 146
              if (! (priority >= ptr->priority)) {
#line 146
                goto while_break;
              }
            } else {
#line 146
              goto while_break;
            }
#line 147
            prev = ptr;
#line 148
            ptr = ptr->next;
          }
          while_break: /* CIL Label */ ;
          }
#line 151
          new_element->next = prev->next;
#line 152
          prev->next = new_element;
        }
        {
#line 155
        nolock_rewind_queue(q);
        }
      }
    }
  }
#line 157
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void add_to_queue(Queue *q , void *element , int priority ) 
{ 


  {
  {
#line 163
  pthread_mutex_lock(& q->lock);
#line 165
  nolock_add_to_queue(q, element, priority);
#line 168
  pthread_mutex_unlock(& q->lock);
  }
#line 170
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
int empty_queue(Queue *q ) 
{ 


  {
#line 175
  return ((unsigned long )q->queue == (unsigned long )((Queue_element )0));
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void remove_from_front(Queue *q , void *element ) 
{ 
  Queue_element temp ;

  {
  {
#line 185
  pthread_mutex_lock(& q->lock);
  }
#line 188
  if ((unsigned long )q->queue == (unsigned long )((Queue_element )0)) {
    {
#line 189
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function remove_from_front()\n");
#line 190
    exit(1);
    }
  } else {
    {
#line 196
    memcpy((void */* __restrict  */)element, (void const   */* __restrict  */)(q->queue)->info,
           (size_t )q->elementsize);
#line 198
    free((q->queue)->info);
#line 199
    temp = q->queue;
#line 200
    q->queue = (q->queue)->next;
#line 201
    free((void *)temp);
#line 202
    (q->queuelength) --;
    }
  }
  {
#line 205
  nolock_rewind_queue(q);
#line 208
  pthread_mutex_unlock(& q->lock);
  }
#line 209
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void peek_at_current(Queue *q , void *element ) 
{ 


  {
  {
#line 216
  pthread_mutex_lock(& q->lock);
  }
#line 219
  if ((unsigned long )q->queue == (unsigned long )((Queue_element )0)) {
    {
#line 220
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function peek_at_current()\n");
#line 221
    exit(1);
    }
  } else
#line 219
  if ((unsigned long )q->current == (unsigned long )((Queue_element )0)) {
    {
#line 220
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function peek_at_current()\n");
#line 221
    exit(1);
    }
  } else {
    {
#line 227
    memcpy((void */* __restrict  */)element, (void const   */* __restrict  */)(q->current)->info,
           (size_t )q->elementsize);
#line 230
    pthread_mutex_unlock(& q->lock);
    }
  }
#line 232
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void *pointer_to_current(Queue *q ) 
{ 
  void *data ;

  {
  {
#line 240
  pthread_mutex_lock(& q->lock);
  }
#line 243
  if ((unsigned long )q->queue == (unsigned long )((Queue_element )0)) {
    {
#line 244
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function pointer_to_current()\n");
#line 245
    exit(1);
    }
  } else
#line 243
  if ((unsigned long )q->current == (unsigned long )((Queue_element )0)) {
    {
#line 244
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function pointer_to_current()\n");
#line 245
    exit(1);
    }
  } else {
    {
#line 251
    data = (q->current)->info;
#line 254
    pthread_mutex_unlock(& q->lock);
    }
#line 256
    return (data);
  }
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
int current_priority(Queue *q ) 
{ 
  int priority ;

  {
  {
#line 267
  pthread_mutex_lock(& q->lock);
  }
#line 270
  if ((unsigned long )q->queue == (unsigned long )((Queue_element )0)) {
    {
#line 271
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function peek_at_current()\n");
#line 272
    exit(1);
    }
  } else
#line 270
  if ((unsigned long )q->current == (unsigned long )((Queue_element )0)) {
    {
#line 271
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function peek_at_current()\n");
#line 272
    exit(1);
    }
  } else {
    {
#line 278
    priority = (q->current)->priority;
#line 281
    pthread_mutex_unlock(& q->lock);
    }
#line 283
    return (priority);
  }
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void update_current(Queue *q , void *element ) 
{ 


  {
  {
#line 292
  pthread_mutex_lock(& q->lock);
  }
#line 295
  if ((unsigned long )q->queue == (unsigned long )((Queue_element )0)) {
    {
#line 296
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function update_current()\n");
#line 297
    exit(1);
    }
  } else
#line 295
  if ((unsigned long )q->current == (unsigned long )((Queue_element )0)) {
    {
#line 296
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function update_current()\n");
#line 297
    exit(1);
    }
  } else {
    {
#line 302
    memcpy((void */* __restrict  */)(q->current)->info, (void const   */* __restrict  */)element,
           (size_t )q->elementsize);
    }
  }
  {
#line 306
  pthread_mutex_unlock(& q->lock);
  }
#line 307
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void delete_current(Queue *q ) 
{ 
  Queue_element temp ;

  {
  {
#line 316
  pthread_mutex_lock(& q->lock);
  }
#line 319
  if ((unsigned long )q->queue == (unsigned long )((Queue_element )0)) {
    {
#line 320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function delete_current()\n");
#line 321
    exit(1);
    }
  } else
#line 319
  if ((unsigned long )q->current == (unsigned long )((Queue_element )0)) {
    {
#line 320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function delete_current()\n");
#line 321
    exit(1);
    }
  } else {
    {
#line 327
    free((q->current)->info);
#line 328
    temp = q->current;
    }
#line 330
    if ((unsigned long )q->previous == (unsigned long )((Queue_element )0)) {
#line 331
      q->queue = (q->queue)->next;
#line 332
      q->current = q->queue;
    } else {
#line 335
      (q->previous)->next = (q->current)->next;
#line 336
      q->current = (q->previous)->next;
    }
    {
#line 339
    free((void *)temp);
#line 340
    (q->queuelength) --;
    }
  }
  {
#line 345
  pthread_mutex_unlock(& q->lock);
  }
#line 347
  return;
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
int end_of_queue(Queue *q ) 
{ 


  {
#line 353
  return ((unsigned long )q->current == (unsigned long )((Queue_element )0));
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void next_element(Queue *q ) 
{ 


  {
  {
#line 361
  pthread_mutex_lock(& q->lock);
#line 363
  nolock_next_element(q);
#line 366
  pthread_mutex_unlock(& q->lock);
  }
#line 367
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void nolock_next_element(Queue *q ) 
{ 


  {
#line 373
  if ((unsigned long )q->queue == (unsigned long )((Queue_element )0)) {
    {
#line 374
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function next_element()\n");
#line 375
    exit(1);
    }
  } else
#line 377
  if ((unsigned long )q->current == (unsigned long )((Queue_element )0)) {
    {
#line 378
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Advance past end in NULL pointer in function next_element()\n");
#line 379
    exit(1);
    }
  } else {
#line 384
    q->previous = q->current;
#line 385
    q->current = (q->current)->next;
  }
#line 387
  return;
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void rewind_queue(Queue *q ) 
{ 


  {
  {
#line 394
  pthread_mutex_lock(& q->lock);
#line 396
  nolock_rewind_queue(q);
#line 398
  pthread_mutex_unlock(& q->lock);
  }
#line 399
  return;
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void nolock_rewind_queue(Queue *q ) 
{ 


  {
#line 403
  q->current = q->queue;
#line 404
  q->previous = (Queue_element )0;
#line 406
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
int queue_length(Queue *q ) 
{ 


  {
#line 411
  return (q->queuelength);
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void copy_queue(Queue *q1 , Queue *q2 ) 
{ 
  Queue_element temp ;
  Queue_element new_element ;
  Queue_element endq1 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 421
  pthread_mutex_lock(& global_lock);
#line 424
  pthread_mutex_lock(& q1->lock);
#line 425
  pthread_mutex_lock(& q2->lock);
#line 429
  nolock_destroy_queue(q1);
#line 433
  q1->queuelength = 0;
#line 434
  q1->elementsize = q2->elementsize;
#line 435
  q1->queue = (Queue_element )0;
#line 436
  q1->duplicates = q2->duplicates;
#line 437
  q1->compare = q2->compare;
#line 439
  temp = q2->queue;
#line 440
  endq1 = q1->queue;
  }
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! ((unsigned long )temp != (unsigned long )((Queue_element )0))) {
#line 442
      goto while_break;
    }
    {
#line 443
    tmp = malloc(sizeof(struct _Queue_element ));
#line 443
    new_element = (Queue_element )tmp;
    }
#line 445
    if ((unsigned long )new_element == (unsigned long )((Queue_element )0)) {
      {
#line 446
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malloc failed in function copy_queue()\n");
#line 447
      exit(1);
      }
    }
    {
#line 450
    tmp___0 = malloc((size_t )q1->elementsize);
#line 450
    new_element->info = tmp___0;
    }
#line 451
    if ((unsigned long )new_element->info == (unsigned long )((void *)0)) {
      {
#line 452
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malloc failed in function copy_queue()\n");
#line 453
      exit(1);
      }
    }
    {
#line 455
    memcpy((void */* __restrict  */)new_element->info, (void const   */* __restrict  */)temp->info,
           (size_t )q1->elementsize);
#line 457
    new_element->priority = temp->priority;
#line 458
    new_element->next = (struct _Queue_element *)0;
#line 460
    (q1->queuelength) ++;
    }
#line 462
    if ((unsigned long )endq1 == (unsigned long )((Queue_element )0)) {
#line 463
      q1->queue = new_element;
    } else {
#line 466
      endq1->next = new_element;
    }
#line 468
    endq1 = new_element;
#line 469
    temp = temp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 472
  nolock_rewind_queue(q1);
#line 475
  pthread_mutex_unlock(& q2->lock);
#line 476
  pthread_mutex_unlock(& q1->lock);
#line 479
  pthread_mutex_unlock(& global_lock);
  }
#line 481
  return;
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
int equal_queues(Queue *q1 , Queue *q2 ) 
{ 
  Queue_element temp1 ;
  Queue_element temp2 ;
  int same ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 488
  same = 1;
#line 492
  pthread_mutex_lock(& global_lock);
#line 495
  pthread_mutex_lock(& q1->lock);
#line 496
  pthread_mutex_lock(& q2->lock);
  }
#line 498
  if (q1->queuelength != q2->queuelength) {
#line 499
    same = 0;
  } else
#line 498
  if (q1->elementsize != q2->elementsize) {
#line 499
    same = 0;
  } else {
#line 502
    temp1 = q1->queue;
#line 503
    temp2 = q2->queue;
    {
#line 504
    while (1) {
      while_continue: /* CIL Label */ ;
#line 504
      if (same) {
#line 504
        if (! ((unsigned long )temp1 != (unsigned long )((Queue_element )0))) {
#line 504
          goto while_break;
        }
      } else {
#line 504
        goto while_break;
      }
      {
#line 505
      tmp = memcmp((void const   *)temp1->info, (void const   *)temp2->info, (size_t )q1->elementsize);
      }
#line 505
      if (tmp) {
#line 505
        tmp___0 = 0;
      } else
#line 505
      if (temp1->priority == temp2->priority) {
#line 505
        tmp___0 = 1;
      } else {
#line 505
        tmp___0 = 0;
      }
#line 505
      same = tmp___0;
#line 507
      temp1 = temp1->next;
#line 508
      temp2 = temp2->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 513
  pthread_mutex_unlock(& q2->lock);
#line 514
  pthread_mutex_unlock(& q1->lock);
#line 517
  pthread_mutex_unlock(& global_lock);
  }
#line 519
  return (same);
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void merge_queues(Queue *q1 , Queue *q2 ) 
{ 
  Queue_element temp ;

  {
  {
#line 529
  pthread_mutex_lock(& global_lock);
#line 532
  pthread_mutex_lock(& q1->lock);
#line 533
  pthread_mutex_lock(& q2->lock);
#line 535
  temp = q2->queue;
  }
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! ((unsigned long )temp != (unsigned long )((Queue_element )0))) {
#line 537
      goto while_break;
    }
    {
#line 538
    nolock_add_to_queue(q1, temp->info, temp->priority);
#line 539
    temp = temp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 542
  nolock_rewind_queue(q1);
#line 545
  pthread_mutex_unlock(& q2->lock);
#line 546
  pthread_mutex_unlock(& q1->lock);
#line 549
  pthread_mutex_unlock(& global_lock);
  }
#line 551
  return;
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void local_peek_at_current(Context *ctx , void *element ) 
{ 


  {
  {
#line 558
  pthread_mutex_lock(& (ctx->queue)->lock);
  }
#line 561
  if ((unsigned long )ctx->queue == (unsigned long )((Queue *)0)) {
    {
#line 562
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function peek_at_current()\n");
#line 563
    exit(1);
    }
  } else
#line 561
  if ((unsigned long )ctx->current == (unsigned long )((Queue_element )0)) {
    {
#line 562
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function peek_at_current()\n");
#line 563
    exit(1);
    }
  } else {
    {
#line 569
    memcpy((void */* __restrict  */)element, (void const   */* __restrict  */)(ctx->current)->info,
           (size_t )(ctx->queue)->elementsize);
#line 572
    pthread_mutex_unlock(& (ctx->queue)->lock);
    }
  }
#line 575
  return;
}
}
#line 578 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void *local_pointer_to_current(Context *ctx ) 
{ 
  void *data ;

  {
  {
#line 583
  pthread_mutex_lock(& (ctx->queue)->lock);
  }
#line 586
  if ((unsigned long )ctx->queue == (unsigned long )((Queue *)0)) {
    {
#line 587
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function pointer_to_current()\n");
#line 588
    exit(1);
    }
  } else
#line 586
  if ((unsigned long )ctx->current == (unsigned long )((Queue_element )0)) {
    {
#line 587
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function pointer_to_current()\n");
#line 588
    exit(1);
    }
  } else {
    {
#line 594
    data = (ctx->current)->info;
#line 597
    pthread_mutex_unlock(& (ctx->queue)->lock);
    }
#line 599
    return (data);
  }
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
int local_current_priority(Context *ctx ) 
{ 
  int priority ;

  {
  {
#line 609
  pthread_mutex_lock(& (ctx->queue)->lock);
  }
#line 612
  if ((unsigned long )ctx->queue == (unsigned long )((Queue *)0)) {
    {
#line 613
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function peek_at_current()\n");
#line 614
    exit(1);
    }
  } else
#line 612
  if ((unsigned long )ctx->current == (unsigned long )((Queue_element )0)) {
    {
#line 613
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function peek_at_current()\n");
#line 614
    exit(1);
    }
  } else {
    {
#line 619
    priority = (ctx->current)->priority;
#line 622
    pthread_mutex_unlock(& (ctx->queue)->lock);
    }
#line 624
    return (priority);
  }
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void local_update_current(Context *ctx , void *element ) 
{ 


  {
  {
#line 633
  pthread_mutex_lock(& (ctx->queue)->lock);
  }
#line 636
  if ((unsigned long )ctx->queue == (unsigned long )((Queue *)0)) {
    {
#line 637
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function update_current()\n");
#line 638
    exit(1);
    }
  } else
#line 636
  if ((unsigned long )ctx->current == (unsigned long )((Queue_element )0)) {
    {
#line 637
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function update_current()\n");
#line 638
    exit(1);
    }
  } else {
    {
#line 643
    memcpy((void */* __restrict  */)(ctx->current)->info, (void const   */* __restrict  */)element,
           (size_t )(ctx->queue)->elementsize);
    }
  }
  {
#line 647
  pthread_mutex_unlock(& (ctx->queue)->lock);
  }
#line 648
  return;
}
}
#line 652 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void local_delete_current(Context *ctx ) 
{ 
  Queue_element temp ;

  {
  {
#line 657
  pthread_mutex_lock(& (ctx->queue)->lock);
  }
#line 660
  if ((unsigned long )ctx->queue == (unsigned long )((Queue *)0)) {
    {
#line 661
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function delete_current()\n");
#line 662
    exit(1);
    }
  } else
#line 660
  if ((unsigned long )ctx->current == (unsigned long )((Queue_element )0)) {
    {
#line 661
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function delete_current()\n");
#line 662
    exit(1);
    }
  } else {
    {
#line 668
    free((ctx->current)->info);
#line 669
    temp = ctx->current;
    }
#line 671
    if ((unsigned long )ctx->previous == (unsigned long )((Queue_element )0)) {
#line 672
      (ctx->queue)->queue = ((ctx->queue)->queue)->next;
#line 673
      ctx->current = (ctx->queue)->queue;
    } else {
#line 676
      (ctx->previous)->next = (ctx->current)->next;
#line 677
      ctx->current = (ctx->current)->next;
    }
    {
#line 680
    free((void *)temp);
#line 681
    ((ctx->queue)->queuelength) --;
    }
  }
  {
#line 686
  pthread_mutex_unlock(& (ctx->queue)->lock);
  }
#line 688
  return;
}
}
#line 692 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
int local_end_of_queue(Context *ctx ) 
{ 


  {
#line 694
  return ((unsigned long )ctx->current == (unsigned long )((Queue_element )0));
}
}
#line 699 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void local_next_element(Context *ctx ) 
{ 


  {
  {
#line 702
  pthread_mutex_lock(& (ctx->queue)->lock);
#line 704
  local_nolock_next_element(ctx);
#line 707
  pthread_mutex_unlock(& (ctx->queue)->lock);
  }
#line 708
  return;
}
}
#line 711 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void local_nolock_next_element(Context *ctx ) 
{ 


  {
#line 714
  if ((unsigned long )ctx->queue == (unsigned long )((Queue *)0)) {
    {
#line 715
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL pointer in function next_element()\n");
#line 716
    exit(1);
    }
  } else
#line 718
  if ((unsigned long )ctx->current == (unsigned long )((Queue_element )0)) {
    {
#line 719
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Advance past end in NULL pointer in function next_element()\n");
#line 720
    exit(1);
    }
  } else {
#line 725
    ctx->previous = ctx->current;
#line 726
    ctx->current = (ctx->current)->next;
  }
#line 728
  return;
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void local_rewind_queue(Context *ctx ) 
{ 


  {
  {
#line 735
  pthread_mutex_lock(& (ctx->queue)->lock);
#line 737
  local_nolock_rewind_queue(ctx);
#line 740
  pthread_mutex_unlock(& (ctx->queue)->lock);
  }
#line 741
  return;
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void local_nolock_rewind_queue(Context *ctx ) 
{ 


  {
#line 745
  ctx->current = (ctx->queue)->queue;
#line 746
  ctx->previous = (Queue_element )0;
#line 748
  return;
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/prioque.c"
void local_init_context(Queue *q , Context *ctx ) 
{ 


  {
#line 751
  ctx->queue = q;
#line 752
  ctx->current = q->queue;
#line 753
  ctx->previous = (Queue_element )0;
#line 754
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 333 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.h"
void checkMemoryAllocation(struct scalpelState *state , void *ptr , int line , char *file ,
                           char *structure ) ;
#line 335
int skipInFile(struct scalpelState *state , FILE *infile ) ;
#line 336
void scalpelLog(struct scalpelState *state , char *format  , ...) ;
#line 337
void handleError(struct scalpelState *state , int error___0 ) ;
#line 338
int memwildcardcmp(void const   *s1 , void const   *s2 , size_t n , int caseSensitive ) ;
#line 341
void init_bm_table(char *needle , size_t *table , size_t len , int casesensitive ) ;
#line 343
int findLongestNeedle(struct SearchSpecLine *SearchSpec ) ;
#line 345
char *bm_needleinhaystack(char *needle , size_t needle_len , char *haystack , size_t haystack_len ,
                          size_t *table , int casesensitive ) ;
#line 348
int translate(char *str ) ;
#line 349
char *skipWhiteSpace(char *str ) ;
#line 350
void setttywidth(void) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/helpers.c"
void checkMemoryAllocation(struct scalpelState *state , void *ptr , int line , char *file ,
                           char *structure ) 
{ 


  {
#line 32
  if (ptr) {
#line 33
    return;
  } else {
    {
#line 36
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** MEMORY ALLOCATION FAILURE **\n");
#line 37
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Memory exhausted at line %d in file %s. Scalpel was \n",
            line, file);
#line 40
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"allocating memory for %s when this condition occurred.\n",
            structure);
#line 44
    fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"ERROR: Memory exhausted at line %d in file %s. Scalpel was \n",
            line, file);
#line 47
    fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"allocating memory for %s when this condition occurred.\n",
            structure);
#line 51
    handleError(state, 999);
    }
  }
#line 53
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/helpers.c"
void scalpelLog(struct scalpelState *state , char *format  , ...) 
{ 
  va_list argp ;

  {
  {
#line 75
  __builtin_va_start(argp, format);
#line 76
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           argp);
#line 77
  vfprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)format,
           argp);
#line 78
  __builtin_va_end(argp);
  }
#line 79
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/helpers.c"
int charactersMatch(char a , char b , int caseSensitive ) 
{ 
  int tmp ;

  {
#line 86
  if ((int )a == (int )wildcard) {
#line 87
    return (1);
  } else
#line 86
  if ((int )a == (int )b) {
#line 87
    return (1);
  }
#line 89
  if (caseSensitive) {
#line 90
    return (0);
  } else
#line 89
  if ((int )a < 65) {
#line 90
    return (0);
  } else
#line 89
  if ((int )a > 122) {
#line 90
    return (0);
  } else
#line 89
  if ((int )b < 65) {
#line 90
    return (0);
  } else
#line 89
  if ((int )b > 122) {
#line 90
    return (0);
  }
  {
#line 94
  tmp = abs((int )a - (int )b);
  }
#line 94
  return (tmp == 32);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/helpers.c"
int memwildcardcmp(void const   *s1 , void const   *s2 , size_t n , int caseSensitive ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 104
  if (n != 0UL) {
#line 105
    p1 = (unsigned char const   *)s1;
#line 105
    p2 = (unsigned char const   *)s2;
    {
#line 106
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 107
      tmp = p2;
#line 107
      p2 ++;
#line 107
      tmp___0 = p1;
#line 107
      p1 ++;
#line 107
      tmp___1 = charactersMatch((char )*tmp___0, (char )*tmp, caseSensitive);
      }
#line 107
      if (! tmp___1) {
#line 108
        p1 --;
#line 108
        p2 --;
#line 108
        return ((int )((int const   )*p1 - (int const   )*p2));
      }
#line 106
      n --;
#line 106
      if (! (n != 0UL)) {
#line 106
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 112
  return (0);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/helpers.c"
void init_bm_table(char *needle , size_t *table , size_t len , int casesensitive ) 
{ 
  size_t i ;
  size_t j ;
  size_t currentindex ;
  int tmp ;
  int tmp___0 ;

  {
#line 122
  i = (size_t )0;
#line 122
  j = (size_t )0;
#line 122
  currentindex = (size_t )0;
#line 124
  i = (size_t )0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i <= 255UL)) {
#line 124
      goto while_break;
    }
#line 125
    *(table + i) = len;
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  i = (size_t )0;
  {
#line 128
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 128
    if (! (i < len)) {
#line 128
      goto while_break___0;
    }
#line 129
    currentindex = (len - i) - 1UL;
#line 131
    if ((int )*(needle + i) == (int )wildcard) {
#line 132
      j = (size_t )0;
      {
#line 132
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 132
        if (! (j <= 255UL)) {
#line 132
          goto while_break___1;
        }
#line 133
        *(table + j) = currentindex;
#line 132
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 136
    *(table + (unsigned char )*(needle + i)) = currentindex;
#line 137
    if (! casesensitive) {
#line 137
      if ((int )*(needle + i) > 0) {
        {
#line 138
        tmp = tolower((int )*(needle + i));
#line 138
        *(table + tmp) = currentindex;
#line 139
        tmp___0 = toupper((int )*(needle + i));
#line 139
        *(table + tmp___0) = currentindex;
        }
      }
    }
#line 128
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/helpers.c"
char *bm_needleinhaystack_skipnchars(char *needle , size_t needle_len , char *haystack ,
                                     size_t haystack_len , size_t *table , int casesensitive ,
                                     int start_pos ) 
{ 
  register size_t shift ;
  register size_t pos ;
  char *here ;
  int tmp ;

  {
#line 154
  shift = (size_t )0;
#line 155
  pos = (size_t )start_pos;
#line 158
  if (needle_len == 0UL) {
#line 159
    return (haystack);
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (pos < haystack_len)) {
#line 162
      goto while_break;
    }
    {
#line 163
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 163
      if (pos < haystack_len) {
#line 163
        shift = *(table + (unsigned char )*(haystack + pos));
#line 163
        if (! (shift > 0UL)) {
#line 163
          goto while_break___0;
        }
      } else {
#line 163
        goto while_break___0;
      }
#line 164
      pos += shift;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 166
    if (0UL == shift) {
      {
#line 167
      here = haystack + ((pos - needle_len) + 1UL);
#line 167
      tmp = memwildcardcmp((void const   *)needle, (void const   *)here, needle_len,
                           casesensitive);
      }
#line 167
      if (0 == tmp) {
#line 168
        return (here);
      } else {
#line 171
        pos ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return ((char *)((void *)0));
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/helpers.c"
char *bm_needleinhaystack(char *needle , size_t needle_len , char *haystack , size_t haystack_len ,
                          size_t *table , int casesensitive ) 
{ 
  char *tmp ;

  {
  {
#line 183
  tmp = bm_needleinhaystack_skipnchars(needle, needle_len, haystack, haystack_len,
                                       table, casesensitive, (int )(needle_len - 1UL));
  }
#line 183
  return (tmp);
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/helpers.c"
int findLongestNeedle(struct SearchSpecLine *SearchSpec ) 
{ 
  int longest ;
  int i ;

  {
#line 195
  longest = 0;
#line 196
  i = 0;
#line 197
  i = 0;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! ((unsigned long )(SearchSpec + i)->suffix != (unsigned long )((void *)0))) {
#line 197
      goto while_break;
    }
#line 198
    if ((SearchSpec + i)->beginlength > longest) {
#line 199
      longest = (SearchSpec + i)->beginlength;
    }
#line 201
    if ((SearchSpec + i)->endlength > longest) {
#line 202
      longest = (SearchSpec + i)->endlength;
    }
#line 197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return (longest);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/helpers.c"
int translate(char *str ) 
{ 
  char next ;
  char *rd ;
  char *wr ;
  char *bad ;
  char temp[5] ;
  char ch ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned long tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 214
  rd = str;
#line 214
  wr = str;
#line 218
  if (! *rd) {
#line 219
    return (0);
  }
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! *rd) {
#line 222
      goto while_break;
    }
#line 224
    if ((int )*rd == 92) {
#line 225
      rd ++;
      {
#line 227
      if ((int )*rd == 92) {
#line 227
        goto case_92;
      }
#line 228
      if ((int )*rd == 97) {
#line 228
        goto case_97;
      }
#line 229
      if ((int )*rd == 115) {
#line 229
        goto case_115;
      }
#line 230
      if ((int )*rd == 110) {
#line 230
        goto case_110;
      }
#line 231
      if ((int )*rd == 114) {
#line 231
        goto case_114;
      }
#line 232
      if ((int )*rd == 116) {
#line 232
        goto case_116;
      }
#line 233
      if ((int )*rd == 118) {
#line 233
        goto case_118;
      }
#line 236
      if ((int )*rd == 51) {
#line 236
        goto case_51;
      }
#line 236
      if ((int )*rd == 50) {
#line 236
        goto case_51;
      }
#line 236
      if ((int )*rd == 49) {
#line 236
        goto case_51;
      }
#line 236
      if ((int )*rd == 48) {
#line 236
        goto case_51;
      }
#line 236
      if ((int )*rd == 120) {
#line 236
        goto case_51;
      }
#line 255
      goto switch_default;
      case_92: /* CIL Label */ 
#line 227
      rd ++;
#line 227
      tmp = wr;
#line 227
      wr ++;
#line 227
      *tmp = (char )'\\';
#line 227
      goto switch_break;
      case_97: /* CIL Label */ 
#line 228
      rd ++;
#line 228
      tmp___0 = wr;
#line 228
      wr ++;
#line 228
      *tmp___0 = (char )'\a';
#line 228
      goto switch_break;
      case_115: /* CIL Label */ 
#line 229
      rd ++;
#line 229
      tmp___1 = wr;
#line 229
      wr ++;
#line 229
      *tmp___1 = (char )' ';
#line 229
      goto switch_break;
      case_110: /* CIL Label */ 
#line 230
      rd ++;
#line 230
      tmp___2 = wr;
#line 230
      wr ++;
#line 230
      *tmp___2 = (char )'\n';
#line 230
      goto switch_break;
      case_114: /* CIL Label */ 
#line 231
      rd ++;
#line 231
      tmp___3 = wr;
#line 231
      wr ++;
#line 231
      *tmp___3 = (char )'\r';
#line 231
      goto switch_break;
      case_116: /* CIL Label */ 
#line 232
      rd ++;
#line 232
      tmp___4 = wr;
#line 232
      wr ++;
#line 232
      *tmp___4 = (char )'\t';
#line 232
      goto switch_break;
      case_118: /* CIL Label */ 
#line 233
      rd ++;
#line 233
      tmp___5 = wr;
#line 233
      wr ++;
#line 233
      *tmp___5 = (char )'\v';
#line 233
      goto switch_break;
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
      case_120: /* CIL Label */ 
#line 237
      next = *(rd + 1);
#line 238
      if ((int )next < 48) {
#line 240
        goto switch_break;
      } else
#line 238
      if (57 < (int )next) {
#line 238
        if ((int )next < 65) {
#line 240
          goto switch_break;
        } else {
#line 238
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 238
      if (70 < (int )next) {
#line 238
        if ((int )next < 97) {
#line 240
          goto switch_break;
        } else {
#line 238
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 238
      if ((int )next > 102) {
#line 240
        goto switch_break;
      }
#line 241
      next = *(rd + 2);
#line 242
      if ((int )next < 48) {
#line 244
        goto switch_break;
      } else
#line 242
      if (57 < (int )next) {
#line 242
        if ((int )next < 65) {
#line 244
          goto switch_break;
        } else {
#line 242
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 242
      if (70 < (int )next) {
#line 242
        if ((int )next < 97) {
#line 244
          goto switch_break;
        } else {
#line 242
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 242
      if ((int )next > 102) {
#line 244
        goto switch_break;
      }
      {
#line 246
      temp[0] = (char )'0';
#line 246
      bad = temp;
#line 247
      strncpy((char */* __restrict  */)(temp + 1), (char const   */* __restrict  */)rd,
              (size_t )3);
#line 248
      temp[4] = (char )'\000';
#line 249
      tmp___6 = strtoul((char const   */* __restrict  */)(temp), (char **/* __restrict  */)(& bad),
                        0);
#line 249
      ch = (char )tmp___6;
      }
#line 250
      if ((int )*bad == 0) {
#line 251
        tmp___7 = wr;
#line 251
        wr ++;
#line 251
        *tmp___7 = ch;
#line 252
        rd += 3;
      }
#line 254
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 256
      tmp___8 = wr;
#line 256
      wr ++;
#line 256
      *tmp___8 = (char )'\\';
#line 257
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 262
      tmp___9 = wr;
#line 262
      wr ++;
#line 262
      tmp___10 = rd;
#line 262
      rd ++;
#line 262
      *tmp___9 = *tmp___10;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  *wr = (char )'\000';
#line 266
  return ((int )(wr - str));
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/helpers.c"
char *skipWhiteSpace(char *str ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 271
    tmp = __ctype_b_loc();
    }
#line 271
    if (! ((int const   )*(*tmp + (int )*(str + 0)) & 8192)) {
#line 271
      goto while_break;
    }
#line 272
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return (str);
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/helpers.c"
void handleError(struct scalpelState *state , int error___0 ) 
{ 


  {
  {
#line 283
  if (error___0 == 2) {
#line 283
    goto case_2;
  }
#line 290
  if (error___0 == 3) {
#line 290
    goto case_3;
  }
#line 297
  if (error___0 == 7) {
#line 297
    goto case_7;
  }
#line 304
  if (error___0 == 4) {
#line 304
    goto case_4;
  }
#line 313
  if (error___0 == 1) {
#line 313
    goto case_1;
  }
#line 322
  if (error___0 == 999) {
#line 322
    goto case_999;
  }
#line 329
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 285
  scalpelLog(state, (char *)"Scalpel was unable to open the image file: %s\nSkipping...\n\n",
             state->imagefile);
  }
#line 288
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 292
  scalpelLog(state, (char *)"Scalpel was unable to read the image file: %s\nSkipping...\n\n",
             state->imagefile);
  }
#line 295
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 299
  scalpelLog(state, (char *)"Scalpel was unable to read a needed file and will abort.\n");
#line 300
  closeFile(state->auditFile);
#line 301
  exit(-1);
  }
#line 302
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 306
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Scalpel was unable to write output files and will abort.\n");
#line 308
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This error generally indicates that disk space is exhausted.\n");
#line 310
  closeFile(state->auditFile);
#line 311
  exit(-1);
  }
  case_1: /* CIL Label */ 
  {
#line 315
  scalpelLog(state, (char *)"ERROR: The configuration file didn\'t specify any file types to carve.\n");
#line 317
  scalpelLog(state, (char *)"(If you\'re using the default configuration file, you\'ll have to\n");
#line 318
  scalpelLog(state, (char *)"uncomment some of the file types.)\n");
#line 319
  closeFile(state->auditFile);
#line 320
  exit(-1);
  }
  case_999: /* CIL Label */ 
  {
#line 324
  scalpelLog(state, (char *)"Scalpel will abort.\n");
#line 325
  closeFile(state->auditFile);
#line 326
  exit(-1);
  }
#line 327
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 331
  scalpelLog(state, (char *)"Scalpel has encountered an error it doesn\'t knowhow to handle.\nError code: %d\n",
             error___0);
#line 334
  closeFile(state->auditFile);
#line 335
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 337
  return;
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/helpers.c"
void setttywidth(void) 
{ 
  struct winsize winsize ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 354
  tmp = fileno(stdout);
#line 354
  tmp___0 = ioctl(tmp, 21523UL, & winsize);
  }
#line 354
  if (tmp___0 != -1) {
#line 355
    ttywidth = (int )winsize.ws_col;
  } else {
#line 359
    ttywidth = 80;
  }
#line 363
  return;
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/helpers.c"
int skipInFile(struct scalpelState *state , FILE *infile ) 
{ 
  int retries ;
  int tmp ;
  int tmp___0 ;

  {
#line 368
  retries = 0;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 370
    tmp___0 = fseeko(infile, (__off64_t )state->skip, 0);
    }
#line 370
    if (tmp___0) {
      {
#line 377
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Couldn\'t skip %lld bytes at the start of image file %s\n",
              state->skip, state->imagefile);
#line 382
      tmp = retries;
#line 382
      retries ++;
      }
#line 382
      if (tmp > 3) {
        {
#line 383
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sorry, maximum retries exceeded...\n");
        }
#line 384
        return (0);
      } else {
        {
#line 387
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Waiting to try again... \n");
#line 388
        sleep(3U);
        }
      }
    } else {
      {
#line 396
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skipped the first %lld bytes of %s...\n",
              state->skip, state->imagefile);
      }
#line 401
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dirname.h"
char *base_name(char const   *name ) ;
#line 43
size_t base_len(char const   *name ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/base_name.c"
char *base_name(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;

  {
#line 36
  base = name + 0;
#line 39
  p = base;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! *p) {
#line 39
      goto while_break;
    }
#line 41
    if ((int const   )*p == 47) {
      {
#line 44
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 44
        p ++;
#line 44
        if (! ((int const   )*p == 47)) {
#line 44
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 49
      if (! *p) {
#line 51
        if ((int const   )*base == 47) {
#line 52
          base = p - 1;
        }
#line 53
        goto while_break;
      }
#line 57
      base = p;
    }
#line 39
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return ((char *)base);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/base_name.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;

  {
  {
#line 73
  len = strlen(name);
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (1UL < len) {
#line 73
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 73
        goto while_break;
      }
    } else {
#line 73
      goto while_break;
    }
#line 74
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 73
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (len);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 734
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int sig ) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 178 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 328 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.h"
int digImageFile(struct scalpelState *state ) ;
#line 329
int carveImageFile(struct scalpelState *state ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static char readbuffer[10485760]  ;
#line 34
static int writeHeaderFooterDatabase(struct scalpelState *state ) ;
#line 35
static int setupCoverageMaps(struct scalpelState *state , unsigned long long filesize ) ;
#line 36
static int auditUpdateCoverageBlockmap(struct scalpelState *state , struct CarveInfo *carve ) ;
#line 37
static int updateCoverageBlockmap(struct scalpelState *state , unsigned long long block ) ;
#line 38
static void generateFragments(struct scalpelState *state , Queue *fragments , struct CarveInfo *carve ) ;
#line 39
static unsigned long long positionUseCoverageBlockmap(struct scalpelState *state ,
                                                      unsigned long long position ) ;
#line 40
static void destroyCoverageMaps(struct scalpelState *state ) ;
#line 41
static int fseeko_use_coverage_map(struct scalpelState *state , FILE *fp , off64_t offset ) ;
#line 42
static off64_t ftello_use_coverage_map(struct scalpelState *state , FILE *fp ) ;
#line 43
static size_t fread_use_coverage_map(struct scalpelState *state , void *ptr , size_t size ,
                                     size_t nmemb , FILE *stream ) ;
#line 45
static void printhex(char *s , int len ) ;
#line 46
static void clean_up(struct scalpelState *state , int signum ) ;
#line 47
static int displayPosition(int *units , unsigned long long pos , unsigned long long size ,
                           char *fn ) ;
#line 51
static void setupAuditFile(struct scalpelState *state ) ;
#line 52
static int bm_digBuffer(struct scalpelState *state , FILE *infile , unsigned long long lengthofbuf ,
                        unsigned long long offset ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static void printhex(char *s , int len ) 
{ 
  int i ;

  {
#line 64
  i = 0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < len)) {
#line 64
      goto while_break;
    }
    {
#line 65
    printf((char const   */* __restrict  */)"\\x%.2x", (int )((unsigned char )*(s + i)));
#line 64
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static void clean_up(struct scalpelState *state , int signum ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 71
  scalpelLog(state, (char *)"Cleaning up...\n");
#line 72
  tmp = strsignal(signum);
#line 72
  scalpelLog(state, (char *)"\nCaught signal: %s. Program is terminating early\n",
             tmp);
#line 75
  tmp___2 = closeFile(state->auditFile);
  }
#line 75
  if (tmp___2) {
    {
#line 76
    tmp___0 = ferror(state->auditFile);
#line 76
    tmp___1 = strerror(tmp___0);
#line 76
    scalpelLog(state, (char *)"Error closing %s/audit.txt -- %s", state->outputdirectory,
               tmp___1);
    }
  }
  {
#line 80
  exit(1);
  }
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static struct timeval start  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static int displayPosition(int *units , unsigned long long pos , unsigned long long size ,
                           char *fn ) 
{ 
  double percentDone ;
  double position ;
  int count ;
  int barlength ;
  int i ;
  int len ;
  double elapsed ;
  long remaining ;
  char buf[4096] ;
  char line[4096] ;
  struct timeval now ;
  struct timeval td ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 90
  percentDone = ((double )pos / (double )size) * (double )100;
#line 91
  position = (double )pos;
#line 113
  if (pos <= 10485760ULL) {
    {
#line 114
    gettimeofday((struct timeval */* __restrict  */)(& start), (__timezone_ptr_t )((struct timezone *)0));
    }
  }
  {
#line 116
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((struct timezone *)0));
#line 119
  count = 0;
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (count < *units)) {
#line 119
      goto while_break;
    }
#line 120
    position /= (double )1024;
#line 119
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 124
    if (! (position > (double )1023)) {
#line 124
      goto while_break___0;
    }
#line 125
    position /= (double )1024;
#line 126
    (*units) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 131
  if (*units == 0) {
#line 131
    goto case_0;
  }
#line 133
  if (*units == 1) {
#line 133
    goto case_1;
  }
#line 135
  if (*units == 2) {
#line 135
    goto case_2;
  }
#line 137
  if (*units == 3) {
#line 137
    goto case_3;
  }
#line 139
  if (*units == 4) {
#line 139
    goto case_4;
  }
#line 141
  if (*units == 5) {
#line 141
    goto case_5;
  }
#line 143
  if (*units == 6) {
#line 143
    goto case_6;
  }
#line 146
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 132
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"bytes");
  }
#line 132
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 134
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"KB");
  }
#line 134
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 136
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"MB");
  }
#line 136
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 138
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"GB");
  }
#line 138
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 140
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"TB");
  }
#line 140
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 142
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"PB");
  }
#line 142
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 144
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"EB");
  }
#line 144
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 147
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Unable to compute progress.\n");
  }
#line 148
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 151
  len = 0;
#line 152
  tmp = snprintf((char */* __restrict  */)(line + len), sizeof(line) - (unsigned long )len,
                 (char const   */* __restrict  */)"\r%s: %5.1f%% ", fn, percentDone);
#line 152
  len += tmp;
#line 153
  tmp___0 = strlen((char const   *)fn);
#line 153
  tmp___1 = strlen((char const   *)(buf));
#line 153
  barlength = (int )((((size_t )ttywidth - tmp___0) - tmp___1) - 32UL);
  }
#line 154
  if (barlength > 0) {
    {
#line 155
    i = (barlength * (int )percentDone) / 100;
#line 156
    tmp___2 = snprintf((char */* __restrict  */)(line + len), sizeof(line) - (unsigned long )len,
                       (char const   */* __restrict  */)"|%.*s%*s|", i, "****************************************************************************************************************************************************************",
                       barlength - i, "");
#line 156
    len += tmp___2;
    }
  }
  {
#line 162
  tmp___3 = snprintf((char */* __restrict  */)(line + len), sizeof(line) - (unsigned long )len,
                     (char const   */* __restrict  */)" %6.1f %s", position, buf);
#line 162
  len += tmp___3;
  }
  {
#line 168
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 168
    td.tv_sec = now.tv_sec - start.tv_sec;
#line 168
    td.tv_usec = now.tv_usec - start.tv_usec;
#line 168
    if (td.tv_usec < 0L) {
#line 168
      (td.tv_sec) --;
#line 168
      td.tv_usec += 1000000L;
    }
#line 168
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 169
  elapsed = (double )td.tv_sec + (double )td.tv_usec / 1000000.0;
#line 171
  remaining = (long )((((double )100 - percentDone) / percentDone) * elapsed);
#line 174
  if (remaining >= 360000L) {
    {
#line 175
    tmp___4 = snprintf((char */* __restrict  */)(line + len), sizeof(line) - (unsigned long )len,
                       (char const   */* __restrict  */)" --:--ETA");
#line 175
    len += tmp___4;
    }
  } else {
#line 177
    i = (int )(remaining / 3600L);
#line 178
    if (i) {
      {
#line 179
      tmp___5 = snprintf((char */* __restrict  */)(line + len), sizeof(line) - (unsigned long )len,
                         (char const   */* __restrict  */)" %2d:", i);
#line 179
      len += tmp___5;
      }
    } else {
      {
#line 181
      tmp___6 = snprintf((char */* __restrict  */)(line + len), sizeof(line) - (unsigned long )len,
                         (char const   */* __restrict  */)"    ");
#line 181
      len += tmp___6;
      }
    }
    {
#line 182
    i = (int )(remaining % 3600L);
#line 183
    tmp___7 = snprintf((char */* __restrict  */)(line + len), sizeof(line) - (unsigned long )len,
                       (char const   */* __restrict  */)"%02d:%02d ETA", i / 60, i % 60);
#line 183
    len += tmp___7;
    }
  }
  {
#line 186
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
          line);
#line 187
  fflush(stdout);
  }
#line 189
  return (0);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static void setupAuditFile(struct scalpelState *state ) 
{ 
  char imageFile[4096] ;

  {
  {
#line 197
  realpath((char const   */* __restrict  */)state->imagefile, (char */* __restrict  */)(imageFile));
#line 199
  scalpelLog(state, (char *)"\nOpening target \"%s\"\n\n", imageFile);
  }
#line 211
  if (state->skip) {
    {
#line 212
    fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Skipped the first %llu bytes of %s...\n",
            state->skip, state->imagefile);
    }
#line 214
    if (state->modeVerbose) {
      {
#line 215
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Skipped the first %llu bytes of %s...\n",
              state->skip, state->imagefile);
      }
    }
  }
  {
#line 221
  fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"The following files were carved:\n");
#line 222
  fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"File\t\t  Start\t\t\tChop\t\tLength\t\tExtracted From\n");
  }
#line 224
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static int bm_digBuffer(struct scalpelState *state , FILE *infile , unsigned long long lengthofbuf ,
                        unsigned long long offset ) 
{ 
  unsigned long long startLocation ;
  int needlenum ;
  char *foundat ;
  struct SearchSpecLine *currentneedle ;
  unsigned long long tmp ;
  void *tmp___0 ;
  unsigned long long tmp___1 ;
  void *tmp___2 ;

  {
#line 234
  startLocation = 0ULL;
#line 240
  needlenum = 0;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! ((unsigned long )(state->SearchSpec + needlenum)->suffix != (unsigned long )((void *)0))) {
#line 240
      goto while_break;
    }
#line 244
    currentneedle = state->SearchSpec + needlenum;
#line 248
    foundat = readbuffer;
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 249
      if (! foundat) {
#line 249
        goto while_break___0;
      }
#line 251
      if (signal_caught == 15) {
        {
#line 252
        clean_up(state, signal_caught);
        }
      } else
#line 251
      if (signal_caught == 2) {
        {
#line 252
        clean_up(state, signal_caught);
        }
      }
      {
#line 255
      foundat = bm_needleinhaystack(currentneedle->begin, (size_t )currentneedle->beginlength,
                                    foundat, (size_t )((int )(lengthofbuf - (unsigned long long )(foundat - readbuffer))),
                                    (size_t *)(currentneedle->begin_bm_table), currentneedle->casesensitive);
#line 262
      startLocation = offset + (unsigned long long )(foundat - readbuffer);
      }
#line 263
      if ((unsigned long )foundat > 0UL) {
#line 267
        if (state->modeVerbose) {
          {
#line 272
          tmp = positionUseCoverageBlockmap(state, startLocation);
#line 272
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"A %s header was found at : %llu\n",
                  currentneedle->suffix, tmp);
          }
        }
#line 277
        (currentneedle->offsets.numheaders) ++;
#line 278
        if (currentneedle->offsets.headerstorage <= currentneedle->offsets.numheaders) {
          {
#line 282
          tmp___0 = realloc((void *)currentneedle->offsets.headers, (size_t )((unsigned long long )sizeof(unsigned long long ) * (currentneedle->offsets.numheaders + 100ULL)));
#line 282
          currentneedle->offsets.headers = (unsigned long long *)tmp___0;
#line 286
          checkMemoryAllocation(state, (void *)currentneedle->offsets.headers, 286,
                                (char *)"/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c",
                                (char *)"header array");
#line 287
          currentneedle->offsets.headerstorage = currentneedle->offsets.numheaders + 100ULL;
          }
#line 290
          if (state->modeVerbose) {
            {
#line 295
            fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Memory reallocation performed, total header storage = %llu\n",
                    currentneedle->offsets.headerstorage);
            }
          }
        }
#line 301
        *(currentneedle->offsets.headers + (currentneedle->offsets.numheaders - 1ULL)) = startLocation;
      }
#line 305
      if (foundat) {
#line 311
        if (state->noSearchOverlap) {
#line 312
          foundat += currentneedle->beginlength;
        } else {
#line 315
          foundat ++;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 333
    if (currentneedle->offsets.numheaders > 0ULL) {
#line 333
      if (currentneedle->endlength) {
#line 333
        if (*(currentneedle->offsets.headers + (currentneedle->offsets.numheaders - 1ULL)) > offset) {
#line 333
          goto _L;
        } else
#line 333
        if (offset - *(currentneedle->offsets.headers + (currentneedle->offsets.numheaders - 1ULL)) < currentneedle->length) {
#line 333
          goto _L;
        } else {
#line 333
          goto _L___1;
        }
      } else {
#line 333
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 333
    if (currentneedle->endlength) {
#line 333
      if (state->generateHeaderFooterDatabase) {
        _L: /* CIL Label */ 
#line 346
        foundat = readbuffer;
        {
#line 347
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 347
          if (! foundat) {
#line 347
            goto while_break___1;
          }
#line 350
          if (signal_caught == 15) {
            {
#line 351
            clean_up(state, signal_caught);
            }
          } else
#line 350
          if (signal_caught == 2) {
            {
#line 351
            clean_up(state, signal_caught);
            }
          }
          {
#line 355
          foundat = bm_needleinhaystack(currentneedle->end, (size_t )currentneedle->endlength,
                                        foundat, (size_t )((int )(lengthofbuf - (unsigned long long )(foundat - readbuffer))),
                                        (size_t *)(currentneedle->end_bm_table), currentneedle->casesensitive);
          }
#line 362
          if ((unsigned long )foundat > 0UL) {
#line 366
            startLocation = offset + (unsigned long long )(foundat - readbuffer);
#line 368
            if (state->modeVerbose) {
              {
#line 373
              tmp___1 = positionUseCoverageBlockmap(state, startLocation);
#line 373
              fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"A %s footer was found at : %llu\n",
                      currentneedle->suffix, tmp___1);
              }
            }
#line 378
            (currentneedle->offsets.numfooters) ++;
#line 379
            if (currentneedle->offsets.footerstorage <= currentneedle->offsets.numfooters) {
              {
#line 383
              tmp___2 = realloc((void *)currentneedle->offsets.footers, (size_t )((unsigned long long )sizeof(unsigned long long ) * (currentneedle->offsets.numfooters + 100ULL)));
#line 383
              currentneedle->offsets.footers = (unsigned long long *)tmp___2;
#line 387
              checkMemoryAllocation(state, (void *)currentneedle->offsets.footers,
                                    387, (char *)"/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c",
                                    (char *)"footer array");
#line 388
              currentneedle->offsets.footerstorage = currentneedle->offsets.numfooters + 100ULL;
              }
#line 391
              if (state->modeVerbose) {
                {
#line 396
                fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Memory reallocation performed, total footer storage = %llu\n",
                        currentneedle->offsets.footerstorage);
                }
              }
            }
#line 402
            *(currentneedle->offsets.footers + (currentneedle->offsets.numfooters - 1ULL)) = startLocation;
#line 409
            if (state->noSearchOverlap) {
#line 410
              foundat += currentneedle->endlength;
            } else {
#line 413
              foundat ++;
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 240
    needlenum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  return (0);
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
int digImageFile(struct scalpelState *state ) 
{ 
  FILE *infile ;
  unsigned long long filesize ;
  unsigned long long bytesread ;
  unsigned long long fileposition ;
  unsigned long long filebegin ;
  unsigned long long beginreadpos ;
  long err ;
  int status ;
  int displayUnits ;
  int success ;
  int longestneedle ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __off64_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  __off64_t tmp___7 ;
  off64_t tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 433
  filesize = 0ULL;
#line 433
  bytesread = 0ULL;
#line 433
  fileposition = 0ULL;
#line 433
  filebegin = 0ULL;
#line 433
  beginreadpos = 0ULL;
#line 435
  err = 0L;
#line 436
  displayUnits = 0;
#line 437
  success = 0;
#line 439
  setupAuditFile(state);
  }
#line 441
  if ((unsigned long )(state->SearchSpec + 0)->suffix == (unsigned long )((void *)0)) {
#line 442
    return (1);
  }
  {
#line 452
  longestneedle = findLongestNeedle(state->SearchSpec);
#line 455
  infile = fopen((char const   */* __restrict  */)state->imagefile, (char const   */* __restrict  */)"rb");
  }
#line 455
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 456
    tmp = __errno_location();
#line 456
    tmp___0 = strerror(*tmp);
    }
#line 456
    if ((int )*(state->imagefile) == 0) {
#line 456
      tmp___1 = "<blank>";
    } else {
#line 456
      tmp___1 = (char const   *)state->imagefile;
    }
    {
#line 456
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Couldn\'t open input file: %s -- %s\n",
            tmp___1, tmp___0);
    }
#line 459
    return (2);
  }
  {
#line 467
  tmp___2 = fileno(infile);
#line 467
  fcntl(tmp___2, 4, 0);
  }
#line 472
  if (state->skip > 0ULL) {
    {
#line 473
    tmp___3 = skipInFile(state, infile);
    }
#line 473
    if (! tmp___3) {
#line 474
      return (3);
    }
  }
  {
#line 482
  tmp___4 = ftello(infile);
#line 482
  filebegin = (unsigned long long )tmp___4;
#line 483
  filesize = measureOpenFile(infile, state);
  }
#line 483
  if (filesize == 0xffffffffffffffffULL) {
    {
#line 484
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Couldn\'t measure size of image file %s\n",
            state->imagefile);
    }
#line 487
    return (3);
  }
#line 495
  if (state->modeVerbose) {
    {
#line 496
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Total file size is %llu bytes\n",
            filesize);
    }
  }
  {
#line 502
  tmp___5 = setupCoverageMaps(state, filesize);
#line 502
  err = (long )tmp___5;
  }
#line 502
  if (err != 0L) {
#line 503
    return ((int )err);
  }
  {
#line 511
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Image file pass 1/2.\n");
#line 512
  success = 1;
  }
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 513
    tmp___9 = fread_use_coverage_map(state, (void *)(readbuffer), (size_t )1, (size_t )10485760,
                                     infile);
#line 513
    bytesread = (unsigned long long )tmp___9;
    }
#line 513
    if (! (bytesread > (unsigned long long )(longestneedle - 1))) {
#line 513
      if (! (success == 0)) {
#line 513
        goto while_break;
      }
    }
#line 518
    if (state->modeVerbose) {
      {
#line 522
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Read %llu bytes from image file.\n",
              bytesread);
      }
    }
    {
#line 526
    tmp___6 = ferror(infile);
#line 526
    err = (long )tmp___6;
    }
#line 526
    if (err) {
#line 527
      return (3);
    }
    {
#line 529
    success = 1;
#line 532
    tmp___7 = ftello(infile);
#line 532
    fileposition = (unsigned long long )tmp___7;
#line 533
    displayPosition(& displayUnits, fileposition - filebegin, filesize, state->imagefile);
#line 537
    tmp___8 = ftello_use_coverage_map(state, infile);
#line 537
    fileposition = (unsigned long long )tmp___8;
#line 538
    beginreadpos = fileposition - bytesread;
    }
#line 541
    if (signal_caught == 15) {
      {
#line 542
      clean_up(state, signal_caught);
      }
    } else
#line 541
    if (signal_caught == 2) {
      {
#line 542
      clean_up(state, signal_caught);
      }
    }
    {
#line 545
    status = bm_digBuffer(state, infile, bytesread, beginreadpos);
    }
#line 545
    if (status != 0) {
#line 549
      return (status);
    }
    {
#line 556
    fseeko_use_coverage_map(state, infile, (off64_t )(-1 * (longestneedle - 1)));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 559
  closeFile(infile);
  }
#line 561
  return (0);
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
int carveImageFile(struct scalpelState *state ) 
{ 
  FILE *infile ;
  struct SearchSpecLine *currentneedle ;
  struct CarveInfo *carveinfo ;
  char fn[4096] ;
  char orgdir[4096] ;
  unsigned long long start___0 ;
  unsigned long long stop ;
  unsigned long long prevstopindex ;
  int needlenum ;
  unsigned long long filesize ;
  unsigned long long bytesread ;
  unsigned long long fileposition ;
  unsigned long long filebegin ;
  long err ;
  int displayUnits ;
  int success ;
  unsigned long long i ;
  unsigned long long j ;
  int halt ;
  char chopped ;
  int CURRENTFILESOPEN ;
  unsigned long long headerblockindex ;
  unsigned long long footerblockindex ;
  struct Queue *carvelists ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __off64_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  unsigned long long biglseek ;
  off64_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  off64_t tmp___13 ;
  off64_t tmp___14 ;
  int tmp___15 ;
  __off64_t tmp___16 ;
  off64_t tmp___17 ;
  struct CarveInfo *carve ;
  int operation ;
  unsigned long long bytestowrite ;
  unsigned long long byteswritten ;
  unsigned long long offset ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;

  {
  {
#line 581
  filesize = 0ULL;
#line 581
  bytesread = 0ULL;
#line 581
  fileposition = 0ULL;
#line 581
  filebegin = 0ULL;
#line 583
  err = 0L;
#line 584
  displayUnits = 0;
#line 585
  success = 0;
#line 590
  CURRENTFILESOPEN = 0;
#line 601
  infile = fopen((char const   */* __restrict  */)state->imagefile, (char const   */* __restrict  */)"rb");
  }
#line 601
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 602
    tmp = __errno_location();
#line 602
    tmp___0 = strerror(*tmp);
    }
#line 602
    if ((int )*(state->imagefile) == 0) {
#line 602
      tmp___1 = "<blank>";
    } else {
#line 602
      tmp___1 = (char const   *)state->imagefile;
    }
    {
#line 602
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Couldn\'t open input file: %s -- %s\n",
            tmp___1, tmp___0);
    }
#line 605
    return (2);
  }
  {
#line 613
  tmp___2 = fileno(infile);
#line 613
  fcntl(tmp___2, 4, 0);
  }
#line 619
  if (state->skip > 0ULL) {
    {
#line 620
    tmp___3 = skipInFile(state, infile);
    }
#line 620
    if (! tmp___3) {
#line 621
      return (3);
    }
  }
  {
#line 625
  tmp___4 = ftello(infile);
#line 625
  filebegin = (unsigned long long )tmp___4;
#line 626
  filesize = measureOpenFile(infile, state);
  }
#line 626
  if (filesize == 0xffffffffffffffffULL) {
    {
#line 627
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Couldn\'t measure size of image file %s\n",
            state->imagefile);
    }
#line 630
    return (3);
  }
  {
#line 637
  tmp___5 = malloc((size_t )((unsigned long long )sizeof(Queue ) * (2ULL + filesize / 10485760ULL)));
#line 637
  carvelists = (struct Queue *)tmp___5;
#line 638
  checkMemoryAllocation(state, (void *)carvelists, 638, (char *)"/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c",
                        (char *)"carvelists");
#line 643
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Allocating work queues...\n");
#line 645
  i = 0ULL;
  }
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;
#line 645
    if (! (i < 2ULL + filesize / 10485760ULL)) {
#line 645
      goto while_break;
    }
    {
#line 646
    init_queue(carvelists + i, (int )sizeof(struct CarveInfo *), 1, (int (*)(void *e1 ,
                                                                             void *e2 ))0);
#line 645
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 650
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Work queues allocation complete. Building carve lists...\n");
#line 654
  needlenum = 0;
  }
  {
#line 654
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 654
    if (! ((unsigned long )(state->SearchSpec + needlenum)->suffix != (unsigned long )((void *)0))) {
#line 654
      goto while_break___0;
    }
#line 656
    currentneedle = state->SearchSpec + needlenum;
#line 660
    prevstopindex = 0ULL;
#line 661
    i = 0ULL;
    {
#line 661
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 661
      if (! (i < currentneedle->offsets.numheaders)) {
#line 661
        goto while_break___1;
      }
#line 662
      start___0 = *(currentneedle->offsets.headers + i);
#line 666
      if (state->blockAlignedOnly) {
#line 666
        if (start___0 % (unsigned long long )state->alignedblocksize != 0ULL) {
#line 667
          goto __Cont;
        }
      }
#line 670
      stop = 0ULL;
#line 671
      chopped = (char)0;
#line 674
      if (! currentneedle->endlength) {
#line 679
        stop = (start___0 + currentneedle->length) - 1ULL;
#line 682
        chopped = (char)1;
      } else
#line 684
      if (currentneedle->searchtype == 0) {
#line 684
        goto _L;
      } else
#line 684
      if (currentneedle->searchtype == 2) {
        _L: /* CIL Label */ 
#line 695
        halt = 0;
#line 701
        j = prevstopindex;
        {
#line 701
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 701
          if (j < currentneedle->offsets.numfooters) {
#line 701
            if (! (! halt)) {
#line 701
              goto while_break___2;
            }
          } else {
#line 701
            goto while_break___2;
          }
#line 703
          if (*(currentneedle->offsets.footers + j) <= start___0) {
#line 704
            prevstopindex = j;
          } else {
#line 707
            halt = 1;
#line 708
            stop = *(currentneedle->offsets.footers + j);
#line 710
            if (currentneedle->searchtype == 0) {
#line 712
              stop += (unsigned long long )(currentneedle->endlength - 1);
            } else {
#line 716
              stop --;
            }
#line 720
            if ((stop - start___0) + 1ULL > currentneedle->length) {
#line 721
              if (currentneedle->searchtype == 0) {
#line 727
                if (state->carveWithMissingFooters) {
#line 728
                  stop = (start___0 + currentneedle->length) - 1ULL;
#line 729
                  chopped = (char)1;
                } else {
#line 732
                  stop = 0ULL;
                }
              } else {
#line 739
                stop = (start___0 + currentneedle->length) - 1ULL;
#line 740
                chopped = (char)1;
              }
            }
          }
#line 701
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 745
        if (! halt) {
#line 745
          if (currentneedle->searchtype == 2) {
#line 752
            stop = (start___0 + currentneedle->length) - 1ULL;
          } else
#line 745
          if (currentneedle->searchtype == 0) {
#line 745
            if (state->carveWithMissingFooters) {
#line 752
              stop = (start___0 + currentneedle->length) - 1ULL;
            }
          }
        }
      } else {
#line 763
        halt = 0;
#line 764
        j = prevstopindex;
        {
#line 764
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 764
          if (j < currentneedle->offsets.numfooters) {
#line 764
            if (! (! halt)) {
#line 764
              goto while_break___3;
            }
          } else {
#line 764
            goto while_break___3;
          }
#line 766
          if (*(currentneedle->offsets.footers + j) <= start___0) {
#line 767
            prevstopindex = j;
          } else
#line 769
          if (*(currentneedle->offsets.footers + j) - start___0 <= currentneedle->length) {
#line 771
            stop = (*(currentneedle->offsets.footers + j) + (unsigned long long )currentneedle->endlength) - 1ULL;
          } else {
#line 775
            halt = 1;
          }
#line 764
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 782
      if (stop) {
#line 784
        if (stop > filesize) {
#line 784
          stop = filesize;
        } else {
#line 784
          stop = stop;
        }
#line 792
        headerblockindex = start___0 / 10485760ULL;
#line 793
        footerblockindex = stop / 10485760ULL;
#line 800
        if (state->organizeSubdirectories) {
          {
#line 801
          snprintf((char */* __restrict  */)(orgdir), (size_t )4096, (char const   */* __restrict  */)"%s/%s-%d-%1lu",
                   state->outputdirectory, currentneedle->suffix, needlenum, currentneedle->organizeDirNum);
          }
#line 806
          if (! state->previewMode) {
            {
#line 810
            mkdir((char const   *)(orgdir), (__mode_t )511);
            }
          }
        } else {
          {
#line 815
          snprintf((char */* __restrict  */)(orgdir), (size_t )4096, (char const   */* __restrict  */)"%s",
                   state->outputdirectory);
          }
        }
#line 818
        if (state->modeNoSuffix) {
          {
#line 825
          snprintf((char */* __restrict  */)(fn), (size_t )4096, (char const   */* __restrict  */)"%s/%08llu",
                   orgdir, state->fileswritten);
          }
        } else
#line 818
        if ((int )*(currentneedle->suffix + 0) == -1) {
          {
#line 825
          snprintf((char */* __restrict  */)(fn), (size_t )4096, (char const   */* __restrict  */)"%s/%08llu",
                   orgdir, state->fileswritten);
          }
        } else {
          {
#line 838
          snprintf((char */* __restrict  */)(fn), (size_t )4096, (char const   */* __restrict  */)"%s/%08llu.%s",
                   orgdir, state->fileswritten, currentneedle->suffix);
          }
        }
#line 844
        (state->fileswritten) ++;
#line 845
        (currentneedle->numfilestocarve) ++;
#line 846
        if (currentneedle->numfilestocarve % state->organizeMaxFilesPerSub == 0ULL) {
#line 847
          (currentneedle->organizeDirNum) ++;
        }
        {
#line 850
        tmp___6 = malloc(sizeof(struct CarveInfo ));
#line 850
        carveinfo = (struct CarveInfo *)tmp___6;
#line 851
        checkMemoryAllocation(state, (void *)carveinfo, 851, (char *)"/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c",
                              (char *)"carveinfo");
#line 854
        tmp___7 = strlen((char const   *)(fn));
#line 854
        tmp___8 = malloc(tmp___7 + 1UL);
#line 854
        carveinfo->filename = (char *)tmp___8;
#line 855
        checkMemoryAllocation(state, (void *)carveinfo->filename, 855, (char *)"/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c",
                              (char *)"carveinfo");
#line 856
        strcpy((char */* __restrict  */)carveinfo->filename, (char const   */* __restrict  */)(fn));
#line 857
        carveinfo->start = start___0;
#line 858
        carveinfo->stop = stop;
#line 859
        carveinfo->chopped = chopped;
#line 864
        carveinfo->fp = (FILE *)0;
        }
#line 866
        if (headerblockindex == footerblockindex) {
          {
#line 868
          add_to_queue(carvelists + headerblockindex, (void *)(& carveinfo), 3);
          }
        } else {
          {
#line 874
          add_to_queue(carvelists + headerblockindex, (void *)(& carveinfo), 1);
#line 875
          add_to_queue(carvelists + footerblockindex, (void *)(& carveinfo), 2);
#line 878
          j = headerblockindex + 1ULL;
          }
          {
#line 878
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 878
            if (! (j < footerblockindex)) {
#line 878
              goto while_break___4;
            }
            {
#line 879
            add_to_queue(carvelists + j, (void *)(& carveinfo), 4);
#line 878
            j ++;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 661
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 654
    needlenum ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 886
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Carve lists built.  Workload:\n");
#line 887
  needlenum = 0;
  }
  {
#line 887
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 887
    if (! ((unsigned long )(state->SearchSpec + needlenum)->suffix != (unsigned long )((void *)0))) {
#line 887
      goto while_break___5;
    }
    {
#line 888
    currentneedle = state->SearchSpec + needlenum;
#line 889
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s with header \"",
            currentneedle->suffix);
#line 891
    printhex(currentneedle->begin, currentneedle->beginlength);
#line 892
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\" and footer \"");
    }
#line 893
    if ((unsigned long )currentneedle->end == (unsigned long )((char *)0)) {
      {
#line 894
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"NONE");
      }
    } else {
      {
#line 897
      printhex(currentneedle->end, currentneedle->endlength);
      }
    }
    {
#line 902
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\" --> %llu files\n",
            currentneedle->numfilestocarve);
#line 887
    needlenum ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 907
  if (state->previewMode) {
    {
#line 908
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"** PREVIEW MODE: GENERATING AUDIT LOG ONLY **\n");
#line 909
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"** NO CARVED FILES WILL BE WRITTEN **\n");
    }
  }
  {
#line 912
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Carving files from image.\n");
#line 913
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Image file pass 2/2.\n");
#line 918
  success = 1;
  }
  {
#line 919
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 919
    if (! success) {
#line 919
      goto while_break___6;
    }
    {
#line 921
    biglseek = 0ULL;
#line 924
    tmp___9 = ftello_use_coverage_map(state, infile);
#line 924
    fileposition = (unsigned long long )tmp___9;
    }
    {
#line 926
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 926
      tmp___10 = queue_length(carvelists + fileposition / 10485760ULL);
      }
#line 926
      if (tmp___10 == 0) {
#line 926
        if (! success) {
#line 926
          goto while_break___7;
        }
      } else {
#line 926
        goto while_break___7;
      }
#line 928
      biglseek += 10485760ULL;
#line 929
      fileposition += 10485760ULL;
#line 930
      success = fileposition <= filesize;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 934
    if (success) {
#line 934
      if (biglseek) {
        {
#line 935
        fseeko_use_coverage_map(state, infile, (off64_t )biglseek);
        }
      }
    }
#line 938
    if (! success) {
      {
#line 941
      displayPosition(& displayUnits, filesize, filesize, state->imagefile);
      }
#line 944
      goto while_continue___6;
    }
#line 947
    if (! state->previewMode) {
      {
#line 948
      tmp___11 = fread_use_coverage_map(state, (void *)(readbuffer), (size_t )1, (size_t )10485760,
                                        infile);
#line 948
      bytesread = (unsigned long long )tmp___11;
#line 950
      tmp___12 = ferror(infile);
#line 950
      err = (long )tmp___12;
      }
#line 950
      if (err) {
#line 951
        return (3);
      } else
#line 953
      if (bytesread == 0ULL) {
#line 955
        success = 0;
#line 956
        goto while_continue___6;
      }
    } else {
      {
#line 964
      tmp___13 = ftello_use_coverage_map(state, infile);
#line 964
      fileposition = (unsigned long long )tmp___13;
#line 965
      fseeko_use_coverage_map(state, infile, (off64_t )10485760);
#line 966
      tmp___14 = ftello_use_coverage_map(state, infile);
#line 966
      bytesread = (unsigned long long )tmp___14 - fileposition;
#line 969
      tmp___15 = ferror(infile);
#line 969
      err = (long )tmp___15;
      }
#line 969
      if (err) {
#line 970
        return (3);
      } else
#line 972
      if (bytesread == 0ULL) {
#line 974
        success = 0;
#line 975
        goto while_continue___6;
      }
    }
    {
#line 979
    success = 1;
#line 982
    tmp___16 = ftello(infile);
#line 982
    fileposition = (unsigned long long )tmp___16;
#line 983
    displayPosition(& displayUnits, fileposition - filebegin, filesize, state->imagefile);
#line 987
    tmp___17 = ftello_use_coverage_map(state, infile);
#line 987
    fileposition = (unsigned long long )tmp___17;
    }
#line 990
    if (signal_caught == 15) {
      {
#line 991
      clean_up(state, signal_caught);
      }
    } else
#line 990
    if (signal_caught == 2) {
      {
#line 991
      clean_up(state, signal_caught);
      }
    }
    {
#line 996
    rewind_queue(carvelists + (fileposition - bytesread) / 10485760ULL);
    }
    {
#line 998
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 998
      tmp___32 = end_of_queue(carvelists + (fileposition - bytesread) / 10485760ULL);
      }
#line 998
      if (tmp___32) {
#line 998
        goto while_break___8;
      }
      {
#line 1001
      bytestowrite = 0ULL;
#line 1001
      byteswritten = 0ULL;
#line 1001
      offset = 0ULL;
#line 1003
      peek_at_current(carvelists + (fileposition - bytesread) / 10485760ULL, (void *)(& carve));
#line 1005
      operation = current_priority(carvelists + (fileposition - bytesread) / 10485760ULL);
      }
#line 1010
      if (operation == 3) {
#line 1010
        goto _L___0;
      } else
#line 1010
      if (operation == 1) {
#line 1010
        goto _L___0;
      } else
#line 1010
      if ((unsigned long )carve->fp == (unsigned long )((FILE *)0)) {
        _L___0: /* CIL Label */ 
#line 1013
        if (! state->previewMode) {
#line 1013
          if (state->modeVerbose) {
            {
#line 1014
            fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"OPENING %s\n",
                    carve->filename);
            }
          }
        }
#line 1017
        carve->fp = (FILE *)1;
#line 1018
        if (! state->previewMode) {
          {
#line 1019
          carve->fp = fopen((char const   */* __restrict  */)carve->filename, (char const   */* __restrict  */)"ab");
          }
        }
#line 1022
        if (! carve->fp) {
          {
#line 1023
          tmp___18 = __errno_location();
#line 1023
          tmp___19 = strerror(*tmp___18);
#line 1023
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening file: %s -- %s\n",
                  carve->filename, tmp___19);
#line 1025
          tmp___20 = __errno_location();
#line 1025
          tmp___21 = strerror(*tmp___20);
#line 1025
          fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error opening file: %s -- %s\n",
                  carve->filename, tmp___21);
          }
#line 1027
          return (4);
        } else {
#line 1030
          CURRENTFILESOPEN ++;
        }
      }
      {
#line 1036
      if (operation == 4) {
#line 1036
        goto case_4;
      }
#line 1040
      if (operation == 3) {
#line 1040
        goto case_3;
      }
#line 1044
      if (operation == 1) {
#line 1044
        goto case_1;
      }
#line 1050
      if (operation == 2) {
#line 1050
        goto case_2;
      }
#line 1035
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1037
      offset = 0ULL;
#line 1038
      bytestowrite = 10485760ULL;
#line 1039
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1041
      offset = carve->start - (fileposition - bytesread);
#line 1042
      bytestowrite = (carve->stop - carve->start) + 1ULL;
#line 1043
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1045
      offset = carve->start - (fileposition - bytesread);
#line 1046
      if ((carve->stop - carve->start) + 1ULL > 10485760ULL - offset) {
#line 1046
        bytestowrite = 10485760ULL - offset;
      } else {
#line 1046
        bytestowrite = (carve->stop - carve->start) + 1ULL;
      }
#line 1049
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1051
      offset = 0ULL;
#line 1052
      bytestowrite = (carve->stop - (fileposition - bytesread)) + 1ULL;
#line 1053
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1056
      if (! state->previewMode) {
        {
#line 1057
        tmp___26 = fwrite((void const   */* __restrict  */)(readbuffer + offset),
                          sizeof(char ), (size_t )bytestowrite, (FILE */* __restrict  */)carve->fp);
#line 1057
        byteswritten = (unsigned long long )tmp___26;
        }
#line 1057
        if (byteswritten != bytestowrite) {
          {
#line 1062
          tmp___22 = ferror(carve->fp);
#line 1062
          tmp___23 = strerror(tmp___22);
#line 1062
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing to file: %s -- %s\n",
                  carve->filename, tmp___23);
#line 1064
          tmp___24 = ferror(carve->fp);
#line 1064
          tmp___25 = strerror(tmp___24);
#line 1064
          fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error writing to file: %s -- %s\n",
                  carve->filename, tmp___25);
          }
#line 1066
          return (4);
        }
      }
#line 1075
      if (operation == 3) {
#line 1075
        goto _L___1;
      } else
#line 1075
      if (operation == 2) {
#line 1075
        goto _L___1;
      } else
#line 1075
      if (CURRENTFILESOPEN > 512) {
        _L___1: /* CIL Label */ 
#line 1078
        err = 0L;
#line 1079
        if (! state->previewMode) {
#line 1080
          if (state->modeVerbose) {
            {
#line 1081
            fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"CLOSING %s\n",
                    carve->filename);
            }
          }
          {
#line 1083
          tmp___27 = fclose(carve->fp);
#line 1083
          err = (long )tmp___27;
          }
        }
#line 1086
        if (err) {
          {
#line 1087
          tmp___28 = ferror(carve->fp);
#line 1087
          tmp___29 = strerror(tmp___28);
#line 1087
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error closing file: %s -- %s\n\n",
                  carve->filename, tmp___29);
#line 1089
          tmp___30 = ferror(carve->fp);
#line 1089
          tmp___31 = strerror(tmp___30);
#line 1089
          fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error closing file: %s -- %s\n\n",
                  carve->filename, tmp___31);
          }
#line 1091
          return (4);
        } else {
#line 1094
          CURRENTFILESOPEN --;
#line 1095
          carve->fp = (FILE *)0;
#line 1100
          if (operation == 3) {
            {
#line 1101
            auditUpdateCoverageBlockmap(state, carve);
#line 1102
            free((void *)carve->filename);
            }
          } else
#line 1100
          if (operation == 2) {
            {
#line 1101
            auditUpdateCoverageBlockmap(state, carve);
#line 1102
            free((void *)carve->filename);
            }
          }
        }
      }
      {
#line 1106
      next_element(carvelists + (fileposition - bytesread) / 10485760ULL);
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1110
  closeFile(infile);
  }
#line 1115
  if (state->generateHeaderFooterDatabase) {
    {
#line 1116
    tmp___33 = writeHeaderFooterDatabase(state);
#line 1116
    err = (long )tmp___33;
    }
#line 1116
    if (err != 0L) {
#line 1117
      return ((int )err);
    }
  }
  {
#line 1122
  destroyCoverageMaps(state);
#line 1124
  printf((char const   */* __restrict  */)"Processing of image file complete. Cleaning up...\n");
#line 1128
  needlenum = 0;
  }
  {
#line 1128
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1128
    if (! ((unsigned long )(state->SearchSpec + needlenum)->suffix != (unsigned long )((void *)0))) {
#line 1128
      goto while_break___9;
    }
#line 1131
    currentneedle = state->SearchSpec + needlenum;
#line 1132
    if (currentneedle->offsets.headers) {
      {
#line 1133
      free((void *)currentneedle->offsets.headers);
      }
    }
#line 1135
    if (currentneedle->offsets.footers) {
      {
#line 1136
      free((void *)currentneedle->offsets.footers);
      }
    }
#line 1138
    currentneedle->offsets.headers = (unsigned long long *)0;
#line 1139
    currentneedle->offsets.footers = (unsigned long long *)0;
#line 1140
    currentneedle->offsets.numheaders = 0ULL;
#line 1141
    currentneedle->offsets.numfooters = 0ULL;
#line 1142
    currentneedle->offsets.headerstorage = 0ULL;
#line 1143
    currentneedle->offsets.footerstorage = 0ULL;
#line 1128
    needlenum ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1151
  i = 0ULL;
  {
#line 1151
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1151
    if (! (i < 2ULL + filesize / 10485760ULL)) {
#line 1151
      goto while_break___10;
    }
    {
#line 1152
    destroy_queue(carvelists + i);
#line 1151
    i ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 1155
  free((void *)carvelists);
#line 1157
  printf((char const   */* __restrict  */)"Done.");
  }
#line 1158
  return (0);
}
}
#line 1194 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static int writeHeaderFooterDatabase(struct scalpelState *state ) 
{ 
  FILE *dbfile ;
  char fn[4096] ;
  int needlenum ;
  struct SearchSpecLine *currentneedle ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned long long tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1203
  tmp = base_name((char const   *)state->imagefile);
#line 1203
  snprintf((char */* __restrict  */)(fn), (size_t )4096, (char const   */* __restrict  */)"%s/%s.hfd",
           state->outputdirectory, tmp);
#line 1207
  dbfile = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"w");
  }
#line 1207
  if ((unsigned long )dbfile == (unsigned long )((void *)0)) {
    {
#line 1208
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing to header/footer database file: %s\n",
            fn);
#line 1210
    fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error writing to header/footer database file: %s\n",
            fn);
    }
#line 1212
    return (4);
  }
  {
#line 1220
  tmp___0 = fileno(dbfile);
#line 1220
  fcntl(tmp___0, 4, 0);
#line 1223
  needlenum = 0;
  }
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1223
    if (! ((unsigned long )(state->SearchSpec + needlenum)->suffix != (unsigned long )((void *)0))) {
#line 1223
      goto while_break;
    }
#line 1227
    currentneedle = state->SearchSpec + needlenum;
#line 1229
    if ((int )*(currentneedle->suffix + 0) != -1) {
      {
#line 1231
      tmp___1 = fprintf((FILE */* __restrict  */)dbfile, (char const   */* __restrict  */)"%s\n",
                        currentneedle->suffix);
      }
#line 1231
      if (tmp___1 <= 0) {
        {
#line 1232
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing to header/footer database file: %s\n",
                fn);
#line 1234
        fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error writing to header/footer database file: %s\n",
                fn);
        }
#line 1236
        return (4);
      }
      {
#line 1243
      tmp___2 = fprintf((FILE */* __restrict  */)dbfile, (char const   */* __restrict  */)"%llu\n",
                        currentneedle->offsets.numheaders);
      }
#line 1243
      if (tmp___2 <= 0) {
        {
#line 1245
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing to header/footer database file: %s\n",
                fn);
#line 1247
        fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error writing to header/footer database file: %s\n",
                fn);
        }
#line 1249
        return (4);
      }
#line 1253
      i = 0;
      {
#line 1253
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1253
        if (! ((unsigned long long )i < currentneedle->offsets.numheaders)) {
#line 1253
          goto while_break___0;
        }
        {
#line 1257
        tmp___3 = positionUseCoverageBlockmap(state, *(currentneedle->offsets.headers + i));
#line 1257
        tmp___4 = fprintf((FILE */* __restrict  */)dbfile, (char const   */* __restrict  */)"%llu\n",
                          tmp___3);
        }
#line 1257
        if (tmp___4 <= 0) {
          {
#line 1259
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing to header/footer database file: %s\n",
                  fn);
#line 1261
          fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error writing to header/footer database file: %s\n",
                  fn);
          }
#line 1263
          return (4);
        }
#line 1253
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1271
      tmp___5 = fprintf((FILE */* __restrict  */)dbfile, (char const   */* __restrict  */)"%llu\n",
                        currentneedle->offsets.numfooters);
      }
#line 1271
      if (tmp___5 <= 0) {
        {
#line 1273
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing to header/footer database file: %s\n",
                fn);
#line 1275
        fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error writing to header/footer database file: %s\n",
                fn);
        }
#line 1277
        return (4);
      }
#line 1281
      i = 0;
      {
#line 1281
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1281
        if (! ((unsigned long long )i < currentneedle->offsets.numfooters)) {
#line 1281
          goto while_break___1;
        }
        {
#line 1285
        tmp___6 = positionUseCoverageBlockmap(state, *(currentneedle->offsets.footers + i));
#line 1285
        tmp___7 = fprintf((FILE */* __restrict  */)dbfile, (char const   */* __restrict  */)"%llu\n",
                          tmp___6);
        }
#line 1285
        if (tmp___7 <= 0) {
          {
#line 1287
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing to header/footer database file: %s\n",
                  fn);
#line 1289
          fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error writing to header/footer database file: %s\n",
                  fn);
          }
#line 1291
          return (4);
        }
#line 1281
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1223
    needlenum ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1296
  fclose(dbfile);
  }
#line 1298
  return (0);
}
}
#line 1319 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static int setupCoverageMaps(struct scalpelState *state , unsigned long long filesize ) 
{ 
  char fn[4096] ;
  unsigned long long i ;
  unsigned long long k ;
  int empty ;
  unsigned int blocksize ;
  unsigned int entry ;
  char *tmp ;
  FILE *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  double tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  double tmp___7 ;
  FILE *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;

  {
#line 1327
  state->coveragebitmap = (unsigned char *)0;
#line 1328
  state->coverageblockmap = (FILE *)0;
#line 1330
  if (state->modeVerbose) {
#line 1330
    if (state->useCoverageBlockmap) {
      {
#line 1331
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Setting up coverage maps.\n");
      }
    } else
#line 1330
    if (state->updateCoverageBlockmap) {
      {
#line 1331
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Setting up coverage maps.\n");
      }
    }
  }
#line 1334
  if (state->updateCoverageBlockmap) {
#line 1334
    goto _L___1;
  } else
#line 1334
  if (state->useCoverageBlockmap) {
    _L___1: /* CIL Label */ 
    {
#line 1336
    tmp = base_name((char const   *)state->imagefile);
#line 1336
    snprintf((char */* __restrict  */)(fn), (size_t )4096, (char const   */* __restrict  */)"%s/%s.map",
             state->coveragedirectory, tmp);
    }
#line 1340
    if (state->modeVerbose) {
      {
#line 1341
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Coverage blockmap is \"%s\".\n",
              fn);
      }
    }
    {
#line 1345
    tmp___0 = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"rb");
#line 1345
    state->coverageblockmap = tmp___0;
#line 1345
    empty = (unsigned long )tmp___0 == (unsigned long )((void *)0);
    }
#line 1347
    if (state->modeVerbose) {
#line 1348
      if (empty) {
#line 1348
        tmp___1 = "EMPTY";
      } else {
#line 1348
        tmp___1 = "NOT EMPTY";
      }
      {
#line 1348
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Coverage blockmap file is %s.\n",
              tmp___1);
      }
    }
#line 1352
    if (! empty) {
      {
#line 1358
      tmp___2 = fileno(state->coverageblockmap);
#line 1358
      fcntl(tmp___2, 4, 0);
      }
#line 1361
      if (state->modeVerbose) {
        {
#line 1362
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Reading blocksize from Coverage blockmap file.\n");
        }
      }
      {
#line 1366
      tmp___3 = fread((void */* __restrict  */)(& blocksize), sizeof(unsigned int ),
                      (size_t )1, (FILE */* __restrict  */)state->coverageblockmap);
      }
#line 1366
      if (tmp___3 != 1UL) {
        {
#line 1367
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading coverage blockmap blocksize in\ncoverage blockmap file: %s\n",
                fn);
#line 1369
        fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error reading coverage blockmap blocksize in\ncoverage blockmap file: %s\n",
                fn);
        }
#line 1371
        return (7);
      }
#line 1374
      if (state->useCoverageBlockmap) {
#line 1374
        if (! state->updateCoverageBlockmap) {
#line 1376
          state->coverageblocksize = blocksize;
#line 1378
          if (state->modeVerbose) {
            {
#line 1379
            fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Blocksize for coverage blockmap is %u.\n",
                    state->coverageblocksize);
            }
          }
        } else {
#line 1374
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1382
      if (blocksize != state->coverageblocksize) {
        {
#line 1383
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"User-specified blocksize does not match blocksize in\ncoverage blockmap file: %s\n",
                fn);
#line 1385
        fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"User-specified blocksize does not match blocksize in\ncoverage blockmap file: %s\n",
                fn);
        }
#line 1387
        return (999);
      }
      {
#line 1390
      tmp___4 = ceil((double )filesize / (double )state->coverageblocksize);
#line 1390
      state->coveragenumblocks = (unsigned long long )tmp___4;
      }
#line 1391
      if (state->modeVerbose) {
        {
#line 1395
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"# of blocks in coverage blockmap is %llu.\n",
                state->coveragenumblocks);
        }
      }
#line 1399
      if (state->useCoverageBlockmap) {
#line 1400
        if (state->modeVerbose) {
          {
#line 1401
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Allocating and clearing coverage bitmap.\n");
          }
        }
        {
#line 1405
        tmp___5 = malloc((size_t )((state->coveragenumblocks / 8ULL) * (unsigned long long )sizeof(unsigned char )));
#line 1405
        state->coveragebitmap = (unsigned char *)tmp___5;
#line 1407
        checkMemoryAllocation(state, (void *)state->coveragebitmap, 1407, (char *)"/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c",
                              (char *)"coveragebitmap");
#line 1410
        k = 0ULL;
        }
        {
#line 1410
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1410
          if (! (k < state->coveragenumblocks / 8ULL)) {
#line 1410
            goto while_break;
          }
#line 1411
          *(state->coveragebitmap + k) = (unsigned char)0;
#line 1410
          k ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1414
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Reading existing coverage blockmap...this may take a while.\n");
#line 1416
        i = 0ULL;
        }
        {
#line 1416
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1416
          if (! (i < state->coveragenumblocks)) {
#line 1416
            goto while_break___0;
          }
          {
#line 1417
          fseeko(state->coverageblockmap, (__off64_t )((i + 1ULL) * (unsigned long long )sizeof(unsigned int )),
                 0);
#line 1418
          tmp___6 = fread((void */* __restrict  */)(& entry), sizeof(unsigned int ),
                          (size_t )1, (FILE */* __restrict  */)state->coverageblockmap);
          }
#line 1418
          if (tmp___6 != 1UL) {
            {
#line 1419
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading coverage blockmap entry (blockmap truncated?): %s\n",
                    fn);
#line 1421
            fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error reading coverage blockmap entry (blockmap truncated?): %s\n",
                    fn);
            }
#line 1423
            return (7);
          }
#line 1425
          if (entry) {
#line 1426
            *(state->coveragebitmap + i / 8ULL) = (unsigned char )((int )*(state->coveragebitmap + i / 8ULL) | (1 << i % 8ULL));
          }
#line 1416
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else
#line 1431
    if (empty) {
#line 1431
      if (state->useCoverageBlockmap) {
        {
#line 1432
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-u option requires that the blockmap file %s exist.\n",
                fn);
#line 1434
        fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"-u option requires that the blockmap file %s exist.\n",
                fn);
        }
#line 1436
        return (999);
      } else {
#line 1431
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 1439
      tmp___7 = ceil((double )filesize / (double )state->coverageblocksize);
#line 1439
      state->coveragenumblocks = (unsigned long long )tmp___7;
      }
#line 1440
      if (state->modeVerbose) {
        {
#line 1444
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"# of blocks in coverage blockmap is %llu.\n",
                state->coveragenumblocks);
        }
      }
    }
#line 1450
    if (state->updateCoverageBlockmap) {
#line 1451
      if (state->modeVerbose) {
        {
#line 1452
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Changing mode of coverage blockmap file to R/W.\n");
        }
      }
#line 1455
      if (! empty) {
        {
#line 1456
        fclose(state->coverageblockmap);
        }
      }
#line 1458
      if (empty) {
#line 1458
        tmp___9 = "w+b";
      } else {
#line 1458
        tmp___9 = "r+b";
      }
      {
#line 1458
      tmp___8 = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)tmp___9);
#line 1458
      state->coverageblockmap = tmp___8;
      }
#line 1458
      if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
        {
#line 1459
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing to coverage blockmap file: %s\n",
                fn);
#line 1461
        fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error writing to coverage blockmap file: %s\n",
                fn);
        }
#line 1463
        return (4);
      }
      {
#line 1471
      tmp___10 = fileno(state->coverageblockmap);
#line 1471
      fcntl(tmp___10, 4, 0);
      }
#line 1474
      if (empty) {
        {
#line 1476
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Writing empty coverage blockmap...this may take a while.\n");
#line 1477
        entry = 0U;
#line 1478
        tmp___11 = fwrite((void const   */* __restrict  */)(& state->coverageblocksize),
                          sizeof(unsigned int ), (size_t )1, (FILE */* __restrict  */)state->coverageblockmap);
        }
#line 1478
        if (tmp___11 != 1UL) {
          {
#line 1479
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing initial entry in coverage blockmap file!\n");
#line 1480
          fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error writing initial entry in coverage blockmap file!\n");
          }
#line 1481
          return (4);
        }
#line 1483
        k = 0ULL;
        {
#line 1483
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1483
          if (! (k < state->coveragenumblocks)) {
#line 1483
            goto while_break___1;
          }
          {
#line 1484
          tmp___12 = fwrite((void const   */* __restrict  */)(& entry), sizeof(unsigned int ),
                            (size_t )1, (FILE */* __restrict  */)state->coverageblockmap);
          }
#line 1484
          if (tmp___12 != 1UL) {
            {
#line 1485
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing to coverage blockmap file!\n");
#line 1486
            fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error writing to coverage blockmap file!\n");
            }
#line 1487
            return (4);
          }
#line 1483
          k ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
#line 1494
  if (state->modeVerbose) {
#line 1494
    if (state->useCoverageBlockmap) {
      {
#line 1495
      printf((char const   */* __restrict  */)"Finished setting up coverage maps.\n");
      }
    } else
#line 1494
    if (state->updateCoverageBlockmap) {
      {
#line 1495
      printf((char const   */* __restrict  */)"Finished setting up coverage maps.\n");
      }
    }
  }
#line 1498
  return (0);
}
}
#line 1504 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static void generateFragments(struct scalpelState *state , Queue *fragments , struct CarveInfo *carve ) 
{ 
  unsigned long long curblock ;
  unsigned long long neededbytes ;
  unsigned long long bytestoskip ;
  unsigned long long morebytes ;
  unsigned long long totalbytes ;
  unsigned long long curpos ;
  Fragment frag ;

  {
  {
#line 1506
  neededbytes = (carve->stop - carve->start) + 1ULL;
#line 1506
  totalbytes = 0ULL;
#line 1512
  init_queue(fragments, (int )sizeof(struct Fragment ), 1, (int (*)(void *e1 , void *e2 ))0);
  }
#line 1516
  if (! state->useCoverageBlockmap) {
    {
#line 1518
    frag.start = carve->start;
#line 1519
    frag.stop = carve->stop;
#line 1520
    add_to_queue(fragments, (void *)(& frag), 0);
    }
#line 1521
    return;
  } else {
    {
#line 1524
    curpos = positionUseCoverageBlockmap(state, carve->start);
#line 1525
    curblock = curpos / (unsigned long long )state->coverageblocksize;
    }
    {
#line 1527
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1527
      if (totalbytes < neededbytes) {
#line 1527
        if (! (curblock < state->coveragenumblocks)) {
#line 1527
          goto while_break;
        }
      } else {
#line 1527
        goto while_break;
      }
#line 1529
      morebytes = 0ULL;
#line 1530
      bytestoskip = 0ULL;
      {
#line 1533
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1533
        if (curblock < state->coveragenumblocks) {
#line 1533
          if (! ((int )*(state->coveragebitmap + curblock / 8ULL) & (1 << curblock % 8ULL))) {
#line 1533
            goto while_break___0;
          }
        } else {
#line 1533
          goto while_break___0;
        }
#line 1535
        bytestoskip += (unsigned long long )state->coverageblocksize - curpos % (unsigned long long )state->coverageblocksize;
#line 1537
        curblock ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1540
      curpos += bytestoskip;
      {
#line 1543
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1543
        if (curblock < state->coveragenumblocks) {
#line 1543
          if (((int )*(state->coveragebitmap + curblock / 8ULL) & (1 << curblock % 8ULL)) == 0) {
#line 1543
            if (! (totalbytes + morebytes < neededbytes)) {
#line 1543
              goto while_break___1;
            }
          } else {
#line 1543
            goto while_break___1;
          }
        } else {
#line 1543
          goto while_break___1;
        }
#line 1547
        morebytes += (unsigned long long )state->coverageblocksize - curpos % (unsigned long long )state->coverageblocksize;
#line 1550
        curblock ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1554
      if (totalbytes + morebytes > neededbytes) {
#line 1555
        morebytes = neededbytes - totalbytes;
      }
      {
#line 1558
      frag.start = curpos;
#line 1559
      curpos += morebytes;
#line 1560
      frag.stop = curpos - 1ULL;
#line 1561
      totalbytes += morebytes;
#line 1563
      add_to_queue(fragments, (void *)(& frag), 0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1566
  return;
}
}
#line 1577 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static unsigned long long positionUseCoverageBlockmap(struct scalpelState *state ,
                                                      unsigned long long position ) 
{ 
  unsigned long long totalbytes ;
  unsigned long long neededbytes ;
  unsigned long long morebytes ;
  unsigned long long curblock ;
  unsigned long long curpos ;
  unsigned long long bytestoskip ;

  {
#line 1580
  totalbytes = 0ULL;
#line 1580
  neededbytes = position;
#line 1580
  curblock = 0ULL;
#line 1580
  curpos = 0ULL;
#line 1583
  if (! state->useCoverageBlockmap) {
#line 1584
    return (position);
  } else {
    {
#line 1587
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1587
      if (totalbytes < neededbytes) {
#line 1587
        if (! (curblock < state->coveragenumblocks)) {
#line 1587
          goto while_break;
        }
      } else {
#line 1587
        goto while_break;
      }
#line 1588
      morebytes = 0ULL;
#line 1589
      bytestoskip = 0ULL;
      {
#line 1592
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1592
        if (curblock < state->coveragenumblocks) {
#line 1592
          if (! ((int )*(state->coveragebitmap + curblock / 8ULL) & (1 << curblock % 8ULL))) {
#line 1592
            goto while_break___0;
          }
        } else {
#line 1592
          goto while_break___0;
        }
#line 1594
        bytestoskip += (unsigned long long )state->coverageblocksize - curpos % (unsigned long long )state->coverageblocksize;
#line 1596
        curblock ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1599
      curpos += bytestoskip;
      {
#line 1602
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1602
        if (curblock < state->coveragenumblocks) {
#line 1602
          if (((int )*(state->coveragebitmap + curblock / 8ULL) & (1 << curblock % 8ULL)) == 0) {
#line 1602
            if (! (totalbytes + morebytes < neededbytes)) {
#line 1602
              goto while_break___1;
            }
          } else {
#line 1602
            goto while_break___1;
          }
        } else {
#line 1602
          goto while_break___1;
        }
#line 1606
        morebytes += (unsigned long long )state->coverageblocksize - curpos % (unsigned long long )state->coverageblocksize;
#line 1608
        curblock ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1612
      if (totalbytes + morebytes > neededbytes) {
#line 1613
        morebytes = neededbytes - totalbytes;
      }
#line 1616
      curpos += morebytes;
#line 1617
      totalbytes += morebytes;
    }
    while_break: /* CIL Label */ ;
    }
#line 1620
    return (curpos);
  }
}
}
#line 1629 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static int auditUpdateCoverageBlockmap(struct scalpelState *state , struct CarveInfo *carve ) 
{ 
  struct Queue fragments ;
  Fragment *frag ;
  int k ;
  int err ;
  void *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1639
  generateFragments(state, & fragments, carve);
#line 1641
  rewind_queue(& fragments);
  }
  {
#line 1642
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1642
    tmp___3 = end_of_queue(& fragments);
    }
#line 1642
    if (tmp___3) {
#line 1642
      goto while_break;
    }
    {
#line 1643
    tmp = pointer_to_current(& fragments);
#line 1643
    frag = (Fragment *)tmp;
#line 1644
    tmp___0 = base_name((char const   *)carve->filename);
#line 1644
    fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"%s",
            tmp___0);
#line 1650
    fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"%13llu\t\t",
            frag->start);
    }
#line 1654
    if (carve->chopped) {
#line 1654
      tmp___1 = "YES   ";
    } else {
#line 1654
      tmp___1 = "NO    ";
    }
    {
#line 1654
    fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"%3s",
            tmp___1);
#line 1661
    fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"%13llu\t\t",
            (frag->stop - frag->start) + 1ULL);
#line 1665
    tmp___2 = base_name((char const   *)state->imagefile);
#line 1665
    fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"%s\n",
            tmp___2);
    }
#line 1669
    if (state->updateCoverageBlockmap) {
#line 1670
      k = (int )(frag->start / (unsigned long long )state->coverageblocksize);
      {
#line 1670
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1670
        if (! ((unsigned long long )k <= frag->stop / (unsigned long long )state->coverageblocksize)) {
#line 1670
          goto while_break___0;
        }
        {
#line 1672
        err = updateCoverageBlockmap(state, (unsigned long long )k);
        }
#line 1672
        if (err != 0) {
          {
#line 1673
          destroy_queue(& fragments);
          }
#line 1674
          return (err);
        }
#line 1670
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1678
    next_element(& fragments);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1681
  destroy_queue(& fragments);
  }
#line 1683
  return (0);
}
}
#line 1688 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static int updateCoverageBlockmap(struct scalpelState *state , unsigned long long block ) 
{ 
  unsigned int entry ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 1692
  if (state->updateCoverageBlockmap) {
    {
#line 1694
    fseeko(state->coverageblockmap, (__off64_t )((block + 1ULL) * (unsigned long long )sizeof(unsigned int )),
           0);
#line 1695
    tmp = fread((void */* __restrict  */)(& entry), sizeof(unsigned int ), (size_t )1,
                (FILE */* __restrict  */)state->coverageblockmap);
    }
#line 1695
    if (tmp != 1UL) {
      {
#line 1696
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading coverage blockmap entry!\n");
#line 1697
      fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error reading coverage blockmap entry!\n");
      }
#line 1698
      return (7);
    }
    {
#line 1700
    entry ++;
#line 1702
    fseeko(state->coverageblockmap, (__off64_t )((block + 1ULL) * (unsigned long long )sizeof(unsigned int )),
           0);
#line 1703
    tmp___0 = fwrite((void const   */* __restrict  */)(& entry), sizeof(unsigned int ),
                     (size_t )1, (FILE */* __restrict  */)state->coverageblockmap);
    }
#line 1703
    if (tmp___0 != 1UL) {
      {
#line 1704
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing to coverage blockmap file!\n");
#line 1705
      fprintf((FILE */* __restrict  */)state->auditFile, (char const   */* __restrict  */)"Error writing to coverage blockmap file!\n");
      }
#line 1706
      return (4);
    }
  }
#line 1710
  return (0);
}
}
#line 1715 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static void destroyCoverageMaps(struct scalpelState *state ) 
{ 


  {
#line 1719
  if (state->coveragebitmap) {
    {
#line 1720
    free((void *)state->coveragebitmap);
    }
  }
#line 1723
  if (state->useCoverageBlockmap) {
    {
#line 1724
    fclose(state->coverageblockmap);
    }
  } else
#line 1723
  if (state->updateCoverageBlockmap) {
    {
#line 1724
    fclose(state->coverageblockmap);
    }
  }
#line 1726
  return;
}
}
#line 1735 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static int fseeko_use_coverage_map(struct scalpelState *state , FILE *fp , off64_t offset ) 
{ 
  off64_t currentpos ;
  unsigned long long curblock ;
  unsigned long long bytestoskip ;
  unsigned long long bytestokeep ;
  unsigned long long totalbytes ;
  int sign ;
  off64_t tmp ;
  off64_t tmp___0 ;
  int tmp___1 ;

  {
#line 1738
  totalbytes = 0ULL;
#line 1741
  if (state->useCoverageBlockmap) {
    {
#line 1742
    currentpos = ftello(fp);
    }
#line 1743
    if (offset > 0L) {
#line 1743
      sign = 1;
    } else {
#line 1743
      sign = -1;
    }
#line 1745
    curblock = (unsigned long long )(currentpos / (off64_t )state->coverageblocksize);
    {
#line 1747
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1747
      if (offset > 0L) {
#line 1747
        tmp___0 = offset;
      } else {
#line 1747
        tmp___0 = offset * -1L;
      }
#line 1747
      if (totalbytes < (unsigned long long )tmp___0) {
#line 1747
        if (curblock < state->coveragenumblocks) {
#line 1747
          if (! (curblock >= 0ULL)) {
#line 1747
            goto while_break;
          }
        } else {
#line 1747
          goto while_break;
        }
      } else {
#line 1747
        goto while_break;
      }
#line 1749
      bytestoskip = 0ULL;
      {
#line 1752
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1752
        if (curblock < state->coveragenumblocks) {
#line 1752
          if (curblock >= 0ULL) {
#line 1752
            if (! ((int )*(state->coveragebitmap + curblock / 8ULL) & (1 << curblock % 8ULL))) {
#line 1752
              goto while_break___0;
            }
          } else {
#line 1752
            goto while_break___0;
          }
        } else {
#line 1752
          goto while_break___0;
        }
#line 1756
        bytestoskip += (unsigned long long )((long )state->coverageblocksize - currentpos % (long )state->coverageblocksize);
#line 1758
        curblock += (unsigned long long )sign;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1761
      offset = (off64_t )((unsigned long long )offset + bytestoskip * (unsigned long long )sign);
#line 1762
      currentpos = (off64_t )((unsigned long long )currentpos + bytestoskip * (unsigned long long )sign);
#line 1764
      bytestokeep = 0ULL;
      {
#line 1767
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1767
        if (curblock < state->coveragenumblocks) {
#line 1767
          if (curblock >= 0ULL) {
#line 1767
            if (((int )*(state->coveragebitmap + curblock / 8ULL) & (1 << curblock % 8ULL)) == 0) {
#line 1767
              if (offset > 0L) {
#line 1767
                tmp = offset;
              } else {
#line 1767
                tmp = offset * -1L;
              }
#line 1767
              if (! (totalbytes < (unsigned long long )tmp)) {
#line 1767
                goto while_break___1;
              }
            } else {
#line 1767
              goto while_break___1;
            }
          } else {
#line 1767
            goto while_break___1;
          }
        } else {
#line 1767
          goto while_break___1;
        }
#line 1772
        bytestokeep += (unsigned long long )((long )state->coverageblocksize - currentpos % (long )state->coverageblocksize);
#line 1775
        curblock += (unsigned long long )sign;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1778
      totalbytes += bytestokeep;
#line 1779
      currentpos = (off64_t )((unsigned long long )currentpos + bytestokeep * (unsigned long long )sign);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1783
  tmp___1 = fseeko(fp, offset, 1);
  }
#line 1783
  return (tmp___1);
}
}
#line 1797 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static off64_t ftello_use_coverage_map(struct scalpelState *state , FILE *fp ) 
{ 
  off64_t currentpos ;
  off64_t decrease ;
  unsigned long long endblock ;
  unsigned long long k ;

  {
  {
#line 1799
  decrease = (off64_t )0;
#line 1802
  currentpos = ftello(fp);
  }
#line 1804
  if (state->useCoverageBlockmap) {
#line 1805
    endblock = (unsigned long long )(currentpos / (off64_t )state->coverageblocksize);
#line 1808
    k = 0ULL;
    {
#line 1808
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1808
      if (! (k <= endblock)) {
#line 1808
        goto while_break;
      }
#line 1809
      if ((int )*(state->coveragebitmap + k / 8ULL) & (1 << k % 8ULL)) {
#line 1810
        decrease += (off64_t )state->coverageblocksize;
      }
#line 1808
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1814
    if ((int )*(state->coveragebitmap + endblock / 8ULL) & (1 << endblock % 8ULL)) {
#line 1815
      decrease += (long )state->coverageblocksize - currentpos % (long )state->coverageblocksize;
    }
#line 1819
    if (state->modeVerbose) {
#line 1819
      if (state->useCoverageBlockmap) {
        {
#line 1823
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Coverage map decreased current file position by %llu bytes.\n",
                (unsigned long long )decrease);
        }
      }
    }
  }
#line 1828
  return (currentpos - decrease);
}
}
#line 1836 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/dig.c"
static size_t fread_use_coverage_map(struct scalpelState *state , void *ptr , size_t size ,
                                     size_t nmemb , FILE *stream ) 
{ 
  unsigned long long curblock ;
  unsigned long long neededbytes ;
  unsigned long long bytestoskip ;
  unsigned long long bytestoread ;
  unsigned long long bytesread ;
  unsigned long long totalbytesread ;
  unsigned long long curpos ;
  int shortread ;
  __off64_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 1839
  neededbytes = (unsigned long long )(nmemb * size);
#line 1839
  totalbytesread = 0ULL;
#line 1844
  if (state->useCoverageBlockmap) {
#line 1845
    if (state->modeVerbose) {
      {
#line 1849
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Issuing coverage map-based READ, wants %llu bytes.\n",
              neededbytes);
      }
    }
    {
#line 1853
    tmp = ftello(stream);
#line 1853
    curpos = (unsigned long long )tmp;
#line 1854
    curblock = curpos / (unsigned long long )state->coverageblocksize;
#line 1855
    shortread = 0;
    }
    {
#line 1857
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1857
      if (totalbytesread < neededbytes) {
#line 1857
        if (curblock < state->coveragenumblocks) {
#line 1857
          if (! (! shortread)) {
#line 1857
            goto while_break;
          }
        } else {
#line 1857
          goto while_break;
        }
      } else {
#line 1857
        goto while_break;
      }
#line 1858
      bytestoread = 0ULL;
#line 1859
      bytestoskip = 0ULL;
      {
#line 1862
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1862
        if (curblock < state->coveragenumblocks) {
#line 1862
          if (! ((int )*(state->coveragebitmap + curblock / 8ULL) & (1 << curblock % 8ULL))) {
#line 1862
            goto while_break___0;
          }
        } else {
#line 1862
          goto while_break___0;
        }
#line 1864
        bytestoskip += (unsigned long long )state->coverageblocksize - curpos % (unsigned long long )state->coverageblocksize;
#line 1866
        curblock ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1869
      curpos += bytestoskip;
#line 1872
      if (state->modeVerbose) {
        {
#line 1876
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"fread using coverage map to skip %llu bytes.\n",
                bytestoskip);
        }
      }
      {
#line 1880
      fseeko(stream, (off64_t )bytestoskip, 1);
      }
      {
#line 1883
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1883
        if (curblock < state->coveragenumblocks) {
#line 1883
          if (((int )*(state->coveragebitmap + curblock / 8ULL) & (1 << curblock % 8ULL)) == 0) {
#line 1883
            if (! (totalbytesread + bytestoread <= neededbytes)) {
#line 1883
              goto while_break___1;
            }
          } else {
#line 1883
            goto while_break___1;
          }
        } else {
#line 1883
          goto while_break___1;
        }
#line 1887
        bytestoread += (unsigned long long )state->coverageblocksize - curpos % (unsigned long long )state->coverageblocksize;
#line 1890
        curblock ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1894
      if (totalbytesread + bytestoread > neededbytes) {
#line 1895
        bytestoread = neededbytes - totalbytesread;
      }
#line 1899
      if (state->modeVerbose) {
        {
#line 1903
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"fread using coverage map found %llu consecutive bytes.\n",
                bytestoread);
        }
      }
      {
#line 1907
      tmp___0 = fread((void */* __restrict  */)((char *)ptr + totalbytesread), (size_t )1,
                      (size_t )bytestoread, (FILE */* __restrict  */)stream);
#line 1907
      bytesread = (unsigned long long )tmp___0;
      }
#line 1907
      if (bytesread < bytestoread) {
#line 1908
        shortread = 1;
      }
#line 1911
      totalbytesread += bytesread;
#line 1912
      curpos += bytestoread;
#line 1914
      if (state->modeVerbose) {
        {
#line 1918
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"fread using coverage map read %llu bytes.\n",
                bytesread);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1923
    if (state->modeVerbose) {
      {
#line 1924
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Coverage map-based READ complete.\n");
      }
    }
#line 1928
    return ((size_t )(totalbytesread / (unsigned long long )size));
  } else {
    {
#line 1931
    tmp___1 = fread((void */* __restrict  */)ptr, size, nmemb, (FILE */* __restrict  */)stream);
    }
#line 1931
    return (tmp___1);
  }
}
}
#line 214 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 791
extern  __attribute__((__nothrow__)) ldiv_t ( __attribute__((__leaf__)) ldiv)(long __numer ,
                                                                              long __denom )  __attribute__((__const__)) ;
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.c"
void usage(void) 
{ 


  {
  {
#line 37
  printf((char const   */* __restrict  */)"Carves files from a disk image based on file headers and footers.\n");
#line 38
  printf((char const   */* __restrict  */)"\nUsage: scalpel [-b] [-c <config file>] [-d] [-h|V] [-i <file>]\n");
#line 39
  printf((char const   */* __restrict  */)"                 [-m blocksize] [-n] [-o <outputdir>] [-O num] [-q clustersize]\n");
#line 40
  printf((char const   */* __restrict  */)"                 [-r] [-s num] [-t <blockmap file>] [-u] [-v]\n");
#line 41
  printf((char const   */* __restrict  */)"                 <imgfile> [<imgfile>] ...\n\n");
#line 42
  printf((char const   */* __restrict  */)"-b  Carve files even if defined footers aren\'t discovered within\n");
#line 43
  printf((char const   */* __restrict  */)"    maximum carve size for file type [foremost 0.69 compat mode].\n");
#line 44
  printf((char const   */* __restrict  */)"-c  Choose configuration file.\n");
#line 45
  printf((char const   */* __restrict  */)"-d  Generate header/footer database; will bypass certain optimizations\n");
#line 46
  printf((char const   */* __restrict  */)"    and discover all footers, so performance suffers.  Doesn\'t affect\n");
#line 47
  printf((char const   */* __restrict  */)"    the set of files carved.  **EXPERIMENTAL**\n");
#line 48
  printf((char const   */* __restrict  */)"-h  Print this help message and exit.\n");
#line 49
  printf((char const   */* __restrict  */)"-i  Read names of disk images from specified file.\n");
#line 50
  printf((char const   */* __restrict  */)"-m  Generate/update carve coverage blockmap file.  The first 32bit\n");
#line 51
  printf((char const   */* __restrict  */)"    unsigned int in the file identifies the block size. Thereafter\n");
#line 52
  printf((char const   */* __restrict  */)"    each 32bit unsigned int entry in the blockmap file corresponds\n");
#line 53
  printf((char const   */* __restrict  */)"    to one block in the image file.  Each entry counts how many\n");
#line 54
  printf((char const   */* __restrict  */)"    carved files contain this block. Requires more memory and\n");
#line 55
  printf((char const   */* __restrict  */)"    disk.  **EXPERIMENTAL**\n");
#line 56
  printf((char const   */* __restrict  */)"-n  Don\'t add extensions to extracted files.\n");
#line 57
  printf((char const   */* __restrict  */)"-o  Set output directory for carved files.\n");
#line 58
  printf((char const   */* __restrict  */)"-O  Don\'t organize carved files by type. Default is to organize carved files\n");
#line 59
  printf((char const   */* __restrict  */)"    into subdirectories.\n");
#line 60
  printf((char const   */* __restrict  */)"-p  Perform image file preview; audit log indicates which files\n");
#line 61
  printf((char const   */* __restrict  */)"    would have been carved, but no files are actually carved.\n");
#line 62
  printf((char const   */* __restrict  */)"-q  Carve only when header is cluster-aligned.\n");
#line 63
  printf((char const   */* __restrict  */)"-r  Find only first of overlapping headers/footers [foremost 0.69 compat mode].\n");
#line 64
  printf((char const   */* __restrict  */)"-s  Skip n bytes in each disk image before carving.\n");
#line 65
  printf((char const   */* __restrict  */)"-t  Set directory for coverage blockmap.  **EXPERIMENTAL**\n");
#line 66
  printf((char const   */* __restrict  */)"-u  Use carve coverage blockmap when carving.  Carve only sections\n");
#line 67
  printf((char const   */* __restrict  */)"    of the image whose entries in the blockmap are 0.  These areas\n");
#line 68
  printf((char const   */* __restrict  */)"    are treated as contiguous regions.  **EXPERIMENTAL**\n");
#line 69
  printf((char const   */* __restrict  */)"-V  Print copyright information and exit.\n");
#line 70
  printf((char const   */* __restrict  */)"-v  Verbose mode.\n");
  }
#line 71
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.c"
void catch_alarm(int signum ) 
{ 


  {
  {
#line 78
  signal_caught = signum;
#line 79
  signal(signum, & catch_alarm);
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nKill signal detected. Cleaning up...\n");
  }
#line 86
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.c"
int extractSearchSpecData(struct SearchSpecLine *s , char **tokenarray ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;

  {
  {
#line 99
  tmp = malloc(8UL * sizeof(char ));
#line 99
  s->suffix = (char *)tmp;
#line 100
  tmp___0 = malloc(4096UL * sizeof(char ));
#line 100
  s->begin = (char *)tmp___0;
#line 101
  tmp___1 = malloc(4096UL * sizeof(char ));
#line 101
  s->end = (char *)tmp___1;
#line 103
  tmp___2 = strlen("NONE");
#line 103
  tmp___3 = strncasecmp((char const   *)*(tokenarray + 0), "NONE", tmp___2);
  }
#line 103
  if (tmp___3) {
    {
#line 110
    memcpy((void */* __restrict  */)s->suffix, (void const   */* __restrict  */)*(tokenarray + 0),
           (size_t )8);
    }
  } else {
#line 106
    *(s->suffix + 0) = (char )'\377';
#line 107
    *(s->suffix + 1) = (char)0;
  }
  {
#line 114
  tmp___4 = strncasecmp((char const   *)*(tokenarray + 1), "y", (size_t )1);
  }
#line 114
  if (tmp___4) {
    {
#line 114
    tmp___5 = strncasecmp((char const   *)*(tokenarray + 1), "yes", (size_t )3);
    }
#line 114
    if (tmp___5) {
#line 114
      tmp___6 = 0;
    } else {
#line 114
      tmp___6 = 1;
    }
  } else {
#line 114
    tmp___6 = 1;
  }
  {
#line 114
  s->casesensitive = tmp___6;
#line 123
  s->length = strtoull((char const   */* __restrict  */)*(tokenarray + 2), (char **/* __restrict  */)0,
                       10);
#line 126
  s->searchtype = 0;
#line 127
  tmp___11 = strlen("REVERSE");
#line 127
  tmp___12 = strncasecmp((char const   *)*(tokenarray + 5), "REVERSE", tmp___11);
  }
#line 127
  if (tmp___12) {
    {
#line 130
    tmp___9 = strlen("NEXT");
#line 130
    tmp___10 = strncasecmp((char const   *)*(tokenarray + 5), "NEXT", tmp___9);
    }
#line 130
    if (tmp___10) {
      {
#line 134
      tmp___7 = strlen("FORWARD");
#line 134
      tmp___8 = strncasecmp((char const   *)*(tokenarray + 5), "FORWARD", tmp___7);
      }
#line 134
      if (! tmp___8) {
#line 135
        s->searchtype = 0;
      }
    } else {
#line 131
      s->searchtype = 2;
    }
  } else {
#line 128
    s->searchtype = 1;
  }
  {
#line 138
  s->beginlength = translate(*(tokenarray + 3));
#line 139
  memcpy((void */* __restrict  */)s->begin, (void const   */* __restrict  */)*(tokenarray + 3),
         (size_t )s->beginlength);
#line 140
  s->endlength = translate(*(tokenarray + 4));
#line 141
  memcpy((void */* __restrict  */)s->end, (void const   */* __restrict  */)*(tokenarray + 4),
         (size_t )s->endlength);
#line 143
  init_bm_table(s->begin, (size_t *)(s->begin_bm_table), (size_t )s->beginlength,
                s->casesensitive);
#line 145
  init_bm_table(s->end, (size_t *)(s->end_bm_table), (size_t )s->endlength, s->casesensitive);
  }
#line 147
  return (0);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.c"
int processSearchSpecLine(struct scalpelState *state , char *buffer , int lineNumber ) 
{ 
  char *buf ;
  char *token ;
  char **tokenarray ;
  void *tmp ;
  int i ;
  int err ;
  int len ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 155
  buf = buffer;
#line 157
  tmp = malloc(6UL * sizeof(char [4097]));
#line 157
  tokenarray = (char **)tmp;
#line 158
  i = 0;
#line 158
  err = 0;
#line 158
  tmp___0 = strlen((char const   *)buffer);
#line 158
  len = (int )tmp___0;
  }
#line 161
  if ((int )*(buffer + (len - 2)) == 13) {
#line 161
    if ((int )*(buffer + (len - 1)) == 10) {
#line 162
      *(buffer + (len - 2)) = *(buffer + (len - 1));
#line 163
      *(buffer + (len - 1)) = *(buffer + len);
    }
  }
  {
#line 166
  tmp___1 = skipWhiteSpace(buf);
#line 166
  buf = tmp___1;
#line 167
  token = strtok((char */* __restrict  */)buf, (char const   */* __restrict  */)" \t\n");
  }
#line 170
  if ((unsigned long )token == (unsigned long )((void *)0)) {
#line 171
    return (0);
  } else
#line 170
  if ((int )*(token + 0) == 35) {
#line 171
    return (0);
  }
  {
#line 175
  tmp___4 = strncasecmp((char const   *)token, "wildcard", (size_t )9);
  }
#line 175
  if (! tmp___4) {
    {
#line 176
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
    }
#line 176
    if ((unsigned long )token != (unsigned long )((void *)0)) {
      {
#line 177
      translate(token);
      }
    } else {
      {
#line 180
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Warning: Empty wildcard in configuration file line %d. Ignoring.\n",
              lineNumber);
      }
#line 182
      return (0);
    }
    {
#line 185
    tmp___3 = strlen((char const   *)token);
    }
#line 185
    if (tmp___3 > 1UL) {
      {
#line 186
      tmp___2 = strlen((char const   *)token);
#line 186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Wildcard can only be one character, but you specified %d characters.\n         Using the first character, \"%c\", as the wildcard.\n",
              (int )tmp___2, (int )*(token + 0));
      }
    }
#line 192
    wildcard = *(token + 0);
#line 193
    return (0);
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (token) {
#line 196
      if (! (i < 6)) {
#line 196
        goto while_break;
      }
    } else {
#line 196
      goto while_break;
    }
    {
#line 197
    *(tokenarray + i) = token;
#line 198
    i ++;
#line 199
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 203
  if (6 - i == 2) {
#line 203
    goto case_2;
  }
#line 207
  if (6 - i == 1) {
#line 207
    goto case_1;
  }
#line 210
  if (6 - i == 0) {
#line 210
    goto case_0;
  }
#line 212
  goto switch_default;
  case_2: /* CIL Label */ 
#line 204
  *(tokenarray + 5) = (char *)"";
#line 205
  *(tokenarray + 4) = (char *)"";
#line 206
  goto switch_break;
  case_1: /* CIL Label */ 
#line 208
  *(tokenarray + 5) = (char *)"";
#line 209
  goto switch_break;
  case_0: /* CIL Label */ 
#line 211
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 213
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nERROR: In line %d of the configuration file, expected %d tokens,\n       but instead found only %d.\n",
          lineNumber, 6, i);
  }
#line 217
  return (1);
#line 218
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 222
  err = extractSearchSpecData(state->SearchSpec + state->specLines, tokenarray);
  }
#line 222
  if (err) {
    {
#line 225
    goto switch_default___0;
    switch_default___0: /* CIL Label */ 
    {
#line 226
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nERROR: Unknown error on line %d of the configuration file.\n",
            lineNumber);
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 231
  (state->specLines) ++;
#line 232
  return (0);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.c"
int readSearchSpecFile(struct scalpelState *state ) 
{ 
  int lineNumber ;
  int status ;
  FILE *f ;
  char *buffer ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 239
  lineNumber = 0;
#line 242
  tmp = malloc(24577UL * sizeof(char ));
#line 242
  buffer = (char *)tmp;
#line 244
  f = fopen((char const   */* __restrict  */)state->conffile, (char const   */* __restrict  */)"r");
  }
#line 245
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 246
    tmp___0 = __errno_location();
#line 246
    tmp___1 = strerror(*tmp___0);
#line 246
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Couldn\'t open configuration file: %s -- %s\n",
            state->conffile, tmp___1);
#line 249
    free((void *)buffer);
    }
#line 250
    return (2);
  }
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 253
    tmp___2 = fgets((char */* __restrict  */)buffer, 24576, (FILE */* __restrict  */)f);
    }
#line 253
    if (! tmp___2) {
#line 253
      goto while_break;
    }
#line 254
    lineNumber ++;
#line 256
    if (state->specLines > 100) {
      {
#line 257
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Your conf file contains too many file types.\n");
#line 258
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This version was compiled with MAX_FILE_TYPES == %d.\n",
              100);
#line 260
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Increase MAX_FILE_TYPES, recompile, and try again.\n");
#line 261
      free((void *)buffer);
      }
#line 262
      return (6);
    }
    {
#line 265
    status = processSearchSpecLine(state, buffer, lineNumber);
    }
#line 265
    if (status != 0) {
      {
#line 266
      free((void *)buffer);
      }
#line 267
      return (status);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 273
  (state->SearchSpec + state->specLines)->suffix = (char *)((void *)0);
#line 274
  (state->SearchSpec + state->specLines)->casesensitive = 0;
#line 275
  (state->SearchSpec + state->specLines)->length = 0ULL;
#line 276
  (state->SearchSpec + state->specLines)->begin = (char *)((void *)0);
#line 277
  (state->SearchSpec + state->specLines)->beginlength = 0;
#line 278
  (state->SearchSpec + state->specLines)->end = (char *)((void *)0);
#line 279
  (state->SearchSpec + state->specLines)->endlength = 0;
#line 284
  fclose(f);
#line 285
  free((void *)buffer);
  }
#line 286
  return (0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.c"
void registerSignalHandlers(void) 
{ 
  __sighandler_t tmp ;
  __sighandler_t tmp___0 ;

  {
  {
#line 292
  tmp = signal(2, & catch_alarm);
  }
#line 292
  if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))1)) {
    {
#line 293
    signal(2, (void (*)(int  ))1);
    }
  }
  {
#line 295
  tmp___0 = signal(15, & catch_alarm);
  }
#line 295
  if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))1)) {
    {
#line 296
    signal(15, (void (*)(int  ))1);
    }
  }
  {
#line 307
  signal(28, (void (*)(int  ))(& setttywidth));
  }
#line 309
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.c"
void initializeState(char **argv , struct scalpelState *state ) 
{ 
  char **argvcopy ;
  int sss ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 314
  argvcopy = argv;
#line 319
  tmp = malloc(4096UL * sizeof(char ));
#line 319
  state->imagefile = (char *)tmp;
#line 320
  tmp___0 = malloc(4096UL * sizeof(char ));
#line 320
  state->inputFileList = (char *)tmp___0;
#line 321
  tmp___1 = malloc(4096UL * sizeof(char ));
#line 321
  state->conffile = (char *)tmp___1;
#line 322
  tmp___2 = malloc(4096UL * sizeof(char ));
#line 322
  state->outputdirectory = (char *)tmp___2;
#line 323
  tmp___3 = malloc(4096UL * sizeof(char ));
#line 323
  state->invocation = (char *)tmp___3;
#line 328
  sss = (int )(101UL * sizeof(struct SearchSpecLine ));
#line 329
  tmp___4 = malloc((size_t )sss);
#line 329
  state->SearchSpec = (struct SearchSpecLine *)tmp___4;
#line 330
  state->specLines = 0;
#line 338
  i = 0;
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (i < 100)) {
#line 338
      goto while_break;
    }
#line 339
    (state->SearchSpec + i)->offsets.headers = (unsigned long long *)0;
#line 340
    (state->SearchSpec + i)->offsets.footers = (unsigned long long *)0;
#line 341
    (state->SearchSpec + i)->offsets.numheaders = 0ULL;
#line 342
    (state->SearchSpec + i)->offsets.numfooters = 0ULL;
#line 343
    (state->SearchSpec + i)->offsets.headerstorage = 0ULL;
#line 344
    (state->SearchSpec + i)->offsets.footerstorage = 0ULL;
#line 345
    (state->SearchSpec + i)->numfilestocarve = 0ULL;
#line 346
    (state->SearchSpec + i)->organizeDirNum = 0UL;
#line 338
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 349
  state->fileswritten = 0ULL;
#line 350
  state->skip = 0ULL;
#line 351
  state->organizeMaxFilesPerSub = 1000ULL;
#line 352
  state->modeVerbose = 0;
#line 353
  state->modeNoSuffix = 0;
#line 354
  state->useInputFileList = 0;
#line 355
  state->carveWithMissingFooters = 0;
#line 356
  state->noSearchOverlap = 0;
#line 357
  state->generateHeaderFooterDatabase = 0;
#line 358
  state->updateCoverageBlockmap = 0;
#line 359
  state->useCoverageBlockmap = 0;
#line 360
  state->blockAlignedOnly = 0;
#line 361
  state->organizeSubdirectories = 1;
#line 362
  state->previewMode = 0;
#line 363
  state->ignoreEmbedded = 0;
#line 364
  state->auditFile = (FILE *)((void *)0);
#line 368
  tmp___5 = strlen("scalpel-output");
#line 368
  strncpy((char */* __restrict  */)state->outputdirectory, (char const   */* __restrict  */)"scalpel-output",
          tmp___5);
#line 370
  strncpy((char */* __restrict  */)state->conffile, (char const   */* __restrict  */)"/etc/scalpel/scalpel.conf",
          (size_t )4096);
#line 372
  state->coveragedirectory = state->outputdirectory;
#line 373
  wildcard = (char )'?';
#line 374
  signal_caught = 0;
#line 375
  *(state->invocation + 0) = (char)0;
  }
  {
#line 378
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 379
    tmp___6 = strlen((char const   *)state->invocation);
#line 379
    strncat((char */* __restrict  */)state->invocation, (char const   */* __restrict  */)*argvcopy,
            4096UL - tmp___6);
#line 382
    tmp___7 = strlen((char const   *)state->invocation);
#line 382
    strncat((char */* __restrict  */)state->invocation, (char const   */* __restrict  */)" ",
            4096UL - tmp___7);
#line 385
    argvcopy ++;
    }
#line 378
    if (! *argvcopy) {
#line 378
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 388
  registerSignalHandlers();
  }
#line 389
  return;
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.c"
void processCommandLineArgs(int argc , char **argv , struct scalpelState *state ) 
{ 
  char i ;
  unsigned long tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 396
    tmp___2 = getopt(argc, (char * const  *)argv, "bhvVundpq:rt:c:o:s:i:m:O");
#line 396
    i = (char )tmp___2;
    }
#line 396
    if (! ((int )i != -1)) {
#line 396
      goto while_break;
    }
    {
#line 399
    if ((int )i == 86) {
#line 399
      goto case_86;
    }
#line 403
    if ((int )i == 104) {
#line 403
      goto case_104;
    }
#line 407
    if ((int )i == 115) {
#line 407
      goto case_115;
    }
#line 413
    if ((int )i == 99) {
#line 413
      goto case_99;
    }
#line 417
    if ((int )i == 100) {
#line 417
      goto case_100;
    }
#line 426
    if ((int )i == 109) {
#line 426
      goto case_109;
    }
#line 436
    if ((int )i == 111) {
#line 436
      goto case_111;
    }
#line 440
    if ((int )i == 116) {
#line 440
      goto case_116;
    }
#line 445
    if ((int )i == 79) {
#line 445
      goto case_79;
    }
#line 449
    if ((int )i == 112) {
#line 449
      goto case_112;
    }
#line 453
    if ((int )i == 98) {
#line 453
      goto case_98;
    }
#line 457
    if ((int )i == 105) {
#line 457
      goto case_105;
    }
#line 462
    if ((int )i == 110) {
#line 462
      goto case_110;
    }
#line 467
    if ((int )i == 113) {
#line 467
      goto case_113;
    }
#line 477
    if ((int )i == 114) {
#line 477
      goto case_114;
    }
#line 481
    if ((int )i == 117) {
#line 481
      goto case_117;
    }
#line 485
    if ((int )i == 118) {
#line 485
      goto case_118;
    }
#line 489
    goto switch_default;
    case_86: /* CIL Label */ 
    {
#line 400
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Scalpel is (c) 2005-6 by Golden G. Richard III.\nThis program is based on Foremost 0.69, by Kris Kendall and Jesse Kornblum.");
#line 401
    exit(1);
    }
    case_104: /* CIL Label */ 
    {
#line 404
    usage();
#line 405
    exit(1);
    }
    case_115: /* CIL Label */ 
    {
#line 408
    state->skip = strtoull((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                           10);
#line 409
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Skipping the first %lld bytes of each image file.\n",
            state->skip);
    }
#line 411
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 414
    strncpy((char */* __restrict  */)state->conffile, (char const   */* __restrict  */)optarg,
            (size_t )4096);
    }
#line 415
    goto switch_break;
    case_100: /* CIL Label */ 
#line 418
    state->generateHeaderFooterDatabase = 1;
#line 419
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 427
    state->updateCoverageBlockmap = 1;
#line 428
    tmp = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                  10);
#line 428
    state->coverageblocksize = (unsigned int )tmp;
    }
#line 429
    if (state->coverageblocksize <= 0U) {
      {
#line 430
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nERROR: Invalid blocksize for -m command line option.\n");
#line 432
      exit(1);
      }
    }
#line 434
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 437
    strncpy((char */* __restrict  */)state->outputdirectory, (char const   */* __restrict  */)optarg,
            (size_t )4096);
    }
#line 438
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 441
    tmp___0 = malloc(4096UL * sizeof(char ));
#line 441
    state->coveragedirectory = (char *)tmp___0;
#line 442
    strncpy((char */* __restrict  */)state->coveragedirectory, (char const   */* __restrict  */)optarg,
            (size_t )4096);
    }
#line 443
    goto switch_break;
    case_79: /* CIL Label */ 
#line 446
    state->organizeSubdirectories = 0;
#line 447
    goto switch_break;
    case_112: /* CIL Label */ 
#line 450
    state->previewMode = 1;
#line 451
    goto switch_break;
    case_98: /* CIL Label */ 
#line 454
    state->carveWithMissingFooters = 1;
#line 455
    goto switch_break;
    case_105: /* CIL Label */ 
#line 458
    state->useInputFileList = 1;
#line 459
    state->inputFileList = optarg;
#line 460
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 463
    state->modeNoSuffix = 1;
#line 464
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Extracting files without filename extensions.\n");
    }
#line 465
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 468
    state->blockAlignedOnly = 1;
#line 469
    tmp___1 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                      10);
#line 469
    state->alignedblocksize = (unsigned int )tmp___1;
    }
#line 470
    if (state->alignedblocksize <= 0U) {
      {
#line 471
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nERROR: Invalid blocksize for -q command line option.\n");
#line 473
      exit(1);
      }
    }
#line 475
    goto switch_break;
    case_114: /* CIL Label */ 
#line 478
    state->noSearchOverlap = 1;
#line 479
    goto switch_break;
    case_117: /* CIL Label */ 
#line 482
    state->useCoverageBlockmap = 1;
#line 483
    goto switch_break;
    case_118: /* CIL Label */ 
#line 486
    state->modeVerbose = 1;
#line 487
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 490
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.c"
void convertFileNames(struct scalpelState *state ) 
{ 
  char fn[4096] ;

  {
  {
#line 500
  realpath((char const   */* __restrict  */)state->outputdirectory, (char */* __restrict  */)(fn));
#line 501
  strncpy((char */* __restrict  */)state->outputdirectory, (char const   */* __restrict  */)(fn),
          (size_t )4096);
  }
#line 505
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.c"
void digAllFiles(int argc , char **argv , struct scalpelState *state ) 
{ 
  int i ;
  int j ;
  FILE *listoffiles ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
#line 514
  i = 0;
#line 514
  j = 0;
#line 515
  listoffiles = (FILE *)((void *)0);
#line 517
  if (state->useInputFileList) {
    {
#line 518
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Batch mode: reading list of images from %s.",
            state->inputFileList);
#line 520
    listoffiles = fopen((char const   */* __restrict  */)state->inputFileList, (char const   */* __restrict  */)"r");
    }
#line 521
    if ((unsigned long )listoffiles == (unsigned long )((void *)0)) {
      {
#line 522
      tmp = __errno_location();
#line 522
      tmp___0 = strerror(*tmp);
      }
#line 522
      if ((int )*(state->inputFileList) == 0) {
#line 522
        tmp___1 = "<blank>";
      } else {
#line 522
        tmp___1 = (char const   *)state->inputFileList;
      }
      {
#line 522
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t open file: %s -- %s\n",
              tmp___1, tmp___0);
#line 525
      closeFile(state->auditFile);
#line 526
      exit(-1);
      }
    }
#line 528
    j = 0;
    {
#line 529
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 530
      j ++;
#line 532
      tmp___2 = fgets((char */* __restrict  */)state->imagefile, 4096, (FILE */* __restrict  */)listoffiles);
      }
#line 532
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
#line 534
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading line %d of %s. Skipping line.\n",
                j, state->inputFileList);
        }
#line 537
        goto __Cont;
      }
      {
#line 539
      tmp___4 = strlen((char const   *)state->imagefile);
      }
#line 539
      if ((int )*(state->imagefile + (tmp___4 - 1UL)) == 10) {
        {
#line 540
        tmp___3 = strlen((char const   *)state->imagefile);
#line 540
        *(state->imagefile + (tmp___3 - 1UL)) = (char )'\000';
        }
      }
      {
#line 546
      i = digImageFile(state);
      }
#line 546
      if (i) {
        {
#line 547
        handleError(state, i);
        }
      } else {
        {
#line 554
        i = carveImageFile(state);
        }
#line 554
        if (i) {
          {
#line 555
          handleError(state, i);
          }
        }
      }
      __Cont: /* CIL Label */ 
      {
#line 529
      tmp___5 = feof(listoffiles);
      }
#line 529
      if (tmp___5) {
#line 529
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 560
    closeFile(listoffiles);
    }
  } else {
    {
#line 563
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 564
      state->imagefile = *argv;
#line 569
      i = digImageFile(state);
      }
#line 569
      if (i) {
        {
#line 570
        handleError(state, i);
        }
      } else {
        {
#line 577
        i = carveImageFile(state);
        }
#line 577
        if (i) {
          {
#line 578
          handleError(state, i);
          }
        }
      }
#line 581
      argv ++;
#line 563
      if (! *argv) {
#line 563
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 584
  return;
}
}
#line 587 "/home/june/repo/benchmarks/collector/temp/scalpel-1.60/scalpel.c"
int main(int argc , char **argv ) 
{ 
  time_t starttime ;
  time_t tmp ;
  struct scalpelState state ;
  ldiv_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  time_t tmp___3 ;

  {
  {
#line 589
  tmp = time((time_t *)0);
#line 589
  starttime = tmp;
#line 592
  tmp___0 = ldiv(10485760L, 512L);
  }
#line 592
  if (tmp___0.rem != 0L) {
    {
#line 593
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PANIC: SIZE_OF_BUFFER has been incorrectly configured.\n");
#line 594
    exit(-1);
    }
  }
  {
#line 601
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Scalpel version %s\nWritten by Golden G. Richard III, based on Foremost 0.69.\n",
          "1.60");
#line 603
  initializeState(argv, & state);
#line 605
  processCommandLineArgs(argc, argv, & state);
#line 607
  convertFileNames(& state);
  }
#line 609
  if (state.modeVerbose) {
    {
#line 610
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Output directory: \"%s\"\n",
            state.outputdirectory);
#line 611
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Configuration file: \"%s\"\n",
            state.conffile);
#line 612
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Coverage maps directory: \"%s\"\n",
            state.coveragedirectory);
    }
  }
  {
#line 616
  tmp___1 = readSearchSpecFile(& state);
  }
#line 616
  if (tmp___1) {
    {
#line 618
    exit(-1);
    }
  }
  {
#line 621
  setttywidth();
#line 623
  argv += optind;
  }
#line 624
  if ((unsigned long )*argv != (unsigned long )((void *)0)) {
#line 624
    goto _L;
  } else
#line 624
  if (state.useInputFileList) {
    _L: /* CIL Label */ 
    {
#line 626
    tmp___2 = openAuditFile(& state);
    }
#line 626
    if (tmp___2) {
      {
#line 627
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aborting.\n\n");
#line 628
      exit(-1);
      }
    }
    {
#line 630
    digAllFiles(argc, argv, & state);
#line 631
    closeFile(state.auditFile);
    }
  } else {
    {
#line 633
    usage();
#line 634
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\nERROR: No image files specified.\n\n");
    }
  }
  {
#line 642
  tmp___3 = time((time_t *)0);
#line 642
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\nScalpel is done, files carved = %llu, elapsed = %ld seconds.\n",
          state.fileswritten, (time_t )((int )tmp___3) - starttime);
  }
#line 647
  return (0);
}
}
