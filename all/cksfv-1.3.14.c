/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/crc32.c"
static uint32_t const   crctable[256]  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/crc32.c"
  {      (uint32_t const   )0,      (uint32_t const   )1996959894,      (uint32_t const   )3993919788U,      (uint32_t const   )2567524794U, 
        (uint32_t const   )124634137,      (uint32_t const   )1886057615,      (uint32_t const   )3915621685U,      (uint32_t const   )2657392035U, 
        (uint32_t const   )249268274,      (uint32_t const   )2044508324,      (uint32_t const   )3772115230U,      (uint32_t const   )2547177864U, 
        (uint32_t const   )162941995,      (uint32_t const   )2125561021,      (uint32_t const   )3887607047U,      (uint32_t const   )2428444049U, 
        (uint32_t const   )498536548,      (uint32_t const   )1789927666,      (uint32_t const   )4089016648U,      (uint32_t const   )2227061214U, 
        (uint32_t const   )450548861,      (uint32_t const   )1843258603,      (uint32_t const   )4107580753U,      (uint32_t const   )2211677639U, 
        (uint32_t const   )325883990,      (uint32_t const   )1684777152,      (uint32_t const   )4251122042U,      (uint32_t const   )2321926636U, 
        (uint32_t const   )335633487,      (uint32_t const   )1661365465,      (uint32_t const   )4195302755U,      (uint32_t const   )2366115317U, 
        (uint32_t const   )997073096,      (uint32_t const   )1281953886,      (uint32_t const   )3579855332U,      (uint32_t const   )2724688242U, 
        (uint32_t const   )1006888145,      (uint32_t const   )1258607687,      (uint32_t const   )3524101629U,      (uint32_t const   )2768942443U, 
        (uint32_t const   )901097722,      (uint32_t const   )1119000684,      (uint32_t const   )3686517206U,      (uint32_t const   )2898065728U, 
        (uint32_t const   )853044451,      (uint32_t const   )1172266101,      (uint32_t const   )3705015759U,      (uint32_t const   )2882616665U, 
        (uint32_t const   )651767980,      (uint32_t const   )1373503546,      (uint32_t const   )3369554304U,      (uint32_t const   )3218104598U, 
        (uint32_t const   )565507253,      (uint32_t const   )1454621731,      (uint32_t const   )3485111705U,      (uint32_t const   )3099436303U, 
        (uint32_t const   )671266974,      (uint32_t const   )1594198024,      (uint32_t const   )3322730930U,      (uint32_t const   )2970347812U, 
        (uint32_t const   )795835527,      (uint32_t const   )1483230225,      (uint32_t const   )3244367275U,      (uint32_t const   )3060149565U, 
        (uint32_t const   )1994146192,      (uint32_t const   )31158534,      (uint32_t const   )2563907772U,      (uint32_t const   )4023717930U, 
        (uint32_t const   )1907459465,      (uint32_t const   )112637215,      (uint32_t const   )2680153253U,      (uint32_t const   )3904427059U, 
        (uint32_t const   )2013776290,      (uint32_t const   )251722036,      (uint32_t const   )2517215374U,      (uint32_t const   )3775830040U, 
        (uint32_t const   )2137656763,      (uint32_t const   )141376813,      (uint32_t const   )2439277719U,      (uint32_t const   )3865271297U, 
        (uint32_t const   )1802195444,      (uint32_t const   )476864866,      (uint32_t const   )2238001368U,      (uint32_t const   )4066508878U, 
        (uint32_t const   )1812370925,      (uint32_t const   )453092731,      (uint32_t const   )2181625025U,      (uint32_t const   )4111451223U, 
        (uint32_t const   )1706088902,      (uint32_t const   )314042704,      (uint32_t const   )2344532202U,      (uint32_t const   )4240017532U, 
        (uint32_t const   )1658658271,      (uint32_t const   )366619977,      (uint32_t const   )2362670323U,      (uint32_t const   )4224994405U, 
        (uint32_t const   )1303535960,      (uint32_t const   )984961486,      (uint32_t const   )2747007092U,      (uint32_t const   )3569037538U, 
        (uint32_t const   )1256170817,      (uint32_t const   )1037604311,      (uint32_t const   )2765210733U,      (uint32_t const   )3554079995U, 
        (uint32_t const   )1131014506,      (uint32_t const   )879679996,      (uint32_t const   )2909243462U,      (uint32_t const   )3663771856U, 
        (uint32_t const   )1141124467,      (uint32_t const   )855842277,      (uint32_t const   )2852801631U,      (uint32_t const   )3708648649U, 
        (uint32_t const   )1342533948,      (uint32_t const   )654459306,      (uint32_t const   )3188396048U,      (uint32_t const   )3373015174U, 
        (uint32_t const   )1466479909,      (uint32_t const   )544179635,      (uint32_t const   )3110523913U,      (uint32_t const   )3462522015U, 
        (uint32_t const   )1591671054,      (uint32_t const   )702138776,      (uint32_t const   )2966460450U,      (uint32_t const   )3352799412U, 
        (uint32_t const   )1504918807,      (uint32_t const   )783551873,      (uint32_t const   )3082640443U,      (uint32_t const   )3233442989U, 
        (uint32_t const   )3988292384U,      (uint32_t const   )2596254646U,      (uint32_t const   )62317068,      (uint32_t const   )1957810842, 
        (uint32_t const   )3939845945U,      (uint32_t const   )2647816111U,      (uint32_t const   )81470997,      (uint32_t const   )1943803523, 
        (uint32_t const   )3814918930U,      (uint32_t const   )2489596804U,      (uint32_t const   )225274430,      (uint32_t const   )2053790376, 
        (uint32_t const   )3826175755U,      (uint32_t const   )2466906013U,      (uint32_t const   )167816743,      (uint32_t const   )2097651377, 
        (uint32_t const   )4027552580U,      (uint32_t const   )2265490386U,      (uint32_t const   )503444072,      (uint32_t const   )1762050814, 
        (uint32_t const   )4150417245U,      (uint32_t const   )2154129355U,      (uint32_t const   )426522225,      (uint32_t const   )1852507879, 
        (uint32_t const   )4275313526U,      (uint32_t const   )2312317920U,      (uint32_t const   )282753626,      (uint32_t const   )1742555852, 
        (uint32_t const   )4189708143U,      (uint32_t const   )2394877945U,      (uint32_t const   )397917763,      (uint32_t const   )1622183637, 
        (uint32_t const   )3604390888U,      (uint32_t const   )2714866558U,      (uint32_t const   )953729732,      (uint32_t const   )1340076626, 
        (uint32_t const   )3518719985U,      (uint32_t const   )2797360999U,      (uint32_t const   )1068828381,      (uint32_t const   )1219638859, 
        (uint32_t const   )3624741850U,      (uint32_t const   )2936675148U,      (uint32_t const   )906185462,      (uint32_t const   )1090812512, 
        (uint32_t const   )3747672003U,      (uint32_t const   )2825379669U,      (uint32_t const   )829329135,      (uint32_t const   )1181335161, 
        (uint32_t const   )3412177804U,      (uint32_t const   )3160834842U,      (uint32_t const   )628085408,      (uint32_t const   )1382605366, 
        (uint32_t const   )3423369109U,      (uint32_t const   )3138078467U,      (uint32_t const   )570562233,      (uint32_t const   )1426400815, 
        (uint32_t const   )3317316542U,      (uint32_t const   )2998733608U,      (uint32_t const   )733239954,      (uint32_t const   )1555261956, 
        (uint32_t const   )3268935591U,      (uint32_t const   )3050360625U,      (uint32_t const   )752459403,      (uint32_t const   )1541320221, 
        (uint32_t const   )2607071920U,      (uint32_t const   )3965973030U,      (uint32_t const   )1969922972,      (uint32_t const   )40735498, 
        (uint32_t const   )2617837225U,      (uint32_t const   )3943577151U,      (uint32_t const   )1913087877,      (uint32_t const   )83908371, 
        (uint32_t const   )2512341634U,      (uint32_t const   )3803740692U,      (uint32_t const   )2075208622,      (uint32_t const   )213261112, 
        (uint32_t const   )2463272603U,      (uint32_t const   )3855990285U,      (uint32_t const   )2094854071,      (uint32_t const   )198958881, 
        (uint32_t const   )2262029012U,      (uint32_t const   )4057260610U,      (uint32_t const   )1759359992,      (uint32_t const   )534414190, 
        (uint32_t const   )2176718541U,      (uint32_t const   )4139329115U,      (uint32_t const   )1873836001,      (uint32_t const   )414664567, 
        (uint32_t const   )2282248934U,      (uint32_t const   )4279200368U,      (uint32_t const   )1711684554,      (uint32_t const   )285281116, 
        (uint32_t const   )2405801727U,      (uint32_t const   )4167216745U,      (uint32_t const   )1634467795,      (uint32_t const   )376229701, 
        (uint32_t const   )2685067896U,      (uint32_t const   )3608007406U,      (uint32_t const   )1308918612,      (uint32_t const   )956543938, 
        (uint32_t const   )2808555105U,      (uint32_t const   )3495958263U,      (uint32_t const   )1231636301,      (uint32_t const   )1047427035, 
        (uint32_t const   )2932959818U,      (uint32_t const   )3654703836U,      (uint32_t const   )1088359270,      (uint32_t const   )936918000, 
        (uint32_t const   )2847714899U,      (uint32_t const   )3736837829U,      (uint32_t const   )1202900863,      (uint32_t const   )817233897, 
        (uint32_t const   )3183342108U,      (uint32_t const   )3401237130U,      (uint32_t const   )1404277552,      (uint32_t const   )615818150, 
        (uint32_t const   )3134207493U,      (uint32_t const   )3453421203U,      (uint32_t const   )1423857449,      (uint32_t const   )601450431, 
        (uint32_t const   )3009837614U,      (uint32_t const   )3294710456U,      (uint32_t const   )1567103746,      (uint32_t const   )711928724, 
        (uint32_t const   )3020668471U,      (uint32_t const   )3272380065U,      (uint32_t const   )1510334235,      (uint32_t const   )755167117};
#line 94 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/crc32.c"
int crc32(int fd , uint32_t *main_val ) 
{ 
  char buf[16384] ;
  char *p ;
  int nr ;
  uint32_t crc ;
  int *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 99
  crc = (uint32_t )(~ 0);
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    tmp___1 = read(fd, (void *)(buf), sizeof(buf));
#line 102
    nr = (int )tmp___1;
    }
#line 102
    if (nr < 0) {
      {
#line 103
      tmp = __errno_location();
      }
#line 103
      if (*tmp == 4) {
#line 104
        goto while_continue;
      } else {
        {
#line 103
        tmp___0 = __errno_location();
        }
#line 103
        if (*tmp___0 == 11) {
#line 104
          goto while_continue;
        }
      }
#line 105
      goto while_break;
    }
#line 107
    if (nr == 0) {
#line 108
      goto while_break;
    }
#line 109
    p = buf;
    {
#line 109
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 109
      tmp___2 = nr;
#line 109
      nr --;
#line 109
      if (! tmp___2) {
#line 109
        goto while_break___0;
      }
#line 110
      crc = (crc >> 8) ^ (unsigned int )crctable[(crc ^ (unsigned int )*p) & 255U];
#line 109
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  if (nr < 0) {
#line 113
    return (1);
  }
#line 115
  *main_val = ~ crc;
#line 116
  return (0);
}
}
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/cksfv.h"
int use_basename ;
#line 21
int be_quiet ;
#line 31
void pusage(void) ;
#line 33
void pnsfv_head(void) ;
#line 34
void pfileinfo(char **argv ) ;
#line 35
void pcrc(char *fn , uint32_t val ) ;
#line 37
void prsfv_head(char *fn ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/print.c"
void pnsfv_head(void) 
{ 
  time_t clock___0 ;
  struct tm *timeinfo ;
  struct tm ti ;

  {
  {
#line 39
  clock___0 = time((time_t *)((void *)0));
#line 40
  timeinfo = localtime((time_t const   *)(& clock___0));
  }
#line 41
  if ((unsigned long )timeinfo == (unsigned long )((void *)0)) {
    {
#line 42
    memset((void *)(& ti), 0, sizeof(ti));
#line 43
    ti.tm_year = 70;
#line 44
    timeinfo = & ti;
    }
  }
  {
#line 46
  printf((char const   */* __restrict  */)"; Generated by cksfv v%s on ", "1.3.14");
#line 47
  printf((char const   */* __restrict  */)"%02d-%02d-%02d at %02d:%02d.%02d\n", timeinfo->tm_year + 1900,
         timeinfo->tm_mon + 1, timeinfo->tm_mday, timeinfo->tm_hour, timeinfo->tm_min,
         timeinfo->tm_sec);
#line 50
  printf((char const   */* __restrict  */)"; Project web site: %s\n", "http://www.iki.fi/shd/foss/cksfv/");
  }
#line 51
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/print.c"
void pfileinfo(char **argv ) 
{ 
  char *fn ;
  struct stat sb ;
  struct tm *timeinfo ;
  char *tmpname ;
  char *fname ;
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 61
  printf((char const   */* __restrict  */)";\n");
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! *argv) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp = argv;
#line 64
    argv ++;
#line 64
    fn = *tmp;
#line 65
    tmp___0 = stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& sb));
    }
#line 65
    if (! tmp___0) {
#line 66
      if (! ((sb.st_mode & 61440U) == 16384U)) {
#line 68
        tmpname = (char *)((void *)0);
#line 69
        if (use_basename) {
          {
#line 70
          tmpname = strdup((char const   *)fn);
          }
#line 70
          if ((unsigned long )tmpname == (unsigned long )((void *)0)) {
#line 71
            if (! (be_quiet >= 2)) {
              {
#line 72
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"out of memory\n");
              }
            }
            {
#line 73
            exit(1);
            }
          }
          {
#line 75
          fname = __xpg_basename(tmpname);
          }
        } else {
#line 77
          fname = fn;
        }
        {
#line 80
        timeinfo = localtime((time_t const   *)(& sb.st_mtim.tv_sec));
#line 81
        printf((char const   */* __restrict  */)";%13lu  %02d:%02d.%02d %02d-%02d-%02d %s\n",
               (unsigned long )sb.st_size, timeinfo->tm_hour, timeinfo->tm_min, timeinfo->tm_sec,
               timeinfo->tm_year + 1900, timeinfo->tm_mon + 1, timeinfo->tm_mday,
               fname);
        }
#line 86
        if (use_basename) {
          {
#line 87
          free((void *)tmpname);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/print.c"
void pcrc(char *fn , uint32_t val ) 
{ 


  {
  {
#line 95
  printf((char const   */* __restrict  */)"%s %.8X\n", fn, val);
  }
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/print.c"
void prsfv_head(char *fn ) 
{ 
  char head[82] ;
  char *p ;
  int len ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 105
  snprintf((char */* __restrict  */)(head), (size_t )80, (char const   */* __restrict  */)"--( Verifying: %s",
           fn);
#line 106
  tmp = strlen((char const   *)(head));
#line 106
  len = (int )tmp;
  }
#line 107
  if (len < 76) {
#line 108
    p = head + len;
#line 109
    tmp___0 = p;
#line 109
    p ++;
#line 109
    *tmp___0 = (char )' ';
#line 110
    tmp___1 = p;
#line 110
    p ++;
#line 110
    *tmp___1 = (char )')';
#line 112
    p = (head + len) + 2;
#line 112
    len = 78 - len;
    {
#line 112
    while (1) {
      while_continue: /* CIL Label */ ;
#line 112
      tmp___2 = len;
#line 112
      len --;
#line 112
      if (! tmp___2) {
#line 112
        goto while_break;
      }
#line 113
      *p = (char )'-';
#line 112
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 115
    p = head + 76;
#line 116
    tmp___3 = p;
#line 116
    p ++;
#line 116
    *tmp___3 = (char )' ';
#line 117
    tmp___4 = p;
#line 117
    p ++;
#line 117
    *tmp___4 = (char )')';
#line 118
    tmp___5 = p;
#line 118
    p ++;
#line 118
    *tmp___5 = (char )'-';
#line 119
    tmp___6 = p;
#line 119
    p ++;
#line 119
    *tmp___6 = (char )'-';
  }
  {
#line 121
  head[80] = (char )'\n';
#line 122
  head[81] = (char )'\000';
#line 123
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          head);
  }
#line 124
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/print.c"
void pusage(void) 
{ 


  {
  {
#line 128
  printf((char const   */* __restrict  */)"cksfv v%s: %s\n", "1.3.14", "http://www.iki.fi/shd/foss/cksfv/");
#line 129
  printf((char const   */* __restrict  */)"\nusage: cksfv [-bciq] [-C dir] [-f file] [-g path] [file ...]\n\n -b\t\tprint only the basename when creating an sfv (no directory\n\t\tcomponent)\n -c\t\tuse stdout for printing progress and final resolution (useful\n\t\tfor external tools analysing cksfv output)\n -C dir\t\tchange to directory for processing\n -f file\tVerify the sfv file\n -g path\tGo to the path name directory and verify the sfv file.\n\t\tYou probably want this option instead of -f.\n -i\t\tignore case on filenames\n -L\t\tfollow symlinks in recursive mode\n -q\t\tquiet, only prints error messages\n -r\t\trecursively check .sfv files in subdirectories\n -s\t\treplace backslashes with slashes on filenames\n -v\t\tverbose, by default this option is on\n\nExample 1: Verify an sfv file in directory foo/\n\n\tcksfv -g foo/bar.sfv\n\n");
#line 151
  exit(1);
  }
}
}
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 220 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/cksfv.h"
int newsfv(char **argv ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/newsfv.c"
int newsfv(char **argv ) 
{ 
  int fd ;
  int rval ;
  char *fn ;
  uint32_t val ;
  char *tmpname ;
  struct stat st ;
  char **tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 37
  rval = 0;
#line 43
  pnsfv_head();
#line 44
  pfileinfo(argv);
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! *argv) {
#line 46
      goto while_break;
    }
    {
#line 47
    tmp = argv;
#line 47
    argv ++;
#line 47
    fn = *tmp;
#line 48
    fd = open((char const   *)fn, 0, 0);
    }
#line 48
    if (fd < 0) {
#line 49
      if (! (be_quiet >= 2)) {
        {
#line 50
        tmp___0 = __errno_location();
#line 50
        tmp___1 = strerror(*tmp___0);
#line 50
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: %s: %s\n",
                fn, tmp___1);
        }
      }
#line 51
      rval = 1;
#line 52
      goto while_continue;
    }
    {
#line 54
    tmp___4 = fstat(fd, & st);
    }
#line 54
    if (tmp___4) {
#line 55
      if (! (be_quiet >= 2)) {
        {
#line 56
        tmp___2 = __errno_location();
#line 56
        tmp___3 = strerror(*tmp___2);
#line 56
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: can not fstat %s: %s\n",
                fn, tmp___3);
        }
      }
#line 58
      rval = 1;
#line 59
      goto next;
    }
#line 61
    if ((st.st_mode & 61440U) == 16384U) {
#line 62
      if (! (be_quiet >= 2)) {
        {
#line 63
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: %s: Is a directory\n",
                fn);
        }
      }
#line 64
      rval = 1;
#line 65
      goto next;
    }
    {
#line 67
    tmp___8 = crc32(fd, & val);
    }
#line 67
    if (tmp___8) {
#line 68
      if (! (be_quiet >= 2)) {
        {
#line 69
        tmp___5 = __errno_location();
#line 69
        tmp___6 = strerror(*tmp___5);
#line 69
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: %s: %s\n",
                fn, tmp___6);
        }
      }
#line 70
      rval = 1;
    } else
#line 72
    if (use_basename) {
      {
#line 73
      tmpname = strdup((char const   *)fn);
      }
#line 73
      if ((unsigned long )tmpname == (unsigned long )((void *)0)) {
#line 74
        if (! (be_quiet >= 2)) {
          {
#line 75
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"out of memory\n");
          }
        }
        {
#line 76
        exit(1);
        }
      }
      {
#line 78
      tmp___7 = __xpg_basename(tmpname);
#line 78
      pcrc(tmp___7, val);
#line 79
      free((void *)tmpname);
      }
    } else {
      {
#line 81
      pcrc(fn, val);
      }
    }
    next: 
    {
#line 85
    close(fd);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (rval);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 22 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/cksfv.h"
int be_caseinsensitive ;
#line 23
int be_backslashinsensitive ;
#line 24
char **sfv_broken_list ;
#line 25
int sfv_broken ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/cksfv.h"
FILE *progress_file  ;
#line 28
int readsfv(char *fn , char *dir , int argc , char **argv ) ;
#line 29
int recursivereadsfv(char *dir , int follow , int argc , char **argv ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/cksfv.c"
int use_basename  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/cksfv.c"
int be_quiet  =    0;
#line 29 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/cksfv.c"
int be_caseinsensitive  =    0;
#line 30 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/cksfv.c"
int be_backslashinsensitive  =    0;
#line 34 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/cksfv.c"
int main(int argc , char **argv ) 
{ 
  int ch ;
  int rval ;
  int rsfvflag ;
  char dir[4096] ;
  unsigned int tmp ;
  char sfvfile[4096] ;
  int follow ;
  int i ;
  int dir_set ;
  int recurse ;
  char *newdir ;

  {
#line 37
  rsfvflag = 0;
#line 38
  dir[0] = (char )'.';
#line 38
  dir[1] = (char )'\000';
#line 38
  tmp = 2U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (tmp >= 4096U) {
#line 38
      goto while_break;
    }
#line 38
    dir[tmp] = (char)0;
#line 38
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  follow = 0;
#line 42
  dir_set = 0;
#line 43
  recurse = 0;
#line 45
  progress_file = stderr;
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 47
    ch = getopt(argc, (char * const  *)argv, "icC:f:g:qvbrLs");
    }
#line 47
    if (! (ch != -1)) {
#line 47
      goto while_break___0;
    }
    {
#line 49
    if (ch == 105) {
#line 49
      goto case_105;
    }
#line 52
    if (ch == 115) {
#line 52
      goto case_115;
    }
#line 55
    if (ch == 99) {
#line 55
      goto case_99;
    }
#line 58
    if (ch == 67) {
#line 58
      goto case_67;
    }
#line 63
    if (ch == 102) {
#line 63
      goto case_102;
    }
#line 68
    if (ch == 103) {
#line 68
      goto case_103;
    }
#line 73
    if (ch == 76) {
#line 73
      goto case_76;
    }
#line 80
    if (ch == 113) {
#line 80
      goto case_113;
    }
#line 83
    if (ch == 118) {
#line 83
      goto case_118;
    }
#line 86
    if (ch == 98) {
#line 86
      goto case_98;
    }
#line 89
    if (ch == 114) {
#line 89
      goto case_114;
    }
#line 93
    goto switch_default;
    case_105: /* CIL Label */ 
#line 50
    be_caseinsensitive = 1;
#line 51
    goto switch_break;
    case_115: /* CIL Label */ 
#line 53
    be_backslashinsensitive = 1;
#line 54
    goto switch_break;
    case_99: /* CIL Label */ 
#line 56
    progress_file = stdout;
#line 57
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 59
    strncpy((char */* __restrict  */)(dir), (char const   */* __restrict  */)optarg,
            sizeof(dir));
#line 60
    dir[sizeof(dir) - 1UL] = (char)0;
#line 61
    dir_set = 1;
    }
#line 62
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 64
    strncpy((char */* __restrict  */)(sfvfile), (char const   */* __restrict  */)optarg,
            sizeof(sfvfile));
#line 65
    sfvfile[sizeof(sfvfile) - 1UL] = (char)0;
#line 66
    rsfvflag = 1;
    }
#line 67
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 69
    strncpy((char */* __restrict  */)(sfvfile), (char const   */* __restrict  */)optarg,
            sizeof(sfvfile));
#line 70
    sfvfile[sizeof(sfvfile) - 1UL] = (char)0;
#line 71
    rsfvflag = 2;
    }
#line 72
    goto switch_break;
    case_76: /* CIL Label */ 
#line 75
    follow = 1;
#line 79
    goto switch_break;
    case_113: /* CIL Label */ 
#line 81
    be_quiet ++;
#line 82
    goto switch_break;
    case_118: /* CIL Label */ 
#line 84
    be_quiet = 0;
#line 85
    goto switch_break;
    case_98: /* CIL Label */ 
#line 87
    use_basename = 1;
#line 88
    goto switch_break;
    case_114: /* CIL Label */ 
#line 90
    recurse = 1;
#line 91
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 94
    pusage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 96
  argc -= optind;
#line 97
  argv += optind;
#line 99
  if (recurse) {
#line 99
    if (rsfvflag) {
      {
#line 100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: you may not specify both -r and -f/-g\n");
#line 101
      exit(1);
      }
    }
  }
#line 104
  if (dir_set) {
#line 104
    if (rsfvflag == 2) {
      {
#line 105
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: you may not specify both -C and -g\n");
#line 106
      exit(1);
      }
    }
  }
#line 109
  if (recurse) {
    {
#line 110
    rval = recursivereadsfv(dir, follow, argc, argv);
    }
  } else
#line 112
  if (rsfvflag) {
#line 114
    if (rsfvflag == 1) {
      {
#line 115
      rval = readsfv(sfvfile, dir, argc, argv);
      }
    } else
#line 117
    if (rsfvflag == 2) {
      {
#line 122
      strcpy((char */* __restrict  */)(dir), (char const   */* __restrict  */)(sfvfile));
#line 123
      newdir = strrchr((char const   *)(dir), '/');
      }
#line 124
      if (newdir) {
#line 125
        *newdir = (char)0;
      } else {
        {
#line 127
        strcpy((char */* __restrict  */)(dir), (char const   */* __restrict  */)".");
        }
      }
      {
#line 129
      rval = readsfv(sfvfile, dir, argc, argv);
      }
    } else {
      {
#line 131
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rsfvflag > 2. Please report this bug!\n");
#line 132
      exit(1);
      }
    }
  } else {
#line 136
    if (argc < 1) {
      {
#line 137
      pusage();
      }
    }
    {
#line 139
    rval = newsfv(argv);
    }
  }
#line 142
  if (! (be_quiet >= 2)) {
#line 142
    if (recurse) {
#line 142
      if (sfv_broken) {
        {
#line 143
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nList of sfv files with broken files (or broken sfv files):\n");
#line 145
        i = 0;
        }
        {
#line 145
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 145
          if (! (i < sfv_broken)) {
#line 145
            goto while_break___1;
          }
          {
#line 146
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                  *(sfv_broken_list + i));
#line 145
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 148
  exit(rval);
  }
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 208
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) rewinddir)(DIR *__dirp ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 267 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf )  __asm__("lstat64")  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/readsfv.c"
static int find_file(char *filename , char *dir ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/readsfv.c"
char **sfv_broken_list  =    (char **)((void *)0);
#line 39 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/readsfv.c"
int sfv_broken  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/readsfv.c"
static void add_broken_entry(char *fn , char *dir ) 
{ 
  char sfvname[4097] ;
  char **new_broken ;
  void *tmp ;

  {
  {
#line 48
  sfv_broken ++;
#line 49
  tmp = realloc((void *)sfv_broken_list, (unsigned long )sfv_broken * sizeof(char **));
#line 49
  new_broken = (char **)tmp;
  }
#line 50
  if (new_broken) {
    {
#line 51
    sfv_broken_list = new_broken;
#line 52
    snprintf((char */* __restrict  */)(sfvname), sizeof(sfvname), (char const   */* __restrict  */)"%s/%s",
             dir, fn);
#line 53
    *(sfv_broken_list + (sfv_broken - 1)) = strdup((char const   *)(sfvname));
    }
  } else {
    {
#line 55
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: very annoying... no space for broken list...\n");
#line 57
    sfv_broken --;
    }
  }
#line 59
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/readsfv.c"
int readsfv(char *fn , char *dir , int argc , char **argv ) 
{ 
  FILE *fd ;
  char buf[4352] ;
  char *filename ;
  int file ;
  int rval ;
  uint32_t sfvcrc ;
  uint32_t val ;
  size_t i ;
  size_t checksumstart ;
  size_t checksumend ;
  size_t linelen ;
  int j ;
  int check ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned long tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;

  {
#line 67
  rval = 0;
#line 78
  if (! (be_quiet >= 1)) {
    {
#line 79
    prsfv_head(fn);
    }
  }
  {
#line 81
  fd = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 82
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 83
    if (! (be_quiet >= 2)) {
      {
#line 84
      tmp = __errno_location();
#line 84
      tmp___0 = strerror(*tmp);
#line 84
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: %s: %s\n",
              fn, tmp___0);
      }
    }
#line 85
    return (1);
  }
  {
#line 87
  tmp___3 = fileno(fd);
#line 87
  tmp___4 = fstat(tmp___3, & st);
  }
#line 87
  if (tmp___4) {
#line 88
    if (! (be_quiet >= 2)) {
      {
#line 89
      tmp___1 = __errno_location();
#line 89
      tmp___2 = strerror(*tmp___1);
#line 89
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: can not fstat %s: %s\n",
              fn, tmp___2);
      }
    }
    {
#line 90
    fclose(fd);
    }
#line 91
    return (1);
  }
#line 93
  if ((st.st_mode & 61440U) == 16384U) {
#line 94
    if (! (be_quiet >= 2)) {
      {
#line 95
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: %s: Is a directory\n",
              fn);
      }
    }
    {
#line 96
    fclose(fd);
    }
#line 97
    return (1);
  }
  {
#line 100
  tmp___7 = chdir((char const   *)dir);
  }
#line 100
  if (tmp___7 != 0) {
#line 101
    if (! (be_quiet >= 2)) {
      {
#line 102
      tmp___5 = __errno_location();
#line 102
      tmp___6 = strerror(*tmp___5);
#line 102
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: %s: %s\n",
              dir, tmp___6);
      }
    }
#line 103
    goto error;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    tmp___9 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fd);
    }
#line 107
    if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
      {
#line 108
      tmp___8 = feof(fd);
      }
#line 108
      if (tmp___8) {
#line 109
        goto while_break;
      }
#line 111
      goto while_continue;
    }
#line 115
    if ((int )buf[0] == 59) {
#line 116
      goto while_continue;
    } else
#line 115
    if ((int )buf[0] == 10) {
#line 116
      goto while_continue;
    } else
#line 115
    if ((int )buf[0] == 13) {
#line 116
      goto while_continue;
    }
    {
#line 118
    linelen = strlen((char const   *)(buf));
#line 121
    i = linelen - 1UL;
    }
    {
#line 122
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 122
      tmp___10 = __ctype_b_loc();
      }
#line 122
      if ((int const   )*(*tmp___10 + (int )buf[i]) & 8192) {
#line 122
        if (! (i > 0UL)) {
#line 122
          goto while_break___0;
        }
      } else {
#line 122
        goto while_break___0;
      }
#line 123
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 124
    if (! i) {
#line 125
      goto while_continue;
    }
#line 128
    checksumend = i + 1UL;
    {
#line 131
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 131
      if (! (i > 0UL)) {
#line 131
        goto while_break___1;
      }
      {
#line 132
      tmp___11 = __ctype_b_loc();
      }
#line 132
      if (! ((int const   )*(*tmp___11 + (int )buf[i]) & 4096)) {
#line 133
        goto while_break___1;
      }
#line 134
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 136
    checksumstart = i + 1UL;
#line 137
    if (i == 0UL) {
#line 137
      goto _L;
    } else
#line 137
    if (checksumend - checksumstart != 8UL) {
      _L: /* CIL Label */ 
#line 138
      if (! (be_quiet >= 2)) {
        {
#line 139
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: checksum should contain 8 hexdigits: %s\n",
                buf);
        }
      }
#line 140
      goto error;
    }
    {
#line 144
    buf[i] = (char )'\000';
#line 145
    buf[checksumend] = (char )'\000';
#line 147
    tmp___12 = strtoul((char const   */* __restrict  */)(& buf[checksumstart]), (char **/* __restrict  */)((void *)0),
                       16);
#line 147
    sfvcrc = (uint32_t )tmp___12;
#line 149
    filename = buf;
    }
#line 151
    if (argc) {
#line 152
      check = 0;
#line 153
      j = 0;
      {
#line 153
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 153
        if (! (j < argc)) {
#line 153
          goto while_break___2;
        }
#line 154
        if ((unsigned long )*(argv + j) == (unsigned long )((void *)0)) {
#line 155
          goto __Cont;
        }
#line 156
        if (be_caseinsensitive != 0) {
          {
#line 156
          tmp___13 = strcasecmp((char const   *)*(argv + j), (char const   *)filename);
          }
#line 156
          if (tmp___13 == 0) {
#line 160
            check = 1;
#line 161
            *(argv + j) = (char *)((void *)0);
#line 162
            goto while_break___2;
          } else {
#line 156
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 156
        if (be_caseinsensitive == 0) {
          {
#line 156
          tmp___14 = strcmp((char const   *)*(argv + j), (char const   *)filename);
          }
#line 156
          if (tmp___14 == 0) {
#line 160
            check = 1;
#line 161
            *(argv + j) = (char *)((void *)0);
#line 162
            goto while_break___2;
          }
        }
        __Cont: /* CIL Label */ 
#line 153
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 165
      if (check == 0) {
#line 166
        goto while_continue;
      }
    }
    {
#line 169
    tmp___15 = strlen((char const   *)filename);
    }
#line 169
    if (tmp___15 >= 4096UL) {
#line 170
      if (! (be_quiet >= 2)) {
        {
#line 171
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: filename too long\n");
        }
      }
#line 172
      rval = 1;
#line 173
      goto while_continue;
    }
#line 177
    if (be_backslashinsensitive == 1) {
#line 178
      j = 0;
#line 179
      j = 0;
      {
#line 179
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 179
        if (! ((int )*(filename + j) != 0)) {
#line 179
          goto while_break___3;
        }
#line 180
        if ((int )*(filename + j) == 92) {
#line 181
          *(filename + j) = (char )'/';
        }
#line 179
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 185
    if (! (be_quiet >= 1)) {
      {
#line 186
      fprintf((FILE */* __restrict  */)progress_file, (char const   */* __restrict  */)"%-49s ",
              filename);
#line 187
      fflush(progress_file);
      }
    }
    {
#line 191
    file = open((char const   *)filename, 0, 0);
    }
#line 191
    if (file < 0) {
#line 193
      if (be_caseinsensitive == 1) {
        {
#line 195
        find_file(filename, dir);
#line 196
        file = open((char const   *)filename, 0, 0);
        }
      }
    }
#line 202
    if (file < 0) {
#line 203
      if (! (be_quiet >= 1)) {
        {
#line 204
        tmp___16 = __errno_location();
#line 204
        tmp___17 = strerror(*tmp___16);
#line 204
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                tmp___17);
        }
      } else
#line 205
      if (! (be_quiet >= 2)) {
        {
#line 206
        tmp___18 = __errno_location();
#line 206
        tmp___19 = strerror(*tmp___18);
#line 206
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: %s: %s\n",
                filename, tmp___19);
        }
      }
#line 208
      rval = 1;
#line 209
      goto while_continue;
    }
    {
#line 212
    tmp___22 = fstat(file, & st);
    }
#line 212
    if (tmp___22) {
#line 213
      if (! (be_quiet >= 1)) {
        {
#line 214
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can not fstat\n");
        }
      } else
#line 215
      if (! (be_quiet >= 2)) {
        {
#line 216
        tmp___20 = __errno_location();
#line 216
        tmp___21 = strerror(*tmp___20);
#line 216
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: can not fstat %s: %s\n",
                filename, tmp___21);
        }
      }
#line 219
      rval = 1;
#line 220
      goto next;
    }
#line 222
    if ((st.st_mode & 61440U) == 16384U) {
#line 223
      if (! (be_quiet >= 1)) {
        {
#line 224
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Is a directory\n");
        }
      } else
#line 225
      if (! (be_quiet >= 2)) {
        {
#line 226
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: %s: Is a directory\n",
                filename);
        }
      }
#line 228
      rval = 1;
#line 229
      goto next;
    }
    {
#line 232
    tmp___27 = crc32(file, & val);
    }
#line 232
    if (tmp___27) {
#line 234
      if (! (be_quiet >= 1)) {
        {
#line 235
        tmp___23 = __errno_location();
#line 235
        tmp___24 = strerror(*tmp___23);
#line 235
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                tmp___24);
        }
      } else
#line 236
      if (! (be_quiet >= 2)) {
        {
#line 237
        tmp___25 = __errno_location();
#line 237
        tmp___26 = strerror(*tmp___25);
#line 237
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: %s: %s\n",
                filename, tmp___26);
        }
      }
#line 239
      rval = 1;
    } else
#line 241
    if (val != sfvcrc) {
#line 242
      if (! (be_quiet >= 1)) {
        {
#line 243
        fprintf((FILE */* __restrict  */)progress_file, (char const   */* __restrict  */)"different CRC\n");
#line 244
        fflush(progress_file);
        }
      } else
#line 245
      if (! (be_quiet >= 2)) {
        {
#line 246
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: %s: Has a different CRC\n",
                filename);
        }
      }
#line 248
      rval = 1;
    } else
#line 249
    if (! (be_quiet >= 1)) {
      {
#line 250
      fprintf((FILE */* __restrict  */)progress_file, (char const   */* __restrict  */)"OK\n");
#line 251
      fflush(progress_file);
      }
    }
    next: 
    {
#line 255
    close(file);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 258
  fclose(fd);
  }
#line 260
  if (argc) {
#line 261
    j = 0;
    {
#line 261
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 261
      if (! (j < argc)) {
#line 261
        goto while_break___4;
      }
#line 262
      if (*(argv + j)) {
#line 263
        if (! (be_quiet >= 1)) {
          {
#line 264
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-49s not found in sfv\n",
                  *(argv + j));
          }
        } else
#line 265
        if (! (be_quiet >= 2)) {
          {
#line 266
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: %s: not found in sfv\n",
                  *(argv + j));
          }
        }
#line 269
        rval = 1;
      }
#line 261
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 274
  if (! (be_quiet >= 1)) {
    {
#line 275
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--------------------------------------------------------------------------------\n");
    }
#line 277
    if (rval == 0) {
#line 277
      tmp___28 = "Everything OK";
    } else {
#line 277
      tmp___28 = "Errors Occured";
    }
    {
#line 277
    fprintf((FILE */* __restrict  */)progress_file, (char const   */* __restrict  */)"%s\a\n",
            tmp___28);
#line 279
    fflush(progress_file);
    }
  }
#line 282
  if (rval) {
    {
#line 283
    add_broken_entry(fn, dir);
    }
  }
#line 285
  return (rval);
  error: 
  {
#line 288
  fclose(fd);
#line 289
  add_broken_entry(fn, dir);
  }
#line 290
  return (1);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/readsfv.c"
static int find_file(char *filename , char *dir ) 
{ 
  DIR *dirp ;
  struct dirent *dirinfo ;
  char *foo ;
  char *bar ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
  {
#line 301
  dirp = opendir(".");
  }
#line 302
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 303
    if (! (be_quiet >= 1)) {
      {
#line 304
      tmp = __errno_location();
#line 304
      tmp___0 = strerror(*tmp);
#line 304
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
              tmp___0);
      }
    } else
#line 305
    if (! (be_quiet >= 2)) {
      {
#line 306
      tmp___1 = __errno_location();
#line 306
      tmp___2 = strerror(*tmp___1);
#line 306
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: %s: %s\n",
              dir, tmp___2);
      }
    }
#line 308
    return (0);
  }
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 311
    dirinfo = readdir(dirp);
    }
#line 311
    if (! ((unsigned long )dirinfo != (unsigned long )((void *)0))) {
#line 311
      goto while_break;
    }
#line 312
    foo = filename;
#line 312
    bar = dirinfo->d_name;
    {
#line 312
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 312
      if (! ((int )*foo != 0)) {
#line 312
        if (! ((int )*bar != 0)) {
#line 312
          goto while_break___0;
        }
      }
#line 314
      if ((int )*foo != (int )*bar) {
        {
#line 315
        tmp___5 = __ctype_b_loc();
        }
#line 315
        if ((int const   )*(*tmp___5 + (int )*foo) & 1024) {
          {
#line 315
          tmp___6 = __ctype_b_loc();
          }
#line 315
          if ((int const   )*(*tmp___6 + (int )*bar) & 1024) {
            {
#line 316
            tmp___3 = tolower((int )*foo);
#line 316
            tmp___4 = tolower((int )*bar);
            }
#line 316
            if (tmp___3 != tmp___4) {
#line 317
              goto while_break___0;
            }
          } else {
#line 315
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 320
        if ((int )*foo == 95) {
#line 320
          goto _L;
        } else
#line 320
        if ((int )*foo == 32) {
          _L: /* CIL Label */ 
#line 320
          if (! ((int )*bar == 95)) {
#line 320
            if (! ((int )*bar == 32)) {
#line 322
              goto while_break___0;
            }
          }
        } else {
#line 322
          goto while_break___0;
        }
      }
#line 312
      foo ++;
#line 312
      bar ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 327
    if ((int )*foo == 0) {
#line 327
      if ((int )*bar == 0) {
        {
#line 328
        strcpy((char */* __restrict  */)filename, (char const   */* __restrict  */)(dirinfo->d_name));
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 330
  rewinddir(dirp);
  }
#line 331
  return (1);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/cksfv-1.3.14/src/readsfv.c"
int recursivereadsfv(char *dir , int follow , int argc , char **argv ) 
{ 
  DIR *dirp ;
  struct dirent *dirinfo ;
  char cwd[4097] ;
  struct stat dirstat ;
  int ret ;
  int finalret ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char processdir[4096] ;
  int *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;

  {
  {
#line 342
  finalret = 0;
#line 344
  tmp___1 = getcwd(cwd, sizeof(cwd));
  }
#line 344
  if (! tmp___1) {
#line 345
    if (! (be_quiet >= 1)) {
      {
#line 346
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getcwd:\n");
      }
    } else
#line 347
    if (! (be_quiet >= 2)) {
      {
#line 348
      tmp = __errno_location();
#line 348
      tmp___0 = strerror(*tmp);
#line 348
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getcwd: %s\n",
              tmp___0);
      }
    }
#line 350
    return (1);
  }
#line 353
  if (dir) {
    {
#line 353
    tmp___5 = strcmp((char const   *)dir, ".");
    }
#line 353
    if (tmp___5 != 0) {
      {
#line 354
      tmp___4 = chdir((char const   *)dir);
      }
#line 354
      if (tmp___4 == -1) {
#line 355
        if (! (be_quiet >= 1)) {
          {
#line 356
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"chdir:\n");
          }
        } else
#line 357
        if (! (be_quiet >= 2)) {
          {
#line 358
          tmp___2 = __errno_location();
#line 358
          tmp___3 = strerror(*tmp___2);
#line 358
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: cannot chdir to %s: %s\n",
                  dir, tmp___3);
          }
        }
#line 361
        return (1);
      }
    }
  }
  {
#line 365
  dirp = opendir(".");
  }
#line 367
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 368
    if (! (be_quiet >= 1)) {
      {
#line 369
      tmp___6 = __errno_location();
#line 369
      tmp___7 = strerror(*tmp___6);
#line 369
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
              tmp___7);
      }
    } else
#line 370
    if (! (be_quiet >= 2)) {
      {
#line 371
      tmp___8 = __errno_location();
#line 371
      tmp___9 = strerror(*tmp___8);
#line 371
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: %s: %s\n",
              dir, tmp___9);
      }
    }
#line 373
    return (1);
  }
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 376
    dirinfo = readdir(dirp);
    }
#line 376
    if (! ((unsigned long )dirinfo != (unsigned long )((void *)0))) {
#line 376
      goto while_break;
    }
    {
#line 378
    tmp___10 = strcmp((char const   *)(dirinfo->d_name), ".");
    }
#line 378
    if (tmp___10 == 0) {
#line 379
      goto while_continue;
    }
    {
#line 381
    tmp___11 = strcmp((char const   *)(dirinfo->d_name), "..");
    }
#line 381
    if (tmp___11 == 0) {
#line 382
      goto while_continue;
    }
#line 385
    if (! follow) {
      {
#line 386
      ret = lstat((char const   */* __restrict  */)(dirinfo->d_name), (struct stat */* __restrict  */)(& dirstat));
      }
    } else {
      {
#line 389
      ret = stat((char const   */* __restrict  */)(dirinfo->d_name), (struct stat */* __restrict  */)(& dirstat));
      }
    }
#line 391
    if (ret == -1) {
#line 392
      if (! (be_quiet >= 1)) {
        {
#line 393
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot fstat\n");
        }
      } else
#line 394
      if (! (be_quiet >= 2)) {
        {
#line 395
        tmp___12 = __errno_location();
#line 395
        tmp___13 = strerror(*tmp___12);
#line 395
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: cannot stat %s: %s\n",
                dirinfo->d_name, tmp___13);
        }
      }
      {
#line 398
      closedir(dirp);
      }
#line 399
      return (1);
    }
#line 402
    if ((dirstat.st_mode & 61440U) == 16384U) {
      {
#line 404
      tmp___14 = recursivereadsfv(dirinfo->d_name, follow, argc, argv);
      }
#line 404
      if (tmp___14) {
#line 405
        finalret = 1;
      }
    } else
#line 407
    if ((dirstat.st_mode & 61440U) == 32768U) {
      {
#line 407
      tmp___19 = strlen((char const   *)(dirinfo->d_name));
      }
#line 407
      if (tmp___19 > 4UL) {
        {
#line 407
        tmp___20 = strlen((char const   *)(dirinfo->d_name));
#line 407
        tmp___21 = strcasecmp((char const   *)((dirinfo->d_name + tmp___20) - 4),
                              ".sfv");
        }
#line 407
        if (tmp___21 == 0) {
          {
#line 413
          tmp___17 = getcwd(processdir, sizeof(processdir));
          }
#line 413
          if (! tmp___17) {
#line 415
            if (! (be_quiet >= 1)) {
              {
#line 416
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getcwd:\n");
              }
            } else
#line 417
            if (! (be_quiet >= 2)) {
              {
#line 418
              tmp___15 = __errno_location();
#line 418
              tmp___16 = strerror(*tmp___15);
#line 418
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getcwd: %s\n",
                      tmp___16);
              }
            }
            {
#line 421
            closedir(dirp);
            }
#line 423
            return (1);
          }
#line 426
          if (! (be_quiet >= 1)) {
            {
#line 427
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering directory: %s\n",
                    processdir);
            }
          }
          {
#line 429
          tmp___18 = readsfv(dirinfo->d_name, processdir, argc, argv);
          }
#line 429
          if (tmp___18) {
#line 430
            finalret = 1;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 434
  tmp___24 = chdir((char const   *)(cwd));
  }
#line 434
  if (tmp___24 == -1) {
#line 435
    if (! (be_quiet >= 1)) {
      {
#line 436
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"chdir:\n");
      }
    } else
#line 437
    if (! (be_quiet >= 2)) {
      {
#line 438
      tmp___22 = __errno_location();
#line 438
      tmp___23 = strerror(*tmp___22);
#line 438
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cksfv: cannot chdir to %s: %s\n",
              cwd, tmp___23);
      }
    }
#line 441
    return (1);
  }
  {
#line 444
  closedir(dirp);
  }
#line 446
  return (finalret);
}
}
