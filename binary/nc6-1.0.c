/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 32 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.h"
struct circ_buf {
   uint8_t *buf ;
   uint8_t *ptr ;
   size_t data_size ;
   size_t buf_size ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.h"
typedef struct circ_buf circ_buf_t;
#line 28 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.h"
struct io_stream {
   int fd_in ;
   int fd_out ;
   int socktype ;
   int flags ;
   circ_buf_t *buf_in ;
   circ_buf_t *buf_out ;
   size_t mtu ;
   size_t nru ;
   _Bool half_close_suppress ;
   int idle_timeout ;
   struct timeval last_active ;
   int hold_time ;
   struct timeval read_eof ;
   char *name ;
   size_t rcvd ;
   size_t sent ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.h"
typedef struct io_stream io_stream_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 30 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.h"
enum sock_family {
    PROTO_UNSPECIFIED = 0,
    PROTO_IPv6 = 1,
    PROTO_IPv4 = 2,
    PROTO_BLUEZ = 3
} ;
#line 30 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.h"
typedef enum sock_family sock_family_t;
#line 37
enum sock_protocol {
    TCP_PROTOCOL = 0,
    UDP_PROTOCOL = 1,
    SCO_PROTOCOL = 2,
    L2CAP_PROTOCOL = 3
} ;
#line 37 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.h"
typedef enum sock_protocol sock_protocol_t;
#line 44 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.h"
struct address {
   char *address ;
   char *service ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.h"
typedef struct address address_t;
#line 53 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.h"
struct connection_attributes {
   sock_family_t family ;
   sock_protocol_t protocol ;
   address_t remote_address ;
   address_t local_address ;
   int ttl ;
   int flags ;
   size_t buffer_size ;
   size_t remote_mtu ;
   size_t remote_nru ;
   size_t sndbuf_size ;
   size_t rcvbuf_size ;
   int connect_timeout ;
   int idle_timeout ;
   int local_hold_timeout ;
   int remote_hold_timeout ;
   _Bool remote_half_close_suppress ;
   _Bool local_half_close_suppress ;
   char *local_exec ;
   _Bool zflag ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.h"
typedef struct connection_attributes connection_attributes_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 44 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c"
struct callback_proxy_data {
   connection_attributes_t const   *attrs ;
   void (*callback)(connection_attributes_t const   *attrs , int fd , int socktype ,
                    void *cdata ) ;
   void *cdata ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c"
typedef struct callback_proxy_data callback_proxy_data_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 51 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.h"
struct bound_socket {
   int fd ;
   int socktype ;
   struct bound_socket *next ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.h"
typedef struct bound_socket bound_socket_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_34 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_34 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 93 "../contrib/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 264 "/usr/include/netinet/in.h"
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
#line 288 "/usr/include/netinet/in.h"
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   unsigned int ipv6mr_interface ;
};
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.h"
void fatal(char const   *template  , ...) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.h"
int ios_schedule_read(io_stream_t *ios ) ;
#line 94
int ios_schedule_write(io_stream_t *ios ) ;
#line 98
struct timeval *ios_next_timeout(io_stream_t *ios , struct timeval *tv ) ;
#line 108
ssize_t ios_read(io_stream_t *ios ) ;
#line 112
ssize_t ios_write(io_stream_t *ios ) ;
#line 116
ssize_t ios_write_crlf(io_stream_t *ios ) ;
#line 125
void ios_write_eof(io_stream_t *ios ) ;
#line 132
void ios_shutdown(io_stream_t *ios , int how ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/readwrite.h"
int readwrite(io_stream_t *ios1 , io_stream_t *ios2 ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.h"
_Bool crlf_mode(void) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/readwrite.c"
int readwrite(io_stream_t *ios1 , io_stream_t *ios2 ) 
{ 
  int rr ;
  int max_fd ;
  int ios1_read_fd ;
  int ios1_write_fd ;
  int ios2_read_fd ;
  int ios2_write_fd ;
  fd_set read_fdset ;
  fd_set write_fdset ;
  struct timeval tv1 ;
  struct timeval tv2 ;
  struct timeval *tvp1 ;
  struct timeval *tvp2 ;
  struct timeval *tvp ;
  _Bool timedout1 ;
  _Bool timedout2 ;
  int retval ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  _Bool tmp___8 ;
  ssize_t tmp___9 ;

  {
#line 46
  max_fd = -1;
#line 52
  timedout1 = (_Bool)0;
#line 52
  timedout2 = (_Bool)0;
#line 53
  retval = 0;
#line 56
  if (! ((unsigned long )ios1 != (unsigned long )((void *)0))) {
    {
#line 56
    __assert_fail("ios1 != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/readwrite.c",
                  56U, "readwrite");
    }
  }
#line 57
  if (! ((unsigned long )ios2 != (unsigned long )((void *)0))) {
    {
#line 57
    __assert_fail("ios2 != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/readwrite.c",
                  57U, "readwrite");
    }
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 77
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& read_fdset.__fds_bits[0]): "memory");
#line 77
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 78
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 78
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& write_fdset.__fds_bits[0]): "memory");
#line 78
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 80
    ios1_read_fd = ios_schedule_read(ios1);
#line 81
    ios1_write_fd = ios_schedule_write(ios1);
#line 82
    ios2_read_fd = ios_schedule_read(ios2);
#line 83
    ios2_write_fd = ios_schedule_write(ios2);
#line 85
    max_fd = -1;
    }
#line 86
    if (ios1_read_fd >= 0) {
#line 87
      read_fdset.__fds_bits[ios1_read_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ios1_read_fd % (8 * (int )sizeof(__fd_mask ));
#line 88
      max_fd = ios1_read_fd;
    }
#line 90
    if (ios1_write_fd >= 0) {
#line 91
      write_fdset.__fds_bits[ios1_write_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ios1_write_fd % (8 * (int )sizeof(__fd_mask ));
#line 92
      if (ios1_write_fd > max_fd) {
#line 92
        max_fd = ios1_write_fd;
      } else {
#line 92
        max_fd = max_fd;
      }
    }
#line 94
    if (ios2_read_fd >= 0) {
#line 95
      read_fdset.__fds_bits[ios2_read_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ios2_read_fd % (8 * (int )sizeof(__fd_mask ));
#line 96
      if (ios2_read_fd > max_fd) {
#line 96
        max_fd = ios2_read_fd;
      } else {
#line 96
        max_fd = max_fd;
      }
    }
#line 98
    if (ios2_write_fd >= 0) {
#line 99
      write_fdset.__fds_bits[ios2_write_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ios2_write_fd % (8 * (int )sizeof(__fd_mask ));
#line 100
      if (ios2_write_fd > max_fd) {
#line 100
        max_fd = ios2_write_fd;
      } else {
#line 100
        max_fd = max_fd;
      }
    }
#line 104
    if (max_fd == -1) {
#line 105
      goto while_break;
    }
#line 108
    tvp2 = (struct timeval *)((void *)0);
#line 108
    tvp1 = tvp2;
#line 109
    if (! timedout1) {
      {
#line 110
      tvp1 = ios_next_timeout(ios1, & tv1);
      }
#line 113
      if (ios1->flags & 8) {
#line 115
        retval = -1;
#line 116
        goto while_break;
      }
#line 118
      if (ios1->flags & 4) {
        {
#line 120
        ios_shutdown(ios2, 0);
#line 122
        ios_shutdown(ios1, 1);
#line 123
        timedout1 = (_Bool)1;
        }
#line 124
        goto __Cont;
      }
    }
#line 127
    if (! timedout2) {
      {
#line 128
      tvp2 = ios_next_timeout(ios2, & tv2);
      }
#line 131
      if (ios2->flags & 8) {
#line 133
        retval = -1;
#line 134
        goto while_break;
      }
#line 136
      if (ios2->flags & 4) {
        {
#line 138
        ios_shutdown(ios1, 0);
#line 140
        ios_shutdown(ios2, 1);
#line 141
        timedout2 = (_Bool)1;
        }
#line 142
        goto __Cont;
      }
    }
#line 147
    if ((unsigned long )tvp1 != (unsigned long )((void *)0)) {
#line 148
      if ((unsigned long )tvp2 != (unsigned long )((void *)0)) {
#line 149
        if (tvp1->tv_sec == tvp2->tv_sec) {
#line 149
          tmp___0 = tvp1->tv_usec < tvp2->tv_usec;
        } else {
#line 149
          tmp___0 = tvp1->tv_sec < tvp2->tv_sec;
        }
#line 149
        if (tmp___0) {
#line 149
          tvp = tvp1;
        } else {
#line 149
          tvp = tvp2;
        }
      } else {
#line 151
        tvp = tvp1;
      }
    } else {
#line 153
      tvp = tvp2;
    }
    {
#line 157
    rr = select(max_fd + 1, (fd_set */* __restrict  */)(& read_fdset), (fd_set */* __restrict  */)(& write_fdset),
                (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)tvp);
    }
#line 161
    if (rr < 0) {
      {
#line 162
      tmp___1 = __errno_location();
      }
#line 162
      if (*tmp___1 == 4) {
#line 163
        goto __Cont;
      }
      {
#line 164
      tmp___2 = __errno_location();
#line 164
      tmp___3 = strerror(*tmp___2);
#line 164
      fatal("select error: %s", tmp___3);
      }
    }
#line 167
    if (ios1_read_fd >= 0) {
#line 167
      if ((read_fdset.__fds_bits[ios1_read_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ios1_read_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 169
        tmp___4 = ios_read(ios1);
#line 169
        rr = (int )tmp___4;
        }
#line 171
        if (rr < 0) {
#line 172
          if (rr == -2) {
            {
#line 173
            ios_write_eof(ios2);
            }
          } else {
#line 177
            retval = -1;
#line 178
            goto while_break;
          }
        }
      }
    }
#line 183
    if (ios2_read_fd >= 0) {
#line 183
      if ((read_fdset.__fds_bits[ios2_read_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ios2_read_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 185
        tmp___5 = ios_read(ios2);
#line 185
        rr = (int )tmp___5;
        }
#line 187
        if (rr < 0) {
#line 188
          if (rr == -2) {
            {
#line 189
            ios_write_eof(ios1);
            }
          } else {
#line 193
            retval = -1;
#line 194
            goto while_break;
          }
        }
      }
    }
#line 199
    if (ios1_write_fd >= 0) {
#line 199
      if ((write_fdset.__fds_bits[ios1_write_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ios1_write_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 202
        tmp___8 = crlf_mode();
        }
#line 202
        if (tmp___8) {
          {
#line 203
          tmp___6 = ios_write_crlf(ios1);
#line 203
          rr = (int )tmp___6;
          }
        } else {
          {
#line 205
          tmp___7 = ios_write(ios1);
#line 205
          rr = (int )tmp___7;
          }
        }
#line 207
        if (rr < 0) {
#line 210
          retval = -1;
#line 211
          goto while_break;
        }
      }
    }
#line 215
    if (ios2_write_fd >= 0) {
#line 215
      if ((write_fdset.__fds_bits[ios2_write_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ios2_write_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 218
        tmp___9 = ios_write(ios2);
#line 218
        rr = (int )tmp___9;
        }
#line 220
        if (rr < 0) {
#line 223
          retval = -1;
#line 224
          goto while_break;
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return (retval);
}
}
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.h"
char const   *get_program_name(void) ;
#line 37
void warning(char const   *template  , ...) ;
#line 39
void *xmalloc(size_t size ) ;
#line 44
int open3(char const   *cmd , int *in , int *out , int *err ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.h"
void cb_init(circ_buf_t *cb , size_t size ) ;
#line 42
void cb_destroy(circ_buf_t *cb ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.h"
void ios_init_socket(io_stream_t *ios , char const   *name , int fd , int socktype ,
                     circ_buf_t *inbuf , circ_buf_t *outbuf ) ;
#line 66
void ios_init_stdio(io_stream_t *ios , char const   *name , circ_buf_t *inbuf , circ_buf_t *outbuf ) ;
#line 68
void ios_init(io_stream_t *ios , char const   *name , int fd_in , int fd_out , int socktype ,
              circ_buf_t *inbuf , circ_buf_t *outbuf ) ;
#line 72
void io_stream_destroy(io_stream_t *ios ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.h"
void ca_init(connection_attributes_t *attrs ) ;
#line 88
void ca_destroy(connection_attributes_t *attrs ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.h"
_Bool very_verbose_mode(void) ;
#line 31
void parse_arguments(int argc , char **argv , connection_attributes_t *attrs ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.h"
int net_establish(connection_attributes_t const   *attrs , void (*callback)(connection_attributes_t const   *attrs ,
                                                                            int fd ,
                                                                            int socktype ,
                                                                            void *cdata ) ,
                  void *cdata ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c"
static char *program_name  =    (char *)((void *)0);
#line 50
static int establish_connections(connection_attributes_t const   *attrs ) ;
#line 51
static void established_callback(connection_attributes_t const   *attrs , int fd ,
                                 int socktype , void *cdata ) ;
#line 53
static int connection_main(connection_attributes_t const   *attrs , int fd , int socktype ) ;
#line 55
static void setup_local_stream(connection_attributes_t const   *attrs , io_stream_t *stream ,
                               circ_buf_t *remote_buffer , circ_buf_t *local_buffer ) ;
#line 58
static void setup_remote_stream(connection_attributes_t const   *attrs , int fd ,
                                int socktype , io_stream_t *stream , circ_buf_t *remote_buffer ,
                                circ_buf_t *local_buffer ) ;
#line 61
static int run_transfer(connection_attributes_t const   *attrs , io_stream_t *remote_stream ,
                        io_stream_t *local_stream ) ;
#line 63
static void i18n_init(void) ;
#line 64
static void sigchld_handler(int signum ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c"
int main(int argc , char **argv ) 
{ 
  connection_attributes_t connection_attrs ;
  char *ptr ;
  int retval ;
  int tmp ;

  {
  {
#line 74
  i18n_init();
#line 77
  ca_init(& connection_attrs);
#line 80
  ptr = strrchr((char const   *)*(argv + 0), '/');
  }
#line 80
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 81
    ptr ++;
#line 81
    program_name = ptr;
  } else {
#line 83
    program_name = *(argv + 0);
  }
  {
#line 87
  signal(23, (void (*)(int  ))1);
#line 88
  signal(13, (void (*)(int  ))1);
#line 91
  signal(17, & sigchld_handler);
#line 94
  parse_arguments(argc, argv, & connection_attrs);
#line 97
  retval = establish_connections((connection_attributes_t const   *)(& connection_attrs));
#line 100
  ca_destroy(& connection_attrs);
  }
#line 102
  if (retval) {
#line 102
    tmp = 1;
  } else {
#line 102
    tmp = 0;
  }
#line 102
  return (tmp);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c"
static int establish_connections(connection_attributes_t const   *attrs ) 
{ 
  int err ;
  int result ;

  {
  {
#line 109
  result = 0;
#line 112
  err = net_establish(attrs, & established_callback, (void *)(& result));
  }
#line 113
  if (err) {
#line 114
    return (err);
  }
#line 118
  return (result);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c"
static void established_callback(connection_attributes_t const   *attrs , int fd ,
                                 int socktype , void *cdata ) 
{ 
  int do_fork ;
  int result ;
  int pid ;
  int size ;
  char *new_name ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  __pid_t tmp___3 ;
  int tmp___4 ;

  {
#line 127
  do_fork = 0;
#line 132
  if (attrs->flags & 8) {
#line 132
    if (attrs->flags & 256) {
#line 135
      do_fork = 1;
    }
  }
#line 138
  if (do_fork) {
    {
#line 144
    pid = fork();
    }
#line 145
    if (pid < 0) {
      {
#line 146
      tmp = __errno_location();
#line 146
      tmp___0 = strerror(*tmp);
#line 146
      fatal("fork failed: %s", tmp___0);
      }
    } else
#line 147
    if (pid > 0) {
#line 149
      return;
    }
    {
#line 153
    tmp___1 = strlen((char const   *)program_name);
#line 153
    size = (int )(tmp___1 + 10UL);
#line 154
    tmp___2 = xmalloc((unsigned long )size * sizeof(char ));
#line 154
    new_name = (char *)tmp___2;
#line 155
    tmp___3 = getpid();
#line 155
    snprintf((char */* __restrict  */)new_name, (size_t )size, (char const   */* __restrict  */)"%s[%d]",
             program_name, tmp___3);
#line 156
    program_name = new_name;
    }
  }
  {
#line 160
  result = connection_main(attrs, fd, socktype);
  }
#line 163
  if (do_fork) {
#line 164
    if (result) {
#line 164
      tmp___4 = 1;
    } else {
#line 164
      tmp___4 = 0;
    }
    {
#line 164
    exit(tmp___4);
    }
  }
#line 167
  *((int *)cdata) = result;
#line 168
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c"
static int connection_main(connection_attributes_t const   *attrs , int fd , int socktype ) 
{ 
  circ_buf_t remote_buffer ;
  circ_buf_t local_buffer ;
  io_stream_t remote_stream ;
  io_stream_t local_stream ;
  int retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;

  {
#line 177
  retval = 0;
#line 179
  if (! ((unsigned long )attrs != (unsigned long )((void *)0))) {
    {
#line 179
    __assert_fail("attrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c",
                  179U, "connection_main");
    }
  }
#line 180
  if (! (fd >= 0)) {
    {
#line 180
    __assert_fail("fd >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c",
                  180U, "connection_main");
    }
  }
#line 181
  if (! (socktype >= 0)) {
    {
#line 181
    __assert_fail("socktype >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c",
                  181U, "connection_main");
    }
  }
  {
#line 184
  cb_init(& remote_buffer, (size_t )attrs->buffer_size);
#line 185
  cb_init(& local_buffer, (size_t )attrs->buffer_size);
#line 188
  setup_remote_stream(attrs, fd, socktype, & remote_stream, & remote_buffer, & local_buffer);
#line 192
  setup_local_stream(attrs, & local_stream, & remote_buffer, & local_buffer);
#line 195
  remote_stream.mtu = (size_t )attrs->remote_mtu;
#line 196
  remote_stream.nru = (size_t )attrs->remote_nru;
#line 199
  remote_stream.idle_timeout = (int )attrs->idle_timeout;
#line 202
  remote_stream.hold_time = (int )attrs->remote_hold_timeout;
#line 203
  local_stream.hold_time = (int )attrs->local_hold_timeout;
#line 206
  remote_stream.half_close_suppress = (_Bool )attrs->remote_half_close_suppress;
#line 208
  local_stream.half_close_suppress = (_Bool )attrs->local_half_close_suppress;
#line 212
  tmp___2 = very_verbose_mode();
  }
#line 212
  if (tmp___2) {
    {
#line 213
    tmp = gettext("using buffer size of %d");
#line 213
    warning((char const   *)tmp, remote_buffer.buf_size);
    }
#line 214
    if (remote_stream.nru > 0UL) {
      {
#line 215
      tmp___0 = gettext("using remote receive nru of %d");
#line 215
      warning((char const   *)tmp___0, remote_stream.nru);
      }
    }
#line 217
    if (remote_stream.mtu > 0UL) {
      {
#line 218
      tmp___1 = gettext("using remote send mtu of %d");
#line 218
      warning((char const   *)tmp___1, remote_stream.mtu);
      }
    }
  }
#line 223
  if ((int const   )attrs->zflag == 0) {
    {
#line 225
    retval = run_transfer(attrs, & remote_stream, & local_stream);
#line 228
    io_stream_destroy(& local_stream);
#line 229
    io_stream_destroy(& remote_stream);
#line 230
    cb_destroy(& local_buffer);
#line 231
    cb_destroy(& remote_buffer);
    }
  }
#line 234
  return (retval);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c"
static void setup_local_stream(connection_attributes_t const   *attrs , io_stream_t *stream ,
                               circ_buf_t *remote_buffer , circ_buf_t *local_buffer ) 
{ 
  char const   *cmd ;
  int in ;
  int out ;
  char *tmp ;
  _Bool tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 244
  if (! ((unsigned long )attrs != (unsigned long )((void *)0))) {
    {
#line 244
    __assert_fail("attrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c",
                  244U, "setup_local_stream");
    }
  }
#line 245
  if (! ((unsigned long )stream != (unsigned long )((void *)0))) {
    {
#line 245
    __assert_fail("stream != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c",
                  245U, "setup_local_stream");
    }
  }
#line 247
  cmd = (char const   *)attrs->local_exec;
#line 248
  if ((unsigned long )cmd != (unsigned long )((void *)0)) {
    {
#line 250
    tmp___0 = very_verbose_mode();
    }
#line 250
    if (tmp___0) {
      {
#line 251
      tmp = gettext("executing \'%s\'");
#line 251
      warning((char const   *)tmp, cmd);
      }
    }
    {
#line 252
    tmp___4 = open3(cmd, & in, & out, (int *)((void *)0));
    }
#line 252
    if (tmp___4 < 0) {
      {
#line 253
      tmp___1 = __errno_location();
#line 253
      tmp___2 = strerror(*tmp___1);
#line 253
      tmp___3 = gettext("failed to exec \'%s\': %s");
#line 253
      fatal((char const   *)tmp___3, cmd, tmp___2);
      }
    }
    {
#line 256
    ios_init(stream, "local", out, in, 1, local_buffer, remote_buffer);
    }
  } else {
    {
#line 260
    ios_init_stdio(stream, "local", local_buffer, remote_buffer);
    }
  }
#line 262
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c"
static void setup_remote_stream(connection_attributes_t const   *attrs , int fd ,
                                int socktype , io_stream_t *stream , circ_buf_t *remote_buffer ,
                                circ_buf_t *local_buffer ) 
{ 


  {
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  if (! ((unsigned long )attrs != (unsigned long )((void *)0))) {
    {
#line 272
    __assert_fail("attrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c",
                  272U, "setup_remote_stream");
    }
  }
#line 273
  if (! (fd >= 0)) {
    {
#line 273
    __assert_fail("fd >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c",
                  273U, "setup_remote_stream");
    }
  }
#line 274
  if (! (socktype >= 0)) {
    {
#line 274
    __assert_fail("socktype >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c",
                  274U, "setup_remote_stream");
    }
  }
#line 275
  if (! ((unsigned long )stream != (unsigned long )((void *)0))) {
    {
#line 275
    __assert_fail("stream != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c",
                  275U, "setup_remote_stream");
    }
  }
  {
#line 277
  ios_init_socket(stream, "remote", fd, socktype, remote_buffer, local_buffer);
  }
#line 279
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c"
static int run_transfer(connection_attributes_t const   *attrs , io_stream_t *remote_stream ,
                        io_stream_t *local_stream ) 
{ 
  int retval ;
  char *tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  char *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
#line 288
  if (! ((unsigned long )remote_stream != (unsigned long )((void *)0))) {
    {
#line 288
    __assert_fail("remote_stream != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c",
                  288U, "run_transfer");
    }
  }
#line 289
  if (! ((unsigned long )local_stream != (unsigned long )((void *)0))) {
    {
#line 289
    __assert_fail("local_stream != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c",
                  289U, "run_transfer");
    }
  }
#line 292
  if (! (! (attrs->flags & 32))) {
#line 292
    if (! (! (attrs->flags & 64))) {
      {
#line 292
      __assert_fail("!((attrs)->flags & (0x000020)) || !((attrs)->flags & (0x000040))",
                    "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c",
                    293U, "run_transfer");
      }
    }
  }
#line 295
  if (attrs->flags & 32) {
    {
#line 299
    ios_shutdown(remote_stream, 1);
#line 301
    ios_shutdown(local_stream, 0);
#line 303
    remote_stream->hold_time = -1;
#line 304
    local_stream->hold_time = -1;
#line 306
    tmp___0 = very_verbose_mode();
    }
#line 306
    if (tmp___0) {
      {
#line 307
      tmp = gettext("receiving from remote only, transmit disabled");
#line 307
      warning((char const   *)tmp);
      }
    }
  }
#line 311
  if (attrs->flags & 64) {
    {
#line 315
    ios_shutdown(remote_stream, 0);
#line 317
    ios_shutdown(local_stream, 1);
#line 319
    remote_stream->hold_time = -1;
#line 320
    local_stream->hold_time = -1;
#line 322
    tmp___2 = very_verbose_mode();
    }
#line 322
    if (tmp___2) {
      {
#line 323
      tmp___1 = gettext("transmitting to remote only, receive disabled");
#line 323
      warning((char const   *)tmp___1);
      }
    }
  }
  {
#line 328
  retval = readwrite(remote_stream, local_stream);
#line 330
  tmp___4 = very_verbose_mode();
  }
#line 330
  if (tmp___4) {
    {
#line 331
    tmp___3 = gettext("connection closed (sent %d, rcvd %d)");
#line 331
    warning((char const   *)tmp___3, remote_stream->sent, remote_stream->rcvd);
    }
  }
  {
#line 335
  tmp___5 = very_verbose_mode();
  }
#line 335
  if (tmp___5) {
    {
#line 336
    warning("readwrite returned %d", retval);
    }
  }
#line 339
  return (retval);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c"
char const   *get_program_name(void) 
{ 


  {
#line 346
  return ((char const   *)program_name);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c"
static void i18n_init(void) 
{ 


  {
  {
#line 355
  setlocale(6, "");
#line 356
  setlocale(5, "");
#line 358
  bindtextdomain("nc6", "/usr/local/share/locale");
#line 359
  textdomain("nc6");
  }
#line 361
  return;
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c"
static void sigchld_handler(int signum ) 
{ 
  int pid ;
  int status ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! (signum == 17)) {
    {
#line 372
    __assert_fail("signum == 17", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/main.c",
                  372U, "sigchld_handler");
    }
  }
  {
#line 374
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 376
    pid = waitpid(-1, & status, 1);
    }
#line 374
    if (! (pid > 0)) {
#line 374
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 378
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.h"
void fatal_internal(char const   *template  , ...) ;
#line 40
char *xstrdup(char const   *str ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.h"
void ca_set_local_exec(connection_attributes_t *attrs , char const   *exec ) ;
#line 156
void ca_to_addrinfo(struct addrinfo *ainfo , connection_attributes_t const   *attrs ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.c"
static unsigned long const   DEFAULT_BUFFER_SIZE  =    (size_t const   )8192;
#line 40 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.c"
void ca_init(connection_attributes_t *attrs ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 42
  if (! ((unsigned long )attrs != (unsigned long )((void *)0))) {
    {
#line 42
    __assert_fail("attrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.c",
                  42U, "ca_init");
    }
  }
#line 44
  attrs->family = (sock_family_t )0;
#line 45
  attrs->protocol = (sock_protocol_t )0;
#line 47
  tmp = (char *)((void *)0);
#line 47
  attrs->remote_address.service = tmp;
#line 47
  attrs->remote_address.address = tmp;
#line 48
  tmp___0 = (char *)((void *)0);
#line 48
  attrs->local_address.service = tmp___0;
#line 48
  attrs->local_address.address = tmp___0;
#line 51
  attrs->flags = 0;
#line 52
  attrs->buffer_size = (size_t )DEFAULT_BUFFER_SIZE;
#line 53
  attrs->remote_mtu = (size_t )0;
#line 54
  attrs->remote_nru = (size_t )0;
#line 55
  attrs->sndbuf_size = (size_t )0;
#line 56
  attrs->rcvbuf_size = (size_t )0;
#line 57
  attrs->connect_timeout = -1;
#line 58
  attrs->idle_timeout = -1;
#line 59
  attrs->local_hold_timeout = -1;
#line 60
  attrs->remote_hold_timeout = 0;
#line 61
  attrs->remote_half_close_suppress = (_Bool)1;
#line 62
  attrs->local_half_close_suppress = (_Bool)0;
#line 63
  attrs->local_exec = (char *)((void *)0);
#line 64
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.c"
void ca_destroy(connection_attributes_t *attrs ) 
{ 


  {
#line 70
  if (! ((unsigned long )attrs != (unsigned long )((void *)0))) {
    {
#line 70
    __assert_fail("attrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.c",
                  70U, "ca_destroy");
    }
  }
  {
#line 71
  ca_set_local_exec(attrs, (char const   *)((void *)0));
  }
#line 72
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.c"
void ca_set_local_exec(connection_attributes_t *attrs , char const   *exec ) 
{ 
  char *tmp ;

  {
#line 78
  if (attrs->local_exec) {
    {
#line 79
    free((void *)attrs->local_exec);
    }
  }
#line 80
  if (exec) {
    {
#line 80
    tmp = xstrdup(exec);
#line 80
    attrs->local_exec = tmp;
    }
  } else {
#line 80
    attrs->local_exec = (char *)((void *)0);
  }
#line 81
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.c"
void ca_to_addrinfo(struct addrinfo *ainfo , connection_attributes_t const   *attrs ) 
{ 


  {
#line 88
  if (! ((unsigned long )ainfo != (unsigned long )((void *)0))) {
    {
#line 88
    __assert_fail("ainfo != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.c",
                  88U, "ca_to_addrinfo");
    }
  }
#line 89
  if (! ((unsigned long )attrs != (unsigned long )((void *)0))) {
    {
#line 89
    __assert_fail("attrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/connection.c",
                  89U, "ca_to_addrinfo");
    }
  }
  {
#line 92
  if ((unsigned int const   )attrs->family == 0U) {
#line 92
    goto case_0;
  }
#line 95
  if ((unsigned int const   )attrs->family == 1U) {
#line 95
    goto case_1;
  }
#line 102
  if ((unsigned int const   )attrs->family == 2U) {
#line 102
    goto case_2;
  }
#line 105
  if ((unsigned int const   )attrs->family == 3U) {
#line 105
    goto case_3;
  }
#line 112
  goto switch_default;
  case_0: /* CIL Label */ 
#line 93
  ainfo->ai_family = 0;
#line 94
  goto switch_break;
  case_1: /* CIL Label */ 
#line 97
  ainfo->ai_family = 10;
#line 101
  goto switch_break;
  case_2: /* CIL Label */ 
#line 103
  ainfo->ai_family = 2;
#line 104
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 109
  fatal_internal("unavailable bluez support required");
  }
#line 111
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 113
  fatal_internal("unknown socket domain");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 117
  if ((unsigned int const   )attrs->protocol == 1U) {
#line 117
    goto case_1___0;
  }
#line 124
  if ((unsigned int const   )attrs->protocol == 0U) {
#line 124
    goto case_0___0;
  }
#line 131
  if ((unsigned int const   )attrs->protocol == 2U) {
#line 131
    goto case_2___0;
  }
#line 139
  if ((unsigned int const   )attrs->protocol == 3U) {
#line 139
    goto case_3___0;
  }
#line 147
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 118
  ainfo->ai_protocol = 17;
#line 122
  ainfo->ai_socktype = 2;
#line 123
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 125
  ainfo->ai_protocol = 6;
#line 129
  ainfo->ai_socktype = 1;
#line 130
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 136
  fatal_internal("unavailable bluez support required");
  }
#line 138
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 144
  fatal_internal("unavailable bluez support required");
  }
#line 146
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 148
  fatal_internal("unknown socket type");
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 150
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.h"
void nonblock(int fd ) ;
#line 46
int safe_atoi(char const   *str , int *result ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.c"
void fatal_internal(char const   *template  , ...) 
{ 
  va_list ap ;
  char const   *tmp ;

  {
#line 56
  if (! ((unsigned long )template != (unsigned long )((void *)0))) {
    {
#line 56
    __assert_fail("template != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.c",
                  56U, "fatal_internal");
    }
  }
  {
#line 58
  tmp = get_program_name();
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: internal error: ",
          tmp);
#line 60
  __builtin_va_start(ap, template);
#line 61
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)template,
           ap);
#line 62
  __builtin_va_end(ap);
#line 64
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (please report this error to nc6 authors)\n");
#line 66
  abort();
  }
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.c"
void fatal(char const   *template  , ...) 
{ 
  va_list ap ;
  char const   *tmp ;

  {
#line 76
  if (! ((unsigned long )template != (unsigned long )((void *)0))) {
    {
#line 76
    __assert_fail("template != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.c",
                  76U, "fatal");
    }
  }
  {
#line 78
  tmp = get_program_name();
#line 78
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          tmp);
#line 80
  __builtin_va_start(ap, template);
#line 81
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)template,
           ap);
#line 82
  __builtin_va_end(ap);
#line 84
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 86
  exit(1);
  }
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.c"
void warning(char const   *template  , ...) 
{ 
  va_list ap ;
  char const   *tmp ;

  {
#line 95
  if (! ((unsigned long )template != (unsigned long )((void *)0))) {
    {
#line 95
    __assert_fail("template != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.c",
                  95U, "warning");
    }
  }
  {
#line 97
  tmp = get_program_name();
#line 97
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          tmp);
#line 99
  __builtin_va_start(ap, template);
#line 100
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)template,
           ap);
#line 101
  __builtin_va_end(ap);
#line 103
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 104
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.c"
void *xmalloc(size_t size ) 
{ 
  register void *value ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 111
  tmp = malloc(size);
#line 111
  value = tmp;
  }
#line 113
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 113
    tmp___0 = gettext("virtual memory exhausted");
#line 113
    fatal((char const   *)tmp___0);
    }
  }
#line 115
  return (value);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.c"
char *xstrdup(char const   *str ) 
{ 
  register char *nstr ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 122
  tmp = strlen(str);
#line 122
  tmp___0 = xmalloc(tmp);
#line 122
  nstr = (char *)tmp___0;
#line 124
  strcpy((char */* __restrict  */)nstr, (char const   */* __restrict  */)str);
  }
#line 125
  return (nstr);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.c"
void nonblock(int fd ) 
{ 
  int arg ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 133
  arg = fcntl(fd, 3, 0);
  }
#line 133
  if (arg < 0) {
    {
#line 134
    tmp = __errno_location();
#line 134
    tmp___0 = strerror(*tmp);
#line 134
    fatal("error reading file descriptor flags: %s", tmp___0);
    }
  }
  {
#line 137
  arg |= 2048;
#line 139
  tmp___3 = fcntl(fd, 4, arg);
  }
#line 139
  if (tmp___3 < 0) {
    {
#line 140
    tmp___1 = __errno_location();
#line 140
    tmp___2 = strerror(*tmp___1);
#line 140
    fatal("error setting flag O_NONBLOCK on file descriptor", tmp___2);
    }
  }
#line 142
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.c"
int open3(char const   *cmd , int *in , int *out , int *err ) 
{ 
  int inpipe[2] ;
  int outpipe[2] ;
  int errpipe[2] ;
  int pid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *argv[4] ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;

  {
#line 153
  if ((unsigned long )in != (unsigned long )((void *)0)) {
    {
#line 154
    tmp = pipe((int *)(inpipe));
    }
#line 154
    if (tmp < 0) {
#line 155
      return (-1);
    }
  } else {
    {
#line 157
    inpipe[0] = open("/dev/null", 0);
    }
#line 158
    if (inpipe[0] < 0) {
#line 159
      return (-1);
    }
  }
#line 162
  if ((unsigned long )out != (unsigned long )((void *)0)) {
    {
#line 163
    tmp___0 = pipe((int *)(outpipe));
    }
#line 163
    if (tmp___0 < 0) {
#line 164
      return (-1);
    }
  } else {
    {
#line 166
    outpipe[1] = open("/dev/null", 1);
    }
#line 167
    if (outpipe[1] < 0) {
#line 168
      return (-1);
    }
  }
#line 171
  if ((unsigned long )err != (unsigned long )((void *)0)) {
    {
#line 172
    tmp___1 = pipe((int *)(errpipe));
    }
#line 172
    if (tmp___1 < 0) {
#line 173
      return (-1);
    }
  } else {
    {
#line 175
    errpipe[1] = open("/dev/null", 1);
    }
#line 176
    if (errpipe[1] < 0) {
#line 177
      return (-1);
    }
  }
  {
#line 181
  pid = fork();
  }
#line 182
  if (pid < 0) {
#line 183
    return (-1);
  } else
#line 184
  if (pid == 0) {
    {
#line 190
    close(inpipe[1]);
#line 191
    close(outpipe[0]);
#line 192
    close(errpipe[0]);
#line 194
    argv[0] = (char *)"sh";
#line 195
    argv[1] = (char *)"-c";
#line 196
    argv[2] = xstrdup(cmd);
#line 197
    argv[3] = (char *)((void *)0);
#line 200
    close(0);
#line 201
    tmp___4 = dup2(inpipe[0], 0);
    }
#line 201
    if (tmp___4 < 0) {
      {
#line 202
      tmp___2 = __errno_location();
#line 202
      tmp___3 = strerror(*tmp___2);
#line 202
      fatal("dup2 failed: %s", tmp___3);
      }
    }
    {
#line 203
    close(inpipe[0]);
#line 205
    close(1);
#line 206
    tmp___7 = dup2(outpipe[1], 1);
    }
#line 206
    if (tmp___7 < 0) {
      {
#line 207
      tmp___5 = __errno_location();
#line 207
      tmp___6 = strerror(*tmp___5);
#line 207
      fatal("dup2 failed: %s", tmp___6);
      }
    }
    {
#line 208
    close(outpipe[1]);
#line 210
    close(2);
#line 211
    tmp___10 = dup2(errpipe[1], 2);
    }
#line 211
    if (tmp___10 < 0) {
      {
#line 212
      tmp___8 = __errno_location();
#line 212
      tmp___9 = strerror(*tmp___8);
#line 212
      fatal("dup2 failed: %s", tmp___9);
      }
    }
    {
#line 213
    close(errpipe[1]);
#line 216
    execv("/bin/sh", (char * const  *)(argv));
#line 217
    tmp___11 = __errno_location();
#line 217
    tmp___12 = strerror(*tmp___11);
#line 217
    fatal("execv failed: %s", tmp___12);
    }
  }
  {
#line 223
  close(inpipe[0]);
#line 224
  close(outpipe[1]);
#line 225
  close(errpipe[1]);
  }
#line 227
  if ((unsigned long )in != (unsigned long )((void *)0)) {
#line 227
    *in = inpipe[1];
  }
#line 228
  if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 228
    *out = outpipe[0];
  }
#line 229
  if ((unsigned long )err != (unsigned long )((void *)0)) {
#line 229
    *err = errpipe[0];
  }
#line 231
  return (pid);
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.c"
int safe_atoi(char const   *str , int *result ) 
{ 
  long lresult ;
  char *endptr ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 241
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 241
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.c",
                  241U, "safe_atoi");
    }
  }
#line 242
  if (! ((unsigned long )result != (unsigned long )((void *)0))) {
    {
#line 242
    __assert_fail("result != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/misc.c",
                  242U, "safe_atoi");
    }
  }
  {
#line 245
  tmp = __errno_location();
#line 245
  *tmp = 0;
#line 246
  lresult = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)(& endptr),
                   10);
  }
#line 247
  if ((int )*endptr != 0) {
    {
#line 248
    tmp___0 = __errno_location();
#line 248
    *tmp___0 = 22;
    }
#line 249
    return (-1);
  }
  {
#line 251
  tmp___2 = __errno_location();
  }
#line 251
  if (*tmp___2 == 34) {
    {
#line 252
    tmp___1 = __errno_location();
#line 252
    *tmp___1 = 34;
    }
#line 253
    return (-1);
  } else
#line 251
  if (lresult > 2147483647L) {
    {
#line 252
    tmp___1 = __errno_location();
#line 252
    *tmp___1 = 34;
    }
#line 253
    return (-1);
  } else
#line 251
  if (lresult < (-0x7FFFFFFF-1)) {
    {
#line 252
    tmp___1 = __errno_location();
#line 252
    *tmp___1 = 34;
    }
#line 253
    return (-1);
  }
#line 265
  *result = (int )lresult;
#line 266
  return (0);
}
}
#line 219 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.h"
int afindep_connect(struct addrinfo  const  *hints , char const   *remote_address ,
                    char const   *remote_service , char const   *local_address , char const   *local_service ,
                    void (*set_sockopt_handler___0)(int sock , void *hdata ) , void *hdata ,
                    time_t timeout , int *rt_socktype ) ;
#line 41
int afindep_listener(struct addrinfo  const  *hints , char const   *local_address ,
                     char const   *local_service , char const   *remote_address ,
                     char const   *remote_service , void (*set_sockopt_handler___0)(int sock ,
                                                                                    void *hdata ) ,
                     void *hdata , void (*callback)(int fd , int socktype , void *cdata ) ,
                     void *cdata , time_t timeout , int max_accept ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c"
static int net_connect(connection_attributes_t const   *attrs , void (*callback)(connection_attributes_t const   *attrs ,
                                                                                 int fd ,
                                                                                 int socktype ,
                                                                                 void *cdata ) ,
                       void *cdata ) ;
#line 54
static int net_listen(connection_attributes_t const   *attrs , void (*callback)(connection_attributes_t const   *attrs ,
                                                                                int fd ,
                                                                                int socktype ,
                                                                                void *cdata ) ,
                      void *cdata ) ;
#line 56
static void callback_proxy(int fd , int socktype , void *cdata ) ;
#line 57
static void set_sockopt_handler(int sock , void *hdata ) ;
#line 58
static void warn_socket_details(connection_attributes_t const   *attrs , int sock ,
                                int socktype ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c"
int net_establish(connection_attributes_t const   *attrs , void (*callback)(connection_attributes_t const   *attrs ,
                                                                            int fd ,
                                                                            int socktype ,
                                                                            void *cdata ) ,
                  void *cdata ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 67
  if (attrs->flags & 16) {
    {
#line 68
    tmp = net_connect(attrs, callback, cdata);
    }
#line 68
    return (tmp);
  } else
#line 69
  if (attrs->flags & 8) {
    {
#line 70
    tmp___0 = net_listen(attrs, callback, cdata);
    }
#line 70
    return (tmp___0);
  } else {
    {
#line 72
    fatal_internal("unknown connection mode");
    }
  }
  {
#line 76
  abort();
  }
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c"
static int net_connect(connection_attributes_t const   *attrs , void (*callback)(connection_attributes_t const   *attrs ,
                                                                                 int fd ,
                                                                                 int socktype ,
                                                                                 void *cdata ) ,
                       void *cdata ) 
{ 
  struct addrinfo hints ;
  address_t const   *remote ;
  address_t const   *local ;
  time_t timeout ;
  int fd ;
  int socktype ;
  callback_proxy_data_t proxy_data ;

  {
#line 90
  if (! ((unsigned long )attrs != (unsigned long )((void *)0))) {
    {
#line 90
    __assert_fail("attrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c",
                  90U, "net_connect");
    }
  }
  {
#line 93
  memset((void *)(& hints), 0, sizeof(hints));
#line 94
  ca_to_addrinfo(& hints, attrs);
#line 98
  hints.ai_flags |= 32;
  }
#line 100
  if (attrs->flags & 1) {
#line 101
    hints.ai_flags |= 4;
  }
#line 104
  remote = & attrs->remote_address;
#line 105
  local = & attrs->local_address;
#line 108
  timeout = (time_t )attrs->connect_timeout;
#line 111
  proxy_data.attrs = attrs;
#line 112
  proxy_data.callback = callback;
#line 113
  proxy_data.cdata = cdata;
  {
#line 125
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 126
  fd = afindep_connect((struct addrinfo  const  *)(& hints), (char const   *)remote->address,
                       (char const   *)remote->service, (char const   *)local->address,
                       (char const   *)local->service, & set_sockopt_handler, (void *)(& attrs),
                       timeout, & socktype);
  }
#line 131
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 135
  if (fd < 0) {
#line 136
    return (fd);
  }
  {
#line 139
  callback_proxy(fd, socktype, (void *)(& proxy_data));
  }
#line 140
  return (0);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c"
static int net_listen(connection_attributes_t const   *attrs , void (*callback)(connection_attributes_t const   *attrs ,
                                                                                int fd ,
                                                                                int socktype ,
                                                                                void *cdata ) ,
                      void *cdata ) 
{ 
  struct addrinfo hints ;
  address_t const   *remote ;
  address_t const   *local ;
  time_t timeout ;
  int max_accept ;
  callback_proxy_data_t proxy_data ;
  int tmp ;

  {
#line 155
  if (! ((unsigned long )attrs != (unsigned long )((void *)0))) {
    {
#line 155
    __assert_fail("attrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c",
                  155U, "net_listen");
    }
  }
  {
#line 158
  memset((void *)(& hints), 0, sizeof(hints));
#line 159
  ca_to_addrinfo(& hints, attrs);
#line 160
  hints.ai_flags = 1;
#line 162
  hints.ai_flags |= 32;
  }
#line 164
  if (attrs->flags & 1) {
#line 165
    hints.ai_flags |= 4;
  }
#line 168
  remote = & attrs->remote_address;
#line 169
  local = & attrs->local_address;
#line 172
  timeout = (time_t )attrs->connect_timeout;
#line 175
  if (attrs->flags & 256) {
#line 175
    max_accept = -1;
  } else {
#line 175
    max_accept = 1;
  }
#line 178
  proxy_data.attrs = attrs;
#line 179
  proxy_data.callback = callback;
#line 180
  proxy_data.cdata = cdata;
  {
#line 193
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 194
  tmp = afindep_listener((struct addrinfo  const  *)(& hints), (char const   *)local->address,
                         (char const   *)local->service, (char const   *)remote->address,
                         (char const   *)remote->service, & set_sockopt_handler, (void *)(& attrs),
                         & callback_proxy, (void *)(& proxy_data), timeout, max_accept);
  }
#line 194
  return (tmp);
  switch_break: /* CIL Label */ ;
  }
  {
#line 203
  abort();
  }
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c"
static void callback_proxy(int fd , int socktype , void *cdata ) 
{ 
  callback_proxy_data_t *proxy_data ;
  connection_attributes_t const   *attrs ;

  {
#line 211
  proxy_data = (callback_proxy_data_t *)cdata;
#line 214
  if (! ((unsigned long )proxy_data != (unsigned long )((void *)0))) {
    {
#line 214
    __assert_fail("proxy_data != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c",
                  214U, "callback_proxy");
    }
  }
#line 215
  if (! (fd >= 0)) {
    {
#line 215
    __assert_fail("fd >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c",
                  215U, "callback_proxy");
    }
  }
#line 216
  if (! (socktype >= 0)) {
    {
#line 216
    __assert_fail("socktype >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c",
                  216U, "callback_proxy");
    }
  }
  {
#line 218
  attrs = proxy_data->attrs;
#line 220
  warn_socket_details(attrs, fd, socktype);
#line 222
  (*(proxy_data->callback))(attrs, fd, socktype, proxy_data->cdata);
  }
#line 223
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c"
static void set_sockopt_handler(int sock , void *hdata ) 
{ 
  int on ;
  int err ;
  connection_attributes_t const   *attrs ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;

  {
#line 231
  attrs = *((connection_attributes_t const   **)hdata);
#line 235
  if (! ((unsigned long )attrs != (unsigned long )((void *)0))) {
    {
#line 235
    __assert_fail("attrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c",
                  235U, "set_sockopt_handler");
    }
  }
#line 236
  if (! (sock >= 0)) {
    {
#line 236
    __assert_fail("sock >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c",
                  236U, "set_sockopt_handler");
    }
  }
#line 239
  if (! (attrs->flags & 4)) {
    {
#line 240
    on = 1;
#line 242
    err = setsockopt(sock, 1, 2, (void const   *)(& on), (socklen_t )sizeof(on));
    }
#line 244
    if (err < 0) {
      {
#line 245
      tmp = __errno_location();
#line 245
      tmp___0 = strerror(*tmp);
#line 245
      warning("error with setsockopt SO_REUSEADDR: %s", tmp___0);
      }
    }
  }
#line 250
  if (attrs->flags & 128) {
    {
#line 251
    on = 1;
#line 253
    err = setsockopt(sock, 6, 1, (void const   *)(& on), (socklen_t )sizeof(on));
    }
#line 256
    if (err < 0) {
      {
#line 256
      tmp___3 = __errno_location();
      }
#line 256
      if (*tmp___3 != 92) {
        {
#line 257
        tmp___1 = __errno_location();
#line 257
        tmp___2 = strerror(*tmp___1);
#line 257
        warning("error with setsockopt TCP_NODELAY: %s", tmp___2);
        }
      }
    }
  }
#line 263
  on = (int )attrs->sndbuf_size;
#line 263
  if (on > 0) {
    {
#line 265
    err = setsockopt(sock, 1, 7, (void const   *)(& on), (socklen_t )sizeof(on));
    }
#line 266
    if (err < 0) {
      {
#line 267
      tmp___4 = __errno_location();
#line 267
      tmp___5 = strerror(*tmp___4);
#line 267
      warning("error with setsockopt SO_SNDBUF: %s", tmp___5);
      }
    }
  }
#line 272
  on = (int )attrs->rcvbuf_size;
#line 272
  if (on > 0) {
    {
#line 274
    err = setsockopt(sock, 1, 8, (void const   *)(& on), (socklen_t )sizeof(on));
    }
#line 275
    if (err < 0) {
      {
#line 276
      tmp___6 = __errno_location();
#line 276
      tmp___7 = strerror(*tmp___6);
#line 276
      warning("error with setsockopt SO_RCVBUF: %s", tmp___7);
      }
    }
  }
#line 279
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c"
static void warn_socket_details(connection_attributes_t const   *attrs , int sock ,
                                int socktype ) 
{ 
  int n ;
  socklen_t nlen ;
  char *tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  char *tmp___3 ;
  _Bool tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 290
  if (! ((unsigned long )attrs != (unsigned long )((void *)0))) {
    {
#line 290
    __assert_fail("attrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c",
                  290U, "warn_socket_details");
    }
  }
#line 291
  if (! (sock >= 0)) {
    {
#line 291
    __assert_fail("sock >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/network.c",
                  291U, "warn_socket_details");
    }
  }
  {
#line 295
  if (socktype == 1) {
#line 295
    goto case_1;
  }
#line 299
  if (socktype == 2) {
#line 299
    goto case_2;
  }
#line 303
  if (socktype == 5) {
#line 303
    goto case_5;
  }
#line 307
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 296
  tmp___0 = very_verbose_mode();
  }
#line 296
  if (tmp___0) {
    {
#line 297
    tmp = gettext("using stream socket");
#line 297
    warning((char const   *)tmp);
    }
  }
#line 298
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 300
  tmp___2 = very_verbose_mode();
  }
#line 300
  if (tmp___2) {
    {
#line 301
    tmp___1 = gettext("using datagram socket");
#line 301
    warning((char const   *)tmp___1);
    }
  }
#line 302
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 304
  tmp___4 = very_verbose_mode();
  }
#line 304
  if (tmp___4) {
    {
#line 305
    tmp___3 = gettext("using seqpacket socket");
#line 305
    warning((char const   *)tmp___3);
    }
  }
#line 306
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 308
  fatal_internal("unsupported socket type %d", socktype);
  }
  switch_break: /* CIL Label */ ;
  }
#line 312
  if (attrs->sndbuf_size > 0UL) {
    {
#line 313
    nlen = (socklen_t )sizeof(n);
#line 314
    tmp___8 = getsockopt(sock, 1, 7, (void */* __restrict  */)(& n), (socklen_t */* __restrict  */)(& nlen));
    }
#line 314
    if (tmp___8 < 0) {
      {
#line 315
      tmp___5 = __errno_location();
#line 315
      tmp___6 = strerror(*tmp___5);
#line 315
      warning("error with getsockopt SO_SNDBUF: %s", tmp___6);
      }
    } else {
      {
#line 318
      tmp___7 = gettext("using socket sndbuf size of %d");
#line 318
      warning((char const   *)tmp___7, n);
      }
    }
  }
#line 322
  if (attrs->rcvbuf_size > 0UL) {
    {
#line 323
    nlen = (socklen_t )sizeof(n);
#line 324
    tmp___12 = getsockopt(sock, 1, 8, (void */* __restrict  */)(& n), (socklen_t */* __restrict  */)(& nlen));
    }
#line 324
    if (tmp___12 < 0) {
      {
#line 325
      tmp___9 = __errno_location();
#line 325
      tmp___10 = strerror(*tmp___9);
#line 325
      warning("error with getsockopt SO_RCVBUF: %s", tmp___10);
      }
    } else {
      {
#line 328
      tmp___11 = gettext("using socket rcvbuf size of %d");
#line 328
      warning((char const   *)tmp___11, n);
      }
    }
  }
#line 330
  return;
}
}
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 261 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.h"
ssize_t cb_read(circ_buf_t *cb , int fd , size_t nbytes ) ;
#line 54
ssize_t cb_recv(circ_buf_t *cb , int fd , size_t nbytes , struct sockaddr *from ,
                size_t *fromlen ) ;
#line 57
ssize_t cb_write(circ_buf_t *cb , int fd , size_t nbytes ) ;
#line 58
ssize_t cb_write_crlf(circ_buf_t *cb , int fd , size_t nbytes ) ;
#line 59
ssize_t cb_send(circ_buf_t *cb , int fd , size_t nbytes , struct sockaddr *dest ,
                size_t destlen ) ;
#line 531 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c"
static void ios_assert(io_stream_t const   *ios ) 
{ 


  {
#line 42
  if ((unsigned long )ios == (unsigned long )((void *)0)) {
    {
#line 47
    fatal_internal("I/O stream assertion failed");
    }
  } else
#line 42
  if ((unsigned long )ios->name == (unsigned long )((void *)0)) {
    {
#line 47
    fatal_internal("I/O stream assertion failed");
    }
  } else
#line 42
  if ((unsigned long )ios->buf_in == (unsigned long )((void *)0)) {
    {
#line 47
    fatal_internal("I/O stream assertion failed");
    }
  } else
#line 42
  if ((unsigned long )ios->buf_out == (unsigned long )((void *)0)) {
    {
#line 47
    fatal_internal("I/O stream assertion failed");
    }
  }
#line 49
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c"
void ios_init_socket(io_stream_t *ios , char const   *name , int fd , int socktype ,
                     circ_buf_t *inbuf , circ_buf_t *outbuf ) 
{ 


  {
#line 60
  if (! ((unsigned long )ios != (unsigned long )((void *)0))) {
    {
#line 60
    __assert_fail("ios != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  60U, "ios_init_socket");
    }
  }
#line 61
  if (! ((unsigned long )name != (unsigned long )((void *)0))) {
    {
#line 61
    __assert_fail("name != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  61U, "ios_init_socket");
    }
  }
#line 62
  if (! (fd >= 0)) {
    {
#line 62
    __assert_fail("fd >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  62U, "ios_init_socket");
    }
  }
#line 63
  if (! ((unsigned long )inbuf != (unsigned long )((void *)0))) {
    {
#line 63
    __assert_fail("inbuf != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  63U, "ios_init_socket");
    }
  }
#line 64
  if (! ((unsigned long )outbuf != (unsigned long )((void *)0))) {
    {
#line 64
    __assert_fail("outbuf != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  64U, "ios_init_socket");
    }
  }
  {
#line 66
  ios_init(ios, name, fd, fd, socktype, inbuf, outbuf);
  }
#line 67
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c"
void ios_init_stdio(io_stream_t *ios , char const   *name , circ_buf_t *inbuf , circ_buf_t *outbuf ) 
{ 
  int fd_in ;
  int fd_out ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 77
  if (! ((unsigned long )ios != (unsigned long )((void *)0))) {
    {
#line 77
    __assert_fail("ios != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  77U, "ios_init_stdio");
    }
  }
#line 78
  if (! ((unsigned long )name != (unsigned long )((void *)0))) {
    {
#line 78
    __assert_fail("name != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  78U, "ios_init_stdio");
    }
  }
#line 79
  if (! ((unsigned long )inbuf != (unsigned long )((void *)0))) {
    {
#line 79
    __assert_fail("inbuf != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  79U, "ios_init_stdio");
    }
  }
#line 80
  if (! ((unsigned long )outbuf != (unsigned long )((void *)0))) {
    {
#line 80
    __assert_fail("outbuf != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  80U, "ios_init_stdio");
    }
  }
  {
#line 82
  fd_in = dup(0);
  }
#line 82
  if (fd_in < 0) {
    {
#line 83
    tmp = __errno_location();
#line 83
    tmp___0 = strerror(*tmp);
#line 83
    fatal("error duplicating stdin file descriptor: %s", tmp___0);
    }
  }
  {
#line 86
  fd_out = dup(1);
  }
#line 86
  if (fd_out < 0) {
    {
#line 87
    tmp___1 = __errno_location();
#line 87
    tmp___2 = strerror(*tmp___1);
#line 87
    fatal("error duplicating stdout file descriptor: %s", tmp___2);
    }
  }
  {
#line 91
  ios_init(ios, name, fd_in, fd_out, 1, inbuf, outbuf);
  }
#line 92
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c"
void ios_init(io_stream_t *ios , char const   *name , int fd_in , int fd_out , int socktype ,
              circ_buf_t *inbuf , circ_buf_t *outbuf ) 
{ 
  __suseconds_t tmp ;

  {
#line 101
  if (! ((unsigned long )ios != (unsigned long )((void *)0))) {
    {
#line 101
    __assert_fail("ios != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  101U, "ios_init");
    }
  }
#line 102
  if (! ((unsigned long )name != (unsigned long )((void *)0))) {
    {
#line 102
    __assert_fail("name != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  102U, "ios_init");
    }
  }
#line 103
  if (! (fd_in >= 0)) {
    {
#line 103
    __assert_fail("fd_in >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  103U, "ios_init");
    }
  }
#line 104
  if (! (fd_out >= 0)) {
    {
#line 104
    __assert_fail("fd_out >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  104U, "ios_init");
    }
  }
#line 105
  if (! ((unsigned long )inbuf != (unsigned long )((void *)0))) {
    {
#line 105
    __assert_fail("inbuf != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  105U, "ios_init");
    }
  }
#line 106
  if (! ((unsigned long )outbuf != (unsigned long )((void *)0))) {
    {
#line 106
    __assert_fail("outbuf != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  106U, "ios_init");
    }
  }
  {
#line 108
  ios->fd_in = fd_in;
#line 109
  ios->fd_out = fd_out;
#line 110
  ios->socktype = socktype;
#line 112
  ios->flags = 0;
#line 114
  ios->buf_in = inbuf;
#line 115
  ios->buf_out = outbuf;
#line 117
  ios->mtu = (size_t )0;
#line 118
  ios->nru = (size_t )0;
#line 120
  ios->half_close_suppress = (_Bool)0;
#line 122
  ios->idle_timeout = -1;
#line 123
  gettimeofday((struct timeval */* __restrict  */)(& ios->last_active), (__timezone_ptr_t )((void *)0));
#line 125
  ios->hold_time = -1;
#line 126
  tmp = (__suseconds_t )0;
#line 126
  ios->read_eof.tv_usec = tmp;
#line 126
  ios->read_eof.tv_sec = tmp;
#line 128
  ios->name = xstrdup(name);
#line 129
  ios->rcvd = (size_t )0;
#line 130
  ios->sent = (size_t )0;
  }
#line 131
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c"
void io_stream_destroy(io_stream_t *ios ) 
{ 


  {
  {
#line 138
  ios_assert((io_stream_t const   *)ios);
#line 140
  ios_shutdown(ios, 2);
#line 141
  free((void *)ios->name);
  }
#line 142
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c"
int ios_schedule_read(io_stream_t *ios ) 
{ 
  size_t space ;

  {
  {
#line 151
  ios_assert((io_stream_t const   *)ios);
#line 153
  space = (ios->buf_in)->buf_size - (ios->buf_in)->data_size;
  }
#line 157
  if (ios->fd_in < 0) {
#line 158
    return (-1);
  } else
#line 157
  if (space == 0UL) {
#line 158
    return (-1);
  } else
#line 157
  if (space < ios->nru) {
#line 158
    return (-1);
  }
#line 161
  return (ios->fd_in);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c"
int ios_schedule_write(io_stream_t *ios ) 
{ 


  {
  {
#line 169
  ios_assert((io_stream_t const   *)ios);
  }
#line 172
  if (ios->fd_out < 0) {
#line 173
    return (-1);
  } else
#line 172
  if ((ios->buf_out)->data_size == 0UL) {
#line 173
    return (-1);
  }
#line 176
  return (ios->fd_out);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c"
struct timeval *ios_next_timeout(io_stream_t *ios , struct timeval *tv ) 
{ 
  struct timeval now ;
  struct timeval *tvp ;
  char *tmp ;
  _Bool tmp___0 ;
  __suseconds_t tmp___1 ;
  struct timeval hold_tv ;
  char *tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 184
  tvp = (struct timeval *)((void *)0);
#line 187
  ios_assert((io_stream_t const   *)ios);
  }
#line 188
  if (! ((unsigned long )tv != (unsigned long )((void *)0))) {
    {
#line 188
    __assert_fail("tv != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  188U, "ios_next_timeout");
    }
  }
#line 191
  if (ios->idle_timeout > 0) {
    {
#line 193
    gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
    }
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
#line 196
      tv->tv_sec = ios->last_active.tv_sec - now.tv_sec;
#line 196
      tv->tv_usec = ios->last_active.tv_usec - now.tv_usec;
#line 196
      if (tv->tv_usec < 0L) {
#line 196
        (tv->tv_sec) --;
#line 196
        tv->tv_usec += 1000000L;
      }
#line 196
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 197
    tv->tv_sec += (__time_t )ios->idle_timeout;
#line 198
    tvp = tv;
#line 201
    if (tv->tv_sec < 0L) {
#line 201
      goto _L;
    } else
#line 201
    if (tv->tv_sec == 0L) {
#line 201
      if (tv->tv_usec <= 0L) {
        _L: /* CIL Label */ 
        {
#line 202
        tmp___0 = very_verbose_mode();
        }
#line 202
        if (tmp___0) {
          {
#line 203
          tmp = gettext("%s idle timed out");
#line 203
          warning((char const   *)tmp, ios->name);
          }
        }
#line 204
        ios->flags |= 8;
#line 205
        tmp___1 = (__suseconds_t )0;
#line 205
        tv->tv_usec = tmp___1;
#line 205
        tv->tv_sec = tmp___1;
      }
    }
  }
#line 210
  if (ios->flags & 1) {
#line 210
    if (ios->hold_time >= 0) {
#line 214
      if (ios->hold_time == 0) {
#line 217
        ios->flags |= 4;
#line 218
        hold_tv.tv_usec = (__suseconds_t )0;
#line 218
        hold_tv.tv_sec = hold_tv.tv_usec;
      } else {
#line 222
        if ((unsigned long )tvp == (unsigned long )((void *)0)) {
          {
#line 223
          gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
          }
        }
        {
#line 224
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 224
          hold_tv.tv_sec = ios->read_eof.tv_sec - now.tv_sec;
#line 224
          hold_tv.tv_usec = ios->read_eof.tv_usec - now.tv_usec;
#line 224
          if (hold_tv.tv_usec < 0L) {
#line 224
            (hold_tv.tv_sec) --;
#line 224
            hold_tv.tv_usec += 1000000L;
          }
#line 224
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 225
        hold_tv.tv_sec += (__time_t )ios->hold_time;
      }
#line 229
      if (hold_tv.tv_sec < 0L) {
#line 229
        goto _L___0;
      } else
#line 229
      if (hold_tv.tv_sec == 0L) {
#line 229
        if (hold_tv.tv_usec <= 0L) {
          _L___0: /* CIL Label */ 
          {
#line 230
          tmp___3 = very_verbose_mode();
          }
#line 230
          if (tmp___3) {
            {
#line 231
            tmp___2 = gettext("%s hold timed out");
#line 231
            warning((char const   *)tmp___2, ios->name);
            }
          }
#line 233
          ios->flags |= 4;
#line 234
          hold_tv.tv_usec = (__suseconds_t )0;
#line 234
          hold_tv.tv_sec = hold_tv.tv_usec;
        }
      }
#line 238
      if ((unsigned long )tvp == (unsigned long )((void *)0)) {
#line 239
        *tv = hold_tv;
#line 240
        tvp = tv;
      } else {
#line 238
        if (hold_tv.tv_sec == tv->tv_sec) {
#line 238
          tmp___4 = hold_tv.tv_usec < tv->tv_usec;
        } else {
#line 238
          tmp___4 = hold_tv.tv_sec < tv->tv_sec;
        }
#line 238
        if (tmp___4) {
#line 239
          *tv = hold_tv;
#line 240
          tvp = tv;
        }
      }
    }
  }
#line 245
  if (tvp) {
#line 245
    if (! (tvp->tv_sec < 0L)) {
#line 245
      if (tvp->tv_sec == 0L) {
#line 245
        if (! (tvp->tv_usec <= 0L)) {
#line 245
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 245
        tmp___5 = very_verbose_mode();
        }
#line 245
        if (tmp___5) {
          {
#line 246
          warning("%s timer expires in %d.%06d", ios->name, tvp->tv_sec, tvp->tv_usec);
          }
        }
      }
    }
  }
#line 250
  return (tvp);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c"
ssize_t ios_read(io_stream_t *ios ) 
{ 
  ssize_t rr ;
  _Bool tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 260
  ios_assert((io_stream_t const   *)ios);
  }
#line 263
  if (! (ios->fd_in >= 0)) {
    {
#line 263
    __assert_fail("ios->fd_in >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  263U, "ios_read");
    }
  }
#line 264
  if (! ((ios->buf_in)->buf_size - (ios->buf_in)->data_size >= ios->nru)) {
    {
#line 264
    __assert_fail("((ios->buf_in)->buf_size - (ios->buf_in)->data_size) >= ios->nru",
                  "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  264U, "ios_read");
    }
  }
#line 267
  if (ios->socktype == 2) {
    {
#line 268
    rr = cb_recv(ios->buf_in, ios->fd_in, (size_t )0, (struct sockaddr *)((void *)0),
                 (size_t *)0);
    }
  } else {
    {
#line 270
    rr = cb_read(ios->buf_in, ios->fd_in, (size_t )0);
    }
  }
#line 272
  if (rr > 0L) {
    {
#line 273
    ios->rcvd += (size_t )rr;
#line 275
    tmp = very_verbose_mode();
    }
#line 275
    if (tmp) {
      {
#line 276
      warning("read %d bytes from %s", rr, ios->name);
      }
    }
    {
#line 279
    gettimeofday((struct timeval */* __restrict  */)(& ios->last_active), (__timezone_ptr_t )((void *)0));
    }
#line 281
    return (rr);
  } else
#line 282
  if (rr == 0L) {
    {
#line 284
    tmp___1 = very_verbose_mode();
    }
#line 284
    if (tmp___1) {
      {
#line 285
      tmp___0 = gettext("read eof from %s");
#line 285
      warning((char const   *)tmp___0, ios->name);
      }
    }
    {
#line 288
    gettimeofday((struct timeval */* __restrict  */)(& ios->read_eof), (__timezone_ptr_t )((void *)0));
#line 291
    ios->flags |= 1;
#line 294
    ios_shutdown(ios, 0);
    }
#line 296
    return ((ssize_t )-2);
  } else {
    {
#line 297
    tmp___6 = __errno_location();
    }
#line 297
    if (*tmp___6 == 11) {
#line 299
      return ((ssize_t )0);
    } else {
      {
#line 302
      tmp___5 = very_verbose_mode();
      }
#line 302
      if (tmp___5) {
        {
#line 303
        tmp___2 = __errno_location();
#line 303
        tmp___3 = strerror(*tmp___2);
#line 303
        tmp___4 = gettext("error reading from %s: %s");
#line 303
        warning((char const   *)tmp___4, ios->name, tmp___3);
        }
      }
#line 305
      return ((ssize_t )-1);
    }
  }
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c"
ssize_t ios_write(io_stream_t *ios ) 
{ 
  ssize_t rr ;
  _Bool tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  _Bool tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 316
  ios_assert((io_stream_t const   *)ios);
  }
#line 319
  if (! (ios->fd_out >= 0)) {
    {
#line 319
    __assert_fail("ios->fd_out >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  319U, "ios_write");
    }
  }
#line 320
  if (! (! ((ios->buf_out)->data_size == 0UL))) {
    {
#line 320
    __assert_fail("!(((ios->buf_out)->data_size) == 0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  320U, "ios_write");
    }
  }
#line 323
  if (ios->socktype == 2) {
    {
#line 324
    rr = cb_send(ios->buf_out, ios->fd_out, ios->mtu, (struct sockaddr *)((void *)0),
                 (size_t )0);
    }
  } else {
    {
#line 326
    rr = cb_write(ios->buf_out, ios->fd_out, ios->mtu);
    }
  }
#line 328
  if (rr > 0L) {
    {
#line 329
    ios->sent += (size_t )rr;
#line 331
    tmp = very_verbose_mode();
    }
#line 331
    if (tmp) {
      {
#line 332
      warning("wrote %d bytes to %s", rr, ios->name);
      }
    }
    {
#line 335
    gettimeofday((struct timeval */* __restrict  */)(& ios->last_active), (__timezone_ptr_t )((void *)0));
    }
#line 338
    if (ios->flags & 2) {
#line 338
      if ((ios->buf_out)->data_size == 0UL) {
        {
#line 339
        ios_shutdown(ios, 1);
        }
      }
    }
#line 341
    return (rr);
  } else
#line 342
  if (rr == 0L) {
#line 344
    return ((ssize_t )0);
  } else {
    {
#line 345
    tmp___6 = __errno_location();
    }
#line 345
    if (*tmp___6 == 11) {
#line 347
      return ((ssize_t )0);
    } else {
      {
#line 349
      tmp___5 = very_verbose_mode();
      }
#line 349
      if (tmp___5) {
        {
#line 350
        tmp___4 = __errno_location();
        }
#line 350
        if (*tmp___4 == 32) {
          {
#line 351
          tmp___0 = gettext("received SIGPIPE on %s");
#line 351
          warning((char const   *)tmp___0, ios->name);
          }
        } else {
          {
#line 353
          tmp___1 = __errno_location();
#line 353
          tmp___2 = strerror(*tmp___1);
#line 353
          tmp___3 = gettext("error writing to %s: %s");
#line 353
          warning((char const   *)tmp___3, ios->name, tmp___2);
          }
        }
      }
#line 356
      return ((ssize_t )-1);
    }
  }
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c"
ssize_t ios_write_crlf(io_stream_t *ios ) 
{ 
  ssize_t rr ;
  _Bool tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  _Bool tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 367
  ios_assert((io_stream_t const   *)ios);
  }
#line 370
  if (! (ios->fd_out >= 0)) {
    {
#line 370
    __assert_fail("ios->fd_out >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  370U, "ios_write_crlf");
    }
  }
#line 371
  if (! (! ((ios->buf_out)->data_size == 0UL))) {
    {
#line 371
    __assert_fail("!(((ios->buf_out)->data_size) == 0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                  371U, "ios_write_crlf");
    }
  }
#line 374
  if (ios->socktype == 2) {
    {
#line 375
    rr = cb_send(ios->buf_out, ios->fd_out, ios->mtu, (struct sockaddr *)((void *)0),
                 (size_t )0);
    }
  } else {
    {
#line 377
    rr = cb_write_crlf(ios->buf_out, ios->fd_out, ios->mtu);
    }
  }
#line 379
  if (rr > 0L) {
    {
#line 380
    ios->sent += (size_t )rr;
#line 382
    tmp = very_verbose_mode();
    }
#line 382
    if (tmp) {
      {
#line 383
      warning("wrote %d bytes to %s", rr, ios->name);
      }
    }
    {
#line 386
    gettimeofday((struct timeval */* __restrict  */)(& ios->last_active), (__timezone_ptr_t )((void *)0));
    }
#line 389
    if (ios->flags & 2) {
#line 389
      if ((ios->buf_out)->data_size == 0UL) {
        {
#line 390
        ios_shutdown(ios, 1);
        }
      }
    }
#line 392
    return (rr);
  } else
#line 393
  if (rr == 0L) {
#line 395
    return ((ssize_t )0);
  } else {
    {
#line 396
    tmp___6 = __errno_location();
    }
#line 396
    if (*tmp___6 == 11) {
#line 398
      return ((ssize_t )0);
    } else {
      {
#line 400
      tmp___5 = very_verbose_mode();
      }
#line 400
      if (tmp___5) {
        {
#line 401
        tmp___4 = __errno_location();
        }
#line 401
        if (*tmp___4 == 32) {
          {
#line 402
          tmp___0 = gettext("received SIGPIPE on %s");
#line 402
          warning((char const   *)tmp___0, ios->name);
          }
        } else {
          {
#line 404
          tmp___1 = __errno_location();
#line 404
          tmp___2 = strerror(*tmp___1);
#line 404
          tmp___3 = gettext("error writing to %s: %s");
#line 404
          warning((char const   *)tmp___3, ios->name, tmp___2);
          }
        }
      }
#line 407
      return ((ssize_t )-1);
    }
  }
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c"
void ios_write_eof(io_stream_t *ios ) 
{ 


  {
  {
#line 416
  ios_assert((io_stream_t const   *)ios);
#line 418
  ios->flags |= 2;
  }
#line 420
  if ((ios->buf_out)->data_size == 0UL) {
    {
#line 421
    ios_shutdown(ios, 1);
    }
  }
#line 422
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c"
void ios_shutdown(io_stream_t *ios , int how ) 
{ 
  char *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  char *tmp___6 ;
  _Bool tmp___7 ;
  char *tmp___8 ;
  _Bool tmp___9 ;

  {
  {
#line 429
  ios_assert((io_stream_t const   *)ios);
  }
#line 431
  if (how == 2) {
#line 433
    if (ios->fd_in < 0) {
#line 433
      if (ios->fd_out < 0) {
#line 434
        return;
      }
    }
#line 436
    if (ios->fd_in >= 0) {
      {
#line 437
      close(ios->fd_in);
      }
    }
#line 439
    if (ios->fd_out >= 0) {
#line 439
      if (ios->fd_out != ios->fd_in) {
        {
#line 440
        close(ios->fd_out);
        }
      }
    }
    {
#line 441
    tmp___0 = very_verbose_mode();
    }
#line 441
    if (tmp___0) {
      {
#line 442
      tmp = gettext("closed %s");
#line 442
      warning((char const   *)tmp, ios->name);
      }
    }
#line 443
    tmp___1 = -1;
#line 443
    ios->fd_out = tmp___1;
#line 443
    ios->fd_in = tmp___1;
  } else
#line 444
  if (how == 0) {
#line 446
    if (ios->fd_in < 0) {
#line 447
      return;
    }
#line 450
    if (ios->fd_in == ios->fd_out) {
#line 451
      if (! ios->half_close_suppress) {
        {
#line 452
        shutdown(ios->fd_in, 0);
#line 453
        tmp___3 = very_verbose_mode();
        }
#line 453
        if (tmp___3) {
          {
#line 454
          tmp___2 = gettext("shutdown %s for read");
#line 454
          warning((char const   *)tmp___2, ios->name);
          }
        }
      }
    } else {
      {
#line 458
      close(ios->fd_in);
#line 459
      tmp___5 = very_verbose_mode();
      }
#line 459
      if (tmp___5) {
        {
#line 460
        tmp___4 = gettext("closed %s for read");
#line 460
        warning((char const   *)tmp___4, ios->name);
        }
      }
    }
#line 462
    ios->fd_in = -1;
  } else {
#line 464
    if (! (how == 1)) {
      {
#line 464
      __assert_fail("how == SHUT_WR", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/io_stream.c",
                    464U, "ios_shutdown");
      }
    }
#line 467
    if (ios->fd_out < 0) {
#line 468
      return;
    }
#line 471
    if (ios->fd_in == ios->fd_out) {
#line 472
      if (! ios->half_close_suppress) {
        {
#line 473
        shutdown(ios->fd_out, 1);
#line 474
        tmp___7 = very_verbose_mode();
        }
#line 474
        if (tmp___7) {
          {
#line 475
          tmp___6 = gettext("shutdown %s for write");
#line 475
          warning((char const   *)tmp___6, ios->name);
          }
        }
      }
    } else {
      {
#line 479
      close(ios->fd_out);
#line 480
      tmp___9 = very_verbose_mode();
      }
#line 480
      if (tmp___9) {
        {
#line 481
        tmp___8 = gettext("closed %s for write");
#line 481
        warning((char const   *)tmp___8, ios->name);
        }
      }
    }
#line 483
    ios->fd_out = -1;
  }
#line 485
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 137 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.h"
int connect_with_timeout(int fd , struct sockaddr  const  *sa , socklen_t salen ,
                         int timeout ) ;
#line 37
_Bool unsupported_sock_error(int err ) ;
#line 42
_Bool is_address_ipv4_mapped(struct sockaddr  const  *a ) ;
#line 47
_Bool sockaddr_compare(struct sockaddr  const  *a , socklen_t a_len , struct sockaddr  const  *b ,
                       socklen_t b_len ) ;
#line 58
bound_socket_t *add_bound_socket(bound_socket_t *list , int fd , int socktype ) ;
#line 61
int get_bound_socket_type(bound_socket_t const   *list , int fd ) ;
#line 64
void free_bound_sockets(bound_socket_t *list ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 227 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c"
int connect_with_timeout(int fd , struct sockaddr  const  *sa , socklen_t salen ,
                         int timeout ) 
{ 
  int err ;
  struct timeval tv ;
  struct timeval *tvp ;
  fd_set connect_fdset ;
  socklen_t len ;
  int optval ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 56
  tvp = (struct timeval *)((void *)0);
#line 61
  if (! ((unsigned long )sa != (unsigned long )((void *)0))) {
    {
#line 61
    __assert_fail("sa != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c",
                  61U, "connect_with_timeout");
    }
  }
#line 62
  if (! (salen > 0U)) {
    {
#line 62
    __assert_fail("salen > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c",
                  62U, "connect_with_timeout");
    }
  }
#line 65
  if (timeout > 0) {
#line 66
    tv.tv_sec = (time_t )timeout;
#line 67
    tv.tv_usec = (__suseconds_t )0;
#line 68
    tvp = & tv;
  }
  {
#line 72
  nonblock(fd);
#line 75
  err = connect(fd, sa, salen);
  }
#line 77
  if (err != 0) {
    {
#line 77
    tmp___2 = __errno_location();
    }
#line 77
    if (*tmp___2 == 115) {
      {
#line 82
      while (1) {
        while_continue: /* CIL Label */ ;
#line 82
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& connect_fdset.__fds_bits[0]): "memory");
#line 82
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 83
      connect_fdset.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
      {
#line 86
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 87
        err = select(fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& connect_fdset),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)tvp);
        }
#line 86
        if (err < 0) {
          {
#line 86
          tmp = __errno_location();
          }
#line 86
          if (! (*tmp == 4)) {
#line 86
            goto while_break___0;
          }
        } else {
#line 86
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 92
      if (err < 0) {
#line 93
        return (-1);
      }
#line 96
      if (err == 0) {
        {
#line 98
        tmp___0 = __errno_location();
#line 98
        *tmp___0 = 110;
        }
#line 99
        return (-1);
      }
      {
#line 104
      len = (socklen_t )sizeof(optval);
#line 105
      err = getsockopt(fd, 1, 4, (void */* __restrict  */)(& optval), (socklen_t */* __restrict  */)(& len));
      }
#line 106
      if (err != 0) {
#line 107
        return (err);
      }
#line 111
      if (optval != 0) {
        {
#line 113
        tmp___1 = __errno_location();
#line 113
        *tmp___1 = optval;
        }
#line 114
        return (-1);
      }
    }
  }
#line 118
  return (0);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c"
_Bool is_address_ipv4_mapped(struct sockaddr  const  *a ) 
{ 
  _Bool ret ;
  struct sockaddr_in6  const  *tmp ;
  struct in6_addr  const  *__a ;
  uint32_t tmp___0 ;
  int tmp___1 ;

  {
#line 127
  ret = (_Bool)0;
#line 128
  tmp = (struct sockaddr_in6  const  *)a;
#line 130
  if (! ((unsigned long )a != (unsigned long )((void *)0))) {
    {
#line 130
    __assert_fail("a != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c",
                  130U, "is_address_ipv4_mapped");
    }
  }
#line 133
  if ((int const   )a->sa_family == 10) {
#line 133
    __a = & tmp->sin6_addr;
#line 133
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 133
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
        {
#line 133
        tmp___0 = htonl((uint32_t )65535);
        }
#line 133
        if (__a->__in6_u.__u6_addr32[2] == tmp___0) {
#line 133
          tmp___1 = 1;
        } else {
#line 133
          tmp___1 = 0;
        }
      } else {
#line 133
        tmp___1 = 0;
      }
    } else {
#line 133
      tmp___1 = 0;
    }
#line 133
    if (tmp___1) {
#line 135
      ret = (_Bool)1;
    }
  }
#line 138
  return (ret);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c"
_Bool sockaddr_compare(struct sockaddr  const  *a , socklen_t a_len , struct sockaddr  const  *b ,
                       socklen_t b_len ) 
{ 
  struct sockaddr_in6  const  *a6 ;
  struct sockaddr_in *a_in ;
  void *tmp ;
  _Bool tmp___0 ;
  struct sockaddr_in6  const  *b6 ;
  struct sockaddr_in *b_in ;
  void *tmp___1 ;
  _Bool tmp___2 ;
  struct sockaddr_in6  const  *a6___0 ;
  struct sockaddr_in6  const  *b6___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct sockaddr_in  const  *a_in___0 ;
  struct sockaddr_in  const  *b_in___0 ;
  int tmp___7 ;

  {
#line 148
  if (! ((unsigned long )a != (unsigned long )((void *)0))) {
    {
#line 148
    __assert_fail("a != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c",
                  148U, "sockaddr_compare");
    }
  }
#line 149
  if (! ((unsigned long )b != (unsigned long )((void *)0))) {
    {
#line 149
    __assert_fail("b != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c",
                  149U, "sockaddr_compare");
    }
  }
#line 150
  if (! (a_len > 0U)) {
    {
#line 150
    __assert_fail("a_len > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c",
                  150U, "sockaddr_compare");
    }
  }
#line 151
  if (! (b_len > 0U)) {
    {
#line 151
    __assert_fail("b_len > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c",
                  151U, "sockaddr_compare");
    }
  }
  {
#line 155
  tmp___0 = is_address_ipv4_mapped(a);
  }
#line 155
  if (tmp___0) {
    {
#line 159
    a6 = (struct sockaddr_in6  const  *)a;
#line 160
    tmp = __builtin_alloca(sizeof(struct sockaddr_in ));
#line 160
    a_in = (struct sockaddr_in *)tmp;
#line 162
    memset((void *)a_in, 0, sizeof(struct sockaddr_in ));
#line 163
    memcpy((void */* __restrict  */)(& a_in->sin_addr.s_addr), (void const   */* __restrict  */)(& a6->sin6_addr.__in6_u.__u6_addr8[12]),
           sizeof(struct in_addr ));
#line 165
    a_in->sin_port = (in_port_t )a6->sin6_port;
#line 166
    a = (struct sockaddr  const  *)a_in;
    }
  }
  {
#line 169
  tmp___2 = is_address_ipv4_mapped(b);
  }
#line 169
  if (tmp___2) {
    {
#line 173
    b6 = (struct sockaddr_in6  const  *)b;
#line 174
    tmp___1 = __builtin_alloca(sizeof(struct sockaddr_in ));
#line 174
    b_in = (struct sockaddr_in *)tmp___1;
#line 176
    memset((void *)b_in, 0, sizeof(struct sockaddr_in ));
#line 177
    memcpy((void */* __restrict  */)(& b_in->sin_addr.s_addr), (void const   */* __restrict  */)(& b6->sin6_addr.__in6_u.__u6_addr8[12]),
           sizeof(struct in_addr ));
#line 179
    b_in->sin_port = (in_port_t )b6->sin6_port;
#line 180
    b = (struct sockaddr  const  *)b_in;
    }
  }
#line 187
  if ((int const   )a->sa_family != (int const   )b->sa_family) {
#line 188
    return ((_Bool)0);
  }
#line 193
  if ((int const   )a->sa_family == 10) {
#line 194
    a6___0 = (struct sockaddr_in6  const  *)a;
#line 195
    b6___0 = (struct sockaddr_in6  const  *)b;
#line 199
    if (a6___0->sin6_scope_id) {
#line 199
      if (b6___0->sin6_scope_id) {
#line 199
        if (a6___0->sin6_scope_id != b6___0->sin6_scope_id) {
#line 202
          return ((_Bool)0);
        }
      }
    }
    {
#line 207
    tmp___3 = memcmp((void const   *)(& a6___0->sin6_addr), (void const   *)(& in6addr_any),
                     sizeof(struct in6_addr ));
    }
#line 207
    if (tmp___3 != 0) {
      {
#line 207
      tmp___4 = memcmp((void const   *)(& b6___0->sin6_addr), (void const   *)(& in6addr_any),
                       sizeof(struct in6_addr ));
      }
#line 207
      if (tmp___4 != 0) {
        {
#line 207
        tmp___5 = memcmp((void const   *)(& a6___0->sin6_addr), (void const   *)(& b6___0->sin6_addr),
                         sizeof(struct in6_addr ));
        }
#line 207
        if (tmp___5 != 0) {
#line 214
          return ((_Bool)0);
        }
      }
    }
#line 219
    if ((int const   )a6___0->sin6_port == 0) {
#line 219
      tmp___6 = 1;
    } else
#line 219
    if ((int const   )b6___0->sin6_port == 0) {
#line 219
      tmp___6 = 1;
    } else
#line 219
    if ((int const   )a6___0->sin6_port == (int const   )b6___0->sin6_port) {
#line 219
      tmp___6 = 1;
    } else {
#line 219
      tmp___6 = 0;
    }
#line 219
    return ((_Bool )tmp___6);
  }
#line 224
  if ((int const   )a->sa_family == 2) {
#line 225
    a_in___0 = (struct sockaddr_in  const  *)a;
#line 226
    b_in___0 = (struct sockaddr_in  const  *)b;
#line 230
    if (a_in___0->sin_addr.s_addr != 0U) {
#line 230
      if (b_in___0->sin_addr.s_addr != 0U) {
#line 230
        if (a_in___0->sin_addr.s_addr != b_in___0->sin_addr.s_addr) {
#line 234
          return ((_Bool)0);
        }
      }
    }
#line 239
    if ((int const   )a_in___0->sin_port == 0) {
#line 239
      tmp___7 = 1;
    } else
#line 239
    if ((int const   )b_in___0->sin_port == 0) {
#line 239
      tmp___7 = 1;
    } else
#line 239
    if ((int const   )a_in___0->sin_port == (int const   )b_in___0->sin_port) {
#line 239
      tmp___7 = 1;
    } else {
#line 239
      tmp___7 = 0;
    }
#line 239
    return ((_Bool )tmp___7);
  }
#line 252
  return ((_Bool)0);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c"
_Bool unsupported_sock_error(int err ) 
{ 
  int tmp ;

  {
#line 263
  if (err == 96) {
#line 263
    tmp = 1;
  } else
#line 263
  if (err == 97) {
#line 263
    tmp = 1;
  } else
#line 263
  if (err == 93) {
#line 263
    tmp = 1;
  } else
#line 263
  if (err == 94) {
#line 263
    tmp = 1;
  } else
#line 263
  if (err == 92) {
#line 263
    tmp = 1;
  } else {
#line 263
    tmp = 0;
  }
#line 263
  return ((_Bool )tmp);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c"
bound_socket_t *add_bound_socket(bound_socket_t *list , int fd , int socktype ) 
{ 
  bound_socket_t *fdnew ;
  void *tmp ;

  {
  {
#line 279
  tmp = xmalloc(sizeof(bound_socket_t ));
#line 279
  fdnew = (bound_socket_t *)tmp;
#line 281
  fdnew->fd = fd;
#line 282
  fdnew->socktype = socktype;
#line 285
  fdnew->next = list;
  }
#line 287
  return (fdnew);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c"
int get_bound_socket_type(bound_socket_t const   *list , int fd ) 
{ 
  int tmp ;

  {
#line 295
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 295
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c",
                  295U, "get_bound_socket_type");
    }
  }
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if ((unsigned long )list != (unsigned long )((void *)0)) {
#line 297
      if (! (list->fd != (int const   )fd)) {
#line 297
        goto while_break;
      }
    } else {
#line 297
      goto while_break;
    }
#line 298
    list = (bound_socket_t const   *)list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  if ((unsigned long )list != (unsigned long )((void *)0)) {
#line 300
    tmp = list->socktype;
  } else {
#line 300
    tmp = (int const   )-1;
  }
#line 300
  return ((int )tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c"
void free_bound_sockets(bound_socket_t *list ) 
{ 
  bound_socket_t *tmp ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 310
      goto while_break;
    }
    {
#line 311
    tmp = list;
#line 312
    list = list->next;
#line 313
    free((void *)tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  return;
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/netsupport.c"
void close_and_destroy_bound_sockets(bound_socket_t *list ) 
{ 
  bound_socket_t *tmp ;

  {
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 324
      goto while_break;
    }
    {
#line 325
    tmp = list;
#line 326
    list = list->next;
#line 327
    close(tmp->fd);
#line 328
    free((void *)tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 27 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.h"
_Bool verbose_mode(void) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 46 "../contrib/getopt.h"
extern char *optarg ;
#line 60
extern int optind ;
#line 150
extern int getopt_long(int __argc , char * const  *__argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
static unsigned long const   DEFAULT_UDP_MTU  =    (size_t const   )8192;
#line 44 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
static unsigned long const   DEFAULT_UDP_NRU  =    (size_t const   )65536;
#line 46 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
static unsigned long const   DEFAULT_BLUETOOTH_MTU  =    (size_t const   )672;
#line 48 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
static unsigned long const   DEFAULT_UDP_BUFFER_SIZE  =    (size_t const   )131072;
#line 50 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
static unsigned long const   DEFAULT_FILE_TRANSFER_BUFFER_SIZE  =    (size_t const   )65536;
#line 54 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
static int const   VERBOSE_MODE  =    (int const   )1;
#line 55 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
static int const   VERY_VERBOSE_MODE  =    (int const   )2;
#line 58 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
static int _verbosity_level  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
static int opt_crlf  =    0;
#line 62 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
static struct option  const  long_options[27]  = 
#line 62
  {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 0}, 
        {"listen", 0, (int *)((void *)0), 'l'}, 
        {"port", 1, (int *)((void *)0), 'p'}, 
        {"hold-timeout", 1, (int *)((void *)0), 'q'}, 
        {"address", 1, (int *)((void *)0), 's'}, 
        {"udp", 0, (int *)((void *)0), 'u'}, 
        {"timeout", 1, (int *)((void *)0), 'w'}, 
        {"idle-timeout", 1, (int *)((void *)0), 't'}, 
        {"transfer", 0, (int *)((void *)0), 'x'}, 
        {"rev-transfer", 0, (int *)((void *)0), 'X'}, 
        {"recv-only", 0, (int *)((void *)0), 0}, 
        {"send-only", 0, (int *)((void *)0), 0}, 
        {"buffer-size", 1, (int *)((void *)0), 0}, 
        {"mtu", 1, (int *)((void *)0), 0}, 
        {"nru", 1, (int *)((void *)0), 0}, 
        {"half-close", 0, (int *)((void *)0), 0}, 
        {"disable-nagle", 0, (int *)((void *)0), 0}, 
        {"no-reuseaddr", 0, (int *)((void *)0), 0}, 
        {"sndbuf-size", 1, (int *)((void *)0), 0}, 
        {"rcvbuf-size", 1, (int *)((void *)0), 0}, 
        {"exec", 1, (int *)((void *)0), 'e'}, 
        {"continuous", 0, (int *)((void *)0), 0}, 
        {"bluetooth", 0, (int *)((void *)0), 'b'}, 
        {"sco", 0, (int *)((void *)0), 0}, 
        {"ttl", 1, (int *)((void *)0), 'T'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 121
static int parse_int_pair(char const   *str , int *first , int *second ) ;
#line 122
static void print_usage(FILE *fp ) ;
#line 123
static void print_version(FILE *fp ) ;
#line 127 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
void parse_arguments(int argc , char **argv , connection_attributes_t *attrs ) 
{ 
  int c ;
  int option_index ;
  sock_family_t family ;
  sock_protocol_t protocol ;
  address_t local_address ;
  address_t remote_address ;
  _Bool listen_mode ;
  _Bool file_transfer ;
  _Bool rev_file_transfer ;
  _Bool half_close ;
  int connect_timeout ;
  int idle_timeout ;
  _Bool set_local_hold_timeout ;
  int local_hold_timeout ;
  _Bool set_remote_hold_timeout ;
  int remote_hold_timeout ;
  int remote_mtu ;
  int remote_nru ;
  int ttl ;
  int buffer_size ;
  int sndbuf_size ;
  int rcvbuf_size ;
  _Bool zflag ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;

  {
#line 130
  option_index = 0;
#line 133
  family = (sock_family_t )0;
#line 134
  protocol = (sock_protocol_t )0;
#line 136
  listen_mode = (_Bool)0;
#line 137
  file_transfer = (_Bool)0;
#line 138
  rev_file_transfer = (_Bool)0;
#line 139
  half_close = (_Bool)0;
#line 140
  connect_timeout = -1;
#line 141
  idle_timeout = -1;
#line 142
  set_local_hold_timeout = (_Bool)0;
#line 143
  local_hold_timeout = 0;
#line 144
  set_remote_hold_timeout = (_Bool)0;
#line 145
  remote_hold_timeout = 0;
#line 146
  remote_mtu = 0;
#line 147
  remote_nru = 0;
#line 148
  ttl = -1;
#line 149
  buffer_size = 0;
#line 150
  sndbuf_size = 0;
#line 151
  rcvbuf_size = 0;
#line 152
  zflag = (_Bool)0;
#line 155
  if (! (argc > 0)) {
    {
#line 155
    __assert_fail("argc > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                  155U, "parse_arguments");
    }
  }
#line 156
  if (! ((unsigned long )argv != (unsigned long )((void *)0))) {
    {
#line 156
    __assert_fail("argv != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                  156U, "parse_arguments");
    }
  }
#line 157
  if (! ((unsigned long )*argv != (unsigned long )((void *)0))) {
    {
#line 157
    __assert_fail("*argv != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                  157U, "parse_arguments");
    }
  }
#line 158
  if (! ((unsigned long )attrs != (unsigned long )((void *)0))) {
    {
#line 158
    __assert_fail("attrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                  158U, "parse_arguments");
    }
  }
#line 161
  remote_address.service = (char *)((void *)0);
#line 161
  remote_address.address = remote_address.service;
#line 162
  local_address.service = (char *)((void *)0);
#line 162
  local_address.address = local_address.service;
#line 165
  _verbosity_level = 0;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 168
    c = getopt_long(argc, (char * const  *)argv, "46be:T:hlnp:q:s:uvw:xXCt:z", long_options,
                    & option_index);
    }
#line 168
    if (! (c >= 0)) {
#line 168
      goto while_break;
    }
    {
#line 172
    if (c == 0) {
#line 172
      goto case_0;
    }
#line 232
    if (c == 52) {
#line 232
      goto case_52;
    }
#line 235
    if (c == 54) {
#line 235
      goto case_54;
    }
#line 239
    if (c == 98) {
#line 239
      goto case_98;
    }
#line 242
    if (c == 101) {
#line 242
      goto case_101;
    }
#line 246
    if (c == 104) {
#line 246
      goto case_104;
    }
#line 249
    if (c == 108) {
#line 249
      goto case_108;
    }
#line 252
    if (c == 110) {
#line 252
      goto case_110;
    }
#line 255
    if (c == 112) {
#line 255
      goto case_112;
    }
#line 259
    if (c == 113) {
#line 259
      goto case_113;
    }
#line 270
    if (c == 115) {
#line 270
      goto case_115;
    }
#line 274
    if (c == 116) {
#line 274
      goto case_116;
    }
#line 279
    if (c == 117) {
#line 279
      goto case_117;
    }
#line 290
    if (c == 118) {
#line 290
      goto case_118;
    }
#line 293
    if (c == 67) {
#line 293
      goto case_67;
    }
#line 301
    if (c == 119) {
#line 301
      goto case_119;
    }
#line 306
    if (c == 120) {
#line 306
      goto case_120;
    }
#line 309
    if (c == 88) {
#line 309
      goto case_88;
    }
#line 312
    if (c == 84) {
#line 312
      goto case_84;
    }
#line 320
    if (c == 122) {
#line 320
      goto case_122;
    }
#line 323
    if (c == 63) {
#line 323
      goto case_63;
    }
#line 326
    goto switch_default___1;
    case_0: /* CIL Label */ 
    {
#line 174
    if (option_index == 1) {
#line 174
      goto case_1;
    }
#line 177
    if (option_index == 11) {
#line 177
      goto case_11;
    }
#line 180
    if (option_index == 12) {
#line 180
      goto case_12;
    }
#line 183
    if (option_index == 13) {
#line 183
      goto case_13;
    }
#line 189
    if (option_index == 14) {
#line 189
      goto case_14;
    }
#line 194
    if (option_index == 15) {
#line 194
      goto case_15;
    }
#line 199
    if (option_index == 16) {
#line 199
      goto case_16;
    }
#line 202
    if (option_index == 17) {
#line 202
      goto case_17;
    }
#line 205
    if (option_index == 18) {
#line 205
      goto case_18;
    }
#line 208
    if (option_index == 19) {
#line 208
      goto case_19;
    }
#line 214
    if (option_index == 20) {
#line 214
      goto case_20;
    }
#line 220
    if (option_index == 22) {
#line 220
      goto case_22;
    }
#line 223
    if (option_index == 24) {
#line 223
      goto case_24;
    }
#line 226
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 175
    print_version(stdout);
#line 176
    exit(0);
    }
    case_11: /* CIL Label */ 
#line 178
    attrs->flags |= 32;
#line 179
    goto switch_break___0;
    case_12: /* CIL Label */ 
#line 181
    attrs->flags |= 64;
#line 182
    goto switch_break___0;
    case_13: /* CIL Label */ 
#line 184
    if (! ((unsigned long )optarg != (unsigned long )((void *)0))) {
      {
#line 184
      __assert_fail("optarg != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                    184U, "parse_arguments");
      }
    }
    {
#line 185
    tmp___0 = safe_atoi((char const   *)optarg, & buffer_size);
    }
#line 185
    if (tmp___0) {
      {
#line 186
      tmp = gettext("invalid argument to --buffer-size");
#line 186
      fatal((char const   *)tmp);
      }
    }
#line 188
    goto switch_break___0;
    case_14: /* CIL Label */ 
#line 190
    if (! ((unsigned long )optarg != (unsigned long )((void *)0))) {
      {
#line 190
      __assert_fail("optarg != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                    190U, "parse_arguments");
      }
    }
    {
#line 191
    tmp___2 = safe_atoi((char const   *)optarg, & remote_mtu);
    }
#line 191
    if (tmp___2) {
      {
#line 192
      tmp___1 = gettext("invalid argument to --mtu");
#line 192
      fatal((char const   *)tmp___1);
      }
    }
#line 193
    goto switch_break___0;
    case_15: /* CIL Label */ 
#line 195
    if (! ((unsigned long )optarg != (unsigned long )((void *)0))) {
      {
#line 195
      __assert_fail("optarg != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                    195U, "parse_arguments");
      }
    }
    {
#line 196
    tmp___4 = safe_atoi((char const   *)optarg, & remote_nru);
    }
#line 196
    if (tmp___4) {
      {
#line 197
      tmp___3 = gettext("invalid argument to --nru");
#line 197
      fatal((char const   *)tmp___3);
      }
    }
#line 198
    goto switch_break___0;
    case_16: /* CIL Label */ 
#line 200
    half_close = (_Bool)1;
#line 201
    goto switch_break___0;
    case_17: /* CIL Label */ 
#line 203
    attrs->flags |= 128;
#line 204
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 206
    attrs->flags |= 4;
#line 207
    goto switch_break___0;
    case_19: /* CIL Label */ 
#line 209
    if (! ((unsigned long )optarg != (unsigned long )((void *)0))) {
      {
#line 209
      __assert_fail("optarg != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                    209U, "parse_arguments");
      }
    }
    {
#line 210
    tmp___6 = safe_atoi((char const   *)optarg, & sndbuf_size);
    }
#line 210
    if (tmp___6) {
      {
#line 211
      tmp___5 = gettext("invalid argument to --sndbuf-size");
#line 211
      fatal((char const   *)tmp___5);
      }
    }
#line 213
    goto switch_break___0;
    case_20: /* CIL Label */ 
#line 215
    if (! ((unsigned long )optarg != (unsigned long )((void *)0))) {
      {
#line 215
      __assert_fail("optarg != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                    215U, "parse_arguments");
      }
    }
    {
#line 216
    tmp___8 = safe_atoi((char const   *)optarg, & rcvbuf_size);
    }
#line 216
    if (tmp___8) {
      {
#line 217
      tmp___7 = gettext("invalid argument to --rcvbuf-size");
#line 217
      fatal((char const   *)tmp___7);
      }
    }
#line 219
    goto switch_break___0;
    case_22: /* CIL Label */ 
#line 221
    attrs->flags |= 256;
#line 222
    goto switch_break___0;
    case_24: /* CIL Label */ 
#line 224
    protocol = (sock_protocol_t )2;
#line 225
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 227
    fatal_internal("getopt returned unexpected long option offset index %d\n", option_index);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 231
    goto switch_break;
    case_52: /* CIL Label */ 
#line 233
    family = (sock_family_t )2;
#line 234
    goto switch_break;
    case_54: /* CIL Label */ 
#line 236
    family = (sock_family_t )1;
#line 237
    attrs->flags |= 2;
#line 238
    goto switch_break;
    case_98: /* CIL Label */ 
#line 240
    family = (sock_family_t )3;
#line 241
    goto switch_break;
    case_101: /* CIL Label */ 
#line 243
    if (! ((unsigned long )optarg != (unsigned long )((void *)0))) {
      {
#line 243
      __assert_fail("optarg != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                    243U, "parse_arguments");
      }
    }
    {
#line 244
    ca_set_local_exec(attrs, (char const   *)optarg);
    }
#line 245
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 247
    print_usage(stdout);
#line 248
    exit(0);
    }
    case_108: /* CIL Label */ 
#line 250
    listen_mode = (_Bool)1;
#line 251
    goto switch_break;
    case_110: /* CIL Label */ 
#line 253
    attrs->flags |= 1;
#line 254
    goto switch_break;
    case_112: /* CIL Label */ 
#line 256
    if (! ((unsigned long )optarg != (unsigned long )((void *)0))) {
      {
#line 256
      __assert_fail("optarg != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                    256U, "parse_arguments");
      }
    }
    {
#line 257
    local_address.service = xstrdup((char const   *)optarg);
    }
#line 258
    goto switch_break;
    case_113: /* CIL Label */ 
#line 260
    if (! ((unsigned long )optarg != (unsigned long )((void *)0))) {
      {
#line 260
      __assert_fail("optarg != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                    260U, "parse_arguments");
      }
    }
    {
#line 261
    tmp___9 = parse_int_pair((char const   *)optarg, & local_hold_timeout, & remote_hold_timeout);
    }
    {
#line 264
    if (tmp___9 == 2) {
#line 264
      goto case_2;
    }
#line 265
    if (tmp___9 == 1) {
#line 265
      goto case_1___0;
    }
#line 266
    goto switch_default___0;
    case_2: /* CIL Label */ 
#line 264
    set_remote_hold_timeout = (_Bool)1;
    case_1___0: /* CIL Label */ 
#line 265
    set_local_hold_timeout = (_Bool)1;
#line 265
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 267
    tmp___10 = gettext("invalid argument to -q");
#line 267
    fatal((char const   *)tmp___10);
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 269
    goto switch_break;
    case_115: /* CIL Label */ 
#line 271
    if (! ((unsigned long )optarg != (unsigned long )((void *)0))) {
      {
#line 271
      __assert_fail("optarg != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                    271U, "parse_arguments");
      }
    }
    {
#line 272
    local_address.address = xstrdup((char const   *)optarg);
    }
#line 273
    goto switch_break;
    case_116: /* CIL Label */ 
#line 275
    if (! ((unsigned long )optarg != (unsigned long )((void *)0))) {
      {
#line 275
      __assert_fail("optarg != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                    275U, "parse_arguments");
      }
    }
    {
#line 276
    tmp___12 = safe_atoi((char const   *)optarg, & idle_timeout);
    }
#line 276
    if (tmp___12) {
      {
#line 277
      tmp___11 = gettext("invalid argument to -t");
#line 277
      fatal((char const   *)tmp___11);
      }
    }
#line 278
    goto switch_break;
    case_117: /* CIL Label */ 
#line 280
    protocol = (sock_protocol_t )1;
#line 283
    if (remote_mtu == 0) {
#line 284
      remote_mtu = (int )DEFAULT_UDP_MTU;
    }
#line 285
    if (remote_nru == 0) {
#line 286
      remote_nru = (int )DEFAULT_UDP_NRU;
    }
#line 287
    if (buffer_size == 0) {
#line 288
      buffer_size = (int )DEFAULT_UDP_BUFFER_SIZE;
    }
#line 289
    goto switch_break;
    case_118: /* CIL Label */ 
#line 291
    _verbosity_level ++;
#line 292
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 297
    fatal_internal("invalid option -- %c (netcat was compiled with --disable-crlfoption)\n",
                   c);
    }
#line 300
    goto switch_break;
    case_119: /* CIL Label */ 
#line 302
    if (! ((unsigned long )optarg != (unsigned long )((void *)0))) {
      {
#line 302
      __assert_fail("optarg != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                    302U, "parse_arguments");
      }
    }
    {
#line 303
    tmp___14 = safe_atoi((char const   *)optarg, & connect_timeout);
    }
#line 303
    if (tmp___14) {
      {
#line 304
      tmp___13 = gettext("invalid argument to -w");
#line 304
      fatal((char const   *)tmp___13);
      }
    }
#line 305
    goto switch_break;
    case_120: /* CIL Label */ 
#line 307
    file_transfer = (_Bool)1;
#line 308
    goto switch_break;
    case_88: /* CIL Label */ 
#line 310
    rev_file_transfer = (_Bool)1;
#line 311
    goto switch_break;
    case_84: /* CIL Label */ 
#line 313
    if (! ((unsigned long )optarg != (unsigned long )((void *)0))) {
      {
#line 313
      __assert_fail("optarg != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                    313U, "parse_arguments");
      }
    }
    {
#line 314
    tmp___16 = safe_atoi((char const   *)optarg, & ttl);
    }
#line 314
    if (tmp___16) {
      {
#line 315
      tmp___15 = gettext("invalid argument to --ttl");
#line 315
      fatal((char const   *)tmp___15);
      }
    }
#line 317
    if (ttl < -1) {
      {
#line 318
      tmp___17 = gettext("ttl can only be set between 0 to 255");
#line 318
      fatal((char const   *)tmp___17);
      }
    } else
#line 317
    if (ttl > 255) {
      {
#line 318
      tmp___17 = gettext("ttl can only be set between 0 to 255");
#line 318
      fatal((char const   *)tmp___17);
      }
    }
#line 319
    goto switch_break;
    case_122: /* CIL Label */ 
#line 321
    zflag = (_Bool)1;
#line 322
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 324
    print_usage(stderr);
#line 325
    exit(1);
    }
    switch_default___1: /* CIL Label */ 
    {
#line 327
    fatal_internal("getopt returned unexpected character 0%o\n", c);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  argv += optind;
#line 333
  argc -= optind;
  {
#line 337
  if (argc == 0) {
#line 337
    goto case_0___0;
  }
#line 341
  if (argc == 1) {
#line 341
    goto case_1___1;
  }
#line 345
  if (argc == 2) {
#line 345
    goto case_2___0;
  }
#line 349
  goto switch_default___2;
  case_0___0: /* CIL Label */ 
#line 338
  remote_address.address = (char *)((void *)0);
#line 339
  remote_address.service = (char *)((void *)0);
#line 340
  goto switch_break___2;
  case_1___1: /* CIL Label */ 
#line 342
  remote_address.address = *(argv + 0);
#line 343
  remote_address.service = (char *)((void *)0);
#line 344
  goto switch_break___2;
  case_2___0: /* CIL Label */ 
#line 346
  remote_address.address = *(argv + 0);
#line 347
  remote_address.service = *(argv + 1);
#line 348
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
  {
#line 350
  print_usage(stderr);
#line 351
  exit(1);
  }
  switch_break___2: /* CIL Label */ ;
  }
#line 355
  if ((unsigned int )protocol == 0U) {
    {
#line 357
    if ((unsigned int )family == 3U) {
#line 357
      goto case_3;
    }
#line 360
    goto switch_default___3;
    case_3: /* CIL Label */ 
#line 358
    protocol = (sock_protocol_t )3;
#line 359
    goto switch_break___3;
    switch_default___3: /* CIL Label */ 
#line 361
    protocol = (sock_protocol_t )0;
#line 362
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
  }
#line 367
  if ((unsigned int )protocol == 1U) {
#line 367
    if ((unsigned int )family == 3U) {
      {
#line 368
      tmp___18 = gettext("cannot specify UDP protocol and bluetooth");
#line 368
      fatal((char const   *)tmp___18);
      }
    }
  }
#line 369
  if ((unsigned int )protocol == 2U) {
#line 369
    if ((unsigned int )family != 3U) {
      {
#line 370
      tmp___19 = gettext("--sco requires --bluetooth (-b)");
#line 370
      fatal((char const   *)tmp___19);
      }
    }
  }
#line 374
  if ((unsigned int )family == 3U) {
    {
#line 375
    tmp___20 = gettext("system does not support bluetooth");
#line 375
    fatal((char const   *)tmp___20);
    }
  }
#line 383
  if ((unsigned long )remote_address.address != (unsigned long )((void *)0)) {
    {
#line 383
    tmp___21 = strlen((char const   *)remote_address.address);
    }
#line 383
    if (tmp___21 == 0UL) {
#line 386
      remote_address.address = (char *)((void *)0);
    }
  }
#line 388
  if ((unsigned long )remote_address.service != (unsigned long )((void *)0)) {
    {
#line 388
    tmp___22 = strlen((char const   *)remote_address.service);
    }
#line 388
    if (tmp___22 == 0UL) {
#line 391
      remote_address.service = (char *)((void *)0);
    }
  }
  {
#line 397
  if ((unsigned int )family == 1U) {
#line 397
    goto case_1___2;
  }
#line 397
  if ((unsigned int )family == 2U) {
#line 397
    goto case_1___2;
  }
#line 397
  if ((unsigned int )family == 0U) {
#line 397
    goto case_1___2;
  }
#line 402
  if ((unsigned int )family == 3U) {
#line 402
    goto case_3___0;
  }
#line 407
  goto switch_default___4;
  case_1___2: /* CIL Label */ 
  case_2___1: /* CIL Label */ 
  case_0___1: /* CIL Label */ 
#line 398
  if ((unsigned int )protocol != 1U) {
#line 398
    if ((unsigned int )protocol != 0U) {
      {
#line 399
      fatal_internal("unknown/unsupported transport protocol %d", (unsigned int )protocol);
      }
    }
  }
#line 401
  goto switch_break___4;
  case_3___0: /* CIL Label */ 
#line 403
  if ((unsigned int )protocol != 2U) {
#line 403
    if ((unsigned int )protocol != 3U) {
      {
#line 404
      fatal_internal("unknown/unsupported bluetooth protocol %d", (unsigned int )protocol);
      }
    }
  }
#line 406
  goto switch_break___4;
  switch_default___4: /* CIL Label */ 
  {
#line 408
  fatal_internal("invalid protocol family %d", (unsigned int )family);
  }
  switch_break___4: /* CIL Label */ ;
  }
#line 412
  if ((int )listen_mode == 1) {
#line 412
    if ((int )zflag == 1) {
      {
#line 413
      tmp___23 = gettext("cannot set both -l and -z");
#line 413
      fatal((char const   *)tmp___23);
      }
    }
  }
#line 417
  if ((int )listen_mode == 1) {
#line 418
    attrs->flags |= 8;
#line 419
    attrs->flags &= -17;
  } else {
#line 421
    attrs->flags |= 16;
#line 422
    attrs->flags &= -9;
  }
#line 427
  if ((int )file_transfer == 1) {
#line 427
    if ((int )rev_file_transfer == 1) {
      {
#line 428
      tmp___24 = gettext("cannot set both --transfer (-x) and --rev-transfer (-X)");
#line 428
      fatal((char const   *)tmp___24);
      }
    }
  }
#line 433
  if ((int )file_transfer == 1) {
#line 433
    goto _L___0;
  } else
#line 433
  if ((int )rev_file_transfer == 1) {
    _L___0: /* CIL Label */ 
#line 434
    if (buffer_size == 0) {
#line 435
      buffer_size = (int )DEFAULT_FILE_TRANSFER_BUFFER_SIZE;
    }
#line 436
    if ((int )rev_file_transfer == 1) {
#line 436
      goto _L;
    } else
#line 436
    if ((int )listen_mode == 1) {
      _L: /* CIL Label */ 
#line 436
      if ((int )rev_file_transfer == 1) {
#line 436
        if ((int )listen_mode == 1) {
#line 440
          attrs->flags |= 64;
#line 441
          attrs->flags &= -33;
        } else {
#line 437
          attrs->flags |= 32;
#line 438
          attrs->flags &= -65;
        }
      } else {
#line 437
        attrs->flags |= 32;
#line 438
        attrs->flags &= -65;
      }
    } else {
#line 440
      attrs->flags |= 64;
#line 441
      attrs->flags &= -33;
    }
  }
#line 446
  if (remote_nru > buffer_size) {
#line 447
    remote_nru = buffer_size;
  }
#line 451
  if (attrs->flags & 32) {
#line 451
    if (attrs->flags & 64) {
      {
#line 454
      tmp___25 = gettext("cannot set both --recv-only and --send-only");
#line 454
      fatal((char const   *)tmp___25);
      }
    }
  }
#line 458
  if ((unsigned int )protocol == 2U) {
#line 459
    if ((unsigned long )remote_address.service != (unsigned long )((void *)0)) {
      {
#line 460
      tmp___26 = gettext("--sco does not support remote port");
#line 460
      fatal((char const   *)tmp___26);
      }
    }
#line 461
    if ((unsigned long )local_address.service != (unsigned long )((void *)0)) {
      {
#line 462
      tmp___27 = gettext("--sco does not support local port (-p)");
#line 462
      fatal((char const   *)tmp___27);
      }
    }
  }
#line 466
  if ((int )listen_mode == 1) {
#line 468
    if ((unsigned long )local_address.service == (unsigned long )((void *)0)) {
#line 468
      if ((unsigned int )protocol != 2U) {
        {
#line 469
        tmp___28 = gettext("in listen mode you must specify a port with the -p switch");
#line 469
        fatal((char const   *)tmp___28);
        }
      }
    }
#line 472
    if (attrs->flags & 256) {
#line 472
      if ((unsigned long )((char const   *)attrs->local_exec) == (unsigned long )((void *)0)) {
        {
#line 475
        tmp___29 = gettext("--continuous option must be used with --exec");
#line 475
        fatal((char const   *)tmp___29);
        }
      }
    }
#line 479
    if (ttl != -1) {
      {
#line 480
      tmp___30 = gettext("setting ttl in listen mode is meaningless, ignoring");
#line 480
      warning((char const   *)tmp___30);
      }
    }
  } else {
#line 485
    if ((unsigned long )remote_address.address == (unsigned long )((void *)0)) {
      {
#line 489
      tmp___31 = gettext("you must specify the address/port couple of the remote endpoint");
#line 489
      fatal((char const   *)tmp___31);
      }
    } else
#line 485
    if ((unsigned long )remote_address.service == (unsigned long )((void *)0)) {
#line 485
      if ((unsigned int )protocol != 2U) {
        {
#line 489
        tmp___31 = gettext("you must specify the address/port couple of the remote endpoint");
#line 489
        fatal((char const   *)tmp___31);
        }
      }
    }
#line 492
    if (attrs->flags & 4) {
      {
#line 493
      tmp___32 = gettext("--no-reuseaddr option can be used only in listen mode");
#line 493
      fatal((char const   *)tmp___32);
      }
    }
#line 496
    if (attrs->flags & 256) {
      {
#line 497
      tmp___33 = gettext("--continuous option can be used only in listen mode");
#line 497
      fatal((char const   *)tmp___33);
      }
    }
  }
#line 504
  if ((unsigned int )protocol == 1U) {
#line 505
    if (remote_mtu == 0) {
#line 506
      remote_mtu = (int )DEFAULT_UDP_MTU;
    }
#line 507
    if (remote_nru == 0) {
#line 508
      remote_nru = (int )DEFAULT_UDP_NRU;
    }
#line 509
    if (buffer_size == 0) {
#line 510
      buffer_size = (int )DEFAULT_UDP_BUFFER_SIZE;
    }
  }
#line 512
  if ((unsigned int )family == 3U) {
#line 514
    if (remote_mtu == 0) {
#line 515
      remote_mtu = (int )DEFAULT_BLUETOOTH_MTU;
    }
  }
#line 519
  attrs->family = family;
#line 520
  attrs->protocol = protocol;
#line 521
  attrs->remote_address = remote_address;
#line 522
  attrs->local_address = local_address;
#line 525
  if (connect_timeout != -1) {
#line 526
    attrs->connect_timeout = connect_timeout;
  }
#line 529
  if (idle_timeout != -1) {
#line 530
    attrs->idle_timeout = idle_timeout;
  }
#line 533
  if ((int )half_close == 1) {
#line 535
    attrs->remote_half_close_suppress = (_Bool)0;
#line 536
    attrs->remote_hold_timeout = -1;
  }
#line 540
  if ((int )set_remote_hold_timeout == 1) {
#line 541
    attrs->remote_hold_timeout = remote_hold_timeout;
  }
#line 542
  if ((int )set_local_hold_timeout == 1) {
#line 543
    attrs->local_hold_timeout = local_hold_timeout;
  }
#line 546
  if (remote_mtu > 0) {
#line 547
    attrs->remote_mtu = (size_t )remote_mtu;
  }
#line 548
  if (remote_nru > 0) {
#line 549
    attrs->remote_nru = (size_t )remote_nru;
  }
#line 550
  attrs->ttl = ttl;
#line 551
  if (buffer_size > 0) {
#line 552
    attrs->buffer_size = (size_t )buffer_size;
  }
#line 553
  if (sndbuf_size > 0) {
#line 554
    attrs->sndbuf_size = (size_t )sndbuf_size;
  }
#line 555
  if (rcvbuf_size > 0) {
#line 556
    attrs->rcvbuf_size = (size_t )rcvbuf_size;
  }
#line 559
  attrs->zflag = zflag;
#line 560
  return;
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
_Bool verbose_mode(void) 
{ 
  int tmp ;

  {
#line 566
  if (_verbosity_level >= (int )VERBOSE_MODE) {
#line 566
    tmp = 1;
  } else {
#line 566
    tmp = 0;
  }
#line 566
  return ((_Bool )tmp);
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
_Bool very_verbose_mode(void) 
{ 
  int tmp ;

  {
#line 573
  if (_verbosity_level >= (int )VERY_VERBOSE_MODE) {
#line 573
    tmp = 1;
  } else {
#line 573
    tmp = 0;
  }
#line 573
  return ((_Bool )tmp);
}
}
#line 578 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
_Bool crlf_mode(void) 
{ 
  int tmp ;

  {
#line 580
  if (opt_crlf == 0) {
#line 580
    tmp = 0;
  } else {
#line 580
    tmp = 1;
  }
#line 580
  return ((_Bool )tmp);
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
static void print_usage(FILE *fp ) 
{ 
  char const   *program_name___0 ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
  {
#line 587
  tmp = get_program_name();
#line 587
  program_name___0 = tmp;
  }
#line 589
  if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
    {
#line 589
    __assert_fail("fp != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                  589U, "print_usage");
    }
  }
#line 590
  if (! ((unsigned long )program_name___0 != (unsigned long )((void *)0))) {
    {
#line 590
    __assert_fail("program_name != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                  590U, "print_usage");
    }
  }
  {
#line 592
  tmp___0 = gettext("Usage:\n\t%s [options...] hostname port\n\t%s -l -p port [-s addr] [options...] [hostname] [port]\n\nRecognized options are:\n");
#line 592
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___0, program_name___0,
          program_name___0);
#line 597
  tmp___1 = gettext("Use only IPv4");
#line 597
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -4                     %s\n",
          tmp___1);
#line 598
  tmp___2 = gettext("Use only IPv6");
#line 598
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -6                     %s\n",
          tmp___2);
#line 599
  tmp___3 = gettext("Use Bluetooth (defaults to L2CAP protocol)");
#line 599
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -b, --bluetooth        %s\n",
          tmp___3);
#line 601
  tmp___4 = gettext("Set buffer size");
#line 601
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" --buffer-size=BYTES    %s\n",
          tmp___4);
#line 602
  tmp___5 = gettext("Continuously accept connections\n                        (only in listen mode with --exec)");
#line 602
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" --continuous           %s\n",
          tmp___5);
#line 605
  tmp___6 = gettext("Disable nagle algorithm for TCP connections");
#line 605
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" --disable-nagle        %s\n",
          tmp___6);
#line 607
  tmp___7 = gettext("Exec command after connect");
#line 607
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -e, --exec=CMD         %s\n",
          tmp___7);
#line 609
  tmp___8 = gettext("Handle network half-closes correctly");
#line 609
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" --half-close           %s\n",
          tmp___8);
#line 611
  tmp___9 = gettext("Display help");
#line 611
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -h, --help             %s\n",
          tmp___9);
#line 612
  tmp___10 = gettext("Listen mode, for inbound connects");
#line 612
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -l, --listen           %s\n",
          tmp___10);
#line 614
  tmp___11 = gettext("Set MTU for network connection transmits");
#line 614
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" --mtu=BYTES            %s\n",
          tmp___11);
#line 616
  tmp___12 = gettext("Numeric-only IP addresses, no DNS");
#line 616
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -n                     %s\n",
          tmp___12);
#line 618
  tmp___13 = gettext("Disable SO_REUSEADDR socket option\n                        (only in listen mode)\n");
#line 618
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" --no-reuseaddr         %s\n",
          tmp___13);
#line 621
  tmp___14 = gettext("Set NRU for network connection receives");
#line 621
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" --nru=BYTES            %s\n",
          tmp___14);
#line 623
  tmp___15 = gettext("Local port");
#line 623
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -p, --port=PORT        %s\n",
          tmp___15);
#line 624
  tmp___16 = gettext("Set hold timeout(s) for local [and remote]");
#line 624
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -q, --hold-timeout=SEC1[:SEC2]\n                        %s\n",
          tmp___16);
#line 627
  tmp___17 = gettext("Kernel receive buffer size for network sockets");
#line 627
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" --rcvbuf-size          %s\n",
          tmp___17);
#line 629
  tmp___18 = gettext("Only receive data, don\'t transmit");
#line 629
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" --recv-only            %s\n",
          tmp___18);
#line 631
  tmp___19 = gettext("Local source address");
#line 631
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -s, --address=ADDRESS  %s\n",
          tmp___19);
#line 632
  tmp___20 = gettext("Use SCO over Bluetooth");
#line 632
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" --sco                  %s\n",
          tmp___20);
#line 634
  tmp___21 = gettext("Only transmit data, don\'t receive");
#line 634
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" --send-only            %s\n",
          tmp___21);
#line 636
  tmp___22 = gettext("Kernel send buffer size for network sockets");
#line 636
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" --sndbuf-size          %s\n",
          tmp___22);
#line 638
  tmp___23 = gettext("Idle connection timeout");
#line 638
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -t, --idle-timeout=SECONDS\n                        %s\n",
          tmp___23);
#line 640
  tmp___24 = gettext("Require use of UDP");
#line 640
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -u, --udp              %s\n",
          tmp___24);
#line 641
  tmp___25 = gettext("Increase program verbosity\n                        (call twice for max verbosity)");
#line 641
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -v                     %s\n",
          tmp___25);
#line 647
  tmp___26 = gettext("Display nc6 version information");
#line 647
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" --version              %s\n",
          tmp___26);
#line 649
  tmp___27 = gettext("Timeout for connects/accepts");
#line 649
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -w, --timeout=SECONDS  %s\n",
          tmp___27);
#line 651
  tmp___28 = gettext("File transfer mode");
#line 651
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -x, --transfer         %s\n",
          tmp___28);
#line 652
  tmp___29 = gettext("File transfer mode (reverse direction)");
#line 652
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -X, --rev-transfer     %s\n",
          tmp___29);
#line 654
  tmp___30 = gettext("TTL of outgoing IP packet");
#line 654
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -T, --ttl=TTL          %s\n",
          tmp___30);
#line 655
  tmp___31 = gettext("Don\'t send any data (scan mode)");
#line 655
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -z                     %s\n",
          tmp___31);
#line 656
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
#line 657
  return;
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
static void print_version(FILE *fp ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 663
  if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
    {
#line 663
    __assert_fail("fp != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                  663U, "print_version");
    }
  }
  {
#line 665
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s version %s\nCopyright (C) 2001-2006\n",
          "nc6", "1.0");
#line 669
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\tMauro Tortonesi\n\tChris Leishman\n\tSimone Piunno\n\tFilippo Natali\n<http://www.deepspace6.net>\n");
#line 677
  tmp = gettext("Configured with IPv6 support\n");
#line 677
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp);
#line 688
  tmp___0 = gettext("Configured without Bluetooth (bluez) support\n");
#line 688
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___0);
  }
#line 691
  return;
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c"
static int parse_int_pair(char const   *str , int *first , int *second ) 
{ 
  char *s ;
  int count ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 698
  count = 1;
#line 700
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 700
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/parser.c",
                  700U, "parse_int_pair");
    }
  }
  {
#line 702
  s = strchr(str, ':');
  }
#line 702
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 703
    tmp = s;
#line 703
    s ++;
#line 703
    *tmp = (char )'\000';
#line 704
    if ((unsigned long )second != (unsigned long )((void *)0)) {
#line 705
      if ((int )*(s + 0) == 45) {
#line 706
        *second = -1;
      } else {
        {
#line 707
        tmp___0 = safe_atoi((char const   *)s, second);
        }
#line 707
        if (tmp___0) {
#line 708
          return (-1);
        }
      }
    }
#line 710
    count = 2;
  }
#line 713
  if ((unsigned long )first != (unsigned long )((void *)0)) {
#line 714
    if ((int const   )*(str + 0) == 45) {
#line 715
      *first = -1;
    } else {
      {
#line 716
      tmp___1 = safe_atoi(str, first);
      }
#line 716
      if (tmp___1) {
#line 717
        return (-1);
      }
    }
  }
#line 720
  return (count);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 677
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c"
static int const   AI_STR_SIZE  =    (int const   )2126;
#line 45
static _Bool skip_address(struct addrinfo  const  *ai ) ;
#line 47
static struct addrinfo *order_ipv6_first(struct addrinfo *ai ) ;
#line 49
static void getnameinfo_ex(struct sockaddr  const  *sa , socklen_t len , char *str ,
                           size_t size , _Bool numeric_mode ) ;
#line 51
static _Bool is_allowed(struct sockaddr  const  *sa , socklen_t salen , struct addrinfo  const  *hints ,
                        char const   *address , char const   *service ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c"
int afindep_connect(struct addrinfo  const  *hints , char const   *remote_address ,
                    char const   *remote_service , char const   *local_address , char const   *local_service ,
                    void (*set_sockopt_handler___0)(int sock , void *hdata ) , void *hdata ,
                    time_t timeout , int *rt_socktype ) 
{ 
  int err ;
  int fd ;
  struct addrinfo *res ;
  struct addrinfo *ptr ;
  _Bool connect_attempted ;
  char *name_buf ;
  unsigned long __lengthofname_buf ;
  void *tmp ;
  connection_attributes_t const   *attrs ;
  int on ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  uint32_t tmp___7 ;
  int *tmp___8 ;
  _Bool tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int on___0 ;
  _Bool tmp___12 ;
  struct addrinfo src_hints ;
  struct addrinfo *src_res ;
  struct addrinfo *src_ptr ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  _Bool tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  _Bool tmp___19 ;
  uint32_t tmp___20 ;
  char *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int *tmp___25 ;
  _Bool tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  _Bool tmp___30 ;

  {
  {
#line 63
  fd = -1;
#line 64
  res = (struct addrinfo *)((void *)0);
#line 65
  connect_attempted = (_Bool)0;
#line 66
  __lengthofname_buf = (unsigned long )AI_STR_SIZE;
#line 66
  tmp = __builtin_alloca(sizeof(*name_buf) * __lengthofname_buf);
#line 66
  name_buf = (char *)tmp;
#line 67
  attrs = *((connection_attributes_t const   **)hdata);
  }
#line 72
  if (! ((unsigned long )hints != (unsigned long )((void *)0))) {
    {
#line 72
    __assert_fail("hints != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  72U, "afindep_connect");
    }
  }
#line 73
  if ((unsigned long )remote_address != (unsigned long )((void *)0)) {
    {
#line 73
    tmp___0 = strlen(remote_address);
    }
#line 73
    if (! (tmp___0 > 0UL)) {
      {
#line 73
      __assert_fail("remote_address != ((void *)0) && strlen(remote_address) > 0",
                    "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                    73U, "afindep_connect");
      }
    }
  } else {
    {
#line 73
    __assert_fail("remote_address != ((void *)0) && strlen(remote_address) > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  73U, "afindep_connect");
    }
  }
#line 74
  if ((unsigned long )remote_service != (unsigned long )((void *)0)) {
    {
#line 74
    tmp___1 = strlen(remote_service);
    }
#line 74
    if (! (tmp___1 > 0UL)) {
      {
#line 74
      __assert_fail("remote_service != ((void *)0) && strlen(remote_service) > 0",
                    "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                    74U, "afindep_connect");
      }
    }
  } else {
    {
#line 74
    __assert_fail("remote_service != ((void *)0) && strlen(remote_service) > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  74U, "afindep_connect");
    }
  }
#line 75
  if (! ((unsigned long )local_address == (unsigned long )((void *)0))) {
    {
#line 75
    tmp___2 = strlen(local_address);
    }
#line 75
    if (! (tmp___2 > 0UL)) {
      {
#line 75
      __assert_fail("local_address == ((void *)0) || strlen(local_address) > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                    75U, "afindep_connect");
      }
    }
  }
#line 76
  if (! ((unsigned long )local_service == (unsigned long )((void *)0))) {
    {
#line 76
    tmp___3 = strlen(local_service);
    }
#line 76
    if (! (tmp___3 > 0UL)) {
      {
#line 76
      __assert_fail("local_service == ((void *)0) || strlen(local_service) > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                    76U, "afindep_connect");
      }
    }
  }
  {
#line 79
  err = getaddrinfo((char const   */* __restrict  */)remote_address, (char const   */* __restrict  */)remote_service,
                    (struct addrinfo  const  */* __restrict  */)hints, (struct addrinfo **/* __restrict  */)(& res));
  }
#line 80
  if (err != 0) {
    {
#line 81
    tmp___4 = gai_strerror(err);
#line 81
    tmp___5 = gettext("forward host lookup failed for remote endpoint %s: %s");
#line 81
    warning((char const   *)tmp___5, remote_address, tmp___4);
    }
#line 84
    return (-1);
  }
#line 88
  if (! ((unsigned long )res != (unsigned long )((void *)0))) {
    {
#line 88
    __assert_fail("res != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  88U, "afindep_connect");
    }
  }
#line 91
  ptr = res;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 91
      goto while_break;
    }
    {
#line 94
    tmp___6 = skip_address((struct addrinfo  const  *)ptr);
    }
#line 94
    if ((int )tmp___6 == 1) {
#line 94
      goto __Cont;
    }
#line 96
    if (ptr->ai_socktype == 1) {
#line 97
      if (ptr->ai_family == 2) {
        {
#line 98
        tmp___7 = ntohl(((struct sockaddr_in *)ptr->ai_addr)->sin_addr.s_addr);
        }
#line 98
        if ((tmp___7 & 4026531840U) == 3758096384U) {
          {
#line 99
          warning("socket type STREAM and multicast bad, udp only!");
          }
#line 100
          return (-1);
        }
      } else
#line 104
      if (ptr->ai_family == 10) {
#line 105
        if ((int const   )*((uint8_t const   *)(& ((struct sockaddr_in6 *)ptr->ai_addr)->sin6_addr) + 0) == 255) {
          {
#line 106
          warning("socket type STREAM and multicast bad, udp only!");
          }
#line 107
          return (-1);
        }
      }
    }
    {
#line 114
    connect_attempted = (_Bool)1;
#line 117
    fd = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
    }
#line 118
    if (fd < 0) {
      {
#line 120
      tmp___8 = __errno_location();
#line 120
      tmp___9 = unsupported_sock_error(*tmp___8);
      }
#line 120
      if (! tmp___9) {
#line 121
        goto __Cont;
      }
      {
#line 122
      tmp___10 = __errno_location();
#line 122
      tmp___11 = strerror(*tmp___10);
#line 122
      warning("cannot create the socket: %s", tmp___11);
      }
#line 124
      return (-1);
    }
#line 128
    if (ptr->ai_family == 10) {
      {
#line 129
      on___0 = 1;
#line 131
      err = setsockopt(fd, 41, 26, (void const   *)(& on___0), (socklen_t )sizeof(on___0));
      }
#line 133
      if (err < 0) {
        {
#line 134
        warning("error with sockopt IPV6_V6ONLY");
        }
      }
    }
#line 138
    if ((unsigned long )set_sockopt_handler___0 != (unsigned long )((void *)0)) {
      {
#line 139
      (*set_sockopt_handler___0)(fd, hdata);
      }
    }
    {
#line 142
    tmp___12 = verbose_mode();
    }
#line 142
    if (tmp___12) {
      {
#line 143
      getnameinfo_ex((struct sockaddr  const  *)ptr->ai_addr, ptr->ai_addrlen, name_buf,
                     sizeof(*name_buf) * __lengthofname_buf, (_Bool )(hints->ai_flags & 4));
      }
    }
#line 148
    if ((unsigned long )local_address != (unsigned long )((void *)0)) {
#line 148
      goto _L;
    } else
#line 148
    if ((unsigned long )local_service != (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 149
      src_res = (struct addrinfo *)((void *)0);
#line 152
      memset((void *)(& src_hints), 0, sizeof(src_hints));
#line 153
      src_hints.ai_family = ptr->ai_family;
#line 154
      src_hints.ai_flags = 1;
#line 155
      src_hints.ai_socktype = ptr->ai_socktype;
#line 156
      src_hints.ai_protocol = ptr->ai_protocol;
#line 158
      src_hints.ai_flags |= (int )hints->ai_flags;
#line 161
      err = getaddrinfo((char const   */* __restrict  */)local_address, (char const   */* __restrict  */)local_service,
                        (struct addrinfo  const  */* __restrict  */)(& src_hints),
                        (struct addrinfo **/* __restrict  */)(& src_res));
      }
#line 163
      if (err != 0) {
        {
#line 164
        tmp___15 = verbose_mode();
        }
#line 164
        if (tmp___15) {
          {
#line 165
          tmp___13 = gai_strerror(err);
#line 165
          tmp___14 = gettext("bind to source addr/port failed when connecting to %s: %s");
#line 165
          warning((char const   *)tmp___14, name_buf, tmp___13);
          }
        }
        {
#line 170
        close(fd);
#line 171
        fd = -1;
        }
#line 172
        goto __Cont;
      }
#line 176
      if (! ((unsigned long )src_res != (unsigned long )((void *)0))) {
        {
#line 176
        __assert_fail("src_res != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                      176U, "afindep_connect");
        }
      }
#line 179
      src_ptr = src_res;
      {
#line 179
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 179
        if (! ((unsigned long )src_ptr != (unsigned long )((void *)0))) {
#line 179
          goto while_break___0;
        }
        {
#line 182
        err = bind(fd, (struct sockaddr  const  *)src_ptr->ai_addr, src_ptr->ai_addrlen);
        }
#line 184
        if (err == 0) {
#line 184
          goto while_break___0;
        }
#line 179
        src_ptr = src_ptr->ai_next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 187
      if (err != 0) {
#line 189
        if (! ((unsigned long )src_ptr == (unsigned long )((void *)0))) {
          {
#line 189
          __assert_fail("src_ptr == ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                        189U, "afindep_connect");
          }
        }
        {
#line 191
        tmp___19 = verbose_mode();
        }
#line 191
        if (tmp___19) {
          {
#line 192
          tmp___16 = __errno_location();
#line 192
          tmp___17 = strerror(*tmp___16);
#line 192
          tmp___18 = gettext("bind to source addr/port failed when connecting to %s: %s");
#line 192
          warning((char const   *)tmp___18, name_buf, tmp___17);
          }
        }
        {
#line 197
        freeaddrinfo(src_res);
#line 198
        close(fd);
#line 199
        fd = -1;
        }
#line 200
        goto __Cont;
      }
      {
#line 203
      freeaddrinfo(src_res);
      }
    }
#line 207
    on = (int )attrs->ttl;
#line 207
    if (on > -1) {
#line 208
      if (ptr->ai_family == 2) {
        {
#line 209
        tmp___20 = ntohl(((struct sockaddr_in *)ptr->ai_addr)->sin_addr.s_addr);
        }
#line 209
        if ((tmp___20 & 4026531840U) == 3758096384U) {
          {
#line 210
          setsockopt(fd, 0, 33, (void const   *)(& on), (socklen_t )sizeof(on));
          }
        } else {
          {
#line 213
          setsockopt(fd, 0, 2, (void const   *)(& on), (socklen_t )sizeof(on));
          }
        }
      } else
#line 217
      if (ptr->ai_family == 10) {
#line 218
        if ((int const   )*((uint8_t const   *)(& ((struct sockaddr_in6 *)ptr->ai_addr)->sin6_addr) + 0) == 255) {
          {
#line 219
          setsockopt(fd, 41, 18, (void const   *)(& on), (socklen_t )sizeof(on));
          }
        } else {
          {
#line 222
          setsockopt(fd, 41, 16, (void const   *)(& on), (socklen_t )sizeof(on));
          }
        }
      }
    }
    {
#line 229
    err = connect_with_timeout(fd, (struct sockaddr  const  *)ptr->ai_addr, ptr->ai_addrlen,
                               (int )timeout);
    }
#line 233
    if (err == 0) {
#line 234
      goto while_break;
    }
    {
#line 237
    tmp___26 = verbose_mode();
    }
#line 237
    if (tmp___26) {
      {
#line 239
      tmp___25 = __errno_location();
      }
#line 239
      if (*tmp___25 == 110) {
        {
#line 241
        tmp___21 = gettext("timeout while connecting to %s");
#line 241
        warning((char const   *)tmp___21, name_buf);
        }
      } else {
        {
#line 246
        tmp___22 = __errno_location();
#line 246
        tmp___23 = strerror(*tmp___22);
#line 246
        tmp___24 = gettext("cannot connect to %s: %s");
#line 246
        warning((char const   *)tmp___24, name_buf, tmp___23);
        }
      }
    }
    {
#line 250
    close(fd);
#line 251
    fd = -1;
    }
    __Cont: /* CIL Label */ 
#line 91
    ptr = ptr->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  if (! ((unsigned long )ptr == (unsigned long )((void *)0))) {
#line 255
    if (! (fd >= 0)) {
      {
#line 255
      __assert_fail("ptr == ((void *)0) || fd >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                    255U, "afindep_connect");
      }
    }
  }
#line 258
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 260
    if ((int )connect_attempted == 0) {
      {
#line 261
      tmp___27 = gettext("forward lookup returned no useful socket types");
#line 261
      warning((char const   *)tmp___27);
      }
    } else {
      {
#line 264
      tmp___28 = gettext("unable to connect to address %s, service %s");
#line 264
      warning((char const   *)tmp___28, remote_address, remote_service);
      }
    }
#line 268
    return (-1);
  }
  {
#line 272
  tmp___30 = verbose_mode();
  }
#line 272
  if (tmp___30) {
    {
#line 273
    tmp___29 = gettext("%s open");
#line 273
    warning((char const   *)tmp___29, name_buf);
    }
  }
#line 276
  if ((unsigned long )rt_socktype != (unsigned long )((void *)0)) {
#line 277
    *rt_socktype = ptr->ai_socktype;
  }
  {
#line 280
  freeaddrinfo(res);
  }
#line 282
  return (fd);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c"
int afindep_listener(struct addrinfo  const  *hints , char const   *local_address ,
                     char const   *local_service , char const   *remote_address ,
                     char const   *remote_service , void (*set_sockopt_handler___0)(int sock ,
                                                                                    void *hdata ) ,
                     void *hdata , void (*callback)(int fd , int socktype , void *cdata ) ,
                     void *cdata , time_t timeout , int max_accept ) 
{ 
  int nfd ;
  int i ;
  int fd ;
  int err ;
  int maxfd ;
  struct addrinfo *res ;
  struct addrinfo *ptr ;
  int off ;
  struct ip_mreq mreq ;
  struct ipv6_mreq mreq6 ;
  _Bool set_ipv6_only ;
  _Bool bound_ipv6_any ;
  bound_socket_t *bound_sockets ;
  fd_set accept_fdset ;
  char *name_buf ;
  unsigned long __lengthofname_buf ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  int __d0 ;
  int __d1 ;
  _Bool tmp___8 ;
  uint32_t tmp___9 ;
  int *tmp___10 ;
  _Bool tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int on ;
  char *tmp___14 ;
  _Bool tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  _Bool tmp___24 ;
  int tmp___25 ;
  uint32_t tmp___26 ;
  char *tmp___27 ;
  fd_set tmp_ap_fdset ;
  struct timeval tv ;
  struct timeval *tvp ;
  struct sockaddr_storage dest ;
  socklen_t destlen ;
  int ns ;
  int socktype ;
  char *c_name_buf ;
  unsigned long __lengthofc_name_buf ;
  void *tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  ssize_t tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  struct sockaddr_storage src ;
  socklen_t srclen ;
  int *tmp___40 ;
  char *tmp___41 ;
  _Bool tmp___42 ;
  int *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  _Bool tmp___47 ;
  char *tmp___48 ;
  _Bool tmp___49 ;
  _Bool tmp___50 ;

  {
  {
#line 294
  maxfd = -1;
#line 295
  res = (struct addrinfo *)((void *)0);
#line 296
  off = 0;
#line 300
  set_ipv6_only = (_Bool)0;
#line 301
  bound_ipv6_any = (_Bool)0;
#line 303
  bound_sockets = (bound_socket_t *)((void *)0);
#line 305
  __lengthofname_buf = (unsigned long )AI_STR_SIZE;
#line 305
  tmp = __builtin_alloca(sizeof(*name_buf) * __lengthofname_buf);
#line 305
  name_buf = (char *)tmp;
  }
#line 308
  if (! ((unsigned long )hints != (unsigned long )((void *)0))) {
    {
#line 308
    __assert_fail("hints != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  308U, "afindep_listener");
    }
  }
#line 309
  if (! ((unsigned long )remote_address == (unsigned long )((void *)0))) {
    {
#line 309
    tmp___0 = strlen(remote_address);
    }
#line 309
    if (! (tmp___0 > 0UL)) {
      {
#line 309
      __assert_fail("remote_address == ((void *)0) || strlen(remote_address) > 0",
                    "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                    309U, "afindep_listener");
      }
    }
  }
#line 310
  if (! ((unsigned long )remote_service == (unsigned long )((void *)0))) {
    {
#line 310
    tmp___1 = strlen(remote_service);
    }
#line 310
    if (! (tmp___1 > 0UL)) {
      {
#line 310
      __assert_fail("remote_service == ((void *)0) || strlen(remote_service) > 0",
                    "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                    310U, "afindep_listener");
      }
    }
  }
#line 311
  if (! ((unsigned long )local_address == (unsigned long )((void *)0))) {
    {
#line 311
    tmp___2 = strlen(local_address);
    }
#line 311
    if (! (tmp___2 > 0UL)) {
      {
#line 311
      __assert_fail("local_address == ((void *)0) || strlen(local_address) > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                    311U, "afindep_listener");
      }
    }
  }
#line 312
  if ((unsigned long )local_service != (unsigned long )((void *)0)) {
    {
#line 312
    tmp___3 = strlen(local_service);
    }
#line 312
    if (! (tmp___3 > 0UL)) {
      {
#line 312
      __assert_fail("local_service != ((void *)0) && strlen(local_service) > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                    312U, "afindep_listener");
      }
    }
  } else {
    {
#line 312
    __assert_fail("local_service != ((void *)0) && strlen(local_service) > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  312U, "afindep_listener");
    }
  }
#line 315
  if (max_accept == 0) {
#line 316
    return (0);
  }
  {
#line 319
  err = getaddrinfo((char const   */* __restrict  */)local_address, (char const   */* __restrict  */)local_service,
                    (struct addrinfo  const  */* __restrict  */)hints, (struct addrinfo **/* __restrict  */)(& res));
  }
#line 320
  if (err != 0) {
    {
#line 321
    tmp___4 = gai_strerror(err);
    }
#line 321
    if (local_address) {
#line 321
      tmp___6 = local_address;
    } else {
      {
#line 321
      tmp___5 = gettext("[unspecified]");
#line 321
      tmp___6 = (char const   *)tmp___5;
      }
    }
    {
#line 321
    tmp___7 = gettext("forward host lookup failed for local endpoint %s (%s): %s");
#line 321
    warning((char const   *)tmp___7, tmp___6, local_service, tmp___4);
    }
#line 325
    return (-1);
  }
#line 329
  if (! ((unsigned long )res != (unsigned long )((void *)0))) {
    {
#line 329
    __assert_fail("res != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  329U, "afindep_listener");
    }
  }
  {
#line 364
  res = order_ipv6_first(res);
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& accept_fdset.__fds_bits[0]): "memory");
#line 368
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  nfd = 0;
#line 372
  ptr = res;
  {
#line 372
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 372
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 372
      goto while_break___0;
    }
    {
#line 375
    tmp___8 = skip_address((struct addrinfo  const  *)ptr);
    }
#line 375
    if ((int )tmp___8 == 1) {
#line 375
      goto __Cont;
    }
#line 377
    if (ptr->ai_socktype == 1) {
#line 378
      if (ptr->ai_family == 2) {
        {
#line 379
        tmp___9 = ntohl(((struct sockaddr_in *)ptr->ai_addr)->sin_addr.s_addr);
        }
#line 379
        if ((tmp___9 & 4026531840U) == 3758096384U) {
          {
#line 380
          warning("socket type STREAM and multicast bad, udp only!");
          }
#line 381
          return (-1);
        }
      } else
#line 385
      if (ptr->ai_family == 10) {
#line 386
        if ((int const   )*((uint8_t const   *)(& ((struct sockaddr_in6 *)ptr->ai_addr)->sin6_addr) + 0) == 255) {
          {
#line 387
          warning("socket type STREAM and multicast bad, udp only!");
          }
#line 388
          return (-1);
        }
      }
    }
    {
#line 395
    fd = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
    }
#line 396
    if (fd < 0) {
      {
#line 398
      tmp___10 = __errno_location();
#line 398
      tmp___11 = unsupported_sock_error(*tmp___10);
      }
#line 398
      if (tmp___11) {
#line 399
        goto __Cont;
      }
      {
#line 400
      tmp___12 = __errno_location();
#line 400
      tmp___13 = strerror(*tmp___12);
#line 400
      warning("cannot create the socket: %s", tmp___13);
      }
#line 402
      return (-1);
    }
#line 406
    if (ptr->ai_family == 10) {
      {
#line 407
      on = 1;
#line 409
      err = setsockopt(fd, 41, 26, (void const   *)(& on), (socklen_t )sizeof(on));
      }
#line 411
      if (err < 0) {
        {
#line 412
        warning("error with sockopt IPV6_V6ONLY");
        }
      } else {
#line 414
        set_ipv6_only = (_Bool)1;
      }
    }
#line 418
    if ((unsigned long )set_sockopt_handler___0 != (unsigned long )((void *)0)) {
      {
#line 419
      (*set_sockopt_handler___0)(fd, hdata);
      }
    }
    {
#line 422
    getnameinfo_ex((struct sockaddr  const  *)ptr->ai_addr, ptr->ai_addrlen, name_buf,
                   sizeof(*name_buf) * __lengthofname_buf, (_Bool)1);
#line 426
    err = bind(fd, (struct sockaddr  const  *)ptr->ai_addr, ptr->ai_addrlen);
    }
#line 427
    if (err != 0) {
      {
#line 431
      tmp___16 = __errno_location();
      }
#line 431
      if (*tmp___16 == 98) {
#line 431
        if (ptr->ai_family == 2) {
#line 431
          if ((int )set_ipv6_only == 0) {
#line 431
            if ((int )bound_ipv6_any == 1) {
              {
#line 436
              tmp___15 = verbose_mode();
              }
#line 436
              if (tmp___15) {
                {
#line 437
                tmp___14 = gettext("listening on %s ...");
#line 437
                warning((char const   *)tmp___14, name_buf);
                }
              }
              {
#line 439
              close(fd);
              }
#line 440
              goto __Cont;
            }
          }
        }
      }
      {
#line 443
      tmp___17 = __errno_location();
#line 443
      tmp___18 = strerror(*tmp___17);
#line 443
      tmp___19 = gettext("bind to source %s failed: %s");
#line 443
      warning((char const   *)tmp___19, name_buf, tmp___18);
#line 445
      close(fd);
      }
#line 446
      goto __Cont;
    }
#line 449
    if (ptr->ai_socktype == 1) {
      {
#line 450
      err = listen(fd, 128);
      }
#line 451
      if (err != 0) {
        {
#line 452
        tmp___20 = __errno_location();
#line 452
        tmp___21 = strerror(*tmp___20);
#line 452
        tmp___22 = gettext("cannot listen on %s: %s");
#line 452
        warning((char const   *)tmp___22, name_buf, tmp___21);
#line 454
        free_bound_sockets(bound_sockets);
        }
#line 455
        return (-1);
      }
    }
    {
#line 459
    tmp___24 = verbose_mode();
    }
#line 459
    if (tmp___24) {
      {
#line 460
      tmp___23 = gettext("listening on %s ...");
#line 460
      warning((char const   *)tmp___23, name_buf);
      }
    }
#line 464
    if (ptr->ai_family == 10) {
      {
#line 464
      tmp___25 = memcmp((void const   *)(& ((struct sockaddr_in6 *)ptr->ai_addr)->sin6_addr),
                        (void const   *)(& in6addr_any), sizeof(struct in6_addr ));
      }
#line 464
      if (tmp___25 == 0) {
#line 468
        bound_ipv6_any = (_Bool)1;
      }
    }
    {
#line 473
    bound_sockets = add_bound_socket(bound_sockets, fd, ptr->ai_socktype);
#line 477
    accept_fdset.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
    }
#line 478
    if (maxfd > fd) {
#line 478
      maxfd = maxfd;
    } else {
#line 478
      maxfd = fd;
    }
#line 479
    nfd ++;
#line 481
    if (ptr->ai_family == 2) {
      {
#line 482
      tmp___26 = ntohl(((struct sockaddr_in *)ptr->ai_addr)->sin_addr.s_addr);
      }
#line 482
      if ((tmp___26 & 4026531840U) == 3758096384U) {
        {
#line 483
        memset((void *)(& mreq), 0, sizeof(mreq));
#line 484
        mreq.imr_multiaddr = ((struct sockaddr_in *)ptr->ai_addr)->sin_addr;
#line 485
        mreq.imr_interface.s_addr = (in_addr_t )0;
#line 486
        setsockopt(fd, 0, 35, (void const   *)(& mreq), (socklen_t )sizeof(mreq));
#line 487
        setsockopt(fd, 0, 34, (void const   *)(& off), (socklen_t )sizeof(off));
        }
      }
    } else
#line 491
    if (ptr->ai_family == 10) {
#line 492
      if ((int const   )*((uint8_t const   *)(& ((struct sockaddr_in6 *)ptr->ai_addr)->sin6_addr) + 0) == 255) {
        {
#line 493
        memset((void *)(& mreq6), 0, sizeof(mreq6));
#line 494
        mreq6.ipv6mr_multiaddr = ((struct sockaddr_in6 *)ptr->ai_addr)->sin6_addr;
#line 495
        mreq6.ipv6mr_interface = 0U;
#line 496
        setsockopt(fd, 41, 20, (void const   *)(& mreq6), (socklen_t )sizeof(mreq));
#line 497
        setsockopt(fd, 41, 19, (void const   *)(& off), (socklen_t )sizeof(off));
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 372
    ptr = ptr->ai_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 503
  freeaddrinfo(res);
  }
#line 505
  if (nfd == 0) {
    {
#line 506
    tmp___27 = gettext("failed to bind to any local addr/port");
#line 506
    warning((char const   *)tmp___27);
    }
#line 507
    return (-1);
  }
  {
#line 511
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 513
    tvp = (struct timeval *)((void *)0);
#line 517
    __lengthofc_name_buf = (unsigned long )AI_STR_SIZE;
#line 517
    tmp___28 = __builtin_alloca(sizeof(*c_name_buf) * __lengthofc_name_buf);
#line 517
    c_name_buf = (char *)tmp___28;
#line 520
    memcpy((void */* __restrict  */)(& tmp_ap_fdset), (void const   */* __restrict  */)(& accept_fdset),
           sizeof(fd_set ));
    }
#line 523
    if (timeout > 0L) {
#line 524
      tv.tv_sec = timeout;
#line 525
      tv.tv_usec = (__suseconds_t )0;
#line 526
      tvp = & tv;
    }
    {
#line 530
    err = select(maxfd + 1, (fd_set */* __restrict  */)(& tmp_ap_fdset), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)tvp);
    }
#line 532
    if (err <= 0) {
#line 533
      if (err < 0) {
        {
#line 533
        tmp___29 = __errno_location();
        }
#line 533
        if (*tmp___29 == 4) {
#line 534
          goto __Cont___0;
        }
      }
#line 535
      if (err == 0) {
        {
#line 536
        tmp___30 = gettext("connection timed out");
#line 536
        warning((char const   *)tmp___30);
        }
      } else {
        {
#line 538
        tmp___31 = __errno_location();
#line 538
        tmp___32 = strerror(*tmp___31);
#line 538
        warning("select error: %s", tmp___32);
        }
      }
      {
#line 539
      free_bound_sockets(bound_sockets);
      }
#line 540
      return (-1);
    }
#line 544
    fd = 0;
    {
#line 544
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 544
      if (fd <= maxfd) {
#line 544
        if (! (! ((tmp_ap_fdset.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L))) {
#line 544
          goto while_break___2;
        }
      } else {
#line 544
        goto while_break___2;
      }
#line 544
      fd ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 548
    if (fd > maxfd) {
#line 549
      goto __Cont___0;
    }
    {
#line 552
    socktype = get_bound_socket_type((bound_socket_t const   *)bound_sockets, fd);
#line 554
    destlen = (socklen_t )sizeof(dest);
    }
#line 558
    if (socktype == 1) {
      {
#line 559
      ns = accept(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dest)),
                  (socklen_t */* __restrict  */)(& destlen));
      }
#line 560
      if (ns < 0) {
        {
#line 561
        tmp___33 = __errno_location();
#line 561
        tmp___34 = strerror(*tmp___33);
#line 561
        warning("accept failed: %s", tmp___34);
#line 562
        free_bound_sockets(bound_sockets);
        }
#line 563
        return (-1);
      }
    } else {
#line 567
      if (! (socktype == 2)) {
        {
#line 567
        __assert_fail("socktype == SOCK_DGRAM", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                      567U, "afindep_listener");
        }
      }
      {
#line 569
      tmp___35 = recvfrom(fd, (void */* __restrict  */)((void *)0), (size_t )0, 2,
                          (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dest)),
                          (socklen_t */* __restrict  */)(& destlen));
#line 569
      err = (int )tmp___35;
      }
#line 571
      if (err < 0) {
        {
#line 572
        tmp___36 = __errno_location();
#line 572
        tmp___37 = strerror(*tmp___36);
#line 572
        warning("recvfrom failed: %s", tmp___37);
#line 573
        free_bound_sockets(bound_sockets);
        }
#line 574
        return (-1);
      }
      {
#line 577
      ns = dup(fd);
      }
#line 578
      if (ns < 0) {
        {
#line 579
        tmp___38 = __errno_location();
#line 579
        tmp___39 = strerror(*tmp___38);
#line 579
        warning("dup failed: %s", tmp___39);
#line 580
        free_bound_sockets(bound_sockets);
        }
#line 581
        return (-1);
      }
    }
    {
#line 586
    tmp___42 = verbose_mode();
    }
#line 586
    if (tmp___42) {
      {
#line 588
      srclen = (socklen_t )sizeof(src);
#line 591
      err = getsockname(ns, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& src)),
                        (socklen_t */* __restrict  */)(& srclen));
      }
#line 592
      if (err < 0) {
        {
#line 593
        tmp___40 = __errno_location();
#line 593
        tmp___41 = strerror(*tmp___40);
#line 593
        warning("getsockname failed: %s", tmp___41);
#line 595
        free_bound_sockets(bound_sockets);
        }
#line 596
        return (-1);
      }
      {
#line 600
      getnameinfo_ex((struct sockaddr  const  *)((struct sockaddr *)(& src)), srclen,
                     name_buf, sizeof(*name_buf) * __lengthofname_buf, (_Bool)1);
#line 604
      getnameinfo_ex((struct sockaddr  const  *)((struct sockaddr *)(& dest)), destlen,
                     c_name_buf, sizeof(*c_name_buf) * __lengthofc_name_buf, (_Bool )(hints->ai_flags & 4));
      }
    }
#line 610
    if ((unsigned long )remote_address == (unsigned long )((void *)0)) {
#line 610
      if ((unsigned long )remote_service == (unsigned long )((void *)0)) {
#line 610
        goto _L;
      } else {
#line 610
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 610
      tmp___50 = is_allowed((struct sockaddr  const  *)((struct sockaddr *)(& dest)),
                            destlen, hints, remote_address, remote_service);
      }
#line 610
      if ((int )tmp___50 == 1) {
        _L: /* CIL Label */ 
#line 615
        if (socktype == 2) {
          {
#line 618
          err = connect(ns, (struct sockaddr  const  *)((struct sockaddr *)(& dest)),
                        destlen);
          }
#line 620
          if (err != 0) {
            {
#line 621
            tmp___43 = __errno_location();
#line 621
            tmp___44 = strerror(*tmp___43);
#line 621
            tmp___45 = gettext("connect failed on datagram socket: %s");
#line 621
            warning((char const   *)tmp___45, tmp___44);
#line 624
            free_bound_sockets(bound_sockets);
            }
#line 625
            return (-1);
          }
        }
        {
#line 629
        tmp___47 = verbose_mode();
        }
#line 629
        if (tmp___47) {
          {
#line 630
          tmp___46 = gettext("connect to %s from %s");
#line 630
          warning((char const   *)tmp___46, name_buf, c_name_buf);
          }
        }
        {
#line 634
        (*callback)(ns, socktype, cdata);
        }
#line 636
        if (max_accept > 0) {
#line 636
          max_accept --;
#line 636
          if (max_accept == 0) {
#line 637
            goto while_break___1;
          }
        }
      } else {
#line 639
        if (socktype == 2) {
          {
#line 642
          recvfrom(ns, (void */* __restrict  */)((void *)0), (size_t )0, 0, (struct sockaddr */* __restrict  */)((void *)0),
                   (socklen_t */* __restrict  */)0);
          }
        }
        {
#line 644
        close(ns);
#line 646
        tmp___49 = verbose_mode();
        }
#line 646
        if (tmp___49) {
          {
#line 647
          tmp___48 = gettext("refused connect to %s from %s");
#line 647
          warning((char const   *)tmp___48, name_buf, c_name_buf);
          }
        }
      }
    }
    __Cont___0: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 654
  i = 0;
  {
#line 654
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 654
    if (! (i <= maxfd)) {
#line 654
      goto while_break___3;
    }
#line 655
    if (((accept_fdset.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) != 0) {
      {
#line 655
      close(i);
      }
    }
#line 654
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 659
  free_bound_sockets(bound_sockets);
  }
#line 660
  return (0);
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c"
static _Bool skip_address(struct addrinfo  const  *ai ) 
{ 
  _Bool tmp ;

  {
#line 668
  if (! ((unsigned long )ai != (unsigned long )((void *)0))) {
    {
#line 668
    __assert_fail("ai != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  668U, "skip_address");
    }
  }
#line 671
  if (ai->ai_socktype != 1) {
#line 671
    if (ai->ai_socktype != 2) {
#line 673
      return ((_Bool)1);
    }
  }
  {
#line 689
  tmp = is_address_ipv4_mapped((struct sockaddr  const  *)ai->ai_addr);
  }
#line 689
  if (tmp) {
#line 690
    return ((_Bool)1);
  }
#line 699
  return ((_Bool)0);
}
}
#line 716 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c"
static struct addrinfo *order_ipv6_first(struct addrinfo *ai ) 
{ 
  struct addrinfo *ptr ;
  struct addrinfo *lastv6 ;
  struct addrinfo *tmp ;

  {
#line 719
  lastv6 = (struct addrinfo *)((void *)0);
#line 722
  if (! ((unsigned long )ai != (unsigned long )((void *)0))) {
    {
#line 722
    __assert_fail("ai != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  722U, "order_ipv6_first");
    }
  }
#line 727
  if (ai->ai_family == 10) {
#line 728
    lastv6 = ai;
  }
#line 730
  ptr = ai;
  {
#line 730
  while (1) {
    while_continue: /* CIL Label */ ;
#line 730
    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 730
      if (! ((unsigned long )ptr->ai_next != (unsigned long )((void *)0))) {
#line 730
        goto while_break;
      }
    } else {
#line 730
      goto while_break;
    }
#line 731
    if ((ptr->ai_next)->ai_family == 10) {
#line 732
      tmp = ptr->ai_next;
#line 733
      ptr->ai_next = tmp->ai_next;
#line 734
      if (lastv6) {
#line 735
        tmp->ai_next = lastv6->ai_next;
#line 736
        lastv6->ai_next = tmp;
      } else {
#line 738
        tmp->ai_next = ai;
#line 739
        ai = tmp;
      }
#line 741
      lastv6 = tmp;
    }
#line 730
    ptr = ptr->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 745
  return (ai);
}
}
#line 751 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c"
static void getnameinfo_ex(struct sockaddr  const  *sa , socklen_t len , char *str ,
                           size_t size , _Bool numeric_mode ) 
{ 
  int err ;
  char hbuf_rev[1026] ;
  char hbuf_num[1026] ;
  char sbuf_rev[33] ;
  char sbuf_num[33] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
#line 761
  if (! ((unsigned long )sa != (unsigned long )((void *)0))) {
    {
#line 761
    __assert_fail("sa != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  761U, "getnameinfo_ex");
    }
  }
#line 762
  if (! (len > 0U)) {
    {
#line 762
    __assert_fail("len > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  762U, "getnameinfo_ex");
    }
  }
#line 763
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 763
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  763U, "getnameinfo_ex");
    }
  }
#line 764
  if (! (size > 0UL)) {
    {
#line 764
    __assert_fail("size > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  764U, "getnameinfo_ex");
    }
  }
  {
#line 767
  err = getnameinfo((struct sockaddr  const  */* __restrict  */)sa, len, (char */* __restrict  */)(hbuf_num),
                    (socklen_t )sizeof(hbuf_num), (char */* __restrict  */)(sbuf_num),
                    (socklen_t )sizeof(sbuf_num), 3);
  }
#line 772
  if (err != 0) {
    {
#line 773
    tmp = gai_strerror(err);
#line 773
    fatal("getnameinfo failed: %s", tmp);
    }
  }
#line 775
  if ((int )numeric_mode == 0) {
    {
#line 777
    err = getnameinfo((struct sockaddr  const  */* __restrict  */)sa, len, (char */* __restrict  */)(hbuf_rev),
                      (socklen_t )sizeof(hbuf_rev), (char */* __restrict  */)(sbuf_rev),
                      (socklen_t )sizeof(sbuf_rev), 0);
    }
#line 779
    if (err == 0) {
      {
#line 780
      snprintf((char */* __restrict  */)str, size, (char const   */* __restrict  */)"%s (%s) %s [%s]",
               hbuf_rev, hbuf_num, sbuf_num, sbuf_rev);
      }
    } else {
      {
#line 783
      tmp___0 = gai_strerror(err);
#line 783
      tmp___1 = gettext("inverse lookup failed for %s: %s");
#line 783
      warning((char const   *)tmp___1, hbuf_num, tmp___0);
#line 786
      snprintf((char */* __restrict  */)str, size, (char const   */* __restrict  */)"%s %s",
               hbuf_num, sbuf_num);
      }
    }
  } else {
    {
#line 789
    snprintf((char */* __restrict  */)str, size, (char const   */* __restrict  */)"%s %s",
             hbuf_num, sbuf_num);
    }
  }
#line 791
  return;
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c"
static _Bool is_allowed(struct sockaddr  const  *sa , socklen_t salen , struct addrinfo  const  *hints ,
                        char const   *address , char const   *service ) 
{ 
  struct addrinfo *res ;
  struct addrinfo *ptr ;
  int err ;
  _Bool ret ;
  size_t tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
#line 800
  res = (struct addrinfo *)((void *)0);
#line 804
  if (! ((unsigned long )sa != (unsigned long )((void *)0))) {
    {
#line 804
    __assert_fail("sa != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  804U, "is_allowed");
    }
  }
#line 805
  if (! ((unsigned long )hints != (unsigned long )((void *)0))) {
    {
#line 805
    __assert_fail("hints != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                  805U, "is_allowed");
    }
  }
#line 806
  if (! ((unsigned long )address == (unsigned long )((void *)0))) {
    {
#line 806
    tmp = strlen(address);
    }
#line 806
    if (! (tmp > 0UL)) {
      {
#line 806
      __assert_fail("address == ((void *)0) || strlen(address) > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                    806U, "is_allowed");
      }
    }
  }
#line 807
  if (! ((unsigned long )service == (unsigned long )((void *)0))) {
    {
#line 807
    tmp___0 = strlen(service);
    }
#line 807
    if (! (tmp___0 > 0UL)) {
      {
#line 807
      __assert_fail("service == ((void *)0) || strlen(service) > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/afindep.c",
                    807U, "is_allowed");
      }
    }
  }
#line 810
  if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 810
    if ((unsigned long )service == (unsigned long )((void *)0)) {
#line 810
      return ((_Bool)1);
    }
  }
  {
#line 812
  err = getaddrinfo((char const   */* __restrict  */)address, (char const   */* __restrict  */)service,
                    (struct addrinfo  const  */* __restrict  */)hints, (struct addrinfo **/* __restrict  */)(& res));
  }
#line 813
  if (err != 0) {
    {
#line 824
    if (err == -7) {
#line 824
      goto case_neg_7;
    }
#line 824
    if (err == -8) {
#line 824
      goto case_neg_7;
    }
#line 824
    if (err == -6) {
#line 824
      goto case_neg_7;
    }
#line 826
    goto switch_default;
    case_neg_7: /* CIL Label */ 
    case_neg_8: /* CIL Label */ 
    case_neg_6: /* CIL Label */ 
#line 825
    return ((_Bool)0);
    switch_default: /* CIL Label */ 
    {
#line 827
    tmp___1 = gai_strerror(err);
#line 827
    fatal("getaddrinfo error: %s", tmp___1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 831
  ret = (_Bool)0;
#line 833
  ptr = res;
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 833
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 833
      goto while_break;
    }
    {
#line 837
    tmp___2 = is_address_ipv4_mapped((struct sockaddr  const  *)ptr->ai_addr);
    }
#line 837
    if (tmp___2) {
#line 838
      goto __Cont;
    }
    {
#line 841
    tmp___3 = sockaddr_compare(sa, salen, (struct sockaddr  const  *)ptr->ai_addr,
                               ptr->ai_addrlen);
    }
#line 841
    if ((int )tmp___3 == 1) {
#line 844
      ret = (_Bool)1;
#line 845
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 833
    ptr = ptr->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 849
  freeaddrinfo(res);
  }
#line 851
  return (ret);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t readv(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 50
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 184 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.h"
void cb_resize(circ_buf_t *cb , size_t size ) ;
#line 62
ssize_t cb_append(circ_buf_t *cb , uint8_t const   *buf , size_t len ) ;
#line 63
ssize_t cb_extract(circ_buf_t *cb , uint8_t *buf , size_t len ) ;
#line 65
void cb_clear(circ_buf_t *cb ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c"
static void cb_assert(circ_buf_t const   *cb ) 
{ 


  {
#line 40
  if ((unsigned long )cb == (unsigned long )((void *)0)) {
    {
#line 45
    fatal_internal("circular buffer assertion failed");
    }
  } else
#line 40
  if ((unsigned long )cb->buf == (unsigned long )((void *)0)) {
    {
#line 45
    fatal_internal("circular buffer assertion failed");
    }
  } else
#line 40
  if ((unsigned long )cb->ptr == (unsigned long )((void *)0)) {
    {
#line 45
    fatal_internal("circular buffer assertion failed");
    }
  } else
#line 40
  if (cb->buf_size < cb->data_size) {
    {
#line 45
    fatal_internal("circular buffer assertion failed");
    }
  }
#line 47
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c"
void cb_init(circ_buf_t *cb , size_t size ) 
{ 
  void *tmp ;

  {
#line 56
  if (! ((unsigned long )cb != (unsigned long )((void *)0))) {
    {
#line 56
    __assert_fail("cb != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                  56U, "cb_init");
    }
  }
#line 57
  if (! (size > 0UL)) {
    {
#line 57
    __assert_fail("size > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                  57U, "cb_init");
    }
  }
  {
#line 59
  memset((void *)cb, 0, sizeof(circ_buf_t ));
#line 61
  tmp = xmalloc(size);
#line 61
  cb->buf = (uint8_t *)tmp;
#line 62
  cb->ptr = cb->buf;
#line 63
  cb->data_size = (size_t )0;
#line 64
  cb->buf_size = size;
#line 66
  cb_assert((circ_buf_t const   *)cb);
  }
#line 67
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c"
void cb_destroy(circ_buf_t *cb ) 
{ 


  {
  {
#line 73
  cb_assert((circ_buf_t const   *)cb);
#line 75
  free((void *)cb->buf);
#line 76
  cb->buf = (uint8_t *)((void *)0);
  }
#line 77
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c"
void cb_resize(circ_buf_t *cb , size_t size ) 
{ 
  uint8_t *new_buf ;
  void *tmp ;

  {
  {
#line 85
  cb_assert((circ_buf_t const   *)cb);
  }
#line 86
  if (! (size > 0UL)) {
    {
#line 86
    __assert_fail("size > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                  86U, "cb_resize");
    }
  }
  {
#line 89
  tmp = xmalloc(size);
#line 89
  new_buf = (uint8_t *)tmp;
#line 90
  cb_extract(cb, new_buf, size);
#line 93
  free((void *)cb->buf);
#line 94
  cb->buf = new_buf;
#line 97
  cb->ptr = cb->buf;
#line 98
  cb->buf_size = size;
  }
#line 99
  if (cb->data_size > size) {
#line 100
    cb->data_size = size;
  }
#line 101
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c"
ssize_t cb_read(circ_buf_t *cb , int fd , size_t nbytes ) 
{ 
  ssize_t rr ;
  int count ;
  struct iovec iov[2] ;
  size_t len ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 112
  cb_assert((circ_buf_t const   *)cb);
  }
#line 113
  if (! (fd >= 0)) {
    {
#line 113
    __assert_fail("fd >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                  113U, "cb_read");
    }
  }
#line 116
  if (cb->buf_size - cb->data_size == 0UL) {
#line 116
    return ((ssize_t )-1);
  }
#line 119
  if (nbytes == 0UL) {
#line 120
    nbytes = cb->buf_size - cb->data_size;
  } else
#line 119
  if (nbytes > cb->buf_size - cb->data_size) {
#line 120
    nbytes = cb->buf_size - cb->data_size;
  }
#line 123
  if ((unsigned long )cb->ptr == (unsigned long )cb->buf) {
#line 125
    iov[0].iov_base = (void *)(cb->ptr + cb->data_size);
#line 126
    iov[0].iov_len = nbytes;
#line 127
    count = 1;
  } else
#line 128
  if ((unsigned long )(cb->ptr + cb->data_size) >= (unsigned long )(cb->buf + cb->buf_size)) {
#line 130
    iov[0].iov_base = (void *)((cb->ptr + cb->data_size) - cb->buf_size);
#line 131
    iov[0].iov_len = nbytes;
#line 132
    count = 1;
  } else {
#line 135
    iov[0].iov_base = (void *)(cb->ptr + cb->data_size);
#line 136
    len = (cb->buf_size - cb->data_size) - (size_t )(cb->ptr - cb->buf);
#line 138
    if (len >= nbytes) {
#line 140
      iov[0].iov_len = nbytes;
#line 141
      count = 1;
    } else {
#line 144
      iov[0].iov_len = len;
#line 145
      iov[1].iov_base = (void *)cb->buf;
#line 146
      iov[1].iov_len = nbytes - len;
#line 147
      count = 2;
    }
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 153
    tmp = __errno_location();
#line 153
    *tmp = 0;
#line 154
    rr = readv(fd, (struct iovec  const  *)(iov), count);
#line 152
    tmp___0 = __errno_location();
    }
#line 152
    if (! (*tmp___0 == 4)) {
#line 152
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if (rr > 0L) {
    {
#line 161
    cb->data_size += (size_t )rr;
#line 164
    cb_assert((circ_buf_t const   *)cb);
    }
  }
#line 167
  return (rr);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c"
ssize_t cb_recv(circ_buf_t *cb , int fd , size_t nbytes , struct sockaddr *from ,
                size_t *fromlen ) 
{ 
  ssize_t rr ;
  int count ;
  struct iovec iov[2] ;
  struct msghdr msg ;
  size_t len ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 181
  cb_assert((circ_buf_t const   *)cb);
  }
#line 182
  if (! (fd >= 0)) {
    {
#line 182
    __assert_fail("fd >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                  182U, "cb_recv");
    }
  }
#line 185
  if (cb->buf_size - cb->data_size == 0UL) {
#line 185
    return ((ssize_t )-1);
  }
#line 188
  if (nbytes == 0UL) {
#line 189
    nbytes = cb->buf_size - cb->data_size;
  } else
#line 188
  if (nbytes > cb->buf_size - cb->data_size) {
#line 189
    nbytes = cb->buf_size - cb->data_size;
  }
#line 192
  if ((unsigned long )cb->ptr == (unsigned long )cb->buf) {
#line 194
    iov[0].iov_base = (void *)(cb->ptr + cb->data_size);
#line 195
    iov[0].iov_len = nbytes;
#line 196
    count = 1;
  } else
#line 197
  if ((unsigned long )(cb->ptr + cb->data_size) >= (unsigned long )(cb->buf + cb->buf_size)) {
#line 199
    iov[0].iov_base = (void *)((cb->ptr + cb->data_size) - cb->buf_size);
#line 200
    iov[0].iov_len = nbytes;
#line 201
    count = 1;
  } else {
#line 204
    iov[0].iov_base = (void *)(cb->ptr + cb->data_size);
#line 205
    len = (cb->buf_size - cb->data_size) - (size_t )(cb->ptr - cb->buf);
#line 207
    if (len >= nbytes) {
#line 209
      iov[0].iov_len = nbytes;
#line 210
      count = 1;
    } else {
#line 213
      iov[0].iov_len = len;
#line 214
      iov[1].iov_base = (void *)cb->buf;
#line 215
      iov[1].iov_len = nbytes - len;
#line 216
      count = 2;
    }
  }
  {
#line 221
  memset((void *)(& msg), 0, sizeof(msg));
#line 222
  msg.msg_name = (void *)from;
  }
#line 223
  if ((unsigned long )from != (unsigned long )((void *)0)) {
#line 223
    if ((unsigned long )fromlen != (unsigned long )((size_t *)0)) {
#line 223
      msg.msg_namelen = (socklen_t )*fromlen;
    } else {
#line 223
      msg.msg_namelen = (socklen_t )0;
    }
  } else {
#line 223
    msg.msg_namelen = (socklen_t )0;
  }
#line 224
  msg.msg_iov = iov;
#line 225
  msg.msg_iovlen = (size_t )count;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 229
    tmp = __errno_location();
#line 229
    *tmp = 0;
#line 230
    rr = recvmsg(fd, & msg, 0);
    }
#line 233
    if ((unsigned long )from != (unsigned long )((void *)0)) {
#line 233
      if ((unsigned long )fromlen != (unsigned long )((size_t *)0)) {
#line 234
        *fromlen = (size_t )msg.msg_namelen;
      }
    }
    {
#line 228
    tmp___0 = __errno_location();
    }
#line 228
    if (! (*tmp___0 == 4)) {
#line 228
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  if (rr > 0L) {
    {
#line 241
    cb->data_size += (size_t )rr;
#line 244
    cb_assert((circ_buf_t const   *)cb);
    }
  }
#line 247
  return (rr);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c"
ssize_t cb_append(circ_buf_t *cb , uint8_t const   *buf , size_t len ) 
{ 
  ssize_t rr ;
  int i ;
  int count ;
  struct iovec iov[2] ;
  uint8_t const   *tmp ;
  size_t chunk_size ;

  {
  {
#line 259
  cb_assert((circ_buf_t const   *)cb);
  }
#line 260
  if (! ((unsigned long )buf != (unsigned long )((void *)0))) {
    {
#line 260
    __assert_fail("buf != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                  260U, "cb_append");
    }
  }
#line 263
  if (cb->buf_size - cb->data_size == 0UL) {
#line 263
    return ((ssize_t )-1);
  }
#line 266
  if (len == 0UL) {
#line 266
    return ((ssize_t )0);
  }
#line 269
  tmp = buf;
#line 270
  rr = (ssize_t )0;
#line 273
  if ((unsigned long )cb->ptr == (unsigned long )cb->buf) {
#line 275
    iov[0].iov_base = (void *)(cb->ptr + cb->data_size);
#line 276
    iov[0].iov_len = cb->buf_size - cb->data_size;
#line 277
    count = 1;
  } else
#line 278
  if ((unsigned long )(cb->ptr + cb->data_size) >= (unsigned long )(cb->buf + cb->buf_size)) {
#line 280
    iov[0].iov_base = (void *)((cb->ptr + cb->data_size) - cb->buf_size);
#line 281
    iov[0].iov_len = cb->buf_size - cb->data_size;
#line 282
    count = 1;
  } else {
#line 285
    iov[0].iov_base = (void *)(cb->ptr + cb->data_size);
#line 286
    iov[0].iov_len = (cb->buf_size - cb->data_size) - (size_t )(cb->ptr - cb->buf);
#line 288
    iov[1].iov_base = (void *)cb->buf;
#line 289
    iov[1].iov_len = (size_t )(cb->ptr - cb->buf);
#line 290
    count = 2;
  }
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < count)) {
#line 294
      goto while_break;
    }
#line 297
    if (iov[i].iov_len < len) {
#line 297
      chunk_size = iov[i].iov_len;
    } else {
#line 297
      chunk_size = len;
    }
#line 298
    if (! (chunk_size > 0UL)) {
      {
#line 298
      __assert_fail("chunk_size > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                    298U, "cb_append");
      }
    }
    {
#line 300
    memcpy((void */* __restrict  */)iov[i].iov_base, (void const   */* __restrict  */)((void const   *)tmp),
           chunk_size);
#line 302
    tmp += chunk_size;
#line 303
    len -= chunk_size;
#line 304
    cb->data_size += chunk_size;
#line 305
    rr = (ssize_t )((size_t )rr + chunk_size);
#line 308
    cb_assert((circ_buf_t const   *)cb);
    }
#line 310
    if (len == 0UL) {
#line 310
      goto while_break;
    }
#line 294
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  return (rr);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c"
ssize_t cb_write(circ_buf_t *cb , int fd , size_t nbytes ) 
{ 
  ssize_t rr ;
  int count ;
  struct iovec iov[2] ;
  size_t len ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 325
  cb_assert((circ_buf_t const   *)cb);
  }
#line 326
  if (! (fd >= 0)) {
    {
#line 326
    __assert_fail("fd >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                  326U, "cb_write");
    }
  }
#line 329
  if (cb->data_size == 0UL) {
#line 329
    return ((ssize_t )0);
  }
#line 332
  if (nbytes == 0UL) {
#line 333
    nbytes = cb->data_size;
  } else
#line 332
  if (nbytes > cb->data_size) {
#line 333
    nbytes = cb->data_size;
  }
#line 336
  if ((unsigned long )(cb->ptr + cb->data_size) > (unsigned long )(cb->buf + cb->buf_size)) {
#line 338
    iov[0].iov_base = (void *)cb->ptr;
#line 339
    len = cb->buf_size - (size_t )(cb->ptr - cb->buf);
#line 341
    if (len >= nbytes) {
#line 343
      iov[0].iov_len = nbytes;
#line 344
      count = 1;
    } else {
#line 346
      iov[0].iov_len = len;
#line 347
      iov[1].iov_base = (void *)cb->buf;
#line 348
      iov[1].iov_len = nbytes - len;
#line 349
      count = 2;
    }
  } else {
#line 353
    iov[0].iov_base = (void *)cb->ptr;
#line 354
    iov[0].iov_len = nbytes;
#line 355
    count = 1;
  }
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 360
    tmp = __errno_location();
#line 360
    *tmp = 0;
#line 361
    rr = writev(fd, (struct iovec  const  *)(iov), count);
#line 359
    tmp___0 = __errno_location();
    }
#line 359
    if (! (*tmp___0 == 4)) {
#line 359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  if (rr > 0L) {
#line 368
    if (! ((size_t )rr <= cb->data_size)) {
      {
#line 368
      __assert_fail("(size_t)rr <= cb->data_size", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                    368U, "cb_write");
      }
    }
#line 369
    cb->data_size -= (size_t )rr;
#line 372
    cb->ptr += rr;
#line 373
    if ((unsigned long )cb->ptr >= (unsigned long )(cb->buf + cb->buf_size)) {
#line 374
      cb->ptr -= cb->buf_size;
    }
    {
#line 377
    cb_assert((circ_buf_t const   *)cb);
    }
  }
#line 380
  return (rr);
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c"
ssize_t cb_write_crlf(circ_buf_t *cb , int fd , size_t nbytes ) 
{ 
  circ_buf_t cb2 ;
  ssize_t cb2ptr ;
  ssize_t rr ;
  ssize_t tmp ;

  {
  {
#line 391
  cb_init(& cb2, cb->data_size * 2UL);
#line 393
  cb2ptr = (ssize_t )0;
  }
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! ((size_t )cb2ptr < cb->data_size)) {
#line 393
      goto while_break;
    }
#line 394
    if ((int )*(cb->buf + cb2ptr) == 10) {
      {
#line 395
      cb_append(& cb2, (uint8_t const   *)"\r\n", (size_t )2);
      }
    } else {
      {
#line 397
      cb_append(& cb2, (uint8_t const   *)(cb->buf + cb2ptr), (size_t )1);
      }
    }
#line 393
    cb2ptr ++;
#line 393
    rr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 400
  cb->data_size -= (size_t )rr;
#line 402
  tmp = cb_write(& cb2, fd, nbytes);
  }
#line 402
  return (tmp);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c"
ssize_t cb_send(circ_buf_t *cb , int fd , size_t nbytes , struct sockaddr *dest ,
                size_t destlen ) 
{ 
  ssize_t rr ;
  int count ;
  struct iovec iov[2] ;
  struct msghdr msg ;
  size_t len ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 416
  cb_assert((circ_buf_t const   *)cb);
  }
#line 417
  if (! (fd >= 0)) {
    {
#line 417
    __assert_fail("fd >= 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                  417U, "cb_send");
    }
  }
#line 420
  if (cb->data_size == 0UL) {
#line 420
    return ((ssize_t )0);
  }
#line 423
  if (nbytes == 0UL) {
#line 424
    nbytes = cb->data_size;
  } else
#line 423
  if (nbytes > cb->data_size) {
#line 424
    nbytes = cb->data_size;
  }
#line 427
  if ((unsigned long )(cb->ptr + cb->data_size) > (unsigned long )(cb->buf + cb->buf_size)) {
#line 429
    iov[0].iov_base = (void *)cb->ptr;
#line 430
    len = cb->buf_size - (size_t )(cb->ptr - cb->buf);
#line 432
    if (len >= nbytes) {
#line 434
      iov[0].iov_len = nbytes;
#line 435
      count = 1;
    } else {
#line 437
      iov[0].iov_len = len;
#line 438
      iov[1].iov_base = (void *)cb->buf;
#line 439
      iov[1].iov_len = nbytes - len;
#line 440
      count = 2;
    }
  } else {
#line 444
    iov[0].iov_base = (void *)cb->ptr;
#line 445
    iov[0].iov_len = nbytes;
#line 446
    count = 1;
  }
  {
#line 450
  memset((void *)(& msg), 0, sizeof(msg));
#line 451
  msg.msg_name = (void *)dest;
#line 452
  msg.msg_namelen = (socklen_t )destlen;
#line 453
  msg.msg_iov = iov;
#line 454
  msg.msg_iovlen = (size_t )count;
  }
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 458
    tmp = __errno_location();
#line 458
    *tmp = 0;
#line 459
    rr = sendmsg(fd, (struct msghdr  const  *)(& msg), 0);
#line 457
    tmp___0 = __errno_location();
    }
#line 457
    if (! (*tmp___0 == 4)) {
#line 457
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  if (rr > 0L) {
#line 466
    if (! ((size_t )rr <= cb->data_size)) {
      {
#line 466
      __assert_fail("(size_t)rr <= cb->data_size", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                    466U, "cb_send");
      }
    }
#line 467
    cb->data_size -= (size_t )rr;
#line 470
    cb->ptr += rr;
#line 471
    if ((unsigned long )cb->ptr >= (unsigned long )(cb->buf + cb->buf_size)) {
#line 472
      cb->ptr -= cb->buf_size;
    }
    {
#line 475
    cb_assert((circ_buf_t const   *)cb);
    }
  }
#line 478
  return (rr);
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c"
ssize_t cb_extract(circ_buf_t *cb , uint8_t *buf , size_t len ) 
{ 
  ssize_t rr ;
  int i ;
  int count ;
  struct iovec iov[2] ;
  size_t chunk_size ;

  {
  {
#line 489
  cb_assert((circ_buf_t const   *)cb);
  }
#line 490
  if (! ((unsigned long )buf != (unsigned long )((void *)0))) {
    {
#line 490
    __assert_fail("buf != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                  490U, "cb_extract");
    }
  }
#line 493
  if (cb->data_size == 0UL) {
#line 493
    return ((ssize_t )0);
  }
#line 496
  if (len == 0UL) {
#line 496
    return ((ssize_t )0);
  }
#line 499
  rr = (ssize_t )0;
#line 502
  if ((unsigned long )(cb->ptr + cb->data_size) > (unsigned long )(cb->buf + cb->buf_size)) {
#line 503
    iov[0].iov_base = (void *)cb->ptr;
#line 504
    iov[0].iov_len = cb->buf_size - (size_t )(cb->ptr - cb->buf);
#line 505
    iov[1].iov_base = (void *)cb->buf;
#line 506
    iov[1].iov_len = cb->data_size - iov[0].iov_len;
#line 507
    count = 2;
  } else {
#line 509
    iov[0].iov_base = (void *)cb->ptr;
#line 510
    iov[0].iov_len = cb->data_size;
#line 511
    count = 1;
  }
#line 515
  i = 0;
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    if (! (i < count)) {
#line 515
      goto while_break;
    }
#line 518
    if (iov[i].iov_len < len) {
#line 518
      chunk_size = iov[i].iov_len;
    } else {
#line 518
      chunk_size = len;
    }
#line 519
    if (! (chunk_size > 0UL)) {
      {
#line 519
      __assert_fail("chunk_size > 0", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                    519U, "cb_extract");
      }
    }
    {
#line 521
    memcpy((void */* __restrict  */)((void *)buf), (void const   */* __restrict  */)((void const   *)iov[i].iov_base),
           chunk_size);
#line 523
    buf += chunk_size;
#line 524
    len -= chunk_size;
#line 525
    rr = (ssize_t )((size_t )rr + chunk_size);
#line 528
    cb_assert((circ_buf_t const   *)cb);
    }
#line 530
    if (len == 0UL) {
#line 530
      goto while_break;
    }
#line 515
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  if (rr > 0L) {
#line 536
    if (! ((size_t )rr <= cb->data_size)) {
      {
#line 536
      __assert_fail("(size_t)rr <= cb->data_size", "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c",
                    536U, "cb_extract");
      }
    }
#line 537
    cb->data_size -= (size_t )rr;
#line 540
    cb->ptr += rr;
#line 541
    if ((unsigned long )cb->ptr >= (unsigned long )(cb->buf + cb->buf_size)) {
#line 542
      cb->ptr -= cb->buf_size;
    }
    {
#line 545
    cb_assert((circ_buf_t const   *)cb);
    }
  }
#line 548
  return (rr);
}
}
#line 553 "/home/june/repo/benchmarks/collector/temp/nc6-1.0/src/circ_buf.c"
void cb_clear(circ_buf_t *cb ) 
{ 


  {
  {
#line 555
  cb_assert((circ_buf_t const   *)cb);
#line 557
  cb->ptr = cb->buf;
#line 558
  cb->data_size = (size_t )0;
  }
#line 559
  return;
}
}
